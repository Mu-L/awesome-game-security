Project Path: arc_block_stoic_fxe799i2

Source Tree:

```txt
arc_block_stoic_fxe799i2
├── LICENSE
├── README.md
├── RELEASING.md
├── assets
│   └── logo.svg
├── bnr.sh
├── build.gradle.kts
├── build.sh
├── buildSrc
│   ├── build.gradle.kts
│   ├── settings.gradle.kts
│   └── src
│       └── main
│           └── kotlin
│               └── VersionCodeFromVersionName.kt
├── check-warnings.sh
├── demo-app
│   ├── with-sdk
│   │   ├── build.gradle.kts
│   │   ├── proguard-rules.pro
│   │   └── src
│   │       └── main
│   │           ├── AndroidManifest.xml
│   │           ├── assets
│   │           │   └── stoic
│   │           │       └── authorized_keys
│   │           ├── java
│   │           │   └── com
│   │           │       └── squareup
│   │           │           └── stoic
│   │           │               └── demoapp
│   │           │                   └── withsdk
│   │           │                       ├── ExampleActivity.kt
│   │           │                       └── plugins
│   │           │                           ├── DemoEmbeddedPlugin.kt
│   │           │                           └── DemoStoicConfig.kt
│   │           └── res
│   │               ├── drawable
│   │               │   ├── ic_launcher_background.xml
│   │               │   └── ic_launcher_foreground.xml
│   │               ├── layout
│   │               │   └── activity_example.xml
│   │               ├── mipmap-anydpi
│   │               │   ├── ic_launcher.xml
│   │               │   └── ic_launcher_round.xml
│   │               ├── mipmap-hdpi
│   │               │   ├── ic_launcher.webp
│   │               │   └── ic_launcher_round.webp
│   │               ├── mipmap-mdpi
│   │               │   ├── ic_launcher.webp
│   │               │   └── ic_launcher_round.webp
│   │               ├── mipmap-xhdpi
│   │               │   ├── ic_launcher.webp
│   │               │   └── ic_launcher_round.webp
│   │               ├── mipmap-xxhdpi
│   │               │   ├── ic_launcher.webp
│   │               │   └── ic_launcher_round.webp
│   │               ├── mipmap-xxxhdpi
│   │               │   ├── ic_launcher.webp
│   │               │   └── ic_launcher_round.webp
│   │               ├── values
│   │               │   ├── attrs.xml
│   │               │   ├── colors.xml
│   │               │   ├── strings.xml
│   │               │   ├── styles.xml
│   │               │   └── themes.xml
│   │               └── values-night
│   │                   └── themes.xml
│   └── without-sdk
│       ├── build.gradle.kts
│       ├── proguard-rules.pro
│       └── src
│           └── main
│               ├── AndroidManifest.xml
│               ├── java
│               │   └── com
│               │       └── squareup
│               │           └── stoic
│               │               └── demoapp
│               │                   └── withoutsdk
│               │                       └── ExampleActivity.kt
│               └── res
│                   ├── drawable
│                   │   ├── ic_launcher_background.xml
│                   │   └── ic_launcher_foreground.xml
│                   ├── layout
│                   │   └── activity_example.xml
│                   ├── mipmap-anydpi
│                   │   ├── ic_launcher.xml
│                   │   └── ic_launcher_round.xml
│                   ├── mipmap-hdpi
│                   │   ├── ic_launcher.webp
│                   │   └── ic_launcher_round.webp
│                   ├── mipmap-mdpi
│                   │   ├── ic_launcher.webp
│                   │   └── ic_launcher_round.webp
│                   ├── mipmap-xhdpi
│                   │   ├── ic_launcher.webp
│                   │   └── ic_launcher_round.webp
│                   ├── mipmap-xxhdpi
│                   │   ├── ic_launcher.webp
│                   │   └── ic_launcher_round.webp
│                   ├── mipmap-xxxhdpi
│                   │   ├── ic_launcher.webp
│                   │   └── ic_launcher_round.webp
│                   ├── values
│                   │   ├── attrs.xml
│                   │   ├── colors.xml
│                   │   ├── strings.xml
│                   │   ├── styles.xml
│                   │   └── themes.xml
│                   └── values-night
│                       └── themes.xml
├── demo-plugin
│   ├── appexitinfo
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           └── kotlin
│   │               └── Main.kt
│   ├── breakpoint
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           └── kotlin
│   │               └── Main.kt
│   ├── crasher
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           └── kotlin
│   │               └── Main.kt
│   └── helloworld
│       ├── build.gradle.kts
│       └── src
│           └── main
│               └── kotlin
│                   └── Main.kt
├── docs
│   ├── APPEXITINFO.md
│   ├── ARCHITECTURE.md
│   ├── DEBUG.md
│   ├── DEVELOP.md
│   ├── JVMTI.md
│   └── USR_CONFIG.md
├── gradle
│   ├── libs.versions.toml
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── host
│   └── main
│       ├── build.gradle.kts
│       └── src
│           └── main
│               └── kotlin
│                   └── com
│                       └── squareup
│                           └── stoic
│                               └── host
│                                   ├── AttachVia.kt
│                                   ├── FailedExecException.kt
│                                   ├── FileWithSha.kt
│                                   ├── HostUtils.kt
│                                   ├── MainParsedArgs.kt
│                                   ├── MismatchedVersionException.kt
│                                   ├── PithyException.kt
│                                   ├── PluginHost.kt
│                                   ├── PluginParsedArgs.kt
│                                   ├── Sha.kt
│                                   └── main
│                                       ├── ApkCache.kt
│                                       ├── HostMain.kt
│                                       └── SELinuxViolationDetector.kt
├── integration-tests
│   ├── README.md
│   └── build.gradle.kts
├── internal
│   ├── test
│   │   └── protocol-version-client
│   │       ├── build.gradle.kts
│   │       └── src
│   │           └── main
│   │               └── kotlin
│   │                   └── ProtocolVersionClient.kt
│   └── tool
│       ├── jar-to-apk-preserve-manifest
│       │   ├── build.gradle.kts
│       │   └── src
│       │       └── main
│       │           └── kotlin
│       │               └── com
│       │                   └── squareup
│       │                       └── stoic
│       │                           └── apk
│       │                               └── Main.kt
│       └── release
│           ├── build.gradle.kts
│           └── src
│               └── main
│                   └── java
│                       └── com
│                           └── squareup
│                               └── stoic
│                                   └── release
│                                       └── Main.kt
├── native
│   ├── Makefile
│   ├── Makefile.arch
│   ├── Makefile.inc
│   ├── build.gradle.kts
│   ├── jvmti.h
│   ├── nativehelper_utils.h
│   ├── scoped_local_ref.h
│   ├── scoped_utf_chars.h
│   ├── stoic.cc
│   └── stoic_logging.h
├── prebuilt
│   ├── README.md
│   ├── STOIC_VERSION
│   ├── bin
│   │   └── jvm
│   │       └── stoic
│   ├── script
│   │   ├── adb-pick
│   │   └── android_serial.sh
│   ├── sync
│   │   └── bin
│   │       ├── stoic-attach
│   │       └── su-run-as
│   └── template
│       ├── plugin-template
│       │   ├── build.gradle.kts
│       │   ├── gradle
│       │   │   ├── libs.versions.toml
│       │   │   └── wrapper
│       │   │       ├── gradle-wrapper.jar
│       │   │       └── gradle-wrapper.properties
│       │   ├── gradlew
│       │   ├── gradlew.bat
│       │   ├── settings.gradle.kts
│       │   ├── src
│       │   │   └── main
│       │   │       ├── AndroidManifest.xml
│       │   │       └── kotlin
│       │   │           └── Main.kt
│       │   └── stoic-build-plugin
│       └── usr_config
│           └── README.md
├── protocol
│   ├── build.gradle.kts
│   └── src
│       └── main
│           └── kotlin
│               └── com
│                   └── squareup
│                       └── stoic
│                           ├── bridge
│                           │   ├── StoicProperties.kt
│                           │   └── VersionCodeFromVersionName.kt
│                           └── common
│                               ├── Stoic.kt
│                               └── StoicMessages.kt
├── release.sh
├── settings.gradle.kts
├── setup.sh
├── target
│   ├── app-sdk
│   │   ├── build.gradle.kts
│   │   ├── consumer-rules.pro
│   │   ├── proguard-rules.pro
│   │   └── src
│   │       └── main
│   │           ├── AndroidManifest.xml
│   │           └── kotlin
│   │               └── com
│   │                   └── squareup
│   │                       └── stoic
│   │                           ├── android
│   │                           │   └── sdk
│   │                           │       └── StoicBroadcastReceiver.kt
│   │                           └── target
│   │                               └── runtime
│   │                                   ├── MainThreadExecutor.kt
│   │                                   ├── MessageWriterOutputStream.kt
│   │                                   ├── Mux.kt
│   │                                   ├── StoicConfigLoader.kt
│   │                                   ├── StoicContextProvider.kt
│   │                                   ├── StoicPaths.kt
│   │                                   ├── StoicPluginServer.kt
│   │                                   ├── StoicUnixDomainSocketServer.kt
│   │                                   └── TargetUtils.kt
│   ├── jvmti-attach
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           ├── AndroidManifest.xml
│   │           └── kotlin
│   │               └── com
│   │                   └── squareup
│   │                       └── stoic
│   │                           └── target
│   │                               └── runtime
│   │                                   └── AndroidServerJar.kt
│   └── plugin-sdk
│       ├── build.gradle.kts
│       └── src
│           └── main
│               └── kotlin
│                   └── com
│                       └── squareup
│                           └── stoic
│                               ├── ExitCodeException.kt
│                               ├── Stoic.kt
│                               ├── helpers
│                               │   └── Helpers.kt
│                               ├── jvmti
│                               │   ├── BreakpointRequest.kt
│                               │   ├── BreakpointResult.kt
│                               │   ├── Event.kt
│                               │   ├── EventRequest.kt
│                               │   ├── EventRequestManager.kt
│                               │   ├── Jvmti.kt
│                               │   ├── JvmtiClass.kt
│                               │   ├── JvmtiException.kt
│                               │   ├── JvmtiField.kt
│                               │   ├── JvmtiMethod.kt
│                               │   ├── LocalVariable.kt
│                               │   ├── Locatable.kt
│                               │   ├── Location.kt
│                               │   ├── MethodEntryRequest.kt
│                               │   ├── MethodExitRequest.kt
│                               │   ├── StackFrame.kt
│                               │   ├── VirtualMachine.kt
│                               │   ├── magic
│                               │   │   ├── MagicFields.kt
│                               │   │   ├── MagicMethod.kt
│                               │   │   └── MagicMethods.kt
│                               │   └── magics
│                               │       └── Magics.kt
│                               ├── plugin
│                               │   ├── StoicConfig.kt
│                               │   └── StoicPlugin.kt
│                               ├── threadlocals
│                               │   └── ThreadLocals.kt
│                               └── trace
│                                   └── Trace.kt
├── test
│   ├── TestHostShebang.kt
│   ├── TestPkgShebang.kt
│   ├── TestSrcPathRefShebang.kt
│   ├── TestXplatShebang.kt
│   ├── clean-build-and-regression-check.sh
│   ├── emulator-tests.sh
│   ├── perf-fast-path.sh
│   ├── perf-host-shebang.sh
│   ├── perf-slow-path.sh
│   ├── regression-check.sh
│   ├── run-all-tests-on-connected-device.sh
│   ├── setup-stoic-path.sh
│   ├── shellcheck.sh
│   ├── smoke-test.sh
│   ├── test-demo-app-with-sdk.sh
│   ├── test-demo-app-without-sdk.sh
│   ├── test-env-flag.sh
│   ├── test-env-vars.sh
│   ├── test-plugin-new.sh
│   ├── test-protocol-version-handshake.sh
│   ├── test-shebang.sh
│   ├── test-stress.sh
│   ├── test-without-config.sh
│   ├── testsuite.sh
│   ├── todo-tests.txt
│   ├── verify-kotlin-api-version.sh
│   └── with-emulator.sh
└── test-plugin
    ├── build.gradle.kts
    └── src
        └── main
            └── kotlin
                └── Main.kt

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# Stoic <img src="./assets/logo.svg" alt="App logo" width="25">

> *"Σκόπει εἰς σεαυτόν. Ἐντὸς σοῦ πηγὴ ἀγαθοῦ ἐστιν, ἡ ἀεὶ ἐκβρύειν ἑτοίμη, ἐὰν ἀεὶ σκάπτῃς."*
>
> "Look within. Within is the fountain of good, and it will ever bubble up, if you will ever dig."

*- Marcus Aurelius (121-180 AD), Roman Emperor and Stoic philosopher*

> *"Ignis aurum probat, miseria fortes."*
>
> "Fire tests gold and adversity tests the brave."

*- Seneca the Younger (c. 4 BC - AD 65), Roman statesman and Stoic philosopher*

Run code inside Android processes from your laptop. No APK modifications needed for debuggable apps.

Stoic opens a communication channel into your app. Write plugins that hook methods, inspect heap objects, or call internal APIs—all from the command line.

First attach takes 2-3 seconds. After that, under a second.

## Quick Start

```bash
brew install block/tap/stoic
stoic helloworld
```

This runs against a demo app. For your app: `stoic --pkg com.yourapp helloworld`

Works on API 26+ (Android 8.0+) with debuggable apps. For non-debuggable apps,
add the
[app-sdk](https://mvnrepository.com/artifact/com.squareup.stoic/app-sdk).

## Bundled Plugins

- [appexitinfo](docs/APPEXITINFO.md) - query ApplicationExitInfo API
- breakpoint - hook method calls, print args/returns/stacktraces
- crasher - test crash handling

## Writing Plugins

Plugins are Java/Kotlin main functions. Use `com.squareup.stoic.jvmti` for debugger features:

```kotlin
// Hook a method
InputEventReceiver.dispatchInputEvent.forEachInvocation {
  println("dispatchInputEvent called")
}

// Scan the heap
for (bitmap in jvmti.instances(Bitmap::class.java)) {
  println("$bitmap: ${bitmap.allocationByteCount} bytes")
}
```

Create your own plugin:
```bash
stoic plugin --new scratch
stoic scratch
```

Alternatively, use the
[plugin-sdk](https://mvnrepository.com/artifact/com.squareup.stoic/plugin-sdk)
to register plugins inside your app.

## How It Works

- Debuggable apps: Stoic attaches a JVMTI agent to your process, which starts a server
- Non-debuggable apps: The app-sdk registers a BroadcastReceiver, which starts a server
- Server connection happens via unix domain sockets - no internet permission needed
- Stoic sends plugin APKs to the server, which then loads them via DexClassLoader

See [ARCHITECTURE.md](docs/ARCHITECTURE.md).

```

`RELEASING.md`:

```md
# Releasing Stoic

This document describes how to create a new release of Stoic.

## Prerequisites

Before starting a release, ensure you have:

1. **An ARM Mac**
   - The release script verifies that stoic works on Darwin arm64

2. **A physical Android device attached** (not an emulator)
   - The release script runs integration tests on the built artifacts
   - This ensures Stoic works correctly on macOS (not just in CI on Linux)
   - We could run CI on macOS, but that would complicate emulator usage and make tests slower
   - Check device is connected: `adb devices`

3. **Clean git working directory**
   - All changes must be committed
   - Must be on the `main` branch

4. **GitHub CLI authenticated**
   - Install: `brew install gh`
   - Login: `gh auth login`

## Release Process

The release script automates the entire release process. Run:

```bash
./release.sh
```

### What the Script Does

The script will:

1. **Validate and confirm** the release version
   - Shows current version (e.g., `0.6.1-SNAPSHOT`)
   - Shows release version (e.g., `0.6.1`)
   - Shows post-release version (e.g., `0.6.2-SNAPSHOT`)
   - Asks for confirmation before proceeding

2. **Run shellcheck** on all shell scripts

3. **Create release branch** (`release/X.Y.Z`)
   - Updates `prebuilt/STOIC_VERSION` to remove `-SNAPSHOT`
   - Commits and pushes the branch

4. **Wait for GitHub Actions build**
   - Monitors the `build` workflow for the release branch
   - Downloads the built artifacts when complete

5. **Extract and verify artifacts**
   - Extracts the release tarball
   - Adds the built binary to PATH

6. **Run integration tests** on your attached device
   - Verifies the correct stoic binary is being used (`which stoic`)
   - Verifies the version matches the release (`stoic --version`)
   - Runs all tests via `test/run-all-tests-on-connected-device.sh`
   - These tests verify the release works on macOS with real hardware

7. **Tag the release** (`vX.Y.Z`)
   - Creates an annotated git tag
   - Pushes the tag to GitHub

8. **Wait for GitHub Actions release workflow**
   - Publishes to Maven Central (plugin-sdk and app-sdk)
   - Creates GitHub release with tarball
   - Prints verification URLs:
     - GitHub Release: `https://github.com/block/stoic/releases/tag/vX.Y.Z`
     - Maven Central (plugin-sdk): `https://central.sonatype.com/artifact/com.squareup.stoic/plugin-sdk/X.Y.Z`
     - Maven Central (app-sdk): `https://central.sonatype.com/artifact/com.squareup.stoic/app-sdk/X.Y.Z`
   - Note: Maven Central artifacts may take up to 30 minutes to become available for download

9. **Merge release branch to main**
   - Fast-forward merge only

10. **Bump version for next development cycle**
    - Updates `prebuilt/STOIC_VERSION` to `X.Y.Z+1-SNAPSHOT`
    - Commits and pushes to main

11. **Update Homebrew formula**
    - Triggers `update-stoic.yaml` workflow in `block/homebrew-tap`
    - Waits for the workflow to complete
    - Prints verification URL: `https://github.com/block/homebrew-tap/blob/main/Formula/stoic.rb`

12. **Print success message** with all release artifact URLs

## Resuming Failed Releases

The release script supports automatic resumption if something fails partway through. The script tracks progress in `releases/X.Y.Z/.prepare_state`.

### How Resumption Works

Each major step in the release process is tracked:
- `SHELLCHECK` - Shellcheck validation
- `CREATE_BRANCH` - Release branch creation
- `WAIT_BUILD` - GitHub Actions build
- `EXTRACT` - Artifact extraction
- `VERIFY_TESTS` - Integration tests
- `TAG_RELEASE` - Git tag creation
- `WAIT_RELEASE` - GitHub Actions release
- `MERGE_MAIN` - Merge to main
- `BUMP_SNAPSHOT` - Version bump
- `UPDATE_HOMEBREW` - Homebrew formula update

If the script fails or is interrupted:
1. Fix the underlying issue (e.g., failing test, network error)
2. Run `./release.sh` again
3. The script will skip already-completed steps
4. It will resume from the first incomplete step

### To Restart from Scratch

If you need to completely restart a release:

```bash
# Delete the artifacts directory
rm -r releases/X.Y.Z

# Delete the release branch (if created)
git checkout main
git branch -D release/X.Y.Z
git push origin --delete release/X.Y.Z

# Delete the tag (if created)
git tag -d vX.Y.Z
git push origin --delete vX.Y.Z

# Run the release script again
./release.sh
```

## Version Numbering

Stoic uses semantic versioning (MAJOR.MINOR.PATCH):

- Development versions end with `-SNAPSHOT` (e.g., `0.6.1-SNAPSHOT`)
- Release versions have no suffix (e.g., `0.6.1`)
- The script automatically:
  - Strips `-SNAPSHOT` for the release
  - Increments the patch version and adds `-SNAPSHOT` for the next development cycle

## Troubleshooting

### Build workflow doesn't start
- GitHub Actions may be delayed. Wait a few minutes and the script will find it.

### Release workflow fails
- Check the workflow logs: `gh run view --repo block/stoic`
- Common issues:
  - Maven Central credentials not configured (repository secrets)
  - GPG signing key issues (repository secrets)

### Integration tests fail
- Make sure a device is attached: `adb devices`
- Check device is unlocked and screen is on
- Verify `ANDROID_HOME` is set correctly
- Check which stoic binary is being used: `which stoic` (should be from `releases/X.Y.Z/verify/bin/darwin-arm64/stoic`)
- Verify the version: `stoic --version` (should show the release version)
- Run tests manually: `test/run-all-tests-on-connected-device.sh`

### Homebrew update times out
- Check the workflow manually: `https://github.com/block/homebrew-tap/actions`
- The workflow may need manual intervention if there are conflicts
- You can manually trigger it: `gh workflow run update-stoic.yaml --repo block/homebrew-tap --field tag=vX.Y.Z`

## Release Artifacts

Each release produces:

1. **GitHub Release** (`https://github.com/block/stoic/releases/tag/vX.Y.Z`)
   - `stoic-release.tar.gz` - Complete release bundle with:
     - Native binaries (darwin-arm64)
     - JAR files
     - SDK artifacts
     - Demo plugins and apps
     - Prebuilt files

2. **Maven Central Artifacts**
   - `com.squareup.stoic:plugin-sdk:X.Y.Z` - Plugin development SDK (JAR)
   - `com.squareup.stoic:app-sdk:X.Y.Z` - App integration SDK (AAR)
   - Both include sources and javadoc

3. **Homebrew Formula**
   - Updated in `block/homebrew-tap` repository
   - Users can install with: `brew install block/tap/stoic`

## Post-Release

After a successful release:

1. Verify the GitHub release page looks correct
2. Test installing via Homebrew: `brew upgrade stoic` (if already installed) or `brew install block/tap/stoic`
3. Verify Maven Central artifacts are available (may take up to 30 minutes):
   - Check the URLs printed by the release script

```

`assets/logo.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 918 900" width="918" height="900">
  <!-- head -->
  <path fill="#3ddc84" d="M 714.0 312.5 L 198.0 312.5 L 195.5 296.0 L 195.5 263.0 L 197.5 245.0 L 206.5 207.0 L 217.5 179.0 L 233.5 150.0 L 256.5 120.0 L 278.0 98.5 L 303.5 80.0 L 263.5 17.0 L 261.5 13.0 L 262.5 5.0 L 269.0 -0.5 L 277.0 -0.5 L 282.5 4.0 L 324.0 68.5 L 351.0 55.5 L 374.0 47.5 L 402.0 40.5 L 430.0 36.5 L 479.0 36.5 L 509.0 40.5 L 535.0 46.5 L 556.0 53.5 L 587.0 67.5 L 614.5 27.0 L 627.5 5.0 L 634.0 -0.5 L 642.0 -0.5 L 647.0 2.5 L 649.5 7.0 L 648.5 16.0 L 606.5 81.0 L 637.0 103.5 L 657.5 124.0 L 672.5 143.0 L 690.5 173.0 L 705.5 212.0 L 711.5 238.0 L 714.5 264.0 L 714.0 312.5 Z" />

  <!-- mustache -->
  <path fill="#ffffff" d="M 568.0 312.5 L 527.0 288.5 L 505.0 283.5 L 488.0 284.5 L 477.0 287.5 L 467.0 292.5 L 457.0 301.5 L 451.0 300.5 L 439.0 290.5 L 426.0 285.5 L 415.0 283.5 L 396.0 284.5 L 380.0 289.5 L 343.0 312.5 Z" />

  <!-- hair -->
  <path fill="#ffffff" d="M 225.5 266.0 L 236.0 263.5 L 242.0 259.5 L 247.5 254.0 L 252.5 245.0 L 254.5 238.0 L 254.5 226.0 L 249.5 213.0 L 258.0 212.5 L 270.0 208.5 L 275.0 205.5 L 285.5 194.0 L 291.5 178.0 L 292.0 160.5 L 307.0 164.5 L 322.0 162.5 L 329.0 158.5 L 335.5 152.0 L 341.0 139.5 L 349.0 148.5 L 355.0 151.5 L 362.0 153.5 L 374.0 153.5 L 379.0 152.5 L 391.0 145.5 L 397.5 138.0 L 400.0 132.5 L 407.0 139.5 L 418.0 146.5 L 433.0 148.5 L 446.0 143.5 L 452.5 138.0 L 456.0 132.5 L 463.0 140.5 L 472.0 145.5 L 490.0 146.5 L 501.0 141.5 L 511.0 130.5 L 515.5 140.0 L 524.0 148.5 L 533.0 152.5 L 552.0 152.5 L 564.0 146.5 L 571.0 138.5 L 576.5 151.0 L 583.0 157.5 L 590.0 161.5 L 598.0 163.5 L 607.0 163.5 L 619.0 159.5 L 618.5 174.0 L 620.5 184.0 L 629.5 199.0 L 637.0 205.5 L 645.0 209.5 L 661.5 212.0 L 657.5 220.0 L 655.5 229.0 L 657.5 244.0 L 661.5 251.0 L 667.0 257.5 L 676.0 263.5 L 682.0 265.5 L 693.0 265.5 L 693.5 262.0 L 684.5 216.0 L 671.5 180.0 L 651.5 146.0 L 626.0 118.5 L 604.0 102.5 L 585.0 91.5 L 549.0 75.5 L 526.0 67.5 L 488.0 59.5 L 467.0 57.5 L 440.0 57.5 L 399.0 63.5 L 370.0 72.5 L 338.0 87.5 L 329.0 93.5 L 321.0 95.5 L 307.0 103.5 L 286.0 118.5 L 266.5 138.0 L 256.5 151.0 L 248.5 164.0 L 235.5 191.0 L 225.5 221.0 L 217.5 262.0 L 218.0 265.5 L 225.5 266.0 Z" />

  <!-- eyes -->
  <path fill="#ffffff" d="M 552.5 249.0 L 559.0 248.5 L 565.0 245.5 L 573.5 237.0 L 576.5 229.0 L 575.5 217.0 L 570.5 209.0 L 565.0 204.5 L 555.0 200.5 L 547.0 201.5 L 540.0 204.5 L 530.5 215.0 L 528.5 222.0 L 528.5 229.0 L 533.5 240.0 L 543.0 247.5 L 552.5 249.0 Z" />
  <path fill="#ffffff" d="M 363.5 249.0 L 369.0 247.5 L 377.5 240.0 L 381.5 232.0 L 382.5 222.0 L 378.5 212.0 L 371.0 204.5 L 364.0 201.5 L 353.0 201.5 L 345.0 205.5 L 338.5 213.0 L 335.5 221.0 L 335.5 230.0 L 340.5 240.0 L 346.0 245.5 L 356.0 249.5 L 363.5 249.0 Z" />

  <!-- torso/legs -->
  <path fill="#3ddc84" d="M 571.0 867.5 L 551.0 867.5 L 532.0 860.5 L 515.5 847.0 L 506.5 833.0 L 501.5 815.0 L 501.0 727.5 L 408.5 728.0 L 408.5 820.0 L 400.5 840.0 L 393.5 849.0 L 384.0 857.5 L 365.0 866.5 L 339.0 867.5 L 326.0 863.5 L 317.0 858.5 L 303.5 846.0 L 295.5 832.0 L 291.5 816.0 L 292.5 728.0 L 251.0 727.5 L 238.0 723.5 L 228.0 718.5 L 222.0 714.5 L 209.5 702.0 L 203.5 693.0 L 197.5 678.0 L 197.0 329.5 L 296.0 329.5 L 714.5 330.0 L 714.5 671.0 L 712.5 680.0 L 706.5 694.0 L 699.5 704.0 L 691.0 712.5 L 679.0 720.5 L 659.0 727.5 L 619.5 728.0 L 619.5 817.0 L 615.5 833.0 L 607.5 846.0 L 598.0 855.5 L 587.0 862.5 L 571.0 867.5 Z" />

  <!-- beard -->
  <path fill="#ffffff" d="M 300.5 329.5 L 309.0 349.5 L 320.0 355.5 L 326.5 357.0 L 320.5 364.0 L 314.5 375.0 L 313.5 393.0 L 316.5 401.0 L 321.0 405.5 L 331.0 409.5 L 339.5 410.0 L 338.5 427.0 L 343.5 439.0 L 353.0 448.5 L 360.0 451.5 L 372.0 452.5 L 382.0 449.5 L 383.5 460.0 L 386.5 467.0 L 395.0 475.5 L 399.0 477.5 L 416.0 478.5 L 427.0 472.5 L 431.5 482.0 L 439.0 489.5 L 450.0 494.5 L 460.0 494.5 L 471.0 489.5 L 477.5 483.0 L 483.0 472.5 L 496.0 478.5 L 512.0 477.5 L 523.5 468.0 L 527.5 459.0 L 529.0 448.5 L 539.0 452.5 L 550.0 451.5 L 557.0 448.5 L 565.5 441.0 L 570.5 432.0 L 572.5 424.0 L 570.5 410.0 L 579.0 409.5 L 588.0 406.5 L 594.5 400.0 L 597.5 393.0 L 598.5 386.0 L 595.5 372.0 L 584.5 357.0 L 595.0 354.5 L 600.0 351.5 L 610.5 329.5 Z" />

  <!-- arms -->
  <path fill="#3ddc84" d="M 132.0 634.5 L 112.0 632.5 L 100.0 627.5 L 93.0 622.5 L 81.5 609.0 L 74.5 590.0 L 74.5 362.0 L 81.5 344.0 L 93.0 330.5 L 106.0 322.5 L 120.0 318.5 L 140.0 319.5 L 157.0 327.5 L 167.5 337.0 L 172.5 344.0 L 178.5 360.0 L 178.5 591.0 L 173.5 606.0 L 168.5 614.0 L 159.0 623.5 L 145.0 631.5 L 132.0 634.5 Z" />
  <path fill="#3ddc84" d="M 788.0 634.5 L 769.0 632.5 L 752.0 623.5 L 742.5 614.0 L 737.5 606.0 L 732.5 590.0 L 732.5 362.0 L 739.5 343.0 L 749.0 331.5 L 763.0 322.5 L 777.0 318.5 L 792.0 318.5 L 805.0 322.5 L 814.0 327.5 L 823.5 336.0 L 830.5 346.0 L 836.5 362.0 L 836.5 589.0 L 830.5 607.0 L 820.0 620.5 L 802.0 631.5 L 788.0 634.5 Z" />

  <!-- mouth -->
  <path fill="#3ddc84" d="M 509.0 376.5 L 491.0 375.5 L 473.0 370.5 L 461.0 363.5 L 455.0 357.5 L 437.0 369.5 L 422.0 374.5 L 409.0 376.5 L 397.0 376.5 L 380.0 373.5 L 372.0 369.5 L 368.5 366.0 L 367.5 361.0 L 376.0 357.5 L 400.0 355.5 L 422.0 349.5 L 438.0 341.5 L 445.0 336.5 L 451.0 329.5 L 455.0 328.5 L 472.0 342.5 L 487.0 349.5 L 508.0 355.5 L 538.0 358.5 L 541.5 361.0 L 541.5 365.0 L 537.0 369.5 L 531.0 372.5 L 509.0 376.5 Z" />

  <!-- toga stripes -->
  <path fill="#ffffff" d="M 402.5 699.0 L 443.0 677.5 L 483.0 650.5 L 520.0 619.5 L 565.5 572.0 L 596.5 531.0 L 631.5 473.0 L 665.5 400.0 L 676.5 370.0 L 679.0 358.5 L 659.0 357.5 L 647.5 381.0 L 629.5 409.0 L 610.5 434.0 L 589.5 458.0 L 566.0 481.5 L 542.0 502.5 L 511.0 526.5 L 474.0 551.5 L 441.0 570.5 L 401.0 590.5 L 353.0 609.5 L 288.0 628.5 L 258.0 634.5 L 228.5 638.0 L 228.5 665.0 L 230.5 672.0 L 235.0 679.5 L 300.0 666.5 L 361.0 647.5 L 395.0 633.5 L 430.0 616.5 L 482.0 586.5 L 532.0 550.5 L 552.0 533.5 L 580.0 505.5 L 580.5 507.0 L 566.5 525.0 L 541.5 554.0 L 498.0 596.5 L 461.0 625.5 L 427.0 647.5 L 384.0 670.5 L 349.0 685.5 L 305.5 699.0 L 402.5 699.0 Z" />
  <path fill="#ffffff" d="M 542.5 701.0 L 575.5 669.0 L 603.5 634.0 L 628.5 594.0 L 646.0 555.5 L 646.5 560.0 L 642.5 585.0 L 635.5 610.0 L 629.5 624.0 L 604.5 669.0 L 580.5 699.0 L 650.0 698.5 L 668.0 689.5 L 674.5 683.0 L 679.5 675.0 L 682.5 665.0 L 682.0 408.5 L 669.5 446.0 L 647.5 497.0 L 624.5 540.0 L 602.5 574.0 L 580.5 604.0 L 550.5 639.0 L 518.0 671.5 L 481.5 701.0 L 542.5 701.0 Z " />
</svg>

```

`bnr.sh`:

```sh
#!/bin/bash
# Build and run stoic (JVM version only, skipping slow GraalVM native compilation)

set -e

cd "$(dirname "$0")"

# Build distribution but skip native compilation
# Use --quiet to suppress output except errors
./gradlew --quiet --console=plain buildDistribution -x nativeCompile

# Run the JVM version using the wrapper script
exec build/distributions/bin/jvm/stoic "$@"

```

`build.gradle.kts`:

```kts
import com.vanniktech.maven.publish.AndroidSingleVariantLibrary
import com.vanniktech.maven.publish.JavadocJar
import com.vanniktech.maven.publish.KotlinJvm
import com.vanniktech.maven.publish.MavenPublishBaseExtension
import java.net.URI
import org.gradle.api.artifacts.repositories.MavenArtifactRepository
import org.gradle.api.publish.maven.MavenPublication

buildscript {
  repositories {
    google()
    mavenCentral()
  }

  dependencies { classpath(libs.vanniktech.maven.publish.plugin) }
}

plugins {
  // Plugins need to be declared here to avoid warnings like:
  //   The Kotlin Gradle plugin was loaded multiple times in different
  //   subprojects, which is not supported and may break the build.
  alias(libs.plugins.android.application) apply false
  alias(libs.plugins.android.library) apply false
  alias(libs.plugins.kotlin.android) apply false
  alias(libs.plugins.kotlin.jvm) apply false
  alias(libs.plugins.kotlin.serialization) apply false
  alias(libs.plugins.vanniktech.maven.publish.base) apply false
  alias(libs.plugins.spotless)
}

val prebuiltDir = rootProject.file("prebuilt")
val versionFile = prebuiltDir.resolve("STOIC_VERSION")
val versionName = versionFile.readText().trim()

// Read Android SDK configuration from gradle.properties
val androidMinSdk = providers.gradleProperty("android.minSdk").get()
val androidCompileSdk = providers.gradleProperty("android.compileSdk").get()
val androidTargetSdk = providers.gradleProperty("android.targetSdk").get()
val androidBuildToolsVersion = providers.gradleProperty("android.buildToolsVersion").get()

// Needed for :protocol code generation, since it needs it during configuration phase
extra["stoic.version_name"] = versionName

allprojects {
  plugins.withId("java") {
    the<JavaPluginExtension>().toolchain.languageVersion.set(JavaLanguageVersion.of(17))
  }
  plugins.withId("org.jetbrains.kotlin.jvm") {
    org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension::class
      .java
      .cast(extensions.getByName("kotlin"))
      .jvmToolchain(17)
  }

  group = "com.squareup.stoic"
  version = versionName

  repositories {
    mavenCentral()
    google()
  }

  plugins.withId("com.vanniktech.maven.publish.base") {
    configure<PublishingExtension> {
      repositories {
        maven {
          name = "testMaven"
          url = rootProject.layout.buildDirectory.dir("testMaven").get().asFile.toURI()
        }

        /*
         * Want to push to an internal repository for testing?
         * Set the following properties in ~/.gradle/gradle.properties.
         *
         * internalUrl=YOUR_INTERNAL_URL
         * internalUsername=YOUR_USERNAME
         * internalPassword=YOUR_PASSWORD
         *
         * Then run the following command to publish a new internal release:
         *
         * ./gradlew publishAllPublicationsToInternalRepository -DRELEASE_SIGNING_ENABLED=false
         */
        val internalUrl = providers.gradleProperty("internalUrl").orNull
        if (internalUrl != null) {
          maven {
            name = "internal"
            url = URI(internalUrl)
            credentials {
              username = providers.gradleProperty("internalUsername").get()
              password = providers.gradleProperty("internalPassword").get()
            }
          }
        }
      }
    }
    configure<MavenPublishBaseExtension> {
      // Configure based on project type
      if (!plugins.hasPlugin("com.android.library")) {
        // Kotlin JVM projects
        configure(KotlinJvm(javadocJar = JavadocJar.Empty(), sourcesJar = true))
      } else {
        // Android library projects
        configure(
          AndroidSingleVariantLibrary(
            variant = "release",
            sourcesJar = true,
            publishJavadocJar = true,
          )
        )
      }

      publishToMavenCentral(automaticRelease = true)
      signAllPublications()

      // Common POM configuration for all projects
      pom {
        description.set("Run code within any debuggable Android process, without modifying its APK")
        name.set(project.name)
        url.set("https://github.com/block/stoic/")

        licenses {
          license {
            name.set("The Apache Software License, Version 2.0")
            url.set("http://www.apache.org/licenses/LICENSE-2.0.txt")
            distribution.set("repo")
          }
        }

        developers {
          developer {
            id.set("block")
            name.set("Block")
          }
        }

        scm {
          url.set("https://github.com/block/stoic/")
          connection.set("scm:git:https://github.com/block/stoic.git")
          developerConnection.set("scm:git:ssh://git@github.com/block/stoic.git")
        }
      }
    }
    tasks.register("printPublishingInfo") {
      doLast {
        val publishing =
          project.extensions.findByType(org.gradle.api.publish.PublishingExtension::class.java)
            ?: run {
              println("No publishing extension for ${project.path}")
              return@doLast
            }

        // Print publication coordinates
        publishing.publications.withType<MavenPublication>().forEach { pub ->
          println("Publication: ${pub.name}")
          println("  groupId:    ${pub.groupId}")
          println("  artifactId: ${pub.artifactId}")
          println("  version:    ${pub.version}")
        }

        // Print repository names and URLs
        publishing.repositories.withType(MavenArtifactRepository::class.java).forEach { repo ->
          println("Repository: ${repo.name} -> ${repo.url}")
        }
      }
    }
  }
}

// For Android modules:
subprojects {
  plugins.withId("com.android.application") {
    extensions.configure<com.android.build.gradle.AppExtension>("android") {
      compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
      }
    }
  }
  plugins.withId("com.android.library") {
    extensions.configure<com.android.build.gradle.LibraryExtension>("android") {
      compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
      }
    }
  }
}

subprojects {
  extra["stoic.android_min_sdk"] = androidMinSdk
  extra["stoic.android_compile_sdk"] = androidCompileSdk
  extra["stoic.android_target_sdk"] = androidTargetSdk
  extra["stoic.android_build_tools_version"] = androidBuildToolsVersion
  extra["stoic.version_name"] = versionName
  extra["stoic.version_code"] = versionCodeFromVersionName(versionName)

  plugins.withId("java") {
    val jarTask = tasks.named<Jar>("jar")

    // Builds .apk, preserving the manifest
    tasks.register<JavaExec>("apk") {
      dependsOn(jarTask)

      val jarFile = jarTask.flatMap { it.archiveFile }.map { it.asFile }
      val apkFile = jarFile.map { File(it.path.replace(".jar", ".apk")) }

      val jarToApkPreserveManifest = project(":internal:tool:jar-to-apk-preserve-manifest")
      // TODO: This triggers a configuration resolution warning in Gradle - needs refactoring to use
      // proper dependency management
      classpath =
        jarToApkPreserveManifest.extensions
          .getByType<JavaPluginExtension>()
          .sourceSets
          .getByName("main")
          .runtimeClasspath
      mainClass.set(jarToApkPreserveManifest.the<JavaApplication>().mainClass)
      inputs.file(jarFile)
      outputs.file(apkFile)

      // Set args lazily, during execution
      doFirst { args = listOf(jarFile.get().absolutePath, apkFile.get().absolutePath) }
    }
  }

  val projectPathSlug = project.path.removePrefix(":").replace(":", "-")
  tasks.withType<Jar>().configureEach {
    manifest {
      attributes(
        "Implementation-Title" to "stoic-$projectPathSlug",
        "Implementation-Version" to versionName,
      )
    }
  }
}

// Distribution task - assembles all artifacts into build/distributions/
val buildDistribution by
  tasks.registering {
    description = "Builds and assembles all Stoic artifacts into build/distributions/"
    group = "build"

    // Depend on all the subproject builds
    dependsOn(
      ":host:main:assemble",
      ":host:main:nativeCompile",
      ":target:plugin-sdk:assemble",
      ":target:app-sdk:assembleRelease",
      ":target:jvmti-attach:assembleDebug",
      ":demo-plugin:helloworld:apk",
      ":demo-plugin:appexitinfo:apk",
      ":demo-plugin:breakpoint:apk",
      ":demo-plugin:crasher:apk",
      ":demo-app:without-sdk:assembleDebug",
      ":demo-app:with-sdk:assembleRelease",
      ":native:buildNative",
    )

    val releaseDir = layout.buildDirectory.dir("distributions").get().asFile
    val syncDir = File(releaseDir, "sync")

    doLast {
      // Create directory structure
      File(releaseDir, "jar").mkdirs()
      File(releaseDir, "sdk").mkdirs()
      File(releaseDir, "bin/darwin-arm64").mkdirs()
      File(syncDir, "plugins").mkdirs()
      File(syncDir, "stoic").mkdirs()
      File(syncDir, "bin").mkdirs()
      File(syncDir, "apk").mkdirs()

      // Copy prebuilt files
      copy {
        from("prebuilt")
        into(releaseDir)
      }

      // Copy host artifacts
      copy {
        from("host/main/build/libs/main-$versionName.jar")
        into("$releaseDir/jar")
        rename { "stoic-host-main.jar" }
      }
      copy {
        from("host/main/build/native/nativeCompile/stoic")
        into("$releaseDir/bin/darwin-arm64")
      }

      // Copy protocol JAR
      copy {
        from("protocol/build/libs/protocol-$versionName.jar")
        into("$releaseDir/sdk")
        rename { "stoic-protocol.jar" }
      }

      // Copy plugin SDK
      copy {
        from("target/plugin-sdk/build/libs/plugin-sdk-$versionName.jar")
        into("$releaseDir/sdk")
        rename { "stoic-plugin-sdk.jar" }
      }

      // Copy app SDK (Android AAR library for apps to include)
      copy {
        from("target/app-sdk/build/outputs/aar/app-sdk-release.aar")
        into("$releaseDir/sdk")
        rename { "stoic-app-sdk.aar" }
      }

      // Copy jvmti-attach APK (debug build for easier debugging)
      copy {
        from("target/jvmti-attach/build/outputs/apk/debug/jvmti-attach-debug.apk")
        into("$syncDir/stoic")
        rename { "stoic-jvmti-attach.apk" }
      }

      // Copy demo apps
      copy {
        from("demo-app/without-sdk/build/outputs/apk/debug/without-sdk-debug.apk")
        into("$syncDir/apk")
        rename { "stoic-demo-app-without-sdk-debug.apk" }
      }
      copy {
        from("demo-app/with-sdk/build/outputs/apk/release/with-sdk-release.apk")
        into("$syncDir/apk")
        rename { "stoic-demo-app-with-sdk-release.apk" }
      }

      // Copy demo plugins
      val demoPluginsDir = File(releaseDir, "demo-plugins")
      demoPluginsDir.mkdirs()
      copy {
        from("demo-plugin/appexitinfo/build/libs/appexitinfo-$versionName.apk")
        into(demoPluginsDir)
        rename { "appexitinfo.apk" }
      }
      copy {
        from("demo-plugin/breakpoint/build/libs/breakpoint-$versionName.apk")
        into(demoPluginsDir)
        rename { "breakpoint.apk" }
      }
      copy {
        from("demo-plugin/crasher/build/libs/crasher-$versionName.apk")
        into(demoPluginsDir)
        rename { "crasher.apk" }
      }
      copy {
        from("demo-plugin/helloworld/build/libs/helloworld-$versionName.apk")
        into(demoPluginsDir)
        rename { "helloworld.apk" }
      }

      // Set permissions on sync directory
      // TODO: exec() is deprecated - refactor to use ExecOperations with a typed task
      exec { commandLine("chmod", "-R", "a+rw", syncDir.absolutePath) }

      println()
      println()
      println("----- Stoic build completed -----")
      println()
      println()
    }
  }

// Configure Spotless for code formatting with ktfmt
spotless {
  kotlin {
    target("**/*.kt")
    targetExclude("**/build/**", "**/prebuilt/**", "**/buildSrc/**")
    ktfmt().googleStyle()
  }
  kotlinGradle {
    target("**/*.gradle.kts")
    targetExclude("**/build/**")
    ktfmt().googleStyle()
  }
}

```

`build.sh`:

```sh
#!/bin/bash
set -euo pipefail

# Main build script for Stoic
# Runs environment setup then delegates to Gradle

stoic_dir="$(realpath "$(dirname "$(readlink -f "$0")")")"

# Parse arguments
export AUTO_YES=0
for arg in "$@"; do
    case $arg in
        --yes) AUTO_YES=1 ;;
        *)
            >&2 echo "Unrecognized arg: $arg"
            exit 1
            ;;
    esac
done

# Source setup (checks submodules, Android SDK, GraalVM)
# Note: We source it so environment variables are available in this shell
source "$stoic_dir/setup.sh"

# Build everything and assemble distribution
cd "$stoic_dir"

# unquoted EXTRA_GRADLE_ARGS is intentional
# shellcheck disable=SC2086
./gradlew buildDistribution --parallel ${EXTRA_GRADLE_ARGS:-}

# Verify stoic is in PATH
set +e
stoic_path="$(readlink -f "$(which stoic)")"
set -e

if [ -z "$stoic_path" ]; then
    case "$SHELL" in
      */bash)
        config_file='~''/.bashrc'
        ;;
      */zsh)
        config_file='~''/.zshrc'
        ;;
      *)
        config_file="<path-to-your-config-file>"
        ;;
    esac

    >&2 echo "WARNING: stoic is missing from your PATH. Next, please run:"
    >&2 echo
    >&2 echo "    echo export PATH=\$PATH:$stoic_dir/build/distributions/bin/darwin-arm64 >> $config_file && source $config_file"
elif [ "$stoic_path" != "$stoic_dir/build/distributions/bin/darwin-arm64/stoic" ]; then
    >&2 echo "WARNING: Your PATH is currently including stoic from: $stoic_path"
    >&2 echo "The version you just built is in \`$stoic_dir/build/distributions/bin/darwin-arm64\`"
else
    >&2 echo "stoic correctly resolves to the version you just built."
fi
>&2 echo

```

`buildSrc/build.gradle.kts`:

```kts
plugins { `kotlin-dsl` }

repositories {
  gradlePluginPortal()
  mavenCentral()
}

```

`buildSrc/settings.gradle.kts`:

```kts
rootProject.name = "buildSrc"

```

`buildSrc/src/main/kotlin/VersionCodeFromVersionName.kt`:

```kt
fun versionCodeFromVersionName(versionName: String): Int {
    val snapshotSuffix = "-SNAPSHOT"
    val isSnapshot = versionName.endsWith(snapshotSuffix)

    val cleaned = versionName.removeSuffix(snapshotSuffix)
    val parts = cleaned.split(".")
    require(parts.size == 3) { "Expected MAJOR.MINOR.PATCH" }

    val (major, minor, patch) = parts.map { it.toInt() }
    require(major in 0..1999)
    require(minor in 0..999)
    require(patch in 0..999)

    val base = major * 1_000_000 + minor * 10_000 + patch * 10
    return if (isSnapshot) base - 1 else base
}

```

`check-warnings.sh`:

```sh
#!/bin/bash
# Script to check for compile warnings in the codebase
# Exits with non-zero status if warnings are found

set -e

echo "Building project and checking for warnings..."
echo "This includes all modules: Gradle, native C++, and GraalVM native-image"
echo ""

# Run clean build using build.sh to ensure all warnings are caught
# This matches what CI does and includes native code compilation
BUILD_OUTPUT=$(mktemp)
./gradlew clean && EXTRA_GRADLE_ARGS="--warning-mode all" AUTO_YES=1 ./build.sh 2>&1 | tee "$BUILD_OUTPUT"

echo ""
echo "Checking for warnings..."

# Extract warnings, excluding:
# - android.support.graphics.drawable: Third-party Android support library namespace conflict (can't fix)
# - Resolution of the configuration.*jar-to-apk-preserve-manifest:runtimeClasspath: Gradle deprecation with TODO in build.gradle.kts:214
# - exec(Action: Gradle exec() deprecation with TODO in build.gradle.kts:362
WARNINGS=$(grep -E "^w:|Warning:|deprecated" "$BUILD_OUTPUT" | \
  grep -v "android.support.graphics.drawable" | \
  grep -v "Resolution of the configuration.*jar-to-apk-preserve-manifest:runtimeClasspath" | \
  grep -v "exec(Action" || true)

# Clean up temp file
rm -f "$BUILD_OUTPUT"

# Check if any warnings were found
if [ -n "$WARNINGS" ]; then
  echo ""
  echo "❌ Found compile warnings:"
  echo "$WARNINGS"
  echo ""
  exit 1
else
  echo "✅ No compile warnings found!"
fi

# Note: Format checking with 'spotlessCheck' is configured but not yet enforced
# Once the codebase is formatted (via 'spotlessApply'), uncomment the following:
echo ""
echo "Checking code formatting..."
./gradlew spotlessCheck
if [ $? -ne 0 ]; then
  echo "❌ Code formatting violations found!"
  echo "Run './gradlew spotlessApply' to fix them."
  exit 1
fi
echo "✅ Code formatting is correct!"

exit 0

```

`demo-app/with-sdk/build.gradle.kts`:

```kts
plugins {
  alias(libs.plugins.android.application)
  alias(libs.plugins.kotlin.android)
}

android {
  namespace = "com.squareup.stoic.demoapp.withsdk"
  compileSdk = (extra["stoic.android_compile_sdk"] as String).toInt()

  defaultConfig {
    applicationId = "com.squareup.stoic.demoapp.withsdk"
    minSdk = (extra["stoic.android_min_sdk"] as String).toInt()
    targetSdk = (extra["stoic.android_target_sdk"] as String).toInt()
    versionCode = extra["stoic.version_code"] as Int
    versionName = extra["stoic.version_name"] as String

    testInstrumentationRunner = "android.support.test.runner.AndroidJUnitRunner"
  }

  buildTypes {
    // The with-sdk demo exists to demonstrate the ability to use stoic in a
    // non-debuggable build, so we always make our builds non-debuggable - even
    // the "debug" variant.
    all {
      isDebuggable = false
      isMinifyEnabled = false
      // This is a release build in the sense that it is not debuggable, but
      // we're still signing it with debug keys
      signingConfig = signingConfigs.getByName("debug")
      proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
    }
  }
  compileOptions {
    val jvmTarget = JavaVersion.toVersion(libs.versions.jvmTarget.get())
    sourceCompatibility = jvmTarget
    targetCompatibility = jvmTarget
  }
  kotlinOptions { jvmTarget = libs.versions.jvmTarget.get() }
  buildFeatures { viewBinding = true }

  // TODO: this doesn't work for source dependencies, but apparently this is the way to pre-exclude
  //   from the .aar file
  packaging { resources { excludes += "META-INF/DEPENDENCIES" } }
}

dependencies {
  implementation("com.android.support:appcompat-v7:28.0.0")
  testImplementation("junit:junit:4.13.2")
  androidTestImplementation("com.android.support.test:runner:1.0.2")
  androidTestImplementation("com.android.support.test.espresso:espresso-core:3.0.2")
  implementation(project(":target:app-sdk"))
  implementation(project(":target:plugin-sdk"))
}

```

`demo-app/with-sdk/proguard-rules.pro`:

```pro
# Add project specific ProGuard com.square.stoic.trace.rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
```

`demo-app/with-sdk/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

  <!-- com.squareup.stoic.trace.getInclude as many permissions as possible so that plugins can do interesting things -->
  <uses-permission android:name="android.permission.INTERNET" />
  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
  <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
  <uses-permission android:name="android.permission.CHANGE_NETWORK_STATE" />

  <application
      android:allowBackup="true"
      android:icon="@mipmap/ic_launcher"
      android:label="@string/app_name"
      android:roundIcon="@mipmap/ic_launcher_round"
      android:supportsRtl="true"
      android:theme="@style/Theme.Stoic">

    <!-- Stoic configuration -->
    <meta-data
        android:name="com.squareup.stoic.config"
        android:value="com.squareup.stoic.demoapp.withsdk.plugins.DemoStoicConfig" />

    <activity
        android:name="com.squareup.stoic.demoapp.withsdk.ExampleActivity"
        android:configChanges="orientation|keyboardHidden|screenSize"
        android:exported="true"
        android:theme="@style/Theme.Stoic.Fullscreen">
      <intent-filter>
        <action android:name="android.intent.action.MAIN" />

        <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
    </activity>
  </application>

</manifest>
```

`demo-app/with-sdk/src/main/assets/stoic/authorized_keys`:

```
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQC0+2TaHK8jf/0Gd5CknU+yvAxS7AEhbC1+NZoi6eg5+TZ/drkSzTdObmINxoxir8tMwev7QNZYrnOyLknDLkWCFJtItB+3QkF/Ycdlu0wmvGZkqJa2Fyri0OET9u267mmL+vHRSVLGSIzlI39vkmeJ9z/Jhyi/T3RXD0iE5AWML7NQY+bAhXK5oxHBY7BcndN1u2JDqDF1wO2Tage33QJhSIn+lOMl5SFsqLlP76EEHHmoRvgki1Rp+XUoCacGc4DuEz0v8P3hPm1dB4A96PyTdGsKOrsT4nt197JOtyLITESG0yP0wEUVOP3CSjtMI8d5sYcPMPDVlaNs/ZxYd6eFF7D/srTb7d3DF95QnfACuxAhijVruws1K0PetWEO06pwU1Xbu2k/QVDaqbklmJXaB5cdqufaUL+Of0ES2h1m9pRfwA9HIIYJBXjauBSKbtpUtA2y9djRzFjgjifsoI4Fez7QTdrTRFSZA7kosV6sLrIJ917J5PHDRZTx0eykusNH1mLazr1/PuMenMzHPvAu0cHQGDaRv64OB2+3y7vXKKP+ikltdeGaIt2lBC1ecRhMByK17i0If09TBquZb+gN5FRsuBv78bzF2OtFF+Sn6WMRz4ekww70TMsdGbkjRcmuJd7U/L8FAIXwiTacXTjNoJ5eXTVdnFT3D5ghE3NbPQ== tomm@BLKH3QC64CHH4.local

```

`demo-app/with-sdk/src/main/java/com/squareup/stoic/demoapp/withsdk/ExampleActivity.kt`:

```kt
package com.squareup.stoic.demoapp.withsdk

import android.annotation.SuppressLint
import android.os.Build
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.support.v7.app.AppCompatActivity
import android.view.MotionEvent
import android.view.View
import android.view.WindowInsets
import android.widget.LinearLayout
import android.widget.TextView
import com.squareup.stoic.demoapp.withsdk.databinding.ActivityExampleBinding

/**
 * An example full-screen activity that shows and hides the system UI (i.e. status bar and
 * navigation/system bar) with user interaction.
 */
class ExampleActivity : AppCompatActivity() {

  private lateinit var binding: ActivityExampleBinding
  private lateinit var fullscreenContent: TextView
  private lateinit var fullscreenContentControls: LinearLayout
  private val hideHandler = Handler(Looper.myLooper()!!)

  // Suppress DEPRECATION: systemUiVisibility is deprecated in API 30+, but required for API 26-29
  // support
  @Suppress("DEPRECATION")
  @SuppressLint("InlinedApi")
  private val hidePart2Runnable = Runnable {
    // Delayed removal of status and navigation bar
    if (Build.VERSION.SDK_INT >= 30) {
      fullscreenContent.windowInsetsController?.hide(
        WindowInsets.Type.statusBars() or WindowInsets.Type.navigationBars()
      )
    } else {
      // Note that some of these constants are new as of API 16 (Jelly Bean)
      // and API 19 (KitKat). It is safe to use them, as they are inlined
      // at compile-time and do nothing on earlier devices.
      fullscreenContent.systemUiVisibility =
        View.SYSTEM_UI_FLAG_LOW_PROFILE or
          View.SYSTEM_UI_FLAG_FULLSCREEN or
          View.SYSTEM_UI_FLAG_LAYOUT_STABLE or
          View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY or
          View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or
          View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
    }
  }
  private val showPart2Runnable = Runnable {
    // Delayed display of UI elements
    supportActionBar?.show()
    fullscreenContentControls.visibility = View.VISIBLE
  }
  private var isFullscreen: Boolean = false

  private val hideRunnable = Runnable { hide() }

  /**
   * Touch listener to use for in-layout UI controls to delay hiding the system UI. This is to
   * prevent the jarring behavior of controls going away while interacting with activity UI.
   */
  private val delayHideTouchListener =
    View.OnTouchListener { view, motionEvent ->
      when (motionEvent.action) {
        MotionEvent.ACTION_DOWN ->
          if (AUTO_HIDE) {
            delayedHide(AUTO_HIDE_DELAY_MILLIS)
          }

        MotionEvent.ACTION_UP -> view.performClick()
        else -> {}
      }
      false
    }

  @SuppressLint("ClickableViewAccessibility")
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    binding = ActivityExampleBinding.inflate(layoutInflater)
    setContentView(binding.root)

    supportActionBar?.setDisplayHomeAsUpEnabled(true)

    isFullscreen = true

    // Set up the user interaction to manually show or hide the system UI.
    fullscreenContent = binding.fullscreenContent
    fullscreenContent.setOnClickListener { toggle() }

    fullscreenContentControls = binding.fullscreenContentControls

    // Upon interacting with UI controls, delay any scheduled hide()
    // operations to prevent the jarring behavior of controls going away
    // while interacting with the UI.
    binding.dummyButton.setOnTouchListener(delayHideTouchListener)
  }

  override fun onPostCreate(savedInstanceState: Bundle?) {
    super.onPostCreate(savedInstanceState)

    // Trigger the initial hide() shortly after the activity has been
    // created, to briefly hint to the user that UI controls
    // are available.
    delayedHide(100)
  }

  private fun toggle() {
    if (isFullscreen) {
      hide()
    } else {
      show()
    }
  }

  private fun hide() {
    // Hide UI first
    supportActionBar?.hide()
    fullscreenContentControls.visibility = View.GONE
    isFullscreen = false

    // Schedule a runnable to remove the status and navigation bar after a delay
    hideHandler.removeCallbacks(showPart2Runnable)
    hideHandler.postDelayed(hidePart2Runnable, UI_ANIMATION_DELAY.toLong())
  }

  // Suppress DEPRECATION: systemUiVisibility is deprecated in API 30+, but required for API 26-29
  // support
  @Suppress("DEPRECATION")
  private fun show() {
    // Show the system bar
    if (Build.VERSION.SDK_INT >= 30) {
      fullscreenContent.windowInsetsController?.show(
        WindowInsets.Type.statusBars() or WindowInsets.Type.navigationBars()
      )
    } else {
      fullscreenContent.systemUiVisibility =
        View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
    }
    isFullscreen = true

    // Schedule a runnable to display UI elements after a delay
    hideHandler.removeCallbacks(hidePart2Runnable)
    hideHandler.postDelayed(showPart2Runnable, UI_ANIMATION_DELAY.toLong())
  }

  /** Schedules a call to hide() in [delayMillis], canceling any previously scheduled calls. */
  private fun delayedHide(delayMillis: Int) {
    hideHandler.removeCallbacks(hideRunnable)
    hideHandler.postDelayed(hideRunnable, delayMillis.toLong())
  }

  companion object {
    /**
     * Whether or not the system UI should be auto-hidden after [AUTO_HIDE_DELAY_MILLIS]
     * milliseconds.
     */
    private const val AUTO_HIDE = true

    /**
     * If [AUTO_HIDE] is set, the number of milliseconds to wait after user interaction before
     * hiding the system UI.
     */
    private const val AUTO_HIDE_DELAY_MILLIS = 3000

    /**
     * Some older devices needs a small delay between UI widget updates and a change of the status
     * and navigation bar.
     */
    private const val UI_ANIMATION_DELAY = 300
  }
}

```

`demo-app/with-sdk/src/main/java/com/squareup/stoic/demoapp/withsdk/plugins/DemoEmbeddedPlugin.kt`:

```kt
package com.squareup.stoic.demoapp.withsdk.plugins

import android.util.Log
import com.squareup.stoic.helpers.*
import com.squareup.stoic.plugin.StoicPlugin

/**
 * Example embedded plugin that demonstrates how to create plugins within your app.
 *
 * This plugin can be invoked with: stoic com.squareup.stoic.demoapp.withsdk demo-embedded <args...>
 */
class DemoEmbeddedPlugin : StoicPlugin {
  override fun run(args: List<String>): Int {
    Log.i("DemoEmbeddedPlugin", "Running with args: $args")

    println("Hello from DemoEmbeddedPlugin!")
    println("Arguments received: ${args.joinToString(", ")}")
    println("This plugin is embedded in the app.")

    // Example: handle some simple commands
    when (args.firstOrNull()) {
      "hello" -> {
        println("Hello back!")
        return 0
      }
      "echo" -> {
        println(args.drop(1).joinToString(" "))
        return 0
      }
      "fail" -> {
        eprintln("Simulating failure")
        return 1
      }
      else -> {
        println("Available commands:")
        println("  hello - Print a greeting")
        println("  echo <message> - Echo a message")
        println("  fail - Return error code")
        return 0
      }
    }
  }
}

```

`demo-app/with-sdk/src/main/java/com/squareup/stoic/demoapp/withsdk/plugins/DemoStoicConfig.kt`:

```kt
package com.squareup.stoic.demoapp.withsdk.plugins

import android.content.Context
import com.squareup.stoic.plugin.StoicConfig
import com.squareup.stoic.plugin.StoicPlugin

/**
 * Stoic configuration for the demo app.
 *
 * This class is declared in AndroidManifest.xml and will be automatically discovered by Stoic when
 * it attaches (via JVMTI or BroadcastReceiver).
 */
class DemoStoicConfig : StoicConfig {
  override fun getEmbeddedPlugins(context: Context): Map<String, Lazy<StoicPlugin>> {
    return mapOf("demo-embedded" to lazy { DemoEmbeddedPlugin() })
  }
}

```

`demo-app/with-sdk/src/main/res/drawable/ic_launcher_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:height="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108"
    android:width="108dp">
  <path
      android:fillColor="#3DDC84"
      android:pathData="M0,0h108v108h-108z" />
  <path
      android:fillColor="#00000000"
      android:pathData="M9,0L9,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M19,0L19,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M29,0L29,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M39,0L39,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M49,0L49,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M59,0L59,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M69,0L69,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M79,0L79,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M89,0L89,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M99,0L99,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,9L108,9"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,19L108,19"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,29L108,29"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,39L108,39"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,49L108,49"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,59L108,59"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,69L108,69"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,79L108,79"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,89L108,89"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,99L108,99"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M19,29L89,29"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M19,39L89,39"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M19,49L89,49"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M19,59L89,59"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M19,69L89,69"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M19,79L89,79"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M29,19L29,89"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M39,19L39,89"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M49,19L49,89"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M59,19L59,89"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M69,19L69,89"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M79,19L79,89"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
</vector>

```

`demo-app/with-sdk/src/main/res/drawable/ic_launcher_foreground.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:height="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108"
    android:width="108dp">
  <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
    <aapt:attr name="android:fillColor">
      <gradient
          android:endX="85.84757"
          android:endY="92.4963"
          android:startX="42.9492"
          android:startY="49.59793"
          android:type="linear">
        <item
            android:color="#44000000"
            android:offset="0.0" />
        <item
            android:color="#00000000"
            android:offset="1.0" />
      </gradient>
    </aapt:attr>
  </path>
  <path
      android:fillColor="#FFFFFF"
      android:fillType="nonZero"
      android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
      android:strokeColor="#00000000"
      android:strokeWidth="1" />
</vector>
```

`demo-app/with-sdk/src/main/res/layout/activity_example.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?attr/fullscreenBackgroundColor"
    android:theme="@style/ThemeOverlay.Stoic.FullscreenContainer"
    tools:context="com.squareup.stoic.demoapp.withsdk.ExampleActivity"
    >

  <!-- The primary full-screen view. This can be replaced with whatever view
         is needed to present your content, e.g. VideoView, SurfaceView,
         TextureView, etc. -->
  <FrameLayout
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      android:fitsSystemWindows="true"
      >

    <LinearLayout
        android:id="@+id/fullscreen_content_controls"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom|center_horizontal"
        android:orientation="horizontal"
        tools:ignore="UselessParent"
        style="@style/Widget.Theme.Stoic.ButtonBar.Fullscreen"
        >

      <Button
          android:id="@+id/dummy_button"
          android:layout_width="0dp"
          android:layout_height="wrap_content"
          android:layout_weight="1"
          android:text="@string/example_button"
          style="?android:attr/buttonBarButtonStyle"
          />

    </LinearLayout>
  </FrameLayout>

  <!-- This FrameLayout insets its children based on system windows using
         android:fitsSystemWindows. -->
  <TextView
      android:id="@+id/fullscreen_content"
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      android:gravity="center"
      android:keepScreenOn="true"
      android:text="@string/example_content"
      android:textColor="?attr/fullscreenTextColor"
      android:textSize="50sp"
      android:textStyle="bold"
      />

</FrameLayout>

```

`demo-app/with-sdk/src/main/res/mipmap-anydpi/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
  <background android:drawable="@drawable/ic_launcher_background" />
  <foreground android:drawable="@drawable/ic_launcher_foreground" />
  <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`demo-app/with-sdk/src/main/res/mipmap-anydpi/ic_launcher_round.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
  <background android:drawable="@drawable/ic_launcher_background" />
  <foreground android:drawable="@drawable/ic_launcher_foreground" />
  <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`demo-app/with-sdk/src/main/res/values-night/themes.xml`:

```xml
<resources xmlns:tools="http://schemas.android.com/tools">
  <!-- Base application theme. -->
  <style name="Theme.Stoic" parent="Theme.AppCompat.Light.DarkActionBar">
    <!-- Primary brand color. -->
    <item name="colorPrimary">@color/purple_200</item>
    <item name="colorPrimaryDark">@color/purple_700</item>
    <item name="colorAccent">@color/teal_200</item>
    <!-- Customize your theme here. -->
  </style>

  <style name="ThemeOverlay.Stoic.FullscreenContainer" parent="">
    <item name="fullscreenBackgroundColor">@color/light_blue_900</item>
    <item name="fullscreenTextColor">@color/light_blue_A400</item>
  </style>
</resources>
```

`demo-app/with-sdk/src/main/res/values/attrs.xml`:

```xml
<resources>
  <declare-styleable name="FullscreenAttrs">
    <attr format="color" name="fullscreenBackgroundColor" />
    <attr format="color" name="fullscreenTextColor" />
  </declare-styleable>
</resources>
```

`demo-app/with-sdk/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <color name="purple_200">#FFBB86FC</color>
  <color name="purple_500">#FF6200EE</color>
  <color name="purple_700">#FF3700B3</color>
  <color name="teal_200">#FF03DAC5</color>
  <color name="teal_700">#FF018786</color>
  <color name="black">#FF000000</color>
  <color name="white">#FFFFFFFF</color>
  <color name="light_blue_600">#FF039BE5</color>
  <color name="light_blue_900">#FF01579B</color>
  <color name="light_blue_A200">#FF40C4FF</color>
  <color name="light_blue_A400">#FF00B0FF</color>
  <color name="light_green_600">#FF03E59B</color>
  <color name="light_green_A200">#FF40FFC4</color>
  <color name="black_overlay">#66000000</color>
</resources>
```

`demo-app/with-sdk/src/main/res/values/strings.xml`:

```xml
<resources>
  <string name="app_name">ExampleApp</string>
  <string name="example_button">Example Button</string>
  <string name="example_content">Stoic</string>
</resources>
```

`demo-app/with-sdk/src/main/res/values/styles.xml`:

```xml
<resources>

  <style name="Widget.Theme.Stoic.ActionBar.Fullscreen" parent="Widget.AppCompat.ActionBar">
    <item name="android:background">@color/black_overlay</item>
  </style>

  <style name="Widget.Theme.Stoic.ButtonBar.Fullscreen" parent="">
    <item name="android:background">@color/black_overlay</item>
    <item name="android:buttonBarStyle">?android:attr/buttonBarStyle</item>
  </style>
</resources>
```

`demo-app/with-sdk/src/main/res/values/themes.xml`:

```xml
<resources xmlns:tools="http://schemas.android.com/tools">
  <!-- Base application theme. -->
  <style name="Theme.Stoic" parent="Theme.AppCompat.Light.DarkActionBar">
    <!-- Primary brand color. -->
    <item name="colorPrimary">@color/purple_500</item>
    <item name="colorPrimaryDark">@color/purple_700</item>
    <item name="colorAccent">@color/teal_200</item>
    <!-- Customize your theme here. -->
  </style>

  <style name="Theme.Stoic.Fullscreen" parent="Theme.Stoic">
    <item name="android:actionBarStyle">@style/Widget.Theme.Stoic.ActionBar.Fullscreen</item>
    <item name="android:windowActionBarOverlay">true</item>
    <item name="android:windowBackground">@null</item>
  </style>

  <style name="ThemeOverlay.Stoic.FullscreenContainer" parent="">
    <item name="fullscreenBackgroundColor">@color/light_green_600</item>
    <item name="fullscreenTextColor">@color/light_green_A200</item>
  </style>
</resources>
```

`demo-app/without-sdk/build.gradle.kts`:

```kts
plugins {
  alias(libs.plugins.android.application)
  alias(libs.plugins.kotlin.android)
}

android {
  namespace = "com.squareup.stoic.demoapp.withoutsdk"
  compileSdk = (extra["stoic.android_compile_sdk"] as String).toInt()

  defaultConfig {
    applicationId = "com.squareup.stoic.demoapp.withoutsdk"
    minSdk = (extra["stoic.android_min_sdk"] as String).toInt()
    targetSdk = (extra["stoic.android_target_sdk"] as String).toInt()
    versionCode = extra["stoic.version_code"] as Int
    versionName = extra["stoic.version_name"] as String

    testInstrumentationRunner = "android.support.test.runner.AndroidJUnitRunner"
  }

  buildTypes {
    release {
      isMinifyEnabled = false
      proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
    }
  }
  compileOptions {
    val jvmTarget = JavaVersion.toVersion(libs.versions.jvmTarget.get())
    sourceCompatibility = jvmTarget
    targetCompatibility = jvmTarget
  }
  kotlinOptions { jvmTarget = libs.versions.jvmTarget.get() }
  buildFeatures { viewBinding = true }
}

dependencies {
  implementation("com.android.support:appcompat-v7:28.0.0")
  testImplementation("junit:junit:4.13.2")
  androidTestImplementation("com.android.support.test:runner:1.0.2")
  androidTestImplementation("com.android.support.test.espresso:espresso-core:3.0.2")
}

```

`demo-app/without-sdk/proguard-rules.pro`:

```pro
# Add project specific ProGuard com.square.stoic.trace.rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
```

`demo-app/without-sdk/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

  <!-- com.squareup.stoic.trace.getInclude as many permissions as possible so that plugins can do interesting things -->
  <uses-permission android:name="android.permission.INTERNET" />
  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
  <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
  <uses-permission android:name="android.permission.CHANGE_NETWORK_STATE" />

  <application
      android:allowBackup="true"
      android:icon="@mipmap/ic_launcher"
      android:label="@string/app_name"
      android:roundIcon="@mipmap/ic_launcher_round"
      android:supportsRtl="true"
      android:theme="@style/Theme.Stoic">
    <activity
        android:name=".ExampleActivity"
        android:configChanges="orientation|keyboardHidden|screenSize"
        android:exported="true"
        android:label="@string/app_name"
        android:theme="@style/Theme.Stoic.Fullscreen">
      <intent-filter>
        <action android:name="android.intent.action.MAIN" />

        <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
    </activity>
  </application>

</manifest>
```

`demo-app/without-sdk/src/main/java/com/squareup/stoic/demoapp/withoutsdk/ExampleActivity.kt`:

```kt
package com.squareup.stoic.demoapp.withoutsdk

import android.annotation.SuppressLint
import android.os.Build
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.support.v7.app.AppCompatActivity
import android.view.MotionEvent
import android.view.View
import android.view.WindowInsets
import android.widget.LinearLayout
import android.widget.TextView
import com.squareup.stoic.demoapp.withoutsdk.databinding.ActivityExampleBinding

/**
 * An example full-screen activity that shows and hides the system UI (i.e. status bar and
 * navigation/system bar) with user interaction.
 */
class ExampleActivity : AppCompatActivity() {

  private lateinit var binding: ActivityExampleBinding
  private lateinit var fullscreenContent: TextView
  private lateinit var fullscreenContentControls: LinearLayout
  private val hideHandler = Handler(Looper.myLooper()!!)

  // Suppress DEPRECATION: systemUiVisibility is deprecated in API 30+, but required for API 26-29
  // support
  @Suppress("DEPRECATION")
  @SuppressLint("InlinedApi")
  private val hidePart2Runnable = Runnable {
    // Delayed removal of status and navigation bar
    if (Build.VERSION.SDK_INT >= 30) {
      fullscreenContent.windowInsetsController?.hide(
        WindowInsets.Type.statusBars() or WindowInsets.Type.navigationBars()
      )
    } else {
      // Note that some of these constants are new as of API 16 (Jelly Bean)
      // and API 19 (KitKat). It is safe to use them, as they are inlined
      // at compile-time and do nothing on earlier devices.
      fullscreenContent.systemUiVisibility =
        View.SYSTEM_UI_FLAG_LOW_PROFILE or
          View.SYSTEM_UI_FLAG_FULLSCREEN or
          View.SYSTEM_UI_FLAG_LAYOUT_STABLE or
          View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY or
          View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or
          View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
    }
  }
  private val showPart2Runnable = Runnable {
    // Delayed display of UI elements
    supportActionBar?.show()
    fullscreenContentControls.visibility = View.VISIBLE
  }
  private var isFullscreen: Boolean = false

  private val hideRunnable = Runnable { hide() }

  /**
   * Touch listener to use for in-layout UI controls to delay hiding the system UI. This is to
   * prevent the jarring behavior of controls going away while interacting with activity UI.
   */
  private val delayHideTouchListener =
    View.OnTouchListener { view, motionEvent ->
      when (motionEvent.action) {
        MotionEvent.ACTION_DOWN ->
          if (AUTO_HIDE) {
            delayedHide(AUTO_HIDE_DELAY_MILLIS)
          }

        MotionEvent.ACTION_UP -> view.performClick()
        else -> {}
      }
      false
    }

  @SuppressLint("ClickableViewAccessibility")
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    binding = ActivityExampleBinding.inflate(layoutInflater)
    setContentView(binding.root)

    supportActionBar?.setDisplayHomeAsUpEnabled(true)

    isFullscreen = true

    // Set up the user interaction to manually show or hide the system UI.
    fullscreenContent = binding.fullscreenContent
    fullscreenContent.setOnClickListener { toggle() }

    fullscreenContentControls = binding.fullscreenContentControls

    // Upon interacting with UI controls, delay any scheduled hide()
    // operations to prevent the jarring behavior of controls going away
    // while interacting with the UI.
    binding.dummyButton.setOnTouchListener(delayHideTouchListener)
  }

  override fun onPostCreate(savedInstanceState: Bundle?) {
    super.onPostCreate(savedInstanceState)

    // Trigger the initial hide() shortly after the activity has been
    // created, to briefly hint to the user that UI controls
    // are available.
    delayedHide(100)
  }

  private fun toggle() {
    if (isFullscreen) {
      hide()
    } else {
      show()
    }
  }

  private fun hide() {
    // Hide UI first
    supportActionBar?.hide()
    fullscreenContentControls.visibility = View.GONE
    isFullscreen = false

    // Schedule a runnable to remove the status and navigation bar after a delay
    hideHandler.removeCallbacks(showPart2Runnable)
    hideHandler.postDelayed(hidePart2Runnable, UI_ANIMATION_DELAY.toLong())
  }

  // Suppress DEPRECATION: systemUiVisibility is deprecated in API 30+, but required for API 26-29
  // support
  @Suppress("DEPRECATION")
  private fun show() {
    // Show the system bar
    if (Build.VERSION.SDK_INT >= 30) {
      fullscreenContent.windowInsetsController?.show(
        WindowInsets.Type.statusBars() or WindowInsets.Type.navigationBars()
      )
    } else {
      fullscreenContent.systemUiVisibility =
        View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
    }
    isFullscreen = true

    // Schedule a runnable to display UI elements after a delay
    hideHandler.removeCallbacks(hidePart2Runnable)
    hideHandler.postDelayed(showPart2Runnable, UI_ANIMATION_DELAY.toLong())
  }

  /** Schedules a call to hide() in [delayMillis], canceling any previously scheduled calls. */
  private fun delayedHide(delayMillis: Int) {
    hideHandler.removeCallbacks(hideRunnable)
    hideHandler.postDelayed(hideRunnable, delayMillis.toLong())
  }

  companion object {
    /**
     * Whether or not the system UI should be auto-hidden after [AUTO_HIDE_DELAY_MILLIS]
     * milliseconds.
     */
    private const val AUTO_HIDE = true

    /**
     * If [AUTO_HIDE] is set, the number of milliseconds to wait after user interaction before
     * hiding the system UI.
     */
    private const val AUTO_HIDE_DELAY_MILLIS = 3000

    /**
     * Some older devices needs a small delay between UI widget updates and a change of the status
     * and navigation bar.
     */
    private const val UI_ANIMATION_DELAY = 300
  }
}

```

`demo-app/without-sdk/src/main/res/drawable/ic_launcher_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:height="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108"
    android:width="108dp">
  <path
      android:fillColor="#3DDC84"
      android:pathData="M0,0h108v108h-108z" />
  <path
      android:fillColor="#00000000"
      android:pathData="M9,0L9,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M19,0L19,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M29,0L29,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M39,0L39,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M49,0L49,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M59,0L59,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M69,0L69,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M79,0L79,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M89,0L89,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M99,0L99,108"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,9L108,9"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,19L108,19"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,29L108,29"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,39L108,39"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,49L108,49"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,59L108,59"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,69L108,69"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,79L108,79"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,89L108,89"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M0,99L108,99"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M19,29L89,29"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M19,39L89,39"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M19,49L89,49"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M19,59L89,59"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M19,69L89,69"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M19,79L89,79"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M29,19L29,89"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M39,19L39,89"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M49,19L49,89"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M59,19L59,89"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M69,19L69,89"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
  <path
      android:fillColor="#00000000"
      android:pathData="M79,19L79,89"
      android:strokeColor="#33FFFFFF"
      android:strokeWidth="0.8" />
</vector>

```

`demo-app/without-sdk/src/main/res/drawable/ic_launcher_foreground.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:height="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108"
    android:width="108dp">
  <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
    <aapt:attr name="android:fillColor">
      <gradient
          android:endX="85.84757"
          android:endY="92.4963"
          android:startX="42.9492"
          android:startY="49.59793"
          android:type="linear">
        <item
            android:color="#44000000"
            android:offset="0.0" />
        <item
            android:color="#00000000"
            android:offset="1.0" />
      </gradient>
    </aapt:attr>
  </path>
  <path
      android:fillColor="#FFFFFF"
      android:fillType="nonZero"
      android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
      android:strokeColor="#00000000"
      android:strokeWidth="1" />
</vector>
```

`demo-app/without-sdk/src/main/res/layout/activity_example.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?attr/fullscreenBackgroundColor"
    android:theme="@style/ThemeOverlay.Stoic.FullscreenContainer"
    tools:context=".ExampleActivity"
    >

  <!-- The primary full-screen view. This can be replaced with whatever view
         is needed to present your content, e.g. VideoView, SurfaceView,
         TextureView, etc. -->
  <FrameLayout
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      android:fitsSystemWindows="true"
      >

    <LinearLayout
        android:id="@+id/fullscreen_content_controls"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom|center_horizontal"
        android:orientation="horizontal"
        tools:ignore="UselessParent"
        style="@style/Widget.Theme.Stoic.ButtonBar.Fullscreen"
        >

      <Button
          android:id="@+id/dummy_button"
          android:layout_width="0dp"
          android:layout_height="wrap_content"
          android:layout_weight="1"
          android:text="@string/example_button"
          style="?android:attr/buttonBarButtonStyle"
          />

    </LinearLayout>
  </FrameLayout>

  <!-- This FrameLayout insets its children based on system windows using
         android:fitsSystemWindows. -->
  <TextView
      android:id="@+id/fullscreen_content"
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      android:gravity="center"
      android:keepScreenOn="true"
      android:text="@string/example_content"
      android:textColor="?attr/fullscreenTextColor"
      android:textSize="50sp"
      android:textStyle="bold"
      />

</FrameLayout>
```

`demo-app/without-sdk/src/main/res/mipmap-anydpi/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
  <background android:drawable="@drawable/ic_launcher_background" />
  <foreground android:drawable="@drawable/ic_launcher_foreground" />
  <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`demo-app/without-sdk/src/main/res/mipmap-anydpi/ic_launcher_round.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
  <background android:drawable="@drawable/ic_launcher_background" />
  <foreground android:drawable="@drawable/ic_launcher_foreground" />
  <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`demo-app/without-sdk/src/main/res/values-night/themes.xml`:

```xml
<resources xmlns:tools="http://schemas.android.com/tools">
  <!-- Base application theme. -->
  <style name="Theme.Stoic" parent="Theme.AppCompat.Light.DarkActionBar">
    <!-- Primary brand color. -->
    <item name="colorPrimary">@color/purple_200</item>
    <item name="colorPrimaryDark">@color/purple_700</item>
    <item name="colorAccent">@color/teal_200</item>
    <!-- Customize your theme here. -->
  </style>

  <style name="ThemeOverlay.Stoic.FullscreenContainer" parent="">
    <item name="fullscreenBackgroundColor">@color/light_blue_900</item>
    <item name="fullscreenTextColor">@color/light_blue_A400</item>
  </style>
</resources>
```

`demo-app/without-sdk/src/main/res/values/attrs.xml`:

```xml
<resources>
  <declare-styleable name="FullscreenAttrs">
    <attr format="color" name="fullscreenBackgroundColor" />
    <attr format="color" name="fullscreenTextColor" />
  </declare-styleable>
</resources>
```

`demo-app/without-sdk/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <color name="purple_200">#FFBB86FC</color>
  <color name="purple_500">#FF6200EE</color>
  <color name="purple_700">#FF3700B3</color>
  <color name="teal_200">#FF03DAC5</color>
  <color name="teal_700">#FF018786</color>
  <color name="black">#FF000000</color>
  <color name="white">#FFFFFFFF</color>
  <color name="light_blue_600">#FF039BE5</color>
  <color name="light_blue_900">#FF01579B</color>
  <color name="light_blue_A200">#FF40C4FF</color>
  <color name="light_blue_A400">#FF00B0FF</color>
  <color name="black_overlay">#66000000</color>
</resources>
```

`demo-app/without-sdk/src/main/res/values/strings.xml`:

```xml
<resources>
  <string name="app_name">ExampleApp</string>
  <string name="example_button">Example Button</string>
  <string name="example_content">Stoic</string>
</resources>
```

`demo-app/without-sdk/src/main/res/values/styles.xml`:

```xml
<resources>

  <style name="Widget.Theme.Stoic.ActionBar.Fullscreen" parent="Widget.AppCompat.ActionBar">
    <item name="android:background">@color/black_overlay</item>
  </style>

  <style name="Widget.Theme.Stoic.ButtonBar.Fullscreen" parent="">
    <item name="android:background">@color/black_overlay</item>
    <item name="android:buttonBarStyle">?android:attr/buttonBarStyle</item>
  </style>
</resources>
```

`demo-app/without-sdk/src/main/res/values/themes.xml`:

```xml
<resources xmlns:tools="http://schemas.android.com/tools">
  <!-- Base application theme. -->
  <style name="Theme.Stoic" parent="Theme.AppCompat.Light.DarkActionBar">
    <!-- Primary brand color. -->
    <item name="colorPrimary">@color/purple_500</item>
    <item name="colorPrimaryDark">@color/purple_700</item>
    <item name="colorAccent">@color/teal_200</item>
    <!-- Customize your theme here. -->
  </style>

  <style name="Theme.Stoic.Fullscreen" parent="Theme.Stoic">
    <item name="android:actionBarStyle">@style/Widget.Theme.Stoic.ActionBar.Fullscreen</item>
    <item name="android:windowActionBarOverlay">true</item>
    <item name="android:windowBackground">@null</item>
  </style>

  <style name="ThemeOverlay.Stoic.FullscreenContainer" parent="">
    <item name="fullscreenBackgroundColor">@color/light_blue_600</item>
    <item name="fullscreenTextColor">@color/light_blue_A200</item>
  </style>
</resources>
```

`demo-plugin/appexitinfo/build.gradle.kts`:

```kts
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
  alias(libs.plugins.kotlin.jvm)
  alias(libs.plugins.kotlin.serialization)
}

val androidHome =
  providers.environmentVariable("ANDROID_HOME").orNull
    ?: throw GradleException("ANDROID_HOME is not set")
val androidCompileSdk = extra["stoic.android_compile_sdk"] as String

dependencies {
  implementation(kotlin("stdlib"))
  implementation(project(":target:plugin-sdk"))
  implementation(libs.kotlinx.serialization.json)
  compileOnly(files("$androidHome/platforms/android-$androidCompileSdk/android.jar"))
}

tasks.withType<KotlinCompile> { kotlinOptions { jvmTarget = "17" } }

tasks.jar {
  duplicatesStrategy = DuplicatesStrategy.EXCLUDE
  // To include all dependencies in the JAR file, uncomment the following lines:
  // from({
  //    configurations.runtimeClasspath.get().filter { it.exists() }.map { if (it.isDirectory) it
  // else zipTree(it) }
  // })
}

```

`demo-plugin/appexitinfo/src/main/kotlin/Main.kt`:

```kt
import android.app.ActivityManager
import android.app.Application
import android.app.ApplicationExitInfo
import android.content.Context
import android.os.StrictMode
import com.squareup.stoic.helpers.*
import com.squareup.stoic.jvmti.JvmtiClass
import com.squareup.stoic.jvmti.magics.*
import com.squareup.stoic.threadlocals.stoic
import java.lang.reflect.Modifier
import java.nio.charset.StandardCharsets.UTF_8
import java.text.SimpleDateFormat
import java.util.Date

fun main(args: Array<String>) {
  StrictMode.setVmPolicy(
    StrictMode.VmPolicy.Builder(StrictMode.getVmPolicy()).permitNonSdkApiUsage().build()
  )
  var errId: String? = null
  if (args.isNotEmpty()) {
    assert(args[0] == "--id")
    errId = args[1]
  }

  eprint("Searching heap for instances of android.app.Application")
  val apps = stoic.jvmti.instances(Application::class.java)
  eprint("\r\u001B[K")

  for (app in apps) {
    val activityManager = app.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager

    // Note: This API requires a manifest-declared permission.
    // TODO: Sensible error message when this isn't present (or when we're on Android 10 or below)
    val exits = activityManager.getHistoricalProcessExitReasons(null, 0, 0)
    if (errId == null) {
      printTabular(exits)
    } else {
      val epoch = decodeIdToEpoch(errId)
      val matchedExits = exits.filter { it.timestamp == epoch }
      if (matchedExits.isEmpty()) {
        eprintln("No exit found matching $errId")
      } else {
        for (exit in matchedExits) {
          println(formatDetailedAppExitInfo(exit))
        }
      }
    }
  }
}

fun printTabular(exits: List<ApplicationExitInfo>) {
  val headers = listOf("id", "timestamp", "process-name", "reason", "sub-reason", "importance")
  val rows = mutableListOf<List<String>>()
  for (exit in exits) {
    val reasonString =
      getConstantNameByValue(ApplicationExitInfo::class.java, "REASON_", exit.reason)

    val importanceString =
      getConstantNameByValue(
        ActivityManager.RunningAppProcessInfo::class.java,
        "IMPORTANCE_",
        exit.importance,
      )

    val subReasonString =
      try {
        getConstantNameByValue(
          ApplicationExitInfo::class.java,
          "SUBREASON_",
          exit.m["getSubReason"]() as Int,
        )
      } catch (e: ReflectiveOperationException) {
        "<unavailable>"
      }

    val epoch = exit.timestamp
    val errId = encodeEpochAsId(epoch)
    val processName = exit.processName
    val timeString = SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(Date(epoch))
    rows.add(
      listOf(errId, timeString, processName, reasonString, subReasonString, importanceString)
    )
  }

  val columnWidths = headers.map { it.length }.toMutableList()

  for (row in rows) {
    row.forEachIndexed { index, value ->
      if (value.length > columnWidths[index]) {
        columnWidths[index] = value.length
      }
    }
  }

  val separatorLine = columnWidths.joinToString(separator = "   ") { "-".repeat(it) }
  val formatString = columnWidths.joinToString(separator = "   ") { "%-${it}s" }

  println(formatString.format(*headers.toTypedArray()))
  println(separatorLine)

  for (row in rows) {
    println(formatString.format(*row.toTypedArray()))
  }
}

// These characters are easily distinguishable, and they don't count as separators in iTerm, so you
// can double-click to copy/paste
const val codecAlphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz~_-+./"

fun encodeEpochAsId(epoch: Long): String {
  assert(codecAlphabet.length == 64) // 6 bits
  val sb = StringBuilder()
  var remaining = epoch
  while (remaining > 0) {
    // Get 6 bits
    val current = (remaining and 0x3f).toInt()
    sb.append(codecAlphabet[current])
    remaining = (remaining shr 6)
  }

  val id = sb.toString().reversed()
  // eprintln("$epoch -> $id")
  return id
}

fun decodeIdToEpoch(id: String): Long {
  assert(codecAlphabet.length == 64) // 6 bits
  var epoch: Long = 0
  for (c in id) {
    val index = codecAlphabet.indexOf(c).toLong()
    epoch = (epoch shl 6) or index
  }

  // eprintln("Decoded $id -> $epoch")
  return epoch
}

fun getConstantNameByValue(
  constantsClass: Class<*>,
  fieldPrefix: String,
  value: Int,
  includePrefix: Boolean = false,
): String {
  val valueToNameMap =
    JvmtiClass[constantsClass]
      .declaredFields
      .filter { it.signature == "I" }
      .filter { it.modifiers and Modifier.STATIC != 0 }
      .filter { it.modifiers and Modifier.FINAL != 0 }
      .filter { it.name.startsWith(fieldPrefix) }
      .associate { it.get(null) to it.name }

  val result = valueToNameMap[value] ?: return "Unknown constant value: $value"
  return if (includePrefix) {
    result
  } else {
    result.drop(fieldPrefix.length)
  }
}

fun formatDetailedAppExitInfo(exit: ApplicationExitInfo): String {
  val reasonString = getConstantNameByValue(ApplicationExitInfo::class.java, "REASON_", exit.reason)

  val subReasonString =
    try {
      getConstantNameByValue(
        ApplicationExitInfo::class.java,
        "SUBREASON_",
        exit.m["getSubReason"]() as Int,
      )
    } catch (e: ReflectiveOperationException) {
      "<unavailable>"
    }

  val importanceString =
    getConstantNameByValue(
      ActivityManager.RunningAppProcessInfo::class.java,
      "IMPORTANCE_",
      exit.importance,
    )

  val epoch = exit.timestamp
  val processName = exit.processName
  val timeString = SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(Date(epoch))

  val packageList =
    try {
      exit.m["getPackageList"]()
    } catch (e: ReflectiveOperationException) {
      arrayOf("<unavailable>")
    }

  val packageListString =
    if (packageList == null) {
      "null"
    } else {
      (packageList as Array<*>).joinToString(" ")
    }

  // TODO: Encode this to base64
  val processStateSummary = exit.processStateSummary

  val detailed =
    """
    Process Name: $processName
    Timestamp: $timeString (epoch: $epoch)
    Reason: $reasonString
    Sub-reason: $subReasonString
    Importance: $importanceString
    Description: ${exit.description}
    Status: ${exit.status}
    Pss: ${exit.pss}
    Rss: ${exit.rss}
    Pid: ${exit.pid}
    Real Uid: ${exit.realUid}
    Package Uid: ${exit.packageUid}
    Defining Uid: ${exit.definingUid}
    Package List: $packageListString
    Process State Summary: $processStateSummary
  """
      .trimIndent()

  val trace =
    when (exit.reason) {
      ApplicationExitInfo.REASON_ANR -> {
        exit.traceInputStream?.bufferedReader(UTF_8).use { it?.readText()?.trim() }
      }
      ApplicationExitInfo.REASON_CRASH_NATIVE -> {
        "TODO: Use https://android.googlesource.com/platform/system/core/+/refs/heads/master/debuggerd/proto/tombstone.proto to parse com.squareup.stoic.trace.trace-input-stream"
      }
      else -> ""
    }

  return "$detailed\n\n$trace"
}

```

`demo-plugin/breakpoint/build.gradle.kts`:

```kts
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
  alias(libs.plugins.kotlin.jvm)
  alias(libs.plugins.kotlin.serialization)
}

repositories { mavenCentral() }

val androidHome =
  providers.environmentVariable("ANDROID_HOME").orNull
    ?: throw GradleException("ANDROID_HOME is not set")
val androidCompileSdk = extra["stoic.android_compile_sdk"] as String

dependencies {
  implementation(kotlin("stdlib"))
  implementation(project(":target:plugin-sdk"))
  implementation(libs.kotlinx.serialization.json)
  compileOnly(files("$androidHome/platforms/android-$androidCompileSdk/android.jar"))
}

tasks.withType<KotlinCompile> { kotlinOptions { jvmTarget = "17" } }

tasks.jar { duplicatesStrategy = DuplicatesStrategy.EXCLUDE }

```

`demo-plugin/breakpoint/src/main/kotlin/Main.kt`:

```kt
import EvalTime.ON_ENTRY
import EvalTime.ON_EXIT
import com.squareup.stoic.Stack
import com.squareup.stoic.helpers.eprintln
import com.squareup.stoic.helpers.exit
import com.squareup.stoic.helpers.println
import com.squareup.stoic.jvmti.JvmtiMethod
import com.squareup.stoic.jvmti.LocalVariable
import com.squareup.stoic.threadlocals.jvmti
import java.util.concurrent.CountDownLatch

fun usage() {
  eprintln("Usage: stoic breakpoint [options] signature1 [options] signature2 ...")
  eprintln("Each signature should adhere to the JVM signature spec.")
  eprintln("e.g. 'java/util/Map.get(Ljava/util/Object;)Ljava/util/Object;'")
  eprintln("you will probably need to quote so that your shell doesn't interpret treat the")
  eprintln("';' / '(' / ')' chars specially.")
  exit(1)
}

enum class EvalTime {
  DEFAULT,
  ON_ENTRY,
  ON_EXIT,
}

enum class PrintType {
  DEFAULT,
  TO_STRING,
  IDENTITY_HASH,
}

data class PrintDesc(
  val expr: String,
  val evalTime: EvalTime = EvalTime.DEFAULT,
  val printType: PrintType = PrintType.DEFAULT,
)

data class PrintSpec(
  // null means return value
  val localVariable: LocalVariable<*>?,
  val evalTime: EvalTime,
  val printType: PrintType,
)

data class BpDesc(val sig: String, val dumpStack: Boolean, val printDescs: List<PrintDesc>)

data class BpSpec(
  val method: JvmtiMethod,
  val dumpStack: Boolean,
  val hasOnExit: Boolean,
  val printSpecs: List<PrintSpec>,
)

fun main(args: Array<String>) {
  if (args.isEmpty()) {
    usage()
  }

  var i = -1
  val bpDescs = mutableListOf<BpDesc>()
  val printDescs = mutableListOf<PrintDesc>()
  var dumpStack = false
  while (++i < args.size) {
    val arg = args[i]
    if (!arg.startsWith("-")) {
      bpDescs.add(BpDesc(arg, dumpStack = dumpStack, printDescs = printDescs.toList()))
      dumpStack = false
      printDescs.clear()
      continue
    }

    when (arg) {
      "--stack",
      "-s" -> dumpStack = true
      "-p" -> {
        val expr = args[++i]
        printDescs.add(PrintDesc(expr))
      }
      else -> {
        eprintln("Unrecognized option: $arg")
        exit(1)
      }
    }
  }

  val bpSpecs =
    bpDescs.map { bpDesc ->
      val method = JvmtiMethod.bySig(bpDesc.sig)
      val printSpecs =
        bpDesc.printDescs.flatMap { printDesc ->
          when (printDesc.expr) {
            "*" -> {
              val evalTime =
                if (printDesc.evalTime == EvalTime.DEFAULT) {
                  ON_ENTRY
                } else {
                  printDesc.evalTime
                }
              method.arguments.map { PrintSpec(it, evalTime, printDesc.printType) }
            }
            "return" -> {
              check(printDesc.evalTime != ON_ENTRY)
              listOf(PrintSpec(null, ON_EXIT, printDesc.printType))
            }
            else -> {
              val evalTime =
                if (printDesc.evalTime == EvalTime.DEFAULT) {
                  ON_ENTRY
                } else {
                  printDesc.evalTime
                }
              listOf(
                PrintSpec(method.argumentByName<Any>(printDesc.expr), evalTime, printDesc.printType)
              )
            }
          }
        }
      val hasOnExit = printSpecs.any { it.evalTime == ON_EXIT }
      BpSpec(method, bpDesc.dumpStack, hasOnExit, printSpecs)
    }

  for (bpSpec in bpSpecs) {
    jvmti.breakpoint(bpSpec.method.startLocation) { entryFrame ->
      val values = mutableListOf<String>()
      for (printSpec in bpSpec.printSpecs.filter { it.evalTime == ON_ENTRY }) {
        val str = entryFrame.get(printSpec.localVariable!!).toString()
        values.add(str)
      }

      if (bpSpec.hasOnExit) {
        // We need to wait until exit to print any values

        entryFrame.onExit { exitFrame, returnValue, wasPoppedByException ->
          for (printSpec in bpSpec.printSpecs.filter { it.evalTime == ON_EXIT }) {
            val str =
              if (printSpec.localVariable != null) {
                exitFrame.get(printSpec.localVariable).toString()
              } else {
                returnValue?.toString() ?: "null"
              }
            values.add(str)
          }
          println("${bpSpec.method.name} ${values.joinToString(" ")}")
          if (bpSpec.dumpStack) {
            println(Stack(exitFrame.stackTrace).stackTraceToString())
          }
        }
      } else {
        // We can print values now
        println("${bpSpec.method.name} ${values.joinToString(" ")}")
        if (bpSpec.dumpStack) {
          println(Stack(entryFrame.stackTrace).stackTraceToString())
        }
      }
    }
  }

  // Log breakpoints until CTRL+C
  eprintln("Waiting for breakpoints to be hit (CTRL-C to abort)")
  CountDownLatch(1).await()
}

```

`demo-plugin/crasher/build.gradle.kts`:

```kts
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
  alias(libs.plugins.kotlin.jvm)
  alias(libs.plugins.kotlin.serialization)
}

repositories { mavenCentral() }

val androidHome =
  providers.environmentVariable("ANDROID_HOME").orNull
    ?: throw GradleException("ANDROID_HOME is not set")
val androidCompileSdk = extra["stoic.android_compile_sdk"] as String

dependencies {
  implementation(kotlin("stdlib"))
  implementation(project(":target:plugin-sdk"))
  implementation(libs.kotlinx.serialization.json)
  compileOnly(files("$androidHome/platforms/android-$androidCompileSdk/android.jar"))
}

tasks.withType<KotlinCompile> { kotlinOptions { jvmTarget = "17" } }

tasks.jar { duplicatesStrategy = DuplicatesStrategy.EXCLUDE }

```

`demo-plugin/crasher/src/main/kotlin/Main.kt`:

```kt
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import com.squareup.stoic.helpers.*
import com.squareup.stoic.threadlocals.stoic
import java.util.concurrent.CountDownLatch

/** A Stoic plugin to inject errors into a running process */
@Suppress("unused")
fun main(args: Array<String>) {
  if (args.size != 1) {
    usage(1)
  }

  // TODO: support other error types
  when (args[0]) {
    "anr" -> injectAnr()
    "art-oom" -> injectArtOom()
    "error" -> injectMainThreadError()
    "background-error" -> injectBackgroundThreadError()
    else -> usage(1)
  }
}

fun usage(exitCode: Int) {
  eprintln("stoic crasher [anr|art-oom|error|background-error]")
  exit(exitCode)
}

fun injectMainThreadError() {
  stoic.runOnLooper(Looper.getMainLooper(), null) {
    eprintln("Injecting main thread error...")
    throw Exception("This is a main thread error.")
  }
}

/**
 * This creates a HandlerThread named "injected-error". Post a message to the HandlerThread that
 * will throw an exception. This will cause the thread to crash.
 */
fun injectBackgroundThreadError() {
  HandlerThread("injected-error").also {
    it.start()
    stoic.runOnLooper(it.looper, null) {
      eprintln("Injecting background thread error...")
      throw Exception("This is a background thread error.")
    }
  }
}

/**
 * This injects an ART OutOfMemory error. The naming art-oom is specific to avoid confusion with
 * lmkd-style OOMs, which are an entirely different class of problem.
 */
// TODO: provide options for single large allocation vs multiple small allocations
// TODO: provide options for main-thread
fun injectArtOom() {
  thread {
    val listOfArrays = mutableListOf<ByteArray>()
    while (true) {
      listOfArrays.add(ByteArray(Int.MAX_VALUE))
      val total = Int.MAX_VALUE.toLong() * listOfArrays.size / (1024 * 1024 * 1024)
      // We print a hash to prevent any possible compiler optimizations from being applied (not that
      // I've seen any).
      eprintln("Total allocated: $total GB. Hash=${listOfArrays.hashCode()}")
    }
  }
}

fun injectAnr() {

  // We acquire two locks from two different threads, opposite ordering, to cause a deadlock
  // This is the nicest type of ANR to debug.
  eprintln("Acquiring locks to hang the main thread...")
  val lock1 = Any()
  val latch1 = CountDownLatch(1)
  val lock2 = Any()
  val latch2 = CountDownLatch(1)
  HandlerThread("ANR Thread").also {
    it.start()
    Handler(it.looper).post {
      synchronized(lock1) {
        latch2.countDown()
        latch1.await()
        synchronized(lock2) { throw Exception("This shouldn't be possible") }
      }
    }
  }
  Handler(Looper.getMainLooper()).post {
    synchronized(lock2) {
      latch1.countDown()
      latch2.await()
      synchronized(lock1) { throw Exception("This shouldn't be possible") }
    }
  }

  eprintln("Main thread hung. Send input to trigger ANR detection.")

  // We can't run `monkey` from inside our process.
  // TODO: It'd be nice to have the ability to run preamble/postamble plugin code on the host
  // This would give us the ability trigger ANR detection automatically.
}

```

`demo-plugin/helloworld/build.gradle.kts`:

```kts
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
  alias(libs.plugins.kotlin.jvm)
  alias(libs.plugins.kotlin.serialization)
}

repositories { mavenCentral() }

val androidHome =
  providers.environmentVariable("ANDROID_HOME").orNull
    ?: throw GradleException("ANDROID_HOME is not set")
val androidCompileSdk = extra["stoic.android_compile_sdk"] as String

dependencies {
  implementation(kotlin("stdlib"))
  implementation(project(":target:plugin-sdk"))
  implementation(libs.kotlinx.serialization.json)
  compileOnly(files("$androidHome/platforms/android-$androidCompileSdk/android.jar"))
}

tasks.withType<KotlinCompile> { kotlinOptions { jvmTarget = "17" } }

tasks.jar { duplicatesStrategy = DuplicatesStrategy.EXCLUDE }

```

`demo-plugin/helloworld/src/main/kotlin/Main.kt`:

```kt
import android.util.Log
import com.squareup.stoic.helpers.*

// This is a demo stoic plugin
// You can make your own by copying the plugin_helloworld directory and adding a new entry
// in settings.gradle
//
// Each plugin module name must begin with the prefix `plugin_`
//
// Your plugin-name is everything after `plugin_`. For example the plugin-name
// for the module plugin_helloworld is helloworld.
// You can invoke your plugin with `stoic <pkg> <plugin-name>`
// So you can invoke this plugin with `stoic <pkg> helloworld`
//
// Stoic looks for a default class named MainKt with a method named `main`.
// The signature must match the one here.
// You can write to stdout/stderr (or read from stdin - in theory - I haven't tested that) with
// System.in/out/err. When stoic loads they are setup to be thread-locals.
//
// The return value of you pluginMain will be the exit code of the stoic command
// (assuming you don't crash - try not to!)
fun main(args: Array<String>) {
  Log.i("helloworld", "Hello logcat")
  println("Hello world ${args.toList()}")
}

```

`docs/APPEXITINFO.md`:

```md
# `appexitinfo` Plugin

The `appexitinfo` plugin provides command-line access to the ApplicationExitInfo API.

```
% stoic --pkg com.example appexitinfo
id        timestamp             process-name   reason           sub-reason   importance
-------   -------------------   ------------   --------------   ----------   ----------
R/j8rML   2024-06-05 13:37:36   com.example    USER_REQUESTED   FORCE_STOP   FOREGROUND
R/j8YpU   2024-06-05 13:36:24   com.example    ANR              UNKNOWN      FOREGROUND
R/j8PXn   2024-06-05 13:35:46   com.example    USER_REQUESTED   FORCE_STOP   FOREGROUND
R/j883J   2024-06-05 13:34:43   com.example    USER_REQUESTED   FORCE_STOP   FOREGROUND
R/j7cfu   2024-06-05 13:32:18   com.example    USER_REQUESTED   FORCE_STOP   FOREGROUND
R/j7b9q   2024-06-05 13:32:12   com.example    USER_REQUESTED   FORCE_STOP   FOREGROUND
R/j7EH_   2024-06-05 13:30:46   com.example    USER_REQUESTED   FORCE_STOP   FOREGROUND
R/j78HJ   2024-06-05 13:30:22   com.example    USER_REQUESTED   FORCE_STOP   FOREGROUND
R/j6aBx   2024-06-05 13:27:46   com.example    USER_REQUESTED   FORCE_STOP   FOREGROUND
R/iU4mq   2024-06-05 10:22:15   com.example    USER_REQUESTED   FORCE_STOP   FOREGROUND
R/iT+4+   2024-06-05 10:21:48   com.example    USER_REQUESTED   FORCE_STOP   FOREGROUND
R/iTTkH   2024-06-05 10:19:27   com.example    USER_REQUESTED   FORCE_STOP   FOREGROUND
R/i19~F   2024-06-05 08:24:38   com.example    USER_REQUESTED   FORCE_STOP   FOREGROUND
R/h/hs_   2024-06-05 08:22:27   com.example    USER_REQUESTED   FORCE_STOP   FOREGROUND
R/f9hao   2024-06-04 19:02:53   com.example    USER_REQUESTED   FORCE_STOP   FOREGROUND
R/f9PHs   2024-06-04 19:01:39   com.example    CRASH_NATIVE     UNKNOWN      FOREGROUND
```
This calls ActivityManager.getHistoricalProcessExitReasons from within
`com.example`'s process (without any Stoic-related code integrated into the
`com.example` APK) and prints the results to stdout. You can then get
additional information about a particular exit with
`--id`. Example:
```
% stoic --pkg com.example appexitinfo --id R/j8YpU
Process Name: com.example
Timestamp: 2024-06-05 13:36:24 (epoch: 1717619784667)
Reason: ANR
Sub-reason: UNKNOWN
Importance: FOREGROUND
Description: user request after error: Input dispatching timed out (c694b07 com.example/com.example.ExampleActivity (server) is not responding. Waited 5008ms for MotionEvent(deviceId=3, eventTime=624650586000, source=TOUCHSCREEN | STYLUS, displayId=0, action=DOWN, actionButton=0x00000000, flags=0x00000000, metaState=0x00000000, buttonState=0x00000000, classification=NONE, edgeFlags=0x00000000, xPrecision=12.8, yPrecision=20.5, xCursorPosition=nan, yCursorPosition=nan, pointers=[0: (1194.9, 989.9)]), policyFlags=0x62000000)
Status: 0
Pss: 40496
Rss: 148456
Pid: 5645
Real Uid: 10192
Package Uid: 10192
Defining Uid: 10192
Package List: null
Process State Summary: null

Subject: Input dispatching timed out (c694b07 com.example/com.example.ExampleActivity (server) is not responding. Waited 5008ms for MotionEvent(deviceId=3, eventTime=624650586000, source=TOUCHSCREEN | STYLUS, displayId=0, action=DOWN, actionButton=0x00000000, flags=0x00000000, metaState=0x00000000, buttonState=0x00000000, classification=NONE, edgeFlags=0x00000000, xPrecision=12.8, yPrecision=20.5, xCursorPosition=nan, yCursorPosition=nan, pointers=[0: (1194.9, 989.9)]), policyFlags=0x62000000)
RssHwmKb: 146168
RssKb: 146164
RssAnonKb: 70484
RssShmemKb: 880
VmSwapKb: 0


--- CriticalEventLog ---
capacity: 20
timestamp_ms: 1717619782086
window_ms: 300000

----- dumping pid: 5645 at 629666

----- pid 5645 at 2024-06-05 13:36:22.075736591-0700 -----
Cmd line: com.example
Build fingerprint: 'google/sdk_gphone64_arm64/emu64a:14/UE1A.230829.036.A1/11228894:userdebug/dev-keys'
ABI: 'arm64'
Build type: optimized
suspend all histogram:	Sum: 1.778ms 99% C.I. 0.101us-658.880us Avg: 63.500us Max: 684us
DALVIK THREADS (22):
"main" prio=5 tid=1 Blocked
  | group="main" sCount=1 ucsCount=0 flags=1 obj=0x732ffdd8 self=0xb400006de4a196f0
  | sysTid=5645 nice=-10 cgrp=top-app sched=0/0 handle=0x6fce9a94f8
  | state=S schedstat=( 596731496 289036089 386 ) utm=48 stm=10 core=2 HZ=100
  | stack=0x7ff87d8000-0x7ff87da000 stackSize=8188KB
  | held mutexes=
  at MainKt.injectAnr$lambda$6(Main.kt:42)
  - waiting to lock <0x045af028> (a java.lang.Object) held by thread 3
  - locked <0x06d4a141> (a java.lang.Object)
  at MainKt.$r8$lambda$rlUPJ5n02yVEmNeC3rFef67j_mg(unavailable:0)
  at MainKt$$ExternalSyntheticLambda1.run(unavailable:8)
  at android.os.Handler.handleCallback(Handler.java:958)
  at android.os.Handler.dispatchMessage(Handler.java:99)
  at android.os.Looper.loopOnce(Looper.java:205)
  at android.os.Looper.loop(Looper.java:294)
  at android.app.ActivityThread.main(ActivityThread.java:8177)
  at java.lang.reflect.Method.invoke(Native method)
  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:552)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:971)

"ANR Thread" daemon prio=1 tid=3 Blocked
  | group="main" sCount=1 ucsCount=0 flags=1 obj=0x132c1258 self=0xb400006de4a20630
  | sysTid=5829 nice=0 cgrp=top-app sched=0/0 handle=0x6cf36ffcb0
  | state=S schedstat=( 634586 44500 3 ) utm=0 stm=0 core=3 HZ=100
  | stack=0x6cf35fc000-0x6cf35fe000 stackSize=1039KB
  | held mutexes=
  at MainKt.injectAnr$lambda$3$lambda$2(Main.kt:32)
  - waiting to lock <0x06d4a141> (a java.lang.Object) held by thread 1
  - locked <0x045af028> (a java.lang.Object)
  at MainKt.$r8$lambda$Z0QSxIY0MznwMokxVXsvpJGVa9s(unavailable:0)
  at MainKt$$ExternalSyntheticLambda0.run(unavailable:8)
  at android.os.Handler.handleCallback(Handler.java:958)
  at android.os.Handler.dispatchMessage(Handler.java:99)
  at android.os.Looper.loopOnce(Looper.java:205)
  at android.os.Looper.loop(Looper.java:294)
  at android.os.HandlerThread.run(HandlerThread.java:67)

...
```


```

`docs/ARCHITECTURE.md`:

```md
# Architecture

Stoic is IPC and RPC for debugging. It trades security for flexibility. Don't run it in production.

Instead of requiring a pre-established server, Stoic injects a server into
running processes via JVMTI (you can use the app-sdk for non-debuggable apps).
Instead of calling predefined functions, you send code to execute.

Communication is bidirectional and multiplexed—stdin/stdout/stderr work
normally. You get access to JVMTI debugging APIs.

```
     Laptop          |        Android Process
  +---------+        |        +---------+
  |  host   | <------|------> | target  |
  +---------+        |        +---------+
```

Your laptop is a client that talks to the server (injected into the app).

## Running a Plugin

1. Inject server into target process
2. Server signals ready
3. Host sends StartPlugin request (plugin name + timestamp)
4. If plugin missing, host sends LoadPlugin with APK contents
5. Multiplexed I/O flows (stdin/stdout/stderr)
6. Plugin finishes, sends PluginFinished
7. Server stays alive for faster subsequent runs

## Injection

Uses JVMTI's `attach-agent` ([docs](https://source.android.com/docs/core/runtime/art-ti)). Works on non-rooted devices via `run-as`.

## Communication

Unix domain sockets. Android won't let shell and package users talk directly,
but `adb forward` allows our laptop to talk directly to the package:

```bash
adb forward tcp:0 localabstract:/stoic/...
```

```

`docs/DEBUG.md`:

```md
# Debugging Stoic

## Check if Stoic is running

```bash
stoic stoic-status
```

Shows protocol version, attach method (JVMTI/SDK), and available embedded plugins.

## View logs

Stoic logs to Android's logcat with tag "stoic":

```bash
adb logcat -s stoic:*
```

For verbose output, use `--verbose` or `--debug`:

```bash
stoic --verbose your-plugin
stoic --debug your-plugin
```

## Restart the app

Sometimes issues can be fixed by restarting the app and retrying:

```bash
stoic --restart your-plugin ...
```

### JVMTI attach fails

JVMTI only works with debuggable apps. For non-debuggable apps you still might
be able to attach if you have root.

```bash
stoic --attach-via=jvmti-root your-plugin
```

Alternatively, you can integrate the app-sdk into your app and attach via that
to avoid using debug APIs altogether.

```bash
stoic --attach-via=sdk your-plugin
```

```

`docs/DEVELOP.md`:

```md
# Developing with Stoic

## Creating a plugin

```bash
stoic plugin --new my-plugin
```

This creates a plugin in `~/.config/stoic/plugin/my-plugin/`. Edit `src/main/kotlin/Main.kt`:

```kotlin
import com.squareup.stoic.helpers.*

fun main(args: Array<String>) {
    println("Hello from my-plugin!")
    println("Args: ${args.joinToString()}")
}
```

Run it:

```bash
stoic my-plugin arg1 arg2
```

Stoic builds and runs your plugin automatically.

## Embedding plugins in your app

Add the plugin SDK to your app:

```kotlin
// build.gradle.kts
dependencies {
    implementation("com.squareup.stoic:stoic-plugin-sdk:$stoicVersion")
}
```

Create a plugin:

```kotlin
package com.example.plugins

import android.content.Context
import com.squareup.stoic.helpers.*
import com.squareup.stoic.plugin.StoicPlugin

class DebugPlugin(private val context: Context) : StoicPlugin {
    override fun run(args: List<String>): Int {
        println("Package: ${context.packageName}")
        println("Debug command: ${args.firstOrNull()}")

        // Access app resources, databases, etc.
        val sharedPrefs = context.getSharedPreferences("app_prefs", Context.MODE_PRIVATE)

        return 0
    }
}
```

Register it in a config class:

```kotlin
package com.example.plugins

import android.content.Context
import com.squareup.stoic.plugin.StoicConfig
import com.squareup.stoic.plugin.StoicPlugin

class AppStoicConfig : StoicConfig {
    override fun getPlugins(context: Context): Map<String, StoicPlugin> {
        return mapOf(
            "debug" to DebugPlugin(context)
        )
    }
}
```

Declare it in AndroidManifest.xml:

```xml
<application>
    <meta-data
        android:name="com.squareup.stoic.config"
        android:value="com.example.plugins.AppStoicConfig" />
</application>
```

Run it:

```bash
stoic com.example.app debug
```

## Using the app SDK

The app SDK lets you attach to non-debuggable apps via BroadcastReceiver.

Add the dependency:

```kotlin
// build.gradle.kts
dependencies {
    implementation("com.squareup.stoic:stoic-app-sdk:$stoicVersion")
}
```

Now you can use SDK mode:

```bash
stoic --attach-via=sdk your-plugin
```

This works with release builds and doesn't require the debuggable flag.

## Plugin SDK reference

### Output

Use these instead of `System.out` and `System.err`:

```kotlin
import com.squareup.stoic.helpers.println
import com.squareup.stoic.helpers.eprintln

println("To stdout")
eprintln("To stderr")
```

### Exit codes

Follow the shell convention and return 0 for success, non-zero for failure:

```kotlin
fun main(args: Array<String>): Int {
    if (args.isEmpty()) {
        eprintln("Usage: my-plugin <arg>")
        return 1
    }
    return 0
}
```

### Environment variables

```kotlin
import com.squareup.stoic.threadlocals.stoic

val value = stoic.getenv("MY_VAR")
```

Set them when invoking:

```bash
stoic --env MY_VAR=value your-plugin
```

## Examples

See `demo-app/with-sdk/src/main/java/com/squareup/stoic/demoapp/withsdk/plugins/` for working examples.

```

`docs/JVMTI.md`:

```md
# JVMTI

The com.squareup.stoic.jvmti package implements something approximating JDI,
but instead of being implemented on JDWP it is implemented directly on top of
JVMTI.

It is hoped by using the structure of JDI I avoid running into any design landmines. Since we are
running in-process, many aspects of JDI can be simplified, so I didn't implement JDI interfaces
directly.

## JVMTI/JDI notes
Unlike JDI, there are no mirrors - i.e. https://docs.oracle.com/javase/8/docs/jdk/api/jpda/jdi/com/sun/jdi/class-use/Mirror.html
and https://docs.oracle.com/javase/8/docs/jdk/api/jpda/jdi/com/sun/jdi/Value.html - Since we are
running in-process, we can return values directly. This is simpler.

Raw JVMTI functionality is exposed as static JNI functions on com.square.stoic.jvmti.VirtualMachine.
`nativeCallback*` methods are JVMTI callbacks invoked from native. All other `native*` methods are
JVMTI APIs, with some differences:
1. Instead of exposing tagging to Kotlin/Java, I've instead of opted to expose higher level APIs
   built on top of tagging - e.g. nativeInstances (note: there are currently race conditions here
   - we should acquire a lock while tagging since the tags are global)
2. Many JVMTI APIs take a `depth` parameter - the count of frames between the current frame of the
   thread and the frame we wish to access. This doesn't make sense when calling APIs from
   Kotlin/Java because the depth of frame is not stable. Instead, we use `height` - the count of
   frames from the bottom of the stack to frame we wish to access. The implementation computes the
   depth on-demand and uses this when calling JVMTI. e.g. `nativeGetLocalObject`
3. Callbacks are invoked on the thread that generates them. 
4. Since everything is in-process, there can only be one VirtualMachine, so its a singleton.

## JVMTI/JPDA links
https://www.pnfsoftware.com/blog/debugging-android-apps-on-android-pie-and-above/
https://docs.oracle.com/javase/8/docs/technotes/guides/jpda/jdwp-spec.html
https://docs.oracle.com/javase/8/docs/platform/jpda/jdwp/jdwp-protocol.html

## JDWP implementation on top of JVMTI. e.g. setBreakpoint:
https://cs.android.com/android/platform/superproject/main/+/d2f87bde534633e17d5c45f908094d5af66ed7e8:external/oj-libjdwp/src/share/back/eventFilter.c;l=1020

https://docs.oracle.com/javase/8/docs/jdk/api/jpda/jdi/

## JDI implementation on top of JDWP
https://cs.android.com/android/platform/superproject/main/+/main:external/oj-libjdwp/src/share/classes/com/sun/tools/jdi/
https://cs.android.com/android/platform/superproject/main/+/main:out/soong/.intermediates/external/oj-libjdwp/jdwp_generated_java/gen/JDWP.java

### e.g. How JDI implements BreakpointRequest.addInstanceFilter
https://docs.oracle.com/javase/8/docs/jdk/api/jpda/jdi/com/sun/jdi/request/BreakpointRequest.html#addInstanceFilter-com.sun.jdi.ObjectReference-
https://cs.android.com/android/platform/superproject/main/+/main:external/oj-libjdwp/src/share/classes/com/sun/tools/jdi/EventRequestManagerImpl.java;l=304

### How JDWP implements it
https://cs.android.com/android/platform/superproject/main/+/main:external/oj-libjdwp/src/share/back/eventFilter.c;l=465
(eventFilterRestricted_passesFilter is called from event_callback which in turn is called by
cbBreakpoint and other actual JVMTI callbacks)
https://cs.android.com/android/platform/superproject/main/+/main:external/oj-libjdwp/src/share/back/eventHandler.c;l=656

```

`docs/USR_CONFIG.md`:

```md
# Stoic config
Stoic configuration lives in `~/.config/stoic`. This directory will be
automatically created when you run `stoic plugin --new <plugin-name>`.

```

`gradle.properties`:

```properties
org.gradle.java.installations.auto-download=true

# Gradle daemon memory settings
# Native compilation requires more memory
org.gradle.jvmargs=-Xmx2048m -XX:MaxMetaspaceSize=768m

# Android SDK configuration
android.compileSdk=35
android.minSdk=26
android.targetSdk=34
android.buildToolsVersion=35.0.1
android.ndkVersion=26.3.11579264

```

`gradle/libs.versions.toml`:

```toml
[versions]
clikt = "5.0.3"
kotlin = "2.1.21"
androidGradle = "8.9.0"
jvmTarget = "17"
vanniktechMavenPublish = "0.34.0"
spotless = "7.0.2"

[libraries]
clikt = { module = "com.github.ajalt.clikt:clikt", version.ref = "clikt" }
jetbrains-kotlin-reflect = { module = "org.jetbrains.kotlin:kotlin-reflect" }
kotlin-reflect = { module = "org.jetbrains.kotlin:kotlin-reflect" }
kotlinx-serialization-json = { module = "org.jetbrains.kotlinx:kotlinx-serialization-json", version = "1.6.3" }
vanniktech-maven-publish-plugin = { module = "com.vanniktech:gradle-maven-publish-plugin", version.ref = "vanniktechMavenPublish" }

[plugins]
kotlin-jvm = { id = "org.jetbrains.kotlin.jvm", version.ref = "kotlin" }
kotlin-serialization = { id = "org.jetbrains.kotlin.plugin.serialization", version.ref = "kotlin" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
android-application = { id = "com.android.application", version.ref = "androidGradle" }
android-library = { id = "com.android.library", version.ref = "androidGradle" }
application = { id = "application" }
vanniktech-maven-publish-base = { id = "com.vanniktech.maven.publish.base", version.ref = "vanniktechMavenPublish" }
spotless = { id = "com.diffplug.spotless", version.ref = "spotless" }

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-all.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`gradlew`:

```
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd "${APP_HOME:-./}" > /dev/null && pwd -P ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`host/main/build.gradle.kts`:

```kts
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
  alias(libs.plugins.application)
  alias(libs.plugins.kotlin.jvm)
  alias(libs.plugins.kotlin.serialization)
  id("org.graalvm.buildtools.native") version ("0.10.6")
  kotlin("kapt")
}

repositories { mavenCentral() }

dependencies {
  implementation(libs.kotlinx.serialization.json)
  implementation(libs.clikt)
  implementation(kotlin("stdlib"))
  implementation(project(":protocol"))
  implementation(project(":internal:tool:jar-to-apk-preserve-manifest"))
}

tasks.withType<KotlinCompile> { kotlinOptions { jvmTarget = "17" } }

application { mainClass.set("com.squareup.stoic.host.main.HostMainKt") }

graalvmNative {
  binaries {
    named("main") {
      //
      // Fixes: Error: Classes that should be initialized at run time got initialized during image
      // building:
      //   kotlin.DeprecationLevel was unintentionally initialized at build time. To see why
      // kotlin.DeprecationLevel got initialized use
      // --trace-class-initialization=kotlin.DeprecationLevel
      //
      buildArgs.add("--initialize-at-build-time=kotlin.DeprecationLevel")

      imageName.set("stoic")
      mainClass.set("com.squareup.stoic.host.main.HostMainKt")
    }
  }
}

tasks.jar {
  duplicatesStrategy = DuplicatesStrategy.EXCLUDE
  manifest { attributes("Main-Class" to "com.squareup.stoic.host.main.HostMainKt") }
  // To include all dependencies in the JAR file, uncomment the following lines:
  from({
    configurations.runtimeClasspath
      .get()
      .filter { it.exists() }
      .map { if (it.isDirectory) it else zipTree(it) }
  })
}

```

`host/main/src/main/kotlin/com/squareup/stoic/host/AttachVia.kt`:

```kt
package com.squareup.stoic.host

enum class AttachVia(val str: String) {
  JVMTI("jvmti"),
  JVMTI_ROOT("jvmti_root"),
  SDK("sdk"),
}

```

`host/main/src/main/kotlin/com/squareup/stoic/host/FailedExecException.kt`:

```kt
package com.squareup.stoic.host

class FailedExecException(val exitCode: Int, msg: String, val errorOutput: String?) :
  Exception(msg)

```

`host/main/src/main/kotlin/com/squareup/stoic/host/FileWithSha.kt`:

```kt
package com.squareup.stoic.host

import java.io.File

class FileWithSha(val file: File, val sha256sum: String)

```

`host/main/src/main/kotlin/com/squareup/stoic/host/HostUtils.kt`:

```kt
package com.squareup.stoic.host

import com.squareup.stoic.common.LogLevel
import com.squareup.stoic.common.logBlock
import com.squareup.stoic.common.toKotlinRepr
import java.io.File
import java.lang.ProcessBuilder.Redirect

// Host-specific command execution utilities
val globalEnvOverrides = mutableMapOf<String, String>()

fun runCommand(
  commandParts: List<String>,
  inheritIO: Boolean = false,
  shell: Boolean = false,
  directory: String? = null,
  chomp: Boolean = true,
  envOverrides: Map<String, String>? = null,
  expectedExitCode: Int = 0,
  redirectErrorStream: Boolean = false,
  redirectError: Redirect? = null,
  redirectOutputAndError: Redirect? = null,
  redirectOutput: Redirect? = null,
): String =
  logBlock(
    LogLevel.DEBUG,
    {
      "runCommand(${commandParts.toKotlinRepr()}, $inheritIO, $shell, $directory, $chomp, $envOverrides, $expectedExitCode)"
    },
  ) {
    val builder =
      resolvedProcessBuilder(
        commandParts,
        shell = shell,
        directory = directory,
        envOverrides = envOverrides,
        redirectErrorStream = redirectErrorStream,
        redirectError = redirectError,
        redirectOutput = redirectOutput,
        redirectOutputAndError = redirectOutputAndError,
      )

    if (inheritIO) {
      builder.inheritIO()
    }

    val process = builder.start().also { it.waitFor() }

    val output = process.inputStream.bufferedReader().readText()
    val exitCode = process.waitFor()
    if (exitCode != expectedExitCode) {
      val errorOutput = process.errorStream.bufferedReader().readText()
      throw FailedExecException(
        exitCode,
        "Failed command: '${commandParts.toKotlinRepr()}', exitCode=$exitCode, error output:\n---\n$errorOutput---",
        errorOutput,
      )
    }

    if (chomp) {
      output.removeSuffix("\n")
    } else {
      output
    }
  }

fun resolvedProcessBuilder(
  command: List<String>,
  shell: Boolean = false,
  directory: String? = null,
  envOverrides: Map<String, String>? = null,
  redirectErrorStream: Boolean = false,
  redirectError: Redirect? = null,
  redirectOutput: Redirect? = null,
  redirectOutputAndError: Redirect? = null,
): ProcessBuilder {
  val resolvedCommand =
    if (shell) {
      listOf("sh", "-c") + command
    } else {
      listOf("sh", "-c", "\"\$0\" \"\$@\"") + command
    }

  val builder = ProcessBuilder(resolvedCommand).redirectErrorStream(redirectErrorStream)
  if (redirectOutputAndError != null) {
    builder.redirectOutput(redirectOutputAndError).redirectError(redirectOutputAndError)
  } else if (redirectError != null) {
    builder.redirectError(redirectError)
  } else {
    builder.redirectError(Redirect.INHERIT)
  }
  if (redirectOutputAndError == null && redirectOutput != null) {
    builder.redirectOutput(redirectOutput)
  }

  val env = builder.environment()
  env.putAll(globalEnvOverrides)
  envOverrides?.let { env.putAll(envOverrides) }

  if (directory != null) {
    builder.directory(File(directory))
  }

  return builder
}

fun ProcessBuilder.waitFor(expectedExitCode: Int? = 0): Int {
  return start().waitFor(expectedExitCode, command())
}

fun Process.waitFor(expectedExitCode: Int?, command: List<String>? = null): Int {
  val exitCode = waitFor()

  if (expectedExitCode != null && expectedExitCode != exitCode) {
    val errorOutput =
      errorStream?.reader()?.readText()?.let {
        if (it.isBlank()) {
          null
        } else {
          it.removeSuffix("\n")
        }
      }
    val errorOutputMsg =
      if (errorOutput != null) {
        ", error output:\n---\n$errorOutput\n---"
      } else {
        ""
      }
    val commandString =
      if (command != null) {
        "'${command.toKotlinRepr()}', "
      } else {
        ""
      }
    throw FailedExecException(
      exitCode,
      "Failed command: ${commandString}exitCode=$exitCode$errorOutputMsg",
      errorOutput,
    )
  }
  return exitCode
}

fun ProcessBuilder.stdout(expectedExitCode: Int? = 0, chomp: Boolean = true): String {
  redirectOutput(Redirect.PIPE)
  val process = start()
  process.waitFor(expectedExitCode, command())

  val output = process.inputStream.bufferedReader().readText()

  return if (chomp) {
    output.removeSuffix("\n")
  } else {
    output
  }
}

```

`host/main/src/main/kotlin/com/squareup/stoic/host/MainParsedArgs.kt`:

```kt
package com.squareup.stoic.host

import com.squareup.stoic.common.LogLevel.DEBUG
import com.squareup.stoic.common.LogLevel.ERROR
import com.squareup.stoic.common.LogLevel.INFO
import com.squareup.stoic.common.LogLevel.VERBOSE
import com.squareup.stoic.common.LogLevel.WARN
import com.squareup.stoic.common.logDebug
import com.squareup.stoic.common.minLogLevel

class MainParsedArgs(
  val stoicArgs: List<String>,
  val command: String,
  val commandArgs: List<String>,
) {
  companion object {
    fun parse(args: Array<String>): MainParsedArgs {
      val stoicArgs = mutableListOf<String>()
      var command: String? = null

      var i = -1
      while (++i < args.size) {
        val arg = args[i]
        if (arg.startsWith("-")) {
          when (arg) {
            "--verbose" -> minLogLevel = VERBOSE
            "--debug" -> minLogLevel = DEBUG
            "--info" -> minLogLevel = INFO
            "--warn" -> minLogLevel = WARN
            "--error" -> minLogLevel = ERROR
            "--log" -> {
              val level = args[++i]
              minLogLevel =
                when {
                  level.toInt() == VERBOSE.level || level.equals("verbose", ignoreCase = true) ->
                    VERBOSE
                  level.toInt() == DEBUG.level || level.equals("debug", ignoreCase = true) -> DEBUG
                  level.toInt() == INFO.level || level.equals("info", ignoreCase = true) -> INFO
                  level.toInt() == WARN.level || level.equals("warn", ignoreCase = true) -> WARN
                  level.toInt() == ERROR.level || level.equals("error", ignoreCase = true) -> ERROR
                  else -> throw IllegalArgumentException("Unrecognized log level: $level")
                }
            }
            "--package",
            "--pkg" -> {
              // option with arg
              stoicArgs.add(arg)
              stoicArgs.add(args[++i])
            }
            else -> stoicArgs.add(arg)
          }
        } else {
          command = args[i]
          break
        }
      }

      if (command == null) {
        throw PithyException("Missing command: ${args.toList()}")
      }

      val commandArgs = args.slice(i + 1..<args.size)
      logDebug { "args: ${args.toList()}" }
      logDebug { "stoicArgs: $stoicArgs" }
      logDebug { "command: $command" }
      logDebug { "commandArgs: $commandArgs" }

      return MainParsedArgs(stoicArgs, command, commandArgs)
    }
  }
}

```

`host/main/src/main/kotlin/com/squareup/stoic/host/MismatchedVersionException.kt`:

```kt
package com.squareup.stoic.host

class MismatchedVersionException(message: String?) : Exception(message)

```

`host/main/src/main/kotlin/com/squareup/stoic/host/PithyException.kt`:

```kt
package com.squareup.stoic.host

class PithyException(val pithyMsg: String?, val exitCode: Int = 1, e: Exception? = null) :
  Exception(
    // Format with indentation so that multiline messages render nicely in stack traces
    """
    ${pithyMsg?.replace("\n", "\n    ") ?: "exitCode=$exitCode"}
  """
      .replace("\\s*$".toRegex(), ""),
    e,
  )

```

`host/main/src/main/kotlin/com/squareup/stoic/host/PluginHost.kt`:

```kt
package com.squareup.stoic.host

import com.squareup.stoic.bridge.StoicProperties
import com.squareup.stoic.common.Failed
import com.squareup.stoic.common.FailureCode
import com.squareup.stoic.common.LoadPlugin
import com.squareup.stoic.common.MessageReader
import com.squareup.stoic.common.MessageWriter
import com.squareup.stoic.common.PluginFinished
import com.squareup.stoic.common.STDERR
import com.squareup.stoic.common.STDIN
import com.squareup.stoic.common.STDOUT
import com.squareup.stoic.common.STOIC_PROTOCOL_VERSION
import com.squareup.stoic.common.StartPlugin
import com.squareup.stoic.common.Succeeded
import com.squareup.stoic.common.VerifyProtocolVersion
import com.squareup.stoic.common.logDebug
import com.squareup.stoic.common.logError
import com.squareup.stoic.common.logVerbose
import com.squareup.stoic.common.minLogLevel
import java.io.DataInputStream
import java.io.DataOutputStream
import java.io.EOFException
import java.io.IOException
import java.io.InputStream
import java.io.OutputStream
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.concurrent.thread

const val stoicDeviceDir = "/data/local/tmp/.stoic"
const val stoicDeviceSyncDir = "$stoicDeviceDir/sync"

class PluginHost(
  apkInfo: FileWithSha?,
  val pluginParsedArgs: PluginParsedArgs,
  inputStream: InputStream,
  outputStream: OutputStream,
) {
  val pluginApk = apkInfo?.file
  val pluginApkSha256Sum = apkInfo?.sha256sum
  val pluginName = pluginApk?.name?.removeSuffix(".apk") ?: pluginParsedArgs.pluginModule
  val writer = MessageWriter(DataOutputStream(outputStream))
  val reader = MessageReader(DataInputStream(inputStream))

  fun handleVersionResult(verifyProtocolVersionRequestId: Int) {
    try {
      val succeeded =
        reader.consumeNext().let {
          check(it.isResponse && it.isComplete)
          check(it.requestId == verifyProtocolVersionRequestId)
          it.payload as Succeeded
        }
      logDebug { succeeded.message }
    } catch (e: EOFException) {
      // This means the server isn't up yet
      throw e
    } catch (e: Exception) {
      logDebug { "Failed to handle version result: ${e.stackTraceToString()}" }

      // We treat any other exception encountered while handling the verify-protocol-version request
      // as a MismatchedVersionException because it's likely that a change in the structure of the
      // request/response is responsible for the problem.
      throw MismatchedVersionException(e.message)
    }
  }

  fun handleStartPluginResult(startPluginRequestId: Int) {
    val msg =
      reader.consumeNext().let {
        check(it.isResponse && it.isComplete)
        check(it.requestId == startPluginRequestId)
        it.payload
      }
    when (msg) {
      is Succeeded -> return // nothing more to do
      is Failed -> {
        when (msg.failureCode) {
          FailureCode.PLUGIN_MISSING.value -> {} // fall through to load plugin
          else -> throw IllegalStateException(msg.toString())
        }
      }
      else -> throw IllegalStateException("Unexpected message $msg")
    }

    // Need to load plugin
    if (pluginApk == null) {
      // TODO: Need to throw a sub-class of PithyException so we can catch it and try a tool instead
      throw PithyException(
        """
          Plugin not found: ${pluginParsedArgs.pluginModule}
          To list available plugins: stoic tool list
        """
          .trimIndent()
      )
    }

    val loadPluginRequestId =
      writer.writeRequest(
        LoadPlugin(pluginName = pluginName, pluginSha = pluginApkSha256Sum!!),
        isComplete = false,
      )
    writer.writeRequest(pluginApk.readBytes(), requestId = loadPluginRequestId)
    val startPluginRequestId =
      writer.writeRequest(
        StartPlugin(
          pluginName = pluginName,
          pluginSha = pluginApkSha256Sum,
          pluginArgs = pluginParsedArgs.pluginArgs,
          minLogLevel = minLogLevel.name,
          env = pluginParsedArgs.pluginEnvVars,
        )
      )
    val loadPluginResult =
      reader.consumeNext().let {
        check(it.isResponse && it.isComplete)
        it.payload as Succeeded
      }
    logVerbose { loadPluginResult.toString() }

    val startPluginResult =
      reader.consumeNext().let {
        check(it.isResponse && it.isComplete)
        it.payload as Succeeded
      }
    logVerbose { startPluginResult.toString() }
  }

  fun handle(): Int {
    logDebug { "reader/writer constructed" }

    // Since we're the host, we will write to stdin (and read from stdout/stderr)
    writer.openStdinForWriting()
    val verifyProtocolVersionRequestId =
      writer.writeRequest(
        VerifyProtocolVersion(STOIC_PROTOCOL_VERSION, StoicProperties.STOIC_VERSION_NAME)
      )

    val startPluginRequestId =
      writer.writeRequest(
        StartPlugin(
          pluginName = pluginName,
          pluginSha = pluginApkSha256Sum,
          pluginArgs = pluginParsedArgs.pluginArgs,
          minLogLevel = minLogLevel.name,
          env = pluginParsedArgs.pluginEnvVars,
        )
      )

    // To minimize roundtrips, we don't read the version result until after we've written RunPlugin
    handleVersionResult(verifyProtocolVersionRequestId)
    handleStartPluginResult(startPluginRequestId)

    val isFinished = AtomicBoolean(false)
    thread(name = "stdin-daemon", isDaemon = true) {
      val buffer = ByteArray(8192)
      try {
        while (true) {
          if (isFinished.get()) {
            break
          }

          val byteCount = System.`in`.read(buffer, 0, buffer.size)
          if (byteCount == -1) {
            writer.writeOneWay(ByteArray(0), STDIN, true)
            break
          } else {
            check(byteCount > 0)
            val bytes = buffer.copyOfRange(0, byteCount)
            writer.writeOneWay(bytes, STDIN, false)
          }
        }
      } catch (e: Throwable) {
        if (e is IOException) {
          // this is unconcerning - the connection is being torn down as we attempt to pump stdin
          logVerbose { "exception while pumping stdin (unconcerning) ${e.stackTraceToString()}" }
        } else {
          logError { e.stackTraceToString() }
          throw e
        }
      }
    }

    while (true) {
      val requestId: Int
      val payload =
        reader.consumeNext().let {
          requestId = it.requestId
          it.payload
        }
      when (payload) {
        is ByteArray -> {
          when (requestId) {
            STDOUT -> System.out.write(payload)
            STDERR -> System.err.write(payload)
            else -> throw IllegalArgumentException("Unrecognized stream id: ${requestId}")
          }
        }
        is PluginFinished -> {
          // To allow the server to stop pumping stdin cleanly, we write a StreamClosed message.
          writer.writeOneWay(ByteArray(0), STDIN, isComplete = true)
          isFinished.set(true)
          return payload.exitCode
        }
        else -> throw IllegalArgumentException("Unexpected msg: $payload")
      }
    }
  }
}

```

`host/main/src/main/kotlin/com/squareup/stoic/host/PluginParsedArgs.kt`:

```kt
package com.squareup.stoic.host

class PluginParsedArgs(
  val pluginModule: String,
  val pluginArgs: List<String> = listOf(),
  val pluginEnvVars: Map<String, String> = mapOf(),
)

```

`host/main/src/main/kotlin/com/squareup/stoic/host/Sha.kt`:

```kt
package com.squareup.stoic.host

import java.security.MessageDigest

object Sha {
  fun computeSha256Sum(text: String): String = computeSha256Sum(text.toByteArray())

  fun computeSha256Sum(bytes: ByteArray): String =
    MessageDigest.getInstance("SHA-256").digest(bytes).joinToString("") { "%02x".format(it) }
}

```

`host/main/src/main/kotlin/com/squareup/stoic/host/main/ApkCache.kt`:

```kt
@file:OptIn(ExperimentalSerializationApi::class)

package com.squareup.stoic.host.main

import com.squareup.stoic.apk.jarToApkPreserveManifest
import com.squareup.stoic.common.LogLevel
import com.squareup.stoic.common.logBlock
import com.squareup.stoic.common.logInfo
import com.squareup.stoic.host.FileWithSha
import com.squareup.stoic.host.Sha
import java.io.File
import java.io.FileOutputStream
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.nio.file.attribute.FileTime
import kotlin.io.path.deleteIfExists
import kotlin.io.path.exists
import kotlin.io.path.readBytes
import kotlin.io.path.readText
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.encodeToStream

/**
 * Cache of APK files.
 *
 * We support input in the form of either APK or JAR files. If input is in JAR form them we need to
 * turn it into an APK first.
 */
object ApkCache {
  private const val VERSION = 2

  /** Root directory (${java.io.tmpdir}/dex_cache) * */
  private val cacheRoot: Path =
    Paths.get(System.getProperty("java.io.tmpdir"), ".stoic/cache/apk-$VERSION")

  init {
    Files.createDirectories(cacheRoot)
  }

  fun resolve(jarOrApkFile: File): FileWithSha {
    val keyDir = computeKeyDir(jarOrApkFile)
    get(keyDir, jarOrApkFile)?.let {
      return it
    }
    logInfo { "ApkCache.get failed - regenerating sha/apk" }

    val apk = computeCachedApkPath(keyDir, jarOrApkFile)
    Files.createDirectories(keyDir)
    val metaFile = keyDir.resolve("meta")
    metaFile.deleteIfExists()

    if (jarOrApkFile.extension == "apk") {
      jarOrApkFile.copyTo(apk.toFile(), overwrite = true)
    } else {
      jarToApk(jarOrApkFile, apk.toFile())
    }

    val apkSha256Sum = updateMeta(keyDir, jarOrApkFile)
    return FileWithSha(apk.toFile(), apkSha256Sum)
  }

  private fun jarToApk(jarFile: File, apkFile: File) {
    logBlock(LogLevel.INFO, { "dexing $jarFile to $apkFile" }) {
      jarToApkPreserveManifest(jarFile, apkFile)
    }
  }

  /**
   * Return the cached apk for [jarOrApkFile] if present *and* still valid. Returns `null` on cache
   * miss.
   */
  private fun get(keyDir: Path, jarOrApkFile: File): FileWithSha? {
    val metaFile = keyDir.resolve("meta")
    if (!metaFile.exists()) {
      return null
    }

    val meta = Json.decodeFromString<ApkCacheMeta>(metaFile.readText())
    val apk = computeCachedApkPath(keyDir, jarOrApkFile)
    val currentCTime = retrieveCTime(Paths.get(meta.canonicalPath))
    if (currentCTime == meta.posixCTime) {
      return FileWithSha(apk.toFile(), meta.apkSha256Sum)
    } else {
      return null
    }
  }

  private fun computeCachedApkPath(keyDir: Path, jarOrApkFile: File): Path {
    val canonicalPath = jarOrApkFile.canonicalPath
    val canonicalFile = File(canonicalPath)
    return keyDir.resolve("${canonicalFile.nameWithoutExtension}.apk")
  }

  private fun updateMeta(keyDir: Path, jarOrApkFile: File): String {
    val apk = computeCachedApkPath(keyDir, jarOrApkFile)
    check(apk.exists())

    val canonicalPath = jarOrApkFile.canonicalPath
    val posixCTime = retrieveCTime(Paths.get(canonicalPath))
    val apkSha256Sum = Sha.computeSha256Sum(apk.readBytes())

    val metaFile = keyDir.resolve("meta")
    FileOutputStream(metaFile.toFile()).use {
      Json.encodeToStream(
        ApkCacheMeta(
          canonicalPath = canonicalPath,
          posixCTime = posixCTime,
          apkSha256Sum = apkSha256Sum,
        ),
        it,
      )
    }

    return apkSha256Sum
  }

  fun computeKeyDir(jar: File): Path {
    val hash = Sha.computeSha256Sum(jar.canonicalPath)

    return cacheRoot.resolve(hash)
  }

  /** True POSIX ctime via the "unix" attribute view. */
  private fun retrieveCTime(path: Path): Long {
    val t = Files.getAttribute(path, "unix:ctime") as FileTime
    return t.toMillis()
  }
}

@Serializable
data class ApkCacheMeta(val canonicalPath: String, val posixCTime: Long, val apkSha256Sum: String)

```

`host/main/src/main/kotlin/com/squareup/stoic/host/main/HostMain.kt`:

```kt
package com.squareup.stoic.host.main

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.CliktError
import com.github.ajalt.clikt.core.Context
import com.github.ajalt.clikt.core.CoreCliktCommand
import com.github.ajalt.clikt.core.UsageError
import com.github.ajalt.clikt.core.context
import com.github.ajalt.clikt.core.main
import com.github.ajalt.clikt.parameters.arguments.argument
import com.github.ajalt.clikt.parameters.arguments.multiple
import com.github.ajalt.clikt.parameters.arguments.optional
import com.github.ajalt.clikt.parameters.options.OptionDelegate
import com.github.ajalt.clikt.parameters.options.OptionWithValues
import com.github.ajalt.clikt.parameters.options.RawOption
import com.github.ajalt.clikt.parameters.options.convert
import com.github.ajalt.clikt.parameters.options.default
import com.github.ajalt.clikt.parameters.options.flag
import com.github.ajalt.clikt.parameters.options.multiple
import com.github.ajalt.clikt.parameters.options.nullableFlag
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.options.transformValues
import com.github.ajalt.clikt.parameters.options.versionOption
import com.github.ajalt.clikt.parameters.types.enum
import com.squareup.stoic.bridge.StoicProperties
import com.squareup.stoic.bridge.versionCodeFromVersionName
import com.squareup.stoic.common.LogLevel
import com.squareup.stoic.common.STOIC_PROTOCOL_VERSION
import com.squareup.stoic.common.logBlock
import com.squareup.stoic.common.logDebug
import com.squareup.stoic.common.logError
import com.squareup.stoic.common.logInfo
import com.squareup.stoic.common.logWarn
import com.squareup.stoic.common.minLogLevel
import com.squareup.stoic.common.serverSocketName
import com.squareup.stoic.common.showStatus
import com.squareup.stoic.common.withStatus
import com.squareup.stoic.host.AttachVia
import com.squareup.stoic.host.FailedExecException
import com.squareup.stoic.host.FileWithSha
import com.squareup.stoic.host.MismatchedVersionException
import com.squareup.stoic.host.PithyException
import com.squareup.stoic.host.PluginHost
import com.squareup.stoic.host.PluginParsedArgs
import com.squareup.stoic.host.stdout
import com.squareup.stoic.host.stoicDeviceSyncDir
import com.squareup.stoic.host.waitFor
import java.io.EOFException
import java.io.File
import java.io.FileFilter
import java.lang.ProcessBuilder.Redirect
import java.net.Socket
import java.nio.file.Paths
import kotlin.concurrent.thread
import kotlin.system.exitProcess

var isGraal: Boolean = false

lateinit var stoicHostUsrConfigDir: String
lateinit var stoicHostUsrPluginSrcDir: String
lateinit var stoicHostUsrSdkDir: String

lateinit var stoicReleaseDir: String
lateinit var stoicReleaseSyncDir: String
lateinit var stoicDemoPluginsDir: String
var androidSerial: String? = null

val adbSerial: String by lazy {
  androidSerial
    ?: run {
      val serialFromEnv = System.getenv("ANDROID_SERIAL")
      serialFromEnv
        ?: try {
          ProcessBuilder("adb", "get-serialno").stdout(0)
        } catch (e: FailedExecException) {
          e.errorOutput?.let {
            // This is probably just a message saying either
            //   "error: more than one device/emulator"
            // or
            //   "adb: no devices/emulators found"
            throw PithyException(it)
          } ?: run { throw e }
        }
    }
}

fun getDefaultAttachVia(): AttachVia {
  val defaultAttach = System.getenv("STOIC_ATTACH_VIA")
  return when (defaultAttach?.lowercase()) {
    "sdk" -> AttachVia.SDK
    "jvmti-root" -> AttachVia.JVMTI_ROOT
    "jvmti" -> AttachVia.JVMTI
    null,
    "" -> AttachVia.JVMTI // Default if not set
    else -> {
      throw PithyException(
        "Warning: Invalid STOIC_ATTACH_VIA value '$defaultAttach'. Valid values are: sdk, jvmti-root, jvmti. Using default: jvmti"
      )
    }
  }
}

data class PluginSpec(
  val pkg: String,
  val pluginModule: String,
  val pluginArgs: List<String> = emptyList(),
  val pluginEnvVars: Map<String, String> = emptyMap(),
  val attachVia: AttachVia = AttachVia.JVMTI,
  val restartApp: Boolean = false,
)

class Entrypoint : CliktCommand(name = "stoic") {
  companion object {
    const val DEFAULT_DEBUGGABLE_PACKAGE = "com.squareup.stoic.demoapp.withoutsdk"
    const val DEFAULT_NON_DEBUGGABLE_PACKAGE = "com.squareup.stoic.demoapp.withsdk"
  }

  init {
    context { allowInterspersedArgs = false }
    versionOption(version = StoicProperties.STOIC_VERSION_NAME, names = setOf("-v", "--version"))
  }

  override val printHelpOnEmptyArgs = true

  override fun help(context: Context): String {
    return """
      Stoic communicates with processes running on Android devices.

      Stoic will attempt to attach to a process via jvmti and establish a unix-domain-socket server.
      If successful, stoic will communicate to the server to request that the specified plugin run,
      with any arguments that follow, connecting stdin/stdout/stderr between the plugin and the
      stoic process.

      e.g. stoic helloworld "this is one arg" "this is a second arg"

      Special functionality is available via `stoic --tool <tool-name> <tool-args>` - for details,
      see `stoic --list --tool`
    """
      .trimIndent()
  }

  // Track which options were explicitly set
  private val specifiedOptions = mutableSetOf<String>()

  fun verifyOptions(subcommand: String, allowedOptions: List<String>) {
    specifiedOptions.forEach {
      if (it !in allowedOptions) {
        throw UsageError("$it not allowed with $subcommand")
      }
    }
  }

  fun RawOption.trackableFlag(): OptionDelegate<Boolean> {
    val longestName = names.maxByOrNull { it.length }!!
    return nullableFlag()
      .transformValues(0..0) {
        specifiedOptions += longestName
        true
      }
      .default(false)
  }

  fun RawOption.trackableOption(): OptionWithValues<String?, String, String> {
    val longestName = names.maxByOrNull { it.length }!!
    return convert {
      specifiedOptions += longestName
      it
    }
  }

  val verbose by option("--verbose", help = "enable verbose logging").trackableFlag()
  val debug by option("--debug", help = "enable debug logging").trackableFlag()
  val info by option("--info", help = "enable info logging").trackableFlag()
  val noStatus by option("--no-status", help = "disable status messages").trackableFlag()

  val restartApp by
    option(
        "--restart",
        "--restart-app",
        "-r",
        help = "if it's already running, force restart the specified package",
      )
      .trackableFlag()
  val noStartIfNeeded by
    option(
        "--no-start-if-needed",
        help =
          """
      by default, stoic will start the specified package if it's not already running - this option
      disables that behavior
    """
            .trimIndent(),
      )
      .trackableFlag()

  val androidSerialArg by
    option(
        "--android-serial",
        "--serial",
        "-s",
        help = "Use device with given serial (overrides \$ANDROID_SERIAL)",
      )
      .trackableOption()

  val rawPkg by
    option("--package", "--pkg", "-n", help = "Specify the package of the process to connect to")
      .trackableOption()

  val pkg by lazy {
    rawPkg
      ?: when (attachVia) {
        AttachVia.JVMTI -> DEFAULT_DEBUGGABLE_PACKAGE
        AttachVia.JVMTI_ROOT -> DEFAULT_NON_DEBUGGABLE_PACKAGE
        AttachVia.SDK -> DEFAULT_NON_DEBUGGABLE_PACKAGE
      }
  }

  val attachVia by
    option(
        "--attach-via",
        "-a",
        help =
          "Specify the method (jvmti, jvmti-root, or sdk) to attach to the target process (defaults to \$STOIC_ATTACH_VIA or jvmti if not otherwise specified)",
      )
      .trackableOption()
      .enum<AttachVia>()
      .default(getDefaultAttachVia())

  // TODO: support --pid/-p to allow attaching by pid

  val env by
    option(
        "--env",
        help = "Environment key=value pairs - plugins access these via stoic.getenv(...)",
      )
      .trackableOption()
      .convert { value ->
        val parts = value.split('=', limit = 2)
        if (parts.size != 2) {
          fail("--env must be in format KEY=VALUE")
        }
        parts[0] to parts[1]
      }
      .multiple()

  val isDemo by option("--demo", help = "limit plugin resolution to demo plugins").trackableFlag()
  val isEmbedded by
    option("--embedded", help = "limit plugin resolution to embedded plugins").trackableFlag()
  val isUser by
    option("--user", "--usr", help = "limit plugin resolution to user plugins").trackableFlag()
  val isTool by
    option("--tool", "-t", help = "run a tool - see `stoic --tool --list` for details").flag()
  val isList by option("--list", "-l", help = "list plugins (pass --tool to list tools)").flag()

  val subcommand by argument(name = "plugin").optional()
  val subcommandArgs by argument(name = "plugin-args").multiple()

  fun toPluginSpec(pluginModule: String? = null, pluginArgs: List<String>? = null): PluginSpec {
    return PluginSpec(
      pkg = pkg,
      pluginModule = pluginModule ?: subcommand!!,
      pluginArgs = pluginArgs ?: subcommandArgs,
      pluginEnvVars = env.toMap(),
      attachVia = attachVia,
      restartApp = restartApp,
    )
  }

  var demoAllowed = false
  var embeddedAllowed = false
  var userAllowed = false

  fun resolveAllowed() {
    val count = listOf(isDemo, isEmbedded, isUser).count { it }
    if (count == 0) {
      demoAllowed = true
      embeddedAllowed = true
      userAllowed = true
    } else if (count > 1) {
      throw UsageError("--demo/--embedded/--user are mutually exclusive")
    } else if (isTool) {
      throw UsageError("--tool is invalid with --demo/--embedded/--user")
    } else if (isDemo) {
      demoAllowed = true
    } else if (isEmbedded) {
      embeddedAllowed = true
    } else if (isUser) {
      userAllowed = true
    }
  }

  override fun run() {
    resolveAllowed()

    // We need to store this globally since we use it to resolve which device we connect to
    androidSerial = androidSerialArg

    if (restartApp && noStartIfNeeded) {
      throw CliktError("--restart-app and --no-start-if-needed are mutually exclusive")
    }

    if (listOf(verbose, debug, info).count { it } > 1) {
      throw CliktError("--verbose and --debug are mutually exclusive")
    }

    minLogLevel =
      if (verbose) {
        LogLevel.VERBOSE
      } else if (debug) {
        LogLevel.DEBUG
      } else if (info) {
        LogLevel.INFO
      } else {
        LogLevel.WARN
      }
    showStatus = !noStatus

    logDebug { "isGraal=$isGraal" }

    val exitCode = runPluginOrTool(this)
    if (exitCode != 0) {
      throw PithyException(null, exitCode)
    }
  }
}

class ShellCommand(val entrypoint: Entrypoint) : CliktCommand(name = "stoic shell") {
  init {
    context { allowInterspersedArgs = false }
  }

  override val treatUnknownOptionsAsArgs = true

  override fun help(context: Context): String {
    return """
      Stoic used to provide a shell command, but its unrelated to Stoic's core functionality, so
      it has been removed.
    """
      .trimIndent()
  }

  val shellArgs by argument().multiple()

  override fun run() {
    echoFormattedHelp()
    throw CliktError()
  }
}

class RsyncCommand(val entrypoint: Entrypoint) : CoreCliktCommand(name = "rsync") {
  init {
    context { allowInterspersedArgs = false }
  }

  override val treatUnknownOptionsAsArgs = true

  override fun help(context: Context): String {
    return """
      Stoic used to provide an rsync command, but its unrelated to Stoic's core functionality, so
      it has been removed.
    """
      .trimIndent()
  }

  val rsyncArgs by argument().multiple()

  override fun run() {
    echoFormattedHelp()
    throw CliktError()
  }
}

class InitConfigCommand(val entrypoint: Entrypoint) : CliktCommand(name = "stoic init-config") {
  init {
    context { allowInterspersedArgs = false }
  }

  override val treatUnknownOptionsAsArgs = true

  override fun help(context: Context): String {
    return """
      Stoic used to provide an init-config command, but it's not longer necessary, so it has been
      removed.
    """
      .trimIndent()
  }

  val initConfigArgsArgs by argument().multiple()

  override fun run() {
    echoFormattedHelp()
    throw CliktError()
  }
}

class PluginCommand(val entrypoint: Entrypoint) : CliktCommand(name = "stoic plugin") {
  override fun help(context: Context): String {
    return """
      Create a new plugin
    """
      .trimIndent()
  }

  val isNew by option("--new", "-n").flag()
  val isEdit by option("--edit", "-e").flag()

  // TODO: support `stoic plugin --list`

  val pluginName by argument("name")

  override fun run() {
    entrypoint.verifyOptions("plugin", listOf("--verbose", "--debug"))

    // Ensure the SDK is up-to-date
    syncSdk()

    if (isNew) {
      val usrPluginSrcDir = newPlugin(pluginName)
      System.err.println("New plugin src written to $usrPluginSrcDir")
      System.err.println("Run it with: stoic $pluginName")
    }

    if (isEdit) {
      val usrPluginSrcDir = File("$stoicHostUsrPluginSrcDir/$pluginName")
      if (!usrPluginSrcDir.exists()) {
        throw PithyException("$usrPluginSrcDir does not exist")
      }

      val stoicEditor = System.getenv("STOIC_EDITOR")
      val editor = System.getenv("EDITOR")
      val resolvedEditor =
        if (!stoicEditor.isNullOrBlank()) {
          stoicEditor
        } else if (!editor.isNullOrBlank()) {
          editor
        } else {
          throw PithyException(
            """
          Editor not found. Please export STOIC_EDITOR or EDITOR.
          For Android Studio:
            export STOIC_EDITOR='open -a "Android Studio"'
          Or, you can open your editor to $usrPluginSrcDir manually.
        """
              .trimIndent()
          )
        }

      val editorParts =
        if (resolvedEditor.contains(" ")) {
          ProcessBuilder("bash", "-c", "for x in $resolvedEditor; do printf '%s\\n' \"\$x\"; done")
            .stdout()
            .split('\n')
        } else {
          listOf(resolvedEditor)
        }

      val srcMain = "$usrPluginSrcDir/src/main/kotlin/Main.kt"
      val srcGradle = "$usrPluginSrcDir/build.gradle.kts"
      ProcessBuilder(editorParts + listOf(srcMain, srcGradle)).inheritIO().waitFor(0)
    }
  }
}

fun newPlugin(pluginName: String, ignoreExisting: Boolean = false): File {
  val pluginNameRegex = Regex("^[A-Za-z0-9_-]+$")
  if (!pluginName.matches(pluginNameRegex)) {
    throw PithyException("Plugin name must adhere to regex: ${pluginNameRegex.pattern}")
  }

  // Ensure the parent directory has been created
  File(stoicHostUsrPluginSrcDir).mkdirs()

  val usrPluginSrcDir = File("$stoicHostUsrPluginSrcDir/$pluginName")
  val pluginTemplateSrcDir = File("$stoicReleaseDir/template/plugin-template")

  if (usrPluginSrcDir.exists()) {
    if (ignoreExisting) {
      return usrPluginSrcDir
    } else {
      throw PithyException("$usrPluginSrcDir already exists")
    }
  }

  // Copy the scratch template plugin
  ProcessBuilder("cp", "-iR", pluginTemplateSrcDir.absolutePath, usrPluginSrcDir.absolutePath)
    .inheritIO()
    .redirectInput(File("/dev/null"))
    .waitFor(0)

  File(usrPluginSrcDir, ".stoic_template_version").writeText(StoicProperties.STOIC_VERSION_NAME)

  return usrPluginSrcDir
}

// This will go away once we publish the jars to maven
fun syncSdk() {
  // Ensure the parent directory has been created
  File(stoicHostUsrPluginSrcDir).mkdirs()
  ProcessBuilder("rsync", "--archive", "$stoicReleaseDir/sdk/", "$stoicHostUsrSdkDir/")
    .inheritIO()
    .waitFor(0)
}

fun main(rawArgs: Array<String>) {
  try {
    minLogLevel = LogLevel.WARN
    isGraal = System.getProperty("org.graalvm.nativeimage.imagecode") != null
    stoicReleaseDir =
      if (isGraal) {
        // This is how we find the release dir from the GraalVM-generated binary
        // The graalvm-binary will be in bin/darwin-arm64/stoic, so we need to walk up three
        // parents.
        val pathToSelf = ProcessHandle.current().info().command().get()
        Paths.get(pathToSelf).toRealPath().parent.parent.parent.toAbsolutePath().toString()
      } else {
        // This is how we find the release dir when normally (via a jar)
        // The jar file will be in jar/stoic-host-main.jar, so we need to walk up two parents.
        val uri = Entrypoint::class.java.protectionDomain.codeSource.location.toURI()
        File(uri).toPath().parent.parent.toAbsolutePath().toString()
      }

    // Check STOIC_REQUIRED_VERSION environment variable
    val requiredVersionStr = System.getenv("STOIC_REQUIRED_VERSION")
    if (!requiredVersionStr.isNullOrBlank()) {
      val currentVersion = versionCodeFromVersionName(StoicProperties.STOIC_VERSION_NAME)
      val requiredVersion =
        try {
          versionCodeFromVersionName(requiredVersionStr)
        } catch (e: Exception) {
          throw PithyException(
            "Could not parse \$STOIC_REQUIRED_VERSION as semantic version: $requiredVersionStr"
          )
        }

      if (currentVersion < requiredVersion) {
        throw PithyException(
          "Error: Stoic version ${StoicProperties.STOIC_VERSION_NAME} is lower than required version $requiredVersionStr specified via \$STOIC_REQUIRED_VERSION"
        )
      }
    }

    stoicReleaseSyncDir = "$stoicReleaseDir/sync"
    stoicDemoPluginsDir = "$stoicReleaseDir/demo-plugins"

    stoicHostUsrConfigDir =
      System.getenv("STOIC_CONFIG").let {
        if (it.isNullOrBlank()) {
          "${System.getenv("HOME")}/.config/stoic"
        } else {
          it
        }
      }
    stoicHostUsrPluginSrcDir = "$stoicHostUsrConfigDir/plugin"
    stoicHostUsrSdkDir = "$stoicHostUsrConfigDir/sdk"

    Entrypoint().main(rawArgs)
    exitProcess(0)
  } catch (e: PithyException) {
    // If we have a pithy message to display to the user, we'll display just that message
    // (unless debug logging is enabled) and then exit with status code 1.
    logDebug { e.stackTraceToString() }
    if (e.pithyMsg != null) {
      System.err.println(e.pithyMsg)
    } else {
      logDebug { "(no pithyMsg)" }
    }
    exitProcess(e.exitCode)
  } catch (e: Exception) {
    // We don't have a pithy message
    logError { e.stackTraceToString() }
    exitProcess(1)
  }
}

fun runList(entrypoint: Entrypoint): Int {
  entrypoint.verifyOptions("--list", listOf("--package", "--pkg", "--attach-via"))
  if (entrypoint.subcommand != null) {
    throw UsageError("`stoic --list` doesn't take positional arguments")
  } else if (entrypoint.isTool) {
    // TODO: deduplicate this list with the one in runTool
    listOf("plugin").forEach { println(it) }
  } else {
    // Show user and demo plugins
    val pluginList = gatherPluginList(entrypoint).toMutableList()

    // If package is specified, also get embedded plugins via __stoic-list
    if (entrypoint.rawPkg != null) {
      val listSpec =
        entrypoint.toPluginSpec(pluginModule = "__stoic-list", pluginArgs = emptyList())

      // Capture output from __stoic-list - we need to temporarily redirect System.out
      // TODO: Provide an API for running a plugin that allows overriding stdin/stdout/stderr
      // directly
      val originalOut = System.out
      val capturedOutput = java.io.ByteArrayOutputStream()
      System.setOut(java.io.PrintStream(capturedOutput))
      try {
        val exitCode = runPlugin(listSpec, apkInfo = null)

        if (exitCode == 0) {
          // Add embedded plugins to the list (filtering out internal plugins)
          capturedOutput.toString().trim().lines().forEach { pluginName ->
            if (pluginName.isNotBlank() && !isInternalPluginName(pluginName)) {
              pluginList.add("$pluginName (--embedded)")
            }
          }
        }
      } finally {
        System.setOut(originalOut)
      }
    }

    pluginList.forEach { println(it) }
  }

  return 0
}

fun isInternalPluginName(name: String): Boolean {
  return name.startsWith("__stoic-")
}

fun gatherPluginList(entrypoint: Entrypoint): List<String> {
  val pluginList = mutableListOf<String>()

  val apkFilter =
    object : FileFilter {
      override fun accept(file: File): Boolean {
        return file.isFile && file.name.endsWith(".apk")
      }
    }

  entrypoint.resolveAllowed()

  if (entrypoint.userAllowed) {
    val usrSourceDirs = File(stoicHostUsrPluginSrcDir).listFiles()!!
    usrSourceDirs.forEach {
      if (!it.name.startsWith(".")) {
        pluginList.add("${it.name} (--user)")
      }
    }
  }

  if (entrypoint.demoAllowed) {
    val demoPrebuilts = File(stoicDemoPluginsDir).listFiles(apkFilter)!!
    demoPrebuilts.forEach { pluginList.add("${it.name.removeSuffix(".apk")} (--demo)") }
  }

  return pluginList
}

fun runTool(entrypoint: Entrypoint): Int {
  val toolName = entrypoint.subcommand
  val command =
    when (toolName) {
      "shell" -> ShellCommand(entrypoint)
      "rsync" -> RsyncCommand(entrypoint)
      "init-config" -> InitConfigCommand(entrypoint)
      "plugin" -> PluginCommand(entrypoint)
      "help" -> {
        entrypoint.echoFormattedHelp()
        return 0
      }
      "version" -> {
        entrypoint.echo("stoic version ${StoicProperties.STOIC_VERSION_NAME}")
        return 0
      }
      else -> {
        if (entrypoint.isTool) {
          // The user was definitely trying to run a tool
          throw PithyException("tool `$toolName` not found, to see list: stoic --tool --list")
        } else {
          // Maybe the user was trying to run a plugin
          throw PithyException(
            """
          plugin or tool `$toolName` not found, to see list:
          stoic --tool --list (for tools)
          stoic --list (for plugins)
          """
              .trimIndent()
          )
        }
      }
    }

  command.main(entrypoint.subcommandArgs)
  return 0
}

fun runPluginFastPath(entrypoint: Entrypoint, apkInfo: FileWithSha?): Int {
  return runPluginFastPath(
    pkg = entrypoint.pkg,
    pluginParsedArgs =
      PluginParsedArgs(
        pluginModule = entrypoint.subcommand!!,
        pluginArgs = entrypoint.subcommandArgs,
        pluginEnvVars = entrypoint.env.toMap(),
      ),
    apkInfo = apkInfo,
  )
}

fun runPluginFastPath(pkg: String, pluginParsedArgs: PluginParsedArgs, apkInfo: FileWithSha?): Int {
  // `adb forward`-powered fast path
  val serverSocketName = serverSocketName(pkg)
  val portStr = adbProcessBuilder("forward", "tcp:0", "localabstract:$serverSocketName").stdout()
  try {
    Socket("localhost", portStr.toInt()).use {
      val host = PluginHost(apkInfo, pluginParsedArgs, it.inputStream, it.outputStream)
      return host.handle()
    }
  } finally {
    adbProcessBuilder("forward", "--remove", portStr)
  }
}

fun runPluginOrTool(entrypoint: Entrypoint): Int {
  if (entrypoint.isList) {
    return runList(entrypoint)
  } else if (entrypoint.isTool) {
    return runTool(entrypoint)
  }

  // If resolvePluginModule returns null then we'll try assuming its a embedded
  // (if we resolved the device) if that fails, then we'll check for a tool
  val apkInfo = resolveUserOrDemo(entrypoint)

  // We have somewhat complex logic for determining whether the specified command is a plugin or
  // a tool. Treating tools like plugins allows us to have separate args for them.
  //   e.g. In `stoic plugin --create foo`, `--create` is specific to the `plugin` tool.
  // But we want to avoid the problem of people creating their own plugins that conflict with tool
  // names. The problem could get even worse if we add a new tool in the future that conflicts with
  // a plugin others have been using for a long time.
  // To avoid such problems, we have the rule that an invocation can only resolve to a tool if the
  // package is not specified. We control what plugins are present in the default package so we can
  // prevent conflicts.
  val usingDefaultPackage = entrypoint.rawPkg == null
  val isPlugin =
    if (apkInfo != null || entrypoint.isEmbedded) {
      true
    } else if (entrypoint.isTool) {
      // Explicitly requested a tool
      false
    } else if (!usingDefaultPackage) {
      // Tools are only valid with the default package, so this must be a plugin
      true
    } else {
      // The default package only has no embedded plugins other than the internal ones - if it's not
      // one of these then it must be a tool.
      entrypoint.subcommand?.let { isInternalPluginName(it) } ?: false
    }

  return if (isPlugin) {
    try {
      runPlugin(entrypoint, apkInfo)
    } catch (e: MismatchedVersionException) {
      if (entrypoint.pkg == Entrypoint.DEFAULT_NON_DEBUGGABLE_PACKAGE) {
        // The non-debuggable package contains the Stoic SDK. If we have an old version installed it
        // could cause a problem. We can automatically try to fix it by uninstalling and retrying.
        logWarn { "runPlugin threw ${e.stackTraceToString()} - uninstalling and retrying" }

        // We ignore the exit code since the packages might not actually be installed
        adbProcessBuilder("uninstall", Entrypoint.DEFAULT_NON_DEBUGGABLE_PACKAGE).waitFor(null)

        runPlugin(entrypoint, apkInfo)
      } else if (entrypoint.attachVia == AttachVia.SDK) {
        throw Exception(
          "Protocol version mismatch - please rebuild the app with sdk version: ${StoicProperties.STOIC_VERSION_NAME}",
          e,
        )
      } else {
        """
          Protocol version mismatch - please try restarting the app (you can use the --restart flag)
          to force Stoic to re-attach.
        """
          .trimIndent()
        throw e
      }
    }
  } else {
    runTool(entrypoint)
  }
}

fun runPlugin(spec: PluginSpec, apkInfo: FileWithSha?): Int {
  if (!spec.restartApp) {
    try {
      return runPluginFastPath(
        pkg = spec.pkg,
        pluginParsedArgs =
          PluginParsedArgs(
            pluginModule = spec.pluginModule,
            pluginArgs = spec.pluginArgs,
            pluginEnvVars = spec.pluginEnvVars,
          ),
        apkInfo = apkInfo,
      )
    } catch (e: PithyException) {
      // PithyException will be caught at the outermost level
      throw e
    } catch (e: Exception) {
      logInfo { "fast-path failed" }
      logDebug { e.stackTraceToString() }
      // fall through to slow path
    }
  }

  withStatus("Attaching...") {
    // force start the server, and then retry
    logInfo { "starting server via slow-path" }

    // syncDevice is usually not necessary - we could optimistically assume its not and have
    // stoic-attach verify. But it typically takes less than 50ms - that's well under 5% of the time
    // needed for the slow path - so it's not too bad.
    syncDevice()

    val startOption =
      if (spec.restartApp) {
        "restart"
      } else {
        "start_if_needed"
      }

    val debugOption =
      if (minLogLevel <= LogLevel.DEBUG) {
        "debug_true"
      } else {
        "debug_false"
      }

    val proc =
      adbShellProcessBuilder(
          "$stoicDeviceSyncDir/bin/stoic-attach",
          "$STOIC_PROTOCOL_VERSION",
          spec.pkg,
          startOption,
          debugOption,
          spec.attachVia.str,
        )
        .redirectInput(File("/dev/null"))
        .redirectOutput(Redirect.PIPE)
        .redirectErrorStream(true)
        .start()

    val maybeError =
      if (minLogLevel <= LogLevel.DEBUG) {
        val stoicAttachOutputLines = mutableListOf<String>()
        thread {
          proc.inputReader().use { inputReader ->
            inputReader.lineSequence().forEach {
              logDebug { it }
              stoicAttachOutputLines += it
            }
          }
        }
        if (proc.waitFor() != 0) {
          stoicAttachOutputLines.joinToString("\n")
        } else {
          null
        }
      } else {
        if (proc.waitFor() != 0) {
          proc.inputReader().readText()
        } else {
          null
        }
      }

    if (maybeError != null) {
      if (spec.attachVia == AttachVia.JVMTI_ROOT) {
        if (maybeError.contains("Can't attach agent, process is not debuggable")) {
          throw PithyException(
            """
            ${spec.pkg} appears to not have JDWP enabled

            To fix this you can run the following (may need to set ANDROID_SERIAL appropriately):
              adb shell su 0 setprop persist.debug.dalvik.vm.jdwp.enabled '"1"' && adb shell su 0 stop && adb shell su 0 start && sleep 3
            (sleep is necessary to allow system processes to finish restarting):

            NOTE: this will enable jdwp for all apps on the device.
          """
              .trimIndent()
          )
        }
      }
      throw PithyException("stoic-attach failed:\n$maybeError")
    }

    logInfo { "waiting for up to 3 seconds for the port to be up" }
    val startTime = System.nanoTime()
    while ((System.nanoTime() - startTime) < 3_000_000_000) {
      try {
        runPluginFastPath(spec.pkg, PluginParsedArgs("__stoic-noop"), null)
        break
      } catch (e: EOFException) {
        logInfo { "server not up yet: ${e.stackTraceToString()}" }
        logInfo { "Sleeping 100ms and retrying..." }
        Thread.sleep(100)
      }
    }
  }

  logInfo { "server up - retrying fast-path" }
  return runPluginFastPath(
    pkg = spec.pkg,
    pluginParsedArgs =
      PluginParsedArgs(
        pluginModule = spec.pluginModule,
        pluginArgs = spec.pluginArgs,
        pluginEnvVars = spec.pluginEnvVars,
      ),
    apkInfo = apkInfo,
  )
}

fun runPlugin(entrypoint: Entrypoint, apkInfo: FileWithSha?): Int {
  return runPlugin(entrypoint.toPluginSpec(), apkInfo)
}

fun syncDevice() {
  logBlock(LogLevel.INFO, { "syncing device" }) {
    // The /. prevents creating an additional level of nesting when the destination directory
    // already exists.
    check(
      adbProcessBuilder("push", "--sync", "$stoicReleaseSyncDir/.", stoicDeviceSyncDir)
        .start()
        .waitFor() == 0
    )
  }
}

fun resolveUserOrDemo(entrypoint: Entrypoint): FileWithSha? {
  val pluginName = entrypoint.subcommand!!
  logDebug { "Attempting to resolve '$pluginName'" }
  if (listOf(entrypoint.isDemo, entrypoint.isEmbedded, entrypoint.isUser).count { it } > 1) {
    throw PithyException("At most one of --demo/--embedded/--user may be specified")
  }

  if (pluginName.endsWith(".jar") || pluginName.endsWith(".apk")) {
    if (!entrypoint.userAllowed) {
      val fileType = if (pluginName.endsWith(".jar")) "jar" else "apk"
      throw PithyException(
        "$fileType plugin are considered user - --demo/--embedded options are incompatible"
      )
    }

    val file = File(pluginName)
    if (!file.exists()) {
      throw PithyException("File not found: $pluginName")
    }

    return ApkCache.resolve(file)
  }

  val pluginApk = "$pluginName.apk"
  if (entrypoint.userAllowed) {
    val usrPluginSrcDir = "$stoicHostUsrPluginSrcDir/$pluginName"
    if (File(usrPluginSrcDir).exists()) {
      // Ensure the SDK is up-to-date
      syncSdk()

      withStatus("Compiling...") {
        val outputPath =
          logBlock(LogLevel.INFO, { "building $usrPluginSrcDir" }) {
            logInfo { "building plugin" }
            val prefix = "STOIC_BUILD_PLUGIN_OUT="
            try {
              ProcessBuilder("./stoic-build-plugin")
                .inheritIO()
                .directory(File(usrPluginSrcDir))
                .stdout()
                .lineSequence()
                .first { it.startsWith(prefix) }
                .removePrefix(prefix)
            } catch (e: NoSuchElementException) {
              logDebug { e.stackTraceToString() }
              throw PithyException(
                "stoic-build-plugin must output line: $prefix<path-to-output-jar-or-apk>"
              )
            }
          }

        return ApkCache.resolve(File(outputPath))
      }
    } else if (entrypoint.isUser) {
      throw PithyException("User plugin `$pluginName` not found, to see list: stoic --list --user")
    }
  }

  if (entrypoint.demoAllowed) {
    val corePluginApk = File("$stoicDemoPluginsDir/$pluginApk")
    if (corePluginApk.exists()) {
      return ApkCache.resolve(corePluginApk)
    } else if (entrypoint.isDemo) {
      throw PithyException("Demo plugin `$pluginName` not found, to see list: stoic --list --demo")
    }
  }

  return null
}

fun adbProcessBuilder(vararg args: String): ProcessBuilder {
  val procArgs = listOf("adb", "-s", adbSerial) + args
  logDebug { "adbProcBuilder($procArgs)" }
  return ProcessBuilder(procArgs)
}

fun adbShellProcessBuilder(
  vararg args: String,
  forceRoot: Boolean = false,
  evalArgs: Boolean = false
): ProcessBuilder {
  // If we're asked to run as root then we run the command through `su 0`
  // (Note: I've only tested this with AOSP's su - I'm not sure if it works
  // with Magisk's su)
  val maybeRoot = if (forceRoot) {
    listOf("su", "0")
  } else {
    listOf()
  }

  // If evalArgs is true then we use eval - otherwise we execute the args directly
  val maybeEval = if (evalArgs) {
    listOf("eval \"$*\"")
  } else {
    listOf("\"$@\"")
  }

  // The following construction may appear convoluted, but it has the property that it works for
  // any combination of forceRoot and evalArgs.
  // The idea is that we pass arguments to sh, which quotes them, and then they get passed to an
  // inner sh on the device (either root or not) which then executes them (either evaluated or not)
  val procArgs = listOf(
    "bash",
    "-c",
    """adb -s $adbSerial shell $(printf " %q" "$@")""",
    "--"
  ) + maybeRoot + listOf("sh", "-c") + maybeEval + listOf("--") + args

  logDebug {
    // shell escape properly, so we can copy/paste in the shell
    val pb = ProcessBuilder(listOf("bash", "-c", """printf ' %q' "$@"""", "--") + procArgs)
      .redirectError(Redirect.INHERIT)
    val out = pb.start().inputStream.bufferedReader().readText()
    "adbShellProcessBuilder: $out"
  }

  return ProcessBuilder(procArgs)
}

```

`host/main/src/main/kotlin/com/squareup/stoic/host/main/SELinuxViolationDetector.kt`:

```kt
package com.squareup.stoic.host.main

import com.squareup.stoic.common.logDebug
import com.squareup.stoic.common.logError
import com.squareup.stoic.host.runCommand
import java.io.IOException
import java.nio.charset.StandardCharsets.UTF_8
import java.util.Collections
import kotlin.concurrent.thread

// TODO: port this code to work on host, or in stoic-attach
class SELinuxViolationDetector {
  private val selinuxViolations = Collections.synchronizedList(mutableListOf<String>())
  private var logcatProcess: Process? = null

  fun start(pkg: String) {
    logcatProcess = ProcessBuilder(listOf("logcat", "-T", "1", "*:w")).start()

    val logcatReader = logcatProcess!!.inputStream.bufferedReader(UTF_8)
    thread {
      while (true) {
        val line =
          try {
            logcatReader.readLine()
          } catch (e: IOException) {
            // Probably we killed the logcat process
            break
          }

        if (line == null) {
          // Usually this means that we hit the timeout and we killed the logcat process
          // In rare circumstances it might mean that the adb connection died
          logDebug { "logcat end-of-stream" }
          break
        }

        if (
          "^.*avc: denied.*permissive=0.*app=${pkg.replace(".", "\\.")}\$".toRegex().matches(line)
        ) {
          logDebug { line }
          selinuxViolations.add(line)
        }
      }
    }
  }

  fun foundViolation(): Boolean {
    return selinuxViolations.isNotEmpty()
  }

  fun stop() {
    logcatProcess?.destroyForcibly()
  }

  fun showViolations() {
    // https://wiki.sqprod.co/display/TREX/How+to%3A+Fix+SELinux+Errors
    if (selinuxViolations.isEmpty()) {
      return
    }

    logError { "Detected SELinux violations!" }
    logError { "--------" }
    for (violation in selinuxViolations) {
      logError { violation }
    }
    logError { "--------\n" }

    if (runCommand(listOf("which", "su")).isNotBlank()) {
      logError { "Recommended fix (may need to tweak command depending on version of su):" }
      logError { "\n    adb shell su 0 setenforce 0\n" }
    } else {
      // Note: It could be the SELinux violations are unrelated to stoic
      // TODO: better diagnostics of what exactly SELinux is disallowing
      logError { "Your device's SELinux configuration may be incompatible with JVMTI." }
    }
  }
}

```

`integration-tests/README.md`:

```md
# Stoic Integration Tests

This module provides tools to run Stoic's end-to-end tests on specific Android emulator API levels.

## Overview

Stoic is a **host tool** that connects to **target devices**. These integration tests:
1. Create/start Android emulators with specific API levels
2. Run the stoic CLI from the host to connect to the emulator
3. Execute test scripts against running emulators
4. Verify functionality across different Android versions

## Quick Start

### Option 1: Run All Tests on Multiple API Levels (Fastest)

The `test/emulator-tests.sh` script runs all test suites on API 29 and API 34:

```bash
cd test
./emulator-tests.sh
```

This will automatically:
- Test on API 29 (Android 10) and API 34 (Android 14)
- Run all test suites on each API level
- Report a summary of results

### Option 2: Using the Standalone Script (Flexible)

The `test/with-emulator.sh` script manages the entire emulator lifecycle and runs your test:

```bash
# Run a single test suite on API 29
cd test
./with-emulator.sh 29 ./test-demo-app-without-sdk.sh

# Run all tests on API 34
./with-emulator.sh 34 ./run-all-tests-on-connected-device.sh
```

The script automatically:
- Creates the AVD if it doesn't exist
- Starts the emulator in headless mode
- Waits for the emulator to boot completely
- Runs your test script
- Cleans up and kills the emulator on exit

### Option 3: Using Gradle Tasks

For convenience, Gradle tasks wrap the standalone script:

```bash
# Run tests on specific API levels
./gradlew :integration-tests:testApi29
./gradlew :integration-tests:testApi34

# Run tests on all API levels (sequentially)
./gradlew :integration-tests:testAll

# List available test tasks
./gradlew :integration-tests:tasks --group=verification
```

## Supported API Levels

| API Level | Android Version |
|-----------|-----------------|
| 29        | Android 10      |
| 30        | Android 11      |
| 31        | Android 12      |
| 33        | Android 13      |
| 34        | Android 14      |

## How It Works

### The `with-emulator.sh` Script

```bash
./with-emulator.sh <api_level> <script_to_run> [script_args...]
```

**What it does:**
1. Validates the API level and checks for required tools
2. Creates an AVD using `avdmanager` (if it doesn't exist)
3. Starts the emulator in headless mode with optimized flags
4. Waits for the device to appear and boot completely
5. Runs your test script with environment variables set (`ANDROID_SERIAL`, `API_LEVEL`)
6. Cleans up by killing the emulator on exit (success or failure)

**Features:**
- Automatic AVD creation with sensible defaults
- Graceful cleanup via trap handlers
- Progress indicators during boot
- Exits with the same code as your test script

## Writing Your Own Tests

You can run any script with `with-emulator.sh`:

```bash
# Create a custom test script
cat > my-test.sh << 'EOF'
#!/usr/bin/env bash
set -euo pipefail

echo "Running on device: $ANDROID_SERIAL"
echo "API Level: $API_LEVEL"
adb shell getprop ro.build.version.sdk
# Your test commands here...
EOF

chmod +x my-test.sh

# Run it with an emulator
./with-emulator.sh 29 ./my-test.sh
```

The following environment variables are automatically set for your test script:
- `ANDROID_SERIAL` - The emulator device serial (e.g., `emulator-5554`)
- `API_LEVEL` - The Android API level (e.g., `29`, `34`)

## CI Integration

The standalone script is designed for CI/CD pipelines:

```yaml
# GitHub Actions example
- name: Run Stoic Tests on API 29
  run: |
    cd test
    ./with-emulator.sh 29 ./test-demo-app-without-sdk.sh

- name: Run Stoic Tests on API 34
  run: |
    cd test
    ./with-emulator.sh 34 ./test-demo-app-without-sdk.sh
```

Or using Gradle:

```yaml
- name: Run All Integration Tests
  run: ./gradlew :integration-tests:testAll
```

## Troubleshooting

### Missing system images

If the AVD creation fails, ensure you have the system image installed:

```bash
$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager \
  "system-images;android-29;default;x86_64"
```

### ANDROID_HOME not set

The script requires either `ANDROID_HOME` or `ANDROID_SDK_ROOT`:

```bash
export ANDROID_HOME=/path/to/android/sdk
```

### Emulator won't start

- Check disk space (emulators need ~4GB each)
- Verify hardware acceleration (Intel HAXM on Mac, KVM on Linux)
- Check that virtualization is enabled in BIOS

### Script hangs during boot

The script waits up to 2 minutes for the emulator to boot. If it consistently times out:
- Check system resources (CPU, RAM)
- Try running the emulator manually to see detailed output
- Check for conflicting emulators: `adb devices`

### Cleanup failed

If the emulator doesn't get killed properly:

```bash
# Manually kill all emulators
adb emu kill

# Or force kill
pkill -9 qemu-system
```

## Advanced Usage

### Running tests in parallel (not recommended)

While the script can technically run multiple emulators simultaneously, it's not recommended due to:
- High resource usage
- Potential port conflicts
- ADB device selection complexity

If you need parallel testing, use separate CI jobs:

```yaml
strategy:
  matrix:
    api: [29, 30, 31, 33, 34]
steps:
  - run: cd test && ./with-emulator.sh ${{ matrix.api }} ./test-demo-app-without-sdk.sh
```

### Adding new API levels

Edit both:
1. `test/with-emulator.sh` - Add to the `ANDROID_VERSIONS` array
2. `integration-tests/build.gradle.kts` - Add to the `apiLevels` list

## Architecture

```
test/
├── emulator-tests.sh                       # Run all tests on API 29, 30, 35 (main entry point)
├── with-emulator.sh                        # Standalone emulator manager
├── run-all-tests-on-connected-device.sh    # Run all test suites (used by with-emulator.sh)
├── test-demo-app-without-sdk.sh            # Individual test suite
├── test-plugin-new.sh                      # Individual test suite
├── test-without-config.sh                  # Individual test suite
└── ...

integration-tests/
├── build.gradle.kts              # Gradle wrapper tasks
└── README.md                     # This file
```

The design separates concerns:
- **Emulator management** lives in `test/with-emulator.sh` (no Gradle dependency)
- **Test orchestration** in `test/emulator-tests.sh` and `test/run-all-tests-on-connected-device.sh`
- **Individual test suites** are standalone scripts in `test/`
- **Gradle tasks** are thin wrappers for developer convenience

This allows you to use the emulator management script anywhere, with or without Gradle.

```

`integration-tests/build.gradle.kts`:

```kts
plugins { base }

// Configuration for test API levels
data class ApiConfig(val apiLevel: Int, val androidVersion: String)

val apiLevels =
  listOf(
    ApiConfig(29, "10.0"),
    ApiConfig(30, "11.0"),
    ApiConfig(31, "12.0"),
    ApiConfig(33, "13.0"),
    ApiConfig(34, "14.0"),
  )

// Create test tasks for each API level
apiLevels.forEach { config ->
  val capitalizedName = "Api${config.apiLevel}"

  tasks.register<Exec>("test${capitalizedName}") {
    group = "verification"
    description = "Run Stoic tests on Android ${config.androidVersion} (API ${config.apiLevel})"

    workingDir = rootProject.projectDir.resolve("test")
    commandLine(
      "./with-emulator.sh",
      config.apiLevel.toString(),
      "./run-all-tests-on-connected-device.sh",
    )

    doFirst { println("Running tests on API ${config.apiLevel} using with-emulator.sh...") }
  }
}

// Convenience task to run all tests sequentially
tasks.register("testAll") {
  group = "verification"
  description = "Run tests on all API levels (sequentially)"

  apiLevels.forEach { config -> dependsOn("testApi${config.apiLevel}") }

  // Make tests run sequentially, not in parallel
  tasks.findByName("testApi30")?.mustRunAfter("testApi29")
  tasks.findByName("testApi31")?.mustRunAfter("testApi30")
  tasks.findByName("testApi33")?.mustRunAfter("testApi31")
  tasks.findByName("testApi34")?.mustRunAfter("testApi33")
}

```

`internal/test/protocol-version-client/build.gradle.kts`:

```kts
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
  alias(libs.plugins.application)
  alias(libs.plugins.kotlin.jvm)
  alias(libs.plugins.kotlin.serialization)
}

application { mainClass.set("com.squareup.stoic.test.ProtocolVersionClientKt") }

repositories { mavenCentral() }

dependencies {
  implementation(kotlin("stdlib"))
  implementation(project(":protocol"))
  implementation(libs.kotlinx.serialization.json)
}

tasks.withType<KotlinCompile> { kotlinOptions { jvmTarget = "17" } }

tasks.jar {
  duplicatesStrategy = DuplicatesStrategy.EXCLUDE
  manifest { attributes("Main-Class" to "com.squareup.stoic.test.ProtocolVersionClientKt") }
  // Include all dependencies in the JAR
  from({
    configurations.runtimeClasspath
      .get()
      .filter { it.exists() }
      .map { if (it.isDirectory) it else zipTree(it) }
  })
}

```

`internal/test/protocol-version-client/src/main/kotlin/ProtocolVersionClient.kt`:

```kt
package com.squareup.stoic.test

import com.squareup.stoic.bridge.StoicProperties
import com.squareup.stoic.common.Failed
import com.squareup.stoic.common.MessageReader
import com.squareup.stoic.common.MessageWriter
import com.squareup.stoic.common.ProtocolError
import com.squareup.stoic.common.Succeeded
import com.squareup.stoic.common.VerifyProtocolVersion
import java.io.DataInputStream
import java.io.DataOutputStream
import java.net.Socket
import kotlin.system.exitProcess

const val EXIT_ACCEPT = 0
const val EXIT_REJECT = 5
const val EXIT_ERROR = 10

/**
 * Test client that sends a VerifyProtocolVersion message with a specified protocol version.
 *
 * Usage: ProtocolVersionClient <host> <port> <protocol-version>
 */
fun main(args: Array<String>) {

  if (args.size != 3) {
    System.err.println("Usage: ProtocolVersionClient <host> <port> <protocol-version>")
    exitProcess(EXIT_ERROR)
  }

  val host = args[0]
  val port =
    args[1].toIntOrNull()
      ?: run {
        System.err.println("Invalid port: ${args[1]}")
        exitProcess(EXIT_ERROR)
      }
  val protocolVersion =
    args[2].toIntOrNull()
      ?: run {
        System.err.println("Invalid protocol version: ${args[2]}")
        exitProcess(EXIT_ERROR)
      }

  try {
    System.err.println("Connecting to $host:$port...")
    Socket(host, port).use { socket ->
      socket.soTimeout = 10000 // 10 second timeout
      socket.tcpNoDelay = true // Disable Nagle's algorithm - send immediately
      socket.setSoLinger(true, 5) // Wait up to 5 seconds when closing to ensure data is sent

      System.err.println("Connected! Creating streams...")
      val writer = MessageWriter(DataOutputStream(socket.getOutputStream()))
      val reader = MessageReader(DataInputStream(socket.getInputStream()))

      // Mark stdin as open for writing
      writer.openStdinForWriting()
      System.err.println("Opened stdin for writing")

      // Send VerifyProtocolVersion with the specified protocol version
      System.err.println("Sending VerifyProtocolVersion with protocol version $protocolVersion...")
      val versionRequestId =
        writer.writeRequest(
          VerifyProtocolVersion(protocolVersion, StoicProperties.STOIC_VERSION_NAME)
        )
      System.err.println("Sent VerifyProtocolVersion with request ID: $versionRequestId")

      // Read VerifyProtocolVersion response
      System.err.println("Waiting for VerifyProtocolVersion response...")
      val versionResponse = reader.consumeNext()
      System.err.println("Received response!")

      if (versionResponse.requestId != versionRequestId) {
        System.err.println("ERROR: Response request ID mismatch")
        exitProcess(EXIT_ERROR)
      }

      when (val payload = versionResponse.payload) {
        is Succeeded -> {
          System.err.println("SUCCESS: Server accepted protocol version $protocolVersion")
          System.err.println("Message: ${payload.message}")
          exitProcess(EXIT_ACCEPT)
        }
        is Failed -> {
          System.err.println("REJECTED: Server rejected protocol version $protocolVersion")
          System.err.println("Message: ${payload.message}")

          // After a version rejection, the server throws an exception which results in a
          // ProtocolError message being sent before the connection closes. Read and verify it.
          System.err.println("Expecting ProtocolError message...")
          val errorMessage = reader.consumeNext()
          val errorPayload = errorMessage.payload
          if (errorPayload is ProtocolError) {
            System.err.println("Received expected ProtocolError")
            exitProcess(EXIT_REJECT)
          } else {
            System.err.println(
              "ERROR: Expected ProtocolError but got ${errorPayload::class.simpleName}"
            )
            exitProcess(EXIT_ERROR)
          }
        }
        else -> {
          System.err.println("ERROR: Unexpected response type: ${payload::class.simpleName}")
          exitProcess(EXIT_ERROR)
        }
      }
    }
  } catch (e: Exception) {
    System.err.println("ERROR: ${e.message}")
    e.printStackTrace()
    exitProcess(EXIT_ERROR)
  }
}

```

`internal/tool/jar-to-apk-preserve-manifest/build.gradle.kts`:

```kts
plugins {
  alias(libs.plugins.kotlin.jvm)
  alias(libs.plugins.application)
}

dependencies { implementation(project(":protocol")) }

application { mainClass.set("com.squareup.stoic.apk.MainKt") }

```

`internal/tool/jar-to-apk-preserve-manifest/src/main/kotlin/com/squareup/stoic/apk/Main.kt`:

```kt
package com.squareup.stoic.apk

import com.squareup.stoic.bridge.StoicProperties
import java.io.File
import java.nio.file.Files
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream

fun main(args: Array<String>) {
  println("args: ${args.joinToString(", ")}")
  val src = File(args[0])
  val dst = File(args[1])
  val tempDir = Files.createTempDirectory("jar-to-apk-preserve-manifest").toFile()
  System.err.println("temp-dir: $tempDir")
  jarToApkPreserveManifest(src, dst, tempDir)
  System.err.println("generated: ${dst.absolutePath}")
}

fun jarToApkPreserveManifest(jarFile: File, apkFile: File) {
  jarToApkPreserveManifest(
    jarFile,
    apkFile,
    tempDir = Files.createTempDirectory("jar-to-apk-preserve-manifest").toFile(),
  )
}

// TODO: This is broken. The intent is to run D8, but preserve META-INF/MANIFEST.MF from the jar
fun jarToApkPreserveManifest(jarFile: File, apkFile: File, tempDir: File) {
  val androidBuildToolsVersion = StoicProperties.ANDROID_BUILD_TOOLS_VERSION
  val androidHome = System.getenv("ANDROID_HOME") ?: error("Need to set ANDROID_HOME")
  val d8Path = File("$androidHome/build-tools/$androidBuildToolsVersion/d8")
  val dexOutDir = File(tempDir, "stoic-dex")
  dexOutDir.mkdirs()

  check(
    ProcessBuilder(
        d8Path.absolutePath,
        "--min-api",
        StoicProperties.ANDROID_MIN_SDK.toString(),
        "--output",
        dexOutDir.absolutePath,
        jarFile.absolutePath,
      )
      .redirectError(ProcessBuilder.Redirect.INHERIT)
      .start()
      .waitFor() == 0
  )

  ZipOutputStream(apkFile.outputStream().buffered()).use { zipOut ->
    dexOutDir.listFiles()?.forEach { file ->
      zipOut.putNextEntry(ZipEntry(file.name))
      file.inputStream().buffered().use { it.copyTo(zipOut) }
      zipOut.closeEntry()
    }
  }
}

```

`internal/tool/release/build.gradle.kts`:

```kts
plugins {
  alias(libs.plugins.kotlin.jvm)
  alias(libs.plugins.application)
}

dependencies { implementation(project(":protocol")) }

application { mainClass.set("com.squareup.stoic.release.MainKt") }

tasks.named<JavaExec>("run") {
  workingDir = File(System.getProperty("user.dir"))
  standardInput = System.`in`
}

```

`internal/tool/release/src/main/java/com/squareup/stoic/release/Main.kt`:

```kt
package com.squareup.stoic.release

import com.squareup.stoic.bridge.versionCodeFromVersionName
import java.io.File
import kotlin.system.exitProcess

fun main(args: Array<String>) {
  if (args.isEmpty()) {
    System.err.println("Usage: release <path-to-stoic-root>")
    exitProcess(1)
  }

  val stoicDir = File(File(args[0]).absolutePath)

  val versionFile = stoicDir.resolve("prebuilt/STOIC_VERSION")
  val currentVersion = versionFile.readText().trim()
  validateSemver(currentVersion)

  val releaseVersion = currentVersion.removeSuffix("-SNAPSHOT")
  validateSemver(releaseVersion)

  val postReleaseVersion = incrementSemver(releaseVersion)
  validateSemver(postReleaseVersion)

  val releaseTag = "v$releaseVersion"

  // Release artifact URLs
  val githubReleaseUrl = "https://github.com/block/stoic/releases/tag/$releaseTag"
  val pluginSdkUrl =
    "https://central.sonatype.com/artifact/com.squareup.stoic/plugin-sdk/$releaseVersion"
  val appSdkUrl = "https://central.sonatype.com/artifact/com.squareup.stoic/app-sdk/$releaseVersion"
  val homebrewFormulaUrl = "https://github.com/block/homebrew-tap/blob/main/Formula/stoic.rb"

  println()
  println("═══════════════════════════════════════════════════════════════")
  println("  Stoic Release Process")
  println("═══════════════════════════════════════════════════════════════")
  println()
  println("  Current version:     $currentVersion")
  println("  Release version:     $releaseVersion")
  println("  Post-release version: $postReleaseVersion")
  println()
  println("  This will:")
  println("    • Create release branch: release/$releaseVersion")
  println("    • Tag the release as: $releaseTag")
  println("    • Publish to Maven Central")
  println("    • Create GitHub release")
  println("    • Update Homebrew formula")
  println("    • Merge to main and bump version")
  println()

  println(
    """
    If you want to abandon the release, you can delete the artifacts directory with:
    % rm -r releases/$releaseVersion

    If the release branch has already been created, you can delete it with:
    % git checkout main && git branch -D release/$releaseVersion && git push origin --delete release/$releaseVersion

    If the tag has already been created, you can delete it with:
    % git tag -d v$releaseVersion && git push origin --delete v$releaseVersion


  """
      .trimIndent()
  )

  val artifactsDir = stoicDir.resolve("releases/$releaseVersion")

  if (artifactsDir.exists()) {
    println("Resuming from previous attempt: $artifactsDir")
  } else {
    println("Creating artifacts directory: $artifactsDir")
    artifactsDir.mkdirs()
  }

  // state tracking
  val stateFile = artifactsDir.resolve(".release_state")
  fun markStep(step: Step) {
    println("Completed: $step")
    stateFile.writeText(step.name)
  }
  fun lastStep(): Step? =
    if (stateFile.exists()) Step.valueOf(stateFile.readText().trim()) else null
  fun shouldRun(step: Step): Boolean {
    val done = lastStep()
    return done == null || step.ordinal > done.ordinal
  }
  fun step(step: Step, action: () -> Unit) {
    if (shouldRun(step)) {
      println("Running step: ${step.name}")
      action()
      markStep(step)
    } else {
      println("Skipping already completed step: ${step.name}")
    }
  }

  lastStep()?.let { println("Resuming from step: $it") }

  step(Step.PROMPT) {
    print("Do you want to proceed with this release? (yes/no): ")
    System.out.flush()

    val response = readLine()?.trim()?.lowercase()
    if (response != "yes") {
      println("Release cancelled.")
      exitProcess(0)
    }

    println()
    println("Starting release process...")
    println()
  }

  step(Step.SHELLCHECK) { check(runCommand(listOf("test/shellcheck.sh"), stoicDir)) }

  val releaseBranch = "release/$releaseVersion"
  step(Step.CREATE_BRANCH) {
    // We ensure clean git repo within the create branch step so that we can
    // modify the repo (without committing!) to help the release succeed
    ensureCleanGitRepo(stoicDir)

    val branch =
      runCommandOutput(listOf("git", "rev-parse", "--abbrev-ref", "HEAD"), stoicDir).trim()
    val normalized = branch.removePrefix("refs/").removePrefix("heads/").removePrefix("origin/")
    require(normalized == "main") { "Must run from main branch (currently on '$normalized')" }

    require(currentVersion.endsWith("-SNAPSHOT")) {
      "Current version must end in -SNAPSHOT (was '$currentVersion')"
    }
    require(
      versionCodeFromVersionName(releaseVersion) == versionCodeFromVersionName(currentVersion) + 1
    )
    require(
      versionCodeFromVersionName(postReleaseVersion) ==
        versionCodeFromVersionName(releaseVersion) + 9
    )

    println("Creating release branch: $releaseBranch")
    check(runCommand(listOf("git", "checkout", "-b", releaseBranch), stoicDir))
    versionFile.writeText("$releaseVersion\n")
    check(runCommand(listOf("git", "add", versionFile.path), stoicDir))
    check(runCommand(listOf("git", "commit", "-m", "Prepare $releaseVersion release"), stoicDir))
    check(runCommand(listOf("git", "push", "--set-upstream", "origin", releaseBranch), stoicDir))
  }

  val commitSha = getHeadSha(stoicDir)

  // Verify the commit message matches the expected release preparation commit
  val commitMessage =
    runCommandOutput(listOf("git", "log", "-1", "--format=%s", commitSha), stoicDir).trim()
  val expectedMessage = "Prepare $releaseVersion release"
  if (commitMessage != expectedMessage) {
    System.err.println("❌ Commit message mismatch!")
    System.err.println("   Expected: $expectedMessage")
    System.err.println("   Got:      $commitMessage")
    System.err.println("   Commit:   $commitSha")
    exitProcess(1)
  }
  println("✓ Verified commit message: $commitMessage")

  step(Step.WAIT_BUILD) {
    println("Waiting for GitHub Actions build workflow to complete...")
    val runId = waitForWorkflow("build", stoicDir, commitSha)

    println("Downloading build artifact...")
    check(
      runCommand(
        listOf(
          "gh",
          "run",
          "download",
          runId,
          "--repo",
          "block/stoic",
          "-n",
          "stoic-release-tar-gz",
          "-D",
          artifactsDir.absolutePath,
        ),
        stoicDir,
      )
    )
  }

  val extractedDir = artifactsDir.resolve("verify")
  step(Step.EXTRACT) {
    extractedDir.mkdirs()
    println("Extracting artifact to $extractedDir...")
    check(
      runCommand(
        listOf(
          "tar",
          "-xzf",
          "${artifactsDir.resolve("stoic-release.tar.gz")}",
          "-C",
          extractedDir.absolutePath,
          "--strip-components",
          "1",
        ),
        stoicDir,
      )
    )
  }

  val binPath = extractedDir.resolve("bin/darwin-arm64").absolutePath
  val newPath = "$binPath:${System.getenv("PATH")}"
  val env = mapOf("PATH" to newPath)

  step(Step.VERIFY_TESTS) {
    println("Verifying stoic binary location...")
    val whichOutput = runCommandOutput(listOf("which", "stoic"), stoicDir, env).trim()
    val expectedPath = extractedDir.resolve("bin/darwin-arm64/stoic").absolutePath
    println("which stoic: $whichOutput")
    if (whichOutput != expectedPath) {
      System.err.println("❌ Wrong stoic binary! Expected $expectedPath but got: $whichOutput")
      exitProcess(1)
    }
    println("✓ Using correct stoic binary from release artifacts")
    println()

    // We need to run the command through `sh -c` to force executable
    // resolution to take PATH into account.
    println("Verifying stoic version...")
    val versionOutput =
      runCommandOutput(listOf("sh", "-c", "stoic --version"), stoicDir, env).trim()
    println("stoic --version: $versionOutput")
    if (!versionOutput.contains(releaseVersion)) {
      System.err.println("❌ Version mismatch! Expected $releaseVersion but got: $versionOutput")
      exitProcess(1)
    }
    println("✓ Version verified: $releaseVersion")
    println()

    println("Running all tests on connected device...")
    check(runCommand(listOf("test/run-all-tests-on-connected-device.sh"), stoicDir, env))
    println("✓ All tests passed on macOS with real hardware.")
  }

  // Tagging the release will kickoff the release workflow. This will first
  // check that the test workflow succeeded and then perform the actual release
  // to Maven and Github releases. Due to permissions issues, we need to
  // release to our homebrew-tap separately within this script.
  step(Step.TAG_RELEASE) {
    println("Tagging release as $releaseTag")
    check(
      runCommand(listOf("git", "tag", "-a", releaseTag, "-m", "Release $releaseVersion"), stoicDir)
    )
    check(runCommand(listOf("git", "push", "origin", releaseTag), stoicDir))
  }

  step(Step.WAIT_RELEASE) {
    println("Waiting for GitHub Actions release workflow to complete...")
    waitForWorkflow("release", stoicDir, commitSha)
    println()
    println("GitHub release and Maven Central artifacts published:")
    println("  GitHub Release: $githubReleaseUrl")
    println("  Maven Central (plugin-sdk): $pluginSdkUrl")
    println("  Maven Central (app-sdk): $appSdkUrl")
    println()
    println(
      "Note: Maven Central artifacts may take up to 30 minutes to become available for download."
    )
  }

  step(Step.MERGE_MAIN) {
    println("Merging release branch into main...")
    check(runCommand(listOf("git", "checkout", "main"), stoicDir))
    check(runCommand(listOf("git", "merge", "--ff-only", releaseBranch), stoicDir))
  }

  step(Step.BUMP_SNAPSHOT) {
    println("Bumping version to post-release: $postReleaseVersion")
    versionFile.writeText("$postReleaseVersion\n")
    check(runCommand(listOf("git", "add", versionFile.path), stoicDir))
    check(
      runCommand(listOf("git", "commit", "-m", "Start $postReleaseVersion development"), stoicDir)
    )
    check(runCommand(listOf("git", "push", "origin", "main"), stoicDir))
  }

  step(Step.UPDATE_HOMEBREW) {
    println("Triggering Homebrew tap update for $releaseTag...")
    check(
      runCommand(
        listOf(
          "gh",
          "workflow",
          "run",
          "update-stoic.yaml",
          "--repo",
          "block/homebrew-tap",
          "--field",
          "tag=$releaseTag",
        ),
        stoicDir,
      )
    )

    println("Waiting for Homebrew tap update workflow to complete...")
    // Get the latest commit SHA from homebrew-tap main branch to wait for the workflow
    val homebrewRepoDir = stoicDir // We're triggering from stoic repo
    waitForWorkflowInRepo("update-stoic.yaml", "block/homebrew-tap", stoicDir, timeoutMinutes = 10)

    println()
    println("Homebrew formula updated:")
    println("  Homebrew formula: $homebrewFormulaUrl")
    println()

    // Success message is intentionally inside the last step so we can distinguish
    // between a fresh successful release and resuming an already-completed release
    println("Release $releaseVersion completed successfully!")
    println()
    println("All release artifacts:")
    println("  GitHub Release: $githubReleaseUrl")
    println("  Maven Central (plugin-sdk): $pluginSdkUrl")
    println("  Maven Central (app-sdk): $appSdkUrl")
    println("  Homebrew formula: $homebrewFormulaUrl")
    println()
  }
}

/** Validate version string pattern. */
fun validateSemver(version: String): Boolean =
  Regex("""^\d+\.\d+\.\d+(-SNAPSHOT)?$""").matches(version)

/** Increment final semver component, always ending with -SNAPSHOT. */
fun incrementSemver(version: String): String {
  val clean = version.removeSuffix("-SNAPSHOT")
  val parts = clean.split(".").map { it.toInt() }
  return "${parts[0]}.${parts[1]}.${parts[2] + 1}-SNAPSHOT"
}

/** Ensure working tree clean. */
fun ensureCleanGitRepo(dir: File) {
  val status = runCommandOutput(listOf("git", "status", "--porcelain"), dir).trim()
  if (status.isNotEmpty()) {
    System.err.println(status)
    System.err.println("The git repository has uncommitted changes or untracked files. Aborting...")
    exitProcess(1)
  }
}

/** Run command, inheriting IO. */
fun runCommand(cmd: List<String>, dir: File, extraEnv: Map<String, String> = emptyMap()): Boolean {
  val pb = ProcessBuilder(cmd).directory(dir).inheritIO()
  pb.environment().putAll(extraEnv)
  val process = pb.start()
  return process.waitFor() == 0
}

/** Capture stdout from command. */
fun runCommandOutput(
  cmd: List<String>,
  dir: File,
  extraEnv: Map<String, String> = emptyMap(),
): String {
  val pb = ProcessBuilder(cmd).directory(dir)
  pb.environment().putAll(extraEnv)
  val process = pb.start()
  val output = process.inputStream.bufferedReader().readText()
  process.waitFor()
  return output
}

/**
 * Wait until a given workflow has completed successfully for the specified commit SHA.
 *
 * @param workflow the workflow name (e.g., "build" or "release")
 * @param repoDir local repo directory
 * @param commitSha the commit to wait for
 * @param timeoutMinutes how long to wait before failing
 */
fun waitForWorkflow(
  workflow: String,
  repoDir: File,
  commitSha: String,
  timeoutMinutes: Int = 40,
): String {
  val repo =
    runCommandOutput(
        listOf("gh", "repo", "view", "--json", "nameWithOwner", "--jq", ".nameWithOwner"),
        repoDir,
      )
      .trim()

  val deadline = System.currentTimeMillis() + timeoutMinutes * 60_000L
  var runId: String? = null

  // The jq filter, written as a raw triple-quoted string for readability.
  val jqFilter =
    """
    .[]
    | select(.headSha=="$commitSha") 
    | "\(.databaseId) \(.status) \(.conclusion)"
  """
      .trimIndent()

  while (true) {
    // Ask gh to give only runs for this commit, already filtered by jq
    val line =
      runCommandOutput(
          listOf(
            "gh",
            "run",
            "list",
            "--repo",
            repo,
            "--workflow",
            workflow,
            "--json",
            "databaseId,headSha,status,conclusion",
            "--jq",
            jqFilter,
            "--limit",
            "50",
          ),
          repoDir,
        )
        .lines()
        .firstOrNull { it.isNotBlank() }

    var runUrl: String? = null
    if (line != null) {
      val parts = line.trim().split(Regex("\\s+"))
      runId = parts[0]
      val status = parts.getOrNull(1)
      val conclusion = parts.getOrNull(2)
      runUrl = "https://github.com/$repo/actions/runs/$runId"

      when {
        status == "completed" && conclusion == "success" -> {
          println("Workflow '$workflow' succeeded for commit $commitSha.")
          return runId
        }
        status == "completed" && conclusion in listOf("failure", "cancelled", "timed_out") -> {
          System.err.println(
            "❌ Workflow '$workflow' failed for commit $commitSha (conclusion=$conclusion)."
          )
          println("See: $runUrl")
          exitProcess(1)
        }
      }
    }

    if (System.currentTimeMillis() > deadline) {
      System.err.println(
        "❌ Timeout waiting for workflow '$workflow' to complete for commit $commitSha."
      )
      runUrl?.let { println("See: $it") }
      exitProcess(1)
    }

    println("Waiting for '$workflow' on commit $commitSha...")
    runUrl?.let { println("See: $it") }
    Thread.sleep(30_000)
  }
}

fun getHeadSha(repoDir: File): String =
  runCommandOutput(listOf("git", "rev-parse", "HEAD"), repoDir).trim()

/**
 * Wait for the most recent workflow run to complete in a different repository. Used when we trigger
 * a workflow but don't know the commit SHA in that repo.
 *
 * @param workflow the workflow name (e.g., "update-stoic.yaml")
 * @param repo the repository in owner/name format (e.g., "block/homebrew-tap")
 * @param localDir local directory to run commands from
 * @param timeoutMinutes how long to wait before failing
 */
fun waitForWorkflowInRepo(
  workflow: String,
  repo: String,
  localDir: File,
  timeoutMinutes: Int = 10,
) {
  val deadline = System.currentTimeMillis() + timeoutMinutes * 60_000L
  var runId: String? = null
  var lastStatus: String? = null

  // Give the workflow a moment to start
  Thread.sleep(5_000)

  while (true) {
    // Get the most recent workflow run
    val line =
      runCommandOutput(
          listOf(
            "gh",
            "run",
            "list",
            "--repo",
            repo,
            "--workflow",
            workflow,
            "--json",
            "databaseId,status,conclusion",
            "--jq",
            """.[0] | "\(.databaseId) \(.status) \(.conclusion)"""",
            "--limit",
            "1",
          ),
          localDir,
        )
        .trim()

    if (line.isNotBlank()) {
      val parts = line.split(Regex("\\s+"))
      val currentRunId = parts[0]
      val status = parts.getOrNull(1)
      val conclusion = parts.getOrNull(2)
      val runUrl = "https://github.com/$repo/actions/runs/$currentRunId"

      // Track the run ID on first encounter
      if (runId == null) {
        runId = currentRunId
        println("Tracking workflow run: $runUrl")
      }

      // Only process if this is still the same run we're tracking
      if (currentRunId == runId) {
        when {
          status == "completed" && conclusion == "success" -> {
            println("Workflow '$workflow' succeeded in $repo.")
            return
          }
          status == "completed" && conclusion in listOf("failure", "cancelled", "timed_out") -> {
            System.err.println("❌ Workflow '$workflow' failed in $repo (conclusion=$conclusion).")
            println("See: $runUrl")
            exitProcess(1)
          }
          status != lastStatus -> {
            println("Workflow status: $status")
            lastStatus = status
          }
        }
      }
    }

    if (System.currentTimeMillis() > deadline) {
      System.err.println("❌ Timeout waiting for workflow '$workflow' in $repo to complete.")
      runId?.let { println("See: https://github.com/$repo/actions/runs/$it") }
      exitProcess(1)
    }

    Thread.sleep(10_000)
  }
}

// Order of steps for resume logic
private enum class Step {
  PROMPT,
  SHELLCHECK,
  CREATE_BRANCH,
  WAIT_BUILD,
  EXTRACT,
  VERIFY_TESTS,
  TAG_RELEASE,
  WAIT_RELEASE,
  MERGE_MAIN,
  BUMP_SNAPSHOT,
  UPDATE_HOMEBREW,
}

```

`native/Makefile`:

```
# For details on how to build for the ndk, see
# https://android.googlesource.com/platform/ndk/+/master/docs/BuildSystemMaintainers.md

# Build for multiple architectures
ARCHS := arm64-v8a x86_64

# Map Android ABI names to NDK toolchain prefixes
ARCH_arm64-v8a_PREFIX := aarch64-linux-android
ARCH_x86_64_PREFIX := x86_64-linux-android

MIN_API := 26
NDK_PATH := $(ANDROID_NDK)
NDK_TOOLCHAIN := $(NDK_PATH)/toolchains/llvm/prebuilt/darwin-x86_64
SYSROOT := $(NDK_TOOLCHAIN)/sysroot

SRC := stoic.cc

.PHONY: all clean prepare $(ARCHS)

all: $(ARCHS)

# Build target for each architecture
$(ARCHS):
	@echo "Building for $@..."
	$(MAKE) -f Makefile.arch ARCH=$@ \
		ARCH_PREFIX=$(ARCH_$@_PREFIX) \
		MIN_API=$(MIN_API) \
		NDK_TOOLCHAIN=$(NDK_TOOLCHAIN) \
		SYSROOT=$(SYSROOT) \
		OUT_DIR=$(OUT_DIR)

clean:
	rm -rf $(OUT_DIR)

debug:
	@echo "ARCHS = $(ARCHS)"
	@echo "OUT_DIR = $(OUT_DIR)"

```

`native/Makefile.arch`:

```arch
# Architecture-specific build
# This Makefile is called from the main Makefile for each architecture

# Compiler setup for this architecture
CC := $(NDK_TOOLCHAIN)/bin/$(ARCH_PREFIX)$(MIN_API)-clang
CXX := $(NDK_TOOLCHAIN)/bin/$(ARCH_PREFIX)$(MIN_API)-clang++
LD := $(CXX)

# Flags
CFLAGS := -fPIC -Wall -DANDROID -D__ANDROID_UNAVAILABLE_SYMBOLS_ARE_WEAK__ -I$(SYSROOT)/usr/include -g -O0
CXXFLAGS := $(CFLAGS) -std=c++20 -Wno-c99-extensions
LDFLAGS := -L$(SYSROOT)/usr/lib -static-libstdc++ -static-libgcc -std=c++2a -landroid -llog -lEGL -lGLESv2 -lm

# Architecture-specific output directories
ARCH_OUT_DIR := $(OUT_DIR)/$(ARCH)
ARCH_SYNC_DIR := $(OUT_DIR)/sync/stoic/$(ARCH)

SRC := stoic.cc
OBJ := $(ARCH_OUT_DIR)/stoic.o
TARGET := $(ARCH_SYNC_DIR)/stoic-jvmti-agent.so

.PHONY: all prepare

all: prepare $(TARGET)

prepare:
	mkdir -p $(ARCH_OUT_DIR)
	mkdir -p $(ARCH_SYNC_DIR)

$(TARGET): $(OBJ)
	$(CXX) $(LDFLAGS) -shared -o $@ $^

$(OBJ): stoic.cc
	$(CXX) $(CXXFLAGS) -c $< -o $@

```

`native/Makefile.inc`:

```inc
# Output directory (can be overridden via environment variable)
OUT_DIR ?= ../out

#
# MIN_API is the lowest Android API level anything we build can run on. Don't
# expect a sensible error message if you try to use it on a lower API level
# though. You'll just get an error about unresolved symbols or something like
# that.
#
# There is some documentation here:
# https://android.googlesource.com/platform/ndk/+/main/docs/BuildSystemMaintainers.md#Weak-symbols-for-API-definitions
#

# NDK setup
MIN_API := 26
NDK_PATH := $(ANDROID_NDK)
NDK_PLATFORM_LEVEL := android-$(MIN_API)
NDK_TOOLCHAIN := $(NDK_PATH)/toolchains/llvm/prebuilt/darwin-x86_64
SYSROOT := $(NDK_TOOLCHAIN)/sysroot

# Compiler setup
CC := $(NDK_TOOLCHAIN)/bin/aarch64-linux-android$(MIN_API)-clang
CXX := $(NDK_TOOLCHAIN)/bin/aarch64-linux-android$(MIN_API)-clang++
LD := $(CXX)

# Flags
CFLAGS := -fPIC -Wall -DANDROID -D__ANDROID_UNAVAILABLE_SYMBOLS_ARE_WEAK__ -I$(SYSROOT)/usr/include -Ilibbase/include -Ilibnativehelper/header_only_include -g -O0
CXXFLAGS := $(CFLAGS)
LDFLAGS := -L$(SYSROOT)/usr/lib -static-libstdc++ -static-libgcc -std=c++2a -landroid -llog -lEGL -lGLESv2 -lm

```

`native/build.gradle.kts`:

```kts
// Build native C++ JVMTI agent using existing Makefile for multiple architectures

val stoicDir = rootProject.projectDir
val nativeDir = projectDir
val distributionsDir = rootProject.layout.buildDirectory.dir("distributions").get().asFile
val syncDir = distributionsDir.resolve("sync")

// Read android_ndk_version from gradle.properties
val androidNdkVersion = rootProject.providers.gradleProperty("android.ndkVersion").get()

val androidHome =
  System.getenv("ANDROID_HOME") ?: error("ANDROID_HOME environment variable not set")

val androidNdk = "$androidHome/ndk/$androidNdkVersion"

// Build for multiple architectures
val androidArchitectures = listOf("arm64-v8a", "x86_64")

tasks.register<Exec>("buildNative") {
  workingDir = nativeDir
  commandLine("make", "-j16", "all")

  environment("ANDROID_NDK", androidNdk)
  environment("OUT_DIR", distributionsDir.absolutePath)

  inputs.files(fileTree(nativeDir) { include("*.cc", "*.h", "Makefile*") })

  // Output files for each architecture
  androidArchitectures.forEach { arch ->
    outputs.file(syncDir.resolve("stoic/$arch/stoic-jvmti-agent.so"))
  }

  doFirst {
    println(
      "Building native JVMTI agent for architectures: ${androidArchitectures.joinToString(", ")}"
    )
    println("Using NDK: $androidNdk")
  }
}

tasks.register<Delete>("clean") { delete(distributionsDir) }

// Make the native build part of the default build
tasks.register("assemble") { dependsOn("buildNative") }

// Default task
defaultTasks("assemble")

```

`native/jvmti.h`:

```h
/*
 * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

    /* AUTOMATICALLY GENERATED FILE - DO NOT EDIT */


    /* Include file for the Java(tm) Virtual Machine Tool Interface */

#ifndef _JAVA_JVMTI_H_
#define _JAVA_JVMTI_H_

#include "jni.h"

#ifdef __cplusplus
extern "C" {
#endif

enum {
    JVMTI_VERSION_1   = 0x30010000,
    JVMTI_VERSION_1_0 = 0x30010000,
    JVMTI_VERSION_1_1 = 0x30010100,
    JVMTI_VERSION_1_2 = 0x30010200,

    JVMTI_VERSION = 0x30000000 + (1 * 0x10000) + (2 * 0x100) + 1  /* version: 1.2.1 */
};

JNIEXPORT jint JNICALL
Agent_OnLoad(JavaVM *vm, char *options, void *reserved);

JNIEXPORT jint JNICALL
Agent_OnAttach(JavaVM* vm, char* options, void* reserved);

JNIEXPORT void JNICALL
Agent_OnUnload(JavaVM *vm);

    /* Forward declaration of the environment */

struct _jvmtiEnv;

struct jvmtiInterface_1_;

#ifdef __cplusplus
typedef _jvmtiEnv jvmtiEnv;
#else
typedef const struct jvmtiInterface_1_ *jvmtiEnv;
#endif /* __cplusplus */

/* Derived Base Types */

typedef jobject jthread;
typedef jobject jthreadGroup;
typedef jlong jlocation;
struct _jrawMonitorID;
typedef struct _jrawMonitorID *jrawMonitorID;
typedef struct JNINativeInterface jniNativeInterface;

    /* Constants */


    /* Thread State Flags */

enum {
    JVMTI_THREAD_STATE_ALIVE = 0x0001,
    JVMTI_THREAD_STATE_TERMINATED = 0x0002,
    JVMTI_THREAD_STATE_RUNNABLE = 0x0004,
    JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = 0x0400,
    JVMTI_THREAD_STATE_WAITING = 0x0080,
    JVMTI_THREAD_STATE_WAITING_INDEFINITELY = 0x0010,
    JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT = 0x0020,
    JVMTI_THREAD_STATE_SLEEPING = 0x0040,
    JVMTI_THREAD_STATE_IN_OBJECT_WAIT = 0x0100,
    JVMTI_THREAD_STATE_PARKED = 0x0200,
    JVMTI_THREAD_STATE_SUSPENDED = 0x100000,
    JVMTI_THREAD_STATE_INTERRUPTED = 0x200000,
    JVMTI_THREAD_STATE_IN_NATIVE = 0x400000,
    JVMTI_THREAD_STATE_VENDOR_1 = 0x10000000,
    JVMTI_THREAD_STATE_VENDOR_2 = 0x20000000,
    JVMTI_THREAD_STATE_VENDOR_3 = 0x40000000
};

    /* java.lang.Thread.State Conversion Masks */

enum {
    JVMTI_JAVA_LANG_THREAD_STATE_MASK = JVMTI_THREAD_STATE_TERMINATED | JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT,
    JVMTI_JAVA_LANG_THREAD_STATE_NEW = 0,
    JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED = JVMTI_THREAD_STATE_TERMINATED,
    JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE,
    JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,
    JVMTI_JAVA_LANG_THREAD_STATE_WAITING = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY,
    JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT
};

    /* Thread Priority Constants */

enum {
    JVMTI_THREAD_MIN_PRIORITY = 1,
    JVMTI_THREAD_NORM_PRIORITY = 5,
    JVMTI_THREAD_MAX_PRIORITY = 10
};

    /* Heap Filter Flags */

enum {
    JVMTI_HEAP_FILTER_TAGGED = 0x4,
    JVMTI_HEAP_FILTER_UNTAGGED = 0x8,
    JVMTI_HEAP_FILTER_CLASS_TAGGED = 0x10,
    JVMTI_HEAP_FILTER_CLASS_UNTAGGED = 0x20
};

    /* Heap Visit Control Flags */

enum {
    JVMTI_VISIT_OBJECTS = 0x100,
    JVMTI_VISIT_ABORT = 0x8000
};

    /* Heap Reference Enumeration */

typedef enum {
    JVMTI_HEAP_REFERENCE_CLASS = 1,
    JVMTI_HEAP_REFERENCE_FIELD = 2,
    JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT = 3,
    JVMTI_HEAP_REFERENCE_CLASS_LOADER = 4,
    JVMTI_HEAP_REFERENCE_SIGNERS = 5,
    JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN = 6,
    JVMTI_HEAP_REFERENCE_INTERFACE = 7,
    JVMTI_HEAP_REFERENCE_STATIC_FIELD = 8,
    JVMTI_HEAP_REFERENCE_CONSTANT_POOL = 9,
    JVMTI_HEAP_REFERENCE_SUPERCLASS = 10,
    JVMTI_HEAP_REFERENCE_JNI_GLOBAL = 21,
    JVMTI_HEAP_REFERENCE_SYSTEM_CLASS = 22,
    JVMTI_HEAP_REFERENCE_MONITOR = 23,
    JVMTI_HEAP_REFERENCE_STACK_LOCAL = 24,
    JVMTI_HEAP_REFERENCE_JNI_LOCAL = 25,
    JVMTI_HEAP_REFERENCE_THREAD = 26,
    JVMTI_HEAP_REFERENCE_OTHER = 27
} jvmtiHeapReferenceKind;

    /* Primitive Type Enumeration */

typedef enum {
    JVMTI_PRIMITIVE_TYPE_BOOLEAN = 90,
    JVMTI_PRIMITIVE_TYPE_BYTE = 66,
    JVMTI_PRIMITIVE_TYPE_CHAR = 67,
    JVMTI_PRIMITIVE_TYPE_SHORT = 83,
    JVMTI_PRIMITIVE_TYPE_INT = 73,
    JVMTI_PRIMITIVE_TYPE_LONG = 74,
    JVMTI_PRIMITIVE_TYPE_FLOAT = 70,
    JVMTI_PRIMITIVE_TYPE_DOUBLE = 68
} jvmtiPrimitiveType;

    /* Heap Object Filter Enumeration */

typedef enum {
    JVMTI_HEAP_OBJECT_TAGGED = 1,
    JVMTI_HEAP_OBJECT_UNTAGGED = 2,
    JVMTI_HEAP_OBJECT_EITHER = 3
} jvmtiHeapObjectFilter;

    /* Heap Root Kind Enumeration */

typedef enum {
    JVMTI_HEAP_ROOT_JNI_GLOBAL = 1,
    JVMTI_HEAP_ROOT_SYSTEM_CLASS = 2,
    JVMTI_HEAP_ROOT_MONITOR = 3,
    JVMTI_HEAP_ROOT_STACK_LOCAL = 4,
    JVMTI_HEAP_ROOT_JNI_LOCAL = 5,
    JVMTI_HEAP_ROOT_THREAD = 6,
    JVMTI_HEAP_ROOT_OTHER = 7
} jvmtiHeapRootKind;

    /* Object Reference Enumeration */

typedef enum {
    JVMTI_REFERENCE_CLASS = 1,
    JVMTI_REFERENCE_FIELD = 2,
    JVMTI_REFERENCE_ARRAY_ELEMENT = 3,
    JVMTI_REFERENCE_CLASS_LOADER = 4,
    JVMTI_REFERENCE_SIGNERS = 5,
    JVMTI_REFERENCE_PROTECTION_DOMAIN = 6,
    JVMTI_REFERENCE_INTERFACE = 7,
    JVMTI_REFERENCE_STATIC_FIELD = 8,
    JVMTI_REFERENCE_CONSTANT_POOL = 9
} jvmtiObjectReferenceKind;

    /* Iteration Control Enumeration */

typedef enum {
    JVMTI_ITERATION_CONTINUE = 1,
    JVMTI_ITERATION_IGNORE = 2,
    JVMTI_ITERATION_ABORT = 0
} jvmtiIterationControl;

    /* Class Status Flags */

enum {
    JVMTI_CLASS_STATUS_VERIFIED = 1,
    JVMTI_CLASS_STATUS_PREPARED = 2,
    JVMTI_CLASS_STATUS_INITIALIZED = 4,
    JVMTI_CLASS_STATUS_ERROR = 8,
    JVMTI_CLASS_STATUS_ARRAY = 16,
    JVMTI_CLASS_STATUS_PRIMITIVE = 32
};

    /* Event Enable/Disable */

typedef enum {
    JVMTI_ENABLE = 1,
    JVMTI_DISABLE = 0
} jvmtiEventMode;

    /* Extension Function/Event Parameter Types */

typedef enum {
    JVMTI_TYPE_JBYTE = 101,
    JVMTI_TYPE_JCHAR = 102,
    JVMTI_TYPE_JSHORT = 103,
    JVMTI_TYPE_JINT = 104,
    JVMTI_TYPE_JLONG = 105,
    JVMTI_TYPE_JFLOAT = 106,
    JVMTI_TYPE_JDOUBLE = 107,
    JVMTI_TYPE_JBOOLEAN = 108,
    JVMTI_TYPE_JOBJECT = 109,
    JVMTI_TYPE_JTHREAD = 110,
    JVMTI_TYPE_JCLASS = 111,
    JVMTI_TYPE_JVALUE = 112,
    JVMTI_TYPE_JFIELDID = 113,
    JVMTI_TYPE_JMETHODID = 114,
    JVMTI_TYPE_CCHAR = 115,
    JVMTI_TYPE_CVOID = 116,
    JVMTI_TYPE_JNIENV = 117
} jvmtiParamTypes;

    /* Extension Function/Event Parameter Kinds */

typedef enum {
    JVMTI_KIND_IN = 91,
    JVMTI_KIND_IN_PTR = 92,
    JVMTI_KIND_IN_BUF = 93,
    JVMTI_KIND_ALLOC_BUF = 94,
    JVMTI_KIND_ALLOC_ALLOC_BUF = 95,
    JVMTI_KIND_OUT = 96,
    JVMTI_KIND_OUT_BUF = 97
} jvmtiParamKind;

    /* Timer Kinds */

typedef enum {
    JVMTI_TIMER_USER_CPU = 30,
    JVMTI_TIMER_TOTAL_CPU = 31,
    JVMTI_TIMER_ELAPSED = 32
} jvmtiTimerKind;

    /* Phases of execution */

typedef enum {
    JVMTI_PHASE_ONLOAD = 1,
    JVMTI_PHASE_PRIMORDIAL = 2,
    JVMTI_PHASE_START = 6,
    JVMTI_PHASE_LIVE = 4,
    JVMTI_PHASE_DEAD = 8
} jvmtiPhase;

    /* Version Interface Types */

enum {
    JVMTI_VERSION_INTERFACE_JNI = 0x00000000,
    JVMTI_VERSION_INTERFACE_JVMTI = 0x30000000
};

    /* Version Masks */

enum {
    JVMTI_VERSION_MASK_INTERFACE_TYPE = 0x70000000,
    JVMTI_VERSION_MASK_MAJOR = 0x0FFF0000,
    JVMTI_VERSION_MASK_MINOR = 0x0000FF00,
    JVMTI_VERSION_MASK_MICRO = 0x000000FF
};

    /* Version Shifts */

enum {
    JVMTI_VERSION_SHIFT_MAJOR = 16,
    JVMTI_VERSION_SHIFT_MINOR = 8,
    JVMTI_VERSION_SHIFT_MICRO = 0
};

    /* Verbose Flag Enumeration */

typedef enum {
    JVMTI_VERBOSE_OTHER = 0,
    JVMTI_VERBOSE_GC = 1,
    JVMTI_VERBOSE_CLASS = 2,
    JVMTI_VERBOSE_JNI = 4
} jvmtiVerboseFlag;

    /* JLocation Format Enumeration */

typedef enum {
    JVMTI_JLOCATION_JVMBCI = 1,
    JVMTI_JLOCATION_MACHINEPC = 2,
    JVMTI_JLOCATION_OTHER = 0
} jvmtiJlocationFormat;

    /* Resource Exhaustion Flags */

enum {
    JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR = 0x0001,
    JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP = 0x0002,
    JVMTI_RESOURCE_EXHAUSTED_THREADS = 0x0004
};

    /* Errors */

typedef enum {
    JVMTI_ERROR_NONE = 0,
    JVMTI_ERROR_INVALID_THREAD = 10,
    JVMTI_ERROR_INVALID_THREAD_GROUP = 11,
    JVMTI_ERROR_INVALID_PRIORITY = 12,
    JVMTI_ERROR_THREAD_NOT_SUSPENDED = 13,
    JVMTI_ERROR_THREAD_SUSPENDED = 14,
    JVMTI_ERROR_THREAD_NOT_ALIVE = 15,
    JVMTI_ERROR_INVALID_OBJECT = 20,
    JVMTI_ERROR_INVALID_CLASS = 21,
    JVMTI_ERROR_CLASS_NOT_PREPARED = 22,
    JVMTI_ERROR_INVALID_METHODID = 23,
    JVMTI_ERROR_INVALID_LOCATION = 24,
    JVMTI_ERROR_INVALID_FIELDID = 25,
    JVMTI_ERROR_NO_MORE_FRAMES = 31,
    JVMTI_ERROR_OPAQUE_FRAME = 32,
    JVMTI_ERROR_TYPE_MISMATCH = 34,
    JVMTI_ERROR_INVALID_SLOT = 35,
    JVMTI_ERROR_DUPLICATE = 40,
    JVMTI_ERROR_NOT_FOUND = 41,
    JVMTI_ERROR_INVALID_MONITOR = 50,
    JVMTI_ERROR_NOT_MONITOR_OWNER = 51,
    JVMTI_ERROR_INTERRUPT = 52,
    JVMTI_ERROR_INVALID_CLASS_FORMAT = 60,
    JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION = 61,
    JVMTI_ERROR_FAILS_VERIFICATION = 62,
    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED = 63,
    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED = 64,
    JVMTI_ERROR_INVALID_TYPESTATE = 65,
    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED = 66,
    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED = 67,
    JVMTI_ERROR_UNSUPPORTED_VERSION = 68,
    JVMTI_ERROR_NAMES_DONT_MATCH = 69,
    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED = 70,
    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED = 71,
    JVMTI_ERROR_UNMODIFIABLE_CLASS = 79,
    JVMTI_ERROR_NOT_AVAILABLE = 98,
    JVMTI_ERROR_MUST_POSSESS_CAPABILITY = 99,
    JVMTI_ERROR_NULL_POINTER = 100,
    JVMTI_ERROR_ABSENT_INFORMATION = 101,
    JVMTI_ERROR_INVALID_EVENT_TYPE = 102,
    JVMTI_ERROR_ILLEGAL_ARGUMENT = 103,
    JVMTI_ERROR_NATIVE_METHOD = 104,
    JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED = 106,
    JVMTI_ERROR_OUT_OF_MEMORY = 110,
    JVMTI_ERROR_ACCESS_DENIED = 111,
    JVMTI_ERROR_WRONG_PHASE = 112,
    JVMTI_ERROR_INTERNAL = 113,
    JVMTI_ERROR_UNATTACHED_THREAD = 115,
    JVMTI_ERROR_INVALID_ENVIRONMENT = 116,
    JVMTI_ERROR_MAX = 116
} jvmtiError;

    /* Event IDs */

typedef enum {
    JVMTI_MIN_EVENT_TYPE_VAL = 50,
    JVMTI_EVENT_VM_INIT = 50,
    JVMTI_EVENT_VM_DEATH = 51,
    JVMTI_EVENT_THREAD_START = 52,
    JVMTI_EVENT_THREAD_END = 53,
    JVMTI_EVENT_CLASS_FILE_LOAD_HOOK = 54,
    JVMTI_EVENT_CLASS_LOAD = 55,
    JVMTI_EVENT_CLASS_PREPARE = 56,
    JVMTI_EVENT_VM_START = 57,
    JVMTI_EVENT_EXCEPTION = 58,
    JVMTI_EVENT_EXCEPTION_CATCH = 59,
    JVMTI_EVENT_SINGLE_STEP = 60,
    JVMTI_EVENT_FRAME_POP = 61,
    JVMTI_EVENT_BREAKPOINT = 62,
    JVMTI_EVENT_FIELD_ACCESS = 63,
    JVMTI_EVENT_FIELD_MODIFICATION = 64,
    JVMTI_EVENT_METHOD_ENTRY = 65,
    JVMTI_EVENT_METHOD_EXIT = 66,
    JVMTI_EVENT_NATIVE_METHOD_BIND = 67,
    JVMTI_EVENT_COMPILED_METHOD_LOAD = 68,
    JVMTI_EVENT_COMPILED_METHOD_UNLOAD = 69,
    JVMTI_EVENT_DYNAMIC_CODE_GENERATED = 70,
    JVMTI_EVENT_DATA_DUMP_REQUEST = 71,
    JVMTI_EVENT_MONITOR_WAIT = 73,
    JVMTI_EVENT_MONITOR_WAITED = 74,
    JVMTI_EVENT_MONITOR_CONTENDED_ENTER = 75,
    JVMTI_EVENT_MONITOR_CONTENDED_ENTERED = 76,
    JVMTI_EVENT_RESOURCE_EXHAUSTED = 80,
    JVMTI_EVENT_GARBAGE_COLLECTION_START = 81,
    JVMTI_EVENT_GARBAGE_COLLECTION_FINISH = 82,
    JVMTI_EVENT_OBJECT_FREE = 83,
    JVMTI_EVENT_VM_OBJECT_ALLOC = 84,
    JVMTI_MAX_EVENT_TYPE_VAL = 84
} jvmtiEvent;


    /* Pre-Declarations */
struct _jvmtiThreadInfo;
typedef struct _jvmtiThreadInfo jvmtiThreadInfo;
struct _jvmtiMonitorStackDepthInfo;
typedef struct _jvmtiMonitorStackDepthInfo jvmtiMonitorStackDepthInfo;
struct _jvmtiThreadGroupInfo;
typedef struct _jvmtiThreadGroupInfo jvmtiThreadGroupInfo;
struct _jvmtiFrameInfo;
typedef struct _jvmtiFrameInfo jvmtiFrameInfo;
struct _jvmtiStackInfo;
typedef struct _jvmtiStackInfo jvmtiStackInfo;
struct _jvmtiHeapReferenceInfoField;
typedef struct _jvmtiHeapReferenceInfoField jvmtiHeapReferenceInfoField;
struct _jvmtiHeapReferenceInfoArray;
typedef struct _jvmtiHeapReferenceInfoArray jvmtiHeapReferenceInfoArray;
struct _jvmtiHeapReferenceInfoConstantPool;
typedef struct _jvmtiHeapReferenceInfoConstantPool jvmtiHeapReferenceInfoConstantPool;
struct _jvmtiHeapReferenceInfoStackLocal;
typedef struct _jvmtiHeapReferenceInfoStackLocal jvmtiHeapReferenceInfoStackLocal;
struct _jvmtiHeapReferenceInfoJniLocal;
typedef struct _jvmtiHeapReferenceInfoJniLocal jvmtiHeapReferenceInfoJniLocal;
struct _jvmtiHeapReferenceInfoReserved;
typedef struct _jvmtiHeapReferenceInfoReserved jvmtiHeapReferenceInfoReserved;
union _jvmtiHeapReferenceInfo;
typedef union _jvmtiHeapReferenceInfo jvmtiHeapReferenceInfo;
struct _jvmtiHeapCallbacks;
typedef struct _jvmtiHeapCallbacks jvmtiHeapCallbacks;
struct _jvmtiClassDefinition;
typedef struct _jvmtiClassDefinition jvmtiClassDefinition;
struct _jvmtiMonitorUsage;
typedef struct _jvmtiMonitorUsage jvmtiMonitorUsage;
struct _jvmtiLineNumberEntry;
typedef struct _jvmtiLineNumberEntry jvmtiLineNumberEntry;
struct _jvmtiLocalVariableEntry;
typedef struct _jvmtiLocalVariableEntry jvmtiLocalVariableEntry;
struct _jvmtiParamInfo;
typedef struct _jvmtiParamInfo jvmtiParamInfo;
struct _jvmtiExtensionFunctionInfo;
typedef struct _jvmtiExtensionFunctionInfo jvmtiExtensionFunctionInfo;
struct _jvmtiExtensionEventInfo;
typedef struct _jvmtiExtensionEventInfo jvmtiExtensionEventInfo;
struct _jvmtiTimerInfo;
typedef struct _jvmtiTimerInfo jvmtiTimerInfo;
struct _jvmtiAddrLocationMap;
typedef struct _jvmtiAddrLocationMap jvmtiAddrLocationMap;

    /* Function Types */

typedef void (JNICALL *jvmtiStartFunction)
    (jvmtiEnv* jvmti_env, JNIEnv* jni_env, void* arg);

typedef jint (JNICALL *jvmtiHeapIterationCallback)
    (jlong class_tag, jlong size, jlong* tag_ptr, jint length, void* user_data);

typedef jint (JNICALL *jvmtiHeapReferenceCallback)
    (jvmtiHeapReferenceKind reference_kind, const jvmtiHeapReferenceInfo* reference_info, jlong class_tag, jlong referrer_class_tag, jlong size, jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data);

typedef jint (JNICALL *jvmtiPrimitiveFieldCallback)
    (jvmtiHeapReferenceKind kind, const jvmtiHeapReferenceInfo* info, jlong object_class_tag, jlong* object_tag_ptr, jvalue value, jvmtiPrimitiveType value_type, void* user_data);

typedef jint (JNICALL *jvmtiArrayPrimitiveValueCallback)
    (jlong class_tag, jlong size, jlong* tag_ptr, jint element_count, jvmtiPrimitiveType element_type, const void* elements, void* user_data);

typedef jint (JNICALL *jvmtiStringPrimitiveValueCallback)
    (jlong class_tag, jlong size, jlong* tag_ptr, const jchar* value, jint value_length, void* user_data);

typedef jint (JNICALL *jvmtiReservedCallback)
    ();

typedef jvmtiIterationControl (JNICALL *jvmtiHeapObjectCallback)
    (jlong class_tag, jlong size, jlong* tag_ptr, void* user_data);

typedef jvmtiIterationControl (JNICALL *jvmtiHeapRootCallback)
    (jvmtiHeapRootKind root_kind, jlong class_tag, jlong size, jlong* tag_ptr, void* user_data);

typedef jvmtiIterationControl (JNICALL *jvmtiStackReferenceCallback)
    (jvmtiHeapRootKind root_kind, jlong class_tag, jlong size, jlong* tag_ptr, jlong thread_tag, jint depth, jmethodID method, jint slot, void* user_data);

typedef jvmtiIterationControl (JNICALL *jvmtiObjectReferenceCallback)
    (jvmtiObjectReferenceKind reference_kind, jlong class_tag, jlong size, jlong* tag_ptr, jlong referrer_tag, jint referrer_index, void* user_data);

typedef jvmtiError (JNICALL *jvmtiExtensionFunction)
    (jvmtiEnv* jvmti_env,  ...);

typedef void (JNICALL *jvmtiExtensionEvent)
    (jvmtiEnv* jvmti_env,  ...);


    /* Structure Types */
struct _jvmtiThreadInfo {
    char* name;
    jint priority;
    jboolean is_daemon;
    jthreadGroup thread_group;
    jobject context_class_loader;
};
struct _jvmtiMonitorStackDepthInfo {
    jobject monitor;
    jint stack_depth;
};
struct _jvmtiThreadGroupInfo {
    jthreadGroup parent;
    char* name;
    jint max_priority;
    jboolean is_daemon;
};
struct _jvmtiFrameInfo {
    jmethodID method;
    jlocation location;
};
struct _jvmtiStackInfo {
    jthread thread;
    jint state;
    jvmtiFrameInfo* frame_buffer;
    jint frame_count;
};
struct _jvmtiHeapReferenceInfoField {
    jint index;
};
struct _jvmtiHeapReferenceInfoArray {
    jint index;
};
struct _jvmtiHeapReferenceInfoConstantPool {
    jint index;
};
struct _jvmtiHeapReferenceInfoStackLocal {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
};
struct _jvmtiHeapReferenceInfoJniLocal {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
};
struct _jvmtiHeapReferenceInfoReserved {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
};
union _jvmtiHeapReferenceInfo {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
};
struct _jvmtiHeapCallbacks {
    jvmtiHeapIterationCallback heap_iteration_callback;
    jvmtiHeapReferenceCallback heap_reference_callback;
    jvmtiPrimitiveFieldCallback primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback reserved5;
    jvmtiReservedCallback reserved6;
    jvmtiReservedCallback reserved7;
    jvmtiReservedCallback reserved8;
    jvmtiReservedCallback reserved9;
    jvmtiReservedCallback reserved10;
    jvmtiReservedCallback reserved11;
    jvmtiReservedCallback reserved12;
    jvmtiReservedCallback reserved13;
    jvmtiReservedCallback reserved14;
    jvmtiReservedCallback reserved15;
};
struct _jvmtiClassDefinition {
    jclass klass;
    jint class_byte_count;
    const unsigned char* class_bytes;
};
struct _jvmtiMonitorUsage {
    jthread owner;
    jint entry_count;
    jint waiter_count;
    jthread* waiters;
    jint notify_waiter_count;
    jthread* notify_waiters;
};
struct _jvmtiLineNumberEntry {
    jlocation start_location;
    jint line_number;
};
struct _jvmtiLocalVariableEntry {
    jlocation start_location;
    jint length;
    char* name;
    char* signature;
    char* generic_signature;
    jint slot;
};
struct _jvmtiParamInfo {
    char* name;
    jvmtiParamKind kind;
    jvmtiParamTypes base_type;
    jboolean null_ok;
};
struct _jvmtiExtensionFunctionInfo {
    jvmtiExtensionFunction func;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
    jint error_count;
    jvmtiError* errors;
};
struct _jvmtiExtensionEventInfo {
    jint extension_event_index;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
};
struct _jvmtiTimerInfo {
    jlong max_value;
    jboolean may_skip_forward;
    jboolean may_skip_backward;
    jvmtiTimerKind kind;
    jlong reserved1;
    jlong reserved2;
};
struct _jvmtiAddrLocationMap {
    const void* start_address;
    jlocation location;
};

typedef struct {
    unsigned int can_tag_objects : 1;
    unsigned int can_generate_field_modification_events : 1;
    unsigned int can_generate_field_access_events : 1;
    unsigned int can_get_bytecodes : 1;
    unsigned int can_get_synthetic_attribute : 1;
    unsigned int can_get_owned_monitor_info : 1;
    unsigned int can_get_current_contended_monitor : 1;
    unsigned int can_get_monitor_info : 1;
    unsigned int can_pop_frame : 1;
    unsigned int can_redefine_classes : 1;
    unsigned int can_signal_thread : 1;
    unsigned int can_get_source_file_name : 1;
    unsigned int can_get_line_numbers : 1;
    unsigned int can_get_source_debug_extension : 1;
    unsigned int can_access_local_variables : 1;
    unsigned int can_maintain_original_method_order : 1;
    unsigned int can_generate_single_step_events : 1;
    unsigned int can_generate_exception_events : 1;
    unsigned int can_generate_frame_pop_events : 1;
    unsigned int can_generate_breakpoint_events : 1;
    unsigned int can_suspend : 1;
    unsigned int can_redefine_any_class : 1;
    unsigned int can_get_current_thread_cpu_time : 1;
    unsigned int can_get_thread_cpu_time : 1;
    unsigned int can_generate_method_entry_events : 1;
    unsigned int can_generate_method_exit_events : 1;
    unsigned int can_generate_all_class_hook_events : 1;
    unsigned int can_generate_compiled_method_load_events : 1;
    unsigned int can_generate_monitor_events : 1;
    unsigned int can_generate_vm_object_alloc_events : 1;
    unsigned int can_generate_native_method_bind_events : 1;
    unsigned int can_generate_garbage_collection_events : 1;
    unsigned int can_generate_object_free_events : 1;
    unsigned int can_force_early_return : 1;
    unsigned int can_get_owned_monitor_stack_depth_info : 1;
    unsigned int can_get_constant_pool : 1;
    unsigned int can_set_native_method_prefix : 1;
    unsigned int can_retransform_classes : 1;
    unsigned int can_retransform_any_class : 1;
    unsigned int can_generate_resource_exhaustion_heap_events : 1;
    unsigned int can_generate_resource_exhaustion_threads_events : 1;
    unsigned int : 7;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
} jvmtiCapabilities;


    /* Event Definitions */

typedef void (JNICALL *jvmtiEventReserved)(void);


typedef void (JNICALL *jvmtiEventBreakpoint)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jlocation location);

typedef void (JNICALL *jvmtiEventClassFileLoadHook)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jclass class_being_redefined,
     jobject loader,
     const char* name,
     jobject protection_domain,
     jint class_data_len,
     const unsigned char* class_data,
     jint* new_class_data_len,
     unsigned char** new_class_data);

typedef void (JNICALL *jvmtiEventClassLoad)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jclass klass);

typedef void (JNICALL *jvmtiEventClassPrepare)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jclass klass);

typedef void (JNICALL *jvmtiEventCompiledMethodLoad)
    (jvmtiEnv *jvmti_env,
     jmethodID method,
     jint code_size,
     const void* code_addr,
     jint map_length,
     const jvmtiAddrLocationMap* map,
     const void* compile_info);

typedef void (JNICALL *jvmtiEventCompiledMethodUnload)
    (jvmtiEnv *jvmti_env,
     jmethodID method,
     const void* code_addr);

typedef void (JNICALL *jvmtiEventDataDumpRequest)
    (jvmtiEnv *jvmti_env);

typedef void (JNICALL *jvmtiEventDynamicCodeGenerated)
    (jvmtiEnv *jvmti_env,
     const char* name,
     const void* address,
     jint length);

typedef void (JNICALL *jvmtiEventException)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jlocation location,
     jobject exception,
     jmethodID catch_method,
     jlocation catch_location);

typedef void (JNICALL *jvmtiEventExceptionCatch)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jlocation location,
     jobject exception);

typedef void (JNICALL *jvmtiEventFieldAccess)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jlocation location,
     jclass field_klass,
     jobject object,
     jfieldID field);

typedef void (JNICALL *jvmtiEventFieldModification)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jlocation location,
     jclass field_klass,
     jobject object,
     jfieldID field,
     char signature_type,
     jvalue new_value);

typedef void (JNICALL *jvmtiEventFramePop)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jboolean was_popped_by_exception);

typedef void (JNICALL *jvmtiEventGarbageCollectionFinish)
    (jvmtiEnv *jvmti_env);

typedef void (JNICALL *jvmtiEventGarbageCollectionStart)
    (jvmtiEnv *jvmti_env);

typedef void (JNICALL *jvmtiEventMethodEntry)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method);

typedef void (JNICALL *jvmtiEventMethodExit)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jboolean was_popped_by_exception,
     jvalue return_value);

typedef void (JNICALL *jvmtiEventMonitorContendedEnter)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jobject object);

typedef void (JNICALL *jvmtiEventMonitorContendedEntered)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jobject object);

typedef void (JNICALL *jvmtiEventMonitorWait)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jobject object,
     jlong timeout);

typedef void (JNICALL *jvmtiEventMonitorWaited)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jobject object,
     jboolean timed_out);

typedef void (JNICALL *jvmtiEventNativeMethodBind)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     void* address,
     void** new_address_ptr);

typedef void (JNICALL *jvmtiEventObjectFree)
    (jvmtiEnv *jvmti_env,
     jlong tag);

typedef void (JNICALL *jvmtiEventResourceExhausted)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jint flags,
     const void* reserved,
     const char* description);

typedef void (JNICALL *jvmtiEventSingleStep)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jlocation location);

typedef void (JNICALL *jvmtiEventThreadEnd)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

typedef void (JNICALL *jvmtiEventThreadStart)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

typedef void (JNICALL *jvmtiEventVMDeath)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env);

typedef void (JNICALL *jvmtiEventVMInit)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

typedef void (JNICALL *jvmtiEventVMObjectAlloc)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jobject object,
     jclass object_klass,
     jlong size);

typedef void (JNICALL *jvmtiEventVMStart)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env);

    /* Event Callback Structure */

typedef struct {
                              /*   50 : VM Initialization Event */
    jvmtiEventVMInit VMInit;
                              /*   51 : VM Death Event */
    jvmtiEventVMDeath VMDeath;
                              /*   52 : Thread Start */
    jvmtiEventThreadStart ThreadStart;
                              /*   53 : Thread End */
    jvmtiEventThreadEnd ThreadEnd;
                              /*   54 : Class File Load Hook */
    jvmtiEventClassFileLoadHook ClassFileLoadHook;
                              /*   55 : Class Load */
    jvmtiEventClassLoad ClassLoad;
                              /*   56 : Class Prepare */
    jvmtiEventClassPrepare ClassPrepare;
                              /*   57 : VM Start Event */
    jvmtiEventVMStart VMStart;
                              /*   58 : Exception */
    jvmtiEventException Exception;
                              /*   59 : Exception Catch */
    jvmtiEventExceptionCatch ExceptionCatch;
                              /*   60 : Single Step */
    jvmtiEventSingleStep SingleStep;
                              /*   61 : Frame Pop */
    jvmtiEventFramePop FramePop;
                              /*   62 : Breakpoint */
    jvmtiEventBreakpoint Breakpoint;
                              /*   63 : Field Access */
    jvmtiEventFieldAccess FieldAccess;
                              /*   64 : Field Modification */
    jvmtiEventFieldModification FieldModification;
                              /*   65 : Method Entry */
    jvmtiEventMethodEntry MethodEntry;
                              /*   66 : Method Exit */
    jvmtiEventMethodExit MethodExit;
                              /*   67 : Native Method Bind */
    jvmtiEventNativeMethodBind NativeMethodBind;
                              /*   68 : Compiled Method Load */
    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
                              /*   69 : Compiled Method Unload */
    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
                              /*   70 : Dynamic Code Generated */
    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
                              /*   71 : Data Dump Request */
    jvmtiEventDataDumpRequest DataDumpRequest;
                              /*   72 */
    jvmtiEventReserved reserved72;
                              /*   73 : Monitor Wait */
    jvmtiEventMonitorWait MonitorWait;
                              /*   74 : Monitor Waited */
    jvmtiEventMonitorWaited MonitorWaited;
                              /*   75 : Monitor Contended Enter */
    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
                              /*   76 : Monitor Contended Entered */
    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
                              /*   77 */
    jvmtiEventReserved reserved77;
                              /*   78 */
    jvmtiEventReserved reserved78;
                              /*   79 */
    jvmtiEventReserved reserved79;
                              /*   80 : Resource Exhausted */
    jvmtiEventResourceExhausted ResourceExhausted;
                              /*   81 : Garbage Collection Start */
    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
                              /*   82 : Garbage Collection Finish */
    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
                              /*   83 : Object Free */
    jvmtiEventObjectFree ObjectFree;
                              /*   84 : VM Object Allocation */
    jvmtiEventVMObjectAlloc VMObjectAlloc;
} jvmtiEventCallbacks;


    /* Function Interface */

typedef struct jvmtiInterface_1_ {

  /*   1 :  RESERVED */
  void *reserved1;

  /*   2 : Set Event Notification Mode */
  jvmtiError (JNICALL *SetEventNotificationMode) (jvmtiEnv* env,
    jvmtiEventMode mode,
    jvmtiEvent event_type,
    jthread event_thread,
     ...);

  /*   3 :  RESERVED */
  void *reserved3;

  /*   4 : Get All Threads */
  jvmtiError (JNICALL *GetAllThreads) (jvmtiEnv* env,
    jint* threads_count_ptr,
    jthread** threads_ptr);

  /*   5 : Suspend Thread */
  jvmtiError (JNICALL *SuspendThread) (jvmtiEnv* env,
    jthread thread);

  /*   6 : Resume Thread */
  jvmtiError (JNICALL *ResumeThread) (jvmtiEnv* env,
    jthread thread);

  /*   7 : Stop Thread */
  jvmtiError (JNICALL *StopThread) (jvmtiEnv* env,
    jthread thread,
    jobject exception);

  /*   8 : Interrupt Thread */
  jvmtiError (JNICALL *InterruptThread) (jvmtiEnv* env,
    jthread thread);

  /*   9 : Get Thread Info */
  jvmtiError (JNICALL *GetThreadInfo) (jvmtiEnv* env,
    jthread thread,
    jvmtiThreadInfo* info_ptr);

  /*   10 : Get Owned Monitor Info */
  jvmtiError (JNICALL *GetOwnedMonitorInfo) (jvmtiEnv* env,
    jthread thread,
    jint* owned_monitor_count_ptr,
    jobject** owned_monitors_ptr);

  /*   11 : Get Current Contended Monitor */
  jvmtiError (JNICALL *GetCurrentContendedMonitor) (jvmtiEnv* env,
    jthread thread,
    jobject* monitor_ptr);

  /*   12 : Run Agent Thread */
  jvmtiError (JNICALL *RunAgentThread) (jvmtiEnv* env,
    jthread thread,
    jvmtiStartFunction proc,
    const void* arg,
    jint priority);

  /*   13 : Get Top Thread Groups */
  jvmtiError (JNICALL *GetTopThreadGroups) (jvmtiEnv* env,
    jint* group_count_ptr,
    jthreadGroup** groups_ptr);

  /*   14 : Get Thread Group Info */
  jvmtiError (JNICALL *GetThreadGroupInfo) (jvmtiEnv* env,
    jthreadGroup group,
    jvmtiThreadGroupInfo* info_ptr);

  /*   15 : Get Thread Group Children */
  jvmtiError (JNICALL *GetThreadGroupChildren) (jvmtiEnv* env,
    jthreadGroup group,
    jint* thread_count_ptr,
    jthread** threads_ptr,
    jint* group_count_ptr,
    jthreadGroup** groups_ptr);

  /*   16 : Get Frame Count */
  jvmtiError (JNICALL *GetFrameCount) (jvmtiEnv* env,
    jthread thread,
    jint* count_ptr);

  /*   17 : Get Thread State */
  jvmtiError (JNICALL *GetThreadState) (jvmtiEnv* env,
    jthread thread,
    jint* thread_state_ptr);

  /*   18 : Get Current Thread */
  jvmtiError (JNICALL *GetCurrentThread) (jvmtiEnv* env,
    jthread* thread_ptr);

  /*   19 : Get Frame Location */
  jvmtiError (JNICALL *GetFrameLocation) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jmethodID* method_ptr,
    jlocation* location_ptr);

  /*   20 : Notify Frame Pop */
  jvmtiError (JNICALL *NotifyFramePop) (jvmtiEnv* env,
    jthread thread,
    jint depth);

  /*   21 : Get Local Variable - Object */
  jvmtiError (JNICALL *GetLocalObject) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jobject* value_ptr);

  /*   22 : Get Local Variable - Int */
  jvmtiError (JNICALL *GetLocalInt) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jint* value_ptr);

  /*   23 : Get Local Variable - Long */
  jvmtiError (JNICALL *GetLocalLong) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jlong* value_ptr);

  /*   24 : Get Local Variable - Float */
  jvmtiError (JNICALL *GetLocalFloat) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jfloat* value_ptr);

  /*   25 : Get Local Variable - Double */
  jvmtiError (JNICALL *GetLocalDouble) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jdouble* value_ptr);

  /*   26 : Set Local Variable - Object */
  jvmtiError (JNICALL *SetLocalObject) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jobject value);

  /*   27 : Set Local Variable - Int */
  jvmtiError (JNICALL *SetLocalInt) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jint value);

  /*   28 : Set Local Variable - Long */
  jvmtiError (JNICALL *SetLocalLong) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jlong value);

  /*   29 : Set Local Variable - Float */
  jvmtiError (JNICALL *SetLocalFloat) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jfloat value);

  /*   30 : Set Local Variable - Double */
  jvmtiError (JNICALL *SetLocalDouble) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jdouble value);

  /*   31 : Create Raw Monitor */
  jvmtiError (JNICALL *CreateRawMonitor) (jvmtiEnv* env,
    const char* name,
    jrawMonitorID* monitor_ptr);

  /*   32 : Destroy Raw Monitor */
  jvmtiError (JNICALL *DestroyRawMonitor) (jvmtiEnv* env,
    jrawMonitorID monitor);

  /*   33 : Raw Monitor Enter */
  jvmtiError (JNICALL *RawMonitorEnter) (jvmtiEnv* env,
    jrawMonitorID monitor);

  /*   34 : Raw Monitor Exit */
  jvmtiError (JNICALL *RawMonitorExit) (jvmtiEnv* env,
    jrawMonitorID monitor);

  /*   35 : Raw Monitor Wait */
  jvmtiError (JNICALL *RawMonitorWait) (jvmtiEnv* env,
    jrawMonitorID monitor,
    jlong millis);

  /*   36 : Raw Monitor Notify */
  jvmtiError (JNICALL *RawMonitorNotify) (jvmtiEnv* env,
    jrawMonitorID monitor);

  /*   37 : Raw Monitor Notify All */
  jvmtiError (JNICALL *RawMonitorNotifyAll) (jvmtiEnv* env,
    jrawMonitorID monitor);

  /*   38 : Set Breakpoint */
  jvmtiError (JNICALL *SetBreakpoint) (jvmtiEnv* env,
    jmethodID method,
    jlocation location);

  /*   39 : Clear Breakpoint */
  jvmtiError (JNICALL *ClearBreakpoint) (jvmtiEnv* env,
    jmethodID method,
    jlocation location);

  /*   40 :  RESERVED */
  void *reserved40;

  /*   41 : Set Field Access Watch */
  jvmtiError (JNICALL *SetFieldAccessWatch) (jvmtiEnv* env,
    jclass klass,
    jfieldID field);

  /*   42 : Clear Field Access Watch */
  jvmtiError (JNICALL *ClearFieldAccessWatch) (jvmtiEnv* env,
    jclass klass,
    jfieldID field);

  /*   43 : Set Field Modification Watch */
  jvmtiError (JNICALL *SetFieldModificationWatch) (jvmtiEnv* env,
    jclass klass,
    jfieldID field);

  /*   44 : Clear Field Modification Watch */
  jvmtiError (JNICALL *ClearFieldModificationWatch) (jvmtiEnv* env,
    jclass klass,
    jfieldID field);

  /*   45 : Is Modifiable Class */
  jvmtiError (JNICALL *IsModifiableClass) (jvmtiEnv* env,
    jclass klass,
    jboolean* is_modifiable_class_ptr);

  /*   46 : Allocate */
  jvmtiError (JNICALL *Allocate) (jvmtiEnv* env,
    jlong size,
    unsigned char** mem_ptr);

  /*   47 : Deallocate */
  jvmtiError (JNICALL *Deallocate) (jvmtiEnv* env,
    unsigned char* mem);

  /*   48 : Get Class Signature */
  jvmtiError (JNICALL *GetClassSignature) (jvmtiEnv* env,
    jclass klass,
    char** signature_ptr,
    char** generic_ptr);

  /*   49 : Get Class Status */
  jvmtiError (JNICALL *GetClassStatus) (jvmtiEnv* env,
    jclass klass,
    jint* status_ptr);

  /*   50 : Get Source File Name */
  jvmtiError (JNICALL *GetSourceFileName) (jvmtiEnv* env,
    jclass klass,
    char** source_name_ptr);

  /*   51 : Get Class Modifiers */
  jvmtiError (JNICALL *GetClassModifiers) (jvmtiEnv* env,
    jclass klass,
    jint* modifiers_ptr);

  /*   52 : Get Class Methods */
  jvmtiError (JNICALL *GetClassMethods) (jvmtiEnv* env,
    jclass klass,
    jint* method_count_ptr,
    jmethodID** methods_ptr);

  /*   53 : Get Class Fields */
  jvmtiError (JNICALL *GetClassFields) (jvmtiEnv* env,
    jclass klass,
    jint* field_count_ptr,
    jfieldID** fields_ptr);

  /*   54 : Get Implemented Interfaces */
  jvmtiError (JNICALL *GetImplementedInterfaces) (jvmtiEnv* env,
    jclass klass,
    jint* interface_count_ptr,
    jclass** interfaces_ptr);

  /*   55 : Is Interface */
  jvmtiError (JNICALL *IsInterface) (jvmtiEnv* env,
    jclass klass,
    jboolean* is_interface_ptr);

  /*   56 : Is Array Class */
  jvmtiError (JNICALL *IsArrayClass) (jvmtiEnv* env,
    jclass klass,
    jboolean* is_array_class_ptr);

  /*   57 : Get Class Loader */
  jvmtiError (JNICALL *GetClassLoader) (jvmtiEnv* env,
    jclass klass,
    jobject* classloader_ptr);

  /*   58 : Get Object Hash Code */
  jvmtiError (JNICALL *GetObjectHashCode) (jvmtiEnv* env,
    jobject object,
    jint* hash_code_ptr);

  /*   59 : Get Object Monitor Usage */
  jvmtiError (JNICALL *GetObjectMonitorUsage) (jvmtiEnv* env,
    jobject object,
    jvmtiMonitorUsage* info_ptr);

  /*   60 : Get Field Name (and Signature) */
  jvmtiError (JNICALL *GetFieldName) (jvmtiEnv* env,
    jclass klass,
    jfieldID field,
    char** name_ptr,
    char** signature_ptr,
    char** generic_ptr);

  /*   61 : Get Field Declaring Class */
  jvmtiError (JNICALL *GetFieldDeclaringClass) (jvmtiEnv* env,
    jclass klass,
    jfieldID field,
    jclass* declaring_class_ptr);

  /*   62 : Get Field Modifiers */
  jvmtiError (JNICALL *GetFieldModifiers) (jvmtiEnv* env,
    jclass klass,
    jfieldID field,
    jint* modifiers_ptr);

  /*   63 : Is Field Synthetic */
  jvmtiError (JNICALL *IsFieldSynthetic) (jvmtiEnv* env,
    jclass klass,
    jfieldID field,
    jboolean* is_synthetic_ptr);

  /*   64 : Get Method Name (and Signature) */
  jvmtiError (JNICALL *GetMethodName) (jvmtiEnv* env,
    jmethodID method,
    char** name_ptr,
    char** signature_ptr,
    char** generic_ptr);

  /*   65 : Get Method Declaring Class */
  jvmtiError (JNICALL *GetMethodDeclaringClass) (jvmtiEnv* env,
    jmethodID method,
    jclass* declaring_class_ptr);

  /*   66 : Get Method Modifiers */
  jvmtiError (JNICALL *GetMethodModifiers) (jvmtiEnv* env,
    jmethodID method,
    jint* modifiers_ptr);

  /*   67 :  RESERVED */
  void *reserved67;

  /*   68 : Get Max Locals */
  jvmtiError (JNICALL *GetMaxLocals) (jvmtiEnv* env,
    jmethodID method,
    jint* max_ptr);

  /*   69 : Get Arguments Size */
  jvmtiError (JNICALL *GetArgumentsSize) (jvmtiEnv* env,
    jmethodID method,
    jint* size_ptr);

  /*   70 : Get Line Number Table */
  jvmtiError (JNICALL *GetLineNumberTable) (jvmtiEnv* env,
    jmethodID method,
    jint* entry_count_ptr,
    jvmtiLineNumberEntry** table_ptr);

  /*   71 : Get Method Location */
  jvmtiError (JNICALL *GetMethodLocation) (jvmtiEnv* env,
    jmethodID method,
    jlocation* start_location_ptr,
    jlocation* end_location_ptr);

  /*   72 : Get Local Variable Table */
  jvmtiError (JNICALL *GetLocalVariableTable) (jvmtiEnv* env,
    jmethodID method,
    jint* entry_count_ptr,
    jvmtiLocalVariableEntry** table_ptr);

  /*   73 : Set Native Method Prefix */
  jvmtiError (JNICALL *SetNativeMethodPrefix) (jvmtiEnv* env,
    const char* prefix);

  /*   74 : Set Native Method Prefixes */
  jvmtiError (JNICALL *SetNativeMethodPrefixes) (jvmtiEnv* env,
    jint prefix_count,
    char** prefixes);

  /*   75 : Get Bytecodes */
  jvmtiError (JNICALL *GetBytecodes) (jvmtiEnv* env,
    jmethodID method,
    jint* bytecode_count_ptr,
    unsigned char** bytecodes_ptr);

  /*   76 : Is Method Native */
  jvmtiError (JNICALL *IsMethodNative) (jvmtiEnv* env,
    jmethodID method,
    jboolean* is_native_ptr);

  /*   77 : Is Method Synthetic */
  jvmtiError (JNICALL *IsMethodSynthetic) (jvmtiEnv* env,
    jmethodID method,
    jboolean* is_synthetic_ptr);

  /*   78 : Get Loaded Classes */
  jvmtiError (JNICALL *GetLoadedClasses) (jvmtiEnv* env,
    jint* class_count_ptr,
    jclass** classes_ptr);

  /*   79 : Get Classloader Classes */
  jvmtiError (JNICALL *GetClassLoaderClasses) (jvmtiEnv* env,
    jobject initiating_loader,
    jint* class_count_ptr,
    jclass** classes_ptr);

  /*   80 : Pop Frame */
  jvmtiError (JNICALL *PopFrame) (jvmtiEnv* env,
    jthread thread);

  /*   81 : Force Early Return - Object */
  jvmtiError (JNICALL *ForceEarlyReturnObject) (jvmtiEnv* env,
    jthread thread,
    jobject value);

  /*   82 : Force Early Return - Int */
  jvmtiError (JNICALL *ForceEarlyReturnInt) (jvmtiEnv* env,
    jthread thread,
    jint value);

  /*   83 : Force Early Return - Long */
  jvmtiError (JNICALL *ForceEarlyReturnLong) (jvmtiEnv* env,
    jthread thread,
    jlong value);

  /*   84 : Force Early Return - Float */
  jvmtiError (JNICALL *ForceEarlyReturnFloat) (jvmtiEnv* env,
    jthread thread,
    jfloat value);

  /*   85 : Force Early Return - Double */
  jvmtiError (JNICALL *ForceEarlyReturnDouble) (jvmtiEnv* env,
    jthread thread,
    jdouble value);

  /*   86 : Force Early Return - Void */
  jvmtiError (JNICALL *ForceEarlyReturnVoid) (jvmtiEnv* env,
    jthread thread);

  /*   87 : Redefine Classes */
  jvmtiError (JNICALL *RedefineClasses) (jvmtiEnv* env,
    jint class_count,
    const jvmtiClassDefinition* class_definitions);

  /*   88 : Get Version Number */
  jvmtiError (JNICALL *GetVersionNumber) (jvmtiEnv* env,
    jint* version_ptr);

  /*   89 : Get Capabilities */
  jvmtiError (JNICALL *GetCapabilities) (jvmtiEnv* env,
    jvmtiCapabilities* capabilities_ptr);

  /*   90 : Get Source Debug Extension */
  jvmtiError (JNICALL *GetSourceDebugExtension) (jvmtiEnv* env,
    jclass klass,
    char** source_debug_extension_ptr);

  /*   91 : Is Method Obsolete */
  jvmtiError (JNICALL *IsMethodObsolete) (jvmtiEnv* env,
    jmethodID method,
    jboolean* is_obsolete_ptr);

  /*   92 : Suspend Thread List */
  jvmtiError (JNICALL *SuspendThreadList) (jvmtiEnv* env,
    jint request_count,
    const jthread* request_list,
    jvmtiError* results);

  /*   93 : Resume Thread List */
  jvmtiError (JNICALL *ResumeThreadList) (jvmtiEnv* env,
    jint request_count,
    const jthread* request_list,
    jvmtiError* results);

  /*   94 :  RESERVED */
  void *reserved94;

  /*   95 :  RESERVED */
  void *reserved95;

  /*   96 :  RESERVED */
  void *reserved96;

  /*   97 :  RESERVED */
  void *reserved97;

  /*   98 :  RESERVED */
  void *reserved98;

  /*   99 :  RESERVED */
  void *reserved99;

  /*   100 : Get All Stack Traces */
  jvmtiError (JNICALL *GetAllStackTraces) (jvmtiEnv* env,
    jint max_frame_count,
    jvmtiStackInfo** stack_info_ptr,
    jint* thread_count_ptr);

  /*   101 : Get Thread List Stack Traces */
  jvmtiError (JNICALL *GetThreadListStackTraces) (jvmtiEnv* env,
    jint thread_count,
    const jthread* thread_list,
    jint max_frame_count,
    jvmtiStackInfo** stack_info_ptr);

  /*   102 : Get Thread Local Storage */
  jvmtiError (JNICALL *GetThreadLocalStorage) (jvmtiEnv* env,
    jthread thread,
    void** data_ptr);

  /*   103 : Set Thread Local Storage */
  jvmtiError (JNICALL *SetThreadLocalStorage) (jvmtiEnv* env,
    jthread thread,
    const void* data);

  /*   104 : Get Stack Trace */
  jvmtiError (JNICALL *GetStackTrace) (jvmtiEnv* env,
    jthread thread,
    jint start_depth,
    jint max_frame_count,
    jvmtiFrameInfo* frame_buffer,
    jint* count_ptr);

  /*   105 :  RESERVED */
  void *reserved105;

  /*   106 : Get Tag */
  jvmtiError (JNICALL *GetTag) (jvmtiEnv* env,
    jobject object,
    jlong* tag_ptr);

  /*   107 : Set Tag */
  jvmtiError (JNICALL *SetTag) (jvmtiEnv* env,
    jobject object,
    jlong tag);

  /*   108 : Force Garbage Collection */
  jvmtiError (JNICALL *ForceGarbageCollection) (jvmtiEnv* env);

  /*   109 : Iterate Over Objects Reachable From Object */
  jvmtiError (JNICALL *IterateOverObjectsReachableFromObject) (jvmtiEnv* env,
    jobject object,
    jvmtiObjectReferenceCallback object_reference_callback,
    const void* user_data);

  /*   110 : Iterate Over Reachable Objects */
  jvmtiError (JNICALL *IterateOverReachableObjects) (jvmtiEnv* env,
    jvmtiHeapRootCallback heap_root_callback,
    jvmtiStackReferenceCallback stack_ref_callback,
    jvmtiObjectReferenceCallback object_ref_callback,
    const void* user_data);

  /*   111 : Iterate Over Heap */
  jvmtiError (JNICALL *IterateOverHeap) (jvmtiEnv* env,
    jvmtiHeapObjectFilter object_filter,
    jvmtiHeapObjectCallback heap_object_callback,
    const void* user_data);

  /*   112 : Iterate Over Instances Of Class */
  jvmtiError (JNICALL *IterateOverInstancesOfClass) (jvmtiEnv* env,
    jclass klass,
    jvmtiHeapObjectFilter object_filter,
    jvmtiHeapObjectCallback heap_object_callback,
    const void* user_data);

  /*   113 :  RESERVED */
  void *reserved113;

  /*   114 : Get Objects With Tags */
  jvmtiError (JNICALL *GetObjectsWithTags) (jvmtiEnv* env,
    jint tag_count,
    const jlong* tags,
    jint* count_ptr,
    jobject** object_result_ptr,
    jlong** tag_result_ptr);

  /*   115 : Follow References */
  jvmtiError (JNICALL *FollowReferences) (jvmtiEnv* env,
    jint heap_filter,
    jclass klass,
    jobject initial_object,
    const jvmtiHeapCallbacks* callbacks,
    const void* user_data);

  /*   116 : Iterate Through Heap */
  jvmtiError (JNICALL *IterateThroughHeap) (jvmtiEnv* env,
    jint heap_filter,
    jclass klass,
    const jvmtiHeapCallbacks* callbacks,
    const void* user_data);

  /*   117 :  RESERVED */
  void *reserved117;

  /*   118 :  RESERVED */
  void *reserved118;

  /*   119 :  RESERVED */
  void *reserved119;

  /*   120 : Set JNI Function Table */
  jvmtiError (JNICALL *SetJNIFunctionTable) (jvmtiEnv* env,
    const jniNativeInterface* function_table);

  /*   121 : Get JNI Function Table */
  jvmtiError (JNICALL *GetJNIFunctionTable) (jvmtiEnv* env,
    jniNativeInterface** function_table);

  /*   122 : Set Event Callbacks */
  jvmtiError (JNICALL *SetEventCallbacks) (jvmtiEnv* env,
    const jvmtiEventCallbacks* callbacks,
    jint size_of_callbacks);

  /*   123 : Generate Events */
  jvmtiError (JNICALL *GenerateEvents) (jvmtiEnv* env,
    jvmtiEvent event_type);

  /*   124 : Get Extension Functions */
  jvmtiError (JNICALL *GetExtensionFunctions) (jvmtiEnv* env,
    jint* extension_count_ptr,
    jvmtiExtensionFunctionInfo** extensions);

  /*   125 : Get Extension Events */
  jvmtiError (JNICALL *GetExtensionEvents) (jvmtiEnv* env,
    jint* extension_count_ptr,
    jvmtiExtensionEventInfo** extensions);

  /*   126 : Set Extension Event Callback */
  jvmtiError (JNICALL *SetExtensionEventCallback) (jvmtiEnv* env,
    jint extension_event_index,
    jvmtiExtensionEvent callback);

  /*   127 : Dispose Environment */
  jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);

  /*   128 : Get Error Name */
  jvmtiError (JNICALL *GetErrorName) (jvmtiEnv* env,
    jvmtiError error,
    char** name_ptr);

  /*   129 : Get JLocation Format */
  jvmtiError (JNICALL *GetJLocationFormat) (jvmtiEnv* env,
    jvmtiJlocationFormat* format_ptr);

  /*   130 : Get System Properties */
  jvmtiError (JNICALL *GetSystemProperties) (jvmtiEnv* env,
    jint* count_ptr,
    char*** property_ptr);

  /*   131 : Get System Property */
  jvmtiError (JNICALL *GetSystemProperty) (jvmtiEnv* env,
    const char* property,
    char** value_ptr);

  /*   132 : Set System Property */
  jvmtiError (JNICALL *SetSystemProperty) (jvmtiEnv* env,
    const char* property,
    const char* value);

  /*   133 : Get Phase */
  jvmtiError (JNICALL *GetPhase) (jvmtiEnv* env,
    jvmtiPhase* phase_ptr);

  /*   134 : Get Current Thread CPU Timer Information */
  jvmtiError (JNICALL *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env,
    jvmtiTimerInfo* info_ptr);

  /*   135 : Get Current Thread CPU Time */
  jvmtiError (JNICALL *GetCurrentThreadCpuTime) (jvmtiEnv* env,
    jlong* nanos_ptr);

  /*   136 : Get Thread CPU Timer Information */
  jvmtiError (JNICALL *GetThreadCpuTimerInfo) (jvmtiEnv* env,
    jvmtiTimerInfo* info_ptr);

  /*   137 : Get Thread CPU Time */
  jvmtiError (JNICALL *GetThreadCpuTime) (jvmtiEnv* env,
    jthread thread,
    jlong* nanos_ptr);

  /*   138 : Get Timer Information */
  jvmtiError (JNICALL *GetTimerInfo) (jvmtiEnv* env,
    jvmtiTimerInfo* info_ptr);

  /*   139 : Get Time */
  jvmtiError (JNICALL *GetTime) (jvmtiEnv* env,
    jlong* nanos_ptr);

  /*   140 : Get Potential Capabilities */
  jvmtiError (JNICALL *GetPotentialCapabilities) (jvmtiEnv* env,
    jvmtiCapabilities* capabilities_ptr);

  /*   141 :  RESERVED */
  void *reserved141;

  /*   142 : Add Capabilities */
  jvmtiError (JNICALL *AddCapabilities) (jvmtiEnv* env,
    const jvmtiCapabilities* capabilities_ptr);

  /*   143 : Relinquish Capabilities */
  jvmtiError (JNICALL *RelinquishCapabilities) (jvmtiEnv* env,
    const jvmtiCapabilities* capabilities_ptr);

  /*   144 : Get Available Processors */
  jvmtiError (JNICALL *GetAvailableProcessors) (jvmtiEnv* env,
    jint* processor_count_ptr);

  /*   145 : Get Class Version Numbers */
  jvmtiError (JNICALL *GetClassVersionNumbers) (jvmtiEnv* env,
    jclass klass,
    jint* minor_version_ptr,
    jint* major_version_ptr);

  /*   146 : Get Constant Pool */
  jvmtiError (JNICALL *GetConstantPool) (jvmtiEnv* env,
    jclass klass,
    jint* constant_pool_count_ptr,
    jint* constant_pool_byte_count_ptr,
    unsigned char** constant_pool_bytes_ptr);

  /*   147 : Get Environment Local Storage */
  jvmtiError (JNICALL *GetEnvironmentLocalStorage) (jvmtiEnv* env,
    void** data_ptr);

  /*   148 : Set Environment Local Storage */
  jvmtiError (JNICALL *SetEnvironmentLocalStorage) (jvmtiEnv* env,
    const void* data);

  /*   149 : Add To Bootstrap Class Loader Search */
  jvmtiError (JNICALL *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env,
    const char* segment);

  /*   150 : Set Verbose Flag */
  jvmtiError (JNICALL *SetVerboseFlag) (jvmtiEnv* env,
    jvmtiVerboseFlag flag,
    jboolean value);

  /*   151 : Add To System Class Loader Search */
  jvmtiError (JNICALL *AddToSystemClassLoaderSearch) (jvmtiEnv* env,
    const char* segment);

  /*   152 : Retransform Classes */
  jvmtiError (JNICALL *RetransformClasses) (jvmtiEnv* env,
    jint class_count,
    const jclass* classes);

  /*   153 : Get Owned Monitor Stack Depth Info */
  jvmtiError (JNICALL *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env,
    jthread thread,
    jint* monitor_info_count_ptr,
    jvmtiMonitorStackDepthInfo** monitor_info_ptr);

  /*   154 : Get Object Size */
  jvmtiError (JNICALL *GetObjectSize) (jvmtiEnv* env,
    jobject object,
    jlong* size_ptr);

  /*   155 : Get Local Instance */
  jvmtiError (JNICALL *GetLocalInstance) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jobject* value_ptr);

} jvmtiInterface_1;

struct _jvmtiEnv {
    const struct jvmtiInterface_1_ *functions;
#ifdef __cplusplus


  jvmtiError Allocate(jlong size,
            unsigned char** mem_ptr) {
    return functions->Allocate(this, size, mem_ptr);
  }

  jvmtiError Deallocate(unsigned char* mem) {
    return functions->Deallocate(this, mem);
  }

  jvmtiError GetThreadState(jthread thread,
            jint* thread_state_ptr) {
    return functions->GetThreadState(this, thread, thread_state_ptr);
  }

  jvmtiError GetCurrentThread(jthread* thread_ptr) {
    return functions->GetCurrentThread(this, thread_ptr);
  }

  jvmtiError GetAllThreads(jint* threads_count_ptr,
            jthread** threads_ptr) {
    return functions->GetAllThreads(this, threads_count_ptr, threads_ptr);
  }

  jvmtiError SuspendThread(jthread thread) {
    return functions->SuspendThread(this, thread);
  }

  jvmtiError SuspendThreadList(jint request_count,
            const jthread* request_list,
            jvmtiError* results) {
    return functions->SuspendThreadList(this, request_count, request_list, results);
  }

  jvmtiError ResumeThread(jthread thread) {
    return functions->ResumeThread(this, thread);
  }

  jvmtiError ResumeThreadList(jint request_count,
            const jthread* request_list,
            jvmtiError* results) {
    return functions->ResumeThreadList(this, request_count, request_list, results);
  }

  jvmtiError StopThread(jthread thread,
            jobject exception) {
    return functions->StopThread(this, thread, exception);
  }

  jvmtiError InterruptThread(jthread thread) {
    return functions->InterruptThread(this, thread);
  }

  jvmtiError GetThreadInfo(jthread thread,
            jvmtiThreadInfo* info_ptr) {
    return functions->GetThreadInfo(this, thread, info_ptr);
  }

  jvmtiError GetOwnedMonitorInfo(jthread thread,
            jint* owned_monitor_count_ptr,
            jobject** owned_monitors_ptr) {
    return functions->GetOwnedMonitorInfo(this, thread, owned_monitor_count_ptr, owned_monitors_ptr);
  }

  jvmtiError GetOwnedMonitorStackDepthInfo(jthread thread,
            jint* monitor_info_count_ptr,
            jvmtiMonitorStackDepthInfo** monitor_info_ptr) {
    return functions->GetOwnedMonitorStackDepthInfo(this, thread, monitor_info_count_ptr, monitor_info_ptr);
  }

  jvmtiError GetCurrentContendedMonitor(jthread thread,
            jobject* monitor_ptr) {
    return functions->GetCurrentContendedMonitor(this, thread, monitor_ptr);
  }

  jvmtiError RunAgentThread(jthread thread,
            jvmtiStartFunction proc,
            const void* arg,
            jint priority) {
    return functions->RunAgentThread(this, thread, proc, arg, priority);
  }

  jvmtiError SetThreadLocalStorage(jthread thread,
            const void* data) {
    return functions->SetThreadLocalStorage(this, thread, data);
  }

  jvmtiError GetThreadLocalStorage(jthread thread,
            void** data_ptr) {
    return functions->GetThreadLocalStorage(this, thread, data_ptr);
  }

  jvmtiError GetTopThreadGroups(jint* group_count_ptr,
            jthreadGroup** groups_ptr) {
    return functions->GetTopThreadGroups(this, group_count_ptr, groups_ptr);
  }

  jvmtiError GetThreadGroupInfo(jthreadGroup group,
            jvmtiThreadGroupInfo* info_ptr) {
    return functions->GetThreadGroupInfo(this, group, info_ptr);
  }

  jvmtiError GetThreadGroupChildren(jthreadGroup group,
            jint* thread_count_ptr,
            jthread** threads_ptr,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr) {
    return functions->GetThreadGroupChildren(this, group, thread_count_ptr, threads_ptr, group_count_ptr, groups_ptr);
  }

  jvmtiError GetStackTrace(jthread thread,
            jint start_depth,
            jint max_frame_count,
            jvmtiFrameInfo* frame_buffer,
            jint* count_ptr) {
    return functions->GetStackTrace(this, thread, start_depth, max_frame_count, frame_buffer, count_ptr);
  }

  jvmtiError GetAllStackTraces(jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr,
            jint* thread_count_ptr) {
    return functions->GetAllStackTraces(this, max_frame_count, stack_info_ptr, thread_count_ptr);
  }

  jvmtiError GetThreadListStackTraces(jint thread_count,
            const jthread* thread_list,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr) {
    return functions->GetThreadListStackTraces(this, thread_count, thread_list, max_frame_count, stack_info_ptr);
  }

  jvmtiError GetFrameCount(jthread thread,
            jint* count_ptr) {
    return functions->GetFrameCount(this, thread, count_ptr);
  }

  jvmtiError PopFrame(jthread thread) {
    return functions->PopFrame(this, thread);
  }

  jvmtiError GetFrameLocation(jthread thread,
            jint depth,
            jmethodID* method_ptr,
            jlocation* location_ptr) {
    return functions->GetFrameLocation(this, thread, depth, method_ptr, location_ptr);
  }

  jvmtiError NotifyFramePop(jthread thread,
            jint depth) {
    return functions->NotifyFramePop(this, thread, depth);
  }

  jvmtiError ForceEarlyReturnObject(jthread thread,
            jobject value) {
    return functions->ForceEarlyReturnObject(this, thread, value);
  }

  jvmtiError ForceEarlyReturnInt(jthread thread,
            jint value) {
    return functions->ForceEarlyReturnInt(this, thread, value);
  }

  jvmtiError ForceEarlyReturnLong(jthread thread,
            jlong value) {
    return functions->ForceEarlyReturnLong(this, thread, value);
  }

  jvmtiError ForceEarlyReturnFloat(jthread thread,
            jfloat value) {
    return functions->ForceEarlyReturnFloat(this, thread, value);
  }

  jvmtiError ForceEarlyReturnDouble(jthread thread,
            jdouble value) {
    return functions->ForceEarlyReturnDouble(this, thread, value);
  }

  jvmtiError ForceEarlyReturnVoid(jthread thread) {
    return functions->ForceEarlyReturnVoid(this, thread);
  }

  jvmtiError FollowReferences(jint heap_filter,
            jclass klass,
            jobject initial_object,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data) {
    return functions->FollowReferences(this, heap_filter, klass, initial_object, callbacks, user_data);
  }

  jvmtiError IterateThroughHeap(jint heap_filter,
            jclass klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data) {
    return functions->IterateThroughHeap(this, heap_filter, klass, callbacks, user_data);
  }

  jvmtiError GetTag(jobject object,
            jlong* tag_ptr) {
    return functions->GetTag(this, object, tag_ptr);
  }

  jvmtiError SetTag(jobject object,
            jlong tag) {
    return functions->SetTag(this, object, tag);
  }

  jvmtiError GetObjectsWithTags(jint tag_count,
            const jlong* tags,
            jint* count_ptr,
            jobject** object_result_ptr,
            jlong** tag_result_ptr) {
    return functions->GetObjectsWithTags(this, tag_count, tags, count_ptr, object_result_ptr, tag_result_ptr);
  }

  jvmtiError ForceGarbageCollection() {
    return functions->ForceGarbageCollection(this);
  }

  jvmtiError IterateOverObjectsReachableFromObject(jobject object,
            jvmtiObjectReferenceCallback object_reference_callback,
            const void* user_data) {
    return functions->IterateOverObjectsReachableFromObject(this, object, object_reference_callback, user_data);
  }

  jvmtiError IterateOverReachableObjects(jvmtiHeapRootCallback heap_root_callback,
            jvmtiStackReferenceCallback stack_ref_callback,
            jvmtiObjectReferenceCallback object_ref_callback,
            const void* user_data) {
    return functions->IterateOverReachableObjects(this, heap_root_callback, stack_ref_callback, object_ref_callback, user_data);
  }

  jvmtiError IterateOverHeap(jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data) {
    return functions->IterateOverHeap(this, object_filter, heap_object_callback, user_data);
  }

  jvmtiError IterateOverInstancesOfClass(jclass klass,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data) {
    return functions->IterateOverInstancesOfClass(this, klass, object_filter, heap_object_callback, user_data);
  }

  jvmtiError GetLocalObject(jthread thread,
            jint depth,
            jint slot,
            jobject* value_ptr) {
    return functions->GetLocalObject(this, thread, depth, slot, value_ptr);
  }

  jvmtiError GetLocalInstance(jthread thread,
            jint depth,
            jobject* value_ptr) {
    return functions->GetLocalInstance(this, thread, depth, value_ptr);
  }

  jvmtiError GetLocalInt(jthread thread,
            jint depth,
            jint slot,
            jint* value_ptr) {
    return functions->GetLocalInt(this, thread, depth, slot, value_ptr);
  }

  jvmtiError GetLocalLong(jthread thread,
            jint depth,
            jint slot,
            jlong* value_ptr) {
    return functions->GetLocalLong(this, thread, depth, slot, value_ptr);
  }

  jvmtiError GetLocalFloat(jthread thread,
            jint depth,
            jint slot,
            jfloat* value_ptr) {
    return functions->GetLocalFloat(this, thread, depth, slot, value_ptr);
  }

  jvmtiError GetLocalDouble(jthread thread,
            jint depth,
            jint slot,
            jdouble* value_ptr) {
    return functions->GetLocalDouble(this, thread, depth, slot, value_ptr);
  }

  jvmtiError SetLocalObject(jthread thread,
            jint depth,
            jint slot,
            jobject value) {
    return functions->SetLocalObject(this, thread, depth, slot, value);
  }

  jvmtiError SetLocalInt(jthread thread,
            jint depth,
            jint slot,
            jint value) {
    return functions->SetLocalInt(this, thread, depth, slot, value);
  }

  jvmtiError SetLocalLong(jthread thread,
            jint depth,
            jint slot,
            jlong value) {
    return functions->SetLocalLong(this, thread, depth, slot, value);
  }

  jvmtiError SetLocalFloat(jthread thread,
            jint depth,
            jint slot,
            jfloat value) {
    return functions->SetLocalFloat(this, thread, depth, slot, value);
  }

  jvmtiError SetLocalDouble(jthread thread,
            jint depth,
            jint slot,
            jdouble value) {
    return functions->SetLocalDouble(this, thread, depth, slot, value);
  }

  jvmtiError SetBreakpoint(jmethodID method,
            jlocation location) {
    return functions->SetBreakpoint(this, method, location);
  }

  jvmtiError ClearBreakpoint(jmethodID method,
            jlocation location) {
    return functions->ClearBreakpoint(this, method, location);
  }

  jvmtiError SetFieldAccessWatch(jclass klass,
            jfieldID field) {
    return functions->SetFieldAccessWatch(this, klass, field);
  }

  jvmtiError ClearFieldAccessWatch(jclass klass,
            jfieldID field) {
    return functions->ClearFieldAccessWatch(this, klass, field);
  }

  jvmtiError SetFieldModificationWatch(jclass klass,
            jfieldID field) {
    return functions->SetFieldModificationWatch(this, klass, field);
  }

  jvmtiError ClearFieldModificationWatch(jclass klass,
            jfieldID field) {
    return functions->ClearFieldModificationWatch(this, klass, field);
  }

  jvmtiError GetLoadedClasses(jint* class_count_ptr,
            jclass** classes_ptr) {
    return functions->GetLoadedClasses(this, class_count_ptr, classes_ptr);
  }

  jvmtiError GetClassLoaderClasses(jobject initiating_loader,
            jint* class_count_ptr,
            jclass** classes_ptr) {
    return functions->GetClassLoaderClasses(this, initiating_loader, class_count_ptr, classes_ptr);
  }

  jvmtiError GetClassSignature(jclass klass,
            char** signature_ptr,
            char** generic_ptr) {
    return functions->GetClassSignature(this, klass, signature_ptr, generic_ptr);
  }

  jvmtiError GetClassStatus(jclass klass,
            jint* status_ptr) {
    return functions->GetClassStatus(this, klass, status_ptr);
  }

  jvmtiError GetSourceFileName(jclass klass,
            char** source_name_ptr) {
    return functions->GetSourceFileName(this, klass, source_name_ptr);
  }

  jvmtiError GetClassModifiers(jclass klass,
            jint* modifiers_ptr) {
    return functions->GetClassModifiers(this, klass, modifiers_ptr);
  }

  jvmtiError GetClassMethods(jclass klass,
            jint* method_count_ptr,
            jmethodID** methods_ptr) {
    return functions->GetClassMethods(this, klass, method_count_ptr, methods_ptr);
  }

  jvmtiError GetClassFields(jclass klass,
            jint* field_count_ptr,
            jfieldID** fields_ptr) {
    return functions->GetClassFields(this, klass, field_count_ptr, fields_ptr);
  }

  jvmtiError GetImplementedInterfaces(jclass klass,
            jint* interface_count_ptr,
            jclass** interfaces_ptr) {
    return functions->GetImplementedInterfaces(this, klass, interface_count_ptr, interfaces_ptr);
  }

  jvmtiError GetClassVersionNumbers(jclass klass,
            jint* minor_version_ptr,
            jint* major_version_ptr) {
    return functions->GetClassVersionNumbers(this, klass, minor_version_ptr, major_version_ptr);
  }

  jvmtiError GetConstantPool(jclass klass,
            jint* constant_pool_count_ptr,
            jint* constant_pool_byte_count_ptr,
            unsigned char** constant_pool_bytes_ptr) {
    return functions->GetConstantPool(this, klass, constant_pool_count_ptr, constant_pool_byte_count_ptr, constant_pool_bytes_ptr);
  }

  jvmtiError IsInterface(jclass klass,
            jboolean* is_interface_ptr) {
    return functions->IsInterface(this, klass, is_interface_ptr);
  }

  jvmtiError IsArrayClass(jclass klass,
            jboolean* is_array_class_ptr) {
    return functions->IsArrayClass(this, klass, is_array_class_ptr);
  }

  jvmtiError IsModifiableClass(jclass klass,
            jboolean* is_modifiable_class_ptr) {
    return functions->IsModifiableClass(this, klass, is_modifiable_class_ptr);
  }

  jvmtiError GetClassLoader(jclass klass,
            jobject* classloader_ptr) {
    return functions->GetClassLoader(this, klass, classloader_ptr);
  }

  jvmtiError GetSourceDebugExtension(jclass klass,
            char** source_debug_extension_ptr) {
    return functions->GetSourceDebugExtension(this, klass, source_debug_extension_ptr);
  }

  jvmtiError RetransformClasses(jint class_count,
            const jclass* classes) {
    return functions->RetransformClasses(this, class_count, classes);
  }

  jvmtiError RedefineClasses(jint class_count,
            const jvmtiClassDefinition* class_definitions) {
    return functions->RedefineClasses(this, class_count, class_definitions);
  }

  jvmtiError GetObjectSize(jobject object,
            jlong* size_ptr) {
    return functions->GetObjectSize(this, object, size_ptr);
  }

  jvmtiError GetObjectHashCode(jobject object,
            jint* hash_code_ptr) {
    return functions->GetObjectHashCode(this, object, hash_code_ptr);
  }

  jvmtiError GetObjectMonitorUsage(jobject object,
            jvmtiMonitorUsage* info_ptr) {
    return functions->GetObjectMonitorUsage(this, object, info_ptr);
  }

  jvmtiError GetFieldName(jclass klass,
            jfieldID field,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr) {
    return functions->GetFieldName(this, klass, field, name_ptr, signature_ptr, generic_ptr);
  }

  jvmtiError GetFieldDeclaringClass(jclass klass,
            jfieldID field,
            jclass* declaring_class_ptr) {
    return functions->GetFieldDeclaringClass(this, klass, field, declaring_class_ptr);
  }

  jvmtiError GetFieldModifiers(jclass klass,
            jfieldID field,
            jint* modifiers_ptr) {
    return functions->GetFieldModifiers(this, klass, field, modifiers_ptr);
  }

  jvmtiError IsFieldSynthetic(jclass klass,
            jfieldID field,
            jboolean* is_synthetic_ptr) {
    return functions->IsFieldSynthetic(this, klass, field, is_synthetic_ptr);
  }

  jvmtiError GetMethodName(jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr) {
    return functions->GetMethodName(this, method, name_ptr, signature_ptr, generic_ptr);
  }

  jvmtiError GetMethodDeclaringClass(jmethodID method,
            jclass* declaring_class_ptr) {
    return functions->GetMethodDeclaringClass(this, method, declaring_class_ptr);
  }

  jvmtiError GetMethodModifiers(jmethodID method,
            jint* modifiers_ptr) {
    return functions->GetMethodModifiers(this, method, modifiers_ptr);
  }

  jvmtiError GetMaxLocals(jmethodID method,
            jint* max_ptr) {
    return functions->GetMaxLocals(this, method, max_ptr);
  }

  jvmtiError GetArgumentsSize(jmethodID method,
            jint* size_ptr) {
    return functions->GetArgumentsSize(this, method, size_ptr);
  }

  jvmtiError GetLineNumberTable(jmethodID method,
            jint* entry_count_ptr,
            jvmtiLineNumberEntry** table_ptr) {
    return functions->GetLineNumberTable(this, method, entry_count_ptr, table_ptr);
  }

  jvmtiError GetMethodLocation(jmethodID method,
            jlocation* start_location_ptr,
            jlocation* end_location_ptr) {
    return functions->GetMethodLocation(this, method, start_location_ptr, end_location_ptr);
  }

  jvmtiError GetLocalVariableTable(jmethodID method,
            jint* entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr) {
    return functions->GetLocalVariableTable(this, method, entry_count_ptr, table_ptr);
  }

  jvmtiError GetBytecodes(jmethodID method,
            jint* bytecode_count_ptr,
            unsigned char** bytecodes_ptr) {
    return functions->GetBytecodes(this, method, bytecode_count_ptr, bytecodes_ptr);
  }

  jvmtiError IsMethodNative(jmethodID method,
            jboolean* is_native_ptr) {
    return functions->IsMethodNative(this, method, is_native_ptr);
  }

  jvmtiError IsMethodSynthetic(jmethodID method,
            jboolean* is_synthetic_ptr) {
    return functions->IsMethodSynthetic(this, method, is_synthetic_ptr);
  }

  jvmtiError IsMethodObsolete(jmethodID method,
            jboolean* is_obsolete_ptr) {
    return functions->IsMethodObsolete(this, method, is_obsolete_ptr);
  }

  jvmtiError SetNativeMethodPrefix(const char* prefix) {
    return functions->SetNativeMethodPrefix(this, prefix);
  }

  jvmtiError SetNativeMethodPrefixes(jint prefix_count,
            char** prefixes) {
    return functions->SetNativeMethodPrefixes(this, prefix_count, prefixes);
  }

  jvmtiError CreateRawMonitor(const char* name,
            jrawMonitorID* monitor_ptr) {
    return functions->CreateRawMonitor(this, name, monitor_ptr);
  }

  jvmtiError DestroyRawMonitor(jrawMonitorID monitor) {
    return functions->DestroyRawMonitor(this, monitor);
  }

  jvmtiError RawMonitorEnter(jrawMonitorID monitor) {
    return functions->RawMonitorEnter(this, monitor);
  }

  jvmtiError RawMonitorExit(jrawMonitorID monitor) {
    return functions->RawMonitorExit(this, monitor);
  }

  jvmtiError RawMonitorWait(jrawMonitorID monitor,
            jlong millis) {
    return functions->RawMonitorWait(this, monitor, millis);
  }

  jvmtiError RawMonitorNotify(jrawMonitorID monitor) {
    return functions->RawMonitorNotify(this, monitor);
  }

  jvmtiError RawMonitorNotifyAll(jrawMonitorID monitor) {
    return functions->RawMonitorNotifyAll(this, monitor);
  }

  jvmtiError SetJNIFunctionTable(const jniNativeInterface* function_table) {
    return functions->SetJNIFunctionTable(this, function_table);
  }

  jvmtiError GetJNIFunctionTable(jniNativeInterface** function_table) {
    return functions->GetJNIFunctionTable(this, function_table);
  }

  jvmtiError SetEventCallbacks(const jvmtiEventCallbacks* callbacks,
            jint size_of_callbacks) {
    return functions->SetEventCallbacks(this, callbacks, size_of_callbacks);
  }

  jvmtiError SetEventNotificationMode(jvmtiEventMode mode,
            jvmtiEvent event_type,
            jthread event_thread,
             ...) {
    return functions->SetEventNotificationMode(this, mode, event_type, event_thread);
  }

  jvmtiError GenerateEvents(jvmtiEvent event_type) {
    return functions->GenerateEvents(this, event_type);
  }

  jvmtiError GetExtensionFunctions(jint* extension_count_ptr,
            jvmtiExtensionFunctionInfo** extensions) {
    return functions->GetExtensionFunctions(this, extension_count_ptr, extensions);
  }

  jvmtiError GetExtensionEvents(jint* extension_count_ptr,
            jvmtiExtensionEventInfo** extensions) {
    return functions->GetExtensionEvents(this, extension_count_ptr, extensions);
  }

  jvmtiError SetExtensionEventCallback(jint extension_event_index,
            jvmtiExtensionEvent callback) {
    return functions->SetExtensionEventCallback(this, extension_event_index, callback);
  }

  jvmtiError GetPotentialCapabilities(jvmtiCapabilities* capabilities_ptr) {
    return functions->GetPotentialCapabilities(this, capabilities_ptr);
  }

  jvmtiError AddCapabilities(const jvmtiCapabilities* capabilities_ptr) {
    return functions->AddCapabilities(this, capabilities_ptr);
  }

  jvmtiError RelinquishCapabilities(const jvmtiCapabilities* capabilities_ptr) {
    return functions->RelinquishCapabilities(this, capabilities_ptr);
  }

  jvmtiError GetCapabilities(jvmtiCapabilities* capabilities_ptr) {
    return functions->GetCapabilities(this, capabilities_ptr);
  }

  jvmtiError GetCurrentThreadCpuTimerInfo(jvmtiTimerInfo* info_ptr) {
    return functions->GetCurrentThreadCpuTimerInfo(this, info_ptr);
  }

  jvmtiError GetCurrentThreadCpuTime(jlong* nanos_ptr) {
    return functions->GetCurrentThreadCpuTime(this, nanos_ptr);
  }

  jvmtiError GetThreadCpuTimerInfo(jvmtiTimerInfo* info_ptr) {
    return functions->GetThreadCpuTimerInfo(this, info_ptr);
  }

  jvmtiError GetThreadCpuTime(jthread thread,
            jlong* nanos_ptr) {
    return functions->GetThreadCpuTime(this, thread, nanos_ptr);
  }

  jvmtiError GetTimerInfo(jvmtiTimerInfo* info_ptr) {
    return functions->GetTimerInfo(this, info_ptr);
  }

  jvmtiError GetTime(jlong* nanos_ptr) {
    return functions->GetTime(this, nanos_ptr);
  }

  jvmtiError GetAvailableProcessors(jint* processor_count_ptr) {
    return functions->GetAvailableProcessors(this, processor_count_ptr);
  }

  jvmtiError AddToBootstrapClassLoaderSearch(const char* segment) {
    return functions->AddToBootstrapClassLoaderSearch(this, segment);
  }

  jvmtiError AddToSystemClassLoaderSearch(const char* segment) {
    return functions->AddToSystemClassLoaderSearch(this, segment);
  }

  jvmtiError GetSystemProperties(jint* count_ptr,
            char*** property_ptr) {
    return functions->GetSystemProperties(this, count_ptr, property_ptr);
  }

  jvmtiError GetSystemProperty(const char* property,
            char** value_ptr) {
    return functions->GetSystemProperty(this, property, value_ptr);
  }

  jvmtiError SetSystemProperty(const char* property,
            const char* value) {
    return functions->SetSystemProperty(this, property, value);
  }

  jvmtiError GetPhase(jvmtiPhase* phase_ptr) {
    return functions->GetPhase(this, phase_ptr);
  }

  jvmtiError DisposeEnvironment() {
    return functions->DisposeEnvironment(this);
  }

  jvmtiError SetEnvironmentLocalStorage(const void* data) {
    return functions->SetEnvironmentLocalStorage(this, data);
  }

  jvmtiError GetEnvironmentLocalStorage(void** data_ptr) {
    return functions->GetEnvironmentLocalStorage(this, data_ptr);
  }

  jvmtiError GetVersionNumber(jint* version_ptr) {
    return functions->GetVersionNumber(this, version_ptr);
  }

  jvmtiError GetErrorName(jvmtiError error,
            char** name_ptr) {
    return functions->GetErrorName(this, error, name_ptr);
  }

  jvmtiError SetVerboseFlag(jvmtiVerboseFlag flag,
            jboolean value) {
    return functions->SetVerboseFlag(this, flag, value);
  }

  jvmtiError GetJLocationFormat(jvmtiJlocationFormat* format_ptr) {
    return functions->GetJLocationFormat(this, format_ptr);
  }

#endif /* __cplusplus */
};


#ifdef __cplusplus
} /* extern "C" */
#endif /* __cplusplus */

#endif /* !_JAVA_JVMTI_H_ */

```

`native/nativehelper_utils.h`:

```h
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** JNI utils for nativehelper-internal use. */

#pragma once

#include <jni.h>

#if defined(__cplusplus)

#if !defined(DISALLOW_COPY_AND_ASSIGN)
// DISALLOW_COPY_AND_ASSIGN disallows the copy and operator= functions. It goes in the private:
// declarations in a class.
#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
  TypeName(const TypeName&) = delete;  \
  void operator=(const TypeName&) = delete
#endif  // !defined(DISALLOW_COPY_AND_ASSIGN)

// This seems a header-only include. Provide NPE throwing.
static inline int jniThrowNullPointerException(JNIEnv* env) {
    if (env->ExceptionCheck()) {
        // Drop any pending exception.
        env->ExceptionClear();
    }

    jclass e_class = env->FindClass("java/lang/NullPointerException");
    if (e_class == nullptr) {
        return -1;
    }

    if (env->ThrowNew(e_class, nullptr) != JNI_OK) {
        env->DeleteLocalRef(e_class);
        return -1;
    }

    env->DeleteLocalRef(e_class);
    return 0;
}

#endif  // defined(__cplusplus)


```

`native/scoped_local_ref.h`:

```h
/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <cstddef>

#include <jni.h>

#include "nativehelper_utils.h"

// A smart pointer that deletes a JNI local reference when it goes out of scope.
//
// For creating a `ScopedLocalRef<jstring>`, consider using `CREATE_UTF_OR_RETURN`.
template<typename T>
class ScopedLocalRef {
public:
    ScopedLocalRef(JNIEnv* env, T localRef) : mEnv(env), mLocalRef(localRef) {
    }

    ScopedLocalRef(ScopedLocalRef&& s) noexcept : mEnv(s.mEnv), mLocalRef(s.release()) {
    }

    explicit ScopedLocalRef(JNIEnv* env) : mEnv(env), mLocalRef(nullptr) {
    }

    ~ScopedLocalRef() {
        reset();
    }

    void reset(T ptr = nullptr) {
        if (ptr != mLocalRef) {
            if (mLocalRef != nullptr) {
                mEnv->DeleteLocalRef(mLocalRef);
            }
            mLocalRef = ptr;
        }
    }

    T release() __attribute__((warn_unused_result)) {
        T localRef = mLocalRef;
        mLocalRef = nullptr;
        return localRef;
    }

    T get() const {
        return mLocalRef;
    }


    // We do not expose an empty constructor as it can easily lead to errors
    // using common idioms, e.g.:
    //   ScopedLocalRef<...> ref;
    //   ref.reset(...);

    // Move assignment operator.
    ScopedLocalRef& operator=(ScopedLocalRef&& s) noexcept {
        reset(s.release());
        mEnv = s.mEnv;
        return *this;
    }

    // Allows "if (scoped_ref == nullptr)"
    bool operator==(std::nullptr_t) const {
        return mLocalRef == nullptr;
    }

    // Allows "if (scoped_ref != nullptr)"
    bool operator!=(std::nullptr_t) const {
        return mLocalRef != nullptr;
    }

private:
    JNIEnv* mEnv;
    T mLocalRef;

    DISALLOW_COPY_AND_ASSIGN(ScopedLocalRef);
};


```

`native/scoped_utf_chars.h`:

```h
/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <stddef.h>
#include <string.h>

#include <jni.h>

#include "nativehelper_utils.h"

// Protect this with __has_include to cope with `stl: "none"` users.
#if __has_include(<string_view>)
#include <string_view>
#endif

// A smart pointer that provides read-only access to a Java string's UTF chars.
// Unlike GetStringUTFChars, we throw NullPointerException rather than abort if
// passed a null jstring, and c_str will return nullptr.
// This makes the correct idiom very simple:
//
//   ScopedUtfChars name(env, java_name);
//   if (name.c_str() == nullptr) {
//     return nullptr;
//   }
//
// Also consider using `GET_UTF_OR_RETURN`, a shorthand for the 4 lines above.
class ScopedUtfChars {
 public:
  ScopedUtfChars(JNIEnv* env, jstring s) : env_(env), string_(s) {
    if (s == nullptr) {
      utf_chars_ = nullptr;
      jniThrowNullPointerException(env);
    } else {
      utf_chars_ = env->GetStringUTFChars(s, nullptr);
    }
  }

  ScopedUtfChars(ScopedUtfChars&& rhs) noexcept :
      env_(rhs.env_), string_(rhs.string_), utf_chars_(rhs.utf_chars_) {
    rhs.env_ = nullptr;
    rhs.string_ = nullptr;
    rhs.utf_chars_ = nullptr;
  }

  ~ScopedUtfChars() {
    if (utf_chars_) {
      env_->ReleaseStringUTFChars(string_, utf_chars_);
    }
  }

  ScopedUtfChars& operator=(ScopedUtfChars&& rhs) noexcept {
    if (this != &rhs) {
      // Delete the currently owned UTF chars.
      this->~ScopedUtfChars();

      // Move the rhs ScopedUtfChars and zero it out.
      env_ = rhs.env_;
      string_ = rhs.string_;
      utf_chars_ = rhs.utf_chars_;
      rhs.env_ = nullptr;
      rhs.string_ = nullptr;
      rhs.utf_chars_ = nullptr;
    }
    return *this;
  }

  const char* c_str() const {
    return utf_chars_;
  }

  size_t size() const {
    return strlen(utf_chars_);
  }

  const char& operator[](size_t n) const {
    return utf_chars_[n];
  }

#if __has_include(<string_view>)
  operator std::string_view() const { return utf_chars_; }
#endif

 private:
  JNIEnv* env_;
  jstring string_;
  const char* utf_chars_;

  DISALLOW_COPY_AND_ASSIGN(ScopedUtfChars);
};

```

`native/stoic.cc`:

```cc
#include <cstddef>
#include <fcntl.h>
#include <fstream>
#include <memory>
#include <sstream>
#include <string>
#include <unistd.h>
#include <unordered_set>

#define LOG_TAG "stoic"

#include <android/log.h>
#include "stoic_logging.h"
#include "scoped_local_ref.h"
#include "scoped_utf_chars.h"

#include <jni.h>
#include <stdlib.h>
#include <string.h>

#include "jvmti.h"

#define CHECK_JVMTI(x) CHECK_EQ((x), JVMTI_ERROR_NONE)

#define JVMTI_THROW_IF_ERROR(x, if_fail) do { int result = (x); if (result != JVMTI_ERROR_NONE) { throwJvmtiError(jni, result, #x); if_fail; } } while (false)

// Note: Art jvmti capabilities are documented here:
// https://android.googlesource.com/platform/art/+/refs/heads/main/openjdkjvmti/art_jvmti.h#256

//using namespace std;
//
typedef struct {
  jvmtiEnv *jvmti;
  jclass stoicJvmtiVmClass;
 
  // callbacks
  jmethodID nativeCallbackOnBreakpoint;
  jmethodID nativeCallbackOnMethodEntry;
  jmethodID nativeCallbackOnMethodExit;
 
  // boxing stuff
  jclass booleanClass;
  jclass byteClass;
  jclass characterClass;
  jclass shortClass;
  jclass integerClass;
  jclass longClass;
  jclass floatClass;
  jclass doubleClass;
  jmethodID booleanCtor;
  jmethodID byteCtor;
  jmethodID characterCtor;
  jmethodID shortCtor;
  jmethodID integerCtor;
  jmethodID longCtor;
  jmethodID floatCtor;
  jmethodID doubleCtor;
 
  // com.squareup.stoic.jvmti.JvmtiMethod stuff
  jclass stoicJvmtiMethodClass;
  jmethodID stoicJvmtiMethodCtor;
  jfieldID stoicJvmtiMethodMethodId;
  jfieldID stoicJvmtiMethodPrivateClazz;
  jfieldID stoicJvmtiMethodPrivateName;
  jfieldID stoicJvmtiMethodPrivateSignature;
  jfieldID stoicJvmtiMethodPrivateGeneric;
  jfieldID stoicJvmtiMethodPrivateStartLocation;
  jfieldID stoicJvmtiMethodPrivateEndLocation;
  jfieldID stoicJvmtiMethodPrivateArgsSize;
  jfieldID stoicJvmtiMethodPrivateMaxLocals;
  jfieldID stoicJvmtiMethodPrivateModifiers;

  // com.squareup.stoic.jvmti.JvmtiField stuff
  jclass stoicJvmtiFieldClass;
  jmethodID stoicJvmtiFieldCtor;
  jfieldID stoicJvmtiFieldClazz;
  jfieldID stoicJvmtiFieldFieldId;
  jfieldID stoicJvmtiFieldPrivateName;
  jfieldID stoicJvmtiFieldPrivateSignature;
  jfieldID stoicJvmtiFieldPrivateGeneric;
  jfieldID stoicJvmtiFieldPrivateModifiers;
} GlobalAgentData;
 
static GlobalAgentData *gdata;

// We don't want to process a callback for our callback to the VM
// TODO: We could probably be more efficient with SetEventNotificationMode
// TODO: We might want to allow the callback to ask for callbacks to be
// temporarily re-enabled
thread_local bool callbacksAllowed = true;

static void
throwJvmtiError(JNIEnv* jni, int result, const char* desc) {
  ScopedLocalRef<jclass> jvmtiExceptionClass(jni, jni->FindClass("com/squareup/stoic/jvmti/JvmtiException"));
  CHECK(jvmtiExceptionClass.get() != NULL);
  jmethodID ctor = jni->GetMethodID(jvmtiExceptionClass.get(), "<init>", "(ILjava/lang/String;)V");
  CHECK(ctor != NULL);
  ScopedLocalRef<jstring> jdesc(jni, jni->NewStringUTF(desc));
  ScopedLocalRef<jthrowable> exc(jni, (jthrowable) jni->NewObject(jvmtiExceptionClass.get(), ctor, result, jdesc.get()));
  CHECK(exc.get() != NULL);
  jni->Throw(exc.get());
}

// Helper to ensure a specific capability is enabled, adding it on-demand if not already present
// Returns JVMTI_ERROR_NONE if the capability is available (or was successfully added)
// Returns the actual error code from GetCapabilities or AddCapabilities otherwise
static jvmtiError
ensureCapability(jvmtiEnv* jvmti, jvmtiCapabilities* cap) {
  // First check if we already have the capability
  jvmtiCapabilities current_caps;
  memset(&current_caps, 0, sizeof(jvmtiCapabilities));
  jvmtiError err = jvmti->GetCapabilities(&current_caps);
  if (err != JVMTI_ERROR_NONE) {
    return err;
  }

  // Check if we already have this capability by comparing the structs
  // We'll use the fact that capabilities are boolean fields in the struct
  unsigned char* current_ptr = (unsigned char*)&current_caps;
  unsigned char* requested_ptr = (unsigned char*)cap;
  bool already_have = true;
  for (size_t i = 0; i < sizeof(jvmtiCapabilities); i++) {
    if (requested_ptr[i] && !current_ptr[i]) {
      already_have = false;
      break;
    }
  }

  if (already_have) {
    return JVMTI_ERROR_NONE;
  }

  // Try to add the capability
  return jvmti->AddCapabilities(cap);
}
 
jvmtiIterationControl JNICALL
jvmtiHeapObjectCallback_tagUnconditionally(jlong class_tag, jlong size, jlong* tag_ptr, void* user_data) {
  *tag_ptr = 1;
  return JVMTI_ITERATION_CONTINUE;
}

jvmtiIterationControl JNICALL
jvmtiHeapObjectCallback_untagUnconditionally(jlong class_tag, jlong size, jlong* tag_ptr, void* user_data) {
  *tag_ptr = 0;
  return JVMTI_ITERATION_CONTINUE;
}

jint JNICALL
jvmtiHeapIterationCallback_tagUnconditionally(jlong class_tag, jlong size, jlong* tag_ptr, jint length, void* user_data) {
  *tag_ptr = *static_cast<jlong*>(user_data);
  return 0;
}

jint JNICALL
jvmtiHeapIterationCallback_untagUnconditionally(jlong class_tag, jlong size, jlong* tag_ptr, jint length, void* user_data) {
  *tag_ptr = 0;
  return 0;
}

JNIEXPORT jobject JNICALL
Jvmti_VirtualMachine_nativeInstances(JNIEnv *jni, jobject vmClass, jclass klass, jboolean includeSubclasses) {
  jvmtiEnv* jvmti = gdata->jvmti;

  // Clear all tags in the heap
  {
    jvmtiHeapCallbacks callbacks = {
      .heap_iteration_callback = jvmtiHeapIterationCallback_untagUnconditionally,
    };

    CHECK_JVMTI(jvmti->IterateThroughHeap(
          JVMTI_HEAP_FILTER_UNTAGGED,
          nullptr,
          &callbacks,
          nullptr));
  }

  if (includeSubclasses) {
    // klassClass = java.lang.Class
    ScopedLocalRef<jclass> klassClass(jni, jni->FindClass("java/lang/Class"));
    if (!klassClass.get()) {
        jni->ExceptionDescribe();
        jni->ExceptionClear();
        return nullptr;
    }

    // Tag every Class object
    jlong tag = 1;
    CHECK_JVMTI(jvmti->IterateOverInstancesOfClass(
          klassClass.get(),
          JVMTI_HEAP_OBJECT_EITHER,
          jvmtiHeapObjectCallback_tagUnconditionally,
          &tag));

    // Iterate through every Class object, clearing the tags of classes that aren't subclasses of klass
    jobject* obj_list;
    jint obj_len;
    jlong tagOne = 1;
    CHECK_JVMTI(jvmti->GetObjectsWithTags(1, &tagOne, &obj_len, &obj_list, nullptr));
    jmethodID method_isAssignableFrom = jni->GetMethodID(klassClass.get(), "isAssignableFrom", "(Ljava/lang/Class;)Z");
    CHECK(method_isAssignableFrom != nullptr);
    for (int i = 0; i < obj_len; i++) {
      ScopedLocalRef<jobject> klassCandidate(jni, obj_list[i]);

      // Never throws (famous last words?)
      jboolean isAssignable = jni->CallBooleanMethod(klass, method_isAssignableFrom, klassCandidate.get());
      
      if (!isAssignable) {
        jlong tagZero = 0;
        CHECK_JVMTI(jvmti->SetTag(klassCandidate.get(), tagZero));
      }
    }

    CHECK_JVMTI(jvmti->Deallocate((unsigned char*) obj_list));
    obj_list = NULL;

    // Tag every object whose class is tagged
    {
      jvmtiHeapCallbacks callbacks = {
        .heap_iteration_callback = jvmtiHeapIterationCallback_tagUnconditionally,
      };
      CHECK_JVMTI(jvmti->IterateThroughHeap(
          JVMTI_HEAP_FILTER_CLASS_UNTAGGED,
          nullptr,
          &callbacks,
          &tagOne));
    }

    // TODO: This wouldn't work for subclasses of java.lang.Class
    // java.lang.Class is final so there aren't any, but if people
    // asked for instances of java.lang.Class and subclasses, this
    // will give the wrong answer. So I need to special-case that.

    // Untag instances of java.lang.Class
    CHECK_JVMTI(jvmti->IterateOverInstancesOfClass(
          klassClass.get(),
          JVMTI_HEAP_OBJECT_TAGGED,
          jvmtiHeapObjectCallback_untagUnconditionally,
          nullptr));
  } else {
    // tag every object whose Class is exactly klass
    jlong tag = 1;
    CHECK_JVMTI(jvmti->IterateOverInstancesOfClass(
          klass,
          JVMTI_HEAP_OBJECT_EITHER,
          jvmtiHeapObjectCallback_tagUnconditionally,
          &tag));
  }
 
  // Get all of the tagged objects
  jobject* obj_list;
  jint obj_len;
  jlong tag = 1;
  CHECK_JVMTI(jvmti->GetObjectsWithTags(1, &tag, &obj_len, &obj_list, nullptr));
 
  jobjectArray klassArray = jni->NewObjectArray(obj_len, klass, NULL);
  if (klassArray == nullptr) {
    LOG(ERROR) << "NewObjectArray failed";
    return nullptr;
  }
 
  for (int i = 0; i < obj_len; i++) {
    ScopedLocalRef<jobject> obj(jni, obj_list[i]);
    jni->SetObjectArrayElement(klassArray, i, obj.get());
  }

  CHECK_JVMTI(jvmti->Deallocate((unsigned char*) obj_list));
  obj_list = NULL;

  return klassArray;
}

JNIEXPORT jobject JNICALL
Jvmti_VirtualMachine_nativeSubclasses(JNIEnv *jni, jobject vmClass, jclass klass) {
  jvmtiEnv* jvmti = gdata->jvmti;
  // TODO: verify VirtualMachine.class lock held

  // Clear all tags in the heap
  {
    jvmtiHeapCallbacks callbacks = {
      .heap_iteration_callback = jvmtiHeapIterationCallback_untagUnconditionally,
    };

    CHECK_JVMTI(jvmti->IterateThroughHeap(
          JVMTI_HEAP_FILTER_UNTAGGED,
          nullptr,
          &callbacks,
          nullptr));
  }

  // klassClass = java.lang.Class
  ScopedLocalRef<jclass> klassClass(jni, jni->FindClass("java/lang/Class"));
  if (!klassClass.get()) {
      jni->ExceptionDescribe();
      jni->ExceptionClear();
      return nullptr;
  }

  // Tag every Class object
  jlong tag = 1;
  CHECK_JVMTI(jvmti->IterateOverInstancesOfClass(
        klassClass.get(),
        JVMTI_HEAP_OBJECT_EITHER,
        jvmtiHeapObjectCallback_tagUnconditionally,
        &tag));

  // Iterate through every Class object, clearing the tags of classes that aren't subclasses of klass
  jobject* obj_list = NULL;
  jint obj_len = -1;
  const jlong tagOne = 1;
  CHECK_JVMTI(jvmti->GetObjectsWithTags(1, &tagOne, &obj_len, &obj_list, nullptr));
  jmethodID method_isAssignableFrom = jni->GetMethodID(klassClass.get(), "isAssignableFrom", "(Ljava/lang/Class;)Z");
  CHECK(method_isAssignableFrom != nullptr);
  for (int i = 0; i < obj_len; i++) {
    ScopedLocalRef<jobject> klassCandidate(jni, obj_list[i]);

    // Never throws (famous last words?)
    jboolean isAssignable = jni->CallBooleanMethod(klass, method_isAssignableFrom, klassCandidate.get());
    
    if (!isAssignable) {
      jlong tagZero = 0;
      CHECK_JVMTI(jvmti->SetTag(klassCandidate.get(), tagZero));
    }
  }

  CHECK_JVMTI(jvmti->Deallocate((unsigned char*) obj_list));
  obj_list = NULL;

  // Get all of the objects tagged with 1
  obj_len = -1;
  CHECK_JVMTI(jvmti->GetObjectsWithTags(1, &tagOne, &obj_len, &obj_list, nullptr));
 
  jobjectArray klassArray = jni->NewObjectArray(obj_len, klassClass.get(), NULL);
  if (klassArray == nullptr) {
    LOG(ERROR) << "NewObjectArray failed";
    return nullptr;
  }
 
  for (int i = 0; i < obj_len; i++) {
    ScopedLocalRef<jobject> obj(jni, obj_list[i]);
    jni->SetObjectArrayElement(klassArray, i, obj.get());
  }

  CHECK_JVMTI(jvmti->Deallocate((unsigned char*) obj_list));
  obj_list = NULL;

  return klassArray;
}

JNIEXPORT jlong JNICALL
Jvmti_VirtualMachine_nativeGetMethodId(JNIEnv *jni, jobject vmClass, jclass clazz, jstring methodName, jstring methodSignature) {
  const char* methodNameChars = jni->GetStringUTFChars(methodName, NULL);
  const char* methodSignatureChars = jni->GetStringUTFChars(methodSignature, NULL);
  jmethodID methodId = jni->GetMethodID(clazz, methodNameChars, methodSignatureChars);
  jni->ReleaseStringUTFChars(methodName, methodNameChars);
  jni->ReleaseStringUTFChars(methodSignature, methodSignatureChars);

  return (jlong) methodId;
}

JNIEXPORT void JNICALL
Jvmti_VirtualMachine_nativeSetBreakpoint(JNIEnv *jni, jobject vmClass, jlong methodId, jlong location) {
  jvmtiEnv* jvmti = gdata->jvmti;
  jmethodID castMethodId = reinterpret_cast<jmethodID>(methodId);
  JVMTI_THROW_IF_ERROR(jvmti->SetBreakpoint(castMethodId, location), ;);
}

JNIEXPORT void JNICALL
Jvmti_VirtualMachine_nativeClearBreakpoint(JNIEnv *jni, jobject vmClass, jlong methodId, jlong location) {
  jvmtiEnv* jvmti = gdata->jvmti;
  CHECK_JVMTI(jvmti->ClearBreakpoint((jmethodID) methodId, (jlocation) location));
}

JNIEXPORT void JNICALL
Jvmti_VirtualMachine_nativeGetMethodCoreMetadata(JNIEnv *jni, jobject vmClass, jobject jvmtiMethod) {
  jvmtiEnv* jvmti = gdata->jvmti;

  jlong longMethodId = jni->GetLongField(jvmtiMethod, gdata->stoicJvmtiMethodMethodId);
  jmethodID castMethodId = reinterpret_cast<jmethodID>(longMethodId);

  char* name = NULL;
  char* signature = NULL;
  char* generic = NULL;
  CHECK_JVMTI(jvmti->GetMethodName(castMethodId, &name, &signature, &generic));
  ScopedLocalRef<jstring> jname(jni, jni->NewStringUTF(name));
  ScopedLocalRef<jstring> jsignature(jni, jni->NewStringUTF(signature));
  ScopedLocalRef<jstring> jgeneric(jni, jni->NewStringUTF(generic));

  jlocation startLocation = -1;
  jlocation endLocation = -1;

  jvmtiError error = JVMTI_ERROR_NONE;
  error = jvmti->GetMethodLocation(castMethodId, &startLocation, &endLocation);
  if (error != JVMTI_ERROR_NATIVE_METHOD) { CHECK_JVMTI(error); }

  jint argsSize = -1;
  error = jvmti->GetArgumentsSize(castMethodId, &argsSize);
  if (error != JVMTI_ERROR_NATIVE_METHOD) { CHECK_JVMTI(error); }

  jint maxLocals = -1;
  error = jvmti->GetMaxLocals(castMethodId, &maxLocals);
  if (error != JVMTI_ERROR_NATIVE_METHOD) { CHECK_JVMTI(error); }

  jint modifiers = -1;
  CHECK_JVMTI(jvmti->GetMethodModifiers(castMethodId, &modifiers));

  jclass declaringClass = nullptr;
  CHECK_JVMTI(jvmti->GetMethodDeclaringClass(castMethodId, &declaringClass));
  jni->SetObjectField(jvmtiMethod, gdata->stoicJvmtiMethodPrivateClazz, declaringClass);
  jni->DeleteLocalRef(declaringClass);
  declaringClass = nullptr;

  jni->SetObjectField(jvmtiMethod, gdata->stoicJvmtiMethodPrivateName, jname.get());
  jni->SetObjectField(jvmtiMethod, gdata->stoicJvmtiMethodPrivateSignature, jsignature.get());
  jni->SetObjectField(jvmtiMethod, gdata->stoicJvmtiMethodPrivateGeneric, jgeneric.get());
  jni->SetLongField(jvmtiMethod, gdata->stoicJvmtiMethodPrivateStartLocation, startLocation);
  jni->SetLongField(jvmtiMethod, gdata->stoicJvmtiMethodPrivateEndLocation, endLocation);
  jni->SetIntField(jvmtiMethod, gdata->stoicJvmtiMethodPrivateArgsSize, argsSize);
  jni->SetIntField(jvmtiMethod, gdata->stoicJvmtiMethodPrivateMaxLocals, maxLocals);
  jni->SetIntField(jvmtiMethod, gdata->stoicJvmtiMethodPrivateModifiers, modifiers);

  jvmti->Deallocate((unsigned char*) name);
  jvmti->Deallocate((unsigned char*) signature);
  jvmti->Deallocate((unsigned char*) generic);
}

JNIEXPORT void JNICALL
Jvmti_VirtualMachine_nativeGetFieldCoreMetadata(JNIEnv *jni, jobject vmClass, jobject jvmtiField) {
  jvmtiEnv* jvmti = gdata->jvmti;

  jlong longFieldId = jni->GetLongField(jvmtiField, gdata->stoicJvmtiFieldFieldId);
  jfieldID castFieldId = reinterpret_cast<jfieldID>(longFieldId);

  ScopedLocalRef<jclass> clazz(jni, (jclass) jni->GetObjectField(jvmtiField, gdata->stoicJvmtiFieldClazz));

  char* name = NULL;
  char* signature = NULL;
  char* generic = NULL;
  CHECK_JVMTI(jvmti->GetFieldName(clazz.get(), castFieldId, &name, &signature, &generic));
  ScopedLocalRef<jstring> jname(jni, jni->NewStringUTF(name));
  ScopedLocalRef<jstring> jsignature(jni, jni->NewStringUTF(signature));
  ScopedLocalRef<jstring> jgeneric(jni, jni->NewStringUTF(generic));

  jint modifiers = -1;
  CHECK_JVMTI(jvmti->GetFieldModifiers(clazz.get(), castFieldId, &modifiers));

  jni->SetObjectField(jvmtiField, gdata->stoicJvmtiFieldPrivateName, jname.get());
  jni->SetObjectField(jvmtiField, gdata->stoicJvmtiFieldPrivateSignature, jsignature.get());
  jni->SetObjectField(jvmtiField, gdata->stoicJvmtiFieldPrivateGeneric, jgeneric.get());
  jni->SetIntField(jvmtiField, gdata->stoicJvmtiFieldPrivateModifiers, modifiers);

  jvmti->Deallocate((unsigned char*) name);
  jvmti->Deallocate((unsigned char*) signature);
  jvmti->Deallocate((unsigned char*) generic);
}

JNIEXPORT jobject JNICALL
Jvmti_VirtualMachine_nativeGetLocalVariables(JNIEnv *jni, jobject vmClass, jlong methodId) {
  jvmtiEnv* jvmti = gdata->jvmti;
  jmethodID castMethodId = reinterpret_cast<jmethodID>(methodId);
  jint entryCount = -1;
  jvmtiLocalVariableEntry* table = NULL;

  // Ensure we have the capability to access local variables (needed for GetLocalVariableTable)
  jvmtiCapabilities caps = {0};
  caps.can_access_local_variables = JNI_TRUE;
  jvmtiError capErr = ensureCapability(jvmti, &caps);
  if (capErr != JVMTI_ERROR_NONE) {
    throwJvmtiError(jni, capErr, "jvmti->AddCapabilities(can_access_local_variables)");
    return NULL;
  }

  // This can fail if local variable information isn't available
  JVMTI_THROW_IF_ERROR(jvmti->GetLocalVariableTable(castMethodId, &entryCount, &table), return NULL);

  ScopedLocalRef<jclass> LocalVariable(jni, jni->FindClass("com/squareup/stoic/jvmti/LocalVariable"));
  CHECK(LocalVariable.get() != NULL);
  jmethodID ctor = jni->GetMethodID(LocalVariable.get(), "<init>", "(JILjava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V");
  CHECK(ctor != NULL);
  ScopedLocalRef<jobjectArray> jTable(jni, jni->NewObjectArray(entryCount, LocalVariable.get(), NULL));
  CHECK(jTable.get() != NULL);

  for (int i = 0; i < entryCount; i++) {
    jlong startLocation = table[i].start_location;
    jint length = table[i].length;
    ScopedLocalRef<jstring> name(jni, jni->NewStringUTF(table[i].name));
    ScopedLocalRef<jstring> signature(jni, jni->NewStringUTF(table[i].signature));
    ScopedLocalRef<jstring> genericSignature(jni, jni->NewStringUTF(table[i].generic_signature));
    jint slot = table[i].slot;
    ScopedLocalRef<jobject> localVar(jni, jni->NewObject(LocalVariable.get(), ctor, startLocation, length, name.get(), signature.get(), genericSignature.get(), slot));
    CHECK(localVar.get() != NULL);
    jni->SetObjectArrayElement(jTable.get(), i, localVar.get());
  }

  // Deallocate
  for (int i = 0; i < entryCount; i++) {
    CHECK_JVMTI(jvmti->Deallocate((unsigned char*) table[i].name));
    CHECK_JVMTI(jvmti->Deallocate((unsigned char*) table[i].signature));
    CHECK_JVMTI(jvmti->Deallocate((unsigned char*) table[i].generic_signature));
    table[i].name = table[i].signature = table[i].generic_signature = NULL;
  }
  CHECK_JVMTI(jvmti->Deallocate((unsigned char*) table));
  table = NULL;

  return jTable.release();
}

JNIEXPORT jobject JNICALL
Jvmti_VirtualMachine_nativeGetLocalObject(JNIEnv *jni, jobject vmClass, jthread thread, jint height, jint slot) {
  jvmtiEnv* jvmti = gdata->jvmti;

  // Ensure we have the capability to access local variables (needed for GetLocalObject)
  jvmtiCapabilities caps = {0};
  caps.can_access_local_variables = JNI_TRUE;
  jvmtiError capErr = ensureCapability(jvmti, &caps);
  if (capErr != JVMTI_ERROR_NONE) {
    throwJvmtiError(jni, capErr, "jvmti->AddCapabilities(can_access_local_variables)");
    return NULL;
  }

  jint frameCount = -1;
  CHECK_JVMTI(jvmti->GetFrameCount(thread, &frameCount));
  jobject result = NULL;
  CHECK_JVMTI(jvmti->GetLocalObject(thread, frameCount - height, slot, &result));
  return result;
}

JNIEXPORT jint JNICALL
Jvmti_VirtualMachine_nativeGetLocalInt(JNIEnv *jni, jobject vmClass, jthread thread, jint height, jint slot) {
  jvmtiEnv* jvmti = gdata->jvmti;

  // Ensure we have the capability to access local variables (needed for GetLocalInt)
  jvmtiCapabilities caps = {0};
  caps.can_access_local_variables = JNI_TRUE;
  jvmtiError capErr = ensureCapability(jvmti, &caps);
  if (capErr != JVMTI_ERROR_NONE) {
    throwJvmtiError(jni, capErr, "jvmti->AddCapabilities(can_access_local_variables)");
    return 0;
  }

  jint frameCount = -1;
  CHECK_JVMTI(jvmti->GetFrameCount(thread, &frameCount));
  jint result = 0;
  CHECK_JVMTI(jvmti->GetLocalInt(thread, frameCount - height, slot, &result));
  return result;
}

JNIEXPORT jlong JNICALL
Jvmti_VirtualMachine_nativeGetLocalLong(JNIEnv *jni, jobject vmClass, jthread thread, jint height, jint slot) {
  jvmtiEnv* jvmti = gdata->jvmti;

  // Ensure we have the capability to access local variables (needed for GetLocalLong)
  jvmtiCapabilities caps = {0};
  caps.can_access_local_variables = JNI_TRUE;
  jvmtiError capErr = ensureCapability(jvmti, &caps);
  if (capErr != JVMTI_ERROR_NONE) {
    throwJvmtiError(jni, capErr, "jvmti->AddCapabilities(can_access_local_variables)");
    return 0;
  }

  jint frameCount = -1;
  CHECK_JVMTI(jvmti->GetFrameCount(thread, &frameCount));
  jlong result = 0;
  CHECK_JVMTI(jvmti->GetLocalLong(thread, frameCount - height, slot, &result));
  return result;
}

JNIEXPORT jfloat JNICALL
Jvmti_VirtualMachine_nativeGetLocalFloat(JNIEnv *jni, jobject vmClass, jthread thread, jint height, jint slot) {
  jvmtiEnv* jvmti = gdata->jvmti;

  // Ensure we have the capability to access local variables (needed for GetLocalFloat)
  jvmtiCapabilities caps = {0};
  caps.can_access_local_variables = JNI_TRUE;
  jvmtiError capErr = ensureCapability(jvmti, &caps);
  if (capErr != JVMTI_ERROR_NONE) {
    throwJvmtiError(jni, capErr, "jvmti->AddCapabilities(can_access_local_variables)");
    return 0.0f;
  }

  jint frameCount = -1;
  CHECK_JVMTI(jvmti->GetFrameCount(thread, &frameCount));
  jfloat result = 0.0f;
  CHECK_JVMTI(jvmti->GetLocalFloat(thread, frameCount - height, slot, &result));
  return result;
}

JNIEXPORT jdouble JNICALL
Jvmti_VirtualMachine_nativeGetLocalDouble(JNIEnv *jni, jobject vmClass, jthread thread, jint height, jint slot) {
  jvmtiEnv* jvmti = gdata->jvmti;

  // Ensure we have the capability to access local variables (needed for GetLocalDouble)
  jvmtiCapabilities caps = {0};
  caps.can_access_local_variables = JNI_TRUE;
  jvmtiError capErr = ensureCapability(jvmti, &caps);
  if (capErr != JVMTI_ERROR_NONE) {
    throwJvmtiError(jni, capErr, "jvmti->AddCapabilities(can_access_local_variables)");
    return 0.0;
  }

  jint frameCount = -1;
  CHECK_JVMTI(jvmti->GetFrameCount(thread, &frameCount));
  jdouble result = 0.0;
  CHECK_JVMTI(jvmti->GetLocalDouble(thread, frameCount - height, slot, &result));
  return result;
}

JNIEXPORT jobject JNICALL
Jvmti_VirtualMachine_nativeGetClassMethods(JNIEnv *jni, jobject vmClass, jclass clazz) {
  jvmtiEnv* jvmti = gdata->jvmti;
  jint methodCount = -1;
  jmethodID* methods = NULL;
  CHECK_JVMTI(jvmti->GetClassMethods(clazz, &methodCount, &methods));

  ScopedLocalRef<jobjectArray> jmethods(jni, jni->NewObjectArray(methodCount, gdata->stoicJvmtiMethodClass, NULL));
  CHECK(jmethods.get() != NULL);
  for (int i = 0; i < methodCount; i++) {
    jlong longMethodId = reinterpret_cast<jlong>(methods[i]);
    ScopedLocalRef<jobject> method(jni, jni->NewObject(
          gdata->stoicJvmtiMethodClass,
          gdata->stoicJvmtiMethodCtor,
          longMethodId));

    jni->SetObjectArrayElement(jmethods.get(), i, method.get());
  }

  jvmti->Deallocate((unsigned char*) methods);

  return jmethods.release();
}

JNIEXPORT jobject JNICALL
Jvmti_VirtualMachine_nativeGetClassFields(JNIEnv *jni, jobject vmClass, jclass clazz) {
  jvmtiEnv* jvmti = gdata->jvmti;
  jint fieldCount = -1;
  jfieldID* fields = NULL;
  CHECK_JVMTI(jvmti->GetClassFields(clazz, &fieldCount, &fields));

  ScopedLocalRef<jobjectArray> jfields(jni, jni->NewObjectArray(fieldCount, gdata->stoicJvmtiFieldClass, NULL));
  CHECK(jfields.get() != NULL);
  for (int i = 0; i < fieldCount; i++) {
    jlong longFieldId = reinterpret_cast<jlong>(fields[i]);
    ScopedLocalRef<jobject> field(jni, jni->NewObject(
          gdata->stoicJvmtiFieldClass,
          gdata->stoicJvmtiFieldCtor,
          clazz,
          longFieldId));

    jni->SetObjectArrayElement(jfields.get(), i, field.get());
  }

  jvmti->Deallocate((unsigned char*) fields);

  return jfields.release();
}

JNIEXPORT jobject JNICALL
Jvmti_VirtualMachine_nativeToReflectedField(JNIEnv *jni, jobject vmClass, jclass clazz, jlong fieldId, jboolean isStatic) {
  jfieldID castFieldId = reinterpret_cast<jfieldID>(fieldId);
  return jni->ToReflectedField(clazz, castFieldId, isStatic);
}

JNIEXPORT jobject JNICALL
Jvmti_VirtualMachine_nativeToReflectedMethod(JNIEnv *jni, jobject vmClass, jclass clazz, jlong methodId, jboolean isStatic) {
  jmethodID castMethodId = reinterpret_cast<jmethodID>(methodId);
  return jni->ToReflectedMethod(clazz, castMethodId, isStatic);
}

JNIEXPORT jlong JNICALL
Jvmti_VirtualMachine_nativeFromReflectedMethod(JNIEnv *jni, jobject vmClass, jobject method) {
  jmethodID methodId = jni->FromReflectedMethod(method);
  return reinterpret_cast<jlong>(methodId);
}

JNIEXPORT jstring JNICALL
Jvmti_VirtualMachine_nativeGetClassSignature(JNIEnv *jni, jobject vmClass, jclass clazz) {
  char* signature = NULL;
  char* generic = NULL;
  CHECK_JVMTI(gdata->jvmti->GetClassSignature(clazz, &signature, &generic));
  ScopedLocalRef<jstring> jsignature(jni, jni->NewStringUTF(signature));
  //ScopedLocalRef<jstring> jgeneric(jni, jni->NewStringUTF(generic));
  gdata->jvmti->Deallocate((unsigned char*) signature);
  gdata->jvmti->Deallocate((unsigned char*) generic);

  return jsignature.release();
}

JNIEXPORT void JNICALL
Jvmti_VirtualMachine_nativeMethodEntryCallbacks(JNIEnv *jni, jobject vmClass, jthread thread, jboolean isEnabled) {
  // This requires the can_generate_method_entry_events capability, which must be added at load time.
  JVMTI_THROW_IF_ERROR(gdata->jvmti->SetEventNotificationMode(isEnabled ? JVMTI_ENABLE : JVMTI_DISABLE, JVMTI_EVENT_METHOD_ENTRY, thread), return);
}

JNIEXPORT void JNICALL
Jvmti_VirtualMachine_nativeMethodExitCallbacks(JNIEnv *jni, jobject vmClass, jthread thread, jboolean isEnabled) {
  // This requires the can_generate_method_exit_events capability, which must be added at load time.
  JVMTI_THROW_IF_ERROR(gdata->jvmti->SetEventNotificationMode(isEnabled ? JVMTI_ENABLE : JVMTI_DISABLE, JVMTI_EVENT_METHOD_EXIT, thread), return);
}

struct AgentInfo {
  std::string options;
};

// Converts a class name to a type descriptor
// (ex. "java.lang.String" to "Ljava/lang/String;")
std::string classNameToDescriptor(const char* className) {
  std::stringstream ss;
  ss << "L";
  for (auto p = className; *p != '\0'; ++p) {
    ss << (*p == '.' ? '/' : *p);
  }
  ss << ";";
  return ss.str();
}

// Converts a descriptor (Lthis/style/of/name;) to a jni-FindClass style Fully-qualified class name
// (this/style/of/name).
std::string DescriptorToFQCN(const std::string& descriptor) {
  return descriptor.substr(1, descriptor.size() - 2);
}

static AgentInfo* GetAgentInfo(jvmtiEnv* jvmti) {
  AgentInfo* ai = nullptr;
  CHECK_EQ(jvmti->GetEnvironmentLocalStorage(reinterpret_cast<void**>(&ai)), JVMTI_ERROR_NONE);
  CHECK(ai != nullptr);
  return ai;
}

static void JNICALL
CbBreakpoint(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread, jmethodID methodId, jlocation location) {
  if (!callbacksAllowed) {
    return;
  }

  jint count = -1;
  CHECK_JVMTI(jvmti->GetFrameCount(thread, &count));

  jlong methodIdAsLong = reinterpret_cast<jlong>(methodId);

  callbacksAllowed = false;
  jni->CallStaticVoidMethod(
      gdata->stoicJvmtiVmClass,
      gdata->nativeCallbackOnBreakpoint,
      methodIdAsLong,
      location,
      count);
  callbacksAllowed = true;
}

static void JNICALL
CbMethodEntry(
    jvmtiEnv* jvmti,
    JNIEnv* jni,
    jthread thread,
    jmethodID methodId) {
  if (!callbacksAllowed) {
    return;
  }

  jint count = -1;
  CHECK_JVMTI(jvmti->GetFrameCount(thread, &count));

  // Note: The methodId parameter tells us which method was entered, but this may not
  // match the top stack frame (frame 0) when inspected via GetFrameLocation.
  // This occurs for native methods, especially intrinsics like System.arraycopy:
  // - JVMTI fires MethodEntry for the native method (e.g., System.arraycopy)
  // - But GetFrameLocation returns the calling Java method (e.g., Arrays.copyOf)
  // - Native methods may not appear as distinct stack frames, particularly when
  //   inlined/intrinsified by the JVM
  // We trust the methodId parameter from JVMTI rather than attempting to verify it
  // against the stack, as the stack may not reflect native method calls as separate frames.
  jmethodID frameMethodId = nullptr;
  jlocation location = -1;
  CHECK_JVMTI(jvmti->GetFrameLocation(thread, 0, &frameMethodId, &location));

  jlong methodIdAsLong = reinterpret_cast<jlong>(methodId);

  callbacksAllowed = false;
  jni->CallStaticVoidMethod(
      gdata->stoicJvmtiVmClass,
      gdata->nativeCallbackOnMethodEntry,
      methodIdAsLong,
      location,
      count);
  callbacksAllowed = true;
}

static jobject
Box(JNIEnv* jni, char type, jvalue value) {
  switch (type) {
    case 'Z': return jni->NewObject(gdata->booleanClass, gdata->booleanCtor, value.z);
    case 'B': return jni->NewObject(gdata->byteClass, gdata->byteCtor, value.b);
    case 'C': return jni->NewObject(gdata->characterClass, gdata->characterCtor, value.c);
    case 'S': return jni->NewObject(gdata->shortClass, gdata->shortCtor, value.s);
    case 'I': return jni->NewObject(gdata->integerClass, gdata->integerCtor, value.i);
    case 'J': return jni->NewObject(gdata->longClass, gdata->longCtor, value.j);
    case 'F': return jni->NewObject(gdata->floatClass, gdata->floatCtor, value.f);
    case 'D': return jni->NewObject(gdata->doubleClass, gdata->doubleCtor, value.d);

    case 'L':
    case '[':
      // NewLocalRef so we can clean it up, just like the others
      return jni->NewLocalRef(value.l);

    case 'V': return nullptr;

    default:
      __android_log_print(ANDROID_LOG_ERROR, "stoic", "unhandled return type: %c\n", type);
      return NULL;
  }
}

static void JNICALL
CbMethodExit(
    jvmtiEnv* jvmti,
    JNIEnv* jni,
    jthread thread,
    jmethodID methodId,
    jboolean was_popped_by_exception,
    jvalue return_value) {
  if (!callbacksAllowed) {
    return;
  }

  jint count = -1;
  CHECK_JVMTI(jvmti->GetFrameCount(thread, &count));

  // Note: The methodId parameter tells us which method was exited, but this may not
  // match the top stack frame (frame 0) when inspected via GetFrameLocation.
  // This occurs for native methods, especially intrinsics like System.arraycopy:
  // - JVMTI fires MethodExit for the native method
  // - But GetFrameLocation returns the calling Java method that invoked it
  // - Native methods may not appear as distinct stack frames, particularly when
  //   inlined/intrinsified by the JVM
  // We trust the methodId parameter from JVMTI rather than attempting to verify it
  // against the stack, as the stack may not reflect native method calls as separate frames.
  jmethodID frameMethodId = nullptr;
  jlocation location = -1;
  CHECK_JVMTI(jvmti->GetFrameLocation(thread, 0, &frameMethodId, &location));
  jlong methodIdAsLong = reinterpret_cast<jlong>(methodId);

  char* signature = NULL;
  CHECK_JVMTI(jvmti->GetMethodName(methodId, NULL, &signature, NULL));
  char* closingParen = strchr(signature, ')');
  CHECK(closingParen != NULL);
  // The return type is the first character after the ')' - for objects this will be L
  char returnType = closingParen[1];
  CHECK_JVMTI(jvmti->Deallocate((unsigned char*) signature));

  ScopedLocalRef<jobject> box(jni, Box(jni, returnType, return_value));

  // TODO: surface return_value (it's complicated because its a union)
  callbacksAllowed = false;
  jni->CallStaticVoidMethod(
      gdata->stoicJvmtiVmClass,
      gdata->nativeCallbackOnMethodExit,
      methodIdAsLong,
      location,
      count,
      box.get(),
      was_popped_by_exception);
  callbacksAllowed = true;
}

static void AgentMain(jvmtiEnv* jvmti, JNIEnv* jni, [[maybe_unused]] void* arg) {
  LOG(DEBUG) << "Running AgentMain";
  // store jvmti in a global data
  gdata = (GlobalAgentData*) calloc(1, sizeof(GlobalAgentData));

  gdata->jvmti = jvmti;
  LOG(DEBUG) << "jvmti stored";

  // Options contains the stoic dir
  std::string stoicDir = GetAgentInfo(jvmti)->options;
  LOG(DEBUG) << "Found stoicDir: " << stoicDir.c_str();


  // In order to setup the ClassLoader correctly, we need to chain it to the
  // Application ClassLoader. Otherwise we might end up with duplicate classes
  // (and weird class casting problems). We find the application class loader
  // via Looper.getMainLooper().getThread().getContextClassLoader(), which is
  // considerably more verbose to express via JNI.

  LOG(DEBUG) << "Looking for Looper";
  ScopedLocalRef<jclass> clsLooper(jni, jni->FindClass("android/os/Looper"));
  CHECK(clsLooper.get() != nullptr);
  LOG(DEBUG) << "Found Looper.class";

  jmethodID mthGetMainLooper = jni->GetStaticMethodID(clsLooper.get(), "getMainLooper", "()Landroid/os/Looper;");
  CHECK(mthGetMainLooper != nullptr);
  ScopedLocalRef<jobject> mainLooper(jni, jni->CallStaticObjectMethod(clsLooper.get(), mthGetMainLooper));
  CHECK(mainLooper.get() != nullptr);

  jmethodID mthGetThread = jni->GetMethodID(clsLooper.get(), "getThread", "()Ljava/lang/Thread;");
  CHECK(mthGetThread != nullptr);
  ScopedLocalRef<jobject> mainThread(jni, jni->CallObjectMethod(mainLooper.get(), mthGetThread));

  ScopedLocalRef<jclass> clsThread(jni, jni->FindClass("java/lang/Thread"));
  CHECK(clsThread.get() != nullptr);

  jmethodID mthGetContextClassLoader = jni->GetMethodID(clsThread.get(), "getContextClassLoader", "()Ljava/lang/ClassLoader;");
  CHECK(mthGetContextClassLoader != nullptr);

  ScopedLocalRef<jobject> originalClassLoader(jni, jni->CallObjectMethod(mainThread.get(), mthGetContextClassLoader));
  CHECK(originalClassLoader.get() != nullptr);
  LOG(DEBUG) << "Found originalClassLoader";


  //
  // Setup args that we need for our ClassLoader
  //

  std::string stoicApkChars = std::string(stoicDir.c_str()) + std::string("/stoic-jvmti-attach.apk");
  LOG(DEBUG) << "stoicApkChars: " << stoicApkChars.c_str();

  std::string dexOutputDirChars = std::string(stoicDir.c_str()) + std::string("/dexout");
  LOG(DEBUG) << "dexOutputDirChars: " << dexOutputDirChars.c_str();

  ScopedLocalRef<jstring> stoicApkString(jni, jni->NewStringUTF(stoicApkChars.c_str()));
  CHECK(stoicApkString.get() != nullptr);

  ScopedLocalRef<jstring> dexOutputDirString(jni, jni->NewStringUTF(dexOutputDirChars.c_str()));
  CHECK(dexOutputDirString.get() != nullptr);


  //
  // Construct a new ClassLoader for stoic-jvmti-attach.apk
  //

  ScopedLocalRef<jclass> klass_DexClassLoader(jni, jni->FindClass("dalvik/system/DexClassLoader"));
  CHECK(klass_DexClassLoader.get() != nullptr);
  LOG(DEBUG) << "Found DexClassLoader";

  jmethodID method_DexClassLoader_ctor = jni->GetMethodID(
      klass_DexClassLoader.get(),
      "<init>",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/ClassLoader;)V");
  CHECK(method_DexClassLoader_ctor != nullptr);

  ScopedLocalRef<jobject> dexClassLoader(jni, jni->NewObject(
      klass_DexClassLoader.get(),
      method_DexClassLoader_ctor,
      stoicApkString.get(),
      dexOutputDirString.get(),
      nullptr,
      originalClassLoader.get()));
  CHECK(dexClassLoader.get() != nullptr);
  LOG(DEBUG) << "Constructed dexClassLoader";


  //
  // RegisterNatives (to connect Stoic APIs with their JNI implementations)
  //

  ScopedLocalRef<jclass> klass_ClassLoader(jni, jni->FindClass("java/lang/ClassLoader"));
  CHECK(klass_ClassLoader.get() != nullptr);
  LOG(DEBUG) << "Found ClassLoader";

  jmethodID method_ClassLoader_loadClass = jni->GetMethodID(klass_ClassLoader.get(), "loadClass", "(Ljava/lang/String;)Ljava/lang/Class;");
  CHECK(method_ClassLoader_loadClass != nullptr);
  LOG(DEBUG) << "Found loadClass method";

  {
    ScopedLocalRef<jstring> stoicJvmtiVmClassName(jni, jni->NewStringUTF("com.squareup.stoic.jvmti.VirtualMachine"));
    CHECK(stoicJvmtiVmClassName.get() != nullptr);

    ScopedLocalRef<jclass> klass_stoicJvmtiVm(jni, (jclass) jni->CallObjectMethod(dexClassLoader.get(), method_ClassLoader_loadClass, stoicJvmtiVmClassName.get()));
    CHECK(klass_stoicJvmtiVm.get() != nullptr);
    LOG(DEBUG) << "Found stoic.jvmti.VirtualMachine class";
    gdata->stoicJvmtiVmClass = (jclass) jni->NewGlobalRef(klass_stoicJvmtiVm.get());
  }

  // JvmtiMethod stuff
  {
    ScopedLocalRef<jstring> stoicJvmtiMethodName(jni, jni->NewStringUTF("com.squareup.stoic.jvmti.JvmtiMethod"));
    CHECK(stoicJvmtiMethodName.get() != nullptr);

    ScopedLocalRef<jclass> klass_stoicJvmtiMethod(jni, (jclass) jni->CallObjectMethod(dexClassLoader.get(), method_ClassLoader_loadClass, stoicJvmtiMethodName.get()));
    CHECK(klass_stoicJvmtiMethod.get() != nullptr);
    gdata->stoicJvmtiMethodClass = (jclass) jni->NewGlobalRef(klass_stoicJvmtiMethod.get());

    gdata->stoicJvmtiMethodCtor = jni->GetMethodID(gdata->stoicJvmtiMethodClass, "<init>", "(J)V");
    CHECK(gdata->stoicJvmtiMethodCtor != NULL);

    gdata->stoicJvmtiMethodMethodId = jni->GetFieldID(gdata->stoicJvmtiMethodClass, "methodId", "J");
    CHECK(gdata->stoicJvmtiMethodMethodId != NULL);

    gdata->stoicJvmtiMethodPrivateClazz = jni->GetFieldID(gdata->stoicJvmtiMethodClass, "privateClazz", "Ljava/lang/Class;");
    CHECK(gdata->stoicJvmtiMethodPrivateClazz != NULL);

    gdata->stoicJvmtiMethodPrivateName = jni->GetFieldID(gdata->stoicJvmtiMethodClass, "privateName", "Ljava/lang/String;");
    CHECK(gdata->stoicJvmtiMethodPrivateName != NULL);

    gdata->stoicJvmtiMethodPrivateSignature = jni->GetFieldID(gdata->stoicJvmtiMethodClass, "privateSignature", "Ljava/lang/String;");
    CHECK(gdata->stoicJvmtiMethodPrivateSignature != NULL);

    gdata->stoicJvmtiMethodPrivateGeneric = jni->GetFieldID(gdata->stoicJvmtiMethodClass, "privateGeneric", "Ljava/lang/String;");
    CHECK(gdata->stoicJvmtiMethodPrivateGeneric != NULL);

    gdata->stoicJvmtiMethodPrivateStartLocation = jni->GetFieldID(gdata->stoicJvmtiMethodClass, "privateStartLocation", "J");
    CHECK(gdata->stoicJvmtiMethodPrivateStartLocation != NULL);

    gdata->stoicJvmtiMethodPrivateEndLocation = jni->GetFieldID(gdata->stoicJvmtiMethodClass, "privateEndLocation", "J");
    CHECK(gdata->stoicJvmtiMethodPrivateEndLocation != NULL);

    gdata->stoicJvmtiMethodPrivateArgsSize = jni->GetFieldID(gdata->stoicJvmtiMethodClass, "privateArgsSize", "I");
    CHECK(gdata->stoicJvmtiMethodPrivateArgsSize != NULL);

    gdata->stoicJvmtiMethodPrivateMaxLocals = jni->GetFieldID(gdata->stoicJvmtiMethodClass, "privateMaxLocals", "I");
    CHECK(gdata->stoicJvmtiMethodPrivateMaxLocals != NULL);

    gdata->stoicJvmtiMethodPrivateModifiers = jni->GetFieldID(gdata->stoicJvmtiMethodClass, "privateModifiers", "I");
    CHECK(gdata->stoicJvmtiMethodPrivateModifiers != NULL);
  }

  // JvmtiField stuff
  {
    ScopedLocalRef<jstring> stoicJvmtiFieldName(jni, jni->NewStringUTF("com.squareup.stoic.jvmti.JvmtiField"));
    CHECK(stoicJvmtiFieldName.get() != nullptr);

    ScopedLocalRef<jclass> klass_stoicJvmtiField(jni, (jclass) jni->CallObjectMethod(dexClassLoader.get(), method_ClassLoader_loadClass, stoicJvmtiFieldName.get()));
    CHECK(klass_stoicJvmtiField.get() != nullptr);
    gdata->stoicJvmtiFieldClass = (jclass) jni->NewGlobalRef(klass_stoicJvmtiField.get());

    gdata->stoicJvmtiFieldCtor = jni->GetMethodID(gdata->stoicJvmtiFieldClass, "<init>", "(Ljava/lang/Class;J)V");
    CHECK(gdata->stoicJvmtiFieldCtor != NULL);

    gdata->stoicJvmtiFieldClazz = jni->GetFieldID(gdata->stoicJvmtiFieldClass, "clazz", "Ljava/lang/Class;");
    CHECK(gdata->stoicJvmtiFieldClazz != NULL);

    gdata->stoicJvmtiFieldFieldId = jni->GetFieldID(gdata->stoicJvmtiFieldClass, "fieldId", "J");
    CHECK(gdata->stoicJvmtiFieldFieldId != NULL);

    gdata->stoicJvmtiFieldPrivateName = jni->GetFieldID(gdata->stoicJvmtiFieldClass, "privateName", "Ljava/lang/String;");
    CHECK(gdata->stoicJvmtiFieldPrivateName != NULL);

    gdata->stoicJvmtiFieldPrivateSignature = jni->GetFieldID(gdata->stoicJvmtiFieldClass, "privateSignature", "Ljava/lang/String;");
    CHECK(gdata->stoicJvmtiFieldPrivateSignature != NULL);

    gdata->stoicJvmtiFieldPrivateGeneric = jni->GetFieldID(gdata->stoicJvmtiFieldClass, "privateGeneric", "Ljava/lang/String;");
    CHECK(gdata->stoicJvmtiFieldPrivateGeneric != NULL);

    gdata->stoicJvmtiFieldPrivateModifiers = jni->GetFieldID(gdata->stoicJvmtiFieldClass, "privateModifiers", "I");
    CHECK(gdata->stoicJvmtiFieldPrivateModifiers != NULL);
  }

  // Boxing stuff
  {
    // TODO: this leaks local refs
    gdata->booleanClass = (jclass) jni->NewGlobalRef(jni->FindClass("java/lang/Boolean"));
    gdata->byteClass = (jclass) jni->NewGlobalRef(jni->FindClass("java/lang/Byte"));
    gdata->characterClass = (jclass) jni->NewGlobalRef(jni->FindClass("java/lang/Character"));
    gdata->shortClass = (jclass) jni->NewGlobalRef(jni->FindClass("java/lang/Short"));
    gdata->integerClass = (jclass) jni->NewGlobalRef(jni->FindClass("java/lang/Integer"));
    gdata->longClass = (jclass) jni->NewGlobalRef(jni->FindClass("java/lang/Long"));
    gdata->floatClass = (jclass) jni->NewGlobalRef(jni->FindClass("java/lang/Float"));
    gdata->doubleClass = (jclass) jni->NewGlobalRef(jni->FindClass("java/lang/Double"));

    gdata->booleanCtor = jni->GetMethodID(gdata->booleanClass, "<init>", "(Z)V");
    gdata->byteCtor = jni->GetMethodID(gdata->byteClass, "<init>", "(B)V");
    gdata->characterCtor = jni->GetMethodID(gdata->characterClass, "<init>", "(C)V");
    gdata->shortCtor = jni->GetMethodID(gdata->shortClass, "<init>", "(S)V");
    gdata->integerCtor = jni->GetMethodID(gdata->integerClass, "<init>", "(I)V");
    gdata->longCtor = jni->GetMethodID(gdata->longClass, "<init>", "(J)V");
    gdata->floatCtor = jni->GetMethodID(gdata->floatClass, "<init>", "(F)V");
    gdata->doubleCtor = jni->GetMethodID(gdata->doubleClass, "<init>", "(D)V");
  }

  gdata->nativeCallbackOnBreakpoint = jni->GetStaticMethodID(gdata->stoicJvmtiVmClass, "nativeCallbackOnBreakpoint", "(JJI)V");
  gdata->nativeCallbackOnMethodEntry = jni->GetStaticMethodID(gdata->stoicJvmtiVmClass, "nativeCallbackOnMethodEntry", "(JJI)V");
  gdata->nativeCallbackOnMethodExit = jni->GetStaticMethodID(gdata->stoicJvmtiVmClass, "nativeCallbackOnMethodExit", "(JJILjava/lang/Object;Z)V");

  JNINativeMethod methods[] = {
    {"nativeInstances",                 "(Ljava/lang/Class;Z)[Ljava/lang/Object;",                      (void *)&Jvmti_VirtualMachine_nativeInstances},
    {"nativeSubclasses",                "(Ljava/lang/Class;)[Ljava/lang/Class;",                        (void *)&Jvmti_VirtualMachine_nativeSubclasses},
    {"nativeGetMethodId",               "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)J",     (void *)&Jvmti_VirtualMachine_nativeGetMethodId},
    {"nativeSetBreakpoint",             "(JJ)V",                                                        (void *)&Jvmti_VirtualMachine_nativeSetBreakpoint},
    {"nativeClearBreakpoint",           "(JJ)V",                                                        (void *)&Jvmti_VirtualMachine_nativeClearBreakpoint},
    {"nativeGetMethodCoreMetadata",     "(Lcom/squareup/stoic/jvmti/JvmtiMethod;)V",                    (void *)&Jvmti_VirtualMachine_nativeGetMethodCoreMetadata},
    {"nativeGetFieldCoreMetadata",      "(Lcom/squareup/stoic/jvmti/JvmtiField;)V",                     (void *)&Jvmti_VirtualMachine_nativeGetFieldCoreMetadata},
    {"nativeGetLocalVariables",         "(J)[Lcom/squareup/stoic/jvmti/LocalVariable;",                 (void *)&Jvmti_VirtualMachine_nativeGetLocalVariables},
    {"nativeGetLocalObject",            "(Ljava/lang/Thread;II)Ljava/lang/Object;",                     (void *)&Jvmti_VirtualMachine_nativeGetLocalObject},
    {"nativeGetLocalInt",               "(Ljava/lang/Thread;II)I",                                      (void *)&Jvmti_VirtualMachine_nativeGetLocalInt},
    {"nativeGetLocalLong",              "(Ljava/lang/Thread;II)J",                                      (void *)&Jvmti_VirtualMachine_nativeGetLocalLong},
    {"nativeGetLocalFloat",             "(Ljava/lang/Thread;II)F",                                      (void *)&Jvmti_VirtualMachine_nativeGetLocalFloat},
    {"nativeGetLocalDouble",            "(Ljava/lang/Thread;II)D",                                      (void *)&Jvmti_VirtualMachine_nativeGetLocalDouble},
    {"nativeGetClassMethods",           "(Ljava/lang/Class;)[Lcom/squareup/stoic/jvmti/JvmtiMethod;",   (void *)&Jvmti_VirtualMachine_nativeGetClassMethods},
    {"nativeGetClassFields",            "(Ljava/lang/Class;)[Lcom/squareup/stoic/jvmti/JvmtiField;",    (void *)&Jvmti_VirtualMachine_nativeGetClassFields},
    {"nativeToReflectedField",          "(Ljava/lang/Class;JZ)Ljava/lang/reflect/Field;",               (void *)&Jvmti_VirtualMachine_nativeToReflectedField},
    {"nativeToReflectedMethod",         "(Ljava/lang/Class;JZ)Ljava/lang/Object;",                      (void *)&Jvmti_VirtualMachine_nativeToReflectedMethod},
    {"nativeFromReflectedMethod",       "(Ljava/lang/reflect/Method;)J",                                (void *)&Jvmti_VirtualMachine_nativeFromReflectedMethod},
    {"nativeGetClassSignature",         "(Ljava/lang/Class;)Ljava/lang/String;",                        (void *)&Jvmti_VirtualMachine_nativeGetClassSignature},
    {"nativeMethodEntryCallbacks",      "(Ljava/lang/Thread;Z)V",                                       (void *)&Jvmti_VirtualMachine_nativeMethodEntryCallbacks},
    {"nativeMethodExitCallbacks",       "(Ljava/lang/Thread;Z)V",                                       (void *)&Jvmti_VirtualMachine_nativeMethodExitCallbacks},
  };

  CHECK(jni->RegisterNatives(gdata->stoicJvmtiVmClass, methods, sizeof(methods) / sizeof(methods[0])) == JNI_OK);


  //
  // Call AndroidServerJarKt.main to start the Android server
  //

  ScopedLocalRef<jstring> androidServerMainClassName(jni, jni->NewStringUTF(
      "com.squareup.stoic.target.runtime.AndroidServerJarKt"));
  CHECK(androidServerMainClassName.get() != nullptr);

  ScopedLocalRef<jclass> klass_AndroidServerJarKt(jni, (jclass) jni->CallObjectMethod(
      dexClassLoader.get(),
      method_ClassLoader_loadClass,
      androidServerMainClassName.get()));
  CHECK(klass_AndroidServerJarKt.get() != nullptr);
  LOG(DEBUG) << "Found AndroidServerJarKt class";

  ScopedLocalRef<jclass> klass_Method(jni, jni->FindClass("java/lang/reflect/Method"));
  CHECK(klass_Method.get() != nullptr);
  LOG(DEBUG) << "Found Method";

  jmethodID method_AndroidServerJarKt_main = jni->GetStaticMethodID(
      klass_AndroidServerJarKt.get(),
      "main",
      "(Ljava/lang/String;)V");
  CHECK(method_AndroidServerJarKt_main != nullptr);
  LOG(DEBUG) << "Found AndroidServerJarKt.main method";

  ScopedLocalRef<jstring> stoicDirString(jni, jni->NewStringUTF(stoicDir.c_str()));
  CHECK(stoicDirString != nullptr);
  LOG(DEBUG) << "Constructed stoicDirString";

  jni->CallStaticVoidMethod(klass_AndroidServerJarKt.get(), method_AndroidServerJarKt_main, stoicDirString.get());


  //
  // Done
  //

  LOG(DEBUG) << "Returned from main";
}

static void CbVmInit(jvmtiEnv* jvmti, JNIEnv* env, [[maybe_unused]] jthread thr) {
  LOG(DEBUG) << "Running CbVmInit";

  // Create a Thread object.
  ScopedLocalRef<jobject> thread_name(env, env->NewStringUTF("Agent Thread"));
  if (thread_name.get() == nullptr) {
    env->ExceptionDescribe();
    env->ExceptionClear();
    return;
  }
  ScopedLocalRef<jclass> thread_klass(env, env->FindClass("java/lang/Thread"));
  if (thread_klass.get() == nullptr) {
    env->ExceptionDescribe();
    env->ExceptionClear();
    return;
  }
  ScopedLocalRef<jobject> thread(env, env->AllocObject(thread_klass.get()));
  if (thread.get() == nullptr) {
    env->ExceptionDescribe();
    env->ExceptionClear();
    return;
  }

  env->CallNonvirtualVoidMethod(
      thread.get(),
      thread_klass.get(),
      env->GetMethodID(thread_klass.get(), "<init>", "(Ljava/lang/String;)V"),
      thread_name.get());
  env->CallVoidMethod(thread.get(), env->GetMethodID(thread_klass.get(), "setPriority", "(I)V"), 1);
  env->CallVoidMethod(
      thread.get(), env->GetMethodID(thread_klass.get(), "setDaemon", "(Z)V"), JNI_TRUE);

  jvmti->RunAgentThread(thread.get(), AgentMain, nullptr, JVMTI_THREAD_MIN_PRIORITY);
}

const int kArtTiVersion = 0x70010200;

template <bool kIsOnLoad>
static jint AgentStart(JavaVM* vm, char* options, [[maybe_unused]] void* reserved) {
  jvmtiEnv* jvmti = nullptr;

  if (vm->GetEnv(reinterpret_cast<void**>(&jvmti), JVMTI_VERSION_1_2) != JNI_OK ||
      jvmti == nullptr) {

    // Retry with kArtTiVersion (for non-debuggable APKs on rooted devices)
    if (vm->GetEnv(reinterpret_cast<void**>(&jvmti), kArtTiVersion) != JNI_OK ||
        jvmti == nullptr) {
      __android_log_print(ANDROID_LOG_ERROR, "stoic", "unable to obtain JVMTI env (tried 0x%x)\n", kArtTiVersion);
      return JNI_ERR;
    } else {
      __android_log_print(ANDROID_LOG_ERROR, "stoic", "successfully obtained JVMTI env (via 0x%x)\n", kArtTiVersion);
    }
  }
  std::string sopts(options);
  AgentInfo* ai = new AgentInfo;
  ai->options = sopts;

  // Request can_tag_objects (required for heap iteration)
  jvmtiCapabilities tagCap = {.can_tag_objects = JNI_TRUE};
  CHECK_JVMTI(jvmti->AddCapabilities(&tagCap));

  // Try to add breakpoint capability - not available on API 26
  jvmtiCapabilities breakpointCap = {.can_generate_breakpoint_events = JNI_TRUE};
  int breakpointResult = jvmti->AddCapabilities(&breakpointCap);
  if (breakpointResult != JVMTI_ERROR_NONE) {
    __android_log_print(
        ANDROID_LOG_WARN,
        "stoic",
        "Breakpoint events not available (this is expected on API 26)\n"
    );
  } else {
    __android_log_print(ANDROID_LOG_INFO, "stoic", "Breakpoint events are available\n");
  }

  // Try to add method entry/exit capabilities - these aren't available on API 26-29
  jvmtiCapabilities entryExitCaps = {
    .can_generate_method_entry_events = JNI_TRUE,
    .can_generate_method_exit_events = JNI_TRUE,
  };
  int entryExitCapsResult = jvmti->AddCapabilities(&entryExitCaps);
  if (entryExitCapsResult != JVMTI_ERROR_NONE) {
    __android_log_print(
        ANDROID_LOG_WARN,
        "stoic",
        "Method entry/exit capabilities not available (this is expected on API 26-29)\n"
    );
  } else {
    __android_log_print(
        ANDROID_LOG_INFO,
        "stoic",
        "Method entry/exit capabilities are available\n"
    );
  }

//{
//  // Entry/exit capabilities must be added at load time, but they aren't
//  // available on API 29 and below

//  jvmtiCapabilities entryExitCaps = {
//    .can_generate_method_entry_events = JNI_TRUE,
//    .can_generate_method_exit_events = JNI_TRUE,
//  };

//  int entryExitCapsResult = jvmti->AddCapabilities(&entryExitCaps);
//  if (entryExitCapsResult != JVMTI_ERROR_NONE) {
//    __android_log_print(
//        ANDROID_LOG_WARN,
//        "stoic",
//        "Failed to add method entry/exit capabilities (this is expected on API 29 and below)\n"
//    );
//  } else {
//    __android_log_print(
//        ANDROID_LOG_WARN,
//        "stoic",
//        "Method entry/exit capabilities added successfully\n"
//    );
//  }
//}

  jvmtiEventCallbacks cb{
    .VMInit = CbVmInit,
    .Breakpoint = CbBreakpoint,
    .MethodEntry = CbMethodEntry,
    .MethodExit = CbMethodExit,
  };
  CHECK_JVMTI(jvmti->SetEventCallbacks(&cb, sizeof(cb)));
  CHECK_JVMTI(jvmti->SetEnvironmentLocalStorage(reinterpret_cast<void*>(ai)));

  // Only enable breakpoint events if we have the capability
  if (breakpointResult == JVMTI_ERROR_NONE) {
    CHECK_JVMTI(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr /* all threads */));
  }

  if (kIsOnLoad) {
    LOG(DEBUG) << "kIsOnLoad";
    jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);
  } else {
    LOG(DEBUG) << "!kIsOnLoad";
    JNIEnv* jni = nullptr;
    vm->GetEnv(reinterpret_cast<void**>(&jni), JNI_VERSION_1_2);
    jthread thr;
    jvmti->GetCurrentThread(&thr);
    CbVmInit(jvmti, jni, thr);
  }


  // TODO: These LOG statements don't work on older Android devices
  LOG(DEBUG) << "Succeeded!";

  return JNI_OK;
}

// Late attachment (e.g. 'am attach-agent').
extern "C" JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM* vm, char* options, void* reserved) {
  __android_log_print(ANDROID_LOG_INFO, "stoic", "Agent_OnAttach\n");
  return AgentStart<false>(vm, options, reserved);
}

// Early attachment
extern "C" JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* jvm, char* options, void* reserved) {
  __android_log_print(ANDROID_LOG_INFO, "stoic", "Agent_OnLoad\n");
  return AgentStart<true>(jvm, options, reserved);
}

```

`native/stoic_logging.h`:

```h
#pragma once

#include <android/log.h>
#include <sstream>
#include <cstdlib>

// Minimal logging support - replaces android-base/logging.h
namespace stoic {
namespace logging {

class LogMessage {
 public:
  LogMessage(const char* file, int line, int priority)
      : file_(file), line_(line), priority_(priority) {}

  ~LogMessage() {
    __android_log_print(priority_, "stoic", "%s:%d: %s",
                       file_, line_, stream_.str().c_str());
    if (priority_ == ANDROID_LOG_FATAL) {
      abort();
    }
  }

  std::ostream& stream() { return stream_; }

 private:
  const char* file_;
  int line_;
  int priority_;
  std::ostringstream stream_;
};

}  // namespace logging
}  // namespace stoic

#define LOG(severity) \
  ::stoic::logging::LogMessage(__FILE__, __LINE__, ANDROID_LOG_##severity).stream()

// CHECK macros
#define CHECK(condition) \
  if (!(condition)) \
    LOG(FATAL) << "Check failed: " #condition " "

#define CHECK_EQ(a, b) \
  if ((a) != (b)) \
    LOG(FATAL) << "Check failed: " #a " == " #b \
               << " (" #a "=" << (a) << ", " #b "=" << (b) << ") "

#define CHECK_NE(a, b) \
  if ((a) == (b)) \
    LOG(FATAL) << "Check failed: " #a " != " #b " "

#define CHECK_LT(a, b) \
  if ((a) >= (b)) \
    LOG(FATAL) << "Check failed: " #a " < " #b " "

#define CHECK_LE(a, b) \
  if ((a) > (b)) \
    LOG(FATAL) << "Check failed: " #a " <= " #b " "

#define CHECK_GT(a, b) \
  if ((a) <= (b)) \
    LOG(FATAL) << "Check failed: " #a " > " #b " "

#define CHECK_GE(a, b) \
  if ((a) < (b)) \
    LOG(FATAL) << "Check failed: " #a " >= " #b " "

```

`prebuilt/README.md`:

```md
This directory contains things that are copied to the release verbatim.
The sync subdirectory is part of this. It's the prebuilt stuff that get sync'd
to the device.

```

`prebuilt/STOIC_VERSION`:

```
0.9.2-SNAPSHOT

```

`prebuilt/bin/jvm/stoic`:

```
#!/bin/sh

# This script gets copied in the release bin/jvm directory. We can find
# stoic-host-main.jar relative to that directory.
script_dir="$(realpath "$(dirname "$(readlink -f "$0")")")"
java -jar "$script_dir/../../jar/stoic-host-main.jar" "$@"

```

`prebuilt/script/adb-pick`:

```
#!/bin/bash
#set -x
set -euo pipefail

if [ ! -t 0 ]; then
    >&2 echo "stdin is not a terminal"
    return 1
fi

devices=()
while IFS= read -r line; do
    devices+=("$line")
done < <(adb devices | grep -w "device" | cut -f 1)

# Bash indexing starts at 0
for ((i=0; i<${#devices[@]}; i++)); do
    >&2 echo "$((i+1)). ${devices[$i]}"
done

read -r -p "Enter the number of the device you want to use: " choice

if [[ $choice -ge 1 && $choice -le ${#devices[@]} ]]; then
    choice="$((choice - 1))"

    # Output
    echo "${devices[$choice]}"
else
    >&2 echo "Invalid choice."
    return 1
fi

```

`prebuilt/script/android_serial.sh`:

```sh
# This file is designed to be sourced

if [ -n "${ZSH_VERSION:-}" ]; then
    # For Zsh
    _android_serial_script_dir="$(realpath "$(dirname "${(%):-%N}")")"
elif [ -n "${BASH_VERSION:-}" ]; then
    # For Bash
    _android_serial_script_dir="$(realpath "$(dirname "${BASH_SOURCE[0]}")")"
else
    _android_serial_script_dir="-unsupported-shell-$SHELL-"
fi

_adb_pick() {
    # Declare and assign separately to avoid masking return values
    ANDROID_SERIAL="$("$_android_serial_script_dir/adb-pick")"
    export ANDROID_SERIAL
}

_android_serial() {
    if [ -n "${ANDROID_SERIAL:-}" ]; then
        return 0
    fi

    # Check the number of connected devices
    local device_count
    if ! device_count=$(adb devices | grep -cw "device"); then
        >&2 echo "No devices connected. Please connect a device and try again."
        return 1
    elif [ "$device_count" -eq 1 ]; then
        # Set ANDROID_SERIAL to the single connected device
        # Declare and assign separately to avoid masking return values
        ANDROID_SERIAL=$(adb devices | grep -w "device" | cut -f 1)
        export ANDROID_SERIAL
    else
        # Multiple devices found, prompt the user to pick one
        >&2 echo "Multiple devices found. Please pick one:"
        _adb_pick
    fi
}

alias android-serial=_android_serial
alias adb-pick=_adb_pick

```

`prebuilt/sync/bin/stoic-attach`:

```
#!/system/bin/sh
set -eux

# API 26 (Android 8.0) doesn't have readlink -f, so we use a more compatible approach
script_path="$0"
# Try readlink -f first (API 29+), fall back to just using $0
if command -v readlink >/dev/null 2>&1; then
  script_path="$(readlink -f "$0" 2>/dev/null || echo "$0")"
fi
script_dir="$(cd "$(dirname "$script_path")" && pwd)"
stoic_device_sync_dir="$(cd "$script_dir/.." && pwd)"
cd "$script_dir"

run_as_compat() {
  case "$attach_option" in
    jvmti)
      run-as "$@"
      ;;
    jvmti_root)
      "$script_dir/su-run-as" "$@"
      ;;
    sdk)
      run-as "$@"
      ;;
    *)
      >&2 echo "Invalid attach option '$attach_option'"
      exit 1
      ;;
  esac
}

attach_agent_compat() {
  case "$attach_option" in
    jvmti)
      am attach-agent "$@"
      ;;
    jvmti_root)
      su 0 am attach-agent "$@"
      ;;
    *)
      >&2 echo "Invalid attach option '$attach_option'"
      exit 1
      ;;
  esac
}

monkey_package() {
  monkey --pct-syskeys 0 -p "$pkg" 1 >/dev/null || true 2>&1
}

start_package() {
  monkey_package
  for i in $(seq 1 5); do
    for j in $(seq 1 500); do
      if pkg_pid="$(pidof "$pkg")"; then
        return 0
      fi
    done
    >&2 "$pkg is slow to start (maybe it's stuck) - retrying monkey"
    monkey_package
  done

  >&2 "Failed to start $pkg"
  return 1
}

resolve_package_pid() {
  case "$start_option" in
    restart)
      am force-stop "$pkg"
      start_package
      ;;
    do_not_start)
      pkg_pid="$(pidof "$pkg")"
      ;;
    start_if_needed)
      if ! pkg_pid="$(pidof "$pkg")"; then
        start_package
      fi
      ;;
    *)
      echo "Invalid start option: '$start_option'" >&2
      return 1
      ;;
  esac
}

cross_uid_cp() {
  perms="$1"
  src="$2"
  dst="$3"
  cat "$src" | run_as_compat "$pkg" sh -c "cat > $dst && chmod $perms $dst"
}

target_process_exited=0
logcat_pid=""
selinux_denials_pgid_file=""
cleanup_attach() {
  if [ -n "${logcat_pid:-}" ]; then
    if [ "$target_process_exited" = "1" ]; then
      # We want to make sure we print all the information we need to debug why
      # the target process exited, so we give the logcat process a chance to
      # finish piping everything before we kill it
      sleep 1
    fi

    kill "$logcat_pid" || true
  fi
  if [ -n "${selinux_denials_pgid_file:-}" ]; then
    run_as_compat "$pkg" sh -c "kill -TERM -\$(cat $selinux_denials_pgid_file)" || true
  fi
  >&2 echo "Finished cleanup_attach\n$attach_error_summary"
}

attach_jvmti() {
  trap cleanup_attach EXIT

  pkg_dir="$(run_as_compat "$pkg" printenv HOME)"
  pkg_stoic_dir="$pkg_dir/stoic"
  pkg_so="$pkg_stoic_dir/stoic-jvmti-agent.so"
  pkg_server_apk="$pkg_stoic_dir/stoic-jvmti-attach.apk"
  pkg_options_json="$pkg_stoic_dir/options.json"
  attach_error_summary=""

  # Detect device architecture and select appropriate .so file
  device_arch="$(getprop ro.product.cpu.abi)"
  case "$device_arch" in
    arm64-v8a)
      stoic_so_path="$stoic_device_sync_dir/stoic/arm64-v8a/stoic-jvmti-agent.so"
      ;;
    x86_64)
      stoic_so_path="$stoic_device_sync_dir/stoic/x86_64/stoic-jvmti-agent.so"
      ;;
    *)
      >&2 echo "Unsupported architecture: $device_arch"
      >&2 echo "Supported architectures: arm64-v8a, x86_64"
      exit 1
      ;;
  esac
  >&2 echo "Using architecture: $device_arch"

  # TODO: Use a lock to ensure that multiple processes aren't attempting to bring
  # the server up simultaneously

  >&2 echo "cleaning $pkg_stoic_dir"
  if ! run_as_compat "$pkg" rm -rf "$pkg_stoic_dir"; then
    # In case there are leftover files from a previous attach using jvmti_root
    "$script_dir/su-run-as" "$pkg" rm -rf "$pkg_stoic_dir"
  fi

  run_as_compat "$pkg" mkdir "$pkg_stoic_dir"
  cross_uid_cp 444 "$stoic_so_path" "$pkg_so"
  cross_uid_cp 444 "$stoic_device_sync_dir/stoic/stoic-jvmti-attach.apk" "$pkg_server_apk"
  echo "{\"stoicProtocolVersion\":$stoic_protocol_version, \"attachedVia\":\"$attach_option\"}" | cross_uid_cp 444 - "$pkg_options_json"

  first_pid="$(pidof "$pkg" || true)"

  # Sets pkg_pid and restarts pkg if needed
  resolve_package_pid "$pkg"

  if [ "$pkg_pid" = "$first_pid" ]; then
    # Since pkg was already running, double-check /proc/pid/maps for stoic-jvmti-agent.so
    if run_as_compat "$pkg" cat /proc/$pkg_pid/maps | grep "stoic-jvmti-agent.so"; then
      >&2 echo "stoic already loaded - need to restart the process first"
      >&2 echo "consider:"
      >&2 echo "  stoic --restart ..."
      exit 1
    fi
  fi

  logcat -T 1 --pid "$pkg_pid" "stoic:v *:w" >&2 &
  logcat_pid=$!

  # setsid runs sh in a new session. This way we can kill the entire process group.
  # We echo the PID of the process group leader, and then read the first line
  # output and capture that as selinux_denials_pid
  # `--line-buffered` is needed because grep defaults to non-line-buffered mode
  # when stdout is not a tty.
  selinux_denials="$pkg_stoic_dir/selinux_denials"
  selinux_denials_pgid_file="$pkg_stoic_dir/selinux_denials_pgid"
  run_as_compat "$pkg" setsid sh -c "printf \"%s\n\" \$\$ > $selinux_denials_pgid_file && logcat -T 1 | grep --line-buffered -E \"avc: denied .*stoic.*permissive=0\" >$selinux_denials" &

  # Sometimes attach-agent complains that the process doesn't exist - maybe
  # because it was created to recently? Sleeping fixes it.
  attach_agent_compat "$pkg" "$pkg_so=$pkg_stoic_dir" || attach_agent_exit_code=$?
  if [ "${attach_agent_exit_code:-0}" -ne 0 ]; then
    >&2 echo "attach-agent exited with code=$attach_agent_exit_code"
    >&2 echo "Attach agent failed... sleeping 1 second and retrying..."
    sleep 1
    attach_agent_compat "$pkg" "$pkg_so=$pkg_stoic_dir"
  fi

  # Poll for server-up file or process exit
  >&2 echo "Waiting for server to come up..."
  start_time=$(date +%s)
  timeout=20
  while :; do
    # Check if server is up
    if run_as_compat "$pkg" sh -c "[ -f $pkg_stoic_dir/server-up ]"; then
      >&2 echo "Server is up!"
      exit 0
    fi

    # Check for SELinux denials
    if run_as_compat "$pkg" sh -c "[ -s $selinux_denials ]"; then
      attach_error_summary="SELinux problem detected - you may be able to work around it with \`adb shell su 0 setenforce 0\`"
      exit 1
    fi

    # Check if target process exited
    if ! ps -p "$pkg_pid" -o NAME= 2>/dev/null | grep -q "$pkg"; then
      target_process_exited=1
      attach_error_summary="Target process ($pkg_pid) exited"
      exit 1
    fi

    # Check for timeout
    current_time=$(date +%s)
    elapsed=$((current_time - start_time))
    if [ "$elapsed" -ge "$timeout" ]; then
      attach_error_summary="Timed out waiting for server to start"
      exit 1
    fi

    sleep 0.1
  done
}

attach_sdk() {
  # TODO: query receivers to verify there is one


  # If the app was just installed or manually stopped via 'am force-stop' then
  # we'll need to unstop it in order for the broadcast to work.
  # (unstop was added in Android 15, so this might fail)
  pm unstop "$pkg" || true

  first_pid="$(pidof "$pkg" || true)"

  # Sets pkg_pid and restarts pkg if needed
  resolve_package_pid "$pkg"

  am broadcast -a com.squareup.stoic.android.sdk.ACTION_UDS_LISTEN -p "$pkg"

  # TODO: wait for confirmation the socket is up
}

# The protocol version the server should expect
stoic_protocol_version="$1"

# The package we'll attach to
pkg="$2"

# One of restart/start_if_needed/do_not_start
start_option="$3"

# TODO: no longer used
debug_option="$4"

# One of jvmti/jvmti_root/sdk
attach_option="$5"

# Check if we need to install/update a demo app
demo_apk=""
case "$pkg" in
  com.squareup.stoic.demoapp.withoutsdk)
    demo_apk="$stoic_device_sync_dir/apk/stoic-demo-app-without-sdk-debug.apk"
    ;;
  com.squareup.stoic.demoapp.withsdk)
    demo_apk="$stoic_device_sync_dir/apk/stoic-demo-app-with-sdk-release.apk"
    ;;
esac

if [ -n "$demo_apk" ]; then
  # This is a demo app - check if it needs to be installed or updated
  apk_timestamp_file="$stoic_device_sync_dir/.installed_apk_timestamps/$pkg"
  apk_mtime=$(stat -c %Y "$demo_apk" 2>/dev/null || echo "0")

  needs_install=false
  if ! pm list packages "$pkg" | grep -x "package:$pkg"; then
    # Package not installed
    needs_install=true
  elif [ ! -f "$apk_timestamp_file" ]; then
    # No timestamp recorded - reinstall to be safe
    needs_install=true
  else
    # Check if APK is newer than what we installed
    installed_mtime=$(cat "$apk_timestamp_file")
    if [ "$apk_mtime" -gt "$installed_mtime" ]; then
      needs_install=true
    fi
  fi

  if [ "$needs_install" = "true" ]; then
    # Try to install with -r flag first - if that fails, uninstall and retry
    if ! pm install -r "$demo_apk" 2>&1; then
      # Fall-back to uninstall and retry (e.g. if signature changed)
      pm uninstall "$pkg"
      pm install "$demo_apk"
      mkdir -p "$(dirname "$apk_timestamp_file")"
      echo "$apk_mtime" > "$apk_timestamp_file"
    else
      # Install succeeded
      mkdir -p "$(dirname "$apk_timestamp_file")"
      echo "$apk_mtime" > "$apk_timestamp_file"
    fi
  fi
elif ! pm list packages "$pkg" | grep -x "package:$pkg"; then
  # Not a demo app and package not found
  attach_error_summary="$pkg not found"
  exit 1
fi

case "$attach_option" in
  jvmti)
    attach_jvmti
    ;;
  jvmti_root)
    # Exactly the same as jvmti, except that run-as-compat uses su-run-as
    # instead of run-as.
    attach_jvmti
    ;;
  sdk)
    attach_sdk
    ;;
  *)
    attach_error_summary="Invalid attach option '$attach_option'"
    exit 1
    ;;
esac

```

`prebuilt/sync/bin/su-run-as`:

```
#!/system/bin/sh

# Like run-as, but uses su so that it works even for non-debuggable packages

pkg="$1"
shift

if [ -z "$(which su)" ]; then
    exit 1
fi


# If run-as doesn't work we need to use some undocumented internals to parse
# out the uid and data_dir for a package
# See: 
# https://cs.android.com/android/platform/superproject/main/+/main:system/core/libpackagelistparser/packagelistparser.cpp
package_info="$(su 0 grep "^$pkg " /data/system/packages.list)"
if [ -z "$package_info" ]; then
    >&2 echo Package $pkg not found.
    exit 1
fi

uid="$(awk '{ print $2 }' <<< "$package_info")"
data_dir="$(awk '{ print $4 }' <<< "$package_info")"

# To mimic the behavior of run-as, we run export HOME and run the command from
# the data_dir
export HOME="$data_dir"

# There are different flavors of su on different devices. This works on userdebug builds.
# TODO: Compatibility with Magisk and TWRP

if [ $# == 0 ]; then
    # No command - enter interactive shell
    args=("$0" "sh")
else
    args=("$0" "$@")
fi
su "$uid" sh -c 'cd "$HOME" && "$@"' "${args[@]}"

```

`prebuilt/template/plugin-template/build.gradle.kts`:

```kts
plugins {
  alias(libs.plugins.shadow)
  alias(libs.plugins.android.application)
  alias(libs.plugins.kotlin.android)
}

repositories {
  google()
  mavenCentral()
}

android {
  namespace = "com.squareup.stoic.plugin"
  compileSdk = 35
  defaultConfig {
    applicationId = "com.squareup.stoic.plugin"
    minSdk = 26
    targetSdk = 35
    versionCode = 1
    versionName = "1.0.0"
  }
  compileOptions {
    val jvmTarget = JavaVersion.VERSION_17
    sourceCompatibility = jvmTarget
    targetCompatibility = jvmTarget
  }
}

dependencies {
  val stoicPluginSdk = "${rootProject.projectDir}/../../sdk/stoic-plugin-sdk.jar"
  compileOnly(files(stoicPluginSdk))
  implementation(kotlin("stdlib"))
}

```

`prebuilt/template/plugin-template/gradle/libs.versions.toml`:

```toml
[versions]
kotlin = "2.1.21"
androidCompileSdk = "35"
androidGradle = "8.9.0"
shadow = "8.3.6"

[plugins]
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
android-application = { id = "com.android.application", version.ref = "androidGradle" }
kotlin-jvm = { id = "org.jetbrains.kotlin.jvm", version.ref = "kotlin" }
application = { id = "application" }
shadow = { id = "com.gradleup.shadow", version.ref = "shadow" }

```

`prebuilt/template/plugin-template/gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`prebuilt/template/plugin-template/gradlew`:

```
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

```

`prebuilt/template/plugin-template/gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`prebuilt/template/plugin-template/settings.gradle.kts`:

```kts
pluginManagement {
  repositories {
    google() // required
    gradlePluginPortal()
    mavenCentral()
  }
}

```

`prebuilt/template/plugin-template/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
  Stoic builds plugins as APKs, but only the classes.dex file within is used.
  Any manifest changes will be ignored.
-->
<manifest 
    xmlns:android="http://schemas.android.com/apk/res/android">
</manifest>

```

`prebuilt/template/plugin-template/src/main/kotlin/Main.kt`:

```kt
// This is a template for your new plugin. Change it however you'd like.

// You may import whatever Android APIs you need
import android.os.Process.myPid
import android.os.Process.myTid

// Import helpers.* to provide access to alternate, plugin-friendly API
// implementations. For example, println normally prints to logcat, but
// helpers.println will tunnel through to Stoic's stdout.
import com.squareup.stoic.helpers.*

// Multiple instances of stoic may be active simultaneously - access the one
// that started your plugin via this thread-local
import com.squareup.stoic.threadlocals.stoic

fun main(args: Array<String>) {
  // You may access the arguments passed on the command-line
  println("main(${args.toList()})")

  // Stoic plugins run on the main thread by default.
  // Use runOnLooper/runOnExecutor/runOnThread for running on other threads.
  // These will automatically propagate threadlocals
  println("Plugin running in process PID=${myPid()} on thread TID=${myTid()}")

  // If you wish to exit with an error-code other than zero, you can call
  // exitPlugin explicitly.
  //exitPlugin(1)
}

```

`prebuilt/template/plugin-template/stoic-build-plugin`:

```
#!/bin/bash
set -euo pipefail

script_dir="$(dirname "$(realpath "$0")")"
final_dir_name="$(basename "$script_dir")"
cd "$script_dir"


./gradlew --quiet :assembleRelease
echo "STOIC_BUILD_PLUGIN_OUT=$PWD/build/outputs/apk/release/$final_dir_name-release-unsigned.apk"

```

`prebuilt/template/usr_config/README.md`:

```md
See the docs in https://github.com/square/stoic/USR_CONFIG.md for details on
how to modify the files in this directory to customize stoic.

```

`protocol/build.gradle.kts`:

```kts
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
  alias(libs.plugins.kotlin.jvm)
  alias(libs.plugins.kotlin.serialization)
  alias(libs.plugins.vanniktech.maven.publish.base)
}

repositories { mavenCentral() }

dependencies {
  implementation(kotlin("stdlib"))
  implementation(libs.kotlinx.serialization.json)
}

// Generate build-time constants
val androidMinSdk = providers.gradleProperty("android.minSdk").get()
val androidCompileSdk = providers.gradleProperty("android.compileSdk").get()
val androidTargetSdk = providers.gradleProperty("android.targetSdk").get()
val androidBuildToolsVersion = providers.gradleProperty("android.buildToolsVersion").get()

val stoicGeneratedSourceDir = layout.buildDirectory.dir("generated/stoic")
val generateCode by
  tasks.registering {
    inputs.property("version_name", rootProject.extra["stoic.version_name"] as String)
    outputs.dir(stoicGeneratedSourceDir)

    doLast {
      val versionName = inputs.properties["version_name"] as String

      // Generate the actual properties (hidden from IDE in build/generated)
      val props =
        stoicGeneratedSourceDir
          .get()
          .asFile
          .resolve("com/squareup/stoic/generated/GeneratedStoicProperties.kt")
      props.parentFile.mkdirs()
      props.writeText(
        """
            package com.squareup.stoic.generated

            internal object GeneratedStoicProperties {
                const val STOIC_VERSION_NAME = "$versionName"
                const val ANDROID_MIN_SDK = $androidMinSdk
                const val ANDROID_COMPILE_SDK = $androidCompileSdk
                const val ANDROID_TARGET_SDK = $androidTargetSdk
                const val ANDROID_BUILD_TOOLS_VERSION = "$androidBuildToolsVersion"
            }
            """
          .trimIndent()
      )

      // Copy VersionCodeFromVersionName for use in release scripts
      val versionCodeFromVersionNameText =
        rootProject.file("buildSrc/src/main/kotlin/VersionCodeFromVersionName.kt").readText()

      val versionCodeFromVersionName =
        stoicGeneratedSourceDir
          .get()
          .asFile
          .resolve("com/squareup/stoic/generated/VersionCodeFromVersionName.kt")

      versionCodeFromVersionName.parentFile.mkdirs()
      versionCodeFromVersionName.writeText(
        """
             |package com.squareup.stoic.generated
             |
             |${versionCodeFromVersionNameText.replace("\n", "\n|")}
          """
          .trimMargin()
      )
    }
  }

kotlin.sourceSets["main"].kotlin.srcDir(stoicGeneratedSourceDir)

tasks.withType<KotlinCompile> {
  dependsOn(generateCode)
  kotlinOptions { jvmTarget = "17" }
}

// Make sourcesJar depend on code generation for publishing
tasks.named("sourcesJar") { dependsOn(generateCode) }

```

`protocol/src/main/kotlin/com/squareup/stoic/bridge/StoicProperties.kt`:

```kt
package com.squareup.stoic.bridge

import com.squareup.stoic.generated.GeneratedStoicProperties

// Generated code can cause problems for IDEs. This bridge provides a stable API
// that delegates to generated code. IDEs see this file, not the generated one.
//
// To resolve GeneratedStoicProperties:
//   ./gradlew :common:build
//   and then Sync Project with Gradle Files
object StoicProperties {
  const val STOIC_VERSION_NAME: String = GeneratedStoicProperties.STOIC_VERSION_NAME
  const val ANDROID_BUILD_TOOLS_VERSION: String =
    GeneratedStoicProperties.ANDROID_BUILD_TOOLS_VERSION
  const val ANDROID_COMPILE_SDK: Int = GeneratedStoicProperties.ANDROID_COMPILE_SDK
  const val ANDROID_MIN_SDK: Int = GeneratedStoicProperties.ANDROID_MIN_SDK
  const val ANDROID_TARGET_SDK: Int = GeneratedStoicProperties.ANDROID_TARGET_SDK
}

```

`protocol/src/main/kotlin/com/squareup/stoic/bridge/VersionCodeFromVersionName.kt`:

```kt
package com.squareup.stoic.bridge

fun versionCodeFromVersionName(versionName: String): Int {
  return com.squareup.stoic.generated.versionCodeFromVersionName(versionName)
}

```

`protocol/src/main/kotlin/com/squareup/stoic/common/Stoic.kt`:

```kt
package com.squareup.stoic.common

private const val MAX_STATUS_LENGTH = 80
private val CLEAR_STATUS = " ".repeat(MAX_STATUS_LENGTH) + "\r"
var showStatus: Boolean = true
var statusShowing: Boolean = false
var minLogLevel: LogLevel = LogLevel.DEBUG

enum class LogLevel(val level: Int) {
  VERBOSE(2),
  DEBUG(3),
  INFO(4),
  WARN(5),
  ERROR(6),
  ASSERT(7);

  fun meetsMinimumLevel(minimumLevel: LogLevel): Boolean {
    return this.level >= minimumLevel.level
  }

  fun isLoggable(): Boolean {
    return this >= minLogLevel
  }
}

fun log(level: LogLevel, msg: () -> String) {
  if (level >= minLogLevel) {
    var realizedMsg = msg()
    if (statusShowing) {
      // We need to clear the status first
      realizedMsg = CLEAR_STATUS + realizedMsg
      statusShowing = false
    }
    System.err.println(realizedMsg)
  }
}

fun status(msg: String) {
  if (showStatus) {
    var msgToDisplay = msg.take(MAX_STATUS_LENGTH) + "\r"
    if (statusShowing) {
      msgToDisplay = CLEAR_STATUS + msgToDisplay
    }

    System.err.print(msgToDisplay)
    statusShowing = true
  }
}

fun clearStatus() {
  if (statusShowing) {
    System.err.print(CLEAR_STATUS)
    statusShowing = false
  }
}

inline fun <T> withStatus(msg: String, block: () -> T): T {
  status(msg)
  return try {
    block()
  } finally {
    clearStatus()
  }
}

fun logVerbose(msg: () -> String) = log(LogLevel.VERBOSE, msg)

fun logDebug(msg: () -> String) = log(LogLevel.DEBUG, msg)

fun logInfo(msg: () -> String) = log(LogLevel.INFO, msg)

fun logWarn(msg: () -> String) = log(LogLevel.WARN, msg)

fun logError(msg: () -> String) = log(LogLevel.ERROR, msg)

inline fun <T> logBlock(level: LogLevel, msg: () -> String, block: () -> T): T {
  val msgValue =
    if (level >= minLogLevel) {
      msg()
    } else {
      ""
    }

  log(level) { "Starting $msgValue..." }
  return runCatching { block() }
    .onSuccess { log(level) { "Finished $msgValue." } }
    .onFailure { e ->
      log(level) { "Aborted $msgValue (--verbose to see Throwable)" }
      log(LogLevel.VERBOSE) { e.stackTraceToString() }
    }
    .getOrThrow()
}

// Utility for debug output
fun Any?.toKotlinRepr(): String =
  when (this) {
    null -> "null"
    is CharSequence -> {
      val unquoted =
        this.toString()
          .replace("\\", "\\\\")
          .replace("\n", "\\n")
          .replace("\t", "\\t")
          .replace("\b", "\\b")
          .replace("\r", "\\r")
          .replace("\"", "\\\"")
          .replace("\$", "\\\$")
      "\"" + unquoted + "\""
    }
    is List<*> -> this.toKotlinListRepr()
    else -> this.toString()
  }

fun List<*>.toKotlinListRepr(): String {
  val reprElements = this.joinToString(separator = ", ") { it.toKotlinRepr() }
  return "listOf($reprElements)"
}

// Socket communication
const val SOCKET_PREFIX = "/stoic"
const val SERVER_SUFFIX = "server"

fun serverSocketName(pkg: String): String {
  return "$SOCKET_PREFIX/$pkg/$SERVER_SUFFIX"
}

```

`protocol/src/main/kotlin/com/squareup/stoic/common/StoicMessages.kt`:

```kt
package com.squareup.stoic.common

import java.io.DataInputStream
import java.io.DataOutputStream
import kotlinx.serialization.Serializable
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json

const val STOIC_PROTOCOL_VERSION = 5
const val STDIN = 0
const val STDOUT = 1
const val STDERR = 2

// json-encoded and base64-encoded and sent as the JVMTI attach options
@Serializable data class JvmtiAttachOptions(val stoicProtocolVersion: Int, val attachedVia: String)

enum class MessageFlags(val code: Int) {
  // Indicates the message is a request, meaning it expects a response in return
  REQUEST(0x1),

  // Indicates the message is a response to an earlier request. The request-id field identifies that
  // request.
  RESPONSE(0x2),

  // For responses, indicating whether or not there will be further messages as part of the same
  // response - must be set if request-id is -1
  COMPLETE(0x4),
}

// Message format:
// size (4 bytes) - overall size of the message, including the flags, type, and payload
// flags (4 bytes) - see MessageFlags
// request-id (4 bytes) - -1 indicates none - note: this can be used even with things that aren't
//     requests/responses - it allows identifies which things are part of a stream
// type (4 bytes) - for use by a higher level to understand how to deserialize the payload
// payload (variable) - an array of bytes (the size can be inferred from the earlier size field)

enum class PayloadType(val code: Int) {
  RAW(1),
  VERIFY_PROTOCOL_VERSION(2),
  START_PLUGIN(3),
  LOAD_PLUGIN(4),
  PLUGIN_FINISHED(5),
  SUCCEEDED(6),
  FAILED(7),
  PROTOCOL_ERROR(8),
}

enum class FailureCode(val value: Int) {
  UNSPECIFIED(0),
  PLUGIN_MISSING(1),
}

@Serializable
data class VerifyProtocolVersion(val protocolVersion: Int, val stoicVersionName: String)

@Serializable
data class StartPlugin(
  val pluginName: String?,
  val pluginSha: String?,
  val pluginArgs: List<String>,
  val minLogLevel: String,
  val env: Map<String, String>,
)

@Serializable data class LoadPlugin(val pluginName: String?, val pluginSha: String)

@Serializable data class PluginFinished(val exitCode: Int)

@Serializable data class Succeeded(val message: String)

@Serializable data class Failed(val failureCode: Int, val message: String)

@Serializable data class ProtocolError(val message: String)

class RawMessage(val flags: Int, val requestId: Int, val payloadType: Int, val payload: ByteArray)

fun DataOutputStream.writeRawMessage(
  flags: Int,
  requestId: Int,
  payloadType: Int,
  payload: ByteArray,
) {
  val size = payload.size + 12
  writeInt(size)
  writeInt(flags)
  writeInt(requestId)
  writeInt(payloadType)
  write(payload)
}

fun DataInputStream.readRawMessage(): RawMessage {
  val size = readInt()
  val flags = readInt()
  val requestId = readInt()
  val payloadType = readInt()

  val payloadSize = size - 12
  val payload = ByteArray(payloadSize).also { readFully(it) }

  return RawMessage(
    flags = flags,
    requestId = requestId,
    payloadType = payloadType,
    payload = payload,
  )
}

data class DecodedMessage<T>(val flags: Int, val requestId: Int, val payload: T) {
  val isRequest
    get() = flags and MessageFlags.REQUEST.code != 0

  val isResponse
    get() = flags and MessageFlags.RESPONSE.code != 0

  val isComplete
    get() = flags and MessageFlags.COMPLETE.code != 0
}

class MessageWriter(val dataOutputStream: DataOutputStream) {
  val openRequestIds = mutableSetOf<Int>()

  // 0/1/2 are reserved for stdin/stdout/stderr
  var nextRequestIndex = 3

  fun allocateRequestId(): Int {
    val requestId = nextRequestIndex++
    openRequestIds.add(requestId)
    return requestId
  }

  fun openStdinForWriting() {
    openRequestIds.add(STDIN)
  }

  fun openStdoutForWriting() {
    openRequestIds.add(STDOUT)
  }

  fun openStderrForWriting() {
    openRequestIds.add(STDERR)
  }

  /**
   * Write a request packet.
   *
   * @param request the request content
   * @param requestId a unique ID identifying the request (or -1 to request an ID to be allocated)
   * @param isComplete false if additional request packets will be sent for the same request ID
   * @return the request ID
   */
  @Synchronized
  fun writeRequest(request: Any, requestId: Int = -1, isComplete: Boolean = true): Int {
    val resolvedRequestId =
      if (requestId == -1) {
        allocateRequestId()
      } else {
        requestId
      }
    val completeFlag =
      if (isComplete) {
        MessageFlags.COMPLETE.code
      } else {
        0
      }
    val flags = MessageFlags.REQUEST.code or completeFlag
    logVerbose { "writing request: $request, requestId=$resolvedRequestId, flags=$flags" }
    writeMessageLocked(flags, resolvedRequestId, request)
    return resolvedRequestId
  }

  /**
   * Write a response packet to a previous request
   *
   * @param requestId the ID identifying the request to which this response corresponds
   * @param response the response content
   * @param isComplete false if additional response packets will be sent for the same request ID
   */
  @Synchronized
  fun writeResponse(requestId: Int, response: Any, isComplete: Boolean = true) {
    val completeFlag =
      if (isComplete) {
        MessageFlags.COMPLETE.code
      } else {
        0
      }
    val flags = MessageFlags.RESPONSE.code or completeFlag
    logVerbose { "writing response: $response, requestId=$requestId, flags=$flags" }
    writeMessageLocked(flags, requestId, response)
  }

  /**
   * Write an independent message packet (neither a request expecting a response nor a response to a
   * previous request)
   *
   * @param oneWay the message content
   * @param requestId the ID identifying the message (in case the message involves multiple packets)
   * @param isComplete false if additional packets will be sent for the same request ID
   */
  @Synchronized
  fun writeOneWay(oneWay: Any, requestId: Int = -1, isComplete: Boolean = true) {
    val resolvedRequestId =
      if (requestId == -1) {
        allocateRequestId()
      } else {
        requestId
      }
    val completeFlag =
      if (isComplete) {
        MessageFlags.COMPLETE.code
      } else {
        0
      }
    logVerbose { "writing one-way: $oneWay, requestId=$resolvedRequestId, flags=$completeFlag" }
    writeMessageLocked(completeFlag, resolvedRequestId, oneWay)
  }

  fun writeMessageLocked(flags: Int, requestId: Int, msg: Any) {
    val payloadType: Int
    val payload: ByteArray
    when (msg) {
      is VerifyProtocolVersion -> {
        payloadType = PayloadType.VERIFY_PROTOCOL_VERSION.code
        payload = Json.encodeToString(msg).toByteArray()
      }
      is StartPlugin -> {
        payloadType = PayloadType.START_PLUGIN.code
        payload = Json.encodeToString(msg).toByteArray()
      }
      is LoadPlugin -> {
        payloadType = PayloadType.LOAD_PLUGIN.code
        payload = Json.encodeToString(msg).toByteArray()
      }
      is PluginFinished -> {
        payloadType = PayloadType.PLUGIN_FINISHED.code
        payload = Json.encodeToString(msg).toByteArray()
      }
      is ByteArray -> {
        payloadType = PayloadType.RAW.code
        payload = msg
      }
      is Succeeded -> {
        payloadType = PayloadType.SUCCEEDED.code
        payload = Json.encodeToString(msg).toByteArray()
      }
      is Failed -> {
        payloadType = PayloadType.FAILED.code
        payload = Json.encodeToString(msg).toByteArray()
      }
      is ProtocolError -> {
        payloadType = PayloadType.PROTOCOL_ERROR.code
        payload = Json.encodeToString(msg).toByteArray()
      }
      else -> throw IllegalArgumentException()
    }
    dataOutputStream.writeRawMessage(
      flags = flags,
      requestId = requestId,
      payloadType = payloadType,
      payload = payload,
    )
  }
}

class MessageReader(val dataInputStream: DataInputStream) {
  private var nextMessage: DecodedMessage<Any>? = null

  @Synchronized
  fun peekNext(): DecodedMessage<Any> {
    if (nextMessage == null) {
      nextMessage = readNextLocked()
    }

    return nextMessage!!
  }

  @Synchronized
  fun consumeNext(): DecodedMessage<Any> {
    return peekNext().also { nextMessage = null }
  }

  private fun readNextLocked(): DecodedMessage<Any> {
    val rawMessage = dataInputStream.readRawMessage()
    val payload =
      when (rawMessage.payloadType) {
        PayloadType.RAW.code -> rawMessage.payload
        PayloadType.VERIFY_PROTOCOL_VERSION.code ->
          Json.decodeFromString<VerifyProtocolVersion>(String(rawMessage.payload))
        PayloadType.START_PLUGIN.code ->
          Json.decodeFromString<StartPlugin>(String(rawMessage.payload))
        PayloadType.LOAD_PLUGIN.code ->
          Json.decodeFromString<LoadPlugin>(String(rawMessage.payload))
        PayloadType.PLUGIN_FINISHED.code ->
          Json.decodeFromString<PluginFinished>(String(rawMessage.payload))
        PayloadType.SUCCEEDED.code -> Json.decodeFromString<Succeeded>(String(rawMessage.payload))
        PayloadType.FAILED.code -> Json.decodeFromString<Failed>(String(rawMessage.payload))
        PayloadType.PROTOCOL_ERROR.code ->
          Json.decodeFromString<ProtocolError>(String(rawMessage.payload))
        else -> throw IllegalArgumentException("Unknown payloadType: ${rawMessage.payloadType}")
      }

    val msg =
      DecodedMessage<Any>(
        flags = rawMessage.flags,
        requestId = rawMessage.requestId,
        payload = payload,
      )

    logVerbose { "read $msg" }

    return msg
  }
}

```

`release.sh`:

```sh
#!/bin/bash
#set -x
set -euo pipefail
script_dir="$(realpath "$(dirname "$(readlink -f "$0")")")"

cd "$script_dir"
./gradlew --console=plain clean :internal:tool:release:run --args "$script_dir"

```

`settings.gradle.kts`:

```kts
rootProject.name = "stoic"

pluginManagement {
  repositories {
    gradlePluginPortal()
    google()
    mavenCentral()
  }
}

dependencyResolutionManagement {
  repositories {
    google()
    mavenCentral()
  }
}

include("target:jvmti-attach")

include("target:app-sdk")

include("target:plugin-sdk")

include("protocol")

include("demo-app:without-sdk")

include("demo-app:with-sdk")

include("demo-plugin:appexitinfo")

include("demo-plugin:breakpoint")

include("demo-plugin:helloworld")

include("demo-plugin:crasher")

include("test-plugin")

include("host:main")

include("internal:tool:jar-to-apk-preserve-manifest")

include("internal:tool:release")

include("internal:test:protocol-version-client")

include("native")

include("integration-tests")

```

`setup.sh`:

```sh
#!/bin/bash
#set -x

# When executed (not sourced), enable strict error handling
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    set -euo pipefail
fi

# One-time setup script for Stoic development environment
# This checks and installs required dependencies:
# - Git submodules
# - Android SDK packages
# - GraalVM

# Determine script directory, handling both sourced and executed cases in bash and zsh
if [ -n "${ZSH_VERSION:-}" ]; then
    # For Zsh
    # shellcheck disable=SC2296
    stoic_dir="$(cd "$(dirname "${(%):-%N}")" && pwd)"
elif [ -n "${BASH_VERSION:-}" ]; then
    # For Bash
    stoic_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
else
    # Fallback for other shells
    stoic_dir="$(cd "$(dirname "$0")" && pwd)"
fi

# Read Android SDK versions from gradle.properties
android_build_tools_version=$(grep "^android.buildToolsVersion=" "$stoic_dir/gradle.properties" | cut -d'=' -f2)
android_target_sdk=$(grep "^android.targetSdk=" "$stoic_dir/gradle.properties" | cut -d'=' -f2)
android_ndk_version=$(grep "^android.ndkVersion=" "$stoic_dir/gradle.properties" | cut -d'=' -f2)

# AUTO_YES can be set by the calling script or passed as --yes argument
# Default to 0 if not set
if [ -z "${AUTO_YES+x}" ]; then
    AUTO_YES=0
    # Only parse arguments if not already set by caller
    for arg in "$@"; do
        case $arg in
            --yes) AUTO_YES=1 ;;
            *)
                >&2 echo "Unrecognized arg: $arg"
                exit 1
                ;;
        esac
    done
fi

#
# Git submodules have been removed - dependencies are now included locally
# (kept this comment as documentation of the change)
#

#
# Install required Android SDK packages
#

if [ -z "${ANDROID_HOME:-}" ]; then
    echo "ANDROID_HOME env variable not defined. This should be the path to your Android SDK."
    echo "e.g."
    echo "    export ANDROID_HOME=~/Library/Android/sdk"
    exit 1
fi

# Find sdkmanager script (falling back to the old location if the new one
# is missing)
sdkmanager="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"
if [ ! -e "$sdkmanager" ]; then
    >&2 echo "Failed to find sdkmanager in its usual location."
    >&2 echo "Please update Android SDK Command-line Tools to the latest version."
    exit 1
fi

sdk_packages="$("$sdkmanager" --list_installed 2>/dev/null | awk '{print $1}')"
required_packages=(
  "build-tools;$android_build_tools_version"
  "platforms;android-$android_target_sdk"
  "ndk;$android_ndk_version"
)
missing=()

for required in "${required_packages[@]}"; do
    if ! echo "$sdk_packages" | grep "$required" >/dev/null; then
        missing+=("$required")
    fi
done

if [ ${#missing[@]} -gt 0 ]; then
    >&2 echo "stoic requires Android SDK packages: ${missing[*]}"
    >&2 echo "Will run \`$sdkmanager ${missing[*]}\`"
    if [[ "$AUTO_YES" -eq 1 ]]; then
        for x in "${missing[@]}"; do
            $sdkmanager "$x"
        done
    else
        read -r -p "Okay? (Y/n) " choice
        case "$(echo "$choice" | tr '[:upper:]' '[:lower:]')" in
          n*)
            exit 1
            ;;
          *)
            for x in "${missing[@]}"; do
                $sdkmanager "$x"
            done
            ;;
        esac
    fi
fi

# Used by native/Makefile.inc
export ANDROID_NDK="$ANDROID_HOME/ndk/$android_ndk_version"

#
# Setup GraalVM
#

setup_graalvm() {
  if [ -n "${GRAALVM_HOME:-}" ] && [ -d "$GRAALVM_HOME" ]; then
    return 0
  fi
  if  { brew list --cask  --versions graalvm-ce-java17 >/dev/null 2>&1; }; then
    GRAALVM_HOME="$(brew info graalvm-ce-java17 | grep 'export JAVA_HOME' | sed -E 's/^ *export JAVA_HOME="(.*)"/\1/')"
    export GRAALVM_HOME
    return 0
  fi
  # macOS – install via Homebrew if necessary
  if [[ "$(uname)" == "Darwin" ]]; then
    if ! command -v brew >/dev/null 2>&1; then
      >&2 echo "Homebrew is required to automatically install GraalVM. Either install Homebrew, install GraalVM manually, or export GRAALVM_HOME before running this script."
      exit 1
    fi

    brew install graalvm/tap/graalvm-ce-java17
    GRAALVM_HOME="$(brew info graalvm-ce-java17 | grep 'export JAVA_HOME' | sed -E 's/^ *export JAVA_HOME="(.*)"/\1/')"
    export GRAALVM_HOME
    # macOS Gatekeeper marks downloaded binaries as quarantined; unquarantine.
    # The quarantine attribute lives on the GraalVM bundle root (…/graalvm-ce-java17-xx). Remove it from there too.
    xattr -r -d com.apple.quarantine "$(dirname "$(dirname "$GRAALVM_HOME")")" 2>/dev/null || true
  else
    # Other platforms – ask the user to install GraalVM manually.
    >&2 echo "Automatic GraalVM installation is only supported on macOS. Please install GraalVM CE Java 17 and set GRAALVM_HOME."
    exit 1
  fi
}

setup_graalvm

echo "Setup completed successfully!"
echo "ANDROID_NDK=$ANDROID_NDK"
echo "GRAALVM_HOME=$GRAALVM_HOME"

# Export for use by calling scripts
export ANDROID_NDK
export GRAALVM_HOME

```

`target/app-sdk/build.gradle.kts`:

```kts
plugins {
  alias(libs.plugins.android.library)
  alias(libs.plugins.kotlin.android)
  alias(libs.plugins.vanniktech.maven.publish.base)
}

android {
  namespace = "com.squareup.stoic.android.sdk"
  compileSdk = (extra["stoic.android_compile_sdk"] as String).toInt()

  defaultConfig {
    minSdk = (extra["stoic.android_min_sdk"] as String).toInt()

    testInstrumentationRunner = "android.support.test.runner.AndroidJUnitRunner"
    consumerProguardFiles("consumer-rules.pro")
  }

  buildTypes {
    release {
      isMinifyEnabled = false
      proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
    }
  }
  compileOptions {
    val jvmTarget = JavaVersion.toVersion(libs.versions.jvmTarget.get())
    sourceCompatibility = jvmTarget
    targetCompatibility = jvmTarget
  }
  kotlinOptions {
    jvmTarget = libs.versions.jvmTarget.get()
    // Set API and language version to 1.9 for maximum compatibility with consumers
    // Even though we compile with Kotlin 2.1+, this ensures the generated bytecode
    // and API surface are compatible with projects using Kotlin 1.9+
    apiVersion = "1.9"
    languageVersion = "1.9"
  }

  packaging { resources { excludes += "META-INF/DEPENDENCIES" } }

  buildFeatures { buildConfig = true }
}

dependencies {
  // These dependencies will be transitive - users of app-sdk will automatically get them
  api(project(":protocol"))
  api(project(":target:plugin-sdk"))
  api(libs.kotlinx.serialization.json)
}

```

`target/app-sdk/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
```

`target/app-sdk/src/main/AndroidManifest.xml`:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.squareup.stoic.android.sdk">

  <application>
    <receiver
        android:name=".StoicBroadcastReceiver"
        android:exported="true"
        android:enabled="true">
      <intent-filter>
        <action android:name="com.squareup.stoic.android.sdk.ACTION_UDS_LISTEN" />
      </intent-filter>
    </receiver>
  </application>
</manifest>
```

`target/app-sdk/src/main/kotlin/com/squareup/stoic/android/sdk/StoicBroadcastReceiver.kt`:

```kt
package com.squareup.stoic.android.sdk

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.util.Log
import com.squareup.stoic.common.STOIC_PROTOCOL_VERSION
import com.squareup.stoic.target.runtime.StoicUnixDomainSocketServer
import com.squareup.stoic.target.runtime.optionsJsonFromStoicDir
import java.io.File

class StoicBroadcastReceiver : BroadcastReceiver() {
  override fun onReceive(context: Context?, intent: Intent?) {
    Log.i("stoic", "onReceive($context, $intent)")
    val stoicDir = context!!.getDir("stoic", Context.MODE_PRIVATE).absolutePath
    val optionsJsonPath = optionsJsonFromStoicDir(stoicDir)
    File(optionsJsonPath)
      .writeText("{\"stoicProtocolVersion\":$STOIC_PROTOCOL_VERSION, \"attachedVia\":\"SDK\"}")
    StoicUnixDomainSocketServer.ensureRunning(
      stoicDir = stoicDir,
      context = context.applicationContext,
    )
    Log.i("stoic", "started server")
  }
}

```

`target/app-sdk/src/main/kotlin/com/squareup/stoic/target/runtime/MainThreadExecutor.kt`:

```kt
package com.squareup.stoic.target.runtime

import android.os.Handler
import android.os.Looper
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import java.util.concurrent.TimeoutException

/** Utility for executing code on the main thread with a timeout. */
object MainThreadExecutor {
  private val mainHandler = Handler(Looper.getMainLooper())

  /**
   * Executes the given block on the main thread, blocking the calling thread until completion.
   *
   * If the main thread cannot be acquired within the timeout, captures the main thread's stack
   * trace and throws a TimeoutException with that stack trace as the cause.
   *
   * @param timeoutMillis Maximum time to wait for the main thread (default: 5000ms)
   * @param block The code to execute on the main thread
   * @return The result of executing the block
   * @throws TimeoutException if the main thread cannot be acquired within the timeout
   */
  fun <T> runOnMainThread(timeoutMillis: Long = 5000, block: () -> T): T {
    // If we're already on the main thread, just execute directly
    if (Looper.myLooper() == Looper.getMainLooper()) {
      return block()
    }

    val latch = CountDownLatch(1)
    var result: T? = null
    var exception: Throwable? = null

    mainHandler.post {
      try {
        result = block()
      } catch (e: Throwable) {
        exception = e
      } finally {
        latch.countDown()
      }
    }

    val completed = latch.await(timeoutMillis, TimeUnit.MILLISECONDS)

    if (!completed) {
      // Timeout - capture main thread stack trace
      val mainThread = Looper.getMainLooper().thread
      val mainThreadStackTrace = mainThread.stackTrace

      val stackTraceException =
        Exception("Main thread stack trace at timeout").apply { stackTrace = mainThreadStackTrace }

      throw TimeoutException(
          "Failed to acquire main thread within ${timeoutMillis}ms. " +
            "Main thread may be blocked or busy."
        )
        .apply { initCause(stackTraceException) }
    }

    exception?.let { throw it }

    @Suppress("UNCHECKED_CAST")
    return result as T
  }
}

```

`target/app-sdk/src/main/kotlin/com/squareup/stoic/target/runtime/MessageWriterOutputStream.kt`:

```kt
package com.squareup.stoic.target.runtime

import com.squareup.stoic.common.MessageWriter
import com.squareup.stoic.common.logVerbose
import java.io.OutputStream

// Used to provide stdout/stderr
class MessageWriterOutputStream(private val id: Int, private val writer: MessageWriter) :
  OutputStream() {
  override fun write(b: Int) {
    write(byteArrayOf(b.toByte()), 0, 1)
  }

  override fun write(b: ByteArray, off: Int, len: Int) {
    val buf = ByteArray(len)
    System.arraycopy(b, off, buf, 0, len)
    writer.writeOneWay(buf, id, isComplete = false)
  }

  override fun close() {
    // Useful for understanding when a stream is prematurely closed
    logVerbose { "stream $id closed: ${Throwable().stackTraceToString()}" }

    writer.writeOneWay(ByteArray(0), id, isComplete = true)
  }
}

```

`target/app-sdk/src/main/kotlin/com/squareup/stoic/target/runtime/Mux.kt`:

```kt
package com.squareup.stoic.target.runtime

import java.io.DataInputStream
import java.io.DataOutputStream

class MultiplexedReader(private val stream: DataInputStream) {
  fun read(): Pair<Int, ByteArray> {
    val id = stream.readInt()
    val payloadSize = stream.readInt()
    val payload = ByteArray(payloadSize)
    stream.readFully(payload)

    return Pair(id, payload)
  }
}

class MultiplexedWriter(private val stream: DataOutputStream) {
  fun write(id: Int, buffer: ByteArray) {
    write(id, buffer, 0, buffer.size)
  }

  fun write(id: Int, buffer: ByteArray, offset: Int, length: Int) {
    stream.writeInt(id)
    stream.writeInt(length)
    stream.write(buffer, offset, length)
    stream.flush()
  }
}

```

`target/app-sdk/src/main/kotlin/com/squareup/stoic/target/runtime/StoicConfigLoader.kt`:

```kt
package com.squareup.stoic.target.runtime

import android.content.Context
import android.content.pm.PackageManager
import android.util.Log
import com.squareup.stoic.plugin.StoicConfig
import com.squareup.stoic.plugin.StoicPlugin

/** Loads Stoic configuration by reading AndroidManifest.xml meta-data. */
object StoicConfigLoader {
  private const val TAG = "StoicConfigLoader"
  private const val METADATA_KEY = "com.squareup.stoic.config"

  private val DEFAULT_CONFIG =
    object : StoicConfig {
      override fun getEmbeddedPlugins(context: Context): Map<String, Lazy<StoicPlugin>> = emptyMap()
    }

  /**
   * Loads the Stoic config registered via AndroidManifest meta-data.
   *
   * Looks for `<meta-data android:name="com.squareup.stoic.config" android:value="..."/>` entry,
   * and instantiates the config class.
   *
   * @param context Application context
   * @return StoicConfig instance, or a default config if not found or invalid
   */
  fun loadConfig(context: Context): StoicConfig {
    try {
      val appInfo =
        context.packageManager.getApplicationInfo(context.packageName, PackageManager.GET_META_DATA)

      val metaData = appInfo.metaData
      if (metaData == null) {
        Log.d(TAG, "No meta-data found in AndroidManifest")
        return DEFAULT_CONFIG
      }

      // Look for the config class
      val configClassName = metaData.getString(METADATA_KEY)
      if (configClassName == null) {
        Log.d(TAG, "No Stoic config found in AndroidManifest")
        return DEFAULT_CONFIG
      }

      Log.d(TAG, "Found Stoic config: $configClassName")

      // Load and instantiate the config
      val clazz = Class.forName(configClassName)
      val instance = clazz.getDeclaredConstructor().newInstance()

      if (instance !is StoicConfig) {
        Log.e(TAG, "Class $configClassName does not implement StoicConfig")
        return DEFAULT_CONFIG
      }

      Log.i(TAG, "Loaded Stoic config: $configClassName")
      return instance
    } catch (e: Exception) {
      Log.e(TAG, "Failed to load Stoic config", e)
      return DEFAULT_CONFIG
    }
  }
}

```

`target/app-sdk/src/main/kotlin/com/squareup/stoic/target/runtime/StoicContextProvider.kt`:

```kt
package com.squareup.stoic.target.runtime

import android.content.Context
import android.util.Log

private const val TAG = "StoicContextProvider"

/**
 * Attempts to retrieve the application Context using reflection.
 *
 * This is needed when Stoic attaches via JVMTI and doesn't have a Context readily available. Uses
 * ActivityThread.currentApplication() which is available in all Android versions.
 *
 * @return Application Context, or null if unable to obtain it
 */
fun retrieveApplicationContextViaReflection(): Context? {
  return try {
    // Use reflection to access ActivityThread.currentApplication()
    val activityThreadClass = Class.forName("android.app.ActivityThread")
    val currentApplicationMethod = activityThreadClass.getMethod("currentApplication")
    val application = currentApplicationMethod.invoke(null)

    if (application != null) {
      Log.d(TAG, "Successfully obtained application context via ActivityThread")
      application as Context
    } else {
      Log.w(TAG, "ActivityThread.currentApplication() returned null")
      null
    }
  } catch (e: Exception) {
    Log.e(TAG, "Failed to get application context via reflection", e)
    null
  }
}

```

`target/app-sdk/src/main/kotlin/com/squareup/stoic/target/runtime/StoicPaths.kt`:

```kt
package com.squareup.stoic.target.runtime

fun optionsJsonFromStoicDir(stoicDir: String): String {
  return "$stoicDir/options.json"
}

```

`target/app-sdk/src/main/kotlin/com/squareup/stoic/target/runtime/StoicPluginServer.kt`:

```kt
package com.squareup.stoic.target.runtime

import android.util.Log
import com.squareup.stoic.ExitCodeException
import com.squareup.stoic.Stoic
import com.squareup.stoic.bridge.StoicProperties
import com.squareup.stoic.common.Failed
import com.squareup.stoic.common.FailureCode
import com.squareup.stoic.common.JvmtiAttachOptions
import com.squareup.stoic.common.LoadPlugin
import com.squareup.stoic.common.MessageReader
import com.squareup.stoic.common.MessageWriter
import com.squareup.stoic.common.PluginFinished
import com.squareup.stoic.common.ProtocolError
import com.squareup.stoic.common.STDERR
import com.squareup.stoic.common.STDIN
import com.squareup.stoic.common.STDOUT
import com.squareup.stoic.common.STOIC_PROTOCOL_VERSION
import com.squareup.stoic.common.StartPlugin
import com.squareup.stoic.common.Succeeded
import com.squareup.stoic.common.VerifyProtocolVersion
import com.squareup.stoic.common.logInfo
import com.squareup.stoic.common.logVerbose
import com.squareup.stoic.plugin.StoicPlugin
import com.squareup.stoic.threadlocals.stoic
import dalvik.system.DexClassLoader
import java.io.DataInputStream
import java.io.DataOutputStream
import java.io.File
import java.io.InputStream
import java.io.OutputStream
import java.io.PipedInputStream
import java.io.PipedOutputStream
import java.io.PrintStream
import java.lang.reflect.InvocationTargetException
import kotlin.Exception
import kotlin.concurrent.thread

class StoicPluginServer(
  private val stoicDir: String,
  private val options: JvmtiAttachOptions,
  extraPlugins: Map<String, Lazy<StoicPlugin>>,
  private val socketInputStream: InputStream,
  private val socketOutputStream: OutputStream,
) {
  private val writer = MessageWriter(DataOutputStream(socketOutputStream))
  private val reader = MessageReader(DataInputStream(socketInputStream))
  private val embeddedPlugins: Map<String, Lazy<StoicPlugin>> = run {
    // Internal plugins prefixed with __ are hidden from --list output
    val defaultPlugins =
      mapOf(
        "__stoic-status" to
          lazy {
            object : StoicPlugin {
              override fun run(args: List<String>): Int {
                stoic.stdout.println(
                  """
                protocol-version: ${options.stoicProtocolVersion}
                attached-via: ${options.attachedVia}
                embedded-plugins: ${embeddedPlugins.keys}
              """
                    .trimIndent()
                )

                return 0
              }
            }
          },
        "__stoic-list" to
          lazy {
            object : StoicPlugin {
              override fun run(args: List<String>): Int {
                embeddedPlugins.keys
                  .sorted()
                  .filter { !it.startsWith("__stoic-") }
                  .forEach { stoic.stdout.println(it) }

                return 0
              }
            }
          },
        "__stoic-noop" to
          lazy {
            object : StoicPlugin {
              override fun run(args: List<String>): Int {
                // This is used to ensure the server is running
                return 0
              }
            }
          },
      )
    defaultPlugins + extraPlugins
  }

  init {
    logVerbose {
      "constructed writer from ${writer.dataOutputStream} (underlying ${socketOutputStream})"
    }
    logVerbose {
      "constructed reader from ${reader.dataInputStream} (underlying ${socketInputStream})"
    }
  }

  fun handleVersion() {
    val decodedMessage = reader.consumeNext()
    check(decodedMessage.isRequest)
    val payload = decodedMessage.payload as VerifyProtocolVersion
    if (payload.protocolVersion != STOIC_PROTOCOL_VERSION) {
      writer.writeResponse(
        decodedMessage.requestId,
        Failed(
          FailureCode.UNSPECIFIED.value,
          "Version mismatch - expected $STOIC_PROTOCOL_VERSION, received ${payload.protocolVersion}",
        ),
      )
      throw FailedOperationException()
    } else {
      val msg =
        if (payload.stoicVersionName != StoicProperties.STOIC_VERSION_NAME) {
          // This is normally fine, but if we forget to rev the protocol version when we make a
          // breaking change it will cause problems. If we see a problem it's worth considering if
          // there was a breaking change.
          "version check succeeded but stoic version name doesn't match " +
            "${payload.stoicVersionName} != ${StoicProperties.STOIC_VERSION_NAME}"
        } else {
          "version check succeeded and stoic version name matches: ${StoicProperties.STOIC_VERSION_NAME}"
        }
      logInfo { msg }
      writer.writeResponse(decodedMessage.requestId, Succeeded(msg))
    }
  }

  fun handlePlugin() {
    while (true) {
      when (reader.peekNext().payload) {
        is StartPlugin -> {
          // Once handleStartPlugin succeeds we're done.
          if (handleStartPlugin()) {
            return
          } else {
            continue
          }
        }
        is LoadPlugin -> handleLoadPlugin()
        else -> {
          logVerbose { "Exiting handlePlugin - next message is ${reader.peekNext()}" }
          return
        }
      }
    }
  }

  /** Returns true for success, false for failure */
  fun handleStartPlugin(): Boolean {
    val startPluginRequestId: Int
    val startPlugin: StartPlugin

    run {
      val decodedMessage = reader.consumeNext()
      check(decodedMessage.isRequest)
      startPlugin = decodedMessage.payload as StartPlugin
      startPluginRequestId = decodedMessage.requestId
    }

    val oldClassLoader = Thread.currentThread().contextClassLoader
    try {
      val plugin =
        if (startPlugin.pluginSha != null) {
          val parentClassLoader = StoicPluginServer::class.java.classLoader
          val pluginDir = "$stoicDir/plugin-by-sha/${startPlugin.pluginSha}"
          val pluginApk = File("$pluginDir/${startPlugin.pluginName}.apk")
          if (!pluginApk.exists()) {
            writer.writeResponse(
              startPluginRequestId,
              Failed(FailureCode.PLUGIN_MISSING.value, "$pluginApk not loaded"),
            )
            return false
          }

          val dexoutDir = File("$pluginDir/${startPlugin.pluginName}-dexout")
          dexoutDir.mkdirs()
          Log.d("stoic", "Making classLoader: (pluginApk: $pluginApk, dexoutDir: $dexoutDir)")

          // It's important to use canonical paths to avoid triggering
          // https://github.com/square/stoic/issues/2
          val classLoader =
            DexClassLoader(
              pluginApk.canonicalPath,
              dexoutDir.canonicalPath,
              null,
              parentClassLoader,
            )

          Log.d("stoic", "made classLoader: $classLoader (parent: $parentClassLoader)")

          // TODO: It'd be nice to allow people to follow the Java convention of declaring a main
          //   method in the manifest, and then insert a StoicMainKt wrapper in the apk (or even
          //   insert the manifest into the apk)
          val pluginMainClass = classLoader.loadClass("MainKt")
          Log.d("stoic", "loaded class: $pluginMainClass via ${pluginMainClass.classLoader}")
          val args = startPlugin.pluginArgs.toTypedArray()
          val pluginMain = pluginMainClass.getDeclaredMethod("main", args.javaClass)

          // Set the context classloader so plugin code can load classes from its own JAR
          Thread.currentThread().contextClassLoader = classLoader

          object : StoicPlugin {
            override fun run(args: List<String>): Int {
              return try {
                pluginMain.invoke(null, args.toTypedArray())
                0
              } catch (e: InvocationTargetException) {
                Log.e("stoic", "plugin crashed", e)
                val targetException = e.targetException
                if (targetException !is ExitCodeException) {
                  targetException.printStackTrace(stoic.stderr)
                  1
                } else {
                  targetException.code
                }
              } catch (e: ReflectiveOperationException) {
                Log.e("stoic", "problem starting plugin", e)
                e.printStackTrace(stoic.stderr)
                1
              }
            }
          }
        } else if (startPlugin.pluginName != null) {
          val p = embeddedPlugins[startPlugin.pluginName]?.value
          if (p == null) {
            val msg = "No embedded plugin named: ${startPlugin.pluginName}"
            Log.i("stoic", msg)
            writer.writeResponse(
              startPluginRequestId,
              Failed(FailureCode.PLUGIN_MISSING.value, msg),
            )
            return false
          } else {
            p
          }
        } else {
          throw IllegalArgumentException(
            "At least one of pluginName/pluginSha must be specified: $startPlugin"
          )
        }

      // Plugin may write to stdout/stderr
      writer.openStdoutForWriting()
      writer.openStderrForWriting()

      val stdinOutPipe = PipedOutputStream()
      val stdin = PipedInputStream(stdinOutPipe)
      val stdout = PrintStream(MessageWriterOutputStream(STDOUT, writer))
      val stderr = PrintStream(MessageWriterOutputStream(STDERR, writer))
      val pluginStoic =
        Stoic(Thread.currentThread().contextClassLoader, startPlugin.env, stdin, stdout, stderr)

      writer.writeResponse(startPluginRequestId, Succeeded("Plugin started"))

      var exitCode: Int
      val t = thread {
        exitCode =
          pluginStoic.callWith {
            // Run plugin on main thread to ensure thread-safe execution
            // Use a mutable variable to capture the return value from runOnMainLooper
            var result = -1
            pluginStoic.runOnMainLooper(timeoutMs = 5000) {
              result = plugin.run(startPlugin.pluginArgs)
            }
            result
          }

        // We write PluginFinished to signal the client to send StreamClosed(STDIN), which signals
        // us
        // to stop pumping messages
        writer.writeOneWay(PluginFinished(exitCode))
      }

      while (true) {
        val decodedMessage = reader.consumeNext()
        val payload = decodedMessage.payload
        val requestId = decodedMessage.requestId
        when (payload) {
          is ByteArray -> {
            if (requestId != STDIN) {
              throw IllegalArgumentException("Unexpected stream id: $requestId")
            }
            stdinOutPipe.write(payload)
            if (decodedMessage.isComplete) {
              logVerbose { "StreamClosed(STDIN)" }
              stdinOutPipe.close()

              // TODO: Really, we shouldn't break here - there might be other inputs to pump
              //   But, right now we don't surface those to clients, so it's okay.
              //   If we didn't break here, we'd need an alternate way to end the pump when the
              // plugin
              //   finished.
              break
            }
          }
        }
      }
      t.join()
    } finally {
      Thread.currentThread().contextClassLoader = oldClassLoader
    }

    return true
  }

  fun handleLoadPlugin() {
    val requestId: Int
    val loadPlugin =
      reader.consumeNext().let {
        check(it.isRequest)
        check(!it.isComplete)
        requestId = it.requestId
        it.payload as LoadPlugin
      }
    val loadPluginBytes =
      reader.consumeNext().let {
        check(it.isRequest)

        // TODO: support streaming the plugin across multiple StreamIO messages
        check(it.isComplete)

        it.payload as ByteArray
      }

    val pluginByShaDir = File("$stoicDir/plugin-by-sha/${loadPlugin.pluginSha}")
    if (pluginByShaDir.exists()) {
      // We are reloading the directory - need to clear it first
      pluginByShaDir.deleteRecursively()
    }

    pluginByShaDir.mkdirs()
    val pluginApk = File(pluginByShaDir, "${loadPlugin.pluginName}.apk")
    pluginApk.writeBytes(loadPluginBytes)
    pluginApk.setWritable(false)
    writer.writeResponse(requestId, Succeeded("Load plugin succeeded"))
  }

  fun pluginMain() {
    Log.i("stoic", "pluginMain")
    try {
      handleVersion()
      handlePlugin()
    } catch (e: Throwable) {
      Log.e("stoic", "pluginMain threw", e)
      // TODO: we should also write to stderr
      writer.writeOneWay(ProtocolError(e.stackTraceToString()))

      // TODO: Instead of this hacky sleep, we should wait for an ACK from the client
      // Give the message time to make it to the other side before we close the connection
      Thread.sleep(1000)
    }
  }
}

class FailedOperationException : Exception()

```

`target/app-sdk/src/main/kotlin/com/squareup/stoic/target/runtime/StoicUnixDomainSocketServer.kt`:

```kt
package com.squareup.stoic.target.runtime

import android.content.Context
import android.net.LocalServerSocket
import android.util.Log
import com.squareup.stoic.common.JvmtiAttachOptions
import com.squareup.stoic.common.STOIC_PROTOCOL_VERSION
import com.squareup.stoic.common.serverSocketName
import java.io.File
import java.io.IOException
import java.nio.charset.StandardCharsets.UTF_8
import kotlin.concurrent.thread
import kotlinx.serialization.json.Json

class StoicUnixDomainSocketServer {
  companion object {
    val lock = Any()
    var isRunning: Boolean = false

    fun ensureRunning(stoicDir: String, context: Context? = null) {
      synchronized(lock) {
        if (isRunning) {
          return
        } else {
          isRunning = true
        }

        thread(isDaemon = true, name = "stoic-uds-server") { startServer(stoicDir, context) }
      }
    }
  }
}

private fun startServer(stoicDir: String, context: Context?) {
  try {
    Log.d("stoic", "stoicDir: $stoicDir")
    val options =
      Json.decodeFromString(
        JvmtiAttachOptions.serializer(),
        File(optionsJsonFromStoicDir(stoicDir)).readText(UTF_8),
      )
    Log.d("stoic", "options: $options")
    if (options.stoicProtocolVersion != STOIC_PROTOCOL_VERSION) {
      throw Exception(
        "Mismatched versions: ${options.stoicProtocolVersion} and $STOIC_PROTOCOL_VERSION"
      )
    }

    // TODO: fix hack - get the pkg from something other than the dir
    val pkg = File(stoicDir).parentFile!!.name

    val server = LocalServerSocket(serverSocketName(pkg))
    val name = server.localSocketAddress.name
    val namespace = server.localSocketAddress.namespace
    Log.d("stoic", "localSocketAddress: ($name, $namespace)")

    // Signal that the server is ready
    val serverUp = serverUpFile(File(stoicDir))
    Log.d("stoic", "Letting the client know that we're up by creating $serverUp")
    try {
      serverUp.createNewFile()
      Log.d("stoic", "created $serverUp!!")
    } catch (e: IOException) {
      Log.e("stoic", "Failed to create $serverUp", e)
      throw e
    }

    while (true) {
      Log.i("stoic", "waiting for connection")

      // Note: If the process gets frozen
      // (https://source.android.com/docs/core/perf/cached-apps-freezer)
      // then the thread will get stuck here
      val socket = server.accept()

      Log.i("stoic", "received connection: $socket")
      thread(name = "stoic-plugin") {
        try {
          // Load config from AndroidManifest
          // Get context either from the parameter (BroadcastReceiver path) or
          // via reflection (JVMTI path)
          val appContext = context?.applicationContext ?: retrieveApplicationContextViaReflection()
          val embeddedPlugins =
            if (appContext != null) {
              Log.d("stoic", "Loading Stoic config...")
              // Run on main thread to ensure thread-safe initialization
              MainThreadExecutor.runOnMainThread {
                StoicConfigLoader.loadConfig(appContext).getEmbeddedPlugins(appContext)
              }
            } else {
              Log.w("stoic", "No context available - skipping config loading")
              emptyMap()
            }

          Log.d("stoic", "embedded plugins: ${embeddedPlugins.keys.joinToString(", ")}")

          StoicPluginServer(
              stoicDir,
              options,
              embeddedPlugins,
              socket.inputStream,
              socket.outputStream,
            )
            .pluginMain()
        } catch (e: Throwable) {
          Log.e("stoic", "unexpected", e)

          // We only close the socket in the event of an exception. Otherwise we want to give
          // the buffering thread(s) a chance to complete their transfers
          socket.close()

          // Bring down the process for non-Exception Throwables
          if (e !is Exception) {
            throw e
          }
        }
      }
    }
  } catch (e: Throwable) {
    Log.e("stoic", "unexpected", e)
    throw e
  }
}

```

`target/app-sdk/src/main/kotlin/com/squareup/stoic/target/runtime/TargetUtils.kt`:

```kt
package com.squareup.stoic.target.runtime

import java.io.File

// Marker file that server creates to signal it's ready
fun serverUpFile(pkgStoicDir: File): File {
  // Needs to match the name in stoic-attach
  return pkgStoicDir.resolve("server-up")
}

```

`target/jvmti-attach/build.gradle.kts`:

```kts
plugins {
  alias(libs.plugins.android.application)
  alias(libs.plugins.kotlin.android)
  alias(libs.plugins.kotlin.serialization)
}

android {
  namespace = "com.squareup.stoic.target.runtime"
  compileSdk = (extra["stoic.android_compile_sdk"] as String).toInt()

  defaultConfig {
    minSdk = (extra["stoic.android_min_sdk"] as String).toInt()
    applicationId = "com.squareup.stoic.jvmti.attach"
  }

  compileOptions {
    val jvmTarget = JavaVersion.toVersion(libs.versions.jvmTarget.get())
    sourceCompatibility = jvmTarget
    targetCompatibility = jvmTarget
  }

  kotlinOptions { jvmTarget = libs.versions.jvmTarget.get() }
}

dependencies { implementation(project(":target:app-sdk")) }

```

`target/jvmti-attach/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- This is a standalone APK loaded via JVMTI for attaching to processes -->
</manifest>

```

`target/jvmti-attach/src/main/kotlin/com/squareup/stoic/target/runtime/AndroidServerJar.kt`:

```kt
package com.squareup.stoic.target.runtime

import android.util.Log
import com.squareup.stoic.StoicJvmti
import com.squareup.stoic.common.LogLevel
import com.squareup.stoic.common.minLogLevel

@Suppress("unused")
fun main(stoicDir: String) {
  Log.i("stoic", "start of AndroidServerJarKt.main")

  minLogLevel = LogLevel.WARN

  // RegisterNatives happened before we were called, so we mark Jvmti as ready to use
  StoicJvmti.markInitialized()

  StoicUnixDomainSocketServer.ensureRunning(stoicDir = stoicDir)
}

```

`target/plugin-sdk/build.gradle.kts`:

```kts
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
  alias(libs.plugins.kotlin.jvm)
  alias(libs.plugins.kotlin.serialization)
  alias(libs.plugins.vanniktech.maven.publish.base)
}

repositories { mavenCentral() }

val androidHome =
  providers.environmentVariable("ANDROID_HOME").orNull
    ?: throw GradleException("ANDROID_HOME is not set")
val androidCompileSdk = extra["stoic.android_compile_sdk"] as String

dependencies {
  implementation(kotlin("stdlib"))
  implementation(libs.kotlinx.serialization.json)
  implementation(libs.jetbrains.kotlin.reflect)
  compileOnly(files("$androidHome/platforms/android-$androidCompileSdk/android.jar"))
}

tasks.withType<KotlinCompile> {
  kotlinOptions {
    jvmTarget = "17"
    // Set API and language version to 1.9 for maximum compatibility with consumers
    // Even though we compile with Kotlin 2.1+, this ensures the generated bytecode
    // and API surface are compatible with projects using Kotlin 1.9+
    apiVersion = "1.9"
    languageVersion = "1.9"
  }
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/ExitCodeException.kt`:

```kt
package com.squareup.stoic

class ExitCodeException(val code: Int) : Exception()

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/Stoic.kt`:

```kt
package com.squareup.stoic

import android.os.Build
import android.os.Handler
import android.os.Looper
import android.os.SystemClock
import com.squareup.stoic.jvmti.BreakpointRequest
import com.squareup.stoic.jvmti.Location
import com.squareup.stoic.jvmti.MethodEntryRequest
import com.squareup.stoic.jvmti.MethodExitRequest
import com.squareup.stoic.jvmti.OnBreakpoint
import com.squareup.stoic.jvmti.OnMethodEntry
import com.squareup.stoic.jvmti.OnMethodExit
import com.squareup.stoic.jvmti.VirtualMachine
import com.squareup.stoic.threadlocals.stoic
import java.io.InputStream
import java.io.PrintStream
import java.util.concurrent.Callable
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executor
import java.util.concurrent.TimeUnit.MILLISECONDS
import java.util.concurrent.TimeoutException
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.atomic.AtomicReference

// internalStoic should only be used in callWith. stoic (as defined in ThreadLocals) should not be
// used
internal val internalStoic = ThreadLocal<Stoic>()

class StoicJvmti private constructor() {
  fun <T> instances(clazz: Class<T>, includeSubclasses: Boolean = true): Array<out T> {
    return VirtualMachine.nativeInstances(clazz, includeSubclasses)
  }

  fun <T> subclasses(clazz: Class<T>): Array<Class<out T>> {
    return VirtualMachine.nativeSubclasses(clazz)
  }

  fun breakpoint(location: Location, onBreakpoint: OnBreakpoint): BreakpointRequest {
    val pluginStoic = stoic
    return VirtualMachine.eventRequestManager.createBreakpointRequest(location) { frame ->
      pluginStoic.callWith { onBreakpoint(frame) }
    }
  }

  fun methodEntries(onMethodEntry: OnMethodEntry): MethodEntryRequest {
    val pluginStoic = stoic
    return VirtualMachine.eventRequestManager.createMethodEntryRequest(Thread.currentThread()) {
      frame ->
      pluginStoic.callWith { onMethodEntry(frame) }
    }
  }

  fun methodExits(onMethodExit: OnMethodExit): MethodExitRequest {
    val pluginStoic = stoic
    return VirtualMachine.eventRequestManager.createMethodExitRequest(Thread.currentThread()) {
      frame,
      value,
      wasPoppedByException ->
      pluginStoic.callWith { onMethodExit(frame, value, wasPoppedByException) }
    }
  }

  val virtualMachine: VirtualMachine
    get() {
      return VirtualMachine
    }

  companion object {
    @Volatile var privateIsInitialized: Boolean = false
    private val stoicJvmti: StoicJvmti = StoicJvmti()
    val isInitialized: Boolean
      get() = privateIsInitialized

    fun get(): StoicJvmti {
      // We'd like to allow for plugins that get run without jvmti, but they'll have to be aware
      // that
      // it's unsafe for them to access jvmti
      assert(isInitialized)
      return stoicJvmti
    }

    // Call this if/when we registerNatives
    fun markInitialized() {
      privateIsInitialized = true
    }
  }
}

class Stoic(
  val contextClassLoader: ClassLoader?,
  val env: Map<String, String>,
  val stdin: InputStream,
  val stdout: PrintStream,
  val stderr: PrintStream,
) {
  companion object {
    const val DEFAULT_TIMEOUT_MS = 60_000L
  }

  val jvmti: StoicJvmti
    get() = StoicJvmti.get()

  // This should be the only place in this file that uses internalStoic
  fun <T> callWith(
    forwardUncaught: Boolean = false,
    printErrors: Boolean = true,
    callable: Callable<T>,
  ): T {
    val oldStoic = internalStoic.get()
    val oldClassLoader = Thread.currentThread().contextClassLoader
    internalStoic.set(this)
    Thread.currentThread().contextClassLoader = contextClassLoader
    try {
      return callable.call()
    } catch (t: Throwable) {
      if (forwardUncaught) {
        // TODO: This should become the default when I have it working
        stderr.println(
          "TODO: forward uncaught exception and bring down the plugin without killing the process"
        )
        if (printErrors) {
          stderr.println(t.stackTraceToString())
        }
        throw t
      } else {
        if (printErrors) {
          stderr.println(t.stackTraceToString())
        }
        throw t
      }
    } finally {
      Thread.currentThread().contextClassLoader = oldClassLoader
      internalStoic.set(oldStoic)
    }
  }

  fun <T> wrapCallable(callable: Callable<T>): Callable<T> {
    return Callable { callWith { callable.call() } }
  }

  fun wrapRunnable(runnable: Runnable): Runnable {
    return Runnable { callWith { runnable.run() } }
  }

  /**
   * runOnLooper/runOnExecutor/thread
   *
   * These provide mechanisms for running stoic plugin code on different threads. These should be
   * used instead of the raw looper/executor/thread APIs because they will handle forwarding the
   * stoic thread-local, and reporting uncaught exceptions to stderr.
   *
   * They also provide an optional timeoutMs that can be used to wait for the asynchronous operation
   * to complete. If timeoutMs is provided then any Throwable will be caught and printed to stderr.
   *
   * TODO: Run-delayed and Future variants
   *
   * If you are using a custom async mechanism you can provide support for it by using using
   * wrapRunnable (for non-blocking behavior) or LatchedRunnable (for blocking)
   */
  fun runOnLooper(looper: Looper, timeoutMs: Long? = DEFAULT_TIMEOUT_MS, runnable: Runnable) {
    if (timeoutMs != null) {
      val latchedRunnable = LatchedRunnable(this, runnable)
      Handler(looper).post(latchedRunnable)
      latchedRunnable.waitFor(timeoutMs)
    } else {
      Handler(looper).post(wrapRunnable(runnable))
    }
  }

  fun runOnMainLooper(timeoutMs: Long? = DEFAULT_TIMEOUT_MS, runnable: Runnable) {
    runOnLooper(Looper.getMainLooper(), timeoutMs, runnable)
  }

  fun runOnExecutor(executor: Executor, timeoutMs: Long? = DEFAULT_TIMEOUT_MS, runnable: Runnable) {
    if (timeoutMs != null) {
      val latchedRunnable = LatchedRunnable(this, runnable)
      executor.execute(latchedRunnable)
      latchedRunnable.waitFor(timeoutMs)
    } else {
      executor.execute(wrapRunnable(runnable))
    }
  }

  fun thread(timeoutMs: Long? = DEFAULT_TIMEOUT_MS, runnable: Runnable): Thread {
    if (timeoutMs != null) {
      val latchedRunnable = LatchedRunnable(this, runnable)
      val t = rawStoicThread(latchedRunnable)
      latchedRunnable.waitFor(timeoutMs)
      return t // The thread will be done by this time
    } else {
      return kotlin.concurrent.thread { wrapRunnable(runnable).run() }
    }
  }

  private fun rawStoicThread(runnable: Runnable): Thread {
    return kotlin.concurrent.thread { callWith { runnable.run() } }
  }

  fun getenv(name: String): String? {
    return env[name] ?: System.getenv(name)
  }

  /**
   * The src path of the shebang script used to invoke stoic, or null if stoic wasn't invoked via a
   * shebang.
   */
  val shebangSrcPath: String?
    get() {
      return getenv("STOIC_SHEBANG_SRC_PATH")
    }

  // It'd be nice to allow plugins to use System.in/out/err directly, but it's easy to end up with
  // weird problems when you System.setOut/setErr so I abandoned this approach. I'd need to be
  // careful I didn't write to System.err anywhere. Here's a StackOverflowError I encountered
  // (it's worse because I catch Throwable and print the result to stderr so I wasn't even seeing
  // that). So I abandoned this approach.
  // TODO: Allow plugins to use System.in/out/err by rewriting their bytecode, AOP-style to use
  // thread-local stdin/stdout/sterr that get propagated by runWithStoic.
  //
  //  ...
  //	at java.io.PrintStream.write(PrintStream.java:503)
  //	at com.squareup.stoic.ThreadLocalOutputStream.write(Stoic.kt:141)
  //	at java.io.PrintStream.write(PrintStream.java:503)
  //	at com.squareup.stoic.ThreadLocalOutputStream.write(Stoic.kt:141)
  //	at java.io.PrintStream.write(PrintStream.java:503)
  // 	at com.squareup.stoic.ThreadLocalOutputStream.write(Stoic.kt:141)
  // 	at java.io.PrintStream.write(PrintStream.java:503)
  // 	at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)
  // 	at sun.nio.cs.StreamEncoder.implWrite(StreamEncoder.java:282)
  // 	at sun.nio.cs.StreamEncoder.write(StreamEncoder.java:125)
  // 	at java.io.OutputStreamWriter.write(OutputStreamWriter.java:207)
  // 	at java.io.BufferedWriter.flushBuffer(BufferedWriter.java:129)
  // 	at java.io.PrintStream.write(PrintStream.java:553)
  // 	at java.io.PrintStream.print(PrintStream.java:698)
  // 	at java.io.PrintStream.println(PrintStream.java:835)
  // 	at com.squareup.stoic.common.StoicKt.log(Stoic.kt:23)
  // 	at com.squareup.stoic.common.StoicKt.logDebug(Stoic.kt:28)
  // 	at com.squareup.stoic.common.NamedPipeServer.accept(NamedPipeServer.kt:135)
  // 	at com.squareup.stoic.target.runtime.AndroidServerJarKt.main(AndroidServerJar.kt:51)
  //

  fun exitPlugin(code: Int) {
    throw ExitCodeException(code)
  }
}

/**
 * A runnable that waits for itself to run. This is used to run code "asynchronously" and wait for
 * it to complete.
 */
class LatchedRunnable(stoicInstance: Stoic, runnable: Runnable) : Runnable {
  private val wrappedRunnable = stoicInstance.wrapRunnable(runnable)
  private val startUptimeMillis = SystemClock.uptimeMillis()
  private val runnableStartUptimeMillisAtomic = AtomicLong(-1)
  private val latch = CountDownLatch(1)
  private val crash = AtomicReference<Throwable>()
  private val ranOnThread = AtomicReference<Thread>()

  override fun run() {
    runnableStartUptimeMillisAtomic.set(SystemClock.uptimeMillis())
    ranOnThread.set(Thread.currentThread())
    try {
      wrappedRunnable.run()
    } catch (t: Throwable) {
      crash.set(t)
    } finally {
      latch.countDown()
    }
  }

  fun waitFor(timeoutMs: Long) {
    if (!latch.await(timeoutMs, MILLISECONDS)) {
      val runnableStartUptimeMillis = runnableStartUptimeMillisAtomic.get()
      val msg =
        if (runnableStartUptimeMillis <= 0) {
          "Unable to schedule $wrappedRunnable within ${timeoutMs}ms"
        } else {
          val scheduleDelay = runnableStartUptimeMillis - startUptimeMillis
          "$wrappedRunnable (scheduled after ${scheduleDelay}ms) did not complete within ${timeoutMs}ms"
        }
      throw TimeoutException(msg).also { e ->
        ranOnThread.get()?.stackTrace?.also { e.stackTrace = it }
      }
    }
  }
}

// Could be useful to someone writing code that runs on either Android/JVM
val isAndroid =
  try {
    Build.VERSION.SDK_INT > -1
  } catch (e: Throwable) {
    false
  }

fun <T> highlander(list: List<T>): T {
  if (list.size != 1) {
    throw IllegalArgumentException("There can be only one: $list")
  }

  return list[0]
}

class Stack(stackTrace: Array<StackTraceElement>) : Throwable() {
  constructor(stackTrace: List<StackTraceElement>) : this(stackTrace.toTypedArray())

  init {
    this.stackTrace = stackTrace
  }
}

class LruCache<K, V>(private val cacheSize: Int) : LinkedHashMap<K, V>(cacheSize, 0.75f, true) {
  override fun removeEldestEntry(eldest: Map.Entry<K, V>): Boolean {
    // Remove the eldest entry if the size exceeds the predefined cache size
    return size > cacheSize
  }
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/helpers/Helpers.kt`:

```kt
/**
 * This package provides safe replacements for operations that don't make sense inside of a Stoic
 * plugin. For example, if you call Kotlin's println, the output will go to logcat. The println here
 * will send its output to the plugin's stdout.
 */
package com.squareup.stoic.helpers

import android.os.Looper
import com.squareup.stoic.threadlocals.stoic
import java.util.concurrent.Executor

fun println(x: Any?) = stoic.stdout.println(x)

fun print(x: Any?) = stoic.stdout.print(x)

fun eprintln(x: Any?) = stoic.stderr.println(x)

fun eprint(x: Any?) = stoic.stderr.print(x)

/** Exit the plugin with the given exit code. */
fun exit(code: Int) = stoic.exitPlugin(code)

fun exitPlugin(code: Int) = stoic.exitPlugin(code)

fun exitProcess(code: Int) = stoic.exitPlugin(code)

/**
 * Create a new thread, calling kotlin.concurrent.thread under the covers, but connecting the stoic
 * thread-local with that thread so any code run on it will be connected to the current plugin
 */
fun thread(runnable: Runnable) = stoic.thread(runnable = runnable)

fun runOnMainLooper(runnable: Runnable) = stoic.runOnMainLooper(runnable = runnable)

fun runOnLooper(looper: Looper, runnable: Runnable) =
  stoic.runOnLooper(looper = looper, runnable = runnable)

fun runOnExecutor(executor: Executor, runnable: Runnable) =
  stoic.runOnExecutor(executor = executor, runnable = runnable)

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/BreakpointRequest.kt`:

```kt
package com.squareup.stoic.jvmti

typealias OnBreakpoint = (frame: StackFrame) -> Unit

/**
 * Analogous to
 * https://docs.oracle.com/javase/8/docs/jdk/api/jpda/jdi/com/sun/jdi/request/EventRequest.html
 */
class BreakpointRequest(val location: Location, val callback: OnBreakpoint) : EventRequest() {}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/BreakpointResult.kt`:

```kt
package com.squareup.stoic.jvmti

const val TYPE_VOID = 'V'
const val TYPE_BOOLEAN = 'Z'
const val TYPE_BYTE = 'B'
const val TYPE_SHORT = 'S'
const val TYPE_INT = 'I'
const val TYPE_LONG = 'J'
const val TYPE_FLOAT = 'F'
const val TYPE_DOUBLE = 'D'
const val TYPE_OBJECT = 'L'

class BreakpointResult(val forceEarlyReturn: Any, val type: Char)

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/Event.kt`:

```kt
package com.squareup.stoic.jvmti

class Event {}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/EventRequest.kt`:

```kt
package com.squareup.stoic.jvmti

/**
 * Analogous to
 * https://docs.oracle.com/javase/8/docs/jdk/api/jpda/jdi/com/sun/jdi/request/EventRequest.html
 */
open class EventRequest {
  var wasClosed = false

  fun close() {
    VirtualMachine.eventRequestManager.deleteEventRequest(this)
    wasClosed = true
  }
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/EventRequestManager.kt`:

```kt
package com.squareup.stoic.jvmti

/**
 * Analogous to
 * https://docs.oracle.com/javase/8/docs/jdk/api/jpda/jdi/com/sun/jdi/request/EventRequestManager.html
 */
class EventRequestManager {
  // These are guarded by the `this` lock. We copy on each traversal inside the lock, and then call
  // the callbacks outside of the lock. We check each callback to make sure it wasn't closed before
  // calling it.
  //
  // TODO: wasClosed should be volatile
  // TODO: lifetimes should be tied to the plugin -
  //   when a plugin dies, its event requests should automatically unregister
  // TODO: there is too much boilerplate for each request type -
  //   find a way to share code amongst the create*/delete* implementations

  private val breakpointRequests =
    mutableMapOf<Pair<JMethodId, JLocation>, MutableList<BreakpointRequest>>()
  private val methodEntryRequests = mutableMapOf<Thread, MutableList<MethodEntryRequest>>()
  private val methodExitRequests = mutableMapOf<Thread, MutableList<MethodExitRequest>>()

  @Synchronized
  fun createBreakpointRequest(location: Location, callback: OnBreakpoint): BreakpointRequest {
    val key = Pair(location.method.methodId, location.jlocation)
    var list = breakpointRequests[key]
    if (list == null) {
      list = mutableListOf()
      breakpointRequests[key] = list
    }
    val request = BreakpointRequest(location, callback)

    if (list.size == 0) {
      VirtualMachine.nativeSetBreakpoint(location.method.methodId, location.jlocation)
    }

    list.add(request)

    return request
  }

  @Synchronized
  fun createMethodEntryRequest(thread: Thread, callback: OnMethodEntry): MethodEntryRequest {
    var list = methodEntryRequests[thread]
    if (list == null) {
      list = mutableListOf()
      methodEntryRequests[thread] = list
    }
    val request = MethodEntryRequest(thread, callback)
    if (list.size == 0) {
      VirtualMachine.nativeMethodEntryCallbacks(thread, true)
    }
    list.add(request)

    return request
  }

  @Synchronized
  fun createMethodExitRequest(thread: Thread, callback: OnMethodExit): MethodExitRequest {
    var list = methodExitRequests[thread]
    if (list == null) {
      list = mutableListOf()
      methodExitRequests[thread] = list
    }
    val request = MethodExitRequest(thread, callback)
    if (list.size == 0) {
      VirtualMachine.nativeMethodExitCallbacks(thread, true)
    }
    list.add(request)

    return request
  }

  fun deleteEventRequest(request: EventRequest) {
    when (request) {
      is BreakpointRequest -> deleteBreakpointRequest(request)
      is MethodEntryRequest -> deleteMethodEntryRequest(request)
      is MethodExitRequest -> deleteMethodExitRequest(request)
      else -> TODO()
    }
  }

  @Synchronized
  fun deleteBreakpointRequest(request: BreakpointRequest) {
    val location = request.location
    val key = Pair(location.method.methodId, location.jlocation)
    val list = breakpointRequests[key]

    // You shouldn't be able to delete a breakpoint unless you never set it before
    check(list != null)

    val sizeBefore = list.size

    list.remove(request)

    if (sizeBefore != 0 && list.size == 0) {
      VirtualMachine.nativeClearBreakpoint(location.method.methodId, location.jlocation)
    }
  }

  @Synchronized
  fun deleteMethodEntryRequest(request: MethodEntryRequest) {
    val list = methodEntryRequests[request.thread]
    check(list != null)
    val sizeBefore = list.size
    list.remove(request)
    if (sizeBefore != 0 && list.size == 0) {
      VirtualMachine.nativeMethodEntryCallbacks(request.thread, false)
    }
  }

  @Synchronized
  fun deleteMethodExitRequest(request: MethodExitRequest) {
    var list = methodExitRequests[request.thread]
    check(list != null)
    val sizeBefore = list.size
    list.remove(request)
    if (sizeBefore != 0 && list.size == 0) {
      VirtualMachine.nativeMethodExitCallbacks(request.thread, false)
    }
  }

  fun onBreakpoint(frame: StackFrame) {
    var requests: List<BreakpointRequest>
    synchronized(this) {
      val location = frame.location
      val key = Pair(location.method.methodId, location.jlocation)
      // This should always be non-null because we should only be getting callbacks for requests we
      // set previously. Due to race conditions it might be empty
      requests = breakpointRequests[key]!!.toList()
    }

    for (request in requests) {
      if (!request.wasClosed) {
        request.callback(frame)
      }
    }
  }

  fun onMethodEntry(frame: StackFrame) {
    var requests: List<MethodEntryRequest>
    synchronized(this) {
      // This should always be non-null because we should only be getting callbacks for requests we
      // set previously.
      requests = methodEntryRequests[Thread.currentThread()]!!.toList()
    }

    for (request in requests) {
      if (!request.wasClosed) {
        request.callback(frame)
      }
    }
  }

  fun onMethodExit(frame: StackFrame, value: Any?, wasPoppedByException: Boolean) {
    var requests: List<MethodExitRequest>
    synchronized(this) {
      // This should always be non-null because we should only be getting callbacks for requests we
      // set previously.
      requests = methodExitRequests[Thread.currentThread()]!!.toList()
    }

    for (request in requests) {
      if (!request.wasClosed) {
        request.callback(frame, value, wasPoppedByException)
      }
    }
  }
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/Jvmti.kt`:

```kt
package com.squareup.stoic.jvmti

import com.squareup.stoic.threadlocals.jvmti
import java.lang.reflect.Method
import kotlin.reflect.KFunction
import kotlin.reflect.jvm.javaMethod

fun KFunction<*>.forEachInvocation(block: (frame: StackFrame) -> Unit) {
  this.javaMethod!!.forEachInvocation { frame -> block(frame) }
}

fun Method.forEachInvocation(block: (frame: StackFrame) -> Unit) {
  val methodId = VirtualMachine.nativeFromReflectedMethod(this)
  val jvmtiMethod = JvmtiMethod[methodId]
  val location = jvmtiMethod.startLocation
  jvmti.breakpoint(location) { frame -> block(frame) }
}

fun JvmtiMethod.forEachInvocation(block: (frame: StackFrame) -> Unit) {
  jvmti.breakpoint(startLocation) { frame -> block(frame) }
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/JvmtiClass.kt`:

```kt
package com.squareup.stoic.jvmti

import com.squareup.stoic.LruCache
import com.squareup.stoic.highlander

class JvmtiClass private constructor(val clazz: Class<*>) {
  private var privateDeclaredFields: List<JvmtiField>? = null
  private var privateDeclaredMethods: List<JvmtiMethod>? = null

  val simpleName
    get(): String = clazz.name.substringAfterLast('.')

  val declaredFields
    get(): List<JvmtiField> {
      synchronized(this) {
        return privateDeclaredFields
          ?: run {
            val result = VirtualMachine.nativeGetClassFields(clazz).toList()
            privateDeclaredFields = result
            result
          }
      }
    }

  val declaredMethods
    get(): List<JvmtiMethod> {
      synchronized(this) {
        return privateDeclaredMethods
          ?: run {
            val result = VirtualMachine.nativeGetClassMethods(clazz).toList()
            privateDeclaredMethods = result
            result
          }
      }
    }

  fun declaredMethod(name: String, signature: String): JvmtiMethod {
    val filteredMethods = declaredMethods.filter { it.name == name && it.signature == signature }
    if (filteredMethods.isNotEmpty()) {
      return highlander(filteredMethods)
    }

    val filteredByName = declaredMethods.filter { it.name == name }
    if (filteredByName.isNotEmpty()) {
      val signatures = filteredByName.map { "${it.signature}\n" }
      throw NoSuchMethodException(
        """
          Method ${clazz.name}.$name$signature does not exist. ${clazz.name}.$name with the
          following signatures exist:
        """
          .trimIndent() + "\n$signatures"
      )
    } else {
      val methodNames = declaredMethods.map { "${it.name}\n" }.toSet()
      throw NoSuchMethodException(
        """
            Method $clazz.$name does not exist. $clazz has declared methods with the following names:
          """
          .trimIndent() + "\n$methodNames"
      )
    }
  }

  fun declaredField(name: String, signature: String): JvmtiField {
    return highlander(declaredFields.filter { it.name == name && it.signature == signature })
  }

  companion object {
    private val cache = LruCache<Class<*>, JvmtiClass>(8192)

    @Synchronized
    operator fun get(clazz: Class<*>): JvmtiClass {
      var jvmtiClass = cache[clazz]
      if (jvmtiClass == null) {
        jvmtiClass = JvmtiClass(clazz)
        cache[clazz] = jvmtiClass
      }

      return jvmtiClass
    }

    fun bySig(signature: String, classLoader: ClassLoader? = null): JvmtiClass {
      when (signature) {
        "Z" -> return JvmtiClass[Boolean::class.java]
        "I" -> return JvmtiClass[Int::class.java]
        "J" -> return JvmtiClass[Long::class.java]
      }

      val classNameWithDots = signature.replace('/', '.')
      val className =
        if (classNameWithDots.endsWith(';')) {
          classNameWithDots.removePrefix("L").removeSuffix(";")
        } else {
          classNameWithDots
        }

      val clazz =
        if (classLoader == null) {
          Thread.currentThread().contextClassLoader.loadClass(className)
        } else {
          classLoader.loadClass(className)
        }
      return JvmtiClass[clazz]
    }
  }
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/JvmtiException.kt`:

```kt
package com.squareup.stoic.jvmti

// No error has occurred. This is the error code that is returned on successful completion of the
// function.
const val JVMTI_ERROR_NONE = 0

// Pointer is unexpectedly NULL.
const val JVMTI_ERROR_NULL_POINTER = 100

// The function attempted to allocate memory and no more memory was available for allocation.
const val JVMTI_ERROR_OUT_OF_MEMORY = 110

// The desired functionality has not been enabled in this virtual machine.
const val JVMTI_ERROR_ACCESS_DENIED = 111

// The thread being used to call this function is not attached to the virtual machine. Calls must be
// made from attached threads. See AttachCurrentThread in the JNI invocation API.
const val JVMTI_ERROR_UNATTACHED_THREAD = 115

// The JVM TI environment provided is no longer connected or is not an environment.
const val JVMTI_ERROR_INVALID_ENVIRONMENT = 116

// The desired functionality is not available in the current phase. Always returned if the virtual
// machine has completed running.
const val JVMTI_ERROR_WRONG_PHASE = 112

// An unexpected internal error has occurred.
const val JVMTI_ERROR_INTERNAL = 113

//
// Function Specific Required Errors
// The following errors are returned by some JVM TI functions and must be returned by the
// implementation when the condition occurs.
//

// Invalid priority.
const val JVMTI_ERROR_INVALID_PRIORITY = 12

// Thread was not suspended.
const val JVMTI_ERROR_THREAD_NOT_SUSPENDED = 13

// Thread already suspended.
const val JVMTI_ERROR_THREAD_SUSPENDED = 14

// This operation requires the thread to be alive--that is, it must be started and not yet have
// died.
const val JVMTI_ERROR_THREAD_NOT_ALIVE = 15

// The class has been loaded but not yet prepared.
const val JVMTI_ERROR_CLASS_NOT_PREPARED = 22

// There are no Java programming language or JNI stack frames at the specified depth.
const val JVMTI_ERROR_NO_MORE_FRAMES = 31

// Information about the frame is not available (e.g. for native frames).
const val JVMTI_ERROR_OPAQUE_FRAME = 32

// Item already set.
const val JVMTI_ERROR_DUPLICATE = 40

// Desired element (e.g. field or breakpoint) not found
const val JVMTI_ERROR_NOT_FOUND = 41

// This thread doesn't own the raw monitor.
const val JVMTI_ERROR_NOT_MONITOR_OWNER = 51

// The call has been interrupted before completion.
const val JVMTI_ERROR_INTERRUPT = 52

// The class cannot be modified.
const val JVMTI_ERROR_UNMODIFIABLE_CLASS = 79

// The functionality is not available in this virtual machine.
const val JVMTI_ERROR_NOT_AVAILABLE = 98

// The requested information is not available.
const val JVMTI_ERROR_ABSENT_INFORMATION = 101

// The specified event type ID is not recognized.
const val JVMTI_ERROR_INVALID_EVENT_TYPE = 102

// The requested information is not available for native method.
const val JVMTI_ERROR_NATIVE_METHOD = 104

// The class loader does not support this operation.
const val JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED = 106

//
// Function Specific Agent Errors
// The following errors are returned by some JVM TI functions. They are returned in the event of
// invalid parameters passed by the agent or usage in an invalid context. An implementation is not
// required to detect these errors.
//

// The passed thread is not a valid thread.
const val JVMTI_ERROR_INVALID_THREAD = 10

// Invalid field.
const val JVMTI_ERROR_INVALID_FIELDID = 25

// Invalid method.
const val JVMTI_ERROR_INVALID_METHODID = 23

// Invalid location.
const val JVMTI_ERROR_INVALID_LOCATION = 24

// Invalid object.
const val JVMTI_ERROR_INVALID_OBJECT = 20

// Invalid class.
const val JVMTI_ERROR_INVALID_CLASS = 21

// The variable is not an appropriate type for the function used.
const val JVMTI_ERROR_TYPE_MISMATCH = 34

// Invalid slot.
const val JVMTI_ERROR_INVALID_SLOT = 35

// The capability being used is false in this environment.
const val JVMTI_ERROR_MUST_POSSESS_CAPABILITY = 99

// Thread group invalid.
const val JVMTI_ERROR_INVALID_THREAD_GROUP = 11

// Invalid raw monitor.
const val JVMTI_ERROR_INVALID_MONITOR = 50

// Illegal argument.
const val JVMTI_ERROR_ILLEGAL_ARGUMENT = 103

// The state of the thread has been modified, and is now inconsistent.
const val JVMTI_ERROR_INVALID_TYPESTATE = 65

// A new class file has a version number not supported by this VM.
const val JVMTI_ERROR_UNSUPPORTED_VERSION = 68

// A new class file is malformed (the VM would return a ClassFormatError).
const val JVMTI_ERROR_INVALID_CLASS_FORMAT = 60

// The new class file definitions would lead to a circular definition (the VM would return a
// ClassCircularityError).
const val JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION = 61

// A new class file would require adding a method.
const val JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED = 63

// A new class version changes a field.
const val JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED = 64

// The class bytes fail verification.
const val JVMTI_ERROR_FAILS_VERIFICATION = 62

// A direct superclass is different for the new class version, or the set of directly implemented
// interfaces is different.
const val JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED = 66

// A new class version does not declare a method declared in the old class version.
const val JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED = 67

// The class name defined in the new class file is different from the name in the old class object.
const val JVMTI_ERROR_NAMES_DONT_MATCH = 69

// A new class version has different modifiers.
const val JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED = 70

// A method in the new class version has different modifiers than its counterpart in the old class
// version.
const val JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED = 71

class JvmtiException(val errorCode: Int, desc: String) : Exception("$desc: $errorCode")

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/JvmtiField.kt`:

```kt
package com.squareup.stoic.jvmti

import com.squareup.stoic.LruCache
import java.lang.reflect.Modifier

class JvmtiField private constructor(val clazz: Class<*>, val fieldId: JFieldId) {
  // These are fetched by nativeGetFieldCoreMetadata
  private var privateName: String? = null
  private var privateSignature: String? = null
  private var privateGeneric: String? = null
  private var privateModifiers: Int = -1

  val name: String
    get() {
      val result = privateName
      if (result != null) {
        return result
      }

      VirtualMachine.nativeGetFieldCoreMetadata(this)
      return privateName!!
    }

  val signature: String
    get() {
      val result = privateSignature
      if (result != null) {
        return result
      }

      VirtualMachine.nativeGetFieldCoreMetadata(this)
      return privateSignature!!
    }

  val modifiers: Int
    get() {
      val result = privateModifiers
      if (result != -1) {
        return result
      }

      VirtualMachine.nativeGetFieldCoreMetadata(this)
      return privateModifiers
    }

  fun get(obj: Any?): Any? {
    val reflected =
      VirtualMachine.nativeToReflectedField(clazz, fieldId, Modifier.isStatic(modifiers))
    reflected.isAccessible = true
    return reflected.get(obj)
  }

  fun set(obj: Any?, value: Any?) {
    val reflected =
      VirtualMachine.nativeToReflectedField(clazz, fieldId, Modifier.isStatic(modifiers))
    reflected.isAccessible = true
    reflected.set(obj, value)
  }

  companion object {
    private val cache = LruCache<JFieldId, JvmtiField>(8192)

    @Synchronized
    operator fun get(clazz: Class<*>, fieldId: JFieldId): JvmtiField {
      var field = cache[fieldId]
      if (field == null) {
        field = JvmtiField(clazz, fieldId)
        cache[fieldId] = field
      }

      return field
    }
  }
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/JvmtiMethod.kt`:

```kt
package com.squareup.stoic.jvmti

import com.squareup.stoic.LruCache
import com.squareup.stoic.highlander
import java.lang.reflect.Constructor
import java.lang.reflect.Method
import java.lang.reflect.Modifier

/**
 * Analogous to https://docs.oracle.com/javase/8/docs/jdk/api/jpda/jdi/com/sun/jdi/Method.html
 *
 * See https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html#method for JVMTI method
 * functions
 */
class JvmtiMethod private constructor(val methodId: JMethodId) {
  init {
    check(methodId != 0L)
  }

  // These are fetched by nativeGetMethodCoreMetadata
  private var privateClazz: Class<*>? = null
  private var privateName: String? = null
  private var privateSignature: String? = null
  private var privateGeneric: String? = null
  private var privateStartLocation: JLocation = Long.MIN_VALUE
  private var privateEndLocation: JLocation = Long.MIN_VALUE
  private var privateArgsSize = Int.MIN_VALUE
  private var privateMaxLocals = Int.MIN_VALUE
  private var privateModifiers: Int = -1
  private var privateReflected: Any? = null

  // This is fetched by nativeGetLocalVariables(jmethodId).toList()
  private var privateVariables: List<LocalVariable<*>>? = null

  val clazz: Class<*>
    get() {
      val result = privateClazz
      if (result != null) {
        return result
      }

      VirtualMachine.nativeGetMethodCoreMetadata(this)
      return privateClazz!!
    }

  val name: String
    get() {
      val result = privateName
      if (result != null) {
        return result
      }

      VirtualMachine.nativeGetMethodCoreMetadata(this)
      return privateName!!
    }

  val signature: String
    get() {
      val result = privateSignature
      if (result != null) {
        return result
      }

      VirtualMachine.nativeGetMethodCoreMetadata(this)
      return privateSignature!!
    }

  /** The start of the method */
  val startLocation
    get(): Location {
      val result = privateStartLocation
      if (result != Long.MIN_VALUE) {
        return Location(this, result)
      }

      VirtualMachine.nativeGetMethodCoreMetadata(this)
      return Location(this, privateStartLocation)
    }

  val argsSize
    get(): Int {
      val result = privateArgsSize
      if (result != Int.MIN_VALUE) {
        return result
      }

      VirtualMachine.nativeGetMethodCoreMetadata(this)
      return privateArgsSize
    }

  val maxLocals
    get(): Int {
      val result = privateMaxLocals
      if (result != Int.MIN_VALUE) {
        return result
      }

      VirtualMachine.nativeGetMethodCoreMetadata(this)
      return privateMaxLocals
    }

  val modifiers
    get(): Int {
      val result = privateModifiers
      if (result != -1) {
        return result
      }

      // -1 is an invalid value for modifiers (it's all modifiers set), so if we see -1 we know we
      // need to fetch
      VirtualMachine.nativeGetMethodCoreMetadata(this)
      return privateModifiers
    }

  val reflected
    get(): Any {
      val result = privateReflected
      if (result != null) {
        return result
      }

      val lookup =
        VirtualMachine.nativeToReflectedMethod(clazz, methodId, Modifier.isStatic(modifiers))
      privateReflected = lookup
      return lookup
    }

  val arguments: List<LocalVariable<*>>
    get() {
      try {
        return variables.filter { it.slot >= maxLocals - argsSize }
      } catch (e: JvmtiException) {
        if (e.errorCode != JVMTI_ERROR_ABSENT_INFORMATION) {
          throw e
        }

        val methodOrCtor = VirtualMachine.nativeToReflectedMethod(clazz, methodId, false)
        val parameterTypes =
          if (methodOrCtor is Constructor<*>) {
            methodOrCtor.parameterTypes
          } else {
            (methodOrCtor as Method).parameterTypes
          }
        var slot = maxLocals - argsSize
        val vars = mutableListOf<LocalVariable<*>>()
        for (param in parameterTypes) {
          val slotSize =
            when (param) {
              java.lang.Long.TYPE,
              java.lang.Double.TYPE -> 2
              else -> 1
            }
          vars.add(
            LocalVariable<Any>(
              0,
              1,
              null,
              VirtualMachine.nativeGetClassSignature(param),
              null,
              slot,
            )
          )

          slot += slotSize
        }

        return vars
      }
    }

  @get:Synchronized
  val variables: List<LocalVariable<*>>
    get() {
      val result = privateVariables
      if (result != null) {
        return result
      }

      // We need to remove duplicate variables (ones that have the same slot), preferring ones with
      // non-null names. See testDuplicateArguments for an example of a method with duplicate
      // variables. We prefer named variables.
      val locals = VirtualMachine.nativeGetLocalVariables(methodId)
      val slotToIndex = mutableMapOf<Int, Int>()
      for (i in locals.indices) {
        val slot = locals[i].slot
        val dupeIndex = slotToIndex[slot]
        if (dupeIndex == null) {
          slotToIndex[slot] = i
          continue
        }

        if (locals[dupeIndex].name == null && locals[i].name != null) {
          slotToIndex[slot] = i
        }
      }

      privateVariables = slotToIndex.entries.sortedBy { it.key }.map { locals[it.value] }

      return privateVariables!!
    }

  fun variablesByName(name: String): List<LocalVariable<*>> {
    return variables.filter { it.name == name }
  }

  fun <T> argumentByName(name: String): LocalVariable<T> {
    return highlander(arguments.filter { it.name == name }) as LocalVariable<T>
  }

  fun invokeStatic(vararg args: Any?): Any? {
    return (reflected as java.lang.reflect.Method).invoke(null, *args)
  }

  fun invokeCtor(vararg args: Any?): Any? {
    return (reflected as Constructor<*>).newInstance(*args)
  }

  fun invokeNormal(thiz: Any, vararg args: Any?): Any? {
    return (reflected as java.lang.reflect.Method).invoke(thiz, *args)
  }

  val jvmtiClass
    get() = JvmtiClass[clazz]

  val simpleQualifiedName = "${jvmtiClass.simpleName}.$name"

  override fun toString(): String {
    return "JvmtiMethod($simpleQualifiedName$signature)"
  }

  companion object {
    private val cache = LruCache<JMethodId, JvmtiMethod>(8192)

    @Synchronized
    operator fun get(methodId: JMethodId): JvmtiMethod {
      var method = cache[methodId]
      if (method == null) {
        method = JvmtiMethod(methodId)
        cache[methodId] = method
      }

      return method
    }

    fun bySig(sig: String): JvmtiMethod {
      val match = Regex("""([^.]+)\.(\w+)(\([^()]*\)[^()]*)""").matchEntire(sig)
      check(match != null) { "Invalid sig: '$sig'" }
      val classSig = match.groupValues[1]
      val methodName = match.groupValues[2]
      val methodSig = match.groupValues[3]
      return JvmtiClass.bySig(classSig).declaredMethod(methodName, methodSig)
    }
  }
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/LocalVariable.kt`:

```kt
package com.squareup.stoic.jvmti

/**
 * Analog to https://docs.oracle.com/javase/8/docs/jdk/api/jpda/jdi/com/sun/jdi/LocalVariable.html
 *
 * This maps directly to the jvmtiLocalVariableEntry struct - it's populated via a call to JVMTI's
 * GetLocalVariableTable
 */
class LocalVariable<T>(
  val startLocation: JLocation,
  val length: Int,
  val name: String?,
  val signature: String,
  val genericSignature: String?,
  val slot: Int,
) {}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/Locatable.kt`:

```kt
package com.squareup.stoic.jvmti

/** Analog of https://docs.oracle.com/javase/8/docs/jdk/api/jpda/jdi/com/sun/jdi/Locatable.html */
interface Locatable {
  fun location(): Location
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/Location.kt`:

```kt
package com.squareup.stoic.jvmti

/** Analogous to https://docs.oracle.com/javase/8/docs/jdk/api/jpda/jdi/com/sun/jdi/Location.html */
class Location(val method: JvmtiMethod, val jlocation: JLocation) {
  override fun toString(): String {
    return "Location(method=$method, jlocation=$jlocation)"
  }
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/MethodEntryRequest.kt`:

```kt
package com.squareup.stoic.jvmti

typealias OnMethodEntry = (frame: StackFrame) -> Unit

class MethodEntryRequest(val thread: Thread, val callback: OnMethodEntry) : EventRequest() {}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/MethodExitRequest.kt`:

```kt
package com.squareup.stoic.jvmti

typealias OnMethodExit = (frame: StackFrame, value: Any?, wasPoppedByException: Boolean) -> Unit

class MethodExitRequest(val thread: Thread, val callback: OnMethodExit) : EventRequest() {}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/StackFrame.kt`:

```kt
package com.squareup.stoic.jvmti

import com.squareup.stoic.threadlocals.jvmti

/**
 * Analog of https://docs.oracle.com/javase/8/docs/jdk/api/jpda/jdi/com/sun/jdi/StackFrame.html
 *
 * This represents a pointer to the Thread's stack frame. When the actual stack frame gets popped
 * this pointer to it becomes invalid, though in practice ART's JVMTI implementation seems pretty
 * good at generating reasonable error messages when you use it after it becomes invalid.
 *
 * The pointer is just the pair of (Thread, frame-height), so if the exact same frame (that is, same
 * method-id, location) then everything will work fine. I'd say it's hacky to depend on that though!
 *
 * TODO: this needs to be rethought - the location currently doesn't necessarily match the height
 *   within the stack. The reason is that the location might correspond to a call (e.g.
 *   method-entry) without a corresponding stack frame. This can happen for example when a native
 *   method is invoked.
 */
class StackFrame(val thread: Thread, val height: Int, val location: Location) {
  val stackTrace
    get(): List<StackTraceElement> {
      return thread.stackTrace.takeLast(height)
    }

  override fun toString(): String {
    return "StackFrame(thread=$thread, location=$location)"
  }

  fun <T> get(variable: LocalVariable<T>): T {
    val thread = Thread.currentThread()
    when (variable.signature) {
      "I",
      "Z",
      "B",
      "S" -> {
        val intRepr = VirtualMachine.nativeGetLocalInt(thread, height, variable.slot)
        return when (variable.signature) {
          "I" -> intRepr
          "Z" -> (intRepr != 0)
          "B" -> intRepr.toByte()
          "S" -> intRepr.toShort()
          else -> throw Throwable("Impossible")
        }
          as T
      }
      "J" -> return VirtualMachine.nativeGetLocalLong(thread, height, variable.slot) as T
      "F" -> return VirtualMachine.nativeGetLocalFloat(thread, height, variable.slot) as T
      "D" -> return VirtualMachine.nativeGetLocalDouble(thread, height, variable.slot) as T
      else -> {
        check(variable.signature.startsWith("L") || variable.signature.startsWith("["))
        return VirtualMachine.nativeGetLocalObject(thread, height, variable.slot) as T
      }
    }
  }

  fun <T> set(variable: LocalVariable<T>, value: T) {
    TODO()
  }

  /**
   * Get a callback when the frame exits.
   *
   * Note: This implementation is based on the MethodExit callback rather than the NotifyFramePop
   * callback. The latter is probably more efficient because it only generates a callback for the
   * frame we are interested in, but it doesn't provide access to the return value.
   *
   * If performance is problematic we could either
   * 1. Expose NotifyFramePop separately, or
   * 2. Filter out callbacks at the native layer
   */
  fun onExit(callback: OnMethodExit) {
    var exitRequest: MethodExitRequest? = null
    exitRequest =
      jvmti.methodExits { frame, value, wasPoppedByException ->
        // In the case of wasPoppedByException=true we may not see a method exit for the current
        // frame
        // Or maybe we see the exit, but its after the frame has already been popped. This would
        // seem
        // to be in violation of
        // https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html#MethodExit
        // but its what I see on my Android 14 emulator. So we need to check for `<=` and not simply
        // `==`.
        if (frame.height <= this.height) {
          exitRequest!!.close()
          callback(frame, value, wasPoppedByException)
        }
      }
  }
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/VirtualMachine.kt`:

```kt
package com.squareup.stoic.jvmti

import java.lang.reflect.Field
import java.lang.reflect.Method

// a jmethodID
typealias JMethodId = Long

// a jfieldID
typealias JFieldId = Long

// a jlocation
typealias JLocation = Long

/**
 * Analogous to
 * https://docs.oracle.com/javase/8/docs/jdk/api/jpda/jdi/com/sun/jdi/VirtualMachine.html
 */
object VirtualMachine {
  val eventRequestManager: EventRequestManager = EventRequestManager()

  @JvmStatic
  external fun <T> nativeInstances(clazz: Class<T>, includeSubclasses: Boolean): Array<out T>

  @JvmStatic external fun <T> nativeSubclasses(clazz: Class<T>): Array<Class<out T>>

  @JvmStatic
  external fun nativeGetMethodId(
    clazz: Class<*>,
    methodName: String,
    methodSignature: String,
  ): JMethodId

  @JvmStatic external fun nativeSetBreakpoint(jmethodId: JMethodId, jlocation: JLocation)

  @JvmStatic external fun nativeClearBreakpoint(jmethodId: JMethodId, jlocation: JLocation)

  @JvmStatic external fun nativeGetLocalVariables(jmethodId: JMethodId): Array<LocalVariable<*>>

  @JvmStatic external fun nativeGetMethodCoreMetadata(method: JvmtiMethod)

  @JvmStatic external fun nativeGetFieldCoreMetadata(method: JvmtiField)

  @JvmStatic external fun nativeGetLocalObject(thread: Thread, height: Int, slot: Int): Any

  @JvmStatic external fun nativeGetLocalInt(thread: Thread, height: Int, slot: Int): Int

  @JvmStatic external fun nativeGetLocalLong(thread: Thread, height: Int, slot: Int): Long

  @JvmStatic external fun nativeGetLocalFloat(thread: Thread, height: Int, slot: Int): Float

  @JvmStatic external fun nativeGetLocalDouble(thread: Thread, height: Int, slot: Int): Double

  @JvmStatic external fun nativeGetClassMethods(clazz: Class<*>): Array<JvmtiMethod>

  @JvmStatic external fun nativeGetClassFields(clazz: Class<*>): Array<JvmtiField>

  // @JvmStatic
  // external fun nativeInvokeMethod(isStatic: Boolean, methodId: JMethodId, args: Array<Any>)

  // Returns either java.lang.reflect.Method or java.lang.reflect.Constructor
  @JvmStatic
  external fun nativeToReflectedMethod(clazz: Class<*>, methodId: JMethodId, isStatic: Boolean): Any

  @JvmStatic
  external fun nativeToReflectedField(clazz: Class<*>, fieldId: JFieldId, isStatic: Boolean): Field

  // TODO: the actual API also returns genericSignature - this should probably return a pair of
  // Strings
  @JvmStatic external fun nativeGetClassSignature(clazz: Class<*>): String

  @JvmStatic external fun nativeMethodEntryCallbacks(thread: Thread, isEnabled: Boolean)

  @JvmStatic external fun nativeMethodExitCallbacks(thread: Thread, isEnabled: Boolean)

  @JvmStatic external fun nativeFromReflectedMethod(method: Method): JMethodId

  // Callback from native
  @JvmStatic
  fun nativeCallbackOnBreakpoint(jmethodId: JMethodId, jlocation: JLocation, frameCount: Int) {
    val method = JvmtiMethod[jmethodId]
    val location = Location(method, jlocation)
    val frame = StackFrame(Thread.currentThread(), frameCount, location)
    eventRequestManager.onBreakpoint(frame)
  }

  @JvmStatic
  fun nativeCallbackOnMethodEntry(jmethodId: JMethodId, jlocation: JLocation, frameCount: Int) {
    val method = JvmtiMethod[jmethodId]
    val location = Location(method, jlocation)
    val frame = StackFrame(Thread.currentThread(), frameCount, location)
    eventRequestManager.onMethodEntry(frame)
  }

  @JvmStatic
  fun nativeCallbackOnMethodExit(
    jmethodId: JMethodId,
    jlocation: JLocation,
    frameCount: Int,
    value: Any?,
    wasPoppedByException: Boolean,
  ) {
    val method = JvmtiMethod[jmethodId]
    val location = Location(method, jlocation)
    val frame = StackFrame(Thread.currentThread(), frameCount, location)
    eventRequestManager.onMethodExit(frame, value, wasPoppedByException)
  }
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/magic/MagicFields.kt`:

```kt
package com.squareup.stoic.jvmti.magic

import com.squareup.stoic.LruCache
import com.squareup.stoic.highlander
import com.squareup.stoic.jvmti.JvmtiClass
import com.squareup.stoic.jvmti.JvmtiField

class MagicFields(private val obj: Any?, private val clazz: JvmtiClass) {

  operator fun get(name: String, className: String? = null): Any? {
    return lookup(clazz, name, className).get(obj)
  }

  operator fun set(name: String, className: String? = null, value: Any?) {
    lookup(clazz, name, className).set(obj, value)
  }

  companion object {
    private val cache = LruCache<Triple<JvmtiClass, String, String?>, JvmtiField>(1024)

    private fun lookup(clazz: JvmtiClass, name: String, className: String?): JvmtiField {
      val key = Triple(clazz, name, className)
      val field = cache[key]
      return if (field == null) {
        val resolvedField = resolve(clazz, name, className)
        cache[key] = resolvedField
        resolvedField
      } else {
        field
      }
    }

    private fun resolve(clazz: JvmtiClass, name: String, signature: String?): JvmtiField {
      var filteredByName: List<JvmtiField>
      var baseClazz = clazz
      while (true) {
        filteredByName = filter(baseClazz, name, signature)
        if (filteredByName.isNotEmpty()) {
          break
        } else if (baseClazz.clazz.superclass == null) {
          break
        }

        baseClazz = JvmtiClass[baseClazz.clazz.superclass]
      }

      if (filteredByName.isEmpty()) {
        // Re-throw with the derived-most class name
        throw NoSuchFieldException("No field $name on $clazz")
      } else {
        return highlander(filteredByName)
      }
    }

    private fun filter(clazz: JvmtiClass, name: String, signature: String?): List<JvmtiField> {
      return clazz.declaredFields.filter {
        if (signature != null) {
          it.name == name && it.signature == signature
        } else {
          it.name == name
        }
      }
    }
  }
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/magic/MagicMethod.kt`:

```kt
package com.squareup.stoic.jvmti.magic

import com.squareup.stoic.jvmti.JvmtiMethod
import java.lang.reflect.InvocationTargetException
import java.lang.reflect.Modifier

class MagicMethod(private val obj: Any?, val method: JvmtiMethod) {
  operator fun invoke(vararg params: Any?): Any? {
    try {
      if (method.name == "<init>") {
        return method.invokeCtor(*params)
      } else if (Modifier.isStatic(method.modifiers)) {
        check(obj == null)
        return method.invokeStatic(*params)
      } else {
        return method.invokeNormal(obj!!, *params)
      }
    } catch (e: InvocationTargetException) {
      throw e.targetException
    } catch (e: ReflectiveOperationException) {
      // TODO: if sig wasn't specified we might incorrectly resolve against a method in the base
      // class
      // when a method in the superclass was intended - it'd be nice to check for that
      // TODO: also catch if there is another sig that would have worked

      // We catch and rethrow for a slightly less confusing stacktrace
      throw Exception(e.message)
    }
  }
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/magic/MagicMethods.kt`:

```kt
package com.squareup.stoic.jvmti.magic

import com.squareup.stoic.LruCache
import com.squareup.stoic.jvmti.JvmtiClass
import com.squareup.stoic.jvmti.JvmtiMethod

class MagicMethods(private val obj: Any?, private val clazz: JvmtiClass) {
  operator fun get(name: String, jvmSig: String? = null): MagicMethod {
    val key = Triple(clazz, name, jvmSig)
    val method = cache[key]
    val resolvedMethod =
      if (method == null) {
        val resolvedMethod =
          try {
            resolve(clazz, name, jvmSig)
          } catch (e: NoSuchMethodException) {
            // eprintln("clazz: ${clazz.name}")
            // for (m in clazz.declaredMethods.sortedBy { it.name }) {
            //  eprintln("method: ${m.name} ${m.modifiers} ${m.parameterTypes.asList()}")
            // }
            throw NoSuchMethodException("$clazz $name $jvmSig not found")
          }

        cache[key] = resolvedMethod
        resolvedMethod
      } else {
        method
      }

    return MagicMethod(obj, resolvedMethod)
  }

  companion object {
    private val cache = LruCache<Triple<JvmtiClass, String, String?>, JvmtiMethod>(1024)

    private fun resolve(clazz: JvmtiClass, name: String, jvmSig: String?): JvmtiMethod {
      val candidates =
        clazz.declaredMethods.filter {
          if (jvmSig == null) {
            name == it.name
          } else {
            name == it.name && jvmSig == it.signature
          }
        }

      return if (candidates.size == 1) {
        candidates[0]
      } else if (candidates.size > 1) {
        // TODO: also consider superclass candidates
        val sigs = candidates.map { it.signature }
        throw Exception(
          "method[$name, $jvmSig] - use method[$name, sig] syntax, where sig is any of $sigs"
        )
      } else {
        if (clazz.clazz.superclass != null) {
          resolve(JvmtiClass[clazz.clazz.superclass], name, jvmSig)
        } else {
          throw NoSuchMethodException()
        }
      }
    }
  }
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/jvmti/magics/Magics.kt`:

```kt
package com.squareup.stoic.jvmti.magics

import com.squareup.stoic.jvmti.JvmtiClass
import com.squareup.stoic.jvmti.magic.MagicFields
import com.squareup.stoic.jvmti.magic.MagicMethods

val Class<*>.sm: MagicMethods
  get() {
    return MagicMethods(null, JvmtiClass[this])
  }

val Class<*>.sf: MagicFields
  get() {
    return MagicFields(null, JvmtiClass[this])
  }

val Any.m: MagicMethods
  get() {
    return MagicMethods(this, JvmtiClass[this.javaClass])
  }

val Any.f: MagicFields
  get() {
    return MagicFields(this, JvmtiClass[this.javaClass])
  }

class c {
  companion object {
    operator fun get(name: String): Class<*> {
      return Class.forName(name)
    }
  }
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/plugin/StoicConfig.kt`:

```kt
package com.squareup.stoic.plugin

import android.content.Context

/**
 * Configuration for Stoic integration.
 *
 * To configure Stoic for your app, implement this interface and declare it in your
 * AndroidManifest.xml:
 * ```xml
 * <application>
 *     <meta-data
 *         android:name="com.squareup.stoic.config"
 *         android:value="com.example.MyStoicConfig" />
 * </application>
 * ```
 *
 * Then implement the config:
 * ```kotlin
 * class MyStoicConfig : StoicConfig {
 *     override fun getPlugins(context: Context): Map<String, Lazy<StoicPlugin>> {
 *         return mapOf(
 *             "my-plugin" to lazy { MyPlugin(context) },
 *             "another-plugin" to lazy { AnotherPlugin() }
 *         )
 *     }
 * }
 * ```
 *
 * When Stoic attaches (via JVMTI or BroadcastReceiver), it will:
 * 1. Read your app's AndroidManifest.xml
 * 2. Find the `com.squareup.stoic.config` meta-data entry
 * 3. Instantiate the config class
 * 4. Call [getPlugins] to load available plugins
 *
 * The plugins can then be invoked with: `stoic PACKAGE PLUGIN_NAME ARGS`.
 */
interface StoicConfig {
  /**
   * Returns a map of plugin names to plugin instances.
   *
   * Plugin names should be lowercase and use hyphens for word separation (e.g., "my-plugin"). These
   * names are used on the command line: `stoic PACKAGE PLUGIN_NAME`
   *
   * Plugins are lazy-loaded to avoid initialization overhead for unused plugins.
   *
   * @param context The application context
   * @return Map of plugin name to lazy plugin instance
   */
  fun getEmbeddedPlugins(context: Context): Map<String, Lazy<StoicPlugin>>
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/plugin/StoicPlugin.kt`:

```kt
package com.squareup.stoic.plugin

/**
 * A Stoic plugin that can be embedded into an application.
 *
 * When embedded plugins are registered via [StoicPluginRegistry], they become available when Stoic
 * attaches to the app (either via JVMTI or BroadcastReceiver).
 *
 * Example:
 * ```kotlin
 * class MyPlugin : StoicPlugin {
 *     override fun run(args: List<String>): Int {
 *         println("Hello from MyPlugin with args: $args")
 *         return 0
 *     }
 * }
 * ```
 *
 * @see StoicPluginRegistry
 */
interface StoicPlugin {
  /**
   * Executes the plugin with the given arguments.
   *
   * @param args Command-line arguments passed to the plugin
   * @return Exit code (0 for success, non-zero for failure)
   */
  fun run(args: List<String>): Int
}

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/threadlocals/ThreadLocals.kt`:

```kt
package com.squareup.stoic.threadlocals

import com.squareup.stoic.Stoic
import com.squareup.stoic.StoicJvmti
import com.squareup.stoic.internalStoic

// These are in a separate file from Stoic to prevent Stoic APIs from accidentally referencing the
// thread-local.
// TODO: allow access (with heavy warning) from any thread even when the thread-local doesn't have
// a value if there is only one Stoic instance in the whole process.
val stoic: Stoic
  get() = internalStoic.get()!!

val jvmti: StoicJvmti
  get() = stoic.jvmti

```

`target/plugin-sdk/src/main/kotlin/com/squareup/stoic/trace/Trace.kt`:

```kt
package com.squareup.stoic.trace

import com.squareup.stoic.Stack
import com.squareup.stoic.helpers.eprintln
import com.squareup.stoic.helpers.println
import com.squareup.stoic.jvmti.JvmtiClass
import com.squareup.stoic.jvmti.JvmtiField
import com.squareup.stoic.jvmti.JvmtiMethod
import com.squareup.stoic.jvmti.LocalVariable
import com.squareup.stoic.jvmti.MethodExitRequest
import com.squareup.stoic.jvmti.StackFrame
import com.squareup.stoic.jvmti.magics.c
import com.squareup.stoic.jvmti.magics.f
import com.squareup.stoic.threadlocals.jvmti
import com.squareup.stoic.trace.ResultTree.ResultLeaf
import com.squareup.stoic.trace.ResultTree.ResultNode
import com.squareup.stoic.trace.Rule.RuleLeaf
import com.squareup.stoic.trace.Rule.RuleMap
import java.lang.reflect.Modifier

val Include = RuleLeaf { type ->
  if (type is JvmtiMethod) {
    SimpleMethodEvaluator(type)
  } else {
    val clazz = (type as JvmtiClass).clazz
    val toStringClasses =
      listOf(
        Boolean::class.java,
        Byte::class.java,
        Short::class.java,
        Int::class.java,
        Long::class.java,
        Float::class.java,
        Double::class.java,
        String::class.java,
      )
    if (toStringClasses.any { clazz.isAssignableFrom(it) }) {
      ToStringEvaluator()
    } else {
      SimpleValueEvaluator(type)
    }
  }
}

val IncludeEach = rules(default = Include)

val Omit = RuleLeaf { _ -> null }

val OmitThis = rules(default = Include, "this" to Omit)

fun traceExpect(expected: String, vararg rules: Pair<String, Rule>, runnable: Runnable) {
  val sb = StringBuilder()
  trace(*rules) { name, tree -> sb.append(methodTreeToString(name, tree)) }

  runnable.run()

  val result = sb.toString()
  check(result.trim() == expected.trim()) { "\nexpected:\n$expected\n\nactual:\n$result\n" }
}

fun rules(default: Rule?, vararg pairs: Pair<String?, Rule?>): Rule {
  return RuleMap(default = default, pairs.toList())
}

fun rules(vararg pairs: Pair<String?, Rule?>): Rule {
  return rules(null, *pairs)
}

fun stringifyUntyped(evaluator: ValueEvaluator): RuleLeaf {
  return RuleLeaf { evaluator }
}

fun <T> stringify(clazz: Class<T>, stringifier: (T) -> String): RuleLeaf {
  return RuleLeaf { type ->
    val jvmtiClass = type as JvmtiClass
    if (!clazz.isAssignableFrom(jvmtiClass.clazz)) {
      throw IllegalArgumentException("${jvmtiClass.simpleName} is not compatible with $clazz")
    }

    object : ValueEvaluator() {
      override fun apply(obj: Any?): ResultTree {
        return ResultLeaf(stringifier(obj as T))
      }
    }
  }
}

sealed class Rule {
  class RuleMap(private val default: Rule?, private val rules: List<Pair<String?, Rule?>>) :
    Rule() {
    /**
     * Gather members.
     *
     * Given a map of name/field, apply com.squareup.stoic.trace.rules to produce a list of
     * name/field/com.squareup.stoic.trace.Rule triples Optionally, populate a list of unmatched
     * com.squareup.stoic.trace.rules
     */
    fun <T> gather(
      members: Map<String?, List<T>>,
      unmatched: MutableList<String?>?,
    ): List<Triple<String?, T, Rule>> {
      val result = mutableListOf<Triple<String?, T, Rule>>()
      val matched = mutableSetOf<String?>()
      for (rule in rules) {

        val memberValues = members[rule.first]
        if (memberValues != null) {
          for (memberValue in memberValues) {
            matched.add(rule.first)
            if (rule.second != null) {
              result.add(Triple(rule.first, memberValue, rule.second!!))
            }
          }
        } else {
          unmatched?.add(rule.first)
        }
      }

      if (default != null) {
        // If there is a default, then we apply it to each non-matched key
        members
          .filter { it.key !in matched }
          .forEach { (key, values) ->
            for (value in values) {
              result.add(Triple(key, value, default))
            }
          }
      }

      return result
    }
  }

  // JvmtiClass/JvmtiMethod ->
  // com.squareup.stoic.trace.MethodEvaluator/com.squareup.stoic.trace.ValueEvaluator
  class RuleLeaf(val typeToEvaluator: (type: Any) -> Any?) : Rule()
}

abstract class MethodEvaluator(val method: JvmtiMethod) {
  abstract fun apply(frame: StackFrame): ResultTree
}

class SimpleMethodEvaluator(method: JvmtiMethod) : MethodEvaluator(method) {
  private val result = ResultLeaf("...")

  override fun apply(frame: StackFrame): ResultTree {
    return result
  }
}

class MappedMethodEvaluator(
  method: JvmtiMethod,
  private val localVars: List<Pair<LocalVariable<*>, ValueEvaluator>>,
) : MethodEvaluator(method) {
  override fun apply(frame: StackFrame): ResultTree {
    return ResultNode(
      method.simpleQualifiedName,
      localVars.map { (localVar, objEval) ->
        val value = frame.get(localVar)
        Pair(localVar.name, objEval.apply(value))
      },
    )
  }
}

abstract class ValueEvaluator {
  abstract fun apply(obj: Any?): ResultTree
}

class MappedObjEvaluator(private val fields: List<Pair<JvmtiField, ValueEvaluator>>) :
  ValueEvaluator() {
  override fun apply(obj: Any?): ResultTree {
    return if (obj == null) {
      ResultLeaf("null")
    } else {
      ResultNode(
        JvmtiClass[obj.javaClass].simpleName,
        fields.map { (field, objEval) ->
          val value = field.get(obj)
          val subtree = objEval.apply(value)
          Pair(field.name, subtree)
        },
      )
    }
  }
}

class SimpleValueEvaluator(private val jvmtiClass: JvmtiClass) : ValueEvaluator() {
  override fun apply(obj: Any?): ResultTree {
    return if (obj == null) {
      ResultLeaf("null")
    } else {
      check(jvmtiClass.clazz.isAssignableFrom(obj.javaClass))
      val name = jvmtiClass.clazz.name.substringAfterLast('.')
      ResultLeaf("$name@@${Integer.toHexString(System.identityHashCode(obj))}")
    }
  }
}

class ToStringEvaluator : ValueEvaluator() {
  override fun apply(obj: Any?): ResultTree {
    return ResultLeaf("$obj")
  }
}

// class TypeEvaluator(val subrules: List<Pair<JvmtiField, TypeEvaluator>>) {
//  fun apply(obj: Any?): com.squareup.stoic.trace.ResultTree {
//    if (obj == null) {
//      return com.squareup.stoic.trace.ResultTree("null")
//    } else {
//      return com.squareup.stoic.trace.ResultTree(
//        subrules.map { (field, subrule) -> Pair(field.name, subrule.apply(field.get(obj))) })
//    }
//  }
// }

// class com.squareup.stoic.trace.MethodEvaluator(
//  val name: String,
//  val jvmtiMethod: JvmtiMethod,
//  private val subrules: List<Pair<LocalVariable<*>, TypeEvaluator>>
// ) {
//  fun apply(frame: StackFrame): com.squareup.stoic.trace.ResultTree {
//    return com.squareup.stoic.trace.ResultTree(
//      "${jvmtiMethod.clazz.simpleName}.${jvmtiMethod.name}",
//      subrules.map { (localVar, subrule) ->
//           com.squareup.stoic.trace.ResultTree(localVar.name!!,
// subrule.apply(frame.get(localVar)))
//          })
//  }
// }

// key/value pairs, where the value is either a String or a com.squareup.stoic.trace.ResultTree
sealed class ResultTree {
  class ResultNode(val value: String, val children: List<Pair<String?, ResultTree>> = listOf()) :
    ResultTree()

  class ResultLeaf(val value: String) : ResultTree()
}

// resolve a top-level rule into a list of MethodEvaluators
// the key is assumed to be a class sig
// TODO: allow the key to be a method-name or method-sig as well
// TODO: allow class to be specified in foo.bar.Baz format too
//
// For each class we find its methods, and then find the corresponding methods in its subclasses
// We resolve the rule names against the local variable names
fun resolveClass(key: String, rule: Rule): List<MethodEvaluator> {
  val jvmtiClass = JvmtiClass.bySig(key)
  val subclasses = jvmti.subclasses(jvmtiClass.clazz).map { JvmtiClass[it] }
  return when (rule) {
    is RuleLeaf -> resolveClassLeaf(jvmtiClass, subclasses, rule)
    is RuleMap ->
      resolveClassMap(
        jvmtiClass,
        subclasses,
        rule.gather(jvmtiClass.declaredMethods.groupBy { it.name }, null),
      )
  }
}

fun resolveClassLeaf(
  rootClass: JvmtiClass,
  subclasses: List<JvmtiClass>,
  rule: RuleLeaf,
): List<MethodEvaluator> {
  return rootClass.declaredMethods.flatMap { jvmtiMethod ->
    resolveMethodLeaf(jvmtiMethod, subclasses, rule)
  }
}

fun resolveClassMap(
  rootClass: JvmtiClass,
  subclasses: List<JvmtiClass>,
  rules: List<Triple<String?, JvmtiMethod, Rule?>>,
): List<MethodEvaluator> {
  return rules.flatMap { (methodName, method, rule) ->
    if (rule != null) {
      resolveMethodMap(methodName!!, method, subclasses, rule)
    } else {
      listOf()
    }
  }
}

fun resolveTypeRule(jvmtiClass: JvmtiClass, rule: Rule): ValueEvaluator? {
  return when (rule) {
    is RuleMap -> {
      val fieldPairs =
        rule
          .gather(
            jvmtiClass.declaredFields
              .filter { !Modifier.isStatic(it.modifiers) }
              .groupBy { it.name },
            null,
          )
          .mapNotNull { (_, field, subrule) ->
            val subtype = JvmtiClass.bySig(field.signature)
            resolveTypeRule(subtype, subrule)?.let { Pair(field, it) }
          }

      MappedObjEvaluator(fieldPairs)
    }
    is RuleLeaf -> {
      rule.typeToEvaluator(jvmtiClass) as ValueEvaluator?
    }
  }
}

fun resolveMethodMap(
  name: String,
  jvmtiMethod: JvmtiMethod,
  subclasses: List<JvmtiClass>,
  rule: Rule,
): List<MethodEvaluator> {
  return subclasses.mapNotNull { jvmtiClass ->
    try {
        jvmtiClass.declaredMethod(jvmtiMethod.name, jvmtiMethod.signature)
      } catch (e: NoSuchMethodException) {
        // override not present
        null
      }
      ?.let { subclassMethod ->
        // We need an evaluator for each argument
        when (rule) {
          is RuleMap -> {
            // TODO: match locals by index, since name can change between super/subclass impl
            val localVarPairs =
              rule.gather(subclassMethod.arguments.groupBy { it.name }, null).mapNotNull {
                (_, localVar, subrule) ->
                val subtype = JvmtiClass.bySig(localVar.signature)
                resolveTypeRule(subtype, subrule)?.let { Pair(localVar, it) }
              }
            MappedMethodEvaluator(subclassMethod, localVarPairs)
          }

          is RuleLeaf -> {
            val localVarPairs =
              subclassMethod.arguments.map {
                val valueEval =
                  rule.typeToEvaluator(JvmtiClass.bySig(it.signature)) as ValueEvaluator
                Pair(it, valueEval)
              }
            MappedMethodEvaluator(subclassMethod, localVarPairs)
          }
        }
      }
  }
}

fun resolveMethodLeaf(
  jvmtiMethod: JvmtiMethod,
  subclasses: List<JvmtiClass>,
  rule: RuleLeaf,
): List<MethodEvaluator> {
  return subclasses.mapNotNull { jvmtiClass ->
    try {
      val subclassMethod = jvmtiClass.declaredMethod(jvmtiMethod.name, jvmtiMethod.signature)
      rule.typeToEvaluator(subclassMethod) as MethodEvaluator
    } catch (e: NoSuchMethodException) {
      // override not present
      null
    }
  }
}

// Structured com.squareup.stoic.trace.trace declaration. This is a complex API, but you can get
// started by following
// examples rather than reading the entire documentation.
//
// e.g.
// com.squareup.stoic.trace.trace(
//   "android/view/View" to com.squareup.stoic.trace.getInclude,
// )
//
// com.squareup.stoic.trace.trace(
//   "android/view/View" to com.squareup.stoic.trace.getIncludeEach,
// )
//
// com.squareup.stoic.trace.trace(
//   "android/view/View" to ruleMap(
//     "getChildCount" to com.squareup.stoic.trace.getIncludeEach,
//   )
// )

// com.squareup.stoic.trace.trace(
//   "android/view/View" to ruleMap(
//     default = com.squareup.stoic.trace.getIncludeEach,
//     "getChildCount" to com.squareup.stoic.trace.getOmit,
//   )
// )
//
// We take in a list of com.squareup.stoic.trace.rules describing what to
// com.squareup.stoic.trace.trace. We type-check them to produce a list of
// evaluators, describing how to capture state at each breakpoint. When the evaluators run, they
// produce a com.squareup.stoic.trace.ResultTree, which is passed to the `consume` parameter.
//
// We apply breakpoints to subclasses, so you can list an interface and capture whenever a method in
// one of its implementations is called.
// TODO: provide an option to not apply breakpoints to subclasses
// The LocalVariables of overrides are not the same. To make matters worse abstract/interface
// functions don't have local variable names. So we need to provide complex logic to match names up
// to argument indices, and then derive the LocalVariable based on the argument index for each
// override.
//
fun trace(vararg rules: Pair<String, Rule>, consume: (String, ResultTree) -> Unit) {
  // TODO: support method sigs too
  val resolvedRules = rules.flatMap { (key, rule) -> resolveClass(key, rule) }
  resolvedRules.forEach { methodEvaluator ->
    val jvmtiMethod = methodEvaluator.method
    val startLocation = jvmtiMethod.startLocation

    // Check location to make sure the method isn't abstract
    if (startLocation.jlocation >= 0) {
      jvmti.breakpoint(startLocation) { frame ->
        val resultTree = methodEvaluator.apply(frame)
        consume(jvmtiMethod.simpleQualifiedName, resultTree)
      }
    }
  }
}

fun printMethodTree(name: String, resultTree: ResultTree) {
  println(methodTreeToString(name, resultTree))
}

fun methodTreeToString(name: String, tree: ResultTree): String {
  return when (tree) {
    is ResultNode -> {
      if (tree.children.isNotEmpty()) {
        val indent = "  "
        val sb = StringBuilder()
        sb.append("$name(\n")
        tree.children.forEach {
          sb.append(indent)
          resultTreeToString(it.first, it.second, indent, sb)
          sb.append(",\n")
        }
        sb.append(")\n")
        sb.toString()
      } else {
        "$name()"
      }
    }
    is ResultLeaf -> {
      return "$name(${tree.value})"
    }
  }
}

fun resultTreeToString(name: String?, tree: ResultTree, indent: String, sb: StringBuilder) {
  when (tree) {
    is ResultLeaf -> sb.append("$name = ${tree.value}")
    is ResultNode -> {
      val newIndent = "$indent  "
      sb.append("$name = ${tree.value} {\n")
      tree.children.forEach { (name, subtree) ->
        sb.append(newIndent)
        resultTreeToString(name, subtree, newIndent, sb)
        sb.append(",\n")
      }
      sb.append("$indent}")
    }
  }
}

// fun traceTopo(traceTopo: Map<JvmtiClass, Map<String, Stringifier<*>>>, dedupe: Boolean) {
//  val dedupeCache = LruCache<String, Unit>(8192)
//
//  traceTopo.forEach { (clazz, classSpec) ->
//    clazz.declaredMethods.forEach { jvmtiMethod ->
//      val stringifier = classSpec[jvmtiMethod.name] ?: StringifyDefault
//      if (stringifier != StringifyOmit && jvmtiMethod.startLocation.jlocation >= 0) {
//        jvmti.breakpoint(jvmtiMethod.startLocation) {
//          val earlyStr = stringifier.stringify(FrameMembers(jvmtiMethod, it), "")
//          if (earlyStr == "") {
//            // do nothing
//          } else {
//            val str = "${Thread.currentThread().id} $earlyStr"
//            if (!dedupe || !dedupeCache.containsKey(str)) {
//              dedupeCache[str] = Unit
//              println(str)
//            } else {
//              val alt = StringifyDefault.stringify(FrameMembers(jvmtiMethod, it), "")
//              println("$alt (deduped)")
//            }
//          }
//        }
//      }
//    }
//  }
//
// }
//
// typealias SpecialToString = (Any?) -> String
//
//// Map of (class-name, method-name, argument-name) to SpecialToString
//// This describes special com.squareup.stoic.trace.rules for stringifying certain arguments
// val specialToStrings: Map<Triple<String, String, String>, SpecialToString> = mapOf(
//  Triple(
//      "android.view.ViewRootImpl\$AccessibilityInteractionConnection",
//      "performAccessibilityAction",
//      "action") to { value: Any? ->
//    com.squareup.stoic.trace.getConstantNameByValue(
//      AccessibilityNodeInfo::class.java,
//      "ACTION_",
//      value as Int,
//      true)
//  },
//  Triple(
//    "android.view.ViewRootImpl\$AccessibilityInteractionConnection",
//    "performAccessibilityAction",
//    "flags") to { value: Any? ->
//    com.squareup.stoic.trace.getFlagNames(
//      AccessibilityNodeInfo::class.java,
//      "FLAG_",
//      value as Int,
//      true)
//  },
//  Triple(
//    "android.view.ViewRootImpl\$AccessibilityInteractionConnection",
//    "findFocus",
//    "flags") to { value: Any? ->
//    com.squareup.stoic.trace.getFlagNames(
//      AccessibilityNodeInfo::class.java,
//      "FLAG_",
//      value as Int,
//      true)
//  },
//  Triple(
//    "android.view.ViewRootImpl\$AccessibilityInteractionConnection",
//    "findAccessibilityNodeInfoByAccessibilityId",
//    "flags") to { value: Any? ->
//    com.squareup.stoic.trace.getFlagNames(
//      AccessibilityNodeInfo::class.java,
//      "FLAG_",
//      value as Int,
//      true)
//  },
// )

fun getConstantNameByValue(
  constantsClass: Class<*>,
  fieldPrefix: String,
  value: Int,
  includePrefix: Boolean = false,
): String {
  // TODO: cache this map
  val valueToNameMap =
    JvmtiClass[constantsClass]
      .declaredFields
      .filter { it.signature == "I" }
      .filter { it.modifiers and Modifier.STATIC != 0 }
      .filter { it.modifiers and Modifier.FINAL != 0 }
      .filter { it.name.startsWith(fieldPrefix) }
      .associate { it.get(null) to it.name }

  val result = valueToNameMap[value] ?: return "Unknown constant value: $value"
  return if (includePrefix) {
    result
  } else {
    result.drop(fieldPrefix.length)
  }
}

fun getFlagNames(
  constantsClass: Class<*>,
  fieldPrefix: String,
  value: Int,
  includePrefix: Boolean = false,
): String {
  // TODO: cache this map
  val valueToNameMap =
    JvmtiClass[constantsClass]
      .declaredFields
      .filter { it.signature == "I" }
      .filter { it.modifiers and Modifier.STATIC != 0 }
      .filter { it.modifiers and Modifier.FINAL != 0 }
      .filter { it.name.startsWith(fieldPrefix) }
      .associate { it.get(null) to it.name }

  val flagNames = mutableListOf<String>()
  for (flagPos in 0..31) {
    val flag = 1 shl flagPos
    if (flag and value != 0) {
      flagNames.add(valueToNameMap[flag] ?: "0x${flag.toString(16)}")
    }
  }

  return if (flagNames.isEmpty()) {
    "0"
  } else {
    flagNames.joinToString(" | ")
  }
}

fun flexibleToList(any: Any): List<Any?> {
  return when (any) {
    is Array<*> -> any.toList()
    is BooleanArray -> any.toList()
    is ByteArray -> any.toList()
    is CharArray -> any.toList()
    is ShortArray -> any.toList()
    is IntArray -> any.toList()
    is LongArray -> any.toList()
    is FloatArray -> any.toList()
    is DoubleArray -> any.toList()
    is List<*> -> any
    else -> {
      if (c["android.util.LongArray"].isInstance(any)) {
        (any.f["mValues"] as LongArray).toList().slice(0..<(any.f["mSize"] as Int))
      } else {
        throw IllegalArgumentException("${any.javaClass}")
      }
    }
  }
}

fun identityString(obj: Any?): String {
  if (obj == null) {
    return "null"
  }

  val hash = Integer.toHexString(System.identityHashCode(obj))
  return obj.javaClass.name.substringAfterLast('.') + "@@" + hash
}

fun traceMethodUntilExit(bpMethod: JvmtiMethod) {
  jvmti.breakpoint(bpMethod.startLocation) { breakpointFrame -> traceUntilExit(breakpointFrame) }
}

fun traceUntilExit(breakpointFrame: StackFrame) {
  val bpMethod = breakpointFrame.location.method
  println("-> called ${bpMethod.name}(...)")

  val entryRequest =
    jvmti.methodEntries { frame ->
      val method = frame.location.method
      val level = frame.height - breakpointFrame.height
      val indent = "  ".repeat(level)
      // println("$indent-> ${method.clazz.name}.${method.name} (...)")

    }
  var exitRequest: MethodExitRequest? = null
  exitRequest =
    jvmti.methodExits { frame, value, wasPoppedByException ->
      val method = frame.location.method
      if (frame.height <= breakpointFrame.height) {
        if (frame.height == breakpointFrame.height) {
          check(bpMethod.methodId == frame.location.method.methodId)
          println("<- exiting from ${bpMethod.name} (${java.lang.Long.toHexString(value as Long)})")
        } else {
          println("<- exiting from ${bpMethod.name} (wasPoppedByException? $wasPoppedByException)")
        }
        entryRequest.close()
        exitRequest!!.close()
        println(Stack(frame.stackTrace).stackTraceToString())
      } else {
        val level = frame.height - breakpointFrame.height
        val indent = "  ".repeat(level)
        // println("$indent<- ${method.clazz.name}.${method.name} (...)")
      }
    }
}

fun Any?.toKotlinRepr(): String =
  when (this) {
    null -> "null"
    is CharSequence -> {
      val unquoted =
        this.toString()
          .replace("\\", "\\\\")
          .replace("\n", "\\n")
          .replace("\t", "\\t")
          .replace("\b", "\\b")
          .replace("\r", "\\r")
          .replace("\"", "\\\"")
          .replace("\$", "\\\$")
      "\"" + unquoted + "\""
    }
    is List<*> -> this.toKotlinListRepr() // Separate function for lists
    else -> this.toString()
  }

fun List<*>.toKotlinListRepr(): String {
  val reprElements = this.joinToString(separator = ", ") { it.toKotlinRepr() }
  return "listOf($reprElements)"
}

fun inspect(clazz: Class<*>) {
  // Note: technically I should walk up the superclasses to find other declared methods
  eprintln("Inspecting ${clazz.name}")
  val staticMethods = clazz.declaredMethods.asList().sortedBy { it.name }
  val staticFields = clazz.declaredFields.asList().sortedBy { it.name }
  val methods =
    (clazz.declaredMethods.asList() + clazz.methods.asList()).distinct().sortedBy { it.name }
  val fields =
    (clazz.declaredFields.asList() + clazz.fields.asList()).distinct().sortedBy { it.name }
  staticFields.forEach { eprintln("static ${it.name}: ${it.type}") }
  staticMethods.forEach {
    eprintln("static ${it.name}: (${it.parameterTypes.asList()}): ${it.returnType}")
  }
  fields.forEach { eprintln("${it.name}: ${it.type}") }
  methods.forEach { eprintln("${it.name}: (${it.parameterTypes.asList()}): ${it.returnType}") }
  eprintln("Done")
}

fun <T> highlander(array: Array<T>): T {
  if (array.size != 1) {
    throw IllegalArgumentException("There can be only one! ${array.size}")
  }

  return array.first()
}

fun <T> highlander(collection: Collection<T>): T {
  if (collection.size != 1) {
    throw IllegalArgumentException("There can be only one! $collection")
  }

  return collection.first()
}

```

`test-plugin/build.gradle.kts`:

```kts
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
  alias(libs.plugins.kotlin.jvm)
  alias(libs.plugins.kotlin.serialization)
}

repositories { mavenCentral() }

val androidHome =
  providers.environmentVariable("ANDROID_HOME").orNull
    ?: throw GradleException("ANDROID_HOME is not set")
val androidCompileSdk = extra["stoic.android_compile_sdk"] as String

dependencies {
  implementation(kotlin("stdlib"))
  implementation(project(":target:plugin-sdk"))
  implementation(libs.kotlinx.serialization.json)
  compileOnly(files("$androidHome/platforms/android-$androidCompileSdk/android.jar"))
}

tasks.withType<KotlinCompile> { kotlinOptions { jvmTarget = "17" } }

tasks.jar {
  duplicatesStrategy = DuplicatesStrategy.EXCLUDE
  manifest { attributes("Main-Class" to "MainKt") }
}

```

`test-plugin/src/main/kotlin/Main.kt`:

```kt
import android.os.Build
import com.squareup.stoic.helpers.*
import com.squareup.stoic.jvmti.JvmtiMethod
import com.squareup.stoic.jvmti.VirtualMachine
import com.squareup.stoic.threadlocals.stoic
import com.squareup.stoic.trace.Include
import com.squareup.stoic.trace.IncludeEach
import com.squareup.stoic.trace.OmitThis
import com.squareup.stoic.trace.identityString
import com.squareup.stoic.trace.rules
import com.squareup.stoic.trace.traceExpect

fun main(args: Array<String>) {
  val command = args.firstOrNull() ?: "testsuite"

  when (command) {
    "testsuite" -> {
      testDuplicateArguments()
      testTrace()
      testMethodEntry()
      testMethodExit()
    }
    "getenv" -> {
      // Print the value of each requested environment variable
      for (varName in args.drop(1)) {
        println(stoic.getenv(varName) ?: "")
      }
    }
    else -> {
      eprintln("Unknown test command: $command")
      eprintln("Available commands: testsuite, getenv")
    }
  }
}

// Verify that we don't include duplicate arguments. The local variable table may contain duplicate
// entries for some slots. If we see duplicate entries, we must prefer ones with non-null names.
// This verifies that we handle it correctly with a method known to suffer from this problem.
fun testDuplicateArguments() {
  eprintln("testDuplicateArguments")
  if (Build.VERSION.SDK_INT < 33) {
    // testDuplicateArguments uses a method signature that changed between API levels
    // The signature we test for is only available on API 32+
    eprintln("skipping (requires API 33+)")
    return
  }

  val method =
    JvmtiMethod.bySig(
      "android/view/AccessibilityInteractionController\$AccessibilityNodePrefetcher.prefetchAccessibilityNodeInfos(Landroid/view/View;Landroid/view/accessibility/AccessibilityNodeInfo;Ljava/util/List;)V"
    )
  check(method.arguments.map { it.name } == listOf("this", "view", "root", "outInfos"))
}

fun testTrace() {
  eprintln("testTrace")
  if (Build.VERSION.SDK_INT < 29) {
    eprintln("skipping (requires API 29+ for IterateOverInstancesOfClass)")
    return
  }

  // Run ahead of time to capture clinit
  Foo.bar()
  Bar.bar()

  traceExpect("Foo.bar(...)", "Foo" to Include) { Foo.bar() }

  traceExpect("Bar\$Companion.bar(...)", "Bar\$Companion" to Include) { Bar.bar() }

  traceExpect(
    """
      Foo.bar(
        this = ${identityString(Foo)},
        baz = 5,
      )
    """
      .trimIndent(),
    "Foo" to IncludeEach,
  ) {
    Foo.bar(5)
  }

  traceExpect(
    """
      Foo.bar(
        baz = 5,
      )
    """
      .trimIndent(),
    "Foo" to rules(OmitThis),
  ) {
    Foo.bar(5)
  }

  // TODO: KotlinRepr - "lol"
  traceExpect(
    """
      Foo.bar(
        baz = 5,
        taz = lol,
      )
    """
      .trimIndent(),
    "Foo" to rules(OmitThis),
  ) {
    Foo.bar(5, "lol")
  }

  traceExpect(
    """
      Bar${'$'}Companion.foo(
        b = Bar {
          baz = 42,
        },
      )
    """
      .trimIndent(),
    "Bar\$Companion" to rules("foo" to rules("b" to IncludeEach)),
  ) {
    Bar.foo(Bar(42))
  }
}

object Foo {
  fun bar() {}

  fun bar(baz: Int) {}

  fun bar(baz: Int, taz: String) {}
}

class Bar(val baz: Int) {
  companion object {
    fun bar() {}

    fun foo(b: Bar) {}
  }
}

fun testMethodEntry() {
  eprintln("testMethodEntry")
  if (Build.VERSION.SDK_INT < 29) {
    eprintln("skipping (requires API 29+)")
    return
  }

  var methodEntryCalled = false

  val testMethod = JvmtiMethod.bySig("MainKt.testMethodEntryHelper()V")

  // Test method entry
  val entryRequest =
    VirtualMachine.eventRequestManager.createMethodEntryRequest(Thread.currentThread()) { frame ->
      if (frame.location.method.methodId == testMethod.methodId) {
        eprintln("Method entry callback triggered")
        methodEntryCalled = true
      }
    }

  // Call the test method
  testMethodEntryHelper()

  // Clean up
  VirtualMachine.eventRequestManager.deleteEventRequest(entryRequest)

  check(methodEntryCalled) { "Method entry callback was not called" }

  eprintln("testMethodEntry passed")
}

fun testMethodExit() {
  eprintln("testMethodExit")
  if (Build.VERSION.SDK_INT < 29) {
    eprintln("skipping (requires API 29+)")
    return
  }

  var methodExitCalled = false

  val testMethod = JvmtiMethod.bySig("MainKt.testMethodExitHelper()V")

  // Test method exit
  val exitRequest =
    VirtualMachine.eventRequestManager.createMethodExitRequest(Thread.currentThread()) {
      frame,
      value,
      wasPoppedByException ->
      if (frame.location.method.methodId == testMethod.methodId) {
        eprintln("Method exit callback triggered")
        methodExitCalled = true
      }
    }

  // Call the test method
  testMethodExitHelper()

  // Clean up
  VirtualMachine.eventRequestManager.deleteEventRequest(exitRequest)

  check(methodExitCalled) { "Method exit callback was not called" }

  eprintln("testMethodExit passed")
}

fun testMethodEntryHelper() {
  // This is just a helper method to test entry callback
}

fun testMethodExitHelper() {
  // This is just a helper method to test exit callback
}

```

`test/TestHostShebang.kt`:

```kt
#!/usr/bin/env stoic shebang --host --
package shebang

import com.squareup.stoic.print.*

fun main(args: List<String>): Int {
  println("args: $args")
  return 0
}

```

`test/TestPkgShebang.kt`:

```kt
#!/usr/bin/env stoic shebang --allowed-stoic-options pkg --
import com.squareup.stoic.print.*

fun main(args: List<String>): Int {
  println("args: $args")
  return 0
}

```

`test/TestSrcPathRefShebang.kt`:

```kt
#!/bin/sh
/*polyglot-trick/
stoic shebang --allow-stoic-options pkg,host,no-host,restart -- "$0" "$@"
exit 0
*/

package shebang

import android.app.Application
import com.squareup.stoic.isAndroid
import com.squareup.stoic.jvmti
import com.squareup.stoic.print.*
import com.squareup.stoic.stoic

@Suppress("UNUSED_PARAMETER")
fun main(args: List<String>): Int {
  val pkg =
    if (isAndroid) {
      val apps = jvmti.instances(Application::class.java)
      apps[0].packageName
    } else {
      "jvm"
    }
  println("pkg: $pkg, ${stoic.shebangSrcPath}")
  return 0
}

```

`test/TestXplatShebang.kt`:

```kt
#!/usr/bin/env stoic shebang --allow-stoic-options pkg,host,no-host --
package shebang

import android.app.Application
import com.squareup.stoic.isAndroid
import com.squareup.stoic.jvmti
import com.squareup.stoic.print.*

fun main(args: List<String>): Int {
  val pkg =
    if (isAndroid) {
      val apps = jvmti.instances(Application::class.java)
      apps[0].packageName
    } else {
      "jvm"
    }
  println("pkg: $pkg, args: $args")
  return 0
}

```

`test/clean-build-and-regression-check.sh`:

```sh
#!/bin/bash
set -euxo pipefail

# This script should be run before pushing to main - all errors must be addressed

script_dir="$(dirname "$(readlink -f "$0")")"

# To ensure stability, we always build clean
(cd "$script_dir/.." && ./gradlew clean)
"$script_dir/../build.sh"

# Use the native build we just created
export STOIC_BIN="$script_dir/../build/distributions/bin/darwin-arm64/stoic"
source "$script_dir/setup-stoic-path.sh"

"$script_dir"/shellcheck.sh
"$script_dir"/emulator-tests.sh

# TODO: these tests require functionality not available on older versions of
#   Android
# "$script_dir/../build/distributions/bin/stoic" testsuite

# TODO
#"$script_dir"/test-shebang.sh


set +x
echo
echo
echo All checks completed successfully
echo
echo

```

`test/emulator-tests.sh`:

```sh
#!/usr/bin/env bash
set -euo pipefail

# Script to run Stoic tests on multiple emulator API levels
# This script tests on a subset of API levels for speed

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

echo "================================================"
echo "Stoic Emulator Test Suite"
echo "================================================"
echo "This will run all tests on API 26, 29, 30, and 35"
echo ""

# API levels to test
API_LEVELS=(26 29 30 35)

# Track failures
FAILED_API_LEVELS=()

for api in "${API_LEVELS[@]}"; do
    echo ""
    echo "================================================"
    echo "Testing on API $api"
    echo "================================================"
    echo ""

    if "$script_dir/with-emulator.sh" "$api" "$script_dir/run-all-tests-on-connected-device.sh"; then
        echo ""
        echo "✓ All tests PASSED on API $api"
    else
        echo ""
        echo "✗ Tests FAILED on API $api"
        FAILED_API_LEVELS+=("$api")
    fi
done

echo ""
echo "================================================"
echo "Final Summary"
echo "================================================"
echo "API levels tested: ${API_LEVELS[*]}"
echo "Passed: $((${#API_LEVELS[@]} - ${#FAILED_API_LEVELS[@]}))"
echo "Failed: ${#FAILED_API_LEVELS[@]}"

if [ ${#FAILED_API_LEVELS[@]} -gt 0 ]; then
    echo ""
    echo "Failed on API levels:"
    for api in "${FAILED_API_LEVELS[@]}"; do
        echo "  - API $api"
    done
    echo ""
    exit 1
fi

echo ""
echo "All tests passed on all API levels!"
exit 0

```

`test/perf-fast-path.sh`:

```sh
#!/bin/bash
#set -x
set -euo pipefail

stoic_dir="$(dirname "$(readlink -f "$0")")/../"
source "$stoic_dir/prebuilt/script/android_serial.sh"

# Pick a device
_android_serial

# We cd so that we can run ./stoic in a subshell without any env vars
cd "$stoic_dir/build/distributions/bin"

# warm
./stoic helloworld >/dev/null

echo "From laptop:"
time sh << 'EOF'
for i in {0..9}; do
  ./stoic helloworld
done
EOF

```

`test/perf-host-shebang.sh`:

```sh
#!/bin/bash
#set -x
set -euo pipefail
script_dir="$(dirname "$(readlink -f "$0")")"

# We cd so that we can run ./TestHostShebang.kt in a subshell without any env
# vars
cd "$script_dir"

# warm-up
./TestHostShebang.kt


>&2 echo "Timing how long it takes to run 10 times"
time sh << 'EOF'
for i in {0..9}; do
  ./TestHostShebang.kt
done
EOF

```

`test/perf-slow-path.sh`:

```sh
#!/bin/bash
#set -x
set -euo pipefail

stoic_dir="$(dirname "$(readlink -f "$0")")/../"
source "$stoic_dir/prebuilt/script/android_serial.sh"

# Pick a device
_android_serial

# We cd so that we can run ./stoic in a subshell without any env vars
cd "$stoic_dir/build/distributions/bin"

# warm
./stoic helloworld >/dev/null

echo "From laptop:"
time sh << 'EOF'
for i in {0..9}; do
  ./stoic --restart helloworld
done
EOF

```

`test/regression-check.sh`:

```sh
#!/bin/bash
set -euxo pipefail

# T
```

`test/run-all-tests-on-connected-device.sh`:

```sh
#!/usr/bin/env bash
set -euo pipefail

# Script to run all Stoic tests
# This is meant to be invoked by with-emulator.sh

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

echo "========================================"
echo "Running all Stoic tests"
echo "========================================"
echo ""

# Track failures
FAILED_TESTS=()

# Run each test suite
TESTS=(
    "verify-kotlin-api-version.sh"  # doesn't use device
    "test-env-vars.sh"  # doesn't use device
    "test-demo-app-without-sdk.sh"
    "test-protocol-version-handshake.sh"
    "test-env-flag.sh"
    "test-plugin-new.sh"
    "test-without-config.sh"
    "testsuite.sh"
    "test-demo-app-with-sdk.sh"
)

for test in "${TESTS[@]}"; do
    echo "----------------------------------------"
    echo "Running: $test"
    echo "----------------------------------------"

    if "$script_dir/$test"; then
        echo "✓ $test PASSED"
    else
        echo "✗ $test FAILED"
        FAILED_TESTS+=("$test")
    fi
    echo ""
done

echo "========================================"
echo "Test Summary"
echo "========================================"
echo "Total tests: ${#TESTS[@]}"
echo "Passed: $((${#TESTS[@]} - ${#FAILED_TESTS[@]}))"
echo "Failed: ${#FAILED_TESTS[@]}"

if [ ${#FAILED_TESTS[@]} -gt 0 ]; then
    echo ""
    echo "Failed tests:"
    for test in "${FAILED_TESTS[@]}"; do
        echo "  - $test"
    done
    exit 1
fi

echo ""
echo "All tests passed!"
exit 0

```

`test/setup-stoic-path.sh`:

```sh
# Sourceable script to ensure tests use the correct stoic binary
#
# Usage: source test/setup-stoic-path.sh
#
# If STOIC_BIN is set, ensures that binary is used.
# If STOIC_BIN is not set, builds the JVM version and uses it.

# Determine the repository root directory
if [ -n "${ZSH_VERSION:-}" ]; then
    # This is zsh-specific, so disable shell check
    # shellcheck disable=SC2296
    _setup_stoic_script_path="${(%):-%N}"
elif [ -n "${BASH_VERSION:-}" ]; then
    _setup_stoic_script_path="${BASH_SOURCE[0]}"
else
    echo "Error: Unsupported shell (neither Bash nor Zsh)" >&2
    return 1
fi

_setup_stoic_script_dir="$(cd "$(dirname "$_setup_stoic_script_path")" && pwd)"
_setup_stoic_repo_dir="$(cd "$_setup_stoic_script_dir/.." && pwd)"

if [ -n "${STOIC_BIN:-}" ]; then
    # STOIC_BIN is set - use the specified binary
    if [ ! -f "$STOIC_BIN" ]; then
        echo "Error: STOIC_BIN is set to '$STOIC_BIN' but file does not exist" >&2
        return 1
    fi

    if [ ! -x "$STOIC_BIN" ]; then
        echo "Error: STOIC_BIN is set to '$STOIC_BIN' but file is not executable" >&2
        return 1
    fi

    # Create a temporary directory with a symlink to stoic
    # This ensures we don't pollute PATH with other binaries from STOIC_BIN's directory
    _setup_stoic_tmpdir="$(mktemp -d)"
    ln -s "$(cd "$(dirname "$STOIC_BIN")" && pwd)/$(basename "$STOIC_BIN")" "$_setup_stoic_tmpdir/stoic"

    export PATH="$_setup_stoic_tmpdir:$PATH"

    echo "Using stoic from STOIC_BIN: $STOIC_BIN" >&2
else
    # STOIC_BIN not set - build the JVM version
    echo "Building JVM version of stoic..." >&2

    # Change to repo directory, build, and return to original directory
    pushd "$_setup_stoic_repo_dir" > /dev/null

    # Build distribution but skip native compilation (same as bnr.sh)
    if ! ./gradlew --quiet --console=plain buildDistribution -x nativeCompile; then
        popd > /dev/null
        echo "Error: Failed to build stoic" >&2
        return 1
    fi

    popd > /dev/null

    # Set up PATH to use the JVM version
    _setup_stoic_jvm_dir="$_setup_stoic_repo_dir/build/distributions/bin/jvm"

    if [ ! -f "$_setup_stoic_jvm_dir/stoic" ]; then
        echo "Error: Build succeeded but $_setup_stoic_jvm_dir/stoic not found" >&2
        return 1
    fi

    # Create a temporary directory with a symlink to stoic
    # This ensures we don't pollute PATH with other binaries from the jvm bin directory
    _setup_stoic_tmpdir="$(mktemp -d)"
    ln -s "$_setup_stoic_jvm_dir/stoic" "$_setup_stoic_tmpdir/stoic"

    export PATH="$_setup_stoic_tmpdir:$PATH"

    echo "Using built JVM version: $_setup_stoic_jvm_dir/stoic" >&2
fi

# Verify stoic is now accessible
if ! command -v stoic &> /dev/null; then
    echo "Error: stoic command not found in PATH after setup" >&2
    return 1
fi

# Show which stoic will be used
# echo "stoic command resolves to: $(command -v stoic)" >&2

# Clean up temporary variables (but not _setup_stoic_tmpdir - it needs to persist)
unset _setup_stoic_script_path
unset _setup_stoic_script_dir
unset _setup_stoic_repo_dir
unset _setup_stoic_jvm_dir

```

`test/shellcheck.sh`:

```sh
#!/bin/bash
set -euxo pipefail

script_dir="$(dirname "$(readlink -f "$0")")"

cd $script_dir/..
shellcheck -x build.sh
shellcheck -x release.sh

```

`test/smoke-test.sh`:

```sh
#!/bin/bash
set -euxo pipefail

# Run a minimal test/tests quickly to find problems
# We expect that there is exactly one connected device

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Parse args - we expect 0 or 1 arg
if [ $# -eq 0 ]; then
  test_script="$script_dir/run-all-tests-on-connected-device.sh"
elif [ $# -eq 1 ]; then
  test_script="$1"
  # If the script name doesn't contain / and doesn't exist, look for it in script_dir
  if [[ "$test_script" != */* ]] && [ ! -f "$test_script" ]; then
    test_script="$script_dir/$test_script"
  fi
  # Verify the test script exists
  if [ ! -f "$test_script" ]; then
    echo "Error: Test script not found: $test_script" >&2
    exit 1
  fi
else
  echo "Usage: $0 [test-script]" >&2
  exit 1
fi

# Ensure we're using the correct stoic binary (builds JVM version if needed)
source "$script_dir/setup-stoic-path.sh"

# Invoke the test script
"$test_script"

```

`test/test-demo-app-with-sdk.sh`:

```sh
#!/bin/bash
#set -x
set -euo pipefail

# Ensure we're using the correct stoic binary
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$script_dir/setup-stoic-path.sh"

stoic --attach-via=sdk helloworld

```

`test/test-demo-app-without-sdk.sh`:

```sh
#!/bin/bash
#set -x
set -euo pipefail

# Ensure we're using the correct stoic binary
script_dir="$(dirname "$(readlink -f "$0")")"
source "$script_dir/setup-stoic-path.sh"

# Function to exit with line number
abort() {
    >&2 echo "line $1: $2"
    exit 1
}

verify_output() {
    expected="$1"
    lineno="$2"
    shift
    shift
    >&2 echo verify_output "$@"
    output="$("$@")"
    if [ "$output" != "$expected" ]; then
        echo "expected: '$expected'"
        echo "actual  : '$output'"
        abort "$lineno" Failed
    fi
}

verify_stderr() {
    expected="$1"
    lineno="$2"
    shift
    shift
    >&2 echo verify_stderr "$@"
    output="$("$@" 3>&1 1>/dev/null 2>&3)"
    return_code="$?"
    if [ "$output" != "$expected" ]; then
        echo "expected: '$expected'"
        echo "actual  : '$output'"
        abort "$lineno" Failed
    elif [ "$return_code" != "0" ]; then
      echo "Failed \"$@\" - returned $return_code"
    fi
}

cd "$script_dir"

# Verify we can install/run the demo app automatically.
# NOTE: When we don't specify a package, we default to the demo app, and the
# demo app implies --start-if-needed
if [ -n "$(adb shell pm list package com.squareup.stoic.demoapp.withoutsdk)" ]; then
    adb uninstall com.squareup.stoic.demoapp.withoutsdk
fi
verify_output 'Hello world []'                                                             $LINENO stoic helloworld
adb shell am force-stop com.squareup.stoic.demoapp.withoutsdk
verify_output 'Hello world []'                                                             $LINENO stoic helloworld

# Verify we can uninstall the demo app (guard against https://github.com/square/stoic/issues/2) 
adb uninstall com.squareup.stoic.demoapp.withoutsdk

# Verify no stderr logs when reinstalling the demo app
verify_stderr '' $LINENO stoic --no-status helloworld

# Verify no stderr logs when starting a previously stopped demo app
adb shell am force-stop com.squareup.stoic.demoapp.withoutsdk
verify_stderr '' $LINENO stoic --no-status helloworld

# Verify no stderr logs when restarting the demo app
verify_stderr '' $LINENO stoic --no-status --restart helloworld

```

`test/test-env-flag.sh`:

```sh
#!/bin/bash
set -euo pipefail
script_dir="$(dirname "$(readlink -f "$0")")"

# Ensure we're using the correct stoic binary
source "$script_dir/setup-stoic-path.sh"

# Build the test plugin
cd "$script_dir/.."
./gradlew :test-plugin:apk --quiet --console=plain
test_plugin="test-plugin/build/libs/test-plugin-$(cat prebuilt/STOIC_VERSION | tr -d '\n').apk"
cd - > /dev/null

# Function to exit with line number
abort() {
    >&2 echo "line $1: $2"
    exit 1
}

verify_output() {
    expected="$1"
    lineno="$2"
    shift
    shift
    >&2 echo verify_output "$@"
    output="$("$@")"
    if [ "$output" != "$expected" ]; then
        echo "expected: '$expected'"
        echo "actual  : '$output'"
        abort "$lineno" Failed
    fi
}

pkg=com.squareup.stoic.demoapp.withoutsdk

# Test single env var
verify_output "TEST_VALUE" "$LINENO" \
    stoic --package="$pkg" --restart --env TEST_VAR=TEST_VALUE \
    "$test_plugin" getenv TEST_VAR

# Test multiple env vars
verify_output $'bar\nqux' "$LINENO" \
    stoic --package="$pkg" --env FOO=bar --env BAZ=qux \
    "$test_plugin" getenv FOO BAZ

# Test env var with spaces
verify_output "hello world" "$LINENO" \
    stoic --package="$pkg" --env "SPACE_VAR=hello world" \
    "$test_plugin" getenv SPACE_VAR

# Test env var with special characters
verify_output "a=b&c" "$LINENO" \
    stoic --package="$pkg" --env "SPECIAL=a=b&c" \
    "$test_plugin" getenv SPECIAL

# Test env var with multiple equals signs
verify_output "bar=baz" "$LINENO" \
    stoic --package="$pkg" --env "MULTI_EQUALS=bar=baz" \
    "$test_plugin" getenv MULTI_EQUALS

# Test missing env var returns empty string
verify_output "" "$LINENO" \
    stoic --package="$pkg" "$test_plugin" getenv NONEXISTENT_VAR

echo "✓ All --env flag tests passed"

```

`test/test-env-vars.sh`:

```sh
#!/bin/bash
set -euo pipefail

# Ensure we're using the correct stoic binary
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$script_dir/setup-stoic-path.sh"

# Test STOIC_REQUIRED_VERSION and STOIC_ATTACH_VIA environment variables

echo "Testing STOIC_REQUIRED_VERSION..."

# Test 1: Lower required version should succeed
echo -n "  Test 1 (lower version): "
if STOIC_REQUIRED_VERSION="0.5.0" stoic --version &>/dev/null; then
    echo "✓ PASS"
else
    echo "✗ FAIL"
    exit 1
fi

# Test 2: Equal major.minor.patch should succeed
echo -n "  Test 2 (equal version): "
current_version=$(stoic --version | awk '{print $3}')
if STOIC_REQUIRED_VERSION="$current_version" stoic --version &>/dev/null; then
    echo "✓ PASS"
else
    echo "✗ FAIL"
    exit 1
fi

# Test 3: Higher required version should fail
echo -n "  Test 3 (higher version): "
set +e
output=$(STOIC_REQUIRED_VERSION="99.0.0" stoic --version 2>&1)
exit_code=$?
set -e
if [ $exit_code -ne 0 ] && echo "$output" | grep -q "is lower than required"; then
    echo "✓ PASS"
else
    echo "✗ FAIL - Expected 'is lower than required' in output: $output"
    exit 1
fi

# Test 4: Invalid version format should fail with appropriate message
echo -n "  Test 4 (invalid format): "
set +e
output=$(STOIC_REQUIRED_VERSION="invalid" stoic --version 2>&1)
exit_code=$?
set -e
if [ $exit_code -ne 0 ] && echo "$output" | grep -q "Could not parse"; then
    echo "✓ PASS"
else
    echo "✗ FAIL"
    exit 1
fi

echo ""
echo "Testing STOIC_ATTACH_VIA..."

# Test 5: Valid sdk value should not cause errors
echo -n "  Test 5 (sdk value): "
if STOIC_ATTACH_VIA="sdk" stoic --help &>/dev/null; then
    echo "✓ PASS"
else
    echo "✗ FAIL"
    exit 1
fi

# Test 6: Valid jvmti-root value should not cause errors
echo -n "  Test 6 (jvmti-root value): "
if STOIC_ATTACH_VIA="jvmti-root" stoic --help &>/dev/null; then
    echo "✓ PASS"
else
    echo "✗ FAIL"
    exit 1
fi

# Test 7: Valid jvmti value should not cause errors
echo -n "  Test 7 (jvmti value): "
if STOIC_ATTACH_VIA="jvmti" stoic --help &>/dev/null; then
    echo "✓ PASS"
else
    echo "✗ FAIL"
    exit 1
fi

# Test 8: Invalid value should show error
echo -n "  Test 8 (invalid value): "
set +e
output=$(STOIC_ATTACH_VIA="invalid-mode" stoic --help 2>&1)
exit_code=$?
set -e
if [ $exit_code -ne 0 ] && echo "$output" | grep -q "Invalid STOIC_ATTACH_VIA"; then
    echo "✓ PASS"
else
    echo "✗ FAIL"
    exit 1
fi

echo ""
echo "✓ All environment variable tests passed!"

```

`test/test-plugin-new.sh`:

```sh
#!/bin/bash
#set -x
set -euo pipefail

# Ensure we're using the correct stoic binary
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$script_dir/setup-stoic-path.sh"

export STOIC_CONFIG="$(mktemp -d)"
echo "STOIC_CONFIG=$STOIC_CONFIG"
cd "$STOIC_CONFIG"

# Verify we can create and run a new plugin
stoic plugin --new a-new-plugin
stoic a-new-plugin

```

`test/test-protocol-version-handshake.sh`:

```sh
#!/bin/bash
set -euo pipefail

# Ensure we're using the correct stoic binary
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$script_dir/setup-stoic-path.sh"

# This test exists to ensure that the stoic server properly enforces the protocol version

# Keep in sync with protocol-version-client source
exit_accept=0
exit_reject=5
exit_error=10

stoic_protocol_version=5
invalid_protocol_version=999
repo_dir="$(realpath "$script_dir/..")"
stoic_version="$(cat "$repo_dir/prebuilt/STOIC_VERSION")"

cd "$repo_dir"

# Test that protocol version handshake works correctly by modifying options.json on device
./gradlew :internal:test:protocol-version-client:assemble
protocol_client_jar="$repo_dir/internal/test/protocol-version-client/build/libs/protocol-version-client-$stoic_version.jar"

test-attach-via() {
  attach_via="$1"
  package="$2"

  stoic --restart --attach-via "$attach_via" --package "$package" __stoic-noop
  jvmti_port="$(adb forward tcp:0 "localabstract:/stoic/$package/server")"

  set +e
  java -jar "$protocol_client_jar" localhost "$jvmti_port" "$stoic_protocol_version"
  exit_code=$?
  set -e
  if [ $exit_code -ne "$exit_accept" ]; then
    echo "FAIL: $attach_via: Connection failed with protocol version=$stoic_protocol_version: exit_code=$exit_code" >&2
    exit 1
  else
    echo "PASS: $attach_via: Connection succeeded with protocol version=$stoic_protocol_version: exit_code=$exit_code" >&2
  fi

  set +e
  java -jar "$protocol_client_jar" localhost "$jvmti_port" "$invalid_protocol_version"
  exit_code=$?
  set -e
  if [ $exit_code -ne "$exit_reject" ]; then
    echo "FAIL: $attach_via: Connection succeeded with protocol version=$invalid_protocol_version: exit_code=$exit_code" >&2
    exit 1
  else
    echo "PASS: $attach_via: Connection failed with protocol version=$invalid_protocol_version: exit_code=$exit_code" >&2
  fi
}

# Sanity check: we want to make sure we can distinguish between actual
# protocol-version-client errors and server rejections
set +e
java -jar "$protocol_client_jar" 2>/dev/null
exit_code=$?
set -e
if [ $exit_code -ne "$exit_error" ]; then
  echo "Exit code sanity check failed" >&2
fi

test-attach-via jvmti com.squareup.stoic.demoapp.withoutsdk
test-attach-via sdk com.squareup.stoic.demoapp.withsdk

```

`test/test-shebang.sh`:

```sh
#!/bin/bash
set -euxo pipefail
script_dir="$(dirname "$(readlink -f "$0")")"

# Function to exit with line number
abort() {
    >&2 echo "line $1: $2"
    exit 1
}

verify_output() {
    {
       set +x
    } 2>/dev/null  # Don't print set +x

    expected="$1"
    lineno="$2"
    shift
    shift
    output="$("$@")"
    if [ "$output" != "$expected" ]; then
        echo "expected: '$expected'"
        echo "actual  : '$output'"
        abort "$lineno" Failed
    fi
    set -x
}

cd "$script_dir"

verify_output 'args: [hello world, !]'                                                           $LINENO ./TestHostShebang.kt "hello world" "!"
verify_output 'args: []'                                                                         $LINENO ./TestHostShebang.kt
verify_output 'pkg: com.squareup.stoic.demoapp.withoutsdk, args: [hello world, !]'               $LINENO ./TestXplatShebang.kt "hello world" "!"
verify_output 'pkg: jvm, args: [hello world, !]'                                                 $LINENO ./TestXplatShebang.kt --host "hello world" "!"
verify_output 'pkg: com.squareup.stoic.demoapp.withoutsdk, args: []'                             $LINENO ./TestXplatShebang.kt
verify_output 'pkg: jvm, args: []'                                                               $LINENO ./TestXplatShebang.kt --host
verify_output "pkg: jvm, $script_dir/TestSrcPathRefShebang.kt"                                   $LINENO ./TestSrcPathRefShebang.kt --host
verify_output "pkg: com.squareup.stoic.demoapp.withoutsdk, $script_dir/TestSrcPathRefShebang.kt" $LINENO ./TestSrcPathRefShebang.kt


```

`test/test-stress.sh`:

```sh
#!/bin/bash
#set -x
set -euo pipefail
script_dir="$(dirname "$(readlink -f "$0")")"

# Ensure we're using the correct stoic binary
source "$script_dir/setup-stoic-path.sh"

cd $script_dir

# In the past we'd occasionally fail when due to strange pidof behavior -
# sometimes pidof would fail even though the process was still running. This
# happened shortly after the process started, but a previous invocation of
# pidof succeeded. This test runs 100 iterations of that scenario
for i in $(seq 1 100); do
    echo iteration: $i
    adb shell am force-stop com.squareup.stoic.demoapp.withoutsdk && stoic helloworld
    if [ $? -ne 0 ]; then
        echo "Command failed on iteration $i: $?"
        exit 1
    fi
done

```

`test/test-without-config.sh`:

```sh
#!/bin/bash
#set -x
set -euo pipefail

# Ensure we're using the correct stoic binary
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$script_dir/setup-stoic-path.sh"

export STOIC_CONFIG="$(mktemp -d)"
rmdir "$STOIC_CONFIG"

echo "STOIC_CONFIG=$STOIC_CONFIG"
stoic helloworld
stoic --restart helloworld

```

`test/testsuite.sh`:

```sh
#!/bin/bash
set -euo pipefail
script_dir="$(dirname "$(readlink -f "$0")")"

# Ensure we're using the correct stoic binary
source "$script_dir/setup-stoic-path.sh"

# Build the test plugin
cd "$script_dir/.."
./gradlew :test-plugin:apk --quiet --console=plain
test_plugin="test-plugin/build/libs/test-plugin-$(cat prebuilt/STOIC_VERSION | tr -d '\n').apk"
cd - > /dev/null

stoic "$test_plugin" testsuite

```

`test/verify-kotlin-api-version.sh`:

```sh
#!/bin/bash
set -euo pipefail

# This script verifies that published SDK artifacts are compiled with Kotlin API version 1.9
# to ensure maximum compatibility with consumers.

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Ensure we're using the correct stoic binary
source "$SCRIPT_DIR/setup-stoic-path.sh"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "Verifying Kotlin API version in published SDK artifacts..."
echo

# Expected Kotlin API version
EXPECTED_API_VERSION="1.9"

verify_jar_kotlin_version() {
  local jar_path="$1"
  local artifact_name="$2"

  if [[ ! -f "$jar_path" ]]; then
    echo -e "${RED}✗ $artifact_name not found at: $jar_path${NC}"
    return 1
  fi

  echo "Checking $artifact_name..."

  # Extract .kotlin_module files from the JAR
  local temp_dir=$(mktemp -d)
  trap "rm -rf $temp_dir" EXIT

  unzip -q "$jar_path" "META-INF/*.kotlin_module" -d "$temp_dir" 2>/dev/null || {
    echo -e "${RED}✗ No .kotlin_module files found in $artifact_name${NC}"
    return 1
  }

  # Read the Kotlin metadata version from the first few bytes
  # Kotlin metadata format: first 4 bytes are magic number, next bytes contain version info
  local kotlin_module_file=$(find "$temp_dir/META-INF" -name "*.kotlin_module" | head -n 1)

  if [[ ! -f "$kotlin_module_file" ]]; then
    echo -e "${RED}✗ Could not find kotlin_module file in $artifact_name${NC}"
    return 1
  fi

  # Use kotlinp (Kotlin protobuf tool) if available, otherwise use kotlinc -version as fallback
  # For now, we'll check if the JAR was compiled with the expected API version by
  # examining the Kotlin stdlib dependency version in the manifest

  # Extract MANIFEST.MF
  unzip -q "$jar_path" "META-INF/MANIFEST.MF" -d "$temp_dir" 2>/dev/null || true

  # Check if we can find version info in manifest or module file
  local manifest="$temp_dir/META-INF/MANIFEST.MF"
  if [[ -f "$manifest" ]]; then
    if grep -q "Kotlin" "$manifest"; then
      echo "  Found Kotlin metadata in manifest"
    fi
  fi

  # Check the actual bytecode version - Kotlin 1.9 should produce specific bytecode
  # We'll use javap to check the class file version
  # Extract a sample .class file
  local class_file=$(unzip -l "$jar_path" "*.class" 2>/dev/null | grep -o '[^ ]*\.class' | head -n 1)

  if [[ -n "$class_file" ]]; then
    unzip -q "$jar_path" "$class_file" -d "$temp_dir" 2>/dev/null || true
    local extracted_class="$temp_dir/$class_file"

    if [[ -f "$extracted_class" ]]; then
      # Check the Kotlin metadata annotation
      javap -v "$extracted_class" 2>/dev/null | grep -A 5 "kotlin.Metadata" > "$temp_dir/metadata.txt" || true

      if [[ -f "$temp_dir/metadata.txt" ]] && [[ -s "$temp_dir/metadata.txt" ]]; then
        echo "  Found Kotlin metadata annotation"

        # The metadata contains version information
        # For Kotlin 1.9, we expect specific version numbers in the metadata
        # mv (metadata version) should be [1, 9, 0] for Kotlin 1.9
        if grep -q "mv.*1.*9" "$temp_dir/metadata.txt" 2>/dev/null; then
          echo -e "${GREEN}✓ $artifact_name compiled with Kotlin API version 1.9${NC}"
          return 0
        else
          echo -e "${YELLOW}  Metadata version info:${NC}"
          grep "mv" "$temp_dir/metadata.txt" || echo "  (no mv field found)"
          echo -e "${RED}✗ $artifact_name may not be using Kotlin API version 1.9${NC}"
          return 1
        fi
      fi
    fi
  fi

  echo -e "${YELLOW}⚠ Could not definitively verify Kotlin version for $artifact_name${NC}"
  echo "  Manual verification recommended"
  return 1
}

verify_aar_kotlin_version() {
  local aar_path="$1"
  local artifact_name="$2"

  if [[ ! -f "$aar_path" ]]; then
    echo -e "${RED}✗ $artifact_name not found at: $aar_path${NC}"
    return 1
  fi

  echo "Checking $artifact_name..."

  # Extract classes.jar from the AAR
  local temp_dir=$(mktemp -d)
  trap "rm -rf $temp_dir" EXIT

  unzip -q "$aar_path" "classes.jar" -d "$temp_dir" 2>/dev/null || {
    echo -e "${RED}✗ No classes.jar found in $artifact_name${NC}"
    return 1
  }

  # Now verify the JAR inside the AAR
  verify_jar_kotlin_version "$temp_dir/classes.jar" "$artifact_name (classes.jar)"
}

# Find the version from STOIC_VERSION
VERSION=$(cat "$PROJECT_ROOT/prebuilt/STOIC_VERSION" | tr -d '\n')
echo "Project version: $VERSION"
echo

# Verify plugin-sdk JAR
SDK_DIR="$(dirname "$(realpath "$(which stoic)")")/../../sdk"
PLUGIN_SDK_JAR="$SDK_DIR/stoic-plugin-sdk.jar"
verify_jar_kotlin_version "$PLUGIN_SDK_JAR" "plugin-sdk"

echo

# Verify app-sdk AAR
APP_SDK_AAR="$SDK_DIR/stoic-app-sdk.aar"
verify_aar_kotlin_version "$APP_SDK_AAR" "app-sdk"

echo
echo -e "${GREEN}All Kotlin API version checks completed${NC}"

```

`test/with-emulator.sh`:

```sh
#!/usr/bin/env bash
set -euo pipefail

# Script to spin up an Android emulator and run a test script
# Usage: ./with-emulator.sh <api_level> <script_to_run> [script_args...]
#
# Example:
#   ./with-emulator.sh 29 ./test-demo-app-without-sdk.sh
#   ./with-emulator.sh 34 ./test-demo-app-without-sdk.sh --verbose

if [ $# -lt 2 ]; then
    echo "Usage: $0 <api_level> <script_to_run> [script_args...]" >&2
    echo "" >&2
    echo "Examples:" >&2
    echo "  $0 29 ./test-demo-app-without-sdk.sh" >&2
    echo "  $0 34 ./test-demo-app-without-sdk.sh --verbose" >&2
    echo "" >&2
    echo "Supported API levels: 26, 29, 30, 31, 32, 33, 34, 35" >&2
    exit 1
fi

API_LEVEL="$1"
TEST_SCRIPT="$2"
shift 2
TEST_ARGS=("$@")

# Configuration mapping
declare -A ANDROID_VERSIONS=(
    [26]="8.0"
    [29]="10.0"
    [30]="11.0"
    [31]="12.0"
    [32]="12.0L"
    [33]="13.0"
    [34]="14.0"
    [35]="15.0"
)

# System image type mapping (use default for all - no need for google_apis)
declare -A SYSTEM_IMAGE_TYPES=(
    [26]="default"
    [29]="default"
    [30]="default"
    [31]="default"
    [32]="default"
    [33]="default"
    [34]="default"
    [35]="default"
)

if [ -z "${ANDROID_VERSIONS[$API_LEVEL]:-}" ]; then
    echo "Error: Unsupported API level: $API_LEVEL" >&2
    echo "Supported API levels: ${!ANDROID_VERSIONS[@]}" >&2
    exit 1
fi

ANDROID_VERSION="${ANDROID_VERSIONS[$API_LEVEL]}"
AVD_NAME="stoic_test_api${API_LEVEL}"
ABI="arm64-v8a"
DEVICE="pixel_2"
SYSTEM_IMAGE_TYPE="${SYSTEM_IMAGE_TYPES[$API_LEVEL]}"
SYSTEM_IMAGE="system-images;android-${API_LEVEL};${SYSTEM_IMAGE_TYPE};${ABI}"

# Get Android SDK path
if [ -n "${ANDROID_HOME:-}" ]; then
    SDK_PATH="$ANDROID_HOME"
elif [ -n "${ANDROID_SDK_ROOT:-}" ]; then
    SDK_PATH="$ANDROID_SDK_ROOT"
else
    echo "Error: ANDROID_HOME or ANDROID_SDK_ROOT environment variable not set" >&2
    exit 1
fi

AVDMANAGER="$SDK_PATH/cmdline-tools/latest/bin/avdmanager"
SDKMANAGER="$SDK_PATH/cmdline-tools/latest/bin/sdkmanager"
EMULATOR="$SDK_PATH/emulator/emulator"
ADB="$SDK_PATH/platform-tools/adb"

# Verify tools exist
for tool in "$AVDMANAGER" "$SDKMANAGER" "$EMULATOR" "$ADB"; do
    if [ ! -x "$tool" ]; then
        echo "Error: Required tool not found or not executable: $tool" >&2
        exit 1
    fi
done

# Verify test script exists and is executable
if [ ! -f "$TEST_SCRIPT" ]; then
    echo "Error: Test script not found: $TEST_SCRIPT" >&2
    exit 1
fi

if [ ! -x "$TEST_SCRIPT" ]; then
    echo "Error: Test script is not executable: $TEST_SCRIPT" >&2
    exit 1
fi

echo "================================================"
echo "Android Emulator Test Runner"
echo "================================================"
echo "API Level:        $API_LEVEL (Android $ANDROID_VERSION)"
echo "AVD Name:         $AVD_NAME"
echo "Test Script:      $TEST_SCRIPT"
echo "Test Args:        ${TEST_ARGS[*]:-<none>}"
echo "================================================"
echo ""

# Function to cleanup on exit
cleanup() {
    local exit_code=$?
    echo ""
    echo "Cleaning up..."

    # Kill logcat
    if [ -n "${LOGCAT_PID:-}" ] && kill -0 "$LOGCAT_PID" 2>/dev/null; then
        echo "Stopping logcat (PID: $LOGCAT_PID)..."
        kill "$LOGCAT_PID" 2>/dev/null || true
    fi

    # Kill emulator
    if [ -n "${EMULATOR_PID:-}" ] && kill -0 "$EMULATOR_PID" 2>/dev/null; then
        echo "Stopping emulator (PID: $EMULATOR_PID)..."
        "$ADB" emu kill 2>/dev/null || true
        # Wait a bit for graceful shutdown
        sleep 2
        # Force kill if still running
        if kill -0 "$EMULATOR_PID" 2>/dev/null; then
            kill -9 "$EMULATOR_PID" 2>/dev/null || true
        fi
    fi

    echo "Cleanup complete."
    exit $exit_code
}

trap cleanup EXIT INT TERM

# Check if system image is installed, install if not
echo "Checking if system image is installed..."
if ! "$SDKMANAGER" --list_installed | grep -q "^  $SYSTEM_IMAGE"; then
    echo "System image not found. Installing: $SYSTEM_IMAGE"
    echo "This may take a few minutes..."

    # yes fails with SIGPIPE, even when the command succeeds
    yes | "$SDKMANAGER" "$SYSTEM_IMAGE" || true
    if ! "$SDKMANAGER" --list_installed | grep -q "^  $SYSTEM_IMAGE"; then
      echo "System image install failed."
      exit 1
    else
      echo "System image installed successfully."
    fi
else
    echo "System image already installed: $SYSTEM_IMAGE"
fi

# Create AVD if it doesn't exist
echo "Checking if AVD exists..."
if "$AVDMANAGER" list avd -c | grep -q "^${AVD_NAME}$"; then
    echo "AVD '$AVD_NAME' already exists."
else
    echo "Creating AVD '$AVD_NAME'..."
    echo "no" | "$AVDMANAGER" create avd \
        --name "$AVD_NAME" \
        --package "$SYSTEM_IMAGE" \
        --device "$DEVICE" \
        --force
    echo "AVD created successfully."
fi

echo ""

# Record existing emulators before starting ours
PRE_EXISTING_DEVICES=$("$ADB" devices | awk '{print $1}' | sort || true)

echo "Starting emulator..."

# Redirect emulator output to log file
EMULATOR_LOG_DIR="/tmp/.stoic"
EMULATOR_LOG_FILE="$EMULATOR_LOG_DIR/emulator-startup.log"
mkdir -p "$EMULATOR_LOG_DIR"

"$EMULATOR" \
    -avd "$AVD_NAME" \
    -no-snapshot-save \
    -no-audio \
    -no-boot-anim \
    -no-window \
    -gpu swiftshader_indirect \
    > "$EMULATOR_LOG_FILE" 2>&1 &

EMULATOR_PID=$!
echo "Emulator started (PID: $EMULATOR_PID)"
echo "Emulator output: $EMULATOR_LOG_FILE"

echo ""
echo "Waiting for emulator to appear in adb devices..."
WAIT_COUNT=0
MAX_WAIT=90  # Increased from 60 to 90 (3 minutes)
NEW_EMULATOR=""
while [ $WAIT_COUNT -lt $MAX_WAIT ]; do
    # Get current emulators
    CURRENT_EMULATORS=$("$ADB" devices | grep "emulator-" | awk '{print $1}' | sort || true)

    # Find the new emulator (present in CURRENT but not in EXISTING)
    # comm -13: suppress lines unique to first file and common lines, showing
    #   only lines unique to second file
    NEW_EMULATOR=$(comm -13 <(echo "$PRE_EXISTING_DEVICES") <(echo "$CURRENT_EMULATORS") | head -1)

    if [ -n "$NEW_EMULATOR" ]; then
        # Check if it's fully booted (shows as "device" not just "offline")
        if "$ADB" -s "$NEW_EMULATOR" get-state 2>/dev/null | grep -q "device"; then
            break
        fi
    fi

    sleep 2
    WAIT_COUNT=$((WAIT_COUNT + 1))
    echo -n "."
done
echo ""

if [ -z "$NEW_EMULATOR" ]; then
    echo "Error: New emulator did not appear in adb devices within 3 minutes" >&2
    echo "" >&2
    echo "Emulator startup log ($EMULATOR_LOG_FILE):" >&2
    echo "===========================================" >&2
    cat "$EMULATOR_LOG_FILE" >&2
    echo "===========================================" >&2
    exit 1
fi

# Use the newly started emulator
export ANDROID_SERIAL="$NEW_EMULATOR"
echo "Emulator device: $ANDROID_SERIAL"

echo ""
echo "Waiting for emulator to finish booting..."
"$ADB" wait-for-device
"$ADB" shell 'while [ -z "$(getprop sys.boot_completed)" ]; do sleep 1; done'

echo "Emulator is ready!"
echo ""

# Start capturing logcat
LOGCAT_DIR="/tmp/.stoic"
LOGCAT_FILE="$LOGCAT_DIR/with-emulator-logcat.txt"
mkdir -p "$LOGCAT_DIR"

echo "Starting logcat capture to $LOGCAT_FILE ..."
# Clear logcat and start capturing from current time with timestamp
#"$ADB" logcat -c
"$ADB" logcat -v time > "$LOGCAT_FILE" &
LOGCAT_PID=$!
echo "Logcat started (PID: $LOGCAT_PID)"
echo ""

echo "================================================"
echo "Running test script..."
echo "================================================"
echo ""

# Set environment variables for the test script
export API_LEVEL="$API_LEVEL"

# Uncomment for better native stack traces
# adb shell su 0 setenforce 0

# Run the test script
set +e
"$TEST_SCRIPT" "${TEST_ARGS[@]}"
TEST_EXIT_CODE=$?
set -e

echo ""
echo "================================================"
echo "Test script completed with exit code: $TEST_EXIT_CODE"
echo "================================================"

# Cleanup will happen via trap
exit $TEST_EXIT_CODE

```