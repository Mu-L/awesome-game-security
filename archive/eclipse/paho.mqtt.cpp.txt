Project Path: arc_eclipse_paho.mqtt.cpp_wsexl7vn

Source Tree:

```txt
arc_eclipse_paho.mqtt.cpp_wsexl7vn
├── CHANGELOG.md
├── CMakeLists.txt
├── CODE_OF_CONDUCT.md
├── CODING_STYLE.md
├── CONTRIBUTING.md
├── Doxyfile
├── LICENSE
├── NOTICE
├── README.md
├── SECURITY.md
├── about.html
├── buildtst.sh
├── cmake
│   ├── CMakeLists.txt
│   ├── CPackDebConfig.cmake
│   └── PahoMqttCppConfig.cmake.in
├── devenv.sh
├── dist
│   ├── Makefile
│   └── paho-cpp.spec
├── doc
│   ├── CMakeLists.txt
│   ├── Doxyfile.cmake
│   ├── Doxyfile.in
│   └── pahologo.png
├── edl-v10
├── epl-v20
├── examples
│   ├── CMakeLists.txt
│   ├── async_consume.cpp
│   ├── async_consume_v5.cpp
│   ├── async_message_consume.cpp
│   ├── async_message_consume_v5.cpp
│   ├── async_publish.cpp
│   ├── async_publish_time.cpp
│   ├── async_subscribe.cpp
│   ├── async_subscribe_v5.cpp
│   ├── data_publish.cpp
│   ├── mqttpp_chat.cpp
│   ├── multithr_pub_sub.cpp
│   ├── pub_speed_test.cpp
│   ├── rpc_math_cli.cpp
│   ├── rpc_math_srvr.cpp
│   ├── server_props_v5.cpp
│   ├── ssl_publish.cpp
│   ├── sync_consume.cpp
│   ├── sync_consume_v5.cpp
│   ├── sync_publish.cpp
│   ├── sync_reconnect.cpp
│   ├── topic_publish.cpp
│   └── ws_publish.cpp
├── externals
│   └── paho-mqtt-c
├── fmt.sh
├── include
│   └── mqtt
│       ├── CMakeLists.txt
│       ├── async_client.h
│       ├── buffer_ref.h
│       ├── buffer_view.h
│       ├── callback.h
│       ├── client.h
│       ├── connect_options.h
│       ├── create_options.h
│       ├── delivery_token.h
│       ├── disconnect_options.h
│       ├── event.h
│       ├── exception.h
│       ├── export.h
│       ├── iaction_listener.h
│       ├── iasync_client.h
│       ├── iclient_persistence.h
│       ├── message.h
│       ├── platform.h
│       ├── properties.h
│       ├── reason_code.h
│       ├── response_options.h
│       ├── server_response.h
│       ├── ssl_options.h
│       ├── string_collection.h
│       ├── subscribe_options.h
│       ├── thread_queue.h
│       ├── token.h
│       ├── topic.h
│       ├── topic_matcher.h
│       ├── types.h
│       └── will_options.h
├── notice.html
├── scripts
│   ├── install_catch2.sh
│   └── install_paho_mqtt_c.sh
├── src
│   ├── CMakeLists.txt
│   ├── async_client.cpp
│   ├── client.cpp
│   ├── connect_options.cpp
│   ├── create_options.cpp
│   ├── disconnect_options.cpp
│   ├── iclient_persistence.cpp
│   ├── message.cpp
│   ├── properties.cpp
│   ├── reason_code.cpp
│   ├── response_options.cpp
│   ├── server_response.cpp
│   ├── ssl_options.cpp
│   ├── string_collection.cpp
│   ├── token.cpp
│   ├── topic.cpp
│   └── will_options.cpp
└── test
    ├── ssl
    │   ├── all-ca.crt
    │   ├── client.pem
    │   ├── mosquitto.conf
    │   ├── server.crt
    │   ├── server.key
    │   └── test-root-ca.crt
    └── unit
        ├── CMakeLists.txt
        ├── catch2_version.h
        ├── mock_action_listener.h
        ├── mock_async_client.h
        ├── mock_callback.h
        ├── mock_persistence.h
        ├── test_async_client.cpp
        ├── test_async_client_v3.cpp
        ├── test_buffer_ref.cpp
        ├── test_client.cpp
        ├── test_connect_options.cpp
        ├── test_create_options.cpp
        ├── test_disconnect_options.cpp
        ├── test_exception.cpp
        ├── test_message.cpp
        ├── test_persistence.cpp
        ├── test_properties.cpp
        ├── test_response_options.cpp
        ├── test_ssl_options.cpp
        ├── test_string_collection.cpp
        ├── test_subscribe_options.cpp
        ├── test_thread_queue.cpp
        ├── test_token.cpp
        ├── test_topic.cpp
        ├── test_topic_matcher.cpp
        ├── test_will_options.cpp
        └── unit_tests.cpp

```

`CHANGELOG.md`:

```md
# Change Log
#
# Eclipse Paho MQTT C++ Library

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/), and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## Unreleased

- Fixed `topic_matcher` and `topic_filter` to properly match parent with multi-level ('#') wildcard.
- Slight optimization of `topic_filter` to do simple string comparison if the filter does not contain wildcards.
- [#556](https://github.com/eclipse-paho/paho.mqtt.cpp/pull/556) fix potential deadlock in `thread_queue` on capacity increase.
- [#559](https://github.com/eclipse-paho/paho.mqtt.cpp/pull/559) prevent undefined behaviour on empty topic matching

## [Version 1.5.3](https://github.com/eclipse/paho.mqtt.cpp/compare/v1.5.2..v1.5.3) (2025-05-15)

- Fix the bundled Paho C build foc C23 compilers by forcing C99 compliance in CMake build
- [#544](https://github.com/eclipse-paho/paho.mqtt.cpp/pull/544) and [#550](https://github.com/eclipse-paho/paho.mqtt.cpp/pull/550) Use std::vector<unsigned char> for the ALPN protocol list in wire format
- [#547](https://github.com/eclipse-paho/paho.mqtt.cpp/pull/547) Fixed up some of the v5 examples for proper connect options
- [#549](https://github.com/eclipse-paho/paho.mqtt.cpp/pull/549) Update TEST_EXTERNAL_SERVER urls


## [Version 1.5.2](https://github.com/eclipse/paho.mqtt.cpp/compare/v1.5.1..v1.5.2) (2025-03-11)

- Fixed the Version number and string.
- Synchronous `Client` constructors updated to use `persistence_type` and (just) `create_options`
    - Restored compatibility with `async_client`
- [#505](https://github.com/eclipse-paho/paho.mqtt.cpp/issues/505): Example of retrieving MQTT v5 properties in message received callback
- [#537](https://github.com/eclipse-paho/paho.mqtt.cpp/issues/537) Fixed the Windows DLL build by exporting message::EMPTY_STR and message::EMPTY_BIN
- [#540](https://github.com/eclipse-paho/paho.mqtt.cpp/issues/537) Missing default argument in `async_client` changed constructor breaks code compatibility


## [Version 1.5.1](https://github.com/eclipse/paho.mqtt.cpp/compare/v1.5.0..v1.5.1) - (2025-02-09)

- Minor fixes to README and docs
- [#532](https://github.com/eclipse-paho/paho.mqtt.cpp/pull/532) Fix CMake install target lib path
- [#534](https://github.com/eclipse-paho/paho.mqtt.cpp/issues/534) Fixed seg fault with clang in get_topic() when publishing a message
- [#535](https://github.com/eclipse-paho/paho.mqtt.cpp/issues/535) Fixed last few files that were not properly licenced for EPL v2.0


## [Version 1.5.0](https://github.com/eclipse/paho.mqtt.cpp/compare/v1.4.1..v1.5.0) - (2025-01-07)

- Code base updated to to C++17
    - Now a C++17 compiler is required to compile the library
- CMake minimum required version raised to v3.13
    - Need a fairly recent CMake for C++17 support (>= v3.12)
    - [#504](https://github.com/eclipse-paho/paho.mqtt.cpp/issues/504) CMake v3.13 allows INSTALL(TARGETS) to work outside the current directory.
- Clients always created for v5 persistence format, making it universal for any connection.
    - If the application specifies a version it is kept as a hint for default connections.
    - The version for the connection should be specified in the connect options.
- The `create_options` now have all the parameters to create a client.
    - Can specify Server URL, Client ID, and persistence in the create options.
    - New client constructor that takes just the options object
    - The client caches a const `create_options` struct with all the creation parameters
    - Client creation internally simplified without breaking the public API
- Expanded the message constmer to be a full client "event" consumer.
    - The events are for *connected, connection_lost, disconnected, message arrived,* and application *shutdown.*
    - The application can get client state change notifications without resorting to callbacks.
- There's a new `persistence_type` (std::variant) that can hold any of the persistence specifiers (none, file directory, or user interface).
- Most of the class static constants are now `constexpr`.
- Removed the fake `ReasonCode::MQTTPP_V3_CODE`. Now all reason codes in a v3 connection are SUCCESS.
- The `mqtt::exception` checks if the 'rc' return code actually contains a reason code error, amd if so, sets it as the reason code.
- `property` can now report the `typeid` of its contained value.
- The `properties` list implements a const iterator
- Added a `to_string()` and `operator<<()` for reason codes.
- `thread_queue` is now closable.
- Added documentation for UNIX domain sockets coming in with Paho C v1.3.14
- Removed the manual implementation of `make_unique<>()`
- Added `create_options` assignment operators.
- Fixed some corner cases for topic_filter::matches()
- Cleaned up and fixed a number of example apps.
    - Most apps now except a server URI from the command line
    - 'data_publish' example uses C++17 std::filesystem for creating a file-based encrypted persistence for messages.
- Updated local CI (buildtst.sh) for current compilers and unit tests.
- Reorganized the source repository
- Completely reformat the sources and added a .clang-format file (a project master and a slightly-different one for headers).
- Added GitHub CI Action, removing legacy Travis and Appveyor files
- [#410](https://github.com/eclipse-paho/paho.mqtt.cpp/issues/410) Added 'shutdown_event' to the event consumer and reworked consumer to prevent propagating exceptions on shutdown.
- [#451](https://github.com/eclipse-paho/paho.mqtt.cpp/issues/451) Added low keep alive to async_publish_time to test connected/connection_lost callbacks
- [#503](https://github.com/eclipse-paho/paho.mqtt.cpp/issues/503) Fixed issue that generated docs were empty.
- [#518](https://github.com/eclipse-paho/paho.mqtt.cpp/pull/518) Add function for checking async consumer event queue size
- [#519](https://github.com/eclipse-paho/paho.mqtt.cpp/pull/519) Fix potential deadlock in set_callback
- [#524](https://github.com/eclipse-paho/paho.mqtt.cpp/issues/524) Fixed copy and move operations for 'subscribe_options'. Added unit tests.


## [Version 1.4.1](https://github.com/eclipse/paho.mqtt.cpp/compare/v1.4.0..v1.4.1) - (2024-07-09)

- [#458](https://github.com/eclipse/paho.mqtt.cpp/issues/458) Set 'disconnected' handler for the consumer queue.


## [Version 1.4.0](https://github.com/eclipse/paho.mqtt.cpp/compare/v1.3.2..v1.4.0) - (2024-06-16)

- Ability to build the Paho C library automatically (now working properly)
    - CMake 'PAHO_WITH_MQTT_C' option properly compiles the existing Paho C v1.3.13
    - Moved 'src/externals/' to top-level
- Reorganized the source tree:
    - Moved header files to top-level 'include/' directory.
    - Moved 'src/sampless/' to top-level and renamed 'examples/'
- Fixed and optimized 'topic_matcher' trie collection
- Added some missing Eclipse/Paho legal documents to the repo.
- Ran a spell-checker over the code and doc files.

- [#498](https://github.com/eclipse/paho.mqtt.cpp/issues/498) Overloaded property constructor to also take a uint32_t
- [#491](https://github.com/eclipse/paho.mqtt.cpp/pull/491) add topic_matcher.h to install
- [#485](https://github.com/eclipse/paho.mqtt.cpp/pull/485) export dependencies
- [#484](https://github.com/eclipse/paho.mqtt.cpp/pull/484) add token::get_message
- [#480](https://github.com/eclipse/paho.mqtt.cpp/issues/480) Fixed Paho C version in 'install_paho_mqtt_c.sh' script.
- [#473](https://github.com/eclipse/paho.mqtt.cpp/issues/473) Getter for the client's cached connect options.
- [#466](https://github.com/eclipse/paho.mqtt.cpp/pull/466) Iterable string collection
- [#416](https://github.com/eclipse/paho.mqtt.cpp/issues/416) Removed FindPahoMqttC.cmake. Using Paho C package directly.


## [Version 1.3.2](https://github.com/eclipse/paho.mqtt.cpp/compare/v1.3.1..v1.3.2) - (2023-12-05)

- [#463](https://github.com/eclipse/paho.mqtt.cpp/issues/463) Fixed generator expression for older CMake
- [#378](https://github.com/eclipse/paho.mqtt.cpp/issues/378) Bad LWT message in async_publish.cpp sample.


## [Version 1.3.1](https://github.com/eclipse/paho.mqtt.cpp/compare/v1.3.0..v1.3.1) - (2023-11-23)

- [#462](https://github.com/eclipse/paho.mqtt.cpp/pull/462) Fix version string for version v1.3.x


## [Version 1.3.0](https://github.com/eclipse/paho.mqtt.cpp/compare/v1.2.0..v1.3.0) - (2023-11-22)

- Fixed building and using library as DLL on Windows with MSVC
- Updated License to Eclipse Public License v2.0
- Updated create and connect options to better deal with MQTT protocol version
- Defaulting connect version to v5 if specified in create options.
- Added a `topic_filter` class to match a single filter to specific topics.
- Added a `topic_matcher` class to create a collection of items in a trie structure that can contain items tied to topic filters. (Useful for queues or callbacks per-subscription topic).
- Minor tweaks to prepare for C++20
- Support for Catch2 v3.x for unit tests (v2.x also still supported).
- Changed the sample apps to use the newer "mqtt://" schemas.
- Connect option initializers for v5 and WebSockets.

Fixed Issues and Pull Requests:

- [#343](https://github.com/eclipse/paho.mqtt.cpp/issues/343) async_client::try_consume_message_until taking single parameter fails to compile
- [#445](https://github.com/eclipse/paho.mqtt.cpp/pull/445) Update properties when moving/copying connect options.
- [#325](https://github.com/eclipse/paho.mqtt.cpp/issues/325) Cache connect options in client to keep memory valid for callbacks like SSL on_error()
- [#361](https://github.com/eclipse/paho.mqtt.cpp/issues/361) Added missing LICENSE file to conform to GitHub conventions.
- [#304](https://github.com/eclipse/paho.mqtt.cpp/issues/304) Missing create_options::DFLT_C_STRUCT symbol when linking with MSVC.
- [#429](https://github.com/eclipse/paho.mqtt.cpp/issues/429) Remove declaration of connect_options::to_string() with missing implementation.
- [#411](https://github.com/eclipse/paho.mqtt.cpp/issues/411) Missing virtual keyword for some client methods
- [#444](https://github.com/eclipse/paho.mqtt.cpp/issues/444) Unit tests to check that connect options builder sets properties.
- [#313](https://github.com/eclipse/paho.mqtt.cpp/issues/313) Get unit tests building on Windows. Needed to get rid of make_unique<> for Windows
- [#397](https://github.com/eclipse/paho.mqtt.cpp/issues/397) Doc about clean session in connect_options.h is wrong
- [#442](https://github.com/eclipse/paho.mqtt.cpp/issues/442) g++ complains with multiple definition of static constexpr for mixed C++11/17 builds
- [#445](https://github.com/eclipse/paho.mqtt.cpp/pull/445)Fix copy/move constructor for connect/disconnect opts with properties
- [#425](https://github.com/eclipse/paho.mqtt.cpp/pull/425) Silence warning for unused variable rsp in class `unsubscribe_response`
- [#440](https://github.com/eclipse/paho.mqtt.cpp/pull/440) Fix typos across the project
- [#428](https://github.com/eclipse/paho.mqtt.cpp/issues/428) Fixed type in create_options.h
- [#407](https://github.com/eclipse/paho.mqtt.cpp/pull/407) Fix nodiscard warnings in sync client
- [#385](https://github.com/eclipse/paho.mqtt.cpp/issues/385) Thread queue deadlock with multiple consumers
- [#374](https://github.com/eclipse/paho.mqtt.cpp/pull/374) Add Paho C as a submodeule
- [#350](https://github.com/eclipse/paho.mqtt.cpp/pull/350) avoid adding Paho MQTT C library twice
- [#253](https://github.com/eclipse/paho.mqtt.cpp/issues/253) implicit capture of 'this' via '[=]' is deprecated in C++20
- [#337](https://github.com/eclipse/paho.mqtt.cpp/issues/337) copy/move of caPath_ in ssl_options
- [#330](https://github.com/eclipse/paho.mqtt.cpp/pull/330) added /build/ folder to .gitignore
- [#317](https://github.com/eclipse/paho.mqtt.cpp/issues/317) String constructor using just len instead of end iterator.
- [#323](https://github.com/eclipse/paho.mqtt.cpp/issues/323) Added Session Expiry Interval to v5 chat sample to test.


## [Version 1.2.0](https://github.com/eclipse/paho.mqtt.cpp/compare/v1.1..v1.2.0) - (2020-12-27)

This release bring in some missing MQTT v5 features, brings in support for websocket headers and proxies, ALPN protocol lists, adds the builder pattern for options, and fixes a number of bugs in both the C++ library and the underlying C lib.

Requires Paho C v1.3.8

- Missing MQTT v5 features:
    - Ability to add properties to Subscribe and Unsubscribe packets (i.e. subscription identifiers)
    - "Disconnected" callback gives reason code and properties for server disconnect
- New `create_options` that can be used to construct a client with new features:
    - Send while disconnected before the 1st successful connection
    - Output buffer can delete oldest messages when full
    - Can choose to clear the persistence store on startup
    - Select whether to persist QoS 0 messages
- Started classes to create options using the Builder Pattern, with the `create_options_builder`, `connect_options_builder`, `message_ptr_builder`, etc.
- User-defined websocket HTTP headers.
- HTTP/S proxy support
- Added ALPN protocol support to SSL/TLS options
- SSL/TLS error and PSK callback support
- Update connection callback support (change credentials when using auto-reconnect)
- Updates to the sample apps:
    - Overall cleanup with better consistency
    - Example of using websockets and a proxy
    - User-based file persistence with simple encoding/encryption
    - Sharing a client between multiple threads
- Converted the unit tests to use Catch2
- All library exceptions are now properly derived from the `mqtt::exception` base class.
- [#231] Added `on_disconnected` callback to handle receipt of disconnect packet from server.
- [#211, #223, #235] Removed use of Log() function from the Paho C library.
- [#227] Fixed race condition in thread-safe queue
- [#224] & [#255] Subscribing to MQTT v3 broker with array of one topic causes segfault.
- [#282] Ability to build Debian/Ubuntu package
- [#300] Calling `reconnect()` was hanging forever, even when successful. In addition several of the synchronous `client` calls were hanging forever on failure. They now properly throw a `timeout_error` exception.
- Several memory issues and bug fixes from updated Paho C library support.


## Version 1.1 (2019-10-12)

This release was primarily to add MQTT v5 support and server responses.

- MQTT v5 support:
    - **Properties**
        - New `property` class acts something like a std::variant to hold a property of any supported type.
        - New `properties` class is a collection type to hold all the properties for a single transmitted packet.
        - Properties can be added to outbound messages and obtained from received messages.
        - Properties can also be obtained from server responses to requests such as from a _connect_ call. These are available in the `token` objects when they complete.
    - The client object tracks the desired MQTT version that the app requested and/or is currently connected at. Internally this is now required by the `response_options` the need to distinguish between pre-v5 and post-v5 callback functions.
    - MQTT v5 reason codes for requests are available via `token` objects when they complete. They are also available in `exception` objects that are thrown by tokens.
    - Support for subscribe options, like no local subscriptions, etc.
    - Sample applications were added showing how to do basic Remote Procedure Calls (RPC's) with MQTT v5 using the *RESPONSE_TOPIC* and *CORRELATION_DATA* properties. These are *rpc_math_cli* and *rpc_math_srvr* in the _src/samples_ directory.
    - A sample "chat" application was added, showing how to use subscribe options, such as "no local".
- More descriptive error messages (PR #154), integrated into the `mqtt::exception` class. MQTT v5 reason codes are also included in the exceptions when an error occurs.
- Applications can (finally) get server responses from the various ACK packets. These are available through the tokens after they complete, as `connect_response`, `subscribe_response`, and `unsubscribe_response`.
- The `topic` objects can be used to subscribe.
- Applications can register individual callback functions instead of using a `callback` interface object. This allows easy use of lambda functions for callbacks.
- The connect options can take a LWT as a plain message, via `connect_options::set_will_message()`
- New unit tests have started using _Catch2_.
- Tested with Paho C v1.3.1


## Version 1.0.1 (2018-12-12)

This is a bug-fix released aimed mainly at issues with the build system and working towards more "modern" usage of CMake. In addition:

- Support for Paho C v1.2.1
- Fixed a number of build issues, particularly on Windows
- Windows shared libraries (DLL's) now supported
- Several minor bug fixes


##  Version 1.0.0 (2017-07-23)

The initial Paho C++ Client library for memory-managed platforms (Linux, Windows, etc).

- Requires Paho C Client Library v1.2.
- MQTT 3.1 & 3.1.1
- SSL/TLS
- Asynchronous & Synchronous interfaces
- Persistence and off-line buffering
- Automatic reconnect
- High availability.

```

`CMakeLists.txt`:

```txt
# CMakeLists.txt
#
# Top-level CMake file for the Paho C++ library.
#
#*******************************************************************************
# This is part of the Paho MQTT C++ client library.
#
# Copyright (c) 2017-2025, Frank Pagliughi
# Copyright (c) 2016-2017, Guilherme Maciel Ferreira
#
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v2.0
# and Eclipse Distribution License v1.0 which accompany this distribution.
# 
# The Eclipse Public License is available at
#   http://www.eclipse.org/legal/epl-v20.html
# and the Eclipse Distribution License is available at
#   http://www.eclipse.org/org/documents/edl-v10.php.
# 
# Contributors:
#   Guilherme Maciel Ferreira - initial version
#   Frank Pagliughi
#*******************************************************************************/

cmake_minimum_required(VERSION 3.13)

project(PahoMqttCpp VERSION "1.5.4")

## --- Build options ---

if(WIN32)
    option(PAHO_BUILD_STATIC "Build static library" TRUE)
    option(PAHO_BUILD_SHARED "Build shared library (DLL)" FALSE)
    option(PAHO_WITH_SSL "Build SSL-enabled library" FALSE)
else()
    option(PAHO_BUILD_STATIC "Build static library" FALSE)
    option(PAHO_BUILD_SHARED "Build shared library" TRUE)
    option(PAHO_WITH_SSL "Build SSL-enabled library" TRUE)
    option(PAHO_BUILD_DEB_PACKAGE "Build debian package" FALSE)
endif()

option(PAHO_BUILD_SAMPLES "Build sample/example programs" FALSE)
option(PAHO_BUILD_EXAMPLES "Build sample/example programs" FALSE)
option(PAHO_BUILD_TESTS "Build tests (requires Catch2)" FALSE)
option(PAHO_BUILD_DOCUMENTATION "Create and install the API documentation (requires Doxygen)" FALSE)
option(PAHO_WITH_MQTT_C "Build Paho C from the internal GIT submodule." FALSE)

if(NOT PAHO_BUILD_SHARED AND NOT PAHO_BUILD_STATIC)
    message(FATAL_ERROR "You must set either PAHO_BUILD_SHARED, PAHO_BUILD_STATIC, or both")
endif()

# --- Setting naming variables ---

set(PAHO_MQTTPP_GENERATED_DIR ${CMAKE_CURRENT_BINARY_DIR}/generated)

## --- Find Paho C or build it, if reqested ---

if(PAHO_WITH_SSL)
    find_package(OpenSSL REQUIRED)
    set(PAHO_MQTT_C_LIB eclipse-paho-mqtt-c::paho-mqtt3as)
else()
    set(PAHO_MQTT_C_LIB eclipse-paho-mqtt-c::paho-mqtt3a)
endif()

if(PAHO_WITH_MQTT_C)
    message(STATUS "Paho C: Bundled")

    ## Build the Paho C library from the submodule
    set(PAHO_ENABLE_TESTING FALSE CACHE BOOL "No Paho C tests")
    set(PAHO_HIGH_PERFORMANCE TRUE CACHE BOOL "Paho C high performance")
    if(NOT WIN32)
        set(PAHO_WITH_UNIX_SOCKETS TRUE CACHE BOOL "Support for Unix-domain sockets")
    endif()
    set(CMAKE_C_STANDARD 99 CACHE STRING "Paho C language standard")

    add_subdirectory(${PROJECT_SOURCE_DIR}/externals/paho-mqtt-c)

    ## Alias namespace so that the full names can be used with the subdir.
    if(PAHO_BUILD_SHARED)
        add_library(eclipse-paho-mqtt-c::paho-mqtt3a ALIAS paho-mqtt3a)
        list(APPEND PAHO_MQTT_C_LIBS paho-mqtt3a)
        if(PAHO_WITH_SSL)
            add_library(eclipse-paho-mqtt-c::paho-mqtt3as ALIAS paho-mqtt3as)
            list(APPEND PAHO_MQTT_C_LIBS paho-mqtt3as)
        endif()
    endif()

    if(PAHO_BUILD_STATIC)
        add_library(eclipse-paho-mqtt-c::paho-mqtt3a-static ALIAS paho-mqtt3a-static)
        list(APPEND PAHO_MQTT_C_LIBS paho-mqtt3a-static)
        if(PAHO_WITH_SSL)
            add_library(eclipse-paho-mqtt-c::paho-mqtt3as-static ALIAS paho-mqtt3as-static)
            list(APPEND PAHO_MQTT_C_LIBS paho-mqtt3as-static)
        endif()
    endif()

    ## install paho.mqtt.c library (appending to PahoMqttCpp export)
    install(TARGETS ${PAHO_MQTT_C_LIBS}
        EXPORT PahoMqttCpp
        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
    )
else()
    find_package(eclipse-paho-mqtt-c REQUIRED)
endif()

# --- System Details ---

include(GNUInstallDirs)

if(WIN32)
    add_definitions(-D_CRT_SECURE_NO_WARNINGS)
    set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)
    set(LIBS_SYSTEM ws2_32)
endif()

# --- The headers ---

add_subdirectory(include/mqtt)

# For the paho_mqtt_c module
list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)
add_subdirectory(src)

# --- Documentation ---

if(PAHO_BUILD_DOCUMENTATION)
    add_subdirectory(doc)
endif()

# --- Example Apps ---

if(PAHO_BUILD_SAMPLES OR PAHO_BUILD_EXAMPLES)
    add_subdirectory(examples)
endif()

# --- Unit Tests ---

if(PAHO_BUILD_TESTS)
    enable_testing()
    add_subdirectory(test/unit)
endif()

## --- Install generated header(s) ---

install(
    DIRECTORY
        ${PAHO_MQTTPP_GENERATED_DIR}/include/
    DESTINATION
        ${CMAKE_INSTALL_INCLUDEDIR}
)

## --- Packaging settings ---

if(WIN32)
    set(CPACK_GENERATOR "ZIP")
elseif(UNIX)
    if(PAHO_BUILD_DEB_PACKAGE)
        set(CPACK_GENERATOR "DEB")
        include(cmake/CPackDebConfig.cmake)
    else()
        set(CPACK_GENERATOR "TGZ")
	endif()
endif()

include(CPack)

# --- Export CMake TARGETS ---

add_subdirectory(cmake)


```

`CODE_OF_CONDUCT.md`:

```md
# Community Code of Conduct

**Version 1.2  
August 19, 2020**

## Our Pledge

In the interest of fostering an open and welcoming environment, we as community members, contributors, committers, and project leaders pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment include:

*   Using welcoming and inclusive language
*   Being respectful of differing viewpoints and experiences
*   Gracefully accepting constructive criticism
*   Focusing on what is best for the community
*   Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

*   The use of sexualized language or imagery and unwelcome sexual attention or advances
*   Trolling, insulting/derogatory comments, and personal or political attacks
*   Public or private harassment
*   Publishing others' private information, such as a physical or electronic address, without explicit permission
*   Other conduct which could reasonably be considered inappropriate in a professional setting

## Our Responsibilities

With the support of the Eclipse Foundation staff (the “Staff”), project committers and leaders are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.

Project committers and leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.

## Scope

This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the Eclipse Foundation project or its community in public spaces. Examples of representing a project or community include posting via an official social media account, or acting as a project representative at an online or offline event. Representation of a project may be further defined and clarified by project committers, leaders, or the EMO.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the Staff at codeofconduct@eclipse.org. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The Staff is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.

Project committers or leaders who do not follow the Code of Conduct in good faith may face temporary or permanent repercussions as determined by the Staff.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org) , version 1.4, available at [https://www.contributor-covenant.org/version/1/4/code-of-conduct.html](https://www.contributor-covenant.org/version/1/4/code-of-conduct/)


```

`CODING_STYLE.md`:

```md
# Eclipse Paho MQTT C++ Client Library
# Coding Styles

This document describes the coding style and language conventions used by the Eclipse Paho C++ Client Library.

## Language Standard

The Paho C++ library uses Modern C++, adhering to the C++11 standard.

Nothing in the library should prevent it from being built with a compiler adhering to a newer standard such as C++14 or C++17, but at this point the library itself doesn't use any newer language feature than C++11. Unfortunately, compilers vary wildly from version to version and platform to platform. So this is a constant struggle to keep true.

Adherence to the base C++11 standard may change at some point in the future. Newer versions of the library will likely start using newer language features some time in the future as they are more widely adapted by compilers and projects. The next logical jump would probably be to C++17.

## Naming Convention

The Paho C++ library attempts to follow the naming conventions of the C++ standard library as much as possible, as this seems the most definitive standard for the language.

 - Class names are lower snake case:  *classes_like_this*
 - Function names are lower snake case:  *functions_like_this*
 - Variable names are lower camel case:  *varsLikeThis*
 - Class members are lower camel case with a trailing underscore: *memVarsLikeThis_*
 - Constants are all caps: *CONSTANTS_LIKE_THIS*

## Format Conventions

The top-level project directory contains a _.editorconfig_ file with some basic hints as to formatting conventions for source files.

A few minutes looking through the existing sources will reveal the basic styles used. Pull Requests should generally try to fit in to the existing style and not try to impose new ones.

At some point in the future, a formatter may be added to the project (probably Clang format), but until then, any sources that can be fixed up with an automated code generator or beautifier would generally be accepted into the project. But at some point soon after would then be reformat to fit into the overall conventions.
```

`CONTRIBUTING.md`:

```md
# Contributing to Paho

Thanks for your interest in this project!

You can contribute bugfixes and new features by sending pull requests through GitHub.

## Legal

In order for your contribution to be accepted, it must comply with the Eclipse Foundation IP policy.

Please read the [Eclipse Foundation policy on accepting contributions via Git](http://wiki.eclipse.org/Development_Resources/Contributing_via_Git).

1. Sign the [Eclipse ECA](http://www.eclipse.org/legal/ECA.php)
  1. Register for an Eclipse Foundation User ID. You can register [here](https://dev.eclipse.org/site_login/createaccount.php).
  2. Log into the [Eclipse projects forge](https://www.eclipse.org/contribute/cla), and click on 'Eclipse Contributor Agreement'.
2. Go to your [account settings](https://dev.eclipse.org/site_login/myaccount.php#open_tab_accountsettings) and add your GitHub username to your account.
3. Make sure that you _sign-off_ your Git commits in the following format:
  ``` Signed-off-by: Alex Smith <alexsmith@nowhere.com> ``` This is usually at the bottom of the commit message. You can automate this by adding the '-s' flag when you make the commits. e.g.   ```git commit -s -m "Adding a cool feature"```
4. Ensure that the email address that you make your commits with is the same one you used to sign up to the Eclipse Foundation website with.

## Contributing a change

1. [Fork the repository on GitHub](https://github.com/eclipse/paho.mqtt.cpp/fork)
2. Clone the forked repository onto your computer: ``` git clone https://github.com/<your username>/paho.mqtt.cpp.git ```
3. Create a new branch from the latest ```develop``` branch with ```git checkout -b YOUR_BRANCH_NAME origin/develop```
4. Make your changes
5. If developing a new feature, make sure to include unit tests.
6. Ensure that all new and existing tests pass.
7. Commit the changes into the branch: ``` git commit -s ``` Make sure that your commit message is meaningful and describes your changes correctly.
8. If you have a lot of commits for the change, squash them into a single / few commits.
9. Push the changes in your branch to your forked repository.
10. Finally, go to [https://github.com/eclipse/paho.mqtt.cpp](https://github.com/eclipse/paho.mqtt.cpp) and create a pull request from your "YOUR_BRANCH_NAME" branch to the ```develop``` one to request review and merge of the commits in your pushed branch.


What happens next depends on the content of the patch. If it is 100% authored
by the contributor and is less than 1000 lines (and meets the needs of the
project), then it can be pulled into the main repository. If not, more steps
are required. These are detailed in the
[legal process poster](http://www.eclipse.org/legal/EclipseLegalProcessPoster.pdf).



## Developer resources:


Information regarding source code management, builds, coding standards, and more.

- [https://projects.eclipse.org/projects/iot.paho/developer](https://projects.eclipse.org/projects/iot.paho/developer)

Contact:
--------

Contact the project developers via the project's development
[mailing list](https://dev.eclipse.org/mailman/listinfo/paho-dev).

Search for bugs:
----------------

This project uses GitHub Issues here: [github.com/eclipse/paho.mqtt.cpp/issues](https://github.com/eclipse/paho.mqtt.cpp/issues) to track ongoing development and issues.

Create a new bug:
-----------------

Be sure to search for existing bugs before you create another one. Remember that contributions are always welcome!

- [Create new Paho bug](https://github.com/eclipse/paho.mqtt.cpp/issues/new)

```

`Doxyfile`:

```
# Doxyfile 1.8.6

# This file describes the settings to be used by the documentation system
# doxygen (www.doxygen.org) for a project.
#
# All text after a double hash (##) is considered a comment and is placed in
# front of the TAG it is preceding.
#
# All text after a single hash (#) is considered a comment and will be ignored.
# The format is:
# TAG = value [value, ...]
# For lists, items can also be appended using:
# TAG += value [value, ...]
# Values that contain spaces should be placed between quotes (\" \").

#---------------------------------------------------------------------------
# Project related configuration options
#---------------------------------------------------------------------------

# This tag specifies the encoding used for all characters in the config file
# that follow. The default is UTF-8 which is also the encoding used for all text
# before the first occurrence of this tag. Doxygen uses libiconv (or the iconv
# built into libc) for the transcoding. See http://www.gnu.org/software/libiconv
# for the list of possible encodings.
# The default value is: UTF-8.

DOXYFILE_ENCODING      = UTF-8

# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
# double-quotes, unless you are using Doxywizard) that should identify the
# project for which the documentation is generated. This name is used in the
# title of most generated pages and in a few other places.
# The default value is: My Project.

PROJECT_NAME           = "Paho C++"

# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
# could be handy for archiving the generated documentation or if some version
# control system is used.

PROJECT_NUMBER         = 1.0

# Using the PROJECT_BRIEF tag one can provide an optional one line description
# for a project that appears at the top of each page and should give viewer a
# quick idea about the purpose of the project. Keep the description short.

PROJECT_BRIEF          = "The Paho MQTT C++ Client Library"

# With the PROJECT_LOGO tag one can specify an logo or icon that is included in
# the documentation. The maximum height of the logo should not exceed 55 pixels
# and the maximum width should not exceed 200 pixels. Doxygen will copy the logo
# to the output directory.

PROJECT_LOGO           = doc/pahologo.png

# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
# into which the generated documentation will be written. If a relative path is
# entered, it will be relative to the location where doxygen was started. If
# left blank the current directory will be used.

OUTPUT_DIRECTORY       = doc

# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 4096 sub-
# directories (in 2 levels) under the output directory of each output format and
# will distribute the generated files over these directories. Enabling this
# option can be useful when feeding doxygen a huge amount of source files, where
# putting all generated files in the same directory would otherwise causes
# performance problems for the file system.
# The default value is: NO.

CREATE_SUBDIRS         = NO

# The OUTPUT_LANGUAGE tag is used to specify the language in which all
# documentation generated by doxygen is written. Doxygen will use this
# information to generate all constant output in the proper language.
# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
# Ukrainian and Vietnamese.
# The default value is: English.

OUTPUT_LANGUAGE        = English

# If the BRIEF_MEMBER_DESC tag is set to YES doxygen will include brief member
# descriptions after the members that are listed in the file and class
# documentation (similar to Javadoc). Set to NO to disable this.
# The default value is: YES.

BRIEF_MEMBER_DESC      = YES

# If the REPEAT_BRIEF tag is set to YES doxygen will prepend the brief
# description of a member or function before the detailed description
#
# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
# brief descriptions will be completely suppressed.
# The default value is: YES.

REPEAT_BRIEF           = YES

# This tag implements a quasi-intelligent brief description abbreviator that is
# used to form the text in various listings. Each string in this list, if found
# as the leading text of the brief description, will be stripped from the text
# and the result, after processing the whole list, is used as the annotated
# text. Otherwise, the brief description is used as-is. If left blank, the
# following values are used ($name is automatically replaced with the name of
# the entity):The $name class, The $name widget, The $name file, is, provides,
# specifies, contains, represents, a, an and the.

ABBREVIATE_BRIEF       =

# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
# doxygen will generate a detailed section even if there is only a brief
# description.
# The default value is: NO.

ALWAYS_DETAILED_SEC    = NO

# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
# inherited members of a class in the documentation of that class as if those
# members were ordinary class members. Constructors, destructors and assignment
# operators of the base classes will not be shown.
# The default value is: NO.

INLINE_INHERITED_MEMB  = NO

# If the FULL_PATH_NAMES tag is set to YES doxygen will prepend the full path
# before files name in the file list and in the header files. If set to NO the
# shortest path that makes the file name unique will be used
# The default value is: YES.

FULL_PATH_NAMES        = YES

# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
# Stripping is only done if one of the specified strings matches the left-hand
# part of the path. The tag can be used to show relative paths in the file list.
# If left blank the directory from which doxygen is run is used as the path to
# strip.
#
# Note that you can specify absolute paths here, but also relative paths, which
# will be relative from the directory where doxygen is started.
# This tag requires that the tag FULL_PATH_NAMES is set to YES.

STRIP_FROM_PATH        =

# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
# path mentioned in the documentation of a class, which tells the reader which
# header file to include in order to use a class. If left blank only the name of
# the header file containing the class definition is used. Otherwise one should
# specify the list of include paths that are normally passed to the compiler
# using the -I flag.

STRIP_FROM_INC_PATH    =

# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
# less readable) file names. This can be useful is your file systems doesn't
# support long names like on DOS, Mac, or CD-ROM.
# The default value is: NO.

SHORT_NAMES            = NO

# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
# first line (until the first dot) of a Javadoc-style comment as the brief
# description. If set to NO, the Javadoc-style will behave just like regular Qt-
# style comments (thus requiring an explicit @brief command for a brief
# description.)
# The default value is: NO.

JAVADOC_AUTOBRIEF      = YES

# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
# line (until the first dot) of a Qt-style comment as the brief description. If
# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
# requiring an explicit \brief command for a brief description.)
# The default value is: NO.

QT_AUTOBRIEF           = NO

# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
# a brief description. This used to be the default behavior. The new default is
# to treat a multi-line C++ comment block as a detailed description. Set this
# tag to YES if you prefer the old behavior instead.
#
# Note that setting this tag to YES also means that rational rose comments are
# not recognized any more.
# The default value is: NO.

MULTILINE_CPP_IS_BRIEF = NO

# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
# documentation from any documented member that it re-implements.
# The default value is: YES.

INHERIT_DOCS           = YES

# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce a
# new page for each member. If set to NO, the documentation of a member will be
# part of the file/class/namespace that contains it.
# The default value is: NO.

SEPARATE_MEMBER_PAGES  = NO

# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
# uses this value to replace tabs by spaces in code fragments.
# Minimum value: 1, maximum value: 16, default value: 4.

TAB_SIZE               = 4

# This tag can be used to specify a number of aliases that act as commands in
# the documentation. An alias has the form:
# name=value
# For example adding
# "sideeffect=@par Side Effects:\n"
# will allow you to put the command \sideeffect (or @sideeffect) in the
# documentation, which will result in a user-defined paragraph with heading
# "Side Effects:". You can put \n's in the value part of an alias to insert
# newlines.

ALIASES                =

# This tag can be used to specify a number of word-keyword mappings (TCL only).
# A mapping has the form "name=value". For example adding "class=itcl::class"
# will allow you to use the command class in the itcl::class meaning.

TCL_SUBST              =

# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
# only. Doxygen will then generate output that is more tailored for C. For
# instance, some of the names that are used will be different. The list of all
# members will be omitted, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_FOR_C  = NO

# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
# Python sources only. Doxygen will then generate output that is more tailored
# for that language. For instance, namespaces will be presented as packages,
# qualified scopes will look different, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_JAVA   = NO

# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
# sources. Doxygen will then generate output that is tailored for Fortran.
# The default value is: NO.

OPTIMIZE_FOR_FORTRAN   = NO

# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
# sources. Doxygen will then generate output that is tailored for VHDL.
# The default value is: NO.

OPTIMIZE_OUTPUT_VHDL   = NO

# Doxygen selects the parser to use depending on the extension of the files it
# parses. With this tag you can assign which parser to use for a given
# extension. Doxygen has a built-in mapping, but you can override or extend it
# using this tag. The format is ext=language, where ext is a file extension, and
# language is one of the parsers supported by doxygen: IDL, Java, Javascript,
# C#, C, C++, D, PHP, Objective-C, Python, Fortran, VHDL. For instance to make
# doxygen treat .inc files as Fortran files (default is PHP), and .f files as C
# (default is Fortran), use: inc=Fortran f=C.
#
# Note For files without extension you can use no_extension as a placeholder.
#
# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
# the files are not read by doxygen.

EXTENSION_MAPPING      =

# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
# according to the Markdown format, which allows for more readable
# documentation. See http://daringfireball.net/projects/markdown/ for details.
# The output of markdown processing is further processed by doxygen, so you can
# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
# case of backward compatibilities issues.
# The default value is: YES.

MARKDOWN_SUPPORT       = YES

# When enabled doxygen tries to link words that correspond to documented
# classes, or namespaces to their corresponding documentation. Such a link can
# be prevented in individual cases by by putting a % sign in front of the word
# or globally by setting AUTOLINK_SUPPORT to NO.
# The default value is: YES.

AUTOLINK_SUPPORT       = YES

# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
# to include (a tag file for) the STL sources as input, then you should set this
# tag to YES in order to let doxygen match functions declarations and
# definitions whose arguments contain STL classes (e.g. func(std::string);
# versus func(std::string) {}). This also make the inheritance and collaboration
# diagrams that involve STL classes more complete and accurate.
# The default value is: NO.

BUILTIN_STL_SUPPORT    = YES

# If you use Microsoft's C++/CLI language, you should set this option to YES to
# enable parsing support.
# The default value is: NO.

CPP_CLI_SUPPORT        = NO

# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
# http://www.riverbankcomputing.co.uk/software/sip/intro) sources only. Doxygen
# will parse them like normal C++ but will assume all classes use public instead
# of private inheritance when no explicit protection keyword is present.
# The default value is: NO.

SIP_SUPPORT            = NO

# For Microsoft's IDL there are propget and propput attributes to indicate
# getter and setter methods for a property. Setting this option to YES will make
# doxygen to replace the get and set methods by a property in the documentation.
# This will only work if the methods are indeed getting or setting a simple
# type. If this is not the case, or you want to show the methods anyway, you
# should set this option to NO.
# The default value is: YES.

IDL_PROPERTY_SUPPORT   = YES

# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
# tag is set to YES, then doxygen will reuse the documentation of the first
# member in the group (if any) for the other members of the group. By default
# all members of a group must be documented explicitly.
# The default value is: NO.

DISTRIBUTE_GROUP_DOC   = NO

# Set the SUBGROUPING tag to YES to allow class member groups of the same type
# (for instance a group of public functions) to be put as a subgroup of that
# type (e.g. under the Public Functions section). Set it to NO to prevent
# subgrouping. Alternatively, this can be done per class using the
# \nosubgrouping command.
# The default value is: YES.

SUBGROUPING            = YES

# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
# are shown inside the group in which they are included (e.g. using \ingroup)
# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
# and RTF).
#
# Note that this feature does not work in combination with
# SEPARATE_MEMBER_PAGES.
# The default value is: NO.

INLINE_GROUPED_CLASSES = NO

# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
# with only public data fields or simple typedef fields will be shown inline in
# the documentation of the scope in which they are defined (i.e. file,
# namespace, or group documentation), provided this scope is documented. If set
# to NO, structs, classes, and unions are shown on a separate page (for HTML and
# Man pages) or section (for LaTeX and RTF).
# The default value is: NO.

INLINE_SIMPLE_STRUCTS  = NO

# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
# enum is documented as struct, union, or enum with the name of the typedef. So
# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
# with name TypeT. When disabled the typedef will appear as a member of a file,
# namespace, or class. And the struct will be named TypeS. This can typically be
# useful for C code in case the coding convention dictates that all compound
# types are typedef'ed and only the typedef is referenced, never the tag name.
# The default value is: NO.

TYPEDEF_HIDES_STRUCT   = NO

# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
# cache is used to resolve symbols given their name and scope. Since this can be
# an expensive process and often the same symbol appears multiple times in the
# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
# doxygen will become slower. If the cache is too large, memory is wasted. The
# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
# symbols. At the end of a run doxygen will report the cache usage and suggest
# the optimal cache size from a speed point of view.
# Minimum value: 0, maximum value: 9, default value: 0.

LOOKUP_CACHE_SIZE      = 0

#---------------------------------------------------------------------------
# Build related configuration options
#---------------------------------------------------------------------------

# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
# documentation are documented, even if no documentation was available. Private
# class members and static file members will be hidden unless the
# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
# Note: This will also disable the warnings about undocumented members that are
# normally produced when WARNINGS is set to YES.
# The default value is: NO.

EXTRACT_ALL            = NO

# If the EXTRACT_PRIVATE tag is set to YES all private members of a class will
# be included in the documentation.
# The default value is: NO.

EXTRACT_PRIVATE        = NO

# If the EXTRACT_PACKAGE tag is set to YES all members with package or internal
# scope will be included in the documentation.
# The default value is: NO.

EXTRACT_PACKAGE        = NO

# If the EXTRACT_STATIC tag is set to YES all static members of a file will be
# included in the documentation.
# The default value is: NO.

EXTRACT_STATIC         = NO

# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) defined
# locally in source files will be included in the documentation. If set to NO
# only classes defined in header files are included. Does not have any effect
# for Java sources.
# The default value is: YES.

EXTRACT_LOCAL_CLASSES  = YES

# This flag is only useful for Objective-C code. When set to YES local methods,
# which are defined in the implementation section but not in the interface are
# included in the documentation. If set to NO only methods in the interface are
# included.
# The default value is: NO.

EXTRACT_LOCAL_METHODS  = NO

# If this flag is set to YES, the members of anonymous namespaces will be
# extracted and appear in the documentation as a namespace called
# 'anonymous_namespace{file}', where file will be replaced with the base name of
# the file that contains the anonymous namespace. By default anonymous namespace
# are hidden.
# The default value is: NO.

EXTRACT_ANON_NSPACES   = NO

# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
# undocumented members inside documented classes or files. If set to NO these
# members will be included in the various overviews, but no documentation
# section is generated. This option has no effect if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_MEMBERS     = NO

# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
# undocumented classes that are normally visible in the class hierarchy. If set
# to NO these classes will be included in the various overviews. This option has
# no effect if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_CLASSES     = NO

# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
# (class|struct|union) declarations. If set to NO these declarations will be
# included in the documentation.
# The default value is: NO.

HIDE_FRIEND_COMPOUNDS  = NO

# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
# documentation blocks found inside the body of a function. If set to NO these
# blocks will be appended to the function's detailed documentation block.
# The default value is: NO.

HIDE_IN_BODY_DOCS      = NO

# The INTERNAL_DOCS tag determines if documentation that is typed after a
# \internal command is included. If the tag is set to NO then the documentation
# will be excluded. Set it to YES to include the internal documentation.
# The default value is: NO.

INTERNAL_DOCS          = NO

# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
# names in lower-case letters. If set to YES upper-case letters are also
# allowed. This is useful if you have classes or files whose names only differ
# in case and if your file system supports case sensitive file names. Windows
# and Mac users are advised to set this option to NO.
# The default value is: system dependent.

CASE_SENSE_NAMES       = YES

# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
# their full class and namespace scopes in the documentation. If set to YES the
# scope will be hidden.
# The default value is: NO.

HIDE_SCOPE_NAMES       = NO

# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
# the files that are included by a file in the documentation of that file.
# The default value is: YES.

SHOW_INCLUDE_FILES     = YES

# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
# grouped member an include statement to the documentation, telling the reader
# which file to include in order to use the member.
# The default value is: NO.

SHOW_GROUPED_MEMB_INC  = NO

# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
# files with double quotes in the documentation rather than with sharp brackets.
# The default value is: NO.

FORCE_LOCAL_INCLUDES   = NO

# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
# documentation for inline members.
# The default value is: YES.

INLINE_INFO            = YES

# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
# (detailed) documentation of file and class members alphabetically by member
# name. If set to NO the members will appear in declaration order.
# The default value is: YES.

SORT_MEMBER_DOCS       = YES

# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
# descriptions of file, namespace and class members alphabetically by member
# name. If set to NO the members will appear in declaration order. Note that
# this will also influence the order of the classes in the class list.
# The default value is: NO.

SORT_BRIEF_DOCS        = NO

# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
# (brief and detailed) documentation of class members so that constructors and
# destructors are listed first. If set to NO the constructors will appear in the
# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
# member documentation.
# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
# detailed member documentation.
# The default value is: NO.

SORT_MEMBERS_CTORS_1ST = NO

# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
# of group names into alphabetical order. If set to NO the group names will
# appear in their defined order.
# The default value is: NO.

SORT_GROUP_NAMES       = NO

# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
# fully-qualified names, including namespaces. If set to NO, the class list will
# be sorted only by class name, not including the namespace part.
# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
# Note: This option applies only to the class list, not to the alphabetical
# list.
# The default value is: NO.

SORT_BY_SCOPE_NAME     = NO

# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
# type resolution of all parameters of a function it will reject a match between
# the prototype and the implementation of a member function even if there is
# only one candidate or it is obvious which candidate to choose by doing a
# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
# accept a match between prototype and implementation in such cases.
# The default value is: NO.

STRICT_PROTO_MATCHING  = NO

# The GENERATE_TODOLIST tag can be used to enable ( YES) or disable ( NO) the
# todo list. This list is created by putting \todo commands in the
# documentation.
# The default value is: YES.

GENERATE_TODOLIST      = YES

# The GENERATE_TESTLIST tag can be used to enable ( YES) or disable ( NO) the
# test list. This list is created by putting \test commands in the
# documentation.
# The default value is: YES.

GENERATE_TESTLIST      = YES

# The GENERATE_BUGLIST tag can be used to enable ( YES) or disable ( NO) the bug
# list. This list is created by putting \bug commands in the documentation.
# The default value is: YES.

GENERATE_BUGLIST       = YES

# The GENERATE_DEPRECATEDLIST tag can be used to enable ( YES) or disable ( NO)
# the deprecated list. This list is created by putting \deprecated commands in
# the documentation.
# The default value is: YES.

GENERATE_DEPRECATEDLIST= YES

# The ENABLED_SECTIONS tag can be used to enable conditional documentation
# sections, marked by \if <section_label> ... \endif and \cond <section_label>
# ... \endcond blocks.

ENABLED_SECTIONS       =

# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
# initial value of a variable or macro / define can have for it to appear in the
# documentation. If the initializer consists of more lines than specified here
# it will be hidden. Use a value of 0 to hide initializers completely. The
# appearance of the value of individual variables and macros / defines can be
# controlled using \showinitializer or \hideinitializer command in the
# documentation regardless of this setting.
# Minimum value: 0, maximum value: 10000, default value: 30.

MAX_INITIALIZER_LINES  = 30

# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
# the bottom of the documentation of classes and structs. If set to YES the list
# will mention the files that were used to generate the documentation.
# The default value is: YES.

SHOW_USED_FILES        = YES

# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
# will remove the Files entry from the Quick Index and from the Folder Tree View
# (if specified).
# The default value is: YES.

SHOW_FILES             = YES

# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
# page. This will remove the Namespaces entry from the Quick Index and from the
# Folder Tree View (if specified).
# The default value is: YES.

SHOW_NAMESPACES        = YES

# The FILE_VERSION_FILTER tag can be used to specify a program or script that
# doxygen should invoke to get the current version for each file (typically from
# the version control system). Doxygen will invoke the program by executing (via
# popen()) the command command input-file, where command is the value of the
# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
# by doxygen. Whatever the program writes to standard output is used as the file
# version. For an example see the documentation.

FILE_VERSION_FILTER    =

# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
# by doxygen. The layout file controls the global structure of the generated
# output files in an output format independent way. To create the layout file
# that represents doxygen's defaults, run doxygen with the -l option. You can
# optionally specify a file name after the option, if omitted DoxygenLayout.xml
# will be used as the name of the layout file.
#
# Note that if you run doxygen from a directory containing a file called
# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
# tag is left empty.

LAYOUT_FILE            =

# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
# the reference definitions. This must be a list of .bib files. The .bib
# extension is automatically appended if omitted. This requires the bibtex tool
# to be installed. See also http://en.wikipedia.org/wiki/BibTeX for more info.
# For LaTeX the style of the bibliography can be controlled using
# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
# search path. Do not use file names with spaces, bibtex cannot handle them. See
# also \cite for info how to create references.

CITE_BIB_FILES         =

#---------------------------------------------------------------------------
# Configuration options related to warning and progress messages
#---------------------------------------------------------------------------

# The QUIET tag can be used to turn on/off the messages that are generated to
# standard output by doxygen. If QUIET is set to YES this implies that the
# messages are off.
# The default value is: NO.

QUIET                  = NO

# The WARNINGS tag can be used to turn on/off the warning messages that are
# generated to standard error ( stderr) by doxygen. If WARNINGS is set to YES
# this implies that the warnings are on.
#
# Tip: Turn warnings on while writing the documentation.
# The default value is: YES.

WARNINGS               = YES

# If the WARN_IF_UNDOCUMENTED tag is set to YES, then doxygen will generate
# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
# will automatically be disabled.
# The default value is: YES.

WARN_IF_UNDOCUMENTED   = YES

# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
# potential errors in the documentation, such as not documenting some parameters
# in a documented function, or documenting parameters that don't exist or using
# markup commands wrongly.
# The default value is: YES.

WARN_IF_DOC_ERROR      = YES

# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
# are documented, but have no documentation for their parameters or return
# value. If set to NO doxygen will only warn about wrong or incomplete parameter
# documentation, but not about the absence of documentation.
# The default value is: NO.

WARN_NO_PARAMDOC       = NO

# The WARN_FORMAT tag determines the format of the warning messages that doxygen
# can produce. The string should contain the $file, $line, and $text tags, which
# will be replaced by the file and line number from which the warning originated
# and the warning text. Optionally the format may contain $version, which will
# be replaced by the version of the file (if it could be obtained via
# FILE_VERSION_FILTER)
# The default value is: $file:$line: $text.

WARN_FORMAT            = "$file:$line: $text"

# The WARN_LOGFILE tag can be used to specify a file to which warning and error
# messages should be written. If left blank the output is written to standard
# error (stderr).

WARN_LOGFILE           =

#---------------------------------------------------------------------------
# Configuration options related to the input files
#---------------------------------------------------------------------------

# The INPUT tag is used to specify the files and/or directories that contain
# documented source files. You may enter file names like myfile.cpp or
# directories like /usr/src/myproject. Separate the files or directories with
# spaces.
# Note: If this tag is empty the current directory is searched.

INPUT                  = src/mqtt

# This tag can be used to specify the character encoding of the source files
# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
# documentation (see: http://www.gnu.org/software/libiconv) for the list of
# possible encodings.
# The default value is: UTF-8.

INPUT_ENCODING         = UTF-8

# If the value of the INPUT tag contains directories, you can use the
# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
# *.h) to filter out the source-files in the directories. If left blank the
# following patterns are tested:*.c, *.cc, *.cxx, *.cpp, *.c++, *.java, *.ii,
# *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h, *.hh, *.hxx, *.hpp,
# *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc, *.m, *.markdown,
# *.md, *.mm, *.dox, *.py, *.f90, *.f, *.for, *.tcl, *.vhd, *.vhdl, *.ucf,
# *.qsf, *.as and *.js.

FILE_PATTERNS          = *.h

# The RECURSIVE tag can be used to specify whether or not subdirectories should
# be searched for input files as well.
# The default value is: NO.

RECURSIVE              = NO

# The EXCLUDE tag can be used to specify files and/or directories that should be
# excluded from the INPUT source files. This way you can easily exclude a
# subdirectory from a directory tree whose root is specified with the INPUT tag.
#
# Note that relative paths are relative to the directory from which doxygen is
# run.

EXCLUDE                =

# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
# directories that are symbolic links (a Unix file system feature) are excluded
# from the input.
# The default value is: NO.

EXCLUDE_SYMLINKS       = NO

# If the value of the INPUT tag contains directories, you can use the
# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
# certain files from those directories.
#
# Note that the wildcards are matched against the file with absolute path, so to
# exclude all test directories for example use the pattern */test/*

EXCLUDE_PATTERNS       =

# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
# (namespaces, classes, functions, etc.) that should be excluded from the
# output. The symbol name can be a fully qualified name, a word, or if the
# wildcard * is used, a substring. Examples: ANamespace, AClass,
# AClass::ANamespace, ANamespace::*Test
#
# Note that the wildcards are matched against the file with absolute path, so to
# exclude all test directories use the pattern */test/*

EXCLUDE_SYMBOLS        =

# The EXAMPLE_PATH tag can be used to specify one or more files or directories
# that contain example code fragments that are included (see the \include
# command).

EXAMPLE_PATH           =

# If the value of the EXAMPLE_PATH tag contains directories, you can use the
# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
# *.h) to filter out the source-files in the directories. If left blank all
# files are included.

EXAMPLE_PATTERNS       =

# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
# searched for input files to be used with the \include or \dontinclude commands
# irrespective of the value of the RECURSIVE tag.
# The default value is: NO.

EXAMPLE_RECURSIVE      = NO

# The IMAGE_PATH tag can be used to specify one or more files or directories
# that contain images that are to be included in the documentation (see the
# \image command).

IMAGE_PATH             =

# The INPUT_FILTER tag can be used to specify a program that doxygen should
# invoke to filter for each input file. Doxygen will invoke the filter program
# by executing (via popen()) the command:
#
# <filter> <input-file>
#
# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
# name of an input file. Doxygen will then use the output that the filter
# program writes to standard output. If FILTER_PATTERNS is specified, this tag
# will be ignored.
#
# Note that the filter must not add or remove lines; it is applied before the
# code is scanned, but not when the output code is generated. If lines are added
# or removed, the anchors will not be placed correctly.

INPUT_FILTER           =

# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
# basis. Doxygen will compare the file name with each pattern and apply the
# filter if there is a match. The filters are a list of the form: pattern=filter
# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
# patterns match the file name, INPUT_FILTER is applied.

FILTER_PATTERNS        =

# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
# INPUT_FILTER ) will also be used to filter the input files that are used for
# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
# The default value is: NO.

FILTER_SOURCE_FILES    = NO

# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
# it is also possible to disable source filtering for a specific pattern using
# *.ext= (so without naming a filter).
# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.

FILTER_SOURCE_PATTERNS =

# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
# is part of the input, its contents will be placed on the main page
# (index.html). This can be useful if you have a project on for instance GitHub
# and want to reuse the introduction page also for the doxygen output.

USE_MDFILE_AS_MAINPAGE =

#---------------------------------------------------------------------------
# Configuration options related to source browsing
#---------------------------------------------------------------------------

# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
# generated. Documented entities will be cross-referenced with these sources.
#
# Note: To get rid of all source code in the generated output, make sure that
# also VERBATIM_HEADERS is set to NO.
# The default value is: NO.

SOURCE_BROWSER         = NO

# Setting the INLINE_SOURCES tag to YES will include the body of functions,
# classes and enums directly into the documentation.
# The default value is: NO.

INLINE_SOURCES         = NO

# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
# special comment blocks from generated source code fragments. Normal C, C++ and
# Fortran comments will always remain visible.
# The default value is: YES.

STRIP_CODE_COMMENTS    = YES

# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
# function all documented functions referencing it will be listed.
# The default value is: NO.

REFERENCED_BY_RELATION = NO

# If the REFERENCES_RELATION tag is set to YES then for each documented function
# all documented entities called/used by that function will be listed.
# The default value is: NO.

REFERENCES_RELATION    = NO

# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
# to YES, then the hyperlinks from functions in REFERENCES_RELATION and
# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
# link to the documentation.
# The default value is: YES.

REFERENCES_LINK_SOURCE = YES

# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
# source code will show a tooltip with additional information such as prototype,
# brief description and links to the definition and documentation. Since this
# will make the HTML file larger and loading of large files a bit slower, you
# can opt to disable this feature.
# The default value is: YES.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

SOURCE_TOOLTIPS        = YES

# If the USE_HTAGS tag is set to YES then the references to source code will
# point to the HTML generated by the htags(1) tool instead of doxygen built-in
# source browser. The htags tool is part of GNU's global source tagging system
# (see http://www.gnu.org/software/global/global.html). You will need version
# 4.8.6 or higher.
#
# To use it do the following:
# - Install the latest version of global
# - Enable SOURCE_BROWSER and USE_HTAGS in the config file
# - Make sure the INPUT points to the root of the source tree
# - Run doxygen as normal
#
# Doxygen will invoke htags (and that will in turn invoke gtags), so these
# tools must be available from the command line (i.e. in the search path).
#
# The result: instead of the source browser generated by doxygen, the links to
# source code will now point to the output of htags.
# The default value is: NO.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

USE_HTAGS              = NO

# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
# verbatim copy of the header file for each class for which an include is
# specified. Set to NO to disable this.
# See also: Section \class.
# The default value is: YES.

VERBATIM_HEADERS       = YES

#---------------------------------------------------------------------------
# Configuration options related to the alphabetical class index
#---------------------------------------------------------------------------

# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
# compounds will be generated. Enable this if the project contains a lot of
# classes, structs, unions or interfaces.
# The default value is: YES.

ALPHABETICAL_INDEX     = YES

# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
# which the alphabetical index list will be split.
# Minimum value: 1, maximum value: 20, default value: 5.
# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.

COLS_IN_ALPHA_INDEX    = 5

# In case all classes in a project start with a common prefix, all classes will
# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
# can be used to specify a prefix (or a list of prefixes) that should be ignored
# while generating the index headers.
# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.

IGNORE_PREFIX          =

#---------------------------------------------------------------------------
# Configuration options related to the HTML output
#---------------------------------------------------------------------------

# If the GENERATE_HTML tag is set to YES doxygen will generate HTML output
# The default value is: YES.

GENERATE_HTML          = YES

# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_OUTPUT            = html

# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
# generated HTML page (for example: .htm, .php, .asp).
# The default value is: .html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FILE_EXTENSION    = .html

# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
# each generated HTML page. If the tag is left blank doxygen will generate a
# standard header.
#
# To get valid HTML the header file that includes any scripts and style sheets
# that doxygen needs, which is dependent on the configuration options used (e.g.
# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
# default header using
# doxygen -w html new_header.html new_footer.html new_stylesheet.css
# YourConfigFile
# and then modify the file new_header.html. See also section "Doxygen usage"
# for information on how to generate the default header that doxygen normally
# uses.
# Note: The header is subject to change so you typically have to regenerate the
# default header when upgrading to a newer version of doxygen. For a description
# of the possible markers and block names see the documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_HEADER            =

# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
# generated HTML page. If the tag is left blank doxygen will generate a standard
# footer. See HTML_HEADER for more information on how to generate a default
# footer and what special commands can be used inside the footer. See also
# section "Doxygen usage" for information on how to generate the default footer
# that doxygen normally uses.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FOOTER            =

# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
# sheet that is used by each HTML page. It can be used to fine-tune the look of
# the HTML output. If left blank doxygen will generate a default style sheet.
# See also section "Doxygen usage" for information on how to generate the style
# sheet that doxygen normally uses.
# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
# it is more robust and this tag (HTML_STYLESHEET) will in the future become
# obsolete.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_STYLESHEET        =

# The HTML_EXTRA_STYLESHEET tag can be used to specify an additional user-
# defined cascading style sheet that is included after the standard style sheets
# created by doxygen. Using this option one can overrule certain style aspects.
# This is preferred over using HTML_STYLESHEET since it does not replace the
# standard style sheet and is therefor more robust against future updates.
# Doxygen will copy the style sheet file to the output directory. For an example
# see the documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_STYLESHEET  =

# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the HTML output directory. Note
# that these files will be copied to the base HTML output directory. Use the
# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
# files will be copied as-is; there are no commands or markers available.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_FILES       =

# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
# will adjust the colors in the stylesheet and background images according to
# this color. Hue is specified as an angle on a colorwheel, see
# http://en.wikipedia.org/wiki/Hue for more information. For instance the value
# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
# purple, and 360 is red again.
# Minimum value: 0, maximum value: 359, default value: 220.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_HUE    = 220

# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
# in the HTML output. For a value of 0 the output will use grayscales only. A
# value of 255 will produce the most vivid colors.
# Minimum value: 0, maximum value: 255, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_SAT    = 100

# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
# luminance component of the colors in the HTML output. Values below 100
# gradually make the output lighter, whereas values above 100 make the output
# darker. The value divided by 100 is the actual gamma applied, so 80 represents
# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
# change the gamma.
# Minimum value: 40, maximum value: 240, default value: 80.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_GAMMA  = 80

# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
# page will contain the date and time when the page was generated. Setting this
# to NO can help when comparing the output of multiple runs.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_TIMESTAMP         = YES

# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
# documentation will contain sections that can be hidden and shown after the
# page has loaded.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_DYNAMIC_SECTIONS  = NO

# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
# shown in the various tree structured indices initially; the user can expand
# and collapse entries dynamically later on. Doxygen will expand the tree to
# such a level that at most the specified number of entries are visible (unless
# a fully collapsed tree already exceeds this amount). So setting the number of
# entries 1 will produce a full collapsed tree by default. 0 is a special value
# representing an infinite number of entries and will result in a full expanded
# tree by default.
# Minimum value: 0, maximum value: 9999, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_INDEX_NUM_ENTRIES = 100

# If the GENERATE_DOCSET tag is set to YES, additional index files will be
# generated that can be used as input for Apple's Xcode 3 integrated development
# environment (see: http://developer.apple.com/tools/xcode/), introduced with
# OSX 10.5 (Leopard). To create a documentation set, doxygen will generate a
# Makefile in the HTML output directory. Running make will produce the docset in
# that directory and running make install will install the docset in
# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
# startup. See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
# for more information.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_DOCSET        = NO

# This tag determines the name of the docset feed. A documentation feed provides
# an umbrella under which multiple documentation sets from a single provider
# (such as a company or product suite) can be grouped.
# The default value is: Doxygen generated docs.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_FEEDNAME        = "Doxygen generated docs"

# This tag specifies a string that should uniquely identify the documentation
# set bundle. This should be a reverse domain-name style string, e.g.
# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_BUNDLE_ID       = org.doxygen.Project

# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
# the documentation publisher. This should be a reverse domain-name style
# string, e.g. com.mycompany.MyDocSet.documentation.
# The default value is: org.doxygen.Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_ID    = org.doxygen.Publisher

# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
# The default value is: Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_NAME  = Publisher

# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
# (see: http://www.microsoft.com/en-us/download/details.aspx?id=21138) on
# Windows.
#
# The HTML Help Workshop contains a compiler that can convert all HTML output
# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
# files are now used as the Windows 98 help format, and will replace the old
# Windows help format (.hlp) on all Windows platforms in the future. Compressed
# HTML files also contain an index, a table of contents, and you can search for
# words in the documentation. The HTML workshop also contains a viewer for
# compressed HTML files.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_HTMLHELP      = NO

# The CHM_FILE tag can be used to specify the file name of the resulting .chm
# file. You can add a path in front of the file if the result should not be
# written to the html output directory.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_FILE               =

# The HHC_LOCATION tag can be used to specify the location (absolute path
# including file name) of the HTML help compiler ( hhc.exe). If non-empty
# doxygen will try to run the HTML help compiler on the generated index.hhp.
# The file has to be specified with full path.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

HHC_LOCATION           =

# The GENERATE_CHI flag controls if a separate .chi index file is generated (
# YES) or that it should be included in the master .chm file ( NO).
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

GENERATE_CHI           = NO

# The CHM_INDEX_ENCODING is used to encode HtmlHelp index ( hhk), content ( hhc)
# and project file content.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_INDEX_ENCODING     =

# The BINARY_TOC flag controls whether a binary table of contents is generated (
# YES) or a normal table of contents ( NO) in the .chm file.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

BINARY_TOC             = NO

# The TOC_EXPAND flag can be set to YES to add extra items for group members to
# the table of contents of the HTML help documentation and to the tree view.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

TOC_EXPAND             = NO

# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
# (.qch) of the generated HTML documentation.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_QHP           = NO

# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
# the file name of the resulting .qch file. The path specified is relative to
# the HTML output folder.
# This tag requires that the tag GENERATE_QHP is set to YES.

QCH_FILE               =

# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
# Project output. For more information please see Qt Help Project / Namespace
# (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#namespace).
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_NAMESPACE          = org.doxygen.Project

# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
# Help Project output. For more information please see Qt Help Project / Virtual
# Folders (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#virtual-
# folders).
# The default value is: doc.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_VIRTUAL_FOLDER     = doc

# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
# filter to add. For more information please see Qt Help Project / Custom
# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
# filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_NAME   =

# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
# custom filter to add. For more information please see Qt Help Project / Custom
# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
# filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_ATTRS  =

# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
# project's filter section matches. Qt Help Project / Filter Attributes (see:
# http://qt-project.org/doc/qt-4.8/qthelpproject.html#filter-attributes).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_SECT_FILTER_ATTRS  =

# The QHG_LOCATION tag can be used to specify the location of Qt's
# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
# generated .qhp file.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHG_LOCATION           =

# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
# generated, together with the HTML files, they form an Eclipse help plugin. To
# install this plugin and make it available under the help contents menu in
# Eclipse, the contents of the directory containing the HTML and XML files needs
# to be copied into the plugins directory of eclipse. The name of the directory
# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
# After copying Eclipse needs to be restarted before the help appears.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_ECLIPSEHELP   = NO

# A unique identifier for the Eclipse help plugin. When installing the plugin
# the directory name containing the HTML and XML files should also have this
# name. Each documentation set should have its own identifier.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.

ECLIPSE_DOC_ID         = org.doxygen.Project

# If you want full control over the layout of the generated HTML pages it might
# be necessary to disable the index and replace it with your own. The
# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
# of each HTML page. A value of NO enables the index and the value YES disables
# it. Since the tabs in the index contain the same information as the navigation
# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

DISABLE_INDEX          = NO

# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
# structure should be generated to display hierarchical information. If the tag
# value is set to YES, a side panel will be generated containing a tree-like
# index structure (just like the one that is generated for HTML Help). For this
# to work a browser that supports JavaScript, DHTML, CSS and frames is required
# (i.e. any modern browser). Windows users are probably better off using the
# HTML help feature. Via custom stylesheets (see HTML_EXTRA_STYLESHEET) one can
# further fine-tune the look of the index. As an example, the default style
# sheet generated by doxygen has an example that shows how to put an image at
# the root of the tree instead of the PROJECT_NAME. Since the tree basically has
# the same information as the tab index, you could consider setting
# DISABLE_INDEX to YES when enabling this option.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_TREEVIEW      = YES

# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
# doxygen will group on one line in the generated HTML documentation.
#
# Note that a value of 0 will completely suppress the enum values from appearing
# in the overview section.
# Minimum value: 0, maximum value: 20, default value: 4.
# This tag requires that the tag GENERATE_HTML is set to YES.

ENUM_VALUES_PER_LINE   = 1

# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
# to set the initial width (in pixels) of the frame in which the tree is shown.
# Minimum value: 0, maximum value: 1500, default value: 250.
# This tag requires that the tag GENERATE_HTML is set to YES.

TREEVIEW_WIDTH         = 250

# When the EXT_LINKS_IN_WINDOW option is set to YES doxygen will open links to
# external symbols imported via tag files in a separate window.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

EXT_LINKS_IN_WINDOW    = NO

# Use this tag to change the font size of LaTeX formulas included as images in
# the HTML documentation. When you change the font size after a successful
# doxygen run you need to manually remove any form_*.png images from the HTML
# output directory to force them to be regenerated.
# Minimum value: 8, maximum value: 50, default value: 10.
# This tag requires that the tag GENERATE_HTML is set to YES.

FORMULA_FONTSIZE       = 10

# Use the FORMULA_TRANPARENT tag to determine whether or not the images
# generated for formulas are transparent PNGs. Transparent PNGs are not
# supported properly for IE 6.0, but are supported on all modern browsers.
#
# Note that when changing this option you need to delete any form_*.png files in
# the HTML output directory before the changes have effect.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

FORMULA_TRANSPARENT    = YES

# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
# http://www.mathjax.org) which uses client side Javascript for the rendering
# instead of using prerendered bitmaps. Use this if you do not have LaTeX
# installed or if you want to formulas look prettier in the HTML output. When
# enabled you may also need to install MathJax separately and configure the path
# to it using the MATHJAX_RELPATH option.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

USE_MATHJAX            = NO

# When MathJax is enabled you can set the default output format to be used for
# the MathJax output. See the MathJax site (see:
# http://docs.mathjax.org/en/latest/output.html) for more details.
# Possible values are: HTML-CSS (which is slower, but has the best
# compatibility), NativeMML (i.e. MathML) and SVG.
# The default value is: HTML-CSS.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_FORMAT         = HTML-CSS

# When MathJax is enabled you need to specify the location relative to the HTML
# output directory using the MATHJAX_RELPATH option. The destination directory
# should contain the MathJax.js script. For instance, if the mathjax directory
# is located at the same level as the HTML output directory, then
# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
# Content Delivery Network so you can quickly see the result without installing
# MathJax. However, it is strongly recommended to install a local copy of
# MathJax from http://www.mathjax.org before deployment.
# The default value is: http://cdn.mathjax.org/mathjax/latest.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest

# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
# extension names that should be enabled during MathJax rendering. For example
# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_EXTENSIONS     =

# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
# of code that will be used on startup of the MathJax code. See the MathJax site
# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
# example see the documentation.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_CODEFILE       =

# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
# the HTML output. The underlying search engine uses javascript and DHTML and
# should work on any modern browser. Note that when using HTML help
# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
# there is already a search function so this one should typically be disabled.
# For large projects the javascript based search engine can be slow, then
# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
# search using the keyboard; to jump to the search box use <access key> + S
# (what the <access key> is depends on the OS and browser, but it is typically
# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
# key> to jump into the search results window, the results can be navigated
# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
# the search. The filter options can be selected when the cursor is inside the
# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
# to select a filter and <Enter> or <escape> to activate or cancel the filter
# option.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

SEARCHENGINE           = YES

# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
# implemented using a web server instead of a web client using Javascript. There
# are two flavours of web server based searching depending on the
# EXTERNAL_SEARCH setting. When disabled, doxygen will generate a PHP script for
# searching and an index file used by the script. When EXTERNAL_SEARCH is
# enabled the indexing and searching needs to be provided by external tools. See
# the section "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

SERVER_BASED_SEARCH    = NO

# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
# script for searching. Instead the search results are written to an XML file
# which needs to be processed by an external indexer. Doxygen will invoke an
# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
# search results.
#
# Doxygen ships with an example indexer ( doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see: http://xapian.org/).
#
# See the section "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH        = NO

# The SEARCHENGINE_URL should point to a search engine hosted by a web server
# which will return the search results when EXTERNAL_SEARCH is enabled.
#
# Doxygen ships with an example indexer ( doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see: http://xapian.org/). See the section "External Indexing and
# Searching" for details.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHENGINE_URL       =

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
# search data is written to a file for indexing by an external tool. With the
# SEARCHDATA_FILE tag the name of this file can be specified.
# The default file is: searchdata.xml.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHDATA_FILE        = searchdata.xml

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
# projects and redirect the results back to the right project.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH_ID     =

# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
# projects other than the one defined by this configuration file, but that are
# all added to the same external search index. Each project needs to have a
# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
# to a relative location where the documentation can be found. The format is:
# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTRA_SEARCH_MAPPINGS  =

#---------------------------------------------------------------------------
# Configuration options related to the LaTeX output
#---------------------------------------------------------------------------

# If the GENERATE_LATEX tag is set to YES doxygen will generate LaTeX output.
# The default value is: YES.

GENERATE_LATEX         = YES

# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: latex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_OUTPUT           = latex

# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
# invoked.
#
# Note that when enabling USE_PDFLATEX this option is only used for generating
# bitmaps for formulas in the HTML output, but not in the Makefile that is
# written to the output directory.
# The default file is: latex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_CMD_NAME         = latex

# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
# index for LaTeX.
# The default file is: makeindex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

MAKEINDEX_CMD_NAME     = makeindex

# If the COMPACT_LATEX tag is set to YES doxygen generates more compact LaTeX
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

COMPACT_LATEX          = NO

# The PAPER_TYPE tag can be used to set the paper type that is used by the
# printer.
# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
# 14 inches) and executive (7.25 x 10.5 inches).
# The default value is: a4.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PAPER_TYPE             = a4

# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
# that should be included in the LaTeX output. To get the times font for
# instance you can specify
# EXTRA_PACKAGES=times
# If left blank no extra packages will be included.
# This tag requires that the tag GENERATE_LATEX is set to YES.

EXTRA_PACKAGES         =

# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
# generated LaTeX document. The header should contain everything until the first
# chapter. If it is left blank doxygen will generate a standard header. See
# section "Doxygen usage" for information on how to let doxygen write the
# default header to a separate file.
#
# Note: Only use a user-defined header if you know what you are doing! The
# following commands have a special meaning inside the header: $title,
# $datetime, $date, $doxygenversion, $projectname, $projectnumber. Doxygen will
# replace them by respectively the title of the page, the current date and time,
# only the current date, the version number of doxygen, the project name (see
# PROJECT_NAME), or the project number (see PROJECT_NUMBER).
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HEADER           =

# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
# generated LaTeX document. The footer should contain everything after the last
# chapter. If it is left blank doxygen will generate a standard footer.
#
# Note: Only use a user-defined footer if you know what you are doing!
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_FOOTER           =

# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the LATEX_OUTPUT output
# directory. Note that the files will be copied as-is; there are no commands or
# markers available.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EXTRA_FILES      =

# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
# contain links (just like the HTML output) instead of page references. This
# makes the output suitable for online browsing using a PDF viewer.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PDF_HYPERLINKS         = YES

# If the LATEX_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
# the PDF file directly from the LaTeX files. Set this option to YES to get a
# higher quality PDF documentation.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

USE_PDFLATEX           = YES

# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
# command to the generated LaTeX files. This will instruct LaTeX to keep running
# if errors occur, instead of asking the user for help. This option is also used
# when generating formulas in HTML.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BATCHMODE        = NO

# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
# index chapters (such as File Index, Compound Index, etc.) in the output.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HIDE_INDICES     = NO

# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
# code with syntax highlighting in the LaTeX output.
#
# Note that which sources are shown also depends on other settings such as
# SOURCE_BROWSER.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_SOURCE_CODE      = NO

# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
# bibliography, e.g. plainnat, or ieeetr. See
# http://en.wikipedia.org/wiki/BibTeX and \cite for more info.
# The default value is: plain.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BIB_STYLE        = plain

#---------------------------------------------------------------------------
# Configuration options related to the RTF output
#---------------------------------------------------------------------------

# If the GENERATE_RTF tag is set to YES doxygen will generate RTF output. The
# RTF output is optimized for Word 97 and may not look too pretty with other RTF
# readers/editors.
# The default value is: NO.

GENERATE_RTF           = NO

# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: rtf.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_OUTPUT             = rtf

# If the COMPACT_RTF tag is set to YES doxygen generates more compact RTF
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

COMPACT_RTF            = NO

# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
# contain hyperlink fields. The RTF file will contain links (just like the HTML
# output) instead of page references. This makes the output suitable for online
# browsing using Word or some other Word compatible readers that support those
# fields.
#
# Note: WordPad (write) and others do not support links.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_HYPERLINKS         = NO

# Load stylesheet definitions from file. Syntax is similar to doxygen's config
# file, i.e. a series of assignments. You only have to provide replacements,
# missing definitions are set to their default value.
#
# See also section "Doxygen usage" for information on how to generate the
# default style sheet that doxygen normally uses.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_STYLESHEET_FILE    =

# Set optional variables used in the generation of an RTF document. Syntax is
# similar to doxygen's config file. A template extensions file can be generated
# using doxygen -e rtf extensionFile.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_EXTENSIONS_FILE    =

#---------------------------------------------------------------------------
# Configuration options related to the man page output
#---------------------------------------------------------------------------

# If the GENERATE_MAN tag is set to YES doxygen will generate man pages for
# classes and files.
# The default value is: NO.

GENERATE_MAN           = NO

# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it. A directory man3 will be created inside the directory specified by
# MAN_OUTPUT.
# The default directory is: man.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_OUTPUT             = man

# The MAN_EXTENSION tag determines the extension that is added to the generated
# man pages. In case the manual section does not start with a number, the number
# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
# optional.
# The default value is: .3.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_EXTENSION          = .3

# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
# will generate one additional man file for each entity documented in the real
# man page(s). These additional files only source the real man page, but without
# them the man command would be unable to find the correct page.
# The default value is: NO.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_LINKS              = NO

#---------------------------------------------------------------------------
# Configuration options related to the XML output
#---------------------------------------------------------------------------

# If the GENERATE_XML tag is set to YES doxygen will generate an XML file that
# captures the structure of the code including all documentation.
# The default value is: NO.

GENERATE_XML           = NO

# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: xml.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_OUTPUT             = xml

# The XML_SCHEMA tag can be used to specify a XML schema, which can be used by a
# validating XML parser to check the syntax of the XML files.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_SCHEMA             =

# The XML_DTD tag can be used to specify a XML DTD, which can be used by a
# validating XML parser to check the syntax of the XML files.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_DTD                =

# If the XML_PROGRAMLISTING tag is set to YES doxygen will dump the program
# listings (including syntax highlighting and cross-referencing information) to
# the XML output. Note that enabling this will significantly increase the size
# of the XML output.
# The default value is: YES.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_PROGRAMLISTING     = YES

#---------------------------------------------------------------------------
# Configuration options related to the DOCBOOK output
#---------------------------------------------------------------------------

# If the GENERATE_DOCBOOK tag is set to YES doxygen will generate Docbook files
# that can be used to generate PDF.
# The default value is: NO.

GENERATE_DOCBOOK       = NO

# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
# front of it.
# The default directory is: docbook.
# This tag requires that the tag GENERATE_DOCBOOK is set to YES.

DOCBOOK_OUTPUT         = docbook

#---------------------------------------------------------------------------
# Configuration options for the AutoGen Definitions output
#---------------------------------------------------------------------------

# If the GENERATE_AUTOGEN_DEF tag is set to YES doxygen will generate an AutoGen
# Definitions (see http://autogen.sf.net) file that captures the structure of
# the code including all documentation. Note that this feature is still
# experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_AUTOGEN_DEF   = NO

#---------------------------------------------------------------------------
# Configuration options related to the Perl module output
#---------------------------------------------------------------------------

# If the GENERATE_PERLMOD tag is set to YES doxygen will generate a Perl module
# file that captures the structure of the code including all documentation.
#
# Note that this feature is still experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_PERLMOD       = NO

# If the PERLMOD_LATEX tag is set to YES doxygen will generate the necessary
# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
# output from the Perl module output.
# The default value is: NO.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_LATEX          = NO

# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be nicely
# formatted so it can be parsed by a human reader. This is useful if you want to
# understand what is going on. On the other hand, if this tag is set to NO the
# size of the Perl module output will be much smaller and Perl will parse it
# just the same.
# The default value is: YES.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_PRETTY         = YES

# The names of the make variables in the generated doxyrules.make file are
# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
# so different doxyrules.make files included by the same Makefile don't
# overwrite each other's variables.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_MAKEVAR_PREFIX =

#---------------------------------------------------------------------------
# Configuration options related to the preprocessor
#---------------------------------------------------------------------------

# If the ENABLE_PREPROCESSING tag is set to YES doxygen will evaluate all
# C-preprocessor directives found in the sources and include files.
# The default value is: YES.

ENABLE_PREPROCESSING   = YES

# If the MACRO_EXPANSION tag is set to YES doxygen will expand all macro names
# in the source code. If set to NO only conditional compilation will be
# performed. Macro expansion can be done in a controlled way by setting
# EXPAND_ONLY_PREDEF to YES.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

MACRO_EXPANSION        = NO

# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
# the macro expansion is limited to the macros specified with the PREDEFINED and
# EXPAND_AS_DEFINED tags.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_ONLY_PREDEF     = NO

# If the SEARCH_INCLUDES tag is set to YES the includes files in the
# INCLUDE_PATH will be searched if a #include is found.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SEARCH_INCLUDES        = YES

# The INCLUDE_PATH tag can be used to specify one or more directories that
# contain include files that are not input files but should be processed by the
# preprocessor.
# This tag requires that the tag SEARCH_INCLUDES is set to YES.

INCLUDE_PATH           =

# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
# patterns (like *.h and *.hpp) to filter out the header-files in the
# directories. If left blank, the patterns specified with FILE_PATTERNS will be
# used.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

INCLUDE_FILE_PATTERNS  =

# The PREDEFINED tag can be used to specify one or more macro names that are
# defined before the preprocessor is started (similar to the -D option of e.g.
# gcc). The argument of the tag is a list of macros of the form: name or
# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
# is assumed. To prevent a macro definition from being undefined via #undef or
# recursively expanded use the := operator instead of the = operator.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

PREDEFINED             =

# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
# tag can be used to specify a list of macro names that should be expanded. The
# macro definition that is found in the sources will be used. Use the PREDEFINED
# tag if you want to use a different macro definition that overrules the
# definition found in the source code.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_AS_DEFINED      =

# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
# remove all refrences to function-like macros that are alone on a line, have an
# all uppercase name, and do not end with a semicolon. Such function macros are
# typically used for boiler-plate code, and will confuse the parser if not
# removed.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SKIP_FUNCTION_MACROS   = YES

#---------------------------------------------------------------------------
# Configuration options related to external references
#---------------------------------------------------------------------------

# The TAGFILES tag can be used to specify one or more tag files. For each tag
# file the location of the external documentation should be added. The format of
# a tag file without this location is as follows:
# TAGFILES = file1 file2 ...
# Adding location for the tag files is done as follows:
# TAGFILES = file1=loc1 "file2 = loc2" ...
# where loc1 and loc2 can be relative or absolute paths or URLs. See the
# section "Linking to external documentation" for more information about the use
# of tag files.
# Note: Each tag file must have an unique name (where the name does NOT include
# the path). If a tag file is not located in the directory in which doxygen is
# run, you must also specify the path to the tagfile here.

TAGFILES               =

# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
# tag file that is based on the input files it reads. See section "Linking to
# external documentation" for more information about the usage of tag files.

GENERATE_TAGFILE       =

# If the ALLEXTERNALS tag is set to YES all external class will be listed in the
# class index. If set to NO only the inherited external classes will be listed.
# The default value is: NO.

ALLEXTERNALS           = NO

# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed in
# the modules index. If set to NO, only the current project's groups will be
# listed.
# The default value is: YES.

EXTERNAL_GROUPS        = YES

# If the EXTERNAL_PAGES tag is set to YES all external pages will be listed in
# the related pages index. If set to NO, only the current project's pages will
# be listed.
# The default value is: YES.

EXTERNAL_PAGES         = YES

# The PERL_PATH should be the absolute path and name of the perl script
# interpreter (i.e. the result of 'which perl').
# The default file (with absolute path) is: /usr/bin/perl.

PERL_PATH              = /usr/bin/perl

#---------------------------------------------------------------------------
# Configuration options related to the dot tool
#---------------------------------------------------------------------------

# If the CLASS_DIAGRAMS tag is set to YES doxygen will generate a class diagram
# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
# NO turns the diagrams off. Note that this option also works with HAVE_DOT
# disabled, but it is recommended to install and use dot, since it yields more
# powerful graphs.
# The default value is: YES.

CLASS_DIAGRAMS         = YES

# You can define message sequence charts within doxygen comments using the \msc
# command. Doxygen will then run the mscgen tool (see:
# http://www.mcternan.me.uk/mscgen/)) to produce the chart and insert it in the
# documentation. The MSCGEN_PATH tag allows you to specify the directory where
# the mscgen tool resides. If left empty the tool is assumed to be found in the
# default search path.

MSCGEN_PATH            =

# You can include diagrams made with dia in doxygen documentation. Doxygen will
# then run dia to produce the diagram and insert it in the documentation. The
# DIA_PATH tag allows you to specify the directory where the dia binary resides.
# If left empty dia is assumed to be found in the default search path.

DIA_PATH               =

# If set to YES, the inheritance and collaboration graphs will hide inheritance
# and usage relations if the target is undocumented or is not a class.
# The default value is: YES.

HIDE_UNDOC_RELATIONS   = YES

# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
# available from the path. This tool is part of Graphviz (see:
# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
# Bell Labs. The other options in this section have no effect if this option is
# set to NO
# The default value is: NO.

HAVE_DOT               = NO

# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
# to run in parallel. When set to 0 doxygen will base this on the number of
# processors available in the system. You can set it explicitly to a value
# larger than 0 to get control over the balance between CPU load and processing
# speed.
# Minimum value: 0, maximum value: 32, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_NUM_THREADS        = 0

# When you want a differently looking font n the dot files that doxygen
# generates you can specify the font name using DOT_FONTNAME. You need to make
# sure dot is able to find the font, which can be done by putting it in a
# standard location or by setting the DOTFONTPATH environment variable or by
# setting DOT_FONTPATH to the directory containing the font.
# The default value is: Helvetica.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTNAME           = Helvetica

# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
# dot graphs.
# Minimum value: 4, maximum value: 24, default value: 10.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTSIZE           = 10

# By default doxygen will tell dot to use the default font as specified with
# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
# the path where dot can find it using this tag.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTPATH           =

# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
# each documented class showing the direct and indirect inheritance relations.
# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

CLASS_GRAPH            = YES

# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
# graph for each documented class showing the direct and indirect implementation
# dependencies (inheritance, containment, and class references variables) of the
# class with other documented classes.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

COLLABORATION_GRAPH    = YES

# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
# groups, showing the direct groups dependencies.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GROUP_GRAPHS           = YES

# If the UML_LOOK tag is set to YES doxygen will generate inheritance and
# collaboration diagrams in a style similar to the OMG's Unified Modeling
# Language.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

UML_LOOK               = NO

# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
# class node. If there are many fields or methods and many nodes the graph may
# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
# number of items for each type to make the size more manageable. Set this to 0
# for no limit. Note that the threshold may be exceeded by 50% before the limit
# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
# but if the number exceeds 15, the total amount of fields shown is limited to
# 10.
# Minimum value: 0, maximum value: 100, default value: 10.
# This tag requires that the tag HAVE_DOT is set to YES.

UML_LIMIT_NUM_FIELDS   = 10

# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
# collaboration graphs will show the relations between templates and their
# instances.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

TEMPLATE_RELATIONS     = NO

# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
# YES then doxygen will generate a graph for each documented file showing the
# direct and indirect include dependencies of the file with other documented
# files.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDE_GRAPH          = YES

# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
# set to YES then doxygen will generate a graph for each documented file showing
# the direct and indirect include dependencies of the file with other documented
# files.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDED_BY_GRAPH      = YES

# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable call graphs for selected
# functions only using the \callgraph command.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALL_GRAPH             = NO

# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable caller graphs for selected
# functions only using the \callergraph command.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALLER_GRAPH           = NO

# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
# hierarchy of all classes instead of a textual one.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GRAPHICAL_HIERARCHY    = YES

# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
# dependencies a directory has on other directories in a graphical way. The
# dependency relations are determined by the #include relations between the
# files in the directories.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

DIRECTORY_GRAPH        = YES

# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
# generated by dot.
# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
# to make the SVG files visible in IE 9+ (other browsers do not have this
# requirement).
# Possible values are: png, jpg, gif and svg.
# The default value is: png.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_IMAGE_FORMAT       = png

# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
# enable generation of interactive SVG images that allow zooming and panning.
#
# Note that this requires a modern browser other than Internet Explorer. Tested
# and working are Firefox, Chrome, Safari, and Opera.
# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
# the SVG files visible. Older versions of IE do not have SVG support.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

INTERACTIVE_SVG        = NO

# The DOT_PATH tag can be used to specify the path where the dot tool can be
# found. If left blank, it is assumed the dot tool can be found in the path.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_PATH               =

# The DOTFILE_DIRS tag can be used to specify one or more directories that
# contain dot files that are included in the documentation (see the \dotfile
# command).
# This tag requires that the tag HAVE_DOT is set to YES.

DOTFILE_DIRS           =

# The MSCFILE_DIRS tag can be used to specify one or more directories that
# contain msc files that are included in the documentation (see the \mscfile
# command).

MSCFILE_DIRS           =

# The DIAFILE_DIRS tag can be used to specify one or more directories that
# contain dia files that are included in the documentation (see the \diafile
# command).

DIAFILE_DIRS           =

# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
# that will be shown in the graph. If the number of nodes in a graph becomes
# larger than this value, doxygen will truncate the graph, which is visualized
# by representing a node as a red box. Note that doxygen if the number of direct
# children of the root node in a graph is already larger than
# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
# Minimum value: 0, maximum value: 10000, default value: 50.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_GRAPH_MAX_NODES    = 50

# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
# generated by dot. A depth value of 3 means that only nodes reachable from the
# root by following a path via at most 3 edges will be shown. Nodes that lay
# further from the root node will be omitted. Note that setting this option to 1
# or 2 may greatly reduce the computation time needed for large code bases. Also
# note that the size of a graph can be further restricted by
# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
# Minimum value: 0, maximum value: 1000, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

MAX_DOT_GRAPH_DEPTH    = 0

# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
# background. This is disabled by default, because dot on Windows does not seem
# to support this out of the box.
#
# Warning: Depending on the platform used, enabling this option may lead to
# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
# read).
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_TRANSPARENT        = NO

# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
# files in one run (i.e. multiple -o and -T options on the command line). This
# makes dot run faster, but since only newer versions of dot (>1.8.10) support
# this, this feature is disabled by default.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_MULTI_TARGETS      = YES

# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
# explaining the meaning of the various boxes and arrows in the dot generated
# graphs.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GENERATE_LEGEND        = YES

# If the DOT_CLEANUP tag is set to YES doxygen will remove the intermediate dot
# files that are used to generate the various graphs.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_CLEANUP            = YES

```

`LICENSE`:

```
Eclipse Public License - v 2.0

This program and the accompanying materials
are made available under the terms of the Eclipse Public License v2.0
and Eclipse Distribution License v1.0 which accompany this distribution.

The Eclipse Public License is available at
  https://www.eclipse.org/legal/epl-20/
and the Eclipse Distribution License is available at
  http://www.eclipse.org/org/documents/edl-v10.php.

For an explanation of what dual-licensing means to you, see:
https://www.eclipse.org/legal/eplfaq.php#DUALLIC

```

`NOTICE`:

```
# Notices for Eclipse Paho

This content is produced and maintained by the Eclipse Paho project.

* Project home: https://projects.eclipse.org/projects/iot.paho

## Trademarks

Paho™ is a trademark of the Eclipse Foundation.

## Copyright

All content is the property of the respective authors or their employers. For
more information regarding authorship of content, please consult the listed
source code repository logs.

## Declared Project Licenses

This program and the accompanying materials are made available under the terms
of the Eclipse Public License v2.0 which is available at
https://www.eclipse.org/legal/epl-2.0, or the Eclipse Distribution License
v1.0 which is available at https://www.eclipse.org/org/documents/edl-v10.php.

SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause

## Source Code

The project maintains the following source code repositories:

* https://github.com/eclipse/paho-website
* https://github.com/eclipse/paho.golang
* https://github.com/eclipse/paho.mqtt-sn.embedded-c
* https://github.com/eclipse/paho.mqtt-spy
* https://github.com/eclipse/paho.mqtt.android
* https://github.com/eclipse/paho.mqtt.c
* https://github.com/eclipse/paho.mqtt.cpp
* https://github.com/eclipse/paho.mqtt.d
* https://github.com/eclipse/paho.mqtt.embedded-c
* https://github.com/eclipse/paho.mqtt.golang
* https://github.com/eclipse/paho.mqtt.java
* https://github.com/eclipse/paho.mqtt.javascript
* https://github.com/eclipse/paho.mqtt.m2mqtt
* https://github.com/eclipse/paho.mqtt.python
* https://github.com/eclipse/paho.mqtt.ruby
* https://github.com/eclipse/paho.mqtt.rust
* https://github.com/eclipse/paho.mqtt.testing

## Cryptography

Content may contain encryption software. The country in which you are currently
may have restrictions on the import, possession, and use, and/or re-export to
another country, of encryption software. BEFORE using any encryption software,
please check the country's laws, regulations and policies concerning the import,
possession, or use, and re-export of encryption software, to see if this is
permitted.

```

`README.md`:

```md
# Eclipse Paho MQTT C++ Client Library

This repository contains the source code for the [Eclipse Paho](http://eclipse.org/paho) MQTT C++ client library for memory-managed operating systems such as Linux, MacOS, and Windows.

This code builds a library which enables Modern C++ applications (C++17 and beyond) to connect to an [MQTT](http://mqtt.org) broker, publish messages, subscribe to topics, and receive messages from the broker.

The library has the following features:

- Support for MQTT v3.1, v3.1.1, and v5.
- Network Transports:
    - Standard TCP
    - UNIX-domain sockets
    - Secure sockets with SSL/TLS
    - WebSockets
        - Secure and insecure
        - Proxy support
- Message persistence
    - User configurable
    - Built-in File persistence
    - User-defined key/value persistence easy to implement
- Automatic Reconnect
- Offline Buffering
- High Availability
- Blocking and non-blocking APIs
- Modern C++ interface (C++17)

This code requires the [Paho C library](https://github.com/eclipse/paho.mqtt.c) by Ian Craggs, et al., specifically version 1.3.14 or possibly later.

## Latest News

To keep up with the latest announcements for this project, or to ask questions:

**Email:** [Eclipse Paho Mailing List](https://accounts.eclipse.org/mailing-list/paho-dev)

### What's New in v1.5.x

The latest updates for v1.5 moved the codebase to C++17 and added support for UNIX-domain sockets. They also fixed a number of build issues, now targeting the latest Paho C release, v1.3.14.

The primary changes in the v1.5 versions are:

- Updated the code base to C++17
- Support for the Paho C v1.3.14 release.
    - Support for UNIX-domain sockets
- Reorganize and reformat the sources and added a .clang-format capability.
- Create universal client instances that can connect using v3 or v5. (i.e. no more instances that are only v3 capable)
- Bump the CMake to v3.13
- Fix a large number of CMake build issues
- Updated the GitHub CI
- (v1.5.3) Fixes for building this library and the Paho C library with the latest C & C++ compilers, like Clang 20 and GCC 15 which created some breaking hcanges for legacy code.
- (v1.5.4) Fixes for `topic_matcher` and `topic_filter` to match against parent with the multi-field wildcard.

For the full list of updates in each release, see the [CHANGELOG](https://github.com/eclipse-paho/paho.mqtt.cpp/blob/master/CHANGELOG.md).

## Contributing

Contributions to this project are gladly welcomed and appreciated. Before submitting a Pull Request, please keep three things in mind:

 - This is an official Eclipse project, so it is required that all contributors sign an [Eclipse Contributor Agreement (ECA)](https://www.eclipse.org/legal/ECA.php)
 - Please submit all Pull Requests against the _develop_ branch (not master).
 - Please sign all commits.

 For full details, see [CONTRIBUTING.md](https://github.com/eclipse/paho.mqtt.cpp/blob/master/CONTRIBUTING.md).

## Building from source

As of v1.5, the Paho C++ library uses C++17 features, thus requiring a fully compliant C++17 compiler. Some of the more common compilers that can be used, depending on the target platform, are:

* GCC v8 or later
* _clang_ v5 or later
* Visual Studio 2017 15.8 (MSVC 19.15) or later

_CMake_  is a cross-platform build system suitable for Unix and non-Unix platforms such as Microsoft Windows. It is the only supported build system. The current supported minimum version is:

* cmake v3.13

The Paho C++ library requires the Paho C library, v1.3.14 or greater to be built and installed. That can be done before building this library, or it can be done here using the CMake `PAHO_WITH_MQTT_C` build option to build both libraries at the same time. This also guarantees that a proper version of the C library is used, and that it is build with compatible options.

### Build Options

CMake allows for options to direct the build. The following are specific to Paho C++:

Variable | Default Value | Description
------------ | ------------- | -------------
PAHO_BUILD_SHARED | TRUE (*nix), FALSE (Win32) | Whether to build the shared library
PAHO_BUILD_STATIC | FALSE (*nix), TRUE (Win32) | Whether to build the static library
PAHO_WITH_SSL | TRUE (*nix), FALSE (Win32) | Whether to build SSL/TLS support into the library
PAHO_BUILD_DOCUMENTATION | FALSE | Create the HTML API documentation (requires _Doxygen_)
PAHO_BUILD_EXAMPLES | FALSE | Whether to build the example programs
PAHO_BUILD_TESTS | FALSE | Build the unit tests. (Requires _Catch2_)
PAHO_BUILD_DEB_PACKAGE | FALSE | Flag that configures cpack to build a Debian/Ubuntu package
PAHO_WITH_MQTT_C | FALSE | Whether to build the bundled Paho C library

Enabling `PAHO_WITH_MQTT_C` builds and links in the Paho C library using compatible build options. If this is enabled, it passes the `PAHO_WITH_SSL` option to the C library, and also sets the options `PAHO_HIGH_PERFORMANCE` and `PAHO_WITH_UNIX_SOCKETS` for the C lib. These can be disabled in the cache before building if desired.

In addition, the C++ build might commonly use `CMAKE_PREFIX_PATH` to help the build system find the location of the Paho C library if it was built separately.

### Build the Paho C++ and Paho C libraries together

The quickest and easiest way to build Paho C++ is to build it together with Paho C in a single step using the included Git submodule.
This requires the CMake option `PAHO_WITH_MQTT_C` set.

```
$ git clone https://github.com/eclipse/paho.mqtt.cpp
$ cd paho.mqtt.cpp
$ git co v1.5.4

$ git submodule init
$ git submodule update

$ cmake -Bbuild -H. -DPAHO_WITH_MQTT_C=ON -DPAHO_BUILD_EXAMPLES=ON
$ sudo cmake --build build/ --target install
```

This assumes the build tools and dependencies, such as OpenSSL, have already been installed. For more details and platform-specific requirements, see below.

### Unix-style Systems (Linux, macOS, etc)

On *nix systems CMake creates Makefiles.

The build process currently supports a number of Unix and Linux flavors. The build process requires the following tools:

* CMake v3.13 or newer
* A fully-compatible C++17 compiler. Common options are:
    * GCC v8 or later
    * _clang_ v5 or later

On Debian based systems this would mean that the following packages have to be installed:

```
$ sudo apt-get install build-essential gcc make cmake
```

If you will be using secure sockets (and you probably should if you're sending messages across a public netwok):

```
$ sudo apt-get install libssl-dev
```

Building the documentation requires doxygen and optionally graphviz to be installed:

```
$ sudo apt-get install doxygen graphviz
```

Unit tests are built using _Catch2_.

_Catch2_ can be found here: [Catch2](https://github.com/catchorg/Catch2).  You must download and install _Catch2_ to build and run the unit tests locally. Currently _Catch2_ versions v2.x and v3.x are supported.

#### Building the Paho C library

The Paho C library can be built automatically when building this library by enabling the CMake build option, `PAHO_WITH_MQTT_C`. That will build and install the Paho C library from a Git submodule, using a known-good version, and the proper build configuration for the C++ library. But iIf you want to manually specify the build configuration of the Paho C library or use a different version, then it must be built and installed before building the C++ library. Note, this version of the C++ library requires Paho C v1.3.14 or greater.

To download and build the Paho C library:

    $ git clone https://github.com/eclipse/paho.mqtt.c.git
    $ cd paho.mqtt.c
    $ git checkout v1.3.14

    $ cmake -Bbuild -H. -DPAHO_ENABLE_TESTING=OFF -DPAHO_WITH_SSL=ON -DPAHO_HIGH_PERFORMANCE=ON
    $ sudo cmake --build build/ --target install

This builds the C library with SSL/TLS enabled. If that is not desired, omit the `-DPAHO_WITH_SSL=ON`.

It also uses the "high performance" option of the C library to disable more extensive internal memory checks. Remove the _PAHO_HIGH_PERFORMANCE_ option (i.e. turn it off) to debug memory issues, but for most production systems, leave it on for better performance.

The above will install the library to the default location on the host, which for Linux is normally `/usr/local`. To install the library to a non-standard location, use the `CMAKE_INSTALL_PREFIX` to specify a location. For example, to install into a directory under the user's home directory, perhaps for local testing, do this:

    $ cmake -Bbuild -H. -DPAHO_ENABLE_TESTING=OFF \
        -DPAHO_WITH_SSL=ON -DPAHO_HIGH_PERFORMANCE=ON \
        -DCMAKE_INSTALL_PREFIX=$HOME/install

#### Building the Paho C++ library

If the Paho C library is not already installed, the recommended version can be built along with the C++ library in a single step using the CMake option `PAHO_WITH_MQTT_C` set on.

    $ git clone https://github.com/eclipse/paho.mqtt.cpp
    $ cd paho.mqtt.cpp
    $ git co v1.5.4
    $ git submodule init
    $ git submodule update

    $ cmake -Bbuild -H. -DPAHO_WITH_MQTT_C=ON -DPAHO_BUILD_EXAMPLES=ON
    $ sudo cmake --build build/ --target install

If a recent version of the Paho C library is available on the build host, and it's installed to a default location, it does not need to be built again. Omit the `PAHO_WITH_MQTT_C` option:

    $ cmake -Bbuild -H. -DPAHO_BUILD_SAMPLES=ON

If the Paho C library is installed to a _non-default_ location, or you want to build against a different version, use the `CMAKE_PREFIX_PATH` to specify its install location. Perhaps something like this:

    $ cmake -Bbuild -H. -DPAHO_BUILD_SAMPLES=ON -DCMAKE_PREFIX_PATH=$HOME/install

#### Building a Debian/Ubuntu package

A Debian/Ubuntu install `.deb` file can be created as follows:

```
$ cmake -Bbuild -H. -DPAHO_WITH_SSL=ON -DPAHO_ENABLE_TESTING=OFF -DPAHO_BUILD_DEB_PACKAGE=ON
$ cmake --build build
$ (cd build && cpack)
```

### Windows

On Windows, CMake creates Visual Studio project files for use with MSVC. Currently, other compilers like _clang_ or _MinGW_ are not directly supported.

#### Using Paho C++ as a Windows DLL

The project can be built as a static library or shared DLL on Windows. If using it as a DLL in your application, you should define the macro `PAHO_MQTTPP_IMPORTS` before including any Paho C++ include files. Preferably, make it a global definition in the application's build file, like in CMake:

    target_compile_definitions(myapp PUBLIC PAHO_MQTTPP_IMPORTS)

It's better not to mix DLLs and static libraries, but if you do link the Paho C++ DLL against the Paho C static library, you may need to manually resolve some system dependencies, like adding the WinSock library as a dependency to your application:

    target_link_libraries(myapp ws2_32)

#### Building the Library on Windows

The build process currently supports a number Windows versions. The build process requires the following tools:
  * CMake GUI v3.13 or newer
  * Visual Studio 2019 or newer

The libraries can be completely built at an MSBuild Command Prompt. Download the Paho C and C++ library sources, then open a command window and first compile the Paho C library:

    > cd paho.mqtt.c
    > cmake -Bbuild -H. -DCMAKE_INSTALL_PREFIX=C:\mqtt\paho-c
    > cmake --build build/ --target install

Then build the C++ library:

    > cd ..\paho.mqtt.cpp
    > cmake -Bbuild -H. -DCMAKE_INSTALL_PREFIX=C:\mqtt\paho-cpp -DPAHO_BUILD_SAMPLES=ON -DPAHO_WITH_SSL=OFF -DCMAKE_PREFIX_PATH=C:\mqtt\paho-c
    > cmake --build build/ --target install

This builds and installs both libraries to a non-standard location under `C:\mqtt`. Modify this location as desired or use the default location, but either way, the C++ library will most likely need to be told where the C library was built using `CMAKE_PREFIX_PATH`.

It seems quite odd, but even on a 64-bit system using a 64-bit compiler, MSVC seems to default to a 32-bit build target.

The 64-bit target can be selected using the CMake generator switch, *-G*, at configuration time. The full version must be provided.

    > cmake -G "Visual Studio 16 2019" -Ax64 -Bbuild -H. -DCMAKE_INSTALL_PREFIX=C:\mqtt\paho-c
    > ...

*Note that it is very important that you use the same generator (target) to build BOTH libraries, otherwise you will get lots of linker errors when you try to build the C++ library.*

## Supported Network Protocols

The library supports connecting to an MQTT server/broker using TCP, SSL/TLS, and websockets both (secure and insecure). On *nix targets, UNIX-domain sockets are also supported. The underlying transport is chosen by the URI supplied to indicate the remote host. It can be specified as:

    "mqtt://<host>:<port>"   - TCP, unsecure
     "tcp://<host>:<port>"    (same)

    "mqtts://<host>:<port>"  - SSL/TLS
     "ssl://<host>:<port>"     (same)

    "ws://<host>:<port>"    - Unsecure websockets
    "wss://<host>:<port>"   - Secure websockets

	"unix://<path>"          - A UNIX-domain socket on the local machine.
	                           (*nix systems, only)

The "mqtt://" and "tcp://" schemas are identical. They indicate an insecure connection over TCP. The "mqtt://" variation is new for the library, but becoming more common across different MQTT libraries.

Similarly, the "mqtts://" and "ssl://" schemas are identical. They specify a secure connection over SSL/TLS sockets.

Note that to use any of the secure connect options, "mqtts://, "ssl://", or "wss://" you must compile the library with the `PAHO_WITH_SSL=ON` CMake option to include OpenSSL. In addition, you _must_ specify `ssl_options` when you connect to the broker - i.e. you must add an instance of `ssl_options` to the `connect_options` when calling `connect()`.

The use of Unix-domain sockets is only available on *nix-style systems like Linux and macOS. It is not available on Windows. It requires the Paho C library built with the CMake option of PAHO_WITH_UNIX_SOCKETS=ON. This is done by default when building the C library automatically with the Git submodule.

## _Catch2_ Unit Tests

Unit tests use _Catch2_ for the test framework. Versions 2.x and 3.x are supported.

_Catch2_ can be found here: [Catch2](https://github.com/catchorg/Catch2)

## Basics of Thread Safety

Some things to keep in mind when using the library in a multi-threaded application:

- The clients are thread-safe. You can publish/subscribe/etc from multiple threads simultaneously. There are internal mutexes to protect multi-threaded access.
- You should not make a blocking call from within a callback from the library, i.e. anything registered with `set_callback()`, `set_message_callback()`, etc. Callbacks are invoked from the one internal thread that is processing incoming packets from the network. If you make a blocking call that expects an ACK, you will deadlock.
- You can only register one `on_message()` callback per client to receive incoming messages for all of your registered subscriptions. That callback runs in the context of the library thread. If you want to process incoming messages from a different (or multiple) threads:
    - Use a consumer queue, or create one or more instances of a thread-safe queue to move the messages around.
    - The [thread_queue](https://github.com/eclipse/paho.mqtt.cpp/blob/master/include/mqtt/thread_queue.h) class in the library is a thread-safe queue that you can use for this.
    - To route incoming messages by topic:
        - Use an instance of the (topic_matcher)[https://github.com/eclipse/paho.mqtt.cpp/blob/master/include/mqtt/topic_matcher.h] collection to create a collection of queues or callback functions to receive messages that match a set of topic filters.
        - For MQTT v5 consider using Subscription Identifiers to map incoming messages to callbacks or queues.
- The various data and options structs (like connect_options) are simple data structs. They are not thread protected.

## Examples

Sample applications can be found in the source repository at [examples/](https://github.com/eclipse/paho.mqtt.cpp/tree/master/examples).

These can all be build along with the library by specifying the CMake flag: `-DPAHO_BUILD_EXAMPLES=ON` when configuring the build.

This is a partial example of what a typical application might look like:

```cpp
int main(int argc, char* argv[])
{
    sample_mem_persistence persist;
    mqtt::client cli(ADDRESS, CLIENT_ID, &persist);

    callback cb;
    cli.set_callback(cb);

    auto connOpts = mqtt::connect_options_builder()
        .keep_alive_interval(20);
        .clean_session()
        .finalize();

    try {
        cli.connect(connOpts);

        // First use a message pointer.

        mqtt::message_ptr pubmsg = mqtt::make_message(PAYLOAD1);
        pubmsg->set_qos(QOS);
        cli.publish(TOPIC, pubmsg);

        // Now try with itemized publish.

        cli.publish(TOPIC, PAYLOAD2, strlen(PAYLOAD2)+1, 0, false);

        // Disconnect

        cli.disconnect();
    }
    catch (const mqtt::persistence_exception& exc) {
        cerr << "Persistence Error: " << exc.what() << " ["
            << exc.get_reason_code() << "]" << endl;
        return 1;
    }
    catch (const mqtt::exception& exc) {
        cerr << "Error: " << exc.what() << " ["
            << exc.get_reason_code() << "]" << endl;
        return 1;
    }

    return 0;
}
```

This code requires:

The Paho C library by Ian Craggs, et al.
https://github.com/eclipse/paho.mqtt.c
```

`SECURITY.md`:

```md
# Security Policy

This project follows the [Eclipse Vulnerability Reporting Policy](https://www.eclipse.org/security/policy.php).
Vulnerabilities are tracked by the Eclipse security team, in cooperation with the project lead.
Fixing vulnerabilities is taken care of by the project committers, with assistance and guidance of the security
team.

## Supported Versions

Eclipse Paho provides security updates for the most recent version only.

## Reporting a Vulnerability

We recommend that in case of suspected vulnerabilities you do not create a GitHub issue, but instead contact the
Eclipse Security Team directly sending an email to security@eclipse.org.


```

`about.html`:

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>About</title>
</head>
<body lang="EN-US">
<h2>About This Content</h2>
 
<p><em>December 9, 2013</em></p>	
<h3>License</h3>

<p>The Eclipse Foundation makes available all content in this plug-in ("Content").  Unless otherwise 
indicated below, the Content is provided to you under the terms and conditions of the
Eclipse Public License Version 1.0 ("EPL") and Eclipse Distribution License Version 1.0 ("EDL").
A copy of the EPL is available at 
<a href="http://www.eclipse.org/legal/epl-v20.html">http://www.eclipse.org/legal/epl-v20.html</a> 
and a copy of the EDL is available at 
<a href="http://www.eclipse.org/org/documents/edl-v10.php">http://www.eclipse.org/org/documents/edl-v10.php</a>. 
For purposes of the EPL, "Program" will mean the Content.</p>

<p>If you did not receive this Content directly from the Eclipse Foundation, the Content is 
being redistributed by another party ("Redistributor") and different terms and conditions may
apply to your use of any object code in the Content.  Check the Redistributor's license that was 
provided with the Content.  If no such license exists, contact the Redistributor.  Unless otherwise
indicated below, the terms and conditions of the EPL still apply to any source code in the Content
and such source code may be obtained at <a href="http://www.eclipse.org/">http://www.eclipse.org</a>.</p>

</body></html>

```

`buildtst.sh`:

```sh
#!/bin/bash
#
# buildtst.sh
# 
# Build test for the Paho C++ library.
#
# This is a local CI for testing the build on a dev machine.
#
# This test the build with a few compilers on Linux. It does a build using 
# CMake, for the library, tests, and examples, then runs the unit tests.
# This is repeated for each of the compilers in the list. If a particular 
# compiler is not installed on the system, it is just skipped.
#
# This is not meant to replace any CI on the repo server, but is a quick
# test to use locally during development.
#

COMPILERS="g++-9 g++-11 g++-13 clang++-14 clang++-17 clang++-20"

[ "$#" -gt 0 ] && COMPILERS="$@"

[ -z "${BUILD_JOBS}" ] && BUILD_JOBS=4

for COMPILER in $COMPILERS; do
    if [ -z "$(which ${COMPILER})" ]; then
        printf "Compiler not found: %s\n" "${COMPILER}"
    else
        printf "===== Testing: %s =====\n\n" "${COMPILER}"
        rm -rf buildtst-build/
        mkdir buildtst-build
        pushd buildtst-build &> /dev/null

        if ! cmake .. -DCMAKE_CXX_COMPILER=${COMPILER} -DPAHO_WITH_SSL=ON -DPAHO_BUILD_SAMPLES=ON -DPAHO_BUILD_TESTS=ON -DPAHO_WITH_MQTT_C=ON ; then
            printf "\nCMake configuration failed for %s\n" "${COMPILER}"
            exit 1
        fi

        if ! cmake --build . -j ${BUILD_JOBS} ; then
            printf "\nBuild failed for %s\n" "${COMPILER}"
            exit 2
        fi

        printf "\nRunning Catch2 Unit tests for %s:\n" "${COMPILER}"
        if ! ./test/unit/unit_tests ; then
            printf "\nCatch2 unit test failed for %s\n" "${COMPILER}"
            exit 3
        fi

        popd &> /dev/null
    fi
    printf "\n"
done

rm -rf buildtst-build/
printf "\nAll builds completed successfully\n\n"

if ! cppcheck --enable=all --std=c++17 --force --quiet src/*.cpp ; then
    printf "\ncppcheck failed\n"
    exit 5
fi

printf "\n===== All tests completed successfully =====\n\n"
exit 0

```

`cmake/CMakeLists.txt`:

```txt
# CMakeLists.txt
#
# CMake export file for the Paho C++ library.
#
#*******************************************************************************
# This is part of the Paho MQTT C++ client library.
#
# Copyright (c) 2017-2023, Frank Pagliughi
#
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v2.0
# and Eclipse Distribution License v1.0 which accompany this distribution.
#
# The Eclipse Public License is available at
#   http://www.eclipse.org/legal/epl-v20.html
# and the Eclipse Distribution License is available at
#   http://www.eclipse.org/org/documents/edl-v10.php.
#*******************************************************************************/

set(package_name PahoMqttCpp)
configure_file(${package_name}Config.cmake.in ${package_name}Config.cmake @ONLY)

include(CMakePackageConfigHelpers)

write_basic_package_version_file(
  "${CMAKE_CURRENT_BINARY_DIR}/${package_name}ConfigVersion.cmake"
  VERSION ${PROJECT_VERSION}
  COMPATIBILITY SameMajorVersion
)

export(EXPORT ${package_name}
  FILE "${CMAKE_CURRENT_BINARY_DIR}/${package_name}Targets.cmake"
  NAMESPACE ${package_name}::
)

install(EXPORT ${package_name}
  DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${package_name}
  FILE ${package_name}Targets.cmake
  NAMESPACE ${package_name}::
)

install(FILES
  "${CMAKE_CURRENT_BINARY_DIR}/${package_name}Config.cmake"
  "${CMAKE_CURRENT_BINARY_DIR}/${package_name}ConfigVersion.cmake"
  DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${package_name}
)

```

`cmake/CPackDebConfig.cmake`:

```cmake
if(CPACK_GENERATOR MATCHES "DEB")
    set(CPACK_PACKAGE_NAME "libpaho-mqtt.cpp")
    set(CPACK_DEBIAN_PACKAGE_NAME ${CPACK_PACKAGE_NAME})
    set(CPACK_PACKAGE_CONTACT "Eclipse")
    set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "Eclipse Paho MQTT C++ client")
    set(CPACK_DEBIAN_PACKAGE_MAINTAINER " <>")
    set(CPACK_DEBIAN_PACKAGE_SHLIBDEPS ON)
    set(CPACK_DEBIAN_PACKAGE_VERSION ${PACKAGE_VERSION})
    set(CPACK_DEBIAN_PACKAGE_SECTION "net")
endif()

```

`cmake/PahoMqttCppConfig.cmake.in`:

```in
# save build-time options
set(PAHO_BUILD_STATIC @PAHO_BUILD_STATIC@)
set(PAHO_BUILD_SHARED @PAHO_BUILD_SHARED@)
set(PAHO_WITH_SSL @PAHO_WITH_SSL@)
set(PAHO_WITH_MQTT_C @PAHO_WITH_MQTT_C@)

include(CMakeFindDependencyMacro)

find_dependency(Threads REQUIRED)

if (NOT PAHO_WITH_MQTT_C)
  find_dependency(eclipse-paho-mqtt-c REQUIRED)
endif()

if (PAHO_WITH_SSL)
  find_dependency(OpenSSL REQUIRED)
endif()

if(NOT TARGET PahoMqttCpp::paho-mqttpp3-shared AND NOT TARGET PahoMqttCpp::paho-mqttpp3-static)
    include("${CMAKE_CURRENT_LIST_DIR}/@package_name@Targets.cmake")

    if(TARGET PahoMqttCpp::paho-mqttpp3-shared)
        add_library(PahoMqttCpp::paho-mqttpp3 ALIAS PahoMqttCpp::paho-mqttpp3-shared)
    else()
        add_library(PahoMqttCpp::paho-mqttpp3 ALIAS PahoMqttCpp::paho-mqttpp3-static)
    endif()
endif()

```

`devenv.sh`:

```sh
#!/bin/bash
#
# devenv.sh
#
# Sets up a development environment for working on the the Paho C++ Library on Linux,
# using the development tree of the Paho C library. 
# This is _not_ necessary for building applications against the library once it has 
# been installed - it's just for library developers.
#
# Source it into the current shell as:
#     $ source devenv.sh
#

PAHO_C_DIR=$(readlink -e ../paho.mqtt.c)

export DEVELOP=1
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:${PAHO_C_DIR}/build/output:${PWD}/lib


```

`dist/Makefile`:

```
VERSION=1.0.0

check:
	rpmlint -i dist/paho-cpp.spec

rpm-prep:
	mkdir -p ${HOME}/rpmbuild/SOURCES/
	tar --transform="s/\./paho-cpp-${VERSION}/" -cf ${HOME}/rpmbuild/SOURCES/v${VERSION}.tar.gz --exclude=./build.paho.cpp --exclude=.git --exclude=*.bz ./ --gzip

rpm: rpm-prep
	rpmbuild -ba dist/paho-cpp.spec

```

`dist/paho-cpp.spec`:

```spec
Summary:            MQTT CPP Client
Name:               paho-cpp
Version:            1.5.4
Release:            0%{?dist}
License:            Eclipse Eclipse Public License 2.0 and Distribution License 1.0
Group:              Development/Tools
Source:             https://github.com/eclipse/paho.mqtt.cpp/archive/v%{version}.tar.gz
URL:                https://eclipse.org/paho/clients/cpp/
BuildRequires:      cmake3
BuildRequires:      gcc
BuildRequires:      graphviz
BuildRequires:      doxygen
BuildRequires:      openssl-devel
BuildRequires:      paho-c-devel
Requires:           openssl
Requires:           paho-c


%description
The Paho MQTT CPP Client is a fully fledged MQTT client written in ANSI standard C++ 17.


%package devel
Summary:            MQTT CPP Client development kit
Group:              Development/Libraries
Requires:           paho-cpp

%description devel
Development files and samples for the the Paho MQTT CPP Client.


%package devel-docs
Summary:            MQTT CPP Client development kit documentation
Group:              Development/Libraries

%description devel-docs
Development documentation files for the the Paho MQTT CPP Client.

%prep
%autosetup -n paho-cpp-%{version}

%build
mkdir build.paho.cpp && cd build.paho.cpp
%cmake3 -DPAHO_WITH_SSL=TRUE -DPAHO_BUILD_DOCUMENTATION=TRUE -DPAHO_BUILD_EXAMPLES=TRUE ..
make %{?_smp_mflags}

%install
cd build.paho.cpp
make install DESTDIR=%{buildroot}

%files
%doc edl-v10 epl-v20
%{_libdir}/*

%files devel
%{_bindir}/*
%{_includedir}/*

%files devel-docs
%{_datadir}/*

%changelog
* Wed Oct 11 2017 Julien Courtat <julien.courtat@aqsacom.com> - 1.0.0
- Initial packaging

```

`doc/CMakeLists.txt`:

```txt
#*******************************************************************************
# Copyright (c) 2024, Frank Pagliughi
# Copyright (c) 2016, Guilherme Maciel Ferreira
# 
#  All rights reserved. This program and the accompanying materials
#  are made available under the terms of the Eclipse Public License v2.0
#  and Eclipse Distribution License v1.0 which accompany this distribution. 
# 
#  The Eclipse Public License is available at 
#     http://www.eclipse.org/legal/epl-v20.html
#  and the Eclipse Distribution License is available at 
#    http://www.eclipse.org/org/documents/edl-v10.php.
# 
#  Contributors:
#     Frank Pagliughi - Updated paths. Fixed conflict with Paho C
#     Guilherme Maciel Ferreira - initial version
#*******************************************************************************/

## documentation settings
find_package(Doxygen REQUIRED)
file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/doc)

message(STATUS "Doxygen: ${DOXYGEN_EXECUTABLE}")

configure_file(
    ${CMAKE_CURRENT_SOURCE_DIR}/Doxyfile.cmake
    ${CMAKE_CURRENT_BINARY_DIR}/Doxyfile
    @ONLY
)

add_custom_target(
    paho-mqttpp3-doc.target
    COMMAND ${DOXYGEN_EXECUTABLE} Doxyfile
    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    COMMENT "Generating API documentation with Doxygen"
    VERBATIM
)

add_custom_target(paho-mqttpp3-doc ALL 
    DEPENDS paho-mqttpp3-doc.target
)

install(
    DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/doc/
    DESTINATION share/doc/EclipsePahoCpp
)


```

`doc/Doxyfile.cmake`:

```cmake
# Doxyfile 1.7.6.1

# This file describes the settings to be used by the documentation system
# doxygen (www.doxygen.org) for a project.
#
# All text after a hash (#) is considered a comment and will be ignored.
# The format is:
#       TAG = value [value, ...]
# For lists items can also be appended using:
#       TAG += value [value, ...]
# Values that contain spaces should be placed between quotes (" ").

#---------------------------------------------------------------------------
# Project related configuration options
#---------------------------------------------------------------------------

# This tag specifies the encoding used for all characters in the config file
# that follow. The default is UTF-8 which is also the encoding used for all
# text before the first occurrence of this tag. Doxygen uses libiconv (or the
# iconv built into libc) for the transcoding. See
# http://www.gnu.org/software/libiconv for the list of possible encodings.

DOXYFILE_ENCODING      = UTF-8

# The PROJECT_NAME tag is a single word (or sequence of words) that should
# identify the project. Note that if you do not use Doxywizard you need
# to put quotes around the project name if it contains spaces.

PROJECT_NAME           = @PROJECT_NAME@

# The PROJECT_NUMBER tag can be used to enter a project or revision number.
# This could be handy for archiving the generated documentation or
# if some version control system is used.

PROJECT_NUMBER         = @CLIENT_VERSION@

# Using the PROJECT_BRIEF tag one can provide an optional one line description
# for a project that appears at the top of each page and should give viewer
# a quick idea about the purpose of the project. Keep the description short.

PROJECT_BRIEF          = "MQTT C++ Client for POSIX and Windows"

# With the PROJECT_LOGO tag one can specify an logo or icon that is
# included in the documentation. The maximum height of the logo should not
# exceed 55 pixels and the maximum width should not exceed 200 pixels.
# Doxygen will copy the logo to the output directory.

PROJECT_LOGO           = "@PROJECT_SOURCE_DIR@/doc/pahologo.png"

# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
# base path where the generated documentation will be put.
# If a relative path is entered, it will be relative to the location
# where doxygen was started. If left blank the current directory will be used.

OUTPUT_DIRECTORY       = "@CMAKE_CURRENT_BINARY_DIR@/doc"

# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create
# 4096 sub-directories (in 2 levels) under the output directory of each output
# format and will distribute the generated files over these directories.
# Enabling this option can be useful when feeding doxygen a huge amount of
# source files, where putting all generated files in the same directory would
# otherwise cause performance problems for the file system.

CREATE_SUBDIRS         = NO

# The OUTPUT_LANGUAGE tag is used to specify the language in which all
# documentation generated by doxygen is written. Doxygen will use this
# information to generate all constant output in the proper language.
# The default language is English, other supported languages are:
# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional,
# Croatian, Czech, Danish, Dutch, Esperanto, Farsi, Finnish, French, German,
# Greek, Hungarian, Italian, Japanese, Japanese-en (Japanese with English
# messages), Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian,
# Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrillic, Slovak,
# Slovene, Spanish, Swedish, Ukrainian, and Vietnamese.

OUTPUT_LANGUAGE        = English

# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will
# include brief member descriptions after the members that are listed in
# the file and class documentation (similar to JavaDoc).
# Set to NO to disable this.

BRIEF_MEMBER_DESC      = YES

# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend
# the brief description of a member or function before the detailed description.
# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
# brief descriptions will be completely suppressed.

REPEAT_BRIEF           = YES

# This tag implements a quasi-intelligent brief description abbreviator
# that is used to form the text in various listings. Each string
# in this list, if found as the leading text of the brief description, will be
# stripped from the text and the result after processing the whole list, is
# used as the annotated text. Otherwise, the brief description is used as-is.
# If left blank, the following values are used ("$name" is automatically
# replaced with the name of the entity): "The $name class" "The $name widget"
# "The $name file" "is" "provides" "specifies" "contains"
# "represents" "a" "an" "the"

ABBREVIATE_BRIEF       =

# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
# Doxygen will generate a detailed section even if there is only a brief
# description.

ALWAYS_DETAILED_SEC    = NO

# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
# inherited members of a class in the documentation of that class as if those
# members were ordinary class members. Constructors, destructors and assignment
# operators of the base classes will not be shown.

INLINE_INHERITED_MEMB  = NO

# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full
# path before files name in the file list and in the header files. If set
# to NO the shortest path that makes the file name unique will be used.

FULL_PATH_NAMES        = NO

# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag
# can be used to strip a user-defined part of the path. Stripping is
# only done if one of the specified strings matches the left-hand part of
# the path. The tag can be used to show relative paths in the file list.
# If left blank the directory from which doxygen is run is used as the
# path to strip.

STRIP_FROM_PATH        =

# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of
# the path mentioned in the documentation of a class, which tells
# the reader which header file to include in order to use a class.
# If left blank only the name of the header file containing the class
# definition is used. Otherwise one should specify the include paths that
# are normally passed to the compiler using the -I flag.

STRIP_FROM_INC_PATH    =

# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter
# (but less readable) file names. This can be useful if your file system
# doesn't support long names like on DOS, Mac, or CD-ROM.

SHORT_NAMES            = NO

# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen
# will interpret the first line (until the first dot) of a JavaDoc-style
# comment as the brief description. If set to NO, the JavaDoc
# comments will behave just like regular Qt-style comments
# (thus requiring an explicit @brief command for a brief description.)

JAVADOC_AUTOBRIEF      = NO

# If the QT_AUTOBRIEF tag is set to YES then Doxygen will
# interpret the first line (until the first dot) of a Qt-style
# comment as the brief description. If set to NO, the comments
# will behave just like regular Qt-style comments (thus requiring
# an explicit \brief command for a brief description.)

QT_AUTOBRIEF           = NO

# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen
# treat a multi-line C++ special comment block (i.e. a block of //! or ///
# comments) as a brief description. This used to be the default behaviour.
# The new default is to treat a multi-line C++ comment block as a detailed
# description. Set this tag to YES if you prefer the old behaviour instead.

MULTILINE_CPP_IS_BRIEF = NO

# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented
# member inherits the documentation from any documented member that it
# re-implements.

INHERIT_DOCS           = YES

# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce
# a new page for each member. If set to NO, the documentation of a member will
# be part of the file/class/namespace that contains it.

SEPARATE_MEMBER_PAGES  = NO

# The TAB_SIZE tag can be used to set the number of spaces in a tab.
# Doxygen uses this value to replace tabs by spaces in code fragments.

TAB_SIZE               = 4

# This tag can be used to specify a number of aliases that acts
# as commands in the documentation. An alias has the form "name=value".
# For example adding "sideeffect=\par Side Effects:\n" will allow you to
# put the command \sideeffect (or @sideeffect) in the documentation, which
# will result in a user-defined paragraph with heading "Side Effects:".
# You can put \n's in the value part of an alias to insert newlines.

ALIASES                =

# This tag can be used to specify a number of word-keyword mappings (TCL only).
# A mapping has the form "name=value". For example adding
# "class=itcl::class" will allow you to use the command class in the
# itcl::class meaning.

TCL_SUBST              =

# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C
# sources only. Doxygen will then generate output that is more tailored for C.
# For instance, some of the names that are used will be different. The list
# of all members will be omitted, etc.

OPTIMIZE_OUTPUT_FOR_C  = YES

# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java
# sources only. Doxygen will then generate output that is more tailored for
# Java. For instance, namespaces will be presented as packages, qualified
# scopes will look different, etc.

OPTIMIZE_OUTPUT_JAVA   = NO

# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
# sources only. Doxygen will then generate output that is more tailored for
# Fortran.

OPTIMIZE_FOR_FORTRAN   = NO

# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
# sources. Doxygen will then generate output that is tailored for
# VHDL.

OPTIMIZE_OUTPUT_VHDL   = NO

# Doxygen selects the parser to use depending on the extension of the files it
# parses. With this tag you can assign which parser to use for a given extension.
# Doxygen has a built-in mapping, but you can override or extend it using this
# tag. The format is ext=language, where ext is a file extension, and language
# is one of the parsers supported by doxygen: IDL, Java, Javascript, CSharp, C,
# C++, D, PHP, Objective-C, Python, Fortran, VHDL, C, C++. For instance to make
# doxygen treat .inc files as Fortran files (default is PHP), and .f files as C
# (default is Fortran), use: inc=Fortran f=C. Note that for custom extensions
# you also need to set FILE_PATTERNS otherwise the files are not read by doxygen.

EXTENSION_MAPPING      =

# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
# to include (a tag file for) the STL sources as input, then you should
# set this tag to YES in order to let doxygen match functions declarations and
# definitions whose arguments contain STL classes (e.g. func(std::string); v.s.
# func(std::string) {}). This also makes the inheritance and collaboration
# diagrams that involve STL classes more complete and accurate.

BUILTIN_STL_SUPPORT    = NO

# If you use Microsoft's C++/CLI language, you should set this option to YES to
# enable parsing support.

CPP_CLI_SUPPORT        = NO

# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only.
# Doxygen will parse them like normal C++ but will assume all classes use public
# instead of private inheritance when no explicit protection keyword is present.

SIP_SUPPORT            = NO

# For Microsoft's IDL there are propget and propput attributes to indicate getter
# and setter methods for a property. Setting this option to YES (the default)
# will make doxygen replace the get and set methods by a property in the
# documentation. This will only work if the methods are indeed getting or
# setting a simple type. If this is not the case, or you want to show the
# methods anyway, you should set this option to NO.

IDL_PROPERTY_SUPPORT   = YES

# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
# tag is set to YES, then doxygen will reuse the documentation of the first
# member in the group (if any) for the other members of the group. By default
# all members of a group must be documented explicitly.

DISTRIBUTE_GROUP_DOC   = NO

# Set the SUBGROUPING tag to YES (the default) to allow class member groups of
# the same type (for instance a group of public functions) to be put as a
# subgroup of that type (e.g. under the Public Functions section). Set it to
# NO to prevent subgrouping. Alternatively, this can be done per class using
# the \nosubgrouping command.

SUBGROUPING            = YES

# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and
# unions are shown inside the group in which they are included (e.g. using
# @ingroup) instead of on a separate page (for HTML and Man pages) or
# section (for LaTeX and RTF).

INLINE_GROUPED_CLASSES = NO

# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and
# unions with only public data fields will be shown inline in the documentation
# of the scope in which they are defined (i.e. file, namespace, or group
# documentation), provided this scope is documented. If set to NO (the default),
# structs, classes, and unions are shown on a separate page (for HTML and Man
# pages) or section (for LaTeX and RTF).

INLINE_SIMPLE_STRUCTS  = NO

# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum
# is documented as struct, union, or enum with the name of the typedef. So
# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
# with name TypeT. When disabled the typedef will appear as a member of a file,
# namespace, or class. And the struct will be named TypeS. This can typically
# be useful for C code in case the coding convention dictates that all compound
# types are typedef'ed and only the typedef is referenced, never the tag name.

TYPEDEF_HIDES_STRUCT   = NO

# The SYMBOL_CACHE_SIZE determines the size of the internal cache use to
# determine which symbols to keep in memory and which to flush to disk.
# When the cache is full, less often used symbols will be written to disk.
# For small to medium size projects (<1000 input files) the default value is
# probably good enough. For larger projects a too small cache size can cause
# doxygen to be busy swapping symbols to and from disk most of the time
# causing a significant performance penalty.
# If the system has enough physical memory increasing the cache will improve the
# performance by keeping more symbols in memory. Note that the value works on
# a logarithmic scale so increasing the size by one will roughly double the
# memory usage. The cache size is given by this formula:
# 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0,
# corresponding to a cache size of 2^16 = 65536 symbols.

#SYMBOL_CACHE_SIZE      = 0

# Similar to the SYMBOL_CACHE_SIZE the size of the symbol lookup cache can be
# set using LOOKUP_CACHE_SIZE. This cache is used to resolve symbols given
# their name and scope. Since this can be an expensive process and often the
# same symbol appear multiple times in the code, doxygen keeps a cache of
# pre-resolved symbols. If the cache is too small doxygen will become slower.
# If the cache is too large, memory is wasted. The cache size is given by this
# formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range is 0..9, the default is 0,
# corresponding to a cache size of 2^16 = 65536 symbols.

LOOKUP_CACHE_SIZE      = 0

#---------------------------------------------------------------------------
# Build related configuration options
#---------------------------------------------------------------------------

# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
# documentation are documented, even if no documentation was available.
# Private class members and static file members will be hidden unless
# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES

EXTRACT_ALL            = YES

# If the EXTRACT_PRIVATE tag is set to YES all private members of a class
# will be included in the documentation.

EXTRACT_PRIVATE        = NO

# If the EXTRACT_STATIC tag is set to YES all static members of a file
# will be included in the documentation.

EXTRACT_STATIC         = NO

# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs)
# defined locally in source files will be included in the documentation.
# If set to NO only classes defined in header files are included.

EXTRACT_LOCAL_CLASSES  = YES

# This flag is only useful for Objective-C code. When set to YES local
# methods, which are defined in the implementation section but not in
# the interface are included in the documentation.
# If set to NO (the default) only methods in the interface are included.

EXTRACT_LOCAL_METHODS  = NO

# If this flag is set to YES, the members of anonymous namespaces will be
# extracted and appear in the documentation as a namespace called
# 'anonymous_namespace{file}', where file will be replaced with the base
# name of the file that contains the anonymous namespace. By default
# anonymous namespaces are hidden.

EXTRACT_ANON_NSPACES   = NO

# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all
# undocumented members of documented classes, files or namespaces.
# If set to NO (the default) these members will be included in the
# various overviews, but no documentation section is generated.
# This option has no effect if EXTRACT_ALL is enabled.

HIDE_UNDOC_MEMBERS     = NO

# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all
# undocumented classes that are normally visible in the class hierarchy.
# If set to NO (the default) these classes will be included in the various
# overviews. This option has no effect if EXTRACT_ALL is enabled.

HIDE_UNDOC_CLASSES     = NO

# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all
# friend (class|struct|union) declarations.
# If set to NO (the default) these declarations will be included in the
# documentation.

HIDE_FRIEND_COMPOUNDS  = NO

# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any
# documentation blocks found inside the body of a function.
# If set to NO (the default) these blocks will be appended to the
# function's detailed documentation block.

HIDE_IN_BODY_DOCS      = NO

# The INTERNAL_DOCS tag determines if documentation
# that is typed after a \internal command is included. If the tag is set
# to NO (the default) then the documentation will be excluded.
# Set it to YES to include the internal documentation.

INTERNAL_DOCS          = NO

# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate
# file names in lower-case letters. If set to YES upper-case letters are also
# allowed. This is useful if you have classes or files whose names only differ
# in case and if your file system supports case sensitive file names. Windows
# and Mac users are advised to set this option to NO.

CASE_SENSE_NAMES       = YES

# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen
# will show members with their full class and namespace scopes in the
# documentation. If set to YES the scope will be hidden.

HIDE_SCOPE_NAMES       = NO

# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen
# will put a list of the files that are included by a file in the documentation
# of that file.

SHOW_INCLUDE_FILES     = YES

# If the FORCE_LOCAL_INCLUDES tag is set to YES then Doxygen
# will list include files with double quotes in the documentation
# rather than with sharp brackets.

FORCE_LOCAL_INCLUDES   = NO

# If the INLINE_INFO tag is set to YES (the default) then a tag [inline]
# is inserted in the documentation for inline members.

INLINE_INFO            = YES

# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen
# will sort the (detailed) documentation of file and class members
# alphabetically by member name. If set to NO the members will appear in
# declaration order.

SORT_MEMBER_DOCS       = NO

# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the
# brief documentation of file, namespace and class members alphabetically
# by member name. If set to NO (the default) the members will appear in
# declaration order.

SORT_BRIEF_DOCS        = NO

# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen
# will sort the (brief and detailed) documentation of class members so that
# constructors and destructors are listed first. If set to NO (the default)
# the constructors will appear in the respective orders defined by
# SORT_MEMBER_DOCS and SORT_BRIEF_DOCS.
# This tag will be ignored for brief docs if SORT_BRIEF_DOCS is set to NO
# and ignored for detailed docs if SORT_MEMBER_DOCS is set to NO.

SORT_MEMBERS_CTORS_1ST = NO

# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the
# hierarchy of group names into alphabetical order. If set to NO (the default)
# the group names will appear in their defined order.

SORT_GROUP_NAMES       = NO

# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be
# sorted by fully-qualified names, including namespaces. If set to
# NO (the default), the class list will be sorted only by class name,
# not including the namespace part.
# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
# Note: This option applies only to the class list, not to the
# alphabetical list.

SORT_BY_SCOPE_NAME     = NO

# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to
# do proper type resolution of all parameters of a function it will reject a
# match between the prototype and the implementation of a member function even
# if there is only one candidate or it is obvious which candidate to choose
# by doing a simple string match. By disabling STRICT_PROTO_MATCHING doxygen
# will still accept a match between prototype and implementation in such cases.

STRICT_PROTO_MATCHING  = NO

# The GENERATE_TODOLIST tag can be used to enable (YES) or
# disable (NO) the todo list. This list is created by putting \todo
# commands in the documentation.

GENERATE_TODOLIST      = YES

# The GENERATE_TESTLIST tag can be used to enable (YES) or
# disable (NO) the test list. This list is created by putting \test
# commands in the documentation.

GENERATE_TESTLIST      = YES

# The GENERATE_BUGLIST tag can be used to enable (YES) or
# disable (NO) the bug list. This list is created by putting \bug
# commands in the documentation.

GENERATE_BUGLIST       = YES

# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or
# disable (NO) the deprecated list. This list is created by putting
# \deprecated commands in the documentation.

GENERATE_DEPRECATEDLIST= YES

# The ENABLED_SECTIONS tag can be used to enable conditional
# documentation sections, marked by \if sectionname ... \endif.

ENABLED_SECTIONS       =

# The MAX_INITIALIZER_LINES tag determines the maximum number of lines
# the initial value of a variable or macro consists of for it to appear in
# the documentation. If the initializer consists of more lines than specified
# here it will be hidden. Use a value of 0 to hide initializers completely.
# The appearance of the initializer of individual variables and macros in the
# documentation can be controlled using \showinitializer or \hideinitializer
# command in the documentation regardless of this setting.

MAX_INITIALIZER_LINES  = 30

# Set the SHOW_USED_FILES tag to NO to disable the list of files generated
# at the bottom of the documentation of classes and structs. If set to YES the
# list will mention the files that were used to generate the documentation.

SHOW_USED_FILES        = YES

# If the sources in your project are distributed over multiple directories
# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy
# in the documentation. The default is NO.

#SHOW_DIRECTORIES       = NO

# Set the SHOW_FILES tag to NO to disable the generation of the Files page.
# This will remove the Files entry from the Quick Index and from the
# Folder Tree View (if specified). The default is YES.

SHOW_FILES             = YES

# Set the SHOW_NAMESPACES tag to NO to disable the generation of the
# Namespaces page.
# This will remove the Namespaces entry from the Quick Index
# and from the Folder Tree View (if specified). The default is YES.

SHOW_NAMESPACES        = YES

# The FILE_VERSION_FILTER tag can be used to specify a program or script that
# doxygen should invoke to get the current version for each file (typically from
# the version control system). Doxygen will invoke the program by executing (via
# popen()) the command <command> <input-file>, where <command> is the value of
# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file
# provided by doxygen. Whatever the program writes to standard output
# is used as the file version. See the manual for examples.

FILE_VERSION_FILTER    =

# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
# by doxygen. The layout file controls the global structure of the generated
# output files in an output format independent way. The create the layout file
# that represents doxygen's defaults, run doxygen with the -l option.
# You can optionally specify a file name after the option, if omitted
# DoxygenLayout.xml will be used as the name of the layout file.

LAYOUT_FILE            =

# The CITE_BIB_FILES tag can be used to specify one or more bib files
# containing the references data. This must be a list of .bib files. The
# .bib extension is automatically appended if omitted. Using this command
# requires the bibtex tool to be installed. See also
# http://en.wikipedia.org/wiki/BibTeX for more info. For LaTeX the style
# of the bibliography can be controlled using LATEX_BIB_STYLE. To use this
# feature you need bibtex and perl available in the search path.

CITE_BIB_FILES         =

#---------------------------------------------------------------------------
# configuration options related to warning and progress messages
#---------------------------------------------------------------------------

# The QUIET tag can be used to turn on/off the messages that are generated
# by doxygen. Possible values are YES and NO. If left blank NO is used.

QUIET                  = NO

# The WARNINGS tag can be used to turn on/off the warning messages that are
# generated by doxygen. Possible values are YES and NO. If left blank
# NO is used.

WARNINGS               = YES

# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings
# for undocumented members. If EXTRACT_ALL is set to YES then this flag will
# automatically be disabled.

WARN_IF_UNDOCUMENTED   = YES

# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for
# potential errors in the documentation, such as not documenting some
# parameters in a documented function, or documenting parameters that
# don't exist or using markup commands wrongly.

WARN_IF_DOC_ERROR      = YES

# The WARN_NO_PARAMDOC option can be enabled to get warnings for
# functions that are documented, but have no documentation for their parameters
# or return value. If set to NO (the default) doxygen will only warn about
# wrong or incomplete parameter documentation, but not about the absence of
# documentation.

WARN_NO_PARAMDOC       = NO

# The WARN_FORMAT tag determines the format of the warning messages that
# doxygen can produce. The string should contain the $file, $line, and $text
# tags, which will be replaced by the file and line number from which the
# warning originated and the warning text. Optionally the format may contain
# $version, which will be replaced by the version of the file (if it could
# be obtained via FILE_VERSION_FILTER)

WARN_FORMAT            = "$file:$line: $text"

# The WARN_LOGFILE tag can be used to specify a file to which warning
# and error messages should be written. If left blank the output is written
# to stderr.

WARN_LOGFILE           =

#---------------------------------------------------------------------------
# configuration options related to the input files
#---------------------------------------------------------------------------

# The INPUT tag can be used to specify the files and/or directories that contain
# documented source files. You may enter file names like "myfile.cpp" or
# directories like "/usr/src/myproject". Separate the files or directories
# with spaces.

STRIP_FROM_PATH        = @PROJECT_SOURCE_DIR@/include/mqtt
INPUT                  = @PROJECT_SOURCE_DIR@/include/mqtt/

# This tag can be used to specify the character encoding of the source files
# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is
# also the default input encoding. Doxygen uses libiconv (or the iconv built
# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for
# the list of possible encodings.

INPUT_ENCODING         = UTF-8

# If the value of the INPUT tag contains directories, you can use the
# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
# and *.h) to filter out the source-files in the directories. If left
# blank the following patterns are tested:
# *.c *.cc *.cxx *.cpp *.c++ *.d *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh
# *.hxx *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.dox *.py
# *.f90 *.f *.for *.vhd *.vhdl

FILE_PATTERNS          = *.h

# The RECURSIVE tag can be used to turn specify whether or not subdirectories
# should be searched for input files as well. Possible values are YES and NO.
# If left blank NO is used.

RECURSIVE              = NO

# The EXCLUDE tag can be used to specify files and/or directories that should be
# excluded from the INPUT source files. This way you can easily exclude a
# subdirectory from a directory tree whose root is specified with the INPUT tag.
# Note that relative paths are relative to the directory from which doxygen is
# run.

EXCLUDE                =

# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
# directories that are symbolic links (a Unix file system feature) are excluded
# from the input.

EXCLUDE_SYMLINKS       = NO

# If the value of the INPUT tag contains directories, you can use the
# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
# certain files from those directories. Note that the wildcards are matched
# against the file with absolute path, so to exclude all test directories
# for example use the pattern */test/*

EXCLUDE_PATTERNS       =

# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
# (namespaces, classes, functions, etc.) that should be excluded from the
# output. The symbol name can be a fully qualified name, a word, or if the
# wildcard * is used, a substring. Examples: ANamespace, AClass,
# AClass::ANamespace, ANamespace::*Test

EXCLUDE_SYMBOLS        =

# The EXAMPLE_PATH tag can be used to specify one or more files or
# directories that contain example code fragments that are included (see
# the \include command).

EXAMPLE_PATH           =

# If the value of the EXAMPLE_PATH tag contains directories, you can use the
# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
# and *.h) to filter out the source-files in the directories. If left
# blank all files are included.

EXAMPLE_PATTERNS       = *

# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
# searched for input files to be used with the \include or \dontinclude
# commands irrespective of the value of the RECURSIVE tag.
# Possible values are YES and NO. If left blank NO is used.

EXAMPLE_RECURSIVE      = NO

# The IMAGE_PATH tag can be used to specify one or more files or
# directories that contain image that are included in the documentation (see
# the \image command).

IMAGE_PATH             =

# The INPUT_FILTER tag can be used to specify a program that doxygen should
# invoke to filter for each input file. Doxygen will invoke the filter program
# by executing (via popen()) the command <filter> <input-file>, where <filter>
# is the value of the INPUT_FILTER tag, and <input-file> is the name of an
# input file. Doxygen will then use the output that the filter program writes
# to standard output.
# If FILTER_PATTERNS is specified, this tag will be
# ignored.

INPUT_FILTER           =

# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
# basis.
# Doxygen will compare the file name with each pattern and apply the
# filter if there is a match.
# The filters are a list of the form:
# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further
# info on how filters are used. If FILTER_PATTERNS is empty or if
# non of the patterns match the file name, INPUT_FILTER is applied.

FILTER_PATTERNS        =

# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
# INPUT_FILTER) will be used to filter the input files when producing source
# files to browse (i.e. when SOURCE_BROWSER is set to YES).

FILTER_SOURCE_FILES    = NO

# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
# pattern. A pattern will override the setting for FILTER_PATTERN (if any)
# and it is also possible to disable source filtering for a specific pattern
# using *.ext= (so without naming a filter). This option only has effect when
# FILTER_SOURCE_FILES is enabled.

FILTER_SOURCE_PATTERNS =

#---------------------------------------------------------------------------
# configuration options related to source browsing
#---------------------------------------------------------------------------

# If the SOURCE_BROWSER tag is set to YES then a list of source files will
# be generated. Documented entities will be cross-referenced with these sources.
# Note: To get rid of all source code in the generated output, make sure also
# VERBATIM_HEADERS is set to NO.

SOURCE_BROWSER         = NO

# Setting the INLINE_SOURCES tag to YES will include the body
# of functions and classes directly in the documentation.

INLINE_SOURCES         = NO

# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct
# doxygen to hide any special comment blocks from generated source code
# fragments. Normal C and C++ comments will always remain visible.

STRIP_CODE_COMMENTS    = YES

# If the REFERENCED_BY_RELATION tag is set to YES
# then for each documented function all documented
# functions referencing it will be listed.

REFERENCED_BY_RELATION = NO

# If the REFERENCES_RELATION tag is set to YES
# then for each documented function all documented entities
# called/used by that function will be listed.

REFERENCES_RELATION    = NO

# If the REFERENCES_LINK_SOURCE tag is set to YES (the default)
# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from
# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will
# link to the source code.
# Otherwise they will link to the documentation.

REFERENCES_LINK_SOURCE = YES

# If the USE_HTAGS tag is set to YES then the references to source code
# will point to the HTML generated by the htags(1) tool instead of doxygen
# built-in source browser. The htags tool is part of GNU's global source
# tagging system (see http://www.gnu.org/software/global/global.html). You
# will need version 4.8.6 or higher.

USE_HTAGS              = NO

# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen
# will generate a verbatim copy of the header file for each class for
# which an include is specified. Set to NO to disable this.

VERBATIM_HEADERS       = YES

#---------------------------------------------------------------------------
# configuration options related to the alphabetical class index
#---------------------------------------------------------------------------

# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index
# of all compounds will be generated. Enable this if the project
# contains a lot of classes, structs, unions or interfaces.

ALPHABETICAL_INDEX     = YES

# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then
# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns
# in which this list will be split (can be a number in the range [1..20])

COLS_IN_ALPHA_INDEX    = 5

# In case all classes in a project start with a common prefix, all
# classes will be put under the same header in the alphabetical index.
# The IGNORE_PREFIX tag can be used to specify one or more prefixes that
# should be ignored while generating the index headers.

IGNORE_PREFIX          =

#---------------------------------------------------------------------------
# configuration options related to the HTML output
#---------------------------------------------------------------------------

# If the GENERATE_HTML tag is set to YES (the default) Doxygen will
# generate HTML output.

GENERATE_HTML          = YES

# The HTML_OUTPUT tag is used to specify where the HTML docs will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be
# put in front of it. If left blank `html' will be used as the default path.

HTML_OUTPUT            = html

# The HTML_FILE_EXTENSION tag can be used to specify the file extension for
# each generated HTML page (for example: .htm,.php,.asp). If it is left blank
# doxygen will generate files with .html extension.

HTML_FILE_EXTENSION    = .html

# The HTML_HEADER tag can be used to specify a personal HTML header for
# each generated HTML page. If it is left blank doxygen will generate a
# standard header. Note that when using a custom header you are responsible
#  for the proper inclusion of any scripts and style sheets that doxygen
# needs, which is dependent on the configuration options used.
# It is advised to generate a default header using "doxygen -w html
# header.html footer.html stylesheet.css YourConfigFile" and then modify
# that header. Note that the header is subject to change so you typically
# have to redo this when upgrading to a newer version of doxygen or when
# changing the value of configuration settings such as GENERATE_TREEVIEW!

HTML_HEADER            =

# The HTML_FOOTER tag can be used to specify a personal HTML footer for
# each generated HTML page. If it is left blank doxygen will generate a
# standard footer.

HTML_FOOTER            =

# The HTML_STYLESHEET tag can be used to specify a user-defined cascading
# style sheet that is used by each HTML page. It can be used to
# fine-tune the look of the HTML output. If the tag is left blank doxygen
# will generate a default style sheet. Note that doxygen will try to copy
# the style sheet file to the HTML output directory, so don't put your own
# style sheet in the HTML output directory as well, or it will be erased!

HTML_STYLESHEET        =

# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the HTML output directory. Note
# that these files will be copied to the base HTML output directory. Use the
# $relpath$ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
# files. In the HTML_STYLESHEET file, use the file name only. Also note that
# the files will be copied as-is; there are no commands or markers available.

HTML_EXTRA_FILES       =

# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output.
# Doxygen will adjust the colors in the style sheet and background images
# according to this color. Hue is specified as an angle on a colorwheel,
# see http://en.wikipedia.org/wiki/Hue for more information.
# For instance the value 0 represents red, 60 is yellow, 120 is green,
# 180 is cyan, 240 is blue, 300 purple, and 360 is red again.
# The allowed range is 0 to 359.

HTML_COLORSTYLE_HUE    = 220

# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of
# the colors in the HTML output. For a value of 0 the output will use
# grayscales only. A value of 255 will produce the most vivid colors.

HTML_COLORSTYLE_SAT    = 100

# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to
# the luminance component of the colors in the HTML output. Values below
# 100 gradually make the output lighter, whereas values above 100 make
# the output darker. The value divided by 100 is the actual gamma applied,
# so 80 represents a gamma of 0.8, The value 220 represents a gamma of 2.2,
# and 100 does not change the gamma.

HTML_COLORSTYLE_GAMMA  = 80

# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
# page will contain the date and time when the page was generated. Setting
# this to NO can help when comparing the output of multiple runs.

HTML_TIMESTAMP         = YES

# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes,
# files or namespaces will be aligned in HTML using tables. If set to
# NO a bullet list will be used.

#HTML_ALIGN_MEMBERS     = YES

# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
# documentation will contain sections that can be hidden and shown after the
# page has loaded. For this to work a browser that supports
# JavaScript and DHTML is required (for instance Mozilla 1.0+, Firefox
# Netscape 6.0+, Internet explorer 5.0+, Konqueror, or Safari).

HTML_DYNAMIC_SECTIONS  = NO

# If the GENERATE_DOCSET tag is set to YES, additional index files
# will be generated that can be used as input for Apple's Xcode 3
# integrated development environment, introduced with OSX 10.5 (Leopard).
# To create a documentation set, doxygen will generate a Makefile in the
# HTML output directory. Running make will produce the docset in that
# directory and running "make install" will install the docset in
# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find
# it at startup.
# See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
# for more information.

GENERATE_DOCSET        = NO

# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the
# feed. A documentation feed provides an umbrella under which multiple
# documentation sets from a single provider (such as a company or product suite)
# can be grouped.

DOCSET_FEEDNAME        = "Doxygen generated docs"

# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that
# should uniquely identify the documentation set bundle. This should be a
# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen
# will append .docset to the name.

DOCSET_BUNDLE_ID       = org.doxygen.Project

# When GENERATE_PUBLISHER_ID tag specifies a string that should uniquely identify
# the documentation publisher. This should be a reverse domain-name style
# string, e.g. com.mycompany.MyDocSet.documentation.

DOCSET_PUBLISHER_ID    = org.doxygen.Publisher

# The GENERATE_PUBLISHER_NAME tag identifies the documentation publisher.

DOCSET_PUBLISHER_NAME  = Publisher

# If the GENERATE_HTMLHELP tag is set to YES, additional index files
# will be generated that can be used as input for tools like the
# Microsoft HTML help workshop to generate a compiled HTML help file (.chm)
# of the generated HTML documentation.

GENERATE_HTMLHELP      = NO

# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can
# be used to specify the file name of the resulting .chm file. You
# can add a path in front of the file if the result should not be
# written to the html output directory.

CHM_FILE               =

# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can
# be used to specify the location (absolute path including file name) of
# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run
# the HTML help compiler on the generated index.hhp.

HHC_LOCATION           =

# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag
# controls if a separate .chi index file is generated (YES) or that
# it should be included in the master .chm file (NO).

GENERATE_CHI           = NO

# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING
# is used to encode HtmlHelp index (hhk), content (hhc) and project file
# content.

CHM_INDEX_ENCODING     =

# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag
# controls whether a binary table of contents is generated (YES) or a
# normal table of contents (NO) in the .chm file.

BINARY_TOC             = NO

# The TOC_EXPAND flag can be set to YES to add extra items for group members
# to the contents of the HTML help documentation and to the tree view.

TOC_EXPAND             = NO

# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated
# that can be used as input for Qt's qhelpgenerator to generate a
# Qt Compressed Help (.qch) of the generated HTML documentation.

GENERATE_QHP           = NO

# If the QHG_LOCATION tag is specified, the QCH_FILE tag can
# be used to specify the file name of the resulting .qch file.
# The path specified is relative to the HTML output folder.

QCH_FILE               =

# The QHP_NAMESPACE tag specifies the namespace to use when generating
# Qt Help Project output. For more information please see
# http://doc.trolltech.com/qthelpproject.html#namespace

QHP_NAMESPACE          = org.doxygen.Project

# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating
# Qt Help Project output. For more information please see
# http://doc.trolltech.com/qthelpproject.html#virtual-folders

QHP_VIRTUAL_FOLDER     = doc

# If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to
# add. For more information please see
# http://doc.trolltech.com/qthelpproject.html#custom-filters

QHP_CUST_FILTER_NAME   =

# The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the
# custom filter to add. For more information please see
# <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters">
# Qt Help Project / Custom Filters</a>.

QHP_CUST_FILTER_ATTRS  =

# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
# project's
# filter section matches.
# <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes">
# Qt Help Project / Filter Attributes</a>.

QHP_SECT_FILTER_ATTRS  =

# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can
# be used to specify the location of Qt's qhelpgenerator.
# If non-empty doxygen will try to run qhelpgenerator on the generated
# .qhp file.

QHG_LOCATION           =

# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files
#  will be generated, which together with the HTML files, form an Eclipse help
# plugin. To install this plugin and make it available under the help contents
# menu in Eclipse, the contents of the directory containing the HTML and XML
# files needs to be copied into the plugins directory of eclipse. The name of
# the directory within the plugins directory should be the same as
# the ECLIPSE_DOC_ID value. After copying Eclipse needs to be restarted before
# the help appears.

GENERATE_ECLIPSEHELP   = YES

# A unique identifier for the eclipse help plugin. When installing the plugin
# the directory name containing the HTML and XML files should also have
# this name.

ECLIPSE_DOC_ID         = org.doxygen.Project

# The DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs)
# at top of each HTML page. The value NO (the default) enables the index and
# the value YES disables it. Since the tabs have the same information as the
# navigation tree you can set this option to NO if you already set
# GENERATE_TREEVIEW to YES.

DISABLE_INDEX          = NO

# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
# structure should be generated to display hierarchical information.
# If the tag value is set to YES, a side panel will be generated
# containing a tree-like index structure (just like the one that
# is generated for HTML Help). For this to work a browser that supports
# JavaScript, DHTML, CSS and frames is required (i.e. any modern browser).
# Windows users are probably better off using the HTML help feature.
# Since the tree basically has the same information as the tab index you
# could consider to set DISABLE_INDEX to NO when enabling this option.

GENERATE_TREEVIEW      = NONE

# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values
# (range [0,1..20]) that doxygen will group on one line in the generated HTML
# documentation. Note that a value of 0 will completely suppress the enum
# values from appearing in the overview section.

ENUM_VALUES_PER_LINE   = 4

# By enabling USE_INLINE_TREES, doxygen will generate the Groups, Directories,
# and Class Hierarchy pages using a tree view instead of an ordered list.

#USE_INLINE_TREES       = NO

# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be
# used to set the initial width (in pixels) of the frame in which the tree
# is shown.

TREEVIEW_WIDTH         = 250

# When the EXT_LINKS_IN_WINDOW option is set to YES doxygen will open
# links to external symbols imported via tag files in a separate window.

EXT_LINKS_IN_WINDOW    = NO

# Use this tag to change the font size of Latex formulas included
# as images in the HTML documentation. The default is 10. Note that
# when you change the font size after a successful doxygen run you need
# to manually remove any form_*.png images from the HTML output directory
# to force them to be regenerated.

FORMULA_FONTSIZE       = 10

# Use the FORMULA_TRANPARENT tag to determine whether or not the images
# generated for formulas are transparent PNGs. Transparent PNGs are
# not supported properly for IE 6.0, but are supported on all modern browsers.
# Note that when changing this option you need to delete any form_*.png files
# in the HTML output before the changes have effect.

FORMULA_TRANSPARENT    = YES

# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax
# (see http://www.mathjax.org) which uses client side Javascript for the
# rendering instead of using prerendered bitmaps. Use this if you do not
# have LaTeX installed or if you want to formulas look prettier in the HTML
# output. When enabled you also need to install MathJax separately and
# configure the path to it using the MATHJAX_RELPATH option.

USE_MATHJAX            = NO

# When MathJax is enabled you need to specify the location relative to the
# HTML output directory using the MATHJAX_RELPATH option. The destination
# directory should contain the MathJax.js script. For instance, if the mathjax
# directory is located at the same level as the HTML output directory, then
# MATHJAX_RELPATH should be ../mathjax. The default value points to the
# mathjax.org site, so you can quickly see the result without installing
# MathJax, but it is strongly recommended to install a local copy of MathJax
# before deployment.

MATHJAX_RELPATH        = http://www.mathjax.org/mathjax

# The MATHJAX_EXTENSIONS tag can be used to specify one or MathJax extension
# names that should be enabled during MathJax rendering.

MATHJAX_EXTENSIONS     =

# When the SEARCHENGINE tag is enabled doxygen will generate a search box
# for the HTML output. The underlying search engine uses javascript
# and DHTML and should work on any modern browser. Note that when using
# HTML help (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets
# (GENERATE_DOCSET) there is already a search function so this one should
# typically be disabled. For large projects the javascript based search engine
# can be slow, then enabling SERVER_BASED_SEARCH may provide a better solution.

SEARCHENGINE           = YES

# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
# implemented using a PHP enabled web server instead of at the web client
# using Javascript. Doxygen will generate the search PHP script and index
# file to put on the web server. The advantage of the server
# based approach is that it scales better to large projects and allows
# full text search. The disadvantages are that it is more difficult to setup
# and does not have live searching capabilities.

SERVER_BASED_SEARCH    = NO

#---------------------------------------------------------------------------
# configuration options related to the LaTeX output
#---------------------------------------------------------------------------

# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will
# generate Latex output.

GENERATE_LATEX         = NO

# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be
# put in front of it. If left blank `latex' will be used as the default path.

LATEX_OUTPUT           = latex

# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
# invoked. If left blank `latex' will be used as the default command name.
# Note that when enabling USE_PDFLATEX this option is only used for
# generating bitmaps for formulas in the HTML output, but not in the
# Makefile that is written to the output directory.

LATEX_CMD_NAME         = latex

# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to
# generate index for LaTeX. If left blank `makeindex' will be used as the
# default command name.

MAKEINDEX_CMD_NAME     = makeindex

# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact
# LaTeX documents. This may be useful for small projects and may help to
# save some trees in general.

COMPACT_LATEX          = NO

# The PAPER_TYPE tag can be used to set the paper type that is used
# by the printer. Possible values are: a4, letter, legal and
# executive. If left blank a4wide will be used.

PAPER_TYPE             = a4

# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX
# packages that should be included in the LaTeX output.

EXTRA_PACKAGES         =

# The LATEX_HEADER tag can be used to specify a personal LaTeX header for
# the generated latex document. The header should contain everything until
# the first chapter. If it is left blank doxygen will generate a
# standard header. Notice: only use this tag if you know what you are doing!

LATEX_HEADER           =

# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for
# the generated latex document. The footer should contain everything after
# the last chapter. If it is left blank doxygen will generate a
# standard footer. Notice: only use this tag if you know what you are doing!

LATEX_FOOTER           =

# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated
# is prepared for conversion to pdf (using ps2pdf). The pdf file will
# contain links (just like the HTML output) instead of page references
# This makes the output suitable for online browsing using a pdf viewer.

PDF_HYPERLINKS         = YES

# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of
# plain latex in the generated Makefile. Set this option to YES to get a
# higher quality PDF documentation.

USE_PDFLATEX           = YES

# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode.
# command to the generated LaTeX files. This will instruct LaTeX to keep
# running if errors occur, instead of asking the user for help.
# This option is also used when generating formulas in HTML.

LATEX_BATCHMODE        = NO

# If LATEX_HIDE_INDICES is set to YES then doxygen will not
# include the index chapters (such as File Index, Compound Index, etc.)
# in the output.

LATEX_HIDE_INDICES     = NO

# If LATEX_SOURCE_CODE is set to YES then doxygen will include
# source code with syntax highlighting in the LaTeX output.
# Note that which sources are shown also depends on other settings
# such as SOURCE_BROWSER.

LATEX_SOURCE_CODE      = NO

# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
# bibliography, e.g. plainnat, or ieeetr. The default style is "plain". See
# http://en.wikipedia.org/wiki/BibTeX for more info.

LATEX_BIB_STYLE        = plain

#---------------------------------------------------------------------------
# configuration options related to the RTF output
#---------------------------------------------------------------------------

# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output
# The RTF output is optimized for Word 97 and may not look very pretty with
# other RTF readers or editors.

GENERATE_RTF           = NO

# The RTF_OUTPUT tag is used to specify where the RTF docs will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be
# put in front of it. If left blank `rtf' will be used as the default path.

RTF_OUTPUT             = rtf

# If the COMPACT_RTF tag is set to YES Doxygen generates more compact
# RTF documents. This may be useful for small projects and may help to
# save some trees in general.

COMPACT_RTF            = NO

# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated
# will contain hyperlink fields. The RTF file will
# contain links (just like the HTML output) instead of page references.
# This makes the output suitable for online browsing using WORD or other
# programs which support those fields.
# Note: wordpad (write) and others do not support links.

RTF_HYPERLINKS         = NO

# Load style sheet definitions from file. Syntax is similar to doxygen's
# config file, i.e. a series of assignments. You only have to provide
# replacements, missing definitions are set to their default value.

RTF_STYLESHEET_FILE    =

# Set optional variables used in the generation of an rtf document.
# Syntax is similar to doxygen's config file.

RTF_EXTENSIONS_FILE    =

#---------------------------------------------------------------------------
# configuration options related to the man page output
#---------------------------------------------------------------------------

# If the GENERATE_MAN tag is set to YES (the default) Doxygen will
# generate man pages

GENERATE_MAN           = NO

# The MAN_OUTPUT tag is used to specify where the man pages will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be
# put in front of it. If left blank `man' will be used as the default path.

MAN_OUTPUT             = man

# The MAN_EXTENSION tag determines the extension that is added to
# the generated man pages (default is the subroutine's section .3)

MAN_EXTENSION          = .3

# If the MAN_LINKS tag is set to YES and Doxygen generates man output,
# then it will generate one additional man file for each entity
# documented in the real man page(s). These additional files
# only source the real man page, but without them the man command
# would be unable to find the correct page. The default is NO.

MAN_LINKS              = NO

#---------------------------------------------------------------------------
# configuration options related to the XML output
#---------------------------------------------------------------------------

# If the GENERATE_XML tag is set to YES Doxygen will
# generate an XML file that captures the structure of
# the code including all documentation.

GENERATE_XML           = NO

# The XML_OUTPUT tag is used to specify where the XML pages will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be
# put in front of it. If left blank `xml' will be used as the default path.

XML_OUTPUT             = xml

# The XML_SCHEMA tag can be used to specify an XML schema,
# which can be used by a validating XML parser to check the
# syntax of the XML files.

#XML_SCHEMA             =

# The XML_DTD tag can be used to specify an XML DTD,
# which can be used by a validating XML parser to check the
# syntax of the XML files.

#XML_DTD                =

# If the XML_PROGRAMLISTING tag is set to YES Doxygen will
# dump the program listings (including syntax highlighting
# and cross-referencing information) to the XML output. Note that
# enabling this will significantly increase the size of the XML output.

XML_PROGRAMLISTING     = YES

#---------------------------------------------------------------------------
# configuration options for the AutoGen Definitions output
#---------------------------------------------------------------------------

# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will
# generate an AutoGen Definitions (see autogen.sf.net) file
# that captures the structure of the code including all
# documentation. Note that this feature is still experimental
# and incomplete at the moment.

GENERATE_AUTOGEN_DEF   = NO

#---------------------------------------------------------------------------
# configuration options related to the Perl module output
#---------------------------------------------------------------------------

# If the GENERATE_PERLMOD tag is set to YES Doxygen will
# generate a Perl module file that captures the structure of
# the code including all documentation. Note that this
# feature is still experimental and incomplete at the
# moment.

GENERATE_PERLMOD       = NO

# If the PERLMOD_LATEX tag is set to YES Doxygen will generate
# the necessary Makefile rules, Perl scripts and LaTeX code to be able
# to generate PDF and DVI output from the Perl module output.

PERLMOD_LATEX          = NO

# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be
# nicely formatted so it can be parsed by a human reader.
# This is useful
# if you want to understand what is going on.
# On the other hand, if this
# tag is set to NO the size of the Perl module output will be much smaller
# and Perl will parse it just the same.

PERLMOD_PRETTY         = YES

# The names of the make variables in the generated doxyrules.make file
# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX.
# This is useful so different doxyrules.make files included by the same
# Makefile don't overwrite each other's variables.

PERLMOD_MAKEVAR_PREFIX =

#---------------------------------------------------------------------------
# Configuration options related to the preprocessor
#---------------------------------------------------------------------------

# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will
# evaluate all C-preprocessor directives found in the sources and include
# files.

ENABLE_PREPROCESSING   = YES

# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro
# names in the source code. If set to NO (the default) only conditional
# compilation will be performed. Macro expansion can be done in a controlled
# way by setting EXPAND_ONLY_PREDEF to YES.

MACRO_EXPANSION        = NO

# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES
# then the macro expansion is limited to the macros specified with the
# PREDEFINED and EXPAND_AS_DEFINED tags.

EXPAND_ONLY_PREDEF     = NO

# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files
# pointed to by INCLUDE_PATH will be searched when a #include is found.

SEARCH_INCLUDES        = YES

# The INCLUDE_PATH tag can be used to specify one or more directories that
# contain include files that are not input files but should be processed by
# the preprocessor.

INCLUDE_PATH           =

# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
# patterns (like *.h and *.hpp) to filter out the header-files in the
# directories. If left blank, the patterns specified with FILE_PATTERNS will
# be used.

INCLUDE_FILE_PATTERNS  =

# The PREDEFINED tag can be used to specify one or more macro names that
# are defined before the preprocessor is started (similar to the -D option of
# gcc). The argument of the tag is a list of macros of the form: name
# or name=definition (no spaces). If the definition and the = are
# omitted =1 is assumed. To prevent a macro definition from being
# undefined via #undef or recursively expanded use the := operator
# instead of the = operator.

PREDEFINED             =

# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then
# this tag can be used to specify a list of macro names that should be expanded.
# The macro definition that is found in the sources will be used.
# Use the PREDEFINED tag if you want to use a different macro definition that
# overrules the definition found in the source code.

EXPAND_AS_DEFINED      =

# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then
# doxygen's preprocessor will remove all references to function-like macros
# that are alone on a line, have an all uppercase name, and do not end with a
# semicolon, because these will confuse the parser if not removed.

SKIP_FUNCTION_MACROS   = YES

#---------------------------------------------------------------------------
# Configuration::additions related to external references
#---------------------------------------------------------------------------

# The TAGFILES option can be used to specify one or more tagfiles.
# Optionally an initial location of the external documentation
# can be added for each tagfile. The format of a tag file without
# this location is as follows:
#
# TAGFILES = file1 file2 ...
# Adding location for the tag files is done as follows:
#
# TAGFILES = file1=loc1 "file2 = loc2" ...
# where "loc1" and "loc2" can be relative or absolute paths or
# URLs. If a location is present for each tag, the installdox tool
# does not have to be run to correct the links.
# Note that each tag file must have a unique name
# (where the name does NOT include the path)
# If a tag file is not located in the directory in which doxygen
# is run, you must also specify the path to the tagfile here.

TAGFILES               =

# When a file name is specified after GENERATE_TAGFILE, doxygen will create
# a tag file that is based on the input files it reads.

GENERATE_TAGFILE       =

# If the ALLEXTERNALS tag is set to YES all external classes will be listed
# in the class index. If set to NO only the inherited external classes
# will be listed.

ALLEXTERNALS           = NO

# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed
# in the modules index. If set to NO, only the current project's groups will
# be listed.

EXTERNAL_GROUPS        = YES

# The PERL_PATH should be the absolute path and name of the perl script
# interpreter (i.e. the result of `which perl').

PERL_PATH              = /usr/bin/perl

#---------------------------------------------------------------------------
# Configuration options related to the dot tool
#---------------------------------------------------------------------------

# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will
# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base
# or super classes. Setting the tag to NO turns the diagrams off. Note that
# this option also works with HAVE_DOT disabled, but it is recommended to
# install and use dot, since it yields more powerful graphs.

CLASS_DIAGRAMS         = YES

# You can define message sequence charts within doxygen comments using the \msc
# command. Doxygen will then run the mscgen tool (see
# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the
# documentation. The MSCGEN_PATH tag allows you to specify the directory where
# the mscgen tool resides. If left empty the tool is assumed to be found in the
# default search path.

MSCGEN_PATH            =

# If set to YES, the inheritance and collaboration graphs will hide
# inheritance and usage relations if the target is undocumented
# or is not a class.

HIDE_UNDOC_RELATIONS   = YES

# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
# available from the path. This tool is part of Graphviz, a graph visualization
# toolkit from AT&T and Lucent Bell Labs. The other options in this section
# have no effect if this option is set to NO (the default)

HAVE_DOT               = NO

# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is
# allowed to run in parallel. When set to 0 (the default) doxygen will
# base this on the number of processors available in the system. You can set it
# explicitly to a value larger than 0 to get control over the balance
# between CPU load and processing speed.

DOT_NUM_THREADS        = 0

# By default doxygen will use the Helvetica font for all dot files that
# doxygen generates. When you want a differently looking font you can specify
# the font name using DOT_FONTNAME. You need to make sure dot is able to find
# the font, which can be done by putting it in a standard location or by setting
# the DOTFONTPATH environment variable or by setting DOT_FONTPATH to the
# directory containing the font.

DOT_FONTNAME           = Helvetica

# The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs.
# The default size is 10pt.

DOT_FONTSIZE           = 10

# By default doxygen will tell dot to use the Helvetica font.
# If you specify a different font using DOT_FONTNAME you can use DOT_FONTPATH to
# set the path where dot can find it.

DOT_FONTPATH           =

# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen
# will generate a graph for each documented class showing the direct and
# indirect inheritance relations. Setting this tag to YES will force the
# CLASS_DIAGRAMS tag to NO.

CLASS_GRAPH            = YES

# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen
# will generate a graph for each documented class showing the direct and
# indirect implementation dependencies (inheritance, containment, and
# class references variables) of the class with other documented classes.

COLLABORATION_GRAPH    = YES

# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen
# will generate a graph for groups, showing the direct groups dependencies

GROUP_GRAPHS           = YES

# If the UML_LOOK tag is set to YES doxygen will generate inheritance and
# collaboration diagrams in a style similar to the OMG's Unified Modeling
# Language.

UML_LOOK               = NO

# If set to YES, the inheritance and collaboration graphs will show the
# relations between templates and their instances.

TEMPLATE_RELATIONS     = NO

# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT
# tags are set to YES then doxygen will generate a graph for each documented
# file showing the direct and indirect include dependencies of the file with
# other documented files.

INCLUDE_GRAPH          = YES

# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and
# HAVE_DOT tags are set to YES then doxygen will generate a graph for each
# documented header file showing the documented files that directly or
# indirectly include this file.

INCLUDED_BY_GRAPH      = YES

# If the CALL_GRAPH and HAVE_DOT options are set to YES then
# doxygen will generate a call dependency graph for every global function
# or class method. Note that enabling this option will significantly increase
# the time of a run. So in most cases it will be better to enable call graphs
# for selected functions only using the \callgraph command.

CALL_GRAPH             = YES

# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then
# doxygen will generate a caller dependency graph for every global function
# or class method. Note that enabling this option will significantly increase
# the time of a run. So in most cases it will be better to enable caller
# graphs for selected functions only using the \callergraph command.

CALLER_GRAPH           = NO

# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen
# will generate a graphical hierarchy of all classes instead of a textual one.

GRAPHICAL_HIERARCHY    = YES

# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES
# then doxygen will show the dependencies a directory has on other directories
# in a graphical way. The dependency relations are determined by the #include
# relations between the files in the directories.

DIRECTORY_GRAPH        = YES

# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
# generated by dot. Possible values are svg, png, jpg, or gif.
# If left blank png will be used. If you choose svg you need to set
# HTML_FILE_EXTENSION to xhtml in order to make the SVG files
# visible in IE 9+ (other browsers do not have this requirement).

DOT_IMAGE_FORMAT       = png

# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
# enable generation of interactive SVG images that allow zooming and panning.
# Note that this requires a modern browser other than Internet Explorer.
# Tested and working are Firefox, Chrome, Safari, and Opera. For IE 9+ you
# need to set HTML_FILE_EXTENSION to xhtml in order to make the SVG files
# visible. Older versions of IE do not have SVG support.

INTERACTIVE_SVG        = NO

# The tag DOT_PATH can be used to specify the path where the dot tool can be
# found. If left blank, it is assumed the dot tool can be found in the path.

DOT_PATH               =

# The DOTFILE_DIRS tag can be used to specify one or more directories that
# contain dot files that are included in the documentation (see the
# \dotfile command).

DOTFILE_DIRS           =

# The MSCFILE_DIRS tag can be used to specify one or more directories that
# contain msc files that are included in the documentation (see the
# \mscfile command).

MSCFILE_DIRS           =

# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of
# nodes that will be shown in the graph. If the number of nodes in a graph
# becomes larger than this value, doxygen will truncate the graph, which is
# visualized by representing a node as a red box. Note that doxygen if the
# number of direct children of the root node in a graph is already larger than
# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note
# that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.

DOT_GRAPH_MAX_NODES    = 50

# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the
# graphs generated by dot. A depth value of 3 means that only nodes reachable
# from the root by following a path via at most 3 edges will be shown. Nodes
# that lay further from the root node will be omitted. Note that setting this
# option to 1 or 2 may greatly reduce the computation time needed for large
# code bases. Also note that the size of a graph can be further restricted by
# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.

MAX_DOT_GRAPH_DEPTH    = 0

# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
# background. This is disabled by default, because dot on Windows does not
# seem to support this out of the box. Warning: Depending on the platform used,
# enabling this option may lead to badly anti-aliased labels on the edges of
# a graph (i.e. they become hard to read).

DOT_TRANSPARENT        = NO

# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
# files in one run (i.e. multiple -o and -T options on the command line). This
# makes dot run faster, but since only newer versions of dot (>1.8.10)
# support this, this feature is disabled by default.

DOT_MULTI_TARGETS      = YES

# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will
# generate a legend page explaining the meaning of the various boxes and
# arrows in the dot generated graphs.

GENERATE_LEGEND        = YES

# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will
# remove the intermediate dot files that are used to generate
# the various graphs.

DOT_CLEANUP            = YES

```

`doc/Doxyfile.in`:

```in
# Doxyfile 1.7.6.1

# This file describes the settings to be used by the documentation system
# doxygen (www.doxygen.org) for a project.
#
# All text after a hash (#) is considered a comment and will be ignored.
# The format is:
#       TAG = value [value, ...]
# For lists items can also be appended using:
#       TAG += value [value, ...]
# Values that contain spaces should be placed between quotes (" ").

#---------------------------------------------------------------------------
# Project related configuration options
#---------------------------------------------------------------------------

# This tag specifies the encoding used for all characters in the config file
# that follow. The default is UTF-8 which is also the encoding used for all
# text before the first occurrence of this tag. Doxygen uses libiconv (or the
# iconv built into libc) for the transcoding. See
# http://www.gnu.org/software/libiconv for the list of possible encodings.

DOXYFILE_ENCODING      = UTF-8

# The PROJECT_NAME tag is a single word (or sequence of words) that should
# identify the project. Note that if you do not use Doxywizard you need
# to put quotes around the project name if it contains spaces.

PROJECT_NAME           = @PACKAGE_NAME@

# The PROJECT_NUMBER tag can be used to enter a project or revision number.
# This could be handy for archiving the generated documentation or
# if some version control system is used.

PROJECT_NUMBER         = @PACKAGE_VERSION@

# Using the PROJECT_BRIEF tag one can provide an optional one line description
# for a project that appears at the top of each page and should give viewer
# a quick idea about the purpose of the project. Keep the description short.

PROJECT_BRIEF          = "MQTT C++ Client for POSIX and Windows"

# With the PROJECT_LOGO tag one can specify an logo or icon that is
# included in the documentation. The maximum height of the logo should not
# exceed 55 pixels and the maximum width should not exceed 200 pixels.
# Doxygen will copy the logo to the output directory.

PROJECT_LOGO           = "@top_srcdir@/doc/pahologo.png"

# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
# base path where the generated documentation will be put.
# If a relative path is entered, it will be relative to the location
# where doxygen was started. If left blank the current directory will be used.

OUTPUT_DIRECTORY       = @top_builddir@/doc

# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create
# 4096 sub-directories (in 2 levels) under the output directory of each output
# format and will distribute the generated files over these directories.
# Enabling this option can be useful when feeding doxygen a huge amount of
# source files, where putting all generated files in the same directory would
# otherwise cause performance problems for the file system.

CREATE_SUBDIRS         = NO

# The OUTPUT_LANGUAGE tag is used to specify the language in which all
# documentation generated by doxygen is written. Doxygen will use this
# information to generate all constant output in the proper language.
# The default language is English, other supported languages are:
# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional,
# Croatian, Czech, Danish, Dutch, Esperanto, Farsi, Finnish, French, German,
# Greek, Hungarian, Italian, Japanese, Japanese-en (Japanese with English
# messages), Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian,
# Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrillic, Slovak,
# Slovene, Spanish, Swedish, Ukrainian, and Vietnamese.

OUTPUT_LANGUAGE        = English

# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will
# include brief member descriptions after the members that are listed in
# the file and class documentation (similar to JavaDoc).
# Set to NO to disable this.

BRIEF_MEMBER_DESC      = YES

# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend
# the brief description of a member or function before the detailed description.
# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
# brief descriptions will be completely suppressed.

REPEAT_BRIEF           = YES

# This tag implements a quasi-intelligent brief description abbreviator
# that is used to form the text in various listings. Each string
# in this list, if found as the leading text of the brief description, will be
# stripped from the text and the result after processing the whole list, is
# used as the annotated text. Otherwise, the brief description is used as-is.
# If left blank, the following values are used ("$name" is automatically
# replaced with the name of the entity): "The $name class" "The $name widget"
# "The $name file" "is" "provides" "specifies" "contains"
# "represents" "a" "an" "the"

ABBREVIATE_BRIEF       =

# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
# Doxygen will generate a detailed section even if there is only a brief
# description.

ALWAYS_DETAILED_SEC    = NO

# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
# inherited members of a class in the documentation of that class as if those
# members were ordinary class members. Constructors, destructors and assignment
# operators of the base classes will not be shown.

INLINE_INHERITED_MEMB  = NO

# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full
# path before files name in the file list and in the header files. If set
# to NO the shortest path that makes the file name unique will be used.

FULL_PATH_NAMES        = NO

# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag
# can be used to strip a user-defined part of the path. Stripping is
# only done if one of the specified strings matches the left-hand part of
# the path. The tag can be used to show relative paths in the file list.
# If left blank the directory from which doxygen is run is used as the
# path to strip.

STRIP_FROM_PATH        =

# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of
# the path mentioned in the documentation of a class, which tells
# the reader which header file to include in order to use a class.
# If left blank only the name of the header file containing the class
# definition is used. Otherwise one should specify the include paths that
# are normally passed to the compiler using the -I flag.

STRIP_FROM_INC_PATH    =

# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter
# (but less readable) file names. This can be useful if your file system
# doesn't support long names like on DOS, Mac, or CD-ROM.

SHORT_NAMES            = NO

# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen
# will interpret the first line (until the first dot) of a JavaDoc-style
# comment as the brief description. If set to NO, the JavaDoc
# comments will behave just like regular Qt-style comments
# (thus requiring an explicit @brief command for a brief description.)

JAVADOC_AUTOBRIEF      = NO

# If the QT_AUTOBRIEF tag is set to YES then Doxygen will
# interpret the first line (until the first dot) of a Qt-style
# comment as the brief description. If set to NO, the comments
# will behave just like regular Qt-style comments (thus requiring
# an explicit \brief command for a brief description.)

QT_AUTOBRIEF           = NO

# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen
# treat a multi-line C++ special comment block (i.e. a block of //! or ///
# comments) as a brief description. This used to be the default behaviour.
# The new default is to treat a multi-line C++ comment block as a detailed
# description. Set this tag to YES if you prefer the old behaviour instead.

MULTILINE_CPP_IS_BRIEF = NO

# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented
# member inherits the documentation from any documented member that it
# re-implements.

INHERIT_DOCS           = YES

# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce
# a new page for each member. If set to NO, the documentation of a member will
# be part of the file/class/namespace that contains it.

SEPARATE_MEMBER_PAGES  = NO

# The TAB_SIZE tag can be used to set the number of spaces in a tab.
# Doxygen uses this value to replace tabs by spaces in code fragments.

TAB_SIZE               = 4

# This tag can be used to specify a number of aliases that acts
# as commands in the documentation. An alias has the form "name=value".
# For example adding "sideeffect=\par Side Effects:\n" will allow you to
# put the command \sideeffect (or @sideeffect) in the documentation, which
# will result in a user-defined paragraph with heading "Side Effects:".
# You can put \n's in the value part of an alias to insert newlines.

ALIASES                =

# This tag can be used to specify a number of word-keyword mappings (TCL only).
# A mapping has the form "name=value". For example adding
# "class=itcl::class" will allow you to use the command class in the
# itcl::class meaning.

TCL_SUBST              =

# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C
# sources only. Doxygen will then generate output that is more tailored for C.
# For instance, some of the names that are used will be different. The list
# of all members will be omitted, etc.

OPTIMIZE_OUTPUT_FOR_C  = YES

# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java
# sources only. Doxygen will then generate output that is more tailored for
# Java. For instance, namespaces will be presented as packages, qualified
# scopes will look different, etc.

OPTIMIZE_OUTPUT_JAVA   = NO

# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
# sources only. Doxygen will then generate output that is more tailored for
# Fortran.

OPTIMIZE_FOR_FORTRAN   = NO

# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
# sources. Doxygen will then generate output that is tailored for
# VHDL.

OPTIMIZE_OUTPUT_VHDL   = NO

# Doxygen selects the parser to use depending on the extension of the files it
# parses. With this tag you can assign which parser to use for a given extension.
# Doxygen has a built-in mapping, but you can override or extend it using this
# tag. The format is ext=language, where ext is a file extension, and language
# is one of the parsers supported by doxygen: IDL, Java, Javascript, CSharp, C,
# C++, D, PHP, Objective-C, Python, Fortran, VHDL, C, C++. For instance to make
# doxygen treat .inc files as Fortran files (default is PHP), and .f files as C
# (default is Fortran), use: inc=Fortran f=C. Note that for custom extensions
# you also need to set FILE_PATTERNS otherwise the files are not read by doxygen.

EXTENSION_MAPPING      =

# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
# to include (a tag file for) the STL sources as input, then you should
# set this tag to YES in order to let doxygen match functions declarations and
# definitions whose arguments contain STL classes (e.g. func(std::string); v.s.
# func(std::string) {}). This also makes the inheritance and collaboration
# diagrams that involve STL classes more complete and accurate.

BUILTIN_STL_SUPPORT    = NO

# If you use Microsoft's C++/CLI language, you should set this option to YES to
# enable parsing support.

CPP_CLI_SUPPORT        = NO

# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only.
# Doxygen will parse them like normal C++ but will assume all classes use public
# instead of private inheritance when no explicit protection keyword is present.

SIP_SUPPORT            = NO

# For Microsoft's IDL there are propget and propput attributes to indicate getter
# and setter methods for a property. Setting this option to YES (the default)
# will make doxygen replace the get and set methods by a property in the
# documentation. This will only work if the methods are indeed getting or
# setting a simple type. If this is not the case, or you want to show the
# methods anyway, you should set this option to NO.

IDL_PROPERTY_SUPPORT   = YES

# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
# tag is set to YES, then doxygen will reuse the documentation of the first
# member in the group (if any) for the other members of the group. By default
# all members of a group must be documented explicitly.

DISTRIBUTE_GROUP_DOC   = NO

# Set the SUBGROUPING tag to YES (the default) to allow class member groups of
# the same type (for instance a group of public functions) to be put as a
# subgroup of that type (e.g. under the Public Functions section). Set it to
# NO to prevent subgrouping. Alternatively, this can be done per class using
# the \nosubgrouping command.

SUBGROUPING            = YES

# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and
# unions are shown inside the group in which they are included (e.g. using
# @ingroup) instead of on a separate page (for HTML and Man pages) or
# section (for LaTeX and RTF).

INLINE_GROUPED_CLASSES = NO

# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and
# unions with only public data fields will be shown inline in the documentation
# of the scope in which they are defined (i.e. file, namespace, or group
# documentation), provided this scope is documented. If set to NO (the default),
# structs, classes, and unions are shown on a separate page (for HTML and Man
# pages) or section (for LaTeX and RTF).

INLINE_SIMPLE_STRUCTS  = NO

# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum
# is documented as struct, union, or enum with the name of the typedef. So
# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
# with name TypeT. When disabled the typedef will appear as a member of a file,
# namespace, or class. And the struct will be named TypeS. This can typically
# be useful for C code in case the coding convention dictates that all compound
# types are typedef'ed and only the typedef is referenced, never the tag name.

TYPEDEF_HIDES_STRUCT   = NO

# The SYMBOL_CACHE_SIZE determines the size of the internal cache use to
# determine which symbols to keep in memory and which to flush to disk.
# When the cache is full, less often used symbols will be written to disk.
# For small to medium size projects (<1000 input files) the default value is
# probably good enough. For larger projects a too small cache size can cause
# doxygen to be busy swapping symbols to and from disk most of the time
# causing a significant performance penalty.
# If the system has enough physical memory increasing the cache will improve the
# performance by keeping more symbols in memory. Note that the value works on
# a logarithmic scale so increasing the size by one will roughly double the
# memory usage. The cache size is given by this formula:
# 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0,
# corresponding to a cache size of 2^16 = 65536 symbols.

#SYMBOL_CACHE_SIZE      = 0

# Similar to the SYMBOL_CACHE_SIZE the size of the symbol lookup cache can be
# set using LOOKUP_CACHE_SIZE. This cache is used to resolve symbols given
# their name and scope. Since this can be an expensive process and often the
# same symbol appear multiple times in the code, doxygen keeps a cache of
# pre-resolved symbols. If the cache is too small doxygen will become slower.
# If the cache is too large, memory is wasted. The cache size is given by this
# formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range is 0..9, the default is 0,
# corresponding to a cache size of 2^16 = 65536 symbols.

LOOKUP_CACHE_SIZE      = 0

#---------------------------------------------------------------------------
# Build related configuration options
#---------------------------------------------------------------------------

# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
# documentation are documented, even if no documentation was available.
# Private class members and static file members will be hidden unless
# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES

EXTRACT_ALL            = YES

# If the EXTRACT_PRIVATE tag is set to YES all private members of a class
# will be included in the documentation.

EXTRACT_PRIVATE        = NO

# If the EXTRACT_STATIC tag is set to YES all static members of a file
# will be included in the documentation.

EXTRACT_STATIC         = NO

# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs)
# defined locally in source files will be included in the documentation.
# If set to NO only classes defined in header files are included.

EXTRACT_LOCAL_CLASSES  = YES

# This flag is only useful for Objective-C code. When set to YES local
# methods, which are defined in the implementation section but not in
# the interface are included in the documentation.
# If set to NO (the default) only methods in the interface are included.

EXTRACT_LOCAL_METHODS  = NO

# If this flag is set to YES, the members of anonymous namespaces will be
# extracted and appear in the documentation as a namespace called
# 'anonymous_namespace{file}', where file will be replaced with the base
# name of the file that contains the anonymous namespace. By default
# anonymous namespaces are hidden.

EXTRACT_ANON_NSPACES   = NO

# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all
# undocumented members of documented classes, files or namespaces.
# If set to NO (the default) these members will be included in the
# various overviews, but no documentation section is generated.
# This option has no effect if EXTRACT_ALL is enabled.

HIDE_UNDOC_MEMBERS     = NO

# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all
# undocumented classes that are normally visible in the class hierarchy.
# If set to NO (the default) these classes will be included in the various
# overviews. This option has no effect if EXTRACT_ALL is enabled.

HIDE_UNDOC_CLASSES     = NO

# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all
# friend (class|struct|union) declarations.
# If set to NO (the default) these declarations will be included in the
# documentation.

HIDE_FRIEND_COMPOUNDS  = NO

# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any
# documentation blocks found inside the body of a function.
# If set to NO (the default) these blocks will be appended to the
# function's detailed documentation block.

HIDE_IN_BODY_DOCS      = NO

# The INTERNAL_DOCS tag determines if documentation
# that is typed after a \internal command is included. If the tag is set
# to NO (the default) then the documentation will be excluded.
# Set it to YES to include the internal documentation.

INTERNAL_DOCS          = NO

# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate
# file names in lower-case letters. If set to YES upper-case letters are also
# allowed. This is useful if you have classes or files whose names only differ
# in case and if your file system supports case sensitive file names. Windows
# and Mac users are advised to set this option to NO.

CASE_SENSE_NAMES       = YES

# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen
# will show members with their full class and namespace scopes in the
# documentation. If set to YES the scope will be hidden.

HIDE_SCOPE_NAMES       = NO

# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen
# will put a list of the files that are included by a file in the documentation
# of that file.

SHOW_INCLUDE_FILES     = YES

# If the FORCE_LOCAL_INCLUDES tag is set to YES then Doxygen
# will list include files with double quotes in the documentation
# rather than with sharp brackets.

FORCE_LOCAL_INCLUDES   = NO

# If the INLINE_INFO tag is set to YES (the default) then a tag [inline]
# is inserted in the documentation for inline members.

INLINE_INFO            = YES

# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen
# will sort the (detailed) documentation of file and class members
# alphabetically by member name. If set to NO the members will appear in
# declaration order.

SORT_MEMBER_DOCS       = NO

# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the
# brief documentation of file, namespace and class members alphabetically
# by member name. If set to NO (the default) the members will appear in
# declaration order.

SORT_BRIEF_DOCS        = NO

# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen
# will sort the (brief and detailed) documentation of class members so that
# constructors and destructors are listed first. If set to NO (the default)
# the constructors will appear in the respective orders defined by
# SORT_MEMBER_DOCS and SORT_BRIEF_DOCS.
# This tag will be ignored for brief docs if SORT_BRIEF_DOCS is set to NO
# and ignored for detailed docs if SORT_MEMBER_DOCS is set to NO.

SORT_MEMBERS_CTORS_1ST = NO

# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the
# hierarchy of group names into alphabetical order. If set to NO (the default)
# the group names will appear in their defined order.

SORT_GROUP_NAMES       = NO

# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be
# sorted by fully-qualified names, including namespaces. If set to
# NO (the default), the class list will be sorted only by class name,
# not including the namespace part.
# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
# Note: This option applies only to the class list, not to the
# alphabetical list.

SORT_BY_SCOPE_NAME     = NO

# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to
# do proper type resolution of all parameters of a function it will reject a
# match between the prototype and the implementation of a member function even
# if there is only one candidate or it is obvious which candidate to choose
# by doing a simple string match. By disabling STRICT_PROTO_MATCHING doxygen
# will still accept a match between prototype and implementation in such cases.

STRICT_PROTO_MATCHING  = NO

# The GENERATE_TODOLIST tag can be used to enable (YES) or
# disable (NO) the todo list. This list is created by putting \todo
# commands in the documentation.

GENERATE_TODOLIST      = YES

# The GENERATE_TESTLIST tag can be used to enable (YES) or
# disable (NO) the test list. This list is created by putting \test
# commands in the documentation.

GENERATE_TESTLIST      = YES

# The GENERATE_BUGLIST tag can be used to enable (YES) or
# disable (NO) the bug list. This list is created by putting \bug
# commands in the documentation.

GENERATE_BUGLIST       = YES

# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or
# disable (NO) the deprecated list. This list is created by putting
# \deprecated commands in the documentation.

GENERATE_DEPRECATEDLIST= YES

# The ENABLED_SECTIONS tag can be used to enable conditional
# documentation sections, marked by \if sectionname ... \endif.

ENABLED_SECTIONS       =

# The MAX_INITIALIZER_LINES tag determines the maximum number of lines
# the initial value of a variable or macro consists of for it to appear in
# the documentation. If the initializer consists of more lines than specified
# here it will be hidden. Use a value of 0 to hide initializers completely.
# The appearance of the initializer of individual variables and macros in the
# documentation can be controlled using \showinitializer or \hideinitializer
# command in the documentation regardless of this setting.

MAX_INITIALIZER_LINES  = 30

# Set the SHOW_USED_FILES tag to NO to disable the list of files generated
# at the bottom of the documentation of classes and structs. If set to YES the
# list will mention the files that were used to generate the documentation.

SHOW_USED_FILES        = YES

# If the sources in your project are distributed over multiple directories
# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy
# in the documentation. The default is NO.

#SHOW_DIRECTORIES       = NO

# Set the SHOW_FILES tag to NO to disable the generation of the Files page.
# This will remove the Files entry from the Quick Index and from the
# Folder Tree View (if specified). The default is YES.

SHOW_FILES             = YES

# Set the SHOW_NAMESPACES tag to NO to disable the generation of the
# Namespaces page.
# This will remove the Namespaces entry from the Quick Index
# and from the Folder Tree View (if specified). The default is YES.

SHOW_NAMESPACES        = YES

# The FILE_VERSION_FILTER tag can be used to specify a program or script that
# doxygen should invoke to get the current version for each file (typically from
# the version control system). Doxygen will invoke the program by executing (via
# popen()) the command <command> <input-file>, where <command> is the value of
# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file
# provided by doxygen. Whatever the program writes to standard output
# is used as the file version. See the manual for examples.

FILE_VERSION_FILTER    =

# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
# by doxygen. The layout file controls the global structure of the generated
# output files in an output format independent way. The create the layout file
# that represents doxygen's defaults, run doxygen with the -l option.
# You can optionally specify a file name after the option, if omitted
# DoxygenLayout.xml will be used as the name of the layout file.

LAYOUT_FILE            =

# The CITE_BIB_FILES tag can be used to specify one or more bib files
# containing the references data. This must be a list of .bib files. The
# .bib extension is automatically appended if omitted. Using this command
# requires the bibtex tool to be installed. See also
# http://en.wikipedia.org/wiki/BibTeX for more info. For LaTeX the style
# of the bibliography can be controlled using LATEX_BIB_STYLE. To use this
# feature you need bibtex and perl available in the search path.

CITE_BIB_FILES         =

#---------------------------------------------------------------------------
# configuration options related to warning and progress messages
#---------------------------------------------------------------------------

# The QUIET tag can be used to turn on/off the messages that are generated
# by doxygen. Possible values are YES and NO. If left blank NO is used.

QUIET                  = NO

# The WARNINGS tag can be used to turn on/off the warning messages that are
# generated by doxygen. Possible values are YES and NO. If left blank
# NO is used.

WARNINGS               = YES

# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings
# for undocumented members. If EXTRACT_ALL is set to YES then this flag will
# automatically be disabled.

WARN_IF_UNDOCUMENTED   = YES

# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for
# potential errors in the documentation, such as not documenting some
# parameters in a documented function, or documenting parameters that
# don't exist or using markup commands wrongly.

WARN_IF_DOC_ERROR      = YES

# The WARN_NO_PARAMDOC option can be enabled to get warnings for
# functions that are documented, but have no documentation for their parameters
# or return value. If set to NO (the default) doxygen will only warn about
# wrong or incomplete parameter documentation, but not about the absence of
# documentation.

WARN_NO_PARAMDOC       = NO

# The WARN_FORMAT tag determines the format of the warning messages that
# doxygen can produce. The string should contain the $file, $line, and $text
# tags, which will be replaced by the file and line number from which the
# warning originated and the warning text. Optionally the format may contain
# $version, which will be replaced by the version of the file (if it could
# be obtained via FILE_VERSION_FILTER)

WARN_FORMAT            = "$file:$line: $text"

# The WARN_LOGFILE tag can be used to specify a file to which warning
# and error messages should be written. If left blank the output is written
# to stderr.

WARN_LOGFILE           =

#---------------------------------------------------------------------------
# configuration options related to the input files
#---------------------------------------------------------------------------

# The INPUT tag can be used to specify the files and/or directories that contain
# documented source files. You may enter file names like "myfile.cpp" or
# directories like "/usr/src/myproject". Separate the files or directories
# with spaces.

STRIP_FROM_PATH        = @top_srcdir@/src/mqtt
INPUT                  = @top_srcdir@/src/mqtt/

# This tag can be used to specify the character encoding of the source files
# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is
# also the default input encoding. Doxygen uses libiconv (or the iconv built
# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for
# the list of possible encodings.

INPUT_ENCODING         = UTF-8

# If the value of the INPUT tag contains directories, you can use the
# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
# and *.h) to filter out the source-files in the directories. If left
# blank the following patterns are tested:
# *.c *.cc *.cxx *.cpp *.c++ *.d *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh
# *.hxx *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.dox *.py
# *.f90 *.f *.for *.vhd *.vhdl

FILE_PATTERNS          = *.h

# The RECURSIVE tag can be used to turn specify whether or not subdirectories
# should be searched for input files as well. Possible values are YES and NO.
# If left blank NO is used.

RECURSIVE              = NO

# The EXCLUDE tag can be used to specify files and/or directories that should be
# excluded from the INPUT source files. This way you can easily exclude a
# subdirectory from a directory tree whose root is specified with the INPUT tag.
# Note that relative paths are relative to the directory from which doxygen is
# run.

EXCLUDE                =

# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
# directories that are symbolic links (a Unix file system feature) are excluded
# from the input.

EXCLUDE_SYMLINKS       = NO

# If the value of the INPUT tag contains directories, you can use the
# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
# certain files from those directories. Note that the wildcards are matched
# against the file with absolute path, so to exclude all test directories
# for example use the pattern */test/*

EXCLUDE_PATTERNS       =

# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
# (namespaces, classes, functions, etc.) that should be excluded from the
# output. The symbol name can be a fully qualified name, a word, or if the
# wildcard * is used, a substring. Examples: ANamespace, AClass,
# AClass::ANamespace, ANamespace::*Test

EXCLUDE_SYMBOLS        =

# The EXAMPLE_PATH tag can be used to specify one or more files or
# directories that contain example code fragments that are included (see
# the \include command).

EXAMPLE_PATH           =

# If the value of the EXAMPLE_PATH tag contains directories, you can use the
# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
# and *.h) to filter out the source-files in the directories. If left
# blank all files are included.

EXAMPLE_PATTERNS       = *

# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
# searched for input files to be used with the \include or \dontinclude
# commands irrespective of the value of the RECURSIVE tag.
# Possible values are YES and NO. If left blank NO is used.

EXAMPLE_RECURSIVE      = NO

# The IMAGE_PATH tag can be used to specify one or more files or
# directories that contain image that are included in the documentation (see
# the \image command).

IMAGE_PATH             =

# The INPUT_FILTER tag can be used to specify a program that doxygen should
# invoke to filter for each input file. Doxygen will invoke the filter program
# by executing (via popen()) the command <filter> <input-file>, where <filter>
# is the value of the INPUT_FILTER tag, and <input-file> is the name of an
# input file. Doxygen will then use the output that the filter program writes
# to standard output.
# If FILTER_PATTERNS is specified, this tag will be
# ignored.

INPUT_FILTER           =

# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
# basis.
# Doxygen will compare the file name with each pattern and apply the
# filter if there is a match.
# The filters are a list of the form:
# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further
# info on how filters are used. If FILTER_PATTERNS is empty or if
# non of the patterns match the file name, INPUT_FILTER is applied.

FILTER_PATTERNS        =

# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
# INPUT_FILTER) will be used to filter the input files when producing source
# files to browse (i.e. when SOURCE_BROWSER is set to YES).

FILTER_SOURCE_FILES    = NO

# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
# pattern. A pattern will override the setting for FILTER_PATTERN (if any)
# and it is also possible to disable source filtering for a specific pattern
# using *.ext= (so without naming a filter). This option only has effect when
# FILTER_SOURCE_FILES is enabled.

FILTER_SOURCE_PATTERNS =

#---------------------------------------------------------------------------
# configuration options related to source browsing
#---------------------------------------------------------------------------

# If the SOURCE_BROWSER tag is set to YES then a list of source files will
# be generated. Documented entities will be cross-referenced with these sources.
# Note: To get rid of all source code in the generated output, make sure also
# VERBATIM_HEADERS is set to NO.

SOURCE_BROWSER         = NO

# Setting the INLINE_SOURCES tag to YES will include the body
# of functions and classes directly in the documentation.

INLINE_SOURCES         = NO

# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct
# doxygen to hide any special comment blocks from generated source code
# fragments. Normal C and C++ comments will always remain visible.

STRIP_CODE_COMMENTS    = YES

# If the REFERENCED_BY_RELATION tag is set to YES
# then for each documented function all documented
# functions referencing it will be listed.

REFERENCED_BY_RELATION = NO

# If the REFERENCES_RELATION tag is set to YES
# then for each documented function all documented entities
# called/used by that function will be listed.

REFERENCES_RELATION    = NO

# If the REFERENCES_LINK_SOURCE tag is set to YES (the default)
# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from
# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will
# link to the source code.
# Otherwise they will link to the documentation.

REFERENCES_LINK_SOURCE = YES

# If the USE_HTAGS tag is set to YES then the references to source code
# will point to the HTML generated by the htags(1) tool instead of doxygen
# built-in source browser. The htags tool is part of GNU's global source
# tagging system (see http://www.gnu.org/software/global/global.html). You
# will need version 4.8.6 or higher.

USE_HTAGS              = NO

# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen
# will generate a verbatim copy of the header file for each class for
# which an include is specified. Set to NO to disable this.

VERBATIM_HEADERS       = YES

#---------------------------------------------------------------------------
# configuration options related to the alphabetical class index
#---------------------------------------------------------------------------

# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index
# of all compounds will be generated. Enable this if the project
# contains a lot of classes, structs, unions or interfaces.

ALPHABETICAL_INDEX     = YES

# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then
# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns
# in which this list will be split (can be a number in the range [1..20])

COLS_IN_ALPHA_INDEX    = 5

# In case all classes in a project start with a common prefix, all
# classes will be put under the same header in the alphabetical index.
# The IGNORE_PREFIX tag can be used to specify one or more prefixes that
# should be ignored while generating the index headers.

IGNORE_PREFIX          =

#---------------------------------------------------------------------------
# configuration options related to the HTML output
#---------------------------------------------------------------------------

# If the GENERATE_HTML tag is set to YES (the default) Doxygen will
# generate HTML output.

GENERATE_HTML          = YES

# The HTML_OUTPUT tag is used to specify where the HTML docs will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be
# put in front of it. If left blank `html' will be used as the default path.

HTML_OUTPUT            = html

# The HTML_FILE_EXTENSION tag can be used to specify the file extension for
# each generated HTML page (for example: .htm,.php,.asp). If it is left blank
# doxygen will generate files with .html extension.

HTML_FILE_EXTENSION    = .html

# The HTML_HEADER tag can be used to specify a personal HTML header for
# each generated HTML page. If it is left blank doxygen will generate a
# standard header. Note that when using a custom header you are responsible
#  for the proper inclusion of any scripts and style sheets that doxygen
# needs, which is dependent on the configuration options used.
# It is advised to generate a default header using "doxygen -w html
# header.html footer.html stylesheet.css YourConfigFile" and then modify
# that header. Note that the header is subject to change so you typically
# have to redo this when upgrading to a newer version of doxygen or when
# changing the value of configuration settings such as GENERATE_TREEVIEW!

HTML_HEADER            =

# The HTML_FOOTER tag can be used to specify a personal HTML footer for
# each generated HTML page. If it is left blank doxygen will generate a
# standard footer.

HTML_FOOTER            =

# The HTML_STYLESHEET tag can be used to specify a user-defined cascading
# style sheet that is used by each HTML page. It can be used to
# fine-tune the look of the HTML output. If the tag is left blank doxygen
# will generate a default style sheet. Note that doxygen will try to copy
# the style sheet file to the HTML output directory, so don't put your own
# style sheet in the HTML output directory as well, or it will be erased!

HTML_STYLESHEET        =

# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the HTML output directory. Note
# that these files will be copied to the base HTML output directory. Use the
# $relpath$ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
# files. In the HTML_STYLESHEET file, use the file name only. Also note that
# the files will be copied as-is; there are no commands or markers available.

HTML_EXTRA_FILES       =

# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output.
# Doxygen will adjust the colors in the style sheet and background images
# according to this color. Hue is specified as an angle on a colorwheel,
# see http://en.wikipedia.org/wiki/Hue for more information.
# For instance the value 0 represents red, 60 is yellow, 120 is green,
# 180 is cyan, 240 is blue, 300 purple, and 360 is red again.
# The allowed range is 0 to 359.

HTML_COLORSTYLE_HUE    = 220

# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of
# the colors in the HTML output. For a value of 0 the output will use
# grayscales only. A value of 255 will produce the most vivid colors.

HTML_COLORSTYLE_SAT    = 100

# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to
# the luminance component of the colors in the HTML output. Values below
# 100 gradually make the output lighter, whereas values above 100 make
# the output darker. The value divided by 100 is the actual gamma applied,
# so 80 represents a gamma of 0.8, The value 220 represents a gamma of 2.2,
# and 100 does not change the gamma.

HTML_COLORSTYLE_GAMMA  = 80

# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
# page will contain the date and time when the page was generated. Setting
# this to NO can help when comparing the output of multiple runs.

HTML_TIMESTAMP         = YES

# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes,
# files or namespaces will be aligned in HTML using tables. If set to
# NO a bullet list will be used.

#HTML_ALIGN_MEMBERS     = YES

# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
# documentation will contain sections that can be hidden and shown after the
# page has loaded. For this to work a browser that supports
# JavaScript and DHTML is required (for instance Mozilla 1.0+, Firefox
# Netscape 6.0+, Internet explorer 5.0+, Konqueror, or Safari).

HTML_DYNAMIC_SECTIONS  = NO

# If the GENERATE_DOCSET tag is set to YES, additional index files
# will be generated that can be used as input for Apple's Xcode 3
# integrated development environment, introduced with OSX 10.5 (Leopard).
# To create a documentation set, doxygen will generate a Makefile in the
# HTML output directory. Running make will produce the docset in that
# directory and running "make install" will install the docset in
# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find
# it at startup.
# See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
# for more information.

GENERATE_DOCSET        = NO

# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the
# feed. A documentation feed provides an umbrella under which multiple
# documentation sets from a single provider (such as a company or product suite)
# can be grouped.

DOCSET_FEEDNAME        = "Doxygen generated docs"

# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that
# should uniquely identify the documentation set bundle. This should be a
# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen
# will append .docset to the name.

DOCSET_BUNDLE_ID       = org.doxygen.Project

# When GENERATE_PUBLISHER_ID tag specifies a string that should uniquely identify
# the documentation publisher. This should be a reverse domain-name style
# string, e.g. com.mycompany.MyDocSet.documentation.

DOCSET_PUBLISHER_ID    = org.doxygen.Publisher

# The GENERATE_PUBLISHER_NAME tag identifies the documentation publisher.

DOCSET_PUBLISHER_NAME  = Publisher

# If the GENERATE_HTMLHELP tag is set to YES, additional index files
# will be generated that can be used as input for tools like the
# Microsoft HTML help workshop to generate a compiled HTML help file (.chm)
# of the generated HTML documentation.

GENERATE_HTMLHELP      = NO

# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can
# be used to specify the file name of the resulting .chm file. You
# can add a path in front of the file if the result should not be
# written to the html output directory.

CHM_FILE               =

# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can
# be used to specify the location (absolute path including file name) of
# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run
# the HTML help compiler on the generated index.hhp.

HHC_LOCATION           =

# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag
# controls if a separate .chi index file is generated (YES) or that
# it should be included in the master .chm file (NO).

GENERATE_CHI           = NO

# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING
# is used to encode HtmlHelp index (hhk), content (hhc) and project file
# content.

CHM_INDEX_ENCODING     =

# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag
# controls whether a binary table of contents is generated (YES) or a
# normal table of contents (NO) in the .chm file.

BINARY_TOC             = NO

# The TOC_EXPAND flag can be set to YES to add extra items for group members
# to the contents of the HTML help documentation and to the tree view.

TOC_EXPAND             = NO

# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated
# that can be used as input for Qt's qhelpgenerator to generate a
# Qt Compressed Help (.qch) of the generated HTML documentation.

GENERATE_QHP           = NO

# If the QHG_LOCATION tag is specified, the QCH_FILE tag can
# be used to specify the file name of the resulting .qch file.
# The path specified is relative to the HTML output folder.

QCH_FILE               =

# The QHP_NAMESPACE tag specifies the namespace to use when generating
# Qt Help Project output. For more information please see
# http://doc.trolltech.com/qthelpproject.html#namespace

QHP_NAMESPACE          = org.doxygen.Project

# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating
# Qt Help Project output. For more information please see
# http://doc.trolltech.com/qthelpproject.html#virtual-folders

QHP_VIRTUAL_FOLDER     = doc

# If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to
# add. For more information please see
# http://doc.trolltech.com/qthelpproject.html#custom-filters

QHP_CUST_FILTER_NAME   =

# The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the
# custom filter to add. For more information please see
# <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters">
# Qt Help Project / Custom Filters</a>.

QHP_CUST_FILTER_ATTRS  =

# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
# project's
# filter section matches.
# <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes">
# Qt Help Project / Filter Attributes</a>.

QHP_SECT_FILTER_ATTRS  =

# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can
# be used to specify the location of Qt's qhelpgenerator.
# If non-empty doxygen will try to run qhelpgenerator on the generated
# .qhp file.

QHG_LOCATION           =

# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files
#  will be generated, which together with the HTML files, form an Eclipse help
# plugin. To install this plugin and make it available under the help contents
# menu in Eclipse, the contents of the directory containing the HTML and XML
# files needs to be copied into the plugins directory of eclipse. The name of
# the directory within the plugins directory should be the same as
# the ECLIPSE_DOC_ID value. After copying Eclipse needs to be restarted before
# the help appears.

GENERATE_ECLIPSEHELP   = YES

# A unique identifier for the eclipse help plugin. When installing the plugin
# the directory name containing the HTML and XML files should also have
# this name.

ECLIPSE_DOC_ID         = org.doxygen.Project

# The DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs)
# at top of each HTML page. The value NO (the default) enables the index and
# the value YES disables it. Since the tabs have the same information as the
# navigation tree you can set this option to NO if you already set
# GENERATE_TREEVIEW to YES.

DISABLE_INDEX          = NO

# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
# structure should be generated to display hierarchical information.
# If the tag value is set to YES, a side panel will be generated
# containing a tree-like index structure (just like the one that
# is generated for HTML Help). For this to work a browser that supports
# JavaScript, DHTML, CSS and frames is required (i.e. any modern browser).
# Windows users are probably better off using the HTML help feature.
# Since the tree basically has the same information as the tab index you
# could consider to set DISABLE_INDEX to NO when enabling this option.

GENERATE_TREEVIEW      = NONE

# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values
# (range [0,1..20]) that doxygen will group on one line in the generated HTML
# documentation. Note that a value of 0 will completely suppress the enum
# values from appearing in the overview section.

ENUM_VALUES_PER_LINE   = 4

# By enabling USE_INLINE_TREES, doxygen will generate the Groups, Directories,
# and Class Hierarchy pages using a tree view instead of an ordered list.

#USE_INLINE_TREES       = NO

# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be
# used to set the initial width (in pixels) of the frame in which the tree
# is shown.

TREEVIEW_WIDTH         = 250

# When the EXT_LINKS_IN_WINDOW option is set to YES doxygen will open
# links to external symbols imported via tag files in a separate window.

EXT_LINKS_IN_WINDOW    = NO

# Use this tag to change the font size of Latex formulas included
# as images in the HTML documentation. The default is 10. Note that
# when you change the font size after a successful doxygen run you need
# to manually remove any form_*.png images from the HTML output directory
# to force them to be regenerated.

FORMULA_FONTSIZE       = 10

# Use the FORMULA_TRANPARENT tag to determine whether or not the images
# generated for formulas are transparent PNGs. Transparent PNGs are
# not supported properly for IE 6.0, but are supported on all modern browsers.
# Note that when changing this option you need to delete any form_*.png files
# in the HTML output before the changes have effect.

FORMULA_TRANSPARENT    = YES

# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax
# (see http://www.mathjax.org) which uses client side Javascript for the
# rendering instead of using prerendered bitmaps. Use this if you do not
# have LaTeX installed or if you want to formulas look prettier in the HTML
# output. When enabled you also need to install MathJax separately and
# configure the path to it using the MATHJAX_RELPATH option.

USE_MATHJAX            = NO

# When MathJax is enabled you need to specify the location relative to the
# HTML output directory using the MATHJAX_RELPATH option. The destination
# directory should contain the MathJax.js script. For instance, if the mathjax
# directory is located at the same level as the HTML output directory, then
# MATHJAX_RELPATH should be ../mathjax. The default value points to the
# mathjax.org site, so you can quickly see the result without installing
# MathJax, but it is strongly recommended to install a local copy of MathJax
# before deployment.

MATHJAX_RELPATH        = http://www.mathjax.org/mathjax

# The MATHJAX_EXTENSIONS tag can be used to specify one or MathJax extension
# names that should be enabled during MathJax rendering.

MATHJAX_EXTENSIONS     =

# When the SEARCHENGINE tag is enabled doxygen will generate a search box
# for the HTML output. The underlying search engine uses javascript
# and DHTML and should work on any modern browser. Note that when using
# HTML help (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets
# (GENERATE_DOCSET) there is already a search function so this one should
# typically be disabled. For large projects the javascript based search engine
# can be slow, then enabling SERVER_BASED_SEARCH may provide a better solution.

SEARCHENGINE           = YES

# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
# implemented using a PHP enabled web server instead of at the web client
# using Javascript. Doxygen will generate the search PHP script and index
# file to put on the web server. The advantage of the server
# based approach is that it scales better to large projects and allows
# full text search. The disadvantages are that it is more difficult to setup
# and does not have live searching capabilities.

SERVER_BASED_SEARCH    = NO

#---------------------------------------------------------------------------
# configuration options related to the LaTeX output
#---------------------------------------------------------------------------

# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will
# generate Latex output.

GENERATE_LATEX         = NO

# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be
# put in front of it. If left blank `latex' will be used as the default path.

LATEX_OUTPUT           = latex

# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
# invoked. If left blank `latex' will be used as the default command name.
# Note that when enabling USE_PDFLATEX this option is only used for
# generating bitmaps for formulas in the HTML output, but not in the
# Makefile that is written to the output directory.

LATEX_CMD_NAME         = latex

# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to
# generate index for LaTeX. If left blank `makeindex' will be used as the
# default command name.

MAKEINDEX_CMD_NAME     = makeindex

# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact
# LaTeX documents. This may be useful for small projects and may help to
# save some trees in general.

COMPACT_LATEX          = NO

# The PAPER_TYPE tag can be used to set the paper type that is used
# by the printer. Possible values are: a4, letter, legal and
# executive. If left blank a4wide will be used.

PAPER_TYPE             = a4

# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX
# packages that should be included in the LaTeX output.

EXTRA_PACKAGES         =

# The LATEX_HEADER tag can be used to specify a personal LaTeX header for
# the generated latex document. The header should contain everything until
# the first chapter. If it is left blank doxygen will generate a
# standard header. Notice: only use this tag if you know what you are doing!

LATEX_HEADER           =

# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for
# the generated latex document. The footer should contain everything after
# the last chapter. If it is left blank doxygen will generate a
# standard footer. Notice: only use this tag if you know what you are doing!

LATEX_FOOTER           =

# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated
# is prepared for conversion to pdf (using ps2pdf). The pdf file will
# contain links (just like the HTML output) instead of page references
# This makes the output suitable for online browsing using a pdf viewer.

PDF_HYPERLINKS         = YES

# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of
# plain latex in the generated Makefile. Set this option to YES to get a
# higher quality PDF documentation.

USE_PDFLATEX           = YES

# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode.
# command to the generated LaTeX files. This will instruct LaTeX to keep
# running if errors occur, instead of asking the user for help.
# This option is also used when generating formulas in HTML.

LATEX_BATCHMODE        = NO

# If LATEX_HIDE_INDICES is set to YES then doxygen will not
# include the index chapters (such as File Index, Compound Index, etc.)
# in the output.

LATEX_HIDE_INDICES     = NO

# If LATEX_SOURCE_CODE is set to YES then doxygen will include
# source code with syntax highlighting in the LaTeX output.
# Note that which sources are shown also depends on other settings
# such as SOURCE_BROWSER.

LATEX_SOURCE_CODE      = NO

# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
# bibliography, e.g. plainnat, or ieeetr. The default style is "plain". See
# http://en.wikipedia.org/wiki/BibTeX for more info.

LATEX_BIB_STYLE        = plain

#---------------------------------------------------------------------------
# configuration options related to the RTF output
#---------------------------------------------------------------------------

# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output
# The RTF output is optimized for Word 97 and may not look very pretty with
# other RTF readers or editors.

GENERATE_RTF           = NO

# The RTF_OUTPUT tag is used to specify where the RTF docs will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be
# put in front of it. If left blank `rtf' will be used as the default path.

RTF_OUTPUT             = rtf

# If the COMPACT_RTF tag is set to YES Doxygen generates more compact
# RTF documents. This may be useful for small projects and may help to
# save some trees in general.

COMPACT_RTF            = NO

# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated
# will contain hyperlink fields. The RTF file will
# contain links (just like the HTML output) instead of page references.
# This makes the output suitable for online browsing using WORD or other
# programs which support those fields.
# Note: wordpad (write) and others do not support links.

RTF_HYPERLINKS         = NO

# Load style sheet definitions from file. Syntax is similar to doxygen's
# config file, i.e. a series of assignments. You only have to provide
# replacements, missing definitions are set to their default value.

RTF_STYLESHEET_FILE    =

# Set optional variables used in the generation of an rtf document.
# Syntax is similar to doxygen's config file.

RTF_EXTENSIONS_FILE    =

#---------------------------------------------------------------------------
# configuration options related to the man page output
#---------------------------------------------------------------------------

# If the GENERATE_MAN tag is set to YES (the default) Doxygen will
# generate man pages

GENERATE_MAN           = NO

# The MAN_OUTPUT tag is used to specify where the man pages will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be
# put in front of it. If left blank `man' will be used as the default path.

MAN_OUTPUT             = man

# The MAN_EXTENSION tag determines the extension that is added to
# the generated man pages (default is the subroutine's section .3)

MAN_EXTENSION          = .3

# If the MAN_LINKS tag is set to YES and Doxygen generates man output,
# then it will generate one additional man file for each entity
# documented in the real man page(s). These additional files
# only source the real man page, but without them the man command
# would be unable to find the correct page. The default is NO.

MAN_LINKS              = NO

#---------------------------------------------------------------------------
# configuration options related to the XML output
#---------------------------------------------------------------------------

# If the GENERATE_XML tag is set to YES Doxygen will
# generate an XML file that captures the structure of
# the code including all documentation.

GENERATE_XML           = NO

# The XML_OUTPUT tag is used to specify where the XML pages will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be
# put in front of it. If left blank `xml' will be used as the default path.

XML_OUTPUT             = xml

# The XML_SCHEMA tag can be used to specify an XML schema,
# which can be used by a validating XML parser to check the
# syntax of the XML files.

#XML_SCHEMA             =

# The XML_DTD tag can be used to specify an XML DTD,
# which can be used by a validating XML parser to check the
# syntax of the XML files.

#XML_DTD                =

# If the XML_PROGRAMLISTING tag is set to YES Doxygen will
# dump the program listings (including syntax highlighting
# and cross-referencing information) to the XML output. Note that
# enabling this will significantly increase the size of the XML output.

XML_PROGRAMLISTING     = YES

#---------------------------------------------------------------------------
# configuration options for the AutoGen Definitions output
#---------------------------------------------------------------------------

# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will
# generate an AutoGen Definitions (see autogen.sf.net) file
# that captures the structure of the code including all
# documentation. Note that this feature is still experimental
# and incomplete at the moment.

GENERATE_AUTOGEN_DEF   = NO

#---------------------------------------------------------------------------
# configuration options related to the Perl module output
#---------------------------------------------------------------------------

# If the GENERATE_PERLMOD tag is set to YES Doxygen will
# generate a Perl module file that captures the structure of
# the code including all documentation. Note that this
# feature is still experimental and incomplete at the
# moment.

GENERATE_PERLMOD       = NO

# If the PERLMOD_LATEX tag is set to YES Doxygen will generate
# the necessary Makefile rules, Perl scripts and LaTeX code to be able
# to generate PDF and DVI output from the Perl module output.

PERLMOD_LATEX          = NO

# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be
# nicely formatted so it can be parsed by a human reader.
# This is useful
# if you want to understand what is going on.
# On the other hand, if this
# tag is set to NO the size of the Perl module output will be much smaller
# and Perl will parse it just the same.

PERLMOD_PRETTY         = YES

# The names of the make variables in the generated doxyrules.make file
# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX.
# This is useful so different doxyrules.make files included by the same
# Makefile don't overwrite each other's variables.

PERLMOD_MAKEVAR_PREFIX =

#---------------------------------------------------------------------------
# Configuration options related to the preprocessor
#---------------------------------------------------------------------------

# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will
# evaluate all C-preprocessor directives found in the sources and include
# files.

ENABLE_PREPROCESSING   = YES

# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro
# names in the source code. If set to NO (the default) only conditional
# compilation will be performed. Macro expansion can be done in a controlled
# way by setting EXPAND_ONLY_PREDEF to YES.

MACRO_EXPANSION        = NO

# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES
# then the macro expansion is limited to the macros specified with the
# PREDEFINED and EXPAND_AS_DEFINED tags.

EXPAND_ONLY_PREDEF     = NO

# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files
# pointed to by INCLUDE_PATH will be searched when a #include is found.

SEARCH_INCLUDES        = YES

# The INCLUDE_PATH tag can be used to specify one or more directories that
# contain include files that are not input files but should be processed by
# the preprocessor.

INCLUDE_PATH           =

# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
# patterns (like *.h and *.hpp) to filter out the header-files in the
# directories. If left blank, the patterns specified with FILE_PATTERNS will
# be used.

INCLUDE_FILE_PATTERNS  =

# The PREDEFINED tag can be used to specify one or more macro names that
# are defined before the preprocessor is started (similar to the -D option of
# gcc). The argument of the tag is a list of macros of the form: name
# or name=definition (no spaces). If the definition and the = are
# omitted =1 is assumed. To prevent a macro definition from being
# undefined via #undef or recursively expanded use the := operator
# instead of the = operator.

PREDEFINED             =

# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then
# this tag can be used to specify a list of macro names that should be expanded.
# The macro definition that is found in the sources will be used.
# Use the PREDEFINED tag if you want to use a different macro definition that
# overrules the definition found in the source code.

EXPAND_AS_DEFINED      =

# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then
# doxygen's preprocessor will remove all references to function-like macros
# that are alone on a line, have an all uppercase name, and do not end with a
# semicolon, because these will confuse the parser if not removed.

SKIP_FUNCTION_MACROS   = YES

#---------------------------------------------------------------------------
# Configuration::additions related to external references
#---------------------------------------------------------------------------

# The TAGFILES option can be used to specify one or more tagfiles.
# Optionally an initial location of the external documentation
# can be added for each tagfile. The format of a tag file without
# this location is as follows:
#
# TAGFILES = file1 file2 ...
# Adding location for the tag files is done as follows:
#
# TAGFILES = file1=loc1 "file2 = loc2" ...
# where "loc1" and "loc2" can be relative or absolute paths or
# URLs. If a location is present for each tag, the installdox tool
# does not have to be run to correct the links.
# Note that each tag file must have a unique name
# (where the name does NOT include the path)
# If a tag file is not located in the directory in which doxygen
# is run, you must also specify the path to the tagfile here.

TAGFILES               =

# When a file name is specified after GENERATE_TAGFILE, doxygen will create
# a tag file that is based on the input files it reads.

GENERATE_TAGFILE       =

# If the ALLEXTERNALS tag is set to YES all external classes will be listed
# in the class index. If set to NO only the inherited external classes
# will be listed.

ALLEXTERNALS           = NO

# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed
# in the modules index. If set to NO, only the current project's groups will
# be listed.

EXTERNAL_GROUPS        = YES

# The PERL_PATH should be the absolute path and name of the perl script
# interpreter (i.e. the result of `which perl').

PERL_PATH              = /usr/bin/perl

#---------------------------------------------------------------------------
# Configuration options related to the dot tool
#---------------------------------------------------------------------------

# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will
# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base
# or super classes. Setting the tag to NO turns the diagrams off. Note that
# this option also works with HAVE_DOT disabled, but it is recommended to
# install and use dot, since it yields more powerful graphs.

CLASS_DIAGRAMS         = YES

# You can define message sequence charts within doxygen comments using the \msc
# command. Doxygen will then run the mscgen tool (see
# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the
# documentation. The MSCGEN_PATH tag allows you to specify the directory where
# the mscgen tool resides. If left empty the tool is assumed to be found in the
# default search path.

MSCGEN_PATH            =

# If set to YES, the inheritance and collaboration graphs will hide
# inheritance and usage relations if the target is undocumented
# or is not a class.

HIDE_UNDOC_RELATIONS   = YES

# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
# available from the path. This tool is part of Graphviz, a graph visualization
# toolkit from AT&T and Lucent Bell Labs. The other options in this section
# have no effect if this option is set to NO (the default)

HAVE_DOT               = NO

# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is
# allowed to run in parallel. When set to 0 (the default) doxygen will
# base this on the number of processors available in the system. You can set it
# explicitly to a value larger than 0 to get control over the balance
# between CPU load and processing speed.

DOT_NUM_THREADS        = 0

# By default doxygen will use the Helvetica font for all dot files that
# doxygen generates. When you want a differently looking font you can specify
# the font name using DOT_FONTNAME. You need to make sure dot is able to find
# the font, which can be done by putting it in a standard location or by setting
# the DOTFONTPATH environment variable or by setting DOT_FONTPATH to the
# directory containing the font.

DOT_FONTNAME           = Helvetica

# The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs.
# The default size is 10pt.

DOT_FONTSIZE           = 10

# By default doxygen will tell dot to use the Helvetica font.
# If you specify a different font using DOT_FONTNAME you can use DOT_FONTPATH to
# set the path where dot can find it.

DOT_FONTPATH           =

# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen
# will generate a graph for each documented class showing the direct and
# indirect inheritance relations. Setting this tag to YES will force the
# CLASS_DIAGRAMS tag to NO.

CLASS_GRAPH            = YES

# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen
# will generate a graph for each documented class showing the direct and
# indirect implementation dependencies (inheritance, containment, and
# class references variables) of the class with other documented classes.

COLLABORATION_GRAPH    = YES

# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen
# will generate a graph for groups, showing the direct groups dependencies

GROUP_GRAPHS           = YES

# If the UML_LOOK tag is set to YES doxygen will generate inheritance and
# collaboration diagrams in a style similar to the OMG's Unified Modeling
# Language.

UML_LOOK               = NO

# If set to YES, the inheritance and collaboration graphs will show the
# relations between templates and their instances.

TEMPLATE_RELATIONS     = NO

# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT
# tags are set to YES then doxygen will generate a graph for each documented
# file showing the direct and indirect include dependencies of the file with
# other documented files.

INCLUDE_GRAPH          = YES

# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and
# HAVE_DOT tags are set to YES then doxygen will generate a graph for each
# documented header file showing the documented files that directly or
# indirectly include this file.

INCLUDED_BY_GRAPH      = YES

# If the CALL_GRAPH and HAVE_DOT options are set to YES then
# doxygen will generate a call dependency graph for every global function
# or class method. Note that enabling this option will significantly increase
# the time of a run. So in most cases it will be better to enable call graphs
# for selected functions only using the \callgraph command.

CALL_GRAPH             = YES

# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then
# doxygen will generate a caller dependency graph for every global function
# or class method. Note that enabling this option will significantly increase
# the time of a run. So in most cases it will be better to enable caller
# graphs for selected functions only using the \callergraph command.

CALLER_GRAPH           = NO

# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen
# will generate a graphical hierarchy of all classes instead of a textual one.

GRAPHICAL_HIERARCHY    = YES

# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES
# then doxygen will show the dependencies a directory has on other directories
# in a graphical way. The dependency relations are determined by the #include
# relations between the files in the directories.

DIRECTORY_GRAPH        = YES

# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
# generated by dot. Possible values are svg, png, jpg, or gif.
# If left blank png will be used. If you choose svg you need to set
# HTML_FILE_EXTENSION to xhtml in order to make the SVG files
# visible in IE 9+ (other browsers do not have this requirement).

DOT_IMAGE_FORMAT       = png

# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
# enable generation of interactive SVG images that allow zooming and panning.
# Note that this requires a modern browser other than Internet Explorer.
# Tested and working are Firefox, Chrome, Safari, and Opera. For IE 9+ you
# need to set HTML_FILE_EXTENSION to xhtml in order to make the SVG files
# visible. Older versions of IE do not have SVG support.

INTERACTIVE_SVG        = NO

# The tag DOT_PATH can be used to specify the path where the dot tool can be
# found. If left blank, it is assumed the dot tool can be found in the path.

DOT_PATH               =

# The DOTFILE_DIRS tag can be used to specify one or more directories that
# contain dot files that are included in the documentation (see the
# \dotfile command).

DOTFILE_DIRS           =

# The MSCFILE_DIRS tag can be used to specify one or more directories that
# contain msc files that are included in the documentation (see the
# \mscfile command).

MSCFILE_DIRS           =

# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of
# nodes that will be shown in the graph. If the number of nodes in a graph
# becomes larger than this value, doxygen will truncate the graph, which is
# visualized by representing a node as a red box. Note that doxygen if the
# number of direct children of the root node in a graph is already larger than
# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note
# that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.

DOT_GRAPH_MAX_NODES    = 50

# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the
# graphs generated by dot. A depth value of 3 means that only nodes reachable
# from the root by following a path via at most 3 edges will be shown. Nodes
# that lay further from the root node will be omitted. Note that setting this
# option to 1 or 2 may greatly reduce the computation time needed for large
# code bases. Also note that the size of a graph can be further restricted by
# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.

MAX_DOT_GRAPH_DEPTH    = 0

# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
# background. This is disabled by default, because dot on Windows does not
# seem to support this out of the box. Warning: Depending on the platform used,
# enabling this option may lead to badly anti-aliased labels on the edges of
# a graph (i.e. they become hard to read).

DOT_TRANSPARENT        = NO

# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
# files in one run (i.e. multiple -o and -T options on the command line). This
# makes dot run faster, but since only newer versions of dot (>1.8.10)
# support this, this feature is disabled by default.

DOT_MULTI_TARGETS      = YES

# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will
# generate a legend page explaining the meaning of the various boxes and
# arrows in the dot generated graphs.

GENERATE_LEGEND        = YES

# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will
# remove the intermediate dot files that are used to generate
# the various graphs.

DOT_CLEANUP            = YES

```

`edl-v10`:

```

Eclipse Distribution License - v 1.0

Copyright (c) 2007, Eclipse Foundation, Inc. and its licensors.

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
    Neither the name of the Eclipse Foundation, Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


```

`epl-v20`:

```
Eclipse Public License - v 2.0

    THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE
    PUBLIC LICENSE ("AGREEMENT"). ANY USE, REPRODUCTION OR DISTRIBUTION
    OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.

1. DEFINITIONS

"Contribution" means:

  a) in the case of the initial Contributor, the initial content
     Distributed under this Agreement, and

  b) in the case of each subsequent Contributor:
     i) changes to the Program, and
     ii) additions to the Program;
  where such changes and/or additions to the Program originate from
  and are Distributed by that particular Contributor. A Contribution
  "originates" from a Contributor if it was added to the Program by
  such Contributor itself or anyone acting on such Contributor's behalf.
  Contributions do not include changes or additions to the Program that
  are not Modified Works.

"Contributor" means any person or entity that Distributes the Program.

"Licensed Patents" mean patent claims licensable by a Contributor which
are necessarily infringed by the use or sale of its Contribution alone
or when combined with the Program.

"Program" means the Contributions Distributed in accordance with this
Agreement.

"Recipient" means anyone who receives the Program under this Agreement
or any Secondary License (as applicable), including Contributors.

"Derivative Works" shall mean any work, whether in Source Code or other
form, that is based on (or derived from) the Program and for which the
editorial revisions, annotations, elaborations, or other modifications
represent, as a whole, an original work of authorship.

"Modified Works" shall mean any work in Source Code or other form that
results from an addition to, deletion from, or modification of the
contents of the Program, including, for purposes of clarity any new file
in Source Code form that contains any contents of the Program. Modified
Works shall not include works that contain only declarations,
interfaces, types, classes, structures, or files of the Program solely
in each case in order to link to, bind by name, or subclass the Program
or Modified Works thereof.

"Distribute" means the acts of a) distributing or b) making available
in any manner that enables the transfer of a copy.

"Source Code" means the form of a Program preferred for making
modifications, including but not limited to software source code,
documentation source, and configuration files.

"Secondary License" means either the GNU General Public License,
Version 2.0, or any later versions of that license, including any
exceptions or additional permissions as identified by the initial
Contributor.

2. GRANT OF RIGHTS

  a) Subject to the terms of this Agreement, each Contributor hereby
  grants Recipient a non-exclusive, worldwide, royalty-free copyright
  license to reproduce, prepare Derivative Works of, publicly display,
  publicly perform, Distribute and sublicense the Contribution of such
  Contributor, if any, and such Derivative Works.

  b) Subject to the terms of this Agreement, each Contributor hereby
  grants Recipient a non-exclusive, worldwide, royalty-free patent
  license under Licensed Patents to make, use, sell, offer to sell,
  import and otherwise transfer the Contribution of such Contributor,
  if any, in Source Code or other form. This patent license shall
  apply to the combination of the Contribution and the Program if, at
  the time the Contribution is added by the Contributor, such addition
  of the Contribution causes such combination to be covered by the
  Licensed Patents. The patent license shall not apply to any other
  combinations which include the Contribution. No hardware per se is
  licensed hereunder.

  c) Recipient understands that although each Contributor grants the
  licenses to its Contributions set forth herein, no assurances are
  provided by any Contributor that the Program does not infringe the
  patent or other intellectual property rights of any other entity.
  Each Contributor disclaims any liability to Recipient for claims
  brought by any other entity based on infringement of intellectual
  property rights or otherwise. As a condition to exercising the
  rights and licenses granted hereunder, each Recipient hereby
  assumes sole responsibility to secure any other intellectual
  property rights needed, if any. For example, if a third party
  patent license is required to allow Recipient to Distribute the
  Program, it is Recipient's responsibility to acquire that license
  before distributing the Program.

  d) Each Contributor represents that to its knowledge it has
  sufficient copyright rights in its Contribution, if any, to grant
  the copyright license set forth in this Agreement.

  e) Notwithstanding the terms of any Secondary License, no
  Contributor makes additional grants to any Recipient (other than
  those set forth in this Agreement) as a result of such Recipient's
  receipt of the Program under the terms of a Secondary License
  (if permitted under the terms of Section 3).

3. REQUIREMENTS

3.1 If a Contributor Distributes the Program in any form, then:

  a) the Program must also be made available as Source Code, in
  accordance with section 3.2, and the Contributor must accompany
  the Program with a statement that the Source Code for the Program
  is available under this Agreement, and informs Recipients how to
  obtain it in a reasonable manner on or through a medium customarily
  used for software exchange; and

  b) the Contributor may Distribute the Program under a license
  different than this Agreement, provided that such license:
     i) effectively disclaims on behalf of all other Contributors all
     warranties and conditions, express and implied, including
     warranties or conditions of title and non-infringement, and
     implied warranties or conditions of merchantability and fitness
     for a particular purpose;

     ii) effectively excludes on behalf of all other Contributors all
     liability for damages, including direct, indirect, special,
     incidental and consequential damages, such as lost profits;

     iii) does not attempt to limit or alter the recipients' rights
     in the Source Code under section 3.2; and

     iv) requires any subsequent distribution of the Program by any
     party to be under a license that satisfies the requirements
     of this section 3.

3.2 When the Program is Distributed as Source Code:

  a) it must be made available under this Agreement, or if the
  Program (i) is combined with other material in a separate file or
  files made available under a Secondary License, and (ii) the initial
  Contributor attached to the Source Code the notice described in
  Exhibit A of this Agreement, then the Program may be made available
  under the terms of such Secondary Licenses, and

  b) a copy of this Agreement must be included with each copy of
  the Program.

3.3 Contributors may not remove or alter any copyright, patent,
trademark, attribution notices, disclaimers of warranty, or limitations
of liability ("notices") contained within the Program from any copy of
the Program which they Distribute, provided that Contributors may add
their own appropriate notices.

4. COMMERCIAL DISTRIBUTION

Commercial distributors of software may accept certain responsibilities
with respect to end users, business partners and the like. While this
license is intended to facilitate the commercial use of the Program,
the Contributor who includes the Program in a commercial product
offering should do so in a manner which does not create potential
liability for other Contributors. Therefore, if a Contributor includes
the Program in a commercial product offering, such Contributor
("Commercial Contributor") hereby agrees to defend and indemnify every
other Contributor ("Indemnified Contributor") against any losses,
damages and costs (collectively "Losses") arising from claims, lawsuits
and other legal actions brought by a third party against the Indemnified
Contributor to the extent caused by the acts or omissions of such
Commercial Contributor in connection with its distribution of the Program
in a commercial product offering. The obligations in this section do not
apply to any claims or Losses relating to any actual or alleged
intellectual property infringement. In order to qualify, an Indemnified
Contributor must: a) promptly notify the Commercial Contributor in
writing of such claim, and b) allow the Commercial Contributor to control,
and cooperate with the Commercial Contributor in, the defense and any
related settlement negotiations. The Indemnified Contributor may
participate in any such claim at its own expense.

For example, a Contributor might include the Program in a commercial
product offering, Product X. That Contributor is then a Commercial
Contributor. If that Commercial Contributor then makes performance
claims, or offers warranties related to Product X, those performance
claims and warranties are such Commercial Contributor's responsibility
alone. Under this section, the Commercial Contributor would have to
defend claims against the other Contributors related to those performance
claims and warranties, and if a court requires any other Contributor to
pay any damages as a result, the Commercial Contributor must pay
those damages.

5. NO WARRANTY

EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT
PERMITTED BY APPLICABLE LAW, THE PROGRAM IS PROVIDED ON AN "AS IS"
BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR
IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF
TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE. Each Recipient is solely responsible for determining the
appropriateness of using and distributing the Program and assumes all
risks associated with its exercise of rights under this Agreement,
including but not limited to the risks and costs of program errors,
compliance with applicable laws, damage to or loss of data, programs
or equipment, and unavailability or interruption of operations.

6. DISCLAIMER OF LIABILITY

EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT
PERMITTED BY APPLICABLE LAW, NEITHER RECIPIENT NOR ANY CONTRIBUTORS
SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST
PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE
EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

7. GENERAL

If any provision of this Agreement is invalid or unenforceable under
applicable law, it shall not affect the validity or enforceability of
the remainder of the terms of this Agreement, and without further
action by the parties hereto, such provision shall be reformed to the
minimum extent necessary to make such provision valid and enforceable.

If Recipient institutes patent litigation against any entity
(including a cross-claim or counterclaim in a lawsuit) alleging that the
Program itself (excluding combinations of the Program with other software
or hardware) infringes such Recipient's patent(s), then such Recipient's
rights granted under Section 2(b) shall terminate as of the date such
litigation is filed.

All Recipient's rights under this Agreement shall terminate if it
fails to comply with any of the material terms or conditions of this
Agreement and does not cure such failure in a reasonable period of
time after becoming aware of such noncompliance. If all Recipient's
rights under this Agreement terminate, Recipient agrees to cease use
and distribution of the Program as soon as reasonably practicable.
However, Recipient's obligations under this Agreement and any licenses
granted by Recipient relating to the Program shall continue and survive.

Everyone is permitted to copy and distribute copies of this Agreement,
but in order to avoid inconsistency the Agreement is copyrighted and
may only be modified in the following manner. The Agreement Steward
reserves the right to publish new versions (including revisions) of
this Agreement from time to time. No one other than the Agreement
Steward has the right to modify this Agreement. The Eclipse Foundation
is the initial Agreement Steward. The Eclipse Foundation may assign the
responsibility to serve as the Agreement Steward to a suitable separate
entity. Each new version of the Agreement will be given a distinguishing
version number. The Program (including Contributions) may always be
Distributed subject to the version of the Agreement under which it was
received. In addition, after a new version of the Agreement is published,
Contributor may elect to Distribute the Program (including its
Contributions) under the new version.

Except as expressly stated in Sections 2(a) and 2(b) above, Recipient
receives no rights or licenses to the intellectual property of any
Contributor under this Agreement, whether expressly, by implication,
estoppel or otherwise. All rights in the Program not expressly granted
under this Agreement are reserved. Nothing in this Agreement is intended
to be enforceable by any entity that is not a Contributor or Recipient.
No third-party beneficiary rights are created under this Agreement.

Exhibit A - Form of Secondary Licenses Notice

"This Source Code may also be made available under the following 
Secondary Licenses when the conditions for such availability set forth 
in the Eclipse Public License, v. 2.0 are satisfied: {name license(s),
version(s), and exceptions or additional permissions here}."

  Simply including a copy of this Agreement, including this Exhibit A
  is not sufficient to license the Source Code under Secondary Licenses.

  If it is not possible or desirable to put the notice in a particular
  file, then You may include the notice in a location (such as a LICENSE
  file in a relevant directory) where a recipient would be likely to
  look for such a notice.

  You may add additional accurate notices of copyright ownership.
```

`examples/CMakeLists.txt`:

```txt
# CMakeLists.txt
#
# CMake file for the Paho C++ example applications.
#
#*******************************************************************************
# This is part of the Paho MQTT C++ client library.
#
# Copyright (c) 2016-2024
# 
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v2.0
# and Eclipse Distribution License v1.0 which accompany this distribution.
# 
# The Eclipse Public License is available at
#   http://www.eclipse.org/legal/epl-v20.html
# and the Eclipse Distribution License is available at
#   http://www.eclipse.org/org/documents/edl-v10.php.
# 
# Contributors:
#   Guilherme Maciel Ferreira - initial version
#   Frank Pagliughi - Updates for new samples
#*******************************************************************************/

## --- Library dependencies ---

set (THREADS_PREFER_PTHREAD_FLAG ON)
find_package(Threads REQUIRED)

# The example applications
set(EXECUTABLES
    async_publish
    async_publish_time
    async_subscribe
    async_subscribe_v5
    async_consume
    async_consume_v5
    async_message_consume
    async_message_consume_v5
    data_publish
    mqttpp_chat
    multithr_pub_sub
    pub_speed_test
    rpc_math_cli
    rpc_math_srvr
    server_props_v5
    sync_publish
    sync_consume
    sync_consume_v5
    sync_reconnect
    topic_publish
    ws_publish
)

# These will only be built if SSL selected
if(PAHO_WITH_SSL)
    set(SSL_EXECUTABLES ssl_publish)
endif()

## Build the example apps
foreach(EXECUTABLE ${EXECUTABLES} ${SSL_EXECUTABLES})
    add_executable(${EXECUTABLE} ${EXECUTABLE}.cpp)
    target_link_libraries(${EXECUTABLE} PahoMqttCpp::paho-mqttpp3)

    set_target_properties(${EXECUTABLE} PROPERTIES
        CXX_STANDARD 17
        CXX_STANDARD_REQUIRED ON
        CXX_EXTENSIONS OFF
    )

    if(PAHO_BUILD_SHARED)
        target_compile_definitions(${EXECUTABLE} PRIVATE PAHO_MQTTPP_IMPORTS)
    endif()
endforeach()

## Extra configuration for the SSL/TLS examples, if selected
foreach(EXECUTABLE ${SSL_EXECUTABLES})
    target_compile_definitions(${EXECUTABLE} PUBLIC OPENSSL)
endforeach()

## install binaries
include(GNUInstallDirs)

install(TARGETS ${EXECUTABLES} ${SSL_EXECUTABLES}
    EXPORT PahoMqttCppSamples
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
)



```

`examples/async_consume.cpp`:

```cpp
// async_consume.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// This application is an MQTT consumer/subscriber using the C++
// asynchronous client interface, employing the  to receive messages
// and status updates.
//
// The sample demonstrates:
//  - Connecting to an MQTT v3 server/broker.
//  - Subscribing to a topic
//  - Persistent subscriber session
//  - Receiving messages through the synchronous queuing API
//  - Auto reconnecting
//

/*******************************************************************************
 * Copyright (c) 2013-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <cctype>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>

#include "mqtt/async_client.h"

using namespace std;

const string DFLT_SERVER_URI{"mqtt://localhost:1883"};
const string CLIENT_ID{"paho_cpp_async_consume"};

const string TOPIC{"hello"};
const int QOS = 1;

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    auto serverUri = (argc > 1) ? string{argv[1]} : DFLT_SERVER_URI;

    mqtt::async_client cli(serverUri, CLIENT_ID);

    auto connOpts = mqtt::connect_options_builder::v3()
                        .keep_alive_interval(30s)
                        .clean_session(false)
                        .automatic_reconnect()
                        .finalize();

    try {
        // Start consumer before connecting to make sure to not miss any messages

        cli.start_consuming();

        // Connect to the server

        cout << "Connecting to the MQTT server..." << flush;
        auto tok = cli.connect(connOpts);

        // Getting the connect response will block waiting for the
        // connection to complete.
        auto rsp = tok->get_connect_response();

        // If there is no session present, then we need to subscribe, but if
        // there is a session, then the server remembers us and our
        // subscriptions.
        if (!rsp.is_session_present()) {
            cout << "  No session present on server. Subscribing..." << flush;
            cli.subscribe(TOPIC, QOS)->wait();
        }

        cout << "OK" << endl;

        // Consume messages

        cout << "\nWaiting for messages on topic: '" << TOPIC << "'" << endl;

        // The client handles automatic reconnects, but we monitor
        // the events here to report them to the user.
        while (true) {
            auto evt = cli.consume_event();

            if (const auto* p = evt.get_message_if()) {
                auto& msg = *p;
                if (msg)
                    cout << msg->get_topic() << ": " << msg->to_string() << endl;
            }
            else if (evt.is_connected())
                cout << "\n*** Connected ***" << endl;
            else if (evt.is_connection_lost())
                cout << "*** Connection Lost ***" << endl;
        }
    }
    catch (const mqtt::exception& exc) {
        cerr << "\n  " << exc << endl;
        return 1;
    }

    return 0;
}

```

`examples/async_consume_v5.cpp`:

```cpp
// async_consume_v5.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// This application is an MQTT consumer/subscriber using the C++
// asynchronous client interface, employing the  to receive messages
// and status updates.
//
// The sample demonstrates:
//  - Connecting to an MQTT v5 server/broker.
//  - Subscribing to a topic
//  - Receiving messages through the consuming (queuing) API
//

/*******************************************************************************
 * Copyright (c) 2013-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <cctype>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>

#include "mqtt/async_client.h"

using namespace std;

const string DFLT_SERVER_URI{"mqtt://localhost:1883"};
const string CLIENT_ID{"PahoCppAsyncConsumeV5"};

const string TOPIC{"#"};
const int QOS = 1;

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    auto serverURI = (argc > 1) ? string{argv[1]} : DFLT_SERVER_URI;

    auto cli = std::make_shared<mqtt::async_client>(serverURI, CLIENT_ID);

    auto connOpts = mqtt::connect_options_builder::v5()
                        .clean_start(false)
                        .properties({{mqtt::property::SESSION_EXPIRY_INTERVAL, 604800}})
                        .finalize();

    try {
        // Start consumer before connecting to make sure to not miss messages

        cli->start_consuming();

        // Connect to the server

        cout << "Connecting to the MQTT server..." << flush;
        auto tok = cli->connect(connOpts);

        // Getting the connect response will block waiting for the
        // connection to complete.
        auto rsp = tok->get_connect_response();

        // Make sure we were granted a v5 connection.
        if (rsp.get_mqtt_version() < MQTTVERSION_5) {
            cout << "\n  Did not get an MQTT v5 connection." << flush;
            exit(1);
        }

        // If there is no session present, then we need to subscribe, but if
        // there is a session, then the server remembers us and our
        // subscriptions.
        if (!rsp.is_session_present()) {
            cout << "\n  Session not present on broker. Subscribing..." << flush;
            cli->subscribe(TOPIC, QOS)->wait();
        }

        cout << "\n  OK" << endl;

        // We'll signal the consumer to exit from another thread.
        // (just to show that we can)
        thread([cli] {
            this_thread::sleep_for(60s);
            cout << "\nClosing the consumer." << endl;
            cli->stop_consuming();
        }).detach();

        // Consume messages
        //
        // This just exits if the consumer is closed or the client is
        // disconnected. (See some other examples for auto or manual
        // reconnect)

        cout << "\nWaiting for messages on topic: '" << TOPIC << "'" << endl;

        try {
            while (true) {
                auto evt = cli->consume_event();

                if (const auto* p = evt.get_message_if()) {
                    auto& msg = *p;
                    if (!msg)
                        continue;

                    cout << msg->get_topic() << ": " << msg->to_string();

                    const auto& props = msg->get_properties();
                    if (size_t n = props.size(); n != 0) {
                        cout << "\n  [";
                        for (size_t i = 0; i < n - 1; ++i) cout << props[i] << ", ";
                        cout << props[n - 1] << "]";
                    }
                    cout << endl;
                }
                else if (evt.is_connected()) {
                    cout << "\n*** Connected ***" << endl;
                }
                else if (evt.is_connection_lost()) {
                    cout << "*** Connection Lost ***" << endl;
                    break;
                }
                else if (const auto* p = evt.get_disconnected_if()) {
                    cout << "*** Disconnected. Reason [0x" << hex << int{p->reasonCode}
                         << "]: " << p->reasonCode << " ***" << endl;
                    break;
                }
            }
        }
        catch (mqtt::queue_closed&) {
        }

        // If we're here, the client was almost certainly disconnected.
        // But we check, just to make sure.

        if (cli->is_connected()) {
            cout << "\nShutting down and disconnecting from the MQTT server..." << flush;
            cli->disconnect()->wait();
            cout << "OK" << endl;
        }
    }
    catch (const mqtt::exception& exc) {
        cerr << "\n  " << exc << endl;
        return 1;
    }

    return 0;
}

```

`examples/async_message_consume.cpp`:

```cpp
// async_consume.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// This application is an MQTT consumer/subscriber using the C++
// asynchronous client interface, employing the  to receive messages
// and status updates.
//
// The sample demonstrates:
//  - Connecting to an MQTT v3 server/broker.
//  - Subscribing to a topic
//  - Persistent subscriber session
//  - Receiving messages through the synchronous queuing API
//  - Auto reconnecting
//

/*******************************************************************************
 * Copyright (c) 2013-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <cctype>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>

#include "mqtt/async_client.h"

using namespace std;

const string DFLT_SERVER_URI{"mqtt://localhost:1883"};
const string CLIENT_ID{"paho_cpp_async_consume"};

const string TOPIC{"hello"};
const int QOS = 1;

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    auto serverUri = (argc > 1) ? string{argv[1]} : DFLT_SERVER_URI;

    mqtt::async_client cli(serverUri, CLIENT_ID);

    auto connOpts = mqtt::connect_options_builder::v3()
                        .keep_alive_interval(30s)
                        .clean_session(false)
                        .automatic_reconnect()
                        .finalize();

    // The client will handle automatic reconnects, but we add this
    // callbacks to let the user know when we're reconnected.
    cli.set_connected_handler([](const std::string&) {
        cout << "\n*** Connected ***" << endl;
    });

    try {
        // Start consumer before connecting to make sure to not miss any messages

        cli.start_consuming();

        // Connect to the server

        cout << "Connecting to the MQTT server..." << flush;
        auto tok = cli.connect(connOpts);

        // Getting the connect response will block waiting for the
        // connection to complete.
        auto rsp = tok->get_connect_response();

        // If there is no session present, then we need to subscribe, but if
        // there is a session, then the server remembers us and our
        // subscriptions.
        if (!rsp.is_session_present()) {
            cout << "  No session present on server. Subscribing..." << flush;
            cli.subscribe(TOPIC, QOS)->wait();
        }

        cout << "OK" << endl;

        // Consume messages

        cout << "\nWaiting for messages on topic: '" << TOPIC << "'" << endl;

        while (true) {
            auto msg = cli.consume_message();

            if (msg)
                cout << msg->get_topic() << ": " << msg->to_string() << endl;
            else
                cout << "*** Connection Lost ***" << endl;
        }
    }
    catch (const mqtt::exception& exc) {
        cerr << "\n  " << exc << endl;
        return 1;
    }

    return 0;
}

```

`examples/async_message_consume_v5.cpp`:

```cpp
// async_consume_v5.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// This application is an MQTT consumer/subscriber using the C++
// asynchronous client interface, employing the  to receive messages
// and status updates.
//
// The sample demonstrates:
//  - Connecting to an MQTT v5 server/broker.
//  - Subscribing to a topic
//  - Receiving messages through the consuming (queuing) API
//

/*******************************************************************************
 * Copyright (c) 2013-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <cctype>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>

#include "mqtt/async_client.h"

using namespace std;

const string DFLT_SERVER_URI{"mqtt://localhost:1883"};
const string CLIENT_ID{"PahoCppAsyncConsumeV5"};

const string TOPIC{"hello"};
const int QOS = 1;

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    auto serverURI = (argc > 1) ? string{argv[1]} : DFLT_SERVER_URI;

    mqtt::async_client cli(serverURI, CLIENT_ID);

    auto connOpts = mqtt::connect_options_builder::v5()
                        .clean_start(false)
                        .properties({{mqtt::property::SESSION_EXPIRY_INTERVAL, 604800}})
                        .finalize();

    try {
        cli.set_connection_lost_handler([](const std::string&) {
            cout << "*** Connection Lost ***" << endl;
        });

        cli.set_disconnected_handler([](const mqtt::properties&, mqtt::ReasonCode reason) {
            cout << "*** Disconnected. Reason [0x" << hex << int{reason} << "]: " << reason
                 << " ***" << endl;
        });

        // Start consumer before connecting to make sure to not miss messages

        cli.start_consuming();

        // Connect to the server

        cout << "Connecting to the MQTT server..." << flush;
        auto tok = cli.connect(connOpts);

        // Getting the connect response will block waiting for the
        // connection to complete.
        auto rsp = tok->get_connect_response();

        // Make sure we were granted a v5 connection.
        if (rsp.get_mqtt_version() < MQTTVERSION_5) {
            cout << "\n  Did not get an MQTT v5 connection." << flush;
            exit(1);
        }

        // If there is no session present, then we need to subscribe, but if
        // there is a session, then the server remembers us and our
        // subscriptions.
        if (!rsp.is_session_present()) {
            cout << "\n  Session not present on broker. Subscribing..." << flush;
            cli.subscribe(TOPIC, QOS)->wait();
        }

        cout << "\n  OK" << endl;

        // Consume messages
        // This just exits if the client is disconnected.
        // (See some other examples for auto or manual reconnect)

        cout << "\nWaiting for messages on topic: '" << TOPIC << "'" << endl;

        while (true) {
            auto msg = cli.consume_message();
            if (!msg)
                break;
            cout << msg->get_topic() << ": " << msg->to_string() << endl;
        }

        // If we're here, the client was almost certainly disconnected.
        // But we check, just to make sure.

        if (cli.is_connected()) {
            cout << "\nShutting down and disconnecting from the MQTT server..." << flush;
            cli.stop_consuming();
            cli.disconnect()->wait();
            cout << "OK" << endl;
        }
        else {
            cout << "\nClient was disconnected" << endl;
        }
    }
    catch (const mqtt::exception& exc) {
        cerr << "\n  " << exc << endl;
        return 1;
    }

    return 0;
}

```

`examples/async_publish.cpp`:

```cpp
// async_publish.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// It's an example of how to send messages as an MQTT publisher using the
// C++ asynchronous client interface.
//
// The sample demonstrates:
//  - Connecting to an MQTT server/broker
//  - Using a connect timeout
//  - Publishing messages
//  - Default file persistence
//  - Last will and testament
//  - Using asynchronous tokens
//  - Implementing callbacks and action listeners
//

/*******************************************************************************
 * Copyright (c) 2013-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <atomic>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>

#include "mqtt/async_client.h"

using namespace std;
using namespace std::chrono;

const string DFLT_SERVER_URI{"mqtt://localhost:1883"};
const string CLIENT_ID{"paho_cpp_async_publish"};

const mqtt::persistence_type PERSIST_DIR{"./persist"};

const string TOPIC{"hello"};

const string PAYLOAD1{"Hello World!"};
const string PAYLOAD2{"Hi there!"};
const string PAYLOAD3{"Is anyone listening?"};
const string PAYLOAD4{"Someone is always listening."};

const string LWT_PAYLOAD{"Last will and testament."};

const int QOS = 1;

const auto TIMEOUT = std::chrono::seconds(10);

/////////////////////////////////////////////////////////////////////////////

/**
 * A callback class for use with the main MQTT client.
 */
class callback : public virtual mqtt::callback
{
public:
    void connection_lost(const string& cause) override
    {
        cout << "\nConnection lost" << endl;
        if (!cause.empty())
            cout << "\tcause: " << cause << endl;
    }

    void delivery_complete(mqtt::delivery_token_ptr tok) override
    {
        cout << "\tDelivery complete for token: " << (tok ? tok->get_message_id() : -1)
             << endl;
    }
};

/////////////////////////////////////////////////////////////////////////////

/**
 * A base action listener.
 */
class action_listener : public virtual mqtt::iaction_listener
{
protected:
    void on_failure(const mqtt::token& tok) override
    {
        cout << "\tListener failure for token: " << tok.get_message_id() << endl;
    }

    void on_success(const mqtt::token& tok) override
    {
        cout << "\tListener success for token: " << tok.get_message_id() << endl;
    }
};

/////////////////////////////////////////////////////////////////////////////

/**
 * A derived action listener for publish events.
 */
class delivery_action_listener : public action_listener
{
    atomic<bool> done_;

    void on_failure(const mqtt::token& tok) override
    {
        action_listener::on_failure(tok);
        done_ = true;
    }

    void on_success(const mqtt::token& tok) override
    {
        action_listener::on_success(tok);
        done_ = true;
    }

public:
    delivery_action_listener() : done_(false) {}
    bool is_done() const { return done_; }
};

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    // A client that just publishes normally doesn't need a persistent
    // session or Client ID unless it's using persistence, then the local
    // library requires an ID to identify the persistence files.

    string serverURI = (argc > 1) ? string{argv[1]} : DFLT_SERVER_URI,
           clientID = (argc > 2) ? string{argv[2]} : CLIENT_ID;

    cout << "Initializing for server '" << serverURI << "'..." << endl;
    mqtt::async_client client(serverURI, clientID, PERSIST_DIR);

    callback cb;
    client.set_callback(cb);

    auto connOpts = mqtt::connect_options_builder()
                        .connect_timeout(5s)
                        .clean_session()
                        .will(mqtt::message(TOPIC, LWT_PAYLOAD, QOS, false))
                        .finalize();

    cout << "  ...OK" << endl;

    try {
        cout << "\nConnecting..." << endl;
        mqtt::token_ptr conntok = client.connect(connOpts);
        cout << "Waiting for the connection..." << endl;
        conntok->wait();
        cout << "  ...OK" << endl;

        // First use a message pointer.

        cout << "\nSending message..." << endl;
        mqtt::message_ptr pubmsg = mqtt::make_message(TOPIC, PAYLOAD1);
        pubmsg->set_qos(QOS);
        client.publish(pubmsg)->wait_for(TIMEOUT);
        cout << "  ...OK" << endl;

        // Now try with itemized publish.

        cout << "\nSending next message..." << endl;
        mqtt::delivery_token_ptr pubtok;
        pubtok = client.publish(TOPIC, PAYLOAD2, QOS, false);
        cout << "  ...with token: " << pubtok->get_message_id() << endl;
        cout << "  ...for message with " << pubtok->get_message()->get_payload().size()
             << " bytes" << endl;
        pubtok->wait_for(TIMEOUT);
        cout << "  ...OK" << endl;

        // Now try with a listener

        cout << "\nSending next message..." << endl;
        action_listener listener;
        pubmsg = mqtt::make_message(TOPIC, PAYLOAD3);
        pubtok = client.publish(pubmsg, nullptr, listener);
        pubtok->wait();
        cout << "  ...OK" << endl;

        // Finally try with a listener, but no token

        cout << "\nSending final message..." << endl;
        delivery_action_listener deliveryListener;
        pubmsg = mqtt::make_message(TOPIC, PAYLOAD4);
        client.publish(pubmsg, nullptr, deliveryListener);

        while (!deliveryListener.is_done()) {
            this_thread::sleep_for(std::chrono::milliseconds(100));
        }
        cout << "OK" << endl;

        // Double check that there are no pending tokens

        auto toks = client.get_pending_delivery_tokens();
        if (!toks.empty())
            cout << "Error: There are pending delivery tokens!" << endl;

        // Disconnect
        cout << "\nDisconnecting..." << endl;
        client.disconnect()->wait();
        cout << "  ...OK" << endl;
    }
    catch (const mqtt::exception& exc) {
        cerr << exc.what() << endl;
        return 1;
    }

    return 0;
}

```

`examples/async_publish_time.cpp`:

```cpp
// async_publish_time.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// It's a fairly contrived, but useful example of an MQTT data monitor and
// publisher, using the C++ asynchronous client interface. A fairly common
// usage for MQTT applications to monitor a sensor and publish the reading
// when it changes by a "significant" amount (whatever that may be).
// This might be temperature, pressure, humidity, soil moisture, CO2 levels,
// or anything like that.
//
// Since we don't have a universal sensor to use for this example, we simply
// use time itself as out input data. We periodically "sample" the time
// value and when it changes by more than our required delta amount, we
// publish the time. In this case we use the system clock, measuring the
// time with millisecond precision.
//
// The sample demonstrates:
//  - Connecting to an MQTT server/broker
//  - Sampling a value
//  - Publishing messages using a `topic` object
//  - Last will and testament
//  - Callbacks with lambdas (on connect and disconnect)
//  - Using `create_options`
//  - Creating options with builder classes
//  - Offline buffering in the client
//

/*******************************************************************************
 * Copyright (c) 2019-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <atomic>
#include <chrono>
#include <csignal>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>  // For sleep

#include "mqtt/async_client.h"

using namespace std;
using namespace std::chrono;

const std::string DFLT_SERVER_URI{"mqtt://localhost:1883"};

// The QoS for sending data
const int QOS = 1;

// How often to sample the "data"
const auto SAMPLE_PERIOD = 5ms;

// How much the "data" needs to change before we publish a new value.
const int DELTA_MS = 100;

// How many to buffer while off-line
const int MAX_BUFFERED_MESSAGES = 1200;

// Atomic flag to tell the main loop to exit.
atomic<bool> quit{false};

// Handler for ^C (SIGINT)
void ctrlc_handler(int) { quit = true; }

// --------------------------------------------------------------------------
// Gets the current time as the number of milliseconds since the epoch:
// like a time_t with ms resolution.

uint64_t timestamp()
{
    auto now = system_clock::now();
    auto tse = now.time_since_epoch();
    auto msTm = duration_cast<milliseconds>(tse);
    return uint64_t(msTm.count());
}

// --------------------------------------------------------------------------

int main(int argc, char* argv[])
{
    // The server URI (address)
    string serverURI = (argc > 1) ? string{argv[1]} : DFLT_SERVER_URI;

    // The amount of time to run (in ms). Zero means "run forever".
    uint64_t trun = (argc > 2) ? stoll(argv[2]) : 0LL;

    cout << "Initializing for server '" << serverURI << "'..." << endl;

    // We configure to allow publishing to the client while off-line,
    // and that it's OK to do so before the 1st successful connection.
    auto createOpts = mqtt::create_options_builder()
                          .server_uri(serverURI)
                          .send_while_disconnected(true, true)
                          .max_buffered_messages(MAX_BUFFERED_MESSAGES)
                          .delete_oldest_messages()
                          .finalize();

    mqtt::async_client cli(createOpts);

    // Set callbacks for when connected and connection lost.

    cli.set_connected_handler([&cli](const std::string&) {
        std::cout << "*** Connected (" << timestamp() << ") ***" << std::endl;
    });

    cli.set_connection_lost_handler([&cli](const std::string&) {
        std::cout << "*** Connection Lost (" << timestamp() << ") ***" << std::endl;
    });

    auto willMsg = mqtt::message("test/events", "Time publisher disconnected", 1, true);
    auto connOpts = mqtt::connect_options_builder()
                        .clean_session()
                        .will(willMsg)
                        .keep_alive_interval(10s)
                        .automatic_reconnect(seconds(1), seconds(10))
                        .finalize();

    try {
        // Note that we start the connection, but don't wait for completion.
        // We configured to allow publishing before a successful connection.
        cout << "Starting connection..." << endl;
        cli.connect(connOpts);

        auto top = mqtt::topic(cli, "data/time", QOS);
        cout << "Publishing data..." << endl;

        // Install a ^C handler for user to signal when to exit
        signal(SIGINT, ctrlc_handler);

        // Sync clock to start of delta period
        while (timestamp() % DELTA_MS != 0);

        uint64_t t = timestamp(), tlast = t, tstart = t;
        top.publish(to_string(t));

        while (!quit) {
            this_thread::sleep_for(SAMPLE_PERIOD);

            t = timestamp();

            if (abs(int(t - tlast)) >= DELTA_MS)
                top.publish(to_string(tlast = t));

            if (trun > 0 && t >= (trun + tstart))
                break;
        }

        // Disconnect
        cout << "\nDisconnecting..." << endl;
        cli.disconnect()->wait();
        cout << "  ...OK" << endl;
    }
    catch (const mqtt::exception& exc) {
        cerr << exc.what() << endl;
        return 1;
    }

    return 0;
}

```

`examples/async_subscribe.cpp`:

```cpp
// async_subscribe.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// This application is an MQTT subscriber using the C++ asynchronous client
// interface, employing callbacks to receive messages and status updates.
//
// The sample demonstrates:
//  - Connecting to an MQTT server/broker using MQTT v3.
//  - Subscribing to a topic
//  - Receiving messages through the callback API
//  - Receiving network disconnect updates and attempting manual reconnects.
//  - Using a "clean session" and manually re-subscribing to topics on
//    reconnect.
//

/*******************************************************************************
 * Copyright (c) 2013-2025 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <cctype>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>

#include "mqtt/async_client.h"

const std::string DFLT_SERVER_URI("mqtt://localhost:1883");
const std::string CLIENT_ID("paho_cpp_async_subscribe");

const std::string TOPIC("#");

const int QOS = 1;
const int N_RETRY_ATTEMPTS = 5;

/////////////////////////////////////////////////////////////////////////////

// Callbacks for the success or failures of requested actions.
// This could be used to initiate further action, but here we just log the
// results to the console.

class action_listener : public virtual mqtt::iaction_listener
{
    std::string name_;

    void on_failure(const mqtt::token& tok) override
    {
        std::cout << name_ << " failure";
        if (tok.get_message_id() != 0)
            std::cout << " for token: [" << tok.get_message_id() << "]" << std::endl;
        std::cout << std::endl;
    }

    void on_success(const mqtt::token& tok) override
    {
        std::cout << name_ << " success";
        if (tok.get_message_id() != 0)
            std::cout << " for token: [" << tok.get_message_id() << "]" << std::endl;
        auto top = tok.get_topics();
        if (top && !top->empty())
            std::cout << "\ttoken topic: '" << (*top)[0] << "', ..." << std::endl;
        std::cout << std::endl;
    }

public:
    action_listener(const std::string& name) : name_(name) {}
};

/////////////////////////////////////////////////////////////////////////////

/**
 * Local callback & listener class for use with the client connection.
 * This is primarily intended to receive messages, but it will also monitor
 * the connection to the broker. If the connection is lost, it will attempt
 * to restore the connection and re-subscribe to the topic.
 */
class callback : public virtual mqtt::callback, public virtual mqtt::iaction_listener

{
    // Counter for the number of connection retries
    int nretry_;
    // The MQTT client
    mqtt::async_client& cli_;
    // Options to use if we need to reconnect
    mqtt::connect_options& connOpts_;
    // An action listener to display the result of actions.
    action_listener subListener_;

    // This deomonstrates manually reconnecting to the broker by calling
    // connect() again. This is a possibility for an application that keeps
    // a copy of it's original connect_options, or if the app wants to
    // reconnect with different options.
    // Another way this can be done manually, if using the same options, is
    // to just call the async_client::reconnect() method.
    void reconnect()
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(2500));
        try {
            cli_.connect(connOpts_, nullptr, *this);
        }
        catch (const mqtt::exception& exc) {
            std::cerr << "Error: " << exc.what() << std::endl;
            exit(1);
        }
    }

    // Re-connection failure
    void on_failure(const mqtt::token& tok) override
    {
        std::cout << "Connection attempt failed" << std::endl;
        if (++nretry_ > N_RETRY_ATTEMPTS)
            exit(1);
        reconnect();
    }

    // (Re)connection success
    // Either this or connected() can be used for callbacks.
    void on_success(const mqtt::token& tok) override {}

    // (Re)connection success
    void connected(const std::string& cause) override
    {
        std::cout << "\nConnection success" << std::endl;
        std::cout << "\nSubscribing to topic '" << TOPIC << "'\n"
                  << "\tfor client " << CLIENT_ID << " using QoS" << QOS << "\n"
                  << "\nPress Q<Enter> to quit\n"
                  << std::endl;

        cli_.subscribe(TOPIC, QOS, nullptr, subListener_);
    }

    // Callback for when the connection is lost.
    // This will initiate the attempt to manually reconnect.
    void connection_lost(const std::string& cause) override
    {
        std::cout << "\nConnection lost" << std::endl;
        if (!cause.empty())
            std::cout << "\tcause: " << cause << std::endl;

        std::cout << "Reconnecting..." << std::endl;
        nretry_ = 0;
        reconnect();
    }

    // Callback for when a message arrives.
    void message_arrived(mqtt::const_message_ptr msg) override
    {
        std::cout << "Message arrived" << std::endl;
        std::cout << "\ttopic: '" << msg->get_topic() << "'" << std::endl;
        std::cout << "\tpayload: '" << msg->to_string() << "'\n" << std::endl;
    }

    void delivery_complete(mqtt::delivery_token_ptr token) override {}

public:
    callback(mqtt::async_client& cli, mqtt::connect_options& connOpts)
        : nretry_(0), cli_(cli), connOpts_(connOpts), subListener_("Subscription")
    {
    }
};

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    // A subscriber often wants the server to remember its messages when its
    // disconnected. In that case, it needs a unique ClientID and a
    // non-clean session.

    auto serverURI = (argc > 1) ? std::string{argv[1]} : DFLT_SERVER_URI;

    mqtt::async_client cli(serverURI, CLIENT_ID);

    mqtt::connect_options connOpts;
    connOpts.set_clean_session(false);

    // Install the callback(s) before connecting.
    callback cb(cli, connOpts);
    cli.set_callback(cb);

    // Start the connection.
    // When completed, the callback will subscribe to topic.

    try {
        std::cout << "Connecting to the MQTT server '" << serverURI << "'..." << std::flush;
        cli.connect(connOpts, nullptr, cb);
    }
    catch (const mqtt::exception& exc) {
        std::cerr << "\nERROR: Unable to connect to MQTT server: '" << serverURI << "'" << exc
                  << std::endl;
        return 1;
    }

    // Just block till user tells us to quit.

    while (std::tolower(std::cin.get()) != 'q');

    // Disconnect

    try {
        std::cout << "\nDisconnecting from the MQTT server..." << std::flush;
        cli.disconnect()->wait();
        std::cout << "OK" << std::endl;
    }
    catch (const mqtt::exception& exc) {
        std::cerr << exc << std::endl;
        return 1;
    }

    return 0;
}

```

`examples/async_subscribe_v5.cpp`:

```cpp
// async_subscribe.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// This application is an MQTT subscriber using the C++ asynchronous client
// interface, employing callbacks to receive messages and status updates.
//
// The sample demonstrates:
//  - Connecting to an MQTT server/broker using MQTT v5.
//  - Subscribing to a topic
//  - Receiving messages through the callback API
//  - Displaying MQTT v5 message properties.
//  - Receiving network disconnect updates and attempting manual reconnects.
//  - Using a "clean session" and manually re-subscribing to topics on
//    reconnect.
//

/*******************************************************************************
 * Copyright (c) 2013-2025 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <cctype>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>

#include "mqtt/async_client.h"

const std::string DFLT_SERVER_URI("mqtt://localhost:1883");
const std::string CLIENT_ID("paho_cpp_async_subscribe");
const std::string TOPIC("#");

const int QOS = 1;
const int N_RETRY_ATTEMPTS = 5;

/////////////////////////////////////////////////////////////////////////////

// Callbacks for the success or failures of requested actions.
// This could be used to initiate further action, but here we just log the
// results to the console.

class action_listener : public virtual mqtt::iaction_listener
{
    std::string name_;

    void on_failure(const mqtt::token& tok) override
    {
        std::cout << name_ << " failure";
        if (tok.get_message_id() != 0)
            std::cout << " for token: [" << tok.get_message_id() << "]" << std::endl;
        std::cout << std::endl;
    }

    void on_success(const mqtt::token& tok) override
    {
        std::cout << name_ << " success";
        if (tok.get_message_id() != 0)
            std::cout << " for token: [" << tok.get_message_id() << "]" << std::endl;
        auto top = tok.get_topics();
        if (top && !top->empty())
            std::cout << "\ttoken topic: '" << (*top)[0] << "', ..." << std::endl;
        std::cout << std::endl;
    }

public:
    action_listener(const std::string& name) : name_(name) {}
};

/////////////////////////////////////////////////////////////////////////////

/**
 * Local callback & listener class for use with the client connection.
 * This is primarily intended to receive messages, but it will also monitor
 * the connection to the broker. If the connection is lost, it will attempt
 * to restore the connection and re-subscribe to the topic.
 */
class callback : public virtual mqtt::callback, public virtual mqtt::iaction_listener

{
    // Counter for the number of connection retries
    int nretry_;
    // The MQTT client
    mqtt::async_client& cli_;
    // Options to use if we need to reconnect
    mqtt::connect_options& connOpts_;
    // An action listener to display the result of actions.
    action_listener subListener_;

    // This deomonstrates manually reconnecting to the broker by calling
    // connect() again. This is a possibility for an application that keeps
    // a copy of it's original connect_options, or if the app wants to
    // reconnect with different options.
    // Another way this can be done manually, if using the same options, is
    // to just call the async_client::reconnect() method.
    void reconnect()
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(2500));
        try {
            cli_.connect(connOpts_, nullptr, *this);
        }
        catch (const mqtt::exception& exc) {
            std::cerr << "Error: " << exc.what() << std::endl;
            exit(1);
        }
    }

    // Re-connection failure
    void on_failure(const mqtt::token& tok) override
    {
        std::cout << "Connection attempt failed" << std::endl;
        if (++nretry_ > N_RETRY_ATTEMPTS)
            exit(1);
        reconnect();
    }

    // (Re)connection success
    // Either this or connected() can be used for callbacks.
    void on_success(const mqtt::token& tok) override {}

    // (Re)connection success
    void connected(const std::string& cause) override
    {
        std::cout << "\nConnection success" << std::endl;
        std::cout << "\nSubscribing to topic '" << TOPIC << "'\n"
                  << "\tfor client " << CLIENT_ID << " using QoS" << QOS << "\n"
                  << "\nPress Q<Enter> to quit\n"
                  << std::endl;

        cli_.subscribe(TOPIC, QOS, nullptr, subListener_);
    }

    // Callback for when the connection is lost.
    // This will initiate the attempt to manually reconnect.
    void connection_lost(const std::string& cause) override
    {
        std::cout << "\nConnection lost" << std::endl;
        if (!cause.empty())
            std::cout << "\tcause: " << cause << std::endl;

        std::cout << "Reconnecting..." << std::endl;
        nretry_ = 0;
        reconnect();
    }

    // Callback for when a message arrives.
    void message_arrived(mqtt::const_message_ptr msg) override
    {
        std::cout << "\nMessage arrived" << std::endl;
        std::cout << "\ttopic: '" << msg->get_topic() << "'" << std::endl;
        std::cout << "\tpayload: '" << msg->to_string() << std::endl;

        const mqtt::properties& props = msg->get_properties();
        if (size_t n = props.size(); n != 0) {
            std::cout << "\tproperties (" << n << "):\n\t  [";
            for (size_t i = 0; i < n - 1; ++i) std::cout << props[i] << ", ";
            std::cout << props[n - 1] << "]" << std::endl;
        }
    }

    void delivery_complete(mqtt::delivery_token_ptr token) override {}

public:
    callback(mqtt::async_client& cli, mqtt::connect_options& connOpts)
        : nretry_(0), cli_(cli), connOpts_(connOpts), subListener_("Subscription")
    {
    }
};

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    // A subscriber often wants the server to remember its messages when its
    // disconnected. In that case, it needs a unique ClientID and a
    // non-clean session.

    auto serverURI = (argc > 1) ? std::string{argv[1]} : DFLT_SERVER_URI;

    mqtt::async_client cli(serverURI, CLIENT_ID);

    auto connOpts = mqtt::connect_options_builder::v5().clean_start(true).finalize();

    // Install the callback(s) before connecting.
    callback cb(cli, connOpts);
    cli.set_callback(cb);

    // Start the connection.
    // When completed, the callback will subscribe to topic.

    try {
        std::cout << "Connecting to the MQTT server '" << serverURI << "'..." << std::flush;
        cli.connect(connOpts, nullptr, cb);
    }
    catch (const mqtt::exception& exc) {
        std::cerr << "\nERROR: Unable to connect to MQTT server: '" << serverURI << "'" << exc
                  << std::endl;
        return 1;
    }

    // Just block till user tells us to quit.

    while (std::tolower(std::cin.get()) != 'q');

    // Disconnect

    try {
        std::cout << "\nDisconnecting from the MQTT server..." << std::flush;
        cli.disconnect()->wait();
        std::cout << "OK" << std::endl;
    }
    catch (const mqtt::exception& exc) {
        std::cerr << exc << std::endl;
        return 1;
    }

    return 0;
}

```

`examples/data_publish.cpp`:

```cpp
// data_publish.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// It's an example of how to collect and publish periodic data to MQTT, as
// an MQTT publisher using the C++ asynchronous client interface.
//
// The sample demonstrates:
//  - Connecting to an MQTT server/broker
//  - Publishing messages
//  - Using a topic object to repeatedly publish to the same topic.
//  - Automatic reconnects
//  - Off-line buffering
//  - User file-based persistence with simple encoding.
//
// This just uses the steady clock to run a periodic loop. Each time
// through, it generates a random number [0-100] as simulated data and
// creates a text, CSV payload in the form:
//  	<sample #>,<time stamp>,<data>
//
// Note that it uses the steady clock to pace the periodic timing, but then
// reads the system_clock to generate the timestamp for local calendar time.
//
// The sample number is just a counting integer to help test the off-line
// buffering to easily confirm that all the messages got across.
//

/*******************************************************************************
 * Copyright (c) 2013-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <algorithm>
#include <chrono>
#include <condition_variable>
#include <csignal>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <mutex>
#include <random>
#include <string>
#include <thread>

#include "mqtt/async_client.h"

using namespace std;
using namespace std::chrono;
namespace fs = std::filesystem;

const std::string DFLT_SERVER_URI{"mqtt://localhost:1883"};
const std::string CLIENT_ID{"paho-cpp-data-publish"};

const string TOPIC{"data/rand"};
const int QOS = 1;

// How often we output a data point
const auto PERIOD = seconds(5);

// The number of out-bound messages we will buffer locally when disconnected.
const int MAX_BUFFERED_MSGS = 120;  // 120 * 5sec => 10min off-line buffering

// Top-level directory to keep persistence data
const fs::path PERSIST_DIR{"persist"};

// A key for encoding the persistence data
const string PERSIST_KEY{"elephant"};

// Class to pace timing and signal and exit without delay.
class quit_signal
{
    condition_variable cv_;
    mutex mtx_;
    bool quit_{false};

public:
    template <class Clock, class Duration>
    bool wait_until(const time_point<Clock, Duration>& abs_time)
    {
        unique_lock lk(mtx_);
        return cv_.wait_until(lk, abs_time, [this] { return quit_; });
    }

    void signal()
    {
        unique_lock<mutex> lk(mtx_);
        quit_ = true;
        lk.unlock();
        cv_.notify_one();
    }
};

// Variable to pace timing and signal exit
quit_signal quit;

/////////////////////////////////////////////////////////////////////////////

// Example of user-based file persistence with a simple XOR encoding scheme.
//
// Similar to the built-in file persistence, this just creates a
// subdirectory for the persistence data, then places each key into a
// separate file using the key as the file name.
//
// With user-defined persistence, you can transform the data in any way you
// like, such as with encryption/decryption, and you can store the data any
// place you want, such as here with disk files, or use a local DB like
// SQLite or a local key/value store like Redis.
class encoded_file_persistence : virtual public mqtt::iclient_persistence
{
    // The directory for the persistence store.
    fs::path dir_;

    // A key for encoding the data, as supplied by the user
    string encodeKey_;

    // Simple, in-place XOR encoding and decoding
    void encode(string& s) const
    {
        size_t n = encodeKey_.size();
        if (n == 0 || s.empty())
            return;

        for (size_t i = 0; i < s.size(); ++i) s[i] ^= encodeKey_[i % n];
    }

    // Gets the persistence file name for the supplied key.
    fs::path path_name(const string& key) const { return dir_ / key; }

public:
    // Create the persistence object with the specified encoding key
    encoded_file_persistence(const string& encodeKey) : encodeKey_(encodeKey) {}

    // "Open" the persistence store.
    // Create a directory for persistence files, using the client ID and
    // serverURI to make a unique directory name. Note that neither can be
    // empty. In particular, the app can't use an empty `clientID` if it
    // wants to use persistence. (This isn't an absolute rule for your own
    // persistence, but you do need a way to keep data from different apps
    // separate).
    void open(const string& clientId, const string& serverURI) override
    {
        if (clientId.empty() || serverURI.empty())
            throw mqtt::persistence_exception();

        // Create a name for the persistence subdirectory for this client
        string name = serverURI + "-" + clientId;
        std::replace(name.begin(), name.end(), ':', '-');

        dir_ = PERSIST_DIR;
        dir_ /= name;

        fs::create_directories(dir_);
    }

    // Close the persistent store that was previously opened.
    // Remove the persistence directory, if it's empty.
    void close() override
    {
        fs::remove(dir_);
        fs::remove(dir_.parent_path());
    }

    // Clears persistence, so that it no longer contains any persisted data.
    // Just remove all the files from the persistence directory.
    void clear() override
    {
        // We could iterate through and remove each file,
        // but this does the same thing in fewer steps.
        if (!fs::is_empty(dir_)) {
            fs::remove_all(dir_);
            fs::create_directories(dir_);
        }
    }

    // Returns whether or not data is persisted using the specified key.
    // We just look for a file in the store directory with the same name as
    // the key.
    bool contains_key(const string& key) override
    {
        if (fs::exists(dir_)) {
            for (const auto& entry : fs::directory_iterator(dir_)) {
                if (entry.path().filename() == key)
                    return true;
            }
        }
        return false;
    }

    // Returns the keys in this persistent data store.
    // We just make a collection of the file names in the store directory.
    mqtt::string_collection keys() const override
    {
        mqtt::string_collection ks;

        if (fs::exists(dir_)) {
            for (const auto& entry : fs::directory_iterator(dir_)) {
                ks.push_back(entry.path().filename().string());
            }
        }
        return ks;
    }

    // Puts the specified data into the persistent store.
    // We just encode the data and write it to a file using the key as the
    // name of the file. The multiple buffers given here need to be written
    // in order - and a scatter/gather like writev() would be fine. But...
    // the data will be read back as a single buffer, so here we first
    // concat a string so that the encoding key lines up with the data the
    // same way it will on the read-back.
    void put(const string& key, const std::vector<mqtt::string_view>& bufs) override
    {
        auto path = path_name(key);

        ofstream os(path, ios_base::binary);
        if (!os)
            throw mqtt::persistence_exception();

        string s;
        for (const auto& b : bufs) s.append(b.data(), b.size());

        encode(s);
        os.write(s.data(), s.size());
    }

    // Gets the specified data out of the persistent store.
    // We look for a file with the name of the key, read the contents,
    // decode, and return it.
    string get(const string& key) const override
    {
        auto path = path_name(key);

        ifstream is(path, ios_base::ate | ios_base::binary);
        if (!is)
            throw mqtt::persistence_exception();

        // Read the whole file into a string
        streamsize sz = is.tellg();
        if (sz == 0)
            return string();

        is.seekg(0);
        string s(sz, '\0');
        is.read(&s[0], sz);
        if (is.gcount() < sz)
            s.resize(is.gcount());

        encode(s);
        return s;
    }

    // Remove the data for the specified key.
    // Just remove the file with the same name as the key, if found.
    void remove(const string& key) override
    {
        auto path = path_name(key);
        fs::remove(path);
    }
};

/////////////////////////////////////////////////////////////////////////////

// Handler for ^C (SIGINT)
void ctrlc_handler(int) { quit.signal(); }

// --------------------------------------------------------------------------

int main(int argc, char* argv[])
{
    string serverURI = (argc > 1) ? string{argv[1]} : DFLT_SERVER_URI;

    // Create a persistence object
    encoded_file_persistence persist{PERSIST_KEY};

    // Create a client to use the persistence.
    mqtt::async_client cli(serverURI, CLIENT_ID, MAX_BUFFERED_MSGS, &persist);

    auto connOpts = mqtt::connect_options_builder()
                        .keep_alive_interval(MAX_BUFFERED_MSGS * PERIOD)
                        .clean_session(false)
                        .automatic_reconnect(true)
                        .finalize();

    // Create a topic object. This is a conventience since we will
    // repeatedly publish messages with the same parameters.
    mqtt::topic top(cli, TOPIC, QOS, true);

    // Random number generator [0 - 100]
    random_device rnd;
    mt19937 gen(rnd());
    uniform_int_distribution<> dis(0, 100);

    try {
        // Connect to the MQTT broker
        cout << "Connecting to server '" << serverURI << "'..." << flush;
        cli.connect(connOpts)->wait();
        cout << "OK\n" << endl;

        char tmbuf[32];
        unsigned nsample = 0;

        // Install a ^C handler for user to signal when to exit
        signal(SIGINT, ctrlc_handler);

        // The steady time at which to read the next sample
        auto tm = steady_clock::now() + 250ms;

        // Pace the sampling by letting the condition variable time out
        // periodically. When 'quit' is signaled, it's time to quit.
        while (!quit.wait_until(tm)) {
            // Get a timestamp and format as a string
            time_t t = system_clock::to_time_t(system_clock::now());
            strftime(tmbuf, sizeof(tmbuf), "%F %T", localtime(&t));

            // Simulate reading some data
            int x = dis(gen);

            // Create the payload as a text CSV string
            string payload = to_string(++nsample) + "," + tmbuf + "," + to_string(x);
            cout << payload << endl;

            // Publish to the topic
            top.publish(std::move(payload));

            tm += PERIOD;
        }

        // Disconnect
        cout << "\nDisconnecting..." << flush;
        cli.disconnect()->wait();
        cout << "OK" << endl;
    }
    catch (const mqtt::exception& exc) {
        cerr << exc.what() << endl;
        return 1;
    }

    return 0;
}

```

`examples/mqttpp_chat.cpp`:

```cpp
// mqttpp_chat.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// The "chat" application is practically the "Hello World" application for
// messaging systems. This allows a user to type in message to send to a
// "group" while seeing all the messages that the other members of the group
// send.
//
// This application is an MQTT publisher/subscriber using the C++
// asynchronous client interface, employing callbacks to receive messages
// and status updates.
//
// The sample demonstrates:
//  - Connecting to an MQTT server/broker.
//  - Publishing messages.
//  - Subscribing to a topic
//  - Receiving messages (callbacks) through a lambda function
//
// USAGE:
//     mqttpp_chat <user> <group>

/*******************************************************************************
 * Copyright (c) 2019-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <cctype>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>

#include "mqtt/async_client.h"
#include "mqtt/topic.h"

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    // The broker/server address
    const std::string SERVER_ADDRESS("mqtt://localhost:1883");

    // The QoS to use for publishing and subscribing
    const int QOS = 1;

    // Tell the broker we don't want our own messages sent back to us.
    const bool NO_LOCAL = true;

    if (argc != 3) {
        std::cout << "USAGE: mqttpp_chat <user> <group>" << std::endl;
        return 1;
    }

    std::string chatUser{argv[1]}, chatGroup{argv[2]}, chatTopic{"chat/" + chatGroup};

    mqtt::async_client cli(SERVER_ADDRESS);

    // LWT message is broadcast to other users if out connection is lost

    auto lwt =
        mqtt::message(chatTopic, "<<<" + chatUser + " was disconnected>>>", QOS, false);

    // Set up the connect options

    auto connOpts = mqtt::connect_options_builder::v5()
                        .properties({{mqtt::property::SESSION_EXPIRY_INTERVAL, 604800}})
                        .clean_start(false)
                        .will(std::move(lwt))
                        .keep_alive_interval(std::chrono::seconds(20))
                        .finalize();

    // Set a callback for connection lost.
    // This just exits the app.

    cli.set_connection_lost_handler([](const std::string&) {
        std::cout << "*** Connection Lost  ***" << std::endl;
        exit(2);
    });

    // Set the callback for incoming messages

    cli.set_message_callback([](mqtt::const_message_ptr msg) {
        std::cout << msg->get_payload_str() << std::endl;
    });

    // We publish and subscribe to one topic,
    // so a 'topic' object is helpful.

    mqtt::topic topic{cli, "chat/" + chatGroup, QOS};

    // Start the connection.

    try {
        std::cout << "Connecting to the chat server at '" << SERVER_ADDRESS << "'..."
                  << std::flush;
        auto tok = cli.connect(connOpts);
        tok->wait();

        // Subscribe to the topic using "no local" so that
        // we don't get own messages sent back to us

        std::cout << "Ok\nJoining the group..." << std::flush;
        auto subOpts = mqtt::subscribe_options(NO_LOCAL);
        topic.subscribe(subOpts)->wait();
        std::cout << "Ok" << std::endl;
    }
    catch (const mqtt::exception& exc) {
        std::cerr << "\nERROR: Unable to connect. " << exc.what() << std::endl;
        return 1;
    }

    // Let everyone know that a new user joined the conversation.

    topic.publish("<<" + chatUser + " joined the group>>");

    // Read messages from the console and publish them.
    // Quit when the use enters an empty line.

    std::string usrMsg;

    while (std::getline(std::cin, usrMsg) && !usrMsg.empty()) {
        usrMsg = chatUser + ": " + usrMsg;
        topic.publish(usrMsg);
    }

    // Let everyone know that the user left the conversation.

    topic.publish("<<" + chatUser + " left the group>>")->wait();

    // Disconnect

    try {
        std::cout << "Disconnecting from the chat server..." << std::flush;
        cli.disconnect()->wait();
        std::cout << "OK" << std::endl;
    }
    catch (const mqtt::exception& exc) {
        std::cerr << exc.what() << std::endl;
        return 1;
    }

    return 0;
}

```

`examples/multithr_pub_sub.cpp`:

```cpp
// async_subscribe.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// This application is an MQTT publisher/subscriber using the C++
// asynchronous client interface, demonstrating how you can share a client
// between multiple threads.
//
// The app will count the number of "data" messages arriving at the broker
// and then emit "events" with updated counts. A data message is any on a
// "data/#" topic, and counts are emitted on the "events/count" topic. It
// emits an event count around once every ten data messages.
//
// Note that this is a fairly contrived example, and it could be done much
// more easily in a single thread. It is meant to demonstrate how you can
// share a client amongst threads if and when that's a proper thing to do.
//
// At this time, there is a single callback or consumer queue for all
// incoming messages, so you would typically only have one thead receiving
// messages, although it _could_ send messages to multiple threads for
// processing, perhaps based on the topics. It could be common, however, to
// want to have multiple threads for publishing.
//
// This example demonstrates:
//  - Creating a client and sharing it across threads using a shared_ptr<>
//  - Using one thread to receive incoming messages from the broker and
//    another thread to publish messages to it.
//  - Connecting to an MQTT server/broker.
//  - Automatic reconnect
//  - Publishing messages
//  - Subscribing to multiple topics
//  - Using the asynchronous message consumer
//  - Signaling consumer from another thread
//

/*******************************************************************************
 * Copyright (c) 2020-2025 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <cctype>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <memory>
#include <string>
#include <thread>

#include "mqtt/async_client.h"

using namespace std;
using namespace std::chrono;

const std::string DFLT_SERVER_ADDRESS{"mqtt://localhost:1883"};
const std::string CLIENT_ID{"multithr_pub_sub_cpp"};

/////////////////////////////////////////////////////////////////////////////

/**
 * A thread-safe counter that can be used to occasionally signal a waiter on
 * every 10th increment.
 */
class multithr_counter
{
    using guard = std::unique_lock<std::mutex>;

    size_t count_;
    bool closed_;
    mutable bool ready_;
    mutable std::condition_variable cond_;
    mutable std::mutex lock_;

public:
    // Declare a pointer type for sharing a counter between threads
    using ptr_t = std::shared_ptr<multithr_counter>;

    // Create a new thread-safe counter with an initial count of zero.
    multithr_counter() : count_(0), closed_(false), ready_(false) {}

    // Determines if the counter has been closed.
    bool closed() const
    {
        guard g(lock_);
        return closed_;
    }

    // Close the counter and signal all waiters.
    void close()
    {
        guard g(lock_);
        closed_ = ready_ = true;
        cond_.notify_all();
    }

    // Increments the count, and then signals once every 10 messages.
    void incr()
    {
        guard g(lock_);
        if (closed_)
            throw string("Counter is closed");
        if (++count_ % 10 == 0) {
            ready_ = true;
            g.unlock();
            cond_.notify_all();
        }
    }

    // This will block the caller until at least 10 new messages received.
    size_t get_count() const
    {
        guard g(lock_);
        cond_.wait(g, [this] { return ready_; });
        ready_ = false;
        return count_;
    }
};

/////////////////////////////////////////////////////////////////////////////

// The MQTT publisher function will run in its own thread.
// It runs until the receiver thread closes the counter object.
void publisher_func(mqtt::async_client_ptr cli, multithr_counter::ptr_t counter)
{
    while (true) {
        size_t n = counter->get_count();
        if (counter->closed())
            break;

        string payload = std::to_string(n);
        cli->publish("events/count", payload)->wait();
    }
}

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    string address = (argc > 1) ? string(argv[1]) : DFLT_SERVER_ADDRESS;

    // Create an MQTT client using a smart pointer to be shared among threads.
    auto cli = std::make_shared<mqtt::async_client>(address, CLIENT_ID);

    // Make a counter object also with a shared pointer.
    auto counter = std::make_shared<multithr_counter>();

    // Connect options for a persistent session and automatic reconnects.
    auto connOpts = mqtt::connect_options_builder()
                        .clean_session(false)
                        .automatic_reconnect(seconds(2), seconds(30))
                        .finalize();

    auto TOPICS = mqtt::string_collection::create({"data/#", "command"});
    const vector<int> QOS{0, 1};

    try {
        // Start consuming _before_ connecting, because we could get a flood
        // of stored messages as soon as the connection completes since
        // we're using a persistent (non-clean) session with the broker.
        cli->start_consuming();

        cout << "Connecting to the MQTT server at " << address << "..." << flush;
        auto rsp = cli->connect(connOpts)->get_connect_response();
        cout << "OK\n" << endl;

        cout << "Now start an application such as 'async_publish_time'\n"
             << "that publishes to a 'data/' topic...\n"
             << endl;

        // Subscribe if this is a new session with the server
        if (!rsp.is_session_present())
            cli->subscribe(TOPICS, QOS);

        // Start the publisher thread

        std::thread publisher(publisher_func, cli, counter);

        // Start another thread to shut us down after a minute

        std::thread{[cli] {
            this_thread::sleep_for(30s);
            cout << "Signaling the consumer to stop." << endl;
            cli->stop_consuming();
        }}.detach();

        // Consume messages in this thread

        // Remember that with the message consumer, we can't detect a
        // reconnect We would need to register a connect callback or use the
        // event consumer.

        while (true) {
            auto msg = cli->consume_message();

            if (!msg) {
                // Exit if the consumer was shut down
                if (cli->consumer_closed())
                    break;

                // Otherwise let auto-reconnect deal with it.
                cout << "Disconnect detected. Attempting an auto-reconnect." << endl;
                continue;
            }

            if (msg->get_topic() == "command" && msg->to_string() == "exit") {
                cout << "Exit command received" << endl;
                break;
            }

            cout << msg->get_topic() << ": " << msg->to_string() << endl;
            counter->incr();
        }

        // Close the counter and wait for the publisher thread to complete
        cout << "\nShutting down..." << flush;
        counter->close();
        publisher.join();

        // Disconnect

        cout << "OK\nDisconnecting..." << flush;
        cli->disconnect();
        cout << "OK" << endl;
    }
    catch (const mqtt::exception& exc) {
        cerr << exc.what() << endl;
        return 1;
    }

    return 0;
}

```

`examples/pub_speed_test.cpp`:

```cpp
// pub_speed_test.cpp
//
// Paho C++ sample client application to do a simple test of the speed at
// which messages can be published.
//
/*******************************************************************************
 * Copyright (c) 2013-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <atomic>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <future>
#include <iostream>
#include <string>
#include <thread>

#include "mqtt/async_client.h"
#include "mqtt/thread_queue.h"

using namespace std;
using namespace std::chrono;

const std::string DFLT_SERVER_ADDRESS{"mqtt://localhost:1883"};

const size_t DFLT_PAYLOAD_SIZE = 1024;
const int DFLT_N_MSG = 1000, DFLT_QOS = 1;

const string TOPIC{"test/speed"};

const char* LWT_PAYLOAD = "pub_speed_test died unexpectedly.";

// Queue for passing tokens to the wait thread
mqtt::thread_queue<mqtt::delivery_token_ptr> que;

// Get the current time on the steady clock
steady_clock::time_point now() { return steady_clock::now(); }

// Convert a duration to a count of milliseconds
template <class Rep, class Period>
int64_t msec(const std::chrono::duration<Rep, Period>& dur)
{
    return (int64_t)duration_cast<milliseconds>(dur).count();
}

// --------------------------------------------------------------------------
// Thread function will wait for all the tokens to complete.
// Any exceptions thrown from here will be caught in main().

void token_wait_func()
{
    while (true) {
        mqtt::delivery_token_ptr tok = que.get();
        if (!tok)
            break;
        // cout.put('x');
        tok->wait();
    }
}

// --------------------------------------------------------------------------

int main(int argc, char* argv[])
{
    string address = (argc > 1) ? string(argv[1]) : DFLT_SERVER_ADDRESS;
    int nMsg = (argc > 2) ? atoi(argv[2]) : DFLT_N_MSG;
    size_t msgSz = (size_t)((argc > 3) ? atol(argv[3]) : DFLT_PAYLOAD_SIZE);
    int qos = (argc > 4) ? atoi(argv[4]) : DFLT_QOS;

    cout << "Initializing for server '" << address << "'..." << flush;
    mqtt::async_client cli(address, "");

    mqtt::message willmsg(TOPIC, LWT_PAYLOAD, 1, true);
    mqtt::will_options will(willmsg);

    mqtt::connect_options connOpts;
    connOpts.set_clean_session(true);
    connOpts.set_will(will);

    // Create a payload
    mqtt::binary payload;
    for (size_t i = 0; i < msgSz; ++i) payload.push_back('a' + i % 26);

    cout << "OK" << endl;

    try {
        // Create the message (move payload into it)
        auto msg = mqtt::make_message(TOPIC, std::move(payload), qos, false);

        // Connect to the broker
        cout << "\nConnecting..." << flush;
        auto start = now();
        cli.connect(connOpts)->wait();
        auto end = now();
        cout << "OK" << endl;

        cout << "Connected in " << msec(end - start) << "ms" << endl;

        auto fut = std::async(launch::async, token_wait_func);

        // Publish the messages
        cout << "\nPublishing " << nMsg << " messages..." << flush;
        start = now();
        for (int i = 0; i < nMsg; ++i) {
            auto dtok = cli.publish(msg);
            // cout.put('^');
            que.put(std::move(dtok));
        }
        auto pubend = now();
        que.put(mqtt::delivery_token_ptr());

        // Wait for all the tokens to complete
        fut.get();
        end = now();

        cout << "OK" << endl;
        auto ms = msec(pubend - start);
        cout << "Published in    " << ms << "ms " << (nMsg / ms) << "k msg/sec" << endl;
        ms = msec(end - start);
        cout << "Acknowledged in " << ms << "ms " << (nMsg / ms) << "k msg/sec" << endl;

        // Disconnect
        cout << "\nDisconnecting..." << flush;
        start = now();
        cli.disconnect(seconds(10))->wait();
        end = now();
        cout << "OK" << endl;
        cout << "Disconnected in " << msec(end - start) << "ms" << endl;
    }
    catch (const mqtt::exception& exc) {
        que.put(mqtt::delivery_token_ptr{});
        cerr << exc.what() << endl;
        return 1;
    }

    return 0;
}

```

`examples/rpc_math_cli.cpp`:

```cpp
// rpc_math_cli.cpp
//
// This is a Paho MQTT v5 C++ sample application.
//
// It's an example of how to create a client for performing remote procedure
// calls using MQTT with the 'response topic' and 'correlation data'
// properties.
//
// The sample demonstrates:
//  - Connecting to an MQTT server/broker
//  - Using MQTT v5 properties
//  - Publishing RPC request messages
//  - Using asynchronous tokens
//	- Subscribing to reply topic
//

/*******************************************************************************
 * Copyright (c) 2019-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <atomic>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <sstream>
#include <string>
#include <thread>

#include "mqtt/async_client.h"
#include "mqtt/properties.h"

using namespace std;
using namespace std::chrono;

const string SERVER_ADDRESS{"mqtt://localhost:1883"};
const auto TIMEOUT = std::chrono::seconds(10);

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    if (argc < 4) {
        cout << "USAGE: rpc_math_cli <add|mult> <num1> <num2> [... numN]" << endl;
        return 1;
    }

    constexpr int QOS = 1;
    const string REQ_TOPIC_HDR{"requests/math/"};

    // Create a client
    mqtt::async_client cli(SERVER_ADDRESS, "");

    cli.start_consuming();

    try {
        cout << "Connecting..." << flush;
        auto connOpts = mqtt::connect_options::v5();

        mqtt::token_ptr tok = cli.connect(connOpts);
        auto connRsp = tok->get_connect_response();
        cout << "OK (" << connRsp.get_server_uri() << ")" << endl;

        // Since we gave an empty client ID, the server should create a
        // unique one for us and send it back as ASSIGNED_CLIENT_IDENTIFIER
        // in the connect properties.

        string clientId =
            get<string>(connRsp.get_properties(), mqtt::property::ASSIGNED_CLIENT_IDENTIFIER);

        // So now we can create a unique RPC response topic using
        // the assigned (unique) client ID.

        string repTopic = "replies/" + clientId + "/math";
        cout << "    Reply topic: " << repTopic << endl;

        // Subscribe to the reply topic and verify the QoS

        tok = cli.subscribe(repTopic, QOS);
        tok->wait();

        if (int(tok->get_reason_code()) != QOS) {
            cerr << "Error: Server doesn't support reply QoS: [" << tok->get_reason_code()
                 << "]" << endl;
            return 2;
        }

        // Create and send the request message

        string req{argv[1]}, reqTopic{REQ_TOPIC_HDR + req};

        mqtt::properties props{
            {mqtt::property::RESPONSE_TOPIC, repTopic},
            {mqtt::property::CORRELATION_DATA, "1"}
        };

        ostringstream os;
        os << "[ ";
        for (int i = 2; i < argc - 1; ++i) os << argv[i] << ", ";
        os << argv[argc - 1] << " ]";

        string reqArgs{os.str()};

        cout << "\nSending '" << req << "' request " << os.str() << "..." << flush;
        auto pubmsg = mqtt::message_ptr_builder()
                          .topic(reqTopic)
                          .payload(reqArgs)
                          .qos(QOS)
                          .properties(props)
                          .finalize();

        cli.publish(pubmsg)->wait_for(TIMEOUT);
        cout << "OK" << endl;

        // Wait for reply.

        auto msg = cli.try_consume_message_for(seconds(5));
        if (!msg) {
            cerr << "Didn't receive a reply from the service." << endl;
            return 1;
        }

        cout << "  Result: " << msg->to_string() << endl;

        // Unsubscribe

        cli.unsubscribe(repTopic)->wait();

        // Disconnect
        cout << "\nDisconnecting..." << flush;
        cli.disconnect()->wait();
        cout << "OK" << endl;
    }
    catch (const mqtt::exception& exc) {
        cerr << exc.what() << endl;
        return 1;
    }

    return 0;
}

```

`examples/rpc_math_srvr.cpp`:

```cpp
// rpc_math_srvr.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// This application is an MQTT consumer/subscriber using the C++ synchronous
// client interface, which uses the queuing API to receive messages.
//
// The sample demonstrates:
//  - Connecting to an MQTT server/broker
//  - Subscribing to multiple topics
//  - Receiving messages through the queueing consumer API
//  - Receiving and acting upon commands via MQTT topics
//  - Manual reconnects
//  - Using a persistent (non-clean) session
//

/*******************************************************************************
 * Copyright (c) 2019-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <cctype>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <sstream>
#include <string>
#include <thread>

#include "mqtt/client.h"

using namespace std;
using namespace std::chrono;

const string SERVER_ADDRESS{"mqtt://localhost:1883"};
const string CLIENT_ID{"rpc_math_srvr"};

constexpr auto RESPONSE_TOPIC = mqtt::property::RESPONSE_TOPIC;
constexpr auto CORRELATION_DATA = mqtt::property::CORRELATION_DATA;

// --------------------------------------------------------------------------
// Simple function to manually reconnect a client.

bool try_reconnect(mqtt::client& cli)
{
    constexpr int N_ATTEMPT = 30;

    for (int i = 0; i < N_ATTEMPT && !cli.is_connected(); ++i) {
        try {
            cli.reconnect();
            return true;
        }
        catch (const mqtt::exception&) {
            this_thread::sleep_for(seconds(1));
        }
    }
    return false;
}

// --------------------------------------------------------------------------
// RPC function implementations

double add(const std::vector<double>& nums)
{
    double sum = 0.0;
    for (auto n : nums) sum += n;
    return sum;
}

double mult(const std::vector<double>& nums)
{
    double prod = 1.0;
    for (auto n : nums) prod *= n;
    return prod;
}

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    mqtt::client cli(SERVER_ADDRESS, CLIENT_ID);

    auto connOpts = mqtt::connect_options_builder::v5()
                        .keep_alive_interval(seconds(20))
                        .clean_start()
                        .finalize();

    const vector<string> TOPICS{"requests/math", "requests/math/#"};
    const vector<int> QOS{1, 1};

    try {
        cout << "Connecting to the MQTT server..." << flush;
        cli.connect(connOpts);
        cli.subscribe(TOPICS, QOS);
        cout << "OK\n" << endl;

        // Consume messages

        cout << "Waiting for RPC requests..." << endl;
        while (true) {
            auto msg = cli.consume_message();

            if (!msg) {
                if (!cli.is_connected()) {
                    cout << "Lost connection. Attempting reconnect" << endl;
                    if (try_reconnect(cli)) {
                        cli.subscribe(TOPICS, QOS);
                        cout << "Reconnected" << endl;
                        continue;
                    }
                    else {
                        cout << "Reconnect failed." << endl;
                        break;
                    }
                }
                else
                    break;
            }

            cout << "Received a request" << endl;

            const mqtt::properties& props = msg->get_properties();

            if (props.contains(RESPONSE_TOPIC) && props.contains(CORRELATION_DATA)) {
                mqtt::binary corr_id = mqtt::get<string>(props, CORRELATION_DATA);
                string reply_to = mqtt::get<string>(props, RESPONSE_TOPIC);

                cout << "Client wants a reply to [" << corr_id << "] on '" << reply_to << "'"
                     << endl;

                cout << msg->get_topic() << ": " << msg->to_string() << endl;

                char c;
                double x;
                vector<double> nums;

                istringstream is(msg->to_string());
                if (!(is >> c) || c != '[') {
                    cout << "Malformed arguments" << endl;
                    // Maybe send an error message to client.
                    continue;
                }

                c = ',';
                while (c == ',' && (is >> x >> c)) nums.push_back(x);

                if (c != ']') {
                    cout << "Bad closing delimiter" << endl;
                    continue;
                }

                x = 0.0;
                if (msg->get_topic() == "requests/math/add")
                    x = add(nums);
                else if (msg->get_topic() == "requests/math/mult")
                    x = mult(nums);
                else {
                    cout << "Unknown request: " << msg->get_topic() << endl;
                    continue;
                }

                cout << "  Result: " << x << endl;

                auto reply_msg = mqtt::message::create(reply_to, to_string(x), 1, false);
                cli.publish(reply_msg);
            }
        }

        // Disconnect

        cout << "\nDisconnecting from the MQTT server..." << flush;
        cli.disconnect();
        cout << "OK" << endl;
    }
    catch (const mqtt::exception& exc) {
        cerr << exc.what() << endl;
        return 1;
    }

    return 0;
}

```

`examples/server_props_v5.cpp`:

```cpp
// server_props_v5.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// This application is an MQTT client using the C++ asynchronous interface
// which shows how to check the server cofiguration for an MQTT v5
// connection.
//
// With an MQTT v5 connection, the server specify can some features that it
// doesn't supports, or limits in some way. It does this by adding v5
// properties to the CONNACK packet it sends back to the client in a connect
// transaction. The C++ application can retrieve these from the connect
// token via the `connect_response` object.
//
// It also shows short-lived persistent sessions. The client asks the server
// to just keep the session for 10sec. If you re-run the application in less
// than 10sec, it should report that the session exists. Any longer, and the
// session will be gone.
//
// Note that 10sec is probably *way too short* a time for real-world
// applications. This is just for demonstrating/testing the session expiry
// interval.
//
// The sample demonstrates:
//  - Connecting to an MQTT v5 server/broker.
//  - Specifying a short-lived (10sec) persistent session.
//  - Retrieving the v5 properties from the connect response (i.e. CONNACK
//    packet)
//  - Iterating through v5 properties.
//  - Displaying server properties to the user.
//

/*******************************************************************************
 * Copyright (c) 2013-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <cctype>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>

#include "mqtt/async_client.h"

using namespace std;

const string DFLT_SERVER_URI{"mqtt://localhost:1883"};
const string CLIENT_ID{"server_props_v5"};

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    auto serverURI = (argc > 1) ? string{argv[1]} : DFLT_SERVER_URI;

    mqtt::async_client cli(serverURI, CLIENT_ID);
    auto connOpts = mqtt::connect_options_builder::v5()
                        .clean_start(false)
                        .properties({{mqtt::property::SESSION_EXPIRY_INTERVAL, 10}})
                        .finalize();

    try {
        // Connect to the server

        cout << "Connecting to the MQTT server at '" << serverURI << "'..." << flush;
        auto tok = cli.connect(connOpts);

        // Getting the connect response will block waiting for the
        // connection to complete.
        auto rsp = tok->get_connect_response();
        cout << "OK" << endl;

        // Make sure we were granted a v5 connection.
        if (rsp.get_mqtt_version() < MQTTVERSION_5) {
            cout << "Did not get an MQTT v5 connection." << endl;
            exit(1);
        }

        // Does the server have a session for us?
        cout << "\nThe session is " << (rsp.is_session_present() ? "" : "not ")
             << "present on the server." << endl;

        // Show the v5 properties from the CONNACK, if any
        cout << "\nConnection Properties:" << endl;
        if (rsp.get_properties().empty()) {
            cout << "  <none>" << endl;
        }
        else {
            for (const auto& prop : rsp.get_properties()) {
                cout << "  " << prop << endl;
            }
        }

        // OK, we're done.
        cli.disconnect()->wait();
    }
    catch (const mqtt::exception& exc) {
        cerr << "\n  " << exc << endl;
        return 1;
    }

    return 0;
}

```

`examples/ssl_publish.cpp`:

```cpp
// ssl_publish.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// It's an example of how to connect to an MQTT broker securely, and then
// send messages as an MQTT publisher using the C++ asynchronous client
// interface.
//
// The sample demonstrates:
//  - Connecting to an MQTT server/broker securely
//  - Setting SSL/TLS options
//  - Last will and testament
//  - Publishing messages
//  - Using asynchronous tokens
//  - Implementing callbacks and action listeners
//
// We can test this using mosquitto configured with certificates in the
// Paho C library. The C library has an SSL/TSL test suite, and we can use
// that to test:
//     $ cd paho.mqtt.c
//     $ mosquitto -c test/tls-testing/mosquitto.conf
//
// Then use the files "test-root-ca.crt" and "client.pem" from the
// test/ssl directory (paho.mqtt.c/test/ssl) for the trust store and
// key_store, respectively, for this program.
//

/*******************************************************************************
 * Copyright (c) 2013-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <chrono>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <iostream>
#include <string>

#include "mqtt/async_client.h"

const std::string DFLT_SERVER_URI{"mqtts://localhost:18884"};
const std::string DFLT_CLIENT_ID{"ssl_publish_cpp"};

const std::string KEY_STORE{"client.pem"};
const std::string TRUST_STORE{"test-root-ca.crt"};

const std::string LWT_TOPIC{"events/disconnect"};
const std::string LWT_PAYLOAD{"Last will and testament."};

const int QOS = 1;
const auto TIMEOUT = std::chrono::seconds(10);

/////////////////////////////////////////////////////////////////////////////

/**
 * A callback class for use with the main MQTT client.
 */
class callback : public virtual mqtt::callback
{
public:
    void connection_lost(const std::string& cause) override
    {
        std::cout << "\nConnection lost" << std::endl;
        if (!cause.empty())
            std::cout << "\tcause: " << cause << std::endl;
    }

    void delivery_complete(mqtt::delivery_token_ptr tok) override
    {
        std::cout << "\tDelivery complete for token: " << (tok ? tok->get_message_id() : -1)
                  << std::endl;
    }
};

/////////////////////////////////////////////////////////////////////////////

using namespace std;

int main(int argc, char* argv[])
{
    string serverURI = (argc > 1) ? string{argv[1]} : DFLT_SERVER_URI,
           clientID = (argc > 2) ? string{argv[2]} : DFLT_CLIENT_ID;

    // Note that we don't actually need to open the trust or key stores.
    // We just need a quick, portable way to check that they exist.
    {
        ifstream tstore(TRUST_STORE);
        if (!tstore) {
            cerr << "The trust store file does not exist: " << TRUST_STORE << endl;
            cerr << "  Get a copy from \"paho.mqtt.c/test/ssl/test-root-ca.crt\"" << endl;
            ;
            return 1;
        }

        ifstream kstore(KEY_STORE);
        if (!kstore) {
            cerr << "The key store file does not exist: " << KEY_STORE << endl;
            cerr << "  Get a copy from \"paho.mqtt.c/test/ssl/client.pem\"" << endl;
            return 1;
        }
    }

    cout << "Initializing for server '" << serverURI << "'..." << endl;
    mqtt::async_client client(serverURI, clientID);

    callback cb;
    client.set_callback(cb);

    // Build the connect options, including SSL and a LWT message.

    auto sslopts = mqtt::ssl_options_builder()
                       .trust_store(TRUST_STORE)
                       .key_store(KEY_STORE)
                       .error_handler([](const std::string& msg) {
                           std::cerr << "SSL Error: " << msg << std::endl;
                       })
                       .finalize();

    auto willmsg = mqtt::message(LWT_TOPIC, LWT_PAYLOAD, QOS, true);

    auto connopts = mqtt::connect_options_builder()
                        .user_name("testuser")
                        .password("testpassword")
                        .will(std::move(willmsg))
                        .ssl(std::move(sslopts))
                        .finalize();

    cout << "  ...OK" << endl;

    try {
        // Connect using SSL/TLS

        cout << "\nConnecting..." << endl;
        mqtt::token_ptr conntok = client.connect(connopts);
        cout << "Waiting for the connection..." << endl;
        conntok->wait();
        cout << "  ...OK" << endl;

        // Send a message

        cout << "\nSending message..." << endl;
        auto msg = mqtt::make_message("hello", "Hello secure C++ world!", QOS, false);
        client.publish(msg)->wait_for(TIMEOUT);
        cout << "  ...OK" << endl;

        // Disconnect

        cout << "\nDisconnecting..." << endl;
        client.disconnect()->wait();
        cout << "  ...OK" << endl;
    }
    catch (const mqtt::exception& exc) {
        cerr << exc.what() << endl;
        return 1;
    }

    return 0;
}

```

`examples/sync_consume.cpp`:

```cpp
// sync_consume.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// This application is an MQTT consumer/subscriber using the C++ synchronous
// client interface, which uses the queuing API to receive messages.
//
// The sample demonstrates:
//  - Connecting to an MQTT server/broker
//  - Using a persistent (non-clean) session
//  - Subscribing to multiple topics
//  - Receiving messages through the queueing consumer API
//  - Receiving and acting upon commands via MQTT topics
//  - Auto reconnect
//  - Updating auto-reconnect data
//

/*******************************************************************************
 * Copyright (c) 2013-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <cctype>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>

#include "mqtt/client.h"

using namespace std;
using namespace std::chrono;

const string DFLT_SERVER_URI{"mqtt://localhost:1883"};
const string CLIENT_ID{"paho_cpp_sync_consume"};

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    auto serverURI = (argc > 1) ? std::string{argv[1]} : DFLT_SERVER_URI;

    mqtt::client cli(serverURI, CLIENT_ID);

    auto connOpts = mqtt::connect_options_builder::v3()
                        .user_name("user")
                        .password("passwd")
                        .keep_alive_interval(seconds(30))
                        .automatic_reconnect(seconds(2), seconds(30))
                        .clean_session(false)
                        .finalize();

    // You can install a callback to change some connection data
    // on auto reconnect attempts. To make a change, update the
    // `connect_data` and return 'true'.
    cli.set_update_connection_handler([](mqtt::connect_data& connData) {
        string newUserName{"newuser"};
        if (connData.get_user_name() == newUserName)
            return false;

        cout << "Previous user: '" << connData.get_user_name() << "'" << endl;
        connData.set_user_name(newUserName);
        cout << "New user name: '" << connData.get_user_name() << "'" << endl;
        return true;
    });

    const vector<string> TOPICS{"data/#", "command"};
    const vector<int> QOS{0, 1};

    try {
        cout << "Connecting to the MQTT server..." << flush;
        mqtt::connect_response rsp = cli.connect(connOpts);
        cout << "OK\n" << endl;

        if (!rsp.is_session_present()) {
            std::cout << "Subscribing to topics..." << std::flush;
            cli.subscribe(TOPICS, QOS);
            std::cout << "OK" << std::endl;
        }
        else {
            cout << "Session already present. Skipping subscribe." << std::endl;
        }

        // Consume messages

        while (true) {
            auto msg = cli.consume_message();

            if (msg) {
                if (msg->get_topic() == "command" && msg->to_string() == "exit") {
                    cout << "Exit command received" << endl;
                    break;
                }

                cout << msg->get_topic() << ": " << msg->to_string() << endl;
            }
            else if (!cli.is_connected()) {
                cout << "Lost connection" << endl;
                while (!cli.is_connected()) {
                    this_thread::sleep_for(milliseconds(250));
                }
                cout << "Re-established connection" << endl;
            }
        }

        // Disconnect

        cout << "\nDisconnecting from the MQTT server..." << flush;
        cli.disconnect();
        cout << "OK" << endl;
    }
    catch (const mqtt::exception& exc) {
        cerr << exc.what() << endl;
        return 1;
    }

    return 0;
}

```

`examples/sync_consume_v5.cpp`:

```cpp
// sync_consume_v5.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// This application is an MQTT consumer/subscriber using the C++ synchronous
// client interface, which uses the queuing API to receive messages.
//
// The sample demonstrates:
//  - Connecting to an MQTT server/broker
//  - Using a persistent (non-clean) session
//  - Subscribing to multiple topics
//  - Receiving messages through the queueing consumer API
//  - Receiving and acting upon commands via MQTT topics
//  - Auto reconnect
//  - Updating auto-reconnect data
//

/*******************************************************************************
 * Copyright (c) 2020-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <cctype>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iostream>
#include <string>
#include <thread>
#include <vector>

#include "mqtt/client.h"

using namespace std;
using namespace std::chrono;

const string DFLT_SERVER_URI{"mqtt://localhost:1883"};
const string CLIENT_ID{"paho_cpp_sync_consume5"};

constexpr int QOS_0 = 0;
constexpr int QOS_1 = 1;

// Infinite time for session expiration
const uint32_t INFINITE = std::numeric_limits<uint32_t>::max();

/////////////////////////////////////////////////////////////////////////////

// Message table function signature
using handler_t = std::function<bool(const mqtt::message&)>;

// Handler for data messages (i.e. topic "data/#")
bool data_handler(const mqtt::message& msg)
{
    cout << msg.get_topic() << ": " << msg.to_string() << endl;
    return true;
}

// Handler for command messages (i.e. topic "command")
// Return false to exit the application
bool command_handler(const mqtt::message& msg)
{
    if (msg.to_string() == "exit") {
        cout << "Exit command received" << endl;
        return false;
    }
    return true;
}

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    auto serverURI = (argc > 1) ? std::string{argv[1]} : DFLT_SERVER_URI;

    mqtt::client cli(serverURI, CLIENT_ID);

    auto connOpts = mqtt::connect_options_builder::v5()
                        .automatic_reconnect(seconds(2), seconds(30))
                        .clean_start(false)
                        .properties({{mqtt::property::SESSION_EXPIRY_INTERVAL, INFINITE}})
                        .finalize();

    // Dispatch table to handle incoming messages based on Subscription ID's.
    std::vector<handler_t> handler{data_handler, command_handler};

    try {
        cout << "Connecting to the MQTT server..." << flush;
        mqtt::connect_response rsp = cli.connect(connOpts);
        cout << "OK\n" << endl;

        if (!rsp.is_session_present()) {
            std::cout << "Subscribing to topics..." << std::flush;

            mqtt::subscribe_options subOpts;
            mqtt::properties props1{
                {mqtt::property::SUBSCRIPTION_IDENTIFIER, 1},
            };
            cli.subscribe("data/#", QOS_0, subOpts, props1);

            mqtt::properties props2{
                {mqtt::property::SUBSCRIPTION_IDENTIFIER, 2},
            };
            cli.subscribe("command", QOS_1, subOpts, props2);

            std::cout << "OK" << std::endl;
        }
        else {
            cout << "Session already present. Skipping subscribe." << std::endl;
        }

        // Consume messages

        while (true) {
            auto msg = cli.consume_message();

            // Note: In a real app, you'd want to do a lot more error
            // and bounds checking than this.

            if (msg) {
                // Get the subscription ID from the incoming message
                auto subId = mqtt::get<uint32_t>(
                    msg->get_properties(), mqtt::property::SUBSCRIPTION_IDENTIFIER
                );

                // Dispatch to a handler function based on the Subscription ID
                if (!(handler[subId - 1])(*msg))
                    break;
            }
            else if (!cli.is_connected()) {
                cout << "Lost connection" << endl;
                while (!cli.is_connected()) {
                    this_thread::sleep_for(milliseconds(250));
                }
                cout << "Re-established connection" << endl;
            }
        }

        // Disconnect

        cout << "\nDisconnecting from the MQTT server..." << flush;
        cli.disconnect();
        cout << "OK" << endl;
    }
    catch (const mqtt::exception& exc) {
        cerr << exc.what() << endl;
        return 1;
    }

    return 0;
}

```

`examples/sync_publish.cpp`:

```cpp
// sync_publish.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// It's an example of how to send messages as an MQTT publisher using the
// C++ synchronous client interface.
//
// The sample demonstrates:
//  - Connecting to an MQTT server/broker
//  - Publishing messages
//  - User-defined persistence
//

/*******************************************************************************
 * Copyright (c) 2013-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "mqtt/client.h"

const std::string DFLT_SERVER_URI{"mqtt://localhost:1883"};
const std::string TOPIC{"hello"};

const std::string PAYLOAD1{"Hello World!"};

const char* PAYLOAD2 = "Hi there!";
const char* PAYLOAD3 = "Is anyone listening?";

const int QOS = 1;

/////////////////////////////////////////////////////////////////////////////

// Example of a simple, in-memory persistence class.
//
// This is an extremely silly example, because if you want to use
// persistence, you actually need it to be out of process so that if the
// client crashes and restarts, the persistence data still exists.
//
// This is just here to show how the persistence API callbacks work. It maps
// well to key/value stores, like Redis, but only if it's on the local host,
// as it wouldn't make sense to persist data over the network, since that's
// what the MQTT client it trying to do.
//
class sample_mem_persistence : virtual public mqtt::iclient_persistence
{
    // Whether the store is open
    bool open_;

    // Use an STL map to store shared persistence pointers
    // against string keys.
    std::map<std::string, std::string> store_;

public:
    sample_mem_persistence() : open_(false) {}

    // "Open" the store
    void open(const std::string& clientId, const std::string& serverURI) override
    {
        std::cout << "  [Opening persistence store for '" << clientId << "' at '" << serverURI
                  << "']" << std::endl;
        open_ = true;
    }

    // Close the persistent store that was previously opened.
    void close() override
    {
        std::cout << "  [Closing persistence store.]" << std::endl;
        open_ = false;
    }

    // Clears persistence, so that it no longer contains any persisted data.
    void clear() override
    {
        std::cout << "  [Clearing persistence store.]" << std::endl;
        store_.clear();
    }

    // Returns whether or not data is persisted using the specified key.
    bool contains_key(const std::string& key) override
    {
        return store_.find(key) != store_.end();
    }

    // Returns the keys in this persistent data store.
    mqtt::string_collection keys() const override
    {
        mqtt::string_collection ks;
        for (const auto& k : store_) ks.push_back(k.first);
        return ks;
    }

    // Puts the specified data into the persistent store.
    void put(const std::string& key, const std::vector<mqtt::string_view>& bufs) override
    {
        std::cout << "  [Persisting data with key '" << key << "']" << std::endl;
        std::string str;
        for (const auto& b : bufs) str.append(b.data(), b.size());  // += b.str();
        store_[key] = std::move(str);
    }

    // Gets the specified data out of the persistent store.
    std::string get(const std::string& key) const override
    {
        std::cout << "  [Searching persistence for key '" << key << "']" << std::endl;
        auto p = store_.find(key);
        if (p == store_.end())
            throw mqtt::persistence_exception();
        std::cout << "  [Found persistence data for key '" << key << "']" << std::endl;

        return p->second;
    }

    // Remove the data for the specified key.
    void remove(const std::string& key) override
    {
        std::cout << "  [Persistence removing key '" << key << "']" << std::endl;
        auto p = store_.find(key);
        if (p == store_.end())
            throw mqtt::persistence_exception();
        store_.erase(p);
        std::cout << "  [Persistence key removed '" << key << "']" << std::endl;
    }
};

/////////////////////////////////////////////////////////////////////////////
// Class to receive callbacks

class user_callback : public virtual mqtt::callback
{
    void connection_lost(const std::string& cause) override
    {
        std::cout << "\nConnection lost" << std::endl;
        if (!cause.empty())
            std::cout << "\tcause: " << cause << std::endl;
    }

    void delivery_complete(mqtt::delivery_token_ptr tok) override
    {
        std::cout << "\n  [Delivery complete for token: "
                  << (tok ? tok->get_message_id() : -1) << "]" << std::endl;
    }

public:
};

// --------------------------------------------------------------------------

int main(int argc, char* argv[])
{
    auto serverURI = (argc > 1) ? std::string{argv[1]} : DFLT_SERVER_URI;

    std::cout << "Initializing..." << std::endl;
    sample_mem_persistence persist;
    mqtt::client client(serverURI, "", &persist);

    user_callback cb;
    client.set_callback(cb);

    mqtt::connect_options connOpts;
    connOpts.set_keep_alive_interval(20);
    connOpts.set_clean_session(true);
    std::cout << "...OK" << std::endl;

    try {
        std::cout << "\nConnecting..." << std::endl;
        client.connect(connOpts);
        std::cout << "...OK" << std::endl;

        // First use a message pointer.

        std::cout << "\nSending message..." << std::endl;
        auto pubmsg = mqtt::make_message(TOPIC, PAYLOAD1);
        pubmsg->set_qos(QOS);
        client.publish(pubmsg);
        std::cout << "...OK" << std::endl;

        // Now try with itemized publish.

        std::cout << "\nSending next message..." << std::endl;
        client.publish(TOPIC, PAYLOAD2, strlen(PAYLOAD2) + 1);
        std::cout << "...OK" << std::endl;

        // Now try with a listener, no token, and non-heap message

        std::cout << "\nSending final message..." << std::endl;
        client.publish(mqtt::message(TOPIC, PAYLOAD3, QOS, false));
        std::cout << "OK" << std::endl;

        // Disconnect
        std::cout << "\nDisconnecting..." << std::endl;
        client.disconnect();
        std::cout << "...OK" << std::endl;
    }
    catch (const mqtt::persistence_exception& exc) {
        std::cerr << "Persistence Error: " << exc.what() << " [" << exc.get_reason_code()
                  << "]" << std::endl;
        return 1;
    }
    catch (const mqtt::exception& exc) {
        std::cerr << exc.what() << std::endl;
        return 1;
    }

    std::cout << "\nExiting" << std::endl;
    return 0;
}

```

`examples/sync_reconnect.cpp`:

```cpp
// sync_reconnect.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// It's a fairly contrived, but useful example of an MQTT data monitor and
// publisher, using the C++ synchronous client interface. A fairly common
// usage for MQTT applications to stay offline for much of the time and only
// connect to the broker when there is data to send.
//
// Since we don't have a universal sensor to use for this example, we simply
// use time itself as out input data. We periodically "sample" the time
// value, connect, send the value, disconnect, and then sleep. In this case
// we use the system clock, measuring the time with millisecond precision.
//
// The sample demonstrates:
//  - The synchronous client
//  - Connecting to an MQTT server/broker
//  - Periodically reconnecting to the broker
//  - Publishing messages using a `topic` object
//  - Using `connect_options` with builder classes
//

/*******************************************************************************
 * Copyright (c) 2019-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <atomic>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>

#include "mqtt/client.h"

using namespace std;
using namespace std::chrono;

const std::string DFLT_SERVER_URI{"mqtt://localhost:1883"};

// The QoS for sending data
const int QOS = 1;

// How often to sample the "data"
const auto SAMPLE_PERIOD = seconds(5);

// --------------------------------------------------------------------------
// Gets the current time as the number of milliseconds since the epoch:
// like a time_t with ms resolution.

uint64_t timestamp()
{
    auto now = system_clock::now();
    auto tse = now.time_since_epoch();
    auto msTm = duration_cast<milliseconds>(tse);
    return uint64_t(msTm.count());
}

// --------------------------------------------------------------------------

int main(int argc, char* argv[])
{
    // The server URI (address)
    string serverURI = (argc > 1) ? string{argv[1]} : DFLT_SERVER_URI;

    // The amount of time to run (in sec). Zero means "run forever".
    uint64_t trun = (argc > 2) ? stoll(argv[2]) : 0LL;

    cout << "Initializing for server '" << serverURI << "'..." << endl;

    mqtt::client cli(serverURI, "");

    auto connOpts = mqtt::connect_options_builder().clean_session().finalize();

    cli.set_timeout(seconds(3));

    auto top = cli.get_topic("data/time", QOS);

    uint64_t t = timestamp(), tstart = t;

    try {
        // We need to connect once before we can use reconnect()
        cli.connect(connOpts);

        while (true) {
            cout << "\nCollecting data..." << endl;

            // Collect some data
            t = timestamp();

            if (!cli.is_connected()) {
                cout << "Reconnecting..." << endl;
                cli.reconnect();
            }

            cout << "Publishing data: " << t << "..." << endl;
            top.publish(to_string(t));

            cout << "Disconnecting..." << endl;
            cli.disconnect();

            // Quit if it's past time
            if (trun > 0 && t >= (trun + tstart))
                break;

            cout << "Going to sleep." << endl;
            this_thread::sleep_for(SAMPLE_PERIOD);
        }
    }
    catch (const mqtt::exception& exc) {
        cerr << exc << endl;
        return 1;
    }

    return 0;
}

```

`examples/topic_publish.cpp`:

```cpp
// topic_publish.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// It's an example of how to send messages as an MQTT publisher using the
// C++ asynchronous client interface using a 'topic' object to repeatedly
// send data to the same topic.
//
// The sample demonstrates:
//  - Connecting to an MQTT server/broker
//  - Publishing messages
//  - Use of the 'topic' class
//

/*******************************************************************************
 * Copyright (c) 2019-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <atomic>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>  // For sleep

#include "mqtt/async_client.h"

using namespace std;

const string DFLT_SERVER_URI{"mqtt://localhost:1883"};

const string TOPIC{"test"};
const int QOS = 1;

const char* PAYLOADS[] = {
    "Hello World!", "Hi there!", "Is anyone listening?", "Someone is always listening.",
    nullptr
};

const auto TIMEOUT = std::chrono::seconds(10);

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    string serverURI = (argc > 1) ? string(argv[1]) : DFLT_SERVER_URI;

    cout << "Initializing for server '" << serverURI << "'..." << endl;
    mqtt::async_client cli(serverURI, "");

    cout << "  ...OK" << endl;

    try {
        cout << "\nConnecting..." << endl;
        cli.connect()->wait();
        cout << "  ...OK" << endl;

        cout << "\nPublishing messages..." << endl;

        mqtt::topic top(cli, "test", QOS);
        mqtt::token_ptr tok;

        size_t i = 0;
        while (PAYLOADS[i]) {
            tok = top.publish(PAYLOADS[i++]);
        }
        tok->wait();  // Just wait for the last one to complete.
        cout << "OK" << endl;

        // Disconnect
        cout << "\nDisconnecting..." << endl;
        cli.disconnect()->wait();
        cout << "  ...OK" << endl;
    }
    catch (const mqtt::exception& exc) {
        cerr << exc << endl;
        return 1;
    }

    return 0;
}

```

`examples/ws_publish.cpp`:

```cpp
// ws_publish.cpp
//
// This is a Paho MQTT C++ client, sample application.
//
// It's an example of how to connect to an MQTT broker using websockets with
// an optional proxy.
//
// The sample demonstrates:
//  - Connecting to an MQTT server/broker using websockets
//  - Publishing messages
//  - Using asynchronous tokens
//
// This example requires a broker that is configured to accept websocket
// connections, and optionally, an HTTP proxy.
//

/*******************************************************************************
 * Copyright (c) 2020-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <chrono>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <iostream>
#include <string>

#include "mqtt/async_client.h"

// Assume a local server with websocket support on port 8080
const std::string DFLT_SERVER_URI{"ws://localhost:8080"};

// A local proxy, like squid on port 3128
// Here assuming basic authentication with user "user" and password "pass".
const std::string DFLT_PROXY_ADDRESS{"http://user:pass@localhost:3128"};

// Quality of service for this app.
const int QOS = 1;

// Timeout for publish to complete
const auto TIMEOUT = std::chrono::seconds(10);

using namespace std;

/////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
    string serverURI = (argc > 1) ? string{argv[1]} : DFLT_SERVER_URI,
           proxy = (argc > 2) ? string{argv[2]} : DFLT_PROXY_ADDRESS;

    cout << "Initializing for server '" << serverURI << "'..." << endl;
    if (!proxy.empty())
        cout << "    with proxy '" << proxy << "'" << endl;

    mqtt::async_client client(serverURI, "");

    // Build the connect options.

    auto connBuilder = mqtt::connect_options_builder::ws();

    if (!proxy.empty())
        connBuilder.http_proxy(proxy);

    auto connOpts = connBuilder.keep_alive_interval(std::chrono::seconds(45)).finalize();

    cout << "  ...OK" << endl;

    try {
        // Connect to the server

        cout << "\nConnecting..." << endl;
        client.connect(connOpts)->wait();
        cout << "  ...OK" << endl;

        // Send a message

        cout << "\nSending message..." << endl;
        auto msg = mqtt::make_message("hello", "Hello C++ websocket world!", QOS, false);
        bool ok = client.publish(msg)->wait_for(TIMEOUT);
        cout << "  ..." << (ok ? "OK" : "Error") << endl;

        // Disconnect

        cout << "\nDisconnecting..." << endl;
        client.disconnect()->wait();
        cout << "  ...OK" << endl;
    }
    catch (const mqtt::exception& exc) {
        cerr << exc.get_error_str() << endl;
        return 1;
    }

    return 0;
}

```

`fmt.sh`:

```sh
#!/bin/bash
#
# Runs clang format over the whole project tree, excluding
# the 'externals/' and 'build/' directories.
#

find . -type d \( -path './externals' -o -path './build' \) -prune -iname '*.h' -o -iname '*.cpp' | xargs clang-format -i


```

`include/mqtt/CMakeLists.txt`:

```txt
#*******************************************************************************
#  Copyright (c) 2016-2024  Frank Pagliughi <fpagliughi@mindspring.com>
# 
#  All rights reserved. This program and the accompanying materials
#  are made available under the terms of the Eclipse Public License v2.0
#  and Eclipse Distribution License v1.0 which accompany this distribution. 
# 
#  The Eclipse Public License is available at 
#     http://www.eclipse.org/legal/epl-v20.html
#  and the Eclipse Distribution License is available at 
#    http://www.eclipse.org/org/documents/edl-v10.php.
# 
#  Contributors:
#     Guilherme Maciel Ferreira - initial version
#     Frank Pagliughi - updates throughout
#*******************************************************************************/

install(
    FILES
        async_client.h
        buffer_ref.h
        buffer_view.h
        callback.h
        client.h
        connect_options.h
        create_options.h
        delivery_token.h
        disconnect_options.h
        event.h
        exception.h
        export.h
        iaction_listener.h
        iasync_client.h
        iclient_persistence.h
        message.h
        platform.h
        properties.h
        reason_code.h
        response_options.h
        server_response.h
        ssl_options.h
        string_collection.h
        subscribe_options.h
        thread_queue.h
        token.h
        topic_matcher.h
        topic.h
        types.h
        will_options.h
    DESTINATION 
        include/mqtt
)


```

`include/mqtt/async_client.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file async_client.h
/// Declaration of MQTT async_client class
/// @date May 1, 2013
/// @author Frank Pagliughi
///
/// @mainpage The Eclipse Paho MQTT Library for C++
///
/// @section Introduction
///
/// This is the Eclipse Paho MQTT Library for C++. It contains an MQTT
/// client for memory-managed operating systems like Windows, macOS, Linux,
/// and other *nix-style systems.
///
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2013-2025 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *    Frank Pagliughi - MQTT v5 support
 *******************************************************************************/

#ifndef __mqtt_async_client_h
#define __mqtt_async_client_h

#include <functional>
#include <list>
#include <memory>
#include <stdexcept>
#include <tuple>
#include <vector>

#include "MQTTAsync.h"
#include "mqtt/callback.h"
#include "mqtt/create_options.h"
#include "mqtt/delivery_token.h"
#include "mqtt/event.h"
#include "mqtt/exception.h"
#include "mqtt/iaction_listener.h"
#include "mqtt/iasync_client.h"
#include "mqtt/iclient_persistence.h"
#include "mqtt/message.h"
#include "mqtt/properties.h"
#include "mqtt/string_collection.h"
#include "mqtt/thread_queue.h"
#include "mqtt/token.h"
#include "mqtt/types.h"

namespace mqtt {

// OBSOLETE: The legacy constants that lacked the "PAHO_MQTTPP_" prefix
// clashed with #define's from other libraries and will be removed at the
// next major version upgrade.

#if defined(PAHO_MQTTPP_VERSIONS)
/** The version number for the client library. */
const uint32_t PAHO_MQTTPP_VERSION = 0x01050004;
/** The version string for the client library  */
const string PAHO_MQTTPP_VERSION_STR("Paho MQTT C++ (mqttpp) v. 1.5.4");
/** Copyright notice for the client library */
const string PAHO_MQTTPP_COPYRIGHT("Copyright (c) 2013-2025 Frank Pagliughi");
#else
/** The version number for the client library. */
const uint32_t VERSION = 0x01050004;
/** The version string for the client library  */
const string VERSION_STR("Paho MQTT C++ (mqttpp) v. 1.5.4");
/** Copyright notice for the client library */
const string COPYRIGHT("Copyright (c) 2013-2025 Frank Pagliughi");
#endif

/////////////////////////////////////////////////////////////////////////////

/**
 * Client for talking to an MQTT server using non-blocking
 * methods that allow an operation to run in the background.
 *
 * The location of the server is specified as a URI string with the
 * following schemas supported to specify the type and security used for the
 * connection:
 * @li @em "mqtt://" - A standard (insecure) connection over TCP. (Also,
 * "tcp://")
 * @li @em "mqtts://" - A secure connection using SSL/TLS sockets. (Also
 * "ssl://")
 * @li @em "ws://" - A standard (insecure) WebSocket connection.
 * @li @em "wss:// - A secure websocket connection using SSL/TLS.
 * @li @em "unix://" - A UNIX-domain connection on the local machine. (*nix
 * systems, only)
 *
 * The secure connection types assume that the library was built with
 * SSL/TLS support, otherwise requesting a secure connection will result in
 * an error.
 *
 * The communication methods of this class - `connect()`, `publish()`,
 * `subscribe()`, etc. - are all asynchronous. They create the request for
 * the server, but return immediately, before a response is received back
 * from the server.
 *
 * These methods return a `token` to the caller which is akin to a C++
 * std::future. The caller can keep the Token, then use it later to block
 * until the asynchronous operation is complete and retrieve the result of
 * the operation, including any response from the server.
 *
 * Alternately, the application can choose to set callbacks to be fired when
 * each operation completes. This can be used to create an event-driven
 * architecture, but is more complex in that it forces the user to avoid any
 * blocking operations and manually handle thread synchronization (since
 * the callbacks run in a separate thread managed by the library).
 *
 * Note that the numerous constructors pre-date the current, expansive,
 * `create_options` structure. For a full set of create options, a
 * builder can be used to specify the full set of options, then construct
 * the client with those options, like this:
 *
 * @code
 *     auto createOpts = mqtt::create_options_builder()
 *                        .server_uri(serverURI)
 *                        .send_while_disconnected()
 *                        .max_buffered_messages(25)
 *                        .delete_oldest_messages()
 *                        .finalize();
 *
 *     mqtt::async_client cli(createOpts);
 * @endcode
 */
class async_client : public virtual iasync_client
{
public:
    /** Smart/shared pointer for an object of this class */
    using ptr_t = std::shared_ptr<async_client>;
    /** Type for a thread-safe queue to consume events synchronously */
    using consumer_queue_type = std::unique_ptr<thread_queue<event>>;

    /** Handler type for registering an individual message callback */
    using message_handler = std::function<void(const_message_ptr)>;
    /** Handler type for when a connection is made or lost */
    using connection_handler = std::function<void(const string& cause)>;
    /** Handler type for when a disconnect packet is received */
    using disconnected_handler = std::function<void(const properties&, ReasonCode)>;
    /** Handler for updating connection data before an auto-reconnect. */
    using update_connection_handler = std::function<bool(connect_data&)>;

private:
    /** Lock guard type for this class */
    using guard = std::unique_lock<std::mutex>;
    /** Unique lock type for this class */
    using unique_lock = std::unique_lock<std::mutex>;

    /** Object monitor mutex */
    mutable std::mutex lock_;
    /** The underlying C-lib client. */
    MQTTAsync cli_;
    /** The options used to create the client */
    const create_options createOpts_;
    /** The MQTT protocol version of the connection */
    int mqttVersion_;
    /** A user persistence wrapper (if any) */
    std::unique_ptr<MQTTClient_persistence> persist_{};
    /** Callback supplied by the user (if any) */
    callback* userCallback_{};
    /** Connection handler */
    connection_handler connHandler_;
    /** Connection lost handler */
    connection_handler connLostHandler_;
    /** Disconnected handler */
    disconnected_handler disconnectedHandler_;
    /** Update connect data/options */
    update_connection_handler updateConnectionHandler_;
    /** Message handler */
    message_handler msgHandler_;
    /** Cached options from the last connect */
    connect_options connOpts_;
    /** Copy of connect token (for re-connects) */
    token_ptr connTok_;
    /** A list of tokens that are in play */
    std::list<token_ptr> pendingTokens_;
    /** A list of delivery tokens that are in play */
    std::list<delivery_token_ptr> pendingDeliveryTokens_;
    /** A queue of messages for consumer API */
    consumer_queue_type que_;

    /** Callbacks from the C library */
    static void on_connected(void* context, char* cause);
    static void on_connection_lost(void* context, char* cause);
    static void on_disconnected(
        void* context, MQTTProperties* cprops, MQTTReasonCodes reasonCode
    );
    static int on_message_arrived(
        void* context, char* topicName, int topicLen, MQTTAsync_message* msg
    );
    static void on_delivery_complete(void* context, MQTTAsync_token tok);
    static int on_update_connection(void* context, MQTTAsync_connectData* cdata);

    /** Manage internal list of active tokens */
    friend class token;
    virtual void add_token(token_ptr tok);
    virtual void add_token(delivery_token_ptr tok);
    virtual void remove_token(token* tok) override;
    virtual void remove_token(token_ptr tok) { remove_token(tok.get()); }
    void remove_token(delivery_token_ptr tok) { remove_token(tok.get()); }

    /** Non-copyable */
    async_client() = delete;
    async_client(const async_client&) = delete;
    async_client& operator=(const async_client&) = delete;

    /** Checks a function return code and throws on error. */
    static void check_ret(int rc) {
        if (rc != MQTTASYNC_SUCCESS)
            throw exception(rc);
    }
    /**
     * Create an async_client that can be used to communicate with an MQTT
     * server, which allows for off-line message buffering.
     * This allows the caller to specify a user-defined persistence object,
     * or use no persistence.
     * @throw exception if an argument is invalid
     */
    void create();

public:
    /**
     * Create an async_client that can be used to communicate with an MQTT
     * server.
     * This uses file-based persistence in the specified directory.
     * @param serverURI the address of the server to connect to, specified
     *  				as a URI.
     * @param clientId a client identifier that is unique on the server
     *  			   being connected to
     * @param persistence The persistence that the client should use.
     * @throw exception if an argument is invalid
     */
    explicit async_client(
        const string& serverURI, const string& clientId = string{},
        const persistence_type& persistence = NO_PERSISTENCE
    )
        : createOpts_{serverURI, clientId, persistence} {
        create();
    }
    /**
     * Create an async_client that can be used to communicate with an MQTT
     * server, which allows for off-line message buffering.
     * This uses file-based persistence in the specified directory.
     * @param serverURI the address of the server to connect to, specified
     *  				as a URI.
     * @param clientId a client identifier that is unique on the server
     *  			   being connected to
     * @param maxBufferedMessages the maximum number of messages allowed to
     *  						  be buffered while not connected
     * @param persistence The persistence that the client should use.
     * @throw exception if an argument is invalid
     */
    async_client(
        const string& serverURI, const string& clientId, int maxBufferedMessages,
        const persistence_type& persistence = NO_PERSISTENCE
    )
        : createOpts_{serverURI, clientId, maxBufferedMessages, persistence} {
        create();
    }
    /**
     * Create an async_client that can be used to communicate with an MQTT
     * server, which allows for off-line message buffering.
     * This uses file-based persistence in the specified directory.
     * @param serverURI the address of the server to connect to, specified
     *  				as a URI.
     * @param clientId a client identifier that is unique on the server
     *  			   being connected to
     * @param opts The create options
     * @param persistence The persistence that the client should use.
     * @throw exception if an argument is invalid
     */
    async_client(
        const string& serverURI, const string& clientId, const create_options& opts,
        const persistence_type& persistence = NO_PERSISTENCE
    )
        : createOpts_{serverURI, clientId, opts, persistence} {
        create();
    }
    /**
     * Create an async_client that can be used to communicate with an MQTT
     * server, which allows for off-line message buffering.
     * This allows the caller to specify a user-defined persistence object,
     * or use no persistence.
     * @param opts The create options
     * @throw exception if an argument is invalid
     */
    async_client(const create_options& opts) : createOpts_{opts} { create(); }
    /**
     * Destructor
     */
    ~async_client() override;
    /**
     * Sets a callback listener to use for events that happen
     * asynchronously.
     * @param cb callback receiver which will be invoked for certain
     *  		 asynchronous events
     */
    void set_callback(callback& cb) override;
    /**
     * Stops callbacks.
     * This is not normally called by the application. It should be used
     * cautiously as it may cause the application to lose messages.
     */
    void disable_callbacks() override;
    /**
     * Callback for when a connection is made.
     * @param cb Callback functor for when the connection is made.
     */
    void set_connected_handler(connection_handler cb) /*override*/;
    /**
     * Callback for when a connection is lost.
     * @param cb Callback functor for when the connection is lost.
     */
    void set_connection_lost_handler(connection_handler cb) /*override*/;
    /**
     * Callback for when a disconnect packet is received from the server.
     * @param cb Callback for when the disconnect packet is received.
     */
    void set_disconnected_handler(disconnected_handler cb) /*override*/;
    /**
     * Sets the callback for when a message arrives from the broker.
     * Note that the application can only have one message handler which can
     * be installed individually using this method, or installled as a
     * listener object.
     * @param cb The callback functor to register with the library.
     */
    void set_message_callback(message_handler cb) /*override*/;
    /**
     * Sets a callback to allow the application to update the connection
     * data on automatic reconnects.
     * @param cb The callback functor to register with the library.
     */
    void set_update_connection_handler(update_connection_handler cb);
    /**
     * Connects to an MQTT server using the default options.
     * @return token used to track and wait for the connect to complete. The
     *  	   token will be passed to any callback that has been set.
     * @throw exception for non security related problems
     * @throw security_exception for security related problems
     */
    token_ptr connect() override;
    /**
     * Connects to an MQTT server using the provided connect options.
     * @param options a set of connection parameters that override the
     *  			  defaults.
     * @return token used to track and wait for the connect to complete. The
     *  	   token will be passed to any callback that has been set.
     * @throw exception for non security related problems
     * @throw security_exception for security related problems
     */
    token_ptr connect(connect_options options) override;
    /**
     * Connects to an MQTT server using the specified options.
     * @param options a set of connection parameters that override the
     *  			  defaults.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb callback listener that will be notified when the connect
     *  			   completes.
     * @return token used to track and wait for the connect to complete. The
     *  	   token will be passed to any callback that has been set.
     * @throw exception for non security related problems
     * @throw security_exception for security related problems
     */
    token_ptr connect(
        connect_options options, void* userContext, iaction_listener& cb
    ) override;
    /**
     *
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb callback listener that will be notified when the connect
     *  			   completes.
     * @return token used to track and wait for the connect to complete. The
     *  	   token will be passed to any callback that has been set.
     * @throw exception for non security related problems
     * @throw security_exception for security related problems
     */
    token_ptr connect(void* userContext, iaction_listener& cb) override {
        return connect(connect_options{}, userContext, cb);
    }
    /**
     * Reconnects the client using options from the previous connect.
     * The client must have previously called connect() for this to work.
     * @return token used to track the progress of the reconnect.
     */
    token_ptr reconnect() override;
    /**
     * Disconnects from the server.
     * @return token used to track and wait for the disconnect to complete.
     *  	   The token will be passed to any callback that has been set.
     * @throw exception for problems encountered while disconnecting
     */
    token_ptr disconnect() override { return disconnect(disconnect_options()); }
    /**
     * Disconnects from the server.
     * @param opts Options for disconnecting.
     * @return token used to track and wait for the disconnect to complete.
     *  	   The token will be passed to any callback that has been set.
     * @throw exception for problems encountered while disconnecting
     */
    token_ptr disconnect(disconnect_options opts) override;
    /**
     * Disconnects from the server.
     * @param timeout the amount of time in milliseconds to allow for
     *  			  existing work to finish before disconnecting. A value
     *  			  of zero or less means the client will not quiesce.
     * @return Token used to track and wait for disconnect to complete. The
     *  	   token will be passed to the callback methods if a callback is
     *  	   set.
     * @throw exception for problems encountered while disconnecting
     */
    token_ptr disconnect(int timeout) override {
        return disconnect(disconnect_options(timeout));
    }
    /**
     * Disconnects from the server.
     * @param timeout the amount of time in milliseconds to allow for
     *  			  existing work to finish before disconnecting. A value
     *  			  of zero or less means the client will not quiesce.
     * @return Token used to track and wait for disconnect to complete. The
     *  	   token will be passed to the callback methods if a callback is
     *  	   set.
     * @throw exception for problems encountered while disconnecting
     */
    template <class Rep, class Period>
    token_ptr disconnect(const std::chrono::duration<Rep, Period>& timeout) {
        // TODO: check range
        return disconnect((int)to_milliseconds_count(timeout));
    }
    /**
     * Disconnects from the server.
     * @param timeout the amount of time in milliseconds to allow for
     *  			  existing work to finish before disconnecting. A value
     *  			  of zero or less means the client will not quiesce.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb callback listener that will be notified when the disconnect
     *  			   completes.
     * @return token_ptr Token used to track and wait for disconnect to
     *  	   complete. The token will be passed to the callback methods if
     *  	   a callback is set.
     * @throw exception for problems encountered while disconnecting
     */
    token_ptr disconnect(int timeout, void* userContext, iaction_listener& cb) override;
    /**
     * Disconnects from the server.
     * @param timeout the amount of time in milliseconds to allow for
     *  			  existing work to finish before disconnecting. A value
     *  			  of zero or less means the client will not quiesce.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb callback listener that will be notified when the disconnect
     *  			   completes.
     * @return token_ptr Token used to track and wait for disconnect to
     *  	   complete. The token will be passed to the callback methods if
     *  	   a callback is set.
     * @throw exception for problems encountered while disconnecting
     */
    template <class Rep, class Period>
    token_ptr disconnect(
        const std::chrono::duration<Rep, Period>& timeout, void* userContext,
        iaction_listener& cb
    ) {
        // TODO: check range
        return disconnect((int)to_milliseconds_count(timeout), userContext, cb);
    }
    /**
     * Disconnects from the server.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb callback listener that will be notified when the disconnect
     *  			   completes.
     * @return token_ptr Token used to track and wait for disconnect to
     *  	   complete. The token will be passed to the callback methods if
     *  	   a callback is set.
     * @throw exception for problems encountered while disconnecting
     */
    token_ptr disconnect(void* userContext, iaction_listener& cb) override {
        return disconnect(0L, userContext, cb);
    }
    /**
     * Returns the delivery token for the specified message ID.
     * @return delivery_token
     */
    delivery_token_ptr get_pending_delivery_token(int msgID) const override;
    /**
     * Returns the delivery tokens for any outstanding publish operations.
     * @return delivery_token[]
     */
    std::vector<delivery_token_ptr> get_pending_delivery_tokens() const override;
    /**
     * Returns the client ID used by this client.
     * @return The client ID used by this client.
     */
    string get_client_id() const override { return createOpts_.get_client_id(); }
    /**
     * Returns the address of the server used by this client.
     * @return The server's address, as a URI String.
     */
    string get_server_uri() const override { return createOpts_.get_server_uri(); }
    /**
     * Gets the MQTT version used by the client.
     * @return The MQTT version used by the client
     *   @li MQTTVERSION_DEFAULT (0) = default: start with 3.1.1, and if
     *       that fails, fall back to 3.1
     *   @li MQTTVERSION_3_1 (3) = only try version 3.1
     *   @li MQTTVERSION_3_1_1 (4) = only try version 3.1.1
     *   @li MQTTVERSION_5 (5) = only try version 5
     */
    int mqtt_version() const noexcept { return mqttVersion_; }
    /**
     * Gets a copy of the connect options that were last used in a request
     * to connect to the broker.
     * @returns The last connect options that were used.
     */
    connect_options get_connect_options() const {
        guard g(lock_);
        return connOpts_;
    }
    /**
     * Determines if this client is currently connected to the server.
     * @return true if connected, false otherwise.
     */
    bool is_connected() const override { return to_bool(MQTTAsync_isConnected(cli_)); }
    /**
     * Publishes a message to a topic on the server
     * @param topic The topic to deliver the message to
     * @param payload the bytes to use as the message payload
     * @param n the number of bytes in the payload
     * @param qos the Quality of Service to deliver the message at. Valid
     *  		  values are 0, 1 or 2.
     * @param retained whether or not this message should be retained by the
     *  			   server.
     * @return token used to track and wait for the publish to complete. The
     *  	   token will be passed to callback methods if set.
     */
    delivery_token_ptr publish(
        string_ref topic, const void* payload, size_t n, int qos, bool retained,
        const properties& props = properties()
    ) override;
    /**
     * Publishes a message to a topic on the server
     * @param topic The topic to deliver the message to
     * @param payload the bytes to use as the message payload
     * @param n the number of bytes in the payload
     * @return token used to track and wait for the publish to complete. The
     *  	   token will be passed to callback methods if set.
     */
    delivery_token_ptr publish(string_ref topic, const void* payload, size_t n) override {
        return publish(
            std::move(topic), payload, n, message::DFLT_QOS, message::DFLT_RETAINED
        );
    }
    /**
     * Publishes a message to a topic on the server
     * @param topic The topic to deliver the message to
     * @param payload the bytes to use as the message payload
     * @param qos the Quality of Service to deliver the message at. Valid
     *  		  values are 0, 1 or 2.
     * @param retained whether or not this message should be retained by the
     *  			   server.
     * @return token used to track and wait for the publish to complete. The
     *  	   token will be passed to callback methods if set.
     */
    delivery_token_ptr publish(
        string_ref topic, binary_ref payload, int qos, bool retained,
        const properties& props = properties()
    ) override;
    /**
     * Publishes a message to a topic on the server
     * @param topic The topic to deliver the message to
     * @param payload the bytes to use as the message payload
     * @return token used to track and wait for the publish to complete. The
     *  	   token will be passed to callback methods if set.
     */
    delivery_token_ptr publish(string_ref topic, binary_ref payload) override {
        return publish(
            std::move(topic), std::move(payload), message::DFLT_QOS, message::DFLT_RETAINED
        );
    }
    /**
     * Publishes a message to a topic on the server
     * @param topic The topic to deliver the message to
     * @param payload the bytes to use as the message payload
     * @param n the number of bytes in the payload
     * @param qos the Quality of Service to deliver the message at. Valid
     *  		  values are 0, 1 or 2.
     * @param retained whether or not this message should be retained by the
     *  			   server.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb Listener callback object
     * @return token used to track and wait for the publish to complete. The
     *  	   token will be passed to callback methods if set.
     */
    delivery_token_ptr publish(
        string_ref topic, const void* payload, size_t n, int qos, bool retained,
        void* userContext, iaction_listener& cb
    ) override;
    /**
     * Publishes a message to a topic on the server Takes an Message
     * message and delivers it to the server at the requested quality of
     * service.
     * @param msg the message to deliver to the server
     * @return token used to track and wait for the publish to complete. The
     *  	   token will be passed to callback methods if set.
     */
    delivery_token_ptr publish(const_message_ptr msg) override;
    /**
     * Publishes a message to a topic on the server.
     * @param msg the message to deliver to the server
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb callback optional listener that will be notified when message
     *  			   delivery has completed to the requested quality of
     *  			   service
     * @return token used to track and wait for the publish to complete. The
     *  	   token will be passed to callback methods if set.
     */
    delivery_token_ptr publish(
        const_message_ptr msg, void* userContext, iaction_listener& cb
    ) override;
    /**
     * Subscribe to a topic, which may include wildcards.
     * @param topicFilter the topic to subscribe to, which can include
     *  				  wildcards.
     * @param qos The quality of service for the subscription
     * @param opts The MQTT v5 subscribe options for the topic
     * @param props The MQTT v5 properties.
     * @return token used to track and wait for the subscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    token_ptr subscribe(
        const string& topicFilter, int qos,
        const subscribe_options& opts = subscribe_options(),
        const properties& props = properties()
    ) override;
    /**
     * Subscribe to a topic, which may include wildcards.
     * @param topicFilter the topic to subscribe to, which can include
     *  				  wildcards.
     * @param qos The maximum quality of service at which to subscribe.
     *  		  Messages published at a lower quality of service will be
     *  		  received at the published QoS. Messages published at a
     *  		  higher quality of service will be received using the QoS
     *  		  specified on the subscribe.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb listener that will be notified when subscribe has completed
     * @param opts The MQTT v5 subscribe options for the topic
     * @param props The MQTT v5 properties.
     * @return token used to track and wait for the subscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    token_ptr subscribe(
        const string& topicFilter, int qos, void* userContext, iaction_listener& cb,
        const subscribe_options& opts = subscribe_options(),
        const properties& props = properties()
    ) override;
    /**
     * Subscribe to multiple topics, each of which may include wildcards.
     * @param topicFilters The collection of topic filters to subscribe to,
     *                     any of which can include wildcards
     * @param qos The maximum quality of service at which to subscribe.
     *  		  Messages published at a lower quality of service will be
     *  		  received at the published QoS. Messages published at a
     *  		  higher quality of service will be received using the QoS
     *  		  specified on the subscribe.
     * @param opts The MQTT v5 subscribe options (one for each topic)
     * @param props The MQTT v5 properties.
     * @return token used to track and wait for the subscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    token_ptr subscribe(
        const_string_collection_ptr topicFilters, const qos_collection& qos,
        const std::vector<subscribe_options>& opts = std::vector<subscribe_options>(),
        const properties& props = properties()
    ) override;
    /**
     * Subscribes to multiple topics, each of which may include wildcards.
     * @param topicFilters The collection of topic filters to subscribe to,
     *                     any of which can include wildcards
     * @param qos The maximum quality of service at which to subscribe.
     *  		  Messages published at a lower quality of service will be
     *  		  received at the published QoS. Messages published at a
     *  		  higher quality of service will be received using the QoS
     *  		  specified on the subscribe.
     * @param userContext Optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb listener that will be notified when subscribe has completed
     * @param opts The MQTT v5 subscribe options (one for each topic)
     * @param props The MQTT v5 properties.
     * @return token used to track and wait for the subscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    token_ptr subscribe(
        const_string_collection_ptr topicFilters, const qos_collection& qos,
        void* userContext, iaction_listener& cb,
        const std::vector<subscribe_options>& opts = std::vector<subscribe_options>(),
        const properties& props = properties()
    ) override;
    /**
     * Requests the server unsubscribe the client from a topic.
     * @param topicFilter The topic to unsubscribe from. It must match a
     *  				  topicFilter specified on an earlier subscribe.
     * @param props The MQTT v5 properties.
     * @return token Used to track and wait for the unsubscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    token_ptr unsubscribe(
        const string& topicFilter, const properties& props = properties()
    ) override;
    /**
     * Requests the server unsubscribe the client from one or more topics.
     * @param topicFilters One or more topics to unsubscribe from. Each
     *  				   topicFilter must match one specified on an
     *  				   earlier subscribe.
     * @param props The MQTT v5 properties.
     * @return token used to track and wait for the unsubscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    token_ptr unsubscribe(
        const_string_collection_ptr topicFilters, const properties& props = properties()
    ) override;
    /**
     * Requests the server unsubscribe the client from one or more topics.
     * @param topicFilters One or more topics to unsubscribe from. Each
     *  				   topicFilter must match one specified on an
     *  				   earlier subscribe.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb listener that will be notified when unsubscribe has
     *  		 completed
     * @param props The MQTT v5 properties.
     * @return token used to track and wait for the unsubscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    token_ptr unsubscribe(
        const_string_collection_ptr topicFilters, void* userContext, iaction_listener& cb,
        const properties& props = properties()
    ) override;
    /**
     * Requests the server unsubscribe the client from a topics.
     * @param topicFilter the topic to unsubscribe from. It must match a
     *  				  topicFilter specified on an earlier subscribe.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb listener that will be notified when unsubscribe has
     *  		 completed
     * @param props The MQTT v5 properties.
     * @return token used to track and wait for the unsubscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    token_ptr unsubscribe(
        const string& topicFilter, void* userContext, iaction_listener& cb,
        const properties& props = properties()
    ) override;
    /**
     * Start consuming messages.
     *
     * This initializes the client to receive messages through a queue that
     * can be read synchronously.
     *
     * Normally this should be called _before_ connecting the client to the
     * broker, in order to have the consumer queue in place in the event
     * that the immediately starts sending messages (such as any retained
     * messages) while the client is still in the context of the connect
     * call.
     *
     * This _must_ also be called before calling any 'consume_message' or
     * "'consume_event' methods.
     *
     * Internally, this just creates a thread-safe queue for `mqtt::event`
     * objects, then hooks into the message and state-change callback to
     * push events into the queue in the order received.
     */
    void start_consuming() override;
    /**
     * Stop consuming messages.
     *
     * This shuts down the internal callback and closes the internal
     * consumer queue. Any remaining messages and events can be read until
     * the queue is emptied, but nothing further will be added to it.
     * This will also wake up any thread waiting on the queue.
     */
    void stop_consuming() override;
    /**
     * This clears the consumer queue, discarding any pending event.
     */
    void clear_consumer() override {
        if (que_)
            que_->clear();
    }
    /**
     * Determines if the consumer queue has been closed.
     * Once closed, any events in the queue can still be read, but no new
     * events can be added to it.
     * @return @true if the consumer queue has been closed, @false
     *         otherwise.
     */
    bool consumer_closed() noexcept override { return !que_ || que_->closed(); }
    /**
     * Determines if the consumer queue is "done" (closed and empty).
     * Once the queue is done, no more events can be added or removed from
     * the queue.
     * @return @true if the consumer queue is closed and empty, @false
     *         otherwise.
     */
    bool consumer_done() noexcept override { return !que_ || que_->done(); }
    /**
     * Gets the number of events available for immediate consumption.
     * Note that this retrieves the number of "raw" events, not messages,
     * e.g. may include a connected_event which is not returned by try_consume_message().
     * When polling the queue from multiple threads, prefer using try_consume_event(),
     * as the event count may change between checking the size and actual retrieval.
     * @return the number of events in the queue.
     */
    std::size_t consumer_queue_size() const override { return (que_) ? que_->size() : 0; }
    /**
     * Read the next client event from the queue.
     * This blocks until a new message arrives.
     * If the consumer queue is closed, this returns a shutdown event.
     * @return The client event.
     */
    event consume_event() override;
    /**
     * Try to read the next client event without blocking.
     * @param evt Pointer to the value to receive the event
     * @return @em true if an event was read, @em false if no
     *  	   event was available.
     */
    bool try_consume_event(event* evt) override;
    /**
     * Waits a limited time for a client event to appear.
     * @param evt Pointer to the value to receive the event.
     * @param relTime The maximum amount of time to wait for an event.
     * @return @em true if an event was read, @em false if a timeout
     *  	   occurred.
     */
    template <typename Rep, class Period>
    bool try_consume_event_for(
        event* evt, const std::chrono::duration<Rep, Period>& relTime
    ) {
        if (!que_)
            throw mqtt::exception(-1, "Consumer not started");

        try {
            return que_->try_get_for(evt, relTime);
        }
        catch (queue_closed&) {
            *evt = event{shutdown_event{}};
            return true;
        }
    }
    /**
     * Waits a limited time for a client event to arrive.
     * @param relTime The maximum amount of time to wait for an event.
     * @return The event that was received. It will contain empty message on
     *  	   timeout.
     */
    template <typename Rep, class Period>
    event try_consume_event_for(const std::chrono::duration<Rep, Period>& relTime) {
        event evt;
        try {
            que_->try_get_for(&evt, relTime);
        }
        catch (queue_closed&) {
            evt = event{shutdown_event{}};
        }
        return evt;
    }
    /**
     * Waits until a specific time for a client event to appear.
     * @param evt Pointer to the value to receive the event.
     * @param absTime The time point to wait until, before timing out.
     * @return @em true if an event was recceived, @em false if a timeout
     *  	   occurred.
     */
    template <class Clock, class Duration>
    bool try_consume_event_until(
        event* evt, const std::chrono::time_point<Clock, Duration>& absTime
    ) {
        if (!que_)
            throw mqtt::exception(-1, "Consumer not started");

        try {
            return que_->try_get_until(evt, absTime);
        }
        catch (queue_closed&) {
            *evt = event{shutdown_event{}};
            return true;
        }
    }
    /**
     * Waits until a specific time for a client event to appear.
     * @param absTime The time point to wait until, before timing out.
     * @return The event that was received. It will contain empty message on
     *  	   timeout.
     */
    template <class Clock, class Duration>
    event try_consume_event_until(const std::chrono::time_point<Clock, Duration>& absTime) {
        event evt;
        try {
            que_->try_get_until(&evt, absTime);
        }
        catch (queue_closed&) {
            evt = event{shutdown_event{}};
        }
        return evt;
    }
    /**
     * Read the next message from the queue.
     * This blocks until a new message arrives or until a disconnect or
     * shutdown occurs.
     * @return The message and topic.
     */
    const_message_ptr consume_message() override;
    /**
     * Try to read the next message from the queue without blocking.
     * @param msg Pointer to the value to receive the message
     * @return @em true is a message was read, @em false if no message was
     *  	   available.
     */
    bool try_consume_message(const_message_ptr* msg) override;
    /**
     * Waits a limited time for a message to arrive.
     * @param msg Pointer to the value to receive the message
     * @param relTime The maximum amount of time to wait for a message.
     * @return @em true if a message was read, @em false if a timeout
     *  	   occurred.
     */
    template <typename Rep, class Period>
    bool try_consume_message_for(
        const_message_ptr* msg, const std::chrono::duration<Rep, Period>& relTime
    ) {
        if (!que_)
            throw mqtt::exception(-1, "Consumer not started");

        event evt;

        while (true) {
            if (!try_consume_event_for(&evt, relTime))
                return false;

            if (const auto* pval = evt.get_message_if()) {
                *msg = std::move(*pval);
                break;
            }

            if (evt.is_any_disconnect()) {
                *msg = const_message_ptr{};
                break;
            }
        }
        return true;
    }
    /**
     * Waits a limited time for a message to arrive.
     * @param relTime The maximum amount of time to wait for a message.
     * @return A shared pointer to the message that was received. It will be
     *  	   empty on timeout.
     */
    template <typename Rep, class Period>
    const_message_ptr try_consume_message_for(
        const std::chrono::duration<Rep, Period>& relTime
    ) {
        const_message_ptr msg;
        this->try_consume_message_for(&msg, relTime);
        return msg;
    }
    /**
     * Waits until a specific time for a message to appear.
     * @param msg Pointer to the value to receive the message
     * @param absTime The time point to wait until, before timing out.
     * @return @em true if a message was read, @em false if a timeout
     *  	   occurred.
     */
    template <class Clock, class Duration>
    bool try_consume_message_until(
        const_message_ptr* msg, const std::chrono::time_point<Clock, Duration>& absTime
    ) {
        if (!que_)
            throw mqtt::exception(-1, "Consumer not started");

        event evt;

        while (true) {
            if (!try_consume_event_until(&evt, absTime))
                return false;

            if (const auto* pval = evt.get_message_if()) {
                *msg = std::move(*pval);
                break;
            }

            if (!evt.is_any_disconnect()) {
                *msg = const_message_ptr{};
                break;
            }
        }

        return true;
    }
    /**
     * Waits until a specific time for a message to appear.
     * @param absTime The time point to wait until, before timing out.
     * @return The message, if read, an empty pointer if not.
     */
    template <class Clock, class Duration>
    const_message_ptr try_consume_message_until(
        const std::chrono::time_point<Clock, Duration>& absTime
    ) {
        const_message_ptr msg;
        this->try_consume_message_until(&msg, absTime);
        return msg;
    }
};

/** Smart/shared pointer to an asynchronous MQTT client object */
using async_client_ptr = async_client::ptr_t;

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_async_client_h

```

`include/mqtt/buffer_ref.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file buffer_ref.h
/// Buffer reference type for the Paho MQTT C++ library.
/// @date April 18, 2017
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2017-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_buffer_ref_h
#define __mqtt_buffer_ref_h

#include <cstring>
#include <iostream>

#include "mqtt/types.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/**
 * A reference object for holding immutable data buffers, with cheap copy
 * semantics and lifetime management.
 *
 * Each object of this class contains a reference-counted pointer to an
 * immutable data buffer. Objects can be copied freely and easily, even
 * across threads, since all instances promise not to modify the contents
 * of the buffer.
 *
 * The buffer is immutable but the reference itself acts like a normal
 * variable. It can be reassigned to point to a different buffer.
 *
 * If no value has been assigned to a reference, then it is in a default
 * "null" state. It is not safe to call any member functions on a null
 * reference, other than to check if the object is null or empty.
 * @verbatim
 * string_ref sr;
 * if (!sr)
 *   cout << "null reference" << endl;
 * else
 *   cout.write(sr.data(), sr.size());
 * @endverbatim
 */
template <typename T>
class buffer_ref
{
public:
    /**
     * The underlying type for the buffer.
     * Normally byte-wide data (char or uint8_t) for Paho.
     */
    using value_type = T;
    /**
     * The type for the buffer.
     * We use basic_string for compatibility with string data.
     */
    using blob = std::basic_string<value_type>;
    /**
     *  The pointer we use.
     *  Note that it is a pointer to a _const_ blob.
     */
    using pointer_type = std::shared_ptr<const blob>;

private:
    /** Our data is a shared pointer to a const buffer */
    pointer_type data_;

public:
    /**
     * Default constructor creates a null reference.
     */
    buffer_ref() = default;
    /**
     * Copy constructor only copies a shared pointer.
     * @param buf Another buffer reference.
     */
    buffer_ref(const buffer_ref& buf) = default;
    /**
     * Move constructor only moves a shared pointer.
     * @param buf Another buffer reference.
     */
    buffer_ref(buffer_ref&& buf) = default;
    /**
     * Creates a reference to a new buffer by copying data.
     * @param b A string from which to create a new buffer.
     */
    buffer_ref(const blob& b) : data_{std::make_shared<blob>(b)} {}
    /**
     * Creates a reference to a new buffer by moving a string into the
     * buffer.
     * @param b A string from which to create a new buffer.
     */
    buffer_ref(blob&& b) : data_{std::make_shared<blob>(std::move(b))} {}
    /**
     * Creates a reference to an existing buffer by copying the shared
     * pointer.
     * Note that it is up to the caller to insure that there are no mutable
     * references to the buffer.
     * @param p A shared pointer to a string.
     */
    buffer_ref(const pointer_type& p) : data_(p) {}
    /**
     * Creates a reference to an existing buffer by moving the shared
     * pointer.
     * Note that it is up to the caller to insure that there are no mutable
     * references to the buffer.
     * @param p A shared pointer to a string.
     */
    buffer_ref(pointer_type&& p) : data_(std::move(p)) {}
    /**
     * Creates a reference to a new buffer containing a copy of the data.
     * @param buf The memory to copy
     * @param n The number of bytes to copy.
     */
    buffer_ref(const value_type* buf, size_t n) : data_{std::make_shared<blob>(buf, n)} {}
    /**
     * Creates a reference to a new buffer containing a copy of the
     * NUL-terminated char array.
     * @param buf A NUL-terminated char array (C string).
     */
    buffer_ref(const char* buf)
        : buffer_ref(reinterpret_cast<const value_type*>(buf), std::strlen(buf)) {
        static_assert(
            sizeof(char) == sizeof(T), "can only use C arr with char or byte buffers"
        );
    }

    /**
     * Copy the reference to the buffer.
     * @param rhs Another buffer
     * @return A reference to this object
     */
    buffer_ref& operator=(const buffer_ref& rhs) = default;
    /**
     * Move a reference to a buffer.
     * @param rhs The other reference to move.
     * @return A reference to this object.
     */
    buffer_ref& operator=(buffer_ref&& rhs) = default;
    /**
     * Copy a string into this object, creating a new buffer.
     * Modifies the reference for this object, pointing it to a
     * newly-created buffer. Other references to the old object remain
     * unchanges, so this follows copy-on-write semantics.
     * @param b A new blob/string to copy.
     * @return A reference to this object.
     */
    buffer_ref& operator=(const blob& b) {
        data_.reset(new blob(b));
        return *this;
    }
    /**
     * Move a string into this object, creating a new buffer.
     * Modifies the reference for this object, pointing it to a
     * newly-created buffer. Other references to the old object remain
     * unchanges, so this follows copy-on-write semantics.
     * @param b A new blob/string to move.
     * @return A reference to this object.
     */
    buffer_ref& operator=(blob&& b) {
        data_.reset(new blob(std::move(b)));
        return *this;
    }
    /**
     * Copy a NUL-terminated C char array into a new buffer
     * @param cstr A NUL-terminated C string.
     * @return A reference to this object
     */
    buffer_ref& operator=(const char* cstr) {
        static_assert(
            sizeof(char) == sizeof(T), "can only use C arr with char or byte buffers"
        );
        data_.reset(new blob(reinterpret_cast<const value_type*>(cstr), strlen(cstr)));
        return *this;
    }
    /**
     * Copy another type of buffer reference to this one.
     * This can copy a buffer of different types, provided that the size of
     * the data elements are the same. This is typically used to convert
     * from char to byte, where the data is the same, but the interpretation
     * is different. Note that this copies the underlying buffer.
     * @param rhs A reference to a different type of buffer.
     * @return A reference to this object.
     */
    template <typename OT>
    buffer_ref& operator=(const buffer_ref<OT>& rhs) {
        static_assert(
            sizeof(OT) == sizeof(T), "Can only assign buffers if values the same size"
        );
        data_.reset(new blob(reinterpret_cast<const value_type*>(rhs.data()), rhs.size()));
        return *this;
    }
    /**
     * Clears the reference to nil.
     */
    void reset() { data_.reset(); }
    /**
     * Determines if the reference is valid.
     * If the reference is invalid then it is not safe to call @em any
     * member functions other than @ref is_null() and @ref empty()
     * @return @em true if referring to a valid buffer, @em false if the
     *  	   reference (pointer) is null.
     */
    explicit operator bool() const { return bool(data_); }
    /**
     * Determines if the reference is invalid.
     * If the reference is invalid then it is not safe to call @em any
     * member functions other than @ref is_null() and @ref empty()
     * @return @em true if the reference is null, @em false if it is
     *  	   referring to a valid buffer,
     */
    bool is_null() const { return !data_; }
    /**
     * Determines if the buffer is empty.
     * @return @em true if the buffer is empty or the reference is null,
     *  	   @em false if the buffer contains data.
     */
    bool empty() const { return !data_ || data_->empty(); }
    /**
     * Gets a const pointer to the data buffer.
     * @return A pointer to the data buffer.
     */
    const value_type* data() const { return data_->data(); }
    /**
     * Gets the size of the data buffer.
     * @return The size of the data buffer.
     */
    size_t size() const { return data_->size(); }
    /**
     * Gets the size of the data buffer.
     * @return The size of the data buffer.
     */
    size_t length() const { return data_->length(); }
    /**
     * Gets the data buffer as a string.
     * @return The data buffer as a string.
     */
    const blob& str() const { return *data_; }
    /**
     * Gets the data buffer as a string.
     * @return The data buffer as a string.
     */
    const blob& to_string() const { return str(); }
    /**
     * Gets the data buffer as NUL-terminated C string.
     * Note that the reference must be set to call this function.
     * @return The data buffer as a string.
     */
    const char* c_str() const { return data_->c_str(); }
    /**
     * Gets a shared pointer to the (const) data buffer.
     * @return A shared pointer to the (const) data buffer.
     */
    const pointer_type& ptr() const { return data_; }
    /**
     * Gets elemental access to the data buffer (read only)
     * @param i The index into the buffer.
     * @return The value at the specified index.
     */
    const value_type& operator[](size_t i) const { return (*data_)[i]; }
};

/**
 * Stream inserter for a buffer reference.
 * This does a binary write of the data in the buffer.
 * @param os The output stream.
 * @param buf The buffer reference to write.
 * @return A reference to the output stream.
 */
template <typename T>
std::ostream& operator<<(std::ostream& os, const buffer_ref<T>& buf) {
    if (!buf.empty())
        os.write(buf.data(), buf.size());
    return os;
}

/////////////////////////////////////////////////////////////////////////////

/**
 * A reference to a text buffer.
 */
using string_ref = buffer_ref<char>;

/**
 * A reference to a binary buffer.
 * Note that we're using char for the underlying data type to allow
 * efficient moves to and from std::string's. Using a separate type
 * indicates that the data may be arbitrary binary.
 */
using binary_ref = buffer_ref<char>;

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_buffer_ref_h

```

`include/mqtt/buffer_view.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file buffer_view.h
/// Buffer reference type for the Paho MQTT C++ library.
/// @date April 18, 2017
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2017-2020 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_buffer_view_h
#define __mqtt_buffer_view_h

#include <iostream>

#include "mqtt/types.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/**
 * A reference to a contiguous sequence of items, with no ownership.
 * This simply contains a pointer to a const array of items, and a size.
 * This is a similar, but simplified version of the std::string_view
 * class(es) in the C++17 standard.
 */
template <typename T>
class buffer_view
{
public:
    /** The type of items to be held in the queue. */
    using value_type = T;
    /** The type used to specify number of items in the container. */
    using size_type = size_t;

private:
    /** Const pointer to the data array */
    const value_type* data_;
    /** The size of the array */
    size_type sz_;

public:
    /**
     * Constructs a buffer view.
     * @param data The data pointer
     * @param n The number of items
     */
    buffer_view(const value_type* data, size_type n) : data_(data), sz_(n) {}
    /**
     * Constructs a buffer view to a whole string.
     * This the starting pointer and length of the whole string.
     * @param str The string.
     */
    buffer_view(const std::basic_string<value_type>& str)
        : data_(str.data()), sz_(str.size()) {}
    /**
     * Gets a pointer the first item in the view.
     * @return A const pointer the first item in the view.
     */
    const value_type* data() const { return data_; }
    /**
     * Gets the number of items in the view.
     * @return The number of items in the view.
     */
    size_type size() const { return sz_; }
    /**
     * Gets the number of items in the view.
     * @return The number of items in the view.
     */
    size_type length() const { return sz_; }
    /**
     * Access an item in the view.
     * @param i The index of the item.
     * @return A const reference to the requested item.
     */
    const value_type& operator[](size_t i) const { return data_[i]; }
    /**
     * Gets a copy of the view as a string.
     * @return A copy of the view as a string.
     */
    std::basic_string<value_type> str() const {
        return std::basic_string<value_type>(data_, sz_);
    }
    /**
     * Gets a copy of the view as a string.
     * @return A copy of the view as a string.
     */
    string to_string() const {
        static_assert(
            sizeof(char) == sizeof(T), "can only get string for char or byte buffers"
        );
        return string(reinterpret_cast<const char*>(data_), sz_);
    }
};

/**
 * Stream inserter for a buffer view.
 * This does a binary write of the data in the buffer.
 * @param os The output stream.
 * @param buf The buffer reference to write.
 * @return A reference to the output stream.
 */
template <typename T>
std::ostream& operator<<(std::ostream& os, const buffer_view<T>& buf) {
    if (buf.size() > 0)
        os.write(buf.data(), sizeof(T) * buf.size());
    return os;
}

/** A buffer view for character string data. */
using string_view = buffer_view<char>;

/** A buffer view for binary data */
using binary_view = buffer_view<char>;

/////////////////////////////////////////////////////////////////////////////
// end namespace mqtt
}  // namespace mqtt

#endif  // __mqtt_buffer_view_h

```

`include/mqtt/callback.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file callback.h
/// Declaration of MQTT callback class
/// @date May 1, 2013
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2013-2019 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_callback_h
#define __mqtt_callback_h

#include <memory>
#include <vector>

#include "MQTTAsync.h"
#include "mqtt/delivery_token.h"
#include "mqtt/types.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/**
 * Provides a mechanism for tracking the completion of an asynchronous
 * action.
 */
class callback
{
public:
    /** Smart/shared pointer to an object of this type */
    using ptr_t = std::shared_ptr<callback>;
    /** Smart/shared pointer to a const object of this type */
    using const_ptr_t = std::shared_ptr<const callback>;

    /**
     * Virtual destructor.
     */
    virtual ~callback() {}

    /**
     * This method is called when the client is connected.
     * Note that, in response to an initial connect(), the token from the
     * connect call is also signaled with an on_success(). That occurs just
     * before this is called.
     */
    virtual void connected(const string& /*cause*/) {}
    /**
     * This method is called when the connection to the server is lost.
     */
    virtual void connection_lost(const string& /*cause*/) {}
    /**
     * This method is called when a message arrives from the server.
     */
    virtual void message_arrived(const_message_ptr /*msg*/) {}
    /**
     * Called when delivery for a message has been completed, and all
     * acknowledgments have been received.
     */
    virtual void delivery_complete(delivery_token_ptr /*tok*/) {}
};

/** Smart/shared pointer to a callback object */
using callback_ptr = callback::ptr_t;

/** Smart/shared pointer to a const callback object */
using const_callback_ptr = callback::const_ptr_t;

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_callback_h

```

`include/mqtt/client.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file client.h
/// Declaration of MQTT client class
/// @date May 1, 2013
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2013-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_client_h
#define __mqtt_client_h

#include <future>

#include "mqtt/async_client.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/**
 * Lightweight client for talking to an MQTT server using methods that block
 * until an operation completes.
 */
class client : private callback
{
    /** An arbitrary, but relatively long timeout */
    PAHO_MQTTPP_EXPORT static const std::chrono::seconds DFLT_TIMEOUT;
    /** The default quality of service */
    PAHO_MQTTPP_EXPORT static const int DFLT_QOS;  // =1;

    /** The actual client */
    async_client cli_;
    /** The longest time to wait for an operation to complete.  */
    std::chrono::milliseconds timeout_;
    /** Callback supplied by the user (if any) */
    callback* userCallback_;

    /**
     * Creates a shared pointer to an existing non-heap object.
     * The shared pointer is given a no-op deleter, so it will not try to
     * destroy the object when it goes out of scope. It is up to the caller
     * to ensure that the object remains in memory for as long as there may
     * be pointers to it.
     * @param val A value which may live anywhere in memory (stack,
     *  		  file-scope, etc).
     * @return A shared pointer to the object.
     */
    template <typename T>
    std::shared_ptr<T> ptr(const T& val) {
        return std::shared_ptr<T>(const_cast<T*>(&val), [](T*) {});
    }

    // User callbacks
    // Most are launched in a separate thread, for convenience, except
    // message_arrived, for performance.
    void connected(const string& cause) override {
        std::async(std::launch::async, &callback::connected, userCallback_, cause).wait();
    }
    void connection_lost(const string& cause) override {
        std::async(std::launch::async, &callback::connection_lost, userCallback_, cause)
            .wait();
    }
    void message_arrived(const_message_ptr msg) override {
        userCallback_->message_arrived(msg);
    }
    void delivery_complete(delivery_token_ptr tok) override {
        std::async(std::launch::async, &callback::delivery_complete, userCallback_, tok)
            .wait();
    }

    /** Non-copyable */
    client() = delete;
    client(const async_client&) = delete;
    client& operator=(const async_client&) = delete;

public:
    /** Smart pointer type for this object */
    using ptr_t = std::shared_ptr<client>;
    /** Type for a collection of QOS values */
    using qos_collection = async_client::qos_collection;

    /** Handler for updating connection data before an auto-reconnect. */
    using update_connection_handler = async_client::update_connection_handler;

    /**
     * Create a client that can be used to communicate with an MQTT server.
     * @param serverURI the address of the server to connect to, specified
     *  				as a URI.
     * @param clientId a client identifier that is unique on the server
     *                 being connected to.
     * @param persistence The desired persistence type.
     */
    client(
        const string& serverURI, const string& clientId = string{},
        const persistence_type& persistence = NO_PERSISTENCE
    );
    /**
     * Create a client that can be used to communicate with an MQTT server,
     * which allows for off-line message buffering.
     * This allows the caller to specify a user-defined persistence object,
     * or use no persistence.
     * @param serverURI the address of the server to connect to, specified
     *  				as a URI.
     * @param clientId a client identifier that is unique on the server
     *  			   being connected to
     * @param maxBufferedMessages the maximum number of messages allowed to
     *  						  be buffered while not connected
     * @param persistence The desired persistence type.
     */
    client(
        const string& serverURI, const string& clientId, int maxBufferedMessages,
        const persistence_type& persistence = NO_PERSISTENCE
    );
    /**
     * Create a client that can be used to communicate with an MQTT server,
     * which allows for off-line message buffering. This allows the caller
     * to specify a user-defined persistence object, or use no persistence.
     * @param serverURI the address of the server to connect to, specified
     *  				as a URI.
     * @param clientId a client identifier that is unique on the server
     *  			   being connected to
     * @param opts The create options
     * @param persistence The desired persistence type.
     */
    client(
        const string& serverURI, const string& clientId, const create_options& opts,
        const persistence_type& persistence = NO_PERSISTENCE
    );
    /**
     * Create a client that can be used to communicate with an MQTT server.
     * @param opts The create options
     */
    client(const create_options& opts);
    /**
     * Virtual destructor
     */
    virtual ~client() {}
    /**
     * Connects to an MQTT server using the default options.
     */
    virtual connect_response connect();
    /**
     * Connects to an MQTT server using the specified options.
     * @param opts The connect options
     */
    virtual connect_response connect(connect_options opts);
    /**
     * Reconnects the client using options from the previous connect.
     * The client must have previously called connect() for this to work.
     */
    virtual connect_response reconnect();
    /**
     * Disconnects from the server.
     */
    virtual void disconnect();
    /**
     * Disconnects from the server.
     * @param timeoutMS the amount of time in milliseconds to allow for
     *  			  existing work to finish before disconnecting. A value
     *  			  of zero or less means the client will not quiesce.
     */
    virtual void disconnect(int timeoutMS);
    /**
     * Disconnects from the server.
     * @param to the amount of time in milliseconds to allow for
     *  			  existing work to finish before disconnecting. A value
     *  			  of zero or less means the client will not quiesce.
     */
    template <class Rep, class Period>
    void disconnect(const std::chrono::duration<Rep, Period>& to) {
        disconnect((int)to_milliseconds_count(to));
    }
    /**
     * Gets the client ID used by this client.
     * @return The client ID used by this client.
     */
    virtual string get_client_id() const { return cli_.get_client_id(); }
    /**
     * Gets the address of the server used by this client.
     * @return The address of the server used by this client, as a URI.
     */
    virtual string get_server_uri() const { return cli_.get_server_uri(); }
    /**
     * Return the maximum time to wait for an action to complete.
     * @return int
     */
    virtual std::chrono::milliseconds get_timeout() const { return timeout_; }
    /**
     * Gets a copy of the connect options that were last used in a request
     * to connect to the broker.
     * @returns The last connect options that were used.
     */
    connect_options get_connect_options() const { return cli_.get_connect_options(); }
    /**
     * Get a topic object which can be used to publish messages on this
     * client.
     * @param top The topic name
     * @param qos The Quality of Service for the topic
     * @param retained Whether the published messages set the retain flag.
     * @return A topic attached to this client.
     */
    virtual topic get_topic(
        const string& top, int qos = message::DFLT_QOS, bool retained = message::DFLT_RETAINED
    ) {
        return topic(cli_, top, qos, retained);
    }
    /**
     * Determines if this client is currently connected to the server.
     * @return @em true if the client is currently connected, @em false if
     *  	   not.
     */
    virtual bool is_connected() const { return cli_.is_connected(); }
    /**
     * Sets a callback to allow the application to update the connection
     * data on automatic reconnects.
     * @param cb The callback functor to register with the library.
     */
    void set_update_connection_handler(update_connection_handler cb) {
        cli_.set_update_connection_handler(cb);
    }

    /**
     * Publishes a message to a topic on the server and return once it is
     * delivered.
     * @param top The topic to publish
     * @param payload The data to publish
     * @param n The size in bytes of the data
     * @param qos The QoS for message delivery
     * @param retained Whether the broker should retain the message
     */
    virtual void publish(
        string_ref top, const void* payload, size_t n, int qos, bool retained
    ) {
        if (!cli_.publish(std::move(top), payload, n, qos, retained)->wait_for(timeout_))
            throw timeout_error();
    }
    /**
     * Publishes a message to a topic on the server and return once it is
     * delivered.
     * @param top The topic to publish
     * @param payload The data to publish
     * @param n The size in bytes of the data
     */
    virtual void publish(string_ref top, const void* payload, size_t n) {
        if (!cli_.publish(std::move(top), payload, n)->wait_for(timeout_))
            throw timeout_error();
    }
    /**
     * Publishes a message to a topic on the server.
     * @param msg The message
     */
    virtual void publish(const_message_ptr msg) {
        if (!cli_.publish(msg)->wait_for(timeout_))
            throw timeout_error();
    }
    /**
     * Publishes a message to a topic on the server.
     * This version will not timeout since that could leave the library with
     * a reference to memory that could disappear while the library is still
     * using it.
     * @param msg The message
     */
    virtual void publish(const message& msg) { cli_.publish(ptr(msg))->wait(); }
    /**
     * Sets the callback listener to use for events that happen
     * asynchronously.
     * @param cb The callback functions
     */
    virtual void set_callback(callback& cb);
    /**
     * Set the maximum time to wait for an action to complete.
     * @param timeoutMS The timeout in milliseconds
     */
    virtual void set_timeout(int timeoutMS) {
        timeout_ = std::chrono::milliseconds(timeoutMS);
    }
    /**
     * Set the maximum time to wait for an action to complete.
     * @param to The timeout as a std::chrono duration.
     */
    template <class Rep, class Period>
    void set_timeout(const std::chrono::duration<Rep, Period>& to) {
        timeout_ = to_milliseconds(to);
    }
    /**
     * Subscribe to a topic, which may include wildcards using a QoS of 1.
     * @param topicFilter A single topic to subscribe
maked      * @param props The MQTT v5 properties.
     * @param opts The MQTT v5 subscribe options for the topic
     * @return The "subscribe" response from the server.
     */
    virtual subscribe_response subscribe(
        const string& topicFilter, const subscribe_options& opts = subscribe_options(),
        const properties& props = properties()
    );
    /**
     * Subscribe to a topic, which may include wildcards.
     * @param topicFilter A single topic to subscribe
     * @param qos The QoS of the subscription
     * @param opts The MQTT v5 subscribe options for the topic
     * @param props The MQTT v5 properties.
     * @return The "subscribe" response from the server.
     */
    virtual subscribe_response subscribe(
        const string& topicFilter, int qos,
        const subscribe_options& opts = subscribe_options(),
        const properties& props = properties()
    );
    /**
     * Subscribes to a one or more topics, which may include wildcards using
     * a QoS of 1.
     * @param topicFilters A set of topics to subscribe
     * @param opts The MQTT v5 subscribe options (one for each topic)
     * @param props The MQTT v5 properties.
     * @return The "subscribe" response from the server.
     */
    virtual subscribe_response subscribe(
        const string_collection& topicFilters,
        const std::vector<subscribe_options>& opts = std::vector<subscribe_options>(),
        const properties& props = properties()
    );
    /**
     * Subscribes to multiple topics, each of which may include wildcards.
     * @param topicFilters A collection of topics to subscribe
     * @param qos A collection of QoS for each topic
     * @param opts The MQTT v5 subscribe options (one for each topic)
     * @param props The MQTT v5 properties.
     * @return The "subscribe" response from the server.
     */
    virtual subscribe_response subscribe(
        const string_collection& topicFilters, const qos_collection& qos,
        const std::vector<subscribe_options>& opts = std::vector<subscribe_options>(),
        const properties& props = properties()
    );
    /**
     * Requests the server unsubscribe the client from a topic.
     * @param topicFilter A single topic to unsubscribe.
     * @param props The MQTT v5 properties.
     * @return The "unsubscribe" response from the server.
     */
    virtual unsubscribe_response unsubscribe(
        const string& topicFilter, const properties& props = properties()
    );
    /**
     * Requests the server unsubscribe the client from one or more topics.
     * @param topicFilters A collection of topics to unsubscribe.
     * @param props The MQTT v5 properties.
     * @return The "unsubscribe" response from the server.
     */
    virtual unsubscribe_response unsubscribe(
        const string_collection& topicFilters, const properties& props = properties()
    );
    /**
     * Start consuming messages.
     * This initializes the client to receive messages through a queue that
     * can be read synchronously.
     */
    virtual void start_consuming() { cli_.start_consuming(); }
    /**
     * Stop consuming messages.
     * This shuts down the internal callback and discards any unread
     * messages.
     */
    virtual void stop_consuming() { cli_.stop_consuming(); }
    /**
     * Read the next message from the queue.
     * This blocks until a new message arrives.
     * @return The message and topic.
     */
    virtual const_message_ptr consume_message() { return cli_.consume_message(); }
    /**
     * Try to read the next message from the queue without blocking.
     * @param msg Pointer to the value to receive the message
     * @return @em true is a message was read, @em false if no message was
     *  	   available.
     */
    virtual bool try_consume_message(const_message_ptr* msg) {
        return cli_.try_consume_message(msg);
    }
    /**
     * Waits a limited time for a message to arrive.
     * @param msg Pointer to the value to receive the message
     * @param relTime The maximum amount of time to wait for a message.
     * @return @em true if a message was read, @em false if a timeout
     *  	   occurred.
     */
    template <typename Rep, class Period>
    bool try_consume_message_for(
        const_message_ptr* msg, const std::chrono::duration<Rep, Period>& relTime
    ) {
        return cli_.try_consume_message_for(msg, relTime);
    }
    /**
     * Waits until a specific time for a message to occur.
     * @param msg Pointer to the value to receive the message
     * @param absTime The time point to wait until, before timing out.
     * @return @em true if a message was read, @em false if a timeout
     *  	   occurred.
     */
    template <class Clock, class Duration>
    bool try_consume_message_until(
        const_message_ptr* msg, const std::chrono::time_point<Clock, Duration>& absTime
    ) {
        return cli_.try_consume_message_until(msg, absTime);
    }
};

/** Smart/shared pointer to an MQTT synchronous client object */
using client_ptr = client::ptr_t;

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_client_h

```

`include/mqtt/connect_options.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file connect_options.h
/// Declaration of MQTT connect_options class
/// @date May 1, 2013
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2013-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_connect_options_h
#define __mqtt_connect_options_h

#include <chrono>
#include <map>
#include <vector>

#include "MQTTAsync.h"
#include "mqtt/message.h"
#include "mqtt/platform.h"
#include "mqtt/ssl_options.h"
#include "mqtt/string_collection.h"
#include "mqtt/token.h"
#include "mqtt/topic.h"
#include "mqtt/types.h"
#include "mqtt/will_options.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/**
 * Holds the set of options that control how the client connects to a
 * server.
 */
class connect_options
{
    /** The default C struct for non-WebSocket connections */
    static constexpr MQTTAsync_connectOptions DFLT_C_STRUCT
        MQTTAsync_connectOptions_initializer;

    /** The default C struct for non-Websocket MQTT v5 connections */
    static constexpr MQTTAsync_connectOptions DFLT_C_STRUCT5
        MQTTAsync_connectOptions_initializer5;

    /** The default C struct for WebSocket connections */
    static constexpr MQTTAsync_connectOptions DFLT_C_STRUCT_WS
        MQTTAsync_connectOptions_initializer_ws;

    /** The default C struct for Websocket MQTT v5 connections */
    static constexpr MQTTAsync_connectOptions DFLT_C_STRUCT5_WS
        MQTTAsync_connectOptions_initializer5_ws;

    /** The underlying C connection options */
    MQTTAsync_connectOptions opts_;

    /** The LWT options */
    will_options will_;

    /** The SSL options  */
    ssl_options ssl_;

    /** The user name to use for the connection. */
    string_ref userName_;

    /** The password to use for the connection. */
    binary_ref password_;

    /** Shared token pointer for context, if any */
    token_ptr tok_;

    /** Collection of server URIs, if any */
    const_string_collection_ptr serverURIs_;

    /** The connect properties */
    properties props_;

    /** HTTP Headers */
    name_value_collection httpHeaders_;

    /** HTTP proxy for websockets */
    string httpProxy_;

    /** Secure HTTPS proxy for websockets */
    string httpsProxy_;

    /** The client has special access */
    friend class async_client;

    /**
     * Gets a pointer to the C-language NUL-terminated strings for the
     * struct.
     * @note In the connect options, by default, the Paho C treats
     * nullptr char arrays as unset values, so we keep that semantic and
     * only set those char arrays if the string is non-empty.
     * @param sr The C++ string object.
     * @return Pointer to a NUL terminated string. This is only valid until
     *  	   the next time the string is updated.
     */
    const char* c_str(const string_ref& sr) { return sr.empty() ? nullptr : sr.c_str(); }
    const char* c_str(const string& s) { return s.empty() ? nullptr : s.c_str(); }
    /**
     * Updates the underlying C structure to match our strings.
     */
    void update_c_struct();

    /**
     * Creates the options from a C option struct.
     * @param copts The C options struct.
     */
    connect_options(const MQTTAsync_connectOptions& copts) : opts_(copts) {}

public:
    /** Smart/shared pointer to an object of this class. */
    using ptr_t = std::shared_ptr<connect_options>;
    /** Smart/shared pointer to a const object of this class. */
    using const_ptr_t = std::shared_ptr<const connect_options>;

    /**
     * Constructs a new object using the default values.
     *
     * @param ver The MQTT protocol version.
     */
    explicit connect_options(int ver = MQTTVERSION_DEFAULT);
    /**
     * Constructs a new object using the specified user name and password.
     * @param userName The name of the user for connecting to the server
     * @param password The password for connecting to the server
     * @param ver The MQTT protocol version.
     */
    connect_options(string_ref userName, binary_ref password, int ver = MQTTVERSION_DEFAULT);
    /**
     * Copy constructor.
     * @param opt Another object to copy.
     */
    connect_options(const connect_options& opt);
    /**
     * Move constructor.
     * @param opt Another object to move into this new one.
     */
    connect_options(connect_options&& opt);
    /**
     * Creates default options for an MQTT v3.x connection.
     * @return Default options for an MQTT v3.x connection.
     */
    static connect_options v3() { return connect_options(DFLT_C_STRUCT); }
    /**
     * Creates default options for an MQTT v5 connection.
     * @return Default options for an MQTT v5 connection.
     */
    static connect_options v5() { return connect_options(DFLT_C_STRUCT5); }
    /**
     * Creates default options for an MQTT v3.x connection using WebSockets.
     *
     * The keepalive interval is set to 45 seconds to avoid webserver 60
     * second inactivity timeouts.
     *
     * @return Default options for an MQTT v3.x connection using websockets.
     */
    static connect_options ws() { return connect_options(DFLT_C_STRUCT_WS); }
    /**
     * Creates default options for an MQTT v5 connection using WebSockets.
     *
     * The keepalive interval is set to 45 seconds to avoid webserver 60
     * second inactivity timeouts.
     *
     * @return Default options for an MQTT v5 connection using websockets.
     */
    static connect_options v5_ws() { return connect_options(DFLT_C_STRUCT5_WS); }
    /**
     * Copy assignment.
     * @param opt Another object to copy.
     */
    connect_options& operator=(const connect_options& opt);
    /**
     * Move assignment.
     * @param opt Another object to move into this new one.
     */
    connect_options& operator=(connect_options&& opt);
/**
 * Expose the underlying C struct for the unit tests.
 */
#if defined(UNIT_TESTS)
    const MQTTAsync_connectOptions& c_struct() const { return opts_; }
#endif
    /**
     * Gets the "keep alive" interval.
     * @return The keep alive interval in seconds.
     */
    std::chrono::seconds get_keep_alive_interval() const {
        return std::chrono::seconds(opts_.keepAliveInterval);
    }
    /**
     * Gets the connection timeout.
     * This is the amount of time the underlying library will wait for a
     * timeout before failing.
     * @return The connect timeout in seconds.
     */
    std::chrono::seconds get_connect_timeout() const {
        return std::chrono::seconds(opts_.connectTimeout);
    }
    /**
     * Gets the user name to use for the connection.
     * @return The user name to use for the connection.
     */
    string get_user_name() const { return userName_ ? userName_.to_string() : string(); }
    /**
     * Gets the password to use for the connection.
     * @return The password to use for the connection.
     */
    binary_ref get_password() const { return password_; }
    /**
     * Gets the password to use for the connection.
     * @return The password to use for the connection.
     */
    string get_password_str() const { return password_ ? password_.to_string() : string(); }
    /**
     * Gets the maximum number of messages that can be in-flight
     * simultaneously.
     * @return The maximum number of inflight messages.
     */
    int get_max_inflight() const { return opts_.maxInflight; }
    /**
     * Gets the topic to be used for last will and testament (LWT).
     * @return The topic to be used for last will and testament (LWT).
     */
    string get_will_topic() const { return will_.get_topic(); }
    /**
     * Gets the message to be sent as last will and testament (LWT).
     * @return The message to be sent as last will and testament (LWT).
     */
    const_message_ptr get_will_message() const { return will_.get_message(); }
    /**
     * Get the LWT options to use for the connection.
     * @return The LWT options to use for the connection.
     */
    const will_options& get_will_options() const { return will_; }
    /**
     * Get the SSL options to use for the connection.
     * @return The SSL options to use for the connection.
     */
    const ssl_options& get_ssl_options() const { return ssl_; }
    /**
     * Sets the SSL for the connection.
     * These will only have an effect if compiled against the SSL version of
     * the Paho C library, and using a secure connection, "ssl://" or
     * "wss://".
     * @param ssl The SSL options.
     */
    void set_ssl(const ssl_options& ssl);
    /**
     * Sets the SSL for the connection.
     * These will only have an effect if compiled against the SSL version of
     * the Paho C library, and using a secure connection, "ssl://" or
     * "wss://".
     * @param ssl The SSL options.
     */
    void set_ssl(ssl_options&& ssl);
    /**
     * Returns whether the server should remember state for the client
     * across reconnects. This only applies to MQTT v3.x connections.
     * @return @em true if requesting a clean session, @em false if not.
     */
    bool is_clean_session() const { return to_bool(opts_.cleansession); }
    /**
     * Returns whether the server should remember state for the client
     * across reconnects. This only applies to MQTT v5 connections.
     * @return @em true if requesting a clean start, @em false if not.
     */
    bool is_clean_start() const { return to_bool(opts_.cleanstart); }
    /**
     * Gets the token used as the callback context.
     * @return The delivery token used as the callback context.
     */
    token_ptr get_token() const { return tok_; }
    /**
     * Gets the list of servers to which the client will connect.
     * @return A collection of server URI's. Each entry should be of the
     *  	   form @em protocol://host:port where @em protocol must be tcp
     *  	   or @em ssl. For @em host, you can specify either an IP
     *  	   address or a domain name.
     */
    const_string_collection_ptr get_servers() const { return serverURIs_; }
    /**
     * Gets the version of MQTT to be used for the connection.
     * @return The version of MQTT to be used for the connection:
     * @li MQTTVERSION_DEFAULT (0) = default: start with 3.1.1, and if that
     *     fails, fall back to 3.1
     * @li MQTTVERSION_3_1 (3) = only try version 3.1
     * @li MQTTVERSION_3_1_1 (4) = only try version 3.1.1
     */
    int get_mqtt_version() const { return opts_.MQTTVersion; }
    /**
     * Determines if the options have been configured for automatic
     * reconnect.
     * @return @em true if configured for automatic reconnect, @em false if
     *  	   not.
     */
    bool get_automatic_reconnect() const { return to_bool(opts_.automaticReconnect); }
    /**
     * Gets the minimum retry interval for automatic reconnect.
     * @return The minimum retry interval for automatic reconnect, in
     *  	   seconds.
     */
    std::chrono::seconds get_min_retry_interval() const {
        return std::chrono::seconds(opts_.minRetryInterval);
    }
    /**
     * Gets the maximum retry interval for automatic reconnect.
     * @return The maximum retry interval for automatic reconnect, in
     *  	   seconds.
     */
    std::chrono::seconds get_max_retry_interval() const {
        return std::chrono::seconds(opts_.maxRetryInterval);
    }
    /**
     * Sets whether the server should remember state for the client across
     * reconnects. (MQTT v3.x only)
     *
     * This will only take effect if the version is _already_ set to v3.x
     * (not v5).
     *
     * @param cleanSession @em true if the server should NOT remember state
     *              for the client across reconnects, @em false otherwise.
     */
    void set_clean_session(bool cleanSession);
    /**
     * Sets whether the server should remember state for the client across
     * reconnects. (MQTT v5 only)
     *
     * If a persistent session is desired (turning this off), then the app
     * should also set the `Session Expiry Interval` property, and add that
     * to the connect options.
     *
     * This will only take effect if the MQTT version is set to v5
     *
     * @param cleanStart @em true if the server should NOT remember state
     *              for the client across reconnects, @em false otherwise.
     */
    void set_clean_start(bool cleanStart);
    /**
     * Sets the "keep alive" interval.
     * This is the maximum time that should pass without communications
     * between client and server. If no messages pass in this time, the
     * client will ping the broker.
     * @param keepAliveInterval The keep alive interval in seconds.
     */
    void set_keep_alive_interval(int keepAliveInterval) {
        opts_.keepAliveInterval = keepAliveInterval;
    }
    /**
     * Sets the "keep alive" interval with a chrono duration.
     * This is the maximum time that should pass without communications
     * between client and server. If no messages pass in this time, the
     * client will ping the broker.
     * @param interval The keep alive interval.
     */
    template <class Rep, class Period>
    void set_keep_alive_interval(const std::chrono::duration<Rep, Period>& interval) {
        // TODO: Check range
        set_keep_alive_interval((int)to_seconds_count(interval));
    }
    /**
     * Sets the connect timeout in seconds.
     * This is the maximum time that the underlying library will wait for a
     * connection before failing.
     * @param timeout The connect timeout in seconds.
     */
    void set_connect_timeout(int timeout) { opts_.connectTimeout = timeout; }
    /**
     * Sets the connect timeout with a chrono duration.
     * This is the maximum time that the underlying library will wait for a
     * connection before failing.
     * @param timeout The connect timeout in seconds.
     */
    template <class Rep, class Period>
    void set_connect_timeout(const std::chrono::duration<Rep, Period>& timeout) {
        // TODO: check range
        set_connect_timeout((int)to_seconds_count(timeout));
    }
    /**
     * Sets the user name to use for the connection.
     * @param userName The user name for connecting to the MQTT broker.
     */
    void set_user_name(string_ref userName);
    /**
     * Sets the password to use for the connection.
     * @param password The password for connecting to the MQTT broker.
     */
    void set_password(binary_ref password);
    /**
     * Sets the maximum number of messages that can be in-flight
     * simultaneously.
     * @param n The maximum number of inflight messages.
     */
    void set_max_inflight(int n) { opts_.maxInflight = n; }
    /**
     * Sets the "Last Will and Testament" (LWT) for the connection.
     * @param will The LWT options.
     */
    void set_will(const will_options& will);
    /**
     * Sets the "Last Will and Testament" (LWT) for the connection.
     * @param will The LWT options.
     */
    void set_will(will_options&& will);
    /**
     * Sets the "Last Will and Testament" (LWT) as a message
     * @param msg The LWT message
     */
    void set_will_message(const message& msg) { set_will(will_options(msg)); }
    /**
     * Sets the "Last Will and Testament" (LWT) as a message
     * @param msg Pointer to a LWT message
     */
    void set_will_message(const_message_ptr msg) {
        if (msg)
            set_will(will_options(*msg));
    }
    /**
     * Sets the callback context to a delivery token.
     * @param tok The delivery token to be used as the callback context.
     */
    void set_token(const token_ptr& tok);
    /**
     * Sets the list of servers to which the client will connect.
     * @param serverURIs A pointer to a collection of server URI's. Each
     *  				 entry should be of the form @em
     *  				 protocol://host:port where @em protocol must be
     *  				 @em tcp or @em ssl. For @em host, you can specify
     *  				 either an IP address or a domain name.
     */
    void set_servers(const_string_collection_ptr serverURIs);
    /**
     * Sets the version of MQTT to be used on the connect.
     *
     * This will also set other connect options to legal values dependent on
     * the selected version.
     *
     * @param mqttVersion The MQTT version to use for the connection:
     *   @li MQTTVERSION_DEFAULT (0) = default: start with 3.1.1, and if
     *       that fails, fall back to 3.1
     *   @li MQTTVERSION_3_1 (3) = only try version 3.1
     *   @li MQTTVERSION_3_1_1 (4) = only try version 3.1.1
     *   @li MQTTVERSION_5 (5) = only try version 5
     *
     * Note that it is preferable to create the options for the desired
     * version rather than using this function to change the version after
     * some parameters have already been set. If you do use this function,
     * call it before setting any other version-specific options. @sa
     * connect_options::v5()
     */
    void set_mqtt_version(int mqttVersion);
    /**
     * Enable or disable automatic reconnects.
     * The retry intervals are not affected.
     * @param on Whether to turn reconnects on or off
     */
    void set_automatic_reconnect(bool on) { opts_.automaticReconnect = to_int(on); }
    /**
     * Enable or disable automatic reconnects.
     * @param minRetryInterval Minimum retry interval in seconds.  Doubled
     *  					   on each failed retry.
     * @param maxRetryInterval Maximum retry interval in seconds.  The
     *  					   doubling stops here on failed retries.
     */
    void set_automatic_reconnect(int minRetryInterval, int maxRetryInterval);
    /**
     * Enable or disable automatic reconnects.
     * @param minRetryInterval Minimum retry interval. Doubled on each
     *  					   failed retry.
     * @param maxRetryInterval Maximum retry interval. The doubling stops
     *  					   here on failed retries.
     */
    template <class Rep1, class Period1, class Rep2, class Period2>
    void set_automatic_reconnect(
        const std::chrono::duration<Rep1, Period1>& minRetryInterval,
        const std::chrono::duration<Rep2, Period2>& maxRetryInterval
    ) {
        set_automatic_reconnect(
            (int)to_seconds_count(minRetryInterval), (int)to_seconds_count(maxRetryInterval)
        );
    }
    /**
     * Gets the connect properties.
     * @return A const reference to the properties for the connect.
     */
    const properties& get_properties() const { return props_; }
    /**
     * Gets a mutable reference to the connect properties.
     * @return A reference to the properties for the connect.
     */
    properties& get_properties() { return props_; }
    /**
     * Sets the properties for the connect.
     * @param props The properties to place into the message.
     */
    void set_properties(const properties& props);
    /**
     * Moves the properties for the connect.
     * @param props The properties to move into the connect object.
     */
    void set_properties(properties&& props);
    /**
     * Gets the HTTP headers
     * @return A const reference to the HTTP headers name/value collection.
     */
    const name_value_collection& get_http_headers() const { return httpHeaders_; }
    /**
     * Sets the HTTP headers for the connection.
     * @param httpHeaders The header nam/value collection.
     */
    void set_http_headers(const name_value_collection& httpHeaders) {
        httpHeaders_ = httpHeaders;
        opts_.httpHeaders = httpHeaders_.empty() ? nullptr : httpHeaders_.c_arr();
    }
    /**
     * Sets the HTTP headers for the connection.
     * @param httpHeaders The header nam/value collection.
     */
    void set_http_headers(name_value_collection&& httpHeaders) {
        httpHeaders_ = std::move(httpHeaders);
        opts_.httpHeaders = httpHeaders_.empty() ? nullptr : httpHeaders_.c_arr();
    }
    /**
     * Gets the HTTP proxy setting.
     * @return The HTTP proxy setting. An empty string means no proxy.
     */
    string get_http_proxy() const { return httpProxy_; }
    /**
     * Sets the HTTP proxy setting.
     * @param httpProxy The HTTP proxy setting. An empty string means no
     *  			  proxy.
     */
    void set_http_proxy(const string& httpProxy);
    /**
     * Gets the secure HTTPS proxy setting.
     * @return The HTTPS proxy setting. An empty string means no proxy.
     */
    string get_https_proxy() const { return httpsProxy_; }
    /**
     * Sets the secure HTTPS proxy setting.
     * @param httpsProxy The HTTPS proxy setting. An empty string means no
     *  			 proxy.
     */
    void set_https_proxy(const string& httpsProxy);
};

/** Smart/shared pointer to a connection options object. */
using connect_options_ptr = connect_options::ptr_t;

/////////////////////////////////////////////////////////////////////////////

/**
 * The connect options that can be updated before an automatic reconnect.
 */
class connect_data
{
    /** The default C struct */
    PAHO_MQTTPP_EXPORT static constexpr MQTTAsync_connectData DFLT_C_STRUCT
        MQTTAsync_connectData_initializer;

    /** The underlying C connect data  */
    MQTTAsync_connectData data_{DFLT_C_STRUCT};

    /** The user name to use for the connection. */
    string_ref userName_;

    /** The password to use for the connection. (Optional) */
    binary_ref password_;

    /** The client has special access */
    friend class async_client;

    /**
     * Updates the underlying C structure to match our strings.
     */
    void update_c_struct();

    /**
     * Create data from a C struct
     * This is a deep copy of the data from the C struct.
     * @param cdata The C connect data.
     */
    connect_data(const MQTTAsync_connectData& cdata);

public:
    /**
     * Creates an empty set of connection data.
     */
    connect_data();
    /**
     * Creates connection data with a user name, but no password.
     * @param userName The user name for reconnecting to the MQTT broker.
     */
    explicit connect_data(string_ref userName);
    /**
     * Creates connection data with a user name and password.
     * @param userName The user name for reconnecting to the MQTT broker.
     * @param password The password for connecting to the MQTT broker.
     */
    connect_data(string_ref userName, binary_ref password);
    /**
     * Copy constructor
     * @param other Another data struct to copy into this one.
     */
    connect_data(const connect_data& other);
    /**
     * Copy the connection data.
     * @param rhs Another data struct to copy into this one.
     * @return A reference to this data
     */
    connect_data& operator=(const connect_data& rhs);
    /**
     * Gets the user name to use for the connection.
     * @return The user name to use for the connection.
     */
    string get_user_name() const { return userName_ ? userName_.to_string() : string(); }
    /**
     * Gets the password to use for the connection.
     * @return The password to use for the connection.
     */
    binary_ref get_password() const { return password_; }
    /**
     * Sets the user name to use for the connection.
     * @param userName The user name for connecting to the MQTT broker.
     */
    void set_user_name(string_ref userName);
    /**
     * Sets the password to use for the connection.
     * @param password The password for connecting to the MQTT broker.
     */
    void set_password(binary_ref password);
};

/////////////////////////////////////////////////////////////////////////////

/**
 * Class to build connect options.
 */
class connect_options_builder
{
    connect_options opts_;

public:
    /** This class */
    using self = connect_options_builder;
    /**
     * Default constructor.
     *
     * @param ver The MQTT version for the connection. Defaults to the most
     *  		  recent v3 supported by the server.
     */
    explicit connect_options_builder(int ver = MQTTVERSION_DEFAULT) : opts_(ver) {}
    /**
     * Copy constructor from an existing set of options.
     */
    explicit connect_options_builder(const connect_options& opts) : opts_(opts) {}
    /**
     * Move constructor from an existing set of options.
     */
    explicit connect_options_builder(const connect_options&& opts) : opts_(std::move(opts)) {}
    /**
     * Creates the default options builder for an MQTT v3.x connection.
     * @return An options builder for an MQTT v3.x connection.
     */
    static connect_options_builder v3() {
        return connect_options_builder{connect_options::v3()};
    }
    /**
     * Creates the default options builder for an MQTT v5 connection.
     * @return An options builder for an MQTT v5 connection.
     */
    static connect_options_builder v5() {
        return connect_options_builder{connect_options::v5()};
    }
    /**
     * Creates the default options builder for an MQTT v3.x connection using
     * WebSockets.
     *
     * The keepalive interval is set to 45 seconds to avoid webserver 60
     * second inactivity timeouts.
     *
     * @return An options builder for an MQTT v3.x connection using
     *  	   websockets.
     */
    static connect_options_builder ws() {
        return connect_options_builder{connect_options::ws()};
    }
    /**
     * Creates the default options for an MQTT v5 connection using
     * WebSockets
     * .
     * The keepalive interval is set to 45 seconds to avoid webserver 60
     * second inactivity timeouts.
     *
     * @return An options builder for an MQTT v5 connection using
     *  	   websockets.
     */
    static connect_options_builder v5_ws() {
        return connect_options_builder{connect_options::v5_ws()};
    }
    /**
     * Sets whether the server should remember state for the client across
     * reconnects. (MQTT v3.x only)
     * @param on @em true if the server should NOT remember state for the
     *  		 client across reconnects, @em false otherwise.
     */
    auto clean_session(bool on = true) -> self& {
        opts_.set_clean_session(on);
        return *this;
    }
    /**
     * Sets the "keep alive" interval with a chrono duration.
     * This is the maximum time that should pass without communications
     * between client and server. If no messages pass in this time, the
     * client will ping the broker.
     * @param interval The keep alive interval.
     */
    template <class Rep, class Period>
    auto keep_alive_interval(const std::chrono::duration<Rep, Period>& interval) -> self& {
        opts_.set_keep_alive_interval(interval);
        return *this;
    }
    /**
     * Sets the connect timeout with a chrono duration.
     * This is the maximum time that the underlying library will wait for a
     * connection before failing.
     * @param timeout The connect timeout in seconds.
     */
    template <class Rep, class Period>
    auto connect_timeout(const std::chrono::duration<Rep, Period>& timeout) -> self& {
        opts_.set_connect_timeout(timeout);
        return *this;
    }
    /**
     * Sets the user name for the connection.
     * @param userName The user name for the connection.
     */
    auto user_name(string_ref userName) -> self& {
        opts_.set_user_name(userName);
        return *this;
    }
    /**
     * Sets the password for the connection.
     * @param password The password for the connection.
     */
    auto password(binary_ref password) -> self& {
        opts_.set_password(password);
        return *this;
    }
    /**
     * Sets the maximum number of messages that can be in-flight
     * simultaneously.
     * @param n The maximum number of inflight messages.
     */
    auto max_inflight(int n) -> self& {
        opts_.set_max_inflight(n);
        return *this;
    }
    /**
     * Sets the "Last Will and Testament" (LWT) for the connection.
     * @param will The LWT options.
     */
    auto will(const will_options& will) -> self& {
        opts_.set_will(will);
        return *this;
    }
    /**
     * Sets the "Last Will and Testament" (LWT) for the connection.
     * @param will The LWT options.
     */
    auto will(will_options&& will) -> self& {
        opts_.set_will(std::move(will));
        return *this;
    }
    /**
     * Sets the "Last Will and Testament" (LWT) as a message
     * @param msg The LWT message
     */
    auto will(const message& msg) -> self& {
        opts_.set_will_message(msg);
        return *this;
    }
    /**
     * Sets the SSL options for the connection.
     * These will only have an effect if compiled against the SSL version of
     * the Paho C library, and connecting with a secure URI.
     * @param ssl The SSL options.
     */
    auto ssl(const ssl_options& ssl) -> self& {
        opts_.set_ssl(ssl);
        return *this;
    }
    /**
     * Sets the SSL options for the connection.
     * These will only have an effect if compiled against the SSL version of
     * the Paho C library, and connecting with a secure URI.
     * @param ssl The SSL options.
     */
    auto ssl(ssl_options&& ssl) -> self& {
        opts_.set_ssl(std::move(ssl));
        return *this;
    }
    /**
     * Sets the callback context to a delivery token.
     * @param tok The delivery token to be used as the callback context.
     */
    auto token(const token_ptr& tok) -> self& {
        opts_.set_token(tok);
        return *this;
    }
    /**
     * Sets the list of servers to which the client will connect.
     * @param serverURIs A pointer to a collection of server URI's. Each
     *  				 entry should be of the form @em
     *  				 protocol://host:port where @em protocol must be
     *  				 @em tcp or @em ssl. For @em host, you can specify
     *  				 either an IP address or a domain name.
     */
    auto servers(const_string_collection_ptr serverURIs) -> self& {
        opts_.set_servers(serverURIs);
        return *this;
    }
    /**
     * Sets the version of MQTT to be used on the connect.
     *
     * This will also set other connect options to legal values dependent on
     * the selected version.
     *
     * @param ver The MQTT protocol version to use for the connection:
     *   @li MQTTVERSION_DEFAULT (0) = default: start with 3.1.1, and if
     *       that fails, fall back to 3.1
     *   @li MQTTVERSION_3_1 (3) = only try version 3.1
     *   @li MQTTVERSION_3_1_1 (4) = only try version 3.1.1
     *   @li MQTTVERSION_5 (5) = only try version 5
     *
     * Note that it is preferable to create the options builder for the
     * desired version rather than using this function to change the version
     * after some parameters have already been set. If you do use this
     * function, call it before setting any other version-specific options.
     * @sa connect_options_builder::v5()
     */
    auto mqtt_version(int ver) -> self& {
        opts_.set_mqtt_version(ver);
        return *this;
    }
    /**
     * Enable or disable automatic reconnects.
     * The retry intervals are not affected.
     * @param on Whether to turn reconnects on or off
     */
    auto automatic_reconnect(bool on = true) -> self& {
        opts_.set_automatic_reconnect(on);
        return *this;
    }
    /**
     * Enable or disable automatic reconnects.
     * @param minRetryInterval Minimum retry interval. Doubled on each
     *  					   failed retry.
     * @param maxRetryInterval Maximum retry interval. The doubling stops
     *  					   here on failed retries.
     */
    template <class Rep1, class Period1, class Rep2, class Period2>
    auto automatic_reconnect(
        const std::chrono::duration<Rep1, Period1>& minRetryInterval,
        const std::chrono::duration<Rep2, Period2>& maxRetryInterval
    ) -> self& {
        opts_.set_automatic_reconnect(minRetryInterval, maxRetryInterval);
        return *this;
    }
    /**
     * Sets the 'clean start' flag for the connection. (MQTT v5 only)
     * @param on @em true to set the 'clean start' flag for the connect,
     *  		 @em false otherwise.
     */
    auto clean_start(bool on = true) -> self& {
        opts_.set_clean_start(on);
        return *this;
    }
    /**
     * Sets the properties for the connect message.
     * @param props The properties for the connect message.
     */
    auto properties(const mqtt::properties& props) -> self& {
        opts_.set_properties(props);
        return *this;
    }
    /**
     * Sets the properties for the connect message.
     * @param props The properties for the connect message.
     */
    auto properties(mqtt::properties&& props) -> self& {
        opts_.set_properties(std::move(props));
        return *this;
    }
    /**
     * Sets the HTTP headers for the connection.
     * @param headers The header nam/value collection.
     */
    auto http_headers(const name_value_collection& headers) -> self& {
        opts_.set_http_headers(headers);
        return *this;
    }
    /**
     * Sets the HTTP headers for the connection.
     * @param headers The header nam/value collection.
     */
    auto http_headers(name_value_collection&& headers) -> self& {
        opts_.set_http_headers(std::move(headers));
        return *this;
    }
    /**
     * Sets the HTTP proxy setting.
     * @param httpProxy The HTTP proxy setting. An empty string means no
     *  			  proxy.
     */
    auto http_proxy(const string& httpProxy) -> self& {
        opts_.set_http_proxy(httpProxy);
        return *this;
    }
    /**
     * Sets the secure HTTPS proxy setting.
     * @param httpsProxy The HTTPS proxy setting. An empty string means no
     *  			 proxy.
     */
    auto https_proxy(const string& httpsProxy) -> self& {
        opts_.set_https_proxy(httpsProxy);
        return *this;
    }
    /**
     * Finish building the options and return them.
     * @return The option struct as built.
     */
    connect_options finalize() { return opts_; }
};

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_connect_options_h

```

`include/mqtt/create_options.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file create_options.h
/// Declaration of MQTT create_options class
/// @date Oct 17, 2020
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2020-2025 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_create_options_h
#define __mqtt_create_options_h

#include <variant>

#include "MQTTAsync.h"
#include "mqtt/iclient_persistence.h"
#include "mqtt/types.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/** An empty type that can be used as a `persistent_type` variant option. */
struct no_persistence
{
};

/** A constant used to indicate that no persistence is desired */
constexpr no_persistence NO_PERSISTENCE{};

/**
 * A variant for the different type of persistence:
 * @li @em no_persistence: Any object of this type indicates no persistence
 *     is desired.
 * @li @em string: Indicates file persistence. The string specifies the
 *     directory for the persistence store.
 * @li @em iclient_persistence*: User-defined persistence
 */
using persistence_type = std::variant<no_persistence, string, iclient_persistence*>;

/////////////////////////////////////////////////////////////////////////////

/**
 * The set of options for constructing a client object.
 *
 * Note that the numerous, incomplete set of constructors pre-date the
 * current, expanded, options structure. For a full set of create options, a
 * builder can be used to specify the options, then construct the client
 * with those options, like this:
 *
 * @code
 *     auto createOpts = mqtt::create_options_builder()
 *                        .server_uri(serverURI)
 *                        .send_while_disconnected()
 *                        .max_buffered_messages(25)
 *                        .delete_oldest_messages()
 *                        .finalize();
 *
 *     mqtt::async_client cli(createOpts);
 * @endcode
 */
class create_options
{
    /** The underlying C options */
    MQTTAsync_createOptions opts_ MQTTAsync_createOptions_initializer5;

    /** The address of the server to connect to, specified as a URI */
    string serverURI_{};

    /** A client identifier that is unique on the server */
    string clientId_{};

    /** The persistence for the client */
    persistence_type persistence_{};

    /** The client and tests have special access */
    friend class async_client;
    friend class create_options_builder;

public:
    /** Smart/shared pointer to an object of this class. */
    using ptr_t = std::shared_ptr<create_options>;
    /** Smart/shared pointer to a const object of this class. */
    using const_ptr_t = std::shared_ptr<const create_options>;

    /**
     * Default set of client create options.
     */
    create_options() {}
    /**
     * Default create options for the specified version of MQTT.
     * @param mqttVersion The MQTT version used to create the client.
     */
    explicit create_options(int mqttVersion) : create_options() {
        opts_.MQTTVersion = mqttVersion;
    }
    /**
     * Default create options, but with off-line buffering enabled.
     * @param mqttVersion The MQTT version used to create the client.
     * @param maxBufferedMessages the maximum number of messages allowed to
     *  						  be buffered while not connected
     */
    create_options(int mqttVersion, int maxBufferedMessages);
    /**
     * Create options for the specified server and client ID, with optional
     * persistence.
     * This allows the caller to specify a user-defined persistence object,
     * or use no persistence.
     * @param serverURI the address of the server to connect to, specified
     *  				as a URI.
     * @param clientId a client identifier that is unique on the server
     *  			   being connected to
     * @param persistence The desired persistence structure.
     * @throw exception if an argument is invalid
     */
    explicit create_options(
        const string& serverURI, const string& clientId = string{},
        const persistence_type& persistence = NO_PERSISTENCE
    )
        : serverURI_{serverURI}, clientId_{clientId}, persistence_{persistence} {}
    /**
     * Create an async_client that can be used to communicate with an MQTT
     * server, which allows for off-line message buffering.
     * This uses file-based persistence in the specified directory.
     * @param serverURI the address of the server to connect to, specified
     *  				as a URI.
     * @param clientId a client identifier that is unique on the server
     *  			   being connected to
     * @param maxBufferedMessages the maximum number of messages allowed to
     *  						  be buffered while not connected
     * @param persistence The persistence that the client should use.
     * @throw exception if an argument is invalid
     */
    create_options(
        const string& serverURI, const string& clientId, int maxBufferedMessages,
        const persistence_type& persistence = NO_PERSISTENCE
    )
        : serverURI_{serverURI}, clientId_{clientId}, persistence_{persistence} {
        opts_.maxBufferedMessages = maxBufferedMessages;
    }
    /**
     * Create an async_client that can be used to communicate with an MQTT
     * server, which allows for off-line message buffering.
     * This uses file-based persistence in the specified directory.
     * @param serverURI the address of the server to connect to, specified
     *  				as a URI.
     * @param clientId a client identifier that is unique on the server
     *  			   being connected to
     * @param opts The create options
     * @param persistence The persistence that the client should use.
     * @throw exception if an argument is invalid
     */
    create_options(
        const string& serverURI, const string& clientId, const create_options& opts,
        const persistence_type& persistence
    )
        : opts_{opts.opts_},
          serverURI_{serverURI},
          clientId_{clientId},
          persistence_{persistence} {}
    /**
     * Copy constructor.
     * @param opts The other options.
     */
    create_options(const create_options& opts)
        : opts_{opts.opts_},
          serverURI_{opts.serverURI_},
          clientId_{opts.clientId_},
          persistence_{opts.persistence_} {}
    /**
     * Move constructor.
     * @param opts The other options.
     */
    create_options(create_options&& opts)
        : opts_{opts.opts_},
          serverURI_{std::move(opts.serverURI_)},
          clientId_{std::move(opts.clientId_)},
          persistence_{std::move(opts.persistence_)} {}

    create_options& operator=(const create_options& rhs);
    create_options& operator=(create_options&& rhs);
    /**
     * Set the address of the server to connect to, specified as a URI
     * @param serverURI The URI of the server.
     */
    void set_server_uri(const string& serverURI) { serverURI_ = serverURI; };
    /**
     * Get the address of the server to connect to, specified as a URI.
     * @return The URI of the server.
     */
    const string& get_server_uri() const noexcept { return serverURI_; };
    /**
     * Set the client identifier.
     * @param clientId The client identifier.
     */
    void set_client_id(const string& clientId) { clientId_ = clientId; }
    /**
     * Get the client identifier.
     * @return The client identifier.
     */
    const string& get_client_id() const noexcept { return clientId_; }
    /**
     * Set the persistence for the client.
     * @param persistence The persistence for the client
     */
    void set_persistence(const persistence_type& persistence) { persistence_ = persistence; }
    /**
     * Get the persistence for the client.
     * @return The persistence for the client
     */
    const persistence_type& get_persistence() const noexcept { return persistence_; }
    /**
     * Gets whether the client will accept message to publish while
     * disconnected.
     */
    bool get_send_while_disconnected() const { return to_bool(opts_.sendWhileDisconnected); }
    /**
     * Sets whether the client will accept message to publish while
     * disconnected.
     *
     * @param on @em true to allow the application to publish messages while
     *  		 disconnected, @em false returns an error on publish if
     *  		 disconnected.
     * @param anyTime If @em true, allows you to publish messages before the
     *  			  first successful connection.
     */
    void set_send_while_disconnected(bool on, bool anyTime = false) {
        opts_.sendWhileDisconnected = to_int(on);
        opts_.allowDisconnectedSendAtAnyTime = to_int(anyTime);
    }
    /**
     * Gets the maximum number of offline buffered messages.
     * @return The maximum number of offline buffered messages.
     */
    int get_max_buffered_messages() const { return opts_.maxBufferedMessages; }
    /**
     * Sets the maximum number of offline buffered messages.
     * @param n The maximum number of offline buffered messages.
     */
    void set_max_buffered_messages(int n) { opts_.maxBufferedMessages = n; }
    /**
     * Gets the MQTT version used to create the client.
     * @return The MQTT version used to create the client.
     */
    int mqtt_version() const { return opts_.MQTTVersion; }
    /**
     * Sets the MQTT version used to create the client.
     * @param ver The MQTT version used to create the client.
     */
    void set_mqtt_version(int ver) { opts_.MQTTVersion = ver; }
    /**
     * Whether the oldest messages are deleted when the output buffer is
     * full.
     *
     * @return @em true if the oldest messages should be deleted when the
     *  	   output buffer is full, @em false if the new messages should
     *  	   be dropped when the buffer is full.
     */
    bool get_delete_oldest_messages() const { return to_bool(opts_.deleteOldestMessages); }
    /**
     * Determines what to do when the maximum number of buffered messages is
     * reached: delete the oldest messages rather than the newest
     * @param on @em true When the output queue is full, delete the oldest
     *  		 message, @em false drop the newest message being added.
     */
    void set_delete_oldest_messages(bool on) { opts_.deleteOldestMessages = to_int(on); }
    /**
     * Whether the messages will be restored from persistence or the store
     * will be cleared.
     * @return @em true if the messages will be restored from persistence,
     *  	   @em false if the persistence store will be cleared.
     */
    bool get_restore_messages() const { return to_bool(opts_.restoreMessages); }
    /**
     * Determine whether to restore messages from persistence or clear the
     * persistence store.
     * @param on @em true to restore messages from persistence, @em false to
     *  		 clear the persistence store.
     */
    void set_restore_messages(bool on) { opts_.restoreMessages = to_int(on); }
    /**
     * Whether to persist QoS 0 messages.
     *
     * @return @em true if QoS 0 messages are persisted, @em false if not.
     */
    bool get_persist_qos0() const { return to_bool(opts_.persistQoS0); }
    /**
     * Determine whether to persist QoS 0 messages.
     *
     * @param on @em true if QoS 0 messages are persisted, @em false if not.
     */
    void set_persist_qos0(bool on) { opts_.persistQoS0 = to_int(on); }
};

/** Smart/shared pointer to a connection options object. */
using create_options_ptr = create_options::ptr_t;

/////////////////////////////////////////////////////////////////////////////

/**
 * Builder class to generate the create options.
 */
class create_options_builder
{
    /** The underlying options */
    create_options opts_;

public:
    /** This class */
    using self = create_options_builder;
    /**
     * Default constructor.
     */
    create_options_builder() {}
    /**
     * Set the server URI.
     * @param serverURI The address of the server to connect to, specified
     *  			  as a URI
     */
    auto server_uri(const string& serverURI) -> self& {
        opts_.set_server_uri(serverURI);
        return *this;
    }
    /**
     * Sets the client ID.
     * @param clientId A client identifier that is unique on the server
     */
    auto client_id(const string& clientId) -> self& {
        opts_.set_client_id(clientId);
        return *this;
    }
    /**
     * Sets the persistence.
     * @param persistence The persistence the client should use.
     */
    auto persistence(const persistence_type& persistence) -> self& {
        opts_.set_persistence(persistence);
        return *this;
    }
    /**
     * Sets whether the client will accept message to publish while
     * disconnected.
     *
     * @param on @em true to allow the application to publish messages while
     *  		 disconnected, @em false returns an error on publish if
     *  		 disconnected.
     * @param anyTime If @em true, allows you to publish messages before the
     *  			  first successful connection.
     * @return A reference to this object.
     */
    auto send_while_disconnected(bool on = true, bool anyTime = false) -> self& {
        opts_.opts_.sendWhileDisconnected = to_int(on);
        opts_.opts_.allowDisconnectedSendAtAnyTime = to_int(anyTime);
        return *this;
    }
    /**
     * Sets the maximum number of offline buffered messages.
     * @param n The maximum number of offline buffered messages.
     * @return A reference to this object.
     */
    auto max_buffered_messages(int n) -> self& {
        opts_.opts_.maxBufferedMessages = n;
        return *this;
    }
    /**
     * Sets the MQTT version used to create the client.
     * @param ver The MQTT version used to create the client.
     */
    auto mqtt_version(int ver) -> self& {
        opts_.opts_.MQTTVersion = ver;
        return *this;
    }
    /**
     * Determines what to do when the maximum number of buffered messages is
     * reached: delete the oldest messages rather than the newest.
     * @param on @em true When the output queue is full, delete the oldest
     *  		 message, @em false drop the newest message being added.
     * @return A reference to this object.
     */
    auto delete_oldest_messages(bool on = true) -> self& {
        opts_.opts_.deleteOldestMessages = to_int(on);
        return *this;
    }
    /**
     * Determines whether to restore persisted messages or clear the
     * persistence store. (Defaults true)
     *
     * @param on @em true to restore persisted messages, @em false to clear
     *  		 the persistence store.
     * @return A reference to this object.
     */
    auto restore_messages(bool on = true) -> self& {
        opts_.opts_.restoreMessages = to_int(on);
        return *this;
    }
    /**
     * Whether to persist QoS 0 messages. (Defaults true)
     *
     * @param on @em true persist QoS 0 messages, @em false, don't.
     * @return A reference to this object
     */
    auto persist_qos0(bool on = true) -> self& {
        opts_.opts_.persistQoS0 = to_int(on);
        return *this;
    }
    /**
     * Finish building the options and return them.
     * @return The option struct as built.
     */
    create_options finalize() { return opts_; }
};

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_create_options_h

```

`include/mqtt/delivery_token.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file delivery_token.h
/// Declaration of MQTT delivery_token class
/// @date May 1, 2013
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2013-2016 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_delivery_token_h
#define __mqtt_delivery_token_h

#include <memory>

#include "MQTTAsync.h"
#include "mqtt/message.h"
#include "mqtt/token.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/**
 * Provides a mechanism to track the delivery progress of a message.
 * Used to track the the delivery progress of a message when a publish is
 * executed in a non-blocking manner (run in the background) action.
 */
class delivery_token : public token
{
    /** The message being tracked. */
    const_message_ptr msg_;

    /** Client has special access. */
    friend class async_client;

    /**
     * Sets the message to which this token corresponds.
     * @param msg The message to which this token corresponds.
     */
    void set_message(const_message_ptr msg) { msg_ = msg; }

public:
    /** Smart/shared pointer to an object of this class */
    using ptr_t = std::shared_ptr<delivery_token>;
    /** Smart/shared pointer to a const object of this class */
    using const_ptr_t = std::shared_ptr<delivery_token>;
    /** Weak pointer to an object of this class */
    using weak_ptr_t = std::weak_ptr<delivery_token>;

    /**
     * Creates an empty delivery token connected to a particular client.
     * @param cli The asynchronous client object.
     */
    delivery_token(iasync_client& cli) : token(token::Type::PUBLISH, cli) {}
    /**
     * Creates a delivery token connected to a particular client.
     * @param cli The asynchronous client object.
     * @param msg The message being tracked.
     */
    delivery_token(iasync_client& cli, const_message_ptr msg)
        : token(token::Type::PUBLISH, cli, msg->get_topic()), msg_(std::move(msg)) {}
    /**
     * Creates a delivery token connected to a particular client.
     * @param cli The asynchronous client object.
     * @param msg The message data.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb callback optional listener that will be notified when message
     *  			   delivery has completed to the requested quality of
     *  			   service
     */
    delivery_token(
        iasync_client& cli, const_message_ptr msg, void* userContext, iaction_listener& cb
    )
        : token(token::Type::PUBLISH, cli, msg->get_topic(), userContext, cb),
          msg_(std::move(msg)) {}
    /**
     * Creates an empty delivery token connected to a particular client.
     * @param cli The asynchronous client object.
     */
    static ptr_t create(iasync_client& cli) { return std::make_shared<delivery_token>(cli); }
    /**
     * Creates a delivery token connected to a particular client.
     * @param cli The asynchronous client object.
     * @param msg The message data.
     */
    static ptr_t create(iasync_client& cli, const_message_ptr msg) {
        return std::make_shared<delivery_token>(cli, msg);
    }
    /**
     * Creates a delivery token connected to a particular client.
     * @param cli The asynchronous client object.
     * @param msg The message data.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb callback optional listener that will be notified when message
     *  			   delivery has completed to the requested quality of
     *  			   service
     */
    static ptr_t create(
        iasync_client& cli, const_message_ptr msg, void* userContext, iaction_listener& cb
    ) {
        return std::make_shared<delivery_token>(cli, msg, userContext, cb);
    }
    /**
     * Gets the message associated with this token.
     * @return The message associated with this token.
     */
    virtual const_message_ptr get_message() const { return msg_; }
};

/** Smart/shared pointer to a delivery_token */
using delivery_token_ptr = delivery_token::ptr_t;

/** Smart/shared pointer to a const delivery_token */
using const_delivery_token_ptr = delivery_token::const_ptr_t;

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_delivery_token_h

```

`include/mqtt/disconnect_options.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file disconnect_options.h
/// Implementation of the class 'disconnect_options'
/// @date 26-Aug-2016
/////////////////////////////////////////////////////////////////////////////

/****************************************************************************
 * Copyright (c) 2016-2017 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 ***************************************************************************/

#ifndef __mqtt_disconnect_options_h
#define __mqtt_disconnect_options_h

#include <chrono>

#include "MQTTAsync.h"
#include "mqtt/properties.h"
#include "mqtt/token.h"
#include "mqtt/types.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/**
 * Options for disconnecting from an MQTT broker.
 */
class disconnect_options
{
    /** The default C struct */
    static constexpr MQTTAsync_disconnectOptions DFLT_C_STRUCT
        MQTTAsync_disconnectOptions_initializer;

    /** The default C struct */
    static constexpr MQTTAsync_disconnectOptions DFLT_C_STRUCT5
        MQTTAsync_disconnectOptions_initializer5;

    /** The underlying C disconnect options */
    MQTTAsync_disconnectOptions opts_{DFLT_C_STRUCT};

    /** Shared token pointer for context, if any */
    token_ptr tok_;

    /** Disconnect message properties */
    properties props_;

    /** The client has special access */
    friend class async_client;

    /** The options builder has special access */
    friend class disconnect_options_builder;

    /**
     * Updates the underlying C structure to match our cached data.
     */
    void update_c_struct();

    /** Construct options from a C struct */
    disconnect_options(const MQTTAsync_disconnectOptions& copts) : opts_{copts} {}

public:
    /**
     * Create an empty delivery response object.
     */
    disconnect_options() {}
    /**
     * Creates disconnect options tied to the specific token.
     * @param timeout The timeout (in milliseconds).
     */
    disconnect_options(int timeout) : disconnect_options() { set_timeout(timeout); }
    /**
     * Creates disconnect options tied to the specific token.
     * @param to The timeout.
     */
    template <class Rep, class Period>
    disconnect_options(const std::chrono::duration<Rep, Period>& to) : disconnect_options() {
        set_timeout(to);
    }
    /**
     * Copy constructor.
     * @param opt Another object to copy.
     */
    disconnect_options(const disconnect_options& opt);
    /**
     * Move constructor.
     * @param opt Another object to move into this new one.
     */
    disconnect_options(disconnect_options&& opt);
    /**
     * Creates default options for an MQTT v3.x connection.
     * @return Default options for an MQTT v3.x connection.
     */
    static disconnect_options v3() { return disconnect_options{DFLT_C_STRUCT}; }
    /**
     * Creates default options for an MQTT v5 connection.
     * @return Default options for an MQTT v5 connection.
     */
    static disconnect_options v5() { return disconnect_options{DFLT_C_STRUCT5}; }
    /**
     * Copy assignment.
     * @param opt Another object to copy.
     */
    disconnect_options& operator=(const disconnect_options& opt);
    /**
     * Move assignment.
     * @param opt Another object to move into this new one.
     */
    disconnect_options& operator=(disconnect_options&& opt);
/**
 * Expose the underlying C struct for the unit tests.
 */
#if defined(UNIT_TESTS)
    const MQTTAsync_disconnectOptions& c_struct() const { return opts_; }
#endif
    /**
     * Gets the timeout used for disconnecting.
     * @return The timeout for disconnecting (in milliseconds).
     */
    std::chrono::milliseconds get_timeout() const {
        return std::chrono::milliseconds(opts_.timeout);
    }
    /**
     * Sets the disconnect timeout, in milliseconds.
     * This allows for any remaining in-flight messages to be delivered.
     * @param timeout The disconnect timeout (in milliseconds).
     */
    void set_timeout(int timeout) { opts_.timeout = timeout; }
    /**
     * Sets the disconnect timeout with a duration.
     * This allows for any remaining in-flight messages to be delivered.
     * @param to The disconnect connect timeout.
     */
    template <class Rep, class Period>
    void set_timeout(const std::chrono::duration<Rep, Period>& to) {
        // TODO: check range
        set_timeout((int)to_milliseconds_count(to));
    }
    /**
     * Sets the callback context to a delivery token.
     * @param tok The delivery token to be used as the callback context.
     * @param mqttVersion The version of MQTT we're using for the
     *  				  connection.
     */
    void set_token(const token_ptr& tok, int mqttVersion);
    /**
     * Gets the callback context to a delivery token.
     * @return The delivery token to be used as the callback context.
     */
    token_ptr get_token() const { return tok_; }
    /**
     * Gets the disconnect properties.
     * @return A const reference to the properties for the disconnect.
     */
    const properties& get_properties() const { return props_; }
    /**
     * Gets a mutable reference to the disconnect properties.
     * @return A mutable reference to the properties for the disconnect.
     */
    properties& get_properties() { return props_; }
    /**
     * Sets the properties for the connect.
     * @param props The properties to place into the message.
     */
    void set_properties(const properties& props) {
        props_ = props;
        opts_.properties = props_.c_struct();
    }
    /**
     * Moves the properties for the connect.
     * @param props The properties to move into the connect object.
     */
    void set_properties(properties&& props) {
        props_ = std::move(props);
        opts_.properties = props_.c_struct();
    }
    /**
     * Gets the reason code for the disconnect.
     * @return The reason code for the disconnect.
     */
    ReasonCode get_reason_code() const { return ReasonCode(opts_.reasonCode); }
    /**
     * Sets the reason code for the disconnect.
     * @param code The reason code for the disconnect.
     */
    void set_reason_code(ReasonCode code) { opts_.reasonCode = MQTTReasonCodes(code); }
};

/////////////////////////////////////////////////////////////////////////////

/**
 * Class to build connect options.
 */
class disconnect_options_builder
{
    /** The underlying options */
    disconnect_options opts_;

    /** Construct options builder from a C struct */
    disconnect_options_builder(const MQTTAsync_disconnectOptions& copts) : opts_{copts} {}

public:
    /** This class */
    using self = disconnect_options_builder;
    /**
     * Default constructor.
     */
    disconnect_options_builder() {}
    /**
     * Creates default options builder for an MQTT v3.x connection.
     * @return Default options builder for an MQTT v3.x connection.
     */
    static disconnect_options_builder v3() {
        return disconnect_options_builder{disconnect_options::DFLT_C_STRUCT};
    }
    /**
     * Creates default options builder for an MQTT v5 connection.
     * @return Default options builder for an MQTT v5 connection.
     */
    static disconnect_options_builder v5() {
        return disconnect_options_builder{disconnect_options::DFLT_C_STRUCT5};
    }
    /**
     * Sets the properties for the disconnect message.
     * @param props The properties for the disconnect message.
     */
    auto properties(mqtt::properties&& props) -> self& {
        opts_.set_properties(std::move(props));
        return *this;
    }
    /**
     * Sets the properties for the disconnect message.
     * @param props The properties for the disconnect message.
     */
    auto properties(const mqtt::properties& props) -> self& {
        opts_.set_properties(props);
        return *this;
    }
    /**
     * Sets the disconnect connect timeout.
     * This allows for any remaining in-flight messages to be delivered.
     * @param to The disconnect timeout.
     */
    template <class Rep, class Period>
    auto timeout(const std::chrono::duration<Rep, Period>& to) -> self& {
        opts_.set_timeout(to);
        return *this;
    }
    /**
     * Sets the reason code for the disconnect.
     * @param code The reason code for the disconnect.
     */
    auto reason_code(ReasonCode code) -> self& {
        opts_.set_reason_code(code);
        return *this;
    }
    /**
     * Finish building the options and return them.
     * @return The option struct as built.
     */
    disconnect_options finalize() { return opts_; }
};

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_disconnect_options_h

```

`include/mqtt/event.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file event.h
/// Declaration of MQTT event-related classes
/// @date July 6, 2024
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_event_h
#define __mqtt_event_h

#include <variant>

#include "mqtt/message.h"
#include "mqtt/properties.h"
#include "mqtt/reason_code.h"
#include "mqtt/types.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/** Event for when the client is connected/reconnected */
struct connected_event
{
    string cause;
};

/** Event for when the connection is lost */
struct connection_lost_event
{
    string cause;
};

/** Event for when we receive a DISCONNECT packet from the server */
struct disconnected_event
{
    properties props;
    ReasonCode reasonCode;
};

/** Event for when the consumer queue is shutdown from another thread */
struct shutdown_event
{
};

/* Event for when a message arrives is just a message pointer */

/////////////////////////////////////////////////////////////////////////////

/**
 * An MQTT event.
 *
 * This is used by the client consumer to pass events and state changes from
 * the client to the application without the need for any additional
 * callbacks or client queries.
 *
 * Each instance carries the relevant data for specific event that caused
 * it. For example an incoming message event contains a shared pointer to
 * the message that arrived.
 *
 * The supported event types are:
 * @li **message** A message arrived from the server.
 * @li **connected** The client connected. If the client was configured for
 * automatic reconnects, this can be from a reconnection. (No data)
 * @li **connection lost** The client lost the connection. (No data)
 * @li **disconnected** (v5) The client received a DISCONNECT packet from
 * the server. This includes the reason code and properties for the
 * disconnect.
 */
class event
{
public:
    /** The variant type for any possible event. */
    using event_type = std::variant<
        const_message_ptr, connected_event, connection_lost_event, disconnected_event,
        shutdown_event>;

private:
    event_type evt_{};

public:
    /**
     * Constructs an empty event.
     * This shows as a message, but the message pointer is null.
     */
    event() {}
    /**
     * Constructs an event from an event type variant.
     * @param evt The event type variant.
     */
    event(event_type evt) : evt_{std::move(evt)} {}
    /**
     * Constructs a message event.
     * @param msg A shared message pointer.
     */
    event(message_ptr msg) : evt_{std::move(msg)} {}
    /**
     * Constructs a message event.
     * @param msg A shared const message pointer.
     */
    event(const_message_ptr msg) : evt_{std::move(msg)} {}
    /**
     * Constructs a 'connected' event.
     * @param evt A connected event.
     */
    event(connected_event evt) : evt_{std::move(evt)} {}
    /**
     * Constructs a 'connection lost' event.
     * @param evt A connection lost event.
     */
    event(connection_lost_event evt) : evt_{std::move(evt)} {}
    /**
     * Constructs a 'disconnected' event.
     * @param evt A disconnected event.
     */
    event(disconnected_event evt) : evt_{std::move(evt)} {}
    /**
     * Constructs a 'shutdown' event.
     * @param evt A shutdown event.
     */
    event(shutdown_event evt) : evt_{std::move(evt)} {}
    /**
     * Copy constructor.
     * @param evt The event to copy.
     */
    event(const event& evt) : evt_{evt.evt_} {}
    /**
     * Move constructor.
     * @param evt The event to move.
     */
    event(event&& evt) : evt_{std::move(evt.evt_)} {}
    /**
     * Assignment from an event type variant.
     * @param evt The event type variant.
     * @return A reference to this object.
     */
    event& operator=(event_type evt) {
        evt_ = std::move(evt);
        return *this;
    }
    /**
     * Copy assignment.
     * @param rhs The event to copy.
     * @return A reference to this object.
     */
    event& operator=(const event& rhs) {
        if (&rhs != this)
            evt_ = rhs.evt_;
        return *this;
    }
    /**
     * Move assignment.
     * @param rhs The event to move.
     * @return A reference to this object.
     */
    event& operator=(event&& rhs) {
        if (&rhs != this)
            evt_ = std::move(rhs.evt_);
        return *this;
    }
    /**
     * Determines if this event is an incoming message.
     * @return @em true if this event is an incoming message, @em false
     *         otherwise.
     */
    bool is_message() const { return std::holds_alternative<const_message_ptr>(evt_); }
    /**
     * Determines if this event is a client (re)connection.
     * @return @em true if this event is a client connection, @em false
     *         otherwise.
     */
    bool is_connected() const { return std::holds_alternative<connected_event>(evt_); }
    /**
     * Determines if this event is a client connection lost.
     * @return @em true if this event is a client connection lost, @em false
     *         otherwise.
     */
    bool is_connection_lost() const {
        return std::holds_alternative<connection_lost_event>(evt_);
    }
    /**
     * Determines if this event is a client disconnected.
     * @return @em true if this event is a client disconnected, @em false
     *         otherwise.
     */
    bool is_disconnected() const { return std::holds_alternative<disconnected_event>(evt_); }
    /**
     * Determines if this event is an internal shutdown request.
     * @return @em true if this event is a shutdown request, @em false
     *         otherwise.
     */
    bool is_shutdown() const { return std::holds_alternative<disconnected_event>(evt_); }
    /**
     * Determines if this is any type of client disconnect or shutdown.
     * @return @em true if this event is any type of client disconnect such
     *         as a 'connection lost', 'disconnected', or shutdown event.
     */
    bool is_any_disconnect() const {
        return std::holds_alternative<connection_lost_event>(evt_) ||
               std::holds_alternative<disconnected_event>(evt_) ||
               std::holds_alternative<shutdown_event>(evt_);
    }
    /**
     * Gets the message from the event, iff this is a message event.
     * @return A message pointer, if this is a message event.
     * @throw std::bad_variant_access if this is not a 'message' event.
     */
    const_message_ptr get_message() { return std::get<const_message_ptr>(evt_); }
    /**
     * Gets the underlying information for a disconnected event iff this is
     * a 'disconnected' event.
     * This contains the reason code and properties that the server sent in
     * the DISCONNECT packet.
     * @return The disconnected event object containing information about
     *         why the server disconnected.
     * @throw std::bad_variant_access if this is not a 'disconnected' event.
     */
    disconnected_event get_disconnected() { return std::get<disconnected_event>(evt_); }
    /**
     * Gets a pointer to the message in the event, iff this is a message
     * event.
     * @return A pointer to a message pointer, if this is a message event.
     *         Returns nulltr if this is not a message event.
     */
    constexpr std::add_pointer_t<const_message_ptr> get_message_if() noexcept {
        return std::get_if<const_message_ptr>(&evt_);
    }
    /**
     * Gets a pointer the underlying information for a disconnected event,
     * iff this is a 'disconnected' event.
     * This contains the reason code and properties that the server sent in
     * the DISCONNECT packet.
     * @return The disconnected event object containing information about
     *         why the server disconnected.
     * @throw std::bad_variant_access if this is not a 'disconnected' event.
     */
    constexpr std::add_pointer_t<disconnected_event> get_disconnected_if() noexcept {
        return std::get_if<disconnected_event>(&evt_);
    }
};

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_event_h

```

`include/mqtt/exception.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file exception.h
/// Declaration of MQTT exception class
/// @date May 1, 2013
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2013-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_exception_h
#define __mqtt_exception_h

#include <exception>
#include <iostream>
#include <memory>
#include <stdexcept>
#include <vector>

#include "MQTTAsync.h"
#include "mqtt/types.h"

namespace mqtt {

/** Bring std::bad_cast into the mqtt namespace */
using bad_cast = std::bad_cast;

/////////////////////////////////////////////////////////////////////////////

/**
 * Base mqtt::exception.
 * This wraps the error codes which originate from the underlying C library.
 */
class exception : public std::runtime_error
{
protected:
    /** The error return code from the C library */
    int rc_;
    /** The reason code from the server */
    ReasonCode reasonCode_;
    /** The error message from the C library */
    string msg_;

    /** See if the return code is actually a reason code error value */
    static ReasonCode reason_code(int rc, ReasonCode reasonCode) {
        if (reasonCode == ReasonCode::SUCCESS && rc >= ReasonCode::UNSPECIFIED_ERROR)
            reasonCode = ReasonCode(rc);
        return reasonCode;
    }

public:
    /**
     * Creates an MQTT exception.
     * @param rc The error return code from the C library.
     */
    explicit exception(int rc) : exception(rc, error_str(rc)) {}
    /**
     * Creates an MQTT exception.
     * @param rc The error return code from the C library.
     * @param reasonCode The reason code from the server response.
     */
    explicit exception(int rc, ReasonCode reasonCode)
        : exception(rc, reasonCode, error_str(rc)) {}
    /**
     * Creates an MQTT exception.
     * @param rc The error return code from the C library.
     * @param msg The text message for the error.
     */
    exception(int rc, const string& msg) : exception(rc, ReasonCode::SUCCESS, msg) {}
    /**
     * Creates an MQTT exception.
     * @param rc The error return code from the C library.
     * @param reasonCode The reason code from the server
     * @param msg The text message for the error.
     */
    exception(int rc, ReasonCode reasonCode, const string& msg)
        : std::runtime_error(printable_error(rc, reasonCode, msg)),
          rc_{rc},
          reasonCode_{reason_code(rc, reasonCode)},
          msg_{msg} {}
    /**
     * Gets an error message from an error code.
     * @param rc The error code from the C lib
     * @return A string explanation of the error
     */
    static string error_str(int rc) {
        const char* msg = ::MQTTAsync_strerror(rc);
        return msg ? string(msg) : string();
    }
    /**
     * Gets a string describing the MQTT v5 reason code.
     * @param reasonCode The MQTT v5 reason code.
     * @return A string describing the reason code.
     */
    static string reason_code_str(int reasonCode) {
        auto msg = ::MQTTReasonCode_toString(MQTTReasonCodes(reasonCode));
        return (msg) ? string{msg} : string{};
    }
    /**
     * Gets a detailed error message for an error code.
     * @param rc The error code from the C lib
     * @param reasonCode The MQTT v5 reason code
     * @param msg An optional additional message. If none is provided, the
     *  		  error_str message is used.
     * @return A string error message that includes the error code and an
     *  	   explanation message.
     */
    static string printable_error(
        int rc, ReasonCode reasonCode = ReasonCode::SUCCESS, const string& msg = string()
    ) {
        reasonCode = reason_code(rc, reasonCode);

        string s = "MQTT error [" + std::to_string(rc) + "]";
        if (!msg.empty())
            s += string(": ") + msg;
        if (reasonCode != ReasonCode::SUCCESS)
            s += string(". ") + reason_code_str(reasonCode);
        return s;
    }
    /**
     * Returns the return code for this exception.
     */
    int get_return_code() const { return rc_; }
    /**
     * Gets a string of the error code.
     * @return A string of the error code.
     */
    string get_error_str() const { return error_str(rc_); }
    /**
     * Returns the reason code for this exception.
     * For MQTT v3 connections, this is actually the return code.
     */
    int get_reason_code() const { return reasonCode_; }
    /**
     * Gets a string for the reason code.
     * @return A string for the reason code.
     */
    string get_reason_code_str() const { return reason_code_str(reasonCode_); }
    /**
     * Returns the error message for this exception.
     */
    string get_message() const { return msg_; }
    /**
     * Gets a string representation of this exception.
     * @return A string representation of this exception.
     */
    string to_string() const { return string(what()); }
};

/**
 * Stream inserter writes a fairly verbose message
 * @param os The stream.
 * @param exc The exception to write.
 * @return A reference to the stream.
 */
inline std::ostream& operator<<(std::ostream& os, const exception& exc) {
    os << exc.what();
    return os;
}

/////////////////////////////////////////////////////////////////////////////

/**
 * Exception thrown when an expected server response is missing.
 */
class missing_response : public exception
{
public:
    /**
     * Create a missing response error.
     * @param rsp A string for the type of response expected.
     */
    missing_response(const string& rsp)
        : exception(MQTTASYNC_FAILURE, "Missing " + rsp + " response") {}
};

/////////////////////////////////////////////////////////////////////////////

/**
 * A timeout exception, particularly from the synchronous client.
 */
class timeout_error : public exception
{
public:
    /**
     * Create a timeout error.
     */
    timeout_error() : exception(MQTTASYNC_FAILURE, "Timeout") {}
};

/////////////////////////////////////////////////////////////////////////////

/**
 * This exception is thrown by the implementor of the persistence interface
 * if there is a problem reading or writing persistent data.
 */
class persistence_exception : public exception
{
public:
    /**
     * Creates an MQTT persistence exception.
     */
    persistence_exception() : exception(MQTTCLIENT_PERSISTENCE_ERROR) {}
    /**
     * Creates an MQTT persistence exception.
     * @param code The error code from the C library.
     */
    explicit persistence_exception(int code) : exception(code) {}
    /**
     * Creates an MQTT persistence exception.
     * @param msg The text message for the error.
     */
    explicit persistence_exception(const string& msg)
        : exception(MQTTCLIENT_PERSISTENCE_ERROR, msg) {}
    /**
     * Creates an MQTT persistence exception.
     * @param code The error code
     * @param msg The text message for the error.
     */
    persistence_exception(int code, const string& msg) : exception(code, msg) {}
};

/////////////////////////////////////////////////////////////////////////////

/**
 * Thrown when a client is not authorized to perform an operation, or if
 * there is a problem with the security configuration.
 */
class security_exception : public exception
{
public:
    /**
     * Creates an MQTT security exception
     * @param code The error code.
     */
    explicit security_exception(int code) : exception(code) {}
    /**
     * Creates an MQTT security exception
     * @param code The error code.
     * @param msg The text message for the error.
     */
    security_exception(int code, const string& msg) : exception(code, msg) {}
};

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_exception_h

```

`include/mqtt/export.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file export.h
/// Library symbol export definitions, primarily for Windows MSVC DLL's
/// @date November 20, 2023
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *    Frank Pagliughi - MQTT v5 support
 *******************************************************************************/

#ifndef __mqtt_export_h
#define __mqtt_export_h

#if defined(_WIN32) && defined(_MSC_VER)
    #if defined(PAHO_MQTTPP_EXPORTS)
        #define PAHO_MQTTPP_EXPORT __declspec(dllexport)
    #elif defined(PAHO_MQTTPP_IMPORTS)
        #define PAHO_MQTTPP_EXPORT __declspec(dllimport)
    #else
        #define PAHO_MQTTPP_EXPORT
    #endif
#else
    #if defined(PAHO_MQTTPP_EXPORTS)
        #define PAHO_MQTTPP_EXPORT __attribute__((visibility("default")))
    #else
        #define PAHO_MQTTPP_EXPORT
    #endif
#endif

#endif  // __mqtt_export_h

```

`include/mqtt/iaction_listener.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file iaction_listener.h
/// Declaration of MQTT iaction_listener class
/// @date May 1, 2013
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2013-2016 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_iaction_listener_h
#define __mqtt_iaction_listener_h

#include <vector>

#include "MQTTAsync.h"
#include "mqtt/types.h"

namespace mqtt {

class token;

/////////////////////////////////////////////////////////////////////////////

/**
 * Provides a mechanism for tracking the completion of an asynchronous
 * action.
 *
 * A listener is registered on a token and that token is associated with
 * an action like connect or publish. When used with tokens on the
 * async_client the listener will be called back on the MQTT client's
 * thread. The listener will be informed if the action succeeds or fails. It
 * is important that the listener returns control quickly otherwise the
 * operation of the MQTT client will be stalled.
 */
class iaction_listener
{
public:
    /** Smart/shared pointer to an object of this class. */
    using ptr_t = std::shared_ptr<iaction_listener>;
    /** Smart/shared pointer to a const object of this class. */
    using const_ptr_t = std::shared_ptr<const iaction_listener>;

    /**
     * Virtual base destructor.
     */
    virtual ~iaction_listener() {}
    /**
     * This method is invoked when an action fails.
     * @param asyncActionToken The token
     */
    virtual void on_failure(const token& asyncActionToken) = 0;
    /**
     * This method is invoked when an action has completed successfully.
     * @param asyncActionToken The token
     */
    virtual void on_success(const token& asyncActionToken) = 0;
};

/** Smart/shared pointer to an action listener */
using iaction_listener_ptr = iaction_listener::ptr_t;

/** Smart/shared pointer to a const action listener */
using const_iaction_listener_ptr = iaction_listener::const_ptr_t;

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_iaction_listener_h

```

`include/mqtt/iasync_client.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file iasync_client.h
/// Implementation of the interface for the asynchronous clients,
/// 'iasync_client'
/// @date 25-Aug-2016
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2013-2016 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_iasync_client_h
#define __mqtt_iasync_client_h

#include <vector>

#include "mqtt/callback.h"
#include "mqtt/connect_options.h"
#include "mqtt/delivery_token.h"
#include "mqtt/disconnect_options.h"
#include "mqtt/event.h"
#include "mqtt/exception.h"
#include "mqtt/iaction_listener.h"
#include "mqtt/iclient_persistence.h"
#include "mqtt/message.h"
#include "mqtt/subscribe_options.h"
#include "mqtt/token.h"
#include "mqtt/types.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/**
 * Enables an application to communicate with an MQTT server using
 * non-blocking methods.
 *
 * It provides applications a simple programming interface to all features
 * of the MQTT version 3.1 specification including:
 *
 * @li connect
 * @li publish
 * @li subscribe
 * @li unsubscribe
 * @li disconnect
 */
class iasync_client
{
    friend class token;
    virtual void remove_token(token* tok) = 0;

public:
    /** Type for a collection of QOS values */
    using qos_collection = std::vector<int>;

    /**
     * Virtual destructor
     */
    virtual ~iasync_client() {}
    /**
     * Connects to an MQTT server using the default options.
     * @return token used to track and wait for the connect to complete. The
     *  	   token will be passed to any callback that has been set.
     * @throw exception for non security related problems
     * @throw security_exception for security related problems
     */
    virtual token_ptr connect() = 0;
    /**
     * Connects to an MQTT server using the provided connect options.
     * @param options a set of connection parameters that override the
     *  			  defaults.
     * @return token used to track and wait for the connect to complete. The
     *  	   token will be passed to any callback that has been set.
     * @throw exception for non security related problems
     * @throw security_exception for security related problems
     */
    virtual token_ptr connect(connect_options options) = 0;
    /**
     * Connects to an MQTT server using the specified options.
     *
     * @param options a set of connection parameters that override the
     *  			  defaults.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb callback listener that will be notified when the connect
     *  			   completes.
     * @return token used to track and wait for the connect to complete. The
     *  	   token will be passed to any callback that has been set.
     * @throw exception for non security related problems
     * @throw security_exception for security related problems
     */
    virtual token_ptr connect(
        connect_options options, void* userContext, iaction_listener& cb
    ) = 0;
    /**
     *
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb listener that will be notified when the connect completes.
     * @return token used to track and wait for the connect to complete. The
     *  	   token will be passed to any callback that has been set.
     * @throw exception for non security related problems
     * @throw security_exception for security related problems
     */
    virtual token_ptr connect(void* userContext, iaction_listener& cb) = 0;
    /**
     * Reconnects the client using options from the previous connect.
     * The client must have previously called connect() for this to work.
     * @return token used to track the progress of the reconnect.
     */
    virtual token_ptr reconnect() = 0;
    /**
     * Disconnects from the server.
     * @return token used to track and wait for the disconnect to complete.
     *  	   The token will be passed to any callback that has been set.
     * @throw exception for problems encountered while disconnecting
     */
    virtual token_ptr disconnect() = 0;
    /**
     * Disconnects from the server.
     * @param opts Options for disconnecting.
     * @return token used to track and wait for the disconnect to complete.
     *  	   The token will be passed to any callback that has been set.
     * @throw exception for problems encountered while disconnecting
     */
    virtual token_ptr disconnect(disconnect_options opts) = 0;
    /**
     * Disconnects from the server.
     * @param timeout the amount of time in milliseconds to allow for
     *  			  existing work to finish before disconnecting. A value
     *  			  of zero or less means the client will not quiesce.
     * @return token used to track and wait for the disconnect to complete.
     *  	   The token will be passed to any callback that has been set.
     * @throw exception for problems encountered while disconnecting
     */
    virtual token_ptr disconnect(int timeout) = 0;
    /**
     * Disconnects from the server.
     * @param timeout the amount of time in milliseconds to allow for
     *  			  existing work to finish before disconnecting. A value
     *  			  of zero or less means the client will not quiesce.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb listener that will be notified when the disconnect
     *  		 completes.
     * @return token used to track and wait for the disconnect to complete.
     *  	   The token will be passed to any callback that has been set.
     * @throw exception for problems encountered while disconnecting
     */
    virtual token_ptr disconnect(int timeout, void* userContext, iaction_listener& cb) = 0;
    /**
     * Disconnects from the server.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb listener that will be notified when the disconnect
     *  		 completes.
     * @return token used to track and wait for the disconnect to complete.
     *  	   The token will be passed to any callback that has been set.
     * @throw exception for problems encountered while disconnecting
     */
    virtual token_ptr disconnect(void* userContext, iaction_listener& cb) = 0;
    /**
     * Returns the delivery token for the specified message ID.
     * @return delivery_token
     */
    virtual delivery_token_ptr get_pending_delivery_token(int msgID) const = 0;
    /**
     * Returns the delivery tokens for any outstanding publish operations.
     * @return delivery_token[]
     */
    virtual std::vector<delivery_token_ptr> get_pending_delivery_tokens() const = 0;
    /**
     * Returns the client ID used by this client.
     * @return string
     */
    virtual string get_client_id() const = 0;
    /**
     * Returns the address of the server used by this client.
     */
    virtual string get_server_uri() const = 0;
    /**
     * Determines if this client is currently connected to the server.
     */
    virtual bool is_connected() const = 0;
    /**
     * Publishes a message to a topic on the server
     * @param topic The topic to deliver the message to
     * @param payload The bytes to use as the message payload
     * @param n The number of bytes in the payload
     * @param qos The Quality of Service to deliver the message at. Valid
     *  		  values are 0, 1 or 2.
     * @param retained Whether or not this message should be retained by the
     *  			   server.
     * @return token used to track and wait for the publish to complete. The
     *  	   token will be passed to callback methods if set.
     */
    virtual delivery_token_ptr publish(
        string_ref topic, const void* payload, size_t n, int qos, bool retained,
        const properties& props = properties()
    ) = 0;
    /**
     * Publishes a message to a topic on the server
     * @param topic The topic to deliver the message to
     * @param payload the bytes to use as the message payload
     * @param n the number of bytes in the payload
     * @return token used to track and wait for the publish to complete. The
     *  	   token will be passed to callback methods if set.
     */
    virtual delivery_token_ptr publish(string_ref topic, const void* payload, size_t n) = 0;
    /**
     * Publishes a message to a topic on the server
     * @param topic The topic to deliver the message to
     * @param payload The bytes to use as the message payload
     * @param n The number of bytes in the payload
     * @param qos The Quality of Service to deliver the message at. Valid
     *  		  values are 0, 1 or 2.
     * @param retained whether or not this message should be retained by the
     *  			   server.
     * @param userContext Optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb The listener callback object
     * @return token used to track and wait for the publish to complete. The
     *  	   token will be passed to callback methods if set.
     */
    virtual delivery_token_ptr publish(
        string_ref topic, const void* payload, size_t n, int qos, bool retained,
        void* userContext, iaction_listener& cb
    ) = 0;
    /**
     * Publishes a message to a topic on the server
     * @param topic The topic to deliver the message to
     * @param payload the bytes to use as the message payload
     * @param qos the Quality of Service to deliver the message at. Valid
     *  		  values are 0, 1 or 2.
     * @param retained whether or not this message should be retained by the
     *  			   server.
     * @return token used to track and wait for the publish to complete. The
     *  	   token will be passed to callback methods if set.
     */
    virtual delivery_token_ptr publish(
        string_ref topic, binary_ref payload, int qos, bool retained,
        const properties& props = properties()
    ) = 0;
    /**
     * Publishes a message to a topic on the server.
     * @param topic The topic to deliver the message to
     * @param payload the bytes to use as the message payload
     * @return token used to track and wait for the publish to complete. The
     *  	   token will be passed to callback methods if set.
     */
    virtual delivery_token_ptr publish(string_ref topic, binary_ref payload) = 0;
    /**
     * Publishes a message to a topic on the server Takes an Message
     * message and delivers it to the server at the requested quality of
     * service.
     * @param msg the message to deliver to the server
     * @return token used to track and wait for the publish to complete. The
     *  	   token will be passed to callback methods if set.
     */
    virtual delivery_token_ptr publish(const_message_ptr msg) = 0;
    /**
     * Publishes a message to a topic on the server.
     * @param msg the message to deliver to the server
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb optional listener that will be notified when message
     *  		 delivery has completed to the requested quality of service
     * @return token used to track and wait for the publish to complete. The
     *  	   token will be passed to callback methods if set.
     */
    virtual delivery_token_ptr publish(
        const_message_ptr msg, void* userContext, iaction_listener& cb
    ) = 0;
    /**
     * Sets a callback listener to use for events that happen
     * asynchronously.
     * @param cb callback which will be invoked for certain asynchronous
     *  		 events
     */
    virtual void set_callback(callback& cb) = 0;
    /**
     * Stops the callbacks.
     */
    virtual void disable_callbacks() = 0;
    /**
     * Subscribe to a topic, which may include wildcards.
     * @param topicFilter the topic to subscribe to, which can include
     *  				  wildcards.
     * @param qos the maximum quality of service at which to subscribe.
     *  		  Messages published at a lower quality of service will be
     *  		  received at the published QoS. Messages published at a
     *  		  higher quality of service will be received using the QoS
     *  		  specified on the subscribe.
     * @param opts The options for the subscription.
     * @param props The MQTT v5 properties.
     * @return token used to track and wait for the subscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    virtual token_ptr subscribe(
        const string& topicFilter, int qos,
        const subscribe_options& opts = subscribe_options(),
        const properties& props = properties()
    ) = 0;
    /**
     * Subscribe to a topic, which may include wildcards.
     * @param topicFilter the topic to subscribe to, which can include
     *  				  wildcards.
     * @param qos the maximum quality of service at which to subscribe.
     *  		  Messages published at a lower quality of service will be
     *  		  received at the published QoS. Messages published at a
     *  		  higher quality of service will be received using the QoS
     *  		  specified on the subscribe.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param callback listener that will be notified when subscribe has
     *  			   completed
     * @param opts The options for the subscription.
     * @param props The MQTT v5 properties.
     * @return token used to track and wait for the subscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    virtual token_ptr subscribe(
        const string& topicFilter, int qos, void* userContext, iaction_listener& callback,
        const subscribe_options& opts = subscribe_options(),
        const properties& props = properties()
    ) = 0;
    /**
     * Subscribe to multiple topics, each of which may include wildcards.
     * Provides an optimized way to subscribe to multiple topics compared to
     * subscribing to each one individually.
     * @param topicFilters one or more topics to subscribe to, which can
     *  				   include wildcards
     * @param qos the maximum quality of service at which to subscribe.
     *  		  Messages published at a lower quality of service will be
     *  		  received at the published QoS. Messages published at a
     *  		  higher quality of service will be received using the QoS
     *  		  specified on the subscribe.
     * @param opts A collection of subscription options (one for each
     *  		   topic)
     * @param props The MQTT v5 properties.
     * @return token used to track and wait for the subscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    virtual token_ptr subscribe(
        const_string_collection_ptr topicFilters, const qos_collection& qos,
        const std::vector<subscribe_options>& opts = std::vector<subscribe_options>(),
        const properties& props = properties()
    ) = 0;
    /**
     * Subscribes to multiple topics, each of which may include wildcards.
     * @param topicFilters one or more topics to subscribe to, which can
     *  				   include wildcards
     * @param qos  the maximum quality of service at which to subscribe.
     *  		   Messages published at a lower quality of service will be
     *  		   received at the published QoS. Messages published at a
     *  		   higher quality of service will be received using the QoS
     *  		   specified on the subscribe.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param callback listener that will be notified when subscribe has
     *  			   completed
     * @param opts A collection of subscription options (one for each
     *  		   topic)
     * @param props The MQTT v5 properties.
     * @return token used to track and wait for the subscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    virtual token_ptr subscribe(
        const_string_collection_ptr topicFilters, const qos_collection& qos,
        void* userContext, iaction_listener& callback,
        const std::vector<subscribe_options>& opts = std::vector<subscribe_options>(),
        const properties& props = properties()
    ) = 0;
    /**
     * Requests the server unsubscribe the client from a topic.
     * @param topicFilter the topic to unsubscribe from. It must match a
     *  				  topicFilter specified on an earlier subscribe.
     * @param props The MQTT v5 properties.
     * @return token used to track and wait for the unsubscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    virtual token_ptr unsubscribe(
        const string& topicFilter, const properties& props = properties()
    ) = 0;
    /**
     * Requests the server unsubscribe the client from one or more topics.
     * @param topicFilters one or more topics to unsubscribe from. Each
     *  				   topicFilter must match one specified on an
     *  				   earlier subscribe.
     * @param props The MQTT v5 properties.
     * @return token used to track and wait for the unsubscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    virtual token_ptr unsubscribe(
        const_string_collection_ptr topicFilters, const properties& props = properties()
    ) = 0;
    /**
     * Requests the server unsubscribe the client from one or more topics.
     * @param topicFilters one or more topics to unsubscribe from. Each
     *  				   topicFilter must match one specified on an
     *  				   earlier subscribe.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb listener that will be notified when unsubscribe has
     *  		 completed
     * @param props The MQTT v5 properties.
     * @return token used to track and wait for the unsubscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    virtual token_ptr unsubscribe(
        const_string_collection_ptr topicFilters, void* userContext, iaction_listener& cb,
        const properties& props = properties()
    ) = 0;
    /**
     * Requests the server unsubscribe the client from a topics.
     * @param topicFilter the topic to unsubscribe from. It must match a
     *  				  topicFilter specified on an earlier subscribe.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb listener that will be notified when unsubscribe has
     *  		 completed.
     * @param props The MQTT v5 properties.
     * @return Token used to track and wait for the unsubscribe to complete.
     *  	   The token will be passed to callback methods if set.
     */
    virtual token_ptr unsubscribe(
        const string& topicFilter, void* userContext, iaction_listener& cb,
        const properties& props = properties()
    ) = 0;
    /**
     * Start consuming messages.
     * This initializes the client to receive messages through a queue that
     * can be read synchronously.
     */
    virtual void start_consuming() = 0;
    /**
     * Stop consuming messages.
     * This shuts down the internal callback and discards any unread
     * messages.
     */
    virtual void stop_consuming() = 0;
    /**
     * This clears the consumer queue, discarding any pending event.
     */
    virtual void clear_consumer() {}
    /**
     * Determines if the consumer queue has been closed.
     * Once closed, any events in the queue can still be read, but no new
     * events can be added to it.
     * @return @true if the consumer queue has been closed, @false
     *         otherwise.
     */
    virtual bool consumer_closed() noexcept { return false; }
    /**
     * Determines if the consumer queue is "done" (closed and empty).
     * Once the queue is done, no more events can be added or removed from
     * the queue.
     * @return @true if the consumer queue is closed and empty, @false
     *         otherwise.
     */
    virtual bool consumer_done() noexcept { return false; }
    /**
     * Gets the number of events available for immediate consumption.
     * Note that this retrieves the number of "raw" events, not messages,
     * e.g. may include a connected_event which is not returned by try_consume_message().
     * When polling the queue from multiple threads, prefer using try_consume_event(),
     * as the event count may change between checking the size and actual retrieval.
     * @return the number of events in the queue.
     */
    virtual std::size_t consumer_queue_size() const { return 0; }
    /**
     * Read the next message from the queue.
     * This blocks until a new message arrives.
     * @return The message and topic.
     */
    virtual const_message_ptr consume_message() = 0;
    /**
     * Try to read the next message from the queue without blocking.
     * @param msg Pointer to the value to receive the message
     * @return @em true is a message was read, @em false if no message was
     *  	   available.
     */
    virtual bool try_consume_message(const_message_ptr* msg) = 0;
    /**
     * Read the next event from the queue.
     * This blocks until a new message arrives.
     * @return The message and topic.
     */
    virtual event consume_event() { return event{}; }
    /**
     * Try to read the next message from the queue without blocking.
     * @param evt Pointer to the value to receive the event
     * @return @em true is an event was received, @em false if no event was
     *  	   available.
     */
    virtual bool try_consume_event(event* evt) {
        (void)evt;
        return false;
    }
};

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_iasync_client_h

```

`include/mqtt/iclient_persistence.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file iclient_persistence.h
/// Declaration of MQTT iclient_persistence interface
/// @date May 1, 2013
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2013-2016 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_iclient_persistence_h
#define __mqtt_iclient_persistence_h

#include <vector>

#include "MQTTAsync.h"
#include "mqtt/buffer_view.h"
#include "mqtt/string_collection.h"
#include "mqtt/types.h"

namespace mqtt {

/**
 * Allocate memory for use with user persistence.
 *
 * @param n The number of bytes for the buffer.
 * @return A pointer to the allocated memory
 */
inline void* persistence_malloc(size_t n) { return MQTTAsync_malloc(n); }

/**
 * Frees memory allocated with @ref persistence_malloc().
 * @param p Pointer to a buffer obtained by persistence_malloc.
 */
inline void persistence_free(void* p) { MQTTAsync_free(p); }

/////////////////////////////////////////////////////////////////////////////

/**
 * Represents a persistent data store, used to store outbound and inbound
 * messages while they are in flight, enabling delivery to the QoS
 * specified. You can specify an implementation of this interface using
 * client::client(string, string, iclient_persistence), which the
 * client will use to persist QoS 1 and 2 messages.
 *
 * If the methods defined throw the MqttPersistenceException then the state
 * of the data persisted should remain as prior to the method being called.
 * For example, if put(string, persistable) throws an exception at any
 * point then the data will be assumed to not be in the persistent store.
 * Similarly if remove(string) throws an exception then the data will be
 * assumed to still be held in the persistent store.
 *
 * It is up to the persistence interface to log any exceptions or error
 * information which may be required when diagnosing a persistence failure.
 */
class iclient_persistence
{
    friend class async_client;
    friend class mock_persistence;

    /** Callbacks from the C library */
    static int persistence_open(
        void** handle, const char* clientID, const char* serverURI, void* context
    );
    static int persistence_close(void* handle);
    static int persistence_put(
        void* handle, char* key, int bufcount, char* buffers[], int buflens[]
    );
    static int persistence_get(void* handle, char* key, char** buffer, int* buflen);
    static int persistence_remove(void* handle, char* key);
    static int persistence_keys(void* handle, char*** keys, int* nkeys);
    static int persistence_clear(void* handle);
    static int persistence_containskey(void* handle, char* key);

public:
    /** Smart/shared pointer to an object of this class. */
    using ptr_t = std::shared_ptr<iclient_persistence>;
    /** Smart/shared pointer to a const object of this class. */
    using const_ptr_t = std::shared_ptr<const iclient_persistence>;

    /**
     * Virtual destructor.
     */
    virtual ~iclient_persistence() {}
    /**
     * Initialize the persistent store.
     * This uses the client ID and server name to create a unique location
     * for the data store.
     * @param clientId The identifier string for the client.
     * @param serverURI The server to which the client is connected.
     */
    virtual void open(const string& clientId, const string& serverURI) = 0;
    /**
     * Close the persistent store that was previously opened.
     */
    virtual void close() = 0;
    /**
     * Clears persistence, so that it no longer contains any persisted data.
     */
    virtual void clear() = 0;
    /**
     * Returns whether or not data is persisted using the specified key.
     * @param key The key to find
     * @return @em true if the key exists, @em false if not.
     */
    virtual bool contains_key(const string& key) = 0;
    /**
     * Returns a collection of keys in this persistent data store.
     * @return A collection of strings representing the keys in the store.
     */
    virtual string_collection keys() const = 0;
    /**
     * Puts the specified data into the persistent store.
     * @param key The key.
     * @param bufs The data to store
     */
    virtual void put(const string& key, const std::vector<string_view>& bufs) = 0;
    /**
     * Gets the specified data out of the persistent store.
     * @param key The key
     * @return A const view of the data associated with the key.
     */
    virtual string get(const string& key) const = 0;
    /**
     * Remove the data for the specified key.
     * @param key The key
     */
    virtual void remove(const string& key) = 0;
};

/** Smart/shared pointer to a persistence client */
using iclient_persistence_ptr = iclient_persistence::ptr_t;

/** Smart/shared pointer to a persistence client */
using const_iclient_persistence_ptr = iclient_persistence::const_ptr_t;

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_iclient_persistence_h

```

`include/mqtt/message.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file message.h
/// Declaration of MQTT message class
/// @date May 1, 2013
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2013-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *    Frank Pagliughi - MQTT v5 support (properties)
 *******************************************************************************/

#ifndef __mqtt_message_h
#define __mqtt_message_h

#include <memory>

#include "MQTTAsync.h"
#include "mqtt/buffer_ref.h"
#include "mqtt/exception.h"
#include "mqtt/platform.h"
#include "mqtt/properties.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/**
 * An MQTT message holds everything required for an MQTT PUBLISH message.
 * This holds the binary message payload, topic string, and all the
 * additional meta-data for an MQTT message.
 *
 * The topic and payload buffers are kept as references to const data, so
 * they can be reassigned as needed, but the buffers can not be updated
 * in-place. Normally they would be created externally then copied or moved
 * into the message. The library to transport the messages never touches the
 * payloads or topics.
 *
 * This also means that message objects are fairly cheap to copy, since they
 * don't copy the payloads. They simply copy the reference to the buffers.
 * It is safe to pass these buffer references across threads since all
 * references promise not to update the contents of the buffer.
 */
class message
{
public:
    /** The default QoS for a message */
    static constexpr int DFLT_QOS = 0;
    /** The default retained flag */
    static constexpr bool DFLT_RETAINED = false;

private:
    /** Initializer for the C struct (from the C library) */
    static constexpr MQTTAsync_message DFLT_C_STRUCT MQTTAsync_message_initializer;
    /** A const string to use for references */
    PAHO_MQTTPP_EXPORT static const string EMPTY_STR;
    /** A const binary to use for references */
    PAHO_MQTTPP_EXPORT static const binary EMPTY_BIN;

    /** The underlying C message struct */
    MQTTAsync_message msg_{DFLT_C_STRUCT};
    /** The topic that the message was (or should be) sent on. */
    string_ref topic_;
    /** The message payload - an arbitrary binary blob. */
    binary_ref payload_;
    /** The properties for the message  */
    properties props_;

    /** The client has special access. */
    friend class async_client;

    /**
     * Set the dup flag in the underlying message
     * @param dup Whether to set the dup flag.
     */
    void set_duplicate(bool dup) { msg_.dup = to_int(dup); }

public:
    /** Smart/shared pointer to this class. */
    using ptr_t = std::shared_ptr<message>;
    /** Smart/shared pointer to this class. */
    using const_ptr_t = std::shared_ptr<const message>;

    /**
     * Constructs a message with an empty payload, and all other values set
     * to defaults.
     */
    message() {}
    /**
     * Constructs a message with the specified array as a payload, and all
     * other values set to defaults.
     * @param topic The message topic
     * @param payload the bytes to use as the message payload
     * @param len the number of bytes in the payload
     * @param qos The quality of service for the message.
     * @param retained Whether the message should be retained by the broker.
     * @param props The MQTT v5 properties for the message.
     */
    message(
        string_ref topic, const void* payload, size_t len, int qos, bool retained,
        const properties& props = properties()
    );
    /**
     * Constructs a message with the specified array as a payload, and all
     * other values set to defaults.
     * @param topic The message topic
     * @param payload the bytes to use as the message payload
     * @param len the number of bytes in the payload
     */
    message(string_ref topic, const void* payload, size_t len)
        : message(std::move(topic), payload, len, DFLT_QOS, DFLT_RETAINED) {}
    /**
     * Constructs a message from a byte buffer.
     * Note that the payload accepts copy or move semantics.
     * @param topic The message topic
     * @param payload A byte buffer to use as the message payload.
     * @param qos The quality of service for the message.
     * @param retained Whether the message should be retained by the broker.
     * @param props The MQTT v5 properties for the message.
     */
    message(
        string_ref topic, binary_ref payload, int qos, bool retained,
        const properties& props = properties()
    );
    /**
     * Constructs a message from a byte buffer.
     * Note that the payload accepts copy or move semantics.
     * @param topic The message topic
     * @param payload A byte buffer to use as the message payload.
     */
    message(string_ref topic, binary_ref payload)
        : message(std::move(topic), std::move(payload), DFLT_QOS, DFLT_RETAINED) {}
    /**
     * Constructs a message as a copy of the message structure.
     * @param topic The message topic
     * @param cmsg A "C" MQTTAsync_message structure.
     */
    message(string_ref topic, const MQTTAsync_message& cmsg);
    /**
     * Constructs a message as a copy of the other message.
     * @param other The message to copy into this one.
     */
    message(const message& other);
    /**
     * Moves the other message to this one.
     * @param other The message to move into this one.
     */
    message(message&& other);
    /**
     * Destroys a message and frees all associated resources.
     */
    ~message() {}

    /**
     * Constructs a message with the specified values.
     * @param topic The message topic
     * @param payload the bytes to use as the message payload
     * @param len the number of bytes in the payload
     * @param qos The quality of service for the message.
     * @param retained Whether the message should be retained by the broker.
     * @param props The MQTT v5 properties for the message.
     */
    static ptr_t create(
        string_ref topic, const void* payload, size_t len, int qos, bool retained,
        const properties& props = properties()
    ) {
        return std::make_shared<message>(
            std::move(topic), payload, len, qos, retained, props
        );
    }
    /**
     * Constructs a message with the specified array as a payload, and all
     * other values set to defaults.
     * @param topic The message topic
     * @param payload the bytes to use as the message payload
     * @param len the number of bytes in the payload
     */
    static ptr_t create(string_ref topic, const void* payload, size_t len) {
        return std::make_shared<message>(
            std::move(topic), payload, len, DFLT_QOS, DFLT_RETAINED
        );
    }
    /**
     * Constructs a message from a byte buffer.
     * Note that the payload accepts copy or move semantics.
     * @param topic The message topic
     * @param payload A byte buffer to use as the message payload.
     * @param qos The quality of service for the message.
     * @param retained Whether the message should be retained by the broker.
     * @param props The MQTT v5 properties for the message.
     */
    static ptr_t create(
        string_ref topic, binary_ref payload, int qos, bool retained,
        const properties& props = properties()
    ) {
        return std::make_shared<message>(
            std::move(topic), std::move(payload), qos, retained, props
        );
    }
    /**
     * Constructs a message from a byte buffer.
     * Note that the payload accepts copy or move semantics.
     * @param topic The message topic
     * @param payload A byte buffer to use as the message payload.
     */
    static ptr_t create(string_ref topic, binary_ref payload) {
        return std::make_shared<message>(
            std::move(topic), std::move(payload), DFLT_QOS, DFLT_RETAINED
        );
    }
    /**
     * Constructs a message as a copy of the C message struct.
     * @param topic The message topic
     * @param msg A "C" MQTTAsync_message structure.
     */
    static ptr_t create(string_ref topic, const MQTTAsync_message& msg) {
        return std::make_shared<message>(std::move(topic), msg);
    }
    /**
     * Copies another message to this one.
     * @param rhs The other message.
     * @return A reference to this message.
     */
    message& operator=(const message& rhs);
    /**
     * Moves another message to this one.
     * @param rhs The other message.
     * @return A reference to this message.
     */
    message& operator=(message&& rhs);
/**
 * Expose the underlying C struct for the unit tests.
 */
#if defined(UNIT_TESTS)
    const MQTTAsync_message& c_struct() const { return msg_; }
#endif
    /**
     * Sets the topic string.
     * @param topic The topic on which the message is published.
     */
    void set_topic(string_ref topic) {
        topic_ = topic ? std::move(topic) : string_ref(string());
    }
    /**
     * Gets the topic reference for the message.
     * @return The topic reference for the message.
     */
    const string_ref& get_topic_ref() const { return topic_; }
    /**
     * Gets the topic for the message.
     * @return The topic string for the message.
     */
    const string& get_topic() const { return topic_ ? topic_.str() : EMPTY_STR; }
    /**
     * Clears the payload, resetting it to be empty.
     */
    void clear_payload();
    /**
     * Gets the payload reference.
     */
    const binary_ref& get_payload_ref() const { return payload_; }
    /**
     * Gets the payload
     */
    const binary& get_payload() const { return payload_ ? payload_.str() : EMPTY_BIN; }
    /**
     * Gets the payload as a string
     */
    const string& get_payload_str() const { return payload_ ? payload_.str() : EMPTY_STR; }
    /**
     * Returns the quality of service for this message.
     * @return The quality of service for this message.
     */
    int get_qos() const { return msg_.qos; }
    /**
     * Returns whether or not this message might be a duplicate of one which
     * has already been received.
     * @return true this message might be a duplicate of one which
     * has already been received, false otherwise
     */
    bool is_duplicate() const { return to_bool(msg_.dup); }
    /**
     * Returns whether or not this message should be/was retained by the
     * server.
     * @return true if this message should be/was retained by the
     * server, false otherwise.
     */
    bool is_retained() const { return to_bool(msg_.retained); }
    /**
     * Sets the payload of this message to be the specified buffer.
     * Note that this accepts copy or move operations:
     *   set_payload(buf);
     *   set_payload(std::move(buf));
     * @param payload A buffer to use as the message payload.
     */
    void set_payload(binary_ref payload);
    /**
     * Sets the payload of this message to be the specified byte array.
     * @param payload the bytes to use as the message payload
     * @param n the number of bytes in the payload
     */
    void set_payload(const void* payload, size_t n) {
        set_payload(binary_ref(static_cast<const binary_ref::value_type*>(payload), n));
    }
    /**
     * Sets the quality of service for this message.
     * @param qos The integer Quality of Service for the message
     */
    void set_qos(int qos) {
        validate_qos(qos);
        msg_.qos = qos;
    }
    /**
     * Determines if the QOS value is a valid one.
     * @param qos The QOS value.
     * @throw std::invalid_argument If the qos value is invalid.
     */
    static void validate_qos(int qos) {
        if (qos < 0 || qos > 2)
            throw exception(MQTTASYNC_BAD_QOS, "Bad QoS");
    }
    /**
     * Whether or not the publish message should be retained by the broker.
     * @param retained @em true if the message should be retained by the
     *  			   broker, @em false if not.
     */
    void set_retained(bool retained) { msg_.retained = to_int(retained); }
    /**
     * Gets the properties in the message.
     * @return A const reference to the properties in the message.
     */
    const properties& get_properties() const { return props_; }
    /**
     * Sets the properties in the message.
     * @param props The properties to place into the message.
     */
    void set_properties(const properties& props) {
        props_ = props;
        msg_.properties = props_.c_struct();
    }
    /**
     * Moves the properties into the message.
     * @param props The properties to move into the message.
     */
    void set_properties(properties&& props) {
        props_ = std::move(props);
        msg_.properties = props_.c_struct();
    }
    /**
     * Returns a string representation of this messages payload.
     * @return A string representation of this messages payload.
     */
    string to_string() const { return get_payload_str(); }
};

/** Smart/shared pointer to a message */
using message_ptr = message::ptr_t;

/** Smart/shared pointer to a const message */
using const_message_ptr = message::const_ptr_t;

/**
 * Constructs a message with the specified array as a payload, and all
 * other values set to defaults.
 * @param topic The message topic
 * @param payload the bytes to use as the message payload
 * @param len the number of bytes in the payload
 * @param qos The quality of service for the message.
 * @param retained Whether the message should be retained by the broker.
 * @param props The MQTT v5 properties for the message.
 */
inline message_ptr make_message(
    string_ref topic, const void* payload, size_t len, int qos, bool retained,
    const properties& props = properties()
) {
    return mqtt::message::create(std::move(topic), payload, len, qos, retained, props);
}

/**
 * Constructs a message with the specified array as a payload, and all
 * other values set to defaults.
 * @param topic The message topic
 * @param payload the bytes to use as the message payload
 * @param len the number of bytes in the payload
 */
inline message_ptr make_message(string_ref topic, const void* payload, size_t len) {
    return mqtt::message::create(std::move(topic), payload, len);
}

/**
 * Constructs a message with the specified values.
 * @param topic The message topic
 * @param payload A buffer to use as the message payload.
 * @param qos The quality of service for the message.
 * @param retained Whether the message should be retained by the broker.
 */
inline message_ptr make_message(
    string_ref topic, binary_ref payload, int qos, bool retained,
    const properties& props = properties()
) {
    return mqtt::message::create(std::move(topic), std::move(payload), qos, retained, props);
}

/**
 * Constructs a message with the specified buffer as a payload, and
 * all other values set to defaults.
 * @param topic The message topic
 * @param payload A string to use as the message payload.
 */
inline message_ptr make_message(string_ref topic, binary_ref payload) {
    return mqtt::message::create(std::move(topic), std::move(payload));
}

/////////////////////////////////////////////////////////////////////////////

/**
 * Class to build messages.
 */
class message_ptr_builder
{
    /** The underlying message */
    message_ptr msg_;

public:
    /** This class */
    using self = message_ptr_builder;
    /**
     * Default constructor.
     */
    message_ptr_builder() : msg_{std::make_shared<message>()} {}
    /**
     * Sets the topic string.
     * @param topic The topic on which the message is published.
     */
    auto topic(string_ref topic) -> self& {
        msg_->set_topic(topic);
        return *this;
    }
    /**
     * Sets the payload of this message to be the specified buffer.
     * Note that this accepts copy or move operations:
     *   set_payload(buf);
     *   set_payload(std::move(buf));
     * @param payload A buffer to use as the message payload.
     */
    auto payload(binary_ref payload) -> self& {
        msg_->set_payload(payload);
        return *this;
    }
    /**
     * Sets the payload of this message to be the specified byte array.
     * @param payload the bytes to use as the message payload
     * @param n the number of bytes in the payload
     */
    auto payload(const void* payload, size_t n) -> self& {
        msg_->set_payload(payload, n);
        return *this;
    }
    /**
     * Sets the quality of service for this message.
     * @param qos The integer Quality of Service for the message
     */
    auto qos(int qos) -> self& {
        msg_->set_qos(qos);
        return *this;
    }
    /**
     * Whether or not the publish message should be retained by the broker.
     * @param on @em true if the message should be retained by the broker, @em
     *  		 false if not.
     */
    auto retained(bool on) -> self& {
        msg_->set_retained(on);
        return *this;
    }
    /**
     * Sets the properties for the disconnect message.
     * @param props The properties for the disconnect message.
     */
    auto properties(mqtt::properties&& props) -> self& {
        msg_->set_properties(std::move(props));
        return *this;
    }
    /**
     * Sets the properties for the disconnect message.
     * @param props The properties for the disconnect message.
     */
    auto properties(const mqtt::properties& props) -> self& {
        msg_->set_properties(props);
        return *this;
    }
    /**
     * Finish building the options and return them.
     * @return The option struct as built.
     */
    message_ptr finalize() { return msg_; }
};

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_message_h

```

`include/mqtt/platform.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file platform.h
/// Paho MQTT platform-specific code
/// @date Nov 19, 2023
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_platform_h
#define __mqtt_platform_h

#include "mqtt/export.h"

#endif  // __mqtt_platform_h

```

`include/mqtt/properties.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file properties.h
/// Declaration of MQTT properties class
/// @date July 7, 2019
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2019-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_properties_h
#define __mqtt_properties_h

extern "C" {
#include "MQTTProperties.h"
}

#include <initializer_list>
#include <iostream>
#include <map>
#include <stdexcept>
#include <string_view>
#include <tuple>
#include <typeinfo>

#include "mqtt/buffer_ref.h"
#include "mqtt/exception.h"
#include "mqtt/platform.h"
#include "mqtt/types.h"

namespace mqtt {

/** A pair of strings as a tuple. */
using string_pair = std::tuple<string, string>;

/////////////////////////////////////////////////////////////////////////////

/**
 * A single MQTT v5 property.
 */
class property
{
    /** The underlying Paho C property struct. */
    MQTTProperty prop_;

    // Make a deep copy of the property struct into this one.
    // For string properties, this allocates memory and copied the string(s)
    void copy(const MQTTProperty& other);

    friend class properties;
    property() {}

public:
    /**
     * The integer codes for the different v5 properties.
     */
    enum code {
        PAYLOAD_FORMAT_INDICATOR = 1,
        MESSAGE_EXPIRY_INTERVAL = 2,
        CONTENT_TYPE = 3,
        RESPONSE_TOPIC = 8,
        CORRELATION_DATA = 9,
        SUBSCRIPTION_IDENTIFIER = 11,
        SESSION_EXPIRY_INTERVAL = 17,
        ASSIGNED_CLIENT_IDENTIFIER = 18,
        SERVER_KEEP_ALIVE = 19,
        AUTHENTICATION_METHOD = 21,
        AUTHENTICATION_DATA = 22,
        REQUEST_PROBLEM_INFORMATION = 23,
        WILL_DELAY_INTERVAL = 24,
        REQUEST_RESPONSE_INFORMATION = 25,
        RESPONSE_INFORMATION = 26,
        SERVER_REFERENCE = 28,
        REASON_STRING = 31,
        RECEIVE_MAXIMUM = 33,
        TOPIC_ALIAS_MAXIMUM = 34,
        TOPIC_ALIAS = 35,
        MAXIMUM_QOS = 36,
        RETAIN_AVAILABLE = 37,
        USER_PROPERTY = 38,
        MAXIMUM_PACKET_SIZE = 39,
        WILDCARD_SUBSCRIPTION_AVAILABLE = 40,
        SUBSCRIPTION_IDENTIFIERS_AVAILABLE = 41,
        SHARED_SUBSCRIPTION_AVAILABLE = 42
    };

    /** The names of the different types of properties */
    PAHO_MQTTPP_EXPORT static const std::map<code, std::string_view> TYPE_NAME;

    /**
     * Create a numeric property.
     * This can be a byte, or 2-byte, 4-byte, or variable byte integer.
     * @param c The property code
     * @param val The integer value for the property
     */
    property(code c, int32_t val);
    /**
     * Create a numeric property.
     * This can be a byte, or 2-byte, 4-byte, or variable byte integer.
     * @param c The property code
     * @param val The integer value for the property
     */
    property(code c, uint32_t val) : property(c, int32_t(val)) {}
    /**
     * Create a string or binary property.
     * @param c The property code
     * @param val The value for the property
     */
    property(code c, string_ref val);
    /**
     * Create a string pair property.
     * @param c The property code
     * @param name The string name for the property
     * @param val The string value for the property
     */
    property(code c, string_ref name, string_ref val);
    /**
     * Creates a property from a C struct.
     * @param cprop A C struct for a property list.
     */
    explicit property(const MQTTProperty& cprop) { copy(cprop); }
    /**
     * Moves a C struct into this property list.
     * This takes ownership of any memory that the C struct is holding.
     * @param cprop A C struct for a property list.
     */
    explicit property(MQTTProperty&& cprop) : prop_(cprop) {
        memset(&cprop, 0, sizeof(MQTTProperty));
    }
    /**
     * Copy constructor
     * @param other The other property to copy into this one.
     */
    property(const property& other) { copy(other.prop_); }
    /**
     * Move constructor.
     * @param other The other property that is moved into this one.
     */
    property(property&& other);
    /**
     * Destructor
     */
    ~property();
    /**
     * Copy assignment.
     * @param rhs Another property list to copy into this one.
     * @return A reference to this object.
     */
    property& operator=(const property& rhs);
    /**
     * Move assignment.
     * @param rhs Another property list to move into this one.
     * @return A reference to this object.
     */
    property& operator=(property&& rhs);
    /**
     * Gets the underlying C property struct.
     * @return A const reference to the underlying C property
     *  	   struct.
     */
    const MQTTProperty& c_struct() const { return prop_; }
    /**
     * Gets the property type (identifier).
     * @return The code for the property type.
     */
    code type() const { return code(prop_.identifier); }
    /**
     * Gets a printable name for the property type.
     * @return A printable name for the property type.
     */
    std::string_view type_name() const;
    /**
     * Gets the typeid for the value contained in the property.
     * @return The typeid for the value contained in the property.
     */
    const std::type_info& value_type_id();
};

std::ostream& operator<<(std::ostream& os, const property& prop);

/**
 * Extracts the value from the property as the specified type.
 * @return The value from the property as the specified type.
 */
template <typename T>
inline T get(const property&) {
    throw bad_cast();
}

/**
 * Extracts the value from the property as an unsigned 8-bit integer.
 * @return The value from the property as an unsigned 8-bit integer.
 */
template <>
inline uint8_t get<uint8_t>(const property& prop) {
    return uint8_t(prop.c_struct().value.byte);
}

/**
 * Extracts the value from the property as an unsigned 16-bit integer.
 * @return The value from the property as an unsigned 16-bit integer.
 */
template <>
inline uint16_t get<uint16_t>(const property& prop) {
    return uint16_t(prop.c_struct().value.integer2);
}

/**
 * Extracts the value from the property as a signed 16-bit integer.
 * @return The value from the property as a signed 16-bit integer.
 * @deprecated All integer properties are unsigned. Use
 *  		   `get<uint16_t>()`
 */
template <>
[[deprecated("Integer properties are unsigned. Use get<uint16_t>()")]] inline int16_t
get<int16_t>(const property& prop) {
    return int16_t(prop.c_struct().value.integer2);
}

/**
 * Extracts the value from the property as an unsigned 32-bit integer.
 * @return The value from the property as an unsigned 32-bit integer.
 */
template <>
inline uint32_t get<uint32_t>(const property& prop) {
    return uint32_t(prop.c_struct().value.integer4);
}

/**
 * Extracts the value from the property as a signed 32-bit integer.
 * @return The value from the property as a signed 32-bit integer.
 * @deprecated All integer properties are unsigned. Use
 *  		   `get<uint32_t>()`
 */
template <>
[[deprecated("Integer properties are unsigned. Use get<uint32_t>()")]] inline int32_t
get<int32_t>(const property& prop) {
    return int32_t(prop.c_struct().value.integer4);
}

/**
 * Extracts the value from the property as a string.
 * @return The value from the property as a string.
 */
template <>
inline string get<string>(const property& prop) {
    return (!prop.c_struct().value.data.data)
               ? string()
               : string(prop.c_struct().value.data.data, prop.c_struct().value.data.len);
}

/**
 * Extracts the value from the property as a pair of strings.
 * @return The value from the property as a pair of strings.
 */
template <>
inline string_pair get<string_pair>(const property& prop) {
    string name =
        (!prop.c_struct().value.data.data)
            ? string()
            : string(prop.c_struct().value.data.data, prop.c_struct().value.data.len);

    string value =
        (!prop.c_struct().value.value.data)
            ? string()
            : string(prop.c_struct().value.value.data, prop.c_struct().value.value.len);

    return std::make_tuple(std::move(name), std::move(value));
}

/////////////////////////////////////////////////////////////////////////////

/**
 * MQTT v5 property list.
 *
 * A collection of properties that can be added to outgoing packets or
 * retrieved from incoming packets.
 */
class properties
{
    /** The default C struct */
    static constexpr MQTTProperties DFLT_C_STRUCT MQTTProperties_initializer;

    /** The underlying C properties struct */
    MQTTProperties props_{DFLT_C_STRUCT};

    template <typename T>
    friend T get(const properties& props, property::code propid, size_t idx);

    template <typename T>
    friend T get(const properties& props, property::code propid);

public:
    /** A const iterator for the properties list */
    class const_iterator
    {
        const MQTTProperty* curr_;
        mutable property prop_;

        friend properties;
        const_iterator(const MQTTProperty* curr) : curr_{curr} {}

    public:
        /**
         * Gets a reference to the current value.
         * @return A reference to the current value.
         */
        const property& operator*() const {
            prop_ = property{*curr_};
            return prop_;
        }
        /**
         * Postfix increment operator.
         * @return An iterator pointing to the previous matching item.
         */
        const_iterator operator++(int) noexcept {
            auto tmp = *this;
            curr_++;
            return tmp;
        }
        /**
         * Prefix increment operator.
         * @return An iterator pointing to the next matching item.
         */
        const_iterator& operator++() noexcept {
            ++curr_;
            return *this;
        }
        /**
         * Compares two iterators to see if they don't refer to the same
         * node.
         *
         * @param other The other iterator to compare against this one.
         * @return @em true if they don't match, @em false if they do
         */
        bool operator!=(const const_iterator& other) const noexcept {
            return curr_ != other.curr_;
        }
    };

    /**
     * Default constructor.
     * Creates an empty properties list.
     */
    properties() {}
    /**
     * Copy constructor.
     * @param other The property list to copy.
     */
    properties(const properties& other) : props_(::MQTTProperties_copy(&other.props_)) {}
    /**
     * Move constructor.
     * @param other The property list to move to this one.
     */
    properties(properties&& other) : props_(other.props_) {
        std::memset(&other.props_, 0, sizeof(MQTTProperties));
    }
    /**
     * Creates a list of properties from a C struct.
     * @param cprops The c struct of properties
     */
    properties(const MQTTProperties& cprops) { props_ = ::MQTTProperties_copy(&cprops); }
    /**
     * Constructs from a list of property objects.
     * @param props An initializer list of property objects.
     */
    properties(std::initializer_list<property> props);
    /**
     * Destructor.
     */
    ~properties() { ::MQTTProperties_free(&props_); }
    /**
     * Gets a reference to the underlying C properties structure.
     * @return A const reference to the underlying C properties structure.
     */
    const MQTTProperties& c_struct() const { return props_; }
    /**
     * Copy assignment.
     * @param rhs The other property list to copy into this one
     * @return A reference to this object.
     */
    properties& operator=(const properties& rhs);
    /**
     * Move assignment.
     * @param rhs The property list to move to this one.
     * @return A reference to this object.
     */
    properties& operator=(properties&& rhs);
    /**
     * Determines if the property list is empty.
     * @return @em true if there are no properties in the list, @em false if
     *  	   the list contains any items.
     */
    bool empty() const { return props_.count == 0; }
    /**
     * Gets the property at the specified index in the collection.
     * @param i The index
     * @return The property at the specified index.
     */
    const property operator[](size_t i) const { return property{props_.array[i]}; }
    /**
     * Gets the property at the specified index in the collection.
     * @param i The index
     * @return The property at the specified index.
     */
    const property at(size_t i) const {
        if (i < size_t(props_.count))
            return property{props_.array[i]};
        throw std::out_of_range{"property index"};
    }
    /**
     * Gets the numbers of property items in the list.
     * @return The number of property items in the list.
     */
    size_t size() const { return size_t(props_.count); }
    /**
     * Gets a const iterator to the full collection of properties.
     * @return A const iterator to the full collection of properties.
     */
    const_iterator begin() const { return const_iterator{props_.array}; }
    /**
     * Gets a const iterator to the full collection of properties.
     * @return A const iterator to the full collection of properties.
     */
    const_iterator cbegin() const { return begin(); }
    /**
     * Gets a const iterator to the end of the collection of properties.
     * @return A const iterator to the end of collection of properties.
     */
    const_iterator end() const { return const_iterator{props_.array + size()}; }
    /**
     * Gets a const iterator to the end of the collection of properties.
     * @return A const iterator to the end of collection of properties.
     */
    const_iterator cend() const { return end(); }
    /**
     * Adds a property to the list.
     * @param prop The property to add to the list.
     */
    void add(const property& prop) { ::MQTTProperties_add(&props_, &prop.c_struct()); }
    /**
     * Removes all the items from the property list.
     */
    void clear() { ::MQTTProperties_free(&props_); }
    /**
     * Determines if the list contains a specific property.
     * @param propid The property ID (code).
     * @return @em true if the list contains the property, @em false if not.
     */
    bool contains(property::code propid) const {
        return ::MQTTProperties_hasProperty(
                   const_cast<MQTTProperties*>(&props_), MQTTPropertyCodes(propid)
               ) != 0;
    }
    /**
     * Get the number of properties in the list with the specified property
     * ID.
     *
     * Most properties can exist only once. User properties and subscription
     * ID's can exist more than once.
     *
     * @param propid The property ID (code).
     * @return The number of properties in the list with the specified ID.
     */
    size_t count(property::code propid) const {
        return size_t(
            ::MQTTProperties_propertyCount(
                const_cast<MQTTProperties*>(&props_), MQTTPropertyCodes(propid)
            )
        );
    }
    /**
     * Gets the property with the specified ID.
     *
     * @param propid The property ID (code).
     * @param idx Which instance of the property to retrieve, if there are
     *  		  more than one.
     * @return The requested property
     */
    property get(property::code propid, size_t idx = 0) const;
};

// --------------------------------------------------------------------------

/**
 * Retrieves a single value from a property list for when there may be
 * multiple identical property ID's.
 * @tparam T The type of the value to retrieve
 * @param props The property list
 * @param propid The property ID code for the desired value.
 * @param idx Index of the desired property ID
 * @return The requested value of type T
 */
template <typename T>
inline T get(const properties& props, property::code propid, size_t idx) {
    MQTTProperty* prop = MQTTProperties_getPropertyAt(
        const_cast<MQTTProperties*>(&props.c_struct()), MQTTPropertyCodes(propid), int(idx)
    );
    if (!prop)
        throw bad_cast();

    return get<T>(property(*prop));
}

/**
 * Retrieves a single value from a property list.
 * @tparam T The type of the value to retrieve
 * @param props The property list
 * @param propid The property ID code for the desired value.
 * @return The requested value of type T
 */
template <typename T>
inline T get(const properties& props, property::code propid) {
    return get<T>(props, propid, 0);
}

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_properties_h

```

`include/mqtt/reason_code.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file reason_code.h
///
/// MQTT v5 reason codes for the Paho MQTT C++ library.
///
/// @date July 5, 2024
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __reason_code_h
#define __reason_code_h

#include <iostream>
#include <string>

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/**
 * The MQTT v5 Reason Codes.
 */
enum ReasonCode {
    SUCCESS = 0,
    NORMAL_DISCONNECTION = 0,
    GRANTED_QOS_0 = 0,
    GRANTED_QOS_1 = 1,
    GRANTED_QOS_2 = 2,
    DISCONNECT_WITH_WILL_MESSAGE = 4,
    NO_MATCHING_SUBSCRIBERS = 16,
    NO_SUBSCRIPTION_FOUND = 17,
    CONTINUE_AUTHENTICATION = 24,
    RE_AUTHENTICATE = 25,
    UNSPECIFIED_ERROR = 128,
    MALFORMED_PACKET = 129,
    PROTOCOL_ERROR = 130,
    IMPLEMENTATION_SPECIFIC_ERROR = 131,
    UNSUPPORTED_PROTOCOL_VERSION = 132,
    CLIENT_IDENTIFIER_NOT_VALID = 133,
    BAD_USER_NAME_OR_PASSWORD = 134,
    NOT_AUTHORIZED = 135,
    SERVER_UNAVAILABLE = 136,
    SERVER_BUSY = 137,
    BANNED = 138,
    SERVER_SHUTTING_DOWN = 139,
    BAD_AUTHENTICATION_METHOD = 140,
    KEEP_ALIVE_TIMEOUT = 141,
    SESSION_TAKEN_OVER = 142,
    TOPIC_FILTER_INVALID = 143,
    TOPIC_NAME_INVALID = 144,
    PACKET_IDENTIFIER_IN_USE = 145,
    PACKET_IDENTIFIER_NOT_FOUND = 146,
    RECEIVE_MAXIMUM_EXCEEDED = 147,
    TOPIC_ALIAS_INVALID = 148,
    PACKET_TOO_LARGE = 149,
    MESSAGE_RATE_TOO_HIGH = 150,
    QUOTA_EXCEEDED = 151,
    ADMINISTRATIVE_ACTION = 152,
    PAYLOAD_FORMAT_INVALID = 153,
    RETAIN_NOT_SUPPORTED = 154,
    QOS_NOT_SUPPORTED = 155,
    USE_ANOTHER_SERVER = 156,
    SERVER_MOVED = 157,
    SHARED_SUBSCRIPTIONS_NOT_SUPPORTED = 158,
    CONNECTION_RATE_EXCEEDED = 159,
    MAXIMUM_CONNECT_TIME = 160,
    SUBSCRIPTION_IDENTIFIERS_NOT_SUPPORTED = 161,
    WILDCARD_SUBSCRIPTIONS_NOT_SUPPORTED = 162,
    // This is not a protocol code; used internally by the library (obsolete)
    MQTTPP_V3_CODE = 0
};

/**
 * Get the string representation of the reason code.
 *
 * @param reasonCode An MQTT v5 reason code.
 * @return The string representation of the reason code.
 */
std::string to_string(ReasonCode reasonCode);

/**
 * ostream inserter for reason codes
 *
 * @param os The output stream
 * @param reasonCode The reason code.
 *
 * @return Reference to the output stream
 */
std::ostream& operator<<(std::ostream& os, ReasonCode reasonCode);

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __reason_code_h

```

`include/mqtt/response_options.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file response_options.h
/// Implementation of the class 'response_options'
/// @date 26-Aug-2019
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2019-2025 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_response_options_h
#define __mqtt_response_options_h

#include "MQTTAsync.h"
#include "mqtt/delivery_token.h"
#include "mqtt/token.h"
#include "subscribe_options.h"

namespace mqtt {

class token_test;

/////////////////////////////////////////////////////////////////////////////
//							response_options
/////////////////////////////////////////////////////////////////////////////

/**
 * The response options for various asynchronous calls.
 *
 * This is an internal data structure, only used within the library.
 * Therefore it is not totally fleshed out, but rather only exposes the
 * functionality currently required by the library.
 *
 * Note, too, in the C lib, this became a place to add MQTT v5 options for
 * the outgoing calls without breaking the API, so is also referred to as the
 * "call options".
 */
class response_options
{
    /** The underlying C structure */
    MQTTAsync_responseOptions opts_ MQTTAsync_responseOptions_initializer;

    /** The token to which we are connected */
    token::weak_ptr_t tok_;

    /** Packet Properties (Subscribe/Unsubscribe) */
    properties props_;

    /** A list of subscription options for subscribe-many */
    std::vector<MQTTSubscribe_options> subOpts_;

    /** The client has special access */
    friend class async_client;

    /** Update the underlying C struct to match our data */
    void update_c_struct();

public:
    /**
     * Create an empty response object.
     * @param mqttVersion The MQTT version for the response.
     */
    explicit response_options(int mqttVersion = MQTTVERSION_DEFAULT) {
        set_mqtt_version(mqttVersion);
    }
    /**
     * Creates a response object with the specified callbacks.
     * @param tok A token to be used as the context.
     * @param mqttVersion The MQTT version for the response.
     */
    response_options(const token_ptr& tok, int mqttVersion = MQTTVERSION_DEFAULT);
    /**
     * Copy constructor.
     * @param other The other options to copy to this one.
     */
    response_options(const response_options& other);
    /**
     * Move constructor.
     * @param other The other options to move into this one.
     */
    response_options(response_options&& other);
    /**
     * Copy operator.
     * @param rhs The other options to copy to this one.
     */
    response_options& operator=(const response_options& rhs);
    /**
     * Move operator.
     * @param rhs The other options to move into this one.
     */
    response_options& operator=(response_options&& rhs);
/**
 * Expose the underlying C struct for the unit tests.
 */
#if defined(UNIT_TESTS)
    const auto& c_struct() const { return opts_; }
#endif
    /**
     * Sets the MQTT protocol version used for the response.
     * This sets up proper callbacks for MQTT v5 or versions prior to that.
     * @param mqttVersion The MQTT version used by the connection.
     */
    void set_mqtt_version(int mqttVersion);
    /**
     * Sets the callback context to a generic token.
     * @param tok The token to be used as the callback context.
     */
    void set_token(const token_ptr& tok);
    /**
     * Gets the properties for the response options.
     */
    const properties& get_properties() const { return props_; }
    /**
     * Sets the properties for the response options.
     * @param props The properties for the response options.
     */
    void set_properties(const properties& props) {
        props_ = props;
        opts_.properties = props_.c_struct();
    }
    /**
     * Moves the properties for the response options.
     * @param props The properties to move into the response options.
     */
    void set_properties(properties&& props) {
        props_ = std::move(props);
        opts_.properties = props_.c_struct();
    }
    /**
     * Gets the options for a single topic subscription.
     * @return The subscribe options.
     */
    subscribe_options get_subscribe_options() const {
        return subscribe_options{opts_.subscribeOptions};
    }
    /**
     * Sets the options for a multi-topic subscription.
     * @return The vector of the subscribe options.
     */
    std::vector<subscribe_options> get_subscribe_many_options() const;
    /**
     * Sets the options for a single topic subscription.
     * @param opts The subscribe options.
     */
    void set_subscribe_options(const subscribe_options& opts);
    /**
     * Sets the options for a multi-topic subscription.
     * @param opts A vector of the subscribe options.
     */
    void set_subscribe_many_options(const std::vector<subscribe_options>& opts);
    /**
     * Sets the options for a multi-topic subscription.
     * @param opts A vector of the subscribe options.
     * @sa set_subscribe_options
     */
    void set_subscribe_options(const std::vector<subscribe_options>& opts) {
        set_subscribe_many_options(opts);
    }
};

/////////////////////////////////////////////////////////////////////////////

/**
 * Class to build response options.
 */
class response_options_builder
{
    /** The underlying options */
    response_options opts_;

public:
    /** This class */
    using self = response_options_builder;
    /**
     * Default constructor.
     */
    explicit response_options_builder(int mqttVersion = MQTTVERSION_DEFAULT)
        : opts_(mqttVersion) {}
    /**
     * Sets the MQTT protocol version used for the response.
     * This sets up proper callbacks for MQTT v5 or versions prior to that.
     * @param mqttVersion The MQTT version used by the connection.
     */
    auto mqtt_version(int mqttVersion) -> self& {
        opts_.set_mqtt_version(mqttVersion);
        return *this;
    }
    /**
     * Sets the callback context to a generic token.
     * @param tok The token to be used as the callback context.
     */
    auto token(const token_ptr& tok) -> self& {
        opts_.set_token(tok);
        return *this;
    }
    /**
     * Sets the properties for the response options.
     * @param props The properties for the response options.
     */
    auto properties(mqtt::properties&& props) -> self& {
        opts_.set_properties(std::move(props));
        return *this;
    }
    /**
     * Sets the properties for the disconnect message.
     * @param props The properties for the disconnect message.
     */
    auto properties(const mqtt::properties& props) -> self& {
        opts_.set_properties(props);
        return *this;
    }
    /**
     * Sets the options for a single topic subscription.
     * @param opts The subscribe options.
     */
    auto subscribe_opts(const subscribe_options& opts) -> self& {
        opts_.set_subscribe_options(opts);
        return *this;
    }
    /**
     * Sets the options for a multi-topic subscription.
     * @param opts A vector of the subscribe options.
     */
    auto subscribe_many_opts(const std::vector<subscribe_options>& opts) -> self& {
        opts_.set_subscribe_options(opts);
        return *this;
    }
    /**
     * Sets the options for a multi-topic subscription.
     * @param opts A vector of the subscribe options.
     */
    auto subscribe_opts(const std::vector<subscribe_options>& opts) -> self& {
        opts_.set_subscribe_options(opts);
        return *this;
    }
    /**
     * Finish building the response options and return them.
     * @return The response option struct as built.
     */
    response_options finalize() { return opts_; }
};

/////////////////////////////////////////////////////////////////////////////
//						delivery_response_options
/////////////////////////////////////////////////////////////////////////////

/**
 * The response options for asynchronous calls targeted at delivery.
 * Each of these objects is tied to a specific delivery_token.
 */
class delivery_response_options
{
    /** The underlying C structure */
    MQTTAsync_responseOptions opts_;

    /** The delivery token to which we are connected */
    delivery_token::weak_ptr_t dtok_;

    /** The client has special access */
    friend class async_client;

public:
    /**
     * Create an empty delivery response object.
     */
    delivery_response_options(int mqttVersion = MQTTVERSION_DEFAULT);
    /**
     * Creates a response object tied to the specific delivery token.
     * @param dtok A delivery token to be used as the context.
     * @param mqttVersion The MQTT version for the response
     */
    delivery_response_options(
        const delivery_token_ptr& dtok, int mqttVersion = MQTTVERSION_DEFAULT
    );
/**
 * Expose the underlying C struct for the unit tests.
 */
#if defined(UNIT_TESTS)
    const MQTTAsync_responseOptions& c_struct() const { return opts_; }
#endif
    /**
     * Sets the callback context to a delivery token.
     * @param dtok The delivery token to be used as the callback context.
     */
    void set_token(const delivery_token_ptr& dtok) {
        dtok_ = dtok;
        opts_.context = dtok.get();
    }
};

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_response_options_h

```

`include/mqtt/server_response.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file server_response.h
/// Declaration of MQTT server response classes.
/// @date July 26, 2019
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2019-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_server_response_h
#define __mqtt_server_response_h

#include <iostream>

#include "MQTTAsync.h"
#include "mqtt/properties.h"
#include "mqtt/types.h"

namespace mqtt {

/**
 * Base class for responses from the server.
 */
class server_response
{
    /** The properties from the acknowledge */
    properties props_;

public:
    /**
     * Creates a response with empty property list.
     */
    server_response() {}
    /**
     * Creates a server response with the specified properties.
     * @param props The properties in the response.
     */
    server_response(const properties& props) : props_{props} {}
    /**
     * Creates a server response with the specified properties.
     * @param props The properties in the response.
     */
    server_response(properties&& props) : props_{std::move(props)} {}
    /**
     * Virtual destructor.
     */
    virtual ~server_response() {}
    /**
     * Gets the properties from the response.
     * @return The properties from the response.
     */
    const properties& get_properties() const noexcept { return props_; }
};

/**
 * Response for a connect request.
 */
class connect_response : public server_response
{
    /** The connection string of the server */
    string serverURI_;
    /** The version of MQTT being used */
    int mqttVersion_;
    /** The session present flag returned from the server */
    bool sessionPresent_;

    friend class token;

    /**
     * Create v5 connect response.
     * @param rsp The v5 response struct from the C lib
     */
    connect_response(const MQTTAsync_successData5* rsp);
    /**
     * Create v3 connect response.
     * @param rsp The v3 response struct from the C lib
     */
    connect_response(const MQTTAsync_successData* rsp);

public:
    /**
     * Gets the URI of the broker to which we connected.
     * @return The URI of the broker.
     */
    string get_server_uri() const { return serverURI_; }
    /**
     * Gets the MQTT version for the connection.
     * @return The MQTT version for the connection.
     */
    int get_mqtt_version() const { return mqttVersion_; }
    /**
     * Determines whether a session already existed for this client on the
     * server.
     * This tells whether the server has a persistent session stored for the
     * client, given the ClientID specified in the connect message.
     * @return Whether a session already existed for this client on the server.
     */
    bool is_session_present() const { return sessionPresent_; }
};

/**
 * Response for a subscribe request.
 *
 * This contains the information returned from the broker in the SUBACK
 * packet. It gives information about the granted Qos for each topc in the
 * subscribe request.
 *
 * @li MQTT v3: These are return "codes" with the value 0-2 for each of the
 *     topic filters sent in the subscribe message.
 * @li MQTT v5 These are reason codes, with one for each of the topics sent
 *     in the subscribe message. On success, the values are the same as for
 *     MQTT v3: the granted QoS 0-2. For errors, each could be an error code
 *     with a value >= 0x80, as described in the MQTT v5 spec: (not
 *     authorized, quota exceeded, etc).
 */
struct subscribe_response : public server_response
{
    /** The reason/result code for each topic request. */
    std::vector<ReasonCode> reasonCodes_;

    friend class token;

    /**
     * Create v5 subscribe response.
     * @param rsp The v5 response struct from the C lib
     */
    subscribe_response(MQTTAsync_successData5* rsp);
    /**
     * Create v3 subscribe response.
     * @param n The number of subscription topics
     * @param rsp The v3 response struct from the C lib
     */
    subscribe_response(size_t n, MQTTAsync_successData* rsp);

public:
    /**
     * Gets the reason codes from the server response.
     *
     * On a subscribe ack there is a return/reason code for each topic that
     * was sent in the subscribe packet. Each tells the granted QoS
     * for the corresponding topic.
     *
     * For MQTT v5 values over 0x80 are error codes as described in the MQTT
     * v5 spec.
     *
     * @return A collection of return/reason codes corresponding to
     *  	   subscribing each topic. On success, this is the
     *  	   granted QoS for each topic. On failure it is the
     *  	   reason for the failure.
     */
    const std::vector<ReasonCode>& get_reason_codes() const { return reasonCodes_; }
};

/**
 * Response for unsubscribe messages.
 */
class unsubscribe_response : public server_response
{
    /** The reason/result code for each topic request. */
    std::vector<ReasonCode> reasonCodes_;

    friend class token;

    /**
     * Create v5 unsubscribe response.
     * @param rsp The v5 response struct from the C lib
     */
    unsubscribe_response(MQTTAsync_successData5* rsp);
    /**
     * Create v3 subscribe response.
     * The broker doesn't return any useful information for an unsubscribe
     * in MQTT v3.
     */
    unsubscribe_response(MQTTAsync_successData*) {}

public:
    /**
     * Gets the reason codes from the server response.
     * On an unsubscribe ack there is a reason code for each topic
     * that was sent in the unsubscribe packet. Each tells the
     * result of unsubscribing to the corresponding topic.
     * @return A collection of return codes corresponding to
     *  	   unsubscribing each topic.
     */
    const std::vector<ReasonCode>& get_reason_codes() const { return reasonCodes_; }
};

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_server_response_h

```

`include/mqtt/ssl_options.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file ssl_options.h
/// Declaration of MQTT ssl_options class
/// @date Jul 7, 2016
/// @author Frank Pagliughi, Guilherme Ferreira
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2016-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 * Copyright (c) 2016 Guilherme Ferreira <guilherme.maciel.ferreira@gmail.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme Ferreira - initial implementation and documentation
 *    Frank Pagliughi - added copy & move operations
 *    Frank Pagliughi - upgraded compatibility to Paho C 1.3
 *******************************************************************************/

#ifndef __mqtt_ssl_options_h
#define __mqtt_ssl_options_h

#include <functional>
#include <vector>

#include "MQTTAsync.h"
#include "mqtt/message.h"
#include "mqtt/platform.h"
#include "mqtt/topic.h"
#include "mqtt/types.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/**
 * Holds the set of SSL options for connection.
 */
class ssl_options
{
public:
    /** Smart/shared pointer to an object of this class. */
    using ptr_t = std::shared_ptr<ssl_options>;
    /** Smart/shared pointer to a const object of this class. */
    using const_ptr_t = std::shared_ptr<const ssl_options>;
    /** Unique pointer to an object of this class. */
    using unique_ptr_t = std::unique_ptr<ssl_options>;

    /** Handler type for error message callbacks */
    using error_handler = std::function<void(const string& errMsg)>;
    /**
     * Handler type for TLS-PSK option callback.
     * On success, the callback should return the length of the PSK (in
     * bytes). On failure, it should throw or return zero.
     */
    using psk_handler = std::function<unsigned(
        const string& hint, char* identity, size_t max_identity_len, unsigned char* psk,
        size_t max_psk_len
    )>;

private:
    /** The default C struct */
    static constexpr MQTTAsync_SSLOptions DFLT_C_STRUCT MQTTAsync_SSLOptions_initializer;

    /** The underlying C SSL options */
    MQTTAsync_SSLOptions opts_{DFLT_C_STRUCT};

    /**
     * The file containing the public digital certificates trusted by
     * the client.
     */
    string trustStore_;

    /** The file containing the public certificate chain of the client. */
    string keyStore_;

    /** The file containing the client's private key. */
    string privateKey_;

    /** The password to load the client's privateKey if encrypted. */
    string privateKeyPassword_;

    /** Path to a directory containing CA certificates in PEM format */
    string caPath_;

    /**
     * The list of cipher suites that the client will present to the
     * server during the SSL handshake.
     */
    string enabledCipherSuites_;

    /** Error message callback handler  */
    error_handler errHandler_;

    /** PSK callback handler */
    psk_handler pskHandler_;

    /** ALPN protocol list, in wire format */
    std::vector<unsigned char> protos_;

    /** Callbacks from the C library */
    static int on_error(const char* str, size_t len, void* context);
    static unsigned on_psk(
        const char* hint, char* identity, unsigned int max_identity_len, unsigned char* psk,
        unsigned int max_psk_len, void* context
    );

    /** The connect options has special access */
    friend class connect_options;

    /**
     * Gets a pointer to the C-language NUL-terminated strings for the
     * struct.
     * @note In the SSL options, by default, the Paho C treats nullptr char
     * arrays as unset values, so we keep that semantic and only set those
     * char arrays if the string is non-empty.
     * @param str The C++ string object.
     * @return Pointer to a NUL terminated string. This is only valid until
     *  	   the next time the string is updated.
     */
    const char* c_str(const string& str) { return str.empty() ? nullptr : str.c_str(); }
    /**
     * Updates the underlying C structure to match our strings.
     */
    void update_c_struct();

public:
    /**
     * Constructs a new MqttConnectOptions object using the default values.
     */
    ssl_options() {}
    /**
     * Argument constructor.
     * @param trustStore The file containing the public digital certificates
     * trusted by the client.
     * @param keyStore The file containing the public certificate chain of the
     * client.
     * @param privateKey The file containing the client's private key.
     * @param privateKeyPassword The password to load the client's privateKey
     * if encrypted.
     * @param enabledCipherSuites The list of cipher suites that the client
     * will present to the server during the SSL handshake.
     * @param enableServerCertAuth True/False option to enable verification of
     * the server certificate
     * @param alpnProtos The ALPN protocols to try.
     */
    ssl_options(
        const string& trustStore, const string& keyStore, const string& privateKey,
        const string& privateKeyPassword, const string& enabledCipherSuites,
        bool enableServerCertAuth,
        const std::vector<string> alpnProtos = std::vector<string>()
    );
    /**
     * Argument constructor.
     * @param trustStore The file containing the public digital certificates
     *  				 trusted by the client.
     * @param keyStore The file containing the public certificate chain of
     *  			   the client.
     * @param privateKey The file containing the client's private key.
     * @param privateKeyPassword The password to load the client's
     *  						 privateKey if encrypted.
     * @param caPath The name of a directory containing CA certificates in
     *  			 PEM format.
     * @param enabledCipherSuites The list of cipher suites that the client
     *  						  will present to the server during the SSL
     *  						  handshake.
     * @param enableServerCertAuth True/False option to enable verification
     *  						   of the server certificate
     * @param alpnProtos The ALPN protocols to try.
     */
    ssl_options(
        const string& trustStore, const string& keyStore, const string& privateKey,
        const string& privateKeyPassword, const string& caPath,
        const string& enabledCipherSuites, bool enableServerCertAuth,
        const std::vector<string> alpnProtos = std::vector<string>()
    );
    /**
     * Copy constructor.
     * @param opt The other options to copy.
     */
    ssl_options(const ssl_options& opt);
    /**
     * Move constructor.
     * @param opt The other options to move to this one.
     */
    ssl_options(ssl_options&& opt);
    /**
     * Copy assignment.
     * @param opt The other options to copy.
     * @return A reference to this object.
     */
    ssl_options& operator=(const ssl_options& opt);
    /**
     * Move assignment.
     * @param opt The other options to move to this one.
     * @return A reference to this object.
     */
    ssl_options& operator=(ssl_options&& opt);
    /**
     * Expose the underlying C struct for the unit tests.
     */
#if defined(UNIT_TESTS)
    const MQTTAsync_SSLOptions& c_struct() const { return opts_; }
#endif
    /**
     * Returns the file containing the public digital certificates trusted by
     * the client.
     * @return string
     */
    string get_trust_store() const { return trustStore_; }
    /**
     * Returns the file containing the public certificate chain of the client.
     * @return string
     */
    string get_key_store() const { return keyStore_; }
    /**
     * Gets the name of file containing the client's private key.
     * @return The name of file containing the client's private key.
     */
    string get_private_key() const { return privateKey_; }
    /**
     * Gets the password to load the client's privateKey if encrypted.
     * @return The password to load the client's privateKey if encrypted.
     */
    string get_private_key_password() const { return privateKeyPassword_; }
    /**
     * Returns the list of cipher suites that the client will present to the
     * server during the SSL handshake.
     * @return string
     */
    string get_enabled_cipher_suites() const { return enabledCipherSuites_; }
    /**
     * Returns the true/false to enable verification of the server certificate .
     * @return bool
     */
    bool get_enable_server_cert_auth() const { return to_bool(opts_.enableServerCertAuth); }
    /**
     * Sets the file containing the public digital certificates trusted by
     * the client.
     * @param trustStore The file in PEM format containing the public
     *  				 digital certificates trusted by the client.
     */
    void set_trust_store(const string& trustStore);
    /**
     * Sets the file containing the public certificate chain of the client.
     * @param keyStore The file in PEM format containing the public
     *  			   certificate chain of the client. It may also include
     *				   the client's private key.
     */
    void set_key_store(const string& keyStore);
    /**
     * Sets the file containing the client's private key.
     * @param privateKey If not included in the sslKeyStore, this is the
     *  				 file in PEM format containing the client's private
     *  				 key.
     */
    void set_private_key(const string& privateKey);
    /**
     * Sets the password to load the client's privateKey if encrypted.
     * @param privateKeyPassword The password to load the privateKey if
     *  						 encrypted.
     */
    void set_private_key_password(const string& privateKeyPassword);
    /**
     * Sets the list of cipher suites that the client will present to the server
     * during the SSL handshake.
     * @param enabledCipherSuites The list of cipher suites that the client
     *  						  will present to the server during the SSL
     *  						  handshake. For a  full explanation of the
     *  						  cipher list format, please see the OpenSSL
     *  						  on-line documentation:
     *  						  https://www.openssl.org/docs/manmaster/man1/openssl-ciphers.html
     *  						  If this setting is omitted, its default
     *  						  value will be "ALL", that is, all the
     *  						  cipher suites -excluding those offering no
     *  						  encryption- will be considered. This
     *  						  setting can be used to set an SSL
     *  						  anonymous connection (empty string value,
     *  						  for instance).
     */
    void set_enabled_cipher_suites(const string& enabledCipherSuites);
    /**
     * Enables or disables verification of the server certificate.
     * @param enableServerCertAuth enable/disable verification of the server
     *  						  certificate
     */
    void set_enable_server_cert_auth(bool enableServerCertAuth);
    /**
     * Gets the requested SSL/TLS version.
     * @return The requested SSL/TLS version.
     */
    int get_ssl_version() const { return opts_.sslVersion; }
    /**
     * Set the SSL/TLS version to use.
     *
     * @param ver The desired SSL/TLS version. Specify one of:
     *  	@li MQTT_SSL_VERSION_DEFAULT (0)
     *  	@li MQTT_SSL_VERSION_TLS_1_0 (1)
     *  	@li MQTT_SSL_VERSION_TLS_1_1 (2)
     *  	@li MQTT_SSL_VERSION_TLS_1_2 (3)
     */
    void set_ssl_version(int ver) { opts_.sslVersion = ver; }
    /**
     * Determines whether it will carry out post-connect checks, including
     * that a certificate matches the given host name.
     * @return Whether it will carry out post-connect checks.
     */
    bool get_verify() const { return to_bool(opts_.verify); }
    /**
     * Sets whether it should carry out post-connect checks, including that
     * a certificate matches the given host name.
     * @param v Whether it should carry out post-connect checks.
     */
    void set_verify(bool v) { opts_.verify = to_int(v); }
    /**
     * Gets the path to a directory containing CA certificates in PEM
     * format.
     *
     * @return Path to a directory containing CA certificates in PEM format,
     *  	   if set. If this isn't set, returns an empty string.
     */
    string get_ca_path() const { return caPath_; }
    string ca_path() const { return caPath_; }
    /**
     * Sets the path to a directory containing CA certificates in PEM
     * format.
     *
     * @param path Path to a directory containing CA certificates in PEM
     *  	   format.
     */
    void set_ca_path(const string& path);
    void ca_path(const string& path) { set_ca_path(path); }
    /**
     * Registers the error message callback handler.
     * @param cb The callback to receive error messages.
     */
    void set_error_handler(error_handler cb);
    /**
     * Registers a callback handler to set the TLS-PSK options.
     * See: OpenSSL SSL_CTX_set_psk_client_callback()
     * @param cb The callback.
     */
    void set_psk_handler(psk_handler cb);
    /**
     * Gets the list of supported ALPN protocols.
     * @return A vector containing the supported ALPN protocols.
     */
    std::vector<string> get_alpn_protos() const;
    /**
     * Sets the list of supported ALPN protocols.
     * See:
     * https://www.openssl.org/docs/man1.1.0/man3/SSL_CTX_set_alpn_protos.html
     * @param protos The list of ALPN protocols to be negotiated.
     */
    void set_alpn_protos(const std::vector<string>& protos);
};

/**
 * Shared pointer to the ssl options class.
 */
using ssl_options_ptr = ssl_options::ptr_t;
/**
 * Unique pointer to the ssl options class.
 */
using ssl_options_unique_ptr = ssl_options::unique_ptr_t;

/////////////////////////////////////////////////////////////////////////////

/**
 * Class to build the SSL options for connections.
 */
class ssl_options_builder
{
    /** The underlying options */
    ssl_options opts_;

public:
    /** This class */
    using self = ssl_options_builder;
    /**
     * Default constructor.
     */
    ssl_options_builder() {}
    /**
     * Sets the file containing the public digital certificates trusted by
     * the client.
     * @param store The file in PEM format containing the public digital
     *  			certificates trusted by the client.
     */
    auto trust_store(const string& store) -> self& {
        opts_.set_trust_store(store);
        return *this;
    }
    /**
     * Sets the file containing the public certificate chain of the client.
     * @param store The file in PEM format containing the public certificate
     *  			chain of the client. It may also include the client's
     *  			private key.
     */
    auto key_store(const string& store) -> self& {
        opts_.set_key_store(store);
        return *this;
    }
    /**
     * Sets the file containing the client's private key.
     * @param key If not included in the sslKeyStore, this is the file in
     *  		  PEM format containing the client's private key.
     */
    auto private_key(const string& key) -> self& {
        opts_.set_private_key(key);
        return *this;
    }
    /**
     * Sets the password to load the client's privateKey if encrypted.
     * @param passwd The password to load the privateKey if encrypted.
     */
    auto private_keypassword(const string& passwd) -> self& {
        opts_.set_private_key_password(passwd);
        return *this;
    }
    /**
     * Sets the list of cipher suites that the client will present to the server
     * during the SSL handshake.
     * @param suites The list of cipher suites that the client will present to
     *  			 the server during the SSL handshake. For a full
     *  			 explanation of the cipher list format, please see the
     *  			 OpenSSL on-line documentation:
     *  			 http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT
     *  			 If this setting is omitted, its default value will be
     *  			 "ALL", that is, all the cipher suites -excluding those
     *  			 offering no encryption- will be considered. This setting
     *  			 can be used to set an SSL anonymous connection (empty
     *  			 string value, for instance).
     */
    auto enabled_cipher_suites(const string& suites) -> self& {
        opts_.set_enabled_cipher_suites(suites);
        return *this;
    }
    /**
     * Enables or disables verification of the server certificate.
     * @param on enable/disable verification of the server certificate
     */
    auto enable_server_cert_auth(bool on) -> self& {
        opts_.set_enable_server_cert_auth(on);
        return *this;
    }
    /**
     * Set the SSL/TLS version to use.
     *
     * @param ver The desired SSL/TLS version. Specify one of:
     *  	@li MQTT_SSL_VERSION_DEFAULT (0)
     *  	@li MQTT_SSL_VERSION_TLS_1_0 (1)
     *  	@li MQTT_SSL_VERSION_TLS_1_1 (2)
     *  	@li MQTT_SSL_VERSION_TLS_1_2 (3)
     */
    auto ssl_version(int ver) -> self& {
        opts_.set_ssl_version(ver);
        return *this;
    }
    /**
     * Sets whether it should carry out post-connect checks, including that
     * a certificate matches the given host name.
     * @param on Whether it should carry out post-connect checks.
     */
    auto verify(bool on = true) -> self& {
        opts_.set_verify(on);
        return *this;
    }
    /**
     * Sets the path to a directory containing CA certificates in PEM format.
     * @param path Path to a directory containing CA certificates in PEM
     *  	   format.
     */
    auto ca_path(const string& path) -> self& {
        opts_.ca_path(path);
        return *this;
    }
    /**
     * Registers an error callback handler.
     * @param cb The callback to receive error messages.
     */
    auto error_handler(ssl_options::error_handler cb) -> self& {
        opts_.set_error_handler(cb);
        return *this;
    }
    /**
     * Registers a callback handler to set the TLS-PSK options.
     * See: OpenSSL SSL_CTX_set_psk_client_callback()
     * @param cb The callback.
     */
    auto psk_handler(ssl_options::psk_handler cb) -> self& {
        opts_.set_psk_handler(cb);
        return *this;
    }
    /**
     * Sets the list of supported ALPN protocols.
     * @param protos The list of ALPN protocols to be negotiated.
     */
    auto alpn_protos(const std::vector<string>& protos) -> self& {
        opts_.set_alpn_protos(protos);
        return *this;
    }
    /**
     * Finish building the options and return them.
     * @return The option struct as built.
     */
    ssl_options finalize() { return opts_; }
};

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_ssl_options_h

```

`include/mqtt/string_collection.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file string_collection.h
/// Definition of the string_collection class for the Paho MQTT C++ library.
/// @date April 23, 2017
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2017-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_string_collection_h
#define __mqtt_string_collection_h

#include <map>
#include <memory>
#include <vector>

#include "MQTTAsync.h"
#include "mqtt/types.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/**
 * Type for a collection of strings, such as MQTT topics.
 *
 * This acts like a standard collection of strings but carries an array of
 * pointers to the C strings for easy interactions with the Paho C library.
 */
class string_collection
{
public:
    /** The type for the collection of strings */
    using collection_type = std::vector<string>;
    /** Iterator over const items */
    using const_iterator = collection_type::const_iterator;

    /** Smart/shared pointer to an object of this type */
    using ptr_t = std::shared_ptr<string_collection>;
    /** Smart/shared pointer to a const object of this type */
    using const_ptr_t = std::shared_ptr<const string_collection>;

private:
    /** The type for the array of C pointers */
    using c_arr_type = std::vector<const char*>;

    /**
     * The collection of strings.
     */
    collection_type coll_;
    /**
     * A collection of pointers to NUL-terminated C strings.
     * This is what is required by the Paho C library, and thus the lifetime
     * of the pointers will remain consistent with the lifetime of the
     * object. The value is kept consistent with the current stringss and
     * updated whenever strings are added or removed.
     */
    c_arr_type cArr_;
    /**
     * Updated the cArr_ object to agree with the values in coll_
     * This should be called any time the coll_ variable is modified
     * <i>in any way</i>.
     */
    void update_c_arr();

public:
    /**
     * Construct an empty string collection.
     */
    string_collection() = default;
    /**
     * Construct a collection initially containing a single string.
     * @param str The string
     */
    string_collection(const string& str);
    /**
     * Construct a collection initially containing a single string.
     * @param str The string
     */
    string_collection(string&& str);
    /**
     * Constructs a string collection by copying a vector of strings.
     * @param vec A vector of strings.
     */
    string_collection(const collection_type& vec);
    /**
     * Constructs a string collection by moving a vector of strings.
     * @param vec A vector of strings.
     */
    string_collection(collection_type&& vec);
    /**
     * Copy constructor.
     * @param coll An existing string collection.
     */
    string_collection(const string_collection& coll);
    /**
     * Move constructor.
     * @param coll An existing string collection.
     */
    string_collection(string_collection&& coll) = default;
    /**
     * Construct a string collection from an initialization list of strings.
     * @param sl An initialization list of strings.
     */
    string_collection(std::initializer_list<string> sl);
    /**
     * Construct a string collection from an initialization list of C string
     * pointers.
     * @param sl An initialization list of C character arrays.
     */
    string_collection(std::initializer_list<const char*> sl);
    /**
     * Create an empty string collection on the heap.
     * @return A smart/shared pointer to a string collection.
     */
    static ptr_t create(const string& str) {
        return std::make_shared<string_collection>(str);
    }
    /**
     * Create a string collection on the heap, initially containing a single
     * string.
     * @param str The string
     * @return A smart/shared pointer to a string collection.
     */
    static ptr_t create(string&& str) { return std::make_shared<string_collection>(str); }
    /**
     * Creates a string collection on the heap by copying a vector of
     * strings.
     * @param vec A vector of strings.
     */
    static ptr_t create(const collection_type& vec) {
        return std::make_shared<string_collection>(vec);
    }
    /**
     * Creates a string collection on the heap by copying a vector of
     * strings.
     * @param vec A vector of strings.
     * @return A smart/shared pointer to a string collection.
     */
    static ptr_t create(collection_type&& vec) {
        return std::make_shared<string_collection>(vec);
    }
    /**
     * Create a string collection on the heap from an initialization list of
     * strings.
     * @param sl An initialization list of strings.
     * @return A smart/shared pointer to a string collection.
     */
    static ptr_t create(std::initializer_list<string> sl) {
        return std::make_shared<string_collection>(sl);
    }
    /**
     * Create a string collection on the heap from an initialization list of
     * C string pointers.
     * @param sl An initialization list of C character arrays.
     * @return A smart/shared pointer to a string collection.
     */
    static ptr_t create(std::initializer_list<const char*> sl) {
        return std::make_shared<string_collection>(sl);
    }
    /**
     * Copy assignment.
     * Copy another string collection to this one.
     * @param coll A string collection
     * @return A reference to this collection.
     */
    string_collection& operator=(const string_collection& coll);
    /**
     * Move assignment.
     * Move another string collection to this one.
     * @param coll A string collection
     * @return A reference to this collection.
     */
    string_collection& operator=(string_collection&& coll) = default;
    /**
     * Gets a const iterator to the beginning of the collection.
     * @return A const iterator to the beginning of the collection.
     */
    const_iterator begin() const { return coll_.begin(); }
    /**
     * Gets a const iterator to the end of the collection.
     * @return A const iterator to the end of the collection.
     */
    const_iterator end() const { return coll_.end(); }
    /**
     * Gets a const iterator to the beginning of the collection.
     * @return A const iterator to the beginning of the collection.
     */
    const_iterator cbegin() const { return coll_.cbegin(); }
    /**
     * Gets a const iterator to the end of the collection.
     * @return A const iterator to the end of the collection.
     */
    const_iterator cend() const { return coll_.cend(); }
    /**
     * Determines if the collection is empty.
     * @return @em true if the collection is empty, @em false if not.
     */
    bool empty() const { return coll_.empty(); }
    /**
     * Gets the number of strings in the collection.
     * @return The number of strings in the collection.
     */
    size_t size() const { return coll_.size(); }
    /**
     * Copies a string onto the back of the collection.
     * @param str A string.
     */
    void push_back(const string& str);
    /**
     * Moves a string onto the back of the collection.
     * @param str A string.
     */
    void push_back(string&& str);
    /**
     * Removes all the strings from the collection.
     */
    void clear();
    /**
     * Gets the n'th string in the collection.
     * @param i Index to the desired string.
     * @return A const reference to the string.
     */
    const string& operator[](size_t i) const { return coll_[i]; }
    /**
     * Gets a pointer to an array of NUL-terminated C string pointers.
     * This is the collection type supported by the underlying Paho C
     * library. The returned pointer is guaranteed valid so long as the
     * object is not updated. The return value may change if the object is
     * modified, so the application should not cache the return value, but
     * rather request the value when needed.
     * @return pointer to an array of NUL-terminated C string pointers of
     *  	   the C++ strings in the object.
     *
     */
    char* const* c_arr() const { return (char* const*)cArr_.data(); }
};

/////////////////////////////////////////////////////////////////////////////

/** Smart/shared pointer to a string collection */
using string_collection_ptr = string_collection::ptr_t;

/** Smart/shared pointer to a const string_collection */
using const_string_collection_ptr = string_collection::const_ptr_t;

/////////////////////////////////////////////////////////////////////////////

/**
 * A collection of name/value string pairs.
 */
class name_value_collection
{
    /** The type for the collection of name/value pairs  */
    using collection_type = std::map<string, string>;
    /** The type for the C pointers to pass to Paho C */
    using c_arr_type = std::vector<MQTTAsync_nameValue>;

    /**
     * The name/value pairs.
     */
    collection_type map_;
    /**
     * A collection of pairs of NUL-terminated C strings.
     */
    c_arr_type cArr_;
    /**
     * Updated the cArr_ object to agree with the values in coll_
     * This should be called any time the coll_ variable is modified
     * <i>in any way</i>.
     */
    void update_c_arr();

public:
    /** Smart/shared pointer to an object of this type */
    using ptr_t = std::shared_ptr<name_value_collection>;
    /** Smart/shared pointer to a const object of this type */
    using const_ptr_t = std::shared_ptr<const name_value_collection>;
    /** The type of the string/string pair of values */
    using value_type = collection_type::value_type;
    /**
     * Default constructor for an empty collection.
     */
    name_value_collection() = default;
    /**
     * Creates a name/value collection from an underlying STL collection.
     * @param map The collection of name/value pairs.
     */
    name_value_collection(const collection_type& map) : map_(map) { update_c_arr(); }
    /**
     * Creates a name/value collection from an underlying STL collection.
     * @param map The collection of name/value pairs.
     */
    name_value_collection(collection_type&& map) : map_(std::move(map)) { update_c_arr(); }
    /**
     * Copy constructor.
     * @param other Another collection of name/value pairs.
     */
    name_value_collection(const name_value_collection& other) : map_(other.map_) {
        update_c_arr();
    }
    /**
     * Move constructor.
     * @param other Another collection of name/value pairs
     */
    name_value_collection(name_value_collection&& other) = default;
    /**
     * Constructs the collection with an initializer list.
     *
     * This works identically to initializing a std::map<> with string/tring
     * pairs.
     *
     * @param init Initializer list to construct the members of the
     *  		   collection.
     */
    name_value_collection(std::initializer_list<value_type> init) : map_{init} {
        update_c_arr();
    }
    /**
     * Copy assignment.
     * @param other Another collection of name/value pairs.
     */
    name_value_collection& operator=(const name_value_collection& other) {
        map_ = other.map_;
        update_c_arr();
        return *this;
    }
    /**
     * Move constructor.
     * @param other Another collection of name/value pairs
     */
    name_value_collection& operator=(name_value_collection&& other) = default;
    /**
     * Determines if the collection is empty.
     * @return @em true if the container is empty, @em false if it contains
     *  	   one or more items.
     */
    bool empty() const { return map_.empty(); }
    /**
     * Gets the number of name/value pairs in the collection.
     * @return The number of name/value pairs in the collection.
     */
    size_t size() const { return map_.size(); }
    /**
     * Removes all items from the collection.
     */
    void clear() {
        map_.clear();
        update_c_arr();
    }
    /**
     * Inserts a name/value pair into the collection.
     * @param nvpair The name/value string pair.
     * @return @em true if the inert happened, @em false if not.
     */
    bool insert(const value_type& nvpair) {
        if (map_.insert(nvpair).second) {
            update_c_arr();
            return true;
        }
        return false;
    }
    /**
     * Gets a pointer to an array of NUL-terminated C string pointer pairs.
     * This is a collection type supported by the underlying Paho C
     * library. The returned pointer is guaranteed valid so long as the
     * object is not updated. The return value may change if the object is
     * modified, so the application should not cache the return value, but
     * rather request the value when needed.
     * @return pointer to an array of NUL-terminated C string pointer pairs
     *         for name/values. The array is terminated by a NULL/NULL pair.
     */
    const MQTTAsync_nameValue* c_arr() const { return cArr_.data(); }
};

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_string_collection_h

```

`include/mqtt/subscribe_options.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file subscribe_options.h
/// Declaration of MQTT subscribe_options class
/// @date Aug 1, 2019 @
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2019-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_subscribe_options_h
#define __mqtt_subscribe_options_h

#include "MQTTAsync.h"
#include "MQTTSubscribeOpts.h"
#include "mqtt/platform.h"
#include "mqtt/types.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/**
 * The MQTT v5 subscription options.
 *
 * The subscribe options are bitfields in the payload of a SUBSCRIBE packet,
 * forming a single options byte for each topic filter in the subscription.
 *
 * These were added in MQTT v5. The default (zero/false) value for each
 * field gives the behavior that was present in MQTT v3.1.1. To get a new
 * behavior the field(s) must be set.
 *
 * These are defined in section 3.8.3.1 of the MQTT v5 spec.
 */
class subscribe_options
{
    /** The underlying C structure */
    MQTTSubscribe_options opts_;

    /** The client and response have special access */
    friend class async_client;
    friend class response_options;

public:
    /** Smart/shared pointer to an object of this class. */
    using ptr_t = std::shared_ptr<subscribe_options>;
    /** Smart/shared pointer to a const object of this class. */
    using const_ptr_t = std::shared_ptr<const subscribe_options>;

    /** Don't receive our own publications */
    static constexpr bool NO_LOCAL = true;
    /** Receive our own publications */
    static constexpr bool LOCAL = false;

    /** @deprecated Don't receive our own publications */
    [[deprecated("Use NO_LOCAL")]] static constexpr bool SUBSCRIBE_NO_LOCAL = true;
    /** @deprecated Receive our own publications (obsolete name) */
    [[deprecated("Use LOCAL")]] static constexpr bool SUBSCRIBE_LOCAL = false;

    /**
     * Retain flag is only set on publications sent by a broker if in
     * response to a subscribe request
     */
    static constexpr bool NO_RETAIN_AS_PUBLISHED = false;
    /** Keep the retain flag as on the original publish message */
    static constexpr bool RETAIN_AS_PUBLISHED = true;

    /** The options for subscription retain handling */
    enum RetainHandling {
        /** Send retained messages at the time of the subscribe */
        SEND_RETAINED_ON_SUBSCRIBE = 0,
        /** Send retained messages on subscribe only if subscription is new */
        SEND_RETAINED_ON_NEW = 1,
        /** Do not send retained messages at all */
        DONT_SEND_RETAINED = 2
    };

    /**
     * Create default subscription options.
     * These are the default options corresponding to the original MQTT (v3)
     * behaviors.
     */
    subscribe_options() : opts_(MQTTSubscribe_options_initializer) {}
    /**
     * Creates a set of subscription options.
     *
     * @param noLocal Whether the server should send back our own
     *  			  publications, if subscribed.
     * @param retainAsPublished Whether to keep the retained flag as in the
     *  						original published message (true).
     * @param retainHandling When to send retained messages:
     *  	@li (SEND_RETAINED_ON_SUBSCRIBE, 0) At the time of the subscribe
     *  	@li (SEND_RETAINED_ON_NEW, 1) Only at the time of a new
     *  		subscribe
     *  	@li (DONT_SEND_RETAINED, 2) Not at the time of subscribe
     */
    explicit subscribe_options(
        bool noLocal, bool retainAsPublished = false,
        RetainHandling retainHandling = SEND_RETAINED_ON_SUBSCRIBE
    )
        : opts_(MQTTSubscribe_options_initializer) {
        opts_.noLocal = noLocal ? 1 : 0;
        opts_.retainAsPublished = retainAsPublished ? 1 : 0;
        opts_.retainHandling = (unsigned char)retainHandling;
    }
    /**
     * Creates the set of subscribe options from an underlying C struct.
     * @param opts The Paho C subscribe options
     */
    explicit subscribe_options(MQTTSubscribe_options opts) : opts_{opts} {}

#if defined(UNIT_TESTS)
    /**
     * Expose the underlying C struct for the unit tests.
     */
    const auto& c_struct() const { return opts_; }
#endif

    /**
     * Gets the value of the "no local" flag.
     * @return Whether the server should send back our own publications, if
     *  	   subscribed.
     */
    bool get_no_local() const { return to_bool(opts_.noLocal); }
    /**
     * Sets the "no local" flag on or off.
     * @param on Whether the server should send back our own publications,
     *  		 if subscribed.
     */
    void set_no_local(bool on = true) { opts_.noLocal = on ? 1 : 0; }
    /**
     * Gets the "retain as published" flag.
     * @return Whether to keep the retained flag as in the original
     *  		 published message.
     */
    bool get_retain_as_published() const { return to_bool(opts_.retainAsPublished); }
    /**
     * Sets the "retain as published" flag on or off.
     * @param on Whether to keep the retained flag as in the original
     *  		 published message.
     */
    void set_retain_as_published(bool on = true) { opts_.retainAsPublished = on ? 1 : 0; }
    /**
     * Gets the "retain handling" option.
     * @return When to send retained messages:
     *  	@li (SEND_RETAINED_ON_SUBSCRIBE, 0) At the time of the subscribe
     *  	@li (SEND_RETAINED_ON_NEW, 1) Only at the time of a new
     *  		subscribe
     *  	@li (DONT_SEND_RETAINED, 2) Not at the time of subscribe
     */
    auto get_retain_handling() const -> RetainHandling {
        return RetainHandling(opts_.retainHandling);
    }
    /**
     * Sets the "retain handling" option.
     * @param retainHandling When to send retained messages:
     *  	@li (SEND_RETAINED_ON_SUBSCRIBE, 0) At the time of the subscribe
     *  	@li (SEND_RETAINED_ON_NEW, 1) Only at the time of a new
     *  		subscribe
     *  	@li (DONT_SEND_RETAINED, 2) Not at the time of subscribe
     */
    void set_retain_handling(RetainHandling retainHandling) {
        opts_.retainHandling = (unsigned char)retainHandling;
    }
};

/** Smart/shared pointer to a subscribe options object. */
using subscribe_options_ptr = subscribe_options::ptr_t;

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_subscribe_options_h

```

`include/mqtt/thread_queue.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file thread_queue.h
/// Implementation of the template class 'thread_queue', a thread-safe,
/// blocking queue for passing data between threads, safe for use with smart
/// pointers.
/// @date 09-Jan-2017
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2017-2022 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_thread_queue_h
#define __mqtt_thread_queue_h

#include <algorithm>
#include <condition_variable>
#include <deque>
#include <limits>
#include <mutex>
#include <queue>
#include <thread>

namespace mqtt {

/**
 * Exception that is thrown when operations are performed on a closed
 * queue.
 */
class queue_closed : public std::runtime_error
{
public:
    queue_closed() : std::runtime_error("queue is closed") {}
};

/////////////////////////////////////////////////////////////////////////////

/**
 * A thread-safe queue for inter-thread communication.
 *
 * This is a locking queue with blocking operations. The get() operations
 * can always block on an empty queue, but have variations for non-blocking
 * (try_get) and bounded-time blocking (try_get_for, try_get_until).
 * @par
 * The default queue has a capacity that is unbounded in the practical
 * sense, limited by available memory. In this mode the object will not
 * block when placing values into the queue. A capacity can bet set with the
 * constructor or, at any time later by calling the @ref capacity(size_type)
 * method. Using this latter method, the capacity can be set to an amount
 * smaller than the current size of the queue. In that case all put's to the
 * queue will block until the number of items are removed from the queue to
 * bring the size below the new capacity.
 * @par
 * The queue can be closed. After that, no new items can be placed into it;
 * a `put()` calls will fail. Receivers can still continue to get any items
 * out of the queue that were added before it was closed. Once there are no
 * more items left in the queue after it is closed, it is considered "done".
 * Nothing useful can be done with the queue.
 * @par
 * Note that the queue uses move semantics to place items into the queue and
 * remove items from the queue. This means that the type, T, of the data
 * held by the queue only needs to follow move semantics; not copy
 * semantics. In addition, this means that copies of the value will @em not
 * be left in the queue. This is especially useful when creating queues of
 * shared pointers, as the "dead" part of the queue will not hold onto a
 * reference count after the item has been removed from the queue.
 *
 * @tparam T The type of the items to be held in the queue.
 * @tparam Container The type of the underlying container to use. It must
 * support back(), front(), push_back(), pop_front().
 */
template <typename T, class Container = std::deque<T>>
class thread_queue
{
public:
    /** The underlying container type to use for the queue. */
    using container_type = Container;
    /** The type of items to be held in the queue. */
    using value_type = T;
    /** The type used to specify number of items in the container. */
    using size_type = typename Container::size_type;

    /** The maximum capacity of the queue. */
    static constexpr size_type MAX_CAPACITY = std::numeric_limits<size_type>::max();

private:
    /** Object lock */
    mutable std::mutex lock_;
    /** Condition get signaled when item added to empty queue */
    std::condition_variable notEmptyCond_;
    /** Condition gets signaled then item removed from full queue */
    std::condition_variable notFullCond_;
    /** The capacity of the queue */
    size_type cap_{MAX_CAPACITY};
    /** Whether the queue is closed */
    bool closed_{false};

    /** The actual STL container to hold data */
    std::queue<T, Container> que_;

    /** Simple, scope-based lock guard */
    using guard = std::lock_guard<std::mutex>;
    /** General purpose guard */
    using unique_guard = std::unique_lock<std::mutex>;

    /** Checks if the queue is done (unsafe) */
    bool is_done() const { return closed_ && que_.empty(); }

public:
    /**
     * Constructs a queue with the maximum capacity.
     * This is effectively an unbounded queue.
     */
    thread_queue() {}
    /**
     * Constructs a queue with the specified capacity.
     * This is a bounded queue.
     * @param cap The maximum number of items that can be placed in the
     *  		  queue. The minimum capacity is 1.
     */
    explicit thread_queue(size_t cap) : cap_(std::max<size_type>(cap, 1)) {}
    /**
     * Determine if the queue is empty.
     * @return @em true if there are no elements in the queue, @em false if
     *  	   there are any items in the queue.
     */
    bool empty() const {
        guard g{lock_};
        return que_.empty();
    }
    /**
     * Gets the capacity of the queue.
     * @return The maximum number of elements before the queue is full.
     */
    size_type capacity() const {
        guard g{lock_};
        return cap_;
    }
    /**
     * Sets the capacity of the queue.
     * Note that the capacity can be set to a value smaller than the current
     * size of the queue. In that event, all calls to put() will block until
     * a sufficient number of items are removed from the queue.
     */
    void capacity(size_type cap) {
        guard g{lock_};
        cap_ = std::max<size_type>(cap, 1);
        if (cap_ > que_.size())
            notFullCond_.notify_all();
    }
    /**
     * Gets the number of items in the queue.
     * @return The number of items in the queue.
     */
    size_type size() const {
        guard g{lock_};
        return que_.size();
    }
    /**
     * Close the queue.
     * Once closed, the queue will not accept any new items, but receievers
     * will still be able to get any remaining items out of the queue until
     * it is empty.
     */
    void close() {
        guard g{lock_};
        closed_ = true;
        notFullCond_.notify_all();
        notEmptyCond_.notify_all();
    }
    /**
     * Determines if the queue is closed.
     * Once closed, the queue will not accept any new items, but receievers
     * will still be able to get any remaining items out of the queue until
     * it is empty.
     * @return @em true if the queue is closed, @false otherwise.
     */
    bool closed() const {
        guard g{lock_};
        return closed_;
    }
    /**
     * Determines if all possible operations are done on the queue.
     * If the queue is closed and empty, then no further useful operations
     * can be done on it.
     * @return @true if the queue is closed and empty, @em false otherwise.
     */
    bool done() const {
        guard g{lock_};
        return is_done();
    }
    /**
     * Clear the contents of the queue.
     * This discards all items in the queue.
     */
    void clear() {
        guard g{lock_};
        while (!que_.empty()) que_.pop();
        notFullCond_.notify_all();
    }
    /**
     * Put an item into the queue.
     * If the queue is full, this will block the caller until items are
     * removed bringing the size less than the capacity.
     * @param val The value to add to the queue.
     */
    void put(value_type val) {
        unique_guard g{lock_};
        notFullCond_.wait(g, [this] { return que_.size() < cap_ || closed_; });
        if (closed_)
            throw queue_closed{};

        que_.emplace(std::move(val));
        notEmptyCond_.notify_one();
    }
    /**
     * Non-blocking attempt to place an item into the queue.
     * @param val The value to add to the queue.
     * @return @em true if the item was added to the queue, @em false if the
     *  	   item was not added because the queue is currently full.
     */
    bool try_put(value_type val) {
        guard g{lock_};
        if (que_.size() >= cap_ || closed_)
            return false;

        que_.emplace(std::move(val));
        notEmptyCond_.notify_one();
        return true;
    }
    /**
     * Attempt to place an item in the queue with a bounded wait.
     * This will attempt to place the value in the queue, but if it is full,
     * it will wait up to the specified time duration before timing out.
     * @param val The value to add to the queue.
     * @param relTime The amount of time to wait until timing out.
     * @return @em true if the value was added to the queue, @em false if a
     *  	   timeout occurred.
     */
    template <typename Rep, class Period>
    bool try_put_for(value_type val, const std::chrono::duration<Rep, Period>& relTime) {
        unique_guard g{lock_};
        bool to = !notFullCond_.wait_for(g, relTime, [this] {
            return que_.size() < cap_ || closed_;
        });
        if (to || closed_)
            return false;

        que_.emplace(std::move(val));
        notEmptyCond_.notify_one();
        return true;
    }
    /**
     * Attempt to place an item in the queue with a bounded wait to an
     * absolute time point.
     * This will attempt to place the value in the queue, but if it is full,
     * it will wait up until the specified time before timing out.
     * @param val The value to add to the queue.
     * @param absTime The absolute time to wait to before timing out.
     * @return @em true if the value was added to the queue, @em false if a
     *  	   timeout occurred.
     */
    template <class Clock, class Duration>
    bool try_put_until(
        value_type val, const std::chrono::time_point<Clock, Duration>& absTime
    ) {
        unique_guard g{lock_};
        bool to = !notFullCond_.wait_until(g, absTime, [this] {
            return que_.size() < cap_ || closed_;
        });

        if (to || closed_)
            return false;

        que_.emplace(std::move(val));
        notEmptyCond_.notify_one();
        return true;
    }
    /**
     * Retrieve a value from the queue.
     * If the queue is empty, this will block indefinitely until a value is
     * added to the queue by another thread,
     * @param val Pointer to a variable to receive the value.
     */
    bool get(value_type* val) {
        if (!val)
            return false;

        unique_guard g{lock_};
        notEmptyCond_.wait(g, [this] { return !que_.empty() || closed_; });
        if (que_.empty())  // We must be done
            return false;

        *val = std::move(que_.front());
        que_.pop();
        notFullCond_.notify_one();
        return true;
    }
    /**
     * Retrieve a value from the queue.
     * If the queue is empty, this will block indefinitely until a value is
     * added to the queue by another thread,
     * @return The value removed from the queue
     */
    value_type get() {
        unique_guard g{lock_};
        notEmptyCond_.wait(g, [this] { return !que_.empty() || closed_; });
        if (que_.empty())  // We must be done
            throw queue_closed{};

        value_type val = std::move(que_.front());
        que_.pop();
        notFullCond_.notify_one();
        return val;
    }
    /**
     * Attempts to remove a value from the queue without blocking.
     * If the queue is currently empty, this will return immediately with a
     * failure, otherwise it will get the next value and return it.
     * @param val Pointer to a variable to receive the value.
     * @return @em true if a value was removed from the queue, @em false if
     *  	   the queue is empty.
     */
    bool try_get(value_type* val) {
        if (!val)
            return false;

        guard g{lock_};
        if (que_.empty())
            return false;

        *val = std::move(que_.front());
        que_.pop();
        notFullCond_.notify_one();
        return true;
    }
    /**
     * Attempt to remove an item from the queue for a bounded amount of time.
     * This will retrieve the next item from the queue. If the queue is
     * empty, it will wait the specified amount of time for an item to arrive
     * before timing out.
     * @param val Pointer to a variable to receive the value.
     * @param relTime The amount of time to wait until timing out.
     * @return @em true if the value was removed the queue, @em false if a
     *  	   timeout occurred.
     */
    template <typename Rep, class Period>
    bool try_get_for(value_type* val, const std::chrono::duration<Rep, Period>& relTime) {
        if (!val)
            return false;

        unique_guard g{lock_};
        notEmptyCond_.wait_for(g, relTime, [this] { return !que_.empty() || closed_; });

        if (que_.empty())
            return false;

        *val = std::move(que_.front());
        que_.pop();
        notFullCond_.notify_one();
        return true;
    }
    /**
     * Attempt to remove an item from the queue for a bounded amount of time.
     * This will retrieve the next item from the queue. If the queue is
     * empty, it will wait until the specified time for an item to arrive
     * before timing out.
     * @param val Pointer to a variable to receive the value.
     * @param absTime The absolute time to wait to before timing out.
     * @return @em true if the value was removed from the queue, @em false
     *  	   if a timeout occurred.
     */
    template <class Clock, class Duration>
    bool try_get_until(
        value_type* val, const std::chrono::time_point<Clock, Duration>& absTime
    ) {
        if (!val)
            return false;

        unique_guard g{lock_};
        notEmptyCond_.wait_until(g, absTime, [this] { return !que_.empty() || closed_; });
        if (que_.empty())
            return false;

        *val = std::move(que_.front());
        que_.pop();
        notFullCond_.notify_one();
        return true;
    }
};

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_thread_queue_h

```

`include/mqtt/token.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file token.h
/// Declaration of MQTT token class
/// @date May 1, 2013
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2013-2019 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *    Frank Pagliughi - MQTT v5 support & server responses
 *******************************************************************************/

#ifndef __mqtt_token_h
#define __mqtt_token_h

#include <chrono>
#include <condition_variable>
#include <mutex>
#include <thread>
#include <vector>

#include "MQTTAsync.h"
#include "mqtt/buffer_ref.h"
#include "mqtt/exception.h"
#include "mqtt/iaction_listener.h"
#include "mqtt/properties.h"
#include "mqtt/server_response.h"
#include "mqtt/string_collection.h"
#include "mqtt/types.h"

namespace mqtt {

class iasync_client;

/////////////////////////////////////////////////////////////////////////////

/**
 * Provides a mechanism for tracking the completion of an asynchronous
 * action.
 */
class token
{
public:
    /** Smart/shared pointer to an object of this class */
    using ptr_t = std::shared_ptr<token>;
    /** Smart/shared pointer to an object of this class */
    using const_ptr_t = std::shared_ptr<const token>;
    /** Weak pointer to an object of this class */
    using weak_ptr_t = std::weak_ptr<token>;

    /** The type of request that the token is tracking */
    enum Type { CONNECT, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, DISCONNECT };

private:
    /** Lock guard type for this class. */
    using guard = std::lock_guard<std::mutex>;
    /** Unique type for this class. */
    using unique_lock = std::unique_lock<std::mutex>;

    /** Object monitor mutex. */
    mutable std::mutex lock_;
    /** Condition variable signals when the action completes */
    mutable std::condition_variable cond_;

    /** The type of request that the token is tracking */
    Type type_;
    /** The MQTT client that is processing this action */
    iasync_client* cli_;
    /** The action success/failure code */
    int rc_{0};
    /** MQTT v5 reason code */
    ReasonCode reasonCode_{ReasonCode::SUCCESS};
    /** Error message from the C lib (if any) */
    string errMsg_;
    /** The underlying C token. Note that this is just an integer */
    MQTTAsync_token msgId_;
    /** The topic string(s) for the action being tracked by this token */
    const_string_collection_ptr topics_;
    /** User supplied context */
    void* userContext_;

    /**
     * User supplied listener.
     * Note that the user listener fires after the action is marked
     * complete, but before the token is signaled.
     */
    iaction_listener* listener_;
    /** The number of expected responses */
    size_t nExpected_;
    /** Whether the action has yet to complete */
    bool complete_;

    /** Connection response (null if not available) */
    std::unique_ptr<connect_response> connRsp_;
    /** Subscribe response (null if not available) */
    std::unique_ptr<subscribe_response> subRsp_;
    /** Unsubscribe response (null if not available) */
    std::unique_ptr<unsubscribe_response> unsubRsp_;

    /** Client and token-related options have special access */
    friend class async_client;
    friend class mock_async_client;

    friend class connect_options;
    friend class response_options;
    friend class delivery_response_options;
    friend class disconnect_options;

    /**
     * Resets the token back to a non-signaled state.
     */
    void reset();
    /**
     * Sets the ID for the message.
     * This is a guaranteed atomic operation.
     * @param msgId The ID of the message.
     */
    void set_message_id(MQTTAsync_token msgId) {
        guard g(lock_);
        msgId_ = msgId;
    }
    /**
     * C-style callback for success.
     * This simply passes the call on to the proper token object for
     * processing.
     * @param tokObj The token object to process the call. Note that this is
     *  			 @em not the user-supplied context pointer. That is
     *  			 kept in the object itself.
     * @param rsp The success response.
     */
    static void on_success(void* tokObj, MQTTAsync_successData* rsp);
    static void on_success5(void* tokObj, MQTTAsync_successData5* rsp);
    /**
     * C-style callback for failure.
     * This simply passes the call on to the proper token object for
     * processing.
     * @param tokObj The token object to process the call. Note that this is
     *  			 @em not the user-supplied context pointer. That is
     *  			 kept in the object itself.
     * @param rsp The failure response.
     */
    static void on_failure(void* tokObj, MQTTAsync_failureData* rsp);
    static void on_failure5(void* tokObj, MQTTAsync_failureData5* rsp);
    /**
     * C-style callback for client (re)connection.
     * This is normally only used to process a reconnect completion message.
     * The initial connect() is processed via on_success/failure.
     * @param tokObj Pointer to the token object used to process the call.
     */
    static void on_connected(void* tokObj, char* /*cause*/);
    /**
     * Internal handler for the success callback.
     * @param rsp The success response.
     */
    void on_success(MQTTAsync_successData* rsp);
    void on_success5(MQTTAsync_successData5* rsp);
    /**
     * Internal handler for the failure callback.
     * @param rsp The failure response.
     */
    void on_failure(MQTTAsync_failureData* rsp);
    void on_failure5(MQTTAsync_failureData5* rsp);

    /**
     * Check the current return code and throw an exception if it is not a
     * success code.
     */
    void check_ret() const {
        if (rc_ != MQTTASYNC_SUCCESS || reasonCode_ >= 0x80)
            throw exception(rc_, reasonCode_, errMsg_);
    }

public:
    /**
     * Constructs a token object.
     * @param typ The type of request that the token is tracking.
     * @param cli The client that created the token.
     */
    token(Type typ, iasync_client& cli) : token{typ, cli, MQTTAsync_token(0)} {}
    /**
     * Constructs a token object.
     * @param typ The type of request that the token is tracking.
     * @param cli The client that created the token.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb callback listener that will be notified when subscribe has
     *  		 completed
     */
    token(Type typ, iasync_client& cli, void* userContext, iaction_listener& cb)
        : token{typ, cli, const_string_collection_ptr(), userContext, cb} {}

    /**
     * Constructs a token object.
     * @param typ The type of request that the token is tracking.
     * @param cli The client that created the token.
     * @param topic The topic associated with the token
     */
    token(Type typ, iasync_client& cli, const string& topic)
        : token{typ, cli, string_collection::create(topic)} {}
    /**
     * Constructs a token object.
     * @param typ The type of request that the token is tracking.
     * @param cli The client that created the token.
     * @param topic The topic associated with the token
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb callback listener that will be notified when subscribe has
     *  		 completed
     */
    token(
        Type typ, iasync_client& cli, const string& topic, void* userContext,
        iaction_listener& cb
    )
        : token{typ, cli, string_collection::create(topic), userContext, cb} {}

    /**
     * Constructs a token object.
     * @param typ The type of request that the token is tracking.
     * @param cli The client that created the token.
     * @param topics The topics associated with the token
     */
    token(Type typ, iasync_client& cli, const_string_collection_ptr topics);
    /**
     * Constructs a token object.
     * @param typ The type of request that the token is tracking.
     * @param cli The client that created the token.
     * @param topics The topics associated with the token
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb callback listener that will be notified when subscribe has
     *  		 completed
     */
    token(
        Type typ, iasync_client& cli, const_string_collection_ptr topics, void* userContext,
        iaction_listener& cb
    );
    /**
     * Constructs a token object.
     * @param typ The type of request that the token is tracking.
     * @param cli The client that created the token.
     * @param tok The message ID
     */
    token(Type typ, iasync_client& cli, MQTTAsync_token tok);
    /**
     * Virtual destructor.
     */
    virtual ~token() {}
    /**
     * Constructs a token object.
     * @param typ The type of request that the token is tracking.
     * @param cli The client that created the token.
     * @return A smart/shared pointer to a token.
     */
    static ptr_t create(Type typ, iasync_client& cli) {
        return std::make_shared<token>(typ, cli);
    }
    /**
     * Constructs a token object.
     * @param typ The type of request that the token is tracking.
     * @param cli The client that created the token.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb callback listener that will be notified when subscribe has
     *  		 completed
     */
    static ptr_t create(
        Type typ, iasync_client& cli, void* userContext, iaction_listener& cb
    ) {
        return std::make_shared<token>(typ, cli, userContext, cb);
    }
    /**
     * Constructs a token object.
     * @param typ The type of request that the token is tracking.
     * @param cli The client that created the token.
     * @param topic The topic associated with the token
     */
    static ptr_t create(Type typ, iasync_client& cli, const string& topic) {
        return std::make_shared<token>(typ, cli, topic);
    }
    /**
     * Constructs a token object.
     * @param typ The type of request that the token is tracking.
     * @param cli The client that created the token.
     * @param topic The topic associated with the token
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb callback listener that will be notified when subscribe has
     *  		 completed
     */
    static ptr_t create(
        Type typ, iasync_client& cli, const string& topic, void* userContext,
        iaction_listener& cb
    ) {
        return std::make_shared<token>(typ, cli, topic, userContext, cb);
    }
    /**
     * Constructs a token object.
     * @param typ The type of request that the token is tracking.
     * @param cli The client that created the token.
     * @param topics The topics associated with the token
     */
    static ptr_t create(Type typ, iasync_client& cli, const_string_collection_ptr topics) {
        return std::make_shared<token>(typ, cli, topics);
    }
    /**
     * Constructs a token object.
     * @param typ The type of request that the token is tracking.
     * @param cli The client that created the token.
     * @param topics The topics associated with the token
     *
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     * @param cb callback listener that will be notified when subscribe has
     */
    static ptr_t create(
        Type typ, iasync_client& cli, const_string_collection_ptr topics, void* userContext,
        iaction_listener& cb
    ) {
        return std::make_shared<token>(typ, cli, topics, userContext, cb);
    }
    /**
     * Gets the type of request the token is tracking, like CONNECT,
     * PUBLISH, etc.
     * @return The type of request that the token is tracking.
     */
    Type get_type() const { return type_; }
    /**
     * Gets the action listener for this token.
     * @return The action listener for this token.
     */
    virtual iaction_listener* get_action_callback() const {
        guard g(lock_);
        return listener_;
    }
    /**
     * Returns the MQTT client that is responsible for processing the
     * asynchronous action.
     * @return The client to which this token is connected.
     */
    virtual iasync_client* get_client() const { return cli_; }
    /**
     * Returns the ID of the message that is associated with the token.
     * @return The message ID of the transaction being tracked.
     */
    virtual int get_message_id() const {
        static_assert(sizeof(msgId_) <= sizeof(int), "MQTTAsync_token must fit into int");
        return int(msgId_);
    }
    /**
     * Gets the topic string(s) for the action being tracked by this
     * token.
     * @return A const pointer to the collection of topics being tracked by
     *  	   the token.
     */
    virtual const_string_collection_ptr get_topics() const { return topics_; }
    /**
     * Retrieve the context associated with an action.
     * @return The context associated with an action.
     */
    virtual void* get_user_context() const {
        guard g(lock_);
        return userContext_;
    }
    /**
     * Returns whether or not the action has finished.
     * @return @em true if the transaction has completed, @em false if not.
     */
    virtual bool is_complete() const { return complete_; }
    /**
     * Determines if the reference is valid.
     * If the reference is invalid then it is not safe to call @em any
     * member functions other than @ref is_null() and @ref empty()
     * @return @em true if referring to a valid buffer, @em false if the
     *  	   reference (pointer) is null.
     */
    explicit operator bool() const {
        guard g(lock_);
        return rc_ == MQTTASYNC_SUCCESS && reasonCode_ < 0x80;
    }
    /**
     * Gets the return code from the action.
     * This is only valid after the action has completed (i.e. if @ref
     * is_complete() returns @em true).
     * @return The return code from the action.
     */
    virtual int get_return_code() const { return rc_; }
    /**
     * Register a listener to be notified when an action completes.
     * @param listener The callback to be notified when actions complete.
     */
    virtual void set_action_callback(iaction_listener& listener);
    /**
     * Store some context associated with an action.
     * @param userContext optional object used to pass context to the
     *  				  callback. Use @em nullptr if not required.
     */
    virtual void set_user_context(void* userContext) {
        guard g(lock_);
        userContext_ = userContext;
    }
    /**
     * Sets the number of results expected.
     * This is only required for subscribe many() with < MQTTv5
     * @param n The number of results expected.
     */
    void set_num_expected(size_t n) { nExpected_ = n; }
    /**
     * Gets the reason code for the operation.
     * @return The reason code for the operation.
     */
    ReasonCode get_reason_code() const { return reasonCode_; }
    /**
     * Get the error message from the C library
     * @return Error message for the operation
     */
    string get_error_message() const { return errMsg_; }
    /**
     * Blocks the current thread until the action this token is associated
     * with has completed.
     */
    virtual void wait();
    /**
     * Non-blocking check to see if the action has completed.
     * @return @em true if the wait finished successfully, @em false if the
     *  	   action has not completed yet.
     */
    virtual bool try_wait() {
        guard g(lock_);
        if (complete_)
            check_ret();
        return complete_;
    }
    /**
     * Blocks the current thread until the action this token is associated
     * with has completed.
     * @param timeout The timeout (in milliseconds)
     * @return @em true if the wait finished successfully, @em false if a
     *  	   timeout occurred.
     */
    virtual bool wait_for(long timeout) {
        return wait_for(std::chrono::milliseconds(timeout));
    }
    /**
     * Waits a relative amount of time for the action to complete.
     * @param relTime The amount of time to wait for the event.
     * @return @em true if the event gets signaled in the specified time,
     *  	   @em false on a timeout.
     */
    template <class Rep, class Period>
    bool wait_for(const std::chrono::duration<Rep, Period>& relTime) {
        unique_lock g(lock_);
        if (!cond_.wait_for(g, std::chrono::milliseconds(relTime), [this] {
                return complete_;
            }))
            return false;
        check_ret();
        return true;
    }
    /**
     * Waits until an absolute time for the action to complete.
     * @param absTime The absolute time to wait for the event.
     * @return @em true if the event gets signaled in the specified time,
     *  	   @em false on a timeout.
     */
    template <class Clock, class Duration>
    bool wait_until(const std::chrono::time_point<Clock, Duration>& absTime) {
        unique_lock g(lock_);
        if (!cond_.wait_until(g, absTime, [this] { return complete_; }))
            return false;
        check_ret();
        return true;
    }

    /**
     * Gets the response from a connect operation.
     * This returns the result of the completed operation. If the
     * operation is not yet complete this will block until the result
     * is available.
     * @return The result of the operation.
     */
    connect_response get_connect_response() const;
    /**
     * Gets the response from a connect operation.
     * This returns the result of the completed operation. If the
     * operation is not yet complete this will block until the result
     * is available.
     * @return The result of the operation.
     */
    subscribe_response get_subscribe_response() const;
    /**
     * Gets the response from a connect operation.
     * This returns the result of the completed operation. If the
     * operation is not yet complete this will block until the result
     * is available.
     * @return The result of the operation.
     */
    unsubscribe_response get_unsubscribe_response() const;
};

/** Smart/shared pointer to a token object */
using token_ptr = token::ptr_t;

/** Smart/shared pointer to a const token object */
using const_token_ptr = token::const_ptr_t;

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_token_h

```

`include/mqtt/topic.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file topic.h
/// Declaration of classes for MQTT topics and filters
/// @date May 1, 2013
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2013-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_topic_h
#define __mqtt_topic_h

#include <vector>
#include <variant>

#include "MQTTAsync.h"
#include "mqtt/delivery_token.h"
#include "mqtt/message.h"
#include "mqtt/subscribe_options.h"
#include "mqtt/types.h"

namespace mqtt {

class iasync_client;

/////////////////////////////////////////////////////////////////////////////

/**
 * Represents a topic destination, used for publish/subscribe messaging.
 *
 * This is primarily a convenience class for publishing multiple messages to
 * the same topic. It holds all the parameters for publishing the message
 * other than the payload: topic, QoS, and retain flag. Each publish
 * operation then only needs to supply the payload.
 *
 * It can also be used to subscribe to the specific topic, but this is not
 * the normal use case.
 */
class topic
{
    /** The client to which this topic is connected */
    iasync_client& cli_;
    /** The topic name */
    string name_;
    /** The default QoS */
    int qos_;
    /** The default retained flag */
    bool retained_;

public:
    /** A smart/shared pointer to this class. */
    using ptr_t = std::shared_ptr<topic>;
    /** A smart/shared pointer to this class. */
    using const_ptr_t = std::shared_ptr<const topic>;

    /**
     * Construct an MQTT topic destination for messages.
     * @param cli Client to which the topic is attached
     * @param name The topic string
     * @param qos The default QoS for publishing.
     * @param retained The default retained flag for the topic.
     */
    topic(
        iasync_client& cli, const string& name, int qos = message::DFLT_QOS,
        bool retained = message::DFLT_RETAINED
    )
        : cli_(cli), name_(name), qos_(qos), retained_(retained) {}
    /**
     * Creates a new topic.
     * @param cli Client to which the topic is attached
     * @param name The topic string
     * @param qos The default QoS for publishing.
     * @param retained The default retained flag for the topic.
     * @return A shared pointer to the topic.
     */
    static ptr_t create(
        iasync_client& cli, const string& name, int qos = message::DFLT_QOS,
        bool retained = message::DFLT_RETAINED
    ) {
        return std::make_shared<topic>(cli, name, qos, retained);
    }
    /**
     * Gets a reference to the MQTT client used by this topic.
     * @return The MQTT client used by this topic
     */
    iasync_client& get_client() { return cli_; }
    /**
     * Gets the name of the topic.
     * @return The name of the topic.
     */
    const string& get_name() const { return name_; }
    /**
     * Splits a topic string into individual fields.
     *
     * @param topic A slash-delimited MQTT topic string.
     * @return A vector containing the fields of the topic.
     */
    static std::vector<std::string> split(const std::string& topic);
    /**
     * Gets the default quality of service for this topic.
     * @return The default quality of service for this topic.
     */
    int get_qos() const { return qos_; }
    /**
     * Gets the default retained flag used for this topic.
     * @return The default retained flag used for this topic.
     */
    bool get_retained() const { return retained_; }
    /**
     * Sets the default quality of service for this topic.
     * @param qos The default quality of service for this topic.
     */
    void set_qos(int qos) {
        message::validate_qos(qos);
        qos_ = qos;
    }
    /**
     * Sets the default retained flag used for this topic.
     * @param retained The default retained flag used for this topic.
     */
    void set_retained(bool retained) { retained_ = retained; }
    /**
     * Publishes a message on the topic using the default QoS and retained
     * flag.
     * @param payload the bytes to use as the message payload
     * @param n the number of bytes in the payload
     * @return The delivery token used to track and wait for the publish to
     *  	   complete.
     */
    delivery_token_ptr publish(const void* payload, size_t n);
    /**
     * Publishes a message on the topic.
     * @param payload the bytes to use as the message payload
     * @param n the number of bytes in the payload
     * @param qos the Quality of Service to deliver the message at. Valid
     *  		  values are 0, 1 or 2.
     * @param retained whether or not this message should be retained by the
     *  			   server.
     * @return The delivery token used to track and wait for the publish to
     *  	   complete.
     */
    delivery_token_ptr publish(const void* payload, size_t n, int qos, bool retained);
    /**
     * Publishes a message on the topic using the default QoS and retained
     * flag.
     * @param payload the bytes to use as the message payload
     * @return The delivery token used to track and wait for the publish to
     *  	   complete.
     */
    delivery_token_ptr publish(binary_ref payload);
    /**
     * Publishes a message on the topic.
     * @param payload the bytes to use as the message payload
     * @param qos the Quality of Service to deliver the message at. Valid
     *  		  values are 0, 1 or 2.
     * @param retained whether or not this message should be retained by the
     *  			   server.
     * @return The delivery token used to track and wait for the publish to
     *  	   complete.
     */
    delivery_token_ptr publish(binary_ref payload, int qos, bool retained);
    /**
     * Subscribe to the topic.
     * @return A token used to track the progress of the operation.
     */
    token_ptr subscribe(const subscribe_options& opts = subscribe_options());
    /**
     * Returns a string representation of this topic.
     * @return The name of the topic
     */
    string to_string() const { return name_; }
};

/** A smart/shared pointer to a topic object. */
using topic_ptr = topic::ptr_t;

/** A smart/shared pointer to a const topic object. */
using const_topic_ptr = topic::const_ptr_t;

/////////////////////////////////////////////////////////////////////////////
//  						Topic Filter
/////////////////////////////////////////////////////////////////////////////

/**
 * An MQTT topic filter.
 *
 * This is a multi-field string, delimited by forward slashes, '/', in which
 *  fields can contain the wildcards:
 *
 *     '+' - Matches a single field
 *     '#' - Matches all subsequent fields (must be last field in filter)
 *
 * It can be used to match against specific topics.
 *
 * This is simple class for individual topics. For a collection of topics
 * mapped to arbitrary values, like queues or callback functions, for
 * processing incoming messages, consider the @ref topic_mapper.
 */
class topic_filter
{
    /**
     * If the filter contains wildcards, we split it and store it as a
     * vector of the individual fields. Otherwise we store the filter as
     * a string and match with a simple string comparison.
     */
    std::variant<string, std::vector<string>> filter_;

public:
    /**
     * Creates a new topic filter.
     *
     * @param filter A string MQTT topic filter. This is a slash ('/')
     *  			 delimited topic string that can contain wildcards
     * 				 '+' and '#'.
     */
    explicit topic_filter(const string& filter);
    /**
     * Determines if the character is a wildcard, '+' or '#'
     * @param c The character to check
     * @return @em true if `c` is a wildcard, '+' or '#'
     */
    static bool is_wildcard(char c) { return c == '+' || c == '#'; }
    /**
     * Determines if the string (field) is a wildcard, "+" or "#"
     * @param s The string to check
     * @return @em true if `c` is a wildcard, "+" or "#"
     */
    static bool is_wildcard(const string& s) { return s.size() == 1 && is_wildcard(s[0]); }
    /**
     * Determines if the specified topic/filter contains any wildcards.
     *
     * @param filter The topic/filter string to check for wildcards.
     * @return @em true if any of the fields contain a wildcard, @em false
     *  	   if not.
     */
    static bool has_wildcards(const string& filter);
    /**
     * Determines if this topic filter contains any wildcards.
     *
     * @return @em true if any of the fields contain a wildcard, @em false
     *  	   if not.
     */
    bool has_wildcards() const;
    /**
     * Determine if the topic matches this filter.
     *
     * @param topic An MQTT topic. It should not contain wildcards.
     * @return  @em true of the topic matches this filter, @em false
     *  		otherwise.
     */
    bool matches(const string& topic) const;
    /**
     * Gets the topic filter string.
     * @return The topic filter string.
     */
    string to_string() const;
};

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_topic_h

```

`include/mqtt/topic_matcher.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file topic_matcher.h
/// Declaration of MQTT topic_matcher class
/// @date April 23, 2022
/// @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2022-2025 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_topic_matcher_h
#define __mqtt_topic_matcher_h

#include <forward_list>
#include <initializer_list>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include "mqtt/topic.h"
#include "mqtt/types.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/**
 * A collection of MQTT topic filters mapped to arbitrary values.
 *
 * This can be used to get an iterator to all filters in the collection that
 * match a topic. A typical use case might be to match incoming messages to
 * specific callback functions based on topics.
 *
 * To test against a single filter, see
 * [`TopicFilter`](crate::TopicFilter). This collection is more commonly
 * used when there are a number of filters and each needs to be associated
 * with a particular action or piece of data. Note, however, that a single
 * incoming topic could match against several items in the collection. For
 * example, the topic:
 *
 * @code
 * data/temperature/engine
 * @endcode
 *
 * Could match against the filters:
 * @code
 * data/temperature/engine
 * data/temperature/#
 * data/+/engine
 * @endcode
 *
 * Thus, the collection gives an iterator for the items matching a topic.
 *
 * A common use for this would be to store callbacks to process incoming
 * messages based on topics.
 *
 * Note, however, that MQTT v5 has Subscription Identifiers. These are
 * integer values that can be mapped to specific filters when subscribing.
 * The server will include the identifier when sending a message to the
 * client to indicate which filter the message matched. This can be used to
 * make a simple, efficient, lookup-table for callbacks, etc. It could be a
 * prefereble way to handle subscriptions when available.
 *
 * This code was adapted from the Eclipse Paho Python `MQTTMatcher` class:
 *
 *<https://github.com/eclipse/paho.mqtt.python/blob/master/src/paho/mqtt/matcher.py>
 *
 * which use a prefix tree (trie) to store the values.
 *
 * For example, if you had a `topic_mapper<int>` and you inserted:
 * @code
 * topic_matcher<int> tm{
 *     {"some/random/topic", 42},
 *     {"some/#", 99},
 *     {"some/+/topic", 33}
 * };
 * @endcode
 *
 * The collection would be built like:
 * @code
 * "some" -> <null>
 *     "random" -> <null>
 *         "topic" -> <42>
 *     "#" -> <99>
 *     "+" -> <null>
 *         "topic" -> <33>
 * @endcode
 *
 * Note that the collection has two types of iterators. The basic `iterator`
 * is a normal C++ iterator over *all* the items in the collection. It will
 * visit every node in the collection and produce all items. This is not the
 * typical use case for the collection, but can be used for diagnostics,
 * etc, to show the full contents of the collection.
 *
 * The more common use case is the `match_iterator`, returned by the
 * `topic_matcher::matches(string)` method. This is an optimized search
 * iterator for finding all the filters and values that match the specified
 * topic string.
 */
template <typename T>
class topic_matcher
{
public:
    using key_type = string;
    using mapped_type = T;
    using value_type = std::pair<key_type, mapped_type>;
    using reference = value_type;
    using const_reference = const value_type&;

    using value_ptr = std::unique_ptr<value_type>;
    using mapped_ptr = std::unique_ptr<mapped_type>;

private:
    /**
     * The nodes of the collection.
     */
    struct node
    {
        using ptr_t = std::unique_ptr<node>;
        using map_t = std::map<string, ptr_t>;

        /** The value that matches the topic at this node, if any */
        value_ptr content;
        /** Child nodes mapped by the next field of the topic */
        map_t children;

        /** Creates a new, empty node */
        static ptr_t create() { return std::make_unique<node>(); }
        /** Determines if this node is empty (no content or children) */
        bool empty() const { return !content && children.empty(); }

        /** Removes the empty nodes under this one. */
        void prune() {
            for (auto& child : children) {
                child.second->prune();
            }

            for (auto child = children.cbegin(); child != children.cend();) {
                if (child->second->empty()) {
                    child = children.erase(child);
                }
                else {
                    ++child;
                }
            }
        }
    };
    using node_ptr = typename node::ptr_t;
    using node_map = typename node::map_t;

    /** The root node of the collection */
    node_ptr root_;

public:
    /** Generic iterator over all items in the collection. */
    class iterator
    {
        /** The last-found value */
        value_type* pval_;
        /** The nodes still to be checked, used as a stack */
        std::vector<node*> nodes_;

        void next() {
            // If there are no nodes left to search, we're done.
            if (nodes_.empty()) {
                pval_ = nullptr;
                return;
            }

            // Get the next node to search.
            auto snode = std::move(nodes_.back());
            nodes_.pop_back();

            // Push the children onto the stack for later
            for (auto const& child : snode->children) {
                nodes_.push_back(child.second.get());
            }

            // If there's a value in this node, use it;
            // otherwise keep looking.
            pval_ = snode->content.get();
            if (!pval_)
                this->next();
        }

        friend class topic_matcher;

        iterator(value_type* pval) : pval_{pval} {}
        iterator(node* root) : pval_{nullptr} {
            nodes_.push_back(root);
            next();
        }

    public:
        /**
         * Gets a reference to the current value.
         * @return A reference to the current value.
         */
        reference operator*() noexcept { return *pval_; }
        /**
         * Gets a const reference to the current value.
         * @return A const reference to the current value.
         */
        const_reference operator*() const noexcept { return *pval_; }
        /**
         * Get a pointer to the current value.
         * @return A pointer to the current value.
         */
        value_type* operator->() noexcept { return pval_; }
        /**
         * Get a const pointer to the current value.
         * @return A const pointer to the current value.
         */
        const value_type* operator->() const noexcept { return pval_; }
        /**
         * Postfix increment operator.
         * @return An iterator pointing to the previous matching item.
         */
        iterator operator++(int) noexcept {
            auto tmp = *this;
            this->next();
            return tmp;
        }
        /**
         * Prefix increment operator.
         * @return An iterator pointing to the next matching item.
         */
        iterator& operator++() noexcept {
            this->next();
            return *this;
        }
        /**
         * Compares two iterators to see if they don't refer to the same
         * node.
         *
         * @param other The other iterator to compare against this one.
         * @return @em true if they don't match, @em false if they do
         */
        bool operator!=(const iterator& other) const noexcept { return pval_ != other.pval_; }
    };

    /** A const iterator over all itemsin the collection. */
    class const_iterator : public iterator
    {
        using base = iterator;

        friend class topic_matcher;
        const_iterator(iterator it) : base(it) {}

    public:
        /**
         * Gets a const reference to the current value.
         * @return A const reference to the current value.
         */
        const_reference operator*() const noexcept { return base::operator*(); }
        /**
         * Get a const pointer to the current value.
         * @return A const pointer to the current value.
         */
        const value_type* operator->() const noexcept { return base::operator->(); }
    };

    /**
     * Iterator that efficiently searches the collection for topic
     * matches.
     */
    class match_iterator
    {
        /** Information about a node that needs to be searched. */
        struct search_node
        {
            /** The current node being searched. */
            node* node_;
            /** The fields of the topic still to be searched. */
            std::forward_list<string> fields_;
            /** Whether this is the first/root node */
            bool first_;

            search_node(node* nd, const std::forward_list<string>& sy, bool first = false)
                : node_{nd}, fields_{sy}, first_{first} {}
            search_node(node* nd, std::forward_list<string>&& sy, bool first = false)
                : node_{nd}, fields_{std::move(sy)}, first_{first} {}
        };

        /** The last-found value */
        value_type* pval_;
        /** The nodes still to be checked, used as a stack */
        std::vector<search_node> nodes_;

        /**
         * Move the next iterator to the next value, or to end(), if none
         * left.
         *
         * This will keep recursing until it finds a matching node that
         * contains a value or it reaches the end.
         */
        void next() {
            pval_ = nullptr;

            // If there are no nodes left to search, we're done.
            if (nodes_.empty())
                return;

            // Get the next node to search.
            auto snode = std::move(nodes_.back());
            nodes_.pop_back();

            const auto map_end = snode.node_->children.end();
            typename node_map::iterator child;

            // If we're at the end of the topic fields, we either have a value,
            // or need to move on to the next node to search.
            if (snode.fields_.empty()) {
                pval_ = snode.node_->content.get();
                if (!pval_) {
                    // ...but a '#' matches the parent topic
                    if ((child = snode.node_->children.find("#")) != map_end) {
                        pval_ = child->second->content.get();
                        return;
                    }
                    this->next();
                }
                return;
            }

            // Get the next field of the topic to search
            auto field = std::move(snode.fields_.front());
            snode.fields_.pop_front();

            // Look for an exact match
            if ((child = snode.node_->children.find(field)) != map_end) {
                nodes_.push_back({child->second.get(), snode.fields_});
            }

            // Topics starting with '$' don't match wildcards in the first field
            // MQTT v5 Spec, Section 4.7.2:
            // https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901246

            if (!snode.first_ || field.empty() || field[0] != '$') {
                // Look for a single-field wildcard match
                if ((child = snode.node_->children.find("+")) != map_end) {
                    nodes_.push_back({child->second.get(), snode.fields_});
                }

                // Look for a terminating match
                if ((child = snode.node_->children.find("#")) != map_end) {
                    // By definition, a '#' is a terminating leaf
                    pval_ = child->second->content.get();
                    return;
                }
            }

            this->next();
        }

        friend class topic_matcher;

        match_iterator() : pval_{nullptr} {}
        match_iterator(value_type* pval) : pval_{pval} {}
        match_iterator(node* root, const string& topic) : pval_{nullptr} {
            auto v = topic::split(topic);
            std::forward_list<string> fields{v.begin(), v.end()};
            nodes_.push_back(search_node{root, std::move(fields), true});
            next();
        }

    public:
        /**
         * Gets a reference to the current value.
         * @return A reference to the current value.
         */
        reference operator*() noexcept { return *pval_; }
        /**
         * Gets a const reference to the current value.
         * @return A const reference to the current value.
         */
        const_reference operator*() const noexcept { return *pval_; }
        /**
         * Get a pointer to the current value.
         * @return A pointer to the current value.
         */
        value_type* operator->() noexcept { return pval_; }
        /**
         * Get a const pointer to the current value.
         * @return A const pointer to the current value.
         */
        const value_type* operator->() const noexcept { return pval_; }
        /**
         * Postfix increment operator.
         * @return An iterator pointing to the previous matching item.
         */
        match_iterator operator++(int) noexcept {
            auto tmp = *this;
            this->next();
            return tmp;
        }
        /**
         * Prefix increment operator.
         * @return An iterator pointing to the next matching item.
         */
        match_iterator& operator++() noexcept {
            this->next();
            return *this;
        }
        /**
         * Compares two iterators to see if they don't refer to the same
         * node.
         *
         * @param other The other iterator to compare against this one.
         * @return @em true if they don't match, @em false if they do
         */
        bool operator!=(const match_iterator& other) const noexcept {
            return pval_ != other.pval_;
        }
    };

    /**
     * A const match iterator.
     */
    class const_match_iterator : public match_iterator
    {
        using base = match_iterator;

        friend class topic_matcher;
        const_match_iterator(match_iterator it) : base(it) {}

    public:
        /**
         * Gets a const reference to the current value.
         * @return A const reference to the current value.
         */
        const_reference operator*() const noexcept { return base::operator*(); }
        /**
         * Get a const pointer to the current value.
         * @return A const pointer to the current value.
         */
        const value_type* operator->() const noexcept { return base::operator->(); }
    };

    /**
     * Creates  new, empty collection.
     */
    topic_matcher() : root_(node::create()) {}
    /**
     * Creates a new collection with a list of key/value pairs.
     *
     * This can be used to create a connection from a table of entries, as
     * key/value pairs, like:
     *
     *     topic_matcher<int> matcher {
     *  	   { "#", -1 },
     *  	   { "some/random/topic", 42 },
     *  	   { "some/#", 99 }
     *     }
     *
     * @param lst The list of key/value pairs to populate the collection.
     */
    topic_matcher(std::initializer_list<value_type> lst) : root_(node::create()) {
        for (const auto& v : lst) {
            insert(v);
        }
    }
    /**
     * Determines if the collection is empty.
     * @return @em true if the collection is empty, @em false if it contains
     *         any filters.
     */
    bool empty() const { return root_.empty(); }
    /**
     * Inserts a new key/value pair into the collection.
     * @param val The value to place in the collection.
     */
    void insert(value_type&& val) {
        auto nd = root_.get();
        auto fields = topic::split(val.first);

        for (const auto& field : fields) {
            auto it = nd->children.find(field);
            if (it == nd->children.end()) {
                nd->children[field] = node::create();
                it = nd->children.find(field);
            }
            nd = it->second.get();
        }
        nd->content = std::make_unique<value_type>(std::move(val));
    }
    /**
     * Inserts a new value into the collection.
     * @param key The topic/filter entry
     * @param val The value to associate with that entry.
     */
    void insert(const value_type& val) {
        value_type v{val};
        this->insert(std::move(v));
    }
    /**
     * Removes an entry from the collection.
     *
     * This removes the value from the internal node, but leaves the node in
     * the collection, even if it is empty.
     * @param filter The topic filter to remove.
     * @return A unique pointer to the value, if any.
     */
    mapped_ptr remove(const key_type& filter) {
        auto nd = root_.get();
        auto fields = topic::split(filter);

        for (auto& field : fields) {
            auto it = nd->children.find(field);
            if (it == nd->children.end())
                return mapped_ptr{};

            nd = it->second.get();
        }
        value_ptr valpair;
        nd->content.swap(valpair);

        return (valpair) ? std::make_unique<mapped_type>(valpair->second) : mapped_ptr{};
    }
    /**
     * Removes the empty nodes in the collection.
     */
    void prune() { root_->prune(); }
    /**
     * Gets an iterator to the full collection of filters.
     * @return An iterator to the full collection of filters.
     */
    iterator begin() { return iterator{root_.get()}; }
    /**
     * Gets an iterator to the end of the collection of filters.
     * @return An iterator to the end of collection of filters.
     */
    iterator end() { return iterator{static_cast<value_type*>(nullptr)}; }
    /**
     * Gets an iterator to the end of the collection of filters.
     * @return An iterator to the end of collection of filters.
     */
    const_iterator end() const noexcept {
        return const_iterator{static_cast<value_type*>(nullptr)};
    }
    /**
     * Gets a const iterator to the full collection of filters.
     * @return A const iterator to the full collection of filters.
     */
    const_iterator cbegin() const { return const_iterator{root_.get()}; }
    /**
     * Gets a const iterator to the end of the collection of filters.
     * @return A const iterator to the end of collection of filters.
     */
    const_iterator cend() const noexcept { return end(); }
    /**
     * Gets a pointer to the value at the requested key.
     * @param filter The topic filter entry to find.
     * @return An iterator to the value if found, @em end() if not found.
     */
    iterator find(const key_type& filter) {
        auto nd = root_.get();
        auto fields = topic::split(filter);

        for (auto& field : fields) {
            auto it = nd->children.find(field);
            if (it == nd->children.end())
                return end();
            nd = it->second.get();
        }
        return iterator{nd->content.get()};
    }
    /**
     * Gets a const pointer to the value at the requested key.
     * @param filter The topic filter entry to find.
     * @return A const pointer to the value if found, @em nullptr if not
     *  	   found.
     */
    const_iterator find(const key_type& filter) const {
        return const_cast<topic_matcher*>(this)->find(filter);
    }
    /**
     * Gets an match_iterator that can find the matches to the topic.
     * @param topic The topic to search for matches.
     * @return An iterator that can find the matches to the topic.
     */
    match_iterator matches(const string& topic) { return match_iterator(root_.get(), topic); }
    /**
     * Gets a const iterator that can find the matches to the topic.
     * @param topic The topic to search for matches.
     * @return A const iterator that can find the matches to the topic.
     */
    const_match_iterator matches(const string& topic) const {
        return match_iterator(root_.get(), topic);
    }
    /**
     * Gets an iterator for the end of the collection.
     *
     * This simply returns an empty/null iterator which we can use to signal
     * the end of the collection.
     *
     * @return An empty/null iterator indicating the end of the collection.
     */
    const_match_iterator matches_end() const noexcept { return match_iterator{}; }
    /**
     * Gets an iterator for the end of the collection.
     *
     * This simply returns an empty/null iterator which we can use to signal
     * the end of the collection.
     *
     * @return An empty/null iterator indicating the end of the collection.
     */
    const_match_iterator matches_cend() const noexcept { return match_iterator{}; }
    /**
     * Determines if there are any matches for the specified topic.
     * @param topic The topic to search for matches.
     * @return Whether there are any matches for the topic in the
     *         collection.
     */
    bool has_match(const string& topic) { return matches(topic) != matches_cend(); }
};

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_topic_matcher_h

```

`include/mqtt/types.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file types.h
/// Basic types and type conversions for the Paho MQTT C++ library.
/// @date May 17, 2015 @author Frank Pagliughi
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2015-2017 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __mqtt_types_h
#define __mqtt_types_h

#include <chrono>
#include <memory>
#include <string>
#include <vector>

// Pull in reason codes here for backward compatability with old version
#include "mqtt/reason_code.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////
// Basic data types

/** A 'byte' is an 8-bit, unsigned int */
using byte = uint8_t;

/** An mqtt string is just a std::string */
using string = std::string;
/** A binary blob of data is, umm, just a string too! */
using binary = std::string;

/** Smart/shared pointer to a const string */
using string_ptr = std::shared_ptr<const string>;
/** Smart/shared pointer to a const binary blob */
using binary_ptr = std::shared_ptr<const binary>;

/////////////////////////////////////////////////////////////////////////////
// Time functions

/**
 * Convert a chrono duration to seconds.
 * This casts away precision to get integer seconds.
 * @param dur A chrono duration type
 * @return The duration as a chrono seconds value
 */
template <class Rep, class Period>
std::chrono::seconds to_seconds(const std::chrono::duration<Rep, Period>& dur) {
    return std::chrono::duration_cast<std::chrono::seconds>(dur);
}

/**
 * Convert a chrono duration to a number of seconds.
 * This casts away precision to get integer seconds.
 * @param dur A chrono duration type
 * @return The duration as a number of seconds
 */
template <class Rep, class Period>
long to_seconds_count(const std::chrono::duration<Rep, Period>& dur) {
    return (long)to_seconds(dur).count();
}

/**
 * Convert a chrono duration to milliseconds.
 * This casts away precision to get integer milliseconds.
 * @param dur A chrono duration type
 * @return The duration as a chrono milliseconds value
 */
template <class Rep, class Period>
std::chrono::milliseconds to_milliseconds(const std::chrono::duration<Rep, Period>& dur) {
    return std::chrono::duration_cast<std::chrono::milliseconds>(dur);
}

/**
 * Convert a chrono duration to a number of milliseconds.
 * This casts away precision to get integer milliseconds.
 * @param dur A chrono duration type
 * @return The duration as a number of milliseconds
 */
template <class Rep, class Period>
long to_milliseconds_count(const std::chrono::duration<Rep, Period>& dur) {
    return (long)to_milliseconds(dur).count();
}

/////////////////////////////////////////////////////////////////////////////
// Misc

/**
 * Converts an into to a bool.
 * @param n An integer.
 * @return @em true if n not equal to zero, @em false otherwise
 */
inline bool to_bool(int n) { return n != 0; }
/**
 * Converts the boolean into a C integer true/false value.
 * @param b A boolean
 * @return Zero if b is false, non-zero if b is true.
 */
inline int to_int(bool b) { return b ? (!0) : 0; }

/**
 * Gets a valid string for the char pointer, returning an empty string if
 * the pointer is NULL.
 * @param cstr A C-string pointer
 * @return A string copy of the C array. If `cstr` is NULL, this returns an
 *  	   empty string.
 */
inline string to_string(const char* cstr) { return cstr ? string(cstr) : string(); }

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_types_h

```

`include/mqtt/will_options.h`:

```h
/////////////////////////////////////////////////////////////////////////////
/// @file will_options.h
/// Declaration of MQTT will_options class
/// @date Jul 7, 2016
/// @author Guilherme M. Ferreira
/////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Copyright (c) 2016 Guilherme M. Ferreira <guilherme.maciel.ferreira@gmail.com>
 * Copyright (c) 2016-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme M. Ferreira - initial implementation and documentation
 *    Frank Pagliughi - added copy & move operations
 *******************************************************************************/

#ifndef __mqtt_will_options_h
#define __mqtt_will_options_h

#include "MQTTAsync.h"
#include "mqtt/message.h"
#include "mqtt/platform.h"
#include "mqtt/topic.h"
#include "mqtt/types.h"

namespace mqtt {

class connect_options;

/////////////////////////////////////////////////////////////////////////////

/**
 * Holds the set of options that govern the Last Will and Testament feature.
 *
 * @note
 * This wraps struct v1 of the C library's MQTTAsync_willOptions structure.
 * It sets the LWT binary payload, via the 'payload' struct field, and
   leaves the 'message' field as a nullptr.
 */
class will_options
{
public:
    /** The default QoS for the LWT, if unspecified */
    static constexpr int DFLT_QOS = 0;
    /** The default retained flag for LWT, if unspecified */
    static constexpr bool DFLT_RETAINED = false;

private:
    /** A default C struct to support re-initializing variables */
    static constexpr MQTTAsync_willOptions DFLT_C_STRUCT MQTTAsync_willOptions_initializer;

    /** The underlying C LWT options */
    MQTTAsync_willOptions opts_{DFLT_C_STRUCT};

    /** LWT message topic **/
    string_ref topic_;

    /** LWT message text */
    binary_ref payload_;

    /**
     * The properties for the LWT message.
     * Strangely, in the C lib, the will properties are not in the
     * willOptions struct, but are rather in the connectOptions.
     * So we keep the cached properties here, but need to transfer them to
     * the connect_options when we're added to that struct.
     */
    properties props_;

    /** The connect options has special access */
    friend class connect_options;

    /**
     * Gets a pointer to the C-language NUL-terminated strings for the
     * struct.
     * Some structs, such as this one, require valid pointers at all times,
     * while others expect NULL pointers for missing parameters.
     * So we always return a pointer to a valid C char array, even when
     * empty.
     * @param sr The C++ string object.
     * @return Pointer to a NUL terminated string. This is only valid until
     *  	   the next time the string is updated. This is never nullptr.
     */
    const char* c_str(const string_ref& sr) { return sr ? sr.to_string().c_str() : nullptr; }

public:
    /** Smart/shared pointer to an object of this class. */
    using ptr_t = std::shared_ptr<will_options>;
    /** Smart/shared pointer to a const object of this class. */
    using const_ptr_t = std::shared_ptr<const will_options>;
    /** Smart/shared pointer to an object of this class. */
    using unique_ptr_t = std::unique_ptr<will_options>;

    /**
     * Constructs a new object using the default values.
     */
    will_options();
    /**
     * Sets the "Last Will and Testament" (LWT) for the connection.
     * @param top The LWT message is published to the this topic.
     * @param payload The message that is published to the Will Topic.
     * @param payload_len The message size in bytes
     * @param qos The message Quality of Service.
     * @param retained Tell the broker to keep the LWT message after send to
     *  			   subscribers.
     * @param props MQTT v5 properties for the will message.
     */
    will_options(
        string_ref top, const void* payload, size_t payload_len, int qos = DFLT_QOS,
        bool retained = DFLT_RETAINED, const properties& props = properties()
    );
    /**
     * Sets the "Last Will and Testament" (LWT) for the connection.
     * @param top The LWT message is published to the this topic.
     * @param payload The message that is published to the Will Topic.
     * @param payload_len The message size in bytes.
     * @param qos The message Quality of Service.
     * @param retained Tell the broker to keep the LWT message after send to
     *  			   subscribers.
     * @param props MQTT v5 properties for the will message.
     */
    will_options(
        const topic& top, const void* payload, size_t payload_len, int qos = DFLT_QOS,
        bool retained = DFLT_RETAINED, const properties& props = properties()
    );
    /**
     * Sets the "Last Will and Testament" (LWT) for the connection.
     * @param top The LWT message is published to the this topic.
     * @param payload The message payload that is published to the Will
     *  			  Topic.
     * @param qos The message Quality of Service.
     * @param retained Tell the broker to keep the LWT message after send to
     *  			   subscribers.
     * @param props MQTT v5 properties for the will message.
     */
    will_options(
        string_ref top, binary_ref payload, int qos = DFLT_QOS, bool retained = DFLT_RETAINED,
        const properties& props = properties()
    );
    /**
     * Sets the "Last Will and Testament" (LWT) for the connection.
     * @param top The LWT message is published to the this topic.
     * @param payload The message payload that is published to the Will
     *  			  Topic, as a string.
     * @param qos The message Quality of Service.
     * @param retained Tell the broker to keep the LWT message after send to
     *  			   subscribers.
     * @param props MQTT v5 properties for the will message.
     */
    will_options(
        string_ref top, const string& payload, int qos = DFLT_QOS, bool retained = DFLT_QOS,
        const properties& props = properties()
    );
    /**
     * Sets the "Last Will and Testament" (LWT) for the connection.
     * @param msg The message that is published to the Will Topic.
     */
    will_options(const message& msg);
    /**
     * Copy constructor for the LWT options.
     * @param opt The other options.
     */
    will_options(const will_options& opt);
    /**
     * Move constructor for the LWT options.
     * @param opt The other options.
     */
    will_options(will_options&& opt);
    /**
     * Copy assignment for the LWT options.
     * @param opt The other options.
     */
    will_options& operator=(const will_options& opt);
    /**
     * Move assignment for the LWT options.
     * @param opt The other options.
     */
    will_options& operator=(will_options&& opt);
/**
 * Expose the underlying C struct for the unit tests.
 */
#if defined(UNIT_TESTS)
    const MQTTAsync_willOptions& c_struct() const { return opts_; }
#endif
    /**
     * Gets the LWT message topic name.
     * @return The LWT message topic name.
     */
    string get_topic() const { return topic_ ? topic_.to_string() : string(); }
    /**
     * Gets the LWT message payload.
     * @return The LWT message payload.
     */
    const binary_ref& get_payload() const { return payload_; }
    /**
     * Gets the LWT message payload as a string.
     * @return The LWT message payload as a string.
     */
    string get_payload_str() const { return payload_ ? payload_.to_string() : string(); }
    /**
     * Gets the QoS value for the LWT message.
     * @return The QoS value for the LWT message.
     */
    int get_qos() const { return opts_.qos; }
    /**
     * Gets the 'retained' flag for the LWT message.
     * @return The 'retained' flag for the LWT message.
     */
    bool is_retained() const { return opts_.retained != 0; }
    /**
     * Gets the LWT message as a message object.
     * @return A pointer to a copy of the LWT message.
     */
    const_message_ptr get_message() const {
        return message::create(topic_, payload_, opts_.qos, to_bool(opts_.retained));
    }
    /**
     * Sets the LWT message topic name.
     * @param top The topic where to sent the message
     */
    void set_topic(string_ref top);
    /**
     * Sets the LWT message text.
     * @param msg The LWT message
     */
    void set_payload(binary_ref msg);
    /**
     * Sets the LWT message text.
     * @param msg The LWT message
     */
    void set_payload(string msg) { set_payload(binary_ref(std::move(msg))); }
    /**
     * Sets the QoS value.
     * @param qos The LWT message QoS
     */
    void set_qos(const int qos) { opts_.qos = qos; }
    /**
     * Sets the retained flag.
     * @param retained Tell the broker to keep the LWT message after send to
     *  			   subscribers.
     */
    void set_retained(bool retained) { opts_.retained = to_int(retained); }
    /**
     * Gets the connect properties.
     * @return A const reference to the properties for the connect.
     */
    const properties& get_properties() const { return props_; }
    /**
     * Sets the properties for the connect.
     * @param props The properties to place into the message.
     */
    void set_properties(const properties& props) { props_ = props; }
    /**
     * Moves the properties for the connect.
     * @param props The properties to move into the connect object.
     */
    void set_properties(properties&& props) { props_ = std::move(props); }
};

/** Shared pointer to a will options object. */
using will_options_ptr = will_options::ptr_t;

/** Shared pointer to a const will options object. */
using const_will_options_ptr = will_options::const_ptr_t;

/** Unique pointer to a will options object. */
using will_options_unique_ptr = will_options::unique_ptr_t;

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  // __mqtt_will_options_h

```

`notice.html`:

```html
<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<title>Eclipse Foundation Software User Agreement</title>
</head>

<body lang="EN-US">
<h2>Eclipse Foundation Software User Agreement</h2>
<p>April 6, 2020</p>

<h3>Usage Of Content</h3>

<p>THE ECLIPSE FOUNDATION MAKES AVAILABLE SOFTWARE, DOCUMENTATION, INFORMATION AND/OR OTHER MATERIALS FOR OPEN SOURCE PROJECTS
   (COLLECTIVELY &quot;CONTENT&quot;).  USE OF THE CONTENT IS GOVERNED BY THE TERMS AND CONDITIONS OF THIS AGREEMENT AND/OR THE TERMS AND
   CONDITIONS OF LICENSE AGREEMENTS OR NOTICES INDICATED OR REFERENCED BELOW.  BY USING THE CONTENT, YOU AGREE THAT YOUR USE
   OF THE CONTENT IS GOVERNED BY THIS AGREEMENT AND/OR THE TERMS AND CONDITIONS OF ANY APPLICABLE LICENSE AGREEMENTS OR
   NOTICES INDICATED OR REFERENCED BELOW.  IF YOU DO NOT AGREE TO THE TERMS AND CONDITIONS OF THIS AGREEMENT AND THE TERMS AND
   CONDITIONS OF ANY APPLICABLE LICENSE AGREEMENTS OR NOTICES INDICATED OR REFERENCED BELOW, THEN YOU MAY NOT USE THE CONTENT.</p>

<h3>Applicable Licenses</h3>

<p>Unless otherwise indicated, all Content made available by the Eclipse Foundation is provided to you under the terms and conditions of the Eclipse Public License Version 2.0
   (&quot;EPL&quot;).  A copy of the EPL is provided with this Content and is also available at <a href="https://www.eclipse.org/legal/epl-2.0/">https://www.eclipse.org/legal/epl-2.0/</a>.
   For purposes of the EPL, &quot;Program&quot; will mean the Content.</p>

<p>Content includes, but is not limited to, source code, object code, documentation and other files maintained in the Eclipse Foundation source code
   repository (&quot;Repository&quot;) in software modules (&quot;Modules&quot;) and made available as downloadable archives (&quot;Downloads&quot;).</p>

<ul>
       <li>Content may be structured and packaged into modules to facilitate delivering, extending, and upgrading the Content.  Typical modules may include plug-ins (&quot;Plug-ins&quot;), plug-in fragments (&quot;Fragments&quot;), and features (&quot;Features&quot;).</li>
       <li>Each Plug-in or Fragment may be packaged as a sub-directory or JAR (Java&trade; ARchive) in a directory named &quot;plugins&quot;.</li>
       <li>A Feature is a bundle of one or more Plug-ins and/or Fragments and associated material.  Each Feature may be packaged as a sub-directory in a directory named &quot;features&quot;.  Within a Feature, files named &quot;feature.xml&quot; may contain a list of the names and version numbers of the Plug-ins
      and/or Fragments associated with that Feature.</li>
       <li>Features may also include other Features (&quot;Included Features&quot;). Within a Feature, files named &quot;feature.xml&quot; may contain a list of the names and version numbers of Included Features.</li>
</ul>

<p>The terms and conditions governing Plug-ins and Fragments should be contained in files named &quot;about.html&quot; (&quot;Abouts&quot;). The terms and conditions governing Features and
Included Features should be contained in files named &quot;license.html&quot; (&quot;Feature Licenses&quot;).  Abouts and Feature Licenses may be located in any directory of a Download or Module
including, but not limited to the following locations:</p>

<ul>
       <li>The top-level (root) directory</li>
       <li>Plug-in and Fragment directories</li>
       <li>Inside Plug-ins and Fragments packaged as JARs</li>
       <li>Sub-directories of the directory named &quot;src&quot; of certain Plug-ins</li>
       <li>Feature directories</li>
</ul>

<p>Note: if a Feature made available by the Eclipse Foundation is installed using the Provisioning Technology (as defined below), you must agree to a license (&quot;Feature Update License&quot;) during the
installation process.  If the Feature contains Included Features, the Feature Update License should either provide you with the terms and conditions governing the Included Features or
inform you where you can locate them.  Feature Update Licenses may be found in the &quot;license&quot; property of files named &quot;feature.properties&quot; found within a Feature.
Such Abouts, Feature Licenses, and Feature Update Licenses contain the terms and conditions (or references to such terms and conditions) that govern your use of the associated Content in
that directory.</p>

<p>THE ABOUTS, FEATURE LICENSES, AND FEATURE UPDATE LICENSES MAY REFER TO THE EPL OR OTHER LICENSE AGREEMENTS, NOTICES OR TERMS AND CONDITIONS.  SOME OF THESE
OTHER LICENSE AGREEMENTS MAY INCLUDE (BUT ARE NOT LIMITED TO):</p>

<ul>
       <li>Eclipse Distribution License Version 1.0 (available at <a href="http://www.eclipse.org/licenses/edl-v10.html">http://www.eclipse.org/licenses/edl-v1.0.html</a>)</li>
       <li>Common Public License Version 1.0 (available at <a href="http://www.eclipse.org/legal/cpl-v10.html">http://www.eclipse.org/legal/cpl-v10.html</a>)</li>
       <li>Apache Software License 1.1 (available at <a href="http://www.apache.org/licenses/LICENSE">http://www.apache.org/licenses/LICENSE</a>)</li>
       <li>Apache Software License 2.0 (available at <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>)</li>
       <li>Metro Link Public License 1.00 (available at <a href="http://www.opengroup.org/openmotif/supporters/metrolink/license.html">http://www.opengroup.org/openmotif/supporters/metrolink/license.html</a>)</li>
       <li>Mozilla Public License Version 1.1 (available at <a href="http://www.mozilla.org/MPL/MPL-1.1.html">http://www.mozilla.org/MPL/MPL-1.1.html</a>)</li>
</ul>

<p>IT IS YOUR OBLIGATION TO READ AND ACCEPT ALL SUCH TERMS AND CONDITIONS PRIOR TO USE OF THE CONTENT.  If no About, Feature License, or Feature Update License is provided, please
contact the Eclipse Foundation to determine what terms and conditions govern that particular Content.</p>


<h3>Use of Provisioning Technology</h3>

<p>The Eclipse Foundation makes available provisioning software, examples of which include, but are not limited to, p2 and the Eclipse
   Update Manager (&quot;Provisioning Technology&quot;) for the purpose of allowing users to install software, documentation, information and/or
   other materials (collectively &quot;Installable Software&quot;). This capability is provided with the intent of allowing such users to
   install, extend and update Eclipse-based products. Information about packaging Installable Software is available at <a
       href="http://eclipse.org/equinox/p2/repository_packaging.html">http://eclipse.org/equinox/p2/repository_packaging.html</a>
   (&quot;Specification&quot;).</p>

<p>You may use Provisioning Technology to allow other parties to install Installable Software. You shall be responsible for enabling the
   applicable license agreements relating to the Installable Software to be presented to, and accepted by, the users of the Provisioning Technology
   in accordance with the Specification. By using Provisioning Technology in such a manner and making it available in accordance with the
   Specification, you further acknowledge your agreement to, and the acquisition of all necessary rights to permit the following:</p>

<ol>
       <li>A series of actions may occur (&quot;Provisioning Process&quot;) in which a user may execute the Provisioning Technology
       on a machine (&quot;Target Machine&quot;) with the intent of installing, extending or updating the functionality of an Eclipse-based
       product.</li>
       <li>During the Provisioning Process, the Provisioning Technology may cause third party Installable Software or a portion thereof to be
       accessed and copied to the Target Machine.</li>
       <li>Pursuant to the Specification, you will provide to the user the terms and conditions that govern the use of the Installable
       Software (&quot;Installable Software Agreement&quot;) and such Installable Software Agreement shall be accessed from the Target
       Machine in accordance with the Specification. Such Installable Software Agreement must inform the user of the terms and conditions that govern
       the Installable Software and must solicit acceptance by the end user in the manner prescribed in such Installable Software Agreement. Upon such
       indication of agreement by the user, the provisioning Technology will complete installation of the Installable Software.</li>
</ol>

<h3>Cryptography</h3>

<p>Content may contain encryption software. The country in which you are currently may have restrictions on the import, possession, and use, and/or re-export to
   another country, of encryption software. BEFORE using any encryption software, please check the country's laws, regulations and policies concerning the import,
   possession, or use, and re-export of encryption software, to see if this is permitted.</p>

<p><small>Java and all Java-based trademarks are trademarks of Oracle Corporation in the United States, other countries, or both.</small></p>
</body>
</html>

```

`scripts/install_catch2.sh`:

```sh
#!/bin/bash
#
# install_catch2.sh
#
# Travis CI build/test helper script for the Eclipse Paho C++ library.
# This installs Catch2 into the VM.
#

set -ex

VERSION=2.9.1

# Install Catch2 from sources
wget https://github.com/catchorg/Catch2/archive/v${VERSION}.tar.gz
tar -xf v${VERSION}.tar.gz
cd Catch2-${VERSION}/
cmake -Bbuild -H. -DBUILD_TESTING=OFF

# CMake bin is installed in a strange place where
# sudo can not find by default.
sudo env "PATH=$PATH" cmake --build build/ --target install


```

`scripts/install_paho_mqtt_c.sh`:

```sh
#!/bin/bash
#
# Installs the matching version of Paho MQTT C library required by the C++ lib.
#

set -ex

git clone https://github.com/eclipse/paho.mqtt.c.git
cd paho.mqtt.c
git checkout v1.3.13

cmake -Bbuild -H. -DPAHO_WITH_SSL=ON -DPAHO_BUILD_STATIC=ON -DCMAKE_POSITION_INDEPENDENT_CODE=ON -DPAHO_ENABLE_TESTING=OFF
sudo env "PATH=$PATH" cmake --build build/ --target install
sudo ldconfig

exit 0



```

`src/CMakeLists.txt`:

```txt
# CMakeLists.txt
#
# CMake file for the Paho C++ core library.
#
# This is part of the Paho MQTT C++ client library.
#

#*******************************************************************************
# Copyright (c) 2016-2017, Guilherme Maciel Ferreira
# Copyright (c) 2017-2024, Frank Pagliughi
#
#  All rights reserved. This program and the accompanying materials
#  are made available under the terms of the Eclipse Public License v2.0
#  and Eclipse Distribution License v1.0 which accompany this distribution. 
# 
#  The Eclipse Public License is available at 
#     http://www.eclipse.org/legal/epl-v20.html
#  and the Eclipse Distribution License is available at 
#    http://www.eclipse.org/org/documents/edl-v10.php.
# 
#  Contributors:
#     Guilherme Maciel Ferreira - initial version
#     Frank Pagliughi - made the shared library optional
#*******************************************************************************/

## --- Library dependencies ---

set (THREADS_PREFER_PTHREAD_FLAG ON)
find_package(Threads REQUIRED)

include(GenerateExportHeader)

## --- Use object library to optimize compilation ---

set(COMMON_SRC
    async_client.cpp
    client.cpp
    connect_options.cpp
    create_options.cpp    
    disconnect_options.cpp
    iclient_persistence.cpp
    message.cpp
    properties.cpp
    reason_code.cpp
    response_options.cpp
    server_response.cpp
    ssl_options.cpp
    string_collection.cpp
    token.cpp
    topic.cpp
    will_options.cpp
)

## --- Build the shared library, if requested ---

if(PAHO_BUILD_SHARED)
    message(STATUS "Creating shared library")

    ## Create the shared library
    add_library(paho-mqttpp3-shared SHARED ${COMMON_SRC})
    list(APPEND PAHO_CPP_TARGETS paho-mqttpp3-shared)

    ## Alias for subdirectory builds
    add_library(PahoMqttCpp::paho-mqttpp3-shared ALIAS paho-mqttpp3-shared)
    add_library(PahoMqttCpp::paho-mqttpp3 ALIAS paho-mqttpp3-shared)

    target_compile_definitions(paho-mqttpp3-shared PRIVATE PAHO_MQTTPP_EXPORTS)

    ## Add dependencies to the shared library
    target_link_libraries(paho-mqttpp3-shared PUBLIC
        ${PAHO_MQTT_C_LIB}
        Threads::Threads
        ${LIBS_SYSTEM}
    )

    ## set the shared library soname
    set_target_properties(paho-mqttpp3-shared PROPERTIES
        OUTPUT_NAME paho-mqttpp3
        VERSION ${PROJECT_VERSION}
        SOVERSION ${PROJECT_VERSION_MAJOR}
    )

    generate_export_header(paho-mqttpp3-shared
        BASE_NAME paho_mqttpp
        EXPORT_FILE_NAME ${PAHO_MQTTPP_GENERATED_DIR}/include/mqtt/export.h
    )
endif()

## --- Build static version of the library, if requested ---

if(PAHO_BUILD_STATIC)
    ## Create the static library
    add_library(paho-mqttpp3-static STATIC ${COMMON_SRC})
    list(APPEND PAHO_CPP_TARGETS paho-mqttpp3-static)

    ## Alias for subdirectory builds
    add_library(PahoMqttCpp::paho-mqttpp3-static ALIAS paho-mqttpp3-static)

    ## Add dependencies to the static library
    target_link_libraries(paho-mqttpp3-static PUBLIC 
        ${PAHO_MQTT_C_LIB}-static
        Threads::Threads
        ${LIBS_SYSTEM}
    )

    if(${PAHO_BUILD_SHARED})
        # This lib should configure for static exports
        target_compile_definitions(paho-mqttpp3-static PRIVATE PAHO_MQTTPP_STATIC)
        target_compile_definitions(paho-mqttpp3-static PRIVATE PAHO_MQTTPP_STATIC_DEFINE)
    else()
        # If no shared lib, make this one the default target
        add_library(PahoMqttCpp::paho-mqttpp3 ALIAS paho-mqttpp3-static)

        generate_export_header(paho-mqttpp3-static
            BASE_NAME paho_mqttpp
            EXPORT_FILE_NAME ${PAHO_MQTTPP_GENERATED_DIR}/include/mqtt/export.h
        )
    endif()

    ## Let the archive use the same base name as the shared lib on *nix systems
    if(UNIX)
        set_target_properties(paho-mqttpp3-static PROPERTIES OUTPUT_NAME paho-mqttpp3)
    endif()
endif()

## --- Make sure at least one target was specified ---

if(NOT PAHO_CPP_TARGETS)
    message(FATAL_ERROR "No build targets are specified")
endif()

## --- Set common properties, etc ---

include(GNUInstallDirs)

foreach(TARGET ${PAHO_CPP_TARGETS})
    set_target_properties(${TARGET} PROPERTIES
        CXX_STANDARD 17
        CXX_STANDARD_REQUIRED ON
        CXX_EXTENSIONS OFF
    )

    ## Build warnings
    target_compile_options(${TARGET} PRIVATE
        $<$<CXX_COMPILER_ID:MSVC>:/W3>
        $<$<CXX_COMPILER_ID:Clang>:-Wall -Wextra -Wdocumentation>
        $<$<NOT:$<OR:$<CXX_COMPILER_ID:MSVC>,$<CXX_COMPILER_ID:Clang>>>:-Wall -Wextra>
    )

    target_include_directories(${TARGET} PUBLIC
        $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:include>
    )

    ## install the shared library
    install(TARGETS ${TARGET} EXPORT PahoMqttCpp
        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
    )
endforeach()

```

`src/async_client.cpp`:

```cpp
// async_client.cpp

/*******************************************************************************
 * Copyright (c) 2013-2022 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *    Frank Pagliughi - MQTT v5 support
 *******************************************************************************/

#include "mqtt/async_client.h"

#include <chrono>
#include <condition_variable>
#include <cstdio>
#include <cstring>
#include <mutex>
#include <thread>

#include "mqtt/disconnect_options.h"
#include "mqtt/message.h"
#include "mqtt/response_options.h"
#include "mqtt/token.h"

#define UNUSED(x) (void)(x)

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

void async_client::create()
{
    int rc = MQTTASYNC_SUCCESS;

    const auto& opts = createOpts_;
    mqttVersion_ = opts.mqtt_version();

    // The C client, when created for v5, can accommodate any version for
    // connections. This leaves the version solely to the connection.
    auto copts{opts.opts_};
    copts.MQTTVersion = MQTTVERSION_5;

    auto serverURI = opts.get_server_uri();
    auto clientId = opts.get_client_id();

    const auto userp{std::get_if<iclient_persistence*>(&opts.persistence_)};

    if (std::get_if<no_persistence>(&opts.persistence_) || (userp && !*userp)) {
        rc = MQTTAsync_createWithOptions(
            &cli_, serverURI.c_str(), clientId.c_str(), MQTTCLIENT_PERSISTENCE_NONE, nullptr,
            &copts
        );
    }
    else if (const auto dir{std::get_if<string>(&opts.persistence_)}; dir) {
        rc = MQTTAsync_createWithOptions(
            &cli_, serverURI.c_str(), clientId.c_str(), MQTTCLIENT_PERSISTENCE_DEFAULT,
            const_cast<char*>(dir->c_str()), &copts
        );
    }
    else {
        persist_.reset(new MQTTClient_persistence{
            *userp, &iclient_persistence::persistence_open,
            &iclient_persistence::persistence_close, &iclient_persistence::persistence_put,
            &iclient_persistence::persistence_get, &iclient_persistence::persistence_remove,
            &iclient_persistence::persistence_keys, &iclient_persistence::persistence_clear,
            &iclient_persistence::persistence_containskey
        });

        rc = MQTTAsync_createWithOptions(
            &cli_, serverURI.c_str(), clientId.c_str(), MQTTCLIENT_PERSISTENCE_USER,
            persist_.get(), &copts
        );
    }
    if (rc != MQTTASYNC_SUCCESS)
        throw exception(rc);
}

async_client::~async_client() { MQTTAsync_destroy(&cli_); }

// --------------------------------------------------------------------------
// Class static callbacks.
// These are the callbacks directly from the C-lib. In each case the
// 'context' should be the address of the async_client object that
// registered the callback.

// Callback for MQTTAsync_setConnected()
// This is installed with the normal callbacks and with a call to
// reconnect() to indicate that it succeeded. It signals the client's
// connect token then calls any registered callbacks.
void async_client::on_connected(void* context, char* cause)
{
    if (!context)
        return;

    async_client* cli = static_cast<async_client*>(context);

    auto tok = cli->connTok_;
    if (tok)
        tok->on_success(nullptr);

    callback* cb = cli->userCallback_;
    auto& connHandler = cli->connHandler_;
    auto& que = cli->que_;

    if (cb || connHandler || que) {
        string cause_str = cause ? string{cause} : string{};

        if (cb)
            cb->connected(cause_str);

        if (connHandler)
            connHandler(cause_str);

        if (que)
            que->put(connected_event{cause_str});
    }
}

// Callback for when the connection is lost.
// This is called from the MQTTAsync_connectionLost registered via
// MQTTAsync_setCallbacks().
// It calls the registered handlers then, if there's a consumer queue, it
// places a null pointer in the queue to alert the consumer to a closed
// connection.
void async_client::on_connection_lost(void* context, char* cause)
{
    if (!context)
        return;

    async_client* cli = static_cast<async_client*>(context);

    callback* cb = cli->userCallback_;
    auto& connLostHandler = cli->connLostHandler_;
    auto& que = cli->que_;

    if (cb || connLostHandler || que) {
        string cause_str = cause ? string(cause) : string();

        if (cb)
            cb->connection_lost(cause_str);

        if (connLostHandler)
            connLostHandler(cause_str);

        if (que)
            que->put(connection_lost_event{cause_str});
    }
}

// Callback from the C lib for when a disconnect packet is received from
// the server.
void async_client::on_disconnected(
    void* context, MQTTProperties* cprops, MQTTReasonCodes reasonCode
)
{
    if (!context)
        return;

    async_client* cli = static_cast<async_client*>(context);

    auto& disconnectedHandler = cli->disconnectedHandler_;
    auto& que = cli->que_;

    if (disconnectedHandler || que) {
        properties props(*cprops);

        if (disconnectedHandler)
            disconnectedHandler(props, ReasonCode(reasonCode));

        if (que)
            que->put(disconnected_event{std::move(props), ReasonCode(reasonCode)});
    }
}

// Callback for when a subscribed message arrives.
// This is called from the MQTTAsync_messageArrived registered via
// MQTTAsync_setCallbacks().
int async_client::on_message_arrived(
    void* context, char* topicName, int topicLen, MQTTAsync_message* msg
)
{
    if (!context)
        return to_int(true);

    async_client* cli = static_cast<async_client*>(context);
    callback* cb = cli->userCallback_;
    auto& que = cli->que_;
    auto& msgHandler = cli->msgHandler_;

    if (cb || que || msgHandler) {
        size_t len = (topicLen == 0) ? strlen(topicName) : size_t(topicLen);

        string topic{topicName, len};
        auto m = message::create(std::move(topic), *msg);

        if (msgHandler)
            msgHandler(m);

        if (cb)
            cb->message_arrived(m);

        if (que)
            que->put(m);
    }

    MQTTAsync_freeMessage(&msg);
    MQTTAsync_free(topicName);
    return to_int(true);
}

// Callback from the C lib for when a registered updateConnectOptions
// needs to be called.
int async_client::on_update_connection(void* context, MQTTAsync_connectData* cdata)
{
    if (context) {
        async_client* cli = static_cast<async_client*>(context);
        auto& updateConnection = cli->updateConnectionHandler_;

        if (updateConnection) {
            connect_data data(*cdata);
            if (updateConnection(data)) {
                // Copy username and password into newly allocated buffers.
                // The C lib will take ownership of the memory
                auto n = data.get_user_name().length();
                if (n > 0) {
                    char* username = static_cast<char*>(MQTTAsync_malloc(n + 1));
                    strncpy(username, data.get_user_name().c_str(), n + 1);
                    username[n] = '\0';
                    cdata->username = username;
                }
                else
                    cdata->username = nullptr;

                n = data.get_password().length();
                if (n > 0) {
                    char* passwd = static_cast<char*>(MQTTAsync_malloc(n));
                    memcpy(passwd, data.get_password().data(), n);
                    cdata->binarypwd.data = passwd;
                }
                else
                    cdata->binarypwd.data = nullptr;
                cdata->binarypwd.len = int(n);

                return to_int(true);
            }
        }
    }
    return 0;  // false
}

// --------------------------------------------------------------------------
// Private methods

void async_client::add_token(token_ptr tok)
{
    if (tok) {
        guard g(lock_);
        pendingTokens_.push_back(tok);
    }
}

void async_client::add_token(delivery_token_ptr tok)
{
    if (tok) {
        guard g(lock_);
        pendingDeliveryTokens_.push_back(tok);
    }
}

// Note that we uniquely identify a token by the address of its raw pointer,
// since the message ID is not unique.

void async_client::remove_token(token* tok)
{
    if (!tok)
        return;

    guard g(lock_);
    for (auto p = pendingDeliveryTokens_.begin(); p != pendingDeliveryTokens_.end(); ++p) {
        if (p->get() == tok) {
            delivery_token_ptr dtok = *p;
            pendingDeliveryTokens_.erase(p);

            // If there's a user callback registered, we can now call
            // delivery_complete()

            if (userCallback_) {
                const_message_ptr msg = dtok->get_message();
                if (msg && msg->get_qos() > 0) {
                    callback* cb = userCallback_;
                    g.unlock();
                    cb->delivery_complete(dtok);
                }
            }
            return;
        }
    }
    for (auto p = pendingTokens_.begin(); p != pendingTokens_.end(); ++p) {
        if (p->get() == tok) {
            pendingTokens_.erase(p);
            return;
        }
    }
}

// --------------------------------------------------------------------------
// Callback management

void async_client::set_callback(callback& cb)
{
    {
        guard g(lock_);
        userCallback_ = &cb;
    }
    int rc = MQTTAsync_setConnected(cli_, this, &async_client::on_connected);

    if (rc == MQTTASYNC_SUCCESS) {
        MQTTAsync_setCallbacks(
            cli_, this, &async_client::on_connection_lost, &async_client::on_message_arrived,
            nullptr /*&async_client::on_delivery_complete*/
        );
    }
    else {
        MQTTAsync_setConnected(cli_, nullptr, nullptr);

        guard g(lock_);
        userCallback_ = nullptr;
        throw exception(rc);
    }
}

void async_client::disable_callbacks()
{
    // TODO: It would be nice to disable callbacks at the C library level,
    // but the setCallback function currently does not accept a nullptr for
    // the "message arrived" parameter. So, for now we send it an empty
    // lambda function.
    int rc = MQTTAsync_setCallbacks(
        cli_, this, nullptr,
        [](void*, char*, int, MQTTAsync_message*) -> int { return to_int(true); }, nullptr
    );

    if (rc != MQTTASYNC_SUCCESS)
        throw exception(rc);
}

void async_client::set_connected_handler(connection_handler cb)
{
    connHandler_ = cb;
    check_ret(::MQTTAsync_setConnected(cli_, this, &async_client::on_connected));
}

void async_client::set_connection_lost_handler(connection_handler cb)
{
    connLostHandler_ = cb;
    check_ret(
        ::MQTTAsync_setConnectionLostCallback(cli_, this, &async_client::on_connection_lost)
    );
}

void async_client::set_disconnected_handler(disconnected_handler cb)
{
    disconnectedHandler_ = cb;
    check_ret(::MQTTAsync_setDisconnected(cli_, this, &async_client::on_disconnected));
}

void async_client::set_message_callback(message_handler cb)
{
    msgHandler_ = cb;
    check_ret(
        ::MQTTAsync_setMessageArrivedCallback(cli_, this, &async_client::on_message_arrived)
    );
}

void async_client::set_update_connection_handler(update_connection_handler cb)
{
    updateConnectionHandler_ = cb;
    check_ret(
        ::MQTTAsync_setUpdateConnectOptions(cli_, this, &async_client::on_update_connection)
    );
}

// --------------------------------------------------------------------------
// Connect

token_ptr async_client::connect() { return connect(connect_options{}); }

token_ptr async_client::connect(connect_options opts)
{
    // TODO: We should update the MQTT version from the response
    //  	(when the server confirms the requested version)
    mqttVersion_ = opts.opts_.MQTTVersion;

    // The C lib is very picky about version and clean start/session
    if (opts.opts_.MQTTVersion < 5)
        opts.opts_.cleanstart = 0;
    else
        opts.opts_.cleansession = 0;

    // TODO: If connTok_ is non-null, there could be a pending connect
    // which might complete after creating/assigning a new one. If that
    // happened, the callback would have the context address of the previous
    // token which was destroyed. So for now, keep the old one alive within
    // this function, and check the behavior of the C library...
    auto tmpTok = connTok_;
    connTok_ = token::create(token::Type::CONNECT, *this);
    add_token(connTok_);

    opts.set_token(connTok_);

    // TODO: Lock!
    connOpts_ = std::move(opts);
    int rc = MQTTAsync_connect(cli_, &connOpts_.opts_);

    if (rc != MQTTASYNC_SUCCESS) {
        remove_token(connTok_);
        connTok_.reset();
        throw exception(rc);
    }

    UNUSED(tmpTok);
    return connTok_;
}

token_ptr async_client::connect(connect_options opts, void* userContext, iaction_listener& cb)
{
    // Remember the requested protocol version
    mqttVersion_ = opts.opts_.MQTTVersion;

    // The C lib is very picky about version and clean start/session
    if (opts.opts_.MQTTVersion < 5)
        opts.opts_.cleanstart = 0;
    else
        opts.opts_.cleansession = 0;

    // Keep the old connTok_ alive (see above)
    auto tmpTok = connTok_;
    connTok_ = token::create(token::Type::CONNECT, *this, userContext, cb);
    add_token(connTok_);

    opts.set_token(connTok_);

    connOpts_ = std::move(opts);
    int rc = MQTTAsync_connect(cli_, &connOpts_.opts_);

    if (rc != MQTTASYNC_SUCCESS) {
        remove_token(connTok_);
        connTok_.reset();
        throw exception(rc);
    }

    UNUSED(tmpTok);
    return connTok_;
}

// --------------------------------------------------------------------------
// Re-connect

token_ptr async_client::reconnect()
{
    auto tok = connTok_;

    if (!tok)
        throw exception(MQTTASYNC_FAILURE, "Can't reconnect before a successful connect");

    tok->reset();
    add_token(tok);

    int rc = MQTTAsync_setConnected(cli_, this, &async_client::on_connected);

    if (rc == MQTTASYNC_SUCCESS)
        rc = MQTTAsync_reconnect(cli_);

    if (rc != MQTTASYNC_SUCCESS) {
        remove_token(tok);
        throw exception(rc);
    }

    return tok;
}

// --------------------------------------------------------------------------
// Disconnect

token_ptr async_client::disconnect(disconnect_options opts)
{
    auto tok = token::create(token::Type::DISCONNECT, *this);
    add_token(tok);

    opts.set_token(tok, mqttVersion_);

    int rc = MQTTAsync_disconnect(cli_, &opts.opts_);

    if (rc != MQTTASYNC_SUCCESS) {
        remove_token(tok);
        throw exception(rc);
    }

    return tok;
}

token_ptr async_client::disconnect(int timeout, void* userContext, iaction_listener& cb)
{
    auto tok = token::create(token::Type::DISCONNECT, *this, userContext, cb);
    add_token(tok);

    disconnect_options opts(timeout);
    opts.set_token(tok, mqttVersion_);

    int rc = MQTTAsync_disconnect(cli_, &opts.opts_);

    if (rc != MQTTASYNC_SUCCESS) {
        remove_token(tok);
        throw exception(rc);
    }

    return tok;
}

// --------------------------------------------------------------------------
// Queries

delivery_token_ptr async_client::get_pending_delivery_token(int msgID) const
{
    // Messages with QOS=1 or QOS=2 that require a response/acknowledge should
    // have a non-zero 16-bit message ID. The library keeps the token objects
    // for all of these messages that are in flight. When the acknowledge comes
    // back from the broker, the C++ library can look up the token from the
    // msgID and signal it, indicating completion.

    if (msgID > 0) {
        guard g(lock_);
        const auto it = std::find_if(
            pendingDeliveryTokens_.cbegin(), pendingDeliveryTokens_.cend(),
            [msgID](const auto& t) { return t->get_message_id() == msgID; }
        );
        if (it != pendingDeliveryTokens_.end())
            return *it;
    }
    return delivery_token_ptr();
}

std::vector<delivery_token_ptr> async_client::get_pending_delivery_tokens() const
{
    std::vector<delivery_token_ptr> toks;
    guard g(lock_);
    for (const auto& t : pendingDeliveryTokens_) {
        if (t->get_message_id() > 0) {
            toks.push_back(t);
        }
    }
    return toks;
}

// --------------------------------------------------------------------------
// Publish

delivery_token_ptr async_client::publish(
    string_ref topic, const void* payload, size_t n, int qos, bool retained,
    const properties& props /*=properties()*/
)
{
    auto msg = message::create(std::move(topic), payload, n, qos, retained, props);
    return publish(std::move(msg));
}

delivery_token_ptr async_client::publish(
    string_ref topic, binary_ref payload, int qos, bool retained,
    const properties& props /*=properties()*/
)
{
    auto msg = message::create(std::move(topic), std::move(payload), qos, retained, props);
    return publish(std::move(msg));
}

delivery_token_ptr async_client::publish(
    string_ref topic, const void* payload, size_t n, int qos, bool retained,
    void* userContext, iaction_listener& cb
)
{
    auto msg = message::create(std::move(topic), payload, n, qos, retained);
    return publish(std::move(msg), userContext, cb);
}

delivery_token_ptr async_client::publish(const_message_ptr msg)
{
    auto tok = delivery_token::create(*this, msg);
    add_token(tok);

    delivery_response_options rspOpts(tok, mqttVersion_);

    int rc =
        MQTTAsync_sendMessage(cli_, msg->get_topic().c_str(), &(msg->msg_), &rspOpts.opts_);

    if (rc == MQTTASYNC_SUCCESS) {
        tok->set_message_id(rspOpts.opts_.token);
    }
    else {
        remove_token(tok);
        throw exception(rc);
    }

    return tok;
}

delivery_token_ptr async_client::publish(
    const_message_ptr msg, void* userContext, iaction_listener& cb
)
{
    delivery_token_ptr tok = delivery_token::create(*this, msg, userContext, cb);
    add_token(tok);

    delivery_response_options rspOpts(tok, mqttVersion_);

    int rc =
        MQTTAsync_sendMessage(cli_, msg->get_topic().c_str(), &(msg->msg_), &rspOpts.opts_);

    if (rc == MQTTASYNC_SUCCESS) {
        tok->set_message_id(rspOpts.opts_.token);
    }
    else {
        remove_token(tok);
        throw exception(rc);
    }

    return tok;
}

// --------------------------------------------------------------------------
// Subscribe

token_ptr async_client::subscribe(
    const string& topicFilter, int qos,
    const subscribe_options& opts /*=subscribe_options()*/,
    const properties& props /*=properties()*/
)
{
    auto tok = token::create(token::Type::SUBSCRIBE, *this, topicFilter);
    tok->set_num_expected(0);  // Indicates non-array response for single val
    add_token(tok);

    auto rspOpts = response_options_builder(mqttVersion_)
                       .token(tok)
                       .subscribe_opts(opts)
                       .properties(props)
                       .finalize();

    int rc = MQTTAsync_subscribe(cli_, topicFilter.c_str(), qos, &rspOpts.opts_);

    if (rc != MQTTASYNC_SUCCESS) {
        remove_token(tok);
        throw exception(rc);
    }

    return tok;
}

token_ptr async_client::subscribe(
    const string& topicFilter, int qos, void* userContext, iaction_listener& cb,
    const subscribe_options& opts /*=subscribe_options()*/,
    const properties& props /*=properties()*/
)
{
    auto tok = token::create(token::Type::SUBSCRIBE, *this, topicFilter, userContext, cb);
    tok->set_num_expected(0);
    add_token(tok);

    auto rspOpts = response_options_builder(mqttVersion_)
                       .token(tok)
                       .subscribe_opts(opts)
                       .properties(props)
                       .finalize();

    int rc = MQTTAsync_subscribe(cli_, topicFilter.c_str(), qos, &rspOpts.opts_);

    if (rc != MQTTASYNC_SUCCESS) {
        remove_token(tok);
        throw exception(rc);
    }

    return tok;
}

token_ptr async_client::subscribe(
    const_string_collection_ptr topicFilters, const qos_collection& qos,
    const std::vector<subscribe_options>& opts
    /*=std::vector<subscribe_options>()*/,
    const properties& props /*=properties()*/
)
{
    size_t n = topicFilters->size();

    if (n != qos.size())
        throw std::invalid_argument("Collection sizes don't match");

    auto tok = token::create(token::Type::SUBSCRIBE, *this, topicFilters);
    tok->set_num_expected(n);
    add_token(tok);

    auto rspOpts = response_options_builder(mqttVersion_)
                       .token(tok)
                       .subscribe_opts(opts)
                       .properties(props)
                       .finalize();

    int rc = MQTTAsync_subscribeMany(
        cli_, int(n), topicFilters->c_arr(), const_cast<int*>(qos.data()), &rspOpts.opts_
    );

    if (rc != MQTTASYNC_SUCCESS) {
        remove_token(tok);
        throw exception(rc);
    }

    return tok;
}

token_ptr async_client::subscribe(
    const_string_collection_ptr topicFilters, const qos_collection& qos, void* userContext,
    iaction_listener& cb,
    const std::vector<subscribe_options>& opts
    /*=std::vector<subscribe_options>()*/,
    const properties& props /*=properties()*/
)
{
    size_t n = topicFilters->size();

    if (n != qos.size())
        throw std::invalid_argument("Collection sizes don't match");

    auto tok = token::create(token::Type::SUBSCRIBE, *this, topicFilters, userContext, cb);
    tok->set_num_expected(n);
    add_token(tok);

    auto rspOpts = response_options_builder(mqttVersion_)
                       .token(tok)
                       .subscribe_opts(opts)
                       .properties(props)
                       .finalize();

    int rc = MQTTAsync_subscribeMany(
        cli_, int(n), topicFilters->c_arr(), const_cast<int*>(qos.data()), &rspOpts.opts_
    );

    if (rc != MQTTASYNC_SUCCESS) {
        remove_token(tok);
        throw exception(rc);
    }

    return tok;
}

// --------------------------------------------------------------------------
// Unsubscribe

token_ptr async_client::
    unsubscribe(const string& topicFilter, const properties& props /*=properties()*/)
{
    auto tok = token::create(token::Type::UNSUBSCRIBE, *this, topicFilter);
    tok->set_num_expected(0);  // Indicates non-array response for single val
    add_token(tok);

    auto rspOpts =
        response_options_builder(mqttVersion_).token(tok).properties(props).finalize();

    int rc = MQTTAsync_unsubscribe(cli_, topicFilter.c_str(), &rspOpts.opts_);

    if (rc != MQTTASYNC_SUCCESS) {
        remove_token(tok);
        throw exception(rc);
    }

    return tok;
}

token_ptr async_client::unsubscribe(
    const_string_collection_ptr topicFilters, const properties& props /*=properties()*/
)
{
    size_t n = topicFilters->size();

    auto tok = token::create(token::Type::UNSUBSCRIBE, *this, topicFilters);
    tok->set_num_expected(n);
    add_token(tok);

    auto rspOpts =
        response_options_builder(mqttVersion_).token(tok).properties(props).finalize();

    int rc = MQTTAsync_unsubscribeMany(cli_, int(n), topicFilters->c_arr(), &rspOpts.opts_);

    if (rc != MQTTASYNC_SUCCESS) {
        remove_token(tok);
        throw exception(rc);
    }

    return tok;
}

token_ptr async_client::unsubscribe(
    const_string_collection_ptr topicFilters, void* userContext, iaction_listener& cb,
    const properties& props /*=properties()*/
)
{
    size_t n = topicFilters->size();

    auto tok = token::create(token::Type::UNSUBSCRIBE, *this, topicFilters, userContext, cb);
    tok->set_num_expected(n);
    add_token(tok);

    auto rspOpts =
        response_options_builder(mqttVersion_).token(tok).properties(props).finalize();

    int rc = MQTTAsync_unsubscribeMany(cli_, int(n), topicFilters->c_arr(), &rspOpts.opts_);

    if (rc != MQTTASYNC_SUCCESS) {
        remove_token(tok);
        throw exception(rc);
    }

    return tok;
}

token_ptr async_client::unsubscribe(
    const string& topicFilter, void* userContext, iaction_listener& cb,
    const properties& props /*=properties()*/
)
{
    auto tok = token::create(token::Type::UNSUBSCRIBE, *this, topicFilter, userContext, cb);
    add_token(tok);

    auto rspOpts =
        response_options_builder(mqttVersion_).token(tok).properties(props).finalize();

    int rc = MQTTAsync_unsubscribe(cli_, topicFilter.c_str(), &rspOpts.opts_);

    if (rc != MQTTASYNC_SUCCESS) {
        remove_token(tok);
        throw exception(rc);
    }

    return tok;
}

// --------------------------------------------------------------------------

void async_client::start_consuming()
{
    // Make sure callbacks don't happen while we update the que, etc
    disable_callbacks();

    // TODO: Should we replace user callback?
    // userCallback_ = nullptr;

    que_.reset(new thread_queue<event>);

    int rc = MQTTAsync_setCallbacks(
        cli_, this, &async_client::on_connection_lost, &async_client::on_message_arrived,
        nullptr
    );

    check_ret(rc);
    check_ret(::MQTTAsync_setConnected(cli_, this, &async_client::on_connected));
    check_ret(::MQTTAsync_setDisconnected(cli_, this, &async_client::on_disconnected));
}

void async_client::stop_consuming()
{
    try {
        disable_callbacks();
        if (que_)
            que_->close();
    }
    catch (...) {
        if (que_)
            que_->close();
        throw;
    }
}

event async_client::consume_event()
{
    event evt;
    try {
        evt = que_->get();
    }
    catch (queue_closed&) {
        evt = event{shutdown_event{}};
    }
    return evt;
}

bool async_client::try_consume_event(event* evt)
{
    bool res = false;
    try {
        res = que_->try_get(evt);
    }
    catch (queue_closed&) {
        *evt = event{shutdown_event{}};
        res = true;
    }
    return res;
}

const_message_ptr async_client::consume_message()
{
    if (!que_)
        throw mqtt::exception(-1, "Consumer not started");

    // For backward compatibility we ignore the 'connected' events,
    // whereas disconnected/lost return an empty pointer.
    while (true) {
        auto evt = consume_event();

        if (const auto* pval = evt.get_message_if())
            return *pval;

        if (evt.is_any_disconnect())
            return const_message_ptr{};
    }
}

bool async_client::try_consume_message(const_message_ptr* msg)
{
    if (!que_)
        throw mqtt::exception(-1, "Consumer not started");

    event evt;

    while (true) {
        if (!try_consume_event(&evt))
            return false;

        if (const auto* pval = evt.get_message_if()) {
            *msg = std::move(*pval);
            break;
        }

        if (evt.is_any_disconnect()) {
            *msg = const_message_ptr{};
            break;
        }
    }
    return true;
}

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

```

`src/client.cpp`:

```cpp
// client.cpp
// Implementation of the client class for the mqtt C++ client library.

/*******************************************************************************
 * Copyright (c) 2013-2025 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include "mqtt/client.h"

#include <iostream>
#include <memory>

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

PAHO_MQTTPP_EXPORT const std::chrono::seconds client::DFLT_TIMEOUT = std::chrono::seconds(30);

PAHO_MQTTPP_EXPORT const int client::DFLT_QOS = 1;

// --------------------------------------------------------------------------

client::client(
    const string& serverURI, const string& clientId /*=string{}*/,
    const persistence_type& persistence /*=NO_PERSISTENCE*/
)
    : cli_(serverURI, clientId, persistence), timeout_(DFLT_TIMEOUT), userCallback_(nullptr)
{
}

client::client(
    const string& serverURI, const string& clientId, int maxBufferedMessages,
    const persistence_type& persistence /*=NO_PERSISTENCE*/
)
    : cli_(serverURI, clientId, maxBufferedMessages, persistence),
      timeout_(DFLT_TIMEOUT),
      userCallback_(nullptr)
{
}

client::client(
    const string& serverURI, const string& clientId, const create_options& opts,
    const persistence_type& persistence /*=NO_PERSISTENCE*/
)
    : cli_(serverURI, clientId, opts, persistence),
      timeout_(DFLT_TIMEOUT),
      userCallback_(nullptr)
{
}

client::client(const create_options& opts)
    : cli_(opts), timeout_(DFLT_TIMEOUT), userCallback_(nullptr)
{
}

// --------------------------------------------------------------------------

void client::set_callback(callback& cb)
{
    userCallback_ = &cb;
    cli_.set_callback(*this);
}

connect_response client::connect()
{
    cli_.start_consuming();
    auto tok = cli_.connect();
    if (!tok->wait_for(timeout_))
        throw timeout_error();
    return tok->get_connect_response();
}

connect_response client::connect(connect_options opts)
{
    cli_.start_consuming();
    auto tok = cli_.connect(std::move(opts));
    if (!tok->wait_for(timeout_))
        throw timeout_error();
    return tok->get_connect_response();
}

connect_response client::reconnect()
{
    auto tok = cli_.reconnect();
    if (!tok->wait_for(timeout_))
        throw timeout_error();
    return tok->get_connect_response();
}

subscribe_response client::subscribe(
    const string& topicFilter, const subscribe_options& opts /*=subscribe_options()*/,
    const properties& props /*=properties()*/
)
{
    auto tok = cli_.subscribe(topicFilter, DFLT_QOS, opts, props);
    if (!tok->wait_for(timeout_))
        throw timeout_error();
    return tok->get_subscribe_response();
}

subscribe_response client::subscribe(
    const string& topicFilter, int qos,
    const subscribe_options& opts /*=subscribe_options()*/,
    const properties& props /*=properties()*/
)
{
    auto tok = cli_.subscribe(topicFilter, qos, opts, props);
    if (!tok->wait_for(timeout_))
        throw timeout_error();
    return tok->get_subscribe_response();
}

subscribe_response client::subscribe(
    const string_collection& topicFilters,
    const std::vector<subscribe_options>& opts /*=std::vector<subscribe_options>()*/,
    const properties& props /*=properties()*/
)
{
    qos_collection qos;
    for (size_t i = 0; i < topicFilters.size(); ++i) qos.push_back(DFLT_QOS);

    auto tok = cli_.subscribe(ptr(topicFilters), qos, opts, props);
    if (!tok->wait_for(timeout_))
        throw timeout_error();
    return tok->get_subscribe_response();
}

subscribe_response client::subscribe(
    const string_collection& topicFilters, const qos_collection& qos,
    const std::vector<subscribe_options>& opts /*=std::vector<subscribe_options>()*/,
    const properties& props /*=properties()*/
)
{
    auto tok = cli_.subscribe(ptr(topicFilters), qos, opts, props);
    if (!tok->wait_for(timeout_))
        throw timeout_error();
    return tok->get_subscribe_response();
}

unsubscribe_response
client::unsubscribe(const string& topicFilter, const properties& props /*=properties()*/)
{
    auto tok = cli_.unsubscribe(topicFilter, props);
    if (!tok->wait_for(timeout_))
        throw timeout_error();
    return tok->get_unsubscribe_response();
}

unsubscribe_response client::unsubscribe(
    const string_collection& topicFilters, const properties& props /*=properties()*/
)
{
    auto tok = cli_.unsubscribe(ptr(topicFilters), props);
    if (!tok->wait_for(timeout_))
        throw timeout_error();
    return tok->get_unsubscribe_response();
}

void client::disconnect()
{
    cli_.stop_consuming();
    if (!cli_.disconnect()->wait_for(timeout_))
        throw timeout_error();
}

void client::disconnect(int timeoutMS)
{
    cli_.stop_consuming();
    if (!cli_.disconnect(timeoutMS)->wait_for(timeout_))
        throw timeout_error();
}

/////////////////////////////////////////////////////////////////////////////
// end namespace mqtt
}  // namespace mqtt

```

`src/connect_options.cpp`:

```cpp
// connect_options.cpp

/*******************************************************************************
 * Copyright (c) 2017-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 * Copyright (c) 2016 Guilherme M. Ferreira <guilherme.maciel.ferreira@gmail.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme M. Ferreira - initial implementation and documentation
 *    Frank Pagliughi - Copy and move operations. Bug fixes.
 *******************************************************************************/

#include "mqtt/connect_options.h"

#include <cstring>

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

connect_options::connect_options(int ver /*=MQTTVERSION_DEFAULT*/)
{
    opts_ = (ver < MQTTVERSION_5) ? DFLT_C_STRUCT : DFLT_C_STRUCT5;
}

connect_options::connect_options(
    string_ref userName, binary_ref password, int ver /*=MQTTVERSION_DEFAULT*/
)
    : connect_options(ver)
{
    set_user_name(userName);
    set_password(password);
}

connect_options::connect_options(const connect_options& opt)
    : opts_(opt.opts_),
      userName_(opt.userName_),
      password_(opt.password_),
      tok_(opt.tok_),
      serverURIs_(opt.serverURIs_),
      props_(opt.props_),
      httpHeaders_(opt.httpHeaders_),
      httpProxy_(opt.httpProxy_),
      httpsProxy_(opt.httpsProxy_)
{
    if (opts_.will)
        set_will(opt.will_);

    if (opts_.ssl)
        set_ssl(opt.ssl_);

    update_c_struct();
}

connect_options::connect_options(connect_options&& opt)
    : opts_(opt.opts_),
      will_(std::move(opt.will_)),
      ssl_(std::move(opt.ssl_)),
      userName_(std::move(opt.userName_)),
      password_(std::move(opt.password_)),
      tok_(std::move(opt.tok_)),
      serverURIs_(std::move(opt.serverURIs_)),
      props_(std::move(opt.props_)),
      httpHeaders_(std::move(opt.httpHeaders_)),
      httpProxy_(std::move(opt.httpProxy_)),
      httpsProxy_(std::move(opt.httpsProxy_))
{
    if (opts_.will)
        opts_.will = &will_.opts_;

    if (opts_.willProperties)
        opts_.willProperties = const_cast<MQTTProperties*>(&will_.props_.c_struct());

    if (opts_.ssl)
        opts_.ssl = &ssl_.opts_;

    update_c_struct();
}

// Unfortunately, with the existing implementation, there's no way to know
// if the (connect) properties, will and ssl options were set by looking at the C++ structs.
// In a major update, we can consider using a pointer or optional<> to
// indicate that they were set.
// But, for now, the copy and assignment operations must handle it manually
// by looking to see if the source C options pointer was set.
void connect_options::update_c_struct()
{
    opts_.username = c_str(userName_);

    // Password

    if (password_.empty()) {
        opts_.binarypwd.len = 0;
        opts_.binarypwd.data = nullptr;
    }
    else {
        opts_.binarypwd.len = (int)password_.size();
        opts_.binarypwd.data = password_.data();
    }

    // Token

    opts_.onSuccess = nullptr;
    opts_.onFailure = nullptr;

    opts_.onSuccess5 = nullptr;
    opts_.onFailure5 = nullptr;

    if (tok_) {
        if (opts_.MQTTVersion < MQTTVERSION_5) {
            opts_.onSuccess = &token::on_success;
            opts_.onFailure = &token::on_failure;
        }
        else {
            opts_.onSuccess5 = &token::on_success5;
            opts_.onFailure5 = &token::on_failure5;
        }
    }

    // Server URIs

    if (!serverURIs_ || serverURIs_->empty()) {
        opts_.serverURIcount = 0;
        opts_.serverURIs = nullptr;
    }
    else {
        opts_.serverURIcount = (int)serverURIs_->size();
        opts_.serverURIs = serverURIs_->c_arr();
    }

    // Connect Properties

    if (opts_.MQTTVersion >= MQTTVERSION_5)
        opts_.connectProperties = const_cast<MQTTProperties*>(&props_.c_struct());

    // HTTP & Proxy

    opts_.httpProxy = c_str(httpProxy_);
    opts_.httpsProxy = c_str(httpsProxy_);
}

connect_options& connect_options::operator=(const connect_options& opt)
{
    if (&opt == this)
        return *this;

    opts_ = opt.opts_;

    if (opts_.will)
        set_will(opt.will_);

    if (opts_.ssl)
        set_ssl(opt.ssl_);

    userName_ = opt.userName_;
    password_ = opt.password_;

    tok_ = opt.tok_;
    serverURIs_ = opt.serverURIs_;
    props_ = opt.props_;

    httpHeaders_ = opt.httpHeaders_;
    httpProxy_ = opt.httpProxy_;
    httpsProxy_ = opt.httpsProxy_;

    update_c_struct();
    return *this;
}

connect_options& connect_options::operator=(connect_options&& opt)
{
    if (&opt == this)
        return *this;

    opts_ = opt.opts_;

    if (opts_.will)
        set_will(std::move(opt.will_));

    if (opts_.ssl)
        set_ssl(std::move(opt.ssl_));

    userName_ = std::move(opt.userName_);
    password_ = std::move(opt.password_);

    tok_ = std::move(opt.tok_);
    serverURIs_ = std::move(opt.serverURIs_);
    props_ = std::move(opt.props_);

    httpHeaders_ = std::move(opt.httpHeaders_);
    httpProxy_ = std::move(opt.httpProxy_);
    httpsProxy_ = std::move(opt.httpsProxy_);

    update_c_struct();
    return *this;
}

void connect_options::set_will(const will_options& will)
{
    will_ = will;
    opts_.will = &will_.opts_;
    opts_.willProperties = will_.get_properties().empty()
                               ? nullptr
                               : const_cast<MQTTProperties*>(&will_.props_.c_struct());
}

void connect_options::set_will(will_options&& will)
{
    will_ = will;
    opts_.will = &will_.opts_;
    opts_.willProperties = will_.get_properties().empty()
                               ? nullptr
                               : const_cast<MQTTProperties*>(&will_.props_.c_struct());
}

void connect_options::set_user_name(string_ref userName)
{
    userName_ = std::move(userName);
    opts_.username = c_str(userName_);
}

void connect_options::set_password(binary_ref password)
{
    password_ = std::move(password);

    if (password_.empty()) {
        opts_.binarypwd.len = 0;
        opts_.binarypwd.data = nullptr;
    }
    else {
        opts_.binarypwd.len = (int)password_.size();
        opts_.binarypwd.data = password_.data();
    }
}

void connect_options::set_ssl(const ssl_options& ssl)
{
    ssl_ = ssl;
    opts_.ssl = &ssl_.opts_;
}

void connect_options::set_ssl(ssl_options&& ssl)
{
    ssl_ = ssl;
    opts_.ssl = &ssl_.opts_;
}

// Clean sessions only apply to MQTT v3, so force it there if set.
void connect_options::set_clean_session(bool clean)
{
    if (opts_.MQTTVersion < MQTTVERSION_5)
        opts_.cleansession = to_int(clean);
}

// Clean start only apply to MQTT v5, so force it there if set.
void connect_options::set_clean_start(bool cleanStart)
{
    if (opts_.MQTTVersion >= MQTTVERSION_5)
        opts_.cleanstart = to_int(cleanStart);
}

void connect_options::set_token(const token_ptr& tok)
{
    tok_ = tok;
    opts_.context = tok_.get();

    opts_.onSuccess = nullptr;
    opts_.onFailure = nullptr;

    opts_.onSuccess5 = nullptr;
    opts_.onFailure5 = nullptr;

    if (tok) {
        if (opts_.MQTTVersion < MQTTVERSION_5) {
            opts_.onSuccess = &token::on_success;
            opts_.onFailure = &token::on_failure;
        }
        else {
            opts_.onSuccess5 = &token::on_success5;
            opts_.onFailure5 = &token::on_failure5;
        }
    }
}

void connect_options::set_servers(const_string_collection_ptr serverURIs)
{
    if (serverURIs) {
        serverURIs_ = std::move(serverURIs);
        opts_.serverURIcount = (int)serverURIs_->size();
        opts_.serverURIs = serverURIs_->c_arr();
    }
    else {
        serverURIs_.reset();
        opts_.serverURIcount = 0;
        opts_.serverURIs = nullptr;
    }
}

void connect_options::set_mqtt_version(int mqttVersion)
{
    opts_.MQTTVersion = mqttVersion;

    if (mqttVersion < MQTTVERSION_5)
        opts_.cleanstart = 0;
    else
        opts_.cleansession = 0;
}

void connect_options::set_automatic_reconnect(int minRetryInterval, int maxRetryInterval)
{
    opts_.automaticReconnect = to_int(true);
    opts_.minRetryInterval = minRetryInterval;
    opts_.maxRetryInterval = maxRetryInterval;
}

void connect_options::set_properties(const properties& props)
{
    props_ = props;
    opts_.connectProperties = const_cast<MQTTProperties*>(&props_.c_struct());
    opts_.MQTTVersion = MQTTVERSION_5;
}

void connect_options::set_properties(properties&& props)
{
    props_ = std::move(props);
    opts_.connectProperties = const_cast<MQTTProperties*>(&props_.c_struct());
    opts_.MQTTVersion = MQTTVERSION_5;
}

void connect_options::set_http_proxy(const string& httpProxy)
{
    httpProxy_ = httpProxy;
    opts_.httpProxy = c_str(httpProxy_);
}

void connect_options::set_https_proxy(const string& httpsProxy)
{
    httpsProxy_ = httpsProxy;
    opts_.httpsProxy = c_str(httpsProxy_);
}

/////////////////////////////////////////////////////////////////////////////
// connect_data

connect_data::connect_data(string_ref userName) : userName_(userName) { update_c_struct(); }

connect_data::connect_data(string_ref userName, binary_ref password)
    : userName_(userName), password_(password)
{
    update_c_struct();
}

connect_data::connect_data(const MQTTAsync_connectData& cdata)
    : password_((char*)cdata.binarypwd.data, size_t(cdata.binarypwd.len))
{
    if (cdata.username)
        userName_ = string_ref(cdata.username, strlen(cdata.username));
    update_c_struct();
}

void connect_data::update_c_struct()
{
    data_.username = userName_.empty() ? nullptr : userName_.c_str();

    if (password_.empty()) {
        data_.binarypwd.len = 0;
        data_.binarypwd.data = nullptr;
    }
    else {
        data_.binarypwd.len = (int)password_.size();
        data_.binarypwd.data = password_.data();
    }
}

connect_data& connect_data::operator=(const connect_data& rhs)
{
    if (&rhs != this) {
        userName_ = rhs.userName_;
        password_ = rhs.password_;
        update_c_struct();
    }
    return *this;
}

void connect_data::set_user_name(string_ref userName)
{
    userName_ = std::move(userName);
    update_c_struct();
}

void connect_data::set_password(binary_ref password)
{
    password_ = std::move(password);
    update_c_struct();
}

/////////////////////////////////////////////////////////////////////////////
}  // end namespace mqtt

```

`src/create_options.cpp`:

```cpp
/*******************************************************************************
 * Copyright (c) 2020-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include "mqtt/create_options.h"

#include <cstring>

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

create_options::create_options(int mqttVersion, int maxBufferedMessages)
{
    opts_.MQTTVersion = mqttVersion;

    if (maxBufferedMessages != 0) {
        opts_.sendWhileDisconnected = to_int(true);
        opts_.maxBufferedMessages = maxBufferedMessages;
    }
}

// --------------------------------------------------------------------------

create_options& create_options::operator=(const create_options& rhs)
{
    if (&rhs != this) {
        opts_ = rhs.opts_;
        serverURI_ = rhs.serverURI_;
        clientId_ = rhs.clientId_;
        persistence_ = rhs.persistence_;
    }
    return *this;
}

create_options& create_options::operator=(create_options&& rhs)
{
    if (&rhs != this) {
        opts_ = std::move(rhs.opts_);
        serverURI_ = std::move(rhs.serverURI_);
        clientId_ = std::move(rhs.clientId_);
        persistence_ = std::move(rhs.persistence_);
    }
    return *this;
}

/////////////////////////////////////////////////////////////////////////////
}  // end namespace mqtt

```

`src/disconnect_options.cpp`:

```cpp
// disconnect_options.cpp

#include "mqtt/disconnect_options.h"

#include <cstring>
#include <utility>

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////
// disconnect_options

disconnect_options::disconnect_options(const disconnect_options& opt)
    : opts_(opt.opts_), tok_(opt.tok_), props_(opt.props_)
{
    update_c_struct();
}

disconnect_options::disconnect_options(disconnect_options&& opt)
    : opts_(opt.opts_), tok_(std::move(opt.tok_)), props_(std::move(opt.props_))
{
    update_c_struct();
}

void disconnect_options::update_c_struct()
{
    opts_.properties = props_.c_struct();
    opts_.context = tok_.get();
}

disconnect_options& disconnect_options::operator=(const disconnect_options& opt)
{
    opts_ = opt.opts_;
    tok_ = opt.tok_;
    props_ = opt.props_;
    update_c_struct();
    return *this;
}

disconnect_options& disconnect_options::operator=(disconnect_options&& opt)
{
    opts_ = opt.opts_;
    tok_ = std::move(opt.tok_);
    props_ = std::move(opt.props_);
    update_c_struct();
    return *this;
}

void disconnect_options::set_token(const token_ptr& tok, int mqttVersion)
{
    tok_ = tok;
    opts_.context = tok_.get();

    opts_.onSuccess = nullptr;
    opts_.onFailure = nullptr;

    opts_.onSuccess5 = nullptr;
    opts_.onFailure5 = nullptr;

    if (tok) {
        if (mqttVersion >= MQTTVERSION_5) {
            opts_.onSuccess5 = &token::on_success5;
            opts_.onFailure5 = &token::on_failure5;
        }
        else {
            opts_.onSuccess = &token::on_success;
            opts_.onFailure = &token::on_failure;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

```

`src/iclient_persistence.cpp`:

```cpp
// iclient_persistence.cpp

/*******************************************************************************
 * Copyright (c) 2013-2016 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include "mqtt/iclient_persistence.h"

#include <cstdlib>
#include <cstring>
#include <vector>

#include "mqtt/types.h"

using namespace std;

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////
// Functions to transition C persistence calls to the C++ persistence object.

// Upon the call to persistence_open(), the 'context' has the address of the
// C++ persistence object, which is reassigned to the 'handle'. Subsequent
// calls have the object address as the handle.

int iclient_persistence::persistence_open(
    void** handle, const char* clientID, const char* serverURI, void* context
)
{
    try {
        if (handle && clientID && serverURI && context) {
            static_cast<iclient_persistence*>(context)->open(clientID, serverURI);
            *handle = context;
            return MQTTASYNC_SUCCESS;
        }
    }
    catch (...) {
    }

    return MQTTCLIENT_PERSISTENCE_ERROR;
}

int iclient_persistence::persistence_close(void* handle)
{
    try {
        if (handle) {
            static_cast<iclient_persistence*>(handle)->close();
            return MQTTASYNC_SUCCESS;
        }
    }
    catch (...) {
    }

    return MQTTCLIENT_PERSISTENCE_ERROR;
}

int iclient_persistence::persistence_put(
    void* handle, char* key, int bufcount, char* buffers[], int buflens[]
)
{
    try {
        if (handle && bufcount > 0 && buffers && buflens) {
            std::vector<string_view> vec;
            for (int i = 0; i < bufcount; ++i)
                vec.push_back(string_view(buffers[i], buflens[i]));
            static_cast<iclient_persistence*>(handle)->put(key, vec);
            return MQTTASYNC_SUCCESS;
        }
    }
    catch (...) {
    }

    return MQTTCLIENT_PERSISTENCE_ERROR;
}

int iclient_persistence::persistence_get(void* handle, char* key, char** buffer, int* buflen)
{
    try {
        if (handle && key && buffer && buflen) {
            auto s = static_cast<iclient_persistence*>(handle)->get(key);
            size_t n = s.length();
            *buffer = static_cast<char*>(MQTTAsync_malloc(n));
            memcpy(*buffer, s.data(), n);
            *buflen = int(n);
            return MQTTASYNC_SUCCESS;
        }
    }
    catch (...) {
    }

    return MQTTCLIENT_PERSISTENCE_ERROR;
}

int iclient_persistence::persistence_remove(void* handle, char* key)
{
    try {
        if (handle && key) {
            static_cast<iclient_persistence*>(handle)->remove(key);
            return MQTTASYNC_SUCCESS;
        }
    }
    catch (...) {
    }

    return MQTTCLIENT_PERSISTENCE_ERROR;
}

int iclient_persistence::persistence_keys(void* handle, char*** keys, int* nkeys)
{
    try {
        if (handle && keys && nkeys) {
            auto k = static_cast<iclient_persistence*>(handle)->keys();
            size_t n = k.size();
            *nkeys = int(n);
            if (n == 0) {
                *keys = nullptr;
            }
            else {
                *keys = static_cast<char**>(MQTTAsync_malloc(n * sizeof(char*)));
                for (size_t i = 0; i < n; ++i) {
                    auto sz = k[i].size();
                    char* buf = static_cast<char*>(MQTTAsync_malloc(sz + 1));
                    strncpy(buf, k[i].c_str(), sz + 1);
                    buf[sz] = '\0';
                    (*keys)[i] = buf;
                }
            }
            return MQTTASYNC_SUCCESS;
        }
    }
    catch (...) {
    }

    return MQTTCLIENT_PERSISTENCE_ERROR;
}

int iclient_persistence::persistence_clear(void* handle)
{
    try {
        if (handle) {
            static_cast<iclient_persistence*>(handle)->clear();
            return MQTTASYNC_SUCCESS;
        }
    }
    catch (...) {
    }

    return MQTTCLIENT_PERSISTENCE_ERROR;
}

int iclient_persistence::persistence_containskey(void* handle, char* key)
{
    try {
        if (handle && key && static_cast<iclient_persistence*>(handle)->contains_key(key))
            return MQTTASYNC_SUCCESS;
    }
    catch (...) {
    }

    return MQTTCLIENT_PERSISTENCE_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
// end namespace mqtt
}  // namespace mqtt

```

`src/message.cpp`:

```cpp
// message.cpp

/*******************************************************************************
 * Copyright (c) 2013-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include "mqtt/message.h"

#include <cstring>
#include <utility>

#include "mqtt/export.h"

namespace mqtt {

// A const string to use for references
PAHO_MQTTPP_EXPORT const string message::EMPTY_STR;

// A const binary to use for references
PAHO_MQTTPP_EXPORT const binary message::EMPTY_BIN;

/////////////////////////////////////////////////////////////////////////////

message::message(
    string_ref topic, const void* payload, size_t len, int qos, bool retained,
    const properties& props /*=properties()*/
)
    : topic_(std::move(topic))
{
    set_payload(payload, len);
    set_qos(qos);
    set_retained(retained);
    set_properties(props);
}

message::message(
    string_ref topic, binary_ref payload, int qos, bool retained,
    const properties& props /*=properties()*/
)
    : topic_(std::move(topic))
{
    set_payload(std::move(payload));
    set_qos(qos);
    set_retained(retained);
    set_properties(props);
}

message::message(string_ref topic, const MQTTAsync_message& cmsg)
    : msg_(cmsg), topic_(std::move(topic)), props_(cmsg.properties)
{
    set_payload(cmsg.payload, cmsg.payloadlen);
    msg_.properties = props_.c_struct();
}

message::message(const message& other)
    : msg_(other.msg_), topic_(other.topic_), props_(other.props_)
{
    set_payload(other.payload_);
    msg_.properties = props_.c_struct();
}

message::message(message&& other)
    : msg_(other.msg_), topic_(std::move(other.topic_)), props_(std::move(other.props_))
{
    set_payload(std::move(other.payload_));
    other.msg_.payloadlen = 0;
    other.msg_.payload = nullptr;
    msg_.properties = props_.c_struct();
}

message& message::operator=(const message& rhs)
{
    if (&rhs != this) {
        msg_ = rhs.msg_;
        topic_ = rhs.topic_;
        set_payload(rhs.payload_);
        set_properties(rhs.props_);
    }
    return *this;
}

message& message::operator=(message&& rhs)
{
    if (&rhs != this) {
        msg_ = rhs.msg_;
        topic_ = std::move(rhs.topic_);
        set_payload(std::move(rhs.payload_));
        set_properties(std::move(rhs.props_));

        rhs.msg_ = DFLT_C_STRUCT;
    }
    return *this;
}

void message::clear_payload()
{
    payload_.reset();
    msg_.payload = nullptr;
    msg_.payloadlen = 0;
}

void message::set_payload(binary_ref payload)
{
    payload_ = std::move(payload);

    if (payload_.empty()) {
        msg_.payload = nullptr;
        msg_.payloadlen = 0;
    }
    else {
        msg_.payload = const_cast<binary_ref::value_type*>(payload_.data());
        msg_.payloadlen = int(payload_.length());
    }
}

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

```

`src/properties.cpp`:

```cpp
// properties.cpp

/*******************************************************************************
 * Copyright (c) 2019-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include "mqtt/properties.h"

namespace mqtt {

PAHO_MQTTPP_EXPORT const std::map<property::code, std::string_view> property::TYPE_NAME{
    {PAYLOAD_FORMAT_INDICATOR, "PayloadFormatIndicator"},
    {MESSAGE_EXPIRY_INTERVAL, "MessageExpiryInterval"},
    {CONTENT_TYPE, "ContentType"},
    {RESPONSE_TOPIC, "ResponseTopic"},
    {CORRELATION_DATA, "CorrelationData"},
    {SUBSCRIPTION_IDENTIFIER, "SubscriptionIdentifier"},
    {SESSION_EXPIRY_INTERVAL, "SessionExpiryInterval"},
    {ASSIGNED_CLIENT_IDENTIFIER, "AssignedClientIdentifer"},
    {SERVER_KEEP_ALIVE, "ServerKeepAlive"},
    {AUTHENTICATION_METHOD, "AuthenticationMethod"},
    {AUTHENTICATION_DATA, "AuthenticationData"},
    {REQUEST_PROBLEM_INFORMATION, "RequestProblemInformation"},
    {WILL_DELAY_INTERVAL, "WillDelayInterval"},
    {REQUEST_RESPONSE_INFORMATION, "RequestResponseInformation"},
    {RESPONSE_INFORMATION, "ResponseInformation"},
    {SERVER_REFERENCE, "ServerReference"},
    {REASON_STRING, "ReasonString"},
    {RECEIVE_MAXIMUM, "ReceiveMaximum"},
    {TOPIC_ALIAS_MAXIMUM, "TopicAliasMaximum"},
    {TOPIC_ALIAS, "TopicAlias"},
    {MAXIMUM_QOS, "MaximumQos"},
    {RETAIN_AVAILABLE, "RetainAvailable"},
    {USER_PROPERTY, "UserProperty"},
    {MAXIMUM_PACKET_SIZE, "MaximumPacketSize"},
    {WILDCARD_SUBSCRIPTION_AVAILABLE, "WildcardSubscriptionAvailable"},
    {SUBSCRIPTION_IDENTIFIERS_AVAILABLE, "SubscriptionIdentifiersAvailable"},
    {SHARED_SUBSCRIPTION_AVAILABLE, "SharedSubscriptionAvailable"}
};

/////////////////////////////////////////////////////////////////////////////

property::property(code c, int32_t val)
{
    prop_.identifier = ::MQTTPropertyCodes(c);

    switch (::MQTTProperty_getType(prop_.identifier)) {
        case MQTTPROPERTY_TYPE_BYTE:
            prop_.value.integer4 = 0;
            prop_.value.byte = uint8_t(val);
            break;
        case MQTTPROPERTY_TYPE_TWO_BYTE_INTEGER:
            prop_.value.integer4 = 0;
            prop_.value.integer2 = uint16_t(val);
            break;
        case MQTTPROPERTY_TYPE_FOUR_BYTE_INTEGER:
        case MQTTPROPERTY_TYPE_VARIABLE_BYTE_INTEGER:
            prop_.value.integer4 = uint32_t(val);
            break;
        default:
            // TODO: Throw an exception
            break;
    }
}

property::property(code c, string_ref val)
{
    prop_.identifier = ::MQTTPropertyCodes(c);

    size_t n = val.size();
    prop_.value.data.len = int(n);
    prop_.value.data.data = (char*)malloc(n);
    std::memcpy(prop_.value.data.data, val.data(), n);
}

property::property(code c, string_ref name, string_ref val)
{
    prop_.identifier = MQTTPropertyCodes(c);

    size_t n = name.size();
    prop_.value.data.len = int(n);
    prop_.value.data.data = (char*)malloc(n);
    std::memcpy(prop_.value.data.data, name.data(), n);

    n = val.size();
    prop_.value.value.len = int(n);
    prop_.value.value.data = (char*)malloc(n);
    std::memcpy(prop_.value.value.data, val.data(), n);
}

property::property(property&& other)
{
    std::memcpy(&prop_, &other.prop_, sizeof(MQTTProperty));
    memset(&other.prop_, 0, sizeof(MQTTProperty));
}

property::~property()
{
    switch (::MQTTProperty_getType(prop_.identifier)) {
        case MQTTPROPERTY_TYPE_UTF_8_STRING_PAIR:
            free(prop_.value.value.data);
            // Fall-through

        case MQTTPROPERTY_TYPE_BINARY_DATA:
        case MQTTPROPERTY_TYPE_UTF_8_ENCODED_STRING:
            free(prop_.value.data.data);
            break;

        default:
            // Nothing necessary
            break;
    }
}

void property::copy(const MQTTProperty& cprop)
{
    size_t n;

    std::memcpy(&prop_, &cprop, sizeof(MQTTProperty));

    switch (::MQTTProperty_getType(prop_.identifier)) {
        case MQTTPROPERTY_TYPE_UTF_8_STRING_PAIR:
            n = prop_.value.value.len;
            prop_.value.value.data = (char*)malloc(n);
            memcpy(prop_.value.value.data, cprop.value.value.data, n);
            // Fall-through

        case MQTTPROPERTY_TYPE_BINARY_DATA:
        case MQTTPROPERTY_TYPE_UTF_8_ENCODED_STRING:
            n = prop_.value.data.len;
            prop_.value.data.data = (char*)malloc(n);
            memcpy(prop_.value.data.data, cprop.value.data.data, n);
            break;

        default:
            // Nothing necessary
            break;
    }
}

property& property::operator=(const property& rhs)
{
    if (&rhs != this)
        copy(rhs.prop_);

    return *this;
}

property& property::operator=(property&& rhs)
{
    if (&rhs != this) {
        std::memcpy(&prop_, &rhs.prop_, sizeof(MQTTProperty));
        memset(&rhs.prop_, 0, sizeof(MQTTProperty));
    }
    return *this;
}

std::string_view property::type_name() const
{
    if (auto p = TYPE_NAME.find(code(prop_.identifier)); p != TYPE_NAME.end()) {
        return p->second;
    }
    return std::string_view("Unknown");
}

const std::type_info& property::value_type_id()
{
    switch (::MQTTProperty_getType(prop_.identifier)) {
        case MQTTPROPERTY_TYPE_BYTE:
            return typeid(uint8_t);
        case MQTTPROPERTY_TYPE_TWO_BYTE_INTEGER:
            return typeid(uint16_t);
        case MQTTPROPERTY_TYPE_FOUR_BYTE_INTEGER:
        case MQTTPROPERTY_TYPE_VARIABLE_BYTE_INTEGER:
            return typeid(uint32_t);
        case MQTTPROPERTY_TYPE_BINARY_DATA:
            return typeid(binary);
        case MQTTPROPERTY_TYPE_UTF_8_ENCODED_STRING:
            return typeid(string);
        case MQTTPROPERTY_TYPE_UTF_8_STRING_PAIR:
            return typeid(string_pair);
    }
    return typeid(int);
}

std::ostream& operator<<(std::ostream& os, const property& prop)
{
    os << prop.type_name() << ": ";

    switch (::MQTTProperty_getType(MQTTPropertyCodes(prop.type()))) {
        case MQTTPROPERTY_TYPE_BYTE:
            os << unsigned(get<uint8_t>(prop));
            break;

        case MQTTPROPERTY_TYPE_TWO_BYTE_INTEGER:
            os << get<uint16_t>(prop);
            break;

        case MQTTPROPERTY_TYPE_FOUR_BYTE_INTEGER:
        case MQTTPROPERTY_TYPE_VARIABLE_BYTE_INTEGER:
            os << get<uint32_t>(prop);
            break;

        case MQTTPROPERTY_TYPE_BINARY_DATA: {
            auto bin = get<binary>(prop);
            auto n = bin.size();
            os << '[';
            if (n > 0) {
                os << std::hex;
                for (size_t i = 0; i < n - 1; ++i) os << "0x" << unsigned(bin[i]) << ", ";
                os << "0x" << unsigned(bin[n - 1]);
                os << std::dec;
            }
            os << ']';
        } break;

        case MQTTPROPERTY_TYPE_UTF_8_ENCODED_STRING:
            os << get<string>(prop);
            break;

        case MQTTPROPERTY_TYPE_UTF_8_STRING_PAIR:
            auto sp = get<string_pair>(prop);
            os << '(' << std::get<0>(sp) << ',' << std::get<1>(sp) << ')';
            break;
    }

    return os;
}

/////////////////////////////////////////////////////////////////////////////

properties::properties(std::initializer_list<property> props)
{
    for (const auto& prop : props) {
        ::MQTTProperties_add(&props_, &prop.c_struct());
    }
}

properties& properties::operator=(const properties& rhs)
{
    if (&rhs != this) {
        ::MQTTProperties_free(&props_);
        props_ = ::MQTTProperties_copy(&rhs.props_);
    }
    return *this;
}

properties& properties::operator=(properties&& rhs)
{
    if (&rhs != this) {
        ::MQTTProperties_free(&props_);
        props_ = rhs.props_;
        rhs.props_ = DFLT_C_STRUCT;
    }
    return *this;
}

property properties::get(property::code propid, size_t idx /*=0*/) const
{
    MQTTProperty* prop = MQTTProperties_getPropertyAt(
        const_cast<MQTTProperties*>(&props_), MQTTPropertyCodes(propid), int(idx)
    );
    if (!prop)
        throw bad_cast();

    return property(*prop);
}

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

```

`src/reason_code.cpp`:

```cpp
// reason_code.cpp

/*******************************************************************************
 * Copyright (c) 2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include "mqtt/properties.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

std::string to_string(ReasonCode reasonCode)
{
    return std::string{MQTTReasonCode_toString(MQTTReasonCodes(reasonCode))};
}

std::ostream& operator<<(std::ostream& os, ReasonCode reasonCode)
{
    os << MQTTReasonCode_toString(MQTTReasonCodes(reasonCode));
    return os;
}

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

```

`src/response_options.cpp`:

```cpp
// response_options.cpp

/*******************************************************************************
 * Copyright (c) 2019-2025 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include "mqtt/response_options.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

response_options::
    response_options(const token_ptr& tok, int mqttVersion /*=MQTTVERSION_DEFAULT*/)
    : response_options(mqttVersion)
{
    set_token(tok);
}

response_options::response_options(const response_options& other)
    : opts_{other.opts_}, tok_{other.tok_}, props_{other.props_}, subOpts_{other.subOpts_}
{
    update_c_struct();
}

response_options::response_options(response_options&& other)
    : opts_{other.opts_},
      tok_{std::move(other.tok_)},
      props_{std::move(other.props_)},
      subOpts_{std::move(other.subOpts_)}
{
    update_c_struct();
}

response_options& response_options::operator=(const response_options& rhs)
{
    if (&rhs != this) {
        opts_ = rhs.opts_;
        tok_ = rhs.tok_;
        props_ = rhs.props_;
        subOpts_ = rhs.subOpts_;

        update_c_struct();
    }
    return *this;
}

response_options& response_options::operator=(response_options&& rhs)
{
    if (&rhs != this) {
        opts_ = rhs.opts_;
        tok_ = std::move(rhs.tok_);
        props_ = std::move(rhs.props_);
        subOpts_ = std::move(rhs.subOpts_);

        update_c_struct();
    }
    return *this;
}

void response_options::update_c_struct()
{
    opts_.properties = props_.c_struct();

    if (opts_.subscribeOptionsCount != 0)
        opts_.subscribeOptionsList = const_cast<MQTTSubscribe_options*>(subOpts_.data());
}

void response_options::set_mqtt_version(int mqttVersion)
{
    if (mqttVersion < MQTTVERSION_5) {
        opts_.onSuccess = &token::on_success;
        opts_.onFailure = &token::on_failure;
        opts_.onSuccess5 = nullptr;
        opts_.onFailure5 = nullptr;
    }
    else {
        opts_.onSuccess5 = &token::on_success5;
        opts_.onFailure5 = &token::on_failure5;
        opts_.onSuccess = nullptr;
        opts_.onFailure = nullptr;
    }
}

void response_options::set_token(const token_ptr& tok)
{
    tok_ = tok;
    opts_.context = tok.get();
}

void response_options::set_subscribe_options(const subscribe_options& opts)
{
    opts_.subscribeOptions = opts.opts_;
}

std::vector<subscribe_options> response_options::get_subscribe_many_options() const
{
    std::vector<subscribe_options> opts;
    for (const auto& opt : subOpts_) opts.push_back(subscribe_options{opt});
    return opts;
}

void response_options::set_subscribe_many_options(const std::vector<subscribe_options>& opts)
{
    subOpts_.clear();
    for (const auto& opt : opts) subOpts_.push_back(opt.opts_);

    opts_.subscribeOptionsCount = int(opts.size());
    opts_.subscribeOptionsList = const_cast<MQTTSubscribe_options*>(subOpts_.data());
}

/////////////////////////////////////////////////////////////////////////////

delivery_response_options::delivery_response_options(int mqttVersion /*=MQTTVERSION_DEFAULT*/)
    : opts_(MQTTAsync_responseOptions_initializer)
{
    if (mqttVersion < MQTTVERSION_5) {
        opts_.onSuccess = &delivery_token::on_success;
        opts_.onFailure = &delivery_token::on_failure;
    }
    else {
        opts_.onSuccess5 = &delivery_token::on_success5;
        opts_.onFailure5 = &delivery_token::on_failure5;
    }
}

delivery_response_options::delivery_response_options(
    const delivery_token_ptr& tok, int mqttVersion /*=MQTTVERSION_DEFAULT*/
)
    : delivery_response_options(mqttVersion)
{
    set_token(tok);
}

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

```

`src/server_response.cpp`:

```cpp
/*******************************************************************************
 * Copyright (c) 2020-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include "mqtt/server_response.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

connect_response::connect_response(const MQTTAsync_successData5* rsp)
    : server_response(properties(rsp->properties)),
      serverURI_(string(rsp->alt.connect.serverURI)),
      mqttVersion_(rsp->alt.connect.MQTTVersion),
      sessionPresent_(to_bool(rsp->alt.connect.sessionPresent))
{
}

connect_response::connect_response(const MQTTAsync_successData* rsp)
    : serverURI_(string(rsp->alt.connect.serverURI)),
      mqttVersion_(rsp->alt.connect.MQTTVersion),
      sessionPresent_(to_bool(rsp->alt.connect.sessionPresent))
{
}

/////////////////////////////////////////////////////////////////////////////

// Implementation note: When there is just a single topic, the C library
// places the return/reason code in the main part of the struct, and not in
// the alt `reasonCodes` or `qosList` array, _even_ if the request was sent
// with the subscribeMany call in the C library.

subscribe_response::subscribe_response(MQTTAsync_successData5* rsp)
    : server_response(properties(rsp->properties))
{
    if (rsp->alt.sub.reasonCodeCount <= 1) {
        reasonCodes_.push_back(ReasonCode(rsp->reasonCode));
    }
    else if (rsp->alt.sub.reasonCodes) {
        for (int i = 0; i < rsp->alt.sub.reasonCodeCount; ++i) {
            reasonCodes_.push_back(ReasonCode(rsp->alt.sub.reasonCodes[i]));
        }
    }
}

subscribe_response::subscribe_response(size_t n, MQTTAsync_successData* rsp)
{
    if (n <= 1) {
        reasonCodes_.push_back(ReasonCode(rsp->alt.qos));
    }
    else if (rsp->alt.qosList) {
        for (size_t i = 0; i < n; ++i) {
            reasonCodes_.push_back(ReasonCode(rsp->alt.qosList[i]));
        }
    }
}

/////////////////////////////////////////////////////////////////////////////

// Implementation note: Like with the `subscribe_response`, when there is
// just a single topic, the C library places the return/reason code in the
// main part of the struct, and not in the unsub `reasonCodes` array.

unsubscribe_response::unsubscribe_response(MQTTAsync_successData5* rsp)
    : server_response(properties(rsp->properties))
{
    if (rsp->alt.unsub.reasonCodeCount <= 1) {
        reasonCodes_.push_back(ReasonCode(rsp->reasonCode));
    }
    else if (rsp->alt.unsub.reasonCodes) {
        for (int i = 0; i < rsp->alt.unsub.reasonCodeCount; ++i) {
            reasonCodes_.push_back(ReasonCode(rsp->alt.unsub.reasonCodes[i]));
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
}  // end namespace mqtt

```

`src/ssl_options.cpp`:

```cpp
/*******************************************************************************
 * Copyright (c) 2016 Guilherme Ferreira <guilherme.maciel.ferreira@gmail.com>
 * Copyright (c) 2016-2025 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme Ferreira - initial implementation and documentation
 *    Frank Pagliughi - added copy & move operations
 *******************************************************************************/

#include "mqtt/ssl_options.h"

#include <cstring>
#include <utility>

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

ssl_options::ssl_options(
    const string& trustStore, const string& keyStore, const string& privateKey,
    const string& privateKeyPassword, const string& enabledCipherSuites,
    bool enableServerCertAuth, const std::vector<string> alpnProtos /*=std::vector<string>()*/
)
    : trustStore_(trustStore),
      keyStore_(keyStore),
      privateKey_(privateKey),
      privateKeyPassword_(privateKeyPassword),
      enabledCipherSuites_(enabledCipherSuites)
{
    set_alpn_protos(alpnProtos);
    update_c_struct();
    opts_.enableServerCertAuth = enableServerCertAuth;
}

ssl_options::ssl_options(
    const string& trustStore, const string& keyStore, const string& privateKey,
    const string& privateKeyPassword, const string& caPath, const string& enabledCipherSuites,
    bool enableServerCertAuth, const std::vector<string> alpnProtos /*=std::vector<string>()*/
)
    : trustStore_(trustStore),
      keyStore_(keyStore),
      privateKey_(privateKey),
      privateKeyPassword_(privateKeyPassword),
      caPath_(caPath),
      enabledCipherSuites_(enabledCipherSuites)
{
    set_alpn_protos(alpnProtos);
    update_c_struct();
    opts_.enableServerCertAuth = enableServerCertAuth;
}

ssl_options::ssl_options(const ssl_options& other)
    : opts_(other.opts_),
      trustStore_(other.trustStore_),
      keyStore_(other.keyStore_),
      privateKey_(other.privateKey_),
      privateKeyPassword_(other.privateKeyPassword_),
      caPath_(other.caPath_),
      enabledCipherSuites_(other.enabledCipherSuites_),
      errHandler_(other.errHandler_),
      pskHandler_(other.pskHandler_),
      protos_(other.protos_)
{
    update_c_struct();
}

ssl_options::ssl_options(ssl_options&& other)
    : opts_(other.opts_),
      trustStore_(std::move(other.trustStore_)),
      keyStore_(std::move(other.keyStore_)),
      privateKey_(std::move(other.privateKey_)),
      privateKeyPassword_(std::move(other.privateKeyPassword_)),
      caPath_(std::move(other.caPath_)),
      enabledCipherSuites_(std::move(other.enabledCipherSuites_)),
      errHandler_(std::move(other.errHandler_)),
      pskHandler_(std::move(other.pskHandler_)),
      protos_(std::move(other.protos_))
{
    update_c_struct();
}

void ssl_options::update_c_struct()
{
    opts_.trustStore = c_str(trustStore_);
    opts_.keyStore = c_str(keyStore_);
    opts_.privateKey = c_str(privateKey_);
    opts_.privateKeyPassword = c_str(privateKeyPassword_);
    opts_.CApath = c_str(caPath_);
    opts_.enabledCipherSuites = c_str(enabledCipherSuites_);

    if (errHandler_) {
        opts_.ssl_error_cb = &ssl_options::on_error;
        opts_.ssl_error_context = this;
    }
    else {
        opts_.ssl_error_cb = nullptr;
        opts_.ssl_error_context = nullptr;
    }

    if (pskHandler_) {
        opts_.ssl_psk_cb = &ssl_options::on_psk;
        opts_.ssl_psk_context = this;
    }
    else {
        opts_.ssl_psk_cb = nullptr;
        opts_.ssl_psk_context = nullptr;
    }

    if (!protos_.empty()) {
        opts_.protos = protos_.data();
        opts_.protos_len = unsigned(protos_.size());
    }
    else {
        opts_.protos = nullptr;
        opts_.protos_len = 0;
    }
}

// --------------------------------------------------------------------------

int ssl_options::on_error(const char* str, size_t len, void* context)
{
    try {
        if (context && str && len > 0) {
            string errMsg{str, len};

            ssl_options* opts = static_cast<ssl_options*>(context);
            auto& errHandler = opts->errHandler_;

            if (errHandler)
                errHandler(errMsg);

            return MQTTASYNC_SUCCESS;
        }
    }
    catch (...) {
    }

    return MQTTASYNC_FAILURE;
}

unsigned ssl_options::on_psk(
    const char* hint, char* identity, unsigned max_identity_len, unsigned char* psk,
    unsigned max_psk_len, void* context
)
{
    unsigned ret = 0;

    try {
        if (context) {
            auto hintStr = (hint) ? string(hint) : string();

            ssl_options* opts = static_cast<ssl_options*>(context);
            auto& pskHandler = opts->pskHandler_;

            if (pskHandler) {
                ret = pskHandler(
                    hintStr, identity, size_t(max_identity_len), psk, size_t(max_psk_len)
                );
            }
        }
    }
    catch (...) {
    }

    return ret;
}

// --------------------------------------------------------------------------

ssl_options& ssl_options::operator=(const ssl_options& rhs)
{
    if (&rhs == this)
        return *this;

    opts_ = rhs.opts_;

    trustStore_ = rhs.trustStore_;
    keyStore_ = rhs.keyStore_;
    privateKey_ = rhs.privateKey_;
    privateKeyPassword_ = rhs.privateKeyPassword_;
    caPath_ = rhs.caPath_;
    enabledCipherSuites_ = rhs.enabledCipherSuites_;

    errHandler_ = rhs.errHandler_;
    pskHandler_ = rhs.pskHandler_;

    protos_ = rhs.protos_;

    update_c_struct();
    return *this;
}

ssl_options& ssl_options::operator=(ssl_options&& rhs)
{
    if (&rhs == this)
        return *this;

    opts_ = rhs.opts_;

    trustStore_ = std::move(rhs.trustStore_);
    keyStore_ = std::move(rhs.keyStore_);
    privateKey_ = std::move(rhs.privateKey_);
    privateKeyPassword_ = std::move(rhs.privateKeyPassword_);
    caPath_ = std::move(rhs.caPath_);
    enabledCipherSuites_ = std::move(rhs.enabledCipherSuites_);

    errHandler_ = std::move(rhs.errHandler_);
    pskHandler_ = std::move(rhs.pskHandler_);

    protos_ = std::move(rhs.protos_);

    update_c_struct();
    return *this;
}

// --------------------------------------------------------------------------

void ssl_options::set_trust_store(const string& trustStore)
{
    trustStore_ = trustStore;
    opts_.trustStore = c_str(trustStore_);
}

void ssl_options::set_key_store(const string& keyStore)
{
    keyStore_ = keyStore;
    opts_.keyStore = c_str(keyStore_);
}

void ssl_options::set_private_key(const string& privateKey)
{
    privateKey_ = privateKey;
    opts_.privateKey = c_str(privateKey_);
}

void ssl_options::set_private_key_password(const string& privateKeyPassword)
{
    privateKeyPassword_ = privateKeyPassword;
    opts_.privateKeyPassword = c_str(privateKeyPassword_);
}

void ssl_options::set_enabled_cipher_suites(const string& enabledCipherSuites)
{
    enabledCipherSuites_ = enabledCipherSuites;
    opts_.enabledCipherSuites = c_str(enabledCipherSuites_);
}

void ssl_options::set_enable_server_cert_auth(bool enableServerCertAuth)
{
    opts_.enableServerCertAuth = to_int(enableServerCertAuth);
}

void ssl_options::set_ca_path(const string& path)
{
    caPath_ = path;
    opts_.CApath = c_str(caPath_);
}

void ssl_options::set_error_handler(error_handler cb)
{
    errHandler_ = cb;

    if (errHandler_) {
        opts_.ssl_error_cb = &ssl_options::on_error;
        opts_.ssl_error_context = this;
    }
    else {
        opts_.ssl_error_cb = nullptr;
        opts_.ssl_error_context = nullptr;
    }
}

void ssl_options::set_psk_handler(psk_handler cb)
{
    pskHandler_ = cb;

    if (pskHandler_) {
        opts_.ssl_psk_cb = &ssl_options::on_psk;
        opts_.ssl_psk_context = this;
    }
    else {
        opts_.ssl_psk_cb = nullptr;
        opts_.ssl_psk_context = nullptr;
    }
}

// Gets the list of ALPN protocols.
// To do so, it must recover the strings from the wire format.
std::vector<string> ssl_options::get_alpn_protos() const
{
    std::vector<string> protos;
    size_t i = 0, n = protos_.size();

    while (i < n) {
        size_t sn = protos_[i++];
        if (i + sn > n)
            break;

        string s;
        s.reserve(sn);

        sn += i;
        while (i < sn) s.push_back(char(protos_[i++]));
        protos.push_back(std::move(s));
    }
    return protos;
}

// Converts the vector of names into the binary string in wire format.
// This is a single string uf unsigned characters with each protocol
// prepended by a byte of its length.
void ssl_options::set_alpn_protos(const std::vector<string>& protos)
{
    using uchar = unsigned char;

    if (!protos.empty()) {
        std::vector<uchar> protoBin;
        for (const auto& proto : protos) {
            protoBin.push_back(uchar(proto.length()));
            for (const char c : proto) protoBin.push_back(uchar(c));
        }
        protos_ = std::move(protoBin);

        opts_.protos = protos_.data();
        opts_.protos_len = static_cast<unsigned>(protos_.size());
    }
    else {
        protos_.clear();
        opts_.protos = nullptr;
        opts_.protos_len = 0;
    }
}

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

```

`src/string_collection.cpp`:

```cpp
// string_collection.cpp

/*******************************************************************************
 * Copyright (c) 2017-2020 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include "mqtt/string_collection.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

string_collection::string_collection(const string& str) : coll_{str} { update_c_arr(); }

string_collection::string_collection(string&& str) : coll_{std::move(str)} { update_c_arr(); }

string_collection::string_collection(const collection_type& vec) : coll_{vec}
{
    update_c_arr();
}

string_collection::string_collection(collection_type&& vec) : coll_{std::move(vec)}
{
    update_c_arr();
}

string_collection::string_collection(const string_collection& coll) : coll_{coll.coll_}
{
    update_c_arr();
}

string_collection::string_collection(std::initializer_list<string> sl)
{
    for (const auto& s : sl) coll_.push_back(s);
    update_c_arr();
}

string_collection::string_collection(std::initializer_list<const char*> sl)
{
    for (const auto& s : sl) coll_.push_back(string(s));
    update_c_arr();
}

void string_collection::update_c_arr()
{
    cArr_.clear();
    cArr_.reserve(coll_.size());
    for (const auto& s : coll_) cArr_.push_back(s.c_str());
}

string_collection& string_collection::operator=(const string_collection& coll)
{
    coll_ = coll.coll_;
    update_c_arr();
    return *this;
}

void string_collection::push_back(const string& str)
{
    coll_.push_back(str);
    update_c_arr();
}

void string_collection::push_back(string&& str)
{
    coll_.push_back(str);
    update_c_arr();
}

void string_collection::clear()
{
    coll_.clear();
    cArr_.clear();
}

/////////////////////////////////////////////////////////////////////////////

void name_value_collection::update_c_arr()
{
    cArr_.clear();
    cArr_.reserve(map_.size() + 1);
    for (const auto& m : map_) {
        cArr_.push_back(MQTTAsync_nameValue{m.first.c_str(), m.second.c_str()});
    }
    cArr_.push_back(MQTTAsync_nameValue{nullptr, nullptr});
}

/////////////////////////////////////////////////////////////////////////////
// end namespace mqtt
}  // namespace mqtt

```

`src/token.cpp`:

```cpp
// token.cpp

/*******************************************************************************
 * Copyright (c) 2013-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *    Frank Pagliughi - MQTT v5 support
 *******************************************************************************/

#include "mqtt/token.h"

#include <cstring>
#include <iostream>

#include "mqtt/async_client.h"

namespace mqtt {

// --------------------------------------------------------------------------
// Constructors

token::token(Type typ, iasync_client& cli, const_string_collection_ptr topics)
    : type_(typ),
      cli_(&cli),
      rc_(0),
      reasonCode_(ReasonCode::SUCCESS),
      msgId_(MQTTAsync_token(0)),
      topics_(topics),
      userContext_(nullptr),
      listener_(nullptr),
      nExpected_(0),
      complete_(false)
{
}

token::token(
    Type typ, iasync_client& cli, const_string_collection_ptr topics, void* userContext,
    iaction_listener& cb
)
    : type_(typ),
      cli_(&cli),
      rc_(0),
      reasonCode_(ReasonCode::SUCCESS),
      msgId_(MQTTAsync_token(0)),
      topics_(topics),
      userContext_(userContext),
      listener_(&cb),
      nExpected_(0),
      complete_(false)
{
}

token::token(Type typ, iasync_client& cli, MQTTAsync_token tok)
    : type_(typ),
      cli_(&cli),
      rc_(0),
      reasonCode_(ReasonCode::SUCCESS),
      msgId_(tok),
      userContext_(nullptr),
      listener_(nullptr),
      nExpected_(0),
      complete_(false)
{
}

// --------------------------------------------------------------------------
// Class static callbacks.
// These are the callbacks directly from the C library.
// The 'context' is a raw pointer to the token object.

void token::on_success(void* context, MQTTAsync_successData* rsp)
{
    if (context)
        static_cast<token*>(context)->on_success(rsp);
}

void token::on_success5(void* context, MQTTAsync_successData5* rsp)
{
    if (context)
        static_cast<token*>(context)->on_success5(rsp);
}

void token::on_failure(void* context, MQTTAsync_failureData* rsp)
{
    if (context)
        static_cast<token*>(context)->on_failure(rsp);
}

void token::on_failure5(void* context, MQTTAsync_failureData5* rsp)
{
    if (context)
        static_cast<token*>(context)->on_failure5(rsp);
}

// --------------------------------------------------------------------------
// Object callbacks

//
// The success callback for MQTT v3 connections
//
void token::on_success(MQTTAsync_successData* rsp)
{
    unique_lock g(lock_);
    iaction_listener* listener = listener_;

    if (rsp) {
        msgId_ = rsp->token;

        switch (type_) {
            case Type::CONNECT:
                connRsp_.reset(new connect_response(rsp));
                break;

            case Type::SUBSCRIBE:
                subRsp_.reset(new subscribe_response(nExpected_, rsp));
                break;

            case Type::UNSUBSCRIBE:
                unsubRsp_.reset(new unsubscribe_response(rsp));
                break;

            default:
                // The others don't have responses
                break;
        }
    }

    rc_ = MQTTASYNC_SUCCESS;
    complete_ = true;
    g.unlock();

    // Note: callback always completes before the object is signaled.
    if (listener)
        listener->on_success(*this);
    cond_.notify_all();

    cli_->remove_token(this);
}

//
// The success callback for MQTT v5 connections
//
void token::on_success5(MQTTAsync_successData5* rsp)
{
    unique_lock g(lock_);
    iaction_listener* listener = listener_;
    if (rsp) {
        msgId_ = rsp->token;
        reasonCode_ = ReasonCode(rsp->reasonCode);

        switch (type_) {
            case Type::CONNECT:
                connRsp_.reset(new connect_response(rsp));
                break;

            case Type::SUBSCRIBE:
                subRsp_.reset(new subscribe_response(rsp));
                break;

            case Type::UNSUBSCRIBE:
                unsubRsp_.reset(new unsubscribe_response(rsp));
                break;

            default:
                // The others don't have responses
                break;
        }
    }
    rc_ = MQTTASYNC_SUCCESS;
    complete_ = true;
    g.unlock();

    // Note: callback always completes before the object is signaled.
    if (listener)
        listener->on_success(*this);
    cond_.notify_all();

    cli_->remove_token(this);
}

//
// The failure callback for MQTT v3 connections
//
void token::on_failure(MQTTAsync_failureData* rsp)
{
    unique_lock g(lock_);
    iaction_listener* listener = listener_;
    if (rsp) {
        msgId_ = rsp->token;
        rc_ = rsp->code;
        reasonCode_ = ReasonCode::SUCCESS;

        if (rsp->message)
            errMsg_ = string(rsp->message);
    }
    else {
        rc_ = -1;
    }
    complete_ = true;
    g.unlock();

    // Note: callback always completes before the object is signaled.
    if (listener)
        listener->on_failure(*this);
    cond_.notify_all();

    cli_->remove_token(this);
}

//
// The failure callback for MQTT v5 connections
//
void token::on_failure5(MQTTAsync_failureData5* rsp)
{
    unique_lock g(lock_);
    iaction_listener* listener = listener_;
    if (rsp) {
        msgId_ = rsp->token;
        reasonCode_ = ReasonCode(rsp->reasonCode);
        rc_ = rsp->code;
        if (rsp->message)
            errMsg_ = string(rsp->message);
    }
    else {
        rc_ = -1;
    }
    complete_ = true;
    g.unlock();

    // Note: callback always completes before the object is signaled.
    if (listener)
        listener->on_failure(*this);
    cond_.notify_all();

    cli_->remove_token(this);
}

// --------------------------------------------------------------------------
// API

void token::reset()
{
    guard g(lock_);
    complete_ = false;
    rc_ = MQTTASYNC_SUCCESS;
    reasonCode_ = ReasonCode::SUCCESS;
    errMsg_.clear();
}

void token::set_action_callback(iaction_listener& listener)
{
    unique_lock g{lock_};
    listener_ = &listener;

    if (complete_) {
        g.unlock();

        if (rc_ == MQTTASYNC_SUCCESS)
            listener.on_success(*this);
        else
            listener.on_failure(*this);
    }
}

void token::wait()
{
    unique_lock g(lock_);
    cond_.wait(g, [this] { return complete_; });
    check_ret();
}

connect_response token::get_connect_response() const
{
    if (type_ != Type::CONNECT)
        throw bad_cast();

    unique_lock g(lock_);
    cond_.wait(g, [this] { return complete_; });
    check_ret();

    if (!connRsp_)
        throw missing_response("connect");

    return *connRsp_;
}

subscribe_response token::get_subscribe_response() const
{
    if (type_ != Type::SUBSCRIBE)
        throw bad_cast();

    unique_lock g(lock_);
    cond_.wait(g, [this] { return complete_; });
    check_ret();

    if (!subRsp_)
        throw missing_response("subscribe");

    return *subRsp_;
}

unsubscribe_response token::get_unsubscribe_response() const
{
    if (type_ != Type::UNSUBSCRIBE)
        throw bad_cast();

    unique_lock g(lock_);
    cond_.wait(g, [this] { return complete_; });
    check_ret();

    if (!unsubRsp_)
        throw missing_response("unsubscribe");

    return *unsubRsp_;
}

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

```

`src/topic.cpp`:

```cpp
// topic.cpp

/*******************************************************************************
 * Copyright (c) 2013-2025Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include "mqtt/topic.h"

#include <algorithm>

#include "mqtt/async_client.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////
//  							topic
/////////////////////////////////////////////////////////////////////////////

// This is just a string split around '/'
std::vector<string> topic::split(const string& s)
{
    std::vector<std::string> v;

    if (s.empty())
        return v;

    const auto delim = '/';
    string::size_type startPos = 0, pos;

    do {
        pos = s.find(delim, startPos);
        auto n = (pos == string::npos) ? pos : (pos - startPos);
        v.push_back(s.substr(startPos, n));
        startPos = pos + 1;
    } while (pos != string::npos);

    return v;
}

delivery_token_ptr topic::publish(const void* payload, size_t n)
{
    return cli_.publish(name_, payload, n, qos_, retained_);
}

delivery_token_ptr topic::publish(const void* payload, size_t n, int qos, bool retained)
{
    return cli_.publish(name_, payload, n, qos, retained);
}

delivery_token_ptr topic::publish(binary_ref payload)
{
    return cli_.publish(name_, std::move(payload), qos_, retained_);
}

delivery_token_ptr topic::publish(binary_ref payload, int qos, bool retained)
{
    return cli_.publish(name_, std::move(payload), qos, retained);
}

token_ptr topic::subscribe(const subscribe_options& opts)
{
    return cli_.subscribe(name_, qos_, opts);
}

/////////////////////////////////////////////////////////////////////////////
//  						topic_filter
/////////////////////////////////////////////////////////////////////////////

// If the filter has wildcards, we store the separate fields in a vector,
// otherwise matching is a simple string comparison, so we just save the
// filter as the whole string.
topic_filter::topic_filter(const string& filter)
{
    if (has_wildcards(filter)) {
        filter_ = topic::split(filter);
    }
    else {
        filter_ = filter;
    }
}

// Remember, from the v5 spec:
// "All Topic Names and Topic Filters MUST be at least one character long"
// [MQTT-4.7.3-1]
//
// So, an empty filter can't match anything, and is technically an
// error.

bool topic_filter::has_wildcards(const string& filter)
{
    if (filter.empty())
        return false;

    // A '#' should only be the last char, if present
    if (filter.back() == '#')
        return true;

    return filter.find('+') != string::npos;
}

bool topic_filter::has_wildcards() const
{
    // We parsed for wildcards on construction.
    // Plain string means no wildcards.
    return !std::holds_alternative<string>(filter_);
}

// See if the topic matches this filter.
bool topic_filter::matches(const string& topic) const
{
    // If the filter string doesn't contain any wildcards,
    // then a match is a simple string comparison...
    if (const string* pval = std::get_if<string>(&filter_)) {
        return *pval == topic;
    }

    // ...otherwise we compare individual fields.

    auto fields = std::get<std::vector<string>>(filter_);
    auto n = fields.size();

    if (n == 0) {
        return false;
    }

    auto topic_fields = topic::split(topic);
    auto nt = topic_fields.size();

    // Filter can't match a topic that is shorter
    if (n > nt && !(n == nt + 1 && fields.back() == "#")) {
        return false;
    }

    // Might match a longer topic, but only with '#' wildcard
    if (nt > n && fields.back() != "#") {
        return false;
    }

    // Topics starting with '$' don't match wildcards in the first field
    // MQTT v5 Spec, Section 4.7.2:
    // https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901246

    if (is_wildcard(fields[0]) && nt > 0 && topic_fields[0].size() > 0 &&
        topic_fields[0][0] == '$') {
        return false;
    }

    for (size_t i = 0; i < n; ++i) {
        if (fields[i] == "#") {
            break;
        }
        if (i == nt && i < n - 1) {
            return fields[i + 1] == "#";
        }
        if (fields[i] != "+" && fields[i] != topic_fields[i]) {
            return false;
        }
    }

    return true;
}

string topic_filter::to_string() const
{
    if (const string* pval = std::get_if<string>(&filter_)) {
        return *pval;
    }

    auto fields = std::get<std::vector<string>>(filter_);
    auto n = fields.size();

    string s;
    if (n > 0) {
        for (size_t i = 0; i < n - 1; ++i) {
            s.append(fields[i]);
            s.push_back('/');
        }
        s.append(fields.back());
    }
    return s;
}

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

```

`src/will_options.cpp`:

```cpp
/*******************************************************************************
 * Copyright (c) 2017-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 * Copyright (c) 2016 Guilherme M. Ferreira <guilherme.maciel.ferreira@gmail.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme M. Ferreira - initial implementation and documentation
 *    Frank Pagliughi - added copy & move operations
 *******************************************************************************/

#include "mqtt/will_options.h"

#include <cstring>
#include <utility>

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

will_options::will_options() { set_topic(string()); }

will_options::will_options(
    string_ref top, const void* payload, size_t payloadlen, int qos, bool retained,
    const properties& props /*=properties()*/
)
    : props_(props)
{
    opts_.qos = qos;
    opts_.retained = retained;
    set_topic(std::move(top));
    set_payload(binary_ref(static_cast<const binary_ref::value_type*>(payload), payloadlen));
}

will_options::will_options(
    const topic& top, const void* payload, size_t payloadlen, int qos, bool retained,
    const properties& props /*=properties()*/
)
    : will_options(top.get_name(), payload, payloadlen, qos, retained, props)
{
}

will_options::will_options(
    string_ref top, binary_ref payload, int qos, bool retained,
    const properties& props /*=properties()*/
)
    : props_(props)
{
    opts_.qos = qos;
    opts_.retained = retained;
    set_topic(std::move(top));
    set_payload(std::move(payload));
}

will_options::will_options(
    string_ref top, const string& payload, int qos, bool retained,
    const properties& props /*=properties()*/
)
    : props_(props)
{
    opts_.qos = qos;
    opts_.retained = retained;
    set_topic(std::move(top));
    set_payload(payload);
}

will_options::will_options(const message& msg)
    : will_options(
          msg.get_topic(), msg.get_payload(), msg.get_qos(), msg.is_retained(),
          msg.get_properties()
      )
{
}

will_options::will_options(const will_options& other)
    : opts_(other.opts_), props_(other.props_)
{
    set_topic(other.topic_);
    set_payload(other.payload_);
}

will_options::will_options(will_options&& other)
    : opts_(other.opts_), props_(std::move(other.props_))
{
    set_topic(std::move(other.topic_));
    set_payload(std::move(other.payload_));
}

will_options& will_options::operator=(const will_options& rhs)
{
    if (&rhs != this) {
        opts_ = rhs.opts_;
        set_topic(rhs.topic_);
        set_payload(rhs.payload_);
        props_ = rhs.props_;
    }
    return *this;
}

will_options& will_options::operator=(will_options&& rhs)
{
    if (&rhs != this) {
        opts_ = rhs.opts_;
        set_topic(std::move(rhs.topic_));
        set_payload(std::move(rhs.payload_));
        props_ = std::move(rhs.props_);
    }
    return *this;
}

void will_options::set_topic(string_ref top)
{
    topic_ = top ? std::move(top) : string_ref(string());
    opts_.topicName = topic_.c_str();
}

void will_options::set_payload(binary_ref msg)
{
    // The C struct payload must not be nullptr for will options
    payload_ = msg ? std::move(msg) : binary_ref(binary());

    opts_.payload.len = (int)payload_.size();
    opts_.payload.data = payload_.data();
}

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

```

`test/ssl/all-ca.crt`:

```crt
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 1 (0x1)
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=GB, ST=Wiltshire, L=Salisbury, O=Paho Project, OU=Testing, CN=Root CA
        Validity
            Not Before: Apr 13 13:22:31 2023 GMT
            Not After : Apr 11 13:22:31 2028 GMT
        Subject: C=GB, ST=Wiltshire, O=Paho Project, OU=Testing, CN=Signing CA
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (2048 bit)
                Modulus:
                    00:e6:ce:0e:a2:6a:56:1c:35:8c:7a:af:31:43:7d:
                    28:cb:61:15:81:2d:37:ff:f1:8f:7d:78:c3:37:58:
                    8f:6a:4c:00:b6:9d:04:f3:1c:cd:fb:ca:7d:c0:dc:
                    2b:3b:e4:c1:00:0c:71:83:df:cf:12:6f:98:ea:19:
                    01:0b:87:5f:df:a7:58:76:9c:56:b9:f2:1d:d8:9f:
                    24:89:eb:af:7f:fe:47:5a:a8:b3:79:c2:46:be:38:
                    bf:77:03:61:b7:de:d0:ae:37:8b:ad:0d:02:5c:c3:
                    e2:3a:17:e7:fc:86:9e:cd:ff:87:21:4a:c9:f5:c2:
                    3d:bf:c9:14:1e:19:d9:89:19:e9:d9:b2:c8:a9:e9:
                    d2:9b:ae:73:f2:b7:e7:fc:3d:9b:c3:72:b6:be:10:
                    fc:0c:c2:eb:b7:8f:4a:67:4c:1b:43:ca:4e:58:df:
                    cc:74:c6:6b:95:de:09:ae:ef:60:62:81:82:74:de:
                    b8:48:24:3e:0a:ac:75:72:fa:f8:5d:f2:72:7a:bd:
                    04:13:d2:c8:90:a3:ad:08:39:74:22:3f:10:7b:88:
                    37:b8:77:2b:4a:34:1a:fa:4a:64:82:b4:fe:de:6c:
                    b5:a5:4c:70:6b:7e:ab:b4:2f:57:80:f0:0c:49:1b:
                    f1:32:1f:46:2f:12:af:e7:96:be:b1:09:df:b9:6a:
                    88:bf
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Subject Key Identifier: 
                E1:BE:F5:5F:36:50:CF:FE:3D:42:EE:80:33:22:46:C2:3D:2A:41:41
            X509v3 Authority Key Identifier: 
                keyid:FE:98:8A:C3:41:B2:71:3A:4A:B3:76:5A:3C:17:06:93:11:99:8E:C8

            X509v3 Basic Constraints: 
                CA:TRUE
    Signature Algorithm: sha256WithRSAEncryption
         0d:67:f0:6d:9e:7f:ad:7a:fb:81:f7:ed:40:fe:80:69:e3:df:
         94:ed:94:b7:3f:11:db:02:ba:08:1e:a9:28:95:b5:3f:e5:86:
         02:6d:33:3c:57:39:be:18:4a:d5:18:0f:e8:59:5b:40:38:b2:
         9d:71:18:4c:b1:e6:d9:51:2d:a0:7b:af:35:b4:d9:f3:d8:f5:
         09:b9:e5:e9:81:38:b0:a6:89:57:51:76:71:7d:91:bb:db:10:
         2b:25:ce:2d:59:5a:cd:29:a2:19:a6:a0:56:19:d7:38:f4:cb:
         94:43:90:ff:20:ce:af:37:c7:73:34:ef:fb:cb:e1:f2:1f:68:
         42:91:9d:33:3f:a1:7a:cb:80:5f:f2:52:81:f1:15:fa:79:01:
         1a:29:c4:36:41:26:75:5c:4b:ff:be:67:12:d8:d2:72:03:5a:
         3e:2e:aa:b3:10:b5:10:37:2b:eb:f7:59:3a:66:87:f4:ca:e4:
         d4:35:6f:78:aa:26:de:ac:02:65:91:d2:fa:80:db:b9:8b:a6:
         26:bb:46:8f:21:e8:18:84:a6:b5:17:fb:e2:de:d8:b3:39:b2:
         6a:42:28:e9:05:55:e6:0b:39:32:42:28:a2:72:51:7c:46:96:
         e2:c2:7f:b3:a5:b9:af:3b:04:3a:93:ba:9c:2c:0a:28:39:fc:
         8b:12:7d:b7
-----BEGIN CERTIFICATE-----
MIIDmjCCAoKgAwIBAgIBATANBgkqhkiG9w0BAQsFADBwMQswCQYDVQQGEwJHQjES
MBAGA1UECAwJV2lsdHNoaXJlMRIwEAYDVQQHDAlTYWxpc2J1cnkxFTATBgNVBAoM
DFBhaG8gUHJvamVjdDEQMA4GA1UECwwHVGVzdGluZzEQMA4GA1UEAwwHUm9vdCBD
QTAeFw0yMzA0MTMxMzIyMzFaFw0yODA0MTExMzIyMzFaMF8xCzAJBgNVBAYTAkdC
MRIwEAYDVQQIDAlXaWx0c2hpcmUxFTATBgNVBAoMDFBhaG8gUHJvamVjdDEQMA4G
A1UECwwHVGVzdGluZzETMBEGA1UEAwwKU2lnbmluZyBDQTCCASIwDQYJKoZIhvcN
AQEBBQADggEPADCCAQoCggEBAObODqJqVhw1jHqvMUN9KMthFYEtN//xj314wzdY
j2pMALadBPMczfvKfcDcKzvkwQAMcYPfzxJvmOoZAQuHX9+nWHacVrnyHdifJInr
r3/+R1qos3nCRr44v3cDYbfe0K43i60NAlzD4joX5/yGns3/hyFKyfXCPb/JFB4Z
2YkZ6dmyyKnp0puuc/K35/w9m8Nytr4Q/AzC67ePSmdMG0PKTljfzHTGa5XeCa7v
YGKBgnTeuEgkPgqsdXL6+F3ycnq9BBPSyJCjrQg5dCI/EHuIN7h3K0o0GvpKZIK0
/t5staVMcGt+q7QvV4DwDEkb8TIfRi8Sr+eWvrEJ37lqiL8CAwEAAaNQME4wHQYD
VR0OBBYEFOG+9V82UM/+PULugDMiRsI9KkFBMB8GA1UdIwQYMBaAFP6YisNBsnE6
SrN2WjwXBpMRmY7IMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAA1n
8G2ef616+4H37UD+gGnj35TtlLc/EdsCuggeqSiVtT/lhgJtMzxXOb4YStUYD+hZ
W0A4sp1xGEyx5tlRLaB7rzW02fPY9Qm55emBOLCmiVdRdnF9kbvbECslzi1ZWs0p
ohmmoFYZ1zj0y5RDkP8gzq83x3M07/vL4fIfaEKRnTM/oXrLgF/yUoHxFfp5ARop
xDZBJnVcS/++ZxLY0nIDWj4uqrMQtRA3K+v3WTpmh/TK5NQ1b3iqJt6sAmWR0vqA
27mLpia7Ro8h6BiEprUX++Le2LM5smpCKOkFVeYLOTJCKKJyUXxGluLCf7Olua87
BDqTupwsCig5/IsSfbc=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDwDCCAqigAwIBAgIUPajsILLwblnD7WEDCk00ebOAASgwDQYJKoZIhvcNAQEL
BQAwcDELMAkGA1UEBhMCR0IxEjAQBgNVBAgMCVdpbHRzaGlyZTESMBAGA1UEBwwJ
U2FsaXNidXJ5MRUwEwYDVQQKDAxQYWhvIFByb2plY3QxEDAOBgNVBAsMB1Rlc3Rp
bmcxEDAOBgNVBAMMB1Jvb3QgQ0EwIBcNMjMwNDEzMTMyMjMxWhgPMjEwNTA2MDIx
MzIyMzFaMHAxCzAJBgNVBAYTAkdCMRIwEAYDVQQIDAlXaWx0c2hpcmUxEjAQBgNV
BAcMCVNhbGlzYnVyeTEVMBMGA1UECgwMUGFobyBQcm9qZWN0MRAwDgYDVQQLDAdU
ZXN0aW5nMRAwDgYDVQQDDAdSb290IENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
MIIBCgKCAQEAsqFZCPniXeWNtd5NhccCmirdLv6i/c6FAffg4iMPEYanDTh0PPWE
/tPiiOTzcGp5udF3hjjtv2lx5OSEaZYNSIgWERf0LPS0MBsHjMmVoU4S8+gZAst1
igzWKmmZAaUwBdGz0D6cRr7ZMUBfzJnrF1V6VQMLNXfrXmYAXRpxRMcBv3FPYLUc
qXp9gbFYnc+xNbuDE3Ir6/wMOu3Q1H6BvnIGVmdGqnmrONqzkMcqCuTEGlFEBQ4s
HrZUbXQGSKtlMInAM1hyP+qHmuMwTfue8/qspewHds9fNstJL9wLCZBk3Jdf6B5I
S6S+cmHM00cThnuVVwnwgU6syGhgekCNYwIDAQABo1AwTjAdBgNVHQ4EFgQU/piK
w0GycTpKs3ZaPBcGkxGZjsgwHwYDVR0jBBgwFoAU/piKw0GycTpKs3ZaPBcGkxGZ
jsgwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAhno5Byj3BGy/je/u
yPl8/uGOqh+uK0Ds+6YvUBRTHlnAFegwQrJhq17bzTdZZlw5s0+bYEVtOwX6p7Zk
mT4zUEPEQ7B223+r3TiB5xQ4ad+wZsDa9X7XY0+vqc+wf4CHFPHX4ZR0Xa1p/vBL
Y3L6ANHkwRFgx+XREmkiv4GJxeZtNSevuM63bbRZ/Y7OSZQlvKTxNlsKqi+61d7w
ciWk9BmmXNm2kQeKwsx5o7bMiETOhDXobcibD8R3U+3tf3vWp9jWIMZKkJ40U1Wb
LM0S9B1ZBkqb3Ml4Rq0AhQntQNGKDobt93ilQoGSUKq0/bR5wA8Yad9viVbbbSsm
kkdThg==
-----END CERTIFICATE-----

```

`test/ssl/client.pem`:

```pem
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 2 (0x2)
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=GB, ST=Wiltshire, O=Paho Project, OU=Testing, CN=Signing CA
        Validity
            Not Before: Apr 13 13:22:40 2023 GMT
            Not After : Apr 11 13:22:40 2028 GMT
        Subject: C=GB, ST=Wiltshire, L=Salisbury, O=Paho Project, OU=Production, CN=test client
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (2048 bit)
                Modulus:
                    00:c9:03:bc:43:8e:1e:2e:cd:ac:4a:33:2f:99:fc:
                    de:9b:43:ff:c3:c2:ca:ab:de:a8:e2:10:1b:86:d2:
                    51:ef:71:26:1f:7c:0e:5c:5b:5d:e7:1e:62:25:eb:
                    db:1f:7a:7f:c8:87:3b:79:38:b4:0b:e6:8e:43:8b:
                    8b:3a:e8:85:0a:2f:77:13:80:cb:1b:86:30:ff:7f:
                    f9:a2:70:68:5e:0b:dd:7f:4b:7d:f4:82:2b:39:5d:
                    43:cd:fd:d9:38:be:4e:4f:0f:5d:5c:f6:cc:49:95:
                    d5:b4:d5:a1:56:93:38:1d:62:5e:58:f3:90:3c:44:
                    1e:3d:85:2b:0f:9f:4f:9e:9a:e3:b1:4b:18:a8:e1:
                    05:6b:88:c5:ea:bf:a6:85:b9:3c:9f:02:ad:83:31:
                    09:5e:e3:a2:b1:78:6b:bc:b2:d1:05:f5:22:3a:90:
                    a5:1c:0f:b5:94:aa:29:aa:7d:c8:ee:f5:3a:8f:2c:
                    32:42:e1:c0:ec:8f:a8:73:ca:38:17:05:c9:c0:ce:
                    e2:c4:40:68:0b:4f:86:fb:1b:35:9c:4e:69:81:4f:
                    c8:cf:09:06:eb:ed:3a:f6:46:86:4f:91:f8:35:be:
                    3c:ca:03:a4:0f:3d:75:56:d1:93:7f:a2:d2:32:38:
                    df:02:ac:2b:ff:a1:94:a4:80:b7:9f:ca:9e:51:0f:
                    1a:bb
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Basic Constraints: 
                CA:FALSE
            Netscape Comment: 
                OpenSSL Generated Certificate
            X509v3 Subject Key Identifier: 
                DF:C7:7A:E1:90:8C:51:CB:9F:32:43:B0:A6:60:E8:FB:A0:79:6E:F0
            X509v3 Authority Key Identifier: 
                keyid:E1:BE:F5:5F:36:50:CF:FE:3D:42:EE:80:33:22:46:C2:3D:2A:41:41

    Signature Algorithm: sha256WithRSAEncryption
         5b:94:99:5f:8d:97:69:31:9d:ea:3d:e1:a5:a8:75:4c:1a:ef:
         c0:cb:b1:92:a6:19:c4:a1:25:12:2f:64:3c:af:6d:d4:48:b8:
         77:e8:29:4b:5a:6a:50:65:85:c7:ba:22:a5:9c:24:93:75:fc:
         3e:ee:81:23:a4:89:da:89:4c:54:3b:02:8f:2d:de:dd:85:df:
         11:ac:26:b5:e6:b5:d9:82:21:28:90:3c:45:42:fe:7a:0a:ba:
         46:6c:8f:05:1d:ff:6f:c6:47:16:04:f3:4b:b3:e2:82:a2:3b:
         97:71:78:0b:12:19:db:a4:fc:2f:e1:ce:2b:b1:b6:8b:1b:30:
         69:6a:b0:16:2e:2a:c1:a1:d5:69:ab:b2:b4:95:e1:8f:bf:dc:
         4e:33:7d:06:8c:2b:37:ca:d9:c2:49:b4:4b:ec:32:ac:f1:12:
         80:c9:08:02:67:d9:f8:90:62:d9:27:4d:14:67:7b:09:bb:bc:
         56:8a:68:57:d5:6b:4f:df:00:14:0a:69:45:fc:30:5f:88:3a:
         37:b8:55:8f:a6:8e:fe:48:d8:1b:25:4b:e8:c1:16:84:26:5b:
         e5:0b:ba:96:11:a0:db:b2:68:57:a9:55:f3:a8:03:65:82:da:
         9d:40:19:73:8f:d6:ab:98:fa:26:15:27:da:46:ab:29:df:a9:
         61:8b:55:2d
-----BEGIN CERTIFICATE-----
MIIDzDCCArSgAwIBAgIBAjANBgkqhkiG9w0BAQsFADBfMQswCQYDVQQGEwJHQjES
MBAGA1UECAwJV2lsdHNoaXJlMRUwEwYDVQQKDAxQYWhvIFByb2plY3QxEDAOBgNV
BAsMB1Rlc3RpbmcxEzARBgNVBAMMClNpZ25pbmcgQ0EwHhcNMjMwNDEzMTMyMjQw
WhcNMjgwNDExMTMyMjQwWjB3MQswCQYDVQQGEwJHQjESMBAGA1UECAwJV2lsdHNo
aXJlMRIwEAYDVQQHDAlTYWxpc2J1cnkxFTATBgNVBAoMDFBhaG8gUHJvamVjdDET
MBEGA1UECwwKUHJvZHVjdGlvbjEUMBIGA1UEAwwLdGVzdCBjbGllbnQwggEiMA0G
CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDJA7xDjh4uzaxKMy+Z/N6bQ//Dwsqr
3qjiEBuG0lHvcSYffA5cW13nHmIl69sfen/Ihzt5OLQL5o5Di4s66IUKL3cTgMsb
hjD/f/micGheC91/S330gis5XUPN/dk4vk5PD11c9sxJldW01aFWkzgdYl5Y85A8
RB49hSsPn0+emuOxSxio4QVriMXqv6aFuTyfAq2DMQle46KxeGu8stEF9SI6kKUc
D7WUqimqfcju9TqPLDJC4cDsj6hzyjgXBcnAzuLEQGgLT4b7GzWcTmmBT8jPCQbr
7Tr2RoZPkfg1vjzKA6QPPXVW0ZN/otIyON8CrCv/oZSkgLefyp5RDxq7AgMBAAGj
ezB5MAkGA1UdEwQCMAAwLAYJYIZIAYb4QgENBB8WHU9wZW5TU0wgR2VuZXJhdGVk
IENlcnRpZmljYXRlMB0GA1UdDgQWBBTfx3rhkIxRy58yQ7CmYOj7oHlu8DAfBgNV
HSMEGDAWgBThvvVfNlDP/j1C7oAzIkbCPSpBQTANBgkqhkiG9w0BAQsFAAOCAQEA
W5SZX42XaTGd6j3hpah1TBrvwMuxkqYZxKElEi9kPK9t1Ei4d+gpS1pqUGWFx7oi
pZwkk3X8Pu6BI6SJ2olMVDsCjy3e3YXfEawmtea12YIhKJA8RUL+egq6RmyPBR3/
b8ZHFgTzS7PigqI7l3F4CxIZ26T8L+HOK7G2ixswaWqwFi4qwaHVaauytJXhj7/c
TjN9BowrN8rZwkm0S+wyrPESgMkIAmfZ+JBi2SdNFGd7Cbu8VopoV9VrT98AFApp
RfwwX4g6N7hVj6aO/kjYGyVL6MEWhCZb5Qu6lhGg27JoV6lV86gDZYLanUAZc4/W
q5j6JhUn2karKd+pYYtVLQ==
-----END CERTIFICATE-----
-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAyQO8Q44eLs2sSjMvmfzem0P/w8LKq96o4hAbhtJR73EmH3wO
XFtd5x5iJevbH3p/yIc7eTi0C+aOQ4uLOuiFCi93E4DLG4Yw/3/5onBoXgvdf0t9
9IIrOV1Dzf3ZOL5OTw9dXPbMSZXVtNWhVpM4HWJeWPOQPEQePYUrD59PnprjsUsY
qOEFa4jF6r+mhbk8nwKtgzEJXuOisXhrvLLRBfUiOpClHA+1lKopqn3I7vU6jywy
QuHA7I+oc8o4FwXJwM7ixEBoC0+G+xs1nE5pgU/IzwkG6+069kaGT5H4Nb48ygOk
Dz11VtGTf6LSMjjfAqwr/6GUpIC3n8qeUQ8auwIDAQABAoIBAQCQS8soX2uRQ3kr
JoVEL/6ITI7cMweTytlGtjNcW7wPexTXwxD4AWpuDyR7fkyk0yXJiDIMOcUdSdrT
5+cBWYqvHhWHfYvPbUvdDTvg/HofELtmtoVrMMngeu/CfjghgJLsM+ZcZpmNNS7c
igIwCKxeg4+goO7oJCnlFaQsqbrY6aWzVcPz/Jr/IpTQJfHfFwhZmFGOoLzZNsnv
K5Y0rsVWxMjFDjhFpvTHWI+GJGHv9BNmxezc7hxbnI5QnS/EZUpLvECQryixjxLc
OnubZlGD3mk6eGvO2a+8zYQnOFw5BcX0qx1OoVbbkkzaN8DGytbTZqR9Irx7yFeB
RHg/fEHxAoGBAPrtthY61l7cj28UGFKGtC/a7r+6vYdqDGEJ+O8Ej9y4YZa7SI7x
dYQL/kVrgGFpWlntoW1l7iDRUvLV7oQIv78fKIlVj/kQou5LOLa9AYMLteULPuov
h3krszjOeRtTZSSAOo/tlgkgXPd9gqaFEOqGOII6ZC7S+a4B0eog0kBZAoGBAM0T
xbn/gkHNouOJtfMXjQyhxTcdQcTSsmDA1MxrwMFOj4PkBZ8BygGoNCOX48eK4h3v
2Eq/vGF4PApfwYb1Q4Hmd3quTvTDLprVt+OGsfvcM+91ng44wdCUM5oCV9o0bz9r
+ubsjoqDE+pTj7Oe8diJaqWkOXRjY/cDrjjOTXEzAoGAOOlRMxmFJV7A6WCVY6JJ
m9D79WBVPDFBPYEVhKB0QItRFu7DNihtjtVphjUrmOxcIalTw4wqxiazuX/r6OZT
FvXqK7vMO6EaUxGce1XC0gYF6zzxuAuvnjvbGjc6IIh5mB29KoeoT8mXTEqbJ0lm
3Mo0ZtT3g+c12dFv2ro29YECgYBZ55AoYX5+UKNXc1jj8HAymHz4E4hwvBndVswz
rg178W/zVzSrp8IihdYNwJnoMde9XheJdZMle+t+dMpH2yA0Q5AfpWkR3ruAv671
PWirzLasBPk8rN8zDLWuj9Zp39DhkfoV4KEA0kQZ13ZJPaYy0tOBOITDpIr/kIqB
dtf2hwKBgBQhkugpz/UZOywrrspaYkB0fDjT19MpJDDFMdj7Q9EbVWszdwC00bpk
KvrfB8bH3u/cpQwnJkMHpIEuT4r4JUY1lTq9laGIAJ5kZTYoJoKEfynq8FnMDY12
tO/1WhwvBvWcmvAgR/aI7RVGLJ5VaeCX8LhzU9wNTKkxrgMpC1Ke
-----END RSA PRIVATE KEY-----
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 1 (0x1)
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=GB, ST=Wiltshire, L=Salisbury, O=Paho Project, OU=Testing, CN=Root CA
        Validity
            Not Before: Apr 13 13:22:31 2023 GMT
            Not After : Apr 11 13:22:31 2028 GMT
        Subject: C=GB, ST=Wiltshire, O=Paho Project, OU=Testing, CN=Signing CA
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (2048 bit)
                Modulus:
                    00:e6:ce:0e:a2:6a:56:1c:35:8c:7a:af:31:43:7d:
                    28:cb:61:15:81:2d:37:ff:f1:8f:7d:78:c3:37:58:
                    8f:6a:4c:00:b6:9d:04:f3:1c:cd:fb:ca:7d:c0:dc:
                    2b:3b:e4:c1:00:0c:71:83:df:cf:12:6f:98:ea:19:
                    01:0b:87:5f:df:a7:58:76:9c:56:b9:f2:1d:d8:9f:
                    24:89:eb:af:7f:fe:47:5a:a8:b3:79:c2:46:be:38:
                    bf:77:03:61:b7:de:d0:ae:37:8b:ad:0d:02:5c:c3:
                    e2:3a:17:e7:fc:86:9e:cd:ff:87:21:4a:c9:f5:c2:
                    3d:bf:c9:14:1e:19:d9:89:19:e9:d9:b2:c8:a9:e9:
                    d2:9b:ae:73:f2:b7:e7:fc:3d:9b:c3:72:b6:be:10:
                    fc:0c:c2:eb:b7:8f:4a:67:4c:1b:43:ca:4e:58:df:
                    cc:74:c6:6b:95:de:09:ae:ef:60:62:81:82:74:de:
                    b8:48:24:3e:0a:ac:75:72:fa:f8:5d:f2:72:7a:bd:
                    04:13:d2:c8:90:a3:ad:08:39:74:22:3f:10:7b:88:
                    37:b8:77:2b:4a:34:1a:fa:4a:64:82:b4:fe:de:6c:
                    b5:a5:4c:70:6b:7e:ab:b4:2f:57:80:f0:0c:49:1b:
                    f1:32:1f:46:2f:12:af:e7:96:be:b1:09:df:b9:6a:
                    88:bf
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Subject Key Identifier: 
                E1:BE:F5:5F:36:50:CF:FE:3D:42:EE:80:33:22:46:C2:3D:2A:41:41
            X509v3 Authority Key Identifier: 
                keyid:FE:98:8A:C3:41:B2:71:3A:4A:B3:76:5A:3C:17:06:93:11:99:8E:C8

            X509v3 Basic Constraints: 
                CA:TRUE
    Signature Algorithm: sha256WithRSAEncryption
         0d:67:f0:6d:9e:7f:ad:7a:fb:81:f7:ed:40:fe:80:69:e3:df:
         94:ed:94:b7:3f:11:db:02:ba:08:1e:a9:28:95:b5:3f:e5:86:
         02:6d:33:3c:57:39:be:18:4a:d5:18:0f:e8:59:5b:40:38:b2:
         9d:71:18:4c:b1:e6:d9:51:2d:a0:7b:af:35:b4:d9:f3:d8:f5:
         09:b9:e5:e9:81:38:b0:a6:89:57:51:76:71:7d:91:bb:db:10:
         2b:25:ce:2d:59:5a:cd:29:a2:19:a6:a0:56:19:d7:38:f4:cb:
         94:43:90:ff:20:ce:af:37:c7:73:34:ef:fb:cb:e1:f2:1f:68:
         42:91:9d:33:3f:a1:7a:cb:80:5f:f2:52:81:f1:15:fa:79:01:
         1a:29:c4:36:41:26:75:5c:4b:ff:be:67:12:d8:d2:72:03:5a:
         3e:2e:aa:b3:10:b5:10:37:2b:eb:f7:59:3a:66:87:f4:ca:e4:
         d4:35:6f:78:aa:26:de:ac:02:65:91:d2:fa:80:db:b9:8b:a6:
         26:bb:46:8f:21:e8:18:84:a6:b5:17:fb:e2:de:d8:b3:39:b2:
         6a:42:28:e9:05:55:e6:0b:39:32:42:28:a2:72:51:7c:46:96:
         e2:c2:7f:b3:a5:b9:af:3b:04:3a:93:ba:9c:2c:0a:28:39:fc:
         8b:12:7d:b7
-----BEGIN CERTIFICATE-----
MIIDmjCCAoKgAwIBAgIBATANBgkqhkiG9w0BAQsFADBwMQswCQYDVQQGEwJHQjES
MBAGA1UECAwJV2lsdHNoaXJlMRIwEAYDVQQHDAlTYWxpc2J1cnkxFTATBgNVBAoM
DFBhaG8gUHJvamVjdDEQMA4GA1UECwwHVGVzdGluZzEQMA4GA1UEAwwHUm9vdCBD
QTAeFw0yMzA0MTMxMzIyMzFaFw0yODA0MTExMzIyMzFaMF8xCzAJBgNVBAYTAkdC
MRIwEAYDVQQIDAlXaWx0c2hpcmUxFTATBgNVBAoMDFBhaG8gUHJvamVjdDEQMA4G
A1UECwwHVGVzdGluZzETMBEGA1UEAwwKU2lnbmluZyBDQTCCASIwDQYJKoZIhvcN
AQEBBQADggEPADCCAQoCggEBAObODqJqVhw1jHqvMUN9KMthFYEtN//xj314wzdY
j2pMALadBPMczfvKfcDcKzvkwQAMcYPfzxJvmOoZAQuHX9+nWHacVrnyHdifJInr
r3/+R1qos3nCRr44v3cDYbfe0K43i60NAlzD4joX5/yGns3/hyFKyfXCPb/JFB4Z
2YkZ6dmyyKnp0puuc/K35/w9m8Nytr4Q/AzC67ePSmdMG0PKTljfzHTGa5XeCa7v
YGKBgnTeuEgkPgqsdXL6+F3ycnq9BBPSyJCjrQg5dCI/EHuIN7h3K0o0GvpKZIK0
/t5staVMcGt+q7QvV4DwDEkb8TIfRi8Sr+eWvrEJ37lqiL8CAwEAAaNQME4wHQYD
VR0OBBYEFOG+9V82UM/+PULugDMiRsI9KkFBMB8GA1UdIwQYMBaAFP6YisNBsnE6
SrN2WjwXBpMRmY7IMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAA1n
8G2ef616+4H37UD+gGnj35TtlLc/EdsCuggeqSiVtT/lhgJtMzxXOb4YStUYD+hZ
W0A4sp1xGEyx5tlRLaB7rzW02fPY9Qm55emBOLCmiVdRdnF9kbvbECslzi1ZWs0p
ohmmoFYZ1zj0y5RDkP8gzq83x3M07/vL4fIfaEKRnTM/oXrLgF/yUoHxFfp5ARop
xDZBJnVcS/++ZxLY0nIDWj4uqrMQtRA3K+v3WTpmh/TK5NQ1b3iqJt6sAmWR0vqA
27mLpia7Ro8h6BiEprUX++Le2LM5smpCKOkFVeYLOTJCKKJyUXxGluLCf7Olua87
BDqTupwsCig5/IsSfbc=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDwDCCAqigAwIBAgIUPajsILLwblnD7WEDCk00ebOAASgwDQYJKoZIhvcNAQEL
BQAwcDELMAkGA1UEBhMCR0IxEjAQBgNVBAgMCVdpbHRzaGlyZTESMBAGA1UEBwwJ
U2FsaXNidXJ5MRUwEwYDVQQKDAxQYWhvIFByb2plY3QxEDAOBgNVBAsMB1Rlc3Rp
bmcxEDAOBgNVBAMMB1Jvb3QgQ0EwIBcNMjMwNDEzMTMyMjMxWhgPMjEwNTA2MDIx
MzIyMzFaMHAxCzAJBgNVBAYTAkdCMRIwEAYDVQQIDAlXaWx0c2hpcmUxEjAQBgNV
BAcMCVNhbGlzYnVyeTEVMBMGA1UECgwMUGFobyBQcm9qZWN0MRAwDgYDVQQLDAdU
ZXN0aW5nMRAwDgYDVQQDDAdSb290IENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
MIIBCgKCAQEAsqFZCPniXeWNtd5NhccCmirdLv6i/c6FAffg4iMPEYanDTh0PPWE
/tPiiOTzcGp5udF3hjjtv2lx5OSEaZYNSIgWERf0LPS0MBsHjMmVoU4S8+gZAst1
igzWKmmZAaUwBdGz0D6cRr7ZMUBfzJnrF1V6VQMLNXfrXmYAXRpxRMcBv3FPYLUc
qXp9gbFYnc+xNbuDE3Ir6/wMOu3Q1H6BvnIGVmdGqnmrONqzkMcqCuTEGlFEBQ4s
HrZUbXQGSKtlMInAM1hyP+qHmuMwTfue8/qspewHds9fNstJL9wLCZBk3Jdf6B5I
S6S+cmHM00cThnuVVwnwgU6syGhgekCNYwIDAQABo1AwTjAdBgNVHQ4EFgQU/piK
w0GycTpKs3ZaPBcGkxGZjsgwHwYDVR0jBBgwFoAU/piKw0GycTpKs3ZaPBcGkxGZ
jsgwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAhno5Byj3BGy/je/u
yPl8/uGOqh+uK0Ds+6YvUBRTHlnAFegwQrJhq17bzTdZZlw5s0+bYEVtOwX6p7Zk
mT4zUEPEQ7B223+r3TiB5xQ4ad+wZsDa9X7XY0+vqc+wf4CHFPHX4ZR0Xa1p/vBL
Y3L6ANHkwRFgx+XREmkiv4GJxeZtNSevuM63bbRZ/Y7OSZQlvKTxNlsKqi+61d7w
ciWk9BmmXNm2kQeKwsx5o7bMiETOhDXobcibD8R3U+3tf3vWp9jWIMZKkJ40U1Wb
LM0S9B1ZBkqb3Ml4Rq0AhQntQNGKDobt93ilQoGSUKq0/bR5wA8Yad9viVbbbSsm
kkdThg==
-----END CERTIFICATE-----

```

`test/ssl/mosquitto.conf`:

```conf
log_type error
log_type warning
log_type notice
log_type information
#log_type debug

#log_dest file /var/log/mosquitto/tls-testing.log

allow_anonymous true
#password_file test/tls-testing/mosquitto.pw

#message_size_limit 5000000

# non-SSL listeners
listener 1883
listener 18883

# listener for mutual authentication
listener 18884
cafile test/ssl/all-ca.crt
certfile test/ssl/server.crt
keyfile test/ssl/server.key
require_certificate true
use_identity_as_username false
#tls_version tlsv1

# server authentication - no client authentication
listener 18885
protocol websockets
cafile test/ssl/all-ca.crt
certfile test/ssl/server.crt
keyfile test/ssl/server.key
require_certificate false
#tls_version tlsv1

# TLS-PSK authentication
#listener 18888
#ciphers PSK-AES128-CBC-SHA
#psk_hint Test
#psk_file test/tls-testing/mosquitto.psk

```

`test/ssl/server.crt`:

```crt
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 1 (0x1)
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=GB, ST=Wiltshire, O=Paho Project, OU=Testing, CN=Signing CA
        Validity
            Not Before: Apr 13 13:22:38 2023 GMT
            Not After : Apr 11 13:22:38 2028 GMT
        Subject: C=GB, ST=Wiltshire, L=Salisbury, O=Paho Project, OU=Production, CN=localhost
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (2048 bit)
                Modulus:
                    00:c8:b2:1f:2b:d4:6c:20:f0:67:64:14:9d:79:14:
                    b3:99:49:a9:65:1d:20:f3:1e:b7:96:92:9b:e7:0c:
                    1d:90:be:dc:a5:c5:10:e1:9e:d9:fd:f4:6f:f0:1e:
                    18:ef:db:fd:f9:88:e3:fb:0f:fb:4b:6b:15:c3:8d:
                    43:86:6c:2b:f0:12:94:b5:ce:9d:60:57:04:15:0e:
                    07:0f:72:87:5b:38:62:f4:75:5d:17:05:3d:45:1f:
                    e7:7b:ee:da:50:95:22:10:de:f8:87:cb:b8:39:38:
                    cf:88:6d:69:80:7d:df:a7:50:28:45:df:aa:33:e3:
                    3d:d6:a2:4c:2b:8d:bb:83:db:98:2d:cd:1a:7f:88:
                    75:e5:5d:fc:ea:c8:60:93:31:76:66:f3:24:ad:2b:
                    fa:20:77:41:61:ab:43:ee:47:52:45:6b:a4:11:98:
                    3d:bf:7c:09:57:c0:0b:36:8f:ba:be:e3:29:d5:3e:
                    f9:c1:51:15:1f:b1:c1:4e:9f:c8:68:e2:b1:d8:11:
                    25:7b:65:56:11:79:fe:f7:f1:c8:ac:9b:b0:a2:4b:
                    e5:c4:e4:96:ab:92:30:f8:ce:a7:ae:c9:53:e1:f4:
                    d9:f8:55:e1:52:1a:b2:e0:ae:b6:76:f7:e4:dc:2c:
                    0b:f2:c3:09:b2:f7:42:8d:56:d6:d4:3b:af:18:2e:
                    26:31
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Basic Constraints: 
                CA:FALSE
            Netscape Comment: 
                OpenSSL Generated Certificate
            X509v3 Subject Key Identifier: 
                93:31:D2:88:FB:6F:4C:AB:37:BE:CE:30:6B:1B:AB:70:27:58:8F:DA
            X509v3 Authority Key Identifier: 
                keyid:E1:BE:F5:5F:36:50:CF:FE:3D:42:EE:80:33:22:46:C2:3D:2A:41:41

    Signature Algorithm: sha256WithRSAEncryption
         4a:2e:1f:9c:7e:99:2e:cc:40:b4:49:ea:92:27:d4:35:f5:07:
         6b:ff:a2:2e:15:47:76:40:3c:9b:1c:85:b3:a8:f6:a6:f2:15:
         c0:a1:dc:d6:bd:66:71:09:fd:e6:93:4f:9a:36:e4:a7:0f:b0:
         f5:5a:4d:e2:30:50:9b:12:0d:12:4d:6a:67:81:02:17:92:69:
         00:e4:24:91:5c:83:99:9c:7b:6d:8d:3f:fc:46:81:c2:4a:f4:
         9c:3f:d6:5f:6b:1f:c6:84:fa:de:33:26:3a:d4:d2:4c:98:23:
         c1:2b:20:f2:12:bd:dc:61:5f:63:84:4c:1b:7b:c5:28:3c:4a:
         bb:da:07:61:b7:d7:79:43:66:eb:f9:21:96:14:34:80:1b:bd:
         b7:62:22:ea:7a:0a:25:b5:27:fb:40:c7:f7:ce:18:ea:e6:16:
         55:d9:bb:de:98:c5:19:04:a1:3c:03:e2:6f:50:79:ac:ce:88:
         9c:6e:d0:1a:d2:87:10:2e:59:dd:14:19:be:23:aa:bc:17:1b:
         21:96:5f:08:ce:16:d9:71:52:72:f9:f5:be:f7:cd:17:ae:9a:
         9a:3f:e1:11:a3:a9:9a:6c:8d:ca:c9:7f:e5:6d:32:72:4e:3e:
         c0:c7:96:95:e4:dc:9e:b6:3a:e3:57:4f:eb:79:2a:09:61:51:
         78:c1:b9:50
-----BEGIN CERTIFICATE-----
MIIDyjCCArKgAwIBAgIBATANBgkqhkiG9w0BAQsFADBfMQswCQYDVQQGEwJHQjES
MBAGA1UECAwJV2lsdHNoaXJlMRUwEwYDVQQKDAxQYWhvIFByb2plY3QxEDAOBgNV
BAsMB1Rlc3RpbmcxEzARBgNVBAMMClNpZ25pbmcgQ0EwHhcNMjMwNDEzMTMyMjM4
WhcNMjgwNDExMTMyMjM4WjB1MQswCQYDVQQGEwJHQjESMBAGA1UECAwJV2lsdHNo
aXJlMRIwEAYDVQQHDAlTYWxpc2J1cnkxFTATBgNVBAoMDFBhaG8gUHJvamVjdDET
MBEGA1UECwwKUHJvZHVjdGlvbjESMBAGA1UEAwwJbG9jYWxob3N0MIIBIjANBgkq
hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyLIfK9RsIPBnZBSdeRSzmUmpZR0g8x63
lpKb5wwdkL7cpcUQ4Z7Z/fRv8B4Y79v9+Yjj+w/7S2sVw41Dhmwr8BKUtc6dYFcE
FQ4HD3KHWzhi9HVdFwU9RR/ne+7aUJUiEN74h8u4OTjPiG1pgH3fp1AoRd+qM+M9
1qJMK427g9uYLc0af4h15V386shgkzF2ZvMkrSv6IHdBYatD7kdSRWukEZg9v3wJ
V8ALNo+6vuMp1T75wVEVH7HBTp/IaOKx2BEle2VWEXn+9/HIrJuwokvlxOSWq5Iw
+M6nrslT4fTZ+FXhUhqy4K62dvfk3CwL8sMJsvdCjVbW1DuvGC4mMQIDAQABo3sw
eTAJBgNVHRMEAjAAMCwGCWCGSAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBD
ZXJ0aWZpY2F0ZTAdBgNVHQ4EFgQUkzHSiPtvTKs3vs4waxurcCdYj9owHwYDVR0j
BBgwFoAU4b71XzZQz/49Qu6AMyJGwj0qQUEwDQYJKoZIhvcNAQELBQADggEBAEou
H5x+mS7MQLRJ6pIn1DX1B2v/oi4VR3ZAPJschbOo9qbyFcCh3Na9ZnEJ/eaTT5o2
5KcPsPVaTeIwUJsSDRJNameBAheSaQDkJJFcg5mce22NP/xGgcJK9Jw/1l9rH8aE
+t4zJjrU0kyYI8ErIPISvdxhX2OETBt7xSg8SrvaB2G313lDZuv5IZYUNIAbvbdi
Iup6CiW1J/tAx/fOGOrmFlXZu96YxRkEoTwD4m9QeazOiJxu0BrShxAuWd0UGb4j
qrwXGyGWXwjOFtlxUnL59b73zReumpo/4RGjqZpsjcrJf+VtMnJOPsDHlpXk3J62
OuNXT+t5KglhUXjBuVA=
-----END CERTIFICATE-----

```

`test/ssl/server.key`:

```key
-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAyLIfK9RsIPBnZBSdeRSzmUmpZR0g8x63lpKb5wwdkL7cpcUQ
4Z7Z/fRv8B4Y79v9+Yjj+w/7S2sVw41Dhmwr8BKUtc6dYFcEFQ4HD3KHWzhi9HVd
FwU9RR/ne+7aUJUiEN74h8u4OTjPiG1pgH3fp1AoRd+qM+M91qJMK427g9uYLc0a
f4h15V386shgkzF2ZvMkrSv6IHdBYatD7kdSRWukEZg9v3wJV8ALNo+6vuMp1T75
wVEVH7HBTp/IaOKx2BEle2VWEXn+9/HIrJuwokvlxOSWq5Iw+M6nrslT4fTZ+FXh
Uhqy4K62dvfk3CwL8sMJsvdCjVbW1DuvGC4mMQIDAQABAoIBACd6wp8AnnSsVepe
E8wpwlq5HtWBMWYh+MNp+7krrPU4VndVmMiJUyCd4Rc/FHC6ue9IenB86FYhrppV
Q59B0DLdtNs+1b6J34e0xrbHNNFA+lZUcAeDRFZAvGyow9FuRNFEy2cLMCYxgsG3
pDVejYyAPCvin7ytSxDZxFoc+3Ioeqgx6XKuaT9gFyy1SVYzXiQYXvzCIONGGNJW
7Y1q9l5vqnC3hquaDPs4zYy46I7Iv3pMfoQyMagCyi5sliK7sBWzu5sGPLJK0Sch
CkEvqtCve9mFU75jVE9dg404sil3oiYvPyRcM/fEAj3rR0ZLruVdOoaCr+V0Q+G6
WujDQ7ECgYEA/6J64B639hwPeAY5QNwRY8gLIggAUjzSvvYeG+7/MfzBr+gNzI8l
etMBPp/1VrxRtUw9hAlW6+hcsBA17ynnwzUsTjlYBjs2WvOg5MEZDjlQvyFS9ULA
ejfJgbo1Tdv+IEqUlyW5OXT0QJncpry7shUS7jeUcsC0mmi3Qi1CKksCgYEAyPuL
ERAyW3On04MCz72LiJVngyOZeTyLP8U7WK4spdsXOxW5UUaQXpj23F1JME7LUGnz
ESXQQ9xMNQrPHA81BLCjhi+CKFmmTXrcLnWtw68SQRGiXWx9yH4axkS3nrj2GPUi
U2UbLEu4CaSaJYxHBjTRtUML8qp53AhsvjDvY/MCgYAsQaLoPik3EHCVJO6wjejs
z2st/xifJCyQJufbiirgKpQVsiUBbx7b/r/Oab79vyieLI7R1xQXT2kMiiHsP+MB
5qi++iqFGac1Y8xNDikaT03taQWFtILCJfpa3TPxQM7kJEVJTZydl+PZc0nCDBaq
o/9dAn5Ox5H80Xg4msFDtQKBgQCNSHasGgysSRMzFqfFTWNnMk+/2iirFyp0O7vK
TTZJqUgdWtoZDleyiCkRI+qtMNavwqsB5OkQqy5PIzgQa4hDscBiNcdzggHr+XAK
oOLz6oAUicbvkbKiXDOKKQhDZZZqWPg2U57Udq366WELAB91d2/r0iP2BG0BhlKb
KF9AjQKBgDc3gVP4YDZfqQywEnq6LMl79eda4NBA44MA9AXjxSgBDJIjpkkAOz3I
yL+al6rz/zJlG3kEx46b4LRX40JlF8em50i9VmnVpbe/MKYoacZRTVbuJqWav6En
bRRr+zj0s9T8ksYp9kH/iS0g9Tf4qnB154e7D/br4dRbPJPX97k2
-----END RSA PRIVATE KEY-----

```

`test/ssl/test-root-ca.crt`:

```crt
-----BEGIN CERTIFICATE-----
MIIDwDCCAqigAwIBAgIUPajsILLwblnD7WEDCk00ebOAASgwDQYJKoZIhvcNAQEL
BQAwcDELMAkGA1UEBhMCR0IxEjAQBgNVBAgMCVdpbHRzaGlyZTESMBAGA1UEBwwJ
U2FsaXNidXJ5MRUwEwYDVQQKDAxQYWhvIFByb2plY3QxEDAOBgNVBAsMB1Rlc3Rp
bmcxEDAOBgNVBAMMB1Jvb3QgQ0EwIBcNMjMwNDEzMTMyMjMxWhgPMjEwNTA2MDIx
MzIyMzFaMHAxCzAJBgNVBAYTAkdCMRIwEAYDVQQIDAlXaWx0c2hpcmUxEjAQBgNV
BAcMCVNhbGlzYnVyeTEVMBMGA1UECgwMUGFobyBQcm9qZWN0MRAwDgYDVQQLDAdU
ZXN0aW5nMRAwDgYDVQQDDAdSb290IENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
MIIBCgKCAQEAsqFZCPniXeWNtd5NhccCmirdLv6i/c6FAffg4iMPEYanDTh0PPWE
/tPiiOTzcGp5udF3hjjtv2lx5OSEaZYNSIgWERf0LPS0MBsHjMmVoU4S8+gZAst1
igzWKmmZAaUwBdGz0D6cRr7ZMUBfzJnrF1V6VQMLNXfrXmYAXRpxRMcBv3FPYLUc
qXp9gbFYnc+xNbuDE3Ir6/wMOu3Q1H6BvnIGVmdGqnmrONqzkMcqCuTEGlFEBQ4s
HrZUbXQGSKtlMInAM1hyP+qHmuMwTfue8/qspewHds9fNstJL9wLCZBk3Jdf6B5I
S6S+cmHM00cThnuVVwnwgU6syGhgekCNYwIDAQABo1AwTjAdBgNVHQ4EFgQU/piK
w0GycTpKs3ZaPBcGkxGZjsgwHwYDVR0jBBgwFoAU/piKw0GycTpKs3ZaPBcGkxGZ
jsgwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAhno5Byj3BGy/je/u
yPl8/uGOqh+uK0Ds+6YvUBRTHlnAFegwQrJhq17bzTdZZlw5s0+bYEVtOwX6p7Zk
mT4zUEPEQ7B223+r3TiB5xQ4ad+wZsDa9X7XY0+vqc+wf4CHFPHX4ZR0Xa1p/vBL
Y3L6ANHkwRFgx+XREmkiv4GJxeZtNSevuM63bbRZ/Y7OSZQlvKTxNlsKqi+61d7w
ciWk9BmmXNm2kQeKwsx5o7bMiETOhDXobcibD8R3U+3tf3vWp9jWIMZKkJ40U1Wb
LM0S9B1ZBkqb3Ml4Rq0AhQntQNGKDobt93ilQoGSUKq0/bR5wA8Yad9viVbbbSsm
kkdThg==
-----END CERTIFICATE-----

```

`test/unit/CMakeLists.txt`:

```txt
# CMakeLists.txt
#
# CMake file for the Catch2 unit tests in the Eclipse Paho C++ library.
#

#*******************************************************************************
# Copyright (c) 2019-2023 Frank Pagliughi <fpagliughi@mindspring.com>
#
#  All rights reserved. This program and the accompanying materials
#  are made available under the terms of the Eclipse Public License v2.0
#  and Eclipse Distribution License v1.0 which accompany this distribution. 
# 
#  The Eclipse Public License is available at 
#     http://www.eclipse.org/legal/epl-v20.html
#  and the Eclipse Distribution License is available at 
#    http://www.eclipse.org/org/documents/edl-v10.php.
# 
#  Contributors:
#     Frank Pagliughi - Initial implementation
#*******************************************************************************/

# --- Find Catch2 and figure out which major version ---

find_package(Catch2 REQUIRED)

message(STATUS "Found Catch2 v${Catch2_VERSION}")

if (Catch2_VERSION VERSION_LESS "2.0")
    message(FATAL "Catch2 v2.0 or greater required for tests")
endif()

# --- Executables ---

add_executable(unit_tests unit_tests.cpp
    test_async_client.cpp
    test_buffer_ref.cpp
    test_client.cpp
    test_connect_options.cpp
    test_create_options.cpp
    test_disconnect_options.cpp
    test_exception.cpp
    test_message.cpp
    test_persistence.cpp
    test_properties.cpp
    test_response_options.cpp
    test_string_collection.cpp
    test_subscribe_options.cpp
    test_thread_queue.cpp
    test_token.cpp
    test_topic.cpp
    test_topic_matcher.cpp
    test_will_options.cpp
)

if(PAHO_WITH_SSL)
    target_sources(unit_tests PUBLIC 
        ${CMAKE_CURRENT_SOURCE_DIR}/test_ssl_options.cpp
    )
endif()

set_target_properties(unit_tests PROPERTIES
    CXX_STANDARD 17
    CXX_STANDARD_REQUIRED ON
    CXX_EXTENSIONS OFF
)

if (Catch2_VERSION VERSION_LESS "3.0")
    target_compile_definitions(unit_tests PUBLIC CATCH2_V2)
endif()

# --- Link for executables ---

target_link_libraries(unit_tests
    Catch2::Catch2
    PahoMqttCpp::paho-mqttpp3
)

if(PAHO_BUILD_SHARED)
    target_compile_definitions(unit_tests PUBLIC PAHO_MQTTPP_IMPORTS)

    if(MSVC AND PAHO_BUILD_STATIC)
        target_link_libraries(unit_tests ${LIBS_SYSTEM})
    endif()
endif()

include(CTest)
include(Catch)

catch_discover_tests(unit_tests)


```

`test/unit/catch2_version.h`:

```h
// catch2_version.h
//
// Figure out which Catch2 header file to locad by version.
//

/*******************************************************************************
 * Copyright (c) 2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#ifndef __catch2_version_h
#define __catch2_version_h

#ifdef CATCH2_V2
    // For Catch2 v2.x
    #include "catch2/catch.hpp"
#else
    // For Catch2 v3.x (and beyond?)
    #include "catch2/catch_all.hpp"
#endif

#endif  // __catch2_version_h

```

`test/unit/mock_action_listener.h`:

```h
// mock_action_listener.h
//
// Dummy implementation of mqtt::iaction_listener for Unit Test.
//

/*******************************************************************************
 * Copyright (c) 2016 Guilherme M. Ferreira <guilherme.maciel.ferreira@gmail.com>
 * Copyright (c) 2020 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme M. Ferreira - initial implementation
 *    Frank Pagliughi - prepared for Catch2, renamed 'mock'
 *******************************************************************************/

#ifndef __mqtt_dummy_action_listener_h
#define __mqtt_dummy_action_listener_h

#include "mqtt/token.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

/**
 * Test/mock action listener to determine which callback gets triggered, if
 * any.
 */
class mock_action_listener : public iaction_listener
{
    bool onSuccessCalled_{false};
    bool onFailureCalled_{false};

    void on_success(const mqtt::token&) override { onSuccessCalled_ = true; }

    void on_failure(const mqtt::token&) override { onFailureCalled_ = true; }

public:
    bool succeeded() const { return onSuccessCalled_; }
    bool failed() const { return onFailureCalled_; }
};

/////////////////////////////////////////////////////////////////////////////
// end namespace mqtt
}  // namespace mqtt

#endif  //  __mqtt_dummy_action_listener_h

```

`test/unit/mock_async_client.h`:

```h
// mock_async_client.h
//
// Dummy/mock implementation of mqtt::iasync_client for unit tests.
//

/*******************************************************************************
 * Copyright (c) 2016 Guilherme M. Ferreira <guilherme.maciel.ferreira@gmail.com>
 * Copyright (c) 2020 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme M. Ferreira - initial implementation
 *    Frank Pagliughi - updated and renamed
 *******************************************************************************/

#ifndef __mqtt_test_mock_async_client_h
#define __mqtt_test_mock_async_client_h

#include <vector>

#include "mqtt/connect_options.h"
#include "mqtt/iasync_client.h"
#include "mqtt/token.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

class mock_async_client : public virtual mqtt::iasync_client
{
public:
    void remove_token(mqtt::token* tok) override {}

    static void succeed(mqtt::token* tok, MQTTAsync_successData* rsp)
    {
        token::on_success(tok, rsp);
    }

    static void succeed5(mqtt::token* tok, MQTTAsync_successData5* rsp)
    {
        token::on_success5(tok, rsp);
    }

    static void fail(mqtt::token* tok, MQTTAsync_failureData* rsp)
    {
        token::on_failure(tok, rsp);
    }

    static void fail5(mqtt::token* tok, MQTTAsync_failureData5* rsp)
    {
        token::on_failure5(tok, rsp);
    }

    // iface

    mqtt::token_ptr connect() override { return mqtt::token_ptr{}; }

    mqtt::token_ptr connect(mqtt::connect_options options) override
    {
        return mqtt::token_ptr{};
    }

    mqtt::token_ptr connect(
        mqtt::connect_options options, void* userContext, mqtt::iaction_listener& cb
    ) override
    {
        return mqtt::token_ptr{};
    }

    mqtt::token_ptr connect(void* userContext, mqtt::iaction_listener& cb) override
    {
        return mqtt::token_ptr{};
    }

    mqtt::token_ptr reconnect() override { return mqtt::token_ptr{}; }

    mqtt::token_ptr disconnect() override { return mqtt::token_ptr{}; }

    mqtt::token_ptr disconnect(disconnect_options) override { return mqtt::token_ptr{}; }

    mqtt::token_ptr disconnect(int timeout) override { return mqtt::token_ptr{}; }

    mqtt::token_ptr disconnect(int timeout, void* userContext, mqtt::iaction_listener& cb)
        override
    {
        return mqtt::token_ptr{};
    }

    mqtt::token_ptr disconnect(void* userContext, mqtt::iaction_listener& cb) override
    {
        return mqtt::token_ptr{};
    }

    mqtt::delivery_token_ptr get_pending_delivery_token(int msgID) const override
    {
        return mqtt::delivery_token_ptr{};
    }

    std::vector<mqtt::delivery_token_ptr> get_pending_delivery_tokens() const override
    {
        return std::vector<mqtt::delivery_token_ptr>{};
    };

    std::string get_client_id() const override { return std::string{}; };

    std::string get_server_uri() const override { return std::string{}; };

    bool is_connected() const override { return true; };

    mqtt::delivery_token_ptr publish(
        string_ref topic, const void* payload, size_t n, int qos, bool retained,
		const properties &props=properties()
    ) override
    {
        auto msg = mqtt::message::create(topic, payload, n, qos, retained);
        return publish(msg);
    };

    mqtt::delivery_token_ptr publish(string_ref topic, const void* payload, size_t n) override
    {
        auto msg = mqtt::message::create(topic, payload, n);
        return publish(msg);
    };

    mqtt::delivery_token_ptr publish(
        string_ref topic, binary_ref payload, int qos, bool retained,
		const properties &props=properties()
    ) override
    {
        auto msg = mqtt::message::create(topic, payload, qos, retained);
        return publish(msg);
    };

    mqtt::delivery_token_ptr publish(string_ref topic, binary_ref payload) override
    {
        auto msg = mqtt::message::create(topic, payload);
        return publish(msg);
    };

    mqtt::delivery_token_ptr publish(
        string_ref topic, const void* payload, size_t n, int qos, bool retained,
        void* userContext, mqtt::iaction_listener& cb
    ) override
    {
        return mqtt::delivery_token_ptr{};
    }

    mqtt::delivery_token_ptr publish(mqtt::const_message_ptr msg) override
    {
        return mqtt::delivery_token::create(*this, msg);
    }

    mqtt::delivery_token_ptr publish(
        mqtt::const_message_ptr msg, void* userContext, mqtt::iaction_listener& cb
    ) override
    {
        return mqtt::delivery_token_ptr{};
    }

    void set_callback(mqtt::callback& cb) override {}
    void disable_callbacks() override {}

    mqtt::token_ptr subscribe(
        const string& topicFilter, int qos,
        const subscribe_options& opts = subscribe_options(),
        const properties& props = properties()
    ) override
    {
        return mqtt::token_ptr{};
    }

    mqtt::token_ptr subscribe(
        const string& topicFilter, int qos, void* userContext, iaction_listener& callback,
        const subscribe_options& opts = subscribe_options(),
        const properties& props = properties()
    ) override
    {
        return mqtt::token_ptr{};
    }

    mqtt::token_ptr subscribe(
        const_string_collection_ptr topicFilters, const qos_collection& qos,
        const std::vector<subscribe_options>& opts = std::vector<subscribe_options>(),
        const properties& props = properties()
    ) override
    {
        return mqtt::token_ptr{};
    }

    mqtt::token_ptr subscribe(
        const_string_collection_ptr topicFilters, const qos_collection& qos,
        void* userContext, iaction_listener& callback,
        const std::vector<subscribe_options>& opts = std::vector<subscribe_options>(),
        const properties& props = properties()
    ) override
    {
        return mqtt::token_ptr{};
    }

    mqtt::token_ptr unsubscribe(
        const string& topicFilter, const properties& props = properties()
    ) override
    {
        return mqtt::token_ptr{};
    }

    mqtt::token_ptr unsubscribe(
        const_string_collection_ptr topicFilters, const properties& props = properties()
    ) override
    {
        return mqtt::token_ptr{};
    }

    mqtt::token_ptr unsubscribe(
        const_string_collection_ptr topicFilters, void* userContext,
        mqtt::iaction_listener& cb, const properties& props = properties()
    ) override
    {
        return mqtt::token_ptr{};
    }

    mqtt::token_ptr unsubscribe(
        const string& topicFilter, void* userContext, mqtt::iaction_listener& cb,
        const properties& props = properties()
    ) override
    {
        return mqtt::token_ptr{};
    }

    void start_consuming() override {}
    void stop_consuming() override {}

    const_message_ptr consume_message() override { return const_message_ptr{}; }

    bool try_consume_message(const_message_ptr*) override { return false; }

    event consume_event() override { return const_message_ptr{}; }
    bool try_consume_event(event* evt) override { return false; }
};

/////////////////////////////////////////////////////////////////////////////
}  // namespace mqtt

#endif  //  __mqtt_test_mock_async_client_h

```

`test/unit/mock_callback.h`:

```h
// mock_callback.h
//
// Dummy implementation of mqtt::callback for Unit Test.

/*******************************************************************************
 * Copyright (c) 2017 Guilherme M. Ferreira <guilherme.maciel.ferreira@gmail.com>
 * Copyright (c) 2020 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme M. Ferreira - initial implementation
 *    Frank Pagliughi - Renamed 'mock', and refactored for coding
 *    conventions
 *******************************************************************************/

#ifndef __mqtt_mock_callback_h
#define __mqtt_mock_callback_h

#include "mqtt/callback.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

class mock_callback : public mqtt::callback
{
    bool connectionLost_{false};
    bool messageArrived_{false};
    bool deliveryComplete_{false};

    void connection_lost(const std::string& cause) override { connectionLost_ = true; }

    void message_arrived(mqtt::const_message_ptr msg) override { messageArrived_ = true; }

    void delivery_complete(mqtt::delivery_token_ptr tok) override
    {
        deliveryComplete_ = true;
    }

public:
    bool connection_lost() const { return connectionLost_; }
    bool message_arrived() const { return messageArrived_; }
    bool delivery_complete() const { return deliveryComplete_; }
};

/////////////////////////////////////////////////////////////////////////////
// end namespace mqtt
}  // namespace mqtt

#endif  //  __mqtt_mock_callback_h

```

`test/unit/mock_persistence.h`:

```h
// mock_persistence.h
//
// Dummy implementation of mqtt::iclient_persistence for Unit Test.
//

/*******************************************************************************
 * Copyright (c) 2016 Guilherme M. Ferreira <guilherme.maciel.ferreira@gmail.com>
 * Copyright (c) 2020 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme M. Ferreira - initial implementation and documentation
 *    Frank Pagliughi - Renamed 'mock', refactored for coding conventions
 *******************************************************************************/

#ifndef __mqtt_mock_persistence_h
#define __mqtt_mock_persistence_h

#include "mqtt/exception.h"
#include "mqtt/iclient_persistence.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

// Dummy persistence is a working in-memory persistence class.
class mock_persistence : virtual public iclient_persistence
{
    using base = iclient_persistence;

    // Whether the store is open
    bool open_{false};

    // Use an STL map to store shared persistence pointers
    // against string keys.
    std::map<std::string, std::string> store_;

public:
    static int persistence_open(
        void** handle, const char* clientID, const char* serverURI, void* context
    )
    {
        return base::persistence_open(handle, clientID, serverURI, context);
    }
    static int persistence_close(void* handle) { return base::persistence_close(handle); }
    static int persistence_put(
        void* handle, char* key, int bufcount, char* buffers[], int buflens[]
    )
    {
        return base::persistence_put(handle, key, bufcount, buffers, buflens);
    }
    static int persistence_get(void* handle, char* key, char** buffer, int* buflen)
    {
        return base::persistence_get(handle, key, buffer, buflen);
    }
    static int persistence_remove(void* handle, char* key)
    {
        return base::persistence_remove(handle, key);
    }
    static int persistence_keys(void* handle, char*** keys, int* nkeys)
    {
        return base::persistence_keys(handle, keys, nkeys);
    }
    static int persistence_clear(void* handle) { return base::persistence_clear(handle); }
    static int persistence_containskey(void* handle, char* key)
    {
        return base::persistence_containskey(handle, key);
    }

    // "Open" the store
    void open(const std::string& clientId, const std::string& serverURI) override
    {
        open_ = true;
    }

    // Close the persistent store that was previously opened.
    void close() override { open_ = false; }

    // Clears persistence, so that it no longer contains any persisted data.
    void clear() override { store_.clear(); }

    // Returns whether or not data is persisted using the specified key.
    bool contains_key(const std::string& key) override
    {
        return store_.find(key) != store_.end();
    }

    // Returns the keys in this persistent data store.
    // This could be more efficient, but you get the point.
    mqtt::string_collection keys() const override
    {
        mqtt::string_collection ks;
        for (const auto& k : store_) ks.push_back(k.first);
        return ks;
    }

    // Puts the specified data into the persistent store.
    void put(const std::string& key, const std::vector<mqtt::string_view>& bufs) override
    {
        std::string str;
        for (const auto& b : bufs) str += b.str();
        store_[key] = std::move(str);
    }

    // Gets the specified data out of the persistent store.
    std::string get(const std::string& key) const override
    {
        auto p = store_.find(key);
        if (p == store_.end())
            throw mqtt::persistence_exception();
        return p->second;
    }

    // Remove the data for the specified key.
    void remove(const std::string& key) override
    {
        auto p = store_.find(key);
        if (p == store_.end())
            throw mqtt::persistence_exception();
        store_.erase(p);
    }
};

/////////////////////////////////////////////////////////////////////////////
// end namespace mqtt
}  // namespace mqtt

#endif  // __mqtt_mock_persistence_h

```

`test/unit/test_async_client.cpp`:

```cpp
// test_async_client.cpp
//
// Unit tests for the async_client class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2020-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 * Copyright (c) 2017 Guilherme M. Ferreira <guilherme.maciel.ferreira@gmail.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme M. Ferreira - initial implementation and documentation
 *    Frank Pagliughi - Converted to Catch2
 *******************************************************************************/
#define UNIT_TESTS

#include "catch2_version.h"
#include "mock_action_listener.h"
#include "mock_callback.h"
#include "mock_persistence.h"
#include "mqtt/async_client.h"
#include "mqtt/iasync_client.h"

using namespace mqtt;

/////////////////////////////////////////////////////////////////////////////

// NOTE: This test case requires network access. It uses one of
//  	 the public available MQTT brokers
#if defined(TEST_EXTERNAL_SERVER)
static const std::string GOOD_SERVER_URI{"tcp://mqtt.eclipseprojects.io:1883"};
static const std::string GOOD_SSL_SERVER_URI{"ssl://mqtt.eclipseprojects.io:1885"};
#else
static const std::string GOOD_SERVER_URI{"tcp://localhost:1883"};
static const std::string GOOD_SSL_SERVER_URI{"ssl://localhost:18885"};
#endif

static const std::string BAD_SERVER_URI{"one://invalid.address"};
static const std::string CLIENT_ID{"test_async_client"};
static const std::string TOPIC{"topic"};

static const persistence_type PERSISTENCE_DIR{"persist"};

static const int GOOD_QOS{0};
static const int BAD_QOS{3};
static const_string_collection_ptr TOPIC_COLL{
    string_collection::create({"topic0", "topic1", "topic2"})
};

static iasync_client::qos_collection GOOD_QOS_COLL{0, 1, 2};
static iasync_client::qos_collection BAD_QOS_COLL{BAD_QOS, 1, 2};

static const std::string PAYLOAD{"some payload"};
static const int TIMEOUT{1000};
static int CONTEXT{4};
static mock_action_listener listener;
static const bool RETAINED{false};

// Note: We could someday use this to generate client ID's to run
//    tests in parallel, keeping unique client ID's for each test
/*
static inline std::string test_client_id() {
    auto s = Catch::getResultCapture().getCurrentTestName();
    std::replace(s.begin(), s.end(), ' ', '_');
    return s.substr(0,22);
}
*/

//----------------------------------------------------------------------
// Test constructors async_client::async_client()
//----------------------------------------------------------------------

TEST_CASE("async_client user constructor 2 string_args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};

    REQUIRE(GOOD_SERVER_URI == cli.get_server_uri());
    REQUIRE(CLIENT_ID == cli.get_client_id());
}

TEST_CASE("async_client user constructor 2 string args failure", "[client]")
{
    int return_code = MQTTASYNC_SUCCESS;
    try {
        async_client cli{BAD_SERVER_URI, CLIENT_ID};
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_BAD_PROTOCOL == return_code);
}

TEST_CASE("async_client user constructor 3 string args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID, PERSISTENCE_DIR};

    REQUIRE(GOOD_SERVER_URI == cli.get_server_uri());
    REQUIRE(CLIENT_ID == cli.get_client_id());
}

TEST_CASE("async_client user constructor 3 args", "[client]")
{
    mock_persistence cp;
    async_client cli{GOOD_SERVER_URI, CLIENT_ID, &cp};

    REQUIRE(GOOD_SERVER_URI == cli.get_server_uri());
    REQUIRE(CLIENT_ID == cli.get_client_id());

    async_client cli_no_persistence{GOOD_SERVER_URI, CLIENT_ID, nullptr};

    REQUIRE(GOOD_SERVER_URI == cli_no_persistence.get_server_uri());
    REQUIRE(CLIENT_ID == cli_no_persistence.get_client_id());
}

//----------------------------------------------------------------------
// Test async_client::connect()
//----------------------------------------------------------------------

TEST_CASE("async_client connect 0 arg", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    try {
        token_ptr conn_tok = cli.connect();
        REQUIRE(conn_tok);
        conn_tok->wait();
        REQUIRE(cli.is_connected());
    }
    catch (const std::exception& exc) {
        FAIL(std::string("Connection failure: ") + exc.what());
    }
}

TEST_CASE("async_client connect 1 arg", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    connect_options co;
    token_ptr conn_tok{cli.connect(co)};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());
}

TEST_CASE("async_client connect 1 arg failure", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok;  //{ nullptr };
    connect_options co;
    will_options wo;
    wo.set_qos(BAD_QOS);  // Invalid QoS causes connection failure
    co.set_will(wo);
    int return_code = MQTTASYNC_SUCCESS;
    try {
        conn_tok = cli.connect(co);
        REQUIRE(conn_tok);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(nullptr == conn_tok);
    REQUIRE(!cli.is_connected());
    REQUIRE(MQTTASYNC_BAD_QOS == return_code);
}

TEST_CASE("async_client connect 2 args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    mock_action_listener listener;
    token_ptr conn_tok{cli.connect(&CONTEXT, listener)};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());
    REQUIRE(CONTEXT == *static_cast<int*>(conn_tok->get_user_context()));
    REQUIRE(listener.succeeded());
}

TEST_CASE("async_client connect 3 args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    connect_options co;
    mock_action_listener listener;
    token_ptr conn_tok{cli.connect(co, &CONTEXT, listener)};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());
    REQUIRE(CONTEXT == *static_cast<int*>(conn_tok->get_user_context()));
    REQUIRE(listener.succeeded());
}

TEST_CASE("async_client connect 3 args failure", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok;  //{ nullptr };
    connect_options co;
    will_options wo;
    wo.set_qos(BAD_QOS);  // Invalid QoS causes connection failure
    co.set_will(wo);
    mock_action_listener listener;
    int reasonCode = MQTTASYNC_SUCCESS;
    try {
        conn_tok = cli.connect(co, &CONTEXT, listener);
        REQUIRE(conn_tok);
        conn_tok->wait();
    }
    catch (mqtt::exception& ex) {
        reasonCode = ex.get_return_code();
    }
    REQUIRE(nullptr == conn_tok);
    REQUIRE(!cli.is_connected());
    REQUIRE(MQTTASYNC_BAD_QOS == reasonCode);
    // TODO Why listener.on_failure() is not called?
    // REQUIRE(listener.failed());
}

// An improperly initialized SSL connect request should fail gracefully
TEST_CASE("async_client connect uninitialized ssl", "[client]")
{
    int reasonCode = MQTTASYNC_SUCCESS;
    try {
        // Compiled against a non-SSL library should throw here.
        async_client cli{GOOD_SSL_SERVER_URI, CLIENT_ID};

        connect_options opts;
        opts.set_keep_alive_interval(10);
        opts.set_clean_session(true);
        // Note that we're not setting SSL options.

        token_ptr tok;

        // Compiled against the SSL library should throw here
        tok = cli.connect(opts);
        tok->wait();
    }
    catch (mqtt::exception& ex) {
        reasonCode = ex.get_return_code();
    }
    REQUIRE(reasonCode != MQTTASYNC_SUCCESS);
}

//----------------------------------------------------------------------
// Test async_client::disconnect()
//----------------------------------------------------------------------

TEST_CASE("async_client disconnect 0 arg", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok{cli.connect()};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    token_ptr disconn_tok{cli.disconnect()};
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("async_client disconnect 1 arg", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok{cli.connect()};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    token_ptr disconn_tok{cli.disconnect(0)};
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("async_client disconnect 1 arg failure", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr disconn_tok;  //{ nullptr };
    int return_code = MQTTASYNC_SUCCESS;
    try {
        disconn_tok = cli.disconnect(0);
        REQUIRE(disconn_tok);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(!cli.is_connected());
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

TEST_CASE("async_client disconnect 2 args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok{cli.connect()};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    mock_action_listener listener;
    token_ptr disconn_tok{cli.disconnect(&CONTEXT, listener)};
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
    REQUIRE(CONTEXT == *static_cast<int*>(disconn_tok->get_user_context()));
}

TEST_CASE("async_client disconnect 3 args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok{cli.connect()};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    mock_action_listener listener;
    token_ptr disconn_tok{cli.disconnect(0, &CONTEXT, listener)};
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
    REQUIRE(CONTEXT == *static_cast<int*>(disconn_tok->get_user_context()));
}

TEST_CASE("async_client disconnect 3 args failure", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr disconn_tok;  //{ nullptr };
    mock_action_listener listener;
    int return_code = MQTTASYNC_SUCCESS;
    try {
        disconn_tok = cli.disconnect(0, &CONTEXT, listener);
        REQUIRE(disconn_tok);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(!cli.is_connected());
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

//----------------------------------------------------------------------
// Test async_client::get_pending_delivery_token()
//----------------------------------------------------------------------

TEST_CASE("async_client get pending delivery token", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    REQUIRE(0 == GOOD_QOS_COLL[0]);
    REQUIRE(1 == GOOD_QOS_COLL[1]);
    REQUIRE(2 == GOOD_QOS_COLL[2]);

    token_ptr conn_tok{cli.connect()};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    // NOTE: async_client::publish() is the only method that adds
    // delivery_token via async_client::add_token(delivery_token_ptr tok).
    // The other functions add token async_client::add_token(token_ptr tok).

    delivery_token_ptr token_pub;      // { nullptr };
    delivery_token_ptr token_pending;  // { nullptr };

    // NOTE: message IDs are 16-bit numbers sequentially incremented, from
    // 1 to 65535 (MAX_MSG_ID). See MQTTAsync_assignMsgId() at Paho MQTT C.
    int message_id = 1;

    // NOTE: All of the MQTT messages that require a response/acknowledge
    // should have a non-zero 16-bit message ID. This mainly applies to a
    // message with QOS=1 or QOS=2. The C++ library keeps a collection of
    // pointers to token objects for all of these messages that are in
    // flight. When the acknowledge comes back from the broker, the C++
    // library can look up the token from the msgID and signal it, indicating
    // completion.

    // Messages with QOS=2 are kept by the library
    message_ptr msg2{message::create(TOPIC, PAYLOAD, GOOD_QOS_COLL[2], RETAINED)};
    token_pub = cli.publish(msg2);
    REQUIRE(token_pub);
    token_pending = cli.get_pending_delivery_token(message_id++);
    REQUIRE(token_pending);

    // Messages with QOS=1 are kept by the library
    message_ptr msg1{message::create(TOPIC, PAYLOAD, GOOD_QOS_COLL[1], RETAINED)};
    token_pub = cli.publish(msg1);
    REQUIRE(token_pub);
    token_pending = cli.get_pending_delivery_token(message_id++);
    REQUIRE(token_pending);

    // NOTE: Messages with QOS=0 are fire-and-forget. These just get sent
    // to the broker without any tracking. Their tokens are signaled as
    // "complete" in the send function (by the calling thread).  So, as
    // soon as send returns, the message is considered completed. These
    // have a msgID that is always zero.

    // Messages with QOS=0 are NOT kept by the library
    message_ptr msg0{message::create(TOPIC, PAYLOAD, GOOD_QOS_COLL[0], RETAINED)};
    token_pub = cli.publish(msg0);
    REQUIRE(token_pub);
    token_pending = cli.get_pending_delivery_token(message_id++);
    REQUIRE(!token_pending);

    token_ptr disconn_tok{cli.disconnect()};
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("async_client get pending delivery tokens", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    REQUIRE(0 == GOOD_QOS_COLL[0]);
    REQUIRE(1 == GOOD_QOS_COLL[1]);
    REQUIRE(2 == GOOD_QOS_COLL[2]);

    token_ptr conn_tok{cli.connect()};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    delivery_token_ptr token_pub;  // { nullptr };

    // NOTE: async_client::publish() is the only method that adds
    // delivery_token via async_client::add_token(delivery_token_ptr tok).
    // The other functions add token async_client::add_token(token_ptr tok).

    // Messages with QOS=0 are NOT kept by the library
    message_ptr msg0{message::create(TOPIC, PAYLOAD, GOOD_QOS_COLL[0], RETAINED)};
    token_pub = cli.publish(msg0);
    REQUIRE(token_pub);

    // Messages with QOS=1 are kept by the library
    message_ptr msg1{message::create(TOPIC, PAYLOAD, GOOD_QOS_COLL[1], RETAINED)};
    token_pub = cli.publish(msg1);
    REQUIRE(token_pub);

    // Messages with QOS=2 are kept by the library
    message_ptr msg2{message::create(TOPIC, PAYLOAD, GOOD_QOS_COLL[2], RETAINED)};
    token_pub = cli.publish(msg2);
    REQUIRE(token_pub);

    // NOTE: Only tokens for messages with QOS=1 and QOS=2 are kept. That's
    // why the vector's size does not account for QOS=0 message tokens
    std::vector<delivery_token_ptr> tokens_pending{cli.get_pending_delivery_tokens()};
    REQUIRE(2 == static_cast<int>(tokens_pending.size()));

    token_ptr disconn_tok{cli.disconnect()};
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

//----------------------------------------------------------------------
// Test async_client::publish()
//----------------------------------------------------------------------

TEST_CASE("async_client publish 2 args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok{cli.connect()};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    message_ptr msg{message::create(TOPIC, PAYLOAD)};
    delivery_token_ptr token_pub{cli.publish(msg)};
    REQUIRE(token_pub);
    token_pub->wait_for(TIMEOUT);

    token_ptr disconn_tok{cli.disconnect()};
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("async_client publish 2 args failure", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    int return_code = MQTTASYNC_SUCCESS;
    try {
        message_ptr msg{message::create(TOPIC, PAYLOAD)};
        delivery_token_ptr token_pub{cli.publish(msg)};
        REQUIRE(token_pub);
        token_pub->wait_for(TIMEOUT);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

TEST_CASE("async_client publish 4 args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok{cli.connect()};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    message_ptr msg{message::create(TOPIC, PAYLOAD)};
    mock_action_listener listener;
    delivery_token_ptr token_pub{cli.publish(msg, &CONTEXT, listener)};
    REQUIRE(token_pub);
    token_pub->wait_for(TIMEOUT);
    REQUIRE(CONTEXT == *static_cast<int*>(token_pub->get_user_context()));

    token_ptr disconn_tok{cli.disconnect()};
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("async_client publish 4 args failure", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    int return_code = MQTTASYNC_SUCCESS;
    try {
        message_ptr msg{message::create(TOPIC, PAYLOAD)};
        mock_action_listener listener;
        delivery_token_ptr token_pub{cli.publish(msg, &CONTEXT, listener)};
        REQUIRE(token_pub);
        token_pub->wait_for(TIMEOUT);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

TEST_CASE("async_client publish 5 args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok{cli.connect()};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    const void* payload{PAYLOAD.data()};
    const size_t payload_size{PAYLOAD.size()};
    delivery_token_ptr token_pub{cli.publish(TOPIC, payload, payload_size, GOOD_QOS, RETAINED)
    };
    REQUIRE(token_pub);
    token_pub->wait_for(TIMEOUT);

    token_ptr disconn_tok{cli.disconnect()};
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("async_client publish 7 args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok{cli.connect()};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    const void* payload{PAYLOAD.c_str()};
    const size_t payload_size{PAYLOAD.size()};
    mock_action_listener listener;
    delivery_token_ptr token_pub{
        cli.publish(TOPIC, payload, payload_size, GOOD_QOS, RETAINED, &CONTEXT, listener)
    };
    REQUIRE(token_pub);
    token_pub->wait_for(TIMEOUT);
    REQUIRE(CONTEXT == *static_cast<int*>(token_pub->get_user_context()));

    token_ptr disconn_tok{cli.disconnect()};
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

//----------------------------------------------------------------------
// Test async_client::set_callback()
//----------------------------------------------------------------------

TEST_CASE("async_client set callback", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    mock_callback cb;
    cli.set_callback(cb);

    // REQUIRE(cb.delivery_complete_called);
}

//----------------------------------------------------------------------
// Test async_client::subscribe()
//----------------------------------------------------------------------

TEST_CASE("async_client subscribe single topic 2 args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok{cli.connect()};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    token_ptr sub_tok{cli.subscribe(TOPIC, GOOD_QOS)};
    REQUIRE(sub_tok);
    sub_tok->wait_for(TIMEOUT);

    token_ptr disconn_tok{cli.disconnect()};
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("async_client subscribe single topic 2 args failure", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    int return_code = MQTTASYNC_SUCCESS;
    try {
        token_ptr sub_tok{cli.subscribe(TOPIC, BAD_QOS)};
        REQUIRE(sub_tok);
        sub_tok->wait_for(TIMEOUT);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

TEST_CASE("async_client subscribe single topic 4 args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok{cli.connect()};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    mock_action_listener listener;
    token_ptr sub_tok{cli.subscribe(TOPIC, GOOD_QOS, &CONTEXT, listener)};
    REQUIRE(sub_tok);
    sub_tok->wait_for(TIMEOUT);
    REQUIRE(CONTEXT == *static_cast<int*>(sub_tok->get_user_context()));

    token_ptr disconn_tok{cli.disconnect()};
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("async_client subscribe single topic 4 args failure", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    int return_code = MQTTASYNC_SUCCESS;
    try {
        mock_action_listener listener;
        token_ptr sub_tok{cli.subscribe(TOPIC, BAD_QOS, &CONTEXT, listener)};
        REQUIRE(sub_tok);
        sub_tok->wait_for(TIMEOUT);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

TEST_CASE("async_client subscribe many topics 2 args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    cli.connect()->wait();
    REQUIRE(cli.is_connected());

    try {
        cli.subscribe(TOPIC_COLL, GOOD_QOS_COLL)->wait_for(TIMEOUT);
    }
    catch (const mqtt::exception& exc) {
        FAIL(exc.what());
    }

    token_ptr disconn_tok{cli.disconnect()};
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

// There was an odd failure when subscribe_many was given a single topic.
TEST_CASE("async_client subscribe many topics 2 args_single", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    cli.connect()->wait();
    REQUIRE(cli.is_connected());

    mqtt::const_string_collection_ptr TOPIC_1_COLL{mqtt::string_collection::create({"TOPIC0"})
    };
    iasync_client::qos_collection GOOD_QOS_1_COLL{0};
    try {
        cli.subscribe(TOPIC_1_COLL, GOOD_QOS_1_COLL)->wait_for(TIMEOUT);
    }
    catch (const mqtt::exception& exc) {
        FAIL(exc.what());
    }

    token_ptr disconn_tok{cli.disconnect()};
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("async_client subscribe many topics 2 args failure", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    try {
        token_ptr sub_tok{cli.subscribe(TOPIC_COLL, BAD_QOS_COLL)};
        REQUIRE(sub_tok);
        sub_tok->wait_for(TIMEOUT);
    }
    catch (const mqtt::exception& /*ex*/) {
        // REQUIRE(MQTTASYNC_BAD_QOS == ex.get_return_code());
    }

    int return_code = MQTTASYNC_SUCCESS;
    try {
        token_ptr sub_tok{cli.subscribe(TOPIC_COLL, GOOD_QOS_COLL)};
        REQUIRE(sub_tok);
        sub_tok->wait_for(TIMEOUT);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

TEST_CASE("async_client subscribe many topics 4 args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok{cli.connect()};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    mock_action_listener listener;
    token_ptr sub_tok{cli.subscribe(TOPIC_COLL, GOOD_QOS_COLL, &CONTEXT, listener)};
    REQUIRE(sub_tok);
    sub_tok->wait_for(TIMEOUT);
    REQUIRE(CONTEXT == *static_cast<int*>(sub_tok->get_user_context()));

    token_ptr disconn_tok{cli.disconnect()};
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("async_client subscribe many topics 4 args failure", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    mock_action_listener listener;

    try {
        cli.subscribe(TOPIC_COLL, BAD_QOS_COLL, &CONTEXT, listener)->wait_for(TIMEOUT);
    }
    catch (const mqtt::exception& /*ex*/) {
        // REQUIRE(MQTTASYNC_BAD_QOS == ex.get_return_code());
    }

    int return_code = MQTTASYNC_SUCCESS;
    try {
        token_ptr sub_tok{cli.subscribe(TOPIC_COLL, GOOD_QOS_COLL, &CONTEXT, listener)};
        REQUIRE(sub_tok);
        sub_tok->wait_for(TIMEOUT);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

//----------------------------------------------------------------------
// Test async_client::unsubscribe()
//----------------------------------------------------------------------

TEST_CASE("async_client unsubscribe single topic 1 arg", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok = cli.connect();
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    token_ptr sub_tok = cli.subscribe(TOPIC, 1);
    REQUIRE(sub_tok);
    sub_tok->wait_for(TIMEOUT);

    token_ptr unsub_tok = cli.unsubscribe(TOPIC);
    REQUIRE(unsub_tok);
    sub_tok->wait_for(TIMEOUT);

    token_ptr disconn_tok = cli.disconnect();
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("async_client unsubscribe single topic 1 arg failure", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    int return_code = MQTTASYNC_SUCCESS;
    try {
        token_ptr unsub_tok{cli.unsubscribe(TOPIC)};
        REQUIRE(unsub_tok);
        unsub_tok->wait_for(TIMEOUT);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

TEST_CASE("async_client unsubscribe single topic 3 args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok = cli.connect();
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    token_ptr sub_tok = cli.subscribe(TOPIC, 1);
    REQUIRE(sub_tok);
    sub_tok->wait_for(TIMEOUT);

    mock_action_listener listener;
    token_ptr unsub_tok = cli.unsubscribe(TOPIC, &CONTEXT, listener);
    REQUIRE(unsub_tok);
    unsub_tok->wait_for(TIMEOUT);
    REQUIRE(CONTEXT == *static_cast<int*>(unsub_tok->get_user_context()));

    token_ptr disconn_tok = cli.disconnect();
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("async_client unsubscribe single topic 3 args failure", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    int return_code = MQTTASYNC_SUCCESS;
    try {
        mock_action_listener listener;
        token_ptr unsub_tok{cli.unsubscribe(TOPIC, &CONTEXT, listener)};
        REQUIRE(unsub_tok);
        unsub_tok->wait_for(TIMEOUT);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

TEST_CASE("async_client unsubscribe many topics 1 arg", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok = cli.connect();
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    token_ptr sub_tok = cli.subscribe(TOPIC_COLL, GOOD_QOS_COLL);
    REQUIRE(sub_tok);
    sub_tok->wait_for(TIMEOUT);

    token_ptr unsub_tok = cli.unsubscribe(TOPIC_COLL);
    REQUIRE(unsub_tok);
    unsub_tok->wait_for(TIMEOUT);

    token_ptr disconn_tok = cli.disconnect();
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("async_client unsubscribe many topics 1 arg_failure", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    int return_code = MQTTASYNC_SUCCESS;
    try {
        token_ptr unsub_tok{cli.unsubscribe(TOPIC_COLL)};
        REQUIRE(unsub_tok);
        unsub_tok->wait_for(TIMEOUT);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

TEST_CASE("async_client unsubscribe many topics 3 args", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    token_ptr conn_tok = cli.connect();
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());

    token_ptr sub_tok = cli.subscribe(TOPIC_COLL, GOOD_QOS_COLL);
    REQUIRE(sub_tok);
    sub_tok->wait_for(TIMEOUT);

    mock_action_listener listener;
    token_ptr unsub_tok = cli.unsubscribe(TOPIC_COLL, &CONTEXT, listener);
    REQUIRE(unsub_tok);
    unsub_tok->wait_for(TIMEOUT);
    REQUIRE(CONTEXT == *static_cast<int*>(unsub_tok->get_user_context()));

    token_ptr disconn_tok = cli.disconnect();
    REQUIRE(disconn_tok);
    disconn_tok->wait();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("async_client unsubscribe many topics 3 args failure", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    mock_action_listener listener;
    int return_code = MQTTASYNC_SUCCESS;
    try {
        token_ptr unsub_tok{cli.unsubscribe(TOPIC_COLL, &CONTEXT, listener)};
        REQUIRE(unsub_tok);
        unsub_tok->wait_for(TIMEOUT);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

TEST_CASE("async_client consumer timeout", "[client]")
{
    // This just compiling shows #343 fixed.
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    cli.start_consuming();
    cli.try_consume_message_until(std::chrono::steady_clock::now());
}

TEST_CASE("async_client consumer queue size", "[client]")
{
    async_client cli{GOOD_SERVER_URI, CLIENT_ID};
    cli.start_consuming();
    REQUIRE(0 == cli.consumer_queue_size());

    token_ptr conn_tok{cli.connect()};
    REQUIRE(conn_tok);
    conn_tok->wait();
    REQUIRE(cli.is_connected());
    // expect connected_event to be in the queue now
    REQUIRE(1 == cli.consumer_queue_size());
    event e;
    REQUIRE(cli.try_consume_event(&e));
    REQUIRE(0 == cli.consumer_queue_size());

    cli.stop_consuming();
    cli.disconnect()->wait();
}

```

`test/unit/test_async_client_v3.cpp`:

```cpp
// async_client_v3_test.h
//
// Unit tests for the MQTT v3 async_client class in the Paho MQTT C++
// library.

/*******************************************************************************
 * Copyright (c) 2017 Guilherme M. Ferreira <guilherme.maciel.ferreira@gmail.com>
 * Copyright (c) 2019 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme M. Ferreira - initial implementation and documentation
 *    Frank Pagliughi - updates
 *******************************************************************************/

#ifndef __mqtt_async_client_v3_test_h
#define __mqtt_async_client_v3_test_h

#include <cppunit/extensions/HelperMacros.h>
#include <cppunit/ui/text/TestRunner.h>

#include <stdexcept>
#include <vector>

#include "dummy_action_listener.h"
#include "dummy_callback.h"
#include "dummy_client_persistence.h"
#include "mqtt/async_client.h"
#include "mqtt/iasync_client.h"

namespace mqtt {

/////////////////////////////////////////////////////////////////////////////

class async_client_v3_test : public CppUnit::TestFixture
{
    CPPUNIT_TEST_SUITE(async_client_test);

    CPPUNIT_TEST(test_user_constructor_2_string_args);
    CPPUNIT_TEST(test_user_constructor_3_string_args);
    CPPUNIT_TEST(test_user_constructor_3_args);

    CPPUNIT_TEST(test_connect_0_arg);
    CPPUNIT_TEST(test_connect_1_arg);
    CPPUNIT_TEST(test_connect_1_arg_failure);
    CPPUNIT_TEST(test_connect_2_args);
    CPPUNIT_TEST(test_connect_3_args);
    CPPUNIT_TEST(test_connect_3_args_failure);
    CPPUNIT_TEST(test_connect_uninitialized_ssl);

    CPPUNIT_TEST(test_disconnect_0_arg);
    CPPUNIT_TEST(test_disconnect_1_arg);
    CPPUNIT_TEST(test_disconnect_1_arg_failure);
    CPPUNIT_TEST(test_disconnect_2_args);
    CPPUNIT_TEST(test_disconnect_3_args);
    CPPUNIT_TEST(test_disconnect_3_args_failure);

    CPPUNIT_TEST(test_get_pending_delivery_token);
    CPPUNIT_TEST(test_get_pending_delivery_tokens);

    CPPUNIT_TEST(test_publish_2_args);
    CPPUNIT_TEST(test_publish_2_args_failure);
    CPPUNIT_TEST(test_publish_4_args);
    CPPUNIT_TEST(test_publish_4_args_failure);
    CPPUNIT_TEST(test_publish_5_args);
    CPPUNIT_TEST(test_publish_7_args);

    CPPUNIT_TEST(test_set_callback);

    CPPUNIT_TEST(test_subscribe_single_topic_2_args);
    CPPUNIT_TEST(test_subscribe_single_topic_2_args_failure);
    CPPUNIT_TEST(test_subscribe_single_topic_4_args);
    CPPUNIT_TEST(test_subscribe_single_topic_4_args_failure);
    CPPUNIT_TEST(test_subscribe_many_topics_2_args);
    CPPUNIT_TEST(test_subscribe_many_topics_2_args_failure);
    CPPUNIT_TEST(test_subscribe_many_topics_4_args);
    CPPUNIT_TEST(test_subscribe_many_topics_4_args_failure);

    CPPUNIT_TEST(test_unsubscribe_single_topic_1_arg);
    CPPUNIT_TEST(test_unsubscribe_single_topic_1_arg_failure);
    CPPUNIT_TEST(test_unsubscribe_single_topic_3_args);
    CPPUNIT_TEST(test_unsubscribe_single_topic_3_args_failure);
    CPPUNIT_TEST(test_unsubscribe_many_topics_1_arg);
    CPPUNIT_TEST(test_unsubscribe_many_topics_1_arg_failure);
    CPPUNIT_TEST(test_unsubscribe_many_topics_3_args);
    CPPUNIT_TEST(test_unsubscribe_many_topics_3_args_failure);

    CPPUNIT_TEST_SUITE_END();

// NOTE: This test case requires network access. It uses one of
//  	 the public available MQTT brokers
#if defined(TEST_EXTERNAL_SERVER)
    const std::string GOOD_SERVER_URI{"tcp://mqtt.eclipseprojects.io:1883"};
#else
    const std::string GOOD_SERVER_URI{"tcp://localhost:1883"};
    const std::string GOOD_SSL_SERVER_URI{"ssl://localhost:18885"};
#endif
    const std::string BAD_SERVER_URI{"one://invalid.address"};
    const std::string CLIENT_ID{""};  // { "async_client_unit_test" };
    const std::string PERSISTENCE_DIR{"/tmp"};
    const std::string TOPIC{"TOPIC"};
    const int GOOD_QOS{0};
    const int BAD_QOS{3};
    const_string_collection_ptr TOPIC_COLL{
        string_collection::create({"TOPIC0", "TOPIC1", "TOPIC2"})
    };
    mqtt::iasync_client::qos_collection GOOD_QOS_COLL{0, 1, 2};
    mqtt::iasync_client::qos_collection BAD_QOS_COLL{BAD_QOS, 1, 2};
    const std::string PAYLOAD{"PAYLOAD"};
    const int TIMEOUT{1000};
    int CONTEXT{4};
    mqtt::test::dummy_action_listener listener;
    const bool RETAINED{false};

public:
    void setUp() {}
    void tearDown() {}

    //----------------------------------------------------------------------
    // Test constructors async_client::async_client()
    //----------------------------------------------------------------------

    void test_user_constructor_2_string_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};

        CPPUNIT_ASSERT_EQUAL(GOOD_SERVER_URI, cli.get_server_uri());
        CPPUNIT_ASSERT_EQUAL(CLIENT_ID, cli.get_client_id());
    }

    void test_user_constructor_2_string_args_failure()
    {
        int reason_code = MQTTASYNC_SUCCESS;
        try {
            mqtt::async_client cli{BAD_SERVER_URI, CLIENT_ID};
        }
        catch (mqtt::exception& ex) {
            reason_code = ex.get_reason_code();
        }
        CPPUNIT_ASSERT_EQUAL(MQTTASYNC_BAD_PROTOCOL, reason_code);
    }

    void test_user_constructor_3_string_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID, PERSISTENCE_DIR};

        CPPUNIT_ASSERT_EQUAL(GOOD_SERVER_URI, cli.get_server_uri());
        CPPUNIT_ASSERT_EQUAL(CLIENT_ID, cli.get_client_id());
    }

    void test_user_constructor_3_args()
    {
        mqtt::test::dummy_client_persistence cp;
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID, &cp};

        CPPUNIT_ASSERT_EQUAL(GOOD_SERVER_URI, cli.get_server_uri());
        CPPUNIT_ASSERT_EQUAL(CLIENT_ID, cli.get_client_id());

        mqtt::async_client cli_no_persistence{GOOD_SERVER_URI, CLIENT_ID, nullptr};

        CPPUNIT_ASSERT_EQUAL(GOOD_SERVER_URI, cli_no_persistence.get_server_uri());
        CPPUNIT_ASSERT_EQUAL(CLIENT_ID, cli_no_persistence.get_client_id());
    }

    //----------------------------------------------------------------------
    // Test async_client::connect()
    //----------------------------------------------------------------------

    void test_connect_0_arg()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        try {
            mqtt::token_ptr token_conn = cli.connect();
            CPPUNIT_ASSERT(token_conn);
            token_conn->wait();
            CPPUNIT_ASSERT(cli.is_connected());
        }
        catch (const std::exception& exc) {
            CPPUNIT_FAIL(std::string("Connection failure: ") + exc.what());
        }
    }

    void test_connect_1_arg()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::connect_options co;
        mqtt::token_ptr token_conn{cli.connect(co)};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());
    }

    void test_connect_1_arg_failure()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn;  //{ nullptr };
        mqtt::connect_options co;
        mqtt::will_options wo;
        wo.set_qos(BAD_QOS);  // Invalid QoS causes connection failure
        co.set_will(wo);
        int reason_code = MQTTASYNC_SUCCESS;
        try {
            token_conn = cli.connect(co);
            CPPUNIT_ASSERT(token_conn);
        }
        catch (mqtt::exception& ex) {
            reason_code = ex.get_reason_code();
        }
        CPPUNIT_ASSERT(nullptr == token_conn);
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
        CPPUNIT_ASSERT_EQUAL(MQTTASYNC_BAD_QOS, reason_code);
    }

    void test_connect_2_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::test::dummy_action_listener listener;
        mqtt::token_ptr token_conn{cli.connect(&CONTEXT, listener)};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());
        CPPUNIT_ASSERT_EQUAL(CONTEXT, *static_cast<int*>(token_conn->get_user_context()));
        CPPUNIT_ASSERT(listener.on_success_called);
    }

    void test_connect_3_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::connect_options co;
        mqtt::test::dummy_action_listener listener;
        mqtt::token_ptr token_conn{cli.connect(co, &CONTEXT, listener)};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());
        CPPUNIT_ASSERT_EQUAL(CONTEXT, *static_cast<int*>(token_conn->get_user_context()));
        CPPUNIT_ASSERT(listener.on_success_called);
    }

    void test_connect_3_args_failure()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn;  //{ nullptr };
        mqtt::connect_options co;
        mqtt::will_options wo;
        wo.set_qos(BAD_QOS);  // Invalid QoS causes connection failure
        co.set_will(wo);
        mqtt::test::dummy_action_listener listener;
        int reasonCode = MQTTASYNC_SUCCESS;
        try {
            token_conn = cli.connect(co, &CONTEXT, listener);
            CPPUNIT_ASSERT(token_conn);
            token_conn->wait();
        }
        catch (mqtt::exception& ex) {
            reasonCode = ex.get_reason_code();
        }
        CPPUNIT_ASSERT(nullptr == token_conn);
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
        CPPUNIT_ASSERT_EQUAL(MQTTASYNC_BAD_QOS, reasonCode);
        // TODO Why listener.on_failure() is not called?
        // CPPUNIT_ASSERT(listener.on_failure_called);
    }

    // An improperly initialized SSL connect request should fail gracefully
    void test_connect_uninitialized_ssl()
    {
        int reasonCode = MQTTASYNC_SUCCESS;
        try {
            // Compiled against a non-SSL library should throw here.
            mqtt::async_client cli{GOOD_SSL_SERVER_URI, CLIENT_ID};

            mqtt::connect_options opts;
            opts.set_keep_alive_interval(10);
            opts.set_clean_session(true);
            // Note that we're not setting SSL options.

            mqtt::token_ptr tok;

            // Compiled against the SSL library should throw here
            tok = cli.connect(opts);
            tok->wait();
        }
        catch (mqtt::exception& ex) {
            reasonCode = ex.get_reason_code();
        }
        CPPUNIT_ASSERT(reasonCode != MQTTASYNC_SUCCESS);
    }

    //----------------------------------------------------------------------
    // Test async_client::disconnect()
    //----------------------------------------------------------------------

    void test_disconnect_0_arg()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        mqtt::token_ptr token_disconn{cli.disconnect()};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    void test_disconnect_1_arg()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        mqtt::token_ptr token_disconn{cli.disconnect(0)};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    void test_disconnect_1_arg_failure()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_disconn;  //{ nullptr };
        int reason_code = MQTTASYNC_SUCCESS;
        try {
            token_disconn = cli.disconnect(0);
            CPPUNIT_ASSERT(token_disconn);
        }
        catch (mqtt::exception& ex) {
            reason_code = ex.get_reason_code();
        }
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
        CPPUNIT_ASSERT_EQUAL(MQTTASYNC_DISCONNECTED, reason_code);
    }

    void test_disconnect_2_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        mqtt::test::dummy_action_listener listener;
        mqtt::token_ptr token_disconn{cli.disconnect(&CONTEXT, listener)};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
        CPPUNIT_ASSERT_EQUAL(CONTEXT, *static_cast<int*>(token_disconn->get_user_context()));
    }

    void test_disconnect_3_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        mqtt::test::dummy_action_listener listener;
        mqtt::token_ptr token_disconn{cli.disconnect(0, &CONTEXT, listener)};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
        CPPUNIT_ASSERT_EQUAL(CONTEXT, *static_cast<int*>(token_disconn->get_user_context()));
    }

    void test_disconnect_3_args_failure()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_disconn;  //{ nullptr };
        mqtt::test::dummy_action_listener listener;
        int reason_code = MQTTASYNC_SUCCESS;
        try {
            token_disconn = cli.disconnect(0, &CONTEXT, listener);
            CPPUNIT_ASSERT(token_disconn);
        }
        catch (mqtt::exception& ex) {
            reason_code = ex.get_reason_code();
        }
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
        CPPUNIT_ASSERT_EQUAL(MQTTASYNC_DISCONNECTED, reason_code);
    }

    //----------------------------------------------------------------------
    // Test async_client::get_pending_delivery_token()
    //----------------------------------------------------------------------

    void test_get_pending_delivery_token()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        CPPUNIT_ASSERT_EQUAL(0, GOOD_QOS_COLL[0]);
        CPPUNIT_ASSERT_EQUAL(1, GOOD_QOS_COLL[1]);
        CPPUNIT_ASSERT_EQUAL(2, GOOD_QOS_COLL[2]);

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        // NOTE: async_client::publish() is the only method that adds
        // delivery_token via async_client::add_token(delivery_token_ptr tok).
        // The other functions add token async_client::add_token(token_ptr tok).

        mqtt::delivery_token_ptr token_pub;      // { nullptr };
        mqtt::delivery_token_ptr token_pending;  // { nullptr };

        // NOTE: message IDs are 16-bit numbers sequentially incremented, from
        // 1 to 65535 (MAX_MSG_ID). See MQTTAsync_assignMsgId() at Paho MQTT C.
        int message_id = 1;

        // NOTE: All of the MQTT messages that require a response/acknowledge
        // should have a non-zero 16-bit message ID. This mainly applies to a
        // message with QOS=1 or QOS=2. The C++ library keeps a collection of
        // pointers to token objects for all of these messages that are in
        // flight. When the acknowledge comes back from the broker, the C++
        // library can look up the token from the msgID and signal it, indicating
        // completion.

        // Messages with QOS=2 are kept by the library
        mqtt::message_ptr msg2{
            mqtt::message::create(TOPIC, PAYLOAD, GOOD_QOS_COLL[2], RETAINED)
        };
        token_pub = cli.publish(msg2);
        CPPUNIT_ASSERT(token_pub);
        token_pending = cli.get_pending_delivery_token(message_id++);
        CPPUNIT_ASSERT(token_pending);

        // Messages with QOS=1 are kept by the library
        mqtt::message_ptr msg1{
            mqtt::message::create(TOPIC, PAYLOAD, GOOD_QOS_COLL[1], RETAINED)
        };
        token_pub = cli.publish(msg1);
        CPPUNIT_ASSERT(token_pub);
        token_pending = cli.get_pending_delivery_token(message_id++);
        CPPUNIT_ASSERT(token_pending);

        // NOTE: Messages with QOS=0 are fire-and-forget. These just get sent
        // to the broker without any tracking. Their tokens are signaled as
        // "complete" in the send function (by the calling thread).  So, as
        // soon as send returns, the message is considered completed. These
        // have a msgID that is always zero.

        // Messages with QOS=0 are NOT kept by the library
        mqtt::message_ptr msg0{
            mqtt::message::create(TOPIC, PAYLOAD, GOOD_QOS_COLL[0], RETAINED)
        };
        token_pub = cli.publish(msg0);
        CPPUNIT_ASSERT(token_pub);
        token_pending = cli.get_pending_delivery_token(message_id++);
        CPPUNIT_ASSERT(!token_pending);

        mqtt::token_ptr token_disconn{cli.disconnect()};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    void test_get_pending_delivery_tokens()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        CPPUNIT_ASSERT_EQUAL(0, GOOD_QOS_COLL[0]);
        CPPUNIT_ASSERT_EQUAL(1, GOOD_QOS_COLL[1]);
        CPPUNIT_ASSERT_EQUAL(2, GOOD_QOS_COLL[2]);

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        mqtt::delivery_token_ptr token_pub;  // { nullptr };

        // NOTE: async_client::publish() is the only method that adds
        // delivery_token via async_client::add_token(delivery_token_ptr tok).
        // The other functions add token async_client::add_token(token_ptr tok).

        // Messages with QOS=0 are NOT kept by the library
        mqtt::message_ptr msg0{
            mqtt::message::create(TOPIC, PAYLOAD, GOOD_QOS_COLL[0], RETAINED)
        };
        token_pub = cli.publish(msg0);
        CPPUNIT_ASSERT(token_pub);

        // Messages with QOS=1 are kept by the library
        mqtt::message_ptr msg1{
            mqtt::message::create(TOPIC, PAYLOAD, GOOD_QOS_COLL[1], RETAINED)
        };
        token_pub = cli.publish(msg1);
        CPPUNIT_ASSERT(token_pub);

        // Messages with QOS=2 are kept by the library
        mqtt::message_ptr msg2{
            mqtt::message::create(TOPIC, PAYLOAD, GOOD_QOS_COLL[2], RETAINED)
        };
        token_pub = cli.publish(msg2);
        CPPUNIT_ASSERT(token_pub);

        // NOTE: Only tokens for messages with QOS=1 and QOS=2 are kept. That's
        // why the vector's size does not account for QOS=0 message tokens
        std::vector<mqtt::delivery_token_ptr> tokens_pending{cli.get_pending_delivery_tokens()
        };
        CPPUNIT_ASSERT_EQUAL(2, static_cast<int>(tokens_pending.size()));

        mqtt::token_ptr token_disconn{cli.disconnect()};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    //----------------------------------------------------------------------
    // Test async_client::publish()
    //----------------------------------------------------------------------

    void test_publish_2_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        mqtt::message_ptr msg{mqtt::message::create(TOPIC, PAYLOAD)};
        mqtt::delivery_token_ptr token_pub{cli.publish(msg)};
        CPPUNIT_ASSERT(token_pub);
        token_pub->wait_for(TIMEOUT);

        mqtt::token_ptr token_disconn{cli.disconnect()};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    void test_publish_2_args_failure()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        int reason_code = MQTTASYNC_SUCCESS;
        try {
            mqtt::message_ptr msg{mqtt::message::create(TOPIC, PAYLOAD)};
            mqtt::delivery_token_ptr token_pub{cli.publish(msg)};
            CPPUNIT_ASSERT(token_pub);
            token_pub->wait_for(TIMEOUT);
        }
        catch (mqtt::exception& ex) {
            reason_code = ex.get_reason_code();
        }
        CPPUNIT_ASSERT_EQUAL(MQTTASYNC_DISCONNECTED, reason_code);
    }

    void test_publish_4_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        mqtt::message_ptr msg{mqtt::message::create(TOPIC, PAYLOAD)};
        mqtt::test::dummy_action_listener listener;
        mqtt::delivery_token_ptr token_pub{cli.publish(msg, &CONTEXT, listener)};
        CPPUNIT_ASSERT(token_pub);
        token_pub->wait_for(TIMEOUT);
        CPPUNIT_ASSERT_EQUAL(CONTEXT, *static_cast<int*>(token_pub->get_user_context()));

        mqtt::token_ptr token_disconn{cli.disconnect()};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    void test_publish_4_args_failure()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        int reason_code = MQTTASYNC_SUCCESS;
        try {
            mqtt::message_ptr msg{mqtt::message::create(TOPIC, PAYLOAD)};
            mqtt::test::dummy_action_listener listener;
            mqtt::delivery_token_ptr token_pub{cli.publish(msg, &CONTEXT, listener)};
            CPPUNIT_ASSERT(token_pub);
            token_pub->wait_for(TIMEOUT);
        }
        catch (mqtt::exception& ex) {
            reason_code = ex.get_reason_code();
        }
        CPPUNIT_ASSERT_EQUAL(MQTTASYNC_DISCONNECTED, reason_code);
    }

    void test_publish_5_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        const void* payload{PAYLOAD.data()};
        const size_t payload_size{PAYLOAD.size()};
        mqtt::delivery_token_ptr token_pub{
            cli.publish(TOPIC, payload, payload_size, GOOD_QOS, RETAINED)
        };
        CPPUNIT_ASSERT(token_pub);
        token_pub->wait_for(TIMEOUT);

        mqtt::token_ptr token_disconn{cli.disconnect()};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    void test_publish_7_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        const void* payload{PAYLOAD.c_str()};
        const size_t payload_size{PAYLOAD.size()};
        mqtt::test::dummy_action_listener listener;
        mqtt::delivery_token_ptr token_pub{
            cli.publish(TOPIC, payload, payload_size, GOOD_QOS, RETAINED, &CONTEXT, listener)
        };
        CPPUNIT_ASSERT(token_pub);
        token_pub->wait_for(TIMEOUT);
        CPPUNIT_ASSERT_EQUAL(CONTEXT, *static_cast<int*>(token_pub->get_user_context()));

        mqtt::token_ptr token_disconn{cli.disconnect()};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    //----------------------------------------------------------------------
    // Test async_client::set_callback()
    //----------------------------------------------------------------------

    void test_set_callback()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::test::dummy_callback cb;
        cli.set_callback(cb);

        // CPPUNIT_ASSERT(cb.delivery_complete_called);
    }

    //----------------------------------------------------------------------
    // Test async_client::subscribe()
    //----------------------------------------------------------------------

    void test_subscribe_single_topic_2_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        mqtt::token_ptr token_sub{cli.subscribe(TOPIC, GOOD_QOS)};
        CPPUNIT_ASSERT(token_sub);
        token_sub->wait_for(TIMEOUT);

        mqtt::token_ptr token_disconn{cli.disconnect()};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    void test_subscribe_single_topic_2_args_failure()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        int reason_code = MQTTASYNC_SUCCESS;
        try {
            mqtt::token_ptr token_sub{cli.subscribe(TOPIC, BAD_QOS)};
            CPPUNIT_ASSERT(token_sub);
            token_sub->wait_for(TIMEOUT);
        }
        catch (mqtt::exception& ex) {
            reason_code = ex.get_reason_code();
        }
        CPPUNIT_ASSERT_EQUAL(MQTTASYNC_DISCONNECTED, reason_code);
    }

    void test_subscribe_single_topic_4_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        mqtt::test::dummy_action_listener listener;
        mqtt::token_ptr token_sub{cli.subscribe(TOPIC, GOOD_QOS, &CONTEXT, listener)};
        CPPUNIT_ASSERT(token_sub);
        token_sub->wait_for(TIMEOUT);
        CPPUNIT_ASSERT_EQUAL(CONTEXT, *static_cast<int*>(token_sub->get_user_context()));

        mqtt::token_ptr token_disconn{cli.disconnect()};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    void test_subscribe_single_topic_4_args_failure()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        int reason_code = MQTTASYNC_SUCCESS;
        try {
            mqtt::test::dummy_action_listener listener;
            mqtt::token_ptr token_sub{cli.subscribe(TOPIC, BAD_QOS, &CONTEXT, listener)};
            CPPUNIT_ASSERT(token_sub);
            token_sub->wait_for(TIMEOUT);
        }
        catch (mqtt::exception& ex) {
            reason_code = ex.get_reason_code();
        }
        CPPUNIT_ASSERT_EQUAL(MQTTASYNC_DISCONNECTED, reason_code);
    }

    void test_subscribe_many_topics_2_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        cli.connect()->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        try {
            cli.subscribe(TOPIC_COLL, GOOD_QOS_COLL)->wait_for(TIMEOUT);
        }
        catch (const mqtt::exception& exc) {
            CPPUNIT_FAIL(exc.what());
        }

        mqtt::token_ptr token_disconn{cli.disconnect()};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    void test_subscribe_many_topics_2_args_failure()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        try {
            mqtt::token_ptr token_sub{cli.subscribe(TOPIC_COLL, BAD_QOS_COLL)};
            CPPUNIT_ASSERT(token_sub);
            token_sub->wait_for(TIMEOUT);
        }
        catch (const mqtt::exception& ex) {
            // CPPUNIT_ASSERT_EQUAL(MQTTASYNC_BAD_QOS, ex.get_reason_code());
        }

        int reason_code = MQTTASYNC_SUCCESS;
        try {
            mqtt::token_ptr token_sub{cli.subscribe(TOPIC_COLL, GOOD_QOS_COLL)};
            CPPUNIT_ASSERT(token_sub);
            token_sub->wait_for(TIMEOUT);
        }
        catch (mqtt::exception& ex) {
            reason_code = ex.get_reason_code();
        }
        CPPUNIT_ASSERT_EQUAL(MQTTASYNC_DISCONNECTED, reason_code);
    }

    void test_subscribe_many_topics_4_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        mqtt::test::dummy_action_listener listener;
        mqtt::token_ptr token_sub{cli.subscribe(TOPIC_COLL, GOOD_QOS_COLL, &CONTEXT, listener)
        };
        CPPUNIT_ASSERT(token_sub);
        token_sub->wait_for(TIMEOUT);
        CPPUNIT_ASSERT_EQUAL(CONTEXT, *static_cast<int*>(token_sub->get_user_context()));

        mqtt::token_ptr token_disconn{cli.disconnect()};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    void test_subscribe_many_topics_4_args_failure()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::test::dummy_action_listener listener;

        try {
            cli.subscribe(TOPIC_COLL, BAD_QOS_COLL, &CONTEXT, listener)->wait_for(TIMEOUT);
        }
        catch (const mqtt::exception& ex) {
            // CPPUNIT_ASSERT_EQUAL(MQTTASYNC_BAD_QOS, ex.get_reason_code());
        }

        int reason_code = MQTTASYNC_SUCCESS;
        try {
            mqtt::token_ptr token_sub{
                cli.subscribe(TOPIC_COLL, GOOD_QOS_COLL, &CONTEXT, listener)
            };
            CPPUNIT_ASSERT(token_sub);
            token_sub->wait_for(TIMEOUT);
        }
        catch (mqtt::exception& ex) {
            reason_code = ex.get_reason_code();
        }
        CPPUNIT_ASSERT_EQUAL(MQTTASYNC_DISCONNECTED, reason_code);
    }

    //----------------------------------------------------------------------
    // Test async_client::unsubscribe()
    //----------------------------------------------------------------------

    void test_unsubscribe_single_topic_1_arg()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        mqtt::token_ptr token_unsub{cli.unsubscribe(TOPIC)};
        CPPUNIT_ASSERT(token_unsub);
        token_unsub->wait_for(TIMEOUT);

        mqtt::token_ptr token_disconn{cli.disconnect()};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    void test_unsubscribe_single_topic_1_arg_failure()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        int reason_code = MQTTASYNC_SUCCESS;
        try {
            mqtt::token_ptr token_unsub{cli.unsubscribe(TOPIC)};
            CPPUNIT_ASSERT(token_unsub);
            token_unsub->wait_for(TIMEOUT);
        }
        catch (mqtt::exception& ex) {
            reason_code = ex.get_reason_code();
        }
        CPPUNIT_ASSERT_EQUAL(MQTTASYNC_DISCONNECTED, reason_code);
    }

    void test_unsubscribe_single_topic_3_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        mqtt::test::dummy_action_listener listener;
        mqtt::token_ptr token_unsub{cli.unsubscribe(TOPIC, &CONTEXT, listener)};
        CPPUNIT_ASSERT(token_unsub);
        token_unsub->wait_for(TIMEOUT);
        CPPUNIT_ASSERT_EQUAL(CONTEXT, *static_cast<int*>(token_unsub->get_user_context()));

        mqtt::token_ptr token_disconn{cli.disconnect()};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    void test_unsubscribe_single_topic_3_args_failure()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        int reason_code = MQTTASYNC_SUCCESS;
        try {
            mqtt::test::dummy_action_listener listener;
            mqtt::token_ptr token_unsub{cli.unsubscribe(TOPIC, &CONTEXT, listener)};
            CPPUNIT_ASSERT(token_unsub);
            token_unsub->wait_for(TIMEOUT);
        }
        catch (mqtt::exception& ex) {
            reason_code = ex.get_reason_code();
        }
        CPPUNIT_ASSERT_EQUAL(MQTTASYNC_DISCONNECTED, reason_code);
    }

    void test_unsubscribe_many_topics_1_arg()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        mqtt::token_ptr token_unsub{cli.unsubscribe(TOPIC_COLL)};
        CPPUNIT_ASSERT(token_unsub);
        token_unsub->wait_for(TIMEOUT);

        mqtt::token_ptr token_disconn{cli.disconnect()};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    void test_unsubscribe_many_topics_1_arg_failure()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        int reason_code = MQTTASYNC_SUCCESS;
        try {
            mqtt::token_ptr token_unsub{cli.unsubscribe(TOPIC_COLL)};
            CPPUNIT_ASSERT(token_unsub);
            token_unsub->wait_for(TIMEOUT);
        }
        catch (mqtt::exception& ex) {
            reason_code = ex.get_reason_code();
        }
        CPPUNIT_ASSERT_EQUAL(MQTTASYNC_DISCONNECTED, reason_code);
    }

    void test_unsubscribe_many_topics_3_args()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::token_ptr token_conn{cli.connect()};
        CPPUNIT_ASSERT(token_conn);
        token_conn->wait();
        CPPUNIT_ASSERT(cli.is_connected());

        mqtt::test::dummy_action_listener listener;
        mqtt::token_ptr token_unsub{cli.unsubscribe(TOPIC_COLL, &CONTEXT, listener)};
        CPPUNIT_ASSERT(token_unsub);
        token_unsub->wait_for(TIMEOUT);
        CPPUNIT_ASSERT_EQUAL(CONTEXT, *static_cast<int*>(token_unsub->get_user_context()));

        mqtt::token_ptr token_disconn{cli.disconnect()};
        CPPUNIT_ASSERT(token_disconn);
        token_disconn->wait();
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());
    }

    void test_unsubscribe_many_topics_3_args_failure()
    {
        mqtt::async_client cli{GOOD_SERVER_URI, CLIENT_ID};
        CPPUNIT_ASSERT_EQUAL(false, cli.is_connected());

        mqtt::test::dummy_action_listener listener;
        int reason_code = MQTTASYNC_SUCCESS;
        try {
            mqtt::token_ptr token_unsub{cli.unsubscribe(TOPIC_COLL, &CONTEXT, listener)};
            CPPUNIT_ASSERT(token_unsub);
            token_unsub->wait_for(TIMEOUT);
        }
        catch (mqtt::exception& ex) {
            reason_code = ex.get_reason_code();
        }
        CPPUNIT_ASSERT_EQUAL(MQTTASYNC_DISCONNECTED, reason_code);
    }
};

/////////////////////////////////////////////////////////////////////////////
// end namespace mqtt
}  // namespace mqtt

#endif  //  __mqtt_async_client_v3_test_h

```

`test/unit/test_buffer_ref.cpp`:

```cpp
// test_buffer_ref.cpp
//
// Unit tests for the buffer_ref class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2017-2020 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#define UNIT_TESTS

#include <cstring>

#include "catch2_version.h"
#include "mqtt/buffer_ref.h"

using namespace mqtt;

static const string EMPTY_STR;

static const string STR{"Some random string"};
static const binary BIN{"\x0\x1\x2\x3\x4\x5\x6\x7"};

static const char* CSTR = "Another random string";
static const size_t CSTR_LEN = strlen(CSTR);

// ----------------------------------------------------------------------
// Test the default constructor
// ----------------------------------------------------------------------

TEST_CASE("dflt_ctor", "[collections]")
{
    string_ref sr;

    REQUIRE_FALSE(sr);
    REQUIRE(sr.empty());
}

// ----------------------------------------------------------------------
// Test the string copy constructor
// ----------------------------------------------------------------------

TEST_CASE("str_copy_ctor", "[collections]")
{
    string_ref sr(STR);
    REQUIRE(STR == sr.str());
}

// ----------------------------------------------------------------------
// Test the string move constructor
// ----------------------------------------------------------------------

TEST_CASE("str_move_ctor", "[collections]")
{
    string str(STR);
    string_ref sr(std::move(str));

    REQUIRE(STR == sr.str());
    REQUIRE(EMPTY_STR == str);
}

// ----------------------------------------------------------------------
// Test the c-string constructor
// ----------------------------------------------------------------------

TEST_CASE("cstr_ctor", "[collections]")
{
    string_ref sr(CSTR);

    REQUIRE(CSTR_LEN == strlen(sr.c_str()));
    REQUIRE(0 == strcmp(CSTR, sr.c_str()));
}

// ----------------------------------------------------------------------
// Test the pointer copy constructor
// ----------------------------------------------------------------------

TEST_CASE("ptr_copy_ctor", "[collections]")
{
    string_ptr sp(new string(STR));
    string_ref sr(sp);

    REQUIRE(STR == sr.str());
}

// ----------------------------------------------------------------------
// Test the pointer move constructor
// ----------------------------------------------------------------------

TEST_CASE("ptr_move_ctor", "[collections]")
{
    string_ptr sp(new string(STR));
    string_ref sr(std::move(sp));

    REQUIRE(STR == sr.str());
    REQUIRE_FALSE(sp);
}

// ----------------------------------------------------------------------
// Test the copy constructor
// ----------------------------------------------------------------------

TEST_CASE("copy_ctor", "[collections]")
{
    string_ref orgSR(STR);
    string_ref sr(orgSR);

    REQUIRE(STR == sr.str());
    REQUIRE(orgSR.ptr().get() == sr.ptr().get());
    REQUIRE(2 == sr.ptr().use_count());
}

// ----------------------------------------------------------------------
// Test the move constructor
// ----------------------------------------------------------------------

TEST_CASE("move_ctor", "[collections]")
{
    string_ref orgSR(STR);
    string_ref sr(std::move(orgSR));

    REQUIRE(STR == sr.str());

    REQUIRE_FALSE(orgSR);
    REQUIRE(1 == sr.ptr().use_count());
}

// ----------------------------------------------------------------------
// Test the copy assignment
// ----------------------------------------------------------------------

TEST_CASE("copy_assignment", "[collections]")
{
    string_ref sr, orgSR(STR);

    sr = orgSR;

    REQUIRE(STR == sr.str());
    REQUIRE(orgSR.ptr().get() == sr.ptr().get());
    REQUIRE(2 == sr.ptr().use_count());

    // Test for true copy
    orgSR = EMPTY_STR;
    REQUIRE(STR == sr.str());
}

// ----------------------------------------------------------------------
// Test the move assignment
// ----------------------------------------------------------------------

TEST_CASE("move_assignment", "[collections]")
{
    string_ref sr, orgSR(STR);

    sr = std::move(orgSR);

    REQUIRE(STR == sr.str());

    REQUIRE_FALSE(orgSR);
    REQUIRE(1 == sr.ptr().use_count());
}

// ----------------------------------------------------------------------
// Test the string copy assignment
// ----------------------------------------------------------------------

TEST_CASE("str_copy_assignment", "[collections]")
{
    string str(STR);
    string_ref sr;

    sr = str;
    REQUIRE(STR == sr.str());

    str = EMPTY_STR;
    REQUIRE(STR == sr.str());
}

// ----------------------------------------------------------------------
// Test the string move assignment
// ----------------------------------------------------------------------

TEST_CASE("str_move_assignment", "[collections]")
{
    string str(STR);
    string_ref sr;

    sr = std::move(str);
    REQUIRE(STR == sr.str());

    REQUIRE(EMPTY_STR == str);
    REQUIRE(1 == sr.ptr().use_count());
}

// ----------------------------------------------------------------------
// Test the c-string assignment
// ----------------------------------------------------------------------

TEST_CASE("cstr_assignment", "[collections]")
{
    string_ref sr;
    sr = CSTR;

    REQUIRE(CSTR_LEN == strlen(sr.c_str()));
    REQUIRE(0 == strcmp(CSTR, sr.c_str()));
}

// ----------------------------------------------------------------------
// Test the pointer copy assignment
// ----------------------------------------------------------------------

TEST_CASE("ptr_copy_assignment", "[collections]")
{
    string_ptr sp(new string(STR));
    string_ref sr;

    sr = sp;

    REQUIRE(STR == sr.str());
}

// ----------------------------------------------------------------------
// Test the pointer move assignment
// ----------------------------------------------------------------------

TEST_CASE("ptr_move_assignment", "[collections]")
{
    string_ptr sp(new string(STR));
    string_ref sr;

    sr = std::move(sp);

    REQUIRE(STR == sr.str());
    REQUIRE_FALSE(sp);
}

// ----------------------------------------------------------------------
// Test the reset
// ----------------------------------------------------------------------

TEST_CASE("reset", "[collections]")
{
    string_ref sr(STR);

    sr.reset();
    REQUIRE_FALSE(sr);
    REQUIRE(sr.empty());
}

```

`test/unit/test_client.cpp`:

```cpp
// client_test.h
//
// Unit tests for the client class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2020-2025 Frank Pagliughi <fpagliughi@mindspring.com>
 * Copyright (c) 2017 Guilherme M. Ferreira <guilherme.maciel.ferreira@gmail.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme M. Ferreira
 *        - initial implementation and documentation
 *    Frank Pagliughi
 *        - updated tests for modified v1.0 client API
 *        - Converted to use Catch2
 *******************************************************************************/

#define UNIT_TESTS

#include "catch2_version.h"
#include "mock_action_listener.h"
#include "mock_callback.h"
#include "mock_persistence.h"
#include "mqtt/client.h"

using namespace std::chrono;
using namespace mqtt;

/////////////////////////////////////////////////////////////////////////////

// NOTE: This test case requires network access. It uses one of
//  	 the public available MQTT brokers
#if defined(TEST_EXTERNAL_SERVER)
static const std::string GOOD_SERVER_URI{"tcp://mqtt.eclipseprojects.io:1883"};
#else
static const std::string GOOD_SERVER_URI{"tcp://localhost:1883"};
#endif
static const std::string BAD_SERVER_URI{"one://invalid.address"};
static const std::string CLIENT_ID{"client_test"};
static const std::string TOPIC{"TOPIC"};

static const persistence_type PERSISTENCE_DIR{"persist"};

static const int GOOD_QOS{0};
static const int BAD_QOS{3};

static mqtt::string_collection TOPIC_COLL{"TOPIC0", "TOPIC1", "TOPIC2"};
static mqtt::client::qos_collection GOOD_QOS_COLL{0, 1, 2};
static mqtt::client::qos_collection BAD_QOS_COLL{BAD_QOS};

static const std::string PAYLOAD{"PAYLOAD"};
// const int TIMEOUT { 1000 };
// int CONTEXT { 4 };
static mock_action_listener listener;
static const bool RETAINED{false};

//----------------------------------------------------------------------
// Test constructors client::client()
//----------------------------------------------------------------------

TEST_CASE("client user constructor 2 string args", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};

    REQUIRE(GOOD_SERVER_URI == cli.get_server_uri());
    REQUIRE(CLIENT_ID == cli.get_client_id());
}

TEST_CASE("client user constructor 2 string args failure", "[client]")
{
    int return_code = MQTTASYNC_SUCCESS;
    try {
        mqtt::client cli{BAD_SERVER_URI, CLIENT_ID};
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_BAD_PROTOCOL == return_code);
}

TEST_CASE("client user constructor 3 string args", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID, PERSISTENCE_DIR};

    REQUIRE(GOOD_SERVER_URI == cli.get_server_uri());
    REQUIRE(CLIENT_ID == cli.get_client_id());
}

TEST_CASE("client user constructor 3 args", "[client]")
{
    mock_persistence cp;
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID, &cp};

    REQUIRE(GOOD_SERVER_URI == cli.get_server_uri());
    REQUIRE(CLIENT_ID == cli.get_client_id());

    mqtt::client cli_no_persistence{GOOD_SERVER_URI, CLIENT_ID, nullptr};

    REQUIRE(GOOD_SERVER_URI == cli_no_persistence.get_server_uri());
    REQUIRE(CLIENT_ID == cli_no_persistence.get_client_id());
}

//----------------------------------------------------------------------
// Test client::connect()
//----------------------------------------------------------------------

TEST_CASE("client connect 0 arg", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    cli.connect();
    REQUIRE(cli.is_connected());
}

TEST_CASE("client connect 1 arg", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    mqtt::connect_options co;
    cli.connect(co);
    REQUIRE(cli.is_connected());
}

TEST_CASE("client connect 1 arg failure", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    mqtt::connect_options co;
    mqtt::will_options wo;
    wo.set_qos(BAD_QOS);  // Invalid QoS causes connection failure
    co.set_will(wo);
    int return_code = MQTTASYNC_SUCCESS;
    try {
        cli.connect(co);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(!cli.is_connected());
    REQUIRE(MQTTASYNC_BAD_QOS == return_code);
}

//----------------------------------------------------------------------
// Test client::disconnect()
//----------------------------------------------------------------------

TEST_CASE("client disconnect 0 arg", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    cli.connect();
    REQUIRE(cli.is_connected());

    cli.disconnect();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("client disconnect 1 arg", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    cli.connect();
    REQUIRE(cli.is_connected());

    cli.disconnect(0);
    REQUIRE(!cli.is_connected());
}

TEST_CASE("client disconnect 1 arg failure", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    int return_code = MQTTASYNC_SUCCESS;
    try {
        cli.disconnect(0);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(!cli.is_connected());
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

//----------------------------------------------------------------------
// Test client::get_timeout() and client::set_timeout() using ints
//----------------------------------------------------------------------

TEST_CASE("client timeout int", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    int timeout{std::numeric_limits<int>::min()};
    cli.set_timeout(timeout);
    REQUIRE(timeout == (int)cli.get_timeout().count());

    timeout = 0;
    cli.set_timeout(timeout);
    REQUIRE(timeout == (int)cli.get_timeout().count());

    timeout = std::numeric_limits<int>::max();
    cli.set_timeout(timeout);
    REQUIRE(timeout == (int)cli.get_timeout().count());
}

//----------------------------------------------------------------------
// Test client::get_timeout() and client::set_timeout() using durations
//----------------------------------------------------------------------

TEST_CASE("client timeout duration", "[client]")
{
    const int TIMEOUT_SEC = 120;
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};

    std::chrono::seconds timeout{TIMEOUT_SEC};
    cli.set_timeout(timeout);
    REQUIRE(timeout == cli.get_timeout());
    REQUIRE(TIMEOUT_SEC * 1000 == (int)cli.get_timeout().count());
}

//----------------------------------------------------------------------
// Test client::get_topic()
//----------------------------------------------------------------------

TEST_CASE("client get topic", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    mqtt::topic t{cli.get_topic(TOPIC)};
    REQUIRE(TOPIC == t.get_name());
}

//----------------------------------------------------------------------
// Test client::publish()
//----------------------------------------------------------------------

TEST_CASE("client publish pointer 2 args", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    cli.connect();
    REQUIRE(cli.is_connected());

    mqtt::message_ptr msg{mqtt::message::create(TOPIC, PAYLOAD)};
    cli.publish(msg);

    cli.disconnect();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("client publish pointer 2 args failure", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    int return_code = MQTTASYNC_SUCCESS;
    try {
        mqtt::message_ptr msg{mqtt::message::create(TOPIC, PAYLOAD)};
        cli.publish(msg);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

TEST_CASE("client publish reference 2 args", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    cli.connect();
    REQUIRE(cli.is_connected());

    mqtt::message msg{TOPIC, PAYLOAD};
    cli.publish(msg);

    cli.disconnect();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("client publish 5 args", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    cli.connect();
    REQUIRE(cli.is_connected());

    const void* payload{PAYLOAD.c_str()};
    const size_t payload_size{PAYLOAD.size()};
    cli.publish(TOPIC, payload, payload_size, GOOD_QOS, RETAINED);

    cli.disconnect();
    REQUIRE(!cli.is_connected());
}

//----------------------------------------------------------------------
// Test client::set_callback()
//----------------------------------------------------------------------

TEST_CASE("client set callback", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    mock_callback cb;
    cli.set_callback(cb);
}

//----------------------------------------------------------------------
// Test client::subscribe()
//----------------------------------------------------------------------

TEST_CASE("client subscribe single topic 1 arg", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    cli.connect();
    REQUIRE(cli.is_connected());

    cli.subscribe(TOPIC);

    cli.disconnect();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("client subscribe single topic 1 arg failure", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    int return_code = MQTTASYNC_SUCCESS;
    try {
        cli.subscribe(TOPIC);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

TEST_CASE("client subscribe single topic 2 args", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    cli.connect();
    REQUIRE(cli.is_connected());

    cli.subscribe(TOPIC, GOOD_QOS);

    cli.disconnect();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("client subscribe single topic 2 args failure", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    int return_code = MQTTASYNC_SUCCESS;
    try {
        cli.subscribe(TOPIC, BAD_QOS);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

TEST_CASE("client subscribe many topics 1 arg", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    cli.connect();
    REQUIRE(cli.is_connected());

    cli.subscribe(TOPIC_COLL);

    cli.disconnect();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("client subscribe many topics 1 arg failure", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    int return_code = MQTTASYNC_SUCCESS;
    try {
        cli.subscribe(TOPIC_COLL);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

TEST_CASE("client subscribe many topics 2 args", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    cli.connect();
    REQUIRE(cli.is_connected());

    cli.subscribe(TOPIC_COLL, GOOD_QOS_COLL);

    cli.disconnect();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("client subscribe many topics 2 args failure", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    try {
        cli.subscribe(TOPIC_COLL, BAD_QOS_COLL);
    }
    catch (std::invalid_argument&) {
    }

    int return_code = MQTTASYNC_SUCCESS;
    try {
        cli.subscribe(TOPIC_COLL, GOOD_QOS_COLL);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

//----------------------------------------------------------------------
// Test client::unsubscribe()
//----------------------------------------------------------------------

TEST_CASE("client unsubscribe single topic 1 arg", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    cli.connect();
    REQUIRE(cli.is_connected());

    cli.subscribe(TOPIC, 1);
    cli.unsubscribe(TOPIC);

    cli.disconnect();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("client unsubscribe single topic 1 arg failure", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    int return_code = MQTTASYNC_SUCCESS;
    try {
        cli.unsubscribe(TOPIC);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

TEST_CASE("client unsubscribe many topics 1 arg", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    cli.connect();
    REQUIRE(cli.is_connected());

    cli.subscribe(TOPIC_COLL, GOOD_QOS_COLL);
    cli.unsubscribe(TOPIC_COLL);

    cli.disconnect();
    REQUIRE(!cli.is_connected());
}

TEST_CASE("client unsubscribe many topics 1 arg failure", "[client]")
{
    mqtt::client cli{GOOD_SERVER_URI, CLIENT_ID};
    REQUIRE(!cli.is_connected());

    int return_code = MQTTASYNC_SUCCESS;
    try {
        cli.unsubscribe(TOPIC_COLL);
    }
    catch (mqtt::exception& ex) {
        return_code = ex.get_return_code();
    }
    REQUIRE(MQTTASYNC_DISCONNECTED == return_code);
}

```

`test/unit/test_connect_options.cpp`:

```cpp
// test_connect_options.cpp
//
// Unit tests for the connect_options class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2016-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *    Frank Pagliughi - Converted to Catch2
 *******************************************************************************/

#define UNIT_TESTS

#include "catch2_version.h"
#include "mock_async_client.h"
#include "mqtt/connect_options.h"

using namespace std::chrono;
using namespace mqtt;

// C struct signature/eyecatcher
static const char* CSIG = "MQTC";
static const size_t CSIG_LEN = std::strlen(CSIG);

// These must match the C init struct
static const int DFLT_KEEP_ALIVE = 60;
static const int DFLT_WS_KEEP_ALIVE = 45;
static const int DFLT_CONNECT_TIMEOUT = 30;
static const bool DFLT_AUTO_RECONNECT = false;

static const std::string USER{"wally"};
static const std::string PASSWD{"xyzpdq"};

static const std::string EMPTY_STR;

static const std::vector<string> URIsVec = {
    "mqtt://server1:1883", "mqtt://server2:1883", "mqtts://server3:8883"
};
const const_string_collection_ptr URIs = std::make_shared<const string_collection>(URIsVec);

static constexpr token::Type TOKEN_TYPE = token::Type::CONNECT;

static const std::string HTTP_PROXY{"http://localhost:80"};
static const std::string HTTPS_PROXY{"https://localhost:443"};

// ----------------------------------------------------------------------
// Test the default constructor
// ----------------------------------------------------------------------

TEST_CASE("connect_options default ctor", "[options]")
{
    connect_options opts;

    REQUIRE(EMPTY_STR == opts.get_user_name());
    REQUIRE(EMPTY_STR == opts.get_password_str());
    REQUIRE(DFLT_KEEP_ALIVE == (int)opts.get_keep_alive_interval().count());
    REQUIRE(DFLT_CONNECT_TIMEOUT == (int)opts.get_connect_timeout().count());
    REQUIRE_FALSE(opts.get_servers());
    REQUIRE(DFLT_AUTO_RECONNECT == opts.get_automatic_reconnect());

    REQUIRE(opts.get_http_proxy().empty());
    REQUIRE(opts.get_https_proxy().empty());

    const auto& c_struct = opts.c_struct();
    REQUIRE(0 == memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));

    REQUIRE(DFLT_KEEP_ALIVE == c_struct.keepAliveInterval);
    REQUIRE(DFLT_CONNECT_TIMEOUT == c_struct.connectTimeout);

    REQUIRE(c_struct.username == nullptr);
    REQUIRE(c_struct.password == nullptr);
    REQUIRE(0 == c_struct.binarypwd.len);
    REQUIRE(c_struct.binarypwd.data == nullptr);

    // No callbacks without a context token
    REQUIRE(c_struct.context == nullptr);
    REQUIRE(c_struct.onSuccess == nullptr);
    REQUIRE(c_struct.onFailure == nullptr);
    REQUIRE(c_struct.onSuccess5 == nullptr);
    REQUIRE(c_struct.onFailure5 == nullptr);

    // No will or SSL, for default
    REQUIRE(c_struct.will == nullptr);
    REQUIRE(c_struct.ssl == nullptr);

    REQUIRE(c_struct.connectProperties == nullptr);
    REQUIRE(c_struct.willProperties == nullptr);

    REQUIRE(0 == c_struct.serverURIcount);
    REQUIRE(nullptr == c_struct.serverURIs);

    REQUIRE(nullptr == c_struct.httpProxy);
    REQUIRE(nullptr == c_struct.httpsProxy);
}

// ----------------------------------------------------------------------
// Test the constructor that takes user/password
// ----------------------------------------------------------------------

TEST_CASE("connect_options user_constructor", "[options]")
{
    connect_options opts{USER, PASSWD};

    REQUIRE(opts.get_http_proxy().empty());
    REQUIRE(opts.get_https_proxy().empty());

    const auto& c_struct = opts.c_struct();
    REQUIRE(0 == memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));

    REQUIRE(USER == opts.get_user_name());
    REQUIRE(PASSWD == opts.get_password_str());

    REQUIRE(0 == strcmp(USER.c_str(), c_struct.username));
    REQUIRE(c_struct.password == nullptr);
    REQUIRE(PASSWD.size() == size_t(c_struct.binarypwd.len));
    REQUIRE(0 == memcmp(PASSWD.data(), c_struct.binarypwd.data, PASSWD.size()));

    // No callbacks without a context token
    REQUIRE(c_struct.context == nullptr);
    REQUIRE(c_struct.onSuccess == nullptr);
    REQUIRE(c_struct.onFailure == nullptr);

    REQUIRE(c_struct.httpProxy == nullptr);
    REQUIRE(c_struct.httpsProxy == nullptr);
}

// ----------------------------------------------------------------------
// Test the copy constructor
// ----------------------------------------------------------------------

TEST_CASE("connect_options copy ctor", "[options]")
{
    connect_options orgOpts{USER, PASSWD};

    SECTION("simple options")
    {
        connect_options opts{orgOpts};

        REQUIRE(USER == opts.get_user_name());
        REQUIRE(PASSWD == opts.get_password_str());

        const auto& c_struct = opts.c_struct();

        REQUIRE(0 == memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));

        REQUIRE(0 == strcmp(USER.c_str(), c_struct.username));
        REQUIRE(c_struct.password == nullptr);
        REQUIRE(PASSWD.size() == size_t(c_struct.binarypwd.len));
        REQUIRE(0 == memcmp(PASSWD.data(), c_struct.binarypwd.data, PASSWD.size()));

        // Make sure it's a true copy, not linked to the original
        orgOpts.set_user_name(EMPTY_STR);
        orgOpts.set_password(EMPTY_STR);

        REQUIRE(USER == opts.get_user_name());
        REQUIRE(PASSWD == opts.get_password_str());
    }

    SECTION("proxy options")
    {
        orgOpts.set_http_proxy(HTTP_PROXY);

        connect_options opts{orgOpts};
        REQUIRE(HTTP_PROXY == opts.get_http_proxy());
        REQUIRE(opts.get_https_proxy().empty());
    }

    SECTION("secure proxy options")
    {
        orgOpts.set_https_proxy(HTTPS_PROXY);

        connect_options opts{orgOpts};
        REQUIRE(HTTPS_PROXY == opts.get_https_proxy());
        REQUIRE(opts.get_http_proxy().empty());
    }

    SECTION("properties")
    {
        orgOpts.set_properties({{property::SESSION_EXPIRY_INTERVAL, 0}});

        connect_options opts{orgOpts};

        const auto& copts = opts.c_struct();
        const auto& orgCopts = orgOpts.c_struct();

        // Make sure it's an actual copy
        REQUIRE(copts.connectProperties->array != orgCopts.connectProperties->array);
        orgOpts.get_properties().clear();

        REQUIRE(1 == opts.get_properties().size());
        REQUIRE(opts.get_properties().contains(property::SESSION_EXPIRY_INTERVAL));
        REQUIRE(opts.c_struct().connectProperties == &opts.get_properties().c_struct());
    }
}

// ----------------------------------------------------------------------
// Test the move constructor
// ----------------------------------------------------------------------

TEST_CASE("connect_options move_constructor", "[options]")
{
    connect_options orgOpts{USER, PASSWD};

    SECTION("simple options")
    {
        connect_options opts{std::move(orgOpts)};

        REQUIRE(USER == opts.get_user_name());
        REQUIRE(PASSWD == opts.get_password_str());

        const auto& copts = opts.c_struct();

        REQUIRE(0 == memcmp(&copts.struct_id, CSIG, CSIG_LEN));

        REQUIRE(0 == strcmp(USER.c_str(), copts.username));
        REQUIRE(copts.password == nullptr);
        REQUIRE(PASSWD.size() == size_t(copts.binarypwd.len));
        REQUIRE(0 == memcmp(PASSWD.data(), copts.binarypwd.data, PASSWD.size()));
        REQUIRE(nullptr == copts.connectProperties);

        // Make sure it's a true copy, not linked to the original
        orgOpts.set_user_name(EMPTY_STR);
        orgOpts.set_password(EMPTY_STR);

        REQUIRE(USER == opts.get_user_name());
        REQUIRE(PASSWD == opts.get_password_str());

        // Check that the original was moved
        REQUIRE(EMPTY_STR == orgOpts.get_user_name());
        REQUIRE(EMPTY_STR == orgOpts.get_password_str());
    }

    SECTION("properties")
    {
        orgOpts.set_properties({{property::SESSION_EXPIRY_INTERVAL, 42}});

        connect_options opts{std::move(orgOpts)};

        const auto& copts = opts.c_struct();

        // Check that the original was moved
        REQUIRE(orgOpts.get_properties().empty());

        // Check that we got the correct properties
        REQUIRE(1 == opts.get_properties().size());
        REQUIRE(opts.get_properties().contains(property::SESSION_EXPIRY_INTERVAL));
        REQUIRE(
            42 == get<uint32_t>(opts.get_properties(), property::SESSION_EXPIRY_INTERVAL)
        );

        REQUIRE(copts.connectProperties == &opts.get_properties().c_struct());
    }
}

// ----------------------------------------------------------------------
// Test the copy assignment operator=(const&)
// ----------------------------------------------------------------------

TEST_CASE("connect_options copy_assignment", "[options]")
{
    SECTION("v3")
    {
        connect_options orgOpts{USER, PASSWD};
        connect_options opts;

        opts = orgOpts;

        REQUIRE(USER == opts.get_user_name());
        REQUIRE(PASSWD == opts.get_password_str());

        const auto& copts = opts.c_struct();

        REQUIRE(0 == memcmp(&copts.struct_id, CSIG, CSIG_LEN));

        REQUIRE(0 == strcmp(USER.c_str(), copts.username));
        REQUIRE(copts.password == nullptr);
        REQUIRE(PASSWD.size() == size_t(copts.binarypwd.len));
        REQUIRE(0 == memcmp(PASSWD.data(), copts.binarypwd.data, PASSWD.size()));
        REQUIRE(nullptr == copts.connectProperties);

        // Make sure it's a true copy, not linked to the original
        orgOpts.set_user_name(EMPTY_STR);
        orgOpts.set_password(EMPTY_STR);

        REQUIRE(USER == opts.get_user_name());
        REQUIRE(PASSWD == opts.get_password_str());

        // Self assignment should cause no harm
        opts = opts;

        REQUIRE(USER == opts.get_user_name());
        REQUIRE(PASSWD == opts.get_password_str());
    }

    SECTION("v5")
    {
        auto orgOpts = connect_options::v5();
        orgOpts.set_properties({{property::SESSION_EXPIRY_INTERVAL, 42}});

        connect_options opts = orgOpts;
        const auto& copts = opts.c_struct();
        const auto& orgCopts = orgOpts.c_struct();

        // Make sure it's an actual copy
        REQUIRE(copts.connectProperties->array != orgCopts.connectProperties->array);
        orgOpts.get_properties().clear();

        // Check that we got the correct properties
        REQUIRE(1 == opts.get_properties().size());
        REQUIRE(opts.get_properties().contains(property::SESSION_EXPIRY_INTERVAL));
        REQUIRE(
            42 == get<uint32_t>(opts.get_properties(), property::SESSION_EXPIRY_INTERVAL)
        );

        REQUIRE(copts.connectProperties == &opts.get_properties().c_struct());
    }
}

// ----------------------------------------------------------------------
// Test the move assignment, operator=(&&)
// ----------------------------------------------------------------------

TEST_CASE("connect_options move_assignment", "[options]")
{
    SECTION("v3")
    {
        connect_options orgOpts{USER, PASSWD};
        connect_options opts{std::move(orgOpts)};

        REQUIRE(USER == opts.get_user_name());
        REQUIRE(PASSWD == opts.get_password_str());

        const auto& c_struct = opts.c_struct();

        REQUIRE(0 == memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));

        REQUIRE(0 == strcmp(USER.c_str(), c_struct.username));
        REQUIRE(c_struct.password == nullptr);
        REQUIRE(PASSWD.size() == size_t(c_struct.binarypwd.len));
        REQUIRE(0 == memcmp(PASSWD.data(), c_struct.binarypwd.data, PASSWD.size()));

        // Make sure it's a true copy, not linked to the original
        orgOpts.set_user_name(EMPTY_STR);
        orgOpts.set_password(EMPTY_STR);

        REQUIRE(USER == opts.get_user_name());
        REQUIRE(PASSWD == opts.get_password_str());

        // Check that the original was moved
        REQUIRE(EMPTY_STR == orgOpts.get_user_name());
        REQUIRE(EMPTY_STR == orgOpts.get_password_str());

// Self assignment should cause no harm
// (clang++ is smart enough to warn about this)
#if !defined(__clang__)
        opts = std::move(opts);
        REQUIRE(USER == opts.get_user_name());
        REQUIRE(PASSWD == opts.get_password_str());
#endif
    }

    SECTION("properties")
    {
        auto orgOpts = connect_options::v5();
        orgOpts.set_properties({{property::SESSION_EXPIRY_INTERVAL, 42}});

        connect_options opts = std::move(orgOpts);

        const auto& copts = opts.c_struct();

        // Check that the original was moved
        REQUIRE(orgOpts.get_properties().empty());

        // Check that we got the correct properties
        REQUIRE(1 == opts.get_properties().size());
        REQUIRE(opts.get_properties().contains(property::SESSION_EXPIRY_INTERVAL));
        REQUIRE(
            42 == get<uint32_t>(opts.get_properties(), property::SESSION_EXPIRY_INTERVAL)
        );

        REQUIRE(copts.connectProperties == &opts.get_properties().c_struct());
    }
}

// ----------------------------------------------------------------------
// Test set/get of the user and password.
// ----------------------------------------------------------------------

TEST_CASE("connect_options set_user", "[options]")
{
    connect_options opts;
    const auto& c_struct = opts.c_struct();

    opts.set_user_name(USER);
    opts.set_password(PASSWD);

    REQUIRE(USER == opts.get_user_name());
    REQUIRE(PASSWD == opts.get_password_str());

    REQUIRE(0 == strcmp(USER.c_str(), c_struct.username));
    REQUIRE(c_struct.password == nullptr);
    REQUIRE(PASSWD.size() == size_t(c_struct.binarypwd.len));
    REQUIRE(0 == memcmp(PASSWD.data(), c_struct.binarypwd.data, PASSWD.size()));
}

// ----------------------------------------------------------------------
// Test set/get of a long user name and password.
// ----------------------------------------------------------------------

TEST_CASE("connect_options set_long_user", "[options]")
{
    std::string user;
    std::string passwd;
    for (int i = 0; i < 1053; ++i) {
        auto by = byte(i % 128);
        if (isprint(char(by)))
            user.push_back(char(by));
        passwd.push_back(by);
    }

    connect_options orgOpts;

    orgOpts.set_user_name(user);
    orgOpts.set_password(passwd);

    REQUIRE(user == orgOpts.get_user_name());
    REQUIRE(passwd == orgOpts.get_password_str());

    connect_options opts;
    opts = orgOpts;

    REQUIRE(user == opts.get_user_name());
    REQUIRE(passwd == opts.get_password_str());

    const auto& c_struct = opts.c_struct();

    REQUIRE(0 == strcmp(user.c_str(), c_struct.username));
    REQUIRE(c_struct.password == nullptr);
    REQUIRE(passwd.size() == size_t(c_struct.binarypwd.len));
    REQUIRE(0 == memcmp(passwd.data(), c_struct.binarypwd.data, PASSWD.size()));
}

// ----------------------------------------------------------------------
// Test set/get of will options
// ----------------------------------------------------------------------

TEST_CASE("connect_options set_will", "[options]")
{
    connect_options opts;
    const auto& c_struct = opts.c_struct();

    REQUIRE(nullptr == c_struct.will);
    will_options willOpts;
    opts.set_will(willOpts);
    REQUIRE(nullptr != c_struct.will);
    // REQUIRE(&opts.will_.opts_ == c_struct.will);
}

// ----------------------------------------------------------------------
// Test set/get of ssl options
// ----------------------------------------------------------------------

TEST_CASE("connect_options set_ssl", "[options]")
{
    connect_options opts;
    const auto& c_struct = opts.c_struct();

    REQUIRE(nullptr == c_struct.ssl);
    ssl_options sslOpts;
    opts.set_ssl(sslOpts);
    REQUIRE(nullptr != c_struct.ssl);
    // REQUIRE(&opts.ssl_.opts_ == c_struct.ssl);
}

// ----------------------------------------------------------------------
// Test set/get
// ----------------------------------------------------------------------

TEST_CASE("set_token", "[options]")
{
    connect_options opts;
    const auto& c_struct = opts.c_struct();

    REQUIRE(nullptr == c_struct.context);

    SECTION("set token")
    {
        mock_async_client ac;
        auto tok = token::create(TOKEN_TYPE, ac);
        opts.set_token(tok);
        REQUIRE(tok == opts.get_token());
        REQUIRE(tok.get() == c_struct.context);
    }

    SECTION("keep alive")
    {
        // Set as an int
        const int KEEP_ALIVE_SEC = 30;
        opts.set_keep_alive_interval(KEEP_ALIVE_SEC);

        REQUIRE(KEEP_ALIVE_SEC == (int)opts.get_keep_alive_interval().count());
        REQUIRE(KEEP_ALIVE_SEC == c_struct.keepAliveInterval);

        // Set as an chrono
        opts.set_keep_alive_interval(milliseconds(2 * KEEP_ALIVE_SEC * 1000));

        REQUIRE(2 * KEEP_ALIVE_SEC == (int)opts.get_keep_alive_interval().count());
        REQUIRE(2 * KEEP_ALIVE_SEC == c_struct.keepAliveInterval);
    }

    SECTION("connect timeout")
    {
        // Set as an int
        const int TIMEOUT_SEC = 10;
        opts.set_connect_timeout(TIMEOUT_SEC);

        REQUIRE(TIMEOUT_SEC == (int)opts.get_connect_timeout().count());
        REQUIRE(TIMEOUT_SEC == c_struct.connectTimeout);

        // Set as an chrono
        opts.set_connect_timeout(std::chrono::milliseconds(2 * TIMEOUT_SEC * 1000));

        REQUIRE(2 * TIMEOUT_SEC == (int)opts.get_connect_timeout().count());
        REQUIRE(2 * TIMEOUT_SEC == c_struct.connectTimeout);
    }

    SECTION("set servers")
    {
        opts.set_servers(URIs);

        REQUIRE(URIs.get() == opts.get_servers().get());

        // Check the C struct
        REQUIRE((int)URIsVec.size() == c_struct.serverURIcount);
        REQUIRE(0 == strcmp(URIsVec[0].c_str(), c_struct.serverURIs[0]));
        REQUIRE(0 == strcmp(URIsVec[1].c_str(), c_struct.serverURIs[1]));
        REQUIRE(0 == strcmp(URIsVec[2].c_str(), c_struct.serverURIs[2]));
    }

    SECTION("set auto reconnect")
    {
        // Set as an int
        const int TIMEOUT_SEC = 10;
        opts.set_automatic_reconnect(TIMEOUT_SEC, 2 * TIMEOUT_SEC);

        REQUIRE(opts.get_automatic_reconnect());
        REQUIRE(TIMEOUT_SEC == (int)opts.get_min_retry_interval().count());
        REQUIRE(2 * TIMEOUT_SEC == (int)opts.get_max_retry_interval().count());

        REQUIRE(TIMEOUT_SEC == c_struct.minRetryInterval);
        REQUIRE(2 * TIMEOUT_SEC == c_struct.maxRetryInterval);

        // Set as an chrono
        opts.set_automatic_reconnect(
            milliseconds(2000 * TIMEOUT_SEC), milliseconds(4000 * TIMEOUT_SEC)
        );

        REQUIRE(opts.get_automatic_reconnect());
        REQUIRE(2 * TIMEOUT_SEC == (int)opts.get_min_retry_interval().count());
        REQUIRE(4 * TIMEOUT_SEC == (int)opts.get_max_retry_interval().count());

        REQUIRE(2 * TIMEOUT_SEC == c_struct.minRetryInterval);
        REQUIRE(4 * TIMEOUT_SEC == c_struct.maxRetryInterval);

        // Turn it off
        opts.set_automatic_reconnect(false);
        REQUIRE_FALSE(opts.get_automatic_reconnect());
    }
}

// ----------------------------------------------------------------------
// Test the builder constructors
// ----------------------------------------------------------------------

TEST_CASE("connect_options_builder default generator", "[options]")
{
    connect_options opts;

    // Default is v3.x

    opts = connect_options_builder().finalize();

    REQUIRE(MQTTVERSION_DEFAULT == opts.get_mqtt_version());
    REQUIRE(DFLT_KEEP_ALIVE == (int)opts.get_keep_alive_interval().count());

    // Explicit v3

    opts = connect_options_builder::v3().finalize();

    REQUIRE(MQTTVERSION_DEFAULT == opts.get_mqtt_version());
    REQUIRE(DFLT_KEEP_ALIVE == (int)opts.get_keep_alive_interval().count());

    // v5

    opts = connect_options_builder::v5().finalize();

    REQUIRE(MQTTVERSION_5 == opts.get_mqtt_version());
    REQUIRE(DFLT_KEEP_ALIVE == (int)opts.get_keep_alive_interval().count());

    // WebSocket

    opts = connect_options_builder::ws().finalize();

    REQUIRE(MQTTVERSION_DEFAULT == opts.get_mqtt_version());
    REQUIRE(DFLT_WS_KEEP_ALIVE == (int)opts.get_keep_alive_interval().count());

    // Explicit WebSocket v5

    opts = connect_options_builder::v5_ws().finalize();

    REQUIRE(MQTTVERSION_5 == opts.get_mqtt_version());
    REQUIRE(DFLT_WS_KEEP_ALIVE == (int)opts.get_keep_alive_interval().count());
}

// ----------------------------------------------------------------------
// Test the builder
// ----------------------------------------------------------------------

TEST_CASE("connect_options_builder set", "[options]")
{
    const uint32_t INTERVAL = 80000;

    properties conn_props{property{property::SESSION_EXPIRY_INTERVAL, INTERVAL}};

    auto opts = connect_options_builder().properties(conn_props).finalize();

    auto& props = opts.get_properties();

    REQUIRE(!props.empty());
    REQUIRE(1 == props.size());
    REQUIRE(INTERVAL == get<uint32_t>(props, property::SESSION_EXPIRY_INTERVAL));

    const auto& copts = opts.c_struct();
    REQUIRE(nullptr != copts.connectProperties);
}

// ----------------------------------------------------------------------
// Test the builder's copy assignment operator=(const&)
// ----------------------------------------------------------------------

TEST_CASE("connect_options_builder copy_assignment", "[options]")
{
    SECTION("v3")
    {
        auto orgOptsBldr = connect_options_builder::v3();
        orgOptsBldr.user_name(USER).password(PASSWD);

        connect_options_builder optsBldr;
        optsBldr = orgOptsBldr;

        connect_options opts = optsBldr.finalize();

        REQUIRE(USER == opts.get_user_name());
        REQUIRE(PASSWD == opts.get_password_str());

        const auto& copts = opts.c_struct();

        REQUIRE(0 == memcmp(&copts.struct_id, CSIG, CSIG_LEN));

        REQUIRE(0 == strcmp(USER.c_str(), copts.username));
        REQUIRE(copts.password == nullptr);
        REQUIRE(PASSWD.size() == size_t(copts.binarypwd.len));
        REQUIRE(0 == memcmp(PASSWD.data(), copts.binarypwd.data, PASSWD.size()));
        REQUIRE(nullptr == copts.connectProperties);
    }

    SECTION("v5")
    {
        auto orgOptsBldr = connect_options_builder::v5();
        orgOptsBldr.properties({{property::SESSION_EXPIRY_INTERVAL, 42}});

        connect_options_builder optsBldr;
        optsBldr = orgOptsBldr;

        connect_options opts = optsBldr.finalize();

        // Check that we got the correct properties
        REQUIRE(1 == opts.get_properties().size());
        REQUIRE(opts.get_properties().contains(property::SESSION_EXPIRY_INTERVAL));
        REQUIRE(
            42 == get<uint32_t>(opts.get_properties(), property::SESSION_EXPIRY_INTERVAL)
        );
    }
}

// ----------------------------------------------------------------------
// Test the builder's move assignment, operator=(&&)
// ----------------------------------------------------------------------

TEST_CASE("connect_options_builder move_assignment", "[options]")
{
    SECTION("v3")
    {
        auto orgOptsBldr = connect_options_builder::v3();
        orgOptsBldr.user_name(USER).password(PASSWD);

        connect_options_builder optsBldr;

        optsBldr = std::move(orgOptsBldr);
        connect_options opts = optsBldr.finalize();

        REQUIRE(USER == opts.get_user_name());
        REQUIRE(PASSWD == opts.get_password_str());

        const auto& c_struct = opts.c_struct();

        REQUIRE(0 == memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));

        REQUIRE(0 == strcmp(USER.c_str(), c_struct.username));
        REQUIRE(c_struct.password == nullptr);
        REQUIRE(PASSWD.size() == size_t(c_struct.binarypwd.len));
        REQUIRE(0 == memcmp(PASSWD.data(), c_struct.binarypwd.data, PASSWD.size()));

// Self assignment should cause no harm
// (clang++ is smart enough to warn about this)
#if !defined(__clang__)
        optsBldr = std::move(optsBldr);
        opts = optsBldr.finalize();
        REQUIRE(USER == opts.get_user_name());
        REQUIRE(PASSWD == opts.get_password_str());
#endif
    }

    SECTION("properties")
    {
        auto orgOptsBldr = connect_options_builder::v5();
        orgOptsBldr.properties({{property::SESSION_EXPIRY_INTERVAL, 42}});

        connect_options_builder optsBldr;
        optsBldr = std::move(orgOptsBldr);

        connect_options opts = optsBldr.finalize();

        const auto& copts = opts.c_struct();

        // Check that we got the correct properties
        REQUIRE(1 == opts.get_properties().size());
        REQUIRE(opts.get_properties().contains(property::SESSION_EXPIRY_INTERVAL));
        REQUIRE(
            42 == get<uint32_t>(opts.get_properties(), property::SESSION_EXPIRY_INTERVAL)
        );
    }
}

```

`test/unit/test_create_options.cpp`:

```cpp
// test_create_options.cpp
//
// Unit tests for the create_options class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2020 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#define UNIT_TESTS

#include <cstring>

#include "catch2_version.h"
#include "mock_async_client.h"
#include "mqtt/create_options.h"

using namespace mqtt;

// ----------------------------------------------------------------------
// Test the default constructor
// ----------------------------------------------------------------------

TEST_CASE("create_options default ctor", "[options]")
{
    mqtt::create_options opts;

    REQUIRE(!opts.get_send_while_disconnected());
    REQUIRE(!opts.get_delete_oldest_messages());

    REQUIRE(opts.get_restore_messages());
    REQUIRE(opts.get_persist_qos0());
}

/////////////////////////////////////////////////////////////////////////////
//							create_options_builder
/////////////////////////////////////////////////////////////////////////////

// ----------------------------------------------------------------------
// Test the default constructor
// ----------------------------------------------------------------------

TEST_CASE("create_options_builder default ctor", "[options]")
{
    const auto opts = create_options_builder().finalize();

    REQUIRE(!opts.get_send_while_disconnected());
    REQUIRE(!opts.get_delete_oldest_messages());

    REQUIRE(opts.get_restore_messages());
    REQUIRE(opts.get_persist_qos0());
}

TEST_CASE("create_options_builder sets", "[options]")
{
    const auto opts =
        create_options_builder().send_while_disconnected().delete_oldest_messages().finalize(
        );

    REQUIRE(opts.get_send_while_disconnected());
    REQUIRE(opts.get_delete_oldest_messages());

    REQUIRE(opts.get_restore_messages());
    REQUIRE(opts.get_persist_qos0());
}

```

`test/unit/test_disconnect_options.cpp`:

```cpp
// disconnect_options_test.h
// Unit tests for the disconnect_options class in the Paho MQTT C++ library.

/*******************************************************************************
 * Copyright (c) 2016 Guilherme M. Ferreira <guilherme.maciel.ferreira@gmail.com>
 * Copyright (c) 2016-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme M. Ferreira - initial implementation and documentation
 *******************************************************************************/

#define UNIT_TESTS

#include <cstring>

#include "catch2_version.h"
#include "mock_async_client.h"
#include "mqtt/disconnect_options.h"

using namespace mqtt;

/////////////////////////////////////////////////////////////////////////////

static const int DFLT_TIMEOUT = 0;
static const std::string EMPTY_STR;

static constexpr token::Type TOKEN_TYPE = token::Type::DISCONNECT;

static mock_async_client cli;

// ----------------------------------------------------------------------
// Test default constructor
// ----------------------------------------------------------------------

TEST_CASE("disconnect_options dflt constructor", "[options]")
{
    disconnect_options opts;

    REQUIRE(DFLT_TIMEOUT == (int)opts.get_timeout().count());
    REQUIRE(!opts.get_token());

    const auto& c_struct = opts.c_struct();

    REQUIRE(nullptr == c_struct.onSuccess);
    REQUIRE(nullptr == c_struct.onFailure);

    REQUIRE(DFLT_TIMEOUT == c_struct.timeout);
}

// ----------------------------------------------------------------------
// Test user constructor
// ----------------------------------------------------------------------

TEST_CASE("disconnect_options user constructor", "[options]")
{
    const int TIMEOUT = 10;

    auto tok = token::create(TOKEN_TYPE, cli);
    disconnect_options opts{TIMEOUT};
    opts.set_token(tok, MQTTVERSION_DEFAULT);

    const auto& c_struct = opts.c_struct();

    REQUIRE(nullptr != c_struct.onSuccess);
    REQUIRE(nullptr != c_struct.onFailure);

    REQUIRE(TIMEOUT == (int)opts.get_timeout().count());
    REQUIRE(tok == opts.get_token());
}

// ----------------------------------------------------------------------
// Test the copy constructor
// ----------------------------------------------------------------------

TEST_CASE("disconnect_options copy ctor", "[options]")
{
    constexpr std::chrono::milliseconds TIMEOUT{50};

    disconnect_options orgOpts{TIMEOUT};

    SECTION("simple options")
    {
        disconnect_options opts{orgOpts};

        REQUIRE(TIMEOUT == opts.get_timeout());

        REQUIRE(opts.get_properties().empty());

        // Make sure it's a true copy, not linked to the original
        orgOpts.set_timeout(0);
        REQUIRE(TIMEOUT == opts.get_timeout());
    }

    SECTION("properties")
    {
        orgOpts.set_properties({{property::SESSION_EXPIRY_INTERVAL, 42}});

        disconnect_options opts{orgOpts};

        const auto& copts = opts.c_struct();
        const auto& orgCopts = orgOpts.c_struct();

        // Make sure we copied the properties
        REQUIRE(orgCopts.properties.array != copts.properties.array);
        orgOpts.get_properties().clear();

        // Check that the properties transferred over
        REQUIRE(1 == opts.get_properties().size());
        REQUIRE(opts.get_properties().contains(property::SESSION_EXPIRY_INTERVAL));
        REQUIRE(
            42 == get<uint32_t>(opts.get_properties(), property::SESSION_EXPIRY_INTERVAL)
        );

        REQUIRE(1 == opts.c_struct().properties.count);
        REQUIRE(
            1 == MQTTProperties_propertyCount(
                     const_cast<MQTTProperties*>(&copts.properties),
                     MQTTPROPERTY_CODE_SESSION_EXPIRY_INTERVAL
                 )
        );
        REQUIRE(
            42 == MQTTProperties_getNumericValue(
                      const_cast<MQTTProperties*>(&copts.properties),
                      MQTTPROPERTY_CODE_SESSION_EXPIRY_INTERVAL
                  )
        );
    }
}

// ----------------------------------------------------------------------
// Test the move constructor
// ----------------------------------------------------------------------

TEST_CASE("disconnect_options move_constructor", "[options]")
{
    constexpr std::chrono::milliseconds TIMEOUT{50};

    disconnect_options orgOpts{TIMEOUT};

    SECTION("simple options")
    {
        disconnect_options opts{std::move(orgOpts)};

        REQUIRE(TIMEOUT == opts.get_timeout());
        REQUIRE(opts.get_properties().empty());
    }

    SECTION("properties")
    {
        orgOpts.set_properties({{property::SESSION_EXPIRY_INTERVAL, 42}});

        disconnect_options opts{std::move(orgOpts)};

        const auto& copts = opts.c_struct();

        REQUIRE(1 == opts.get_properties().size());
        REQUIRE(opts.get_properties().contains(property::SESSION_EXPIRY_INTERVAL));
        REQUIRE(1 == copts.properties.count);

        // Check that the original was moved
        REQUIRE(orgOpts.get_properties().empty());
    }
}

// ----------------------------------------------------------------------
// Test set timeout
// ----------------------------------------------------------------------

TEST_CASE("disconnect_options set timeout", "[options]")
{
    disconnect_options opts;
    const auto& c_struct = opts.c_struct();

    const int TIMEOUT = 5000;  // ms

    // Set with integer
    opts.set_timeout(TIMEOUT);
    REQUIRE(TIMEOUT == (int)opts.get_timeout().count());
    REQUIRE(TIMEOUT == c_struct.timeout);

    // Set with chrono duration
    opts.set_timeout(std::chrono::seconds(2 * TIMEOUT / 1000));
    REQUIRE(2 * TIMEOUT == (int)opts.get_timeout().count());
    REQUIRE(2 * TIMEOUT == c_struct.timeout);
}

// ----------------------------------------------------------------------
// Test set connect token
// ----------------------------------------------------------------------

TEST_CASE("disconnect_options set token", "[options]")
{
    auto tok = token::create(TOKEN_TYPE, cli);
    disconnect_options opts;

    const auto& c_struct = opts.c_struct();

    REQUIRE(nullptr == c_struct.onSuccess);
    REQUIRE(nullptr == c_struct.onFailure);

    opts.set_token(token_ptr(), MQTTVERSION_DEFAULT);
    REQUIRE(nullptr == c_struct.onSuccess);
    REQUIRE(nullptr == c_struct.onFailure);

    opts.set_token(tok, MQTTVERSION_DEFAULT);
    REQUIRE(nullptr != c_struct.onSuccess);
    REQUIRE(nullptr != c_struct.onFailure);

    REQUIRE(tok == opts.get_token());
}

```

`test/unit/test_exception.cpp`:

```cpp
// test_exception_test.cpp
//
// Unit tests for the exception class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2016-2017 Guilherme M. Ferreira <guilherme.maciel.ferreira@gmail.com>
 * Copyright (c) 2020 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme M. Ferreira - original CppUnit implementation and documentation
 *    Frank Pagliughi - Conversion to Catch2 and expansion
 *******************************************************************************/

#define UNIT_TESTS

#include <cstring>

#include "catch2_version.h"
#include "mqtt/exception.h"

using namespace mqtt;

static const std::string ERR_MSG{"Some MQTT error"};

// ----------------------------------------------------------------------
// Test user constructor
// ----------------------------------------------------------------------

TEST_CASE("user constructor", "[exception]")
{
    mqtt::exception ex1(MQTTASYNC_FAILURE);
    REQUIRE(MQTTASYNC_FAILURE == ex1.get_return_code());

    mqtt::exception ex2(MQTTASYNC_PERSISTENCE_ERROR);
    REQUIRE(MQTTASYNC_PERSISTENCE_ERROR == ex2.get_return_code());

    mqtt::exception ex3(MQTTASYNC_OPERATION_INCOMPLETE);
    REQUIRE(MQTTASYNC_OPERATION_INCOMPLETE == ex3.get_return_code());
}

// ----------------------------------------------------------------------
// Test get_message()
// ----------------------------------------------------------------------

TEST_CASE("get message", "[exception]")
{
    mqtt::exception ex(MQTTASYNC_FAILURE, ERR_MSG);
    REQUIRE(ERR_MSG == ex.get_message());
}

// ----------------------------------------------------------------------
// Test get_return_code()
// ----------------------------------------------------------------------

TEST_CASE("get return code", "[exception]")
{
    mqtt::exception ex1(MQTTASYNC_FAILURE);
    REQUIRE(MQTTASYNC_FAILURE == ex1.get_return_code());
}

// ----------------------------------------------------------------------
// Test to string
// ----------------------------------------------------------------------

TEST_CASE("to_str", "[exception]")
{
    mqtt::exception ex1(MQTTASYNC_FAILURE);
    std::string msg1{"MQTT error [-1]"};
    REQUIRE(msg1 == ex1.to_string().substr(0, 15));
}

// ----------------------------------------------------------------------
// Test what
// ----------------------------------------------------------------------

TEST_CASE("what", "[exception]")
{
    mqtt::exception ex1(MQTTASYNC_FAILURE);
    const char* msg1 = "MQTT error [-1]";
    REQUIRE(memcmp(msg1, ex1.what(), 15) == 0);
}

```

`test/unit/test_message.cpp`:

```cpp
// message_test.cpp
//
// Unit tests for the message class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2016-2020 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#define UNIT_TESTS

#include <cstring>

#include "catch2_version.h"
#include "mqtt/message.h"

using namespace mqtt;

static const std::string EMPTY_STR;
static const int DFLT_QOS = 0;
static const bool DFLT_RETAINED = false;
static const bool DFLT_DUP = false;

static const std::string TOPIC{"hello"};
static const char* BUF = "Hello there";
static const size_t N = std::strlen(BUF);
static const std::string PAYLOAD{BUF};
;
static const int QOS = 1;
static const std::string RESPONSE_TOPIC{"replies"};
static const properties PROPS{{property::RESPONSE_TOPIC, RESPONSE_TOPIC}};

// --------------------------------------------------------------------------
// Test the default constructor
// --------------------------------------------------------------------------

TEST_CASE("default constructor", "[message]")
{
    mqtt::message msg;

    REQUIRE(msg.get_payload_str().empty());
    REQUIRE(DFLT_QOS == msg.get_qos());
    REQUIRE(DFLT_RETAINED == msg.is_retained());
    REQUIRE(DFLT_DUP == msg.is_duplicate());
    REQUIRE(msg.get_properties().empty());

    const auto& c_struct = msg.c_struct();

    REQUIRE(0 == c_struct.payloadlen);
    REQUIRE(nullptr == c_struct.payload);
    REQUIRE(DFLT_QOS == c_struct.qos);
    REQUIRE(DFLT_RETAINED == (c_struct.retained != 0));
    REQUIRE(DFLT_DUP == (c_struct.dup != 0));
    REQUIRE(0 == c_struct.properties.count);
}

// --------------------------------------------------------------------------
// Test the raw buffer (void*) and length constructor
// --------------------------------------------------------------------------

TEST_CASE("buf len constructor", "[message]")
{
    mqtt::message msg(TOPIC, BUF, N);

    REQUIRE(TOPIC == msg.get_topic());
    REQUIRE(PAYLOAD == msg.get_payload_str());
    REQUIRE(DFLT_QOS == msg.get_qos());
    REQUIRE(DFLT_RETAINED == msg.is_retained());
    REQUIRE(DFLT_DUP == msg.is_duplicate());

    const auto& c_struct = msg.c_struct();

    REQUIRE(int(N) == c_struct.payloadlen);
    REQUIRE(0 == memcmp(BUF, c_struct.payload, N));
    REQUIRE(DFLT_QOS == c_struct.qos);
    REQUIRE(DFLT_RETAINED == (c_struct.retained != 0));
    REQUIRE(DFLT_DUP == (c_struct.dup != 0));
}

// --------------------------------------------------------------------------
// Test the raw buffer (void*) constructor
// --------------------------------------------------------------------------

TEST_CASE("buf constructor", "[message]")
{
    mqtt::message msg(TOPIC, BUF, N, QOS, true, PROPS);

    REQUIRE(TOPIC == msg.get_topic());
    REQUIRE(PAYLOAD == msg.get_payload_str());
    REQUIRE(QOS == msg.get_qos());
    REQUIRE(msg.is_retained());
    REQUIRE(DFLT_DUP == msg.is_duplicate());

    const auto& props = msg.get_properties();
    REQUIRE(1 == props.count(property::RESPONSE_TOPIC));
    REQUIRE(RESPONSE_TOPIC == get<std::string>(props, property::RESPONSE_TOPIC));

    const auto& c_struct = msg.c_struct();

    REQUIRE(int(N) == c_struct.payloadlen);
    REQUIRE(0 == memcmp(BUF, c_struct.payload, N));
    REQUIRE(QOS == c_struct.qos);
    REQUIRE(c_struct.retained != 0);
    REQUIRE(DFLT_DUP == (c_struct.dup != 0));
}

// --------------------------------------------------------------------------
// Test the string buffer constructor
// --------------------------------------------------------------------------

TEST_CASE("string constructor", "[message]")
{
    mqtt::message msg(TOPIC, PAYLOAD);

    REQUIRE(TOPIC == msg.get_topic());
    REQUIRE(PAYLOAD == msg.get_payload_str());
    REQUIRE(DFLT_QOS == msg.get_qos());
    REQUIRE(!msg.is_retained());
    REQUIRE(DFLT_DUP == msg.is_duplicate());
    REQUIRE(msg.get_properties().empty());

    const auto& c_struct = msg.c_struct();

    REQUIRE(int(PAYLOAD.size()) == c_struct.payloadlen);
    REQUIRE(0 == memcmp(PAYLOAD.data(), c_struct.payload, PAYLOAD.size()));
    REQUIRE(DFLT_QOS == c_struct.qos);
    REQUIRE(DFLT_RETAINED == (c_struct.retained != 0));
    REQUIRE(DFLT_DUP == (c_struct.dup != 0));
}

// --------------------------------------------------------------------------
// Test the string buffer with QoS constructor
// --------------------------------------------------------------------------

TEST_CASE("string qos constructor", "[message]")
{
    mqtt::message msg(TOPIC, PAYLOAD, QOS, true, PROPS);

    REQUIRE(TOPIC == msg.get_topic());
    REQUIRE(PAYLOAD == msg.get_payload_str());
    REQUIRE(QOS == msg.get_qos());
    REQUIRE(msg.is_retained());
    REQUIRE(DFLT_DUP == msg.is_duplicate());

    const auto& props = msg.get_properties();
    REQUIRE(1 == props.count(property::RESPONSE_TOPIC));
    REQUIRE(RESPONSE_TOPIC == get<std::string>(props, property::RESPONSE_TOPIC));

    const auto& c_struct = msg.c_struct();

    REQUIRE(int(PAYLOAD.size()) == c_struct.payloadlen);
    REQUIRE(0 == memcmp(PAYLOAD.data(), c_struct.payload, PAYLOAD.size()));
    REQUIRE(QOS == c_struct.qos);
    REQUIRE(c_struct.retained != 0);
    REQUIRE(DFLT_DUP == (c_struct.dup != 0));
}

// --------------------------------------------------------------------------
// Test the initialization by C struct
// --------------------------------------------------------------------------

TEST_CASE("c struct constructor", "[message]")
{
    MQTTAsync_message c_msg = MQTTAsync_message_initializer;

    c_msg.payload = const_cast<char*>(BUF);
    c_msg.payloadlen = int(N);
    c_msg.qos = QOS;
    c_msg.retained = 1;
    c_msg.dup = 1;

    // TODO: Test extracting v5 properties

    mqtt::message msg(TOPIC, c_msg);

    REQUIRE(TOPIC == msg.get_topic());
    REQUIRE(PAYLOAD == msg.get_payload_str());
    REQUIRE(QOS == msg.get_qos());
    REQUIRE(msg.is_retained());
    REQUIRE(msg.is_duplicate());

    const auto& c_struct = msg.c_struct();

    REQUIRE(int(N) == c_struct.payloadlen);
    REQUIRE(0 == memcmp(BUF, c_struct.payload, N));
    REQUIRE(QOS == c_struct.qos);
    REQUIRE(c_struct.retained != 0);
    REQUIRE(c_struct.dup != 0);
}

// --------------------------------------------------------------------------
// Test the copy constructor
// --------------------------------------------------------------------------

TEST_CASE("copy constructor", "[message]")
{
    auto orgMsg = mqtt::message(TOPIC, PAYLOAD, QOS, true, PROPS);

    mqtt::message msg(orgMsg);

    REQUIRE(TOPIC == msg.get_topic());
    REQUIRE(PAYLOAD == msg.get_payload_str());
    REQUIRE(QOS == msg.get_qos());
    REQUIRE(msg.is_retained());

    const auto& props = msg.get_properties();
    REQUIRE(1 == props.count(property::RESPONSE_TOPIC));
    REQUIRE(RESPONSE_TOPIC == get<std::string>(props, property::RESPONSE_TOPIC));

    const auto& c_struct = msg.c_struct();

    REQUIRE(int(PAYLOAD.size()) == c_struct.payloadlen);
    REQUIRE(0 == memcmp(PAYLOAD.data(), c_struct.payload, PAYLOAD.size()));
    REQUIRE(QOS == c_struct.qos);
    REQUIRE(c_struct.retained != 0);
    REQUIRE(DFLT_DUP == (c_struct.dup != 0));

    // Make sure it's a true copy, not linked to the original
    orgMsg.set_payload(EMPTY_STR);
    orgMsg.set_qos(DFLT_QOS);
    orgMsg.set_retained(false);

    REQUIRE(PAYLOAD == msg.get_payload_str());
    REQUIRE(QOS == msg.get_qos());
    REQUIRE(msg.is_retained());
}

// --------------------------------------------------------------------------
// Test the move constructor
// --------------------------------------------------------------------------

TEST_CASE("move constructor", "[message]")
{
    auto orgMsg = mqtt::message(TOPIC, PAYLOAD, QOS, true, PROPS);

    mqtt::message msg(std::move(orgMsg));

    REQUIRE(TOPIC == msg.get_topic());
    REQUIRE(PAYLOAD == msg.get_payload_str());
    REQUIRE(QOS == msg.get_qos());
    REQUIRE(msg.is_retained());

    const auto& props = msg.get_properties();
    REQUIRE(1 == props.count(property::RESPONSE_TOPIC));
    REQUIRE(RESPONSE_TOPIC == get<std::string>(props, property::RESPONSE_TOPIC));

    const auto& c_struct = msg.c_struct();

    REQUIRE(int(PAYLOAD.size()) == c_struct.payloadlen);
    REQUIRE(0 == memcmp(PAYLOAD.data(), c_struct.payload, PAYLOAD.size()));
    REQUIRE(QOS == c_struct.qos);
    REQUIRE(c_struct.retained != 0);
    REQUIRE(DFLT_DUP == (c_struct.dup != 0));

    // Check that the original was moved
    REQUIRE(size_t(0) == orgMsg.get_payload().size());
    REQUIRE(orgMsg.get_properties().empty());
}

// --------------------------------------------------------------------------
// Test the copy assignment operator=(const&)
// --------------------------------------------------------------------------

TEST_CASE("copy assignment", "[message]")
{
    auto orgMsg = mqtt::message(TOPIC, PAYLOAD, QOS, true, PROPS);

    mqtt::message msg;
    msg = orgMsg;

    // Make sure it's a true copy, not linked to the original
    orgMsg.set_payload(EMPTY_STR);
    orgMsg.set_qos(DFLT_QOS);
    orgMsg.set_retained(false);
    orgMsg.set_properties({});

    REQUIRE(TOPIC == msg.get_topic());
    REQUIRE(PAYLOAD == msg.get_payload_str());
    REQUIRE(QOS == msg.get_qos());
    REQUIRE(msg.is_retained());

    const auto& props = msg.get_properties();
    REQUIRE(1 == props.count(property::RESPONSE_TOPIC));
    REQUIRE(RESPONSE_TOPIC == get<std::string>(props, property::RESPONSE_TOPIC));

    const auto& c_struct = msg.c_struct();

    REQUIRE(int(PAYLOAD.size()) == c_struct.payloadlen);
    REQUIRE(0 == memcmp(PAYLOAD.data(), c_struct.payload, PAYLOAD.size()));
    REQUIRE(QOS == c_struct.qos);
    REQUIRE(c_struct.retained != 0);
    REQUIRE(DFLT_DUP == (c_struct.dup != 0));

    // Self assignment should cause no harm
    msg = msg;

    REQUIRE(PAYLOAD == msg.get_payload_str());
    REQUIRE(QOS == msg.get_qos());
    REQUIRE(msg.is_retained());
}

// --------------------------------------------------------------------------
// Test the move assignment, operator=(&&)
// --------------------------------------------------------------------------

TEST_CASE("move assignment", "[message]")
{
    auto orgMsg = mqtt::message(TOPIC, PAYLOAD, QOS, true, PROPS);

    mqtt::message msg;
    msg = std::move(orgMsg);

    REQUIRE(TOPIC == msg.get_topic());
    REQUIRE(PAYLOAD == msg.get_payload_str());
    REQUIRE(QOS == msg.get_qos());
    REQUIRE(msg.is_retained());

    const auto& props = msg.get_properties();
    REQUIRE(1 == props.count(property::RESPONSE_TOPIC));
    REQUIRE(RESPONSE_TOPIC == get<std::string>(props, property::RESPONSE_TOPIC));

    const auto& c_struct = msg.c_struct();

    REQUIRE(int(PAYLOAD.size()) == c_struct.payloadlen);
    REQUIRE(0 == memcmp(PAYLOAD.data(), c_struct.payload, PAYLOAD.size()));
    REQUIRE(QOS == c_struct.qos);
    REQUIRE(c_struct.retained != 0);
    REQUIRE(DFLT_DUP == (c_struct.dup != 0));

    // Check that the original was moved
    REQUIRE(size_t(0) == orgMsg.get_payload().size());
    REQUIRE(orgMsg.get_properties().empty());

// Self assignment should cause no harm
// (clang++ is smart enough to warn about this)
#if !defined(__clang__)
    msg = std::move(msg);
    REQUIRE(PAYLOAD == msg.get_payload_str());
    REQUIRE(QOS == msg.get_qos());
    REQUIRE(msg.is_retained());
#endif
}

// --------------------------------------------------------------------------
// Test the validate_qos()
// --------------------------------------------------------------------------

TEST_CASE("validate qos", "[message]")
{
    REQUIRE_THROWS_AS(mqtt::message::validate_qos(-1), mqtt::exception);
    REQUIRE_THROWS_AS(mqtt::message::validate_qos(3), mqtt::exception);

    REQUIRE_NOTHROW(mqtt::message::validate_qos(0));
}

/////////////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------------
// Test the default builder
// --------------------------------------------------------------------------

TEST_CASE("default builder", "[message]")
{
    auto msg = mqtt::message_ptr_builder().finalize();

    REQUIRE(EMPTY_STR == msg->get_payload_str());
    REQUIRE(DFLT_QOS == msg->get_qos());
    REQUIRE(DFLT_RETAINED == msg->is_retained());
    REQUIRE(DFLT_DUP == msg->is_duplicate());

    const auto& c_struct = msg->c_struct();

    REQUIRE(0 == c_struct.payloadlen);
    REQUIRE(nullptr == c_struct.payload);
    REQUIRE(DFLT_QOS == c_struct.qos);
    REQUIRE(DFLT_RETAINED == (c_struct.retained != 0));
    REQUIRE(DFLT_DUP == (c_struct.dup != 0));
}

// --------------------------------------------------------------------------
// Test a complete builder
// --------------------------------------------------------------------------

TEST_CASE("builder", "[message]")
{
    auto msg = mqtt::message_ptr_builder()
                   .topic(TOPIC)
                   .payload(PAYLOAD)
                   .qos(QOS)
                   .retained(true)
                   .properties(PROPS)
                   .finalize();

    REQUIRE(TOPIC == msg->get_topic());
    REQUIRE(PAYLOAD == msg->get_payload_str());
    REQUIRE(QOS == msg->get_qos());
    REQUIRE(msg->is_retained());
    REQUIRE(DFLT_DUP == msg->is_duplicate());

    const auto& props = msg->get_properties();
    REQUIRE(1 == props.count(property::RESPONSE_TOPIC));
    REQUIRE(RESPONSE_TOPIC == get<std::string>(props, property::RESPONSE_TOPIC));

    const auto& c_struct = msg->c_struct();

    REQUIRE(int(PAYLOAD.size()) == c_struct.payloadlen);
    REQUIRE(0 == memcmp(PAYLOAD.data(), c_struct.payload, PAYLOAD.size()));
    REQUIRE(QOS == c_struct.qos);
    REQUIRE(c_struct.retained != 0);
    REQUIRE(DFLT_DUP == (c_struct.dup != 0));
}

```

`test/unit/test_persistence.cpp`:

```cpp
// test_persistence.cpp
//
// Unit tests for the iclient_persistence class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2016 Guilherme M. Ferreira <guilherme.maciel.ferreira@gmail.com>
 * Copyright (c) 2020 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme M. Ferreira - initial implementation and documentation
 *    Frank Pagliughi - Converted to use Catch2
 *******************************************************************************/

#define UNIT_TESTS

#include <cstring>

#include "catch2_version.h"
#include "mock_persistence.h"
#include "mqtt/iclient_persistence.h"

using namespace mqtt;

static const char* CLIENT_ID = "clientid";
static const char* SERVER_URI = "serveruri";
static const char* KEY = "key";
static const char* INVALID_KEY = "invalid_key";

static const char* PAYLOAD = "some random data";
static const size_t PAYLOAD_LEN = strlen(PAYLOAD);

static const char* PAYLOAD2 = "some other random data";
static const size_t PAYLOAD2_LEN = strlen(PAYLOAD2);

static const char* PAYLOAD3 = "some completely random data";
static const size_t PAYLOAD3_LEN = strlen(PAYLOAD3);

using dcp = mock_persistence;

// ----------------------------------------------------------------------
// Test static method persistence_open()
// ----------------------------------------------------------------------

TEST_CASE("persistence", "[persistence]")
{
    dcp per_;
    void* handle_;
    void* context = dynamic_cast<iclient_persistence*>(&per_);

    dcp::persistence_open(&handle_, CLIENT_ID, SERVER_URI, context);

    // Put no buffer
    int bufcount = 3;
    const char* bufs[] = {PAYLOAD, PAYLOAD2, PAYLOAD3};
    int buflens[] = {int(PAYLOAD_LEN), int(PAYLOAD2_LEN), int(PAYLOAD3_LEN)};

    dcp::persistence_put(
        handle_, const_cast<char*>(KEY), bufcount, const_cast<char**>(bufs), buflens
    );

    SECTION("test persistence open")
    {
        dcp per;
        void* handle = nullptr;
        void* context = dynamic_cast<iclient_persistence*>(&per);

        REQUIRE(
            MQTTCLIENT_PERSISTENCE_ERROR ==
            dcp::persistence_open(&handle, CLIENT_ID, SERVER_URI, nullptr)
        );

        REQUIRE(
            MQTTASYNC_SUCCESS ==
            dcp::persistence_open(&handle, CLIENT_ID, SERVER_URI, context)
        );
        REQUIRE(handle == context);
    }

    // ----------------------------------------------------------------------
    // Test static method persistence_close()
    // ----------------------------------------------------------------------

    SECTION("test persistence close")
    {
        dcp per;

        REQUIRE(MQTTCLIENT_PERSISTENCE_ERROR == dcp::persistence_close(nullptr));

        void* context = dynamic_cast<iclient_persistence*>(&per);
        void* handle = nullptr;
        dcp::persistence_open(&handle, CLIENT_ID, SERVER_URI, context);

        REQUIRE(MQTTASYNC_SUCCESS == dcp::persistence_close(handle));
    }

    // ----------------------------------------------------------------------
    // Test static method persistence_put()
    // ----------------------------------------------------------------------

    SECTION("test persistence put 0 buffer")
    {
        dcp per;
        void* handle;
        dcp::persistence_open(
            &handle, CLIENT_ID, SERVER_URI, dynamic_cast<iclient_persistence*>(&per)
        );

        // Put no buffer
        int bufcount = 0;
        const char* bufs[] = {PAYLOAD};
        int buflens[] = {int(PAYLOAD_LEN)};

        REQUIRE(
            MQTTCLIENT_PERSISTENCE_ERROR ==
            dcp::persistence_put(
                handle, const_cast<char*>(KEY), bufcount, const_cast<char**>(bufs), buflens
            )
        );
    }

    SECTION("persistence put 1 buffer")
    {
        dcp per;
        void* handle;
        dcp::persistence_open(
            &handle, CLIENT_ID, SERVER_URI, dynamic_cast<iclient_persistence*>(&per)
        );

        // Put no buffer
        int bufcount = 1;
        const char* bufs[] = {PAYLOAD};
        int buflens[] = {int(PAYLOAD_LEN)};

        REQUIRE(
            MQTTASYNC_SUCCESS ==
            dcp::persistence_put(
                handle, const_cast<char*>(KEY), bufcount, const_cast<char**>(bufs), buflens
            )
        );
        REQUIRE(
            MQTTASYNC_SUCCESS == dcp::persistence_containskey(handle, const_cast<char*>(KEY))
        );
        REQUIRE(
            MQTTCLIENT_PERSISTENCE_ERROR ==
            dcp::persistence_containskey(handle, const_cast<char*>(INVALID_KEY))
        );
    }

    SECTION("test persistence put 2 buffers")
    {
        dcp per;
        void* handle;
        dcp::persistence_open(
            &handle, CLIENT_ID, SERVER_URI, dynamic_cast<iclient_persistence*>(&per)
        );

        // Put no buffer
        int bufcount = 2;
        const char* bufs[] = {PAYLOAD, PAYLOAD2};
        int buflens[] = {int(PAYLOAD_LEN), int(PAYLOAD2_LEN)};

        REQUIRE(
            MQTTASYNC_SUCCESS ==
            dcp::persistence_put(
                handle, const_cast<char*>(KEY), bufcount, const_cast<char**>(bufs), buflens
            )
        );
        REQUIRE(
            MQTTASYNC_SUCCESS == dcp::persistence_containskey(handle, const_cast<char*>(KEY))
        );
        REQUIRE(
            MQTTCLIENT_PERSISTENCE_ERROR ==
            dcp::persistence_containskey(handle, const_cast<char*>(INVALID_KEY))
        );
    }

    SECTION("test persistence put 3 buffers")
    {
        REQUIRE(
            MQTTASYNC_SUCCESS == dcp::persistence_containskey(handle_, const_cast<char*>(KEY))
        );
        REQUIRE(
            MQTTCLIENT_PERSISTENCE_ERROR ==
            dcp::persistence_containskey(handle_, const_cast<char*>(INVALID_KEY))
        );
    }

    SECTION("test persistence put empty buffers")
    {
        dcp per;
        void* handle;
        dcp::persistence_open(
            &handle, CLIENT_ID, SERVER_URI, dynamic_cast<iclient_persistence*>(&per)
        );

        // Put three empty buffers
        int bufcount = 3;
        const char* buffers[] = {"", "", ""};
        int buflens[] = {0, 0, 0};
        REQUIRE(
            MQTTASYNC_SUCCESS ==
            dcp::persistence_put(
                handle, const_cast<char*>(KEY), bufcount, const_cast<char**>(buffers), buflens
            )
        );
    }

    // ----------------------------------------------------------------------
    // Test static method persistence_get()
    // ----------------------------------------------------------------------

    SECTION("test persistence get")
    {
        char* buf = nullptr;
        int buflen = 0;
        REQUIRE(
            MQTTCLIENT_PERSISTENCE_ERROR ==
            dcp::persistence_get(handle_, const_cast<char*>(INVALID_KEY), &buf, &buflen)
        );
        REQUIRE(0 == buflen);

        REQUIRE(
            MQTTASYNC_SUCCESS ==
            dcp::persistence_get(handle_, const_cast<char*>(KEY), &buf, &buflen)
        );

        size_t n = PAYLOAD_LEN + PAYLOAD2_LEN + PAYLOAD3_LEN;
        string str{PAYLOAD};
        str += PAYLOAD2;
        str += PAYLOAD3;

        REQUIRE(int(n) == buflen);
        REQUIRE(buf != nullptr);
        REQUIRE(memcmp(str.data(), buf, n) == 0);
    }

    // ----------------------------------------------------------------------
    // Test static method persistence_remove()
    // ----------------------------------------------------------------------

    SECTION("test persistence remove")
    {
        REQUIRE(
            MQTTCLIENT_PERSISTENCE_ERROR ==
            dcp::persistence_remove(handle_, const_cast<char*>(INVALID_KEY))
        );
        REQUIRE(
            MQTTASYNC_SUCCESS == dcp::persistence_containskey(handle_, const_cast<char*>(KEY))
        );
        REQUIRE(
            MQTTASYNC_SUCCESS == dcp::persistence_remove(handle_, const_cast<char*>(KEY))
        );
        REQUIRE(
            MQTTCLIENT_PERSISTENCE_ERROR ==
            dcp::persistence_containskey(handle_, const_cast<char*>(KEY))
        );
    }

    // ----------------------------------------------------------------------
    // Test static method persistence_keys()
    // ----------------------------------------------------------------------

    SECTION("test persistence keys")
    {
        char** keys = nullptr;
        int nkeys = 0;

        REQUIRE(MQTTASYNC_SUCCESS == dcp::persistence_keys(handle_, &keys, &nkeys));
        REQUIRE(1 == nkeys);
        REQUIRE(std::string(KEY) == std::string(keys[0]));
        // CPPUNIT_ASSERT(!strcmp(KEY, keys[0]));
    }

    // ----------------------------------------------------------------------
    // Test static method persistence_clear()
    // ----------------------------------------------------------------------

    SECTION("test persistence clear")
    {
        REQUIRE(
            MQTTASYNC_SUCCESS == dcp::persistence_containskey(handle_, const_cast<char*>(KEY))
        );
        REQUIRE(MQTTASYNC_SUCCESS == dcp::persistence_clear(handle_));
        REQUIRE(
            MQTTCLIENT_PERSISTENCE_ERROR ==
            dcp::persistence_containskey(handle_, const_cast<char*>(KEY))
        );

        char** keys = nullptr;
        int nkeys = -1;

        REQUIRE(MQTTASYNC_SUCCESS == dcp::persistence_keys(handle_, &keys, &nkeys));
        REQUIRE(0 == nkeys);
    }

    dcp::persistence_clear(handle_);
    dcp::persistence_close(handle_);
}

```

`test/unit/test_properties.cpp`:

```cpp
// test_properties.cpp
//
// Catch2 unit tests for the 'property' and 'properties' classes in the
// Eclipse Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2020-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#include <cstring>
#include <iostream>

#include "catch2_version.h"
#include "mqtt/properties.h"

using namespace mqtt;

inline bool stringcmp(char* cstr, const string& s)
{
    return std::memcmp(cstr, s.data(), s.length()) == 0;
}

static const uint8_t FMT_IND = 42;
static const uint16_t TOP_ALIAS = 511;
static const uint32_t MAX_PKT_SZ = 32 * 1024;

static const string TOPIC{"replies/bubba"};
static const string NAME1{"usr1"}, NAME2{"usr2"}, VALUE1{"this is value one"},
    VALUE2{"this is value two"};

static const binary CORR_ID{"\x00\x01\x02\x03\x04", 5};

/////////////////////////////////////////////////////////////////////////////
// property

TEST_CASE("int property constructor", "[property]")
{
    // This is a known byte property
    SECTION("creating a byte property")
    {
        property::code typ = property::PAYLOAD_FORMAT_INDICATOR;

        property prop{typ, 42};

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_PAYLOAD_FORMAT_INDICATOR);
        REQUIRE(prop.c_struct().value.byte == 42);

        REQUIRE(prop.type() == typ);
        REQUIRE(get<uint8_t>(prop) == uint8_t(42));
    }

    SECTION("creating a bad byte property")
    {
        // TODO: Test constructor for out of range input
    }

    // This is a known 2-byte integer property
    SECTION("creating an int2 property")
    {
        property::code typ = property::TOPIC_ALIAS;

        property prop{typ, 512};

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_TOPIC_ALIAS);
        REQUIRE(prop.c_struct().value.integer2 == 512);

        REQUIRE(prop.type() == typ);
        REQUIRE(get<uint16_t>(prop) == 512);

        // Should be able to support full 16-bit unsigned range
        const uint16_t MAX = std::numeric_limits<uint16_t>::max();

        property propMax{typ, MAX};
        REQUIRE(get<uint16_t>(propMax) == MAX);
    }

    SECTION("creating a bad int2 property")
    {
        // TODO: Test constructor for out of range input
    }

    // This is a known 4-byte integer property
    SECTION("creating an int4 property")
    {
        property::code typ = property::MESSAGE_EXPIRY_INTERVAL;

        property prop{typ, 70000};

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_MESSAGE_EXPIRY_INTERVAL);
        REQUIRE(prop.c_struct().value.integer4 == 70000);

        REQUIRE(prop.type() == typ);
        REQUIRE(get<uint32_t>(prop) == 70000);

        // Should be able to support full 32-bit unsigned range
        const uint32_t MAX = std::numeric_limits<uint32_t>::max();

        property propMax{typ, MAX};
        REQUIRE(get<uint32_t>(propMax) == MAX);
    }

    SECTION("creating a bad int2 property")
    {
        // TODO: Test constructor for out of range input
    }
}

TEST_CASE("string property constructor", "[property]")
{
    property::code typ = property::RESPONSE_TOPIC;

    SECTION("property from string")
    {
        string topic{"replies/bubba"};

        property prop{typ, topic};

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_RESPONSE_TOPIC);
        REQUIRE(prop.c_struct().value.data.len == int(topic.length()));
        REQUIRE(stringcmp(prop.c_struct().value.data.data, topic));

        REQUIRE(prop.type() == typ);
        REQUIRE(get<string>(prop) == topic);
    }

    SECTION("property from c-string")
    {
        const char* topic = "replies/bubba";
        size_t n = std::strlen(topic);

        property prop{typ, topic};

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_RESPONSE_TOPIC);
        REQUIRE(prop.c_struct().value.data.len == int(n));
        REQUIRE(std::memcmp(prop.c_struct().value.data.data, topic, n) == 0);

        REQUIRE(prop.type() == typ);
        REQUIRE(get<string>(prop) == string(topic, n));
    }
}

TEST_CASE("binary property constructor", "[property]")
{
    SECTION("property from binary")
    {
        property::code typ = property::CORRELATION_DATA;
        const size_t LEN = 5;
        binary corr_id{"\x00\x01\x02\x03\x04", LEN};

        property prop{property::CORRELATION_DATA, corr_id};

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_CORRELATION_DATA);
        REQUIRE(prop.c_struct().value.data.len == int(corr_id.length()));
        REQUIRE(std::memcmp(prop.c_struct().value.data.data, corr_id.data(), LEN) == 0);

        REQUIRE(prop.type() == typ);
        REQUIRE(get<binary>(prop) == corr_id);
    }
}

TEST_CASE("string pair property constructor", "[property]")
{
    property::code typ = property::USER_PROPERTY;

    SECTION("property from strings")
    {
        string name{"bubba"}, value{"some val"};

        property prop{typ, name, value};

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_USER_PROPERTY);

        REQUIRE(prop.c_struct().value.data.len == int(name.length()));
        REQUIRE(stringcmp(prop.c_struct().value.data.data, name));

        REQUIRE(prop.c_struct().value.value.len == int(value.length()));
        REQUIRE(stringcmp(prop.c_struct().value.value.data, value));

        REQUIRE(prop.type() == typ);

        auto usr = get<string_pair>(prop);
        REQUIRE(std::get<0>(usr) == name);
        REQUIRE(std::get<1>(usr) == value);
    }

    SECTION("property from c-strings")
    {
        const char* name = "bubba";
        size_t name_len = strlen(name);

        const char* value = "some val";
        size_t value_len = strlen(value);

        property prop{typ, name, value};

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_USER_PROPERTY);

        REQUIRE(prop.c_struct().value.data.len == name_len);
        REQUIRE(std::memcmp(prop.c_struct().value.data.data, name, name_len) == 0);

        REQUIRE(prop.c_struct().value.value.len == value_len);
        REQUIRE(std::memcmp(prop.c_struct().value.value.data, value, value_len) == 0);

        REQUIRE(prop.type() == typ);

        auto usr = get<string_pair>(prop);
        REQUIRE(std::get<0>(usr) == string(name, name_len));
        REQUIRE(std::get<1>(usr) == string(value, value_len));
    }
}

TEST_CASE("int property copy constructor", "[property]")
{
    SECTION("copy an int4 property")
    {
        property::code typ = property::MESSAGE_EXPIRY_INTERVAL;

        property org_prop{typ, 70000};
        property prop{org_prop};

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_MESSAGE_EXPIRY_INTERVAL);
        REQUIRE(prop.c_struct().value.integer4 == 70000);

        REQUIRE(prop.type() == typ);
        REQUIRE(get<uint32_t>(prop) == 70000);
    }
}

TEST_CASE("int property move constructor", "[property]")
{
    SECTION("move an int4 property")
    {
        property::code typ = property::MESSAGE_EXPIRY_INTERVAL;

        property org_prop{typ, 70000};
        property prop{std::move(org_prop)};

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_MESSAGE_EXPIRY_INTERVAL);
        REQUIRE(prop.c_struct().value.integer4 == 70000);

        REQUIRE(prop.type() == typ);
        REQUIRE(get<uint32_t>(prop) == 70000);

        // Make sure the old value was moved
        REQUIRE(org_prop.c_struct().identifier == 0);
        REQUIRE(org_prop.c_struct().value.integer4 == 0);
    }
}

TEST_CASE("string property copy constructor", "[property]")
{
    SECTION("copy a string property")
    {
        property::code typ = property::RESPONSE_TOPIC;
        string topic{"replies/bubba"};

        property org_prop{typ, topic};
        property prop{org_prop};

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_RESPONSE_TOPIC);

        REQUIRE(prop.c_struct().value.data.len == int(topic.length()));
        REQUIRE(
            std::memcmp(prop.c_struct().value.data.data, topic.data(), topic.length()) == 0
        );

        REQUIRE(prop.type() == typ);
        REQUIRE(get<string>(prop) == topic);
    }

    // Make sure the copy is still valid after the original disappears
    SECTION("copy a temp string property")
    {
        property::code typ = property::RESPONSE_TOPIC;
        string topic{"replies/bubba"};

        std::unique_ptr<property> org_prop{new property{typ, topic}};
        property prop{*org_prop};
        org_prop.reset(nullptr);

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_RESPONSE_TOPIC);

        REQUIRE(prop.c_struct().value.data.len == int(topic.length()));
        REQUIRE(
            std::memcmp(prop.c_struct().value.data.data, topic.data(), topic.length()) == 0
        );

        REQUIRE(prop.type() == typ);
        REQUIRE(get<string>(prop) == topic);
    }
}

TEST_CASE("string property move constructor", "[property]")
{
    SECTION("move a string property")
    {
        property::code typ = property::RESPONSE_TOPIC;
        string topic{"replies/bubba"};

        property org_prop{typ, topic};
        property prop{std::move(org_prop)};

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_RESPONSE_TOPIC);

        REQUIRE(prop.c_struct().value.data.len == int(topic.length()));
        REQUIRE(stringcmp(prop.c_struct().value.data.data, topic));

        REQUIRE(prop.type() == typ);
        REQUIRE(get<string>(prop) == topic);

        // Make sure the old value was moved
        REQUIRE(org_prop.c_struct().identifier == 0);
        REQUIRE(org_prop.c_struct().value.data.len == 0);
        REQUIRE(org_prop.c_struct().value.data.data == nullptr);
    }
}

TEST_CASE("string pair property copy constructor", "[property]")
{
    property::code typ = property::USER_PROPERTY;

    SECTION("property from strings")
    {
        string name{"bubba"}, value{"some val"};

        property org_prop{typ, name, value};
        property prop{org_prop};

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_USER_PROPERTY);

        REQUIRE(prop.c_struct().value.data.len == int(name.length()));
        REQUIRE(stringcmp(prop.c_struct().value.data.data, name));

        REQUIRE(prop.c_struct().value.value.len == int(value.length()));
        REQUIRE(stringcmp(prop.c_struct().value.value.data, value));

        REQUIRE(prop.type() == typ);

        auto usr = get<string_pair>(prop);
        REQUIRE(std::get<0>(usr) == name);
        REQUIRE(std::get<1>(usr) == value);
    }

    // Make sure the property is still valid after the original disappears
    SECTION("property from temp strings property")
    {
        string name{"bubba"}, value{"some val"};

        std::unique_ptr<property> org_prop{new property{typ, name, value}};
        property prop{*org_prop};
        org_prop.reset(nullptr);

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_USER_PROPERTY);

        REQUIRE(prop.c_struct().value.data.len == int(name.length()));
        REQUIRE(stringcmp(prop.c_struct().value.data.data, name));

        REQUIRE(prop.c_struct().value.value.len == int(value.length()));
        REQUIRE(stringcmp(prop.c_struct().value.value.data, value));

        REQUIRE(prop.type() == typ);

        auto usr = get<string_pair>(prop);
        REQUIRE(std::get<0>(usr) == name);
        REQUIRE(std::get<1>(usr) == value);
    }
}

TEST_CASE("string pair property move constructor", "[property]")
{
    property::code typ = property::USER_PROPERTY;

    SECTION("property from strings")
    {
        string name{"bubba"}, value{"some val"};

        property org_prop{typ, name, value};
        property prop{std::move(org_prop)};

        REQUIRE(prop.c_struct().identifier == MQTTPROPERTY_CODE_USER_PROPERTY);

        REQUIRE(prop.c_struct().value.data.len == int(name.length()));
        REQUIRE(stringcmp(prop.c_struct().value.data.data, name));

        REQUIRE(prop.c_struct().value.value.len == int(value.length()));
        REQUIRE(stringcmp(prop.c_struct().value.value.data, value));

        REQUIRE(prop.type() == typ);

        auto usr = get<string_pair>(prop);
        REQUIRE(std::get<0>(usr) == name);
        REQUIRE(std::get<1>(usr) == value);

        // Make sure the old value was moved
        REQUIRE(org_prop.c_struct().identifier == 0);
        REQUIRE(org_prop.c_struct().value.data.len == 0);
        REQUIRE(org_prop.c_struct().value.data.data == nullptr);
        REQUIRE(org_prop.c_struct().value.value.len == 0);
        REQUIRE(org_prop.c_struct().value.value.data == nullptr);
    }
}

/////////////////////////////////////////////////////////////////////////////
// properties

TEST_CASE("properties constructors", "[properties]")
{
    SECTION("properties default constructor")
    {
        properties props;
        REQUIRE(props.empty());
        REQUIRE(props.size() == 0);
    }

    SECTION("properties init list constructor")
    {
        properties props{
            {property::PAYLOAD_FORMAT_INDICATOR, 42},
            {property::MESSAGE_EXPIRY_INTERVAL, 70000}
        };
        REQUIRE(props.size() == 2);

        REQUIRE(42 == get<uint8_t>(props, property::PAYLOAD_FORMAT_INDICATOR));
        REQUIRE(70000 == get<uint32_t>(props, property::MESSAGE_EXPIRY_INTERVAL));
    }
}

TEST_CASE("properties add", "[properties]")
{
    SECTION("properties adding items")
    {
        properties props;
        REQUIRE(props.empty());
        REQUIRE(props.size() == 0);

        props.add({property::PAYLOAD_FORMAT_INDICATOR, 42});
        REQUIRE(!props.empty());
        REQUIRE(props.size() == 1);

        props.add({property::MESSAGE_EXPIRY_INTERVAL, 70000});
        REQUIRE(!props.empty());
        REQUIRE(props.size() == 2);
    }
}

TEST_CASE("properties clear", "[properties]")
{
    SECTION("properties clear")
    {
        properties props{
            {property::PAYLOAD_FORMAT_INDICATOR, 42},
            {property::MESSAGE_EXPIRY_INTERVAL, 70000}
        };
        REQUIRE(props.size() == 2);

        props.clear();
        REQUIRE(props.empty());
        REQUIRE(props.size() == 0);
    }
}

TEST_CASE("properties count and contains", "[properties]")
{
    SECTION("single count properties")
    {
        properties props;

        REQUIRE(props.count(property::PAYLOAD_FORMAT_INDICATOR) == 0);
        REQUIRE(!props.contains(property::PAYLOAD_FORMAT_INDICATOR));

        props.add({property::PAYLOAD_FORMAT_INDICATOR, 42});
        REQUIRE(props.count(property::PAYLOAD_FORMAT_INDICATOR) == 1);
        REQUIRE(props.contains(property::PAYLOAD_FORMAT_INDICATOR));

        props.add({property::MESSAGE_EXPIRY_INTERVAL, 70000});
        REQUIRE(props.count(property::MESSAGE_EXPIRY_INTERVAL) == 1);

        // Make sure adding expirary didn't affect format ind
        REQUIRE(props.count(property::PAYLOAD_FORMAT_INDICATOR) == 1);
        REQUIRE(props.contains(property::PAYLOAD_FORMAT_INDICATOR));
    }

    /*
    SECTION("single count properties with multi add") {
        properties props;

        props.add({property::PAYLOAD_FORMAT_INDICATOR, 42});
        REQUIRE(props.count(property::PAYLOAD_FORMAT_INDICATOR) == 1);

        // Can't add again
        props.add({property::PAYLOAD_FORMAT_INDICATOR, 16});
        REQUIRE(props.count(property::PAYLOAD_FORMAT_INDICATOR) == 1);
    }
    */

    SECTION("multi count properties")
    {
        properties props;

        REQUIRE(props.count(property::USER_PROPERTY) == 0);

        props.add({property::USER_PROPERTY, "usr1", "bubba"});
        REQUIRE(props.count(property::USER_PROPERTY) == 1);

        props.add({property::USER_PROPERTY, "usr2", "wally"});
        REQUIRE(props.count(property::USER_PROPERTY) == 2);

        props.add({property::USER_PROPERTY, "usr3", "some longer property value"});
        REQUIRE(props.count(property::USER_PROPERTY) == 3);
    }
}

TEST_CASE("getting properties", "[properties]")
{
    SECTION("integer properties")
    {
        properties props{
            {property::PAYLOAD_FORMAT_INDICATOR, FMT_IND},
            {property::MAXIMUM_PACKET_SIZE, MAX_PKT_SZ},
            {property::TOPIC_ALIAS, TOP_ALIAS}
        };

        auto fmtInd = props.get(property::PAYLOAD_FORMAT_INDICATOR);
        REQUIRE(get<uint8_t>(fmtInd) == FMT_IND);

        auto topAlias = props.get(property::TOPIC_ALIAS);
        REQUIRE(get<uint16_t>(topAlias) == TOP_ALIAS);

        auto maxPktSz = props.get(property::MAXIMUM_PACKET_SIZE);
        REQUIRE(get<uint32_t>(maxPktSz) == MAX_PKT_SZ);
    }

    SECTION("integer properties with typed get")
    {
        properties props{
            {property::PAYLOAD_FORMAT_INDICATOR, FMT_IND},
            {property::MAXIMUM_PACKET_SIZE, MAX_PKT_SZ},
            {property::TOPIC_ALIAS, TOP_ALIAS}
        };

        REQUIRE(get<uint8_t>(props, property::PAYLOAD_FORMAT_INDICATOR) == FMT_IND);
        REQUIRE(get<uint16_t>(props, property::TOPIC_ALIAS) == TOP_ALIAS);
        REQUIRE(get<uint32_t>(props, property::MAXIMUM_PACKET_SIZE) == MAX_PKT_SZ);
    }

    SECTION("string properties")
    {
        properties props{
            {property::RESPONSE_TOPIC, TOPIC}, {property::CORRELATION_DATA, CORR_ID}
        };

        REQUIRE(get<string>(props, property::RESPONSE_TOPIC) == TOPIC);
        REQUIRE(get<binary>(props, property::CORRELATION_DATA) == CORR_ID);
    }

    SECTION("string pair properties")
    {
        properties props{
            {property::USER_PROPERTY, NAME1, VALUE1}, {property::USER_PROPERTY, NAME2, VALUE2}
        };

        string name1, value1, name2, value2;

        std::tie(name1, value1) = get<string_pair>(props, property::USER_PROPERTY, 0);
        std::tie(name2, value2) = get<string_pair>(props, property::USER_PROPERTY, 1);

        REQUIRE(name1 == NAME1);
        REQUIRE(value1 == VALUE1);

        REQUIRE(name2 == NAME2);
        REQUIRE(value2 == VALUE2);
    }
}

TEST_CASE("properties copy and move", "[properties]")
{
    properties orgProps{
        {property::PAYLOAD_FORMAT_INDICATOR, FMT_IND},
        {property::MAXIMUM_PACKET_SIZE, MAX_PKT_SZ},
        {property::TOPIC_ALIAS, TOP_ALIAS},
        {property::RESPONSE_TOPIC, TOPIC},
        {property::CORRELATION_DATA, CORR_ID},
        {property::USER_PROPERTY, NAME1, VALUE1},
        {property::USER_PROPERTY, NAME2, VALUE2}
    };

    string name1, value1, name2, value2;

    SECTION("copy constructor")
    {
        properties props{orgProps};

        // Make sure it's a real copy, not a reference to org
        const auto& cprops = props.c_struct();
        const auto& orgCprops = orgProps.c_struct();
        REQUIRE(orgCprops.array != cprops.array);

        orgProps.clear();

        REQUIRE(get<uint8_t>(props, property::PAYLOAD_FORMAT_INDICATOR) == FMT_IND);
        REQUIRE(get<uint16_t>(props, property::TOPIC_ALIAS) == TOP_ALIAS);
        REQUIRE(get<uint32_t>(props, property::MAXIMUM_PACKET_SIZE) == MAX_PKT_SZ);

        REQUIRE(get<string>(props, property::RESPONSE_TOPIC) == TOPIC);
        REQUIRE(get<binary>(props, property::CORRELATION_DATA) == CORR_ID);

        std::tie(name1, value1) = get<string_pair>(props, property::USER_PROPERTY, 0);
        std::tie(name2, value2) = get<string_pair>(props, property::USER_PROPERTY, 1);

        REQUIRE(name1 == NAME1);
        REQUIRE(value1 == VALUE1);

        REQUIRE(name2 == NAME2);
        REQUIRE(value2 == VALUE2);
    }

    SECTION("move constructor")
    {
        properties props{std::move(orgProps)};

        REQUIRE(get<uint8_t>(props, property::PAYLOAD_FORMAT_INDICATOR) == FMT_IND);
        REQUIRE(get<uint16_t>(props, property::TOPIC_ALIAS) == TOP_ALIAS);
        REQUIRE(get<uint32_t>(props, property::MAXIMUM_PACKET_SIZE) == MAX_PKT_SZ);

        REQUIRE(get<string>(props, property::RESPONSE_TOPIC) == TOPIC);
        REQUIRE(get<binary>(props, property::CORRELATION_DATA) == CORR_ID);

        std::tie(name1, value1) = get<string_pair>(props, property::USER_PROPERTY, 0);
        std::tie(name2, value2) = get<string_pair>(props, property::USER_PROPERTY, 1);

        REQUIRE(name1 == NAME1);
        REQUIRE(value1 == VALUE1);

        REQUIRE(name2 == NAME2);
        REQUIRE(value2 == VALUE2);

        REQUIRE(orgProps.empty());
        REQUIRE(0 == orgProps.size());

        const auto& orgCprops = orgProps.c_struct();
        REQUIRE(nullptr == orgCprops.array);
    }

    SECTION("copy assignment")
    {
        properties props;
        props = orgProps;

        // Make sure it's a real copy, not a reference to org
        const auto& cprops = props.c_struct();
        const auto& orgCprops = orgProps.c_struct();
        REQUIRE(orgCprops.array != cprops.array);

        orgProps.clear();

        REQUIRE(get<uint8_t>(props, property::PAYLOAD_FORMAT_INDICATOR) == FMT_IND);
        REQUIRE(get<uint16_t>(props, property::TOPIC_ALIAS) == TOP_ALIAS);
        REQUIRE(get<uint32_t>(props, property::MAXIMUM_PACKET_SIZE) == MAX_PKT_SZ);

        REQUIRE(get<string>(props, property::RESPONSE_TOPIC) == TOPIC);
        REQUIRE(get<binary>(props, property::CORRELATION_DATA) == CORR_ID);

        std::tie(name1, value1) = get<string_pair>(props, property::USER_PROPERTY, 0);
        std::tie(name2, value2) = get<string_pair>(props, property::USER_PROPERTY, 1);

        REQUIRE(name1 == NAME1);
        REQUIRE(value1 == VALUE1);

        REQUIRE(name2 == NAME2);
        REQUIRE(value2 == VALUE2);
    }

    SECTION("move assignment")
    {
        properties props;
        props = std::move(orgProps);

        REQUIRE(get<uint8_t>(props, property::PAYLOAD_FORMAT_INDICATOR) == FMT_IND);
        REQUIRE(get<uint16_t>(props, property::TOPIC_ALIAS) == TOP_ALIAS);
        REQUIRE(get<uint32_t>(props, property::MAXIMUM_PACKET_SIZE) == MAX_PKT_SZ);

        REQUIRE(get<string>(props, property::RESPONSE_TOPIC) == TOPIC);
        REQUIRE(get<binary>(props, property::CORRELATION_DATA) == CORR_ID);

        std::tie(name1, value1) = get<string_pair>(props, property::USER_PROPERTY, 0);
        std::tie(name2, value2) = get<string_pair>(props, property::USER_PROPERTY, 1);

        REQUIRE(name1 == NAME1);
        REQUIRE(value1 == VALUE1);

        REQUIRE(name2 == NAME2);
        REQUIRE(value2 == VALUE2);

        REQUIRE(orgProps.empty());
        REQUIRE(0 == orgProps.size());
    }
}

```

`test/unit/test_response_options.cpp`:

```cpp
// test_response_options.cpp
//
// Unit tests for the response_options class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2016 Guilherme M. Ferreira <guilherme.maciel.ferreira@gmail.com>
 * Copyright (c) 2020-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme M. Ferreira
 *        - initial implementation and documentation
 *    Frank Pagliughi
 *        - converted to use Catch2
 *        - Merged in delivery response options
 *******************************************************************************/

#define UNIT_TESTS

#include <cstring>

#include "catch2_version.h"
#include "mock_async_client.h"
#include "mqtt/response_options.h"

using namespace mqtt;

/////////////////////////////////////////////////////////////////////////////

static constexpr token::Type TOKEN_TYPE = token::Type::CONNECT;

// The struct_id for the Paho C MQTTSubscribe_options struct.
static constexpr const char* STRUCT_ID = "MQTR";

const properties PROPS{
    {property::PAYLOAD_FORMAT_INDICATOR, 42}, {property::MESSAGE_EXPIRY_INTERVAL, 70000}
};

const std::vector<subscribe_options> SUB_OPTS{
    3, subscribe_options{subscribe_options::NO_LOCAL}
};

static mock_async_client cli;

// ----------------------------------------------------------------------
// Test default constructor
// ----------------------------------------------------------------------

TEST_CASE("response_options dflt ctor", "[options]")
{
    response_options opts;
    const auto& copts = opts.c_struct();

    REQUIRE(0 == memcmp(copts.struct_id, STRUCT_ID, 4));
    REQUIRE(copts.context == nullptr);

    // Make sure the v3 callback functions are set during object construction
    REQUIRE(copts.onSuccess != nullptr);
    REQUIRE(copts.onFailure != nullptr);
    REQUIRE(copts.onSuccess5 == nullptr);
    REQUIRE(copts.onFailure5 == nullptr);
}

// ----------------------------------------------------------------------
// Test user constructor
// ----------------------------------------------------------------------

TEST_CASE("response_options user ctor", "[options]")
{
    token_ptr token{token::create(TOKEN_TYPE, cli)};
    response_options opts{token};
    const auto& copts = opts.c_struct();

    REQUIRE(0 == memcmp(copts.struct_id, STRUCT_ID, 4));
    REQUIRE(copts.context == token.get());

    // Make sure the v3 callback functions are set during object construction
    REQUIRE(copts.onSuccess != nullptr);
    REQUIRE(copts.onFailure != nullptr);
    REQUIRE(copts.onSuccess5 == nullptr);
    REQUIRE(copts.onFailure5 == nullptr);
}

// ----------------------------------------------------------------------
// Test user constructor for v5
// ----------------------------------------------------------------------

TEST_CASE("response_options user v5 ctor", "[options]")
{
    token_ptr token{token::create(TOKEN_TYPE, cli)};
    response_options opts{token, 5};
    const auto& copts = opts.c_struct();

    REQUIRE(0 == memcmp(copts.struct_id, STRUCT_ID, 4));
    REQUIRE(copts.context == token.get());

    // Make sure the v5 callback functions are set during object construction
    REQUIRE(copts.onSuccess == nullptr);
    REQUIRE(copts.onFailure == nullptr);
    REQUIRE(copts.onSuccess5 != nullptr);
    REQUIRE(copts.onFailure5 != nullptr);
}

// ----------------------------------------------------------------------
// Test copy constructor
// ----------------------------------------------------------------------

TEST_CASE("response_options copy ctor", "[options]")
{
    token_ptr token{token::create(TOKEN_TYPE, cli)};

    response_options optsOrg{token, 5};
    optsOrg.set_properties(PROPS);
    optsOrg.set_subscribe_many_options(SUB_OPTS);

    response_options opts{optsOrg};
    const auto& copts = opts.c_struct();

    REQUIRE(0 == memcmp(copts.struct_id, STRUCT_ID, 4));
    REQUIRE(copts.context == token.get());

    // Make sure the v5 callback functions are set during object construction
    REQUIRE(copts.onSuccess == nullptr);
    REQUIRE(copts.onFailure == nullptr);
    REQUIRE(copts.onSuccess5 != nullptr);
    REQUIRE(copts.onFailure5 != nullptr);

    REQUIRE(opts.get_properties().size() == PROPS.size());

    auto subOpts = opts.get_subscribe_many_options();
    REQUIRE(subOpts.size() == SUB_OPTS.size());
    REQUIRE(subOpts[0].get_no_local());
    REQUIRE(subOpts[1].get_no_local());
}

// ----------------------------------------------------------------------
// Test move constructor
// ----------------------------------------------------------------------

TEST_CASE("response_options move ctor", "[options]")
{
    token_ptr token{token::create(TOKEN_TYPE, cli)};

    response_options optsOrg{token, 5};
    optsOrg.set_properties(PROPS);
    optsOrg.set_subscribe_many_options(SUB_OPTS);

    response_options opts{std::move(optsOrg)};
    const auto& copts = opts.c_struct();

    REQUIRE(0 == memcmp(copts.struct_id, STRUCT_ID, 4));
    REQUIRE(copts.context == token.get());

    // Make sure the v3 callback functions are set during object construction
    REQUIRE(copts.onSuccess == nullptr);
    REQUIRE(copts.onFailure == nullptr);
    REQUIRE(copts.onSuccess5 != nullptr);
    REQUIRE(copts.onFailure5 != nullptr);

    REQUIRE(opts.get_properties().size() == PROPS.size());

    auto subOpts = opts.get_subscribe_many_options();
    REQUIRE(subOpts.size() == SUB_OPTS.size());
    REQUIRE(subOpts[0].get_no_local());
    REQUIRE(subOpts[1].get_no_local());

    auto subOptsOrg = optsOrg.get_subscribe_many_options();
    REQUIRE(subOptsOrg.size() == 0);
}

// ----------------------------------------------------------------------
// Test builder
// ----------------------------------------------------------------------

TEST_CASE("response_options builder", "[options]")
{
    token_ptr token{token::create(TOKEN_TYPE, cli)};

    auto opts = response_options_builder()
                    .mqtt_version(5)
                    .token(token)
                    .properties(PROPS)
                    .subscribe_opts(SUB_OPTS)
                    .finalize();

    const auto& copts = opts.c_struct();

    REQUIRE(0 == memcmp(copts.struct_id, STRUCT_ID, 4));
    REQUIRE(copts.context == token.get());

    // Make sure the v5 callback functions are set during object construction
    REQUIRE(copts.onSuccess == nullptr);
    REQUIRE(copts.onFailure == nullptr);
    REQUIRE(copts.onSuccess5 != nullptr);
    REQUIRE(copts.onFailure5 != nullptr);

    REQUIRE(opts.get_properties().size() == PROPS.size());

    auto subOpts = opts.get_subscribe_many_options();
    REQUIRE(subOpts.size() == SUB_OPTS.size());
    REQUIRE(subOpts[0].get_no_local());
    REQUIRE(subOpts[1].get_no_local());
}

// ----------------------------------------------------------------------
// Test set context
// ----------------------------------------------------------------------

TEST_CASE("response_options set token", "[options]")
{
    response_options opts;
    const auto& copts = opts.c_struct();

    REQUIRE(copts.context == nullptr);
    token_ptr token{token::create(TOKEN_TYPE, cli)};
    opts.set_token(token);
    REQUIRE(copts.context == token.get());
}

/////////////////////////////////////////////////////////////////////////////
// Delivery Response Options
/////////////////////////////////////////////////////////////////////////////

// ----------------------------------------------------------------------
// Test default constructor
// ----------------------------------------------------------------------

TEST_CASE("delivery_response_options dflt ctor", "[options]")
{
    delivery_response_options opts;
    const auto& copts = opts.c_struct();

    REQUIRE(copts.context == nullptr);

    // Make sure the v3 callback functions are set during object construction
    REQUIRE(copts.onSuccess != nullptr);
    REQUIRE(copts.onFailure != nullptr);
    REQUIRE(copts.onSuccess5 == nullptr);
    REQUIRE(copts.onFailure5 == nullptr);
}

// ----------------------------------------------------------------------
// Test user constructor
// ----------------------------------------------------------------------

TEST_CASE("delivery_response_options user ctor", "[options]")
{
    //    mock_async_client cli;

    delivery_token_ptr token{new delivery_token{cli}};
    delivery_response_options opts{token};
    const auto& copts = opts.c_struct();

    REQUIRE(copts.context == token.get());

    // Make sure the callback functions are set during object construction
    REQUIRE(copts.onSuccess != nullptr);
    REQUIRE(copts.onFailure != nullptr);
}

// ----------------------------------------------------------------------
// Test set context
// ----------------------------------------------------------------------

TEST_CASE("delivery_response_options set token", "[options]")
{
    delivery_response_options opts;
    const auto& copts = opts.c_struct();

    REQUIRE(copts.context == nullptr);

    mock_async_client cli;
    delivery_token_ptr token{new delivery_token{cli}};
    opts.set_token(token);
    REQUIRE(copts.context == token.get());
}

```

`test/unit/test_ssl_options.cpp`:

```cpp
// test_ssl_options.cpp
//
// Unit tests for the ssl_options class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2016-2020 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *    Guilherme M. Ferreira - add more test cases
 *    Frank Pagliughi - Converted to Catch2
 *******************************************************************************/

#define UNIT_TESTS

#include "catch2_version.h"
#include "mqtt/ssl_options.h"

using namespace std::chrono;
using namespace mqtt;

/////////////////////////////////////////////////////////////////////////////

// C struct signature/eyecatcher
static const char* CSIG = "MQTS";
static const size_t CSIG_LEN = std::strlen(CSIG);

static const bool DFLT_SERVER_CERT = true;

static const std::string EMPTY_STR;
static const std::string TRUST_STORE{"trust store"};
static const std::string KEY_STORE{"key store"};
static const std::string PRIVATE_KEY{"private key"};
static const std::string PRIVATE_KEY_PASSWORD{"private key password"};
static const std::string CA_PATH{"ca path"};
static const std::string ENABLED_CIPHER_SUITES{"cipher suite"};
static const bool SERVER_CERT{false};

static const std::string ALPN0{"mqtt"};
static const std::string ALPN1{"x-iot-mqtt"};

static mqtt::ssl_options orgOpts{TRUST_STORE,          KEY_STORE,     PRIVATE_KEY,
                                 PRIVATE_KEY_PASSWORD, CA_PATH,       ENABLED_CIPHER_SUITES,
                                 SERVER_CERT,          {ALPN0, ALPN1}};

// ----------------------------------------------------------------------
// Test the default constructor
// ----------------------------------------------------------------------

TEST_CASE("ssl_options dflt constructor", "[options]")
{
    mqtt::ssl_options opts;

    REQUIRE(opts.get_trust_store().empty());
    REQUIRE(opts.get_key_store().empty());
    REQUIRE(opts.get_private_key().empty());
    REQUIRE(opts.get_private_key_password().empty());
    REQUIRE(opts.get_ca_path().empty());
    REQUIRE(DFLT_SERVER_CERT == opts.get_enable_server_cert_auth());
    REQUIRE(opts.get_alpn_protos().empty());

    //  Make sure the empty string represents a nullptr for C library
    const auto& c_struct = opts.c_struct();

    REQUIRE(!memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));
    REQUIRE(c_struct.trustStore == nullptr);
    REQUIRE(c_struct.keyStore == nullptr);
    REQUIRE(c_struct.privateKey == nullptr);
    REQUIRE(c_struct.privateKeyPassword == nullptr);
    REQUIRE(c_struct.CApath == nullptr);
    REQUIRE(c_struct.enabledCipherSuites == nullptr);
    // REQUIRE(DFLT_SERVER_CERT == c_struct.enableServerCertAuth != 0);
    REQUIRE(c_struct.protos == nullptr);
    REQUIRE(c_struct.protos_len == 0);
}

// ----------------------------------------------------------------------
// Test the constructor that takes user arguments
// ----------------------------------------------------------------------

TEST_CASE("ssl_options user constructor", "[options]")
{
    mqtt::ssl_options opts{TRUST_STORE,          KEY_STORE,     PRIVATE_KEY,
                           PRIVATE_KEY_PASSWORD, CA_PATH,       ENABLED_CIPHER_SUITES,
                           SERVER_CERT,          {ALPN0, ALPN1}};

    REQUIRE(TRUST_STORE == opts.get_trust_store());
    REQUIRE(KEY_STORE == opts.get_key_store());
    REQUIRE(PRIVATE_KEY == opts.get_private_key());
    REQUIRE(PRIVATE_KEY_PASSWORD == opts.get_private_key_password());
    REQUIRE(CA_PATH == opts.get_ca_path());
    REQUIRE(ENABLED_CIPHER_SUITES == opts.get_enabled_cipher_suites());
    REQUIRE(SERVER_CERT == opts.get_enable_server_cert_auth());

    auto protos = opts.get_alpn_protos();
    REQUIRE(2 == protos.size());
    REQUIRE(ALPN0 == protos[0]);
    REQUIRE(ALPN1 == protos[1]);

    // Check the underlying C struct
    const auto& c_struct = opts.c_struct();

    REQUIRE(!memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));
    REQUIRE(!strcmp(c_struct.trustStore, TRUST_STORE.c_str()));
    REQUIRE(!strcmp(c_struct.keyStore, KEY_STORE.c_str()));
    REQUIRE(!strcmp(c_struct.privateKey, PRIVATE_KEY.c_str()));
    REQUIRE(!strcmp(c_struct.privateKeyPassword, PRIVATE_KEY_PASSWORD.c_str()));
    REQUIRE(!strcmp(c_struct.CApath, CA_PATH.c_str()));
    REQUIRE(!strcmp(c_struct.enabledCipherSuites, ENABLED_CIPHER_SUITES.c_str()));
    // REQUIRE(SERVER_CERT == c_struct.enableServerCertAuth != 0);

    auto n0 = ALPN0.length();
    auto n1 = ALPN1.length();

    REQUIRE(c_struct.protos_len == n0 + n1 + 2);
    REQUIRE(c_struct.protos[0] == n0);
    REQUIRE(memcmp(c_struct.protos + 1, ALPN0.data(), n0) == 0);
    REQUIRE(c_struct.protos[n0 + 1] == n1);
    REQUIRE(memcmp(c_struct.protos + n0 + 2, ALPN1.data(), n1) == 0);
}

// ----------------------------------------------------------------------
// Test the copy constructor
// ----------------------------------------------------------------------

TEST_CASE("ssl_options copy constructor", "[options]")
{
    mqtt::ssl_options org{TRUST_STORE,          KEY_STORE,     PRIVATE_KEY,
                          PRIVATE_KEY_PASSWORD, CA_PATH,       ENABLED_CIPHER_SUITES,
                          SERVER_CERT,          {ALPN0, ALPN1}};

    mqtt::ssl_options opts{org};

    REQUIRE(TRUST_STORE == opts.get_trust_store());
    REQUIRE(KEY_STORE == opts.get_key_store());
    REQUIRE(PRIVATE_KEY == opts.get_private_key());
    REQUIRE(PRIVATE_KEY_PASSWORD == opts.get_private_key_password());
    REQUIRE(CA_PATH == opts.get_ca_path());
    REQUIRE(ENABLED_CIPHER_SUITES == opts.get_enabled_cipher_suites());
    REQUIRE(SERVER_CERT == opts.get_enable_server_cert_auth());

    auto protos = opts.get_alpn_protos();
    REQUIRE(2 == protos.size());
    REQUIRE(ALPN0 == protos[0]);
    REQUIRE(ALPN1 == protos[1]);

    // Check the underlying C struct
    const auto& c_struct = opts.c_struct();

    REQUIRE(!memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));
    REQUIRE(!strcmp(c_struct.trustStore, TRUST_STORE.c_str()));
    REQUIRE(!strcmp(c_struct.keyStore, KEY_STORE.c_str()));
    REQUIRE(!strcmp(c_struct.privateKey, PRIVATE_KEY.c_str()));
    REQUIRE(!strcmp(c_struct.privateKeyPassword, PRIVATE_KEY_PASSWORD.c_str()));
    REQUIRE(!strcmp(c_struct.CApath, CA_PATH.c_str()));
    REQUIRE(!strcmp(c_struct.enabledCipherSuites, ENABLED_CIPHER_SUITES.c_str()));
    // REQUIRE(SERVER_CERT == c_struct.enableServerCertAuth != 0);

    // Make sure it's a true copy, not linked to the original
    org.set_trust_store(EMPTY_STR);
    org.set_key_store(EMPTY_STR);
    org.set_private_key(EMPTY_STR);
    org.set_private_key_password(EMPTY_STR);
    org.set_ca_path(EMPTY_STR);
    org.set_enabled_cipher_suites(EMPTY_STR);
    org.set_enable_server_cert_auth(!SERVER_CERT);

    REQUIRE(TRUST_STORE == opts.get_trust_store());
    REQUIRE(KEY_STORE == opts.get_key_store());
    REQUIRE(PRIVATE_KEY == opts.get_private_key());
    REQUIRE(PRIVATE_KEY_PASSWORD == opts.get_private_key_password());
    REQUIRE(CA_PATH == opts.get_ca_path());
    REQUIRE(ENABLED_CIPHER_SUITES == opts.get_enabled_cipher_suites());
    REQUIRE(SERVER_CERT == opts.get_enable_server_cert_auth());

    auto n0 = ALPN0.length();
    auto n1 = ALPN1.length();

    REQUIRE(c_struct.protos_len == n0 + n1 + 2);
    REQUIRE(c_struct.protos[0] == n0);
    REQUIRE(memcmp(c_struct.protos + 1, ALPN0.data(), n0) == 0);
    REQUIRE(c_struct.protos[n0 + 1] == n1);
    REQUIRE(memcmp(c_struct.protos + n0 + 2, ALPN1.data(), n1) == 0);
}

// ----------------------------------------------------------------------
// Test the move constructor
// ----------------------------------------------------------------------

TEST_CASE("ssl_options move constructor", "[options]")
{
    mqtt::ssl_options org{orgOpts};
    mqtt::ssl_options opts(std::move(org));

    REQUIRE(TRUST_STORE == opts.get_trust_store());
    REQUIRE(KEY_STORE == opts.get_key_store());
    REQUIRE(PRIVATE_KEY == opts.get_private_key());
    REQUIRE(PRIVATE_KEY_PASSWORD == opts.get_private_key_password());
    REQUIRE(CA_PATH == opts.get_ca_path());
    REQUIRE(ENABLED_CIPHER_SUITES == opts.get_enabled_cipher_suites());
    REQUIRE(SERVER_CERT == opts.get_enable_server_cert_auth());

    auto protos = opts.get_alpn_protos();
    REQUIRE(2 == protos.size());
    REQUIRE(ALPN0 == protos[0]);
    REQUIRE(ALPN1 == protos[1]);

    // Check that the original was moved
    REQUIRE(org.get_trust_store().empty());
    REQUIRE(org.get_key_store().empty());
    REQUIRE(org.get_private_key().empty());
    REQUIRE(org.get_private_key_password().empty());
    REQUIRE(org.get_ca_path().empty());
    REQUIRE(org.get_enabled_cipher_suites().empty());
    REQUIRE(org.get_alpn_protos().empty());

    // Check the underlying C struct
    const auto& c_struct = opts.c_struct();

    auto n0 = ALPN0.length();
    auto n1 = ALPN1.length();

    REQUIRE(c_struct.protos_len == n0 + n1 + 2);
    REQUIRE(c_struct.protos[0] == n0);
    REQUIRE(memcmp(c_struct.protos + 1, ALPN0.data(), n0) == 0);
    REQUIRE(c_struct.protos[n0 + 1] == n1);
    REQUIRE(memcmp(c_struct.protos + n0 + 2, ALPN1.data(), n1) == 0);
}

// ----------------------------------------------------------------------
// Test the copy assignment operator=(const&)
// ----------------------------------------------------------------------

TEST_CASE("ssl_options copy assignment", "[options]")
{
    mqtt::ssl_options org{orgOpts};
    mqtt::ssl_options opts;

    opts = orgOpts;

    REQUIRE(TRUST_STORE == opts.get_trust_store());
    REQUIRE(KEY_STORE == opts.get_key_store());
    REQUIRE(PRIVATE_KEY == opts.get_private_key());
    REQUIRE(PRIVATE_KEY_PASSWORD == opts.get_private_key_password());
    REQUIRE(CA_PATH == opts.get_ca_path());
    REQUIRE(ENABLED_CIPHER_SUITES == opts.get_enabled_cipher_suites());
    REQUIRE(SERVER_CERT == opts.get_enable_server_cert_auth());

    // Make sure it's a true copy, not linked to the original
    org.set_trust_store(EMPTY_STR);
    org.set_key_store(EMPTY_STR);
    org.set_private_key(EMPTY_STR);
    org.set_private_key_password(EMPTY_STR);
    org.set_ca_path(EMPTY_STR);
    org.set_enabled_cipher_suites(EMPTY_STR);
    org.set_enable_server_cert_auth(!SERVER_CERT);
    org.set_alpn_protos({});

    REQUIRE(TRUST_STORE == opts.get_trust_store());
    REQUIRE(KEY_STORE == opts.get_key_store());
    REQUIRE(PRIVATE_KEY == opts.get_private_key());
    REQUIRE(PRIVATE_KEY_PASSWORD == opts.get_private_key_password());
    REQUIRE(CA_PATH == opts.get_ca_path());
    REQUIRE(ENABLED_CIPHER_SUITES == opts.get_enabled_cipher_suites());
    REQUIRE(SERVER_CERT == opts.get_enable_server_cert_auth());

    // Self assignment should cause no harm
    opts = opts;

    REQUIRE(TRUST_STORE == opts.get_trust_store());
    REQUIRE(KEY_STORE == opts.get_key_store());
    REQUIRE(PRIVATE_KEY == opts.get_private_key());
    REQUIRE(PRIVATE_KEY_PASSWORD == opts.get_private_key_password());
    REQUIRE(CA_PATH == opts.get_ca_path());
    REQUIRE(ENABLED_CIPHER_SUITES == opts.get_enabled_cipher_suites());
    REQUIRE(SERVER_CERT == opts.get_enable_server_cert_auth());
}

// ----------------------------------------------------------------------
// Test the move assignment, operator=(&&)
// ----------------------------------------------------------------------

TEST_CASE("ssl_options move assignment", "[options]")
{
    mqtt::ssl_options org{orgOpts};
    mqtt::ssl_options opts;

    opts = std::move(org);

    REQUIRE(TRUST_STORE == opts.get_trust_store());
    REQUIRE(KEY_STORE == opts.get_key_store());
    REQUIRE(PRIVATE_KEY == opts.get_private_key());
    REQUIRE(PRIVATE_KEY_PASSWORD == opts.get_private_key_password());
    REQUIRE(CA_PATH == opts.get_ca_path());
    REQUIRE(ENABLED_CIPHER_SUITES == opts.get_enabled_cipher_suites());
    REQUIRE(SERVER_CERT == opts.get_enable_server_cert_auth());

    auto protos = opts.get_alpn_protos();
    REQUIRE(2 == protos.size());
    REQUIRE(ALPN0 == protos[0]);
    REQUIRE(ALPN1 == protos[1]);

    // Check that the original was moved
    REQUIRE(org.get_trust_store().empty());
    REQUIRE(org.get_key_store().empty());
    REQUIRE(org.get_private_key().empty());
    REQUIRE(org.get_private_key_password().empty());
    REQUIRE(org.get_ca_path().empty());
    REQUIRE(org.get_enabled_cipher_suites().empty());
    REQUIRE(org.get_alpn_protos().empty());

// Self assignment should cause no harm
// (clang++ is smart enough to warn about this)
#if !defined(__clang__)
    opts = std::move(opts);
    REQUIRE(TRUST_STORE == opts.get_trust_store());
    REQUIRE(KEY_STORE == opts.get_key_store());
    REQUIRE(PRIVATE_KEY == opts.get_private_key());
    REQUIRE(PRIVATE_KEY_PASSWORD == opts.get_private_key_password());
    REQUIRE(CA_PATH == opts.get_ca_path());
    REQUIRE(ENABLED_CIPHER_SUITES == opts.get_enabled_cipher_suites());
    REQUIRE(SERVER_CERT == opts.get_enable_server_cert_auth());
#endif
}

// ----------------------------------------------------------------------
// Test set/get of the user and password.
// ----------------------------------------------------------------------

TEST_CASE("ssl_options set user", "[options]")
{
    mqtt::ssl_options opts;

    opts.set_trust_store(TRUST_STORE);
    opts.set_key_store(KEY_STORE);
    opts.set_private_key(PRIVATE_KEY);
    opts.set_private_key_password(PRIVATE_KEY_PASSWORD);
    opts.set_ca_path(CA_PATH);
    opts.set_enabled_cipher_suites(ENABLED_CIPHER_SUITES);
    opts.set_enable_server_cert_auth(SERVER_CERT);
    opts.set_alpn_protos({ALPN0, ALPN1});

    REQUIRE(TRUST_STORE == opts.get_trust_store());
    REQUIRE(KEY_STORE == opts.get_key_store());
    REQUIRE(PRIVATE_KEY == opts.get_private_key());
    REQUIRE(PRIVATE_KEY_PASSWORD == opts.get_private_key_password());
    REQUIRE(CA_PATH == opts.get_ca_path());
    REQUIRE(ENABLED_CIPHER_SUITES == opts.get_enabled_cipher_suites());
    REQUIRE(SERVER_CERT == opts.get_enable_server_cert_auth());

    auto protos = opts.get_alpn_protos();
    REQUIRE(2 == protos.size());
    REQUIRE(ALPN0 == protos[0]);
    REQUIRE(ALPN1 == protos[1]);
}

// ----------------------------------------------------------------------
// Test if empty strings gives nullptr opts
// ----------------------------------------------------------------------

TEST_CASE("ssl_options set empty strings", "[options]")
{
    mqtt::ssl_options opts{orgOpts};

    opts.set_trust_store(EMPTY_STR);
    opts.set_key_store(EMPTY_STR);
    opts.set_private_key(EMPTY_STR);
    opts.set_private_key_password(EMPTY_STR);
    opts.set_ca_path(EMPTY_STR);
    opts.set_enabled_cipher_suites(EMPTY_STR);
    opts.set_alpn_protos({});

    // Make sure the empty string represents a nullptr for C library
    const auto& c_struct = opts.c_struct();

    REQUIRE(!memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));
    REQUIRE(c_struct.trustStore == nullptr);
    REQUIRE(c_struct.keyStore == nullptr);
    REQUIRE(c_struct.privateKey == nullptr);
    REQUIRE(c_struct.privateKeyPassword == nullptr);
    REQUIRE(c_struct.CApath == nullptr);
    REQUIRE(c_struct.enabledCipherSuites == nullptr);
    REQUIRE(c_struct.protos == nullptr);
    REQUIRE(c_struct.protos_len == 0);
}

// ----------------------------------------------------------------------
// Test if empty strings gives nullptr opts
// ----------------------------------------------------------------------

TEST_CASE("ssl_options test error handler", "[options]")
{
    mqtt::ssl_options opts{orgOpts};

    orgOpts.set_error_handler([](const std::string& msg) {
        std::cerr << "SSL Error: " << msg << std::endl;
    });
}

```

`test/unit/test_string_collection.cpp`:

```cpp
// test_string_collection.cpp
//
// Unit tests for the string_collection and name_value_collection classes in
// the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2017-2020 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#define UNIT_TESTS

#include <cstring>
#include <vector>

#include "catch2_version.h"
#include "mqtt/string_collection.h"

using namespace mqtt;

static const string STR{"Some random string"};
static const std::vector<string> VEC{"test0", "test1", "test2"};

static const std::map<string, string> NV_PAIRS{
    {"name0", "value0"}, {"name1", "value1"}, {"name2", "value2"}
};

// ----------------------------------------------------------------------
// Test the default constructor
// ----------------------------------------------------------------------

TEST_CASE("string_collection default ctor", "[collections]")
{
    string_collection sc;

    REQUIRE(sc.empty());
    REQUIRE(sc.size() == size_t(0));
}

// ----------------------------------------------------------------------
// Test the string copy constructor
// ----------------------------------------------------------------------

TEST_CASE("string_collection str copy ctor", "[collections]")
{
    string_collection sc(STR);

    REQUIRE(size_t(1) == sc.size());
    REQUIRE(STR == sc[0]);

    auto c_arr = sc.c_arr();

    REQUIRE(0 == strcmp(STR.c_str(), c_arr[0]));
}

// ----------------------------------------------------------------------
// Test the string move constructor
// ----------------------------------------------------------------------

TEST_CASE("string_collection str move ctor", "[collections]")
{
    string str(STR);
    string_collection sc(std::move(str));

    REQUIRE(size_t(1) == sc.size());
    REQUIRE(STR == sc[0]);

    auto c_arr = sc.c_arr();

    REQUIRE(0 == strcmp(STR.c_str(), c_arr[0]));
}

// ----------------------------------------------------------------------
// Test the vector copy constructor
// ----------------------------------------------------------------------

TEST_CASE("string_collection vec copy ctor", "[collections]")
{
    string_collection sc(VEC);

    REQUIRE(VEC.size() == sc.size());

    REQUIRE(VEC[0] == sc[0]);
    REQUIRE(VEC[1] == sc[1]);
    REQUIRE(VEC[2] == sc[2]);

    auto c_arr = sc.c_arr();

    REQUIRE(0 == strcmp(VEC[0].c_str(), c_arr[0]));
    REQUIRE(0 == strcmp(VEC[1].c_str(), c_arr[1]));
    REQUIRE(0 == strcmp(VEC[2].c_str(), c_arr[2]));
}

// ----------------------------------------------------------------------
// Test the vector move constructor
// ----------------------------------------------------------------------

TEST_CASE("string_collection vec move ctor", "[collections]")
{
    std::vector<string> vec{VEC};

    string_collection sc(std::move(vec));

    REQUIRE(VEC.size() == sc.size());

    REQUIRE(VEC[0] == sc[0]);
    REQUIRE(VEC[1] == sc[1]);
    REQUIRE(VEC[2] == sc[2]);

    auto c_arr = sc.c_arr();

    REQUIRE(0 == strcmp(VEC[0].c_str(), c_arr[0]));
    REQUIRE(0 == strcmp(VEC[1].c_str(), c_arr[1]));
    REQUIRE(0 == strcmp(VEC[2].c_str(), c_arr[2]));
}

// ----------------------------------------------------------------------
// Test the ini vector constructor
// ----------------------------------------------------------------------

TEST_CASE("string_collection ini str ctor", "[collections]")
{
    string_collection sc({VEC[0], VEC[1], VEC[2]});

    REQUIRE(size_t(3) == sc.size());

    REQUIRE(VEC[0] == sc[0]);
    REQUIRE(VEC[1] == sc[1]);
    REQUIRE(VEC[2] == sc[2]);

    auto c_arr = sc.c_arr();

    REQUIRE(0 == strcmp(VEC[0].c_str(), c_arr[0]));
    REQUIRE(0 == strcmp(VEC[1].c_str(), c_arr[1]));
    REQUIRE(0 == strcmp(VEC[2].c_str(), c_arr[2]));
}

// ----------------------------------------------------------------------
// Test the ini vector constructor
// ----------------------------------------------------------------------

TEST_CASE("string_collection ini cstr ctor", "[collections]")
{
    string_collection sc({"test0", "test1", "test2"});

    REQUIRE(size_t(3) == sc.size());

    REQUIRE(string("test0") == sc[0]);
    REQUIRE(string("test1") == sc[1]);
    REQUIRE(string("test2") == sc[2]);

    auto c_arr = sc.c_arr();

    REQUIRE(0 == strcmp(sc[0].c_str(), c_arr[0]));
    REQUIRE(0 == strcmp(sc[1].c_str(), c_arr[1]));
    REQUIRE(0 == strcmp(sc[2].c_str(), c_arr[2]));
}

// ----------------------------------------------------------------------
// Test the copy constructor
// ----------------------------------------------------------------------

TEST_CASE("string_collection copy ctor", "[collections]")
{
    string_collection orgSC(VEC);
    string_collection sc(orgSC);
    ;

    REQUIRE(VEC.size() == sc.size());

    REQUIRE(VEC[0] == sc[0]);
    REQUIRE(VEC[1] == sc[1]);
    REQUIRE(VEC[2] == sc[2]);

    auto c_arr = sc.c_arr();

    REQUIRE(0 == strcmp(VEC[0].c_str(), c_arr[0]));
    REQUIRE(0 == strcmp(VEC[1].c_str(), c_arr[1]));
    REQUIRE(0 == strcmp(VEC[2].c_str(), c_arr[2]));
}

// ----------------------------------------------------------------------
// Test the move constructor
// ----------------------------------------------------------------------

TEST_CASE("string_collection move ctor", "[collections]")
{
    string_collection orgSC(VEC);
    string_collection sc(std::move(orgSC));

    REQUIRE(VEC.size() == sc.size());

    REQUIRE(VEC[0] == sc[0]);
    REQUIRE(VEC[1] == sc[1]);
    REQUIRE(VEC[2] == sc[2]);

    auto c_arr = sc.c_arr();

    REQUIRE(0 == strcmp(VEC[0].c_str(), c_arr[0]));
    REQUIRE(0 == strcmp(VEC[1].c_str(), c_arr[1]));
    REQUIRE(0 == strcmp(VEC[2].c_str(), c_arr[2]));
}

// ----------------------------------------------------------------------
// Test the copy assignment
// ----------------------------------------------------------------------

TEST_CASE("string_collection copy assignment", "[collections]")
{
    string_collection orgSC(VEC);
    string_collection sc;

    sc = orgSC;

    REQUIRE(VEC.size() == sc.size());

    REQUIRE(VEC[0] == sc[0]);
    REQUIRE(VEC[1] == sc[1]);
    REQUIRE(VEC[2] == sc[2]);

    auto c_arr = sc.c_arr();

    REQUIRE(0 == strcmp(VEC[0].c_str(), c_arr[0]));
    REQUIRE(0 == strcmp(VEC[1].c_str(), c_arr[1]));
    REQUIRE(0 == strcmp(VEC[2].c_str(), c_arr[2]));
}

// ----------------------------------------------------------------------
// Test the move assignment
// ----------------------------------------------------------------------

TEST_CASE("string_collection move assignment", "[collections]")
{
    string_collection orgSC(VEC);
    string_collection sc;

    sc = std::move(orgSC);

    REQUIRE(VEC.size() == sc.size());

    REQUIRE(VEC[0] == sc[0]);
    REQUIRE(VEC[1] == sc[1]);
    REQUIRE(VEC[2] == sc[2]);

    auto c_arr = sc.c_arr();

    REQUIRE(0 == strcmp(VEC[0].c_str(), c_arr[0]));
    REQUIRE(0 == strcmp(VEC[1].c_str(), c_arr[1]));
    REQUIRE(0 == strcmp(VEC[2].c_str(), c_arr[2]));
}

// ----------------------------------------------------------------------
// Test the push back of strings
// ----------------------------------------------------------------------

TEST_CASE("string_collection push str", "[collections]")
{
    string_collection sc;

    for (const auto& s : VEC) sc.push_back(s);

    REQUIRE(VEC.size() == sc.size());

    REQUIRE(VEC[0] == sc[0]);
    REQUIRE(VEC[1] == sc[1]);
    REQUIRE(VEC[2] == sc[2]);

    auto c_arr = sc.c_arr();

    REQUIRE(0 == strcmp(VEC[0].c_str(), c_arr[0]));
    REQUIRE(0 == strcmp(VEC[1].c_str(), c_arr[1]));
    REQUIRE(0 == strcmp(VEC[2].c_str(), c_arr[2]));
}

// ----------------------------------------------------------------------
// Test the push back of C strings
// ----------------------------------------------------------------------

TEST_CASE("string_collection push cstr", "[collections]")
{
    string_collection sc;

    for (const auto& s : VEC) sc.push_back(s.c_str());

    REQUIRE(VEC.size() == sc.size());

    REQUIRE(VEC[0] == sc[0]);
    REQUIRE(VEC[1] == sc[1]);
    REQUIRE(VEC[2] == sc[2]);

    auto c_arr = sc.c_arr();

    REQUIRE(0 == strcmp(VEC[0].c_str(), c_arr[0]));
    REQUIRE(0 == strcmp(VEC[1].c_str(), c_arr[1]));
    REQUIRE(0 == strcmp(VEC[2].c_str(), c_arr[2]));
}

// ----------------------------------------------------------------------
// Test the clear method
// ----------------------------------------------------------------------

TEST_CASE("string_collection clear", "[collections]")
{
    string_collection sc(VEC);

    REQUIRE_FALSE(sc.empty());

    sc.clear();

    REQUIRE(sc.empty());
    REQUIRE(size_t(0) == sc.size());
}

// ----------------------------------------------------------------------
// Test the const_iterator class
// ----------------------------------------------------------------------

TEST_CASE("string_collection for each", "[collections]")
{
    string_collection sc(VEC);

    size_t i = 0u;
    for (const auto& string : sc) {
        REQUIRE(sc[i] == sc[i]);
        ++i;
    }
    REQUIRE(i == sc.size());
}

TEST_CASE("string_collection iterator for with advance", "[collections]")
{
    string_collection sc(VEC);

    size_t i = 0u;
    for (auto it = sc.begin(); it != sc.end(); std::advance(it, 1)) {
        REQUIRE(*it == sc[i]);
        ++i;
    }
    REQUIRE(i == sc.size());
}

TEST_CASE("string_collection iterator for with pre-increment", "[collections]")
{
    string_collection sc(VEC);

    size_t i = 0u;
    for (auto it = sc.begin(); it != sc.end(); ++it) {
        REQUIRE(*it == sc[i]);
        ++i;
    }
    REQUIRE(i == sc.size());
}

TEST_CASE("string_collection iterator for with post increment", "[collections]")
{
    string_collection sc(VEC);

    size_t i = 0u;
    for (auto it = sc.begin(); it != sc.end(); it++) {
        REQUIRE(*it == sc[i]);
        ++i;
    }
    REQUIRE(i == sc.size());
}

TEST_CASE("string_collection begin", "[collections]")
{
    string_collection sc(VEC);

    REQUIRE(*(sc.begin()) == sc[0u]);
}

TEST_CASE("string_collection std copy", "[collections]")
{
    string_collection sc(VEC);

    std::vector<std::string> output;
    std::copy(sc.begin(), sc.end(), std::back_inserter(output));

    REQUIRE(sc.size() == output.size());

    for (size_t i = 0u; i < sc.size(); ++i) {
        REQUIRE(sc[i] == output[i]);
    }
}

/////////////////////////////////////////////////////////////////////////////
// 							name_value_collection
/////////////////////////////////////////////////////////////////////////////

TEST_CASE("name_value_collection default ctor", "[collections]")
{
    name_value_collection nvc;
    REQUIRE(nvc.empty());
    REQUIRE(0 == nvc.size());
}

TEST_CASE("name_value_collection initializer ctor", "[collections]")
{
    name_value_collection nvc{{"name0", "value0"}, {"name1", "value1"}, {"name2", "value2"}};

    REQUIRE_FALSE(nvc.empty());
    REQUIRE(3 == nvc.size());

    auto cArr = nvc.c_arr();

    REQUIRE(0 == strcmp("name0", cArr[0].name));
    REQUIRE(0 == strcmp("value0", cArr[0].value));
    REQUIRE(0 == strcmp("name1", cArr[1].name));
    REQUIRE(0 == strcmp("value1", cArr[1].value));
    REQUIRE(0 == strcmp("name2", cArr[2].name));
    REQUIRE(0 == strcmp("value2", cArr[2].value));

    REQUIRE(nullptr == cArr[3].name);
    REQUIRE(nullptr == cArr[3].value);
}

TEST_CASE("name_value_collection coll ctor", "[collections]")
{
    name_value_collection nvc{NV_PAIRS};

    std::map<string, string> nvPairs{NV_PAIRS};
    const size_t SZ = nvPairs.size();

    REQUIRE_FALSE(nvc.empty());
    REQUIRE(SZ == nvc.size());

    auto cArr = nvc.c_arr();

    for (size_t i = 0; i < SZ; ++i) {
        auto key = string(cArr[i].name);
        auto val = string(cArr[i].value);

        auto it = nvPairs.find(key);
        if (it == nvPairs.end()) {
            FAIL("Can't find name/value key");
        }

        REQUIRE(it->first == key);
        REQUIRE(it->second == val);
        nvPairs.erase(it);
    }

    REQUIRE(nvPairs.empty());
}

TEST_CASE("name_value_collection insert", "[collections]")
{
    name_value_collection nvc;

    std::map<string, string> nvPairs{NV_PAIRS};
    for (const auto& nv : nvPairs) {
        nvc.insert(nv);
    }

    const size_t SZ = nvPairs.size();

    REQUIRE_FALSE(nvc.empty());
    REQUIRE(SZ == nvc.size());

    auto cArr = nvc.c_arr();

    for (size_t i = 0; i < SZ; ++i) {
        auto key = string(cArr[i].name);
        auto val = string(cArr[i].value);

        auto it = nvPairs.find(key);
        if (it == nvPairs.end()) {
            FAIL("Can't find name/value key");
        }

        REQUIRE(it->first == key);
        REQUIRE(it->second == val);
        nvPairs.erase(it);
    }

    REQUIRE(nvPairs.empty());
}

```

`test/unit/test_subscribe_options.cpp`:

```cpp
// test_subscribe_options.cpp
//
// Unit tests for the subscribe_options class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2025 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi
 *        - initial implementation and documentation
 *******************************************************************************/

#define UNIT_TESTS

#include <cstring>

#include "catch2_version.h"
#include "mqtt/subscribe_options.h"

using namespace mqtt;

// The struct_id for the Paho C MQTTSubscribe_options struct.
static constexpr const char* STRUCT_ID = "MQSO";

/////////////////////////////////////////////////////////////////////////////

// ----------------------------------------------------------------------
// Test default constructor
// ----------------------------------------------------------------------

TEST_CASE("subscribe_options dflt ctor", "[options]")
{
    subscribe_options opts;
    const auto& copts = opts.c_struct();

    REQUIRE(0 == memcmp(copts.struct_id, STRUCT_ID, 4));
    REQUIRE(0 == copts.noLocal);
    REQUIRE(0 == copts.retainAsPublished);
    REQUIRE(0 == copts.retainHandling);

    REQUIRE(!opts.get_no_local());
    REQUIRE(!opts.get_retain_as_published());
    REQUIRE(0 == opts.get_retain_handling());
}

// ----------------------------------------------------------------------
// Test constructor
// ----------------------------------------------------------------------

TEST_CASE("subscribe_options ctor", "[options]")
{
    subscribe_options opts{
        subscribe_options::NO_LOCAL,
        subscribe_options::RETAIN_AS_PUBLISHED,
        subscribe_options::DONT_SEND_RETAINED,
    };
    const auto& copts = opts.c_struct();

    REQUIRE(0 == memcmp(copts.struct_id, STRUCT_ID, 4));
    REQUIRE(0 != copts.noLocal);
    REQUIRE(0 != copts.retainAsPublished);
    REQUIRE(2 == copts.retainHandling);

    REQUIRE(opts.get_no_local());
    REQUIRE(opts.get_retain_as_published());
    REQUIRE(subscribe_options::DONT_SEND_RETAINED == opts.get_retain_handling());
}

// ----------------------------------------------------------------------
// Test copy constructor
// ----------------------------------------------------------------------

TEST_CASE("subscribe_options copy ctor", "[options]")
{
    subscribe_options org_opts{
        subscribe_options::NO_LOCAL,
        subscribe_options::RETAIN_AS_PUBLISHED,
        subscribe_options::DONT_SEND_RETAINED,
    };

    subscribe_options opts{org_opts};
    const auto& copts = opts.c_struct();

    REQUIRE(0 == memcmp(copts.struct_id, STRUCT_ID, 4));
    REQUIRE(0 != copts.noLocal);
    REQUIRE(0 != copts.retainAsPublished);
    REQUIRE(2 == copts.retainHandling);

    REQUIRE(opts.get_no_local());
    REQUIRE(opts.get_retain_as_published());
    REQUIRE(subscribe_options::DONT_SEND_RETAINED == opts.get_retain_handling());
}

// ----------------------------------------------------------------------
// Test copy assignment
// ----------------------------------------------------------------------

TEST_CASE("subscribe_options copy assignment", "[options]")
{
    subscribe_options org_opts{
        subscribe_options::NO_LOCAL,
        subscribe_options::RETAIN_AS_PUBLISHED,
        subscribe_options::DONT_SEND_RETAINED,
    };

    subscribe_options opts;

    opts = org_opts;
    const auto& copts = opts.c_struct();

    REQUIRE(0 == memcmp(copts.struct_id, STRUCT_ID, 4));
    REQUIRE(0 != copts.noLocal);
    REQUIRE(0 != copts.retainAsPublished);
    REQUIRE(2 == copts.retainHandling);

    REQUIRE(opts.get_no_local());
    REQUIRE(opts.get_retain_as_published());
    REQUIRE(subscribe_options::DONT_SEND_RETAINED == opts.get_retain_handling());
}

```

`test/unit/test_thread_queue.cpp`:

```cpp
// test_thread_queue.cpp
//
// Unit tests for the thread_queue class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2022-2024 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - Initial implementation
 *******************************************************************************/

#define UNIT_TESTS

#include <chrono>
#include <future>
#include <thread>
#include <vector>

#include "catch2_version.h"
#include "mqtt/thread_queue.h"
#include "mqtt/types.h"

using namespace mqtt;
using namespace std::chrono;

TEST_CASE("thread_queue put/get", "[thread_queue]")
{
    thread_queue<int> que;

    que.put(1);
    que.put(2);
    REQUIRE(que.get() == 1);

    que.put(3);
    REQUIRE(que.get() == 2);
    REQUIRE(que.get() == 3);
}

TEST_CASE("thread_queue tryget", "[thread_queue]")
{
    thread_queue<int> que;
    int n;

    // try_get's should fail on empty queue
    REQUIRE(!que.try_get(&n));
    REQUIRE(!que.try_get_for(&n, 5ms));

    auto timeout = steady_clock::now() + 15ms;
    REQUIRE(!que.try_get_until(&n, timeout));

    que.put(1);
    que.put(2);
    REQUIRE(que.try_get(&n));
    REQUIRE(n == 1);

    que.put(3);
    REQUIRE(que.try_get(&n));
    REQUIRE(n == 2);
    REQUIRE(que.try_get(&n));
    REQUIRE(n == 3);

    // Empty now. Try should fail and leave 'n' unchanged
    REQUIRE(!que.try_get(&n));
    REQUIRE(n == 3);
}

TEST_CASE("thread_queue tryput", "[thread_queue]")
{
    thread_queue<int> que{2};

    REQUIRE(que.try_put(1));
    REQUIRE(que.try_put(2));

    // Queue full. Put should fail
    REQUIRE(!que.try_put(3));
    REQUIRE(!que.try_put_for(3, 5ms));

    auto timeout = steady_clock::now() + 15ms;
    REQUIRE(!que.try_put_until(3, timeout));
}

TEST_CASE("thread_queue mt put/get", "[thread_queue]")
{
    thread_queue<string> que;
    const size_t N = 100000;
    const size_t N_THR = 2;

    auto producer = [&que, &N]() {
        string s;
        for (size_t i = 0; i < 512; ++i) {
            s.push_back('a' + i % 26);
        }

        for (size_t i = 0; i < N; ++i) {
            que.put(s);
        }
    };

    auto consumer = [&que, &N]() {
        string s;
        bool ok = true;
        for (size_t i = 0; i < N && ok; ++i) {
            ok = que.try_get_for(&s, 250ms);
        }
        return ok;
    };

    std::vector<std::thread> producers;
    std::vector<std::future<bool>> consumers;

    for (size_t i = 0; i < N_THR; ++i) {
        producers.push_back(std::thread(producer));
    }

    for (size_t i = 0; i < N_THR; ++i) {
        consumers.push_back(std::async(consumer));
    }

    for (size_t i = 0; i < N_THR; ++i) {
        producers[i].join();
    }

    for (size_t i = 0; i < N_THR; ++i) {
        REQUIRE(consumers[i].get());
    }
}

TEST_CASE("thread_queue close", "[thread_queue]")
{
    thread_queue<int> que;
    REQUIRE(!que.closed());

    que.put(1);
    que.put(2);
    que.close();

    // Queue is closed. Shouldn't accept any new items.
    REQUIRE(que.closed());
    REQUIRE(que.size() == 2);

    REQUIRE_THROWS_AS(que.put(3), queue_closed);
    REQUIRE(!que.try_put(3));
    REQUIRE(!que.try_put_for(3, 10ms));
    REQUIRE(!que.try_put_until(3, steady_clock::now() + 10ms));

    // But can get any items already in there.
    REQUIRE(que.get() == 1);
    REQUIRE(que.get() == 2);

    // When done (closed and empty), should throw on a get(),
    // or fail on a try_get
    REQUIRE(que.empty());
    REQUIRE(que.done());

    int n;
    REQUIRE_THROWS_AS(que.get(), queue_closed);
    REQUIRE(!que.try_get(&n));
    REQUIRE(!que.try_get_for(&n, 10ms));
    REQUIRE(!que.try_get_until(&n, steady_clock::now() + 10ms));
}

TEST_CASE("thread_queue close_signals", "[thread_queue]")
{
    thread_queue<int> que;
    REQUIRE(!que.closed());

    auto thr = std::thread([&que] {
        std::this_thread::sleep_for(10ms);
        que.close();
    });

    // Should initially block, but then throw when the queue
    // is closed by the other thread.
    REQUIRE_THROWS_AS(que.get(), queue_closed);

    thr.join();
}

```

`test/unit/test_token.cpp`:

```cpp
// test_token.h
//
//  Unit tests for the token class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2016 Guilherme M. Ferreira <guilherme.maciel.ferreira@gmail.com>
 * Copyright (c) 2016-2020 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Guilherme M. Ferreira
 *        - initial implementation and documentation
 *    Frank Pagliughi
 *        - additional tests. Made this test a friend of token.
 *        - updated for token::Type
 *        - Converted to use Catch2
 *******************************************************************************/

#define UNIT_TESTS

#include <cstring>

#include "catch2_version.h"
#include "mock_action_listener.h"
#include "mock_async_client.h"
#include "mqtt/token.h"

using namespace mqtt;

using milliseconds = std::chrono::milliseconds;
using steady_clock = std::chrono::steady_clock;

static mock_async_client cli;

static constexpr token::Type TYPE = token::Type::CONNECT;

// ----------------------------------------------------------------------
// Test user constructor (iasync_client)
// ----------------------------------------------------------------------

TEST_CASE("token user constructor client", "[token]")
{
    mqtt::token tok{TYPE, cli};
    REQUIRE(0 == tok.get_message_id());
    REQUIRE(dynamic_cast<mqtt::iasync_client*>(&cli) == tok.get_client());
    REQUIRE(nullptr == tok.get_user_context());
    REQUIRE(nullptr == tok.get_action_callback());
    REQUIRE(!tok.is_complete());
    REQUIRE(nullptr == tok.get_topics());
}

// ----------------------------------------------------------------------
// Test user constructor (iasync_client, MQTTAsync_token)
// ----------------------------------------------------------------------

TEST_CASE("token user constructor client token", "[token]")
{
    MQTTAsync_token id{2};
    mqtt::token tok{TYPE, cli, id};
    REQUIRE(id == tok.get_message_id());
    REQUIRE(dynamic_cast<mqtt::iasync_client*>(&cli) == tok.get_client());
    REQUIRE(nullptr == tok.get_user_context());
    REQUIRE(nullptr == tok.get_action_callback());
    REQUIRE(!tok.is_complete());
    REQUIRE(nullptr == tok.get_topics());
}

// ----------------------------------------------------------------------
// Test user constructor (iasync_client, string)
// ----------------------------------------------------------------------

TEST_CASE("token user constructor client string", "[token]")
{
    std::string topic{"topic"};
    mqtt::token tok{TYPE, cli, topic};
    REQUIRE(0 == tok.get_message_id());
    REQUIRE(dynamic_cast<mqtt::iasync_client*>(&cli) == tok.get_client());
    REQUIRE(nullptr == tok.get_user_context());
    REQUIRE(nullptr == tok.get_action_callback());
    REQUIRE(!tok.is_complete());
    REQUIRE(nullptr != tok.get_topics());
    REQUIRE(size_t(1) == tok.get_topics()->size());
    REQUIRE(topic == (*tok.get_topics())[0]);
}

// ----------------------------------------------------------------------
// Test user constructor (iasync_client, vector<string>)
// ----------------------------------------------------------------------

TEST_CASE("token user constructor client vector", "[token]")
{
    auto topics = string_collection::create({"topic1", "topic2"});
    mqtt::token tok{TYPE, cli, topics};
    REQUIRE(0 == tok.get_message_id());
    REQUIRE(dynamic_cast<mqtt::iasync_client*>(&cli) == tok.get_client());
    REQUIRE(static_cast<void*>(nullptr) == tok.get_user_context());
    REQUIRE(static_cast<mqtt::iaction_listener*>(nullptr) == tok.get_action_callback());
    REQUIRE(!tok.is_complete());
    REQUIRE(nullptr != tok.get_topics());
    REQUIRE(size_t(2) == tok.get_topics()->size());
    REQUIRE((*topics)[0] == (*tok.get_topics())[0]);
    REQUIRE((*topics)[1] == (*tok.get_topics())[1]);
}

// ----------------------------------------------------------------------
// Test on success with data
// ----------------------------------------------------------------------

TEST_CASE("token on success with data", "[token]")
{
    mqtt::token tok{TYPE, cli};

    constexpr int MESSAGE_ID = 12;
    MQTTAsync_successData data{};

    data.token = MESSAGE_ID;
    data.alt.connect.serverURI = const_cast<char*>("tcp://some_server.com");

    REQUIRE(!tok.is_complete());
    mock_async_client::succeed(&tok, &data);
    REQUIRE(tok.is_complete());
    REQUIRE(MESSAGE_ID == tok.get_message_id());
}

// ----------------------------------------------------------------------
// Test on success without data
// ----------------------------------------------------------------------

TEST_CASE("token on success without data", "[token]")
{
    mqtt::token tok{TYPE, cli};

    REQUIRE(!tok.is_complete());
    mock_async_client::succeed(&tok, nullptr);
    REQUIRE(tok.is_complete());
}

// ----------------------------------------------------------------------
// Test on failure with data
// ----------------------------------------------------------------------

TEST_CASE("token on failure with data", "[token]")
{
    mqtt::token tok{TYPE, cli};

    REQUIRE(!tok.is_complete());
    constexpr int MESSAGE_ID = 12;
    MQTTAsync_failureData data{};

    data.token = MESSAGE_ID;
    data.code = 13;
    data.message = nullptr;

    mock_async_client::fail(&tok, &data);
    REQUIRE(tok.is_complete());
    REQUIRE(MESSAGE_ID == tok.get_message_id());
}

// ----------------------------------------------------------------------
// Test on failure without data
// ----------------------------------------------------------------------

TEST_CASE("token on failure without data", "[token]")
{
    mqtt::token tok{TYPE, cli};

    REQUIRE(!tok.is_complete());
    mock_async_client::fail(&tok, nullptr);
    REQUIRE(tok.is_complete());
    REQUIRE(0 == tok.get_message_id());
}

// ----------------------------------------------------------------------
// Test set callbacks
// ----------------------------------------------------------------------

TEST_CASE("token action callback", "[token]")
{
    mock_action_listener listener;
    mqtt::token tok{TYPE, cli};
    tok.set_action_callback(listener);
    REQUIRE(dynamic_cast<mqtt::iaction_listener*>(&listener) == tok.get_action_callback());

    REQUIRE(!listener.succeeded());
    mock_async_client::succeed(&tok, nullptr);
    REQUIRE(listener.succeeded());

    REQUIRE(!listener.failed());
    mock_async_client::fail(&tok, nullptr);
    REQUIRE(listener.failed());
}

// ----------------------------------------------------------------------
// Test wait for completion on success case
// All wait's should succeed immediately on successful completion.
// ----------------------------------------------------------------------

TEST_CASE("token wait success", "[token]")
{
    const auto TIMEOUT = milliseconds(10);

    mqtt::token tok{TYPE, cli};

    // NOTE: Make sure the complete flag is already true and the return
    // code (rc) is MQTTASYNC_SUCCESS, so the token::wait()
    // returns immediately. Otherwise we will get stuck in a single thread
    // that can't change the complete flag.
    mock_async_client::succeed(&tok, nullptr);
    REQUIRE(tok.is_complete());

    // A wait does not reset the "complete" flag.

    try {
        tok.wait();
        REQUIRE(tok.is_complete());
    }
    catch (...) {
        FAIL("token::wait() should not throw on success");
    }

    // try_wait()
    try {
        REQUIRE(tok.try_wait());
        REQUIRE(tok.is_complete());
    }
    catch (...) {
        FAIL("token::wait() should not throw on success");
    }

    // wait_for()
    try {
        REQUIRE(tok.wait_for(TIMEOUT));
        REQUIRE(tok.is_complete());
    }
    catch (...) {
        FAIL("token::wait_for() should not throw on success");
    }

    // wait_until()
    const auto TO = steady_clock::now() + TIMEOUT;
    try {
        REQUIRE(tok.wait_until(TO));
        REQUIRE(tok.is_complete());
    }
    catch (...) {
        FAIL("token::wait_until() should not throw on success");
    }
}

// ----------------------------------------------------------------------
// Test wait for completion on failure case
// All wait's should throw if the action failed
// ----------------------------------------------------------------------

TEST_CASE("token wait failure", "[token]")
{
    const auto TIMEOUT = milliseconds(10);

    mqtt::token tok{TYPE, cli};

    // NOTE: Make sure the complete flag is already true and the return
    // code (rc) is MQTTASYNC_FAILURE, so the token::wait()
    // returns immediately. Otherwise we will get stuck in a single thread
    // that can't change the complete flag.
    constexpr int MESSAGE_ID = 12;
    MQTTAsync_failureData data{};

    data.token = MESSAGE_ID;
    data.code = MQTTASYNC_FAILURE;
    data.message = nullptr;

    mock_async_client::fail(&tok, &data);

    REQUIRE(tok.is_complete());
    REQUIRE(MESSAGE_ID == tok.get_message_id());
    REQUIRE(MQTTASYNC_FAILURE == tok.get_return_code());

    try {
        tok.wait();
        FAIL("token::wait() should throw on failure");
    }
    catch (mqtt::exception& ex) {
        REQUIRE(MQTTASYNC_FAILURE == ex.get_return_code());
    }

    try {
        tok.try_wait();
        FAIL("token::try_wait() should throw on failure");
    }
    catch (mqtt::exception& ex) {
        REQUIRE(MQTTASYNC_FAILURE == ex.get_return_code());
    }

    try {
        tok.wait_for(TIMEOUT);
        FAIL("token::wait_for() should throw on failure");
    }
    catch (mqtt::exception& ex) {
        REQUIRE(MQTTASYNC_FAILURE == ex.get_return_code());
    }

    try {
        tok.wait_until(steady_clock::now() + TIMEOUT);
        FAIL("token::wait_until() should throw on failure");
    }
    catch (mqtt::exception& ex) {
        REQUIRE(MQTTASYNC_FAILURE == ex.get_return_code());
    }
}

// ----------------------------------------------------------------------
// Test wait for completion on failure due timeout case
// All waits should return false, but not throw, on a timeout
// ----------------------------------------------------------------------

TEST_CASE("token wait for timeout", "[token]")
{
    const auto TIMEOUT = milliseconds(10);

    mqtt::token tok{TYPE, cli};

    // Test for timeout on non-signaled token.
    REQUIRE(!tok.is_complete());

    // try_wait()
    try {
        REQUIRE(!tok.try_wait());
    }
    catch (...) {
        FAIL("token::try_wait() should not throw");
    }

    // wait_for()
    REQUIRE(!tok.is_complete());
    try {
        REQUIRE(!tok.wait_for(TIMEOUT));
    }
    catch (...) {
        FAIL("token::wait_for() should not throw on timeout");
    }

    // wait_until()
    const auto TO = steady_clock::now() + TIMEOUT;
    REQUIRE(!tok.is_complete());
    try {
        REQUIRE(!tok.wait_until(TO));
    }
    catch (...) {
        FAIL("token::wait_until() should not throw on timeout");
    }
}

```

`test/unit/test_topic.cpp`:

```cpp
// topic_test.h
//
// Unit tests for the topic class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2020-2022 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *******************************************************************************/

#define UNIT_TESTS

#include <algorithm>
#include <memory>
#include <stdexcept>

#include "catch2_version.h"
#include "mock_async_client.h"
#include "mqtt/topic.h"

using namespace mqtt;

/////////////////////////////////////////////////////////////////////////////

static const int DFLT_QOS = message::DFLT_QOS;
static const bool DFLT_RETAINED = message::DFLT_RETAINED;

static const std::string TOPIC{"my/topic/name"};
static const int QOS = 1;
static const bool RETAINED = true;

static const int BAD_LOW_QOS = -1;
static const int BAD_HIGH_QOS = 3;

static const char* BUF = "Hello there";
static const size_t N = std::strlen(BUF);
static const binary PAYLOAD{BUF};

static mqtt::mock_async_client cli;

// ----------------------------------------------------------------------
// Constructors
// ----------------------------------------------------------------------

TEST_CASE("basic ctor", "[topic]")
{
    mqtt::topic topic{cli, TOPIC};

    REQUIRE(static_cast<iasync_client*>(&cli) == &topic.get_client());
    REQUIRE(TOPIC == topic.get_name());
    REQUIRE(TOPIC == topic.to_string());
    REQUIRE(DFLT_QOS == topic.get_qos());
    REQUIRE(DFLT_RETAINED == topic.get_retained());
}

// ----------------------------------------------------------------------

TEST_CASE("full ctor", "[topic]")
{
    mqtt::topic topic{cli, TOPIC, QOS, RETAINED};

    REQUIRE(static_cast<iasync_client*>(&cli) == &topic.get_client());
    REQUIRE(TOPIC == topic.get_name());
    REQUIRE(TOPIC == topic.to_string());
    REQUIRE(QOS == topic.get_qos());
    REQUIRE(RETAINED == topic.get_retained());
}

// ----------------------------------------------------------------------
// get/set
// ----------------------------------------------------------------------

TEST_CASE("get/set", "[topic]")
{
    mqtt::topic topic{cli, TOPIC};

    REQUIRE(DFLT_QOS == topic.get_qos());
    REQUIRE(DFLT_RETAINED == topic.get_retained());

    SECTION("qos")
    {
        topic.set_qos(QOS);
        REQUIRE(QOS == topic.get_qos());

        REQUIRE_THROWS(topic.set_qos(BAD_LOW_QOS));
        REQUIRE_THROWS(topic.set_qos(BAD_HIGH_QOS));
    }

    SECTION("retained")
    {
        topic.set_retained(RETAINED);
        REQUIRE(RETAINED == topic.get_retained());

        topic.set_retained(!RETAINED);
        REQUIRE(!RETAINED == topic.get_retained());
    }
}

TEST_CASE("split", "[topic]")
{
    auto v = topic::split(TOPIC);

    REQUIRE(3 == v.size());
    REQUIRE("my" == v[0]);
    REQUIRE("topic" == v[1]);
    REQUIRE("name" == v[2]);
}

// ----------------------------------------------------------------------
// Publish
// ----------------------------------------------------------------------

TEST_CASE("publish C str", "[topic]")
{
    mqtt::topic topic{cli, TOPIC, QOS, RETAINED};

    auto tok = topic.publish(BUF, N);
    REQUIRE(tok);

    auto msg = tok->get_message();
    REQUIRE(msg);

    REQUIRE(TOPIC == msg->get_topic());
    REQUIRE(msg->get_payload().data());
    REQUIRE(0 == memcmp(BUF, msg->get_payload().data(), N));
    REQUIRE(QOS == msg->get_qos());
    REQUIRE(RETAINED == msg->is_retained());
}

// ----------------------------------------------------------------------

TEST_CASE("publish full C str", "[topic]")
{
    mqtt::topic topic{cli, TOPIC};

    auto tok = topic.publish(BUF, N, QOS, RETAINED);
    REQUIRE(tok);

    auto msg = tok->get_message();
    REQUIRE(msg);

    REQUIRE(TOPIC == msg->get_topic());
    REQUIRE(msg->get_payload().data());
    REQUIRE(0 == memcmp(BUF, msg->get_payload().data(), N));
    REQUIRE(QOS == msg->get_qos());
    REQUIRE(RETAINED == msg->is_retained());
}

// ----------------------------------------------------------------------

TEST_CASE("publish binary", "[topic]")
{
    mqtt::topic topic{cli, TOPIC, QOS, RETAINED};

    auto tok = topic.publish(PAYLOAD);
    REQUIRE(tok);

    auto msg = tok->get_message();
    REQUIRE(msg);

    REQUIRE(TOPIC == msg->get_topic());
    REQUIRE(PAYLOAD == msg->get_payload());
    REQUIRE(QOS == msg->get_qos());
    REQUIRE(RETAINED == msg->is_retained());
}

// ----------------------------------------------------------------------

TEST_CASE("publish full binary", "[topic]")
{
    mqtt::topic topic{cli, TOPIC};

    auto tok = topic.publish(PAYLOAD, QOS, RETAINED);
    REQUIRE(tok);

    auto msg = tok->get_message();
    REQUIRE(msg);

    REQUIRE(TOPIC == msg->get_topic());
    REQUIRE(PAYLOAD == msg->get_payload());
    REQUIRE(QOS == msg->get_qos());
    REQUIRE(RETAINED == msg->is_retained());
}

/////////////////////////////////////////////////////////////////////////////
//						topic_filter
/////////////////////////////////////////////////////////////////////////////

TEST_CASE("topic filter has_wildcards", "[topic_filter]")
{
    REQUIRE(!topic_filter::has_wildcards(TOPIC));

    REQUIRE(topic_filter::has_wildcards("some/wild/+/topic"));
    REQUIRE(topic_filter::has_wildcards("some/multi/wild/#"));
}

TEST_CASE("topic filter matches", "[topic_filter]")
{
    SECTION("no_wildcards")
    {
        topic_filter filt{"my/topic/name"};

        REQUIRE(filt.matches("my/topic/name"));
        REQUIRE(!filt.matches("my/topic/name/but/longer"));
        REQUIRE(!filt.matches("some/other/topic"));
    }

    // Test single-level wildcard, '+'
    SECTION("single_wildcard")
    {
        topic_filter filt{"my/+/name"};

        REQUIRE(filt.matches("my/topic/name"));
        REQUIRE(filt.matches("my/other/name"));
        REQUIRE(!filt.matches("my/other/id"));
    }

    // Test multi-level wildcard, '#'
    SECTION("multi_wildcard")
    {
        topic_filter filt{"my/topic/#"};

        REQUIRE(filt.matches("my/topic/name"));
        REQUIRE(filt.matches("my/topic/id"));
        REQUIRE(filt.matches("my/topic/name/and/id"));
        REQUIRE(filt.matches("my/topic"));

        REQUIRE(!filt.matches("my/other/name"));
        REQUIRE(!filt.matches("my/other/id"));
    }

    // Th following sections are mostly borrowed from the Paho Python tests.
    // They have a number of good corner cases that should and should not
    // match.

    SECTION("should_match")
    {
        REQUIRE(topic_filter{"foo/bar"}.matches("foo/bar"));
        REQUIRE(topic_filter{"foo/+"}.matches("foo/bar"));
        REQUIRE(topic_filter{"foo/+/baz"}.matches("foo/bar/baz"));
        REQUIRE(topic_filter{"foo/+/#"}.matches("foo/bar/baz"));
        REQUIRE(topic_filter("foo/bar/#").matches("foo/bar/baz"));
        REQUIRE(topic_filter("foo/bar/#").matches("foo/bar"));
        REQUIRE(topic_filter{"A/B/+/#"}.matches("A/B/B/C"));
        REQUIRE(topic_filter{"#"}.matches("foo/bar/baz"));
        REQUIRE(topic_filter{"#"}.matches("/foo/bar"));
        REQUIRE(topic_filter{"/#"}.matches("/foo/bar"));
        REQUIRE(topic_filter{"$SYS/bar"}.matches("$SYS/bar"));
        REQUIRE(topic_filter{"$SYS/#"}.matches("$SYS/bar"));
        REQUIRE(topic_filter{"foo/#"}.matches("foo/$bar"));
        REQUIRE(topic_filter{"foo/+/baz"}.matches("foo/$bar/baz"));
    }

    SECTION("should_not_match")
    {
        REQUIRE(!topic_filter{"test/6/#"}.matches("test/3"));
        REQUIRE(!topic_filter{"foo/bar"}.matches("foo"));
        REQUIRE(!topic_filter{"foo/+"}.matches("foo/bar/baz"));
        REQUIRE(!topic_filter{"foo/+/baz"}.matches("foo/bar/bar"));
        REQUIRE(!topic_filter{"foo/+/#"}.matches("fo2/bar/baz"));
        REQUIRE(!topic_filter{"/#"}.matches("foo/bar"));
        REQUIRE(!topic_filter{"#"}.matches("$SYS/bar"));
        REQUIRE(!topic_filter{"$BOB/bar"}.matches("$SYS/bar"));
        REQUIRE(!topic_filter{"+/bar"}.matches("$SYS/bar"));
        REQUIRE(!topic_filter{""}.matches("foo"));
        REQUIRE(!topic_filter{""}.matches("foo/bar"));
        REQUIRE(!topic_filter{"foo/bar"}.matches(""));
    }
}

TEST_CASE("topic filter to_string", "[topic_filter]")
{
    REQUIRE(topic_filter{"some/topic/filter"}.to_string() == "some/topic/filter");
    REQUIRE(topic_filter{"some/+/filter"}.to_string() == "some/+/filter");
    REQUIRE(topic_filter{"some/topic/#"}.to_string() == "some/topic/#");
}

```

`test/unit/test_topic_matcher.cpp`:

```cpp
// test_topic_matcher.cpp
//
// Unit tests for the topic_matcher class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2022 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *******************************************************************************/

#define UNIT_TESTS

#include "catch2_version.h"
#include "mqtt/topic_matcher.h"

using namespace mqtt;

/////////////////////////////////////////////////////////////////////////////

TEST_CASE("insert/get", "[topic_matcher]")
{
    topic_matcher<int> tm;

    tm.insert({"some/random/topic", 42});

    auto it = tm.find("some/random/topic");

    REQUIRE(it != tm.end());
    REQUIRE(it->first == "some/random/topic");
    REQUIRE(it->second == 42);
}

TEST_CASE("matcher initialize", "[topic_matcher]")
{
    topic_matcher<int> tm{
        {"some/random/topic", 42},
        {"some/#", 99},
        {"some/other/topic", 55},
        {"some/+/topic", 33}
    };

    auto it = tm.matches("some/random/topic");

    for (; it != tm.matches_end(); ++it) {
        bool ok =
            ((it->first == "some/random/topic" && it->second == 42) ||
             (it->first == "some/#" && it->second == 99) ||
             (it->first == "some/+/topic" && it->second == 33));
        REQUIRE(ok);
    }
}

// This one is mostly borrowed from the Paho Python tests.
// It has a number of good corner cases that shoud and should not match.
TEST_CASE("matcher matches", "[topic_matcher]")
{
    // Should match

    REQUIRE((topic_matcher<int>{{"foo/bar", 42}}.has_match("foo/bar")));
    REQUIRE((topic_matcher<int>{{"foo/+", 42}}.has_match("foo/bar")));
    REQUIRE((topic_matcher<int>{{"foo/+/baz", 42}}.has_match("foo/bar/baz")));
    REQUIRE((topic_matcher<int>{{"foo/+/#", 42}}.has_match("foo/bar/baz")));
    REQUIRE((topic_matcher<int>{{"foo/bar/#", 42}}.has_match("foo/bar/baz")));
    REQUIRE((topic_matcher<int>{{"foo/bar/#", 42}}.has_match("foo/bar")));
    REQUIRE((topic_matcher<int>{{"A/B/+/#", 42}}.has_match("A/B/B/C")));
    REQUIRE((topic_matcher<int>{{"#", 42}}.has_match("foo/bar/baz")));
    REQUIRE((topic_matcher<int>{{"#", 42}}.has_match("/foo/bar")));
    REQUIRE((topic_matcher<int>{{"/#", 42}}.has_match("/foo/bar")));
    REQUIRE((topic_matcher<int>{{"$SYS/bar", 42}}.has_match("$SYS/bar")));
    REQUIRE((topic_matcher<int>{{"foo/#", 42}}.has_match("foo/$bar")));
    REQUIRE((topic_matcher<int>{{"foo/+/baz", 42}}.has_match("foo/$bar/baz")));

    // Should not match

    REQUIRE(!(topic_matcher<int>{{"test/6/#", 42}}.has_match("test/3")));
    REQUIRE(!(topic_matcher<int>{{"foo/bar", 42}}.has_match("foo")));
    REQUIRE(!(topic_matcher<int>{{"foo/+", 42}}.has_match("foo/bar/baz")));
    REQUIRE(!(topic_matcher<int>{{"foo/+/baz", 42}}.has_match("foo/bar/bar")));
    REQUIRE(!(topic_matcher<int>{{"foo/+/#", 42}}.has_match("fo2/bar/baz")));
    REQUIRE(!(topic_matcher<int>{{"/#", 42}}.has_match("foo/bar")));
    REQUIRE(!(topic_matcher<int>{{"#", 42}}.has_match("$SYS/bar")));
    REQUIRE(!(topic_matcher<int>{{"$BOB/bar", 42}}.has_match("$SYS/bar")));
    REQUIRE(!(topic_matcher<int>{{"+/bar", 42}}.has_match("$SYS/bar")));
}

```

`test/unit/test_will_options.cpp`:

```cpp
// test_will_options.cpp
//
// Unit tests for the will_options class in the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2016-2020 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation and documentation
 *******************************************************************************/

#define UNIT_TESTS

#include <cstring>

#include "catch2_version.h"
#include "mock_async_client.h"
#include "mqtt/will_options.h"

using namespace mqtt;

static const std::string EMPTY_STR;
static const int DFLT_QOS = will_options::DFLT_QOS;
static const bool DFLT_RETAINED = will_options::DFLT_RETAINED;

// C struct signature/eyecatcher
static const char* CSIG = "MQTW";
static const size_t CSIG_LEN = std::strlen(CSIG);

static const std::string TOPIC = "hello";
static const char* BUF = "Hello there";
static const size_t N = std::strlen(BUF);
static const std::string PAYLOAD = std::string(BUF);
static const int QOS = 1;
static const bool RETAINED = true;

// ----------------------------------------------------------------------
// Test the default constructor
// ----------------------------------------------------------------------

TEST_CASE("will_options default ctor", "[options]")
{
    mqtt::will_options opts;

    REQUIRE(EMPTY_STR == opts.get_topic());
    REQUIRE(EMPTY_STR == opts.get_payload_str());
    REQUIRE(DFLT_QOS == opts.get_qos());
    REQUIRE(DFLT_RETAINED == opts.is_retained());

    // Test the C struct
    const auto& c_struct = opts.c_struct();

    REQUIRE(0 == memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));
    REQUIRE(c_struct.topicName != nullptr);
    REQUIRE(size_t(0) == strlen(c_struct.topicName));
    REQUIRE(c_struct.message == nullptr);
    REQUIRE(0 == c_struct.payload.len);
    REQUIRE(c_struct.payload.data == nullptr);
}

// ----------------------------------------------------------------------
// Test the raw buffer (void*) constructor
// ----------------------------------------------------------------------

TEST_CASE("will_options string buf ctor", "[options]")
{
    mock_async_client cli;
    mqtt::topic topic{cli, TOPIC};

    mqtt::will_options opts(topic, BUF, N, QOS, true);

    REQUIRE(TOPIC == opts.get_topic());
    REQUIRE(PAYLOAD == opts.get_payload_str());
    REQUIRE(QOS == opts.get_qos());
    REQUIRE(RETAINED == opts.is_retained());

    // Test the C struct
    // Remember we now fill payload fields, not message
    const auto& c_struct = opts.c_struct();

    REQUIRE(0 == memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));
    REQUIRE(0 == strcmp(c_struct.topicName, TOPIC.c_str()));
    REQUIRE(c_struct.message == nullptr);
    REQUIRE(N == size_t(c_struct.payload.len));
    REQUIRE(0 == memcmp(BUF, c_struct.payload.data, N));
}

// ----------------------------------------------------------------------
// Test the raw buffer (void*) constructor
// ----------------------------------------------------------------------

TEST_CASE("will_options topic buf ctor", "[options]")
{
    mqtt::will_options opts(TOPIC, BUF, N, QOS, true);

    REQUIRE(TOPIC == opts.get_topic());
    REQUIRE(PAYLOAD == opts.get_payload_str());
    REQUIRE(QOS == opts.get_qos());
    REQUIRE(RETAINED == opts.is_retained());

    // Test the C struct
    const auto& c_struct = opts.c_struct();

    REQUIRE(0 == memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));
    REQUIRE(0 == strcmp(c_struct.topicName, TOPIC.c_str()));
    REQUIRE(c_struct.message == nullptr);
    REQUIRE(N == size_t(c_struct.payload.len));
    REQUIRE(0 == memcmp(BUF, c_struct.payload.data, N));
}

// ----------------------------------------------------------------------
// Test the string payload constructor
// ----------------------------------------------------------------------

TEST_CASE("will_options string string ctor", "[options]")
{
    mqtt::will_options opts(TOPIC, PAYLOAD, QOS, true);

    REQUIRE(TOPIC == opts.get_topic());
    REQUIRE(PAYLOAD == opts.get_payload_str());
    REQUIRE(QOS == opts.get_qos());
    REQUIRE(RETAINED == opts.is_retained());

    // Test the C struct
    const auto& c_struct = opts.c_struct();

    REQUIRE(0 == memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));
    REQUIRE(0 == strcmp(c_struct.topicName, TOPIC.c_str()));
    REQUIRE(c_struct.message == nullptr);
    REQUIRE(PAYLOAD.size() == size_t(c_struct.payload.len));
    REQUIRE(0 == memcmp(PAYLOAD.data(), c_struct.payload.data, PAYLOAD.size()));
}

// ----------------------------------------------------------------------
// Test the message payload constructor
// ----------------------------------------------------------------------

TEST_CASE("will_options string message ctor", "[options]")
{
    mqtt::message msg(TOPIC, PAYLOAD, QOS, true);
    mqtt::will_options opts(msg);

    REQUIRE(TOPIC == opts.get_topic());
    REQUIRE(PAYLOAD == opts.get_payload_str());
    REQUIRE(QOS == opts.get_qos());
    REQUIRE(RETAINED == opts.is_retained());

    // Test the C struct
    const auto& c_struct = opts.c_struct();

    REQUIRE(0 == memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));
    REQUIRE(0 == strcmp(c_struct.topicName, TOPIC.c_str()));
    REQUIRE(c_struct.message == nullptr);
    REQUIRE(PAYLOAD.size() == size_t(c_struct.payload.len));
    REQUIRE(0 == memcmp(PAYLOAD.data(), c_struct.payload.data, PAYLOAD.size()));
}

// ----------------------------------------------------------------------
// Test the copy constructor
// ----------------------------------------------------------------------

TEST_CASE("will_options copy ctor", "[options]")
{
    auto orgOpts = mqtt::will_options(TOPIC, BUF, N, QOS, RETAINED);

    mqtt::will_options opts(orgOpts);

    REQUIRE(TOPIC == opts.get_topic());
    REQUIRE(PAYLOAD == opts.get_payload_str());
    REQUIRE(QOS == opts.get_qos());
    REQUIRE(RETAINED == opts.is_retained());

    // Check the C struct
    const auto& c_struct = opts.c_struct();

    REQUIRE(0 == memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));
    REQUIRE(0 == strcmp(c_struct.topicName, TOPIC.c_str()));
    REQUIRE(c_struct.message == nullptr);
    REQUIRE(N == size_t(c_struct.payload.len));
    REQUIRE(0 == memcmp(BUF, c_struct.payload.data, N));

    // Make sure it's a true copy, not linked to the original
    orgOpts.set_topic(EMPTY_STR);
    orgOpts.set_payload(EMPTY_STR);
    orgOpts.set_qos(DFLT_QOS);
    orgOpts.set_retained(false);

    REQUIRE(TOPIC == opts.get_topic());
    REQUIRE(PAYLOAD == opts.get_payload_str());
    REQUIRE(QOS == opts.get_qos());
    REQUIRE(RETAINED == opts.is_retained());
}

// ----------------------------------------------------------------------
// Test the move constructor
// ----------------------------------------------------------------------

TEST_CASE("will_options move ctor", "[options]")
{
    auto orgOpts = mqtt::will_options(TOPIC, BUF, N, QOS, RETAINED);

    mqtt::will_options opts(std::move(orgOpts));

    REQUIRE(TOPIC == opts.get_topic());
    REQUIRE(PAYLOAD == opts.get_payload_str());
    REQUIRE(QOS == opts.get_qos());
    REQUIRE(RETAINED == opts.is_retained());

    // Check the C struct
    const auto& c_struct = opts.c_struct();

    REQUIRE(0 == memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));
    REQUIRE(0 == strcmp(c_struct.topicName, TOPIC.c_str()));
    REQUIRE(c_struct.message == nullptr);
    REQUIRE(N == size_t(c_struct.payload.len));
    REQUIRE(0 == memcmp(BUF, c_struct.payload.data, N));

    // Check that the original was moved
    REQUIRE(EMPTY_STR == orgOpts.get_topic());
    REQUIRE(EMPTY_STR == orgOpts.get_payload_str());
}

// ----------------------------------------------------------------------
// Test the copy assignment operator=(const&)
// ----------------------------------------------------------------------

TEST_CASE("will_options copy assignment", "[options]")
{
    auto orgOpts = mqtt::will_options(TOPIC, BUF, N, QOS, RETAINED);

    mqtt::will_options opts;
    opts = orgOpts;

    REQUIRE(TOPIC == opts.get_topic());
    REQUIRE(PAYLOAD == opts.get_payload_str());
    REQUIRE(QOS == opts.get_qos());
    REQUIRE(RETAINED == opts.is_retained());

    // Check the C struct
    const auto& c_struct = opts.c_struct();

    REQUIRE(0 == memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));
    REQUIRE(0 == strcmp(c_struct.topicName, TOPIC.c_str()));
    REQUIRE(c_struct.message == nullptr);
    REQUIRE(N == size_t(c_struct.payload.len));
    REQUIRE(0 == memcmp(BUF, c_struct.payload.data, N));

    // Make sure it's a true copy, not linked to the original
    orgOpts.set_topic(EMPTY_STR);
    orgOpts.set_payload(EMPTY_STR);
    orgOpts.set_qos(DFLT_QOS);
    orgOpts.set_retained(false);

    REQUIRE(TOPIC == opts.get_topic());
    REQUIRE(PAYLOAD == opts.get_payload_str());
    REQUIRE(QOS == opts.get_qos());
    REQUIRE(RETAINED == opts.is_retained());

    // Self assignment should cause no harm
    opts = opts;

    REQUIRE(TOPIC == opts.get_topic());
    REQUIRE(PAYLOAD == opts.get_payload_str());
    REQUIRE(QOS == opts.get_qos());
    REQUIRE(RETAINED == opts.is_retained());
}

// ----------------------------------------------------------------------
// Test the move assignment, operator=(&&)
// ----------------------------------------------------------------------

TEST_CASE("will_options move assignment", "[options]")
{
    auto orgOpts = mqtt::will_options(TOPIC, BUF, N, QOS, RETAINED);

    mqtt::will_options opts;
    opts = std::move(orgOpts);

    REQUIRE(TOPIC == opts.get_topic());
    REQUIRE(PAYLOAD == opts.get_payload_str());
    REQUIRE(QOS == opts.get_qos());
    REQUIRE(RETAINED == opts.is_retained());

    // Check the C struct
    const auto& c_struct = opts.c_struct();

    REQUIRE(0 == memcmp(&c_struct.struct_id, CSIG, CSIG_LEN));
    REQUIRE(0 == strcmp(c_struct.topicName, TOPIC.c_str()));
    REQUIRE(c_struct.message == nullptr);
    REQUIRE(N == size_t(c_struct.payload.len));
    REQUIRE(0 == memcmp(BUF, c_struct.payload.data, N));

    // Check that the original was moved
    REQUIRE(EMPTY_STR == orgOpts.get_topic());
    REQUIRE(EMPTY_STR == orgOpts.get_payload_str());

// Self assignment should cause no harm
// (clang++ is smart enough to warn about this)
#if !defined(__clang__)
    opts = std::move(opts);
    REQUIRE(TOPIC == opts.get_topic());
    REQUIRE(PAYLOAD == opts.get_payload_str());
    REQUIRE(QOS == opts.get_qos());
    REQUIRE(RETAINED == opts.is_retained());
#endif
}

// ----------------------------------------------------------------------
// Test setting the (text) topic
// ----------------------------------------------------------------------

TEST_CASE("will_options set_topic_str", "[options]")
{
    mqtt::will_options opts;

    opts.set_topic(TOPIC);
    REQUIRE(TOPIC == opts.get_topic());

    const auto& c_struct = opts.c_struct();
    REQUIRE(0 == strcmp(c_struct.topicName, TOPIC.c_str()));

    // Setting empty string should _not_ create nullptr entry, in
    // C struct, rather a valid zero-length string.
    opts.set_topic(EMPTY_STR);

    REQUIRE(EMPTY_STR == opts.get_topic());
    REQUIRE(c_struct.topicName != nullptr);
    REQUIRE(size_t(0) == strlen(c_struct.topicName));
}

// ----------------------------------------------------------------------
// Test setting the (binary) payload
// ----------------------------------------------------------------------

TEST_CASE("will_options set_payload", "[options]")
{
    mqtt::will_options opts;

    opts.set_payload(PAYLOAD);
    REQUIRE(PAYLOAD == opts.get_payload_str());

    const auto& c_struct = opts.c_struct();

    REQUIRE(PAYLOAD.size() == size_t(c_struct.payload.len));
    REQUIRE(0 == memcmp(PAYLOAD.data(), c_struct.payload.data, PAYLOAD.size()));

    // Setting empty string set a valid, but zero-len payload
    // TODO: We need to check what the C lib now accepts.
    opts.set_payload(EMPTY_STR);

    REQUIRE(EMPTY_STR == opts.get_payload_str());
    REQUIRE(size_t(0) == opts.get_payload().size());

    REQUIRE(0 == c_struct.payload.len);
    REQUIRE(c_struct.payload.data != nullptr);
}

```

`test/unit/unit_tests.cpp`:

```cpp
// unit_tests.cpp
//
// Main for the Catch2 unit tests for the Paho MQTT C++ library.
//

/*******************************************************************************
 * Copyright (c) 2019-2023 Frank Pagliughi <fpagliughi@mindspring.com>
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *    Frank Pagliughi - initial implementation
 *******************************************************************************/

// This seems to be required, at least for MSVS 2015 on Win7,
// using Catch2 v2.9.2
#if defined(_WIN32)
    #define CATCH_CONFIG_DISABLE_EXCEPTIONS
#endif

#define CATCH_CONFIG_RUNNER
#include "catch2_version.h"

int main(int argc, char* argv[])
{
    // global setup...

    int result = Catch::Session().run(argc, argv);

    // global clean-up...

    return result;
}

```