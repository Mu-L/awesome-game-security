Project Path: arc_vvb2060_KeyAttestation_tr_j92to

Source Tree:

```txt
arc_vvb2060_KeyAttestation_tr_j92to
├── README.md
├── app
│   ├── build.gradle
│   ├── proguard-rules.pro
│   └── src
│       └── main
│           ├── AndroidManifest.xml
│           ├── aidl
│           │   ├── android
│           │   │   └── hardware
│           │   │       └── security
│           │   │           └── keymint
│           │   │               ├── DeviceInfo.aidl
│           │   │               ├── IRemotelyProvisionedComponent.aidl
│           │   │               ├── MacedPublicKey.aidl
│           │   │               ├── ProtectedData.aidl
│           │   │               └── RpcHardwareInfo.aidl
│           │   └── io
│           │       └── github
│           │           └── vvb2060
│           │               └── keyattestation
│           │                   └── keystore
│           │                       └── IAndroidKeyStore.aidl
│           ├── java
│           │   └── io
│           │       └── github
│           │           └── vvb2060
│           │               └── keyattestation
│           │                   ├── AppApplication.kt
│           │                   ├── app
│           │                   │   ├── AlertDialogFragment.kt
│           │                   │   ├── AppActivity.kt
│           │                   │   ├── AppBarActivity.kt
│           │                   │   └── AppFragment.kt
│           │                   ├── attestation
│           │                   │   ├── Asn1Attestation.java
│           │                   │   ├── Asn1Utils.java
│           │                   │   ├── Attestation.java
│           │                   │   ├── AttestationApplicationId.java
│           │                   │   ├── AttestationPackageInfo.java
│           │                   │   ├── AuthResult.java
│           │                   │   ├── AuthorizationList.java
│           │                   │   ├── CborUtils.java
│           │                   │   ├── CertificateInfo.java
│           │                   │   ├── EatAttestation.java
│           │                   │   ├── EatClaim.java
│           │                   │   ├── IntegrityStatus.java
│           │                   │   ├── KnoxAttestation.java
│           │                   │   ├── ProvisioningInfo.java
│           │                   │   ├── RevocationList.java
│           │                   │   ├── RootOfTrust.java
│           │                   │   └── RootPublicKey.java
│           │                   ├── home
│           │                   │   ├── BootStateViewHolder.kt
│           │                   │   ├── CommonItemViewHolder.kt
│           │                   │   ├── Data.kt
│           │                   │   ├── ErrorViewHolder.kt
│           │                   │   ├── HeaderViewHolder.kt
│           │                   │   ├── HomeActivity.kt
│           │                   │   ├── HomeAdapter.kt
│           │                   │   ├── HomeFragment.kt
│           │                   │   ├── HomeItemDecoration.kt
│           │                   │   ├── HomeViewHolder.kt
│           │                   │   ├── HomeViewModel.kt
│           │                   │   └── SubtitleViewHolder.kt
│           │                   ├── keystore
│           │                   │   ├── AndroidKeyStore.java
│           │                   │   ├── ContextHook.java
│           │                   │   ├── KeyBoxXmlParser.java
│           │                   │   ├── KeyStoreManager.java
│           │                   │   └── RemoteProvisioning.java
│           │                   ├── lang
│           │                   │   └── AttestationException.kt
│           │                   ├── repository
│           │                   │   ├── AttestationData.java
│           │                   │   ├── AttestationRepository.java
│           │                   │   ├── BaseData.java
│           │                   │   └── RemoteProvisioningData.java
│           │                   └── util
│           │                       ├── Resource.kt
│           │                       └── ViewBindingViewHolder.kt
│           └── res
│               ├── color
│               │   ├── material_on_surface_emphasis_high_type.xml
│               │   ├── material_on_surface_emphasis_medium.xml
│               │   └── mtrl_popupmenu_overlay_color.xml
│               ├── drawable
│               │   ├── home_item_background_solid.xml
│               │   ├── ic_boot_locked_24.xml
│               │   ├── ic_boot_unknown_24.xml
│               │   ├── ic_boot_unlocked_24.xml
│               │   ├── ic_error_outline_24.xml
│               │   ├── ic_help_outline_24.xml
│               │   ├── ic_info_outline_24.xml
│               │   ├── ic_launcher.xml
│               │   ├── ic_trustworthy_24.xml
│               │   ├── ic_untrustworthy_24.xml
│               │   └── ic_warning_24.xml
│               ├── drawable-v26
│               │   └── ic_launcher.xml
│               ├── layout
│               │   ├── appbar.xml
│               │   ├── appbar_activity.xml
│               │   ├── appbar_fragment_activity.xml
│               │   ├── home.xml
│               │   ├── home_boot_state.xml
│               │   ├── home_common_item.xml
│               │   ├── home_error.xml
│               │   ├── home_header.xml
│               │   └── home_subtitle.xml
│               ├── menu
│               │   └── home.xml
│               ├── mipmap-hdpi
│               │   ├── ic_key_attestation.png
│               │   ├── ic_key_attestation_background.png
│               │   └── ic_key_attestation_foreground.png
│               ├── mipmap-xhdpi
│               │   ├── ic_key_attestation.png
│               │   ├── ic_key_attestation_background.png
│               │   └── ic_key_attestation_foreground.png
│               ├── mipmap-xxhdpi
│               │   ├── ic_key_attestation.png
│               │   ├── ic_key_attestation_background.png
│               │   └── ic_key_attestation_foreground.png
│               ├── mipmap-xxxhdpi
│               │   ├── ic_key_attestation.png
│               │   ├── ic_key_attestation_background.png
│               │   └── ic_key_attestation_foreground.png
│               ├── raw
│               │   └── status.json
│               ├── resources.properties
│               ├── values
│               │   ├── colors.xml
│               │   ├── dimens.xml
│               │   ├── strings.xml
│               │   ├── strings_no_translate.xml
│               │   ├── styles.xml
│               │   ├── themes.xml
│               │   └── themes_override.xml
│               ├── values-pt-rBR
│               │   └── strings.xml
│               ├── values-sw600dp
│               │   └── dimens.xml
│               ├── values-zh-rCN
│               │   └── strings.xml
│               └── values-zh-rTW
│                   └── strings.xml
├── art
│   ├── icon.ai
│   └── icon_playstore.png
├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── settings.gradle
└── stub
    ├── build.gradle
    └── src
        └── main
            ├── AndroidManifest.xml
            └── java
                ├── android
                │   ├── app
                │   │   ├── ActivityThread.java
                │   │   └── ContextImpl.java
                │   ├── os
                │   │   ├── ServiceManager.java
                │   │   ├── ServiceSpecificException.java
                │   │   └── SystemProperties.java
                │   ├── security
                │   │   ├── keystore
                │   │   │   ├── AndroidKeyStoreProvider.java
                │   │   │   ├── AttestationUtils.java
                │   │   │   ├── DeviceIdAttestationException.java
                │   │   │   └── KeyGenParameterSpec_rename.java
                │   │   └── keystore2
                │   │       └── AndroidKeyStoreProvider.java
                │   └── telephony
                │       └── TelephonyManager_rename.java
                └── com
                    └── samsung
                        └── android
                            └── security
                                └── keystore
                                    ├── AttestParameterSpec.java
                                    └── AttestationUtils.java

```

`README.md`:

```md
Android Key Attestation Test App
==============================

This app supports generating, saving, loading, parsing and verifying Android [key and ID attestation](https://source.android.com/docs/security/features/keystore/attestation) data.

The app is used for self-testing, so it has no network permission. The certificate revocation data is embedded in the apk and will not be updated online. If the system is compromised, parsing and verifying is not safe, you should save the data to a file and then load the file on another device to verify it.

This app also supports loading certificate chain generated by other software.

Useful links
---

[Official documentation](https://developer.android.com/privacy-and-security/security-key-attestation)

[Official implementation](https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/services/core/java/com/android/server/security/AttestationVerificationPeerDeviceVerifier.java)

[Authorization tags](https://cs.android.com/android/platform/superproject/main/+/main:hardware/interfaces/security/keymint/aidl/android/hardware/security/keymint/Tag.aidl)

[Key attestation extension data schema](https://cs.android.com/android/platform/superproject/main/+/main:hardware/interfaces/security/keymint/aidl/android/hardware/security/keymint/KeyCreationResult.aidl)

[RKP documentation](https://cs.android.com/android/platform/superproject/main/+/main:hardware/interfaces/security/rkp/README.md)

License
-------

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

```

`app/build.gradle`:

```gradle
import com.android.build.api.instrumentation.*
import com.android.build.gradle.internal.tasks.CompileArtProfileTask
import org.jetbrains.kotlin.gradle.dsl.KotlinVersion
import org.objectweb.asm.ClassVisitor
import org.objectweb.asm.commons.ClassRemapper
import org.objectweb.asm.commons.Remapper

plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

def gitCommitCount
try {
    gitCommitCount = providers.exec {
        commandLine("git", "rev-list", "--count", "HEAD")
    }.standardOutput.asText.get().toInteger()
} catch (ignored) {
    gitCommitCount = 1
}

def properties = new Properties()
def local = project.rootProject.file("local.properties")
if (local.exists()) {
    properties.load(local.newDataInputStream())
}

android {
    compileSdk = 35
    buildToolsVersion = '35.0.1'
    namespace = 'io.github.vvb2060.keyattestation'
    defaultConfig {
        minSdk = 24
        targetSdk = 35
        versionCode = gitCommitCount
        versionName = '1.8.4'
        resourceConfigurations += ['en', 'zh-rCN', 'zh-rTW', 'pt-rBR']
        optimization {
            keepRules {
                ignoreFromAllExternalDependencies true
            }
        }
    }

    signingConfigs {
        debug {
            if (properties.getProperty("storeFile") != null) {
                storeFile file(properties.getProperty("storeFile"))
                storePassword properties.getProperty("storePassword")
                keyAlias properties.getProperty("keyAlias")
                keyPassword properties.getProperty("keyPassword")
            }
        }
    }
    buildTypes {
        debug {
            versionNameSuffix '-debug'
        }
        release {
            minifyEnabled true
            shrinkResources true
            vcsInfo.include false
            signingConfig signingConfigs.debug
            proguardFiles 'proguard-rules.pro'
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }
    kotlinOptions {
        jvmTarget = "21"
        options.languageVersion = KotlinVersion.KOTLIN_2_0
        options.progressiveMode = true
    }

    buildFeatures {
        viewBinding = true
        buildConfig = true
        aidl = true
    }

    packagingOptions {
        resources {
            excludes += '**'
        }
    }

    androidResources {
        generateLocaleConfig true
    }

    installation {
        installOptions += ["--user 0"]
    }

    lint.checkReleaseBuilds false
    dependenciesInfo.includeInApk false
}

tasks.withType(CompileArtProfileTask.class).configureEach {
    enabled = false
}

configurations.configureEach {
    exclude group: 'dev.rikka.rikkax.appcompat', module: 'appcompat'
    exclude group: 'org.jetbrains.kotlin', module: 'kotlin-stdlib-jdk7'
    exclude group: 'org.jetbrains.kotlin', module: 'kotlin-stdlib-jdk8'
}

dependencies {
    compileOnly project(':stub')

    implementation 'org.bouncycastle:bcprov-jdk18on:1.80'
    implementation 'com.google.guava:guava:33.4.0-android'
    implementation 'co.nstant.in:cbor:0.9'

    //noinspection GradleDependency
    implementation 'dev.rikka.rikkax.material:material:1.6.6'
    implementation 'dev.rikka.rikkax.html:html-ktx:1.1.2'
    implementation 'dev.rikka.rikkax.recyclerview:recyclerview-adapter:1.3.0'
    implementation 'dev.rikka.rikkax.widget:borderview:1.1.0'
    implementation 'dev.rikka.shizuku:api:13.1.5'

    implementation 'androidx.core:core-ktx:1.15.0'
    implementation 'androidx.appcompat:appcompat:1.7.0'
    implementation 'androidx.activity:activity-ktx:1.10.0'
    implementation 'androidx.fragment:fragment-ktx:1.8.5'
    implementation 'androidx.recyclerview:recyclerview:1.4.0'
    implementation 'androidx.lifecycle:lifecycle-livedata-ktx:2.8.7'
    implementation 'com.google.android.material:material:1.12.0'
}

androidComponents {
    onVariants(selector().all(), {
        instrumentation.transformClassesWith(ClassVisitorFactory.class,
                InstrumentationScope.PROJECT) {}
    })
}

abstract class ClassVisitorFactory implements AsmClassVisitorFactory<InstrumentationParameters.None> {
    ClassVisitor createClassVisitor(ClassContext classContext, ClassVisitor classVisitor) {
        return new ClassRemapper(classVisitor, new Remapper() {
            String map(String name) {
                var index = name.indexOf('$')
                if (index != -1) {
                    return map(name.substring(0, index)) + name.substring(index)
                }
                if (name.endsWith("_rename")) {
                    return name.substring(0, name.length() - 7)
                }
                return name
            }
        })
    }

    boolean isInstrumentable(ClassData classData) {
        return classData.className.startsWith("io.github.vvb2060.keyattestation.keystore.")
    }
}

```

`app/proguard-rules.pro`:

```pro
-allowaccessmodification
-repackageclasses

-keepclassmembers class * implements android.os.Parcelable {
    public static final ** CREATOR;
}

-assumenosideeffects class kotlin.jvm.internal.Intrinsics {
	public static void check*(...);
	public static void throw*(...);
}

-assumenosideeffects class java.util.Objects{
    ** requireNonNull(...);
}

-assumenosideeffects class android.util.Log {
    public static int v(...);
    public static int d(...);
}

-keep class com.google.android.material.theme.MaterialComponentsViewInflater {
    <init>();
}

```

`app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <permission
        android:name="${applicationId}.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION"
        android:protectionLevel="signature"
        tools:node="remove" />

    <uses-permission
        android:name="${applicationId}.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION"
        tools:node="remove" />

    <application
        android:name=".AppApplication"
        android:enableOnBackInvokedCallback="true"
        android:hasFragileUserData="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@drawable/ic_launcher"
        android:theme="@style/AppTheme"
        tools:remove="android:appComponentFactory"
        tools:targetApi="33">
        <activity
            android:name=".home.HomeActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <provider
            android:name="androidx.startup.InitializationProvider"
            android:authorities="${applicationId}.androidx-startup"
            android:exported="false"
            tools:ignore="MissingClass"
            tools:node="remove" />
        <receiver
            android:name="androidx.profileinstaller.ProfileInstallReceiver"
            android:exported="false"
            tools:ignore="MissingClass"
            tools:node="remove" />

        <uses-library
            android:name="samsungkeystoreutils"
            android:required="false" />
    </application>

</manifest>

```

`app/src/main/aidl/android/hardware/security/keymint/DeviceInfo.aidl`:

```aidl
/*
 * Copyright (C) 2021 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.security.keymint;

/**
 * DeviceInfo contains information about the device that's signed by the
 * IRemotelyProvisionedComponent HAL. These values are intended to be checked by the server to
 * verify that the certificate signing request crafted by an IRemotelyProvisionedComponent HAL
 * instance is coming from the expected device based on values initially uploaded during device
 * manufacture in the factory.
 * @hide
 */
parcelable DeviceInfo {
    /**
     * DeviceInfo is a CBOR Map structure described by the following CDDL. DeviceInfo must be
     * ordered according to the Length-First Map Key Ordering specified in RFC 8949,
     * Section 4.2.3. Please note that the ordering presented here groups similar entries
     * semantically, and not in the correct order per RFC 8949, Section 4.2.3.
     *
     * The DeviceInfo has changed across versions 1, 2, and 3 of the HAL. All versions of the
     * DeviceInfo CDDL are described in the DeviceInfoV*.cddl files. Please refer to the CDDL
     * structure version that corresponds to the HAL version you are working with.
     *
     */
    byte[] deviceInfo;
}

```

`app/src/main/aidl/android/hardware/security/keymint/IRemotelyProvisionedComponent.aidl`:

```aidl
/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.security.keymint;

import android.hardware.security.keymint.DeviceInfo;
import android.hardware.security.keymint.MacedPublicKey;
import android.hardware.security.keymint.ProtectedData;
import android.hardware.security.keymint.RpcHardwareInfo;

/**
 * An IRemotelyProvisionedComponent is a secure-side component for which certificates can be
 * remotely provisioned. It provides an interface for generating asymmetric key pairs and then
 * creating a CertificateRequest that contains the generated public keys, plus other information to
 * authenticate the request origin. The CertificateRequest can be sent to a server, which can
 * validate the request and create certificates.
 *
 * This interface does not provide any way to use the generated and certified key pairs. It's
 * intended to be implemented by a HAL service that does other things with keys (e.g. KeyMint).
 *
 * The root of trust for secure provisioning is something called the Device Identifier Composition
 * Engine (DICE) Chain. The DICE Chain is a chain of certificates, represented as COSE_Sign1 objects
 * containing CBOR Web Tokens (CWT) which have descriptions about the stage of firmware being
 * signed, including a COSE_Key representation of that stage's public key.
 *
 * DICE Chain Design
 * =================
 *
 * For a more exhaustive and thorough look at DICE and the implementation used within this protocol,
 * please see: https://pigweed.googlesource.com/open-dice/+/HEAD/docs/specification.md
 *
 * The DICE Chain is designed to mirror the boot stages of a device, and to prove the content and
 * integrity of each firmware image. In a proper DICE Chain, each boot stage hashes its own private
 * key material with the code and any relevant configuration parameters of the next stage to produce
 * a Compound Device Identifier, or CDI, which is used as the secret key material for the next
 * stage. From the CDI, a key pair - CDI_*_Pub and CDI_*_Priv - is derived and certified for the
 * next stage by the current stages CDI_*_Priv. The next stage is then loaded and given its CDI and
 * the DICE certificate chain generated so far in a manner that does not leak the previous stage's
 * CDI_*_Priv or CDI to later boot stages. The final, "leaf" CDI certificate contains a public key,
 * denoted CDI_Leaf_Pub, whose corresponding private key, denoted CDI_Leaf_Priv, is available for
 * use by the IRemotelyProvisionedComponent.
 *
 * The root keypair is generated by immutable code (e.g. ROM), from a Unique Device Secret (UDS).
 * The keypair that is generated from it can be referred to as the UDS_Pub/UDS_Priv keys. After the
 * device-unique secret is used, it must be made unavailable to any later boot stage.
 *
 * In this way, booting the device incrementally builds a certificate chain that (a) identifies and
 * validates the integrity of every stage and (b) contains a set of public keys that correspond to
 * private keys, one known to each stage. Any stage can compute the secrets of all later stages
 * (given the necessary input), but no stage can compute the secret of any preceding stage. Updating
 * the firmware or configuration of any stage changes the key pair of that stage, and of all
 * subsequent stages, and no attacker who compromised the previous version of the updated firmware
 * can know or predict the post-update key pairs. It is recommended and expected that the DICE Chain
 * is constructed using the Open Profile for DICE.
 *
 * When the provisioning server receives a message signed by CDI_Leaf_Priv and containing a DICE
 * chain that chains from UDS_Pub to CDI_Leaf_Pub, it can be certain that (barring vulnerabilities
 * in some boot stage), the CertificateRequest came from the device associated with UDS_Pub, running
 * the specific software identified by the certificates in the chain. If the server has some
 * mechanism for knowing the hash values of compromised stages, it can determine whether signing
 * certificates is appropriate.
 *
 * Degenerate DICE Chains
 * ======================
 *
 * While a proper DICE Chain, as described above, reflects the complete boot sequence from boot ROM
 * to the secure area image of the IRemotelyProvisionedComponent, it's also possible to use a
 * "degenerate" DICE Chain which consists only of a single, self-signed certificate containing the
 * public key of a hardware-bound key pair. This is an appropriate solution for devices which
 * haven't implemented everything necessary to produce a proper DICE Chain, but can derive a unique
 * key pair in the secure area. In this degenerate case, UDS_Pub is the same as CDI_Leaf_Pub.
 *
 * DICE Chain Privacy
 * ==================
 *
 * Because the DICE Chain constitutes an unspoofable, device-unique identifier, special care is
 * taken to prevent its availability to entities who may wish to track devices. Three precautions
 * are taken:
 *
 * 1) The DICE chain is only handled by the native Remote Key Provisioning Daemon (RKPD) service on
 *    the HLOS and is not exposed to apps running on device.
 *
 * 2) The CDI_Leaf_Priv key cannot be used to sign arbitrary data.
 *
 * 3) Backend infrastructure does not correlate UDS_Pub with the certificates signed and sent back
 *    to the device.
 *
 * Versioning
 * ==========
 * Versions 1 and 2 of the schema, as previously defined in DeviceInfo.aidl, diverge in
 * functionality from Version 3. Version 3 removes the need to have testMode in function calls and
 * deprecates the Endpoint Encryption Key (EEK) as well. Vendors implementing Version 1
 * (Android S/12) or Version 2 (Android T/13) do not need to implement generateCertificateRequestV2.
 * Vendors implementing Version 3 (Android U/14) need to implement generateCertificateRequestV2.
 *
 * For better coverage of changes from version to version, please see RKP_CHANGELOG.md in the root
 * of the keymint interface directory.
 *
 * @hide
 */
interface IRemotelyProvisionedComponent {
    const int STATUS_FAILED = 1;
    const int STATUS_INVALID_MAC = 2;
    const int STATUS_PRODUCTION_KEY_IN_TEST_REQUEST = 3; // Versions 1 and 2 Only
    const int STATUS_TEST_KEY_IN_PRODUCTION_REQUEST = 4;
    const int STATUS_INVALID_EEK = 5; // Versions 1 and 2 Only
    const int STATUS_REMOVED = 6;

    /**
     * @return info which contains information about the underlying IRemotelyProvisionedComponent
     *         hardware, such as version number, component name, author name, and supported curve.
     */
    RpcHardwareInfo getHardwareInfo();

    /**
     * generateKeyPair generates a new ECDSA P-256 key pair that can be attested by the remote
     * server.
     *
     * @param in boolean testMode indicates whether the generated key is for testing only. Test keys
     *        are marked (see the definition of PublicKey in the MacedPublicKey structure) to
     *        prevent them from being confused with production keys.
     *
     *        This parameter has been deprecated since version 3 of the HAL and will always be
     *        false. From v3, if this parameter is true, the method must raise a
     *        ServiceSpecificException with an error of code of STATUS_REMOVED.
     *
     * @param out MacedPublicKey macedPublicKey contains the public key of the generated key pair,
     *        MACed so that generateCertificateRequest can easily verify, without the
     *        privateKeyHandle, that the contained public key is for remote certification.
     *
     * @return data representing a handle to the private key. The format is implementation-defined,
     *         but note that specific services may define a required format. KeyMint does.
     */
    byte[] generateEcdsaP256KeyPair(in boolean testMode, out MacedPublicKey macedPublicKey);

    /**
     * This method has been deprecated since version 3 of the HAL. The header is kept around for
     * backwards compatibility purposes. From v3, this method must raise a ServiceSpecificException
     * with an error code of STATUS_REMOVED.
     *
     * For v1 and v2 implementations:
     * generateCertificateRequest creates a certificate request to be sent to the provisioning
     * server.
     *
     * @param in boolean testMode indicates whether the generated certificate request is for testing
     *        only.
     *
     * @param in MacedPublicKey[] keysToSign contains the set of keys to certify. The
     *        IRemotelyProvisionedComponent must validate the MACs on each key.  If any entry in the
     *        array lacks a valid MAC, the method must return STATUS_INVALID_MAC.
     *
     *        If testMode is true, the keysToSign array must contain only keys flagged as test
     *        keys. Otherwise, the method must return STATUS_PRODUCTION_KEY_IN_TEST_REQUEST.
     *
     *        If testMode is false, the keysToSign array must not contain any keys flagged as
     *        test keys. Otherwise, the method must return STATUS_TEST_KEY_IN_PRODUCTION_REQUEST.
     *
     * @param in endpointEncryptionKey contains an X25519 or P-256 public key which will be used to
     *        encrypt the BCC. For flexibility, this is represented as a certificate chain
     *        in the form of a CBOR array of COSE_Sign1 objects, ordered from root to leaf.  An
     *        implementor may also choose to use P256 as an alternative curve for signing and
     *        encryption instead of Curve 25519, as indicated by the supportedEekCurve field in
     *        RpcHardwareInfo; the contents of the EEK chain will match the specified
     *        supportedEekCurve.
     *
     *        - For CURVE_25519 the leaf contains the X25519 agreement key, each other element is an
     *          Ed25519 key signing the next in the chain.
     *
     *        - For CURVE_P256 the leaf contains the P-256 agreement key, each other element is a
     *          P-256 key signing the next in the chain.
     *
     *        In either case, the root is self-signed.
     *
     *        See generateCertificateRequest.cddl for CDDL definitions.
     *
     *        If the contents of endpointEncryptionKey do not match the SignedEek structure above,
     *        the method must return STATUS_INVALID_EEK.
     *
     *        If testMode is true, the method must ignore the length and content of the signatures
     *        in the chain, which implies that it must not attempt to validate the signature.
     *
     *        If testMode is false, the method must validate the chain signatures, and must verify
     *        that the public key in the root certificate is in its pre-configured set of
     *        authorized EEK root keys. If the public key is not in the database, or if signature
     *        verification fails, the method must return STATUS_INVALID_EEK.
     *
     * @param in challenge contains a byte string from the provisioning server that must be signed
     *        by the secure area. See the description of the 'signature' output parameter for
     *        details.
     *
     * @param out DeviceInfo contains the VerifiedDeviceInfo portion of the DeviceInfo array in
     *        CertificateRequest. The structure is described within the DeviceInfo.aidl file.
     *
     * @param out ProtectedData contains the encrypted BCC and the ephemeral MAC key used to
     *        authenticate the keysToSign (see keysToSignMac output argument).
     *
     * @return The MAC of KeysToSign in the CertificateRequest structure. Specifically, it contains:
     *
     *            HMAC-256(EK_mac, .cbor KeysToMacStructure)
     *
     *        Where EK_mac is an ephemeral MAC key, found in ProtectedData (see below).  The MACed
     *        data is the "tag" field of a MacedKeys COSE_Mac0 structure.
     *
     *        See generateCertificateRequest.cddl for CDDL definitions.
     */
    byte[] generateCertificateRequest(in boolean testMode, in MacedPublicKey[] keysToSign,
            in byte[] endpointEncryptionCertChain, in byte[] challenge, out DeviceInfo deviceInfo,
            out ProtectedData protectedData);

    /**
     * generateCertificateRequestV2 creates a certificate signing request to be sent to the
     * provisioning server.
     *
     * @param in MacedPublicKey[] keysToSign contains the set of keys to certify. The
     *        IRemotelyProvisionedComponent must validate the MACs on each key.  If any entry in the
     *        array lacks a valid MAC, the method must return STATUS_INVALID_MAC.  This method must
     *        not accept test keys. If any entry in the array is a test key, the method must return
     *        STATUS_TEST_KEY_IN_PRODUCTION_REQUEST.
     *
     * @param in challenge contains a byte string from the provisioning server which will be
     *        included in the signed data of the CSR structure. Different provisioned backends may
     *        use different semantic data for this field, but the supported sizes must be between 0
     *        and 64 bytes, inclusive.
     *
     * @return a CBOR Certificate Signing Request (Csr) serialized into a byte array.
     *
     *         See generateCertificateRequestV2.cddl for CDDL definitions.
     */
    byte[] generateCertificateRequestV2(in MacedPublicKey[] keysToSign, in byte[] challenge);
}

```

`app/src/main/aidl/android/hardware/security/keymint/MacedPublicKey.aidl`:

```aidl
/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.security.keymint;

/**
 * MacedPublicKey contains a CBOR-encoded public key, MACed by an IRemotelyProvisionedComponent, to
 * prove that the key pair was generated by that component.
 * @hide
 */
parcelable MacedPublicKey {
    /**
     * key is a COSE_Mac0 structure containing the new public key.  It's MACed by a key available
     * only to the secure environment, as proof that the public key was generated by that
     * environment. In CDDL, assuming the contained key is a P-256 public key:
     *
     * See MacedPublicKey.cddl for CDDL definition.
     *
     */
    byte[] macedKey;
}

```

`app/src/main/aidl/android/hardware/security/keymint/ProtectedData.aidl`:

```aidl
/*
 * Copyright (C) 2021 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.security.keymint;

/**
 * NOTE: ProtectedData has been removed as of version 3, but is kept around for backwards
 * compatibility reasons. For versions 1 and 2:
 *
 * ProtectedData contains the encrypted BCC and the ephemeral MAC key used to
 * authenticate the keysToSign (see keysToSignMac output argument of
 * IRemotelyProvisionedComponent.generateCertificateRequest).
 *
 * @hide
 */
parcelable ProtectedData {
    /**
     * ProtectedData is a COSE_Encrypt structure, encrypted with an AES key that is agreed upon
     * using Elliptic-curve Diffie-Hellman. The contents of the structure are specified by the
     * following CDDL [RFC8610].
     *
     * Notes:
     *   - None of the CBOR in ProtectedData uses CBOR tags. If an implementation includes
     *     tags, parsers may reject the data.
     *
     *     ProtectedData = [               ; COSE_Encrypt
     *         protected: bstr .cbor {
     *             1 : 3                   ; Algorithm : AES-GCM 256
     *         },
     *         unprotected: {
     *             5 : bstr .size 12       ; IV
     *         },
     *         ciphertext: bstr,           ; AES-GCM-256(K, .cbor ProtectedDataPayload)
     *                                     ; Where the encryption key 'K' is derived as follows:
     *                                     ; ikm = ECDH(EEK_pub, Ephemeral_priv)
     *                                     ; salt = null
     *                                     ; info = .cbor Context (see below)
     *                                     ; K = HKDF-SHA-256(ikm, salt, info)
     *                                     ; AAD for the encryption is a CBOR-serialized
     *                                     ; Enc_structure (RFC 8152 s5.3) with empty external_aad.
     *         recipients : [
     *             [                       ; COSE_Recipient
     *                 protected : bstr .cbor {
     *                     1 : -25         ; Algorithm : ECDH-ES + HKDF-256
     *                 },
     *                 unprotected : {
     *                     -1 : PubKeyX25519 / PubKeyEcdhP256  ; Ephemeral_pub
     *                     4 : bstr,       ; KID : EEK ID
     *                 },
     *                 ciphertext : nil
     *             ]
     *         ]
     *     ]
     *
     *     ; The COSE_KDF_Context that is used to derive the ProtectedData encryption key with
     *     ; HKDF. See details on use in ProtectedData comments above. The public key data
     *     ; included in the other field of PartyUInfo / PartyVInfo is encoded as:
     *     ;  - a raw 32-byte public key for X25519
     *     ;  - raw coordinate data (x || y) for P-256
     *     Context = [
     *         AlgorithmID : 3             ; AES-GCM 256
     *         PartyUInfo : [
     *             identity : bstr "client"
     *             nonce : bstr .size 0,
     *             other : bstr            ; Ephemeral_pub
     *         ],
     *         PartyVInfo : [
     *             identity : bstr "server",
     *             nonce : bstr .size 0,
     *             other : bstr            ; EEK pubkey
     *         ],
     *         SuppPubInfo : [
     *             256,                    ; Output key length
     *             protected : bstr .size 0
     *         ]
     *     ]
     *
     *     ; The data that is encrypted and included in ProtectedData ciphertext (see above).
     *     ProtectedDataPayload [
     *         SignedMac,
     *         Bcc,
     *         ? AdditionalDKSignatures,
     *     ]
     *
     *     ; AdditionalDKSignatures allows the platform to provide additional certifications
     *     ; for the DK_pub. For example, this could be provided by the hardware vendor, who
     *     ; certifies all of their devices. The SignerName is a free-form string describing
     *     ; who generated the signature.
     *     AdditionalDKSignatures = {
     *         + SignerName => DKCertChain
     *     }
     *
     *     ; SignerName is a string identifier that indicates both the signing authority as
     *     ; well as the format of the DKCertChain
     *     SignerName = tstr
     *
     *     DKCertChain = [
     *         2* X509Certificate       ; Root -> ... -> Leaf. "Root" is the vendor self-signed
     *                                  ; cert, "Leaf" contains DK_pub. There may also be
     *                                  ; intermediate certificates between Root and Leaf.
     *     ]
     *
     *     ; A bstr containing a DER-encoded X.509 certificate (RSA, NIST P-curve, or edDSA)
     *     X509Certificate = bstr
     *
     *     ; The SignedMac, which authenticates the MAC key that is used to authenticate the
     *     ; keysToSign.
     *     SignedMac = [                                ; COSE_Sign1
     *         bstr .cbor {                             ; Protected params
     *             1 : AlgorithmEdDSA / AlgorithmES256, ; Algorithm
     *         },
     *         {},                                      ; Unprotected params
     *         bstr .size 32,                           ; Payload: MAC key
     *         bstr ; PureEd25519(KM_priv, bstr .cbor SignedMac_structure) /
     *              ; ECDSA(KM_priv, bstr .cbor SignedMac_structure)
     *     ]
     *
     *     SignedMac_structure = [                      ;  COSE Sig_structure
     *         "Signature1",
     *         bstr .cbor {                             ; Protected params
     *             1 : AlgorithmEdDSA / AlgorithmES256, ; Algorithm
     *         },
     *         bstr .cbor SignedMacAad,
     *         bstr .size 32                            ; MAC key
     *     ]
     *
     *     SignedMacAad = [
     *         challenge : bstr .size (16..64),   ; Size between 16 - 64
     *                                            ; bytes inclusive
     *         VerifiedDeviceInfo,
     *         tag: bstr                 ; This is the tag from COSE_Mac0 of
     *                                   ; KeysToSign, to tie the key set to
     *                                   ; the signature.
     *     ]
     *
     *     VerifiedDeviceInfo = DeviceInfo  ; See DeviceInfo.aidl
     *
     *     ; The BCC is the boot certificate chain, containing measurements about the device
     *     ; boot chain. The BCC generally follows the Open Profile for DICE specification at
     *     ; https:;pigweed.googlesource.com/open-dice/+/HEAD/docs/specification.md.
     *     ;
     *     ; The first entry in the Bcc is the DK_pub, encoded as a COSE_key. All entries after
     *     ; the first describe a link in the boot chain (e.g. bootloaders: BL1, BL2, ... BLN).
     *     ; Note that there is no BccEntry for DK_pub, only a "bare" COSE_key.
     *     Bcc = [
     *         PubKeyEd25519 / PubKeyECDSA256, ; DK_pub
     *         + BccEntry,                     ; Root -> leaf (KM_pub)
     *     ]
     *
     *     ; This is the signed payload for each entry in the Bcc. Note that the "Configuration
     *     ; Input Values" described by the Open Profile are not used here. Instead, the Bcc
     *     ; defines its own configuration values for the Configuration Descriptor field. See
     *     ; the Open Profile for DICE for more details on the fields. All hashes are SHA256.
     *     BccPayload = {                               ; CWT [RFC8392]
     *         1 : tstr,                                ; Issuer
     *         2 : tstr,                                ; Subject
     *         -4670552 : bstr .cbor PubKeyEd25519 /
     *                    bstr .cbor PubKeyECDSA256,    ; Subject Public Key
     *         -4670553 : bstr                          ; Key Usage
     *
     *         ; NOTE: All of the following fields may be omitted for a "Degenerate BCC", as
     *         ;       described by IRemotelyProvisionedComponent.aidl.
     *         -4670545 : bstr,                         ; Code Hash
     *         ? -4670546 : bstr,                       ; Code Descriptor
     *         ? -4670547 : bstr,                       ; Configuration Hash
     *         -4670548 : bstr .cbor {                  ; Configuration Descriptor
     *             ? -70002 : tstr,                         ; Component name
     *             ? -70003 : int,                          ; Firmware version
     *             ? -70004 : null,                         ; Resettable
     *         },
     *         -4670549 : bstr,                         ; Authority Hash
     *         ? -4670550 : bstr,                       ; Authority Descriptor
     *         -4670551 : bstr,                         ; Mode
     *     }
     *
     *     ; Each entry in the Bcc is a BccPayload signed by the key from the previous entry
     *     ; in the Bcc array.
     *     BccEntry = [                                  ; COSE_Sign1 (untagged)
     *         protected : bstr .cbor {
     *             1 : AlgorithmEdDSA / AlgorithmES256,  ; Algorithm
     *         },
     *         unprotected: {},
     *         payload: bstr .cbor BccPayload,
     *         signature: bstr ; PureEd25519(SigningKey, bstr .cbor BccEntryInput) /
     *                         ; ECDSA(SigningKey, bstr .cbor BccEntryInput)
     *         ; See RFC 8032 for details of how to encode the signature value for Ed25519.
     *     ]
     *
     *     BccEntryInput = [
     *         context: "Signature1",
     *         protected: bstr .cbor {
     *             1 : AlgorithmEdDSA / AlgorithmES256,  ; Algorithm
     *         },
     *         external_aad: bstr .size 0,
     *         payload: bstr .cbor BccPayload
     *     ]
     *
     *     ; The following section defines some types that are reused throughout the above
     *     ; data structures.
     *     PubKeyX25519 = {                 ; COSE_Key
     *          1 : 1,                      ; Key type : Octet Key Pair
     *         -1 : 4,                      ; Curve : X25519
     *         -2 : bstr                    ; Sender X25519 public key, little-endian
     *     }
     *
     *     PubKeyEd25519 = {                ; COSE_Key
     *         1 : 1,                       ; Key type : octet key pair
     *         3 : AlgorithmEdDSA,          ; Algorithm : EdDSA
     *         -1 : 6,                      ; Curve : Ed25519
     *         -2 : bstr                    ; X coordinate, little-endian
     *     }
     *
     *     PubKeyEcdhP256 = {               ; COSE_Key
     *          1 : 2,                      ; Key type : EC2
     *          -1 : 1,                     ; Curve : P256
     *          -2 : bstr                   ; Sender X coordinate, big-endian
     *          -3 : bstr                   ; Sender Y coordinate, big-endian
     *     }
     *
     *     PubKeyECDSA256 = {               ; COSE_Key
     *         1 : 2,                       ; Key type : EC2
     *         3 : AlgorithmES256,          ; Algorithm : ECDSA w/ SHA-256
     *         -1 : 1,                      ; Curve: P256
     *         -2 : bstr,                   ; X coordinate, big-endian
     *         -3 : bstr                    ; Y coordinate, big-endian
     *     }
     *
     *     AlgorithmES256 = -7
     *     AlgorithmEdDSA = -8
     */
    byte[] protectedData;
}

```

`app/src/main/aidl/android/hardware/security/keymint/RpcHardwareInfo.aidl`:

```aidl
/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.security.keymint;

/**
 * RpcHardwareInfo is the hardware information returned by calling RemotelyProvisionedComponent
 * getHardwareInfo()
 * @hide
 */
parcelable RpcHardwareInfo {
    const int CURVE_NONE = 0;
    const int CURVE_P256 = 1;
    const int CURVE_25519 = 2;

    /**
     * Implementation version of the remotely provisioned component hardware. The version provided
     * here must match the version reported in the CsrPayload produced by the HAL interface. This
     * field primarily acts as a convenience for the system components interacting with the HALs.
     */
    int versionNumber;

    /**
     * rpcAuthorName is the name of the author of the IRemotelyProvisionedComponent implementation
     * (organization name, not individual). This name is implementation defined, so it can be used
     * to distinguish between different implementations from the same author.
     */
    String rpcAuthorName;

    /**
     * NOTE: This field is no longer used as of version 3 of the HAL interface. This is because the
     *       Endpoint Encryption Key is no longer used in the provisioning scheme.
     *
     * supportedEekCurve returns an int representing which curve is supported for validating
     * signatures over the Endpoint Encryption Key certificate chain and for using the corresponding
     * signed encryption key in ECDH. Only one curve should be supported, with preference for 25519
     * if it's available. These values are defined as constants above.
     *
     * CURVE_NONE is made the default to help ensure that an implementor doesn't accidentally forget
     * to provide the correct information here, as the VTS tests will check to make certain that
     * a passing implementation does not provide CURVE_NONE.
     */
    int supportedEekCurve = CURVE_NONE;

    /**
     * uniqueId is an opaque identifier for this IRemotelyProvisionedComponent implementation. The
     * client should NOT interpret the content of the identifier in any way. The client can only
     * compare identifiers to determine if two IRemotelyProvisionedComponents share the same
     * implementation. Each IRemotelyProvisionedComponent implementation must have a distinct
     * identifier from all other implementations, and it must be consistent across all devices.
     * It's critical that this identifier not be usable to uniquely identify a specific device.
     *
     * This identifier must be consistent across reboots, as it is used to store and track
     * provisioned keys in a persistent, on-device database.
     *
     * uniqueId may not be empty, and must not be any longer than 32 characters.
     *
     * A recommended construction for this value is "[Vendor] [Component Name] [Major Version]",
     * e.g. "Google Trusty KeyMint 1".
     *
     * This field was added in API version 2.
     *
     */
    String uniqueId;

    /**
     * supportedNumKeysInCsr is the maximum number of keys in a CSR that this implementation can
     * support. This value is implementation defined.
     *
     * From version 3 onwards, supportedNumKeysInCsr must be larger or equal to
     * MIN_SUPPORTED_NUM_KEYS_IN_CSR.
     *
     * The default value was chosen as the value enforced by the VTS test in versions 1 and 2 of
     * this interface.
     */
    const int MIN_SUPPORTED_NUM_KEYS_IN_CSR = 20;
    int supportedNumKeysInCsr = 4;
}

```

`app/src/main/aidl/io/github/vvb2060/keyattestation/keystore/IAndroidKeyStore.aidl`:

```aidl
package io.github.vvb2060.keyattestation.keystore;

import android.hardware.security.keymint.DeviceInfo;
import android.hardware.security.keymint.RpcHardwareInfo;

interface IAndroidKeyStore {
    byte[] getCertificateChain(String alias);
    boolean containsAlias(String alias);
    void deleteAllEntry();
    void importKeyBox(String alias, boolean useStrongBox, in ParcelFileDescriptor pfd);
    byte[] generateKeyPair(String alias, String attestKeyAlias, boolean useStrongBox,
                           boolean includeProps, boolean uniqueIdIncluded, int idFlags,
                           boolean useSak);
    byte[] attestDeviceIds(int idFlags);
    void setRkpHostname(String hostname);
    String getRkpHostname();
    boolean canRemoteProvisioning(boolean useStrongBox);
    RpcHardwareInfo getHardwareInfo(boolean useStrongBox, out DeviceInfo deviceInfo);
    byte[] checkRemoteProvisioning(boolean useStrongBox);
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/AppApplication.kt`:

```kt
package io.github.vvb2060.keyattestation

import android.annotation.SuppressLint
import android.app.Application
import android.content.Context
import android.content.pm.PackageManager
import android.widget.Toast
import androidx.arch.core.executor.ArchTaskExecutor
import io.github.vvb2060.keyattestation.keystore.KeyStoreManager
import org.bouncycastle.jce.provider.BouncyCastleProvider
import rikka.html.text.HtmlCompat
import rikka.material.app.DayNightDelegate
import rikka.sui.Sui
import java.security.Security
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

class AppApplication : Application() {
    companion object {
        const val TAG = "KeyAttestation"
        lateinit var app: AppApplication
        val executor: ExecutorService = Executors.newSingleThreadExecutor()

        @SuppressLint("RestrictedApi")
        fun toast(text: String?) {
            ArchTaskExecutor.getInstance().postToMainThread {
                Toast.makeText(app, text, Toast.LENGTH_LONG).show()
            }
        }
    }

    override fun onCreate() {
        super.onCreate()
        app = this
        DayNightDelegate.setApplicationContext(this)
        DayNightDelegate.setDefaultNightMode(DayNightDelegate.MODE_NIGHT_FOLLOW_SYSTEM)
        HtmlCompat.setContext(this)
        installProvider(this)

        if (Sui.init(BuildConfig.APPLICATION_ID)) {
            KeyStoreManager.requestPermission();
        } else {
            KeyStoreManager.requestBinder(this)
        }
    }

    private fun installProvider(context: Context) {
        if (BuildConfig.DEBUG) {
            Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME)
            Security.insertProviderAt(BouncyCastleProvider(), 1)
        } else runCatching {
            context.packageManager.getApplicationInfo("com.google.android.gms",
                    PackageManager.MATCH_SYSTEM_ONLY)
            val gms = context.createPackageContext("com.google.android.gms",
                    CONTEXT_INCLUDE_CODE or CONTEXT_IGNORE_SECURITY)
            gms.classLoader
                    .loadClass("com.google.android.gms.common.security.ProviderInstallerImpl")
                    .getMethod("insertProvider", Context::class.java)
                    .invoke(null, gms)
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/app/AlertDialogFragment.kt`:

```kt
package io.github.vvb2060.keyattestation.app

import android.app.Dialog
import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.os.Bundle
import android.os.Parcel
import android.os.Parcelable
import android.text.method.LinkMovementMethod
import android.widget.Button
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.fragment.app.DialogFragment
import androidx.fragment.app.FragmentManager

open class AlertDialogFragment : DialogFragment() {

    fun show(fragmentManager: FragmentManager) {
        if (fragmentManager.isStateSaved) return
        show(fragmentManager, javaClass.simpleName)
    }

    open fun onCreateAlertDialogBuilder(context: Context): AlertDialog.Builder {
        return AlertDialog.Builder(context)
    }

    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val context = requireContext()
        val builder = onCreateAlertDialogBuilder(context)
        onBuildAlertDialog(builder, savedInstanceState)
        val dialog = builder.create()
        dialog.setOnShowListener { onShow(dialog) }
        onAlertDialogCreated(dialog, savedInstanceState)
        return dialog
    }

    open fun onBuildAlertDialog(builder: AlertDialog.Builder, savedInstanceState: Bundle?) {
        val args = requireArguments()
        if (args.containsKey(INTERNAL_BUILDER_ARGS)) {
            val dialogBuilder: Builder = args.getParcelable(INTERNAL_BUILDER_ARGS)!!
            builder.setTitle(dialogBuilder.title)
            builder.setMessage(dialogBuilder.message)
            if (dialogBuilder.positiveButtonText != null) {
                builder.setPositiveButton(dialogBuilder.positiveButtonText) { _: DialogInterface?, _: Int -> launchIntent(dialogBuilder.positiveButtonIntent) }
            }
            if (dialogBuilder.negativeButtonText != null) {
                builder.setNegativeButton(dialogBuilder.negativeButtonText) { _: DialogInterface?, _: Int -> launchIntent(dialogBuilder.negativeButtonIntent) }
            }
            if (dialogBuilder.neutralButtonText != null) {
                builder.setNeutralButton(dialogBuilder.neutralButtonText) { _: DialogInterface?, _: Int -> launchIntent(dialogBuilder.neutralButtonIntent) }
            }
        }
    }

    open fun onAlertDialogCreated(dialog: AlertDialog, savedInstanceState: Bundle?) {}

    open fun onShow(dialog: AlertDialog) {
        dialog.findViewById<TextView>(android.R.id.message)?.movementMethod = LinkMovementMethod.getInstance()
    }

    override fun getDialog(): AlertDialog? {
        return super.getDialog() as AlertDialog?
    }

    open fun getButton(whichButton: Int): Button? {
        return dialog?.getButton(whichButton)
    }

    private fun launchIntent(intent: Intent?) {
        if (intent != null) {
            //Do nothing.
        }
    }

    class Builder(private val context: Context?) : Parcelable {

        var title: CharSequence? = null
            private set

        var message: CharSequence? = null
            private set

        var positiveButtonText: CharSequence? = null
            private set

        var negativeButtonText: CharSequence? = null
            private set

        var neutralButtonText: CharSequence? = null
            private set

        var positiveButtonIntent: Intent? = null
            private set

        var negativeButtonIntent: Intent? = null
            private set

        var neutralButtonIntent: Intent? = null
            private set

        private constructor(`in`: Parcel) : this(null) {
            title = `in`.readString()
            message = `in`.readString()
            positiveButtonText = `in`.readString()
            negativeButtonText = `in`.readString()
            neutralButtonText = `in`.readString()
            positiveButtonIntent = `in`.readParcelable(Intent::class.java.classLoader)
            negativeButtonIntent = `in`.readParcelable(Intent::class.java.classLoader)
            neutralButtonIntent = `in`.readParcelable(Intent::class.java.classLoader)
        }

        fun title(title: CharSequence?) = apply { this.title = title }

        fun title(title: Int) = title(context!!.getString(title))

        fun message(message: CharSequence?) = apply { this.message = message }

        fun message(message: Int) = message(context!!.getString(message))

        fun positiveButton(text: CharSequence?, intent: Intent? = null) = apply {
            positiveButtonText = text
            positiveButtonIntent = intent
        }

        fun positiveButton(text: Int, intent: Intent? = null) = positiveButton(context!!.getString(text), intent)

        fun negativeButton(text: CharSequence?, intent: Intent? = null) = apply {
            negativeButtonText = text
            negativeButtonIntent = intent
        }

        fun negativeButton(text: Int, intent: Intent? = null) = negativeButton(context!!.getString(text), intent)

        fun neutralButton(text: CharSequence?, intent: Intent? = null) = apply {
            neutralButtonText = text
            neutralButtonIntent = intent
        }

        fun neutralButton(text: Int, intent: Intent? = null) = neutralButton(context!!.getString(text), intent)

        fun build(): AlertDialogFragment {
            val fragment = AlertDialogFragment()
            val args = Bundle()
            args.putParcelable(INTERNAL_BUILDER_ARGS, this)
            fragment.arguments = args
            return fragment
        }

        override fun describeContents(): Int {
            return 0
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            dest.writeString(title?.toString())
            dest.writeString(message?.toString())
            dest.writeString(positiveButtonText?.toString())
            dest.writeString(negativeButtonText?.toString())
            dest.writeString(neutralButtonText?.toString())
            dest.writeParcelable(positiveButtonIntent, flags)
            dest.writeParcelable(negativeButtonIntent, flags)
            dest.writeParcelable(neutralButtonIntent, flags)
        }

        companion object {

            @JvmField
            val CREATOR: Parcelable.Creator<Builder> = object : Parcelable.Creator<Builder> {
                override fun createFromParcel(`in`: Parcel): Builder {
                    return Builder(`in`)
                }

                override fun newArray(size: Int): Array<Builder?> {
                    return arrayOfNulls(size)
                }
            }
        }
    }

    companion object {
        private val INTERNAL_BUILDER_ARGS = AlertDialogFragment::class.java.name + ".BUILDER_ARGS"
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/app/AppActivity.kt`:

```kt
package io.github.vvb2060.keyattestation.app

import android.content.res.Resources
import android.graphics.Color
import android.os.Build
import rikka.core.res.resolveColor
import rikka.material.app.MaterialActivity

open class AppActivity : MaterialActivity() {

    override fun shouldApplyTranslucentSystemBars(): Boolean {
        return true
    }

    override fun onApplyTranslucentSystemBars() {
        super.onApplyTranslucentSystemBars()

        val window = window
        val theme = theme

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            window?.decorView?.post {
                if (window.decorView.rootWindowInsets?.systemWindowInsetBottom ?: 0 >= Resources.getSystem().displayMetrics.density * 40) {
                    window.navigationBarColor = theme.resolveColor(android.R.attr.navigationBarColor) and 0x00ffffff or -0x20000000
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                        window.isNavigationBarContrastEnforced = false
                    }
                } else {
                    window.navigationBarColor = Color.TRANSPARENT
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                        window.isNavigationBarContrastEnforced = true
                    }
                }
            }
        }
    }
}
```

`app/src/main/java/io/github/vvb2060/keyattestation/app/AppBarActivity.kt`:

```kt
package io.github.vvb2060.keyattestation.app

import android.graphics.Color
import android.os.Bundle
import android.view.View
import android.view.ViewGroup
import android.widget.FrameLayout
import androidx.annotation.LayoutRes
import androidx.appcompat.widget.Toolbar
import io.github.vvb2060.keyattestation.R
import rikka.material.widget.AppBarLayout

abstract class AppBarActivity : AppActivity() {

    private val rootView: ViewGroup by lazy {
        findViewById<ViewGroup>(R.id.root)
    }

    private val toolbarContainer: AppBarLayout by lazy {
        findViewById<AppBarLayout>(R.id.toolbar_container)
    }

    private val toolbar: Toolbar by lazy {
        findViewById<Toolbar>(R.id.toolbar)
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        super.setContentView(getLayoutId())

        setAppBar(toolbarContainer, toolbar)
    }

    @LayoutRes
    open fun getLayoutId(): Int {
        return R.layout.appbar_activity
    }

    override fun setContentView(layoutResID: Int) {
        layoutInflater.inflate(layoutResID, rootView, true)
        rootView.bringChildToFront(toolbarContainer)
    }

    override fun setContentView(view: View?) {
        setContentView(view, FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
    }

    override fun setContentView(view: View?, params: ViewGroup.LayoutParams?) {
        rootView.addView(view, 0, params)
    }

    override fun shouldApplyTranslucentSystemBars(): Boolean {
        return true
    }

    override fun onApplyTranslucentSystemBars() {
        super.onApplyTranslucentSystemBars()
        window?.statusBarColor = Color.TRANSPARENT
    }
}

abstract class AppBarFragmentActivity : AppBarActivity() {

    override fun getLayoutId(): Int {
        return R.layout.appbar_fragment_activity
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/app/AppFragment.kt`:

```kt
package io.github.vvb2060.keyattestation.app

import androidx.fragment.app.Fragment

open class AppFragment : Fragment() {

    val appActivity: AppActivity? get() = activity as AppActivity?

    fun requireAppActivity(): AppActivity {
        return appActivity ?: throw IllegalStateException("Fragment $this not attached to an activity.")
    }
}
```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/Asn1Attestation.java`:

```java
/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import org.bouncycastle.asn1.ASN1Sequence;

import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;

public class Asn1Attestation extends Attestation {
    static final int ATTESTATION_VERSION_INDEX = 0;
    static final int ATTESTATION_SECURITY_LEVEL_INDEX = 1;
    static final int KEYMASTER_VERSION_INDEX = 2;
    static final int KEYMASTER_SECURITY_LEVEL_INDEX = 3;
    static final int ATTESTATION_CHALLENGE_INDEX = 4;
    static final int UNIQUE_ID_INDEX = 5;
    static final int SW_ENFORCED_INDEX = 6;
    static final int TEE_ENFORCED_INDEX = 7;

    int attestationSecurityLevel;

    /**
     * Constructs an {@code Asn1Attestation} object from the provided {@link X509Certificate},
     * extracting the attestation data from the attestation extension.
     *
     * @throws CertificateParsingException if the certificate does not contain a properly-formatted
     *     attestation extension.
     */

    public Asn1Attestation(X509Certificate x509Cert) throws CertificateParsingException {
        super(x509Cert);
        ASN1Sequence seq = getAttestationSequence(x509Cert);

        attestationVersion =
                Asn1Utils.getIntegerFromAsn1(seq.getObjectAt(ATTESTATION_VERSION_INDEX));
        attestationSecurityLevel =
                Asn1Utils.getIntegerFromAsn1(seq.getObjectAt(ATTESTATION_SECURITY_LEVEL_INDEX));
        keymasterVersion = Asn1Utils.getIntegerFromAsn1(seq.getObjectAt(KEYMASTER_VERSION_INDEX));
        keymasterSecurityLevel =
                Asn1Utils.getIntegerFromAsn1(seq.getObjectAt(KEYMASTER_SECURITY_LEVEL_INDEX));

        attestationChallenge =
                Asn1Utils.getByteArrayFromAsn1(seq.getObjectAt(ATTESTATION_CHALLENGE_INDEX));

        uniqueId = Asn1Utils.getByteArrayFromAsn1(seq.getObjectAt(UNIQUE_ID_INDEX));

        softwareEnforced = new AuthorizationList(seq.getObjectAt(SW_ENFORCED_INDEX));
        teeEnforced = new AuthorizationList(seq.getObjectAt(TEE_ENFORCED_INDEX));
    }

    ASN1Sequence getAttestationSequence(X509Certificate x509Cert)
            throws CertificateParsingException {
        byte[] attestationExtensionBytes = x509Cert.getExtensionValue(Attestation.ASN1_OID);
        if (attestationExtensionBytes == null || attestationExtensionBytes.length == 0) {
            throw new CertificateParsingException("Did not find extension with OID " + ASN1_OID);
        }
        return Asn1Utils.getAsn1SequenceFromBytes(attestationExtensionBytes);
    }

    public int getAttestationSecurityLevel() {
        return attestationSecurityLevel;
    }

    public RootOfTrust getRootOfTrust() {
        RootOfTrust tee = teeEnforced.getRootOfTrust();
        if (tee != null) return tee;
        return softwareEnforced.getRootOfTrust();
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/Asn1Utils.java`:

```java
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import com.google.common.collect.ImmutableSet;

import org.bouncycastle.asn1.ASN1Boolean;
import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Enumerated;
import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1PrintableString;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.ASN1Set;
import org.bouncycastle.asn1.DEROctetString;

import java.io.IOException;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.cert.CertificateParsingException;
import java.util.Date;
import java.util.Enumeration;
import java.util.Set;

public class Asn1Utils {

    public static int getIntegerFromAsn1(ASN1Encodable asn1Value)
            throws CertificateParsingException {
        if (asn1Value instanceof ASN1Integer) {
            return bigIntegerToInt(((ASN1Integer) asn1Value).getValue());
        } else if (asn1Value instanceof ASN1Enumerated) {
            return bigIntegerToInt(((ASN1Enumerated) asn1Value).getValue());
        } else {
            throw new CertificateParsingException(
                    "Integer value expected, " + asn1Value.getClass().getName() + " found.");
        }
    }

    public static Long getLongFromAsn1(ASN1Encodable asn1Value) throws CertificateParsingException {
        if (asn1Value instanceof ASN1Integer) {
            return bigIntegerToLong(((ASN1Integer) asn1Value).getValue());
        } else {
            throw new CertificateParsingException(
                    "Integer value expected, " + asn1Value.getClass().getName() + " found.");
        }
    }

    public static byte[] getByteArrayFromAsn1(ASN1Encodable asn1Encodable)
            throws CertificateParsingException {
        if (!(asn1Encodable instanceof DEROctetString derOctectString)) {
            throw new CertificateParsingException("Expected DEROctetString");
        }
        return derOctectString.getOctets();
    }

    public static ASN1Encodable getAsn1EncodableFromBytes(byte[] bytes)
            throws CertificateParsingException {
        try (ASN1InputStream asn1InputStream = new ASN1InputStream(bytes)) {
            return asn1InputStream.readObject();
        } catch (IOException e) {
            throw new CertificateParsingException("Failed to parse Encodable", e);
        }
    }

    public static ASN1Sequence getAsn1SequenceFromBytes(byte[] bytes)
            throws CertificateParsingException {
        try (ASN1InputStream asn1InputStream = new ASN1InputStream(bytes)) {
            return getAsn1SequenceFromStream(asn1InputStream);
        } catch (IOException e) {
            throw new CertificateParsingException("Failed to parse SEQUENCE", e);
        }
    }

    public static ASN1Sequence getAsn1SequenceFromStream(final ASN1InputStream asn1InputStream)
            throws IOException, CertificateParsingException {
        ASN1Primitive asn1Primitive = asn1InputStream.readObject();
        if (!(asn1Primitive instanceof ASN1OctetString)) {
            throw new CertificateParsingException(
                    "Expected octet stream, found " + asn1Primitive.getClass().getName());
        }
        try (ASN1InputStream seqInputStream = new ASN1InputStream(
                ((ASN1OctetString) asn1Primitive).getOctets())) {
            asn1Primitive = seqInputStream.readObject();
            if (!(asn1Primitive instanceof ASN1Sequence)) {
                throw new CertificateParsingException(
                        "Expected sequence, found " + asn1Primitive.getClass().getName());
            }
            return (ASN1Sequence) asn1Primitive;
        }
    }

    public static Set<Integer> getIntegersFromAsn1Set(ASN1Encodable set)
            throws CertificateParsingException {
        if (!(set instanceof ASN1Set)) {
            throw new CertificateParsingException(
                    "Expected set, found " + set.getClass().getName());
        }

        ImmutableSet.Builder<Integer> builder = ImmutableSet.builder();
        for (Enumeration<?> e = ((ASN1Set) set).getObjects(); e.hasMoreElements();) {
            builder.add(getIntegerFromAsn1((ASN1Integer) e.nextElement()));
        }
        return builder.build();
    }

    public static String getStringFromAsn1OctetStreamAssumingUTF8(ASN1Encodable encodable)
            throws CertificateParsingException {
        if (!(encodable instanceof ASN1OctetString octetString)) {
            throw new CertificateParsingException(
                    "Expected octet string, found " + encodable.getClass().getName());
        }

        return new String(octetString.getOctets(), StandardCharsets.UTF_8);
    }

    public static String getStringFromASN1PrintableString(ASN1Encodable encodable)
            throws CertificateParsingException {
        if (!(encodable instanceof ASN1PrintableString printableString)) {
            throw new CertificateParsingException(
                    "Expected printable string, found " + encodable.getClass().getName());
        }
        return printableString.getString();
    }

    public static Date getDateFromAsn1(ASN1Primitive value) throws CertificateParsingException {
        return new Date(getLongFromAsn1(value));
    }

    public static boolean getBooleanFromAsn1(ASN1Encodable value)
            throws CertificateParsingException {
        if (!(value instanceof ASN1Boolean booleanValue)) {
            throw new CertificateParsingException(
                    "Expected boolean, found " + value.getClass().getName());
        }
        if (booleanValue.equals(ASN1Boolean.TRUE)) {
            return true;
        } else if (booleanValue.equals((ASN1Boolean.FALSE))) {
            return false;
        }

        throw new CertificateParsingException(
                "DER-encoded boolean values must contain either 0x00 or 0xFF");
    }

    private static int bigIntegerToInt(BigInteger bigInt) throws CertificateParsingException {
        if (bigInt.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) > 0
                || bigInt.compareTo(BigInteger.ZERO) < 0) {
            throw new CertificateParsingException("INTEGER out of bounds");
        }
        return bigInt.intValue();
    }

    private static long bigIntegerToLong(BigInteger bigInt) throws CertificateParsingException {
        if (bigInt.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0
                || bigInt.compareTo(BigInteger.ZERO) < 0) {
            throw new CertificateParsingException("INTEGER out of bounds");
        }
        return bigInt.longValue();
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/Attestation.java`:

```java
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import android.util.Base64;

import com.google.common.collect.ImmutableSet;
import com.google.common.io.BaseEncoding;

import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.Set;

import co.nstant.in.cbor.CborException;

/**
 * Parses an attestation certificate and provides an easy-to-use interface for examining the
 * contents.
 */
public abstract class Attestation {
    static final String EAT_OID = "1.3.6.1.4.1.11129.2.1.25";
    static final String ASN1_OID = "1.3.6.1.4.1.11129.2.1.17";
    static final String KNOX_OID = "1.3.6.1.4.1.236.11.3.23.7";
    static final String KEY_USAGE_OID = "2.5.29.15"; // Standard key usage extension.

    public static final int KM_SECURITY_LEVEL_SOFTWARE = 0;
    public static final int KM_SECURITY_LEVEL_TRUSTED_ENVIRONMENT = 1;
    public static final int KM_SECURITY_LEVEL_STRONG_BOX = 2;

    int attestationVersion;
    int keymasterVersion;
    int keymasterSecurityLevel;
    byte[] attestationChallenge;
    byte[] uniqueId;
    AuthorizationList softwareEnforced;
    AuthorizationList teeEnforced;
    Set<String> unexpectedExtensionOids;

    /**
     * Constructs an {@code Attestation} object from the provided {@link X509Certificate},
     * extracting the attestation data from the attestation extension.
     *
     * <p>This method ensures that at most one attestation extension is included in the certificate.
     *
     * @throws CertificateParsingException if the certificate does not contain a properly-formatted
     *                                     attestation extension, if it contains multiple attestation extensions, or if the
     *                                     attestation extension can not be parsed.
     */

    public static Attestation loadFromCertificate(X509Certificate x509Cert) throws CertificateParsingException {
        if (x509Cert.getExtensionValue(EAT_OID) == null
                && x509Cert.getExtensionValue(ASN1_OID) == null) {
            throw new CertificateParsingException("No attestation extensions found");
        }
        if (x509Cert.getExtensionValue(EAT_OID) != null) {
            if (x509Cert.getExtensionValue(ASN1_OID) != null) {
                throw new CertificateParsingException("Multiple attestation extensions found");
            }
            try {
                return new EatAttestation(x509Cert);
            } catch (CborException cbe) {
                throw new CertificateParsingException("Unable to parse EAT extension", cbe);
            }
        }
        if (x509Cert.getExtensionValue(KNOX_OID) != null) {
            return new KnoxAttestation(x509Cert);
        }
        return new Asn1Attestation(x509Cert);
    }

    Attestation(X509Certificate x509Cert) {
        unexpectedExtensionOids = retrieveUnexpectedExtensionOids(x509Cert);
    }

    public static String securityLevelToString(int attestationSecurityLevel) {
        return switch (attestationSecurityLevel) {
            case KM_SECURITY_LEVEL_SOFTWARE -> "Software";
            case KM_SECURITY_LEVEL_TRUSTED_ENVIRONMENT -> "TEE";
            case KM_SECURITY_LEVEL_STRONG_BOX -> "StrongBox";
            default -> "Unknown (" + attestationSecurityLevel + ")";
        };
    }

    public static String attestationVersionToString(int version) {
        return switch (version) {
            case 1 -> "Keymaster 2.0";
            case 2 -> "Keymaster 3.0";
            case 3 -> "Keymaster 4.0";
            case 4 -> "Keymaster 4.1";
            case 100 -> "KeyMint 1.0";
            case 200 -> "KeyMint 2.0";
            case 300 -> "KeyMint 3.0";
            case 400 -> "KeyMint 4.0";
            default -> "Unknown (" + version + ")";
        };
    }

    public static String keymasterVersionToString(int version) {
        return switch (version) {
            case 0 -> "Keymaster 0.2 or 0.3";
            case 1 -> "Keymaster 1.0";
            case 2 -> "Keymaster 2.0";
            case 3 -> "Keymaster 3.0";
            case 4 -> "Keymaster 4.0";
            case 41 -> "Keymaster 4.1";
            case 100 -> "KeyMint 1.0";
            case 200 -> "KeyMint 2.0";
            case 300 -> "KeyMint 3.0";
            case 400 -> "KeyMint 4.0";
            default -> "Unknown (" + version + ")";
        };
    }

    public int getAttestationVersion() {
        return attestationVersion;
    }

    public abstract int getAttestationSecurityLevel();

    public abstract RootOfTrust getRootOfTrust();

    // Returns one of the KM_VERSION_* values define above.
    public int getKeymasterVersion() {
        return keymasterVersion;
    }

    public int getKeymasterSecurityLevel() {
        return keymasterSecurityLevel;
    }

    public byte[] getAttestationChallenge() {
        return attestationChallenge;
    }

    public byte[] getUniqueId() {
        return uniqueId;
    }

    public AuthorizationList getSoftwareEnforced() {
        return softwareEnforced;
    }

    public AuthorizationList getTeeEnforced() {
        return teeEnforced;
    }

    public Set<String> getUnexpectedExtensionOids() {
        return unexpectedExtensionOids;
    }

    @Override
    public String toString() {
        StringBuilder s = new StringBuilder();
        s.append("Extension type: " + getClass());
        s.append("\nAttest version: " + attestationVersionToString(attestationVersion));
        s.append("\nAttest security: " + securityLevelToString(getAttestationSecurityLevel()));
        s.append("\nKM version: " + keymasterVersionToString(keymasterVersion));
        s.append("\nKM security: " + securityLevelToString(keymasterSecurityLevel));

        s.append("\nChallenge");
        String stringChallenge =
                attestationChallenge != null ? new String(attestationChallenge) : "";
        if (Arrays.equals(attestationChallenge, stringChallenge.getBytes())) {
            s.append(": [" + stringChallenge + "]");
        } else if (attestationChallenge != null) {
            s.append(" (base64): [" + Base64.encodeToString(attestationChallenge, 0) + "]");
        }
        if (uniqueId != null) {
            s.append("\nUnique ID: [" + BaseEncoding.base16().lowerCase().encode(uniqueId) + "]");
        }

        s.append("\n-- SW enforced --");
        s.append(softwareEnforced);
        s.append("\n-- TEE enforced --");
        s.append(teeEnforced);

        return s.toString();
    }

    Set<String> retrieveUnexpectedExtensionOids(X509Certificate x509Cert) {
        return new ImmutableSet.Builder<String>()
                .addAll(x509Cert.getCriticalExtensionOIDs()
                        .stream()
                        .filter(s -> !KEY_USAGE_OID.equals(s))
                        .iterator())
                .addAll(x509Cert.getNonCriticalExtensionOIDs()
                        .stream()
                        .filter(s -> !ASN1_OID.equals(s) && !EAT_OID.equals(s))
                        .iterator())
                .build();
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/AttestationApplicationId.java`:

```java
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.Signature;

import com.google.common.io.BaseEncoding;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.ASN1Set;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateParsingException;
import java.util.ArrayList;
import java.util.List;

public class AttestationApplicationId implements java.lang.Comparable<AttestationApplicationId> {
    private static final int PACKAGE_INFOS_INDEX = 0;
    private static final int SIGNATURE_DIGESTS_INDEX = 1;

    private final List<AttestationPackageInfo> packageInfos;
    private final List<byte[]> signatureDigests;

    public AttestationApplicationId(Context context)
            throws NoSuchAlgorithmException, NameNotFoundException {
        PackageManager pm = context.getPackageManager();
        int uid = context.getApplicationInfo().uid;
        String[] packageNames = pm.getPackagesForUid(uid);
        if (packageNames == null || packageNames.length == 0) {
            throw new NameNotFoundException("No names found for uid");
        }
        packageInfos = new ArrayList<AttestationPackageInfo>();
        for (String packageName : packageNames) {
            // get the package info for the given package name including
            // the signatures
            PackageInfo packageInfo = pm.getPackageInfo(packageName, 0);
            packageInfos.add(new AttestationPackageInfo(packageName, packageInfo.versionCode));
        }
        // The infos must be sorted, the implementation of Comparable relies on it.
        packageInfos.sort(null);

        // compute the sha256 digests of the signature blobs
        signatureDigests = new ArrayList<byte[]>();
        PackageInfo packageInfo = pm.getPackageInfo(packageNames[0], PackageManager.GET_SIGNATURES);
        for (Signature signature : packageInfo.signatures) {
            MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
            signatureDigests.add(sha256.digest(signature.toByteArray()));
        }
        // The digests must be sorted. the implementation of Comparable relies on it
        signatureDigests.sort(new ByteArrayComparator());
    }

    public AttestationApplicationId(ASN1Encodable asn1Encodable)
            throws CertificateParsingException {
        if (!(asn1Encodable instanceof ASN1Sequence sequence)) {
            throw new CertificateParsingException(
                    "Expected sequence for AttestationApplicationId, found "
                            + asn1Encodable.getClass().getName());
        }

        packageInfos = parseAttestationPackageInfos(sequence.getObjectAt(PACKAGE_INFOS_INDEX));
        // The infos must be sorted, the implementation of Comparable relies on it.
        packageInfos.sort(null);
        signatureDigests = parseSignatures(sequence.getObjectAt(SIGNATURE_DIGESTS_INDEX));
        // The digests must be sorted. the implementation of Comparable relies on it
        signatureDigests.sort(new ByteArrayComparator());
    }

    public List<AttestationPackageInfo> getAttestationPackageInfos() {
        return packageInfos;
    }

    public List<byte[]> getSignatureDigests() {
        return signatureDigests;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        int noOfInfos = packageInfos.size();
        int i = 1;
        for (AttestationPackageInfo info : packageInfos) {
            sb.append("Package info " + i++ + "/" + noOfInfos + ":\n");
            sb.append(info);
            sb.append('\n');
        }
        sb.append('\n');
        i = 1;
        int noOfSigs = signatureDigests.size();
        for (byte[] sig : signatureDigests) {
            sb.append("Certificate sha256 digest " + i++ + "/" + noOfSigs + ":\n");
            sb.append(BaseEncoding.base16().lowerCase().encode(sig));
            sb.append('\n');
        }
        return sb.toString();
    }

    @Override
    public int compareTo(AttestationApplicationId other) {
        int res = Integer.compare(packageInfos.size(), other.packageInfos.size());
        if (res != 0) return res;
        for (int i = 0; i < packageInfos.size(); ++i) {
            res = packageInfos.get(i).compareTo(other.packageInfos.get(i));
            if (res != 0) return res;
        }
        res = Integer.compare(signatureDigests.size(), other.signatureDigests.size());
        if (res != 0) return res;
        ByteArrayComparator cmp = new ByteArrayComparator();
        for (int i = 0; i < signatureDigests.size(); ++i) {
            res = cmp.compare(signatureDigests.get(i), other.signatureDigests.get(i));
            if (res != 0) return res;
        }
        return res;
    }

    @Override
    public boolean equals(Object o) {
        return (o instanceof AttestationApplicationId)
                && (0 == compareTo((AttestationApplicationId) o));
    }

    private List<AttestationPackageInfo> parseAttestationPackageInfos(ASN1Encodable asn1Encodable)
            throws CertificateParsingException {
        if (!(asn1Encodable instanceof ASN1Set set)) {
            throw new CertificateParsingException(
                    "Expected set for AttestationApplicationsInfos, found "
                            + asn1Encodable.getClass().getName());
        }

        List<AttestationPackageInfo> result = new ArrayList<AttestationPackageInfo>();
        for (ASN1Encodable e : set) {
            result.add(new AttestationPackageInfo(e));
        }
        return result;
    }

    private List<byte[]> parseSignatures(ASN1Encodable asn1Encodable)
            throws CertificateParsingException {
        if (!(asn1Encodable instanceof ASN1Set set)) {
            throw new CertificateParsingException("Expected set for Signature digests, found "
                    + asn1Encodable.getClass().getName());
        }

        List<byte[]> result = new ArrayList<byte[]>();

        for (ASN1Encodable e : set) {
            result.add(Asn1Utils.getByteArrayFromAsn1(e));
        }
        return result;
    }

    private static class ByteArrayComparator implements java.util.Comparator<byte[]> {
        @Override
        public int compare(byte[] a, byte[] b) {
            int res = Integer.compare(a.length, b.length);
            if (res != 0) return res;
            for (int i = 0; i < a.length; ++i) {
                res = Byte.compare(a[i], b[i]);
                if (res != 0) return res;
            }
            return res;
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/AttestationPackageInfo.java`:

```java
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Sequence;

import java.security.cert.CertificateParsingException;

public class AttestationPackageInfo implements java.lang.Comparable<AttestationPackageInfo> {
    private static final int PACKAGE_NAME_INDEX = 0;
    private static final int VERSION_INDEX = 1;

    private final String packageName;
    private final long version;

    public AttestationPackageInfo(String packageName, long version) {
        this.packageName = packageName;
        this.version = version;
    }

    public AttestationPackageInfo(ASN1Encodable asn1Encodable) throws CertificateParsingException {
        if (!(asn1Encodable instanceof ASN1Sequence sequence)) {
            throw new CertificateParsingException(
                    "Expected sequence for AttestationPackageInfo, found "
                            + asn1Encodable.getClass().getName());
        }

        packageName = Asn1Utils.getStringFromAsn1OctetStreamAssumingUTF8(
                sequence.getObjectAt(PACKAGE_NAME_INDEX));
        version = Asn1Utils.getLongFromAsn1(sequence.getObjectAt(VERSION_INDEX));
    }

    public String getPackageName() {
        return packageName;
    }

    public long getVersion() {
        return version;
    }

    @Override
    public String toString() {
        return getPackageName() + " (version code " + getVersion() + ")";
    }

    @Override
    public int compareTo(AttestationPackageInfo other) {
        int res = packageName.compareTo(other.packageName);
        if (res != 0) return res;
        res = Long.compare(version, other.version);
        if (res != 0) return res;
        return res;
    }

    @Override
    public boolean equals(Object o) {
        return (o instanceof AttestationPackageInfo)
                && (0 == compareTo((AttestationPackageInfo) o));
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/AuthResult.java`:

```java
package io.github.vvb2060.keyattestation.attestation;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.ASN1TaggedObject;

import java.security.cert.CertificateParsingException;

public class AuthResult {
    private static final int CALLER_AUTH_RESULT = 0;
    private static final int CALLING_PACKAGE = 1;
    private static final int CALLING_PACKAGE_SIGS = 2;
    private static final int CALLING_PACKAGE_AUTH_RESULT = 3;

    private int callerAuthResult = IntegrityStatus.STATUS_NOT_SUPPORT;
    private String callingPackage;
    private String callingPackageSigs;
    private int callingPackageAuthResult = IntegrityStatus.STATUS_NOT_SUPPORT;

    public AuthResult(ASN1Encodable asn1Encodable) throws CertificateParsingException {
        if (!(asn1Encodable instanceof ASN1Sequence sequence)) {
            throw new CertificateParsingException("Expected sequence for caller auth, found "
                    + asn1Encodable.getClass().getName());
        }
        for (var entry : sequence) {
            if (!(entry instanceof ASN1TaggedObject taggedObject)) {
                throw new CertificateParsingException(
                        "Expected tagged object, found " + entry.getClass().getName());
            }
            int tag = taggedObject.getTagNo();
            var value = taggedObject.getBaseObject().toASN1Primitive();
            switch (tag) {
                case CALLER_AUTH_RESULT -> callerAuthResult = Asn1Utils.getIntegerFromAsn1(value);
                case CALLING_PACKAGE ->
                        callingPackage = Asn1Utils.getStringFromASN1PrintableString(value);
                case CALLING_PACKAGE_SIGS ->
                        callingPackageSigs = Asn1Utils.getStringFromASN1PrintableString(value);
                case CALLING_PACKAGE_AUTH_RESULT ->
                        callingPackageAuthResult = Asn1Utils.getIntegerFromAsn1(value);
                default -> throw new CertificateParsingException("invalid tag no: " + tag);
            }
        }
    }

    @Override
    public String toString() {
        return "\nCaller Auth Result: " + IntegrityStatus.statusToString(callerAuthResult) +
                "\nCalling Package: " + callingPackage +
                "\nCalling Package Signatures: " + callingPackageSigs +
                "\nCalling Package Auth Result: " + IntegrityStatus.statusToString(callingPackageAuthResult);
    }

    public static AuthResult parse(ASN1Encodable asn1Encodable) throws CertificateParsingException {
        var auth = new AuthResult(asn1Encodable);
        if (auth.callerAuthResult == IntegrityStatus.STATUS_NOT_SUPPORT &&
                auth.callingPackage == null &&
                auth.callingPackageSigs == null &&
                auth.callingPackageAuthResult == IntegrityStatus.STATUS_NOT_SUPPORT) {
            return null;
        }
        return auth;
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/AuthorizationList.java`:

```java
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import static com.google.common.base.Functions.forMap;
import static com.google.common.collect.Collections2.transform;

import android.security.keystore.KeyProperties;
import android.util.Log;

import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.io.BaseEncoding;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.ASN1TaggedObject;

import java.security.cert.CertificateParsingException;
import java.text.DateFormat;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Set;

import co.nstant.in.cbor.model.DataItem;
import co.nstant.in.cbor.model.Number;
import io.github.vvb2060.keyattestation.AppApplication;

public class AuthorizationList {
    // Algorithm values.
    public static final int KM_ALGORITHM_RSA = 1;
    public static final int KM_ALGORITHM_EC = 3;
    public static final int KM_ALGORITHM_AES = 32;
    public static final int KM_ALGORITHM_3DES = 33;
    public static final int KM_ALGORITHM_HMAC = 128;

    // EC Curves
    public static final int KM_EC_CURVE_P224 = 0;
    public static final int KM_EC_CURVE_P256 = 1;
    public static final int KM_EC_CURVE_P384 = 2;
    public static final int KM_EC_CURVE_P521 = 3;
    public static final int KM_EC_CURVE_25519 = 4;

    // Padding modes.
    public static final int KM_PAD_NONE = 1;
    public static final int KM_PAD_RSA_OAEP = 2;
    public static final int KM_PAD_RSA_PSS = 3;
    public static final int KM_PAD_RSA_PKCS1_1_5_ENCRYPT = 4;
    public static final int KM_PAD_RSA_PKCS1_1_5_SIGN = 5;
    public static final int KM_PAD_PKCS7 = 64;

    // Digest modes.
    public static final int KM_DIGEST_NONE = 0;
    public static final int KM_DIGEST_MD5 = 1;
    public static final int KM_DIGEST_SHA1 = 2;
    public static final int KM_DIGEST_SHA_2_224 = 3;
    public static final int KM_DIGEST_SHA_2_256 = 4;
    public static final int KM_DIGEST_SHA_2_384 = 5;
    public static final int KM_DIGEST_SHA_2_512 = 6;

    // Key origins.
    public static final int KM_ORIGIN_GENERATED = 0;
    public static final int KM_ORIGIN_DERIVED = 1;
    public static final int KM_ORIGIN_IMPORTED = 2;
    public static final int KM_ORIGIN_UNKNOWN = 3;
    public static final int KM_ORIGIN_SECURELY_IMPORTED = 4;

    // Operation Purposes.
    public static final int KM_PURPOSE_ENCRYPT = 0;
    public static final int KM_PURPOSE_DECRYPT = 1;
    public static final int KM_PURPOSE_SIGN = 2;
    public static final int KM_PURPOSE_VERIFY = 3;
    public static final int KM_PURPOSE_WRAP = 5;
    public static final int KM_PURPOSE_AGREE_KEY = 6;
    public static final int KM_PURPOSE_ATTEST_KEY = 7;

    // User authenticators.
    public static final int HW_AUTH_PASSWORD = 1 << 0;
    public static final int HW_AUTH_BIOMETRIC = 1 << 1;

    // Keymaster tag classes
    public static final int KM_ENUM = 1 << 28;
    public static final int KM_ENUM_REP = 2 << 28;
    public static final int KM_UINT = 3 << 28;
    public static final int KM_UINT_REP = 4 << 28;
    public static final int KM_ULONG = 5 << 28;
    public static final int KM_DATE = 6 << 28;
    public static final int KM_BOOL = 7 << 28;
    public static final int KM_BYTES = 9 << 28;
    public static final int KM_ULONG_REP = 10 << 28;

    // Tag class removal mask
    public static final int KEYMASTER_TAG_TYPE_MASK = 0x0FFFFFFF;

    // Keymaster tags
    public static final int KM_TAG_PURPOSE = KM_ENUM_REP | 1;
    public static final int KM_TAG_ALGORITHM = KM_ENUM | 2;
    public static final int KM_TAG_KEY_SIZE = KM_UINT | 3;
    public static final int KM_TAG_BLOCK_MODE = KM_ENUM_REP | 4;
    public static final int KM_TAG_DIGEST = KM_ENUM_REP | 5;
    public static final int KM_TAG_PADDING = KM_ENUM_REP | 6;
    public static final int KM_TAG_CALLER_NONCE = KM_BOOL | 7;
    public static final int KM_TAG_MIN_MAC_LENGTH = KM_UINT | 8;
    public static final int KM_TAG_KDF = KM_ENUM_REP | 9;
    public static final int KM_TAG_EC_CURVE = KM_ENUM | 10;
    public static final int KM_TAG_RSA_PUBLIC_EXPONENT = KM_ULONG | 200;
    public static final int KM_TAG_RSA_OAEP_MGF_DIGEST = KM_ENUM_REP | 203;
    public static final int KM_TAG_ROLLBACK_RESISTANCE = KM_BOOL | 303;
    public static final int KM_TAG_EARLY_BOOT_ONLY = KM_BOOL | 305;
    public static final int KM_TAG_ACTIVE_DATETIME = KM_DATE | 400;
    public static final int KM_TAG_ORIGINATION_EXPIRE_DATETIME = KM_DATE | 401;
    public static final int KM_TAG_USAGE_EXPIRE_DATETIME = KM_DATE | 402;
    public static final int KM_TAG_USAGE_COUNT_LIMIT = KM_UINT | 405;
    public static final int KM_TAG_NO_AUTH_REQUIRED = KM_BOOL | 503;
    public static final int KM_TAG_USER_AUTH_TYPE = KM_ENUM | 504;
    public static final int KM_TAG_AUTH_TIMEOUT = KM_UINT | 505;
    public static final int KM_TAG_ALLOW_WHILE_ON_BODY = KM_BOOL | 506;
    public static final int KM_TAG_TRUSTED_USER_PRESENCE_REQUIRED = KM_BOOL | 507;
    public static final int KM_TAG_TRUSTED_CONFIRMATION_REQUIRED = KM_BOOL | 508;
    public static final int KM_TAG_UNLOCKED_DEVICE_REQUIRED = KM_BOOL | 509;
    public static final int KM_TAG_ALL_APPLICATIONS = KM_BOOL | 600;
    public static final int KM_TAG_APPLICATION_ID = KM_BYTES | 601;
    public static final int KM_TAG_CREATION_DATETIME = KM_DATE | 701;
    public static final int KM_TAG_ORIGIN = KM_ENUM | 702;
    public static final int KM_TAG_ROLLBACK_RESISTANT = KM_BOOL | 703;
    public static final int KM_TAG_ROOT_OF_TRUST = KM_BYTES | 704;
    public static final int KM_TAG_OS_VERSION = KM_UINT | 705;
    public static final int KM_TAG_OS_PATCHLEVEL = KM_UINT | 706;
    public static final int KM_TAG_ATTESTATION_APPLICATION_ID = KM_BYTES | 709;
    public static final int KM_TAG_ATTESTATION_ID_BRAND = KM_BYTES | 710;
    public static final int KM_TAG_ATTESTATION_ID_DEVICE = KM_BYTES | 711;
    public static final int KM_TAG_ATTESTATION_ID_PRODUCT = KM_BYTES | 712;
    public static final int KM_TAG_ATTESTATION_ID_SERIAL = KM_BYTES | 713;
    public static final int KM_TAG_ATTESTATION_ID_IMEI = KM_BYTES | 714;
    public static final int KM_TAG_ATTESTATION_ID_MEID = KM_BYTES | 715;
    public static final int KM_TAG_ATTESTATION_ID_MANUFACTURER = KM_BYTES | 716;
    public static final int KM_TAG_ATTESTATION_ID_MODEL = KM_BYTES | 717;
    public static final int KM_TAG_VENDOR_PATCHLEVEL = KM_UINT | 718;
    public static final int KM_TAG_BOOT_PATCHLEVEL = KM_UINT | 719;
    public static final int KM_TAG_DEVICE_UNIQUE_ATTESTATION = KM_BOOL | 720;
    public static final int KM_TAG_IDENTITY_CREDENTIAL_KEY = KM_BOOL | 721;
    public static final int KM_TAG_ATTESTATION_ID_SECOND_IMEI = KM_BYTES | 723;
	public static final int KM_TAG_MODULE_HASH = KM_BYTES | 724;

    // Map for converting padding values to strings
    private static final ImmutableMap<Integer, String> paddingMap = ImmutableMap
            .<Integer, String>builder()
            .put(KM_PAD_NONE, KeyProperties.ENCRYPTION_PADDING_NONE)
            .put(KM_PAD_RSA_OAEP, KeyProperties.ENCRYPTION_PADDING_RSA_OAEP)
            .put(KM_PAD_RSA_PSS, KeyProperties.SIGNATURE_PADDING_RSA_PSS)
            .put(KM_PAD_RSA_PKCS1_1_5_ENCRYPT, KeyProperties.ENCRYPTION_PADDING_RSA_PKCS1)
            .put(KM_PAD_RSA_PKCS1_1_5_SIGN, KeyProperties.SIGNATURE_PADDING_RSA_PKCS1)
            .put(KM_PAD_PKCS7, KeyProperties.ENCRYPTION_PADDING_PKCS7)
            .build();

    // Map for converting digest values to strings
    private static final ImmutableMap<Integer, String> digestMap = ImmutableMap
            .<Integer, String>builder()
            .put(KM_DIGEST_NONE, KeyProperties.DIGEST_NONE)
            .put(KM_DIGEST_MD5, KeyProperties.DIGEST_MD5)
            .put(KM_DIGEST_SHA1, KeyProperties.DIGEST_SHA1)
            .put(KM_DIGEST_SHA_2_224, KeyProperties.DIGEST_SHA224)
            .put(KM_DIGEST_SHA_2_256, KeyProperties.DIGEST_SHA256)
            .put(KM_DIGEST_SHA_2_384, KeyProperties.DIGEST_SHA384)
            .put(KM_DIGEST_SHA_2_512, KeyProperties.DIGEST_SHA512)
            .build();

    // Map for converting purpose values to strings
    private static final ImmutableMap<Integer, String> purposeMap = ImmutableMap
            .<Integer, String>builder()
            .put(KM_PURPOSE_DECRYPT, "DECRYPT")
            .put(KM_PURPOSE_ENCRYPT, "ENCRYPT")
            .put(KM_PURPOSE_SIGN, "SIGN")
            .put(KM_PURPOSE_VERIFY, "VERIFY")
            .put(KM_PURPOSE_WRAP, "WRAP")
            .put(KM_PURPOSE_AGREE_KEY, "AGREE KEY")
            .put(KM_PURPOSE_ATTEST_KEY, "ATTEST KEY")
            .build();

    private Integer securityLevel;
    private Set<Integer> purposes;
    private Integer algorithm;
    private Integer keySize;
    private Set<Integer> digests;
    private Set<Integer> paddingModes;
    private Integer ecCurve;
    private Long rsaPublicExponent;
    private Set<Integer> mgfDigests;
    private Boolean rollbackResistance;
    private Boolean earlyBootOnly;
    private Date activeDateTime;
    private Date originationExpireDateTime;
    private Date usageExpireDateTime;
    private Integer usageCountLimit;
    private Boolean noAuthRequired;
    private Integer userAuthType;
    private Integer authTimeout;
    private Boolean allowWhileOnBody;
    private Boolean trustedUserPresenceReq;
    private Boolean trustedConfirmationReq;
    private Boolean unlockedDeviceReq;
    private Boolean allApplications;
    private String applicationId;
    private Date creationDateTime;
    private Integer origin;
    private Boolean rollbackResistant;
    private RootOfTrust rootOfTrust;
    private Integer osVersion;
    private Integer osPatchLevel;
    private AttestationApplicationId attestationApplicationId;
    private String brand;
    private String device;
    private String product;
    private String serialNumber;
    private String imei;
    private String meid;
    private String manufacturer;
    private String model;
    private Integer vendorPatchLevel;
    private Integer bootPatchLevel;
    private Boolean deviceUniqueAttestation;
    private Boolean identityCredentialKey;
    private String secondImei;
	private byte[] moduleHash;

    public AuthorizationList(ASN1Encodable asn1Encodable) throws CertificateParsingException {
        if (!(asn1Encodable instanceof ASN1Sequence sequence)) {
            throw new CertificateParsingException("Expected sequence for authorization list, found "
                    + asn1Encodable.getClass().getName());
        }
        for (var entry : sequence) {
            if (!(entry instanceof ASN1TaggedObject taggedObject)) {
                throw new CertificateParsingException(
                        "Expected tagged object, found " + entry.getClass().getName());
            }
            int tag = taggedObject.getTagNo();
            var value = taggedObject.getBaseObject().toASN1Primitive();
            Log.v(AppApplication.TAG, "Parsing tag: [" + tag + "], value: [" + value + "]");
            switch (tag) {
                default:
                    throw new CertificateParsingException("Unknown tag " + tag + " found");

                case KM_TAG_PURPOSE & KEYMASTER_TAG_TYPE_MASK:
                    purposes = Asn1Utils.getIntegersFromAsn1Set(value);
                    break;
                case KM_TAG_ALGORITHM & KEYMASTER_TAG_TYPE_MASK:
                    algorithm = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_KEY_SIZE & KEYMASTER_TAG_TYPE_MASK:
                    keySize = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_DIGEST & KEYMASTER_TAG_TYPE_MASK:
                    digests = Asn1Utils.getIntegersFromAsn1Set(value);
                    break;
                case KM_TAG_PADDING & KEYMASTER_TAG_TYPE_MASK:
                    paddingModes = Asn1Utils.getIntegersFromAsn1Set(value);
                    break;
                case KM_TAG_EC_CURVE & KEYMASTER_TAG_TYPE_MASK:
                    ecCurve = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_RSA_PUBLIC_EXPONENT & KEYMASTER_TAG_TYPE_MASK:
                    rsaPublicExponent = Asn1Utils.getLongFromAsn1(value);
                    break;
                case KM_TAG_RSA_OAEP_MGF_DIGEST & KEYMASTER_TAG_TYPE_MASK:
                    mgfDigests = Asn1Utils.getIntegersFromAsn1Set(value);
                    break;
                case KM_TAG_ROLLBACK_RESISTANCE & KEYMASTER_TAG_TYPE_MASK:
                    rollbackResistance = true;
                    break;
                case KM_TAG_EARLY_BOOT_ONLY & KEYMASTER_TAG_TYPE_MASK:
                    earlyBootOnly = true;
                    break;
                case KM_TAG_ACTIVE_DATETIME & KEYMASTER_TAG_TYPE_MASK:
                    activeDateTime = Asn1Utils.getDateFromAsn1(value);
                    break;
                case KM_TAG_ORIGINATION_EXPIRE_DATETIME & KEYMASTER_TAG_TYPE_MASK:
                    originationExpireDateTime = Asn1Utils.getDateFromAsn1(value);
                    break;
                case KM_TAG_USAGE_EXPIRE_DATETIME & KEYMASTER_TAG_TYPE_MASK:
                    usageExpireDateTime = Asn1Utils.getDateFromAsn1(value);
                    break;
                case KM_TAG_USAGE_COUNT_LIMIT & KEYMASTER_TAG_TYPE_MASK:
                    usageCountLimit = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_NO_AUTH_REQUIRED & KEYMASTER_TAG_TYPE_MASK:
                    noAuthRequired = true;
                    break;
                case KM_TAG_USER_AUTH_TYPE & KEYMASTER_TAG_TYPE_MASK:
                    userAuthType = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_AUTH_TIMEOUT & KEYMASTER_TAG_TYPE_MASK:
                    authTimeout = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_ALLOW_WHILE_ON_BODY & KEYMASTER_TAG_TYPE_MASK:
                    allowWhileOnBody = true;
                    break;
                case KM_TAG_TRUSTED_USER_PRESENCE_REQUIRED & KEYMASTER_TAG_TYPE_MASK:
                    trustedUserPresenceReq = true;
                    break;
                case KM_TAG_TRUSTED_CONFIRMATION_REQUIRED & KEYMASTER_TAG_TYPE_MASK:
                    trustedConfirmationReq = true;
                    break;
                case KM_TAG_UNLOCKED_DEVICE_REQUIRED & KEYMASTER_TAG_TYPE_MASK:
                    unlockedDeviceReq = true;
                    break;
                case KM_TAG_ALL_APPLICATIONS & KEYMASTER_TAG_TYPE_MASK:
                    allApplications = true;
                    break;
                case KM_TAG_APPLICATION_ID & KEYMASTER_TAG_TYPE_MASK:
                    applicationId = Asn1Utils.getStringFromAsn1OctetStreamAssumingUTF8(value);
                    break;
                case KM_TAG_CREATION_DATETIME & KEYMASTER_TAG_TYPE_MASK:
                    creationDateTime = Asn1Utils.getDateFromAsn1(value);
                    break;
                case KM_TAG_ORIGIN & KEYMASTER_TAG_TYPE_MASK:
                    origin = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_ROLLBACK_RESISTANT & KEYMASTER_TAG_TYPE_MASK:
                    rollbackResistant = true;
                    break;
                case KM_TAG_ROOT_OF_TRUST & KEYMASTER_TAG_TYPE_MASK:
                    rootOfTrust = new RootOfTrust(value);
                    break;
                case KM_TAG_OS_VERSION & KEYMASTER_TAG_TYPE_MASK:
                    osVersion = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_OS_PATCHLEVEL & KEYMASTER_TAG_TYPE_MASK:
                    osPatchLevel = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_ATTESTATION_APPLICATION_ID & KEYMASTER_TAG_TYPE_MASK:
                    attestationApplicationId = new AttestationApplicationId(Asn1Utils
                            .getAsn1EncodableFromBytes(Asn1Utils.getByteArrayFromAsn1(value)));
                    break;
                case KM_TAG_ATTESTATION_ID_BRAND & KEYMASTER_TAG_TYPE_MASK:
                    brand = Asn1Utils.getStringFromAsn1OctetStreamAssumingUTF8(value);
                    break;
                case KM_TAG_ATTESTATION_ID_DEVICE & KEYMASTER_TAG_TYPE_MASK:
                    device = Asn1Utils.getStringFromAsn1OctetStreamAssumingUTF8(value);
                    break;
                case KM_TAG_ATTESTATION_ID_PRODUCT & KEYMASTER_TAG_TYPE_MASK:
                    product = Asn1Utils.getStringFromAsn1OctetStreamAssumingUTF8(value);
                    break;
                case KM_TAG_ATTESTATION_ID_SERIAL & KEYMASTER_TAG_TYPE_MASK:
                    serialNumber = Asn1Utils.getStringFromAsn1OctetStreamAssumingUTF8(value);
                    break;
                case KM_TAG_ATTESTATION_ID_IMEI & KEYMASTER_TAG_TYPE_MASK:
                    imei = Asn1Utils.getStringFromAsn1OctetStreamAssumingUTF8(value);
                    break;
                case KM_TAG_ATTESTATION_ID_MEID & KEYMASTER_TAG_TYPE_MASK:
                    meid = Asn1Utils.getStringFromAsn1OctetStreamAssumingUTF8(value);
                    break;
                case KM_TAG_ATTESTATION_ID_MANUFACTURER & KEYMASTER_TAG_TYPE_MASK:
                    manufacturer = Asn1Utils.getStringFromAsn1OctetStreamAssumingUTF8(value);
                    break;
                case KM_TAG_ATTESTATION_ID_MODEL & KEYMASTER_TAG_TYPE_MASK:
                    model = Asn1Utils.getStringFromAsn1OctetStreamAssumingUTF8(value);
                    break;
                case KM_TAG_VENDOR_PATCHLEVEL & KEYMASTER_TAG_TYPE_MASK:
                    vendorPatchLevel = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_BOOT_PATCHLEVEL & KEYMASTER_TAG_TYPE_MASK:
                    bootPatchLevel = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_DEVICE_UNIQUE_ATTESTATION & KEYMASTER_TAG_TYPE_MASK:
                    deviceUniqueAttestation = true;
                    break;
                case KM_TAG_IDENTITY_CREDENTIAL_KEY & KEYMASTER_TAG_TYPE_MASK:
                    identityCredentialKey = true;
                    break;
                case KM_TAG_ATTESTATION_ID_SECOND_IMEI & KEYMASTER_TAG_TYPE_MASK:
                    secondImei = Asn1Utils.getStringFromAsn1OctetStreamAssumingUTF8(value);
                    break;
                case KM_TAG_MODULE_HASH & KEYMASTER_TAG_TYPE_MASK:
                    moduleHash = Asn1Utils.getByteArrayFromAsn1(value);
                    break;
            }
        }

    }

    public AuthorizationList(co.nstant.in.cbor.model.Map submodMap)
            throws CertificateParsingException {
        for (DataItem key : submodMap.getKeys()) {
            int keyInt = ((Number) key).getValue().intValue();
            switch (keyInt) {
                default:
                    throw new CertificateParsingException("Unknown EAT tag: " + key);

                case EatClaim.SECURITY_LEVEL:
                    securityLevel = EatAttestation.eatSecurityLevelToKeymintSecurityLevel(
                            CborUtils.getInt(submodMap, key));
                    break;
                case EatClaim.PURPOSE:
                    purposes = CborUtils.getIntSet(submodMap, key);
                    break;
                case EatClaim.ALGORITHM:
                    algorithm = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.KEY_SIZE:
                    keySize = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.DIGEST:
                    digests = CborUtils.getIntSet(submodMap, key);
                    break;
                case EatClaim.PADDING:
                    paddingModes = CborUtils.getIntSet(submodMap, key);
                    break;
                case EatClaim.RSA_PUBLIC_EXPONENT:
                    rsaPublicExponent = CborUtils.getLong(submodMap, key);
                    break;
                case EatClaim.RSA_OAEP_MGF_DIGEST:
                    mgfDigests = CborUtils.getIntSet(submodMap, key);
                    break;
                case EatClaim.NO_AUTH_REQUIRED:
                    noAuthRequired = true;
                    break;
                case EatClaim.IAT:
                    creationDateTime = CborUtils.getDate(submodMap, key);
                    break;
                case EatClaim.ORIGIN:
                    origin = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.OS_VERSION:
                    osVersion = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.OS_PATCHLEVEL:
                    osPatchLevel = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.VENDOR_PATCHLEVEL:
                    vendorPatchLevel = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.BOOT_PATCHLEVEL:
                    bootPatchLevel = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.ACTIVE_DATETIME:
                    activeDateTime = CborUtils.getDate(submodMap, key);
                    break;
                case EatClaim.ORIGINATION_EXPIRE_DATETIME:
                    originationExpireDateTime = CborUtils.getDate(submodMap, key);
                    break;
                case EatClaim.USAGE_EXPIRE_DATETIME:
                    usageExpireDateTime = CborUtils.getDate(submodMap, key);
                    break;
                case EatClaim.ROLLBACK_RESISTANT:
                    rollbackResistant = true;
                    break;
                case EatClaim.ROLLBACK_RESISTANCE:
                    rollbackResistance = true;
                    break;
                case EatClaim.AUTH_TIMEOUT:
                    authTimeout = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.ALLOW_WHILE_ON_BODY:
                    allowWhileOnBody = true;
                    break;
                case EatClaim.EC_CURVE:
                    ecCurve = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.USER_AUTH_TYPE:
                    userAuthType = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.ATTESTATION_APPLICATION_ID:
                    // TODO: The attestation application ID is currently still encoded as an ASN.1
                    // structure. Parse a CBOR structure when it's available instead.
                    attestationApplicationId = new AttestationApplicationId(
                            Asn1Utils.getAsn1EncodableFromBytes(CborUtils.getBytes(submodMap, key)));
                    break;
                case EatClaim.ATTESTATION_ID_BRAND:
                    brand = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.ATTESTATION_ID_DEVICE:
                    device = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.ATTESTATION_ID_PRODUCT:
                    product = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.ATTESTATION_ID_SERIAL:
                    serialNumber = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.UEID:
                    // TODO: Parse depending on encoding chosen in attestation_record.cpp.
                    imei = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.ATTESTATION_ID_MEID:
                    meid = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.ATTESTATION_ID_MANUFACTURER:
                    manufacturer = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.ATTESTATION_ID_MODEL:
                    model = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.USER_PRESENCE_REQUIRED:
                    trustedUserPresenceReq = CborUtils.getBoolean(submodMap, key);
                    break;
                case EatClaim.TRUSTED_CONFIRMATION_REQUIRED:
                    trustedConfirmationReq = true;
                    break;
                case EatClaim.UNLOCKED_DEVICE_REQUIRED:
                    unlockedDeviceReq = true;
                    break;
                case EatClaim.APPLICATION_ID:
                    applicationId = CborUtils.getString(submodMap, key);
                case EatClaim.EARLY_BOOT_ONLY:
                    earlyBootOnly = true;
                    break;
                case EatClaim.DEVICE_UNIQUE_ATTESTATION:
                    deviceUniqueAttestation = true;
                    break;
            }
        }
    }

    private static String joinStrings(Collection<String> collection) {
        return "[" + Joiner.on(", ").join(collection) + "]";
    }

    public static String formatDate(Date date) {
        return DateFormat.getDateTimeInstance().format(date);
    }

    public static String paddingModesToString(final Set<Integer> paddingModes) {
        return joinStrings(transform(paddingModes, forMap(paddingMap, "Unknown")));
    }

    public static String digestsToString(Set<Integer> digests) {
        return joinStrings(transform(digests, forMap(digestMap, "Unknown")));
    }

    public static String purposesToString(Set<Integer> purposes) {
        return joinStrings(transform(purposes, forMap(purposeMap, "Unknown")));
    }

    public static String algorithmToString(int algorithm) {
        return switch (algorithm) {
            case KM_ALGORITHM_RSA -> KeyProperties.KEY_ALGORITHM_RSA;
            case KM_ALGORITHM_EC -> KeyProperties.KEY_ALGORITHM_EC;
            case KM_ALGORITHM_AES -> KeyProperties.KEY_ALGORITHM_AES;
            case KM_ALGORITHM_3DES -> KeyProperties.KEY_ALGORITHM_3DES;
            case KM_ALGORITHM_HMAC -> "HMAC";
            default -> "Unknown (" + algorithm + ")";
        };
    }

    public static String userAuthTypeToString(int userAuthType) {
        List<String> types = Lists.newArrayList();
        if ((userAuthType & HW_AUTH_BIOMETRIC) != 0)
            types.add("Biometric");
        if ((userAuthType & HW_AUTH_PASSWORD) != 0)
            types.add("Password");
        return joinStrings(types);
    }

    public static String originToString(int origin) {
        return switch (origin) {
            case KM_ORIGIN_GENERATED -> "Generated";
            case KM_ORIGIN_DERIVED -> "Derived";
            case KM_ORIGIN_IMPORTED -> "Imported";
            case KM_ORIGIN_UNKNOWN -> "Unknown (KM0)";
            case KM_ORIGIN_SECURELY_IMPORTED -> "Securely Imported";
            default -> "Unknown (" + origin + ")";
        };
    }

    public static String ecCurveAsString(Integer ecCurve) {
        return switch (ecCurve) {
            case KM_EC_CURVE_P224 -> "secp224r1";
            case KM_EC_CURVE_P256 -> "secp256r1";
            case KM_EC_CURVE_P384 -> "secp384r1";
            case KM_EC_CURVE_P521 -> "secp521r1";
            case KM_EC_CURVE_25519 -> "CURVE_25519";
            default -> "unknown (" + ecCurve + ")";
        };
    }

    public Integer getSecurityLevel() {
        return securityLevel;
    }

    public Set<Integer> getPurposes() {
        return purposes;
    }

    public Integer getAlgorithm() {
        return algorithm;
    }

    public Integer getKeySize() {
        return keySize;
    }

    public Set<Integer> getDigests() {
        return digests;
    }

    public Set<Integer> getPaddingModes() {
        return paddingModes;
    }

    public Integer getEcCurve() {
        return ecCurve;
    }

    public Long getRsaPublicExponent() {
        return rsaPublicExponent;
    }

    public Set<Integer> getMgfDigests() {
        return mgfDigests;
    }

    public Boolean getRollbackResistance() {
        return rollbackResistance;
    }

    public Boolean getEarlyBootOnly() {
        return earlyBootOnly;
    }

    public Date getActiveDateTime() {
        return activeDateTime;
    }

    public Date getOriginationExpireDateTime() {
        return originationExpireDateTime;
    }

    public Date getUsageExpireDateTime() {
        return usageExpireDateTime;
    }

    public Integer getUsageCountLimit() {
        return usageCountLimit;
    }

    public Boolean getNoAuthRequired() {
        return noAuthRequired;
    }

    public Integer getUserAuthType() {
        return userAuthType;
    }

    public Integer getAuthTimeout() {
        return authTimeout;
    }

    public Boolean getAllowWhileOnBody() {
        return allowWhileOnBody;
    }

    public Boolean getTrustedUserPresenceReq() {
        return trustedUserPresenceReq;
    }

    public Boolean getTrustedConfirmationReq() {
        return trustedConfirmationReq;
    }

    public Boolean getUnlockedDeviceReq() {
        return unlockedDeviceReq;
    }

    public Boolean getAllApplications() {
        return allApplications;
    }

    public String getApplicationId() {
        return applicationId;
    }

    public Date getCreationDateTime() {
        return creationDateTime;
    }

    public Integer getOrigin() {
        return origin;
    }

    public Boolean getRollbackResistant() {
        return rollbackResistant;
    }

    public RootOfTrust getRootOfTrust() {
        return rootOfTrust;
    }

    public Integer getOsVersion() {
        return osVersion;
    }

    public Integer getOsPatchLevel() {
        return osPatchLevel;
    }

    public AttestationApplicationId getAttestationApplicationId() {
        return attestationApplicationId;
    }

    public String getBrand() {
        return brand;
    }

    public String getDevice() {
        return device;
    }

    public String getProduct() {
        return product;
    }

    public String getSerialNumber() {
        return serialNumber;
    }

    public String getImei() {
        return imei;
    }

    public String getMeid() {
        return meid;
    }

    public String getManufacturer() {
        return manufacturer;
    }

    public String getModel() {
        return model;
    }

    public Integer getVendorPatchLevel() {
        return vendorPatchLevel;
    }

    public Integer getBootPatchLevel() {
        return bootPatchLevel;
    }

    public Boolean getDeviceUniqueAttestation() {
        return deviceUniqueAttestation;
    }

    public Boolean getIdentityCredentialKey() {
        return identityCredentialKey;
    }

    public String getSecondImei() {
        return secondImei;
    }

    public byte[] getModuleHash() {
        return moduleHash;
    }

    @Override
    public String toString() {
        StringBuilder s = new StringBuilder();

        if (algorithm != null) {
            s.append("\nAlgorithm: ").append(algorithmToString(algorithm));
        }

        if (keySize != null) {
            s.append("\nKeySize: ").append(keySize);
        }

        if (purposes != null && !purposes.isEmpty()) {
            s.append("\nPurposes: ").append(purposesToString(purposes));
        }

        if (digests != null && !digests.isEmpty()) {
            s.append("\nDigests: ").append(digestsToString(digests));
        }

        if (paddingModes != null && !paddingModes.isEmpty()) {
            s.append("\nPadding modes: ").append(paddingModesToString(paddingModes));
        }

        if (ecCurve != null) {
            s.append("\nEC Curve: ").append(ecCurveAsString(ecCurve));
        }

        if (rsaPublicExponent != null) {
            s.append("\nRSA exponent: ").append(rsaPublicExponent);
        }

        if (mgfDigests != null && !mgfDigests.isEmpty()) {
            s.append("\nRsa Oaep Mgf Digest: ").append(digestsToString(mgfDigests));
        }

        if (earlyBootOnly != null) {
            s.append("\nEarly boot only");
        }

        if (activeDateTime != null) {
            s.append("\nActive: ").append(formatDate(activeDateTime));
        }

        if (originationExpireDateTime != null) {
            s.append("\nOrigination expire: ").append(formatDate(originationExpireDateTime));
        }

        if (usageExpireDateTime != null) {
            s.append("\nUsage expire: ").append(formatDate(usageExpireDateTime));
        }

        if (usageCountLimit != null) {
            s.append("\nUsage count limit: ").append(usageCountLimit);
        }

        if (noAuthRequired != null) {
            s.append("\nNo Auth Required");
        }

        if (userAuthType != null) {
            s.append("\nAuth types: ").append(userAuthTypeToString(userAuthType));
        }

        if (authTimeout != null) {
            s.append("\nAuth timeout: ").append(authTimeout);
        }

        if (allowWhileOnBody != null) {
            s.append("\nAllow While On Body");
        }

        if (allApplications != null) {
            s.append("\nAll Applications");
        }

        if (applicationId != null) {
            s.append("\nApplication ID: ").append(applicationId);
        }

        if (creationDateTime != null) {
            s.append("\nCreated: ").append(formatDate(creationDateTime));
        }

        if (origin != null) {
            s.append("\nOrigin: ").append(originToString(origin));
        }

        if (rollbackResistant != null) {
            s.append("\nRollback resistant");
        }

        if (rollbackResistance != null) {
            s.append("\nRollback resistance");
        }

        if (rootOfTrust != null) {
            s.append("\nRoot of Trust:\n");
            s.append(rootOfTrust);
        }

        if (osVersion != null) {
            s.append("\nOS Version: ").append(osVersion);
        }

        if (osPatchLevel != null) {
            s.append("\nOS Patchlevel: ").append(osPatchLevel);
        }

        if (vendorPatchLevel != null) {
            s.append("\nVendor Patchlevel: ").append(vendorPatchLevel);
        }

        if (bootPatchLevel != null) {
            s.append("\nBoot Patchlevel: ").append(bootPatchLevel);
        }

        if (attestationApplicationId != null) {
            s.append("\nAttestation Application Id:\n").append(attestationApplicationId);
        }

        if (trustedUserPresenceReq != null) {
            s.append("\nUser presence required");
        }

        if (trustedConfirmationReq != null) {
            s.append("\nConfirmation required");
        }

        if (unlockedDeviceReq != null) {
            s.append("\nUnlocked Device Required");
        }

        if (deviceUniqueAttestation != null) {
            s.append("\nDevice unique attestation");
        }

        if (identityCredentialKey != null) {
            s.append("\nIdentity Credential Key");
        }

        if (brand != null) {
            s.append("\nBrand: ").append(brand);
        }
        if (device != null) {
            s.append("\nDevice type: ").append(device);
        }
        if (product != null) {
            s.append("\nProduct: ").append(product);
        }
        if (serialNumber != null) {
            s.append("\nSerial: ").append(serialNumber);
        }
        if (imei != null) {
            s.append("\nIMEI: ").append(imei);
        }
        if (secondImei != null) {
            s.append("\nSecond IMEI:").append(secondImei);
        }
        if (meid != null) {
            s.append("\nMEID: ").append(meid);
        }
        if (manufacturer != null) {
            s.append("\nManufacturer: ").append(manufacturer);
        }
        if (model != null) {
            s.append("\nModel: ").append(model);
        }
        if (moduleHash != null) {
            s.append("\nModule Hash: ").append(BaseEncoding.base16().lowerCase().encode(moduleHash));
        }
        return s.toString();
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/CborUtils.java`:

```java
/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import co.nstant.in.cbor.CborDecoder;
import co.nstant.in.cbor.CborEncoder;
import co.nstant.in.cbor.CborException;
import co.nstant.in.cbor.model.Array;
import co.nstant.in.cbor.model.ByteString;
import co.nstant.in.cbor.model.DataItem;
import co.nstant.in.cbor.model.Map;
import co.nstant.in.cbor.model.NegativeInteger;
import co.nstant.in.cbor.model.Number;
import co.nstant.in.cbor.model.SimpleValue;
import co.nstant.in.cbor.model.SimpleValueType;
import co.nstant.in.cbor.model.UnicodeString;
import co.nstant.in.cbor.model.UnsignedInteger;

import java.io.ByteArrayOutputStream;
import java.nio.charset.StandardCharsets;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;


class CborUtils {
    public static Number toNumber(long l) {
        return l >= 0 ? new UnsignedInteger(l) : new NegativeInteger(l);
    }

    public static int getInt(Map map, long index) {
        DataItem item = map.get(CborUtils.toNumber(index));
        return ((Number) item).getValue().intValue();
    }

    public static int getInt(Map map, DataItem index) {
        DataItem item = map.get(index);
        return ((Number) item).getValue().intValue();
    }

    public static long getLong(Map map, DataItem index) {
        DataItem item = map.get(index);
        return ((Number) item).getValue().longValue();
    }

    public static Set<Integer> getIntSet(Map map, DataItem index) {
        Array array = (Array) map.get(index);
        Set<Integer> result = new HashSet<>();
        for (DataItem item : array.getDataItems()) {
            result.add(((Number) item).getValue().intValue());
        }
        return result;
    }

    public static Boolean getBoolean(Map map, DataItem index) {
        SimpleValueType value = ((SimpleValue) map.get(index)).getSimpleValueType();
        if (value != SimpleValueType.TRUE && value != SimpleValueType.FALSE) {
            throw new RuntimeException("Only expecting boolean values for " + index);
        }
        return (value == SimpleValueType.TRUE);
    }

    public static List<Boolean> getBooleanList(Map map, DataItem index) {
        Array array = (Array) map.get(index);
        List<Boolean> result = new ArrayList<>();
        for (DataItem item : array.getDataItems()) {
            SimpleValueType value = ((SimpleValue) item).getSimpleValueType();
            if (value == SimpleValueType.FALSE) {
                result.add(false);
            } else if (value == SimpleValueType.TRUE) {
                result.add(true);
            } else {
                throw new RuntimeException("Map contains more than booleans: " + map);
            }
        }
        return result;
    }

    public static Date getDate(Map map, DataItem index) {
        DataItem item = map.get(index);
        long epochMillis = ((Number) item).getValue().longValue();
        return new Date(epochMillis);
    }

    public static byte[] getBytes(Map map, DataItem index) {
        DataItem item = map.get(index);
        return ((ByteString) item).getBytes();
    }

    public static String getString(Map map, DataItem index) {
        byte[] bytes = getBytes(map, index);
        return new String(bytes, StandardCharsets.UTF_8);
    }

    public static String getUnicodeString(Map map, DataItem index) {
        DataItem item = map.get(index);
        return ((UnicodeString) item).getString();
    }

    public static DataItem decodeCbor(byte[] encodedBytes) throws CborException {
        return CborDecoder.decode(encodedBytes).get(0);
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/CertificateInfo.java`:

```java
package io.github.vvb2060.keyattestation.attestation;

import android.util.Log;

import java.security.GeneralSecurityException;
import java.security.PublicKey;
import java.security.cert.CertificateException;
import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;
import java.util.List;

import io.github.vvb2060.keyattestation.AppApplication;

public class CertificateInfo {
    public static final int CERT_UNKNOWN = 0;
    public static final int CERT_SIGN = 1;
    public static final int CERT_REVOKED = 2;
    public static final int CERT_EXPIRED = 3;
    public static final int CERT_NORMAL = 4;

    private final X509Certificate cert;
    private RootPublicKey.Status issuer = RootPublicKey.Status.UNKNOWN;
    private int status = CERT_UNKNOWN;
    private GeneralSecurityException securityException;
    private Attestation attestation;
    private CertificateParsingException certException;

    private ProvisioningInfo provisioningInfo;

    private CertificateInfo(X509Certificate cert) {
        this.cert = cert;
    }

    public X509Certificate getCert() {
        return cert;
    }

    public RootPublicKey.Status getIssuer() {
        return issuer;
    }

    public int getStatus() {
        return status;
    }

    public GeneralSecurityException getSecurityException() {
        return securityException;
    }

    public Attestation getAttestation() {
        return attestation;
    }

    public CertificateParsingException getCertException() {
        return certException;
    }

    public ProvisioningInfo getProvisioningInfo() {
        return provisioningInfo;
    }

    private void checkIssuer() {
        var publicKey = cert.getPublicKey().getEncoded();
        issuer = RootPublicKey.check(publicKey);
    }

    private void checkStatus(PublicKey parentKey) {
        try {
            status = CERT_SIGN;
            cert.verify(parentKey);
            status = CERT_REVOKED;
            var certStatus = RevocationList.get(cert.getSerialNumber());
            if (certStatus != null) {
                throw new CertificateException("Certificate revocation " + certStatus);
            }
            status = CERT_EXPIRED;
            cert.checkValidity();
            status = CERT_NORMAL;
        } catch (GeneralSecurityException e) {
            Log.e(AppApplication.TAG, "checkStatus", e);
            securityException = e;
        }
    }

    private boolean checkAttestation() {
        boolean terminate;
        try {
            attestation = Attestation.loadFromCertificate(cert);
            // If key purpose included KeyPurpose::SIGN,
            // then it could be used to sign arbitrary data, including any tbsCertificate,
            // and so an attestation produced by the key would have no security properties.
            // If the parent certificate can attest that the key purpose is only KeyPurpose::ATTEST_KEY,
            // then the child certificate can be trusted.
            var purposes = attestation.getTeeEnforced().getPurposes();
            terminate = purposes == null || !purposes.contains(AuthorizationList.KM_PURPOSE_ATTEST_KEY);
        } catch (CertificateParsingException e) {
            certException = e;
            terminate = false;
            provisioningInfo = ProvisioningInfo.get(cert);
        }
        return terminate;
    }

    public static void parse(List<X509Certificate> certs, List<CertificateInfo> infoList) {
        var parent = certs.get(certs.size() - 1);
        for (int i = certs.size() - 1; i >= 0; i--) {
            var parentKey = parent.getPublicKey();
            var info = new CertificateInfo(certs.get(i));
            infoList.add(info);
            info.checkStatus(parentKey);
            if (parent == info.cert) {
                info.checkIssuer();
            } else {
                parent = info.cert;
            }
            if (info.checkAttestation()) {
                break;
            }
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/EatAttestation.java`:

```java
/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import android.util.Log;

import co.nstant.in.cbor.CborDecoder;
import co.nstant.in.cbor.CborException;
import co.nstant.in.cbor.model.DataItem;
import co.nstant.in.cbor.model.Map;
import co.nstant.in.cbor.model.Number;
import co.nstant.in.cbor.model.UnicodeString;

import org.bouncycastle.asn1.ASN1Encodable;

import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.List;

public class EatAttestation extends Attestation {
    static final String TAG = "EatAttestation";
    final Map extension;
    final RootOfTrust rootOfTrust;

    /**
     * Constructs an {@code EatAttestation} object from the provided {@link X509Certificate},
     * extracting the attestation data from the attestation extension.
     *
     * @throws CertificateParsingException if the certificate does not contain a properly-formatted
     *     attestation extension.
     */
    public EatAttestation(X509Certificate x509Cert)
            throws CertificateParsingException, CborException {
        super(x509Cert);
        extension = getEatExtension(x509Cert);

        RootOfTrust.Builder rootOfTrustBuilder = new RootOfTrust.Builder();
        List<Boolean> bootState = null;
        boolean officialBuild = false;

        for (DataItem key : extension.getKeys()) {
            int keyInt = ((Number) key).getValue().intValue();
            switch (keyInt) {
                default:
                    throw new CertificateParsingException(
                            "Unknown EAT tag: " + key + "\n in EAT extension:\n" + this);

                case EatClaim.ATTESTATION_VERSION:
                    attestationVersion = CborUtils.getInt(extension, key);
                    break;
                case EatClaim.KEYMASTER_VERSION:
                    keymasterVersion = CborUtils.getInt(extension, key);
                    break;
                case EatClaim.SECURITY_LEVEL:
                    keymasterSecurityLevel =
                            eatSecurityLevelToKeymintSecurityLevel(
                                    CborUtils.getInt(extension, key));
                    break;
                case EatClaim.SUBMODS:
                    Map submods = (Map) extension.get(key);
                    softwareEnforced =
                            new AuthorizationList(
                                    (Map) submods.get(new UnicodeString(EatClaim.SUBMOD_SOFTWARE)));
                    teeEnforced =
                            new AuthorizationList(
                                    (Map) submods.get(new UnicodeString(EatClaim.SUBMOD_TEE)));
                    break;
                case EatClaim.VERIFIED_BOOT_KEY:
                    rootOfTrustBuilder.setVerifiedBootKey(CborUtils.getBytes(extension, key));
                    break;
                case EatClaim.DEVICE_LOCKED:
                    rootOfTrustBuilder.setDeviceLocked(CborUtils.getBoolean(extension, key));
                    break;
                case EatClaim.BOOT_STATE:
                    bootState = CborUtils.getBooleanList(extension, key);
                    break;
                case EatClaim.OFFICIAL_BUILD:
                    officialBuild = CborUtils.getBoolean(extension, key);
                    break;
                case EatClaim.NONCE:
                    attestationChallenge = CborUtils.getBytes(extension, key);
                    break;
                case EatClaim.CTI:
                    Log.i(TAG, "Got CTI claim: " + Arrays.toString(CborUtils.getBytes(extension, key)));
                    uniqueId = CborUtils.getBytes(extension, key);
                    break;
                case EatClaim.VERIFIED_BOOT_HASH:
                    rootOfTrustBuilder.setVerifiedBootHash(CborUtils.getBytes(extension, key));
                    break;
            }
        }

        if (bootState != null) {
            rootOfTrustBuilder.setVerifiedBootState(
                    eatBootStateTypeToVerifiedBootState(bootState, officialBuild));
        }
        rootOfTrust = rootOfTrustBuilder.build();
    }

    /** Find the submod containing the key information, and return its security level. */
    public int getAttestationSecurityLevel() {
        if (teeEnforced != null && teeEnforced.getAlgorithm() != null) {
            return teeEnforced.getSecurityLevel();
        } else if (softwareEnforced != null && softwareEnforced.getAlgorithm() != null) {
            return softwareEnforced.getSecurityLevel();
        } else {
            return -1;
        }
    }

    public RootOfTrust getRootOfTrust() {
        return rootOfTrust;
    }

    public String toString() {
        return super.toString() + "\nEncoded CBOR: " + extension;
    }

    Map getEatExtension(X509Certificate x509Cert)
            throws CertificateParsingException, CborException {
        byte[] attestationExtensionBytes = x509Cert.getExtensionValue(Attestation.EAT_OID);
        if (attestationExtensionBytes == null || attestationExtensionBytes.length == 0) {
            throw new CertificateParsingException("Did not find extension with OID " + EAT_OID);
        }
        ASN1Encodable asn1 = Asn1Utils.getAsn1EncodableFromBytes(attestationExtensionBytes);
        byte[] cborBytes = Asn1Utils.getByteArrayFromAsn1(asn1);
        return (Map) CborUtils.decodeCbor(cborBytes);
    }

    static int eatSecurityLevelToKeymintSecurityLevel(int eatSecurityLevel) {
        switch (eatSecurityLevel) {
            case EatClaim.SECURITY_LEVEL_UNRESTRICTED:
                return Attestation.KM_SECURITY_LEVEL_SOFTWARE;
            case EatClaim.SECURITY_LEVEL_SECURE_RESTRICTED:
                return Attestation.KM_SECURITY_LEVEL_TRUSTED_ENVIRONMENT;
            case EatClaim.SECURITY_LEVEL_HARDWARE:
                return Attestation.KM_SECURITY_LEVEL_STRONG_BOX;
            default:
                throw new RuntimeException("Invalid EAT security level: " + eatSecurityLevel);
        }
    }

    static int eatBootStateTypeToVerifiedBootState(List<Boolean> bootState, Boolean officialBuild) {
        if (bootState.size() != 5) {
            throw new RuntimeException("Boot state map has unexpected size: " + bootState.size());
        }
        if (bootState.get(4)) {
            throw new RuntimeException("debug-permanent-disable must never be true: " + bootState);
        }
        boolean verifiedOrSelfSigned = bootState.get(0);
        if (verifiedOrSelfSigned != bootState.get(1)
                && verifiedOrSelfSigned != bootState.get(2)
                && verifiedOrSelfSigned != bootState.get(3)) {
            throw new RuntimeException("Unexpected boot state: " + bootState);
        }

        if (officialBuild) {
            if (!verifiedOrSelfSigned) {
                throw new AssertionError("Non-verified official build");
            }
            return RootOfTrust.KM_VERIFIED_BOOT_VERIFIED;
        } else {
            return verifiedOrSelfSigned
                    ? RootOfTrust.KM_VERIFIED_BOOT_SELF_SIGNED
                    : RootOfTrust.KM_VERIFIED_BOOT_UNVERIFIED;
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/EatClaim.java`:

```java
package io.github.vvb2060.keyattestation.attestation;

import static io.github.vvb2060.keyattestation.attestation.AuthorizationList.*;

class EatClaim {
    public static final int IAT = 6;
    public static final int CTI = 7;

    public static final int NONCE = -75008;
    public static final int UEID = -75009;

    public static final int SECURITY_LEVEL = -76002;
    public static final int SECURITY_LEVEL_UNRESTRICTED = 1;
    public static final int SECURITY_LEVEL_SECURE_RESTRICTED = 3;
    public static final int SECURITY_LEVEL_HARDWARE = 4;

    public static final int BOOT_STATE = -76003;
    public static final int SUBMODS = -76000;

    private static final int PRIVATE_BASE = -80000;

    public static final int PURPOSE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_PURPOSE);
    public static final int ALGORITHM = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ALGORITHM);
    public static final int KEY_SIZE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_KEY_SIZE);
    public static final int BLOCK_MODE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_BLOCK_MODE);
    public static final int DIGEST = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_DIGEST);
    public static final int PADDING = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_PADDING);
    public static final int CALLER_NONCE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_CALLER_NONCE);
    public static final int MIN_MAC_LENGTH = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_MIN_MAC_LENGTH);
    public static final int KDF = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_KDF);

    public static final int EC_CURVE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_EC_CURVE);
    public static final int EAT_EC_CURVE_P_224 = 0;
    public static final int EAT_EC_CURVE_P_256 = 1;
    public static final int EAT_EC_CURVE_P_384 = 2;
    public static final int EAT_EC_CURVE_P_521 = 3;

    public static final int RSA_PUBLIC_EXPONENT = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_RSA_PUBLIC_EXPONENT);
    public static final int RSA_OAEP_MGF_DIGEST = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_RSA_OAEP_MGF_DIGEST);
    public static final int ROLLBACK_RESISTANCE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ROLLBACK_RESISTANCE);
    public static final int EARLY_BOOT_ONLY = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_EARLY_BOOT_ONLY);

    public static final int ACTIVE_DATETIME = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ACTIVE_DATETIME);
    public static final int ORIGINATION_EXPIRE_DATETIME = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ORIGINATION_EXPIRE_DATETIME);
    public static final int USAGE_EXPIRE_DATETIME = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_USAGE_EXPIRE_DATETIME);

    public static final int NO_AUTH_REQUIRED = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_NO_AUTH_REQUIRED);
    public static final int USER_AUTH_TYPE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_USER_AUTH_TYPE);
    public static final int AUTH_TIMEOUT = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_AUTH_TIMEOUT);
    public static final int ALLOW_WHILE_ON_BODY = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ALLOW_WHILE_ON_BODY);
    public static final int USER_PRESENCE_REQUIRED = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_TRUSTED_USER_PRESENCE_REQUIRED);
    public static final int TRUSTED_CONFIRMATION_REQUIRED = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_TRUSTED_CONFIRMATION_REQUIRED);
    public static final int UNLOCKED_DEVICE_REQUIRED = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_UNLOCKED_DEVICE_REQUIRED);

    public static final int APPLICATION_ID = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_APPLICATION_ID);

    public static final int ORIGIN = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ORIGIN);
    public static final int ROLLBACK_RESISTANT = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ROLLBACK_RESISTANT);
    public static final int OS_VERSION = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_OS_VERSION);
    public static final int OS_PATCHLEVEL = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_OS_PATCHLEVEL);
    public static final int ATTESTATION_APPLICATION_ID = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_APPLICATION_ID);
    public static final int ATTESTATION_ID_BRAND = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_ID_BRAND);
    public static final int ATTESTATION_ID_DEVICE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_ID_DEVICE);
    public static final int ATTESTATION_ID_PRODUCT = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_ID_PRODUCT);
    public static final int ATTESTATION_ID_SERIAL = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_ID_SERIAL);
    public static final int ATTESTATION_ID_MEID = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_ID_MEID);
    public static final int ATTESTATION_ID_MANUFACTURER = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_ID_MANUFACTURER);
    public static final int ATTESTATION_ID_MODEL = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_ID_MODEL);
    public static final int VENDOR_PATCHLEVEL = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_VENDOR_PATCHLEVEL);
    public static final int BOOT_PATCHLEVEL = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_BOOT_PATCHLEVEL);
    public static final int DEVICE_UNIQUE_ATTESTATION = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_DEVICE_UNIQUE_ATTESTATION);
    public static final int IDENTITY_CREDENTIAL_KEY = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_IDENTITY_CREDENTIAL_KEY);

    private static final int NON_KM_BASE = PRIVATE_BASE - 2000;

    public static final int VERIFIED_BOOT_KEY = NON_KM_BASE - 1;
    public static final int DEVICE_LOCKED = NON_KM_BASE - 2;
    public static final int VERIFIED_BOOT_HASH = NON_KM_BASE - 3;
    public static final int ATTESTATION_VERSION = NON_KM_BASE - 4;
    public static final int KEYMASTER_VERSION = NON_KM_BASE - 5;
    public static final int OFFICIAL_BUILD = NON_KM_BASE - 6;

    public static final String SUBMOD_SOFTWARE = "software";
    public static final String SUBMOD_TEE = "tee";
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/IntegrityStatus.java`:

```java
package io.github.vvb2060.keyattestation.attestation;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.ASN1TaggedObject;

import java.security.cert.CertificateParsingException;

public class IntegrityStatus {
    private static final int TRUST_BOOT = 0;
    private static final int WARRANTY = 1;
    private static final int ICD = 2;
    private static final int KERNEL_STATUS = 3;
    private static final int SYSTEM_STATUS = 4;
    private static final int AUTH_RESULT = 5;

    public static final int STATUS_NORMAL = 0;
    public static final int STATUS_ABNORMAL = 1;
    public static final int STATUS_NOT_SUPPORT = 2;

    private int trustBoot = STATUS_NOT_SUPPORT;
    private int warranty = STATUS_NOT_SUPPORT;
    private int icd = STATUS_NOT_SUPPORT;
    private int kernelStatus = STATUS_NOT_SUPPORT;
    private int systemStatus = STATUS_NOT_SUPPORT;
    private AuthResult authResult;

    public IntegrityStatus(ASN1Encodable asn1Encodable) throws CertificateParsingException {
        if (!(asn1Encodable instanceof ASN1Sequence sequence)) {
            throw new CertificateParsingException("Expected sequence for integrity status, found "
                    + asn1Encodable.getClass().getName());
        }
        for (var entry : sequence) {
            if (!(entry instanceof ASN1TaggedObject taggedObject)) {
                throw new CertificateParsingException(
                        "Expected tagged object, found " + entry.getClass().getName());
            }
            int tag = taggedObject.getTagNo();
            var value = taggedObject.getBaseObject().toASN1Primitive();
            switch (tag) {
                case TRUST_BOOT -> trustBoot = Asn1Utils.getIntegerFromAsn1(value);
                case WARRANTY -> warranty = Asn1Utils.getIntegerFromAsn1(value);
                case ICD -> icd = Asn1Utils.getIntegerFromAsn1(value);
                case KERNEL_STATUS -> kernelStatus = Asn1Utils.getIntegerFromAsn1(value);
                case SYSTEM_STATUS -> systemStatus = Asn1Utils.getIntegerFromAsn1(value);
                case AUTH_RESULT -> authResult = AuthResult.parse(value);
                default -> throw new CertificateParsingException("invalid tag no: " + tag);
            }
        }
    }

    public static String statusToString(int status) {
        return switch (status) {
            case STATUS_NORMAL -> "Normal";
            case STATUS_ABNORMAL -> "Abnormal";
            case STATUS_NOT_SUPPORT -> "Not support";
            default -> Integer.toHexString(status);
        };
    }

    @Override
    public String toString() {
        return "TrustBoot: " + statusToString(trustBoot) +
                "\nWarranty: " + statusToString(warranty) +
                "\nICD: " + statusToString(icd) +
                "\nKernel Status: " + statusToString(kernelStatus) +
                "\nSystem Status: " + statusToString(systemStatus) +
                "\nCaller auth(with PROCA) Status: " +
                (authResult == null ? "Not performed" : authResult.toString());
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/KnoxAttestation.java`:

```java
package io.github.vvb2060.keyattestation.attestation;

import com.google.common.io.BaseEncoding;

import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.ASN1TaggedObject;

import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;

// https://docs.samsungknox.com/dev/knox-attestation/
public class KnoxAttestation extends Asn1Attestation {
    private static final int CHALLENGE = 0;
    private static final int ID_ATTEST = 4;
    private static final int INTEGRITY = 5;
    private static final int ATTESTATION_RECORD_HASH = 6;

    private String challenge;
    private String idAttest;
    private IntegrityStatus knoxIntegrity;
    private byte[] recordHash;

    public KnoxAttestation(X509Certificate x509Cert) throws CertificateParsingException {
        super(x509Cert);
        ASN1Sequence knoxExtSeq = getKnoxExtensionSequence(x509Cert);
        for (var entry : knoxExtSeq) {
            if (!(entry instanceof ASN1TaggedObject taggedObject)) {
                throw new CertificateParsingException(
                        "Expected tagged object, found " + entry.getClass().getName());
            }
            int tag = taggedObject.getTagNo();
            var value = taggedObject.getBaseObject().toASN1Primitive();
            switch (tag) {
                case CHALLENGE -> challenge = Asn1Utils.getStringFromASN1PrintableString(value);
                case ID_ATTEST -> idAttest = Asn1Utils.getStringFromASN1PrintableString(value);
                case INTEGRITY -> knoxIntegrity = new IntegrityStatus(value);
                case ATTESTATION_RECORD_HASH -> recordHash = Asn1Utils.getByteArrayFromAsn1(value);
                default -> throw new CertificateParsingException("invalid tag no: " + tag);
            }
        }
    }

    ASN1Sequence getKnoxExtensionSequence(X509Certificate x509Cert)
            throws CertificateParsingException {
        byte[] knoxExtensionSequence = x509Cert.getExtensionValue(KNOX_OID);
        if (knoxExtensionSequence == null || knoxExtensionSequence.length == 0) {
            throw new CertificateParsingException("Did not find extension with OID " + KNOX_OID);
        }
        return Asn1Utils.getAsn1SequenceFromBytes(knoxExtensionSequence);
    }

    public String getKnoxChallenge() {
        return challenge;
    }

    public String getIdAttest() {
        return idAttest;
    }

    public IntegrityStatus getKnoxIntegrity() {
        return knoxIntegrity;
    }

    public byte[] getRecordHash() {
        return recordHash;
    }

    @Override
    public String toString() {
        return super.toString() +
                "\n\nExtension type: " + getClass().getSimpleName() +
                "\nID attestation: " + idAttest +
                "\nChallenge: " + challenge +
                "\nIntegrity status: " + knoxIntegrity +
                "\nAttestation record hash: " + BaseEncoding.base16().lowerCase().encode(recordHash);
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/ProvisioningInfo.java`:

```java
package io.github.vvb2060.keyattestation.attestation;

import android.util.Log;

import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;

import co.nstant.in.cbor.CborException;
import co.nstant.in.cbor.model.Map;
import co.nstant.in.cbor.model.Number;
import io.github.vvb2060.keyattestation.AppApplication;

public class ProvisioningInfo {
    private static final String OID = "1.3.6.1.4.1.11129.2.1.30";

    private Integer certsIssued;
    private String manufacturer;

    private ProvisioningInfo(Map map) {
        for (var key : map.getKeys()) {
            switch (((Number) key).getValue().intValue()) {
                case 1 -> certsIssued = CborUtils.getInt(map, key);
                case 3 -> manufacturer = CborUtils.getUnicodeString(map, key);
                default -> Log.w(AppApplication.TAG, "new provisioning info: "
                        + key + " = " + map.get(key));
            }
        }
    }

    public static ProvisioningInfo get(X509Certificate cert) {
        var bytes = cert.getExtensionValue(OID);
        if (bytes == null) return null;
        try {
            var asn1 = Asn1Utils.getAsn1EncodableFromBytes(bytes);
            var cborBytes = Asn1Utils.getByteArrayFromAsn1(asn1);
            var map = (Map) CborUtils.decodeCbor(cborBytes);
            return new ProvisioningInfo(map);
        } catch (CborException | CertificateParsingException e) {
            Log.e(AppApplication.TAG, "decode", e);
            return null;
        }
    }

    public Integer getCertsIssued() {
        return certsIssued;
    }

    public String getManufacturer() {
        return manufacturer;
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/RevocationList.java`:

```java
package io.github.vvb2060.keyattestation.attestation;

import android.os.Build;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.util.Locale;

import io.github.vvb2060.keyattestation.AppApplication;
import io.github.vvb2060.keyattestation.R;

public record RevocationList(String status, String reason) {
    private static final JSONObject data = getStatus();

    private static String toString(InputStream input) throws IOException {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            return new String(input.readAllBytes(), StandardCharsets.UTF_8);
        } else {
            var output = new ByteArrayOutputStream(8192);
            var buffer = new byte[8192];
            for (int length; (length = input.read(buffer)) != -1; ) {
                output.write(buffer, 0, length);
            }
            return output.toString();
        }
    }

    private static JSONObject parseStatus(InputStream inputStream) throws IOException {
        try {
            var statusListJson = new JSONObject(toString(inputStream));
            return statusListJson.getJSONObject("entries");
        } catch (JSONException e) {
            throw new IOException(e);
        }
    }

    private static JSONObject getStatus() {
        var statusUrl = "https://android.googleapis.com/attestation/status";
        var resName = "android:string/vendor_required_attestation_revocation_list_url";
        var res = AppApplication.app.getResources();
        // noinspection DiscouragedApi
        var id = res.getIdentifier(resName, null, null);
        if (id != 0) {
            var url = res.getString(id);
            if (!statusUrl.equals(url) && url.toLowerCase(Locale.ROOT).startsWith("https")) {
                // no network permission, waiting for user report
                throw new RuntimeException("unknown status url: " + url);
            }
        }
        try (var input = res.openRawResource(R.raw.status)) {
            return parseStatus(input);
        } catch (IOException e) {
            throw new RuntimeException("Failed to parse certificate revocation status", e);
        }
    }

    public static RevocationList get(BigInteger serialNumber) {
        String serialNumberString = serialNumber.toString(16).toLowerCase();
        JSONObject revocationStatus;
        try {
            revocationStatus = data.getJSONObject(serialNumberString);
        } catch (JSONException e) {
            return null;
        }
        try {
            var status = revocationStatus.getString("status");
            var reason = revocationStatus.getString("reason");
            return new RevocationList(status, reason);
        } catch (JSONException e) {
            return new RevocationList("", "");
        }
    }

    @Override
    public String toString() {
        return "status is " + status + ", reason is " + reason;
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/RootOfTrust.java`:

```java
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import com.google.common.io.BaseEncoding;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Sequence;

import java.security.cert.CertificateParsingException;

public class RootOfTrust {
    private static final int VERIFIED_BOOT_KEY_INDEX = 0;
    private static final int DEVICE_LOCKED_INDEX = 1;
    private static final int VERIFIED_BOOT_STATE_INDEX = 2;
    private static final int VERIFIED_BOOT_HASH_INDEX = 3;

    public static final int KM_VERIFIED_BOOT_VERIFIED = 0;
    public static final int KM_VERIFIED_BOOT_SELF_SIGNED = 1;
    public static final int KM_VERIFIED_BOOT_UNVERIFIED = 2;
    public static final int KM_VERIFIED_BOOT_FAILED = 3;

    private final byte[] verifiedBootKey;
    private final boolean deviceLocked;
    private final int verifiedBootState;
    private final byte[] verifiedBootHash;

    public RootOfTrust(ASN1Encodable asn1Encodable) throws CertificateParsingException {
        if (!(asn1Encodable instanceof ASN1Sequence sequence)) {
            throw new CertificateParsingException("Expected sequence for root of trust, found "
                    + asn1Encodable.getClass().getName());
        }

        verifiedBootKey =
                Asn1Utils.getByteArrayFromAsn1(sequence.getObjectAt(VERIFIED_BOOT_KEY_INDEX));
        deviceLocked = Asn1Utils.getBooleanFromAsn1(sequence.getObjectAt(DEVICE_LOCKED_INDEX));
        verifiedBootState =
                Asn1Utils.getIntegerFromAsn1(sequence.getObjectAt(VERIFIED_BOOT_STATE_INDEX));
        if (sequence.size() == 3) verifiedBootHash = null;
        else verifiedBootHash =
                Asn1Utils.getByteArrayFromAsn1(sequence.getObjectAt(VERIFIED_BOOT_HASH_INDEX));
    }

    RootOfTrust(byte[] verifiedBootKey, boolean deviceLocked,
                int verifiedBootState, byte[] verifiedBootHash) {
        this.verifiedBootKey = verifiedBootKey;
        this.deviceLocked = deviceLocked;
        this.verifiedBootState = verifiedBootState;
        this.verifiedBootHash = verifiedBootHash;
    }

    public static String verifiedBootStateToString(int verifiedBootState) {
        switch (verifiedBootState) {
            case KM_VERIFIED_BOOT_VERIFIED:
                return "Verified";
            case KM_VERIFIED_BOOT_SELF_SIGNED:
                return "Self-signed";
            case KM_VERIFIED_BOOT_UNVERIFIED:
                return "Unverified";
            case KM_VERIFIED_BOOT_FAILED:
                return "Failed";
            default:
                return "Unknown (" + verifiedBootState + ")";
        }
    }

    public byte[] getVerifiedBootKey() {
        return verifiedBootKey;
    }

    public boolean isDeviceLocked() {
        return deviceLocked;
    }

    public int getVerifiedBootState() {
        return verifiedBootState;
    }

    public byte[] getVerifiedBootHash() {
        return verifiedBootHash;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder()
                .append("verifiedBootKey: ")
                .append(BaseEncoding.base16().lowerCase().encode(verifiedBootKey))
                .append("\ndeviceLocked: ")
                .append(deviceLocked)
                .append("\nverifiedBootState: ")
                .append(verifiedBootStateToString(verifiedBootState));
        if (verifiedBootHash != null) {
            sb.append("\nverifiedBootHash: ")
                    .append(BaseEncoding.base16().lowerCase().encode(verifiedBootHash));
        }
        return sb.toString();
    }

    public static class Builder {
        private byte[] verifiedBootKey;
        private boolean deviceLocked = false;
        private int verifiedBootState = -1;
        private byte[] verifiedBootHash;

        public Builder setVerifiedBootKey(byte[] verifiedBootKey) {
            this.verifiedBootKey = verifiedBootKey;
            return this;
        }

        public Builder setDeviceLocked(boolean deviceLocked) {
            this.deviceLocked = deviceLocked;
            return this;
        }

        public Builder setVerifiedBootState(int verifiedBootState) {
            this.verifiedBootState = verifiedBootState;
            return this;
        }

        public Builder setVerifiedBootHash(byte[] verifiedBootHash) {
            this.verifiedBootHash = verifiedBootHash;
            return this;
        }

        public RootOfTrust build() {
            return new RootOfTrust(verifiedBootKey, deviceLocked,
                    verifiedBootState, verifiedBootHash);
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/RootPublicKey.java`:

```java
package io.github.vvb2060.keyattestation.attestation;

import android.util.Base64;
import android.util.Log;

import java.io.ByteArrayInputStream;
import java.security.PublicKey;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import io.github.vvb2060.keyattestation.AppApplication;

public class RootPublicKey {
    public enum Status {
        NULL,
        FAILED,
        UNKNOWN,
        AOSP,
        GOOGLE,
        GOOGLE_RKP,
        KNOX,
        OEM,
    }

    private static final String GOOGLE_ROOT_PUBLIC_KEY = """
            MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xU\
            FmOr75gvMsd/dTEDDJdSSxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5j\
            lRfdnJLmN0pTy/4lj4/7tv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y\
            //0rb+T+W8a9nsNL/ggjnar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73X\
            pXyTqRxB/M0n1n/W9nGqC4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYI\
            mQQcHtGl/m00QLVWutHQoVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB\
            +TxywElgS70vE0XmLD+OJtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7q\
            uvmag8jfPioyKvxnK/EgsTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgp\
            Zrt3i5MIlCaY504LzSRiigHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7\
            gLiMm0jhO2B6tUXHI/+MRPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82\
            ixPvZtXQpUpuL12ab+9EaDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+\
            NpUFgNPN9PvQi8WEg5UmAGMCAwEAAQ==""";

    private static final String AOSP_ROOT_EC_PUBLIC_KEY = """
            MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamgu\
            D/9/SQ59dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpA==""";

    private static final String AOSP_ROOT_RSA_PUBLIC_KEY = """
            MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCia63rbi5EYe/VDoLmt5TRdSMf\
            d5tjkWP/96r/C3JHTsAsQ+wzfNes7UA+jCigZtX3hwszl94OuE4TQKuvpSe/lWmg\
            MdsGUmX4RFlXYfC78hdLt0GAZMAoDo9Sd47b0ke2RekZyOmLw9vCkT/X11DEHTVm\
            +Vfkl5YLCazOkjWFmwIDAQAB""";

    private static final String KNOX_SAKV1_ROOT_PUBLIC_KEY = """
            MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBs9Qjr//REhkXW7jUqjY9KNwWac4r\
            5+kdUGk+TZjRo1YEa47Axwj6AJsbOjo4QsHiYRiWTELvFeiuBsKqyuF0xyAAKvDo\
            fBqrEq1/Ckxo2mz7Q4NQes3g4ahSjtgUSh0k85fYwwHjCeLyZ5kEqgHG9OpOH526\
            FFAK3slSUgC8RObbxys=""";

    private static final String KNOX_SAKV2_ROOT_PUBLIC_KEY = """
            MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBhbGuLrpql5I2WJmrE5kEVZOo+dgA\
            46mKrVJf/sgzfzs2u7M9c1Y9ZkCEiiYkhTFE9vPbasmUfXybwgZ2EM30A1ABPd12\
            4n3JbEDfsB/wnMH1AcgsJyJFPbETZiy42Fhwi+2BCA5bcHe7SrdkRIYSsdBRaKBo\
            ZsapxB0gAOs0jSPRX5M=""";

    private static final String KNOX_SAKMV1_ROOT_PUBLIC_KEY = """
            MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQB9XeEN8lg6p5xvMVWG42P2Qi/aRKX\
            2rPRNgK92UlO9O/TIFCKHC1AWCLFitPVEow5W+yEgC2wOiYxgepY85TOoH0AuEkL\
            oiC6ldbF2uNVU3rYYSytWAJg3GFKd1l9VLDmxox58Hyw2Jmdd5VSObGiTFQ/SgKs\
            n2fbQPtpGlNxgEfd6Y8=""";

    private static final byte[] googleKey = Base64.decode(GOOGLE_ROOT_PUBLIC_KEY, 0);
    private static final byte[] aospEcKey = Base64.decode(AOSP_ROOT_EC_PUBLIC_KEY, 0);
    private static final byte[] aospRsaKey = Base64.decode(AOSP_ROOT_RSA_PUBLIC_KEY, 0);
    private static final byte[] knoxSakv1Key = Base64.decode(KNOX_SAKV1_ROOT_PUBLIC_KEY, 0);
    private static final byte[] knoxSakv2Key = Base64.decode(KNOX_SAKV2_ROOT_PUBLIC_KEY, 0);
    private static final byte[] knoxSakmv1Key = Base64.decode(KNOX_SAKMV1_ROOT_PUBLIC_KEY, 0);
    private static final Set<PublicKey> oemKeys = getOemPublicKey();

    private static Set<PublicKey> getOemPublicKey() {
        var resName = "android:array/vendor_required_attestation_certificates";
        var res = AppApplication.app.getResources();
        // noinspection DiscouragedApi
        var id = res.getIdentifier(resName, null, null);
        if (id == 0) {
            return null;
        }
        var set = new HashSet<PublicKey>();
        try {
            var cf = CertificateFactory.getInstance("X.509");
            for (var s : res.getStringArray(id)) {
                var cert = s.replaceAll("\\s+", "\n")
                        .replaceAll("-BEGIN\\nCERTIFICATE-", "-BEGIN CERTIFICATE-")
                        .replaceAll("-END\\nCERTIFICATE-", "-END CERTIFICATE-");
                var input = new ByteArrayInputStream(cert.getBytes());
                var publicKey = cf.generateCertificate(input).getPublicKey();
                set.add(publicKey);
            }
        } catch (CertificateException e) {
            Log.e(AppApplication.TAG, "getOemKeys: ", e);
            return null;
        }
        set.removeIf(key -> Arrays.equals(key.getEncoded(), googleKey));
        if (set.isEmpty()) {
            return null;
        }
        set.forEach(key -> Log.i(AppApplication.TAG, "getOemKeys: " + key));
        return set;
    }

    public static Status check(byte[] publicKey) {
        if (Arrays.equals(publicKey, googleKey)) {
            return Status.GOOGLE;
        } else if (Arrays.equals(publicKey, aospEcKey)) {
            return Status.AOSP;
        } else if (Arrays.equals(publicKey, aospRsaKey)) {
            return Status.AOSP;
        } else if (Arrays.equals(publicKey, knoxSakv2Key)) {
            return Status.KNOX;
        } else if (Arrays.equals(publicKey, knoxSakv1Key)) {
            return Status.KNOX;
        } else if (Arrays.equals(publicKey, knoxSakmv1Key)) {
            return Status.KNOX;
        } else if (oemKeys != null) {
            for (var key : oemKeys) {
                if (Arrays.equals(publicKey, key.getEncoded())) {
                    return Status.OEM;
                }
            }
        }
        return Status.UNKNOWN;
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/BootStateViewHolder.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.content.res.ColorStateList
import android.view.View
import androidx.core.view.isVisible
import io.github.vvb2060.keyattestation.R
import io.github.vvb2060.keyattestation.repository.AttestationData
import io.github.vvb2060.keyattestation.attestation.RootOfTrust
import io.github.vvb2060.keyattestation.databinding.HomeHeaderBinding
import rikka.core.res.resolveColor

class BootStateViewHolder(itemView: View, binding: HomeHeaderBinding) :
        HomeViewHolder<AttestationData, HomeHeaderBinding>(itemView, binding) {

    companion object {

        val CREATOR = Creator<AttestationData> { inflater, parent ->
            val binding = HomeHeaderBinding.inflate(inflater, parent, false)
            BootStateViewHolder(binding.root, binding)
        }
    }

    override fun onBind() {
        val context = itemView.context

        val rootOfTrust = data.rootOfTrust
        val locked = rootOfTrust?.isDeviceLocked
        val bootUnverified = rootOfTrust?.verifiedBootState != RootOfTrust.KM_VERIFIED_BOOT_VERIFIED

        val titleRes: Int
        val summaryRes: Int
        val iconRes: Int
        val colorAttrRes: Int

        if (locked == null) {
            titleRes = R.string.bootloader_unknown
            iconRes = R.drawable.ic_boot_unknown_24
            colorAttrRes = rikka.material.R.attr.colorInactive
        } else if (!locked) {
            titleRes = R.string.bootloader_unlocked
            iconRes = R.drawable.ic_boot_unlocked_24
            colorAttrRes = rikka.material.R.attr.colorWarning
        } else if (bootUnverified) {
            titleRes = R.string.bootloader_user
            iconRes = R.drawable.ic_boot_locked_24
            colorAttrRes = rikka.material.R.attr.colorInactive
        } else {
            titleRes = R.string.bootloader_locked
            iconRes = R.drawable.ic_boot_locked_24
            colorAttrRes = rikka.material.R.attr.colorSafe
        }

        if (data.isSoftwareLevel) {
            summaryRes = R.string.bootloader_summary_sw_level
        } else {
            summaryRes = 0
        }

        val color = context.theme.resolveColor(colorAttrRes)

        binding.apply {
            title.setText(titleRes)
            icon.setImageDrawable(context.getDrawable(iconRes))
            root.backgroundTintList = ColorStateList.valueOf(color)
            if (summaryRes == 0) {
                summary.isVisible = false
            } else {
                summary.isVisible = true
                summary.setText(summaryRes)
            }
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/CommonItemViewHolder.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.util.Pair
import android.view.View
import androidx.core.view.isVisible
import io.github.vvb2060.keyattestation.R
import io.github.vvb2060.keyattestation.attestation.Attestation.KM_SECURITY_LEVEL_STRONG_BOX
import io.github.vvb2060.keyattestation.attestation.Attestation.KM_SECURITY_LEVEL_TRUSTED_ENVIRONMENT
import io.github.vvb2060.keyattestation.attestation.AuthorizationList
import io.github.vvb2060.keyattestation.attestation.CertificateInfo
import io.github.vvb2060.keyattestation.attestation.RootPublicKey
import io.github.vvb2060.keyattestation.databinding.HomeCommonItemBinding
import rikka.core.res.resolveColorStateList

open class CommonItemViewHolder<T>(itemView: View, binding: HomeCommonItemBinding) :
    HomeViewHolder<T, HomeCommonItemBinding>(itemView, binding) {

    companion object {
        val SIMPLE_CREATOR = Creator<Pair<String, String>> { inflater, parent ->
            val binding = HomeCommonItemBinding.inflate(inflater, parent, false)
            object : CommonItemViewHolder<Pair<String, String>>(binding.root, binding) {

                init {
                    this.binding.apply {
                        text1.isVisible = false
                        icon.isVisible = false
                    }
                }

                override fun onBind() {
                    binding.title.text = data.first
                    binding.summary.text = data.second
                }
            }
        }

        val HOSTNAME_CREATOR = Creator<StringData> { inflater, parent ->
            val binding = HomeCommonItemBinding.inflate(inflater, parent, false)
            object : CommonItemViewHolder<StringData>(binding.root, binding) {

                init {
                    this.binding.apply {
                        icon.isVisible = false
                        root.setOnClickListener {
                            listener.onRkpHostnameClick(data.data)
                        }
                    }
                }

                override fun onBind() {
                    binding.title.setText(data.title)
                    if (data.data.isEmpty()) {
                        binding.summary.setText(R.string.rkp_hostname_empty)
                    } else {
                        binding.summary.text = data.data
                    }
                }
            }
        }

        val COMMON_CREATOR = Creator<CommonData> { inflater, parent ->
            val binding = HomeCommonItemBinding.inflate(inflater, parent, false)
            object : CommonItemViewHolder<CommonData>(binding.root, binding) {

                init {
                    this.binding.apply {
                        icon.isVisible = false
                        root.setOnClickListener {
                            listener.onCommonDataClick(data)
                        }
                    }
                }

                override fun onBind() {
                    binding.title.setText(data.title)
                    if (data.data.isNullOrEmpty()) {
                        binding.summary.setText(R.string.empty)
                    } else {
                        binding.summary.text = data.data
                    }
                }
            }
        }

        val AUTHORIZATION_ITEM_CREATOR = Creator<AuthorizationItemData> { inflater, parent ->
            val binding = HomeCommonItemBinding.inflate(inflater, parent, false)
            object : CommonItemViewHolder<AuthorizationItemData>(binding.root, binding) {

                init {
                    this.binding.apply {
                        root.setOnClickListener {
                            listener.onCommonDataClick(data)
                        }
                        icon.isVisible = false
                    }
                }

                override fun onBind() {
                    binding.apply {
                        title.setText(data.title)
                        text1.setText(if (data.tee) R.string.tee_enforced else R.string.sw_enforced)
                        if (data.data.isEmpty()) {
                            summary.setText(R.string.empty)
                        } else {
                            summary.text = data.data
                        }
                    }
                }
            }
        }

        val SECURITY_LEVEL_CREATOR = Creator<SecurityLevelData> { inflater, parent ->
            val binding = HomeCommonItemBinding.inflate(inflater, parent, false)
            object : CommonItemViewHolder<SecurityLevelData>(binding.root, binding) {

                init {
                    this.binding.apply {
                        text1.isVisible = false
                        icon.background = null
                        root.setOnClickListener {
                            listener.onCommonDataClick(data)
                        }
                    }
                }

                override fun onBind() {
                    val context = itemView.context
                    val data = data
                    val securityLevel: Int
                    val iconRes: Int
                    val colorAttr: Int
                    when (data.securityLevel) {
                        KM_SECURITY_LEVEL_TRUSTED_ENVIRONMENT -> {
                            securityLevel = R.string.security_level_trusted_environment
                            iconRes = R.drawable.ic_trustworthy_24
                            colorAttr = rikka.material.R.attr.colorSafe
                        }
                        KM_SECURITY_LEVEL_STRONG_BOX -> {
                            securityLevel = R.string.security_level_strongbox
                            iconRes = R.drawable.ic_trustworthy_24
                            colorAttr = rikka.material.R.attr.colorSafe
                        }
                        else -> {
                            securityLevel = R.string.security_level_software
                            iconRes = R.drawable.ic_untrustworthy_24
                            colorAttr = rikka.material.R.attr.colorWarning
                        }
                    }

                    binding.apply {
                        title.setText(data.title)
                        summary.text = context.getString(R.string.attestation_summary_format, data.version, context.getString(securityLevel))
                        icon.setImageDrawable(context.getDrawable(iconRes))
                        icon.imageTintList = context.theme.resolveColorStateList(colorAttr)
                    }
                }
            }
        }

        val CERT_INFO_CREATOR = Creator<CertificateInfo> { inflater, parent ->
            val binding = HomeCommonItemBinding.inflate(inflater, parent, false)
            object : CommonItemViewHolder<CertificateInfo>(binding.root, binding) {

                init {
                    this.binding.apply {
                        title.isVisible = false
                        text1.isVisible = false
                        icon.background = null
                        icon.setOnClickListener {
                            data.attestation?.let { listener.onAttestationInfoClick(it) }
                        }
                        root.setOnClickListener {
                            val stringData = StringData(R.string.cert_info, data.cert.toString())
                            listener.onCommonDataClick(stringData)
                        }
                    }
                }

                override fun onBind() {
                    val iconRes: Int?
                    val colorAttr: Int?
                    binding.icon.apply {
                        if (data.issuer == RootPublicKey.Status.AOSP) {
                            isVisible = true
                            isClickable = false
                            iconRes = R.drawable.ic_untrustworthy_24
                            colorAttr = rikka.material.R.attr.colorWarning
                        } else if (data.issuer == RootPublicKey.Status.GOOGLE) {
                            isVisible = true
                            isClickable = false
                            iconRes = R.drawable.ic_trustworthy_24
                            colorAttr = rikka.material.R.attr.colorSafe
                        } else if (data.attestation != null) {
                            isVisible = true
                            isClickable = true
                            iconRes = R.drawable.ic_info_outline_24
                            colorAttr = rikka.material.R.attr.colorAccent
                        } else {
                            isVisible = false
                            isClickable = false
                            iconRes = null
                            colorAttr = null
                        }
                        iconRes?.let { setImageDrawable(context.getDrawable(it)) }
                        colorAttr?.let { imageTintList = context.theme.resolveColorStateList(it) }
                    }

                    val sb = StringBuilder()
                    val cert = data.cert
                    val res = context.resources
                    sb.append(res.getString(R.string.cert_subject))
                            .append(cert.subjectDN)
                            .append("\n")
                            .append(res.getString(R.string.cert_not_before))
                            .append(AuthorizationList.formatDate(cert.notBefore))
                            .append("\n")
                            .append(res.getString(R.string.cert_not_after))
                            .append(AuthorizationList.formatDate(cert.notAfter))

                    data.provisioningInfo?.apply {
                        certsIssued?.let {
                            sb.append("\n")
                                .append(res.getString(R.string.provisioning_info_certs_issued))
                                .append(it)
                        }
                        manufacturer?.let {
                            sb.append("\n")
                                .append(res.getString(R.string.provisioning_info_manufacturer))
                                .append(it)
                        }
                    }

                    val resId = when (data.status) {
                        CertificateInfo.CERT_SIGN -> R.string.cert_error_sign
                        CertificateInfo.CERT_REVOKED -> R.string.cert_error_revoked
                        CertificateInfo.CERT_EXPIRED -> R.string.cert_error_expired
                        else -> null
                    }
                    if (resId != null) {
                        sb.append("\n").append(res.getString(resId))
                                .append(data.securityException.message)
                    }
                    binding.summary.text = sb.toString()
                }
            }
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/Data.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.content.Context
import io.github.vvb2060.keyattestation.R
import rikka.html.text.HtmlCompat
import rikka.html.text.toHtml

abstract class Data {
    abstract val title: Int
    abstract val description: Int
    open fun getMessage(context: Context): CharSequence =
        context.getString(description).toHtml(HtmlCompat.FROM_HTML_OPTION_TRIM_WHITESPACE)
}

class CommonData(
    override val title: Int,
    override val description: Int,
    val data: String? = null
) : Data()

class StringData(
    override val title: Int,
    val data: String,
) : Data() {
    override val description = 0
    override fun getMessage(context: Context) = data
}

class HeaderData(
    override val title: Int,
    override val description: Int,
    val icon: Int,
    val color: Int
) : Data()

class AuthorizationItemData(
    override val title: Int,
    override val description: Int,
    val data: String,
    val tee: Boolean
) : Data() {
    constructor(title: Int, description: Int, data: String?, fallback: String?) :
            this(title, description, data ?: fallback!!, data != null)

    override fun getMessage(context: Context): CharSequence {
        val id = if (tee) R.string.tee_enforced_description else R.string.sw_enforced_description
        return "${context.getString(description)}<p>* ${context.getString(id)}"
            .toHtml(HtmlCompat.FROM_HTML_OPTION_TRIM_WHITESPACE)
    }
}

class SecurityLevelData(
    override val title: Int,
    override val description: Int,
    val securityLevelDescription: Int,
    val version: String,
    val securityLevel: Int
) : Data() {
    override fun getMessage(context: Context): CharSequence {
        val flags = HtmlCompat.FROM_HTML_SEPARATOR_LINE_BREAK_LIST_ITEM or
                HtmlCompat.FROM_HTML_OPTION_TRIM_WHITESPACE
        return ("${context.getString(description)}<p>" +
                context.getString(securityLevelDescription)).toHtml(flags)
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/ErrorViewHolder.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.view.View
import io.github.vvb2060.keyattestation.R
import io.github.vvb2060.keyattestation.databinding.HomeErrorBinding
import io.github.vvb2060.keyattestation.lang.AttestationException
import rikka.html.text.HtmlCompat
import rikka.html.text.toHtml

class ErrorViewHolder(itemView: View, binding: HomeErrorBinding) : HomeViewHolder<AttestationException, HomeErrorBinding>(itemView, binding) {

    companion object {

        val CREATOR = Creator<AttestationException> { inflater, parent ->
            val binding = HomeErrorBinding.inflate(inflater, parent, false)
            ErrorViewHolder(binding.root, binding)
        }
    }

    override fun onBind() {
        val context = itemView.context
        binding.apply {
            val sb = StringBuilder()
            sb.append(context.getString(data.descriptionResId)).append("<p>")

            sb.append(context.getString(R.string.error_message_subtitle)).append("<br>")
            sb.append("<font face=\"monospace\">")
            var tr = data.cause
            while (tr != null) {
                sb.append(tr).append("<br>")
                tr = tr.cause
            }
            sb.append("</font>")
            text1.text = sb.toHtml(HtmlCompat.FROM_HTML_OPTION_TRIM_WHITESPACE)
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/HeaderViewHolder.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.view.View
import androidx.core.view.isVisible
import io.github.vvb2060.keyattestation.databinding.HomeHeaderBinding
import rikka.core.res.resolveColorStateList
import rikka.recyclerview.BaseViewHolder.Creator

class HeaderViewHolder(itemView: View, binding: HomeHeaderBinding) : HomeViewHolder<HeaderData, HomeHeaderBinding>(itemView, binding) {

    companion object {

        val CREATOR = Creator<HeaderData> { inflater, parent ->
            val binding = HomeHeaderBinding.inflate(inflater, parent, false)
            HeaderViewHolder(binding.root, binding)
        }
    }

    override fun onBind() {
        binding.apply {
            val context = root.context
            root.backgroundTintList = context.theme.resolveColorStateList(data.color)
            icon.setImageDrawable(context.getDrawable(data.icon))
            title.setText(data.title)
            if (data.description != 0) {
                summary.setText(data.description)
                summary.isVisible = true
            } else {
                summary.isVisible = false
            }
        }
    }
}
```

`app/src/main/java/io/github/vvb2060/keyattestation/home/HomeActivity.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.os.Bundle
import androidx.fragment.app.commit
import io.github.vvb2060.keyattestation.BuildConfig
import io.github.vvb2060.keyattestation.R
import io.github.vvb2060.keyattestation.app.AppBarFragmentActivity

class HomeActivity : AppBarFragmentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        supportActionBar?.subtitle = BuildConfig.VERSION_NAME

        if (savedInstanceState == null) {
            supportFragmentManager.commit {
                setReorderingAllowed(true)
                add(R.id.fragment_container, HomeFragment())
            }
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/HomeAdapter.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.util.Base64
import android.util.Pair
import com.google.common.io.BaseEncoding
import io.github.vvb2060.keyattestation.R
import io.github.vvb2060.keyattestation.attestation.*
import io.github.vvb2060.keyattestation.lang.AttestationException
import io.github.vvb2060.keyattestation.lang.AttestationException.Companion.CODE_RKP
import io.github.vvb2060.keyattestation.repository.AttestationData
import io.github.vvb2060.keyattestation.repository.BaseData
import io.github.vvb2060.keyattestation.repository.RemoteProvisioningData
import rikka.recyclerview.IdBasedRecyclerViewAdapter

class HomeAdapter(listener: Listener) : IdBasedRecyclerViewAdapter() {

    interface Listener {
        fun onCommonDataClick(data: Data)
        fun onAttestationInfoClick(data: Attestation)
        fun onRkpHostnameClick(data: String)
    }

    init {
        setHasStableIds(true)
        setListener(listener)
    }

    fun updateData(baseData: BaseData) {
        clear()
        when (baseData.status) {
            RootPublicKey.Status.NULL -> {
                addItem(HeaderViewHolder.CREATOR, HeaderData(
                        R.string.error_remote_key_provisioning,
                        0,
                        R.drawable.ic_error_outline_24,
                        rikka.material.R.attr.colorInactive), ID_CERT_STATUS)
            }
            RootPublicKey.Status.FAILED -> {
                addItem(HeaderViewHolder.CREATOR, HeaderData(
                        R.string.cert_chain_not_trusted,
                        R.string.cert_chain_not_trusted_summary,
                        R.drawable.ic_error_outline_24,
                        rikka.material.R.attr.colorAlert), ID_CERT_STATUS)
            }
            RootPublicKey.Status.UNKNOWN -> {
                addItem(HeaderViewHolder.CREATOR, HeaderData(
                        R.string.unknown_root_cert,
                        R.string.unknown_root_cert_summary,
                        R.drawable.ic_error_outline_24,
                        rikka.material.R.attr.colorWarning), ID_CERT_STATUS)
            }
            RootPublicKey.Status.AOSP -> {
                addItem(HeaderViewHolder.CREATOR, HeaderData(
                        R.string.aosp_root_cert,
                        R.string.aosp_root_cert_summary,
                        R.drawable.ic_error_outline_24,
                        rikka.material.R.attr.colorWarning), ID_CERT_STATUS)
            }
            RootPublicKey.Status.GOOGLE -> {
                addItem(HeaderViewHolder.CREATOR, HeaderData(
                        R.string.google_root_cert,
                        R.string.google_root_cert_summary,
                        R.drawable.ic_trustworthy_24,
                        rikka.material.R.attr.colorSafe), ID_CERT_STATUS)
            }
            RootPublicKey.Status.GOOGLE_RKP -> {
                addItem(HeaderViewHolder.CREATOR, HeaderData(
                        R.string.google_root_cert_rkp,
                        R.string.google_root_cert_rkp_summary,
                        R.drawable.ic_trustworthy_24,
                        rikka.material.R.attr.colorSafe), ID_CERT_STATUS)
            }
            RootPublicKey.Status.KNOX -> {
                addItem(HeaderViewHolder.CREATOR, HeaderData(
                        R.string.knox_root_cert,
                        R.string.knox_root_cert_summary,
                        R.drawable.ic_trustworthy_24,
                        rikka.material.R.attr.colorSafe), ID_CERT_STATUS)
            }
            RootPublicKey.Status.OEM -> {
                addItem(HeaderViewHolder.CREATOR, HeaderData(
                        R.string.oem_root_cert,
                        R.string.oem_root_cert_summary,
                        R.drawable.ic_trustworthy_24,
                        rikka.material.R.attr.colorSafe), ID_CERT_STATUS)
            }
        }

        var id = ID_CERT_INFO_START
        addItem(SubtitleViewHolder.CREATOR, CommonData(
                R.string.cert_chain,
                R.string.cert_chain_description), id++)
        baseData.certs.forEach { certInfo ->
            addItem(CommonItemViewHolder.CERT_INFO_CREATOR, certInfo, id++)
        }

        when (baseData) {
            is AttestationData -> updateData(baseData)
            is RemoteProvisioningData -> updateData(baseData)
        }

        notifyDataSetChanged()
    }

    private fun updateData(attestationData: AttestationData) {
        addItemAt(1, BootStateViewHolder.CREATOR, attestationData, ID_BOOT_STATUS)

        var id = ID_DESCRIPTION_START
        val attestation = attestationData.showAttestation ?: return
        addItem(CommonItemViewHolder.SECURITY_LEVEL_CREATOR, SecurityLevelData(
                R.string.attestation,
                R.string.attestation_version_description,
                R.string.security_level_description,
                Attestation.attestationVersionToString(attestation.attestationVersion),
                attestation.attestationSecurityLevel), id++)

        addItem(CommonItemViewHolder.SECURITY_LEVEL_CREATOR, SecurityLevelData(
                R.string.keymaster,
                R.string.keymaster_version_description,
                R.string.security_level_description,
                Attestation.keymasterVersionToString(attestation.keymasterVersion),
                attestation.keymasterSecurityLevel), id++)

        addItem(CommonItemViewHolder.COMMON_CREATOR, CommonData(
                R.string.attestation_challenge,
                R.string.attestation_challenge_description,
                attestation.attestationChallenge?.let {
                    val stringChallenge = String(it)
                    if (stringChallenge.toByteArray().contentEquals(it)) stringChallenge
                    else Base64.encodeToString(it, 0) + " (base64)"
                }), id++)

        addItem(CommonItemViewHolder.COMMON_CREATOR, CommonData(
                R.string.unique_id,
                R.string.unique_id_description,
                attestation.uniqueId?.let { BaseEncoding.base16().lowerCase().encode(it) }), id)

        id = ID_AUTHORIZATION_LIST_START
        addItem(SubtitleViewHolder.CREATOR, CommonData(
                R.string.authorization_list,
                R.string.authorization_list_description), id++)

        val tee = createAuthorizationItems(attestation.teeEnforced)
        val sw = createAuthorizationItems(attestation.softwareEnforced)
        for (i in tee.indices) {
            val h = tee[i]
            val s = sw[i]
            if (h == null && s == null) {
                continue
            }

            addItem(CommonItemViewHolder.AUTHORIZATION_ITEM_CREATOR, AuthorizationItemData(
                    authorizationItemTitles[i],
                    authorizationItemDescriptions[i],
                    h, s), id++)

            if (h != null && s != null) {
                addItem(CommonItemViewHolder.AUTHORIZATION_ITEM_CREATOR, AuthorizationItemData(
                        authorizationItemTitles[i],
                        authorizationItemDescriptions[i],
                        s, false), id++)
            }
        }

        if (attestation is KnoxAttestation) {
            id = ID_KNOX_START
            addItem(SubtitleViewHolder.CREATOR, CommonData(
                    R.string.knox,
                    R.string.knox_description), id++)

            addItem(CommonItemViewHolder.COMMON_CREATOR, CommonData(
                    R.string.knox_challenge,
                    R.string.knox_challenge_description,
                    attestation.knoxChallenge), id++)

            addItem(CommonItemViewHolder.COMMON_CREATOR, CommonData(
                R.string.knox_id_attest,
                R.string.knox_id_attest_description,
                attestation.idAttest), id++)

            addItem(CommonItemViewHolder.COMMON_CREATOR, CommonData(
                    R.string.knox_integrity,
                    R.string.knox_integrity_description,
                    attestation.knoxIntegrity.toString()), id++)

            addItem(CommonItemViewHolder.COMMON_CREATOR, CommonData(
                    R.string.knox_record_hash,
                    R.string.knox_record_hash_description,
                    BaseEncoding.base16().lowerCase().encode(attestation.recordHash)), id++)
        }
    }

    private fun updateData(rkpData: RemoteProvisioningData) {
        if (rkpData.status == RootPublicKey.Status.NULL) {
            removeItemAt(1)
            var e = AttestationException(CODE_RKP, rkpData.error)
            addItemAt(1, ErrorViewHolder.CREATOR, e, ID_CERT_INFO_START)
        }

        if (rkpData.rkpHostname != null) {
            addItem(CommonItemViewHolder.HOSTNAME_CREATOR, StringData(
                R.string.rkp_hostname,
                rkpData.rkpHostname), ID_RKP_HOSTNAME)
        }

        var id = ID_DESCRIPTION_START
        var hardware = rkpData.hardwareInfo
        addItem(SubtitleViewHolder.CREATOR, CommonData(
            R.string.rpc_hardware_info,
            R.string.rpc_hardware_info_description), id++)

        addItem(CommonItemViewHolder.COMMON_CREATOR, CommonData(
            R.string.rpc_version_number,
            R.string.rpc_version_number_description,
            hardware.versionNumber.toString()), id++)

        addItem(CommonItemViewHolder.COMMON_CREATOR, CommonData(
            R.string.rpc_author_name,
            R.string.rpc_author_name_description,
            hardware.rpcAuthorName.toString()), id++)

        addItem(CommonItemViewHolder.COMMON_CREATOR, CommonData(
            R.string.rpc_unique_id,
            R.string.rpc_unique_id_description,
            hardware.uniqueId), id++)

        id = ID_AUTHORIZATION_LIST_START
        addItem(SubtitleViewHolder.CREATOR, CommonData(
            R.string.rkp_device_info,
            R.string.rkp_device_info_description), id++)

        rkpData.deviceInfo.forEach { key, value ->
            addItem(CommonItemViewHolder.SIMPLE_CREATOR, Pair(key, value), id++)
        }
    }

    fun updateData(e: AttestationException) {
        clear()
        addItem(HeaderViewHolder.CREATOR, HeaderData(
                e.titleResId,
                0,
                R.drawable.ic_error_outline_24,
                rikka.material.R.attr.colorInactive), ID_ERROR)

        addItem(ErrorViewHolder.CREATOR, e, ID_ERROR_MESSAGE)
        notifyDataSetChanged()
    }

    fun allowFrameAt(position: Int): Boolean {
        if (position < 0) return false
        val id = getItemId(position)
        return id >= ID_CERT_INFO_START
    }

    fun shouldCommitFrameAt(position: Int): Boolean {
        if (position < 0) return false
        val id = getItemId(position)
        if (position == itemCount - 1) {
            return true
        }
        return if (id < ID_CERT_INFO_START) {
            false
        } else {
            (getItemId(position + 1) / 1000 - id / 1000) > 0
        }
    }

    companion object {

        private const val ID_ERROR = 0L
        private const val ID_CERT_STATUS = 1L
        private const val ID_BOOT_STATUS = 2L
        private const val ID_CERT_INFO_START = 1000L
        private const val ID_RKP_HOSTNAME = 2000L
        private const val ID_DESCRIPTION_START = 3000L
        private const val ID_AUTHORIZATION_LIST_START = 4000L
        private const val ID_KNOX_START = 5000L
        private const val ID_ERROR_MESSAGE = 100000L

        private fun createAuthorizationItems(list: AuthorizationList): Array<String?> {
            return arrayOf(
                    list.purposes?.let { AuthorizationList.purposesToString(it) },
                    list.algorithm?.let { AuthorizationList.algorithmToString(it) },
                    list.keySize?.toString(),
                    list.digests?.let { AuthorizationList.digestsToString(it) },
                    list.paddingModes?.let { AuthorizationList.paddingModesToString(it) },
                    list.ecCurve?.let { AuthorizationList.ecCurveAsString(it) },
                    list.rsaPublicExponent?.toString(),
                    list.mgfDigests?.let { AuthorizationList.digestsToString(it) },
                    list.rollbackResistance?.toString(),
                    list.earlyBootOnly?.toString(),
                    list.activeDateTime?.let { AuthorizationList.formatDate(it) },
                    list.originationExpireDateTime?.let { AuthorizationList.formatDate(it) },
                    list.usageExpireDateTime?.let { AuthorizationList.formatDate(it) },
                    list.usageCountLimit?.toString(),
                    list.noAuthRequired?.toString(),
                    list.userAuthType?.let { AuthorizationList.userAuthTypeToString(it) },
                    list.authTimeout?.toString(),
                    list.allowWhileOnBody?.toString(),
                    list.trustedUserPresenceReq?.toString(),
                    list.trustedConfirmationReq?.toString(),
                    list.unlockedDeviceReq?.toString(),
                    list.allApplications?.toString(),
                    list.applicationId,
                    list.creationDateTime?.let { AuthorizationList.formatDate(it) },
                    list.origin?.let { AuthorizationList.originToString(it) },
                    list.rollbackResistant?.toString(),
                    list.rootOfTrust?.toString(),
                    list.osVersion?.toString(),
                    list.osPatchLevel?.toString(),
                    list.attestationApplicationId?.toString()?.trim(),
                    list.brand,
                    list.device,
                    list.product,
                    list.serialNumber,
                    list.imei,
                    list.secondImei,
                    list.meid,
                    list.manufacturer,
                    list.model,
                    list.vendorPatchLevel?.toString(),
                    list.bootPatchLevel?.toString(),
                    list.deviceUniqueAttestation?.toString(),
                    list.identityCredentialKey?.toString(),
                    list.moduleHash?.let { BaseEncoding.base16().lowerCase().encode(it) },
            )
        }

        private val authorizationItemTitles = arrayOf(
                R.string.authorization_list_purpose,
                R.string.authorization_list_algorithm,
                R.string.authorization_list_keySize,
                R.string.authorization_list_digest,
                R.string.authorization_list_padding,
                R.string.authorization_list_ecCurve,
                R.string.authorization_list_rsaPublicExponent,
                R.string.authorization_list_mgfDigest,
                R.string.authorization_list_rollbackResistance,
                R.string.authorization_list_earlyBootOnly,
                R.string.authorization_list_activeDateTime,
                R.string.authorization_list_originationExpireDateTime,
                R.string.authorization_list_usageExpireDateTime,
                R.string.authorization_list_usageCountLimit,
                R.string.authorization_list_noAuthRequired,
                R.string.authorization_list_userAuthType,
                R.string.authorization_list_authTimeout,
                R.string.authorization_list_allowWhileOnBody,
                R.string.authorization_list_trustedUserPresenceRequired,
                R.string.authorization_list_trustedConfirmationRequired,
                R.string.authorization_list_unlockedDeviceRequired,
                R.string.authorization_list_allApplications,
                R.string.authorization_list_applicationId,
                R.string.authorization_list_creationDateTime,
                R.string.authorization_list_origin,
                R.string.authorization_list_rollbackResistant,
                R.string.authorization_list_rootOfTrust,
                R.string.authorization_list_osVersion,
                R.string.authorization_list_osPatchLevel,
                R.string.authorization_list_attestationApplicationId,
                R.string.authorization_list_attestationIdBrand,
                R.string.authorization_list_attestationIdDevice,
                R.string.authorization_list_attestationIdProduct,
                R.string.authorization_list_attestationIdSerial,
                R.string.authorization_list_attestationIdImei,
                R.string.authorization_list_attestationIdSecondImei,
                R.string.authorization_list_attestationIdMeid,
                R.string.authorization_list_attestationIdManufacturer,
                R.string.authorization_list_attestationIdModel,
                R.string.authorization_list_vendorPatchLevel,
                R.string.authorization_list_bootPatchLevel,
                R.string.authorization_list_deviceUniqueAttestation,
                R.string.authorization_list_identityCredentialKey,
                R.string.authorization_list_moduleHash,
        )

        private val authorizationItemDescriptions = arrayOf(
                R.string.authorization_list_purpose_description,
                R.string.authorization_list_algorithm_description,
                R.string.authorization_list_keySize_description,
                R.string.authorization_list_digest_description,
                R.string.authorization_list_padding_description,
                R.string.authorization_list_ecCurve_description,
                R.string.authorization_list_rsaPublicExponent_description,
                R.string.authorization_list_mgfDigest_description,
                R.string.authorization_list_rollbackResistance_description,
                R.string.authorization_list_earlyBootOnly_description,
                R.string.authorization_list_activeDateTime_description,
                R.string.authorization_list_originationExpireDateTime_description,
                R.string.authorization_list_usageExpireDateTime_description,
                R.string.authorization_list_usageCountLimit_description,
                R.string.authorization_list_noAuthRequired_description,
                R.string.authorization_list_userAuthType_description,
                R.string.authorization_list_authTimeout_description,
                R.string.authorization_list_allowWhileOnBody_description,
                R.string.authorization_list_trustedUserPresenceRequired_description,
                R.string.authorization_list_trustedConfirmationRequired_description,
                R.string.authorization_list_unlockedDeviceRequired_description,
                R.string.authorization_list_allApplications_description,
                R.string.authorization_list_applicationId_description,
                R.string.authorization_list_creationDateTime_description,
                R.string.authorization_list_origin_description,
                R.string.authorization_list_rollbackResistant_description,
                R.string.authorization_list_rootOfTrust_description,
                R.string.authorization_list_osVersion_description,
                R.string.authorization_list_osPatchLevel_description,
                R.string.authorization_list_attestationApplicationId_description,
                R.string.authorization_list_attestationIdBrand_description,
                R.string.authorization_list_attestationIdDevice_description,
                R.string.authorization_list_attestationIdProduct_description,
                R.string.authorization_list_attestationIdSerial_description,
                R.string.authorization_list_attestationIdImei_description,
                R.string.authorization_list_attestationIdSecondImei_description,
                R.string.authorization_list_attestationIdMeid_description,
                R.string.authorization_list_attestationIdManufacturer_description,
                R.string.authorization_list_attestationIdModel_description,
                R.string.authorization_list_vendorPatchLevel_description,
                R.string.authorization_list_bootPatchLevel_description,
                R.string.authorization_list_deviceUniqueAttestation_description,
                R.string.authorization_list_identityCredentialKey_description,
                R.string.authorization_list_moduleHash_description,
        )
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/HomeFragment.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.app.Dialog
import android.os.Build
import android.os.Bundle
import android.text.method.LinkMovementMethod
import android.view.*
import android.widget.ImageView
import android.widget.TextView
import androidx.activity.result.contract.ActivityResultContracts.CreateDocument
import androidx.activity.result.contract.ActivityResultContracts.GetContent
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.widget.AppCompatEditText
import androidx.core.view.MenuProvider
import androidx.core.view.isVisible
import androidx.fragment.app.viewModels
import androidx.recyclerview.widget.LinearLayoutManager
import io.github.vvb2060.keyattestation.AppApplication
import io.github.vvb2060.keyattestation.BuildConfig
import io.github.vvb2060.keyattestation.R
import io.github.vvb2060.keyattestation.app.AlertDialogFragment
import io.github.vvb2060.keyattestation.app.AppFragment
import io.github.vvb2060.keyattestation.attestation.Attestation
import io.github.vvb2060.keyattestation.databinding.HomeBinding
import io.github.vvb2060.keyattestation.keystore.KeyStoreManager
import io.github.vvb2060.keyattestation.lang.AttestationException
import io.github.vvb2060.keyattestation.repository.AttestationData
import io.github.vvb2060.keyattestation.util.Status
import rikka.html.text.HtmlCompat
import rikka.html.text.toHtml
import rikka.shizuku.Shizuku
import rikka.widget.borderview.BorderView

class HomeFragment : AppFragment(), HomeAdapter.Listener, MenuProvider {

    private var _binding: HomeBinding? = null

    private val binding: HomeBinding get() = _binding!!

    private val viewModel: HomeViewModel by viewModels { HomeViewModel.Factory }

    private val save = registerForActivityResult(CreateDocument("application/x-pkcs7-certificates")) {
        viewModel.save(it)
    }

    private val load = registerForActivityResult(GetContent()) {
        viewModel.load(it)
    }

    private val import = registerForActivityResult(GetContent()) {
        viewModel.import(it)
    }

    private val adapter by lazy {
        HomeAdapter(this)
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = HomeBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        requireActivity().addMenuProvider(this, viewLifecycleOwner)

        val context = view.context

        binding.list.borderVisibilityChangedListener = BorderView.OnBorderVisibilityChangedListener { top: Boolean, _: Boolean, _: Boolean, _: Boolean -> appActivity?.appBar?.setRaised(!top) }
        binding.list.layoutManager = LinearLayoutManager(context)
        binding.list.adapter = adapter
        binding.list.addItemDecoration(HomeItemDecoration(context))

        viewModel.getAttestationData().observe(viewLifecycleOwner) { res ->
            when (res.status) {
                Status.SUCCESS -> {
                    binding.progress.isVisible = false
                    binding.list.isVisible = true
                    adapter.updateData(res.data!!)
                }
                Status.ERROR -> {
                    binding.progress.isVisible = false
                    binding.list.isVisible = true
                    adapter.updateData(res.error as AttestationException)
                }
                Status.LOADING -> {
                    binding.progress.isVisible = true
                    binding.list.isVisible = false
                }
            }
        }
    }

    override fun onAttestationInfoClick(data: Attestation) {
        val result = viewModel.getAttestationData().value!!.data!! as AttestationData
        result.showAttestation = data
        adapter.updateData(result)
    }

    override fun onRkpHostnameClick(data: String) {
        val context = requireContext()
        val dp24 = Math.round(24 * context.resources.displayMetrics.density)
        val dp18 = Math.round(18 * context.resources.displayMetrics.density)
        val editText = AppCompatEditText(context)
        editText.setHint(R.string.rkp_hostname_empty)
        editText.setText(data)
        editText.setPadding(dp24, dp18, dp24, dp18)
        editText.requestFocus()

        AlertDialog.Builder(context)
            .setView(editText)
            .setTitle(R.string.rkp_hostname)
            .setPositiveButton(android.R.string.ok) { _, _ ->
                viewModel.rkp(editText.text?.toString())
            }
            .setNegativeButton(android.R.string.cancel, null)
            .show()
    }

    override fun onCommonDataClick(data: Data) {
        val context = requireActivity()

        AlertDialogFragment.Builder(context)
            .title(data.title)
            .message(data.getMessage(context))
            .positiveButton(android.R.string.ok)
            .build()
            .show(context.supportFragmentManager)
    }

    override fun onPrepareMenu(menu: Menu) {
        menu.findItem(R.id.menu_use_shizuku).apply {
            isVisible = Shizuku.pingBinder()
            val received = KeyStoreManager.getRemoteKeyStore() != null
            if (!received) viewModel.preferShizuku = false
            isEnabled = received
            isChecked = viewModel.preferShizuku
        }

        menu.findItem(R.id.menu_use_strongbox)?.isVisible = !viewModel.preferSak
        menu.findItem(R.id.menu_use_attest_key)?.isVisible = !viewModel.preferSak
        menu.findItem(R.id.menu_import_attest_key)?.isVisible = !viewModel.preferSak
                && viewModel.preferAttestKey

        menu.setGroupVisible(R.id.menu_id_type_group, viewModel.preferShizuku)
        menu.findItem(R.id.menu_include_unique_id).isVisible =
            viewModel.preferShizuku && viewModel.canIncludeUniqueId
        menu.findItem(R.id.menu_rkp_test).isVisible =
            viewModel.preferShizuku && viewModel.canCheckRkp
        menu.findItem(R.id.menu_use_sak)?.isVisible =
            viewModel.preferShizuku && viewModel.canSak

        menu.findItem(R.id.menu_save).isVisible = viewModel.hasCertificates()
    }

    override fun onCreateMenu(menu: Menu, menuInflater: MenuInflater) {
        menuInflater.inflate(R.menu.home, menu)
        menu.findItem(R.id.menu_use_strongbox).isChecked = viewModel.preferStrongBox
        menu.findItem(R.id.menu_use_attest_key).isChecked = viewModel.preferAttestKey
        menu.findItem(R.id.menu_include_props).isChecked = viewModel.preferIncludeProps
        menu.findItem(R.id.menu_id_type_serial).isChecked = viewModel.preferIdAttestationSerial
        menu.findItem(R.id.menu_id_type_imei).isChecked = viewModel.preferIdAttestationIMEI
        menu.findItem(R.id.menu_id_type_meid).isChecked = viewModel.preferIdAttestationMEID
        menu.findItem(R.id.menu_include_unique_id).isChecked = viewModel.preferIncludeUniqueId
        menu.findItem(R.id.menu_use_sak).isChecked = viewModel.preferSak
        if (!viewModel.hasSak) {
            menu.removeItem(R.id.menu_use_sak)
        }
        if (!viewModel.hasStrongBox) {
            menu.removeItem(R.id.menu_use_strongbox)
        }
        if (!viewModel.hasAttestKey) {
            menu.removeItem(R.id.menu_use_attest_key)
            menu.removeItem(R.id.menu_import_attest_key)
        }
        if (!viewModel.hasDeviceIds) {
            menu.removeItem(R.id.menu_include_props)
            menu.removeItem(R.id.menu_id_type_serial)
            menu.removeItem(R.id.menu_id_type_imei)
            menu.removeItem(R.id.menu_id_type_meid)
        }
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) {
            menu.removeItem(R.id.menu_include_props)
        }
        if (!viewModel.hasIMEI) {
            menu.removeItem(R.id.menu_id_type_imei)
        }
        if (!viewModel.hasMEID) {
            menu.removeItem(R.id.menu_id_type_meid)
        }
    }

    override fun onMenuItemSelected(item: MenuItem): Boolean {
        val status = !item.isChecked
        item.isChecked = status
        when (item.itemId) {
            R.id.menu_use_shizuku -> {
                viewModel.preferShizuku = status
                viewModel.load()
            }
            R.id.menu_use_sak -> {
                viewModel.preferSak = status
                viewModel.load()
            }
            R.id.menu_use_strongbox -> {
                viewModel.preferStrongBox = status
                viewModel.load()
            }
            R.id.menu_use_attest_key -> {
                viewModel.preferAttestKey = status
                viewModel.load()
            }
            R.id.menu_include_props -> {
                viewModel.preferIncludeProps = status
                viewModel.load()
            }
            R.id.menu_id_type_serial -> {
                viewModel.preferIdAttestationSerial = status
                viewModel.load()
            }
            R.id.menu_id_type_imei -> {
                viewModel.preferIdAttestationIMEI = status
                viewModel.load()
            }
            R.id.menu_id_type_meid -> {
                viewModel.preferIdAttestationMEID = status
                viewModel.load()
            }
            R.id.menu_include_unique_id -> {
                viewModel.preferIncludeUniqueId = status
                viewModel.load()
            }
            R.id.menu_rkp_test -> {
                viewModel.rkp()
            }
            R.id.menu_reset -> {
                viewModel.load(true)
            }
            R.id.menu_save -> {
                save.launch("${Build.PRODUCT}-${AppApplication.TAG}.p7b")
            }
            R.id.menu_load -> {
                load.launch("*/*")
            }
            R.id.menu_import_attest_key -> {
                import.launch("text/xml")
            }
            R.id.menu_about -> {
                showAboutDialog()
            }
            else -> return false
        }
        return true
    }

    private fun showAboutDialog() {
        val context = requireContext()
        val text = StringBuilder()
        val source = "<b><a href=\"${context.getString(R.string.github_url)}\">GitHub</a></b>"
        val shizuku = "<b><a href=\"${context.getString(R.string.shizuku_url)}\">Web</a></b>"
        text.append(BuildConfig.VERSION_NAME).append("<p>")
        text.append(getString(R.string.open_source_info, source, context.getString(R.string.license)))
        if (Shizuku.pingBinder()) {
            KeyStoreManager.requestPermission()
        } else if (KeyStoreManager.isShizukuInstalled()) {
            KeyStoreManager.requestBinder(context)
            text.append("<p>").append(context.getString(R.string.start_shizuku))
        } else {
            text.append("<p>").append(context.getString(R.string.install_shizuku, shizuku))
        }
        text.append("<p>").append(context.getString(R.string.copyright))
        val icon = context.getDrawable(R.drawable.ic_launcher)
        val dialog: Dialog = AlertDialog.Builder(context)
                .setView(rikka.material.R.layout.dialog_about)
                .show()
        dialog.findViewById<TextView>(rikka.material.R.id.design_about_info).isVisible = false
        dialog.findViewById<ImageView>(rikka.material.R.id.design_about_icon).setImageDrawable(icon)
        dialog.findViewById<TextView>(rikka.material.R.id.design_about_title).text = getString(R.string.app_name)
        dialog.findViewById<TextView>(rikka.material.R.id.design_about_version).apply {
            movementMethod = LinkMovementMethod.getInstance()
            this.text = text.toHtml(HtmlCompat.FROM_HTML_OPTION_TRIM_WHITESPACE)
        }

    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/HomeItemDecoration.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.content.Context
import android.graphics.Canvas
import android.graphics.Rect
import android.graphics.drawable.Drawable
import android.view.View
import androidx.recyclerview.widget.RecyclerView
import androidx.recyclerview.widget.RecyclerView.ItemDecoration
import rikka.core.res.resolveDrawable
import kotlin.math.roundToInt

class HomeItemDecoration(context: Context) : ItemDecoration() {

    private val drawable: Drawable = context.theme.resolveDrawable(rikka.material.R.attr.outlineButtonBackground)!!
    private val cardMargin: Int = (context.resources.displayMetrics.density * 8).roundToInt()
    private val cardPadding: Int = (context.resources.displayMetrics.density * 8).roundToInt()

    private fun hasTopMargin(@Suppress("UNUSED_PARAMETER") adapter: HomeAdapter, position: Int): Boolean {
        return position == 0
    }

    private fun hasBottomMargin(adapter: HomeAdapter, position: Int): Boolean {
        return position == adapter.itemCount - 1 || !(adapter.allowFrameAt(position) && adapter.allowFrameAt(position + 1) && !adapter.shouldCommitFrameAt(position))
    }

    private fun hasTopPadding(adapter: HomeAdapter, position: Int): Boolean {
        return adapter.allowFrameAt(position) && (position == 0 || adapter.shouldCommitFrameAt(position - 1) || !adapter.allowFrameAt(position - 1))
    }

    private fun hasBottomPadding(adapter: HomeAdapter, position: Int): Boolean {
        return adapter.shouldCommitFrameAt(position)// && (position == adapter.itemCount - 1 || adapter.shouldCommitFrameAt(position))
    }

    override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State) {
        val adapter = parent.adapter as HomeAdapter
        val position = parent.getChildAdapterPosition(view)

        if (hasTopMargin(adapter, position)) {
            outRect.top = cardMargin
        }
        if (hasTopPadding(adapter, position)) {
            outRect.top += cardPadding
        }

        if (hasBottomMargin(adapter, position)) {
            outRect.bottom = cardMargin
        }
        if (hasBottomPadding(adapter, position)) {
            outRect.bottom += cardPadding
        }

        outRect.left = cardMargin
        outRect.right = cardMargin
    }

    override fun onDrawOver(c: Canvas, parent: RecyclerView, state: RecyclerView.State) {
        if (parent.childCount == 0) {
            return
        }
        val adapter = parent.adapter as HomeAdapter
        var invalidatedPosition = true
        var left = 0
        var top = 0
        var right = 0
        var bottom: Int

        for (i in 0 until parent.childCount) {
            val child = parent.getChildAt(i)
            val position = parent.getChildAdapterPosition(child)

            if (!adapter.allowFrameAt(position)) {
                continue
            }

            if (invalidatedPosition) {
                left = child.left
                top = child.top
                right = child.right
                invalidatedPosition = false
            }

            if ((i == parent.childCount - 1) || adapter.shouldCommitFrameAt(position)) {
                bottom = child.bottom

                drawable.setBounds(left, top - cardPadding, right, bottom + cardPadding)
                drawable.draw(c)

                invalidatedPosition = true
            } else {
                left = child.left.coerceAtLeast(left)
                right = child.right.coerceAtLeast(right)
            }
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/HomeViewHolder.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.view.View
import androidx.viewbinding.ViewBinding
import io.github.vvb2060.keyattestation.util.ViewBindingViewHolder

abstract class HomeViewHolder<T, VB : ViewBinding>(itemView: View, binding: VB) : ViewBindingViewHolder<T, VB, HomeAdapter.Listener>(itemView, binding)
```

`app/src/main/java/io/github/vvb2060/keyattestation/home/HomeViewModel.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.app.admin.DevicePolicyManager
import android.content.ContentResolver
import android.content.Context
import android.content.SharedPreferences
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.provider.OpenableColumns
import android.util.Log
import androidx.core.content.edit
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.ViewModelProvider.AndroidViewModelFactory.Companion.APPLICATION_KEY
import androidx.lifecycle.viewmodel.initializer
import androidx.lifecycle.viewmodel.viewModelFactory
import com.samsung.android.security.keystore.AttestationUtils
import io.github.vvb2060.keyattestation.AppApplication
import io.github.vvb2060.keyattestation.keystore.KeyStoreManager
import io.github.vvb2060.keyattestation.repository.AttestationRepository
import io.github.vvb2060.keyattestation.repository.BaseData
import io.github.vvb2060.keyattestation.util.Resource
import rikka.shizuku.Shizuku

class HomeViewModel(
        pm: PackageManager,
        private val cr: ContentResolver,
        private val sp: SharedPreferences,
) : ViewModel() {
    companion object {
        val Factory: ViewModelProvider.Factory = viewModelFactory {
            initializer {
                val app = this[APPLICATION_KEY]!!
                val sp = app.getSharedPreferences("settings", Context.MODE_PRIVATE)
                HomeViewModel(app.packageManager, app.contentResolver, sp)
            }
        }
    }

    private val attestationRepository = AttestationRepository()
    private val attestationData = MutableLiveData<Resource<BaseData>>()

    val hasStrongBox = Build.VERSION.SDK_INT >= Build.VERSION_CODES.P &&
            pm.hasSystemFeature(PackageManager.FEATURE_STRONGBOX_KEYSTORE)
    var preferStrongBox = sp.getBoolean("prefer_strongbox", true)
        set(value) {
            field = value
            sp.edit { putBoolean("prefer_strongbox", value) }
        }

    val hasAttestKey = Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
            pm.hasSystemFeature(PackageManager.FEATURE_KEYSTORE_APP_ATTEST_KEY)
    var preferAttestKey = sp.getBoolean("prefer_attest_key", true)
        set(value) {
            field = value
            sp.edit { putBoolean("prefer_attest_key", value) }
        }

    val hasDeviceIds = Build.VERSION.SDK_INT >= Build.VERSION_CODES.P &&
            pm.hasSystemFeature("android.software.device_id_attestation")
    var preferIncludeProps = sp.getBoolean("prefer_include_props", true)
        set(value) {
            field = value
            sp.edit { putBoolean("prefer_include_props", value) }
        }

    var preferShizuku = false
        set(value) {
            field = value
            attestationRepository.useRemoteKeyStore(value)
        }

    var preferIdAttestationSerial = sp.getBoolean("prefer_id_attestation_serial", true)
        set(value) {
            field = value
            sp.edit { putBoolean("prefer_id_attestation_serial", value) }
        }

    val hasIMEI = pm.hasSystemFeature(PackageManager.FEATURE_TELEPHONY_GSM)
    var preferIdAttestationIMEI = sp.getBoolean("prefer_id_attestation_IMEI", true)
        set(value) {
            field = value
            sp.edit { putBoolean("prefer_id_attestation_IMEI", value) }
        }

    val hasMEID = pm.hasSystemFeature(PackageManager.FEATURE_TELEPHONY_CDMA)
    var preferIdAttestationMEID = sp.getBoolean("prefer_id_attestation_MEID", true)
        set(value) {
            field = value
            sp.edit { putBoolean("prefer_id_attestation_MEID", value) }
        }

    val canIncludeUniqueId: Boolean
        get() {
            if (KeyStoreManager.getRemoteKeyStore() == null) return false
            val name = "android.permission.REQUEST_UNIQUE_ID_ATTESTATION"
            return Shizuku.checkRemotePermission(name) == PackageManager.PERMISSION_GRANTED
        }
    var preferIncludeUniqueId = sp.getBoolean("prefer_include_unique_id", true)
        set(value) {
            field = value
            sp.edit { putBoolean("prefer_include_unique_id", value) }
        }

    val hasSak = Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q &&
            runCatching { AttestationUtils.DEFAULT_KEYSTORE }.isSuccess
    val canSak: Boolean
        get() {
            if (KeyStoreManager.getRemoteKeyStore() == null) return false
            val name = "com.samsung.android.security.permission.SAMSUNG_KEYSTORE_PERMISSION"
            return Shizuku.checkRemotePermission(name) == PackageManager.PERMISSION_GRANTED
        }
    var preferSak = sp.getBoolean("prefer_sak", false)
        set(value) {
            field = value
            sp.edit { putBoolean("prefer_sak", value) }
        }

    val canCheckRkp: Boolean
        get() {
            if (KeyStoreManager.getRemoteKeyStore() == null) return false
            return attestationRepository.canRkp(false)
        }

    init {
        load()
    }

    fun hasCertificates() = attestationRepository.hasCertificates()

    fun getAttestationData(): LiveData<Resource<BaseData>> = attestationData

    fun save(uri: Uri?) = AppApplication.executor.execute {
        if (uri == null || !attestationRepository.hasCertificates()) return@execute

        var name = uri.toString()
        val projection = arrayOf(OpenableColumns.DISPLAY_NAME)
        cr.query(uri, projection, null, null, null)?.use { cursor ->
            val displayNameColumn = cursor.getColumnIndexOrThrow(OpenableColumns.DISPLAY_NAME)
            if (cursor.moveToFirst()) {
                name = cursor.getString(displayNameColumn)
            }
        }

        try {
            cr.openOutputStream(uri).use {
                attestationRepository.saveCerts(it)
            }
            AppApplication.toast(name)
        } catch (e: Exception) {
            Log.e(AppApplication.TAG, "save: ", e)
            AppApplication.toast(e.message)
        }
    }

    fun load(uri: Uri?) = AppApplication.executor.execute {
        if (uri == null) return@execute

        attestationData.postValue(Resource.loading(null))

        val result = cr.openFileDescriptor(uri, "r").use {
            attestationRepository.loadCerts(it)
        }

        attestationData.postValue(result)
    }

    fun load(reset: Boolean = false) = AppApplication.executor.execute {
        attestationData.postValue(Resource.loading(null))

        var uniqueIdIncluded = false
        var useSak = false
        var idFlags = 0
        if (preferShizuku) {
            uniqueIdIncluded = canIncludeUniqueId && preferIncludeUniqueId
            useSak = hasSak && canSak && preferSak
            if (hasDeviceIds) {
                if (preferIdAttestationSerial) idFlags = DevicePolicyManager.ID_TYPE_SERIAL
                if (hasIMEI && preferIdAttestationIMEI) idFlags = idFlags or DevicePolicyManager.ID_TYPE_IMEI
                if (hasMEID && preferIdAttestationMEID) idFlags = idFlags or DevicePolicyManager.ID_TYPE_MEID
            }
        }
        val useAttestKey = hasAttestKey && preferAttestKey && !useSak
        val useStrongBox = hasStrongBox && preferStrongBox && !useSak
        val includeProps = hasDeviceIds && preferIncludeProps &&
                Build.VERSION.SDK_INT >= Build.VERSION_CODES.S


        val result = attestationRepository.attest(reset, useAttestKey, useStrongBox,
                includeProps, uniqueIdIncluded, idFlags, useSak)

        attestationData.postValue(result)
    }

    fun import(uri: Uri?) = AppApplication.executor.execute {
        if (uri == null || !hasAttestKey) return@execute

        val useStrongBox = hasStrongBox && preferStrongBox
        try {
            cr.openFileDescriptor(uri, "r").use {
                attestationRepository.importKeyBox(useStrongBox, it)
            }
            load()
        } catch (e: Exception) {
            Log.e(AppApplication.TAG, "import: ", e)
            AppApplication.toast(e.message)
        }
    }

    fun rkp(newHostname: String? = null) = AppApplication.executor.execute {
        if (!canCheckRkp && !preferShizuku) return@execute

        attestationData.postValue(Resource.loading(null))

        val useStrongBox = hasStrongBox && preferStrongBox && attestationRepository.canRkp(true)
        attestationRepository.setHostname(newHostname)
        val result = attestationRepository.checkRkp(useStrongBox)

        attestationData.postValue(result)
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/SubtitleViewHolder.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.view.View
import io.github.vvb2060.keyattestation.databinding.HomeSubtitleBinding

class SubtitleViewHolder(itemView: View, binding: HomeSubtitleBinding) :
    HomeViewHolder<Data, HomeSubtitleBinding>(itemView, binding) {

    companion object {

        val CREATOR = Creator<Data> { inflater, parent ->
            val binding = HomeSubtitleBinding.inflate(inflater, parent, false)
            SubtitleViewHolder(binding.root, binding)
        }
    }

    init {
        itemView.setOnClickListener {
            listener.onCommonDataClick(data)
        }
    }

    override fun onBind() {
        binding.title.setText(data.title)
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/keystore/AndroidKeyStore.java`:

```java
package io.github.vvb2060.keyattestation.keystore;

import android.annotation.SuppressLint;
import android.app.ActivityThread;
import android.app.Application;
import android.app.Instrumentation;
import android.app.admin.DevicePolicyManager;
import android.content.Context;
import android.hardware.security.keymint.DeviceInfo;
import android.hardware.security.keymint.RpcHardwareInfo;
import android.os.Binder;
import android.os.Build;
import android.os.Parcel;
import android.os.ParcelFileDescriptor;
import android.os.Process;
import android.os.RemoteException;
import android.os.SystemProperties;
import android.security.keystore.AttestationUtils;
import android.security.keystore.DeviceIdAttestationException;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyGenParameterSpec_rename;
import android.security.keystore.KeyProperties;
import android.security.keystore.KeyProtection;
import android.system.Os;
import android.util.Log;

import com.samsung.android.security.keystore.AttestParameterSpec;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.cert.CertificateEncodingException;
import java.security.spec.ECGenParameterSpec;
import java.util.Arrays;
import java.util.Date;
import java.util.Objects;

import javax.security.auth.x500.X500Principal;

import io.github.vvb2060.keyattestation.AppApplication;
import io.github.vvb2060.keyattestation.BuildConfig;
import rikka.shizuku.ShizukuApiConstants;

public class AndroidKeyStore extends IAndroidKeyStore.Stub {
    private final KeyStore keyStore;
    private final KeyPairGenerator keyPairGenerator;
    private int clientUid = -1;

    public AndroidKeyStore() throws Exception {
        if (Os.geteuid() < Process.FIRST_APPLICATION_UID) {
            fixEnv();
            var pm = ActivityThread.currentApplication().getPackageManager();
            clientUid = pm.getApplicationInfo(BuildConfig.APPLICATION_ID, 0).uid;
        }
        keyStore = KeyStore.getInstance("AndroidKeyStore");
        keyStore.load(null);
        keyPairGenerator = KeyPairGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_EC, "AndroidKeyStore");
    }

    private static void fixEnv() throws Exception {
        var packageName = "com.android.shell";
        switch (Os.geteuid()) {
            case Process.ROOT_UID:
                if (Os.gettid() == Os.getpid()) {
                    Os.seteuid(Process.SYSTEM_UID);
                } else {
                    throw new RuntimeException("tid!=pid");
                }
            case Process.SYSTEM_UID:
                packageName = "android";
            case Process.SHELL_UID: {
                break;
            }
            default:
                throw new RuntimeException("unexpected uid");
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            ActivityThread.initializeMainlineModules();
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            android.security.keystore2.AndroidKeyStoreProvider.install();
        } else {
            android.security.keystore.AndroidKeyStoreProvider.install();
        }

        var activityThread = ActivityThread.systemMain();
        Context systemContext = activityThread.getSystemContext();
        var flags = Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY;
        var context = systemContext.createPackageContext(packageName, flags);
        var mPackageInfo = context.getClass().getDeclaredField("mPackageInfo");
        mPackageInfo.setAccessible(true);
        var loadedApk = mPackageInfo.get(context);
        var makeApplication = loadedApk.getClass().getDeclaredMethod("makeApplication",
                boolean.class, Instrumentation.class);
        var application = (Application) makeApplication.invoke(loadedApk, true, null);
        ContextHook.hook(application);
        var mInitialApplication = ActivityThread.class.getDeclaredField("mInitialApplication");
        mInitialApplication.setAccessible(true);
        mInitialApplication.set(activityThread, application);
    }

    @Override
    @SuppressLint("RestrictedApi")
    public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
        var callingUid = Binder.getCallingUid();
        if (callingUid != clientUid
                && callingUid != Process.SHELL_UID
                && callingUid != Process.ROOT_UID
                && callingUid != Process.SYSTEM_UID) {
            return false;
        }
        if (code == ShizukuApiConstants.USER_SERVICE_TRANSACTION_destroy) {
            System.exit(0);
        }
        return super.onTransact(code, data, reply, flags);
    }

    @Override
    public byte[] getCertificateChain(String alias) {
        try {
            var chain = keyStore.getCertificateChain(alias);
            if (chain == null) {
                return null;
            }
            var buf = new ByteArrayOutputStream(8192);
            for (var cert : chain) {
                buf.write(cert.getEncoded());
            }
            return buf.toByteArray();
        } catch (Exception e) {
            Log.e(AppApplication.TAG, "getCertificateChain", e);
            throw new IllegalStateException(e.getMessage());
        }
    }

    @Override
    public boolean containsAlias(String alias) {
        try {
            return keyStore.containsAlias(alias);
        } catch (KeyStoreException e) {
            Log.e(AppApplication.TAG, "containsAlias", e);
            throw new IllegalStateException(e.getMessage());
        }
    }

    @Override
    public void deleteAllEntry() {
        try {
            var aliases = keyStore.aliases();
            while (aliases.hasMoreElements()) {
                var alias = aliases.nextElement();
                keyStore.deleteEntry(alias);
            }
        } catch (KeyStoreException e) {
            Log.e(AppApplication.TAG, "deleteAllEntry", e);
            throw new IllegalStateException(e.getMessage());
        }
    }

    @Override
    public void importKeyBox(String alias, boolean useStrongBox, ParcelFileDescriptor pfd) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) {
            throw new IllegalStateException();
        }
        try (var in = new ParcelFileDescriptor.AutoCloseInputStream(pfd)) {
            var key = KeyBoxXmlParser.getInstance().parse(in);
            var builder = new KeyProtection.Builder(KeyProperties.PURPOSE_ATTEST_KEY)
                    .setDigests(KeyProperties.DIGEST_SHA256);
            if (useStrongBox) {
                builder.setIsStrongBoxBacked(true);
            }
            keyStore.setEntry(alias, key, builder.build());
            if (keyStore.getCertificate(alias) == null) {
                throw new IllegalStateException("import failed");
            }
        } catch (IOException | KeyStoreException e) {
            Log.e(AppApplication.TAG, "importKeyBox", e);
            throw new IllegalStateException(e.getMessage());
        }
    }

    private static int[] flagsToArray(int idFlags) {
        int i = 0;
        var array = new int[3];
        if ((idFlags & DevicePolicyManager.ID_TYPE_SERIAL) != 0) {
            array[i++] = 1;
        }
        if ((idFlags & DevicePolicyManager.ID_TYPE_IMEI) != 0) {
            array[i++] = 2;
        }
        if ((idFlags & DevicePolicyManager.ID_TYPE_MEID) != 0) {
            array[i++] = 3;
        }
        return Arrays.copyOf(array, i);
    }

    private static Object genParameter(String alias,
                                       String attestKeyAlias,
                                       boolean useStrongBox,
                                       boolean includeProps,
                                       boolean uniqueIdIncluded,
                                       int[] attestationIds) {
        var now = new Date();
        boolean attestKey = Objects.equals(alias, attestKeyAlias);
        var purposes = attestKey ? KeyProperties.PURPOSE_ATTEST_KEY : KeyProperties.PURPOSE_SIGN;

        var builder = new KeyGenParameterSpec_rename.Builder(alias, purposes)
                .setAlgorithmParameterSpec(new ECGenParameterSpec("secp256r1"))
                .setDigests(KeyProperties.DIGEST_SHA256)
                .setCertificateNotBefore(now)
                .setAttestationChallenge(now.toString().getBytes());
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P && useStrongBox) {
            builder.setIsStrongBoxBacked(true);
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            if (includeProps) {
                builder.setDevicePropertiesAttestationIncluded(true);
            }
            if (attestationIds != null) {
                builder.setAttestationIds(attestationIds);
            }
            if (attestKey) {
                builder.setCertificateSubject(new X500Principal("CN=App Attest Key"));
            } else {
                builder.setAttestKeyAlias(attestKeyAlias);
            }
        }
        if (uniqueIdIncluded) {
            builder.setUniqueIdIncluded(true);
        }
        return builder.build();
    }

    private static AttestParameterSpec genSakParameter(KeyGenParameterSpec params) {
        var alias = params.getKeystoreAlias();
        var challenge = params.getAttestationChallenge();
        var packageName = ActivityThread.currentApplication().getPackageName();
        var builder = new AttestParameterSpec.Builder(alias, challenge)
                .setAlgorithm(KeyProperties.KEY_ALGORITHM_EC)
                .setKeyGenParameterSpec(params)
                .setVerifiableIntegrity(true)
                .setDeviceAttestation(true)
                .setPackageName(packageName);
        return builder.build();
    }

    @Override
    public byte[] generateKeyPair(String alias,
                                  String attestKeyAlias,
                                  boolean useStrongBox,
                                  boolean includeProps,
                                  boolean uniqueIdIncluded,
                                  int idFlags,
                                  boolean useSak) {
        var params = (KeyGenParameterSpec) genParameter(alias, attestKeyAlias, useStrongBox,
                includeProps, uniqueIdIncluded, flagsToArray(idFlags));
        try {
            keyPairGenerator.initialize(params);
            keyPairGenerator.generateKeyPair();
            if (useSak) {
                var utils = new com.samsung.android.security.keystore.AttestationUtils();
                var spec = genSakParameter(params);
                Iterable<byte[]> certChain;
                if (spec.isDeviceAttestation()) {
                    certChain = utils.attestDevice(spec);
                } else {
                    certChain = utils.attestKey(spec);
                }
                utils.storeCertificateChain(alias, certChain);
            }
            return null;
        } catch (Exception exception) {
            Log.e(AppApplication.TAG, "generateKeyPair", exception);
            var buf = new ByteArrayOutputStream(2048);
            try (var out = new ObjectOutputStream(buf)) {
                out.writeObject(exception);
            } catch (IOException e) {
                throw new IllegalStateException(e.getMessage());
            }
            return buf.toByteArray();
        }
    }

    @Override
    public byte[] attestDeviceIds(int idFlags) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S
                || Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
            throw new IllegalStateException();
        }
        var context = ActivityThread.currentApplication();
        var attestationIds = flagsToArray(idFlags);
        var challenge = new Date().toString().getBytes();
        try {
            var chain = AttestationUtils.attestDeviceIds(context, attestationIds, challenge);
            var buf = new ByteArrayOutputStream(8192);
            buf.write(1);
            for (var cert : chain) {
                buf.write(cert.getEncoded());
            }
            return buf.toByteArray();
        } catch (DeviceIdAttestationException exception) {
            Log.e(AppApplication.TAG, "attestDeviceIds", exception);
            var buf = new ByteArrayOutputStream(2048);
            buf.write(0);
            try (var out = new ObjectOutputStream(buf)) {
                out.writeObject(exception);
            } catch (IOException e) {
                throw new IllegalStateException(e.getMessage());
            }
            return buf.toByteArray();
        } catch (CertificateEncodingException | IOException e) {
            throw new IllegalStateException(e.getMessage());
        }
    }

    @Override
    public void setRkpHostname(String hostname) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
            throw new IllegalStateException();
        }
        SystemProperties.set(RemoteProvisioning.PROP_NAME, hostname);
    }

    @Override
    public String getRkpHostname() {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
            throw new IllegalStateException();
        }
        return SystemProperties.get(RemoteProvisioning.PROP_NAME);
    }

    @Override
    public boolean canRemoteProvisioning(boolean useStrongBox) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) {
            throw new IllegalStateException();
        }
        var rkp = RemoteProvisioning.getInstance(useStrongBox);
        return rkp.isSupported();
    }

    @Override
    public RpcHardwareInfo getHardwareInfo(boolean useStrongBox, DeviceInfo deviceInfo) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) {
            throw new IllegalStateException();
        }
        try {
            var rkp = RemoteProvisioning.getInstance(useStrongBox);
            rkp.localCsr();
            deviceInfo.deviceInfo = rkp.getDeviceInfo();
            return rkp.getHardwareInfo();
        } catch (Exception e) {
            Log.e(AppApplication.TAG, "getHardwareInfo", e);
            throw new IllegalStateException(e.getMessage());
        }
    }

    @Override
    public byte[] checkRemoteProvisioning(boolean useStrongBox) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) {
            throw new IllegalStateException();
        }
        try {
            var rkp = RemoteProvisioning.getInstance(useStrongBox);
            return rkp.check();
        } catch (Exception e) {
            Log.e(AppApplication.TAG, "checkRemoteProvisioning", e);
            throw new IllegalStateException(e.getMessage());
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/keystore/ContextHook.java`:

```java
package io.github.vvb2060.keyattestation.keystore;

import android.content.Context;
import android.content.ContextWrapper;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.SystemProperties;
import android.telephony.TelephonyManager_rename;
import android.util.Log;

import java.util.concurrent.Executor;

import io.github.vvb2060.keyattestation.AppApplication;

public class ContextHook extends ContextWrapper {
    private final TelephonyManager_rename telephonyService = new TelephonyManager_rename(this) {
        @Override
        public String getImei(int slotIndex) {
            String imei = null;
            try {
                imei = super.getImei(slotIndex);
            } catch (SecurityException e) {
                Log.w(AppApplication.TAG, "getImei", e);
            }
            if (imei == null) {
                var slot = slotIndex == 0 ? "" : "2";
                var prop = SystemProperties.get("ro.ril.oem.imei" + slot);
                return prop.isEmpty() ? null : prop;
            }
            return imei;
        }

        @Override
        public String getMeid(int slotIndex) {
            String meid = null;
            try {
                meid = super.getMeid(slotIndex);
            } catch (SecurityException e) {
                Log.w(AppApplication.TAG, "getMeid", e);
            }
            if (meid == null) {
                var prop = SystemProperties.get("ro.ril.oem.meid");
                return prop.isEmpty() ? null : prop;
            }
            return meid;
        }
    };

    private ContextHook(Context base) {
        super(base);
    }

    @Override
    public Object getSystemService(String name) {
        if (Context.TELEPHONY_SERVICE.equals(name)) {
            return telephonyService;
        }
        return super.getSystemService(name);
    }

    @Override
    public boolean bindService(Intent service, int flags, Executor executor, ServiceConnection conn) {
        return false;
    }

    @Override
    public boolean bindService(Intent service, ServiceConnection conn, int flags) {
        return false;
    }

    public static void hook(ContextWrapper context) throws Exception {
        var wrapper = new ContextHook(context.getBaseContext());
        //noinspection JavaReflectionMemberAccess DiscouragedPrivateApi
        var base = ContextWrapper.class.getDeclaredField("mBase");
        base.setAccessible(true);
        base.set(context, wrapper);
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/keystore/KeyBoxXmlParser.java`:

```java
package io.github.vvb2060.keyattestation.keystore;

import android.util.Base64;
import android.util.Xml;

import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
import org.bouncycastle.asn1.sec.ECPrivateKey;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.asn1.x9.X9ObjectIdentifiers;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.security.KeyFactory;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.ArrayList;
import java.util.List;

public class KeyBoxXmlParser {
    private final XmlPullParser parser;
    private final CertificateFactory certificateFactory;
    private final List<Certificate> chain;
    private PrivateKey privateKey;

    private static KeyBoxXmlParser instance;

    public static KeyBoxXmlParser getInstance() throws IOException {
        if (instance == null) {
            instance = new KeyBoxXmlParser();
        }
        return instance;
    }

    private KeyBoxXmlParser() throws IOException {
        parser = Xml.newPullParser();
        chain = new ArrayList<>();
        try {
            certificateFactory = CertificateFactory.getInstance("X.509");
        } catch (GeneralSecurityException e) {
            throw new IOException(e);
        }
    }

    public KeyStore.PrivateKeyEntry parse(InputStream in) throws IOException {
        try {
            parser.setInput(in, StandardCharsets.UTF_8.name());
            chain.clear();
            privateKey = null;
            readAndroidAttestation();
        } catch (XmlPullParserException e) {
            throw new IOException(e);
        }
        if (privateKey == null || chain.isEmpty()) {
            throw new IOException("No key found");
        }
        return new KeyStore.PrivateKeyEntry(privateKey, chain.toArray(new Certificate[0]));
    }

    private void readAndroidAttestation() throws XmlPullParserException, IOException {
        while (parser.next() != XmlPullParser.END_DOCUMENT) {
            if (parser.getEventType() != XmlPullParser.START_TAG) {
                continue;
            }
            var name = parser.getName();
            var algorithm = parser.getAttributeValue(null, "algorithm");
            if ("Key".equals(name) && "ecdsa".equals(algorithm)) {
                parser.nextTag();
                readECKey();
                break;
            }
        }
    }

    private void readECKey() throws XmlPullParserException, IOException {
        while (!(parser.getEventType() == XmlPullParser.END_TAG && "Key".equals(parser.getName()))) {
            if (parser.getEventType() != XmlPullParser.START_TAG) {
                parser.next();
                continue;
            }
            var format = parser.getAttributeValue(null, "format");
            switch (parser.getName()) {
                case "PrivateKey" -> {
                    if ("pem".equals(format)) {
                        parser.next();
                        readPrivateKey(parser.getText());
                        parser.next();
                    } else {
                        return;
                    }
                }
                case "Certificate" -> {
                    if ("pem".equals(format)) {
                        parser.next();
                        readCertificateChain(parser.getText());
                        parser.next();
                    } else {
                        return;
                    }
                }
                default -> parser.next();
            }
        }
    }

    private static byte[] stringToBytes(String text) {
        var sb = new StringBuilder();
        for (var s : text.split("\n")) {
            var line = s.trim();
            if (line.isEmpty()) continue;
            if (line.charAt(0) == '-') continue;
            sb.append(line);
            sb.append("\n");
        }
        return Base64.decode(sb.toString(), 0);
    }

    private void readPrivateKey(String text) throws IOException {
        try {
            var sequence = ASN1Sequence.getInstance(stringToBytes(text));
            var ecKey = ECPrivateKey.getInstance(sequence);
            var id = new AlgorithmIdentifier(X9ObjectIdentifiers.id_ecPublicKey,
                    ecKey.getParametersObject());
            var data = new PrivateKeyInfo(id, ecKey).getEncoded();
            var keySpec = new PKCS8EncodedKeySpec(data);
            var keyFactory = KeyFactory.getInstance("EC");
            privateKey = keyFactory.generatePrivate(keySpec);
        } catch (GeneralSecurityException e) {
            throw new IOException(e);
        }
    }

    private void readCertificateChain(String text) throws IOException {
        try {
            var data = new ByteArrayInputStream(stringToBytes(text));
            chain.add(certificateFactory.generateCertificate(data));
        } catch (CertificateException e) {
            throw new IOException(e);
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/keystore/KeyStoreManager.java`:

```java
package io.github.vvb2060.keyattestation.keystore;

import android.annotation.SuppressLint;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.os.Binder;
import android.os.Bundle;
import android.os.IBinder;
import android.os.Parcel;
import android.os.RemoteException;
import android.util.Log;

import androidx.annotation.NonNull;

import io.github.vvb2060.keyattestation.AppApplication;
import io.github.vvb2060.keyattestation.BuildConfig;
import rikka.shizuku.Shizuku;

public class KeyStoreManager {
    private static IAndroidKeyStore remoteKeyStore;
    private static boolean installed;

    public static IAndroidKeyStore getRemoteKeyStore() {
        return remoteKeyStore;
    }

    public static boolean isShizukuInstalled() {
        return installed;
    }

    private static void bindUserService() {
        if (remoteKeyStore != null) {
            return;
        }
        var name = new ComponentName(BuildConfig.APPLICATION_ID, AndroidKeyStore.class.getName());
        var args = new Shizuku.UserServiceArgs(name)
                .daemon(false)
                .debuggable(BuildConfig.DEBUG)
                .version(BuildConfig.VERSION_CODE)
                .processNameSuffix("keystore");
        var connection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                remoteKeyStore = IAndroidKeyStore.Stub.asInterface(service);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                remoteKeyStore = null;
            }
        };
        Shizuku.bindUserService(args, connection);
    }

    public static void requestPermission() {
        if (Shizuku.checkSelfPermission() == PackageManager.PERMISSION_GRANTED) {
            bindUserService();
        } else if (Shizuku.shouldShowRequestPermissionRationale()) {
            Log.w(AppApplication.TAG, "shizuku permission denied");
        } else {
            Shizuku.addRequestPermissionResultListener(new Shizuku.OnRequestPermissionResultListener() {
                @Override
                public void onRequestPermissionResult(int requestCode, int grantResult) {
                    Shizuku.removeRequestPermissionResultListener(this);
                    if (grantResult == PackageManager.PERMISSION_GRANTED) {
                        bindUserService();
                    } else {
                        Log.w(AppApplication.TAG, "shizuku permission denied");
                    }
                }
            });
            Shizuku.requestPermission(0);
        }
    }

    public static void requestBinder(Context context) {
        var receiver = new Binder() {
            @SuppressLint("RestrictedApi")
            @Override
            protected boolean onTransact(int code, @NonNull Parcel data, Parcel reply, int flags) throws RemoteException {
                if (code == 1) {
                    installed = true;
                    var binder = data.readStrongBinder();
                    if (binder != null) {
                        Shizuku.onBinderReceived(binder, BuildConfig.APPLICATION_ID);
                        requestPermission();
                    } else {
                        Log.w(AppApplication.TAG, "shizuku is not running");
                    }

                    return true;
                }
                return super.onTransact(code, data, reply, flags);
            }
        };
        var data = new Bundle();
        data.putBinder("binder", receiver);
        var intent = new Intent("rikka.shizuku.intent.action.REQUEST_BINDER")
                .setPackage("moe.shizuku.privileged.api")
                .addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES)
                .putExtra("data", data);
        context.sendBroadcast(intent);
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/keystore/RemoteProvisioning.java`:

```java
package io.github.vvb2060.keyattestation.keystore;

import android.hardware.security.keymint.DeviceInfo;
import android.hardware.security.keymint.IRemotelyProvisionedComponent;
import android.hardware.security.keymint.MacedPublicKey;
import android.hardware.security.keymint.ProtectedData;
import android.hardware.security.keymint.RpcHardwareInfo;
import android.net.Uri;
import android.os.Build;
import android.os.IBinder;
import android.os.RemoteException;
import android.os.ServiceManager;
import android.os.ServiceSpecificException;
import android.os.SystemProperties;
import android.util.Base64;
import android.util.Log;

import androidx.annotation.RequiresApi;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.SocketTimeoutException;
import java.net.URL;
import java.net.UnknownHostException;
import java.time.Instant;
import java.util.HashMap;
import java.util.UUID;

import javax.net.ssl.HttpsURLConnection;

import co.nstant.in.cbor.CborBuilder;
import co.nstant.in.cbor.CborDecoder;
import co.nstant.in.cbor.CborEncoder;
import co.nstant.in.cbor.CborException;
import co.nstant.in.cbor.model.Array;
import co.nstant.in.cbor.model.ByteString;
import co.nstant.in.cbor.model.DataItem;
import co.nstant.in.cbor.model.Map;
import co.nstant.in.cbor.model.UnicodeString;
import co.nstant.in.cbor.model.UnsignedInteger;
import io.github.vvb2060.keyattestation.AppApplication;

@RequiresApi(Build.VERSION_CODES.S)
class RemoteProvisioning {
    public static final String PROP_NAME = "remote_provisioning.hostname";
    public static final String HOSTNAME = "remoteprovisioning.googleapis.com";
    private static final String EEK_ED25519_BASE64 = """
            goRDoQEnoFgqpAEBAycgBiFYIJm57t1e5FL2hcZMYtw+YatXSH11NymtdoAy0rPL\
            Y1jZWEAeIghLpLekyNdOAw7+uK8UTKc7b6XN3Np5xitk/pk5r3bngPpmAIUNB5gq\
            rJFcpyUUSQY0dcqKJ3rZ41pJ6wIDhEOhASegWE6lAQECWCDQrsEVyirPc65rzMvR\
            lh1l6LHd10oaN7lDOpfVmd+YCAM4GCAEIVggvoXnRsSjQlpA2TY6phXQLFh+Pdwz\
            AjLS/F4ehyVfcmBYQJvPkOIuS6vRGLEOjl0gJ0uEWP78MpB+cgWDvNeCvvpkeC1U\
            EEvAMb9r6B414vAtzmwvT/L1T6XUg62WovGHWAQ=""";
    private static final String EEK_P256_BASE64 = """
            goRDoQEmoFhNpQECAyYgASFYIPcUituX9MxT79JkEcTjdR9mH6RxDGzP+glGgHSH\
            VPKtIlggXn9b9uzk9hnM/xM3/Q+hyJPbGAZ2xF3m12p3hsMtr49YQC+XjkL7vgct\
            lUeFR5NAsB/Um0ekxESp8qEHhxDHn8sR9L+f6Dvg5zRMFfx7w34zBfTRNDztAgRg\
            ehXgedOK/ySEQ6EBJqBYcaYBAgJYIDVztz+gioCJsSZn6ct8daGvAmH8bmUDkTvT\
            S30UlD5GAzgYIAEhWCDgQc8vDzQPHDMsQbDP1wwwVTXSHmpHE0su0UiWfiScaCJY\
            IB/ORcX7YbqBIfnlBZubOQ52hoZHuB4vRfHOr9o/gGjbWECMs7p+ID4ysGjfYNEd\
            ffCsOI5RvP9s4Wc7Snm8Vnizmdh8igfY2rW1f3H02GvfMyc0e2XRKuuGmZirOrSA\
            qr1Q""";

    private static RemoteProvisioning instance_default;
    private static RemoteProvisioning instance_strongbox;

    private final String requestId = UUID.randomUUID().toString();
    private final IRemotelyProvisionedComponent binder;
    private byte[] deviceInfoData;

    private static class EekResponse {
        private final byte[] challenge;
        private final HashMap<Integer, byte[]> curveToGeek = new HashMap<>();

        EekResponse(DataItem response) throws CborException {
            var respItems = ((Array) response).getDataItems();
            var allEekChains = ((Array) respItems.get(0)).getDataItems();
            for (var entry : allEekChains) {
                var curveAndEekChain = ((Array) entry).getDataItems();
                var curve = (UnsignedInteger) curveAndEekChain.get(0);
                var geek = encodeCbor(curveAndEekChain.get(1));
                curveToGeek.put(curve.getValue().intValue(), geek);
            }
            challenge = ((ByteString) respItems.get(1)).getBytes();
        }

        EekResponse() {
            challenge = Instant.now().toString().getBytes();
            curveToGeek.put(RpcHardwareInfo.CURVE_25519, Base64.decode(EEK_ED25519_BASE64, 0));
            curveToGeek.put(RpcHardwareInfo.CURVE_P256, Base64.decode(EEK_P256_BASE64, 0));
        }

        byte[] getEekChain(int curve) {
            return curveToGeek.get(curve);
        }

        byte[] getChallenge() {
            return challenge;
        }
    }

    public static RemoteProvisioning getInstance(boolean useStrongBox) {
        if (useStrongBox) {
            if (instance_strongbox == null) {
                instance_strongbox = new RemoteProvisioning(true);
            }
            return instance_strongbox;
        } else {
            if (instance_default == null) {
                instance_default = new RemoteProvisioning(false);
            }
            return instance_default;
        }
    }

    private RemoteProvisioning(boolean useStrongBox) {
        var instanceName = useStrongBox ? "strongbox" : "default";
        var serviceName = IRemotelyProvisionedComponent.DESCRIPTOR + "/" + instanceName;
        IBinder iBinder = null;
        try {
            iBinder = ServiceManager.waitForDeclaredService(serviceName);
        } catch (SecurityException | NoSuchMethodError ignored) {
        }
        binder = IRemotelyProvisionedComponent.Stub.asInterface(iBinder);
    }

    public boolean isSupported() {
        return binder != null && binder.asBinder().pingBinder();
    }

    public RpcHardwareInfo getHardwareInfo() throws RemoteException {
        return binder.getHardwareInfo();
    }

    public byte[] getDeviceInfo() {
        return deviceInfoData;
    }

    public byte[] check() throws RuntimeException {
        try {
            var eekResponse = fetchEek();
            var csr = generateCsr(eekResponse);
            return signCertificates(csr, eekResponse.getChallenge());
        } catch (SocketTimeoutException | UnknownHostException e) {
            Log.e(AppApplication.TAG, Log.getStackTraceString(e));
            throw new RuntimeException("No network: " + e.getMessage());
        } catch (ServiceSpecificException e) {
            Log.e(AppApplication.TAG, Log.getStackTraceString(e));
            throw new RuntimeException("Error getting CSR: " + e);
        } catch (IOException | CborException | RemoteException e) {
            Log.e(AppApplication.TAG, Log.getStackTraceString(e));
            throw new RuntimeException("Error checking device registration: " + e);
        }
    }

    public void localCsr() throws RuntimeException {
        try {
            var eekResponse = new EekResponse();
            generateCsr(eekResponse);
        } catch (ServiceSpecificException e) {
            Log.e(AppApplication.TAG, Log.getStackTraceString(e));
            throw new RuntimeException("Error getting CSR: " + e);
        } catch (CborException | RemoteException e) {
            Log.e(AppApplication.TAG, Log.getStackTraceString(e));
            throw new RuntimeException("Error checking device registration: " + e);
        }
    }

    private static Uri.Builder getBaseUri() {
        return new Uri.Builder()
                .scheme("https")
                .authority(SystemProperties.get(PROP_NAME, HOSTNAME))
                .appendPath("v1");
    }

    private EekResponse fetchEek() throws IOException, CborException {
        var uri = getBaseUri().appendEncodedPath(":fetchEekChain").build();
        var input = encodeCbor(new CborBuilder()
                .addMap()
                .put("fingerprint", Build.FINGERPRINT)
                .put(new UnicodeString("id"), new UnsignedInteger(0))
                .end()
                .build()
                .get(0));
        return new EekResponse(httpPost(uri, input));
    }

    private byte[] signCertificates(byte[] csr, byte[] challenge)
            throws IOException, CborException {
        var encoded = Base64.encodeToString(challenge, Base64.URL_SAFE | Base64.NO_WRAP);
        var uri = getBaseUri()
                .appendEncodedPath(":signCertificates")
                .appendQueryParameter("challenge", encoded)
                .build();
        var response = httpPost(uri, csr);
        var dataItems = ((Array) response).getDataItems();
        var shared = ((ByteString) dataItems.get(0)).getBytes();
        var leafItem = ((Array) dataItems.get(1)).getDataItems().get(0);
        var leaf = ((ByteString) leafItem).getBytes();
        var full = new byte[leaf.length + shared.length];
        System.arraycopy(leaf, 0, full, 0, leaf.length);
        System.arraycopy(shared, 0, full, leaf.length, shared.length);
        return full;
    }

    private DataItem httpPost(Uri uri, byte[] input) throws IOException, CborException {
        uri = uri.buildUpon().appendQueryParameter("requestId", requestId).build();
        var con = (HttpsURLConnection) new URL(uri.toString()).openConnection();
        con.setRequestMethod("POST");
        con.setConnectTimeout(2_000);
        con.setReadTimeout(20_000);
        con.setDoOutput(true);
        con.setFixedLengthStreamingMode(input.length);

        con.connect();
        try (var os = con.getOutputStream()) {
            os.write(input, 0, input.length);
        }

        var code = con.getResponseCode();
        var body = new ByteArrayOutputStream(8192);
        try (var in = code >= 400 ? con.getErrorStream() : con.getInputStream()) {
            var buffer = new byte[8192];
            int read;
            while ((read = in.read(buffer, 0, buffer.length)) != -1) {
                body.write(buffer, 0, read);
            }
        }
        con.disconnect();

        if (code == 200) {
            return decodeCbor(body.toByteArray());
        } else if (code == 444) {
            throw new RuntimeException("Device not registered.");
        } else {
            throw new RuntimeException(body.toString());
        }
    }

    private byte[] generateCsr(EekResponse eekResponse)
            throws RemoteException, CborException {
        var unverifiedDeviceInfo = new Map().put(
                new UnicodeString("fingerprint"), new UnicodeString(Build.FINGERPRINT));
        var hwInfo = binder.getHardwareInfo();
        var keysToSign = new MacedPublicKey[]{new MacedPublicKey()};
        binder.generateEcdsaP256KeyPair(false, keysToSign[0]);
        if (hwInfo.versionNumber < 3) {
            var deviceInfo = new DeviceInfo();
            var protectedData = new ProtectedData();
            var geekChain = eekResponse.getEekChain(hwInfo.supportedEekCurve);
            var csrTag = binder.generateCertificateRequest(false, keysToSign, geekChain,
                    eekResponse.getChallenge(), deviceInfo, protectedData);
            var mac0Message = buildMac0MessageForV1Csr(keysToSign[0], csrTag);
            deviceInfoData = deviceInfo.deviceInfo;
            return encodeCbor(new CborBuilder()
                    .addArray()
                    .addArray()
                    .add(decodeCbor(deviceInfo.deviceInfo))
                    .add(unverifiedDeviceInfo)
                    .end()
                    .add(eekResponse.getChallenge())
                    .add(decodeCbor(protectedData.protectedData))
                    .add(mac0Message)
                    .end()
                    .build().get(0));
        } else {
            var csrBytes = binder.generateCertificateRequestV2(keysToSign,
                    eekResponse.getChallenge());
            var array = (Array) decodeCbor(csrBytes);
            var deviceInfo = extractDeviceInfoFromV3Csr(array);
            deviceInfoData = encodeCbor(deviceInfo);
            return encodeCbor(array.add(unverifiedDeviceInfo));
        }
    }

    private static Array buildMac0MessageForV1Csr(MacedPublicKey keyToSign, byte[] csrTag)
            throws CborException {
        var macedPayload = ((Array) decodeCbor(keyToSign.macedKey)).getDataItems().get(2);
        var macedCoseKey = (Map) decodeCbor(((ByteString) macedPayload).getBytes());
        var macedKeys = encodeCbor(new Array().add(macedCoseKey));
        var protectedHeaders = new Map().put(
                new UnsignedInteger(1),
                new UnsignedInteger(5));
        return new Array()
                .add(new ByteString(encodeCbor(protectedHeaders)))
                .add(new Map())
                .add(new ByteString(macedKeys))
                .add(new ByteString(csrTag));
    }

    private static Map extractDeviceInfoFromV3Csr(Array csr) throws CborException {
        var signedMap = (Array) csr.getDataItems().get(3);
        var encodedData = (ByteString) signedMap.getDataItems().get(2);
        var decodedPayload = (Array) decodeCbor(encodedData.getBytes());
        var encodedCsrPayload = (ByteString) decodedPayload.getDataItems().get(1);
        var csrPayload = (Array) decodeCbor(encodedCsrPayload.getBytes());
        return (Map) csrPayload.getDataItems().get(2);
    }

    private static DataItem decodeCbor(byte[] encodedBytes) throws CborException {
        return CborDecoder.decode(encodedBytes).get(0);
    }

    private static byte[] encodeCbor(DataItem dataItem) throws CborException {
        var outputStream = new ByteArrayOutputStream(1024);
        new CborEncoder(outputStream).encode(dataItem);
        return outputStream.toByteArray();
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/lang/AttestationException.kt`:

```kt
package io.github.vvb2060.keyattestation.lang

import io.github.vvb2060.keyattestation.R

class AttestationException(code: Int, cause: Throwable) : RuntimeException(cause) {

    companion object {
        const val CODE_UNKNOWN = -1
        const val CODE_UNAVAILABLE = 0
        const val CODE_CANT_PARSE_CERT = 2
        const val CODE_STRONGBOX_UNAVAILABLE = 3
        const val CODE_DEVICEIDS_UNAVAILABLE = 4
        const val CODE_OUT_OF_KEYS = 5
        const val CODE_OUT_OF_KEYS_TRANSIENT = 6
        const val CODE_UNAVAILABLE_TRANSIENT = 7
        const val CODE_KEYS_NOT_PROVISIONED = 8
        const val CODE_RKP = 9
    }

    val titleResId: Int = when (code) {
        CODE_UNAVAILABLE -> R.string.error_unavailable
        CODE_CANT_PARSE_CERT -> R.string.error_cant_parse_cert
        CODE_STRONGBOX_UNAVAILABLE -> R.string.error_strongbox_unavailable
        CODE_DEVICEIDS_UNAVAILABLE -> R.string.error_deviceids_unavailable
        CODE_OUT_OF_KEYS -> R.string.error_out_of_keys
        CODE_OUT_OF_KEYS_TRANSIENT -> R.string.error_out_of_keys_transient
        CODE_UNAVAILABLE_TRANSIENT -> R.string.error_unavailable_transient
        CODE_KEYS_NOT_PROVISIONED -> R.string.error_keys_not_provisioned
        CODE_RKP -> R.string.error_remote_key_provisioning
        else -> R.string.error_unknown
    }

    val descriptionResId: Int = when (code) {
        CODE_UNAVAILABLE -> R.string.error_unavailable_summary
        CODE_CANT_PARSE_CERT -> R.string.error_cant_parse_cert_summary
        CODE_STRONGBOX_UNAVAILABLE -> R.string.error_strongbox_unavailable_summary
        CODE_DEVICEIDS_UNAVAILABLE -> R.string.error_deviceids_unavailable_summary
        CODE_OUT_OF_KEYS -> R.string.error_out_of_keys_summary
        CODE_OUT_OF_KEYS_TRANSIENT -> R.string.error_out_of_keys_transient_summary
        CODE_UNAVAILABLE_TRANSIENT -> R.string.error_unavailable_transient_summary
        CODE_KEYS_NOT_PROVISIONED -> R.string.error_keys_not_provisioned_summary
        CODE_RKP -> R.string.error_remote_key_provisioning_summary
        else -> R.string.error_unknown
    }

    override fun fillInStackTrace() = this
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/repository/AttestationData.java`:

```java
package io.github.vvb2060.keyattestation.repository;

import static io.github.vvb2060.keyattestation.attestation.Attestation.KM_SECURITY_LEVEL_SOFTWARE;
import static io.github.vvb2060.keyattestation.lang.AttestationException.CODE_CANT_PARSE_CERT;

import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import io.github.vvb2060.keyattestation.attestation.Attestation;
import io.github.vvb2060.keyattestation.attestation.CertificateInfo;
import io.github.vvb2060.keyattestation.attestation.RootOfTrust;
import io.github.vvb2060.keyattestation.lang.AttestationException;

public class AttestationData extends BaseData {
    private final RootOfTrust rootOfTrust;
    private final boolean sw;
    public Attestation showAttestation;

    public RootOfTrust getRootOfTrust() {
        return rootOfTrust;
    }

    public boolean isSoftwareLevel() {
        return sw;
    }

    private AttestationData(List<CertificateInfo> certs) {
        init(certs);

        var info = certs.get(certs.size() - 1);
        var attestation = info.getAttestation();
        if (attestation != null) {
            this.showAttestation = attestation;
            this.rootOfTrust = attestation.getRootOfTrust();
            this.sw = attestation.getAttestationSecurityLevel() == KM_SECURITY_LEVEL_SOFTWARE;
        } else {
            throw new AttestationException(CODE_CANT_PARSE_CERT, info.getCertException());
        }
    }

    private static List<X509Certificate> sortCerts(List<X509Certificate> certs) {
        if (certs.size() < 2) {
            return certs;
        }

        var issuer = certs.get(0).getIssuerX500Principal();
        boolean okay = true;
        for (var cert : certs) {
            var subject = cert.getSubjectX500Principal();
            if (issuer.equals(subject)) {
                issuer = subject;
            } else {
                okay = false;
                break;
            }
        }
        if (okay) {
            return certs;
        }

        var newList = new ArrayList<X509Certificate>(certs.size());
        for (var cert : certs) {
            boolean found = false;
            var subject = cert.getSubjectX500Principal();
            for (var c : certs) {
                if (c == cert) continue;
                if (c.getIssuerX500Principal().equals(subject)) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                newList.add(cert);
            }
        }
        if (newList.size() != 1) {
            return certs;
        }

        var oldList = new LinkedList<>(certs);
        oldList.remove(newList.get(0));
        for (int i = 0; i < newList.size(); i++) {
            issuer = newList.get(i).getIssuerX500Principal();
            for (var it = oldList.iterator(); it.hasNext(); ) {
                var cert = it.next();
                if (cert.getSubjectX500Principal().equals(issuer)) {
                    newList.add(cert);
                    it.remove();
                    break;
                }
            }
        }
        if (!oldList.isEmpty()) {
            return certs;
        }
        return newList;
    }

    static AttestationData parseCertificateChain(List<X509Certificate> certs) {
        var infoList = new ArrayList<CertificateInfo>(certs.size());
        CertificateInfo.parse(sortCerts(certs), infoList);
        return new AttestationData(infoList);
    }

}

```

`app/src/main/java/io/github/vvb2060/keyattestation/repository/AttestationRepository.java`:

```java
package io.github.vvb2060.keyattestation.repository;

import static android.security.KeyStoreException.ERROR_ATTESTATION_KEYS_UNAVAILABLE;
import static android.security.KeyStoreException.ERROR_ID_ATTESTATION_FAILURE;
import static android.security.KeyStoreException.ERROR_KEYMINT_FAILURE;
import static io.github.vvb2060.keyattestation.lang.AttestationException.*;

import android.annotation.SuppressLint;
import android.hardware.security.keymint.DeviceInfo;
import android.os.Build;
import android.os.ParcelFileDescriptor;
import android.os.RemoteException;
import android.security.KeyStoreException;
import android.security.keystore.DeviceIdAttestationException;
import android.security.keystore.StrongBoxUnavailableException;
import android.util.Log;

import androidx.annotation.RequiresApi;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.OutputStream;
import java.security.ProviderException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.List;

import io.github.vvb2060.keyattestation.AppApplication;
import io.github.vvb2060.keyattestation.keystore.AndroidKeyStore;
import io.github.vvb2060.keyattestation.keystore.IAndroidKeyStore;
import io.github.vvb2060.keyattestation.keystore.KeyStoreManager;
import io.github.vvb2060.keyattestation.lang.AttestationException;
import io.github.vvb2060.keyattestation.util.Resource;

public class AttestationRepository {
    private final AndroidKeyStore localKeyStore;
    private final CertificateFactory factory;
    private final List<X509Certificate> currentCerts;
    private IAndroidKeyStore keyStore;

    public AttestationRepository() throws Exception {
        localKeyStore = new AndroidKeyStore();
        factory = CertificateFactory.getInstance("X.509");
        currentCerts = new ArrayList<>();
        keyStore = localKeyStore;
    }

    public void useRemoteKeyStore(boolean useRemote) {
        if (useRemote) {
            keyStore = KeyStoreManager.getRemoteKeyStore();
        } else {
            keyStore = localKeyStore;
        }
    }

    public boolean hasCertificates() {
        return !currentCerts.isEmpty();
    }

    @SuppressWarnings("unchecked")
    private void generateCertificates(InputStream in) throws CertificateException {
        var list = (List<X509Certificate>) factory.generateCertificates(in);
        if (list.isEmpty()) {
            throw new CertificateException("No certificate");
        }
        currentCerts.addAll(list);
    }

    @SuppressWarnings("unchecked")
    private void generateCertPath(InputStream in) throws CertificateException {
        var list = (List<X509Certificate>) factory.generateCertPath(in).getCertificates();
        if (list.isEmpty()) {
            throw new CertificateException("No certificate");
        }
        currentCerts.addAll(list);
    }

    private void generateKeyPair(String alias, String attestKeyAlias,
                                 boolean useStrongBox, boolean includeProps,
                                 boolean uniqueIdIncluded, int idFlags,
                                 boolean useSak) throws Exception {
        var data = keyStore.generateKeyPair(alias, attestKeyAlias, useStrongBox,
                includeProps, uniqueIdIncluded, idFlags, useSak);
        if (data != null) {
            try (var it = new ObjectInputStream((new ByteArrayInputStream(data)))) {
                throw (Exception) it.readObject();
            }
        }
    }

    private void attestDeviceIds(int idFlags) throws Exception {
        var data = keyStore.attestDeviceIds(idFlags);
        var in = new ByteArrayInputStream(data);
        if (in.read() == 1) {
            generateCertificates(in);
        } else {
            try (var it = new ObjectInputStream((in))) {
                var exception = (Exception) it.readObject();
                throw new ProviderException(exception);
            }
        }
    }

    @SuppressLint("SwitchIntDef")
    @RequiresApi(Build.VERSION_CODES.TIRAMISU)
    private static AttestationException toAttestationException(KeyStoreException exception,
                                                               Exception e) {
        int code = exception.getNumericErrorCode();
        if (code == ERROR_ID_ATTESTATION_FAILURE) {
            return new AttestationException(CODE_DEVICEIDS_UNAVAILABLE, e);
        }
        if (code >= ERROR_ATTESTATION_KEYS_UNAVAILABLE) {
            if (exception.isTransientFailure()) {
                return new AttestationException(CODE_OUT_OF_KEYS_TRANSIENT, e);
            } else {
                return new AttestationException(CODE_OUT_OF_KEYS, e);
            }
        }
        if (code == ERROR_KEYMINT_FAILURE) {
            if (exception.toString().contains("ATTESTATION_KEYS_NOT_PROVISIONED")) {
                return new AttestationException(CODE_KEYS_NOT_PROVISIONED, e);
            }
        }
        if (exception.isTransientFailure()) {
            return new AttestationException(CODE_UNAVAILABLE_TRANSIENT, e);
        } else {
            return new AttestationException(CODE_UNAVAILABLE, e);
        }
    }

    private void getCertChain(String alias) throws RemoteException, CertificateException {
        var certChain = keyStore.getCertificateChain(alias);
        if (certChain == null) {
            throw new ProviderException("Unable to get certificate chain");
        }
        generateCertificates(new ByteArrayInputStream(certChain));
    }

    private void doAttestation(boolean useAttestKey, boolean useStrongBox,
                               boolean includeProps, boolean uniqueIdIncluded,
                               int idFlags, boolean useSak) throws AttestationException {
        var alias = useStrongBox ? AppApplication.TAG + "_strongbox" : AppApplication.TAG;
        var attestKeyAlias = useAttestKey ? alias + "_persistent" : null;
        try {
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S && idFlags != 0) {
                attestDeviceIds(idFlags);
                return;
            }

            if (useAttestKey && !keyStore.containsAlias(attestKeyAlias)) {
                generateKeyPair(attestKeyAlias, attestKeyAlias, useStrongBox,
                        includeProps, uniqueIdIncluded, idFlags, false);
            }
            generateKeyPair(alias, attestKeyAlias, useStrongBox,
                    includeProps, uniqueIdIncluded, idFlags, useSak);

            getCertChain(alias);
            if (useAttestKey) {
                getCertChain(attestKeyAlias);
            }
        } catch (ProviderException e) {
            var cause = e.getCause();
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P
                    && e instanceof StrongBoxUnavailableException) {
                throw new AttestationException(CODE_STRONGBOX_UNAVAILABLE, e);
            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU
                    && cause instanceof KeyStoreException keyStoreException) {
                throw toAttestationException(keyStoreException, e);
            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O
                    && cause instanceof DeviceIdAttestationException) {
                throw new AttestationException(CODE_DEVICEIDS_UNAVAILABLE, e);
            } else if (cause != null && cause.toString().contains("device ids")) {
                throw new AttestationException(CODE_DEVICEIDS_UNAVAILABLE, e);
            } else {
                throw new AttestationException(CODE_UNAVAILABLE, e);
            }
        } catch (Exception e) {
            throw new AttestationException(CODE_UNKNOWN, e);
        }
    }

    public Resource<AttestationData> attest(boolean reset, boolean useAttestKey,
                                            boolean useStrongBox, boolean includeProps,
                                            boolean uniqueIdIncluded, int idFlags, boolean useSak) {
        currentCerts.clear();
        try {
            if (reset) keyStore.deleteAllEntry();
            doAttestation(useAttestKey, useStrongBox, includeProps,
                    uniqueIdIncluded, idFlags, useSak);
            return Resource.Companion.success(AttestationData.parseCertificateChain(currentCerts));
        } catch (Exception e) {
            var cause = e instanceof AttestationException ? e.getCause() : e;
            Log.w(AppApplication.TAG, "Do attestation error.", cause);

            if (e instanceof AttestationException) {
                return Resource.Companion.error(e, null);
            } else {
                return Resource.Companion.error(new AttestationException(CODE_UNKNOWN, e), null);
            }
        }
    }

    public Resource<AttestationData> loadCerts(ParcelFileDescriptor pfd) {
        currentCerts.clear();
        try {
            AttestationData data;
            try (var in = new ParcelFileDescriptor.AutoCloseInputStream(pfd);
                 var channel = in.getChannel()) {
                try {
                    generateCertificates(in);
                    data = AttestationData.parseCertificateChain(currentCerts);
                } catch (CertificateException e) {
                    channel.position(0);
                    generateCertPath(in);
                    data = AttestationData.parseCertificateChain(currentCerts);
                }
            }
            return Resource.Companion.success(data);
        } catch (Exception e) {
            var cause = e instanceof AttestationException ? e.getCause() : e;
            Log.w(AppApplication.TAG, "Load attestation error.", cause);

            if (e instanceof AttestationException) {
                return Resource.Companion.error(e, null);
            } else if (e instanceof CertificateException) {
                return Resource.Companion.error(new AttestationException(CODE_CANT_PARSE_CERT, e), null);
            } else {
                return Resource.Companion.error(new AttestationException(CODE_UNKNOWN, e), null);
            }
        }
    }

    public void saveCerts(OutputStream out) throws Exception {
        var certPath = factory.generateCertPath(currentCerts);
        out.write(certPath.getEncoded("PKCS7"));
    }

    public void importKeyBox(boolean useStrongBox, ParcelFileDescriptor pfd) throws Exception {
        var base = useStrongBox ? AppApplication.TAG + "_strongbox" : AppApplication.TAG;
        var alias = base + "_persistent";
        keyStore.importKeyBox(alias, useStrongBox, pfd);
    }

    public boolean canRkp(boolean useStrongBox) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) {
            return false;
        }
        try {
            return keyStore.canRemoteProvisioning(useStrongBox);
        } catch (RemoteException e) {
            return false;
        }
    }

    public Resource<RemoteProvisioningData> checkRkp(boolean useStrongBox) {
        currentCerts.clear();
        try {
            var name = Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE
                    ? keyStore.getRkpHostname() : null;
            var deviceInfo = new DeviceInfo();
            var hw = keyStore.getHardwareInfo(useStrongBox, deviceInfo);
            var info = new RemoteProvisioningData(name, hw, deviceInfo);
            try {
                var data = keyStore.checkRemoteProvisioning(useStrongBox);
                info.setCerts(factory.generateCertificates(new ByteArrayInputStream(data)));
            } catch (IllegalStateException e) {
                info.setError(e);
            }
            return Resource.Companion.success(info);
        } catch (Exception e) {
            var cause = e instanceof AttestationException ? e.getCause() : e;
            Log.w(AppApplication.TAG, "Check RKP error.", cause);

            if (e instanceof IllegalStateException) {
                return Resource.Companion.error(new AttestationException(CODE_RKP, e), null);
            } else {
                return Resource.Companion.error(new AttestationException(CODE_UNKNOWN, e), null);
            }
        }
    }

    public void setHostname(String hostname) {
        if (hostname == null) return;
        try {
            keyStore.setRkpHostname(hostname);
        } catch (RemoteException e) {
            Log.w(AppApplication.TAG, "Set RKP hostname error.", e);
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/repository/BaseData.java`:

```java
package io.github.vvb2060.keyattestation.repository;

import java.util.List;

import io.github.vvb2060.keyattestation.attestation.CertificateInfo;
import io.github.vvb2060.keyattestation.attestation.RootPublicKey;

public abstract class BaseData {
    protected List<CertificateInfo> certs;
    protected RootPublicKey.Status status;

    protected void init(List<CertificateInfo> certs) {
        this.certs = certs;
        if (certs.isEmpty()) {
            this.status = RootPublicKey.Status.NULL;
            return;
        }

        var status = certs.get(0).getIssuer();
        for (var cert : certs) {
            if (cert.getStatus() < CertificateInfo.CERT_EXPIRED) {
                status = RootPublicKey.Status.FAILED;
                break;
            }
        }
        if (status == RootPublicKey.Status.GOOGLE) {
            for (int i = 1; i < certs.size(); i++) {
                if (certs.get(i).getCert().getSubjectX500Principal().getName().contains("Google LLC")) {
                    continue;
                }
                if (certs.get(i).getProvisioningInfo() != null) {
                    status = RootPublicKey.Status.GOOGLE_RKP;
                }
                break;
            }
        }
        this.status = status;
    }

    public List<CertificateInfo> getCerts() {
        return certs;
    }

    public RootPublicKey.Status getStatus() {
        return status;
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/repository/RemoteProvisioningData.java`:

```java
package io.github.vvb2060.keyattestation.repository;

import android.hardware.security.keymint.DeviceInfo;
import android.hardware.security.keymint.RpcHardwareInfo;
import android.util.ArrayMap;

import com.google.common.io.BaseEncoding;

import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import co.nstant.in.cbor.CborDecoder;
import co.nstant.in.cbor.CborException;
import co.nstant.in.cbor.model.ByteString;
import co.nstant.in.cbor.model.Map;
import io.github.vvb2060.keyattestation.attestation.CertificateInfo;

public class RemoteProvisioningData extends BaseData {
    private final String rkpHostname;
    private final RpcHardwareInfo hardwareInfo;
    private final java.util.Map<String, String> deviceInfo = new ArrayMap<>();
    private Throwable error;

    public RemoteProvisioningData(String rkpHostname, RpcHardwareInfo hardwareInfo,
                                  DeviceInfo deviceInfoData) throws CborException {
        this.rkpHostname = rkpHostname;
        this.hardwareInfo = hardwareInfo;
        var deviceInfo = (Map) CborDecoder.decode(deviceInfoData.deviceInfo).get(0);
        for (var key : deviceInfo.getKeys()) {
            var value = deviceInfo.get(key);
            String valueString;
            if (value instanceof ByteString byteString) {
                valueString = BaseEncoding.base16().lowerCase().encode(byteString.getBytes());
            } else {
                valueString = value.toString();
            }
            this.deviceInfo.put(key.toString(), valueString);
        }
    }

    @SuppressWarnings("unchecked")
    public void setCerts(Collection<? extends Certificate> data) {
        var infoList = new ArrayList<CertificateInfo>(data.size());
        CertificateInfo.parse((List<X509Certificate>) data, infoList);
        init(infoList);
    }

    public void setError(Throwable error) {
        this.error = error;
        init(List.of());
    }

    public String getRkpHostname() {
        return rkpHostname;
    }

    public RpcHardwareInfo getHardwareInfo() {
        return hardwareInfo;
    }

    public java.util.Map<String, String> getDeviceInfo() {
        return deviceInfo;
    }

    public Throwable getError() {
        return error;
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/util/Resource.kt`:

```kt
package io.github.vvb2060.keyattestation.util

/**
 * A generic class that holds a value with its loading status.
 * @param <T>
</T> */
open class Resource<out T>(val status: Status, val data: T?, val error: Throwable) {

    companion object {
        private val noError = Throwable("No error")

        fun <T> success(data: T?): Resource<T> {
            return Resource(Status.SUCCESS, data, noError)
        }

        fun <T> error(error: Throwable, data: T?): Resource<T> {
            return Resource(Status.ERROR, data, error)
        }

        fun <T> loading(data: T?): Resource<T> {
            return Resource(Status.LOADING, data, noError)
        }
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as Resource<*>

        if (status != other.status) return false
        if (data != other.data) return false
        if (error != other.error) return false

        return true
    }

    override fun hashCode(): Int {
        var result = status.hashCode()
        result = 31 * result + (data?.hashCode() ?: 0)
        result = 31 * result + error.hashCode()
        return result
    }
}

enum class Status {
    SUCCESS,
    ERROR,
    LOADING
}

class SourcedResource<out T, out S>(status: Status, data: T?, error: Throwable, val source: S?) : Resource<T>(status, data, error) {

    companion object {
        private val noError = Throwable("No error")

        fun <T, S> success(data: T?, source: S?): SourcedResource<T, S> {
            return SourcedResource(Status.SUCCESS, data, noError, source)
        }

        fun <T, S> error(error: Throwable, data: T?, source: S?): SourcedResource<T, S> {
            return SourcedResource(Status.ERROR, data, error, source)
        }

        fun <T, S> loading(data: T?, source: S?): SourcedResource<T, S> {
            return SourcedResource(Status.LOADING, data, noError, source)
        }
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false
        if (!super.equals(other)) return false

        other as SourcedResource<*, *>

        if (source != other.source) return false
        return true
    }

    override fun hashCode(): Int {
        var result = super.hashCode()
        result = 31 * result + (source?.hashCode() ?: 0)
        return result
    }
}
```

`app/src/main/java/io/github/vvb2060/keyattestation/util/ViewBindingViewHolder.kt`:

```kt
package io.github.vvb2060.keyattestation.util

import android.view.View
import androidx.viewbinding.ViewBinding
import rikka.recyclerview.BaseListenerViewHolder

open class ViewBindingViewHolder<T, VB : ViewBinding, L>(itemView: View, internal val binding: VB) : BaseListenerViewHolder<T, L>(itemView)

```

`app/src/main/res/color/material_on_surface_emphasis_high_type.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:alpha="0.88" android:color="?attr/colorOnSurface" />
</selector>

```

`app/src/main/res/color/material_on_surface_emphasis_medium.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:alpha="0.75" android:color="?attr/colorOnSurface" />
</selector>

```

`app/src/main/res/color/mtrl_popupmenu_overlay_color.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:alpha="0.08" android:color="?attr/elevationOverlayColor" />
</selector>
```

`app/src/main/res/drawable-v26/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@mipmap/ic_key_attestation_background" />
    <foreground android:drawable="@mipmap/ic_key_attestation_foreground" />
</adaptive-icon>
```

`app/src/main/res/drawable/home_item_background_solid.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape android:shape="rectangle"
    xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@android:color/white" />
    <corners android:radius="4dp" />
</shape>
```

`app/src/main/res/drawable/ic_boot_locked_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorControlNormal"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M18,8h-1L17,6c0,-2.76 -2.24,-5 -5,-5S7,3.24 7,6v2L6,8c-1.1,0 -2,0.9 -2,2v10c0,1.1 0.9,2 2,2h12c1.1,0 2,-0.9 2,-2L20,10c0,-1.1 -0.9,-2 -2,-2zM9,6c0,-1.66 1.34,-3 3,-3s3,1.34 3,3v2L9,8L9,6zM18,19c0,0.55 -0.45,1 -1,1L7,20c-0.55,0 -1,-0.45 -1,-1v-8c0,-0.55 0.45,-1 1,-1h10c0.55,0 1,0.45 1,1v8zM12,17c1.1,0 2,-0.9 2,-2s-0.9,-2 -2,-2 -2,0.9 -2,2 0.9,2 2,2z" />
</vector>

```

`app/src/main/res/drawable/ic_boot_unknown_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM11,16h2v2h-2zM12.61,6.04c-2.06,-0.3 -3.88,0.97 -4.43,2.79 -0.18,0.58 0.26,1.17 0.87,1.17h0.2c0.41,0 0.74,-0.29 0.88,-0.67 0.32,-0.89 1.27,-1.5 2.3,-1.28 0.95,0.2 1.65,1.13 1.57,2.1 -0.1,1.34 -1.62,1.63 -2.45,2.88 0,0.01 -0.01,0.01 -0.01,0.02 -0.01,0.02 -0.02,0.03 -0.03,0.05 -0.09,0.15 -0.18,0.32 -0.25,0.5 -0.01,0.03 -0.03,0.05 -0.04,0.08 -0.01,0.02 -0.01,0.04 -0.02,0.07 -0.12,0.34 -0.2,0.75 -0.2,1.25h2c0,-0.42 0.11,-0.77 0.28,-1.07 0.02,-0.03 0.03,-0.06 0.05,-0.09 0.08,-0.14 0.18,-0.27 0.28,-0.39 0.01,-0.01 0.02,-0.03 0.03,-0.04 0.1,-0.12 0.21,-0.23 0.33,-0.34 0.96,-0.91 2.26,-1.65 1.99,-3.56 -0.24,-1.74 -1.61,-3.21 -3.35,-3.47z" />
</vector>

```

`app/src/main/res/drawable/ic_boot_unlocked_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,13c-1.1,0 -2,0.9 -2,2s0.9,2 2,2 2,-0.9 2,-2 -0.9,-2 -2,-2zM18,8h-1L17,6c0,-2.76 -2.24,-5 -5,-5 -2.28,0 -4.27,1.54 -4.84,3.75 -0.14,0.54 0.18,1.08 0.72,1.22 0.53,0.14 1.08,-0.18 1.22,-0.72C9.44,3.93 10.63,3 12,3c1.65,0 3,1.35 3,3v2L6,8c-1.1,0 -2,0.9 -2,2v10c0,1.1 0.9,2 2,2h12c1.1,0 2,-0.9 2,-2L20,10c0,-1.1 -0.9,-2 -2,-2zM18,19c0,0.55 -0.45,1 -1,1L7,20c-0.55,0 -1,-0.45 -1,-1v-8c0,-0.55 0.45,-1 1,-1h10c0.55,0 1,0.45 1,1v8z" />
</vector>

```

`app/src/main/res/drawable/ic_error_outline_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,7c0.55,0 1,0.45 1,1v4c0,0.55 -0.45,1 -1,1s-1,-0.45 -1,-1L11,8c0,-0.55 0.45,-1 1,-1zM11.99,2C6.47,2 2,6.48 2,12s4.47,10 9.99,10C17.52,22 22,17.52 22,12S17.52,2 11.99,2zM12,20c-4.42,0 -8,-3.58 -8,-8s3.58,-8 8,-8 8,3.58 8,8 -3.58,8 -8,8zM13,17h-2v-2h2v2z" />
</vector>

```

`app/src/main/res/drawable/ic_help_outline_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM11,16h2v2h-2zM12.61,6.04c-2.06,-0.3 -3.88,0.97 -4.43,2.79 -0.18,0.58 0.26,1.17 0.87,1.17h0.2c0.41,0 0.74,-0.29 0.88,-0.67 0.32,-0.89 1.27,-1.5 2.3,-1.28 0.95,0.2 1.65,1.13 1.57,2.1 -0.1,1.34 -1.62,1.63 -2.45,2.88 0,0.01 -0.01,0.01 -0.01,0.02 -0.01,0.02 -0.02,0.03 -0.03,0.05 -0.09,0.15 -0.18,0.32 -0.25,0.5 -0.01,0.03 -0.03,0.05 -0.04,0.08 -0.01,0.02 -0.01,0.04 -0.02,0.07 -0.12,0.34 -0.2,0.75 -0.2,1.25h2c0,-0.42 0.11,-0.77 0.28,-1.07 0.02,-0.03 0.03,-0.06 0.05,-0.09 0.08,-0.14 0.18,-0.27 0.28,-0.39 0.01,-0.01 0.02,-0.03 0.03,-0.04 0.1,-0.12 0.21,-0.23 0.33,-0.34 0.96,-0.91 2.26,-1.65 1.99,-3.56 -0.24,-1.74 -1.61,-3.21 -3.35,-3.47z" />
</vector>

```

`app/src/main/res/drawable/ic_info_outline_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorControlNormal"
    android:viewportWidth="24"
    android:viewportHeight="24">

    <path
        android:fillColor="@android:color/white"
        android:pathData="M11,7h2v2h-2zM11,11h2v6h-2zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8z" />

</vector>

```

`app/src/main/res/drawable/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<bitmap xmlns:android="http://schemas.android.com/apk/res/android"
    android:src="@mipmap/ic_key_attestation" />
```

`app/src/main/res/drawable/ic_trustworthy_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M12,1L3,5v6c0,5.55 3.84,10.74 9,12 5.16,-1.26 9,-6.45 9,-12L21,5l-9,-4zM19,11c0,4.52 -2.98,8.69 -7,9.93 -4.02,-1.24 -7,-5.41 -7,-9.93L5,6.3l7,-3.11 7,3.11L19,11zM7.41,11.59L6,13l4,4 8,-8 -1.41,-1.42L10,14.17z" />
</vector>

```

`app/src/main/res/drawable/ic_untrustworthy_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M21,11C21,16.55 17.16,21.74 12,23C6.84,21.74 3,16.55 3,11V5L12,1L21,5V11M12,21C15.75,20 19,15.54 19,11.22V6.3L12,3.18L5,6.3V11.22C5,15.54 8.25,20 12,21M11,7H13V13H11V7M11,15H13V17H11V15Z" />
</vector>

```

`app/src/main/res/drawable/ic_warning_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M4.47,21h15.06c1.54,0 2.5,-1.67 1.73,-3L13.73,4.99c-0.77,-1.33 -2.69,-1.33 -3.46,0L2.74,18c-0.77,1.33 0.19,3 1.73,3zM12,14c-0.55,0 -1,-0.45 -1,-1v-2c0,-0.55 0.45,-1 1,-1s1,0.45 1,1v2c0,0.55 -0.45,1 -1,1zM13,18h-2v-2h2v2z" />
</vector>

```

`app/src/main/res/layout/appbar.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<rikka.material.widget.AppBarLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/toolbar_container"
    style="?appBarStyle"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:fitsSystemWindows="true"
    tools:viewBindingIgnore="true">

    <androidx.appcompat.widget.Toolbar
        android:id="@+id/toolbar"
        style="?actionBarStyle"
        android:layout_width="match_parent"
        android:layout_height="?actionBarSize"
        android:layout_gravity="bottom"
        android:layout_marginTop="0dp"
        android:background="@null"
        android:elevation="0dp"
        android:gravity="center_vertical"
        android:paddingTop="0dp"
        android:paddingBottom="0dp"
        app:subtitleTextAppearance="@android:style/TextAppearance.Material.Widget.Toolbar.Subtitle"
        app:titleTextAppearance="@android:style/TextAppearance.Material.Widget.Toolbar.Title"
        tools:text="Title" />

</rikka.material.widget.AppBarLayout>
```

`app/src/main/res/layout/appbar_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/root"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="false"
    app:consumeSystemWindowsInsets="start|end"
    app:edgeToEdge="true"
    app:fitsSystemWindowsInsets="start|end"
    tools:viewBindingIgnore="true">

    <include layout="@layout/appbar" />

</FrameLayout>

```

`app/src/main/res/layout/appbar_fragment_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/root"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="false"
    app:consumeSystemWindowsInsets="start|end"
    app:edgeToEdge="true"
    app:fitsSystemWindowsInsets="start|end"
    tools:viewBindingIgnore="true">

    <FrameLayout
        android:id="@+id/fragment_container"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <include layout="@layout/appbar" />

</FrameLayout>

```

`app/src/main/res/layout/home.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_marginStart="@dimen/rd_activity_horizontal_margin"
    android:layout_marginEnd="@dimen/rd_activity_horizontal_margin"
    android:paddingStart="@dimen/home_padding"
    android:paddingEnd="@dimen/home_padding"
    android:animateLayoutChanges="true">

    <rikka.widget.borderview.BorderRecyclerView
        android:id="@+id/list"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clipToPadding="false"
        android:paddingTop="?actionBarSize"
        android:scrollbarStyle="insideOverlay"
        android:scrollbars="vertical"
        android:visibility="gone"
        app:borderBottomVisibility="never"
        app:borderTopDrawable="@null"
        app:borderTopVisibility="whenTop"
        app:fitsSystemWindowsInsets="top|bottom"
        tools:listitem="@layout/home_header"
        tools:visibility="visible" />

    <ProgressBar
        android:id="@+id/progress"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        app:layout_fitsSystemWindowsInsets="top|bottom" />

</FrameLayout>

```

`app/src/main/res/layout/home_boot_state.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/title"
    style="@style/HomeCardStyle"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@drawable/home_item_background_solid"
    android:backgroundTintMode="src_in"
    android:drawablePadding="24dp"
    android:drawableTint="?android:textColorPrimaryInverse"
    android:drawableTintMode="src_in"
    android:gravity="center_vertical"
    android:textAppearance="?textAppearanceSubtitle2"
    android:textColor="?android:textColorPrimaryInverse"
    android:textSize="16sp"
    tools:backgroundTint="?colorSafe"
    tools:drawableStart="@drawable/ic_boot_locked_24"
    tools:text="@string/bootloader_locked" />

```

`app/src/main/res/layout/home_common_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@android:id/content"
    style="@style/HomeCardStyle"
    android:background="?android:selectableItemBackground"
    android:gravity="center_vertical"
    android:orientation="horizontal">

    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginEnd="16dp"
        android:layout_weight="1"
        android:orientation="vertical">

        <TextView
            android:id="@+id/title"
            style="@style/HomeItemTitleText"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            tools:text="title" />

        <TextView
            android:id="@+id/summary"
            style="@style/HomeItemSummaryText"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            tools:text="summary" />

    </LinearLayout>

    <ImageView
        android:id="@+id/icon"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginStart="-4dp"
        android:background="?android:selectableItemBackgroundBorderless"
        android:importantForAccessibility="no"
        android:padding="4dp"
        android:tintMode="src_in"
        tools:src="@drawable/ic_trustworthy_24"
        tools:tint="?colorSafe" />

    <TextView
        android:id="@+id/text1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="@null"
        android:fontFamily="sans-serif"
        android:letterSpacing="0"
        android:minWidth="0dp"
        android:textColor="?colorAccent"
        android:textStyle="bold"
        tools:text="SW" />

</LinearLayout>

```

`app/src/main/res/layout/home_error.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    style="@style/HomeCardStyle"
    android:orientation="horizontal">

    <ImageView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@drawable/ic_help_outline_24" />

    <TextView
        android:id="@+id/text1"
        style="@style/HomeItemSummaryText"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginStart="24dp"
        android:gravity="center_vertical"
        android:textIsSelectable="true"
        android:minHeight="24dp"
        tools:text="text" />

</LinearLayout>

```

`app/src/main/res/layout/home_header.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    style="@style/HomeCardStyle"
    android:background="@drawable/home_item_background_solid"
    android:backgroundTintMode="src_in"
    android:gravity="center_vertical"
    android:orientation="horizontal"
    tools:backgroundTint="?colorAlert">

    <ImageView
        android:id="@+id/icon"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:importantForAccessibility="no"
        android:tint="?android:textColorPrimaryInverse"
        android:tintMode="src_in"
        tools:src="@drawable/ic_error_outline_24" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginStart="24dp"
        android:orientation="vertical">

        <TextView
            android:id="@+id/title"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center_vertical"
            android:textAppearance="?textAppearanceSubtitle2"
            android:textColor="?android:textColorPrimaryInverse"
            android:textSize="16sp"
            tools:text="@string/error_strongbox_unavailable" />

        <TextView
            android:id="@+id/summary"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center_vertical"
            android:textAppearance="?textAppearanceBody2"
            android:textColor="?android:textColorPrimaryInverse"
            android:textSize="14sp"
            tools:text="@string/error_strongbox_unavailable_summary" />

    </LinearLayout>

</LinearLayout>

```

`app/src/main/res/layout/home_subtitle.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/title"
    style="@style/HomeCardStyle"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="?android:selectableItemBackground"
    android:gravity="bottom"
    android:textAppearance="?textAppearanceSubtitle2"
    android:textColor="?colorAccent"
    tools:text="@string/app_name" />

```

`app/src/main/res/menu/home.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item
        android:id="@+id/menu_use_shizuku"
        android:checkable="true"
        android:showAsAction="never"
        android:title="@string/use_shizuku" />

    <item
        android:id="@+id/menu_use_sak"
        android:checkable="true"
        android:showAsAction="never"
        android:title="@string/use_sak" />

    <item
        android:id="@+id/menu_use_strongbox"
        android:checkable="true"
        android:showAsAction="never"
        android:title="@string/use_strongbox" />

    <item
        android:id="@+id/menu_use_attest_key"
        android:checkable="true"
        android:showAsAction="never"
        android:title="@string/use_attest_key" />

    <item
        android:id="@+id/menu_import_attest_key"
        android:showAsAction="never"
        android:title="@string/import_attest_key" />

    <item
        android:id="@+id/menu_include_props"
        android:checkable="true"
        android:showAsAction="never"
        android:title="@string/attest_device_props" />

    <group android:id="@+id/menu_id_type_group">
        <item
            android:id="@+id/menu_id_type_serial"
            android:checkable="true"
            android:showAsAction="never"
            android:title="@string/id_type_serial" />

        <item
            android:id="@+id/menu_id_type_imei"
            android:checkable="true"
            android:showAsAction="never"
            android:title="@string/id_type_imei" />

        <item
            android:id="@+id/menu_id_type_meid"
            android:checkable="true"
            android:showAsAction="never"
            android:title="@string/id_type_meid" />
    </group>

    <item
        android:id="@+id/menu_include_unique_id"
        android:checkable="true"
        android:showAsAction="never"
        android:title="@string/include_unique_id" />

    <item
        android:id="@+id/menu_rkp_test"
        android:showAsAction="never"
        android:title="@string/rkp_test" />

    <item
        android:id="@+id/menu_reset"
        android:showAsAction="never"
        android:title="@string/reset" />

    <item
        android:id="@+id/menu_save"
        android:showAsAction="never"
        android:title="@string/save_certs" />

    <item
        android:id="@+id/menu_load"
        android:showAsAction="never"
        android:title="@string/load_certs" />

    <item
        android:id="@+id/menu_about"
        android:showAsAction="never"
        android:title="@string/about" />

</menu>

```

`app/src/main/res/raw/status.json`:

```json
{
  "entries": {
    "6681152659205225093" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8350192447815228107" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9408173275444922801" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "11244410301401252959" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "15346629759498347257" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1228286566665971148" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "17471682139930361099" : {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "1545991490585406285": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "16799496319142405818": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2621004353020741590": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1051246719628187981": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c35747a084470c3135aeefe2b8d40cd6": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ee3ac673107ddf0831027a84c532bee4": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1f4363f4acefdf83ae59202b934cead9": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "633d72164968d2b7ec1a927a14c8efbe": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "f3a6cc97099ae7311ca7d1c55625a9e2": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c360da616de6583ae816cdefdda66221": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1476c32be5b4788386062ca1d6a3ec01" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c9b95f08cb46c66e778a996bb04eb063" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2775678662643671941" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "10478051501886118140" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "15304424745846567057" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2540354691047989632" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9605027729693255932" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "7266970422002561562" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2121480040206509646" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4722071905782261079" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "13791718860221210775" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5318853256439367328" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "16619986970074733637" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8090691296252605665" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9422579570321443809" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "14441488828221950432" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "cfd09f492467a8d78f3c87f8ae82b0ed" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "843184b4161e8dfbb711061d3483ad81" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "f2e14b3039c35d54fb9661b60b17ec94" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "836d1498921ff86a22fe3768042849a2" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c95180267ba53a50b636e36d32976065" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9414602a0ce3f77d9ac05af532785ef" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c21b00ddf8c5a26106a03e8c11b37998" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "d9e9fa3c6021bcca273b524f551feab9" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6a0c9ef31f814ebb8d8301eb443f7940" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "78d6b0810af9e6897b62ef2e26a853d2" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "e8063fd19d678b46998c5d25bf6bcd2" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a23891b8cf1e06bea42599aecd9bc9cf" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "fc609574570c3e0a1d347e02a2ad6d4d" : {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "7355273169128314967" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5344612975616013951" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "16166206677093325219" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "15489222854939603791" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "18154252358500841010" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "12098947777634431853" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "10997554208317698753" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "12365028775357944392" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3bbbbd83aa163125a86e900730bc9f53" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "fb3b56606adc45049dd5ebc0846e0daf" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "90fdc81863091e2bc62519d620143d1" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1ae2ba1ba985e8a55a3b617172e61537" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "7f69b2f66b0679f7fffc721fc3978128" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4b7f33db15d04ce1736768dbad021261" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "43cf4aa6e5d9744dd436d9d5ef1391cd" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ad3b740cccc9369f89240dbc5284cb10" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9ed21fe7bfa899183bcb0833de8c5178" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "87a5a6991dfa390d3e4c61bbe3d291b3" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "fb5adea0f8212f845bea3f996bcee726" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "7f90e587a2cb6ef5dee0b83b58893d74" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6b870bcad63bdfe92d02ba4698b16264" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1af3b8c5427453b6937ae0bcb6fe447f" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2975e3f59a67e034d4bd451b927f1d27" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "cdee0d31cb8400838344756231940aea" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c578cd2e254c12dff8ee2ac82f93410a" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "e7daf1046d38581b22f1dd7946b15f1" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8d76fce4395906995adf0de84b80e2ec" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "82d779713c8ee285e8a7ffd61cbfb7ed" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "fc0a3c9f31721c524c3bd84afa72cbe3" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b8ac6e0771a0958aeaa4b68a111a5dee" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "94f4943f978b93b4d7f4e69dc20b4d6b" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c39c08de9731fd57d124c3e17c53faca" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "e24e5301403dcb9bad30918083fa15c7" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "dfd704581cbf9fe223b5c351fab83b4e" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "dfd0bf6bb1cb606ef65572412c0d1ac8" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4d818d8a042b22646a42c395e5c86d6" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "7f9ec229afd8185d8432f408108e0991" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "846736b71487a74075ed6f33f58e4b33" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "14e38b3979edef06d0e95b7131a08b22" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c2272cf25f9ccac5b5633a36b5e08fa9" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8868809403284598250" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "15443728027744674372" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "224403031710863989" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3882667606589968590" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8398415515671998339" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "13965740041072508681" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "70771aada0054842160ef0764bce1623" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "119e72132a781e012ce7a8e68533b140" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4507699620177564323": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "fb15cf8fb17f479ab86309b964bc879f": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "10366491491059815913": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b58f9dea5b5fa47a71232975c9a3105f": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "df60b49f7b9046b5234e0df74ea9ce6b": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "f05d190cdad24969d3303bcf387cb9b4": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "14423003903688859038": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b0e3b89197086be252d5eb29f930e537": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6845757010563880491": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b1f1481091272a4911f18d20eaa12463": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "338b275a6333cc1b59888acf75527802": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "11131729192210368711": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6717229404067592611": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6815517147617176510": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "583dc5cc0dda3c1f886e9b7933137098": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c0e272fdb6e5849fd898834a1598c2fe": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "71cf6a217187e89e086b072a1fd17596": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "14803998145538567806": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a1c043b5aa1f915e0ee2d20fefaee8c1": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "16738628654716464919": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4f327688e1a85e71955cefd696336b91": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2b87baacd6338c76c0dd43c8a4a634d8": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ee6126eeddc43fc387d7753867ed3e80": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a9fb44f216e1fc41041aa21481b9e7a6": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "dc260c2618f40c1504ea3dbc75af48bc": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "12766508004442517294": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "f005b07f550b5dd96a43e3bb6831678": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6972031689279523646": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a67ddc27e1036c7abdd95f1d5e7cad4f": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "39473cc0a44911d10a38971286650ad": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "f0cf9f9d6bc5a7a7d82d9f0e510e57bb": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4e8df84b0a2c3bc222eee317c88cd7ae": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2f7e1dd99a063e16aceefa3e6d681575": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6393c6390b60e0cfc9fb8d6ca1d23605": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "d4c59e957b7207ec11e1a7d8cfd4cb68": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9c2051b3327baf0eb364d3ab96e1a3fb": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "bd1a9e9125a39b590cab7deecec05222": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "13554058501592369784": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "983a895183f5f1271d79202533722279": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "7fdc29d6e5f98ea6d13eb5e737ce705": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3556819627137484722": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ff540c3b97a46444f86ef71653e1df18": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "205941609533867482": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a7c4afb483f1227dc82993f27d1c0998": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6051ed8207d2d1c0bf927f9e2ada4b48": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "49c141a849df35acb6aaede2226f9e9b": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "e6710ab8649ebcfff1c399f0b233795a": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3642e8ebda76a49229811a336135a82c": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a7dc53700e9fc9847d4fea65c29da1e3": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8ec25f23f03dbb50b8c16b8a00c1b385": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1765470235229526865": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4f9a18bc60b33deaf47659718c8e46f3": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "794603fd166a8b853084f94969b6f76a": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9691410294288259865": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "dfe4a9b2dafa2bf5f641962cb3d5a332": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "33554d4e522d915d5dadf16f907c50f7": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "fdf3b3c1e92cec617335708d84e23d66": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "30d9c1c5524174bfbf439e9e73cdb79d": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3751979701730164589": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "928a090e80bb6aee9db4e92b37e41509": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "649dbea9cb64ce308588905214fa361c": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "de9e893188f2e3a04e632f909270a491": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2cf66a251b227a1b9ed6d4e019ea6b36": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "27ed27b2a8c46be59c98ea4711d0dc5f": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2e028083625fd6ef9f74637ff449da5a": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "99eca9a3d7ce7c2d84476402c1e448cf": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9d96f1e695269851494a91d48601a1d8": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2600c3f9b352130017f198e556d57a52": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9705747036760232149": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3154d0663898188cca623ad25bc7271d": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ce88396f2a456fc603cd766c78eacf13": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "13503260129030804995": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1948b1f11ae6b513949d71d85462161f": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "fff56c1b1b7af0a7818eed63918c7abc": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8758766de23bcb4724f9c10da041246e": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8cb65966a99f08fa218afd99ec0e046a": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "13478723519430940204": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4466280473208039047": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8626111651415796206": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "fa303060f00a7d95cba05e1274907eda": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5564751976450306924": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "10669975075318677953": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2768878a858bffb3af12180a1ee5ed7a": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2330e5e1e0a351ab4fc74c464ce88ed3": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4be08979d68acd09934104b6bd2edda5": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "68d1984f7ba32bea63baa680bc5a556c": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5145721877299830915": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8e7c77d159509217d9e11cbfc2664681": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5192399fb1d5fdfe95c4f2fb002ac5f": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "11918519357273683794": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "e00cc58c1ed1f7027f3dbc4e87d33199": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3d8cbfb0f47429cc8165cf175e239a20": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "13325600579469253471": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5214c6faf95197b2079a0a02c688421": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "551b630fbcd8b33a17f001f3d5b08f93": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b3758e92dacf53edd06fa10d9a4361c9": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "33c18997768f13c04f7b81679632bf65": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6355987390329458305": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a3140abd9214f9db70b46964699c8cfb": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3ec3e740a09fc63de719ed99dde9001": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "53e23541cbcde87c85555e180f8b4397": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3b2c71a24f20eee5d71d51cd8533d188": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "93248cf706c6f2e26e7e83d4c86bea0": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "7aee28c4caf600d64355540e33269a57": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3472939056772264175": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b6e4b48e13ed2b06f9ef6fb16c0e37b2": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "bc32a062ce42973daa8e184bdb5810de": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6254754cf6193d69f8370e6398f1956d": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2a305e8eda6380f554ab0964f62ff187": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "af92c90e19f0da1673d19056937b46d3": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4271430637556221188": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "10696134136102907523": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "d9a1ef01a1606b4eec1b34bbbe8d044e": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "10631151104397693527": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "20581dbacd135140e41ce15fa4820589": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "15950000780909930300": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "587213a0a017a3151c3e0d772f3b459a": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "16279865861478413754": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "97c5b89e9e51eff9e9897e92f865d21e": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "e6508499faf6a244d959a9a8d633caf4": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "14117867490237308293": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b0645f9b21d8a8394f5e3475c35244e2": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "94494997671214484": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6a44e14ef662d48d2fb413c808081fa": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "dfa7255055f80aa26fd9eb94217c7941": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "72d3b4e0d47b6f8887179ec2d300dad9": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ce9ee7250269cc92daebc877ed9130f0": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4373482b09e5d1c30144d74de4ed24c8": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ad8257dd3a64436eed9bc69ed7f81a8e": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "f14187a6788de6b3ae4fd7c651d93aee": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "fc8643f646dc253c7b2a9ce69694036e": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5272326329417510368": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8123a63ed4783bc34c7ac20c8646f5a3": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "f10247aa2c62f6b8a73178026e9bc0b7": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "670acdd6e75f1834afe8568e4b090b8d": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "df922e62524b836180720612b9619a3a": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "13672903365956275417": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "14243129576127828603": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "424ab07c0f341f6a01fdb4d34798dd05": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "407d5f958d5fc95972cac240a900aa48": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "14096919803101624708": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4f2db225d3384d2b9157941accf3ff6e": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2d1b9bffc223503cde80405a71765905": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5bad8e7d165b7a311e2b57621556506f": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c3e63dff2bb50259fbd025733ecdd90b": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "457a612fd7e053298c4ee9d4b7691f44": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "511ef62d13cc31325eba9eac0774b5b1": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4a359c9bec46babfbf94a2fe01c835bb": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b329005210913255b99fa1c9f0844349": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9e80eca04c949e335ee919de518bebbf": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "41d46d7986af544bc236bf833bded3a7": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b216046ea1a9a39afe7a7bf846c2fd73": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4775152230268351286": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "72736ea426dcd06ff0bbeb5a4dd79948": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b8e48e0044936226009f11f3275692b7": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "24d407abdcb818b82418df9075f0ff44": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "73b3dcaca88c01fd6280fe072c1cbde6": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a49e49a2a870d4e1de40aeaab37c8ca3": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "11481610630634287040": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b680b2b314e7a715e390e14a33020908": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "e62b0afb8f80f139ef082bfc319c91af": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ba3146d2bfb27978e943fab925bbeb85": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8935204412779183185": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "faf84c1e7cd532045119e470d80be817": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "e0e2b831ac104ecccc5e5dd3a2f11b75": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "e1efed25187ebe05b745c7f466e57599": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "31b9588015bfba8e5b2762c87fb083cd": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "68d889ddd7bbdba0c50fe275576582ae": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "20c6af508272184d8dcae68f145835d0": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "10628994157453962498": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2863739566415969992": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "be38635630e27b8d14049230d2cf8b12": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c4b25c81d5f2adb396621cf1da8cd206": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "d3dcd288c1343eeb42f68f1ec707aa15": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4c665ca6ca9a6671ea6c8c75f491dca": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9b60240e40d15b581525433b9c1b699e": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "28a18b4f04d8e0ba1469e6f08128eb1": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8940841425273370276": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3177d1aafc14b92a33cd42c652d30692": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a71808b06c9145429099a1aaaac0616b": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a030ebea4ad0f0f5c7d30ce666c04828": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9cde3eda4299bdd9bb585390e30a8f3b": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "595bf8afe78ffd88220c9339451ac155": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9233668dceaa5b567e4cf9f52bd2e1e0": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a321977211fe24e3d2dc8f76c083a08": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "846713e0424db838fa4a991d943c4549": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a80f47c0862d94d9269be02b83c37b53": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "43a65376e35524afc045906d7071cdf7": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "16932cc7a3865cea312d84702032b55e": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "792e307458b653a6141d8a2d55a7d7": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9734b6a853e67cd88f8f197f09f5b7ad": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "15735730174267438273": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5ea29375f11952555ebae69b1a1991d8": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8621345197686984555": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6654493384142859524": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "53290dbb4f94c781223e541e524ddcd0": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ddd542d3ab5936ad7fd7e336769f8c73": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "be1c1c337bea50e15973446559a6d9fc": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "cbbab31cd003e49bcf7161f250813585": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b39c7850e07ffb8e3474c8bfaa09fe9d": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "11088723024112326817": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c67256011aeebd5b499a79d0a68174a1": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ef7634571778ff1f882a40929711dadf": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ba76f7cf58dde094159eaa0ad7dd4815": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "d8952e9b744ae2b97eeaf0d237817677": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4052208266068406503": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1100c01705cf01afba09f4969c659705": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "92b6427efac231cf7da973d68b705d46": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "80479dd5006b90da882e13dcd19d0d3b": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c3cf50f9c7b1fbc5019239edaa57b8be": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "24b08e455268f973f79e8af13419a04f": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "33d367c4f4e2ce7e51fd5dac92da62bc": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c4bb59d6dcad28194dd534da18028287": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4aecbb55ac95669cbd322a709f8b8242": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5893256412279433040": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b8af8941ed0939add111eb8e8b3f74c3": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "bf26a255d9bab04bd5e2a797b2c3e13d": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ac74231d6efe02a918c52138c5e6a288": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "13208021490800717034": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "73de4f1c7f6540c3407c8f08c87dfc52": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "38bf5e098b9b9ffcccb7eee84fb9c09c": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1497138949090246232": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2a6fef545d4b8578bafb8245408fee26": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "452cd762f790c607b69946c27e383a4b": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9867094464352066174": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8887999446032040142": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "14191869834556450245": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6ab1c2d064b242edc2dff1d95f688140": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ab63439eabd211ed9cfbcc9d0b7d9972": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "fddd5e6a8d584b1a8141682a12bf5f75": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "24e6c13f4999fa3924e08994257323de": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5f1f2c2f2c3f26bb8f111a279e634510": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "e1052a8a3ad9d5eebf23dae79cdf5fb3": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "57b3857f2784b1a37b356f821e4b6db0": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "10455742914461326988": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a7c8f6f90f75a7fc7ee7db95c366dadf": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4c40d55668244c65f690acd61040c369": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6b9bf9652484e73952e9301e86ef7412": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3da1dc524b8324ce144fd77b53897f57": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "d7126a65f10da48342714f7707c1c4bc": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "cd8225b35cfd298bf5356503e39feefa": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "72a09b54cf99c9cba6da5a96706cd3f9": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "d4370bfca57f597151a18427664bf093": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "cdef9adbc817a11faab9cbf410f0705d": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "f9a0b9888d7a76c58c99c226b7706747": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "7d7fd8b16f3b60fad552cb5af07d6aca": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a6d4145d111b92c3a0254ba9745db9e3": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "94f191b632e0b448c576f70519693edb": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3106306f29d13aef6a388d72e8e7bbab": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "d8c0880797d6f8571a050ed24ed074e1": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b2963c20818a6588e3dab4a34ecb2b69": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "584d08a5cc306a991920a0def351a22d": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9868d88a7b2f02cc2c625baf889af17": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3557c27e3615017ab8c7d2b4edf5a10f": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "16964934668758645558": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3cc2065cd9d758b7b4ccb42f67f310e1": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "77e24e974232bec792932a6d9cad855c": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "e022d351fb24f904d7cf76a74a932f25": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1c94ce366c473a12088308148b7dc866": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5ae2c1d4d4a678e71f2e7b489c2a2e4a": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "476860a2ea20f8112cf0bec8c845663b": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "93fbd4381bd491ad3d6dba8572cb01be": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1cd8e467497e9ef0ada5bf15c9f922de": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6597002198956766176": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "435f04d984cebaa7757b312a5f943067": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "f87b4fb3a9645d3e8abc73ed76fb0572": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "e8c84860ca10ea6aec4221e7afafcc1a": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b7ac5bec96bd1de444c48457a13a858d": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "d16eec885e26129773878f9058704a63": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1219e1543a92a9d2cae73a61625e9aab": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b2a34feff0273b2f61298e02afe897bd": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2a20089c6bc09179b28fa91542065d91": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "62e957ed597044819a0d49db6cfb9f38": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a485f500019e8d664dc93c37a6a0c859": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "7384636828590053418": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1961a915b048a8a457f3cf134cac94a1": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b4aa79bf570cfe9bfb3fa59c24beb6db": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "11020791951271937866": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c9208715e4912840d27bc5485fb08032": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "80f554df8f4db5e168b665e37674767b": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b29207249b68c6712fbf243e6f318c9f": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "133149eb867d7d1cdb6a3555bb5489ad": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ba98ecaf60d94aaa6c8ac685247a152d": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "7aca5ae4929be0870316c52a831254d0": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "12958730390904191521": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "7d2e383f6ecdcb69e62e6acbd9a356f": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "40a987951a45ead9ab2d4e3ab55bfc86": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "50e4fb9e6313d2fc048bff0537c9d9bc": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "d426ecd919711485e4d1e923cb9cd367": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "cc7b471209b7047084b2179373239c29": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5bf5f851b04dd628def22feb04c3cec6": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "331fa3b0bc8f1899dd70bcb1a364c312": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3010000535011146404": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "11387632805333568160": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3ee622a0ecbd09ac188f5c4855a619f": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2b0a09a69c59b482ddb8a21786fdd439": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5810985728898152653": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "16623831713806747857": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "1653902323508258478": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "4754188387179831718": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "18207673658158413385": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "12327620949908374012": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "14813405412631444771": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "7857171223917578575": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "1415893393487464817": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "3060172519121275631": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "1954785483012959664": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "10845561047281622937": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "2496041401547087770": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "6885722966767738507": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "5566180295247644916": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "927486855755331393": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "6165452071192422130": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "15282787245290348368": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "11313542145862450150": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "11246999805035486387": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "10623557657433978240": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "1440276514173143642": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "7102180478812285056": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "3949279890763234464": {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "199e5dcaf566a0e3ef9066f305e756ca": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "f1970b5cb77a6e7fc5a529b1da625738": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "7495153833538638193": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "69435364fc9442d7abb66f9ba15cbd12": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4787674494226554952": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4556706436870875570": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1585354944530892645": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9714381576908752953": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "13248733163135609423": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "899cc95b431b9ed6f4e5c04d223f1edd": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "d11d764d395b58eab0e4254911981f6c": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "17611167200590548471": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "12668387747158417143": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1350561415378564440": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "511301ba8fd1c44c317f78dc1d7d2cd1": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "24f7bff38ae38534a66dd409a15018d3": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5499413214094383533": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1668086897009702941": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b46f082b679a78cd1ddb33727d62fb22": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "7833460656650575616": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6933392829777369721": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2441400622645777626": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "74b6e1978a2d6b06046a334c4e5aa27c": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "3644717209372610241": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "13063048137843225758": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "263c56c9661db1056077c41533e9273a": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "17815072069125310254": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5700cd8388894789b7bf56117617ac8b": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "10226047386288991724": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "13348091602249849805": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "497cef32a39b3ab59a5e4f540b5c6a04": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "13928929639211242692": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "cf408d495722b0ac413071aff33e5827": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "90b4d749dc46b40ef62bb1901953e112": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "15771272847795181104": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "208f5008c39038a7105aa3d2ccfa8f76": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "14640938648747537821": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2333138298448348224": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5871646753572800414": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "10182630751496984110": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "11004354893796124535": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "14138857243207454896": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "17342033108574180851": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4393895627937872466": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4648453603379027456": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6843403734403185074": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9460229422403884383": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "b48dbbd75efb21cd0a48497f8176d0": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9703144777339823906": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5bf2410405189c2281ac6aece3298f2f": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "da5707ca6065a48a74a1dfc1d6785e39": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "d608859f730a11acc35eb186b0d25504": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "73dee6ce1a083d3cd6098e6235e8c45e": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    }
  }
}
```

`app/src/main/res/resources.properties`:

```properties
unqualifiedResLocale=en

```

`app/src/main/res/values-pt-rBR/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">Key Attestation</string>
    <string name="use_shizuku">Usar Shizuku</string>
    <string name="use_sak">Usar o atestado Knox</string>
    <string name="use_strongbox">Usar StrongBox</string>
    <string name="use_attest_key">Usar chave de atestado</string>
    <string name="import_attest_key">Importar chave de atestado</string>
    <string name="attest_device_props">Atestar props do dispositivo</string>
    <string name="id_type_serial">Atestar número de série do dispositivo</string>
    <string name="id_type_imei">Atestar IMEI do dispositivo</string>
    <string name="id_type_meid">Atestar MEID do dispositivo</string>
    <string name="include_unique_id">Incluir ID exclusivo</string>
    <string name="rkp_test">Testar RKP</string>
    <string name="reset">Redefinir</string>
    <string name="load_certs">Carregar do arquivo</string>
    <string name="save_certs">Salvar em arquivo</string>
    <string name="about">Sobre</string>
    <string name="open_source_info">Este software é de código aberto sob %2$s (%1$s).</string>
    <string name="install_shizuku">Instale o Shizuku para usar o Atestado de ID (%s).</string>
    <string name="start_shizuku">Shizuku não está em execução.</string>

    <string name="bootloader_locked">Bootloader bloqueado</string>
    <string name="bootloader_user">Root de confiança definida pelo usuário final</string>
    <string name="bootloader_unlocked">Bootloader desbloqueado</string>
    <string name="bootloader_unknown">Status do bootloader desconhecido</string>
    <string name="bootloader_summary_sw_level">Este dispositivo não suporta atestado de chave em nível de hardware.</string>
    <string name="cert_chain_not_trusted">A cadeia de certificados não é confiável</string>
    <string name="cert_chain_not_trusted_summary">Um certificado foi revogado ou a verificação de assinatura falhou na cadeia de certificados.</string>
    <string name="unknown_root_cert">Certificado root desconhecido</string>
    <string name="unknown_root_cert_summary">O certificado root não é uma autoridade de certificação confiável conhecida.</string>
    <string name="aosp_root_cert">Certificado root de atestado de software AOSP</string>
    <string name="aosp_root_cert_summary">A chave privada da chave de atestado é bem conhecida, a cadeia de certificados pode ser adulterada.</string>
    <string name="google_root_cert">Certificado root de atestado de hardware do Google</string>
    <string name="google_root_cert_summary">Dispositivos compatíveis com GMS podem usar uma chave de atestado assinada pelo Google.</string>
    <string name="google_root_cert_rkp">Provisionamento de chave remota do Google</string>
    <string name="google_root_cert_rkp_summary">A chave de atestado provisionada remotamente tem maior segurança e maior disponibilidade.</string>
    <string name="knox_root_cert">Certificado root de atestado do Samsung Knox</string>
    <string name="knox_root_cert_summary">O atestado Knox é assinado usando a chave de atestado Samsung (SAK).</string>
    <string name="oem_root_cert">Certificado root OEM</string>
    <string name="oem_root_cert_summary">Este dispositivo confia neste certificado root, mas pode não ser confiável para outras pessoas.</string>

    <string name="cert_chain">Cadeia de certificados</string>
    <string name="cert_chain_description">A cadeia de certificados é uma lista de certificados usados para autenticar uma chave. A cadeia começa com o certificado associado a essa chave, e cada certificado é assinado pelo próximo na cadeia. A cadeia termina com um certificado root, e a confiabilidade do atestado depende do certificado root da cadeia.</string>
    <string name="cert_info">Informações do certificado</string>
    <string name="cert_subject">assunto: </string>
    <string name="cert_not_before">não antes: </string>
    <string name="cert_not_after">não após: </string>
    <string name="cert_error_sign">erro de assinatura: </string>
    <string name="cert_error_revoked">revogado: </string>
    <string name="cert_error_expired">expirado: </string>
    <string name="provisioning_info_certs_issued">número de certificados emitidos nos últimos 30 dias: </string>
    <string name="provisioning_info_manufacturer">fabricante: </string>

    <string name="error_message_subtitle">Mensagens detalhadas:</string>
    <string name="error_unknown">Erro desconhecido</string>
    <string name="error_unavailable">Não é possível atestar</string>
    <string name="error_unavailable_summary">
    Falha no teste. Ajuste as opções no menu e tente novamente.
    Um motivo comum para falhas consistentes no atestado é a incapacidade de usar a chave de atestado fornecida de fábrica,
    possivelmente devido a uma configuração incorreta ou a uma partição persist corrompida.
    </string>
    <string name="error_cant_parse_cert">Não foi possível analisar o certificado</string>
    <string name="error_cant_parse_cert_summary">
    O certificado está no formato errado ou há um recurso que ainda não é compatível.
    </string>
    <string name="error_strongbox_unavailable">StrongBox não disponível</string>
    <string name="error_strongbox_unavailable_summary">
    Este dispositivo foi declarado como tendo suporte para StrongBox, mas não está disponível no momento.
    </string>
    <string name="error_deviceids_unavailable">Não foi possível atestar os IDs dos dispositivos</string>
    <string name="error_deviceids_unavailable_summary">
    Este dispositivo foi declarado como tendo suporte para Atestado de ID, mas os IDs não existem, não correspondem,
    ou o dispositivo não pode mais atestar seus IDs. Ajuste as opções no menu e tente novamente.
    </string>
    <string name="error_out_of_keys">Nenhuma chave provisionada remotamente para o atestado</string>
    <string name="error_out_of_keys_summary">
    Este dispositivo não está registrado no servidor de provisionamento de chaves ou o servidor se recusa permanentemente a emitir chaves.
    </string>
    <string name="error_out_of_keys_transient">Atualmente não há chaves provisionadas remotamente para o atestado</string>
    <string name="error_out_of_keys_transient_summary">
    O conjunto de chaves está esgotado. Tente novamente após a rede.
    Se o servidor se recusar temporariamente a emitir chaves, verifique se há atualizações do sistema.
    </string>
    <string name="error_unavailable_transient">Atualmente não é possível atestar</string>
    <string name="error_unavailable_transient_summary">
    O problema é temporário. Ajuste as opções do menu ou tente novamente mais tarde.
    </string>
    <string name="error_keys_not_provisioned">Sem chaves de atestado</string>
    <string name="error_keys_not_provisioned_summary">
    Não é possível buscar chaves de atestado provisionadas remotamente e nenhuma chave de atestado provisionada de fábrica.
    </string>
    <string name="error_remote_key_provisioning">Erro de provisionamento remoto de chave</string>
    <string name="error_remote_key_provisioning_summary">
    Não é possível buscar a chave de atestado do servidor de provisionamento de chaves.
    </string>

    <string name="rpc_hardware_info">Informações de hardware</string>
    <string name="rpc_hardware_info_description">
    As informações de hardware do componente provisionado remotamente.
    </string>
    <string name="rpc_version_number">Versão</string>
    <string name="rpc_version_number_description">
    Versão de implementação do componente de hardware provisionado remotamente.
    A versão fornecida aqui deve corresponder à versão informada no CsrPayload produzido pela interface HAL.
    </string>
    <string name="rpc_author_name">Fornecedor</string>
    <string name="rpc_author_name_description">
    O nome da organização do autor da implementação IRemotelyProvisionedComponent.
    </string>
    <string name="rpc_unique_id">Identificador</string>
    <string name="rpc_unique_id_description">
    Um identificador opaco para esta implementação de IRemotelyProvisionedComponent.
    Cada implementação deve ter um identificador distinto de todas as outras implementações, e deve ser consistente em todos os dispositivos.
    </string>
    <string name="rkp_device_info">Informações do dispositivo</string>
    <string name="rkp_device_info_description">
    As informações do dispositivo contêm informações sobre o dispositivo assinado pelo HAL IRemotelyProvisionedComponent.
    Esses valores devem ser verificados pelo servidor para verificar se a solicitação da assinatura de certificado
    criada por uma instância HAL IRemotelyProvisionedComponent, vem do dispositivo esperado
    com base nos valores carregados inicialmente durante a fabricação do dispositivo na fábrica.
    </string>
    <string name="rkp_hostname">Nome do host de provisionamento remoto</string>
    <string name="rkp_hostname_empty">Provisionamento remoto de chave desativado</string>

    <string name="attestation">Atestado</string>
    <string name="attestation_version_description"><![CDATA[<font face="sans-serif-medium">Versão:</font><br>A versão do recurso de atestado principal.]]></string>
    <string name="keymaster_version_description"><![CDATA[<font face="sans-serif-medium">Versão:</font><br>A versão da camada de abstração de hardware Keymaster ou KeyMint (HAL).]]></string>
    <string name="security_level_description"><![CDATA[<font face="sans-serif-medium">Nível de segurança:</font><br>Esta estrutura de dados indica até que ponto um recurso de software, como um par de chaves, é protegido com base em sua localização no dispositivo.<p><ul><li gap="8sp"><font face="sans-serif-medium">Software</font><br>A lógica de criação e gerenciamento do recurso está implementada no sistema Android. Para fins de criação e armazenamento de pares de chaves, esse local é menos seguro que o TEE, mas é mais seguro que o espaço de processo do seu app.</li><li gap="8sp"><font face="sans-serif-medium">TrustedEnvironment</font><br>A lógica para criar e gerenciar o recurso é implementada em hardware seguro, como um TEE. Para fins de criação e armazenamento de pares de chaves, esse local é mais seguro porque o hardware seguro é altamente resistente ao comprometimento remoto.</li><li gap="8sp"><font face="sans-serif-medium">StrongBox</font><br>A lógica para criar e gerenciar o recurso é implementada em um ambiente dedicado <a href="https://developer.android.com/training/articles/keystore#HardwareSecurityModule">Módulo de segurança de hardware</a>. Para fins de criação e armazenamento de pares de chaves, esse local é mais seguro porque é altamente resistente a comprometimentos remotos e ataques de hardware contra o módulo.</li></ul>]]></string>
    <string name="attestation_summary_format">Versão: %1$s\nNível de segurança: %2$s</string>
    <string name="attestation_challenge">Desafio de atestado</string>
    <string name="attestation_challenge_description">Contém o desafio fornecido no momento da criação da chave. Verifique se este valor corresponde ao valor fornecido pelo seu servidor. Caso contrário, seu serviço poderá ficar vulnerável à reprodução de certificados de atestado antigos.</string>
    <string name="unique_id">ID exclusivo</string>
    <string name="unique_id_description"><![CDATA[Este valor identifica o dispositivo, mas apenas por um período limitado de tempo. Ele é <a href="https://source.android.com/security/keystore/attestation#unique-id">computado</a> e usado apenas por apps do sistema. Em todos os outros apps, uniqueId está vazio.]]></string>

    <string name="empty">(vazio)</string>
    <string name="security_level_software">Software</string>
    <string name="security_level_trusted_environment">TrustedEnvironment</string>
    <string name="security_level_strongbox">StrongBox</string>

    <string name="sw_enforced_description"><![CDATA[Este item é aplicado pelo sistema Android, não pelo hardware do dispositivo.]]></string>
    <string name="tee_enforced_description"><![CDATA[Este item é aplicado pelo hardware do dispositivo.]]></string>

    <string name="authorization_list">Lista de autorização</string>
    <string name="authorization_list_purpose">Propósito</string>
    <string name="authorization_list_algorithm">Algoritmo</string>
    <string name="authorization_list_keySize">Tamanho da chave</string>
    <string name="authorization_list_digest">Resumos</string>
    <string name="authorization_list_padding">Preenchimento</string>
    <string name="authorization_list_ecCurve">Curva EC</string>
    <string name="authorization_list_rsaPublicExponent">Expoente público RSA</string>
    <string name="authorization_list_rollbackResistance">Resistência à rollback</string>
    <string name="authorization_list_activeDateTime">Data e hora ativa</string>
    <string name="authorization_list_originationExpireDateTime">Data e hora de expiração da originação</string>
    <string name="authorization_list_usageExpireDateTime">Data e hora de expiração de uso</string>
    <string name="authorization_list_noAuthRequired">Não é necessária autenticação</string>
    <string name="authorization_list_userAuthType">Tipo de autenticação do usuário</string>
    <string name="authorization_list_authTimeout">Tempo limite de autenticação</string>
    <string name="authorization_list_allowWhileOnBody">Permitir enquanto estiver no corpo</string>
    <string name="authorization_list_trustedUserPresenceRequired">Presença de usuário confiável necessária</string>
    <string name="authorization_list_trustedConfirmationRequired">Confirmação confiável necessária</string>
    <string name="authorization_list_unlockedDeviceRequired">É necessário um dispositivo desbloqueado</string>
    <string name="authorization_list_allApplications">Todos os apps</string>
    <string name="authorization_list_applicationId">ID do app</string>
    <string name="authorization_list_creationDateTime">Data e hora de criação</string>
    <string name="authorization_list_origin">Origem</string>
    <string name="authorization_list_rollbackResistant">Resistente à rollback</string>
    <string name="authorization_list_rootOfTrust">Root de confiança</string>
    <string name="authorization_list_osVersion">Versão do OS</string>
    <string name="authorization_list_osPatchLevel">Nível de patch do OS</string>
    <string name="authorization_list_attestationApplicationId">ID do app</string>
    <string name="authorization_list_attestationIdBrand">marca</string>
    <string name="authorization_list_attestationIdDevice">dispositivo</string>
    <string name="authorization_list_attestationIdProduct">produto</string>
    <string name="authorization_list_attestationIdSerial">número de série</string>
    <string name="authorization_list_attestationIdImei">IMEI</string>
    <string name="authorization_list_attestationIdSecondImei">segundo IMEI</string>
    <string name="authorization_list_attestationIdMeid">MEID</string>
    <string name="authorization_list_attestationIdManufacturer">fabricante</string>
    <string name="authorization_list_attestationIdModel">modelo</string>
    <string name="authorization_list_vendorPatchLevel">Nível do patch do fornecedor</string>
    <string name="authorization_list_bootPatchLevel">Nível do patch de inicialização</string>
    <string name="authorization_list_mgfDigest">Rsa Oaep Mgf Digest</string>
    <string name="authorization_list_earlyBootOnly">Somente inicialização antecipada</string>
    <string name="authorization_list_usageCountLimit">Limite de contagem de uso</string>
    <string name="authorization_list_deviceUniqueAttestation">Atestado exclusivo do dispositivo</string>
    <string name="authorization_list_identityCredentialKey">Chave de credencial de identidade</string>
    <string name="authorization_list_moduleHash">Hash do módulo</string>

    <string name="authorization_list_description"><![CDATA[
    Essa estrutura de dados contém as próprias propriedades do par de chaves, conforme definido na camada de abstração de hardware (HAL) Keymaster ou KeyMint. Você compara esses valores com o estado atual do dispositivo ou com um conjunto de valores esperados para verificar se um par de chaves ainda é válido para uso no seu app.
    ]]></string>
    <string name="authorization_list_purpose_description"><![CDATA[
    Especifica o conjunto de finalidades para as quais a chave pode ser usada.
    ]]></string>
    <string name="authorization_list_algorithm_description"><![CDATA[
    Especifica o algoritmo criptográfico com o qual a chave é usada. Em um objeto AuthorizationList de atestado, o valor do algoritmo é sempre RSA ou EC.
    ]]></string>
    <string name="authorization_list_keySize_description"><![CDATA[
    Especifica o tamanho, em bits, da chave, medindo da maneira normal para o algoritmo da chave.
    ]]></string>
    <string name="authorization_list_digest_description"><![CDATA[
    Especifica os algoritmos de resumo que podem ser usados ​​com a chave para executar operações de assinatura e verificação. Esta tag é relevante para chaves RSA, ECDSA e HMAC.
    ]]></string>
    <string name="authorization_list_padding_description"><![CDATA[
    Especifica os modos de preenchimento que podem ser usados ​​com a chave. Esta tag é relevante para chaves RSA e AES.
    ]]></string>
    <string name="authorization_list_ecCurve_description"><![CDATA[
    O conjunto de parâmetros usados ​​para gerar um par de chaves de curva elíptica (EC), que usa ECDSA para assinatura e verificação, dentro do keystore do sistema Android.
    ]]></string>
    <string name="authorization_list_rsaPublicExponent_description"><![CDATA[
    Especifica o valor do expoente público para um par de chaves RSA. Esta tag é relevante apenas para chaves RSA e necessária para todas as chaves RSA.
    ]]></string>
    <string name="authorization_list_rollbackResistance_description"><![CDATA[
    Indica que a chave é resistente à rollback, o que significa que, quando excluída por deleteKey ou deleteAllKeys, a chave será excluída permanentemente e inutilizável. É possível que chaves sem esta tag sejam excluídas e restauradas do backup.
    ]]></string>
    <string name="authorization_list_activeDateTime_description"><![CDATA[
    Especifica a data e hora em que a chave se torna ativa.
    ]]></string>
    <string name="authorization_list_originationExpireDateTime_description"><![CDATA[
    Especifica a data e a hora em que a chave expira para fins de assinatura e criptografia.
    ]]></string>
    <string name="authorization_list_usageExpireDateTime_description"><![CDATA[
    Especifica a data e hora em que a chave expira para fins de verificação e descriptografia.
    ]]></string>
    <string name="authorization_list_noAuthRequired_description"><![CDATA[
    Especifica que nenhuma autenticação é necessária para usar esta chave.
    ]]></string>
    <string name="authorization_list_userAuthType_description"><![CDATA[
    Especifica os tipos de autenticadores de usuário que podem ser usados ​​para autorizar esta chave.
    ]]></string>
    <string name="authorization_list_authTimeout_description"><![CDATA[
    Especifica o tempo em segundos durante o qual a chave é autorizada para uso, após a autenticação.
    ]]></string>
    <string name="authorization_list_allowWhileOnBody_description"><![CDATA[
    Permita que a chave seja usada após o período de tempo limite de autenticação se o usuário ainda estiver usando o dispositivo junto ao corpo. Observe que um sensor corporal seguro determina se o dispositivo está sendo usado no corpo do usuário.
    ]]></string>
    <string name="authorization_list_trustedUserPresenceRequired_description"><![CDATA[
    Especifica que esta chave só poderá ser usada se o usuário tiver fornecido prova de presença física.
    ]]></string>
    <string name="authorization_list_trustedConfirmationRequired_description"><![CDATA[
    Especifica que a chave só poderá ser usada se o usuário fornecer uma confirmação dos dados a serem assinados usando um token de aprovação.
    ]]></string>
    <string name="authorization_list_unlockedDeviceRequired_description"><![CDATA[
    Exija que a tela do dispositivo seja desbloqueada se a chave for usada.
    ]]></string>
    <string name="authorization_list_allApplications_description"><![CDATA[
    Indica se todos os apps em um dispositivo podem acessar o par de chaves.
    ]]></string>
    <string name="authorization_list_applicationId_description"><![CDATA[
    Quando fornecida para generateKey ou importKey, esta tag especifica os dados necessários durante todos os usos da chave.
    ]]></string>
    <string name="authorization_list_creationDateTime_description"><![CDATA[
    Especifica a data e hora em que a chave foi criada, em milissegundos, desde 1 de janeiro de 1970. Esta tag é opcional e apenas informativa.
    ]]></string>
    <string name="authorization_list_origin_description"><![CDATA[
    Especifica onde a chave foi criada, se conhecida. Esta tag não pode ser especificada durante a geração ou importação da chave e deve ser adicionada às características da chave pelo trustlet.
    ]]></string>
    <string name="authorization_list_rollbackResistant_description"><![CDATA[
    Indica que a chave é resistente à rollback, o que significa que, quando excluída por deleteKey ou deleteAllKeys, a chave será excluída permanentemente e inutilizável. É possível que chaves sem esta tag sejam excluídas e restauradas do backup.
    ]]></string>
    <string name="authorization_list_rootOfTrust_description"><![CDATA[
    Esta coleção de valores define informações importantes sobre o status do dispositivo.<br/><p>
    verifiedBootKey: <br/>Um hash seguro da chave que verifica a imagem do sistema.<br/><br/>
    deviceLocked: <br/>True se o bootloader do dispositivo estiver bloqueado, o que permite a Inicialização verificada e evita que uma imagem de dispositivo não assinada seja flashada no dispositivo.<br/><br/>
    verifiedBootState: <br/>Essa estrutura de dados fornece o estado de boot atual do dispositivo, que representa o nível de proteção fornecido ao usuário e aos apps após a inicialização do dispositivo.<br/><br/>
    verifiedBootHash: <br/>Um resumo de todos os dados protegidos pela Inicialização verificada. Para dispositivos que usam a implementação da Inicialização verificada do Android da Inicialização verificada, esse valor contém o resumo da estrutura VBMeta ou a estrutura de metadados da Inicialização verificada.
    </p>]]></string>
    <string name="authorization_list_osVersion_description"><![CDATA[
    A versão do sistema operacional Android associada ao Keymaster, especificada como um número inteiro de seis dígitos. Por exemplo, a versão 8.1.0 é representada como 080100.
    ]]></string>
    <string name="authorization_list_osPatchLevel_description"><![CDATA[
    O mês e o ano associados ao patch de segurança que está sendo usado no Keymaster, especificado como um número inteiro de seis dígitos. Por exemplo, o patch de agosto de 2018 é representado como 201808.
    ]]></string>
    <string name="authorization_list_attestationApplicationId_description"><![CDATA[
    Essa estrutura de dados reflete a crença da plataforma Android sobre quais apps têm permissão para usar o material da chave secreta sob o atestado. O ID pode compreender vários pacotes se e somente se vários pacotes compartilharem o mesmo UID.
    ]]></string>
    <string name="authorization_list_attestationIdBrand_description"><![CDATA[
    Fornece o nome da marca do dispositivo, conforme retornado por Build.BRAND no Android. Este campo é definido apenas ao solicitar atestado dos identificadores do dispositivo.
    ]]></string>
    <string name="authorization_list_attestationIdDevice_description"><![CDATA[
    Fornece o nome do dispositivo do dispositivo, conforme retornado por Build.DEVICE no Android. Este campo é definido apenas ao solicitar atestado dos identificadores do dispositivo.
    ]]></string>
    <string name="authorization_list_attestationIdProduct_description"><![CDATA[
    Fornece o nome do produto do dispositivo, conforme retornado por Build.PRODUCT no Android. Este campo é definido apenas ao solicitar atestado dos identificadores do dispositivo.
    ]]></string>
    <string name="authorization_list_attestationIdSerial_description"><![CDATA[
    Fornece o número de série do dispositivo. Este campo é definido apenas ao solicitar atestado dos identificadores do dispositivo.
    ]]></string>
    <string name="authorization_list_attestationIdImei_description"><![CDATA[
    Fornece o IMEI de um dos rádios do dispositvo para operações de geração/importação de chaves atestadas. Este campo é definido apenas ao solicitar atestado dos identificadores do dispositivo.
    ]]></string>
    <string name="authorization_list_attestationIdSecondImei_description"><![CDATA[
    Fornece um IMEI adicional de um dos rádios do dispositivo para operações de geração/importação de chaves atestadas. Este campo é definido apenas ao solicitar atestado dos identificadores do dispositivo.
    ]]></string>
    <string name="authorization_list_attestationIdMeid_description"><![CDATA[
    Fornece os MEIDs para todos os rádios do dispositivo. Este campo é definido apenas ao solicitar atestado dos identificadores do dispositivo.
    ]]></string>
    <string name="authorization_list_attestationIdManufacturer_description"><![CDATA[
    Fornece o nome do fabricante do dispositivo, conforme retornado por Build.MANUFACTURER no Android. Este campo é definido apenas ao solicitar atestado dos identificadores do dispositivo.
    ]]></string>
    <string name="authorization_list_attestationIdModel_description"><![CDATA[
    Fornece o nome do modelo do dispositivo, conforme retornado por Build.MODEL no Android. Este campo é definido apenas ao solicitar atestado dos identificadores do dispositivo.
    ]]></string>
    <string name="authorization_list_vendorPatchLevel_description"><![CDATA[
    Especifica o nível do patch de segurança da imagem do fornecedor que deve ser instalado no dispositivo para que essa chave seja usada. O valor aparece no formato AAAAMMDD, representando a data do patch de segurança do fornecedor. Por exemplo, se uma chave fosse gerada em um dispositivo Android com o patch de segurança de 1 de agosto de 2018 do fornecedor instalado, esse valor seria 20180801.
    ]]></string>
    <string name="authorization_list_bootPatchLevel_description"><![CDATA[
    Especifica o nível do patch de segurança da imagem do kernel que deve ser instalado no dispositivo para que essa chave seja usada. O valor aparece no formato AAAAMMDD, representando a data do patch de segurança do sistema. Por exemplo, se uma chave fosse gerada em um dispositivo Android com o patch de segurança de 5 de agosto de 2018 do sistema instalado, esse valor seria 20180805.
    ]]></string>
    <string name="authorization_list_mgfDigest_description"><![CDATA[
    Especifica os algoritmos de resumo MGF1 que podem ser usados ​​com criptografia/descriptografia RSA com preenchimento OAEP. Os valores possíveis são definidos pela enumeração Digest.
    ]]></string>
    <string name="authorization_list_earlyBootOnly_description"><![CDATA[
    Chaves marcadas com EARLY_BOOT_ONLY só podem ser usadas durante a inicialização inicial, até que IKeyMintDevice::earlyBootEnded() seja chamado.
    ]]></string>
    <string name="authorization_list_usageCountLimit_description"><![CDATA[
    Especifica o número de vezes que uma chave pode ser usada. Isso pode ser usado para limitar o uso de uma chave. O valor é um número inteiro de 32 bits que representa o número atual de tentativas restantes.
    ]]></string>
    <string name="authorization_list_deviceUniqueAttestation_description"><![CDATA[
    Indica que é solicitado o atestado usando uma chave exclusiva do dispositivo, em vez de uma chave em lote. Quando uma chave exclusiva do dispositivo é usada, a cadeia retornada deve conter dois ou três certificados.
    ]]></string>
    <string name="authorization_list_identityCredentialKey_description"><![CDATA[
    Ele é usado em atestados produzidos pelo HAL IIdentityCredential quando esse HAL atesta chaves de credenciais. IIdentityCredential produz atestados estilo KeyMint.
    ]]></string>
    <string name="authorization_list_moduleHash_description"><![CDATA[
    Especifica o hash SHA-256 das informações do módulo codificado em DER.
    ]]></string>

    <string name="knox">Samsung Knox Attestation</string>
    <string name="knox_description"><![CDATA[
    Samsung Knox Attestation é um recurso que verifica a integridade dos dados de um dispositivo Samsung, verificando se o dispositivo não está rooteado ou executando firmware não oficial.
    ]]></string>
    <string name="knox_id_attest">Atestado de ID</string>
    <string name="knox_id_attest_description"><![CDATA[
    Verifique se o IMEI e o número de série foram modificados.
    ]]></string>
    <string name="knox_integrity">Status de integridade</string>
    <string name="knox_integrity_description"><![CDATA[
    O Keymaster Trusted Application (TA) no Secure World coleta esses dados:
    <ul>
    <li gap="8sp">O nome do pacote do app solicitante, o código da versão e a chave do desenvolvedor.</li>
    <li gap="8sp">Informações assinadas sobre o estado atual do dispositivo e o ambiente esperado.</li>
    <li gap="8sp">Leituras de fusíveis de hardware indicando se firmware não confiável foi carregado no dispositivo.</li>
    </ul>
    ]]></string>
    <string name="knox_record_hash">Hash de registro do atestado</string>
    <string name="knox_record_hash_description"><![CDATA[
    Um resumo SHA256 do TA solicitando os dados de status de integridade do ICCC.
    ]]></string>
</resources>

```

`app/src/main/res/values-sw600dp/dimens.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <dimen name="home_padding">8dp</dimen>
</resources>
```

`app/src/main/res/values-zh-rCN/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">密钥认证</string>
    <string name="use_shizuku">使用 Shizuku</string>
    <string name="use_sak">使用 Knox 认证</string>
    <string name="use_strongbox">使用安全模块</string>
    <string name="use_attest_key">使用认证密钥</string>
    <string name="import_attest_key">导入认证密钥</string>
    <string name="attest_device_props">认证设备型号</string>
    <string name="id_type_serial">认证设备序列号</string>
    <string name="id_type_imei">认证设备 IMEI</string>
    <string name="id_type_meid">认证设备 MEID</string>
    <string name="include_unique_id">包含唯一 ID</string>
    <string name="rkp_test">远程密钥配置测试</string>
    <string name="reset">重置</string>
    <string name="load_certs">从文件加载</string>
    <string name="save_certs">保存到文件</string>
    <string name="about">关于</string>
    <string name="open_source_info">此软件是 %2$s 下的开源软件（%1$s）。</string>
    <string name="install_shizuku">安装 Shizuku 使用 ID 认证（%s）。</string>
    <string name="start_shizuku">Shizuku 未运行。</string>

    <string name="bootloader_locked">引导加载程序已锁定</string>
    <string name="bootloader_user">信任根由最终用户设置</string>
    <string name="bootloader_unlocked">引导加载程序已解锁</string>
    <string name="bootloader_unknown">引导加载程序状态未知</string>
    <string name="bootloader_summary_sw_level">该设备不支持硬件级别的密钥认证。</string>
    <string name="cert_chain_not_trusted">证书链不受信任</string>
    <string name="cert_chain_not_trusted_summary">证书链中有证书被吊销或签名验证失败。</string>
    <string name="unknown_root_cert">未知根证书</string>
    <string name="unknown_root_cert_summary">根证书不是已知可信的证书颁发机构。</string>
    <string name="aosp_root_cert">AOSP 软件认证根证书</string>
    <string name="aosp_root_cert_summary">认证密钥的私钥众所周知，证书链可以被篡改。</string>
    <string name="google_root_cert">Google 硬件认证根证书</string>
    <string name="google_root_cert_summary">兼容 GMS 的设备可以使用由 Google 签名的认证密钥。</string>
    <string name="google_root_cert_rkp">Google 远程密钥配置</string>
    <string name="google_root_cert_rkp_summary">远程配置的认证密钥有更强的安全性和更高的可用性。</string>
    <string name="knox_root_cert">三星 Knox 认证根证书</string>
    <string name="knox_root_cert_summary">Knox 认证使用三星认证密钥（SAK）签名。</string>
    <string name="oem_root_cert">设备制造商的根证书</string>
    <string name="oem_root_cert_summary">此设备信任该根证书，但它可能不被其它人信任。</string>

    <string name="cert_chain">证书链</string>
    <string name="cert_chain_description">证书链是用于验证密钥的证书列表。从该密钥的证书开始，每个证书均由链中下一个证书签名，到根证书为止。认证的可信度取决于证书链的根证书。</string>
    <string name="cert_info">证书信息</string>
    <string name="cert_subject">使用者：</string>
    <string name="cert_not_before">不早于：</string>
    <string name="cert_not_after">不晚于：</string>
    <string name="cert_error_sign">签名错误：</string>
    <string name="cert_error_revoked">已吊销：</string>
    <string name="cert_error_expired">已过期：</string>
    <string name="provisioning_info_certs_issued">过去 30 天证书颁发数量：</string>
    <string name="provisioning_info_manufacturer">制造商：</string>

    <string name="error_message_subtitle">详细信息：</string>
    <string name="error_unknown">未知错误</string>
    <string name="error_unavailable">无法认证</string>
    <string name="error_unavailable_summary">
    认证出现错误，在菜单调整选项后再试。始终无法认证的常见原因是无法使用工厂配置的认证密钥，
    可能因为设备配置有误或 persist 分区损坏。
    </string>
    <string name="error_cant_parse_cert">无法解析证书</string>
    <string name="error_cant_parse_cert_summary">
    证书格式错误或存在尚未支持的功能。
    </string>
    <string name="error_strongbox_unavailable">安全模块不可用</string>
    <string name="error_strongbox_unavailable_summary">
    设备声明支持安全模块，但实际上不可用。
    </string>
    <string name="error_deviceids_unavailable">无法认证设备 ID</string>
    <string name="error_deviceids_unavailable_summary">
    设备声明支持 ID 认证，但有 ID 不存在，不匹配或设备已无法再证明其 ID。在菜单调整选项后再试。
    </string>
    <string name="error_out_of_keys">没有远程配置的认证密钥</string>
    <string name="error_out_of_keys_summary">
    设备未向密钥配置服务器注册，或者服务器永久拒绝颁发密钥。
    </string>
    <string name="error_out_of_keys_transient">暂无远程配置的认证密钥</string>
    <string name="error_out_of_keys_transient_summary">
    密钥池已用完，请在联网环境下重试。如果服务器暂时拒绝颁发密钥，请检查系统更新。
    </string>
    <string name="error_unavailable_transient">暂时无法认证</string>
    <string name="error_unavailable_transient_summary">
    问题是暂时的，尝试在菜单调整选项，或者稍后再试。
    </string>
    <string name="error_keys_not_provisioned">没有认证密钥</string>
    <string name="error_keys_not_provisioned_summary">
    无法获取远程配置的认证密钥，也没有工厂配置的认证密钥。
    </string>
    <string name="error_remote_key_provisioning">远程密钥配置失败</string>
    <string name="error_remote_key_provisioning_summary">
    无法从密钥配置服务器获取认证密钥。
    </string>

    <string name="rpc_hardware_info">硬件信息</string>
    <string name="rpc_hardware_info_description">
    远程配置组件的硬件信息。
    </string>
    <string name="rpc_version_number">版本</string>
    <string name="rpc_version_number_description">
    远程配置组件硬件的实现版本。此处提供的版本必须与证书签名请求中报告的版本相匹配。
    </string>
    <string name="rpc_author_name">供应商</string>
    <string name="rpc_author_name_description">
    远程配置组件实现的作者的组织名称。
    </string>
    <string name="rpc_unique_id">标识符</string>
    <string name="rpc_unique_id_description">
    远程配置组件实现的不透明标识符。每个实现必须具有与所有其他实现不同的标识符，并且在所有设备上保持一致。
    </string>
    <string name="rkp_device_info">设备信息</string>
    <string name="rkp_device_info_description">
    由远程配置组件签名的设备相关信息。服务器将检查这些值，与工厂制造设备时上传的值对比，
    来验证远程配置组件实例生成的证书签名请求是否来自预期的设备。
    </string>
    <string name="rkp_hostname">远程配置服务器主机名</string>
    <string name="rkp_hostname_empty">远程密钥配置已禁用</string>

    <string name="attestation">认证</string>
    <string name="attestation_version_description"><![CDATA[<font face="sans-serif-medium">版本：</font><br>密钥认证功能的版本。]]></string>
    <string name="keymaster_version_description"><![CDATA[<font face="sans-serif-medium">版本：</font><br>Keymaster 或 KeyMint 硬件抽象层 (HAL) 的版本。]]></string>
    <string name="security_level_description"><![CDATA[<font face="sans-serif-medium">安全等级：</font><br>表示功能受保护的程度基于其在设备中的位置。<p><ul><li gap="8sp"><font face="sans-serif-medium">软件</font><br>用于创建和管理功能的逻辑在 Android 系统中实现。如果用于创建和存储密钥对，此位置没有可信环境安全，但比应用的进程空间安全。</li><li gap="8sp"><font face="sans-serif-medium">可信环境</font><br>用于创建和管理功能的逻辑在可信执行环境中实现。如果用于创建和存储密钥对，此位置比较安全，因为安全硬件更能抵御远程攻击。</li><li gap="8sp"><font face="sans-serif-medium">安全模块</font><br>用于创建和管理功能的逻辑在专用<a href="https://developer.android.com/training/articles/keystore#HardwareSecurityModule">硬件安全模块</a>中实现。对于创建和存储密钥对，此位置更安全，因为它更能抵御远程攻击和针对模块的硬件攻击。</li></ul>]]></string>
    <string name="attestation_summary_format">版本：%1$s\n安全等级：%2$s</string>
    <string name="attestation_challenge">认证质询</string>
    <string name="attestation_challenge_description">包含创建密钥时提供的质询。检查此值是否与您的服务器提供的值匹配。否则，您的服务可能容易受到旧认证证书重放的攻击。</string>
    <string name="unique_id">唯一 ID</string>
    <string name="unique_id_description"><![CDATA[此值用于标识设备，但只能在限定时间段内使用。此值通过<a href="https://source.android.com/security/keystore/attestation#unique-id">计算</a>得出，而且只能由系统应用使用。在所有其他应用中，唯一 ID 为空。]]></string>

    <string name="empty">（空）</string>
    <string name="security_level_software">软件</string>
    <string name="security_level_trusted_environment">可信环境</string>
    <string name="security_level_strongbox">安全模块</string>

    <string name="sw_enforced_description"><![CDATA[此项目由 Android 系统强制执行，而非设备的硬件。]]></string>
    <string name="tee_enforced_description"><![CDATA[此项目由设备的硬件强制执行。]]></string>

    <string name="authorization_list">授权列表</string>
    <string name="authorization_list_purpose">用途</string>
    <string name="authorization_list_algorithm">算法</string>
    <string name="authorization_list_keySize">密钥大小</string>
    <string name="authorization_list_digest">摘要</string>
    <string name="authorization_list_padding">填充</string>
    <string name="authorization_list_ecCurve">椭圆曲线</string>
    <string name="authorization_list_rsaPublicExponent">RSA 公钥指数</string>
    <string name="authorization_list_rollbackResistance">抗回滚</string>
    <string name="authorization_list_activeDateTime">激活时间</string>
    <string name="authorization_list_originationExpireDateTime">生成失效时间</string>
    <string name="authorization_list_usageExpireDateTime">使用失效时间</string>
    <string name="authorization_list_noAuthRequired">不需要身份验证</string>
    <string name="authorization_list_userAuthType">身份验证类型</string>
    <string name="authorization_list_authTimeout">身份验证超时</string>
    <string name="authorization_list_allowWhileOnBody">贴身时允许</string>
    <string name="authorization_list_trustedUserPresenceRequired">需要用户存在证明</string>
    <string name="authorization_list_trustedConfirmationRequired">需要确认证明</string>
    <string name="authorization_list_unlockedDeviceRequired">需要已解锁设备</string>
    <string name="authorization_list_allApplications">全部应用</string>
    <string name="authorization_list_applicationId">应用 ID</string>
    <string name="authorization_list_creationDateTime">创建时间</string>
    <string name="authorization_list_origin">来源</string>
    <string name="authorization_list_rollbackResistant">抗回滚</string>
    <string name="authorization_list_rootOfTrust">信任根</string>
    <string name="authorization_list_osVersion">系统版本</string>
    <string name="authorization_list_osPatchLevel">系统补丁版本</string>
    <string name="authorization_list_attestationApplicationId">应用 ID</string>
    <string name="authorization_list_attestationIdBrand">品牌</string>
    <string name="authorization_list_attestationIdDevice">设备</string>
    <string name="authorization_list_attestationIdProduct">产品</string>
    <string name="authorization_list_attestationIdSerial">序列号</string>
    <string name="authorization_list_attestationIdImei">IMEI</string>
    <string name="authorization_list_attestationIdSecondImei">第二 IMEI</string>
    <string name="authorization_list_attestationIdMeid">MEID</string>
    <string name="authorization_list_attestationIdManufacturer">制造商</string>
    <string name="authorization_list_attestationIdModel">型号</string>
    <string name="authorization_list_vendorPatchLevel">Vendor 补丁版本</string>
    <string name="authorization_list_bootPatchLevel">Boot 补丁版本</string>
    <string name="authorization_list_mgfDigest">Rsa Oaep Mgf 摘要</string>
    <string name="authorization_list_earlyBootOnly">仅早期启动</string>
    <string name="authorization_list_usageCountLimit">使用次数限制</string>
    <string name="authorization_list_deviceUniqueAttestation">设备唯一认证</string>
    <string name="authorization_list_identityCredentialKey">身份凭据密钥</string>
    <string name="authorization_list_moduleHash">模块摘要</string>

    <string name="authorization_list_description"><![CDATA[
    此数据结构包含密钥对的属性本身，如 Keymaster 或 KeyMint 硬件抽象层 (HAL) 中所定义。将这些值与设备的当前状态或一组预期值进行比较，以验证密钥对是否仍适用于您的应用。
    ]]></string>
    <string name="authorization_list_purpose_description"><![CDATA[
    用于指定相应密钥可用于哪些目的。
    ]]></string>
    <string name="authorization_list_algorithm_description"><![CDATA[
    用于指定与相应密钥配合使用的加密算法。在认证 AuthorizationList 对象中，算法值始终为 RSA 或 EC。
    ]]></string>
    <string name="authorization_list_keySize_description"><![CDATA[
    用于指定相应密钥的大小（以位数计，按适用于相应密钥算法的一般方式衡量）。
    ]]></string>
    <string name="authorization_list_digest_description"><![CDATA[
    用于指定可与相应密钥配合使用以执行签名和验证操作的摘要算法。此标记与 RSA 密钥、ECDSA 密钥和 HMAC 密钥有关。
    ]]></string>
    <string name="authorization_list_padding_description"><![CDATA[
    用于指定可与相应密钥配合使用的填充模式。此标记与 RSA 密钥和 AES 密钥有关。
    ]]></string>
    <string name="authorization_list_ecCurve_description"><![CDATA[
    Android 系统密钥库中用于生成椭圆曲线 (EC) 密钥对的参数集，该参数集使用 ECDSA 进行签名和验证。
    ]]></string>
    <string name="authorization_list_rsaPublicExponent_description"><![CDATA[
    用于为 RSA 密钥对指定公开指数的值。此标记仅与 RSA 密钥有关，而且是所有 RSA 密钥都必需的标记。
    ]]></string>
    <string name="authorization_list_rollbackResistance_description"><![CDATA[
    用于表明密钥可抗回滚，也就是说，当通过 deleteKey 或 deleteAllKeys 删除密钥后，可保证该密钥已被永久删除且无法再使用。如果密钥不带此标记，那么在被删除后，可能能够从备份中恢复。
    ]]></string>
    <string name="authorization_list_activeDateTime_description"><![CDATA[
    用于指定相应密钥变为有效状态的日期和时间。
    ]]></string>
    <string name="authorization_list_originationExpireDateTime_description"><![CDATA[
    用于指定相应密钥无法再用于签名和加密目的的过期日期和时间。
    ]]></string>
    <string name="authorization_list_usageExpireDateTime_description"><![CDATA[
    用于指定相应密钥无法再用于验证和解密目的的过期日期和时间。
    ]]></string>
    <string name="authorization_list_noAuthRequired_description"><![CDATA[
    用于指定无需进行身份验证即可使用相应密钥。
    ]]></string>
    <string name="authorization_list_userAuthType_description"><![CDATA[
    用于指定可以使用哪些类型的用户身份验证程序来授权使用相应密钥。
    ]]></string>
    <string name="authorization_list_authTimeout_description"><![CDATA[
    用于指定授权在多长时间内使用相应密钥（以秒数计，从通过身份验证开始算起）。
    ]]></string>
    <string name="authorization_list_allowWhileOnBody_description"><![CDATA[
    如果用户身上仍佩戴着设备，允许在密钥身份验证超时后使用密钥。请注意，安全的体感传感器可以确定设备是否正佩戴在用户身上。
    ]]></string>
    <string name="authorization_list_trustedUserPresenceRequired_description"><![CDATA[
    指定仅在用户提供了物理存在证明时，此密钥才可用。
    ]]></string>
    <string name="authorization_list_trustedConfirmationRequired_description"><![CDATA[
    指定仅在用户确认使用审批令牌签署数据时，此密钥才可用。
    ]]></string>
    <string name="authorization_list_unlockedDeviceRequired_description"><![CDATA[
    要求解锁设备屏幕后才能使用该密钥。
    ]]></string>
    <string name="authorization_list_allApplications_description"><![CDATA[
    指示设备上的所有应用是否都可以访问密钥对。
    ]]></string>
    <string name="authorization_list_applicationId_description"><![CDATA[
    如果将此标记提供给 generateKey 或 importKey，则可指定使用相应密钥时所必需的数据。
    ]]></string>
    <string name="authorization_list_creationDateTime_description"><![CDATA[
    用于指定相应密钥的创建日期和时间（以距 1970 年 1 月 1 日的毫秒数计）。此标记为可选标记，仅供参考。
    ]]></string>
    <string name="authorization_list_origin_description"><![CDATA[
    用于指定相应密钥是在哪里创建的（如果知道）。在生成或导入密钥期间可以不指定此标记，但此标记必须要由 Trustlet 添加到密钥特性中。
    ]]></string>
    <string name="authorization_list_rollbackResistant_description"><![CDATA[
    用于表明密钥可抗回滚，也就是说，当通过 deleteKey 或 deleteAllKeys 删除密钥后，可保证该密钥已被永久删除且无法再使用。如果密钥不带此标记，那么在被删除后，可能能够从备份中恢复。
    ]]></string>
    <string name="authorization_list_rootOfTrust_description"><![CDATA[
    这个值集合可以定义与设备状态有关的密钥信息。<br/><p>
    verifiedBootKey: <br/>验证系统映像的密钥的摘要值。<br/><br/>
    deviceLocked: <br/>在设备的引导加载程序处于锁定状态时为 true，这将启用启动时验证检查，并防止将未签名的设备映像刷写到设备上。<br/><br/>
    verifiedBootState: <br/>此数据结构提供设备的当前启动状态，表示在设备完成启动后为用户和应用提供的保护级别。<br/><br/>
    verifiedBootHash: <br/>受启动时验证保护的所有数据的摘要。对于使用 Android 启动时验证功能实现（针对启动时验证功能）的设备，此值包含 VBMeta 结构或启动时验证元数据结构的摘要。
    </p>]]></string>
    <string name="authorization_list_osVersion_description"><![CDATA[
    与 Keymaster 关联的 Android 操作系统的版本，使用一个 6 位整数表示。例如，版本 8.1.0 表示为 080100。
    ]]></string>
    <string name="authorization_list_osPatchLevel_description"><![CDATA[
    与 Keymaster 中使用的安全补丁程序关联的月份和年度，使用一个 6 位整数表示。例如，2018 年 8 月的补丁程序表示为 201808。
    ]]></string>
    <string name="authorization_list_attestationApplicationId_description"><![CDATA[
    此数据结构反映了 Android 平台允许哪些应用使用认证中的密钥材料。当且仅当多个软件包共享同一 UID 时，此 ID 才可以包含多个软件包。
    ]]></string>
    <string name="authorization_list_attestationIdBrand_description"><![CDATA[
    提供设备的品牌名称（由 Android 中的 Build.BRAND 返回）。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_attestationIdDevice_description"><![CDATA[
    提供设备的设备名称（由 Android 中的 Build.DEVICE 返回）。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_attestationIdProduct_description"><![CDATA[
    提供设备的产品名称（由 Android 中的 Build.PRODUCT 返回）。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_attestationIdSerial_description"><![CDATA[
    提供设备的序列号。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_attestationIdImei_description"><![CDATA[
    提供设备的无线装置 IMEI。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_attestationIdSecondImei_description"><![CDATA[
    提供设备的无线装置附加 IMEI。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_attestationIdMeid_description"><![CDATA[
    提供设备的无线装置 MEID。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_attestationIdManufacturer_description"><![CDATA[
    提供设备的制造商名称（由 Android 中的 Build.MANUFACTURER 返回）。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_attestationIdModel_description"><![CDATA[
    提供设备的型号名称（由 Android 中的 Build.MODEL 返回）。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_vendorPatchLevel_description"><![CDATA[
    规定为了使用此密钥而必须在设备上安装的供应商映像安全补丁级别。此值以 YYYYMMDD 的形式显示，表示供应商安全补丁的日期。例如，如果密钥在 Android 设备上生成，且相应设备安装了供应商于 2018 年 8 月 1 日提供的安全补丁，其值将表示为 20180801。
    ]]></string>
    <string name="authorization_list_bootPatchLevel_description"><![CDATA[
    规定为了使用此密钥而必须在设备上安装的内核映像安全补序级别。此值以 YYYYMMDD 的形式显示，表示系统安全补丁的日期。例如，如果密钥在 Android 设备上生成，且相应设备安装了系统于 2018 年 8 月 5 日提供的安全补丁，其值将表示为 20180805。
    ]]></string>
    <string name="authorization_list_mgfDigest_description"><![CDATA[
    指定可与带有 OAEP 填充的 RSA 加密/解密一起使用的 MGF1 摘要算法。可能的值由 Digest 枚举定义。
    ]]></string>
    <string name="authorization_list_earlyBootOnly_description"><![CDATA[
    标记为 EARLY_BOOT_ONLY 的密钥只能在早期启动时使用，直到调用 IKeyMintDevice::earlyBootEnded() 为止。
    ]]></string>
    <string name="authorization_list_usageCountLimit_description"><![CDATA[
    指定密钥的使用次数。这可用于限制密钥的使用。该值是一个 32 位整数，代表当前剩余的尝试次数。
    ]]></string>
    <string name="authorization_list_deviceUniqueAttestation_description"><![CDATA[
    它表示请求使用设备唯一密钥而非批量密钥进行验证。使用设备唯一密钥时，返回的链应包含两个或三个证书。
    ]]></string>
    <string name="authorization_list_identityCredentialKey_description"><![CDATA[
    当 IIdentityCredential HAL 对凭据密钥进行认证时，它将被用于该 HAL 生成的认证中。IIdentityCredential 生成 KeyMint 样式的证明。
    ]]></string>
    <string name="authorization_list_moduleHash_description"><![CDATA[
    用于指定 DER 编码的 APEX 模块信息的 SHA-256 摘要值
    ]]></string>

    <string name="knox">三星 Knox 认证</string>
    <string name="knox_description"><![CDATA[
    三星 Knox 认证通过检查设备是否被 Root 或运行非官方固件来验证三星设备的数据完整性。
    ]]></string>
    <string name="knox_id_attest">ID 认证</string>
    <string name="knox_id_attest_description"><![CDATA[
    检查 IMEI 和序列号是否被修改。
    ]]></string>
    <string name="knox_integrity">完整性状态</string>
    <string name="knox_integrity_description"><![CDATA[
    安全世界中的密钥管理可信应用（TA）收集这些数据：
    <ul>
    <li gap="8sp">请求应用的软件包名称、版本号和开发者密钥。</li>
    <li gap="8sp">设备当前状态和预期环境的签名信息。</li>
    <li gap="8sp">硬件保险丝读数显示设备上是否加载过不受信任的固件。</li>
    </ul>
    ]]></string>
    <string name="knox_record_hash">认证记录摘要</string>
    <string name="knox_record_hash_description"><![CDATA[
    向 ICCC 请求完整性状态数据的 TA 的 SHA256 摘要。
    ]]></string>
</resources>

```

`app/src/main/res/values-zh-rTW/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">金鑰認證</string>
    <string name="use_shizuku">使用 Shizuku</string>
    <string name="use_sak">使用 Knox 認證</string>
    <string name="use_strongbox">使用硬體安全性模組</string>
    <string name="use_attest_key">使用認證金鑰</string>
    <string name="import_attest_key">匯入認證金鑰</string>
    <string name="attest_device_props">認證裝置型號</string>
    <string name="id_type_serial">認證裝置序號</string>
    <string name="id_type_imei">認證裝置 IMEI</string>
    <string name="id_type_meid">認證裝置 MEID</string>
    <string name="include_unique_id">包含唯一識別碼</string>
    <string name="rkp_test">遠端金鑰配置測試</string>
    <string name="reset">重設</string>
    <string name="load_certs">從檔案讀取</string>
    <string name="save_certs">儲存到檔案</string>
    <string name="about">關於</string>
    <string name="open_source_info">此軟體是 %2$s 下的開源軟體（%1$s）。</string>
    <string name="install_shizuku">安裝 Shizuku 使用識別碼認證（%s）。</string>
    <string name="start_shizuku">Shizuku 未執行。</string>

    <string name="bootloader_locked">開機載入器已上鎖</string>
    <string name="bootloader_user">受信任的根憑證由終端使用者設定</string>
    <string name="bootloader_unlocked">開機載入器已解鎖</string>
    <string name="bootloader_unknown">開機載入器狀態未知</string>
    <string name="bootloader_summary_sw_level">該裝置不支援硬體等級的金鑰認證。</string>
    <string name="cert_chain_not_trusted">憑證鏈不受信任</string>
    <string name="cert_chain_not_trusted_summary">憑證鏈中有憑證被註銷或簽章驗證失敗。</string>
    <string name="unknown_root_cert">未知根憑證</string>
    <string name="unknown_root_cert_summary">根憑證不是已知可信任的憑證授權單位。</string>
    <string name="aosp_root_cert">AOSP 軟體認證的根憑證</string>
    <string name="aosp_root_cert_summary">認證金鑰的私鑰眾所周知，憑證鏈可以被篡改。</string>
    <string name="google_root_cert">Google 硬體認證的根憑證</string>
    <string name="google_root_cert_summary">相容 GMS 的裝置可以使用由 Google 簽章的認證金鑰。</string>
    <string name="google_root_cert_rkp">Google 遠端金鑰配置</string>
    <string name="google_root_cert_rkp_summary">遠端配置的認證金鑰有更強的安全性和更高的可用性。</string>
    <string name="knox_root_cert">三星 Knox 認證的根憑證</string>
    <string name="knox_root_cert_summary">Knox 認證使用三星認證金鑰（SAK）簽章。</string>
    <string name="oem_root_cert">裝置製造商的根憑證</string>
    <string name="oem_root_cert_summary">此裝置信任此根憑證，但它可能不被其它人信任。</string>

    <string name="cert_chain">憑證鏈</string>
    <string name="cert_chain_description">憑證鏈是用於驗證金鑰的憑證列表。從這個金鑰的憑證開始，每個憑證均由鏈中下一個憑證簽章，到根憑證為止。認證的可信度取決於憑證鏈的根憑證。</string>
    <string name="cert_info">憑證資訊</string>
    <string name="cert_subject">使用者：</string>
    <string name="cert_not_before">不早於：</string>
    <string name="cert_not_after">不晚於：</string>
    <string name="cert_error_sign">簽章錯誤：</string>
    <string name="cert_error_revoked">已註銷：</string>
    <string name="cert_error_expired">已過期：</string>
    <string name="provisioning_info_certs_issued">過去 30 天憑證頒發數量：</string>
    <string name="provisioning_info_manufacturer">製造商：</string>

    <string name="error_message_subtitle">詳細資訊：</string>
    <string name="error_unknown">未知錯誤</string>
    <string name="error_unavailable">無法認證</string>
    <string name="error_unavailable_summary">
    認證出現錯誤，在選單調整選項後再試。
    總是無法認證的常見原因是無法使用出廠配置的認證金鑰，可能因為裝置配置錯誤或 persist 分割區損壞。
    </string>
    <string name="error_cant_parse_cert">無法剖析憑證</string>
    <string name="error_cant_parse_cert_summary">
    憑證格式錯誤或存在尚未支援的功能。
    </string>
    <string name="error_strongbox_unavailable">無法使用硬體安全性模組</string>
    <string name="error_strongbox_unavailable_summary">
    裝置聲明支援硬體安全性模組，但實際上無法使用。
    </string>
    <string name="error_deviceids_unavailable">無法認證裝置識別碼</string>
    <string name="error_deviceids_unavailable_summary">
    裝置聲明支援識別碼認證，但識別碼不存在、不符合或裝置已無法再進行識別碼認證。在選單調整選項後再試。
    </string>
    <string name="error_out_of_keys">沒有遠端配置的認證金鑰</string>
    <string name="error_out_of_keys_summary">
    裝置未向金鑰配置伺服器註冊，或者伺服器永久拒絕頒發金鑰。
    </string>
    <string name="error_out_of_keys_transient">目前沒有遠端配置的認證金鑰</string>
    <string name="error_out_of_keys_transient_summary">
    金鑰池已用完，請在聯網環境下重試。如果伺服器暫時拒絕頒發金鑰，請檢查系統更新。
    </string>
    <string name="error_unavailable_transient">目前無法認證</string>
    <string name="error_unavailable_transient_summary">
    問題是暫時的，嘗試在選單調整選項，或者稍後再試。
    </string>
    <string name="error_keys_not_provisioned">沒有認證金鑰</string>
    <string name="error_keys_not_provisioned_summary">
    無法取得遠端配置的認證金鑰，也沒有出廠配置的認證金鑰。
    </string>
    <string name="error_remote_key_provisioning">遠端金鑰配置失敗</string>
    <string name="error_remote_key_provisioning_summary">
    無法從金鑰配置伺服器取得認證金鑰。
    </string>

    <string name="rpc_hardware_info">硬體資訊</string>
    <string name="rpc_hardware_info_description">
    遠端配置組件的硬體資訊。
    </string>
    <string name="rpc_version_number">版本</string>
    <string name="rpc_version_number_description">
    遠端配置組件硬體的實作版本。此處提供的版本必須符合憑證簽章請求中報告的版本。
    </string>
    <string name="rpc_author_name">供應商</string>
    <string name="rpc_author_name_description">
    遠端配置組件實作的作者的組織名稱。
    </string>
    <string name="rpc_unique_id">識別碼</string>
    <string name="rpc_unique_id_description">
    遠端配置組件實作的不透明識別碼。每個實作必須具有與所有其他實作不同的識別碼，並且在所有裝置上保持一致。
    </string>
    <string name="rkp_device_info">裝置資訊</string>
    <string name="rkp_device_info_description">
    由遠端配置組件簽章的裝置相關資訊。伺服器將檢查這些值，與出廠製造裝置時上傳的值對比，
    來驗證遠端配置組件實例產生的憑證簽章請求是否來自預期的裝置。
    </string>
    <string name="rkp_hostname">遠端配置伺服器主機名</string>
    <string name="rkp_hostname_empty">遠端金鑰配置已停用</string>

    <string name="attestation">認證</string>
    <string name="attestation_version_description"><![CDATA[<font face="sans-serif-medium">版本：</font><br>金鑰認證功能的版本。]]></string>
    <string name="keymaster_version_description"><![CDATA[<font face="sans-serif-medium">版本：</font><br>Keymaster 或 KeyMint 硬體抽象層（HAL）的版本。]]></string>
    <string name="security_level_description"><![CDATA[<font face="sans-serif-medium">安全等級：</font><br>代表功能受保護的程度是以其在裝置中的位置為基礎。<p><ul><li gap="8sp"><font face="sans-serif-medium">軟體</font><br>用於在 Android 系統中建立和管理功能的邏輯實作。以建立和儲存金鑰對來說，這個位置的安全性低於受信任執行環境，但高於應用程式的過程空間。</li><li gap="8sp"><font face="sans-serif-medium">受信任執行環境</font><br>用於在受信任執行環境建立和管理功能的邏輯實作。以建立和儲存金鑰對來說，這個位置比較安全，因為安全硬體更能抵禦遠端攻擊。</li><li gap="8sp"><font face="sans-serif-medium">硬體安全性模組</font><br>專門用於<a href="https://developer.android.com/training/articles/keystore#HardwareSecurityModule">硬體安全性模組</a>中建立和管理功能的邏輯實作。以建立和儲存金鑰對來說，這個位置更安全，因為它更能抵禦遠端攻擊和針對模組的硬體攻擊。</li></ul>]]></string>
    <string name="attestation_summary_format">版本：%1$s\n安全等級：%2$s</string>
    <string name="attestation_challenge">認證質詢</string>
    <string name="attestation_challenge_description">包含建立金鑰時提供的質詢。檢查這個值項目是否符合您伺服器提供的值。否則，您的服務可能容易受到舊憑證證書的重播攻擊。</string>
    <string name="unique_id">唯一識別碼</string>
    <string name="unique_id_description"><![CDATA[這個值用於識別裝置，但只能在限定時段內使用。此值透過<a href="https://source.android.com/security/keystore/attestation#unique-id">計算</a>得出，而且只能由系統應用程式使用。在所有其他應用程式中，唯一識別碼為空值。]]></string>

    <string name="empty">（空值）</string>
    <string name="security_level_software">軟體</string>
    <string name="security_level_trusted_environment">受信任執行環境</string>
    <string name="security_level_strongbox">硬體安全性模組</string>

    <string name="sw_enforced_description"><![CDATA[這個項目由 Android 系統強制執行，而非裝置的硬體。]]></string>
    <string name="tee_enforced_description"><![CDATA[這個項目由裝置的硬體強制執行。]]></string>

    <string name="authorization_list">授權列表</string>
    <string name="authorization_list_purpose">使用目的</string>
    <string name="authorization_list_algorithm">演算法</string>
    <string name="authorization_list_keySize">金鑰大小</string>
    <string name="authorization_list_digest">摘要</string>
    <string name="authorization_list_padding">填充</string>
    <string name="authorization_list_ecCurve">橢圓曲線</string>
    <string name="authorization_list_rsaPublicExponent">RSA 公鑰指數</string>
    <string name="authorization_list_rollbackResistance">抗回滾</string>
    <string name="authorization_list_activeDateTime">啟用時間</string>
    <string name="authorization_list_originationExpireDateTime">簽名和加密的失效時間</string>
    <string name="authorization_list_usageExpireDateTime">驗證和解密的失效時間</string>
    <string name="authorization_list_noAuthRequired">不需要身份驗證</string>
    <string name="authorization_list_userAuthType">身份驗證類型</string>
    <string name="authorization_list_authTimeout">身份驗證逾時</string>
    <string name="authorization_list_allowWhileOnBody">允許貼身時</string>
    <string name="authorization_list_trustedUserPresenceRequired">需要使用者存在證明</string>
    <string name="authorization_list_trustedConfirmationRequired">需要確認證明</string>
    <string name="authorization_list_unlockedDeviceRequired">需要已解鎖的裝置</string>
    <string name="authorization_list_allApplications">全部應用程式</string>
    <string name="authorization_list_applicationId">應用程式識別碼</string>
    <string name="authorization_list_creationDateTime">建立時間</string>
    <string name="authorization_list_origin">來源</string>
    <string name="authorization_list_rollbackResistant">抗回滾</string>
    <string name="authorization_list_rootOfTrust">信任根</string>
    <string name="authorization_list_osVersion">系統版本</string>
    <string name="authorization_list_osPatchLevel">系統安全性修補版本</string>
    <string name="authorization_list_attestationApplicationId">應用識別碼</string>
    <string name="authorization_list_attestationIdBrand">品牌</string>
    <string name="authorization_list_attestationIdDevice">裝置</string>
    <string name="authorization_list_attestationIdProduct">產品</string>
    <string name="authorization_list_attestationIdSerial">序號</string>
    <string name="authorization_list_attestationIdImei">IMEI</string>
    <string name="authorization_list_attestationIdSecondImei">第二 IMEI</string>
    <string name="authorization_list_attestationIdMeid">MEID</string>
    <string name="authorization_list_attestationIdManufacturer">製造商</string>
    <string name="authorization_list_attestationIdModel">型號</string>
    <string name="authorization_list_vendorPatchLevel">供應商修補版本</string>
    <string name="authorization_list_bootPatchLevel">開機修補版本</string>
    <string name="authorization_list_mgfDigest">RSA-OAEP MGF 函數</string>
    <string name="authorization_list_earlyBootOnly">只在早期開機</string>
    <string name="authorization_list_usageCountLimit">使用次數限制</string>
    <string name="authorization_list_deviceUniqueAttestation">裝置唯一認證</string>
    <string name="authorization_list_identityCredentialKey">識別憑證金鑰</string>
    <string name="authorization_list_moduleHash">模組摘要</string>

    <string name="authorization_list_description"><![CDATA[
    此資料結構包含金鑰對的屬性本身，如 Keymaster 或 KeyMint 硬體抽象層 (HAL) 中所定義。將這些值與裝置的目前狀態或一組預期值進行比較，以驗證金鑰對是否仍適用於您的應用程式。
    ]]></string>
    <string name="authorization_list_purpose_description"><![CDATA[
    用於這組金鑰的用途組合。
    ]]></string>
    <string name="authorization_list_algorithm_description"><![CDATA[
    指定使用金鑰的加密編譯演算法。
    ]]></string>
    <string name="authorization_list_keySize_description"><![CDATA[
    用於指定對應金鑰的大小（以位元為單位），以金鑰演算法的一般方式進行測量。
    ]]></string>
    <string name="authorization_list_digest_description"><![CDATA[
    用於指定要執行金鑰簽署和驗證作業搭配使用的摘要演算法。這個標記與 RSA、ECDSA 和 HMAC 金鑰相關。
    ]]></string>
    <string name="authorization_list_padding_description"><![CDATA[
    用於指定可與金鑰搭配使用的填充模式。此標記與 RSA 金鑰和 AES 金鑰有關。
    ]]></string>
    <string name="authorization_list_ecCurve_description"><![CDATA[
    用於指定 Android 系統金鑰庫中，建立橢圓曲線 (EC) 金鑰對的參數集，該參數集使用 ECDSA 進行簽章和驗證。
    ]]></string>
    <string name="authorization_list_rsaPublicExponent_description"><![CDATA[
    用於為 RSA 金鑰對指定公開指數的值。此標記只與 RSA 金鑰有關，而且是所有 RSA 金鑰都必需的標記。
    ]]></string>
    <string name="authorization_list_rollbackResistance_description"><![CDATA[
    用於聲明金鑰無法復原，也就是說，當通過 deleteKey 或 deleteAllKeys 刪除金鑰後，可保證金鑰已被永久刪除且無法再使用。如果金鑰沒有這個標記，那麼在被刪除後，可能能夠從備份中恢復。
    ]]></string>
    <string name="authorization_list_activeDateTime_description"><![CDATA[
    用於指定金鑰生效的日期和時間。
    ]]></string>
    <string name="authorization_list_originationExpireDateTime_description"><![CDATA[
    用於指定金鑰到期的日期和時間，以便用於簽署和加密用途。
    ]]></string>
    <string name="authorization_list_usageExpireDateTime_description"><![CDATA[
    用於指定對應金鑰無法再用於驗證和解密目的的過期日期和時間。
    ]]></string>
    <string name="authorization_list_noAuthRequired_description"><![CDATA[
    用於指定使用此金鑰時不需要驗證。
    ]]></string>
    <string name="authorization_list_userAuthType_description"><![CDATA[
    用於指定可用於授權此金鑰的使用者驗證器類型。
    ]]></string>
    <string name="authorization_list_authTimeout_description"><![CDATA[
    用於指定金鑰在驗證後，可使用的時間長度 (以秒為單位，從通過身份驗證開始算起)。
    ]]></string>
    <string name="authorization_list_allowWhileOnBody_description"><![CDATA[
    如果使用者身上仍佩戴著裝置，允許在金鑰身份驗證逾時後使用金鑰。請注意，安全的貼身感測器可以確定裝置是否正佩戴在使用者身上。
    ]]></string>
    <string name="authorization_list_trustedUserPresenceRequired_description"><![CDATA[
    指定只有在使用者提供了物理存在證明時，此金鑰才可用。
    ]]></string>
    <string name="authorization_list_trustedConfirmationRequired_description"><![CDATA[
    指定只有在使用者確認使用簽署金鑰簽署資料時，此金鑰才可用。
    ]]></string>
    <string name="authorization_list_unlockedDeviceRequired_description"><![CDATA[
    要求解鎖裝置鎖定畫面後才能使用該金鑰。
    ]]></string>
    <string name="authorization_list_allApplications_description"><![CDATA[
    指示裝置上的所有應用程式是否都可以存取金鑰對。
    ]]></string>
    <string name="authorization_list_applicationId_description"><![CDATA[
    如果將此標記提供給 generateKey 或 importKey，則可指定使用對應金鑰時所必需的資料。
    ]]></string>
    <string name="authorization_list_creationDateTime_description"><![CDATA[
    用於指定金鑰的建立日期和時間（以距 1970 年 1 月 1 日的毫秒數計）。此標記為選配標記，僅供參考。
    ]]></string>
    <string name="authorization_list_origin_description"><![CDATA[
    用於指定金鑰的建立位置（如果知道）。在建立或匯入金鑰期間可以不指定此標記，但此標記必須要由 Trustlet 新增到金鑰特性中。
    ]]></string>
    <string name="authorization_list_rollbackResistant_description"><![CDATA[
    用於聲明金鑰無法復原，也就是說，當通過 deleteKey 或 deleteAllKeys 刪除金鑰後，可保證金鑰已被永久刪除且無法再使用。如果金鑰沒有這個標記，那麼在被刪除後，可能能夠從備份中恢復。
    ]]></string>
    <string name="authorization_list_rootOfTrust_description"><![CDATA[
    這個值的集合可以定義與裝置狀態有關的金鑰資訊。<br/><p>
    verifiedBootKey: <br/>驗證系統映像金鑰的摘要值。<br/><br/>
    deviceLocked: <br/>在裝置的開機載入器處於上鎖狀態時為 true，這將啟用開機驗證時檢查，並防止將未簽章的裝置映像刷寫到裝置上。<br/><br/>
    verifiedBootState: <br/>此資料結構提供裝置的目前開機狀態，表示在裝置完成開機後為使用者和應用程式提供的保護等級。<br/><br/>
    verifiedBootHash: <br/>受開機驗證時保護的所有資料的摘要。對於使用 Android 開機驗證功能實作（針對開機驗證功能）的裝置，此值包含 VBMeta 結構或開機時驗證中繼資料結構的摘要。
    </p>]]></string>
    <string name="authorization_list_osVersion_description"><![CDATA[
    與 Keymaster 關聯 Android 作業系統的版本，使用一個 6 位整數表示。例如：版本 8.1.0 表示為 080100。
    ]]></string>
    <string name="authorization_list_osPatchLevel_description"><![CDATA[
    與 Keymaster 關聯 Android 安全性更新修補的月份和年度，使用一個 6 位整數表示。例如：2018 年 8 月的更新修補表示為 201808。
    ]]></string>
    <string name="authorization_list_attestationApplicationId_description"><![CDATA[
    此資料結構反映了 Android 平台允許哪些應用程式使用認證中的金鑰材料。只有多個套件軟體共享同一個 UID 時，此識別碼才可以包含多個套件軟體。
    ]]></string>
    <string name="authorization_list_attestationIdBrand_description"><![CDATA[
    提供裝置的品牌名稱（由 Android 中的 Build.BRAND 回傳）。只在請求認證該裝置的識別碼時才會設置此欄位。
    ]]></string>
    <string name="authorization_list_attestationIdDevice_description"><![CDATA[
    提供裝置的裝置名稱（由 Android 中的 Build.DEVICE 回傳）。只在請求認證該裝置的識別碼時才會設置此欄位。
    ]]></string>
    <string name="authorization_list_attestationIdProduct_description"><![CDATA[
    提供裝置的產品名稱（由 Android 中的 Build.PRODUCT 回傳）。只在請求認證該裝置的識別碼時才會設置此欄位。
    ]]></string>
    <string name="authorization_list_attestationIdSerial_description"><![CDATA[
    提供裝置的序號。只在請求認證該裝置的識別碼時才會設置此欄位。
    ]]></string>
    <string name="authorization_list_attestationIdImei_description"><![CDATA[
    提供裝置的 IMEI 碼。只在請求認證該裝置的識別碼時才會設置此欄位。
    ]]></string>
    <string name="authorization_list_attestationIdSecondImei_description"><![CDATA[
    提供裝置的第二 IMEI 碼。只在請求認證該裝置的識別碼時才會設置此欄位。
    ]]></string>
    <string name="authorization_list_attestationIdMeid_description"><![CDATA[
    提供裝置的 MEID 碼。只在請求認證該裝置的識別碼時才會設置此欄位。
    ]]></string>
    <string name="authorization_list_attestationIdManufacturer_description"><![CDATA[
    提供裝置的製造商名稱（由 Android 中的 Build.MANUFACTURER 回傳）。只在請求認證該裝置的識別碼時才會設置此欄位。
    ]]></string>
    <string name="authorization_list_attestationIdModel_description"><![CDATA[
    提供裝置的型號名稱（由 Android 中的 Build.MODEL 回傳）。只在請求認證該裝置的識別碼時才會設置此欄位。
    ]]></string>
    <string name="authorization_list_vendorPatchLevel_description"><![CDATA[
    規定為了使用此金鑰而必須在裝置上安裝的供應商映像安全更新修補等級。此值以 YYYYMMDD 的形式顯示，表示供應商安全更新修補的日期。例如：如果金鑰在 Android 裝置上產生，且對應裝置安裝了供應商於 2018 年 8 月 1 日提供的安全更新修補，其值將表示為 20180801。
    ]]></string>
    <string name="authorization_list_bootPatchLevel_description"><![CDATA[
    規定為了使用此金鑰而必須在裝置上安裝的內核映像安全更新修補等級。此值以 YYYYMMDD 的形式顯示，表示內核安全更新修補的日期。例如：如果金鑰在 Android 裝置上產生，且對應裝置安裝了內核於 2018 年 8 月 5 日提供的安全更新修補，其值將表示為 20180805。
    ]]></string>
    <string name="authorization_list_mgfDigest_description"><![CDATA[
    指定帶有 OAEP 填充的 RSA 加密/解密一起使用的 MGF1 摘要算法。可能的值由「摘要」枚舉定義。
    ]]></string>
    <string name="authorization_list_earlyBootOnly_description"><![CDATA[
    標記為 EARLY_BOOT_ONLY 的金鑰只能在早期開機時使用，直到調用 IKeyMintDevice::earlyBootEnded() 為止。
    ]]></string>
    <string name="authorization_list_usageCountLimit_description"><![CDATA[
    指定金鑰的使用次數。這可用於限制金鑰的使用。該值是一個 32 位元整數，代表目前剩餘的嘗試次數。
    ]]></string>
    <string name="authorization_list_deviceUniqueAttestation_description"><![CDATA[
    它表示請求使用裝置唯一金鑰而非批次金鑰進行驗證。使用裝置唯一金鑰時，回傳的憑證鏈應該包含兩個或三個憑證。
    ]]></string>
    <string name="authorization_list_identityCredentialKey_description"><![CDATA[
    當 IIdentityCredential HAL 對簽署金鑰進行認證時，它將被用於該 HAL 產生的認證中。IIdentityCredential 產生 KeyMint 樣式的證明。
    ]]></string>
    <string name="authorization_list_moduleHash_description"><![CDATA[
    用於指定 DER 編碼的 APEX 模組資訊的 SHA-256 摘要值。
    ]]></string>

    <string name="knox">三星 Knox 認證</string>
    <string name="knox_description"><![CDATA[
    三星 Knox 認證通過檢查裝置是否被 Root 或執行非官方韌體來驗證三星裝置的資料完整性。
    ]]></string>
    <string name="knox_id_attest">識別碼認證</string>
    <string name="knox_id_attest_description"><![CDATA[
    檢查 IMEI 和序號是否被修改。
    ]]></string>
    <string name="knox_integrity">完整性狀態</string>
    <string name="knox_integrity_description"><![CDATA[
    安全世界中的金鑰管理可信任應用程式（TA）蒐集這些資料：
    <ul>
    <li gap="8sp">請求應用程式的套件軟體名稱、版本號碼和開發者金鑰。</li>
    <li gap="8sp">裝置目前狀態和預期環境的簽章資訊。</li>
    <li gap="8sp">硬體保險絲讀數顯示裝置上是否讀取過不受信任的韌體。</li>
    </ul>
    ]]></string>
    <string name="knox_record_hash">認證記錄摘要</string>
    <string name="knox_record_hash_description"><![CDATA[
    向 ICCC 請求完整性狀態資料的 TA 的 SHA256 摘要值。
    ]]></string>
</resources>

```

`app/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="color_background_dark">#365161</color>
    <color name="color_floating_background_dark">#465f6d</color>
    <color name="icon_background">#1765a4</color>
    <color name="color_safe">#efe0f7fA</color>
    <color name="color_warning">#efffd180</color>
    <color name="color_alert">#efff8a80</color>
    <color name="color_inactive">#88ffffff</color>
    <color name="color_accent">#E1F5FE</color>
</resources>
```

`app/src/main/res/values/dimens.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <dimen name="home_padding">0dp</dimen>
</resources>
```

`app/src/main/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">Key Attestation</string>
    <string name="use_shizuku">Use Shizuku</string>
    <string name="use_sak">Use Knox attestation</string>
    <string name="use_strongbox">Use StrongBox</string>
    <string name="use_attest_key">Use attest key</string>
    <string name="import_attest_key">Import attest key</string>
    <string name="attest_device_props">Attest device props</string>
    <string name="id_type_serial">Attest device serial</string>
    <string name="id_type_imei">Attest device IMEI</string>
    <string name="id_type_meid">Attest device MEID</string>
    <string name="include_unique_id">Include unique ID</string>
    <string name="rkp_test">RKP test</string>
    <string name="reset">Reset</string>
    <string name="load_certs">Load from file</string>
    <string name="save_certs">Save to file</string>
    <string name="about">About</string>
    <string name="open_source_info">This software is open source under %2$s (%1$s).</string>
    <string name="install_shizuku">Install Shizuku to use ID attestation (%s).</string>
    <string name="start_shizuku">Shizuku is not running.</string>

    <string name="bootloader_locked">Bootloader is locked</string>
    <string name="bootloader_user">Root of trust set by end user</string>
    <string name="bootloader_unlocked">Bootloader is unlocked</string>
    <string name="bootloader_unknown">Bootloader status is unknown</string>
    <string name="bootloader_summary_sw_level">This device does not support hardware-level key attestation.</string>
    <string name="cert_chain_not_trusted">Certificate chain is not trusted</string>
    <string name="cert_chain_not_trusted_summary">A certificate has been revoked or signature verification failed in the certificate chain.</string>
    <string name="unknown_root_cert">Unknown root certificate</string>
    <string name="unknown_root_cert_summary">Root certificate is not a known trusted certificate authority.</string>
    <string name="aosp_root_cert">AOSP software attestation root certificate</string>
    <string name="aosp_root_cert_summary">Private key of attestation key is well-known, the certificate chain can be tampered with.</string>
    <string name="google_root_cert">Google hardware attestation root certificate</string>
    <string name="google_root_cert_summary">GMS compatible devices can use an attestation key signed by Google.</string>
    <string name="google_root_cert_rkp">Google remote key provisioning</string>
    <string name="google_root_cert_rkp_summary">Remotely provisioned attestation key has stronger security and higher availability.</string>
    <string name="knox_root_cert">Samsung Knox attestation root certificate</string>
    <string name="knox_root_cert_summary">Knox attestation is signed using Samsung attestation key (SAK).</string>
    <string name="oem_root_cert">OEM root certificate</string>
    <string name="oem_root_cert_summary">This device trusts this root certificate, but it may not be trusted by others.</string>

    <string name="cert_chain">Certificate chain</string>
    <string name="cert_chain_description">Certificate chain is a list of certificates used to authenticate a key. The chain starts with the certificate associated with that key, and each certificate is signed by the next in the chain. The chain ends with a root certificate, and the trustworthiness of the attestation depends on the root certificate of the chain..</string>
    <string name="cert_info">Certificate info</string>
    <string name="cert_subject">subject: </string>
    <string name="cert_not_before">not before: </string>
    <string name="cert_not_after">not after: </string>
    <string name="cert_error_sign">signature error: </string>
    <string name="cert_error_revoked">revoked: </string>
    <string name="cert_error_expired">expired: </string>
    <string name="provisioning_info_certs_issued">number of certs issued in last 30 days: </string>
    <string name="provisioning_info_manufacturer">manufacturer: </string>

    <string name="error_message_subtitle">Detailed messages:</string>
    <string name="error_unknown">Unknown error</string>
    <string name="error_unavailable">Unable to attest</string>
    <string name="error_unavailable_summary">
    Attest failed. Adjust options in the menu and try again.
    A common reason for consistently failing to attest is the inability to use the factory provisioned attestation key,
    possibly due to a misconfigured device or a corrupt persist partition.
    </string>
    <string name="error_cant_parse_cert">Unable to parse certificate</string>
    <string name="error_cant_parse_cert_summary">
    The certificate format is incorrect or contains unsupported features.
    </string>
    <string name="error_strongbox_unavailable">StrongBox not available</string>
    <string name="error_strongbox_unavailable_summary">
    This device is declared to have StrongBox support, but it is currently unavailable.
    </string>
    <string name="error_deviceids_unavailable">Unable to attest device IDs</string>
    <string name="error_deviceids_unavailable_summary">
    This device is declared to have ID attestation support, but IDs do not exist, do not match,
    or the device can no longer attest its IDs. Adjust options in the menu and try again.
    </string>
    <string name="error_out_of_keys">No remotely provisioned keys for attestation</string>
    <string name="error_out_of_keys_summary">
    This device is not registered with the key provisioning server, or the server permanently refuses to issue keys.
    </string>
    <string name="error_out_of_keys_transient">Currently no remotely provisioned keys for attestation</string>
    <string name="error_out_of_keys_transient_summary">
    The key pool is exhausted. Please retry after networking.
    If the server temporarily refuses to issue keys, check for system updates.
    </string>
    <string name="error_unavailable_transient">Currently unable to attest</string>
    <string name="error_unavailable_transient_summary">
    The problem is temporary. Adjust options in the menu or try again later.
    </string>
    <string name="error_keys_not_provisioned">No attestation keys</string>
    <string name="error_keys_not_provisioned_summary">
    Unable to fetch remotely provisioned attestation keys, and no factory provisioned attestation keys.
    </string>
    <string name="error_remote_key_provisioning">Remote Key Provisioning Error</string>
    <string name="error_remote_key_provisioning_summary">
    Unable to fetch attestation key from key provisioning server.
    </string>

    <string name="rpc_hardware_info">Hardware info</string>
    <string name="rpc_hardware_info_description">
    The hardware information of remotely provisioned component.
    </string>
    <string name="rpc_version_number">Version</string>
    <string name="rpc_version_number_description">
    Implementation version of the remotely provisioned component hardware.
    The version provided here must match the version reported in the CsrPayload produced by the HAL interface.
    </string>
    <string name="rpc_author_name">Vendor</string>
    <string name="rpc_author_name_description">
    The organization name of the author of the IRemotelyProvisionedComponent implementation.
    </string>
    <string name="rpc_unique_id">Identifier</string>
    <string name="rpc_unique_id_description">
    An opaque identifier for this IRemotelyProvisionedComponent implementation.
    Each implementation must have a distinct identifier from all other implementations, and it must be consistent across all devices.
    </string>
    <string name="rkp_device_info">Device info</string>
    <string name="rkp_device_info_description">
    Device info contains information about the device that is signed by the IRemotelyProvisionedComponent HAL.
    These values are intended to be checked by the server to verify that the certificate signing request,
    crafted by an IRemotelyProvisionedComponent HAL instance is coming from the expected device
    based on values initially uploaded during device\'s manufacture at the factory.
    </string>
    <string name="rkp_hostname">Remote provisioning hostname</string>
    <string name="rkp_hostname_empty">Remote key provisioning disabled</string>

    <string name="attestation">Attestation</string>
    <string name="attestation_version_description"><![CDATA[<font face="sans-serif-medium">Version:</font><br>The version of the key attestation feature.]]></string>
    <string name="keymaster" translatable="false">Keymaster / KeyMint</string>
    <string name="keymaster_version_description"><![CDATA[<font face="sans-serif-medium">Version:</font><br>The version of the Keymaster or KeyMint hardware abstraction layer (HAL).]]></string>
    <string name="security_level_description"><![CDATA[<font face="sans-serif-medium">Security level:</font><br>This data structure indicates the extent to which a software feature, such as a key pair, is protected based on its location on the device.<p><ul><li gap="8sp"><font face="sans-serif-medium">Software</font><br>The logic for creating and managing the feature is implemented in the Android system. For the purposes of creating and storing key pairs, this location is less secure than the TEE but is more secure than your app\'s process space.</li><li gap="8sp"><font face="sans-serif-medium">TrustedEnvironment</font><br>The logic for creating and managing the feature is implemented in secure hardware, such as a TEE. For the purposes of creating and storing key pairs, this location is more secure because secure hardware is highly resistant to remote compromise.</li><li gap="8sp"><font face="sans-serif-medium">StrongBox</font><br>The logic for creating and managing the feature is implemented in a dedicated <a href="https://developer.android.com/training/articles/keystore#HardwareSecurityModule">Hardware security module</a>. For the purposes of creating and storing key pairs, this location is more secure because it is highly resistant to remote compromise and hardware attacks against the module.</li></ul>]]></string>
    <string name="attestation_summary_format">Version: %1$s\nSecurity level: %2$s</string>
    <string name="attestation_challenge">Attestation challenge</string>
    <string name="attestation_challenge_description">Contains the challenge that was provided at key creation time. Check whether this value matches the value your server provided. Otherwise, your service might be vulnerable to replaying of old attestation certificates.</string>
    <string name="unique_id">Unique ID</string>
    <string name="unique_id_description"><![CDATA[This value identifies the device, but only for a limited period of time. It is <a href="https://source.android.com/security/keystore/attestation#unique-id">computed</a> and is only used by system apps. In all other apps, uniqueId is empty.]]></string>

    <string name="empty">(empty)</string>
    <string name="security_level_software">Software</string>
    <string name="security_level_trusted_environment">TrustedEnvironment</string>
    <string name="security_level_strongbox">StrongBox</string>

    <string name="sw_enforced" translatable="false">SW</string>
    <string name="sw_enforced_description"><![CDATA[This item is enforced by the Android system, not by the device\'s hardware.]]></string>
    <string name="tee_enforced" translatable="false">HW</string>
    <string name="tee_enforced_description"><![CDATA[This item is enforced by the device\'s hardware.]]></string>

    <string name="authorization_list">Authorization list</string>
    <string name="authorization_list_purpose">Purpose</string>
    <string name="authorization_list_algorithm">Algorithm</string>
    <string name="authorization_list_keySize">Key size</string>
    <string name="authorization_list_digest">Digests</string>
    <string name="authorization_list_padding">Padding</string>
    <string name="authorization_list_ecCurve">EC curve</string>
    <string name="authorization_list_rsaPublicExponent">RSA public exponent</string>
    <string name="authorization_list_rollbackResistance">Rollback resistance</string>
    <string name="authorization_list_activeDateTime">Active date time</string>
    <string name="authorization_list_originationExpireDateTime">Origination expire date time</string>
    <string name="authorization_list_usageExpireDateTime">Usage expire date time</string>
    <string name="authorization_list_noAuthRequired">No auth required</string>
    <string name="authorization_list_userAuthType">User auth type</string>
    <string name="authorization_list_authTimeout">Auth timeout</string>
    <string name="authorization_list_allowWhileOnBody">Allow while on body</string>
    <string name="authorization_list_trustedUserPresenceRequired">Trusted user presence required</string>
    <string name="authorization_list_trustedConfirmationRequired">Trusted confirmation required</string>
    <string name="authorization_list_unlockedDeviceRequired">Unlocked device required</string>
    <string name="authorization_list_allApplications">All apps</string>
    <string name="authorization_list_applicationId">App ID</string>
    <string name="authorization_list_creationDateTime">Creation date time</string>
    <string name="authorization_list_origin">Origin</string>
    <string name="authorization_list_rollbackResistant">Rollback resistant</string>
    <string name="authorization_list_rootOfTrust">Root of trust</string>
    <string name="authorization_list_osVersion">OS version</string>
    <string name="authorization_list_osPatchLevel">OS patch level</string>
    <string name="authorization_list_attestationApplicationId">app ID</string>
    <string name="authorization_list_attestationIdBrand">brand</string>
    <string name="authorization_list_attestationIdDevice">device</string>
    <string name="authorization_list_attestationIdProduct">product</string>
    <string name="authorization_list_attestationIdSerial">serial</string>
    <string name="authorization_list_attestationIdImei">IMEI</string>
    <string name="authorization_list_attestationIdSecondImei">second IMEI</string>
    <string name="authorization_list_attestationIdMeid">MEID</string>
    <string name="authorization_list_attestationIdManufacturer">manufacturer</string>
    <string name="authorization_list_attestationIdModel">model</string>
    <string name="authorization_list_vendorPatchLevel">Vendor patch level</string>
    <string name="authorization_list_bootPatchLevel">Boot patch level</string>
    <string name="authorization_list_mgfDigest">Rsa Oaep Mgf Digest</string>
    <string name="authorization_list_earlyBootOnly">Early boot only</string>
    <string name="authorization_list_usageCountLimit">Usage count limit</string>
    <string name="authorization_list_deviceUniqueAttestation">Device unique attestation</string>
    <string name="authorization_list_identityCredentialKey">Identity credential key</string>
    <string name="authorization_list_moduleHash">Module hash</string>

    <string name="authorization_list_description"><![CDATA[
    This data structure contains the key pair\'s properties themselves, as defined in the Keymaster or KeyMint hardware abstraction layer (HAL). You compare these values to the device\'s current state or to a set of expected values to verify that a key pair is still valid for use in your app.
    ]]></string>
    <string name="authorization_list_purpose_description"><![CDATA[
    Specifies the set of purposes for which the key may be used.
    ]]></string>
    <string name="authorization_list_algorithm_description"><![CDATA[
    Specifies the cryptographic algorithm with which the key is used. In an attestation AuthorizationList object, the algorithm value is always RSA or EC.
    ]]></string>
    <string name="authorization_list_keySize_description"><![CDATA[
    Specifies the size, in bits, of the key, measuring in the normal way for the key\'s algorithm.
    ]]></string>
    <string name="authorization_list_digest_description"><![CDATA[
    Specifies the digest algorithms that may be used with the key to perform signing and verification operations. This tag is relevant to RSA, ECDSA and HMAC keys.
    ]]></string>
    <string name="authorization_list_padding_description"><![CDATA[
    Specifies the padding modes that may be used with the key. This tag is relevant to RSA and AES keys.
    ]]></string>
    <string name="authorization_list_ecCurve_description"><![CDATA[
    The set of parameters used to generate an elliptic curve (EC) key pair, which uses ECDSA for signing and verification, within the Android system keystore.
    ]]></string>
    <string name="authorization_list_rsaPublicExponent_description"><![CDATA[
    Specifies the value of the public exponent for an RSA key pair. This tag is relevant only to RSA keys, and necessary for all RSA keys.
    ]]></string>
    <string name="authorization_list_rollbackResistance_description"><![CDATA[
    Indicates that the key is rollback-resistant, meaning that when deleted by deleteKey or deleteAllKeys, the key is guaranteed to be permanently deleted and unusable. It\'s possible that keys without this tag could be deleted and then restored from backup.
    ]]></string>
    <string name="authorization_list_activeDateTime_description"><![CDATA[
    Specifies the date and time at which the key becomes active.
    ]]></string>
    <string name="authorization_list_originationExpireDateTime_description"><![CDATA[
    Specifies the date and time at which the key expires for signing and encryption purposes.
    ]]></string>
    <string name="authorization_list_usageExpireDateTime_description"><![CDATA[
    Specifies the date and time at which the key expires for verification and decryption purposes.
    ]]></string>
    <string name="authorization_list_noAuthRequired_description"><![CDATA[
    Specifies that no authentication is required to use this key.
    ]]></string>
    <string name="authorization_list_userAuthType_description"><![CDATA[
    Specifies the types of user authenticators that may be used to authorize this key.
    ]]></string>
    <string name="authorization_list_authTimeout_description"><![CDATA[
    Specifies the time in seconds for which the key is authorized for use, after authentication.
    ]]></string>
    <string name="authorization_list_allowWhileOnBody_description"><![CDATA[
    Allows the key to be used after its authentication timeout period if the user is still wearing the device on their body. Note that a secure on-body sensor determines whether the device is being worn on the user\'s body.
    ]]></string>
    <string name="authorization_list_trustedUserPresenceRequired_description"><![CDATA[
    Specifies that this key is usable only if the user has provided proof of physical presence.
    ]]></string>
    <string name="authorization_list_trustedConfirmationRequired_description"><![CDATA[
    Specifies that the key is usable only if the user provides confirmation of the data to be signed using an approval token.
    ]]></string>
    <string name="authorization_list_unlockedDeviceRequired_description"><![CDATA[
    Require the device screen to be unlocked if the key is used.
    ]]></string>
    <string name="authorization_list_allApplications_description"><![CDATA[
    Indicates whether all apps on a device can access the key pair.
    ]]></string>
    <string name="authorization_list_applicationId_description"><![CDATA[
    When provided to generateKey or importKey, this tag specifies data that is necessary during all uses of the key.
    ]]></string>
    <string name="authorization_list_creationDateTime_description"><![CDATA[
    Specifies the date and time the key was created, in milliseconds since January 1, 1970. This tag is optional and informational only.
    ]]></string>
    <string name="authorization_list_origin_description"><![CDATA[
    Specifies where the key was created, if known. This tag may not be specified during key generation or import, and must be added to the key characteristics by the trustlet.
    ]]></string>
    <string name="authorization_list_rollbackResistant_description"><![CDATA[
    Indicates that the key is rollback-resistant, meaning that when deleted by deleteKey or deleteAllKeys, the key is guaranteed to be permanently deleted and unusable. It\'s possible that keys without this tag could be deleted and then restored from backup.
    ]]></string>
    <string name="authorization_list_rootOfTrust_description"><![CDATA[
    This collection of values defines key information about the device\'s status.<br/><p>
    verifiedBootKey: <br/>A secure hash of the key that verifies the system image.<br/><br/>
    deviceLocked: <br/>True if the device\'s bootloader is locked, which enables Verified Boot checking and prevents an unsigned device image from being flashed onto the device.<br/><br/>
    verifiedBootState: <br/>This data structure provides the device\'s current boot state, which represents the level of protection provided to the user and to apps after the device finishes booting.<br/><br/>
    verifiedBootHash: <br/>A digest of all data protected by Verified Boot. For devices that use the Android Verified Boot implementation of Verified Boot, this value contains the digest of the VBMeta struct, or the Verified Boot metadata structure.
    </p>]]></string>
    <string name="authorization_list_osVersion_description"><![CDATA[
    The version of the Android operating system associated with the Keymaster, specified as a six-digit integer. For example, version 8.1.0 is represented as 080100.
    ]]></string>
    <string name="authorization_list_osPatchLevel_description"><![CDATA[
    The month and year associated with the security patch that is being used within the Keymaster, specified as a six-digit integer. For example, the August 2018 patch is represented as 201808.
    ]]></string>
    <string name="authorization_list_attestationApplicationId_description"><![CDATA[
    This data structure reflects the Android platform\'s belief as to which apps are allowed to use the secret key material under attestation. The ID can comprise multiple packages if and only if multiple packages share the same UID.
    ]]></string>
    <string name="authorization_list_attestationIdBrand_description"><![CDATA[
    Provides the device\'s brand name, as returned by Build.BRAND in Android. This field is set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_attestationIdDevice_description"><![CDATA[
    Provides the device\'s device name, as returned by Build.DEVICE in Android. This field is set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_attestationIdProduct_description"><![CDATA[
    Provides the device\'s product name, as returned by Build.PRODUCT in Android. This field is set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_attestationIdSerial_description"><![CDATA[
    Provides the device\'s serial number. This field is set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_attestationIdImei_description"><![CDATA[
    Provides the IMEI one of the radios on the device to attested key generation/import operations. This field is set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_attestationIdSecondImei_description"><![CDATA[
    Provides an additional IMEI of one of the radios on the device to attested key generation/import operations. This field is set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_attestationIdMeid_description"><![CDATA[
    Provides the MEIDs for all radios on the device. This field is set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_attestationIdManufacturer_description"><![CDATA[
    Provides the device\'s manufacturer name, as returned by Build.MANUFACTURER in Android. This field is set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_attestationIdModel_description"><![CDATA[
    Provides the device\'s model name, as returned by Build.MODEL in Android. This field is set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_vendorPatchLevel_description"><![CDATA[
    Specifies the vendor image security patch level that must be installed on the device for this key to be used. The value appears in the form YYYYMMDD, representing the date of the vendor security patch. For example, if a key were generated on an Android device with the vendor\'s August 1, 2018 security patch installed, this value would be 20180801.
    ]]></string>
    <string name="authorization_list_bootPatchLevel_description"><![CDATA[
    Specifies the kernel image security patch level that must be installed on the device for this key to be used. The value appears in the form YYYYMMDD, representing the date of the system security patch. For example, if a key were generated on an Android device with the system\'s August 5, 2018 security patch installed, this value would be 20180805.
    ]]></string>
    <string name="authorization_list_mgfDigest_description"><![CDATA[
    Specifies the MGF1 digest algorithms that may be used with RSA encryption/decryption with OAEP padding. Possible values are defined by the Digest enum.
    ]]></string>
    <string name="authorization_list_earlyBootOnly_description"><![CDATA[
    Keys tagged with EARLY_BOOT_ONLY may only be used during early boot, until IKeyMintDevice::earlyBootEnded() is called.
    ]]></string>
    <string name="authorization_list_usageCountLimit_description"><![CDATA[
    Specifies the number of times that a key may be used. This can be used to limit the use of a key. The value is a 32-bit integer representing the current number of attempts left.
    ]]></string>
    <string name="authorization_list_deviceUniqueAttestation_description"><![CDATA[
    It indicates that attestation using a device-unique key is requested, rather than a batch key. When a device-unique key is used, the returned chain should contain two or three certificates.
    ]]></string>
    <string name="authorization_list_identityCredentialKey_description"><![CDATA[
    It is used in attestations produced by the IIdentityCredential HAL when that HAL attests to Credential Keys. IIdentityCredential produces KeyMint-style attestations.
    ]]></string>
    <string name="authorization_list_moduleHash_description"><![CDATA[
    Specifies the SHA-256 hash of the DER-encoded module information.
    ]]></string>

    <string name="knox">Samsung Knox Attestation</string>
    <string name="knox_description"><![CDATA[
    Samsung Knox Attestation is a feature that verifies a Samsung device\'s data integrity by checking that the device is not rooted or running unofficial firmware.
    ]]></string>
    <string name="knox_challenge">@string/attestation_challenge</string>
    <string name="knox_challenge_description">@string/attestation_challenge_description</string>
    <string name="knox_id_attest">ID attestation</string>
    <string name="knox_id_attest_description"><![CDATA[
    Check if the IMEI and serial number have been modified.
    ]]></string>
    <string name="knox_integrity">Integrity status</string>
    <string name="knox_integrity_description"><![CDATA[
    The Keymaster Trusted Application (TA) in Secure World gathers this data:
    <ul>
    <li gap="8sp">The requesting app\'s package name, version code, and developer key.</li>
    <li gap="8sp">Signed info about the device\'s current state and expected environment.</li>
    <li gap="8sp">Hardware fuse readings indicating if untrusted firmware was ever loaded onto the device.</li>
    </ul>
    ]]></string>
    <string name="knox_record_hash">Attestation record hash</string>
    <string name="knox_record_hash_description"><![CDATA[
    a SHA256 digest of the TA requesting the integrity status data from ICCC.
    ]]></string>
</resources>

```

`app/src/main/res/values/strings_no_translate.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="copyright" translatable="false">Copyright © vvb2060, Rikka</string>
    <string name="github_url" translatable="false">https://github.com/vvb2060/KeyAttestation</string>
    <string name="shizuku_url" translatable="false">https://shizuku.rikka.app</string>
    <string name="license" translatable="false">Apache License 2.0</string>
</resources>

```

`app/src/main/res/values/styles.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <style name="AppTheme" parent="Theme" />

    <style name="HomeCardStyle">
        <item name="android:layout_width">match_parent</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:paddingStart">16dp</item>
        <item name="android:paddingTop">16dp</item>
        <item name="android:paddingEnd">16dp</item>
        <item name="android:paddingBottom">16dp</item>
        <!--<item name="android:background">?outlineButtonBackground</item>-->
    </style>

    <style name="HomeItemTitleText">
        <item name="android:textSize">16sp</item>
        <item name="android:gravity">center_vertical</item>
        <item name="android:textAppearance">?textAppearanceSubtitle2</item>
        <item name="android:textColor">@color/material_on_surface_emphasis_high_type</item>
    </style>

    <style name="HomeItemSummaryText">
        <item name="android:textSize">14sp</item>
        <item name="android:gravity">center_vertical</item>
        <item name="android:textAppearance">?textAppearanceBody2</item>
        <item name="android:textColor">@color/material_on_surface_emphasis_medium</item>
        <item name="android:lineSpacingExtra">1sp</item>
    </style>

</resources>
```

`app/src/main/res/values/themes.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Base theme -->
    <style name="Theme" parent="Theme.Material">
        <item name="android:statusBarColor">?toolbarColor</item>
        <item name="android:colorPrimary">?toolbarColor</item>
        <item name="android:colorBackground">@color/color_background_dark</item>
        <item name="actionBarPopupTheme">@style/ThemeOverlay.ActionBar.PopupTheme</item>

        <item name="colorBackgroundFloating">@color/color_floating_background_dark</item>
        <item name="android:colorBackgroundFloating">@color/color_floating_background_dark</item>

        <item name="colorPrimary">@color/color_accent</item>
        <item name="colorPrimaryVariant">@color/color_accent</item>
        <item name="colorSecondary">@color/color_accent</item>
        <item name="colorSecondaryVariant">@color/color_accent</item>
        <item name="colorOnSecondary">@android:color/black</item>
        <item name="actionBarTheme">@style/ThemeOverlay.ActionBar</item>
        <item name="toolbarStyle">@style/Widget.Material.Toolbar</item>
        <item name="notificationColor">@color/material_teal_500</item>

        <!--<item name="preferenceTheme">@style/ThemeOverlay.Preference</item>-->
        <item name="appBarStyle">@style/Widget.AppBar</item>
        <item name="toolbarColor">@color/color_background_dark</item>
        <item name="colorSafe">@color/color_safe</item>
        <item name="colorWarning">@color/color_warning</item>
        <item name="colorAlert">@color/color_alert</item>
        <item name="colorInactive">@color/color_inactive</item>

        <item name="android:windowNoTitle">true</item>
        <item name="android:windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
        <item name="windowActionBar">false</item>
    </style>

    <style name="Widget.AppBar" parent="">
        <item name="android:theme">?actionBarTheme</item>
        <item name="android:background">?android:colorBackground</item>
        <item name="android:stateListAnimator">@animator/raise_animator</item>
        <item name="android:elevation">0dp</item>
    </style>

    <style name="ThemeOverlay.ActionBar.PopupTheme" parent="ThemeOverlay.MaterialComponents">
        <item name="colorSurface">@color/color_background_dark</item>
    </style>

    <style name="ThemeOverlay.ActionBar" parent="ThemeOverlay.MaterialComponents.ActionBar">
        <item name="titleTextAppearance">@android:style/TextAppearance.Material.Widget.Toolbar.Title</item>
        <item name="subtitleTextAppearance">@android:style/TextAppearance.Material.Widget.Toolbar.Subtitle</item>
    </style>

    <style name="ThemeOverlay.ActionBar.Dark" parent="ThemeOverlay.MaterialComponents.Dark.ActionBar">
        <item name="titleTextAppearance">@android:style/TextAppearance.Material.Widget.Toolbar.Title</item>
        <item name="subtitleTextAppearance">@android:style/TextAppearance.Material.Widget.Toolbar.Subtitle</item>
    </style>

    <style name="Widget.Material.Toolbar" parent="Widget.MaterialComponents.Toolbar">
        <item name="android:elevation">4dp</item>
        <item name="android:background">?toolbarColor</item>
    </style>

</resources>
```

`app/src/main/res/values/themes_override.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools" tools:ignore="PrivateResource">

    <!-- Add android:colorControlNormal -->
    <style name="Base.ThemeOverlay.AppCompat.ActionBar" tools:override="true">
        <item name="android:colorControlNormal">?android:attr/textColorPrimary</item>
        <item name="colorControlNormal">?android:attr/textColorPrimary</item>
        <item name="searchViewStyle">@style/Widget.AppCompat.SearchView.ActionBar</item>
    </style>

    <style name="Base.ThemeOverlay.AppCompat.Dark.ActionBar" tools:override="true">
        <item name="android:colorControlNormal">?android:attr/textColorPrimary</item>
        <item name="colorControlNormal">?android:attr/textColorPrimary</item>
        <item name="searchViewStyle">@style/Widget.AppCompat.SearchView.ActionBar</item>
    </style>

    <style name="Widget.MaterialComponents.CompoundButton.CheckBox" parent="Widget.AppCompat.CompoundButton.CheckBox" tools:override="true">
        <item name="enforceMaterialTheme">true</item>
        <item name="useMaterialThemeColors">true</item>
    </style>

    <style name="Widget.MaterialComponents.CompoundButton.RadioButton" parent="Widget.AppCompat.CompoundButton.RadioButton" tools:override="true">
        <item name="enforceMaterialTheme">true</item>
        <item name="useMaterialThemeColors">true</item>
    </style>
</resources>
```

`gradle.properties`:

```properties
android.useAndroidX=true
org.gradle.configuration-cache=true
org.gradle.configuration-cache.parallel=true
org.gradle.configureondemand=true

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.12-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`gradlew`:

```
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`settings.gradle`:

```gradle
pluginManagement {
    repositories {
        google()
        mavenCentral()
    }
    plugins {
        id("com.android.application") version '8.8.0'
        id("com.android.library") version '8.8.0'
        id("org.jetbrains.kotlin.android") version "2.1.0"
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google {
            content {
                includeGroupAndSubgroups("androidx")
                includeGroupAndSubgroups("com.android")
                includeGroupAndSubgroups("com.google")
            }
        }
        mavenCentral()
    }
}
rootProject.name = "KeyAttestation"
include(":app", ":stub")

```

`stub/build.gradle`:

```gradle
plugins {
    id 'com.android.library'
}

android {
    namespace = "stub"
    buildToolsVersion = '35.0.1'
    compileSdk = 35

    defaultConfig {
        minSdk = 24
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }
}

```

`stub/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest />

```

`stub/src/main/java/android/app/ActivityThread.java`:

```java
package android.app;

public class ActivityThread {
    public static Application currentApplication() {
        throw new RuntimeException("Stub!");
    }

    public ContextImpl getSystemContext() {
        throw new RuntimeException("Stub!");
    }

    public static ActivityThread systemMain() {
        throw new RuntimeException("Stub!");
    }

    public static void initializeMainlineModules() {
        throw new RuntimeException("Stub!");
    }
}

```

`stub/src/main/java/android/app/ContextImpl.java`:

```java
package android.app;

import android.content.Context;

public abstract class ContextImpl extends Context {
}

```

`stub/src/main/java/android/os/ServiceManager.java`:

```java
package android.os;

public class ServiceManager {
    public static IBinder getService(String name) {
        throw new RuntimeException("Stub!");
    }

    public static boolean isDeclared(String name) {
        throw new RuntimeException("Stub!");
    }

    public static String[] getDeclaredInstances(String iface) {
        throw new RuntimeException("Stub!");
    }

    public static IBinder waitForDeclaredService(String name) {
        throw new RuntimeException("Stub!");
    }
}

```

`stub/src/main/java/android/os/ServiceSpecificException.java`:

```java
package android.os;

public class ServiceSpecificException extends RuntimeException {
}

```

`stub/src/main/java/android/os/SystemProperties.java`:

```java
package android.os;

public class SystemProperties {
    public static String get(String key) {
        throw new RuntimeException("Stub!");
    }

    public static String get(String key, String def) {
        throw new RuntimeException("Stub!");
    }

    public static int getInt(String key, int def) {
        throw new RuntimeException("Stub!");
    }

    public static long getLong(String key, long def) {
        throw new RuntimeException("Stub!");
    }

    public static boolean getBoolean(String key, boolean def) {
        throw new RuntimeException("Stub!");
    }

    public static void set(String key, String val) {
        throw new RuntimeException("Stub!");
    }
}

```

`stub/src/main/java/android/security/keystore/AndroidKeyStoreProvider.java`:

```java
package android.security.keystore;

public class AndroidKeyStoreProvider {
    public static void install() {
        throw new RuntimeException("Stub!");
    }
}

```

`stub/src/main/java/android/security/keystore/AttestationUtils.java`:

```java
package android.security.keystore;

import android.content.Context;

import java.security.cert.X509Certificate;

public abstract class AttestationUtils {
    public static X509Certificate[] attestDeviceIds(Context context,
                                                    int[] idTypes,
                                                    byte[] attestationChallenge
    ) throws DeviceIdAttestationException {
        throw new RuntimeException("Stub!");
    }
}

```

`stub/src/main/java/android/security/keystore/DeviceIdAttestationException.java`:

```java
package android.security.keystore;

public class DeviceIdAttestationException extends Exception {

}

```

`stub/src/main/java/android/security/keystore/KeyGenParameterSpec_rename.java`:

```java
package android.security.keystore;

import java.math.BigInteger;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Date;

import javax.security.auth.x500.X500Principal;

public class KeyGenParameterSpec_rename {

    public static class Builder {
        public Builder(String keystoreAlias, int purposes) {
        }

        public Builder setAlgorithmParameterSpec(AlgorithmParameterSpec spec) {
            return this;
        }

        public Builder setCertificateSubject(X500Principal subject) {
            return this;
        }

        public Builder setCertificateSerialNumber(BigInteger serialNumber) {
            return this;
        }

        public Builder setCertificateNotBefore(Date date) {
            return this;
        }

        public Builder setCertificateNotAfter(Date date) {
            return this;
        }

        public Builder setDigests(String... digests) {
            return this;
        }

        public Builder setAttestationChallenge(byte[] attestationChallenge) {
            return this;
        }

        public Builder setDevicePropertiesAttestationIncluded(boolean devicePropertiesAttestationIncluded) {
            return this;
        }

        public Builder setAttestationIds(int[] attestationIds) {
            return this;
        }

        public Builder setUniqueIdIncluded(boolean uniqueIdIncluded) {
            return this;
        }

        public Builder setIsStrongBoxBacked(boolean isStrongBoxBacked) {
            return this;
        }

        public Builder setAttestKeyAlias(String attestKeyAlias) {
            return this;
        }

        public KeyGenParameterSpec_rename build() {
            throw new RuntimeException("Stub!");
        }
    }
}

```

`stub/src/main/java/android/security/keystore2/AndroidKeyStoreProvider.java`:

```java
package android.security.keystore2;

public class AndroidKeyStoreProvider {
    public static void install() {
        throw new RuntimeException("Stub!");
    }
}

```

`stub/src/main/java/android/telephony/TelephonyManager_rename.java`:

```java
package android.telephony;

import android.content.Context;

public class TelephonyManager_rename {
    public TelephonyManager_rename(Context context) {
        throw new RuntimeException("Stub!");
    }

    public String getImei(int slotIndex) {
        throw new RuntimeException("Stub!");
    }

    public String getMeid(int slotIndex) {
        throw new RuntimeException("Stub!");
    }
}

```

`stub/src/main/java/com/samsung/android/security/keystore/AttestParameterSpec.java`:

```java
package com.samsung.android.security.keystore;

import android.annotation.TargetApi;
import android.os.Build;
import android.security.keystore.KeyGenParameterSpec;

@TargetApi(Build.VERSION_CODES.Q)
public class AttestParameterSpec {
    public boolean isDeviceAttestation() {
        throw new RuntimeException("Stub!");
    }

    public static class Builder {
        public Builder(String alias, byte[] challenge) {
            throw new RuntimeException("Stub!");
        }

        public Builder setAlgorithm(String algorithm) {
            throw new RuntimeException("Stub!");
        }

        public Builder setDeviceAttestation(boolean requested) {
            throw new RuntimeException("Stub!");
        }

        public Builder setVerifiableIntegrity(boolean checked) {
            throw new RuntimeException("Stub!");
        }

        public Builder setPackageName(String packageName) {
            throw new RuntimeException("Stub!");
        }

        public Builder setKeyGenParameterSpec(KeyGenParameterSpec spec) {
            throw new RuntimeException("Stub!");
        }

        public AttestParameterSpec build() {
            throw new RuntimeException("Stub!");
        }
    }
}

```

`stub/src/main/java/com/samsung/android/security/keystore/AttestationUtils.java`:

```java
package com.samsung.android.security.keystore;

import android.annotation.TargetApi;
import android.os.Build;

@TargetApi(Build.VERSION_CODES.Q)
public class AttestationUtils {
    public static String DEFAULT_KEYSTORE = "AndroidKeyStore";

    public Iterable<byte[]> attestKey(AttestParameterSpec spec) {
        throw new RuntimeException("Stub!");
    }

    public Iterable<byte[]> attestDevice(AttestParameterSpec spec) {
        throw new RuntimeException("Stub!");
    }

    public void storeCertificateChain(String alias, Iterable<byte[]> iterable) {
        throw new RuntimeException("Stub!");
    }
}

```