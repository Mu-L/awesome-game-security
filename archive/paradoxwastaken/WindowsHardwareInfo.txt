Project Path: arc_paradoxwastaken_WindowsHardwareInfo_g97s2kaw

Source Tree:

```txt
arc_paradoxwastaken_WindowsHardwareInfo_g97s2kaw
├── LICENSE.md
├── README.md
├── Source.cpp
├── WindowsHW.aps
├── WindowsHW.exe
├── WindowsHW.rc
├── WindowsHW.vcxproj
├── WindowsHW.vcxproj.filters
├── cmd.h
├── hwid.h
├── icon
│   └── icon.ico
└── resource.h

```

`LICENSE.md`:

```md
MIT License

Copyright (c) 2023 Nicholas Galioto

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Windows-Hardware-Info
A project written in C++ to get hardware info on a Windows PC. Interfaces with the Windows Management Instrumentation (WMI) service to query hardware info of interest and provides a basic command line interface. 

Retrieves the following:

Disks
-------------

Serial Number

Model

Interface Type

Bus Type

Drive Letter

Size

Free Space

Media Type

IsBootDrive 

Volumes:
  * Name
  * Serial Number
  * Size
  * Free Space
  * Volume Letter


System Management BIOS (SMBIOS)
-------------
Serial Number

Manufacturer

Product

Version


GPUs
-------------
Name

Driver Version

Memory

Resolution

Refresh Rate


CPU
-------------
Processor Id

Manufacturer

Name

Number of Cores

Number of Logical Processors


Network Adapters
-------------
Name

MAC Address


System
------------
Name

IsHypervisorPresent

OS Version

OS Name

OS Architecture

OS SerialNumber


Physical Memory
-------------
Part Number


Registry
-------------
Computer Hardware Id


Command Line
-------------
The command line interface is independent from the hardware logic and is only used to demonstrate functionality. All relevant hardware logic is in hwid.h

Valid Commands:

"disk" - prints all disk info

"smbios" - prints all SMBIOS info

"gpu" - prints all GPU info

"cpu" - prints all CPU info

"network" - prints all network adapter info

"system" - prints all system info

"physicalmemory" - prints all physical memory info

"registry" - prints all registry info

"all" - prints all info

"help" - opens this webpage on the default browser

"exit" - exits the program


Each of the above commands (except "all", "help" and "exit") can be used to retrieve fields from the hardware component they specify. To do so, the "get" keyword must follow one of the above commands. Valid field(s) should be specified after "get"

For example, "disk get serialnumber" would retrieve the disk serial number(s), while "disk get serialnumber, model" would retrieve the disk serial number(s), as well as the model(s).

Valid fields are as follows:

Disk:

`serialnumber,
model,
interface,
bustype,
driveletter,
size,
freespace,
mediatype,
isbootdrive,
volumes`


SMBIOS:

`serialnumber,
manufacturer,
product,
version`


GPU:

`name,
driverversion,
memory,
resolution,
refreshrate`


CPU:

`processorid,
manufacturer,
name,
cores,
threads`


Network:

`name,
mac`


System:

`name,
ishypervisorpresent,
osversion,
ostitle,
osarchitecture,
osserialnumber`


Physical Memory:

`partnumber`


Registry:

`computerhardwareid`

```

`Source.cpp`:

```cpp
#include "cmd.h"

int main() {
	CommandLine::Create();
}
```

`WindowsHW.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "icon\\icon.ico"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`WindowsHW.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{7cfe113c-ca51-47cb-837b-f98818d65a6c}</ProjectGuid>
    <RootNamespace>WindowsHW</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="cmd.h" />
    <ClInclude Include="hwid.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="WindowsHW.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="icon\icon.ico">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</DeploymentContent>
    </Image>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`WindowsHW.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="hwid.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="cmd.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="WindowsHW.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="icon\icon.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`cmd.h`:

```h
#pragma once

#include <algorithm>
#include "hwid.h"


namespace CommandLine {

	HardwareId HWID{};
	std::wstring CurCmd{ L"" };
	std::wstring CmdName{ L"HWInfo>" };


	enum {
		eInvalid,
		eDisk,
		eSMBIOS,
		eGPU,
		eCPU,
		eNetwork,
		eSystem,
		ePhysicalMemory,
		eRegistry,
		eAll,
		eHelp,
		eExit
	};


	std::unordered_map<unsigned int, std::wstring> BusType {
		{ 0, L"Unspecified" },
		{ 1, L"SCSI" },
		{ 3, L"ATA" },
		{ 7, L"USB" },
		{ 8, L"RAID" },
		{ 11, L"SATA" },
		{ 17, L"NVMe" },
		{ 123, L"USB (Likely Flash Drive)" }
	};


	std::vector <std::wstring> ValidCommands{
		L"invalid command",
		L"disk",
		L"smbios",
		L"gpu",
		L"cpu",
		L"network",
		L"system",
		L"physicalmemory",
		L"registry",
		L"all",
		L"help",
		L"exit"
	};


	std::vector <std::wstring> DiskSubCommands{
		L"invalid command",
		L"serialnumber",
		L"model",
		L"interface",
		L"driveletter",
		L"size",
		L"freespace",
		L"mediatype",
		L"isbootdrive",
		L"bustype",
		L"volumes"
	};


	std::vector <std::wstring> SMBIOSSubCommands{
		L"invalid command",
		L"serialnumber",
		L"manufacturer",
		L"product",
		L"version"
	};


	std::vector <std::wstring> GPUSubCommands{
		L"invalid command",
		L"name",
		L"driverversion",
		L"resolution",
		L"refreshrate",
		L"memory"
	};


	std::vector <std::wstring> CPUSubCommands{
		L"invalid command",
		L"processorid",
		L"manufacturer",
		L"name",
		L"cores",
		L"threads"
	};


	std::vector <std::wstring> NetworkSubCommands{
		L"invalid command",
		L"name",
		L"mac"
	};


	std::vector <std::wstring> SystemSubCommands{
		L"invalid command",
		L"name",
		L"ishypervisorpresent",
		L"osversion",
		L"ostitle",
		L"osarchitecture",
		L"osserialnumber"
	};


	std::vector <std::wstring> PhysicalMemorySubCommands{
		L"invalid command",
		L"partnumber"
	};


	std::vector <std::wstring> RegistrySubCommands{
		L"invalid command",
		L"computerhardwareid"
	};


	struct {

		int CommandIndex{};
		std::vector <int> SubCommandIndex{};

	} ParsedCommand;


	void ChangeTextColor(int Color = 2) {
		HANDLE hConsole{ GetStdHandle(STD_OUTPUT_HANDLE) };
		SetConsoleTextAttribute(hConsole, Color);
	}


	template <typename T>
	void FmtPrint(T ToPrint, int HWType, int Iterator, const wchar_t* AdditionalText = nullptr) {
		std::wcout << ToPrint;
		
		if (AdditionalText != nullptr) {
			std::wcout << AdditionalText;
		}
		

		switch (HWType) {
			case eDisk: {
				std::wcout << (Iterator && Iterator + 1 == HWID.Disk.size() ? L"\n\n" : L"\n");
			} break;

			case eGPU: {
				std::wcout << (Iterator && Iterator + 1 == HWID.GPU.size() ? L"\n\n" : L"\n");
			} break;

			case eNetwork: {
				std::wcout << (Iterator && Iterator + 1 == HWID.NetworkAdapter.size() ? L"\n\n" : L"\n");
			} break;
		}
	}


	void PrintDisks() {
		for (int i = 0; i < HWID.Disk.size(); i++) {
			HardwareId::DiskObject& Disk{ HWID.Disk.at(i) };

			std::wcout << L"Drive: ";
			ChangeTextColor(12);
			std::wcout << Disk.Name.substr(4, Disk.Name.size() - 4);
			ChangeTextColor(15);
			std::wcout << L"\n---------------------\n";

			std::wcout << L"Model:\t\t\t" << Disk.Model << std::endl;
			std::wcout << L"Serial Number:\t\t" << Disk.SerialNumber << std::endl;
			std::wcout << L"Interface Type:\t\t" << Disk.Interface << std::endl;
			std::wcout << L"Bus Type:\t\t" << BusType[HWID.Disk.at(i).BusType] << std::endl;
			std::wcout << L"Size:\t\t\t" << Disk.Size << L" GB" << std::endl;
			std::wcout << L"Free Space:\t\t" << Disk.FreeSpace << L" GB" << std::endl;

			std::wcout << L"Media Type:\t\t" <<
				(HWID.Disk.at(i).MediaType == 4 ? L"SSD" :
					(HWID.Disk.at(i).MediaType == 3 ? L"HDD" : L"(null)")) << std::endl;

			std::wcout << L"Boot Drive:\t\t" << (Disk.IsBootDrive ? L"Yes" : L"No") << std::endl;

			if (Disk.Volumes.empty() == false) {
				for (int j = 0; j < Disk.Volumes.size(); j++) {
					std::wcout << std::endl;
					std::wcout << L"Volume " << j << std::endl << L"--------\n";
					std::wcout << L"Name:\t\t\t" << Disk.Volumes.at(j).Name << std::endl;
					std::wcout << L"Serial Number:\t\t" << std::hex << Disk.Volumes.at(j).SerialNumber << std::dec << std::endl;
					std::wcout << L"Size:\t\t\t" << Disk.Volumes.at(j).Size << L" GB" << std::endl;
					std::wcout << L"Free Space:\t\t" << Disk.Volumes.at(j).FreeSpace << L" GB" << std::endl;
					std::wcout << L"Drive Letter:\t\t" << Disk.Volumes.at(j).DriveLetter << std::endl;

					if (j + 1 == Disk.Volumes.size()) {
						std::wcout << std::endl;
					}
				}
			}
			else {
				std::wcout << L"Drive Letter:\t\t" << HWID.Disk.at(i).DriveLetter << std::endl;
				
				if (i + 1 != HWID.Disk.size()) {
					std::wcout << std::endl;
				}
			}
		}
	}


	void PrintSMBIOS() {
		std::wcout << L"Manufacturer:\t\t" << HWID.SMBIOS.Manufacturer << std::endl;
		std::wcout << L"Product:\t\t" << HWID.SMBIOS.Product << std::endl;
		std::wcout << L"Version:\t\t" << HWID.SMBIOS.Version << std::endl;
		std::wcout << L"Serial Number:\t\t" << HWID.SMBIOS.SerialNumber << std::endl;
	}


	void PrintGPUs() {
		for (int i = 0; i < HWID.GPU.size(); i++) {
			std::wcout << L"Name:\t\t\t" << HWID.GPU.at(i).Name << std::endl;
			std::wcout << L"Driver Version:\t\t" << HWID.GPU.at(i).DriverVersion << std::endl;
			std::wcout << L"Memory:\t\t\t" << HWID.GPU.at(i).Memory << L" MB" << std::endl;
			std::wcout << L"Resolution:\t\t" << HWID.GPU.at(i).XResolution << L"x" << HWID.GPU.at(i).YResolution << std::endl;
			std::wcout << L"Refresh Rate:\t\t" << HWID.GPU.at(i).RefreshRate << std::endl;

			if (i + 1 < HWID.GPU.size()) { std::wcout << std::endl; }
		}
	}


	void PrintCPU() {
		std::wcout << L"Processor Id:\t\t" << HWID.CPU.ProcessorId << std::endl;
		std::wcout << L"Manufacturer:\t\t" << HWID.CPU.Manufacturer << std::endl;
		std::wcout << L"Name:\t\t\t" << HWID.CPU.Name << std::endl;
		std::wcout << L"Cores:\t\t\t" << HWID.CPU.Cores << std::endl;
		std::wcout << L"Threads:\t\t" << HWID.CPU.Threads << std::endl;
	}


	void PrintNetwork() {
		for (int i = 0; i < HWID.NetworkAdapter.size(); i++) {
			std::wcout << L"Name:\t\t\t" << HWID.NetworkAdapter.at(i).Name << std::endl;
			std::wcout << L"MAC Address:\t\t" << HWID.NetworkAdapter.at(i).MAC << std::endl;

			if (i + 1 < HWID.NetworkAdapter.size()) { std::wcout << std::endl; }
		}
	}


	void PrintSystem() {
		std::wcout << L"System Name:\t\t" << HWID.System.Name << std::endl;
		std::wcout << L"Hypervisor Present:\t" << (HWID.System.IsHypervisorPresent ? L"Yes" : L"No") << std::endl;
		std::wcout << L"OS Title:\t\t" << HWID.System.OSName << std::endl;
		std::wcout << L"OS Version:\t\t" << HWID.System.OSVersion << std::endl;
		std::wcout << L"OS Architecture:\t" << HWID.System.OSArchitecture << std::endl;
		std::wcout << L"OS Serial Number:\t" << HWID.System.OSSerialNumber << std::endl;
	}


	void PrintPhysicalMemory() {
		std::wcout << L"Part Number:\t\t" << HWID.PhysicalMemory.PartNumber << std::endl;
	}


	void PrintRegistry() {
		std::wcout << L"Computer Hardware Id:\t" << HWID.Registry.ComputerHardwareId << std::endl;
	}


	std::vector <std::wstring> ValidSubCommands() {
		switch (ParsedCommand.CommandIndex) {
			case eDisk: {
				return DiskSubCommands;
			} break;

			case eSMBIOS: {
				return SMBIOSSubCommands;
			} break;

			case eGPU: {
				return GPUSubCommands;
			} break;

			case eCPU: {
				return CPUSubCommands;
			} break;

			case eNetwork: {
				return NetworkSubCommands;
			} break;

			case eSystem: {
				return SystemSubCommands;
			} break;

			case ePhysicalMemory: {
				return PhysicalMemorySubCommands;
			} break;

			case eRegistry: {
				return RegistrySubCommands;
			} break;
		}

		return {};
	}


	void ParseCommand() {
		bool bFound{ false };

		auto OrderVector{ [] (std::vector <int> ToOrder) -> std::vector <int> {
			struct MinToMax {
				MinToMax(const std::vector <int> &Vector) : _Vector(Vector) {}

				bool operator () (int Index, int Index2) {
					return _Vector[Index] < _Vector[Index2];
				}

				const std::vector <int>& _Vector{};
			};

			std::vector <int> OrderedElements{};
			OrderedElements.resize(ToOrder.size());

			for (int i = 0; i < ToOrder.size(); ++i) {
				OrderedElements.at(i) = i;
			}

			std::sort(OrderedElements.begin(), OrderedElements.end(), MinToMax(ToOrder));
			return OrderedElements;
		} };


		// Convert the command to lowercase to avoid any case issues

		for (int i = 0; i < CurCmd.size(); i++) {
			CurCmd.at(i) = std::tolower(CurCmd.at(i));
		}


		// example of a valid command: "disk get serialnumber, model"
		// "disk" is the main command
		// "get" is the keyword required to request fields/members
		// "serialnumber" and "model" are sub-commands containing the requested fields


		// Determine if the start of the command contains a valid main command by looping through our vector of valid commands

		for (; ParsedCommand.CommandIndex < ValidCommands.size(); ParsedCommand.CommandIndex++) {
			if (CurCmd.find(ValidCommands.at(ParsedCommand.CommandIndex)) == 0) {
				bFound = true;
				break;
			}
		}


		if (!bFound) {
			// The command is invalid
			ParsedCommand.CommandIndex = eInvalid;
			return;
		}


		// Determine if the command contains a "get" request by checking for the "get" keyword
		// Additionally, make sure the command isn't just "[main command] get" by checking 
		// if it's larger than the size of the main command + the size of "get"

		if (CurCmd.find(L"get") != std::wstring::npos && CurCmd.size() != ValidCommands.at(ParsedCommand.CommandIndex).size() + 3) {

			// Determine if "get" is directly after the main command. If it's not, it's an invalid command 
			// e.g. "disk get serialnumber" is valid, "get disk serialnumber" is not

			if (CurCmd.find(L"get") != ValidCommands.at(ParsedCommand.CommandIndex).size()) {
				ParsedCommand.CommandIndex = eInvalid;
				return;
			}


			// Check if we have valid sub-commands 
			// If we do, we construct our vector of sub-command indices; however, they won't be in the same order as the command request
			// If the full command is "disk get model, serialnumber", the requested fields will be returned in the order of our sub-command vector
			// In this example, the disk serial number(s) will be returned before the model(s) because serial number is before model in our vector
			// even though they specified the model before the serial number.
			// So we must keep track of the starting offset of the sub-commands by storing each one in an additional vector
			// The smallest offsets are closest to the "get" keyword in the command, 
			// so we'll use the indices of them to sort our sub-command index vector

			std::vector <std::wstring> SubCmds{ ValidSubCommands() };
			std::vector <int> UnorderedSubIndex{};
			std::vector <int> Offsets{};

			for (int i = 0; i < SubCmds.size(); i++) {
				auto Offset{ CurCmd.find(SubCmds.at(i)) };

				if (Offset != std::wstring::npos) {
					UnorderedSubIndex.push_back(i);
					Offsets.push_back(Offset);
				}
			}


			if (UnorderedSubIndex.size() == 0 || Offsets.size() == 0) {

				// No valid sub-commands, but "get" is present - invalid command

				ParsedCommand.CommandIndex = eInvalid;
				return;
			}


			// We now call our lambda which will return a vector of the original offset indices 
			// ordered in correspondence with the offset values sorted from min to max

			auto OrderedOffsets{ OrderVector(Offsets) };


			// Check if the closest sub-command to the "get" keyword is directly after it
			// If it's not, we have invalid junk between "get" and the sub-commands (e.g. disk get afgxsdf serialnumber)

			if (Offsets.at(OrderedOffsets.at(0)) != ValidCommands.at(ParsedCommand.CommandIndex).size() + 3) {
				ParsedCommand.CommandIndex = eInvalid;
				return;
			}


			// Sort our sub-command indices from closest to farthest relative to "get"

			ParsedCommand.SubCommandIndex.resize(UnorderedSubIndex.size());

			for (int i = 0; i < UnorderedSubIndex.size(); i++) {
				ParsedCommand.SubCommandIndex.at(i) = UnorderedSubIndex.at(OrderedOffsets.at(i));
			}
		}
		else if (CurCmd.size() > ValidCommands.at(ParsedCommand.CommandIndex).size()) {

			// There's a valid main command present, but there are no sub-commands and the total size of the command is larger than 
			// the size of the valid main command it contains
			// We have an invalid command (e.g. diskgkdfmkm)

			ParsedCommand.CommandIndex = eInvalid;
		}
	}


	void RespondCommand() {
		ParseCommand();

		// handle sub-commands if present
		if (ParsedCommand.SubCommandIndex.size()) {

			std::wcout << std::endl;

			switch (ParsedCommand.CommandIndex) {

				// Disk Sub-Command (e.g. "disk get serialnumber")
				case eDisk: {
					for (int i = 0; i < ParsedCommand.SubCommandIndex.size(); i++) {


						switch (ParsedCommand.SubCommandIndex.at(i)) {
							case 1: {
								for (int j = 0; j < HWID.Disk.size(); j++) {
									FmtPrint(HWID.Disk.at(j).SerialNumber, eDisk, j);
								}
							} break;

							case 2: {
								for (int j = 0; j < HWID.Disk.size(); j++) {
									FmtPrint(HWID.Disk.at(j).Model, eDisk, j);
								}
							} break;

							case 3: {
								for (int j = 0; j < HWID.Disk.size(); j++) {
									FmtPrint(HWID.Disk.at(j).Interface, eDisk, j);
								}
							} break;

							case 4: {
								for (int j = 0; j < HWID.Disk.size(); j++) {
									FmtPrint(HWID.Disk.at(j).DriveLetter, eDisk, j);
								}
							} break;

							case 5: {
								for (int j = 0; j < HWID.Disk.size(); j++) {
									FmtPrint(HWID.Disk.at(j).Size, eDisk, j);
								}
							} break;

							case 6: {
								for (int j = 0; j < HWID.Disk.size(); j++) {
									FmtPrint(HWID.Disk.at(j).FreeSpace, eDisk, j);
								}
							} break;

							case 7: {
								for (int j = 0; j < HWID.Disk.size(); j++) {
									FmtPrint(HWID.Disk.at(j).MediaType, eDisk, j);
								}
							} break;

							case 8: {
								for (int j = 0; j < HWID.Disk.size(); j++) {
									FmtPrint(HWID.Disk.at(j).IsBootDrive, eDisk, j);
								}
							} break;

							case 9: {
								for (int j = 0; j < HWID.Disk.size(); j++) {
									FmtPrint(BusType[HWID.Disk.at(j).BusType], eDisk, j);
								}
							} break;

							case 10: {
								for (int i = 0; i < HWID.Disk.size(); i++) {
									HardwareId::DiskObject& Disk{ HWID.Disk.at(i) };

									if (Disk.Volumes.empty() == false) {
										std::wcout << L"Drive: ";
										ChangeTextColor(12);
										std::wcout << Disk.Name.substr(4, Disk.Name.size() - 4);
										ChangeTextColor(15);
										std::wcout << L"\n---------------------";

										for (int j = 0; j < Disk.Volumes.size(); j++) {
											std::wcout << std::endl;
											std::wcout << L"Volume " << j << std::endl;
											std::wcout << L"Name:\t\t\t" << Disk.Volumes.at(j).Name << std::endl;
											std::wcout << L"Serial Number:\t\t" << std::hex << Disk.Volumes.at(j).SerialNumber << std::dec << std::endl;
											std::wcout << L"Size:\t\t\t" << Disk.Volumes.at(j).Size << L" GB" << std::endl;
											std::wcout << L"Free Space:\t\t" << Disk.Volumes.at(j).FreeSpace << L" GB" << std::endl;
											std::wcout << L"Drive Letter:\t\t" << Disk.Volumes.at(j).DriveLetter << std::endl;
										}
									}
									else {
										continue;
									}

									if (i + 1 < HWID.Disk.size()) { 
										std::wcout << std::endl; 
									}
								}
							} break;
						}
					}
				} break;


				// SMBIOS Sub-Command (e.g. "smbios get manufacturer")
				case eSMBIOS: {
					for (int i = 0; i < ParsedCommand.SubCommandIndex.size(); i++) {
						switch (ParsedCommand.SubCommandIndex.at(i)) {
							case 1: {
								std::wcout << HWID.SMBIOS.SerialNumber << std::endl;
							} break;

							case 2: {
								std::wcout << HWID.SMBIOS.Manufacturer << std::endl;
							} break;

							case 3: {
								std::wcout << HWID.SMBIOS.Product << std::endl;
							} break;

							case 4: {
								std::wcout << HWID.SMBIOS.Version << std::endl;
							} break;
						}
					}
				} break;


				// GPU Sub-Command (e.g. "gpu get resolution")
				case eGPU: {
					for (int i = 0; i < ParsedCommand.SubCommandIndex.size(); i++) {
						switch (ParsedCommand.SubCommandIndex.at(i)) {
							case 1: {
								for (int i = 0; i < HWID.GPU.size(); i++) {
									FmtPrint(HWID.GPU.at(i).Name, eGPU, i);
								}
							} break;

							case 2: {
								for (int i = 0; i < HWID.GPU.size(); i++) {
									FmtPrint(HWID.GPU.at(i).DriverVersion, eGPU, i);
								}
							} break;

							case 3: {
								for (int i = 0; i < HWID.GPU.size(); i++) {
									std::wstring Res(std::to_wstring(HWID.GPU.at(i).XResolution));
									Res.append(L"x").append(std::to_wstring(HWID.GPU.at(i).YResolution));

									FmtPrint(Res, eGPU, i);
								}
							} break;

							case 4: {
								for (int i = 0; i < HWID.GPU.size(); i++) {
									FmtPrint(HWID.GPU.at(i).RefreshRate, eGPU, i);
								}
							} break;

							case 5: {
								for (int i = 0; i < HWID.GPU.size(); i++) {
									FmtPrint(HWID.GPU.at(i).Memory, eGPU, i, L" GB");
								}
							} break;
						}
					}
				} break;


				// CPU Sub-Command (e.g. "cpu get processorid")
				case eCPU: {
					for (int i = 0; i < ParsedCommand.SubCommandIndex.size(); i++) {
						switch (ParsedCommand.SubCommandIndex.at(i)) {
							case 1: {
								std::wcout << HWID.CPU.ProcessorId << std::endl;
							} break;

							case 2: {
								std::wcout << HWID.CPU.Manufacturer << std::endl;
							} break;

							case 3: {
								std::wcout << HWID.CPU.Name << std::endl;
							} break;

							case 4: {
								std::wcout << HWID.CPU.Cores << std::endl;
							} break;

							case 5: {
								std::wcout << HWID.CPU.Threads << std::endl;
							} break;
						}
					}

				} break;


				// Network Sub-Command (e.g. "network get mac")
				case eNetwork: {
					for (int i = 0; i < ParsedCommand.SubCommandIndex.size(); i++) {
						switch (ParsedCommand.SubCommandIndex.at(i)) {
							case 1: {
								for (int i = 0; i < HWID.NetworkAdapter.size(); i++) {
									FmtPrint(HWID.NetworkAdapter.at(i).Name, eNetwork, i);
								}
							} break;

							case 2: {
								for (int i = 0; i < HWID.NetworkAdapter.size(); i++) {
									FmtPrint(HWID.NetworkAdapter.at(i).MAC, eNetwork, i);
								}
							} break;
						}
					}
				} break;


				// System Sub-Command (e.g. "system get osversion")
				case eSystem: {
					for (int i = 0; i < ParsedCommand.SubCommandIndex.size(); i++) {
						switch (ParsedCommand.SubCommandIndex.at(i)) {
							case 1: {
								std::wcout << HWID.System.Name << std::endl;
							} break;

							case 2: {
								std::wcout << HWID.System.IsHypervisorPresent << std::endl;
							} break;

							case 3: {
								std::wcout << HWID.System.OSVersion << std::endl;
							} break;

							case 4: {
								std::wcout << HWID.System.OSName << std::endl;
							} break;

							case 5: {
								std::wcout << HWID.System.OSArchitecture << std::endl;
							} break;

							case 6: {
								std::wcout << HWID.System.OSSerialNumber << std::endl;
							} break;
						}
					}

				} break;


				// Physcial Memory Sub-Command (e.g. "physicalmemory get partnumber")
				case ePhysicalMemory: {
					for (int i = 0; i < ParsedCommand.SubCommandIndex.size(); i++) {
						switch (ParsedCommand.SubCommandIndex.at(i)) {
							case 1: {
								std::wcout << HWID.PhysicalMemory.PartNumber << std::endl;
							} break;
						}
					}

				} break;


				// Registry Sub-Command (e.g. "registry get computerhardwareid")
				case eRegistry: {
					for (int i = 0; i < ParsedCommand.SubCommandIndex.size(); i++) {
						switch (ParsedCommand.SubCommandIndex.at(i)) {
							case 1: {
								std::wcout << HWID.Registry.ComputerHardwareId << std::endl;
							} break;
						}
					}

				} break;
			}

			goto ClearCmd;
		}


		// No sub-commands, handle main command
		switch (ParsedCommand.CommandIndex) {

			case eDisk: {
				std::wcout << std::endl;
				PrintDisks();
			} break;

			case eSMBIOS: {
				std::wcout << std::endl;
				PrintSMBIOS();
			} break;

			case eGPU: {
				std::wcout << std::endl;
				PrintGPUs();
			} break;

			case eCPU: {
				std::wcout << std::endl;
				PrintCPU();
			} break;

			case eNetwork: {
				std::wcout << std::endl;
				PrintNetwork();
			} break;

			case eSystem: {
				std::wcout << std::endl;
				PrintSystem();
			} break;

			case ePhysicalMemory: {
				std::wcout << std::endl;
				PrintPhysicalMemory();
			} break;

			case eRegistry: {
				std::wcout << std::endl;
				PrintRegistry();
			} break;

			case eAll: {

				ChangeTextColor();
				std::wcout << L"\n-------------\n";
				std::wcout << L"[+] Disks [+] \n";
				std::wcout << L"-------------\n\n";
				ChangeTextColor(15);
				PrintDisks();

				ChangeTextColor();
				std::wcout << L"\n--------------\n";
				std::wcout << L"[+] SMBIOS [+]\n";
				std::wcout << L"--------------\n\n";
				ChangeTextColor(15);
				PrintSMBIOS();

				ChangeTextColor();
				std::wcout << L"\n------------\n";
				std::wcout << L"[+] GPUs [+]\n";
				std::wcout << L"------------\n\n";
				ChangeTextColor(15);
				PrintGPUs();

				ChangeTextColor();
				std::wcout << L"\n-----------\n";
				std::wcout << L"[+] CPU [+]\n";
				std::wcout << L"-----------\n\n";
				ChangeTextColor(15);
				PrintCPU();

				ChangeTextColor();
				std::wcout << L"\n---------------\n";
				std::wcout << L"[+] Network [+] \n";
				std::wcout << L"---------------\n\n";
				ChangeTextColor(15);
				PrintNetwork();

				ChangeTextColor();;
				std::wcout << L"\n--------------\n";
				std::wcout << L"[+] System [+]\n";
				std::wcout << L"--------------\n\n";
				ChangeTextColor(15);
				PrintSystem();

				ChangeTextColor();
				std::wcout << L"\n-----------------------\n";
				std::wcout << L"[+] Physical Memory [+]\n";
				std::wcout << L"-----------------------\n\n";
				ChangeTextColor(15);
				PrintPhysicalMemory();

				ChangeTextColor();
				std::wcout << L"\n----------------\n";
				std::wcout << L"[+] Registry [+]\n";
				std::wcout << L"----------------\n\n";
				ChangeTextColor(15);
				PrintRegistry();

			} break;

			case eHelp: {
				ShellExecuteW(nullptr, nullptr, L"https://github.com/sondernextdoor/WindowsHardwareInfo#readme", nullptr, nullptr, SW_SHOW);
			} break;

			case eExit: {
				exit(0);
			} break;

			default: {
				std::wcout << L"Invalid Command\n";
			} break;
		}


	ClearCmd:

		ParsedCommand.CommandIndex = eInvalid;
		ParsedCommand.SubCommandIndex.resize(0);
	}


	void Create() {
		auto NewLine{ [] () -> void {
			std::wcout << CmdName;
			std::getline(std::wcin, CurCmd);

			HardwareId::RemoveWhitespaces(CurCmd);
			if (CurCmd.empty()) { return; }

			bool bFmt{
				(CurCmd.find(L"diskget") != std::wstring::npos && HWID.Disk.size() > 1
				|| CurCmd.find(L"gpuget") != std::wstring::npos && HWID.GPU.size() > 1
				|| CurCmd.find(L"networkget") != std::wstring::npos && HWID.NetworkAdapter.size() > 1)
			};

			RespondCommand();
			if (!bFmt) { std::wcout << std::endl; }
		} };

		HWID = HardwareId();

		for (;;) {
			NewLine();
		}
	}
};

```

`hwid.h`:

```h
#pragma once

#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
#include <Windows.h>
#include <comdef.h>
#include <Wbemidl.h>
#include <ntddscsi.h>

#pragma comment(lib, "wbemuuid.lib")


class HardwareId {

public:


	struct VolumeObject {

		unsigned long SerialNumber{};
		std::wstring DriveLetter{};
		std::wstring Name{};
		long long Size{};
		long long FreeSpace{};
	};


	struct DiskObject {

		std::wstring SerialNumber{};
		std::wstring Name;
		std::wstring Model{};
		std::wstring Interface{};
		std::wstring DriveLetter{};
		long long Size{};
		long long FreeSpace{};
		unsigned int MediaType{};
		unsigned int BusType{};
		bool IsBootDrive{};
		std::vector<VolumeObject> Volumes{};

	}; std::vector <DiskObject> Disk{};


	struct {

		std::wstring Manufacturer{};
		std::wstring Product{};
		std::wstring Version{};
		std::wstring SerialNumber{};

	} SMBIOS;


	struct {

		std::wstring ProcessorId{};
		std::wstring Manufacturer{};
		std::wstring Name{};
		int Cores{};
		int Threads{};

	} CPU;


	struct GPUObject {

		std::wstring Name{};
		std::wstring DriverVersion{};
		unsigned long long Memory{};
		int XResolution{};
		int YResolution{};
		int RefreshRate{};

	}; std::vector <GPUObject> GPU{};


	struct NetworkAdapterObject {

		std::wstring Name{};
		std::wstring MAC{};

	}; std::vector <NetworkAdapterObject> NetworkAdapter{};



	struct {

		std::wstring Name{};
		bool IsHypervisorPresent{};
		std::wstring OSVersion{};
		std::wstring OSName{};
		std::wstring OSArchitecture{};
		std::wstring OSSerialNumber{};

	} System;


	struct {

		std::wstring PartNumber{};

	} PhysicalMemory;


	struct {

		std::wstring ComputerHardwareId{};

	} Registry;


	std::unique_ptr<HardwareId> Pointer() {
		return std::make_unique<HardwareId>(*this);
	}


	HardwareId() {
		GetHardwareId();
	}


	static std::wstring SafeString(const wchar_t* pString) {
		return std::wstring((pString == nullptr ? L"(null)" : pString));
	}


	static void RemoveWhitespaces(std::wstring& String) {
		String.erase(std::remove(String.begin(), String.end(), L' '), String.end());
	}


private:

	
	std::wstring GetHKLM(std::wstring SubKey, std::wstring Value) {
		DWORD Size{};
		std::wstring Ret{};

		RegGetValueW(HKEY_LOCAL_MACHINE,
			     SubKey.c_str(),
			     Value.c_str(),
			     RRF_RT_REG_SZ,
			     nullptr,
			     nullptr,
			     &Size);

		Ret.resize(Size);

		RegGetValueW(HKEY_LOCAL_MACHINE,
			     SubKey.c_str(),
			     Value.c_str(),
			     RRF_RT_REG_SZ,
			     nullptr,
			     &Ret[0],
			     &Size);

		return Ret.c_str();
	}


	template <typename T = const wchar_t*>
	void QueryWMI(std::wstring WMIClass, std::wstring Field, std::vector <T>& Value, const wchar_t* ServerName = L"ROOT\\CIMV2") {
		std::wstring Query(L"SELECT ");
		Query.append(Field.c_str()).append(L" FROM ").append(WMIClass.c_str());

		IWbemLocator* Locator{};
		IWbemServices* Services{};
		IEnumWbemClassObject* Enumerator{};
		IWbemClassObject* ClassObject{};
		VARIANT Variant{};
		DWORD Returned{};


		HRESULT hResult{ CoInitializeEx(nullptr, COINIT_MULTITHREADED) };


		if (FAILED(hResult)) {
			return;
		}


		hResult = CoInitializeSecurity(nullptr,
			                       -1,
					       nullptr,
					       nullptr,
					       RPC_C_AUTHN_LEVEL_DEFAULT,
					       RPC_C_IMP_LEVEL_IMPERSONATE,
					       nullptr,
					       EOAC_NONE,
					       nullptr);



		if (FAILED(hResult)) {
			CoUninitialize();
			return;
		}


		hResult = CoCreateInstance(CLSID_WbemLocator,
					   NULL,
					   CLSCTX_INPROC_SERVER,
					   IID_IWbemLocator,
					   reinterpret_cast<PVOID*>(&Locator));


		if (FAILED(hResult)) {
			CoUninitialize();
			return;
		}


		hResult = Locator->ConnectServer(_bstr_t(ServerName),
						 nullptr,
						 nullptr,
						 nullptr,
						 NULL,
						 nullptr,
						 nullptr,
						 &Services);


		if (FAILED(hResult)) {
			Locator->Release();
			CoUninitialize();
			return;
		}


		hResult = CoSetProxyBlanket(Services,
					    RPC_C_AUTHN_WINNT,
					    RPC_C_AUTHZ_NONE,
				  	    nullptr,
					    RPC_C_AUTHN_LEVEL_CALL,
					    RPC_C_IMP_LEVEL_IMPERSONATE,
					    nullptr,
					    EOAC_NONE);


		if (FAILED(hResult)) {
			Services->Release();
			Locator->Release();
			CoUninitialize();
			return;
		}


		hResult = Services->ExecQuery(bstr_t(L"WQL"),
					      bstr_t(Query.c_str()),
					      WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
					      nullptr,
					      &Enumerator);


		if (FAILED(hResult)) {
			Services->Release();
			Locator->Release();
			CoUninitialize();
			return;
		}

		
		while (Enumerator) {

			HRESULT Res = Enumerator->Next(WBEM_INFINITE,
						       1,
						       &ClassObject,
						       &Returned);

			if (!Returned) {
				break;
			}

			Res = ClassObject->Get(Field.c_str(), 
					       0, 
					       &Variant, 
					       nullptr, 
					       nullptr);

			if (typeid(T) == typeid(long) || typeid(T) == typeid(int)) {
				Value.push_back((T)Variant.intVal);
			}
			else if (typeid(T) == typeid(bool)) {
				Value.push_back((T)Variant.boolVal);
			}
			else if (typeid(T) == typeid(unsigned int)) {
				Value.push_back((T)Variant.uintVal);
			}
			else if (typeid(T) == typeid(unsigned short)) {
				Value.push_back((T)Variant.uiVal);
			}
			else if (typeid(T) == typeid(long long)) {
				Value.push_back((T)Variant.llVal);
			}
			else if (typeid(T) == typeid(unsigned long long)) {
				Value.push_back((T)Variant.ullVal);
			}
			else {
				Value.push_back((T)((bstr_t)Variant.bstrVal).copy());
			}

			VariantClear(&Variant);
			ClassObject->Release();
		}

		if (!Value.size()) {
			Value.resize(1);
		}

		Services->Release();
		Locator->Release();
		Enumerator->Release();
		CoUninitialize();
	}


	void QueryDisk() {

		std::wstring VolumePath{ L"\\\\.\\" };
		HANDLE hVolume{ nullptr };
		VOLUME_DISK_EXTENTS DiskExtents{ NULL };
		DWORD IoBytes{ NULL };
		ULARGE_INTEGER FreeBytesAvailable{};
		ULARGE_INTEGER TotalBytes{};
		int DriveCount{ 0 };
		std::unordered_map<std::wstring, std::vector<std::wstring>> VolumeData{}; // [drive model] [volume letters]


		std::vector <const wchar_t*> SerialNumber{};
		std::vector <const wchar_t*> Model{};
		std::vector <const wchar_t*> Interface{};
		std::vector <const wchar_t*> Name{};
		std::vector <const wchar_t*> DeviceId{};
		std::vector <const wchar_t*> FriendlyName{};
		std::vector <const wchar_t*> BootDirectory{};
		std::vector <wchar_t*> SortedDeviceId{};
		std::vector <unsigned int> MediaType{};
		std::vector <unsigned int> BusType{};
		std::vector <unsigned int> SortedBusType{};
		std::vector <unsigned int> DiskNumbers{};
		std::vector <unsigned int> SortedDiskNumbers{};


		// To get most of the data we want, we make several queries to the Windows Management Instrumentation (WMI) service
		// Queries to MSFT_PhysicalDisk and MSFT_Disk require a connection to the ROOT\\microsoft\\windows\\storage namespace

		QueryWMI(L"Win32_DiskDrive", L"SerialNumber", SerialNumber);
		QueryWMI(L"Win32_DiskDrive", L"Model", Model);
		QueryWMI(L"Win32_DiskDrive", L"InterfaceType", Interface);
		QueryWMI(L"Win32_DiskDrive", L"Name", Name);
		QueryWMI(L"Win32_LogicalDisk", L"DeviceId", DeviceId);
		QueryWMI(L"Win32_BootConfiguration", L"BootDirectory", BootDirectory);
		QueryWMI(L"MSFT_Disk", L"BusType", BusType, L"ROOT\\microsoft\\windows\\storage");
		QueryWMI(L"MSFT_Disk", L"Number", DiskNumbers, L"ROOT\\microsoft\\windows\\storage");
		QueryWMI(L"MSFT_PhysicalDisk", L"MediaType", MediaType, L"ROOT\\microsoft\\windows\\storage");
		QueryWMI(L"MSFT_PhysicalDisk", L"FriendlyName", FriendlyName, L"ROOT\\microsoft\\windows\\storage");


		DriveCount = DeviceId.size();
		this->Disk.resize(DriveCount);
		SortedDeviceId.resize(DriveCount);


		for (int i = 0; i < DriveCount; i++) {

			for (int j = 0; j < DriveCount; j++) {
				if (DeviceId.at(j) == L"X") {
					continue;
				}

				// Win32_LogicalDisk is relied on to get the drive letter (DeviceId), however, the data it returns will not be in the same order - 
				// as the results we get from Win32_DiskDrive
				// The drive letter is what we rely on to get the total size and free space of the drive, so we must map the data accordingly
				// To map the data, we can start by opening handles directly to the drive letters and calling into the volume via DeviceIoControl

				hVolume = CreateFileW((VolumePath + DeviceId.at(j)).c_str(),
						      NULL,
						      NULL,
						      nullptr,
						      OPEN_EXISTING,
						      NULL,
						      nullptr);

				// IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS will fill our buffer with a VOLUME_DISK_EXTENTS structure
				// First, we must get the number of disk extents

				DeviceIoControl(hVolume,
						IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
						nullptr,
						NULL,
						&DiskExtents,
						sizeof(DiskExtents),
						&IoBytes,
						nullptr);


				// VOLUME_DISK_EXTENTS contains an array of DISK_EXTENT structures. DISK_EXTENT contains a DWORD member, DiskNumber
				// DiskNumber will be the same number used to construct the name of the disk, which is PhysicalDriveX, where X is the DiskNumber

				DeviceIoControl(hVolume,
						IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
						nullptr,
						NULL,
						&DiskExtents,
						offsetof(VOLUME_DISK_EXTENTS, Extents[DiskExtents.NumberOfDiskExtents]),
						&IoBytes,
						nullptr);

				CloseHandle(hVolume);

				// To map the drive letter from Win32_LogicalDisk to the data returned by Win32_DiskDrive -
				// we compare the drive letter's DiskNumber to the number at the end of the "Name" we recieve from Win32_DiskDrive
				// We then reorder the drive letters accordingly

				if (DiskExtents.Extents->DiskNumber == std::stoi(&SafeString(Name.at(i)).back())) {
					SortedDeviceId.at(i) = const_cast<wchar_t*>(DeviceId.at(j));
					VolumeData[Model.at(i)].push_back(DeviceId.at(j));

					if (std::find(SortedDiskNumbers.begin(), SortedDiskNumbers.end(), DiskExtents.Extents->DiskNumber) == SortedDiskNumbers.end() ) {
						SortedDiskNumbers.push_back(DiskExtents.Extents->DiskNumber);
					}

					DeviceId.at(j) = L"X";

					if (j == DriveCount - 1) {
						break;
					}
				}
			}
		}


		// The BusType data returned by MSFT_Disk will also not be in the proper order, so we must map that accordingly as well
		// To do so, we simply compare the disk numbers returned from MSFT_Disk to the disk numbers we sorted according to the Win32_DiskDrive data

		for (int i = 0; i < DiskNumbers.size(); i++) {
			for (int j = 0; j < DiskNumbers.size(); j++) {
				if (DiskNumbers[j] == SortedDiskNumbers[i]) {
					SortedBusType.push_back(BusType.at(j));
					break;
				}
			}
		}


		for (int i = 0; i < DriveCount && i < SerialNumber.size(); i++) {

			RemoveWhitespaces(this->Disk.at(i).SerialNumber = SafeString(SerialNumber.at(i)));
			this->Disk.at(i).Model = SafeString(Model.at(i));
			this->Disk.at(i).Interface = SafeString(Interface.at(i));
			this->Disk.at(i).BusType = SortedBusType.at(i);
			this->Disk.at(i).Name = SafeString(Name.at(i));

			// Data from MSFT_PhysicalDisk will again not be in the same order as Win32_DiskDrive
			// So we compare the "FriendlyName" from MSFT_PhysicalDisk with the "Model" from Win32_DiskDrive
			// We then reorder the data accordingly

			for (int j = 0; j < FriendlyName.size(); j++) {
				if (!this->Disk.at(i).Model.compare(FriendlyName.at(j))) {
					this->Disk.at(i).MediaType = MediaType.at(j);
				}
			}

			if (VolumeData[Model.at(i)].size() == 1) {

				this->Disk.at(i).DriveLetter = SafeString(SortedDeviceId.at(i));

				// GetDiskFreeSpaceEx() will give us the size and free space available corresponding to the drive letters we have

				GetDiskFreeSpaceEx(this->Disk.at(i).DriveLetter.c_str(),
					&FreeBytesAvailable,
					&TotalBytes,
					nullptr);

				this->Disk.at(i).Size = TotalBytes.QuadPart / pow(1024, 3);
				this->Disk.at(i).FreeSpace = FreeBytesAvailable.QuadPart / pow(1024, 3);
				this->Disk.at(i).IsBootDrive = BootDirectory.at(0)[0] == this->Disk.at(i).DriveLetter[0] ? true : false;
				this->Disk.at(i).BusType = (MediaType.at(i) == 0 && SortedBusType.at(i) == 7) ? 123 : SortedBusType.at(i);
			} 
			else {

				unsigned long long VolumeCount{ VolumeData[Model.at(i)].size() };
				this->Disk.at(i).Volumes.resize(VolumeCount);

				for (int j = 0; j < VolumeCount; j++) {
					VolumeObject& Volume{ this->Disk.at(i).Volumes.at(j) };
					Volume.DriveLetter = SafeString(VolumeData[Model.at(i)][j].c_str());

					GetDiskFreeSpaceEx(Volume.DriveLetter.c_str(),
						&FreeBytesAvailable,
						&TotalBytes,
						nullptr);

					this->Disk.at(i).Size += ( Volume.Size = TotalBytes.QuadPart / pow(1024, 3) );
					this->Disk.at(i).FreeSpace += ( Volume.FreeSpace = FreeBytesAvailable.QuadPart / pow(1024, 3) );

					hVolume = CreateFileW(std::wstring(VolumePath + Volume.DriveLetter).c_str(),
						GENERIC_READ,
						FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
						nullptr,
						OPEN_EXISTING,
						FILE_ATTRIBUTE_NORMAL,
						nullptr);

					if (hVolume == INVALID_HANDLE_VALUE) {
						Volume.Name = L"(null)";
						Volume.SerialNumber = 0;
						break;
					}

					std::wstring VolumeName{};
					VolumeName.resize(MAX_PATH + 1, '\0');

					GetVolumeInformationByHandleW(hVolume,
						VolumeName.data(),
						MAX_PATH + 1,
						&Volume.SerialNumber,
						nullptr,
						nullptr,
						nullptr,
						0);
					
					// If the volume name is null, we want to be able to display "(null)" instead of just blank space - 
					// however, because we don't know the size of the name in advance, we have to preallocate a buffer of MAX_PATH + 1
					// This is a problem because the string will never be null, even if the volume name is
					// To remedy this, we filled the buffer with "\0" and will now loop through it, popping every trailing "\0"
					// If the buffer is empty afterwards, we know to display "(null)"
					// This will be a problem if the actual name of the volume ends with "\0" for whatever reason
					// In such a case, we'll end up popping the name, or at least any trailing "\0"s -
					// however, that's a trade-off that I think is acceptable
					
					for (int i = MAX_PATH + 1; i >= 0 && VolumeName.empty() == false; i--) {
						if (VolumeName.back() == L'\0') {
							VolumeName.pop_back();
						}
					}

					Volume.Name = VolumeName.empty() == true ? L"(null)" : VolumeName;
					CloseHandle(hVolume);
				}
			}
		}

		for (int i = 0; i < this->Disk.size(); i++) {
			if (this->Disk.at(i).Model.empty() && this->Disk.at(i).DriveLetter.empty()) {
				this->Disk.erase(this->Disk.begin() + i);
				--i;
			}
		}
	}


	void QuerySMBIOS() {

		std::vector <const wchar_t*> Manufacturer{};
		std::vector <const wchar_t*> Product{};
		std::vector <const wchar_t*> Version{};
		std::vector <const wchar_t*> SerialNumber{};

		QueryWMI(L"Win32_BaseBoard", L"Manufacturer", Manufacturer);
		QueryWMI(L"Win32_BaseBoard", L"Product", Product);
		QueryWMI(L"Win32_BaseBoard", L"Version", Version);
		QueryWMI(L"Win32_BaseBoard", L"SerialNumber", SerialNumber);


		this->SMBIOS.Manufacturer = SafeString(Manufacturer.at(0));
		this->SMBIOS.Product = SafeString(Product.at(0));
		this->SMBIOS.Version = SafeString(Version.at(0));
		this->SMBIOS.SerialNumber = SafeString(SerialNumber.at(0));
	}


	void QueryProcessor() {

		std::vector <const wchar_t*> ProcessorId{};
		std::vector <const wchar_t*> Manufacturer{};
		std::vector <const wchar_t*> Name{};
		std::vector <int> Cores{};
		std::vector <int> Threads{};

		QueryWMI(L"Win32_Processor", L"ProcessorId", ProcessorId);
		QueryWMI(L"Win32_Processor", L"Manufacturer", Manufacturer);
		QueryWMI(L"Win32_Processor", L"Name", Name);
		QueryWMI<int>(L"Win32_Processor", L"NumberOfCores", Cores);
		QueryWMI<int>(L"Win32_Processor", L"NumberOfLogicalProcessors", Threads);

		this->CPU.ProcessorId = SafeString(ProcessorId.at(0));
		this->CPU.Manufacturer = SafeString(Manufacturer.at(0));
		this->CPU.Name = SafeString(Name.at(0));
		this->CPU.Cores = Cores.at(0);
		this->CPU.Threads = Threads.at(0);
	}


	void QueryGPU() {

		std::vector <const wchar_t*> Name{};
		std::vector <const wchar_t*> DriverVersion{};
		std::vector <unsigned long long> Memory{};
		std::vector <int> XRes{};
		std::vector <int> YRes{};
		std::vector <int> RefreshRate{};

		QueryWMI(L"Win32_VideoController", L"Name", Name);
		QueryWMI(L"Win32_VideoController", L"DriverVersion", DriverVersion);
		QueryWMI(L"Win32_VideoController", L"AdapterRam", Memory);
		QueryWMI(L"Win32_VideoController", L"CurrentHorizontalResolution", XRes);
		QueryWMI(L"Win32_VideoController", L"CurrentVerticalResolution", YRes);
		QueryWMI(L"Win32_VideoController", L"CurrentRefreshRate", RefreshRate);

		this->GPU.resize(Name.size());

		for (int i = 0; i < Name.size(); i++) {
			this->GPU.at(i).Name = SafeString(Name.at(i));
			this->GPU.at(i).DriverVersion = SafeString(DriverVersion.at(i));
			this->GPU.at(i).Memory = Memory.at(i) * 2 / (1024 * 1024);
			this->GPU.at(i).XResolution = XRes.at(i);
			this->GPU.at(i).YResolution = YRes.at(i);
			this->GPU.at(i).RefreshRate = RefreshRate.at(i);
		}
	}


	void QuerySystem() {

		std::vector <const wchar_t*> SystemName{};
		std::vector <const wchar_t*> OSVersion{};
		std::vector <const wchar_t*> OSName{};
		std::vector <const wchar_t*> OSArchitecture{};
		std::vector <const wchar_t*> OSSerialNumber{};
		std::vector <bool> IsHypervisorPresent{};

		QueryWMI(L"Win32_ComputerSystem", L"Name", SystemName);
		QueryWMI(L"Win32_ComputerSystem", L"HypervisorPresent", IsHypervisorPresent);
		QueryWMI(L"Win32_OperatingSystem", L"Version", OSVersion);
		QueryWMI(L"Win32_OperatingSystem", L"Name", OSName);
		QueryWMI(L"Win32_OperatingSystem", L"OSArchitecture", OSArchitecture);
		QueryWMI(L"Win32_OperatingSystem", L"SerialNumber", OSSerialNumber);

		std::wstring wOSName{ SafeString(OSName.at(0)) };

		if (wOSName.find('|') != std::wstring::npos) {
			wOSName.resize(wOSName.find('|'));
		}

		this->System.Name = SafeString(SystemName.at(0));
		this->System.IsHypervisorPresent = IsHypervisorPresent.at(0);
		this->System.OSName = wOSName;
		this->System.OSVersion = SafeString(OSVersion.at(0));
		this->System.OSSerialNumber = SafeString(OSSerialNumber.at(0));
		this->System.OSArchitecture = SafeString(OSArchitecture.at(0));
	}


	void QueryNetwork() {

		std::vector <const wchar_t*> Name{};
		std::vector <const wchar_t*> MAC{};

		QueryWMI(L"Win32_NetworkAdapter", L"Name", Name);
		QueryWMI(L"Win32_NetworkAdapter", L"MACAddress", MAC);

		this->NetworkAdapter.resize(Name.size());

		for (int i = 0; i < Name.size(); i++) {
			this->NetworkAdapter.at(i).Name = SafeString(Name.at(i));
			this->NetworkAdapter.at(i).MAC = SafeString(MAC.at(i));
		}
	}


	void QueryPhysicalMemory() {

		std::vector<const wchar_t*> PartNumber{};

		QueryWMI(L"Win32_PhysicalMemory", L"PartNumber", PartNumber);
		this->PhysicalMemory.PartNumber = SafeString(PartNumber.at(0));
	}


	void QueryRegistry() {
		this->Registry.ComputerHardwareId = SafeString(GetHKLM(L"SYSTEM\\CurrentControlSet\\Control\\SystemInformation", L"ComputerHardwareId").c_str());
	}


	void GetHardwareId() {
		QueryDisk();
		QuerySMBIOS();
		QueryProcessor();
		QueryGPU();
		QuerySystem();
		QueryNetwork();
		QueryPhysicalMemory();
		QueryRegistry();
	}
};

```

`resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by WindowsHW.rc
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```