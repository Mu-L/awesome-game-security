Project Path: arc_hanickadot_cthash_y_q2ie9d

Source Tree:

```txt
arc_hanickadot_cthash_y_q2ie9d
├── CMakeLists.txt
├── LICENSE
├── README.md
├── checksum.cpp
├── cmake
│   ├── colors.cmake
│   ├── coverage.cmake
│   └── pedantic.cmake
├── default.profraw
├── example.cpp
├── examples
│   ├── CMakeLists.txt
│   ├── playground.cpp
│   ├── sha256.cpp
│   ├── sha3.cpp
│   ├── shake128.cpp
│   └── xxhash.cpp
├── external
│   └── catch2
├── include
│   ├── CMakeLists.txt
│   ├── cthash
│   │   ├── cthash.hpp
│   │   ├── encoding
│   │   │   ├── base.hpp
│   │   │   ├── bit-buffer.hpp
│   │   │   ├── chunk-of-bits.hpp
│   │   │   ├── concepts.hpp
│   │   │   └── encodings.hpp
│   │   ├── fixed-string.hpp
│   │   ├── hasher.hpp
│   │   ├── internal
│   │   │   ├── algorithm.hpp
│   │   │   ├── bit.hpp
│   │   │   ├── concepts.hpp
│   │   │   ├── convert.hpp
│   │   │   ├── deduce.hpp
│   │   │   └── hexdec.hpp
│   │   ├── sha2
│   │   │   ├── common.hpp
│   │   │   ├── sha224.hpp
│   │   │   ├── sha256.hpp
│   │   │   ├── sha384.hpp
│   │   │   ├── sha512
│   │   │   │   └── t.hpp
│   │   │   └── sha512.hpp
│   │   ├── sha3
│   │   │   ├── common.hpp
│   │   │   ├── keccak-base.hpp
│   │   │   ├── keccak.hpp
│   │   │   ├── sha3-224.hpp
│   │   │   ├── sha3-256.hpp
│   │   │   ├── sha3-384.hpp
│   │   │   ├── sha3-512.hpp
│   │   │   ├── sha3.hpp
│   │   │   ├── shake128.hpp
│   │   │   └── shake256.hpp
│   │   ├── simple.hpp
│   │   ├── value.hpp
│   │   └── xxhash.hpp
│   └── cthash-single-header.hpp
└── tests
    ├── CMakeLists.txt
    ├── benchmark
    │   ├── sha256.cpp
    │   ├── sha3-256.cpp
    │   └── sha512.cpp
    ├── encoding
    │   ├── base.cpp
    │   ├── bit-buffer.cpp
    │   ├── chunk-of-bits.cpp
    │   └── selection.cpp
    ├── hexdec.cpp
    ├── internal
    │   └── support.hpp
    ├── keccak.cpp
    ├── sha2
    │   ├── sha224.cpp
    │   ├── sha256.cpp
    │   ├── sha384.cpp
    │   ├── sha512.cpp
    │   └── sha512t.cpp
    ├── sha3
    │   ├── keccak-256.cpp
    │   ├── keccak-384.cpp
    │   ├── keccak-512.cpp
    │   ├── sha3-224.cpp
    │   ├── sha3-256.cpp
    │   ├── sha3-384.cpp
    │   ├── sha3-512.cpp
    │   ├── shake128.cpp
    │   ├── shake256.cpp
    │   └── xor-overwrite.cpp
    ├── value.cpp
    └── xxhash
        └── basics.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.21)

project(cthash VERSION 1.0 LANGUAGES CXX)

if (PROJECT_IS_TOP_LEVEL)
set(CMAKE_CXX_STANDARD 20)
list(PREPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")

include(colors)

option(CTHASH_TESTS "Enable CTHASH testing" OFF)

if (CTHASH_TESTS)
	if (EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/external/catch2/CMakeLists.txt)
		message(STATUS "Using local copy of catch2")
		
		#set(CATCH_CONFIG_FAST_COMPILE ON)
		add_subdirectory(external/catch2 EXCLUDE_FROM_ALL SYSTEM)
	endif()
	
	option(CTHASH_COVERAGE "Enable CTHASH test-coverage" ON)

	if (CTHASH_COVERAGE)
		include(coverage)
		enable_coverage()
	else()
		message(STATUS "Test coverage measurement is OFF")
	endif()

	add_subdirectory(tests)
else()
	message(STATUS "Tests are disabled")
endif()

include(pedantic)

option(CTHASH_EXAMPLES "Build CTHASH examples" ON)

if (CTHASH_EXAMPLES)
	add_subdirectory(examples)
	
	add_executable(example example.cpp)
	target_link_libraries(example cthash)

	add_executable(checksum checksum.cpp)
	target_link_libraries(checksum cthash)
endif()

endif()

add_subdirectory(include)

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

    1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

    2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

    3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

    4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

    5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

    6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

    7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

    8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

    9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

    END OF TERMS AND CONDITIONS

    APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

    Copyright [yyyy] [name of copyright owner]

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.


--- LLVM Exceptions to the Apache 2.0 License ----

As an exception, if, as a result of your compiling your source code, portions
of this Software are embedded into an Object form of such source code, you
may redistribute such embedded portions in such Object form without complying
with the conditions of Sections 4(a), 4(b) and 4(d) of the License.

In addition, if you combine or link compiled forms of this Software with
software that is licensed under the GPLv2 ("Combined Software") and if a
court of competent jurisdiction determines that the patent provision (Section
3), the indemnity provision (Section 9) or other Section of the License
conflicts with the conditions of the GPLv2, you may retroactively and
prospectively choose to deem waived or otherwise exclude such Section(s) of
the License, but only in their entirety and only with respect to the Combined
Software.

```

`README.md`:

```md
# CTHASH (Compile Time Hash)

This library is constexpr implementation of SHA-2, SHA-3, and xxhash family of hashes.

## Supported hash function

The library also implements hash_value literals in namespace `cthash::literals` (suffixes in parenthesis for each hash function type). This literal types doesn't compute hash value of its content, but are merely strong typed value from specified hash algorithm (eg. so you won't mix up SHA-256 and SHA3-256 results).

* SHA-224 (`_sha224`)
* SHA-256 (`_sha256`)
* SHA-384 (`_sha384`)
* SHA-512 (`_sha512`)
* SHA-512/t (only for T dividable by 8) (`_sha512_224`, `_sha512_256`)

* SHA3-224 (`_sha3_224`)
* SHA3-256 (`_sha3_256`)
* SHA3-384 (`_sha3_384`)
* SHA3-512 (`_sha3_512`)

* SHAKE-128 (`_shake128`)
* SHAKE-256 (`_shake256`)

* pre-NISE Keccak-256 (`_keccak_256`)
* pre-NISE Keccak-384 (`_keccak_384`)
* pre-NISE Keccak-512 (`_keccak_512`)

* XXHASH-32 (`_xxh32`)
* XXHASH-64 (`_xxh64`)

## Example

SHA256:
```c++
using namespace cthash::literals;

constexpr auto my_hash = cthash::sha256{}.update("hello there!").final();
// or
constexpr auto my_hash = cthash::simple<cthash::sha256>("hello there!");

static_assert(my_hash == "c69509590d81db2f37f9d75480c8efedf79a77933db5a8319e52e13bfd9874a3"_sha256);
```

SHA-3:
```c++
using namespace cthash::literals;

constexpr auto my_hash = cthash::sha3_256{}.update("hello there!").final();
// or
constexpr auto my_hash = cthash::simple<cthash::sha3_256>("hello there!");

static_assert(my_hash == "c7fd85f649fba4bd6fb605038ae8530cf2239152bbbcb9d91d260cc2a90a9fea"_sha3_256);
```

SHAKE128 (d=1024) (with compile time set `d` bits):
```c++
using namespace cthash::literals;

constexpr auto my_hash = cthash::shake128{}.update("hello there!").final<1024>();

static_assert(my_hash == "86089a77e15628597e45caf70c8ef271def6775c54d42d61fb45b9cd6d3b288e5fbd0042241a4aa9180c1bfe94542e16765b3a48d549771202e50aebf8d4f51bd00be2a427f81b7b58aaebc97f89559bca1ea21fec5047de70d075e14e5a3c95c002fd9f81925672d408d4b60c0105e5858df25b64af9b20cec973d66616da81"_shake128);
```

Also look at [runtime example](example.cpp).

### Including library

You can include specific hash function only by `#include <cthash/sha2/sha256.hpp>` or you can include whole library by `#include <cthash/cthash.hpp>`

#### Specific include for SHA-512/t

Just include `#include <cthash/sha2/sha512/t.hpp>`.

## Implementation note

There is no allocation at all, everything is done as a value type from user's perspective. No explicit optimizations were done (for now).

## Compiler support

You need a C++20 compiler.

* Clang 19+
* GCC 13+ 
* MSVC 14.44+


```

`checksum.cpp`:

```cpp
#include <cthash/cthash.hpp>
#include <chrono>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <iostream>

struct mapped_file {
	static constexpr int invalid = -1;

	int fd{invalid};
	size_t sz{0};
	void * ptr{nullptr};

	static size_t get_size(int fd) {
		if (fd == invalid) {
			return 0;
		}

		return (size_t)lseek(fd, 0, SEEK_END);
	}

	mapped_file(const char * path): fd{open(path, O_RDONLY)}, sz{get_size(fd)}, ptr{mmap(nullptr, sz, PROT_READ, MAP_PRIVATE, fd, 0)} { }

	mapped_file(const mapped_file &) = delete;
	mapped_file(mapped_file &&) = delete;

	~mapped_file() {
		if (ptr && fd != invalid) {
			munmap(ptr, sz);
			close(fd);
		}
	}

	auto get_span() const noexcept {
		return std::span<const std::byte>(reinterpret_cast<std::byte *>(ptr), sz);
	}
};

int main(int argc, char ** argv) {
	if (argc < 3) {
		std::cerr << argv[0] << " hash file\n";
		std::cerr << "hash is one of: sha-224, sha-256, sha-384, sha-512, sha-512/223, sha-512/256, sha3-224, sha3-256, sha3-384, sha3-512, \n";
		std::cerr << "  shake-128/n, shake-256/n (where n is 32/64/128/256/512/1024/2048),\n";
		std::cerr << "  xxhash32, xxhash64\n";
		return 1;
	}

	const auto h = std::string_view(argv[1]);
	const auto f = mapped_file(argv[2]);

	if (f.fd == mapped_file::invalid) {
		std::cerr << "can't open file!\n";
		return 1;
	}

	const auto start = std::chrono::high_resolution_clock::now();

	if (h == "sha-224") {
		std::cout << cthash::sha224{}.update(f.get_span()).final() << "\n";
	} else if (h == "sha-256") {
		std::cout << cthash::sha256{}.update(f.get_span()).final() << "\n";
	} else if (h == "sha-384") {
		std::cout << cthash::sha384{}.update(f.get_span()).final() << "\n";
	} else if (h == "sha-512") {
		std::cout << cthash::sha512{}.update(f.get_span()).final() << "\n";
	} else if (h == "sha-512/224") {
		std::cout << cthash::sha512t<224>{}.update(f.get_span()).final() << "\n";
	} else if (h == "sha-512/256") {
		std::cout << cthash::sha512t<256>{}.update(f.get_span()).final() << "\n";
	} else if (h == "sha3-224") {
		std::cout << cthash::sha3_224{}.update(f.get_span()).final() << "\n";
	} else if (h == "sha3-256") {
		std::cout << cthash::sha3_256{}.update(f.get_span()).final() << "\n";
	} else if (h == "sha3-384") {
		std::cout << cthash::sha3_384{}.update(f.get_span()).final() << "\n";
	} else if (h == "sha3-512") {
		std::cout << cthash::sha3_512{}.update(f.get_span()).final() << "\n";
	} else if (h == "shake-128/32") {
		std::cout << cthash::shake128{}.update(f.get_span()).final<32>() << "\n";
	} else if (h == "shake-128/64") {
		std::cout << cthash::shake128{}.update(f.get_span()).final<64>() << "\n";
	} else if (h == "shake-128/128") {
		std::cout << cthash::shake128{}.update(f.get_span()).final<128>() << "\n";
	} else if (h == "shake-128/256") {
		std::cout << cthash::shake128{}.update(f.get_span()).final<256>() << "\n";
	} else if (h == "shake-128/512") {
		std::cout << cthash::shake128{}.update(f.get_span()).final<512>() << "\n";
	} else if (h == "shake-128/1024") {
		std::cout << cthash::shake128{}.update(f.get_span()).final<1024>() << "\n";
	} else if (h == "shake-128/2048") {
		std::cout << cthash::shake128{}.update(f.get_span()).final<2048>() << "\n";
	} else if (h == "shake-256/32") {
		std::cout << cthash::shake256{}.update(f.get_span()).final<32>() << "\n";
	} else if (h == "shake-256/64") {
		std::cout << cthash::shake256{}.update(f.get_span()).final<64>() << "\n";
	} else if (h == "shake-256/128") {
		std::cout << cthash::shake256{}.update(f.get_span()).final<128>() << "\n";
	} else if (h == "shake-256/256") {
		std::cout << cthash::shake256{}.update(f.get_span()).final<256>() << "\n";
	} else if (h == "shake-256/512") {
		std::cout << cthash::shake256{}.update(f.get_span()).final<512>() << "\n";
	} else if (h == "shake-256/1024") {
		std::cout << cthash::shake256{}.update(f.get_span()).final<1024>() << "\n";
	} else if (h == "shake-256/2048") {
		std::cout << cthash::shake256{}.update(f.get_span()).final<2048>() << "\n";
	} else if (h == "xxhash32") {
		std::cout << cthash::xxhash32{}.update(f.get_span()).final() << "\n";
	} else if (h == "xxhash64") {
		std::cout << cthash::xxhash64{}.update(f.get_span()).final() << "\n";
	} else {
		std::cerr << "unknown hash function!\n";
		return 1;
	}

	const auto end = std::chrono::high_resolution_clock::now();
	const auto dur = end - start;

	std::cerr << "and it took " << std::chrono::duration_cast<std::chrono::milliseconds>(dur).count() << " ms\n";
}
```

`cmake/colors.cmake`:

```cmake
option (FORCE_COLORED_OUTPUT "Always produce ANSI-colored output (GNU/Clang only)." ON)
if (${FORCE_COLORED_OUTPUT})
	if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
		add_compile_options ($<$<COMPILE_LANGUAGE:C>:-fdiagnostics-color=always>)
		add_compile_options ($<$<COMPILE_LANGUAGE:CXX>:-fdiagnostics-color=always>)
	elseif ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
		add_compile_options ($<$<COMPILE_LANGUAGE:C>:-fcolor-diagnostics>)
		add_compile_options ($<$<COMPILE_LANGUAGE:CXX>:-fcolor-diagnostics>)
	endif ()
endif ()
```

`cmake/coverage.cmake`:

```cmake
SET(test_source "int main() { }")

try_compile(COVERAGE_WORKS SOURCE_FROM_VAR test.cpp test_source LINK_OPTIONS -fprofile-instr-generate -fcoverage-mapping OUTPUT_VARIABLE COVERAGE_WORKS_OUTPUT)

if (NOT COVERAGE_WORKS)
	#message(STATUS "test coverage is not compatible with current compiler")
	#message(STATUS "${COVERAGE_WORKS_OUTPUT}")
	function(enable_coverage)
	endfunction()
	
	function(coverage_report_after EVENT TARGET)
		add_custom_target(coverage DEPENDS ${EVENT})
	endfunction()
	
	unset(LLVM_COV)
	return()
endif()

cmake_path(GET CMAKE_CXX_COMPILER PARENT_PATH COMPILER_HINT_PATH)

if (NOT LLVM_PROFDATA)
	find_program(LLVM_PROFDATA llvm-profdata HINTS ${COMPILER_HINT_PATH})
endif()

if (NOT LLVM_COV)
	find_program(LLVM_COV llvm-cov HINTS ${COMPILER_HINT_PATH})
endif()

if (LLVM_PROFDATA AND LLVM_COV)
	set(LLVM_PROFDATA "${LLVM_PROFDATA}" CACHE INTERNAL "path to llvm-profdata")
	set(LLVM_COV "${LLVM_COV}" CACHE INTERNAL "path to llvm-cov")
else()
	find_program(XCRUN xcrun)
	if (XCRUN)
		set(LLVM_PROFDATA "${XCRUN} llvm-profdata" CACHE INTERNAL "path to llvm-profdata")
		set(LLVM_COV "${XCRUN} llvm-cov" CACHE INTERNAL "path to llvm-cov")
	endif()
endif()

find_program(OPEN_UTILITY open)
set(OPEN_UTILITY "${OPEN_UTILITY}" CACHE INTERNAL "path to open utility")

function(enable_coverage)
	
	if (NOT COVERAGE_WORKS)
		message(FATAL_ERROR "Source level code coverage is not supporter!")
	endif()
	
	if (NOT LLVM_COV)
		message(FATAL_ERROR "Source level code coverage is supported only for Clang compiler! (CMAKE_CXX_COMPILER_ID = ${CMAKE_CXX_COMPILER_ID})")
	endif()
	
	message(STATUS "Enabling Clang source code-coverage (llvm-cov=${LLVM_COV})")
	
	# add flags to emit coverage
	add_compile_options("-fprofile-instr-generate" "-fcoverage-mapping" "-g")
	add_link_options("-fprofile-instr-generate" "-fcoverage-mapping")
	add_compile_options("-ffile-prefix-map=${CMAKE_SOURCE_DIR}/=/")
endfunction()

function(coverage_report_after EVENT TARGET)
	if (NOT LLVM_COV)
		add_custom_target(coverage DEPENDS ${EVENT})
		return()
	endif()

	SET(coverage_data_name "default.profraw")
	add_custom_command(TARGET ${EVENT} POST_BUILD 
		COMMAND ${LLVM_PROFDATA} merge -sparse ${coverage_data_name} -o coverage.profdata 
		COMMAND ${LLVM_COV} show $<TARGET_FILE:${TARGET}> -format html -instr-profile=coverage.profdata "-ignore-filename-regex=\"(external/.*|tests/.*|cthash/internal/assert[.]hpp)\""  -output-dir ${CMAKE_BINARY_DIR}/report -show-instantiations=false -show-directory-coverage -show-expansions=false -show-line-counts --show-line-counts-or-regions -Xdemangler c++filt -Xdemangler -n -show-branches=percent -tab-size=4 -path-equivalence=/,${CMAKE_SOURCE_DIR} 
		COMMAND cd ${CMAKE_BINARY_DIR} && zip -q -r -9 report.zip report BYPRODUCTS  ${CMAKE_BINARY_DIR}/report.zip COMMENT "Generating Code-Coverage report"
	)
	
	add_custom_target(coverage DEPENDS ${CMAKE_BINARY_DIR}/report.zip)
	
	if (OPEN_UTILITY)
		add_custom_command(TARGET coverage POST_BUILD COMMAND ${OPEN_UTILITY} ${CMAKE_BINARY_DIR}/report/index.html DEPENDS ${CMAKE_BINARY_DIR}/report.zip)
	endif()
endfunction()

```

`cmake/pedantic.cmake`:

```cmake
macro(add_c_and_cxx_compile_options NAME)
	add_compile_options("$<$<COMPILE_LANGUAGE:C>:${NAME}>")
	add_compile_options("$<$<COMPILE_LANGUAGE:CXX>:${NAME}>")
endmacro()

macro(add_c_and_cxx_compile_definitions NAME)
	add_compile_definitions("$<$<COMPILE_LANGUAGE:C>:${NAME}>")
	add_compile_definitions("$<$<COMPILE_LANGUAGE:CXX>:${NAME}>")
endmacro()

if (MSVC)
	add_c_and_cxx_compile_options("/W4")
	add_c_and_cxx_compile_options("/WX")
else()
	add_c_and_cxx_compile_options("-Wall")
	add_c_and_cxx_compile_options("-Wextra")
	add_c_and_cxx_compile_options("-pedantic")
	add_c_and_cxx_compile_options("-Wshadow")
	add_c_and_cxx_compile_options("-Wconversion")
	add_c_and_cxx_compile_options("-Werror")
	
	if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
		add_c_and_cxx_compile_definitions("_LIBCPP_ENABLE_NODISCARD")
		
		if (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 13.0)
			add_c_and_cxx_compile_options("-Wno-missing-braces")
		endif()
	elseif(CMAKE_CXX_COMPILER_ID STREQUAL "AppleClang")
		add_c_and_cxx_compile_definitions("_LIBCPP_ENABLE_NODISCARD")
		add_c_and_cxx_compile_options("-Wno-missing-braces")
	endif()
endif()

```

`example.cpp`:

```cpp
#include <cthash/cthash.hpp>
#include <print>

int main(int argc, char ** argv) {
	if (argc < 2) {
		return 1;
	}

	const auto in = std::string_view(argv[1]);

	std::print("        sha224 = {:hexdec}\n", cthash::sha224{}.update(in).final());
	std::print("        sha256 = {:hexdec}\n", cthash::sha256{}.update(in).final());
	std::print("        sha384 = {:hexdec}\n", cthash::sha384{}.update(in).final());
	std::print("        sha512 = {:hexdec}\n", cthash::sha512{}.update(in).final());
	std::print("    sha512/224 = {:hexdec}\n", cthash::sha512t<224>{}.update(in).final());
	std::print("    sha512/256 = {:hexdec}\n", cthash::sha512t<256>{}.update(in).final());

	std::print("      sha3-224 = {:hexdec}\n", cthash::sha3_224{}.update(in).final());
	std::print("      sha3-256 = {:hexdec}\n", cthash::sha3_256{}.update(in).final());
	std::print("      sha3-384 = {:base64url}\n", cthash::sha3_384{}.update(in).final());
	std::print("      sha3-512 = {:base64url}\n", cthash::sha3_512{}.update(in).final());

	std::print("shake-128/64   = {:base64url}\n", cthash::shake128{}.update(in).final<64>());
	std::print("shake-128/128  = {:base64url}\n", cthash::shake128{}.update(in).final<128>());
	std::print("shake-128/1024 = {:base64url}\n", cthash::shake128{}.update(in).final<1024>());

	std::print("shake-256/64   = {:base64url}\n", cthash::shake256{}.update(in).final<64>());
	std::print("shake-256/128  = {:base64url}\n", cthash::shake256{}.update(in).final<128>());
	std::print("shake-256/1024 = {:base64url}\n", cthash::shake256{}.update(in).final<1024>());

	std::print("      xxhash32 = {:hexdec}\n", cthash::xxhash32{}.update(in).final());
	std::print("      xxhash64 = {:hexdec}\n", cthash::xxhash64{}.update(in).final());
}
```

`examples/CMakeLists.txt`:

```txt
add_executable(sha3 sha3.cpp)
target_link_libraries(sha3 cthash)

add_executable(sha256 sha256.cpp)
target_link_libraries(sha256 cthash)

add_executable(shake128 shake128.cpp)
target_link_libraries(shake128 cthash)

add_executable(xxhash xxhash.cpp)
target_link_libraries(xxhash cthash)

add_executable(playground playground.cpp)
target_link_libraries(playground cthash)
```

`examples/playground.cpp`:

```cpp
#include <cthash/cthash.hpp>
#include <iostream>

using namespace cthash::literals;

template <typename> struct identify;

int main() {
	const cthash::sha256_value y = "1d996e033d612d9af2b44b70061ee0e868bfd14c2dd90b129e1edeb7953e7985"_sha256;

	std::cout << (y | cthash::hexdec_encode) << '\n';
	std::cout << (y | cthash::base32_encode) << '\n';
	std::cout << (y | cthash::binary_encode) << '\n';
}
```

`examples/sha256.cpp`:

```cpp
#include <cthash/sha2/sha256.hpp>
#include <print>

using namespace cthash::literals;

int main() {
	constexpr auto a = cthash::sha256{}.update("hello there!").final();

	std::print("{}", a);
}

```

`examples/sha3.cpp`:

```cpp
#include <cthash/sha3/sha3-256.hpp>
#include <print>

using namespace cthash::literals;

int main() {
	constexpr auto a = cthash::sha3_256{}.update("hello there!").final();

	std::print("{:HEXDEC}", a);
}

```

`examples/shake128.cpp`:

```cpp
#include <cthash/sha3/shake128.hpp>

using namespace cthash::literals;

int main() {
	constexpr auto expected = "86089a77e15628597e45caf70c8ef271def6775c54d42d61fb45b9cd6d3b288e5fbd0042241a4aa9180c1bfe94542e16765b3a48d549771202e50aebf8d4f51bd00be2a427f81b7b58aaebc97f89559bca1ea21fec5047de70d075e14e5a3c95c002fd9f81925672d408d4b60c0105e5858df25b64af9b20cec973d66616da813e544b951bfedbc1f2f79214c900be9621611206aa8b5f5727c38372d4410576206a42908800d8520469b4a62fdb6633a4283fcc290d709b48dad426db1fbe6aff9dabfbf2537f0c0bfce550ce1af1269a65022d29e12268da51bee5f1c54c85be5782ccb6996c902ecfa9f6cc28d52d2e5710677fd076751af267405e8c5ae0"_shake128;

	constexpr cthash::shake128_value<32> calculated_32bit = cthash::shake128().update("hello there!").final<32>();
	constexpr cthash::shake128_value<128> calculated_128bit = cthash::shake128().update("hello there!").final<128>();
	constexpr cthash::shake128_value<512> calculated_512bit = cthash::shake128().update("hello there!").final<512>();
	constexpr cthash::shake128_value<1024> calculated_1024bit = cthash::shake128().update("hello there!").final<1024>();
	constexpr cthash::shake128_value<2048> calculated_2048bit = cthash::shake128().update("hello there!").final<2048>();
	constexpr cthash::shake128_value<4096> calculated_4096bit = cthash::shake128().update("hello there!").final<4096>();

	// it only checks common length of both operands
	static_assert(expected == calculated_32bit);
	static_assert(expected == calculated_128bit);
	static_assert(expected == calculated_512bit);
	static_assert(expected == calculated_1024bit);
	static_assert(expected == calculated_2048bit);
	static_assert(expected == calculated_4096bit);
}
```

`examples/xxhash.cpp`:

```cpp
#include <cthash/xxhash.hpp>
#include <print>

using namespace cthash::literals;

int main() {
	constexpr auto a = cthash::xxhash32{}.update("hello there!").final();

	std::print("{:base32}", a);
}

```

`include/CMakeLists.txt`:

```txt
add_library(cthash INTERFACE)

target_compile_features(cthash INTERFACE cxx_std_23)
target_include_directories(cthash INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})

target_sources(cthash INTERFACE FILE_SET headers TYPE HEADERS FILES
	cthash/cthash.hpp
	cthash/encoding/base.hpp
	cthash/encoding/bit-buffer.hpp
	cthash/encoding/chunk-of-bits.hpp
	cthash/encoding/concepts.hpp
	cthash/encoding/encodings.hpp
	cthash/fixed-string.hpp
	cthash/hasher.hpp
	cthash/simple.hpp
	cthash/value.hpp
	cthash/xxhash.hpp
	cthash/internal/algorithm.hpp
	cthash/internal/bit.hpp
	cthash/internal/concepts.hpp
	cthash/internal/convert.hpp
	cthash/internal/deduce.hpp
	cthash/internal/hexdec.hpp
	cthash/sha2/common.hpp
	cthash/sha2/sha224.hpp
	cthash/sha2/sha256.hpp
	cthash/sha2/sha384.hpp
	cthash/sha2/sha512/t.hpp
	cthash/sha2/sha512.hpp
	cthash/sha3/common.hpp
	cthash/sha3/keccak.hpp
	cthash/sha3/sha3-224.hpp
	cthash/sha3/sha3-256.hpp
	cthash/sha3/sha3-384.hpp
	cthash/sha3/sha3-512.hpp
	cthash/sha3/shake128.hpp
	cthash/sha3/shake256.hpp
)

add_custom_target(single-header DEPENDS single-header.hpp)

add_custom_target(single-header.hpp COMMAND python3 -m quom ${CMAKE_CURRENT_SOURCE_DIR}/cthash/cthash.hpp ${CMAKE_CURRENT_SOURCE_DIR}/cthash-single-header.hpp)

```

`include/cthash-single-header.hpp`:

```hpp
#ifndef CTHASH_CTHASH_HPP
#define CTHASH_CTHASH_HPP

// SHA-2 family
#ifndef CTHASH_SHA2_SHA224_HPP
#define CTHASH_SHA2_SHA224_HPP

#ifndef CTHASH_SHA2_SHA256_HPP
#define CTHASH_SHA2_SHA256_HPP

#ifndef CTHASH_SHA2_COMMON_HPP
#define CTHASH_SHA2_COMMON_HPP

#ifndef CONSTEXPR_SHA2_HASHER_HPP
#define CONSTEXPR_SHA2_HASHER_HPP

#ifndef CTHASH_SIMPLE_HPP
#define CTHASH_SIMPLE_HPP

#include <utility>

namespace cthash {

template <typename Hasher, typename In, typename... Args> concept hasher_like = requires(Hasher & h, const In & in, Args &&... args) //
{
	{ Hasher{std::forward<Args>(args)...} };
	{ h.update(in) } -> std::same_as<Hasher &>;
	{ h.final() };
};

template <typename Hasher, typename In> concept direct_hasher = requires(Hasher & h, const In & in) //
{
	{ h.update_and_final(in) };
};

template <typename Hasher, typename T, typename... Args>
requires hasher_like<Hasher, T, Args...>
constexpr auto simple(const T & value, Args &&... args) noexcept {
	if constexpr (direct_hasher<Hasher, T>) {
		return Hasher{std::forward<Args>(args)...}.update_and_final(value);
	} else {
		return Hasher{std::forward<Args>(args)...}.update(value).final();
	}
}

} // namespace cthash

#endif

#ifndef CTHASH_VALUE_HPP
#define CTHASH_VALUE_HPP

#ifndef CTHASH_FIXED_STRING_HPP
#define CTHASH_FIXED_STRING_HPP

#include <algorithm>
#include <span>
#include <string_view>

namespace cthash {

template <typename CharT, size_t N> struct fixed_string: std::array<CharT, N> {
	using super = std::array<CharT, N>;

	consteval static auto from_string_literal(const CharT (&in)[N + 1]) -> std::array<CharT, N> {
		std::array<CharT, N> out;
		std::copy_n(in, N, out.data());
		return out;
	}

	explicit constexpr fixed_string(std::nullptr_t) noexcept: super{} { }

	consteval fixed_string(const CharT (&in)[N + 1]) noexcept: super{from_string_literal(in)} { }

	using super::data;
	using super::size;

	constexpr operator std::span<const CharT, N>() const noexcept {
		return std::span<const CharT, N>(data(), size());
	}

	constexpr operator std::span<const CharT>() const noexcept {
		return std::span<const CharT>(data(), size());
	}

	constexpr operator std::basic_string_view<CharT>() const noexcept {
		return std::basic_string_view<CharT>(data(), size());
	}

	constexpr friend bool operator==(const fixed_string &, const fixed_string &) noexcept = default;
	constexpr friend bool operator==(const fixed_string & lhs, std::basic_string_view<CharT> rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == rhs;
	}
	constexpr friend bool operator==(const fixed_string & lhs, const CharT * rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == std::basic_string_view<CharT>{rhs};
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N - 1>;

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_BASE_HPP
#define CTHASH_ENCODING_BASE_HPP

#ifndef CTHASH_ENCODING_CHUNK_OF_BITS_HPP
#define CTHASH_ENCODING_CHUNK_OF_BITS_HPP

#ifndef CTHASH_ENCODING_BIT_BUFFER_HPP
#define CTHASH_ENCODING_BIT_BUFFER_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <bit>
#include <iostream>
#include <numeric>
#include <ranges>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct select_bit_integer;

template <size_t Bits> requires(Bits <= 8) struct select_bit_integer<Bits> {
	using type = uint8_t;
};

template <size_t Bits> requires(Bits > 8 && Bits <= 16) struct select_bit_integer<Bits> {
	using type = uint16_t;
};

template <size_t Bits> requires(Bits > 16 && Bits <= 32) struct select_bit_integer<Bits> {
	using type = uint32_t;
};

template <size_t Bits> requires(Bits > 32 && Bits <= 64) struct select_bit_integer<Bits> {
	using type = uint64_t;
};

template <size_t Bits> using select_bit_integer_t = select_bit_integer<Bits>::type;

template <size_t V> requires(std::popcount(V) == 1u) constexpr auto log2_of_power_of_2 = static_cast<size_t>(std::countr_zero(V));

template <size_t Bits> constexpr auto mask = static_cast<select_bit_integer_t<Bits>>((static_cast<select_bit_integer_t<Bits>>(1u) << Bits) - 1u);

template <size_t Capacity> class basic_bit_buffer {
public:
	static constexpr auto capacity = std::integral_constant<size_t, Capacity>{};
	using storage_type = select_bit_integer_t<capacity()>;
	using size_type = select_bit_integer_t<log2_of_power_of_2<std::bit_ceil(capacity())>>;

public:
	storage_type buffer{0};
	size_type bits_available{0};

public:
	template <size_t Bits> static constexpr auto mask = static_cast<storage_type>((static_cast<storage_type>(1u) << Bits) - 1u);

	constexpr friend bool operator==(const basic_bit_buffer & lhs, const basic_bit_buffer & rhs) noexcept = default;

	constexpr size_type size() const noexcept {
		return bits_available;
	}

	constexpr size_type unused_size() const noexcept {
		return capacity() - bits_available;
	}

	constexpr bool empty() const noexcept {
		return bits_available == 0u;
	}

	constexpr bool full() const noexcept {
		return bits_available == capacity();
	}

	template <size_t Bits> constexpr void push(select_bit_integer_t<Bits> in) noexcept requires(Bits <= capacity()) {
		assert(size() <= capacity() - Bits);
		buffer = static_cast<storage_type>(buffer << Bits) | static_cast<storage_type>(in);
		bits_available += static_cast<size_type>(Bits);
	}
	constexpr void push_empty_bits(size_t count) noexcept {
		buffer = static_cast<storage_type>(buffer << count);
		bits_available += static_cast<unsigned char>(count);
	}

	template <size_t Bits> constexpr void pop() noexcept requires(Bits <= capacity()) {
		assert(size() >= Bits);
		bits_available -= static_cast<size_type>(Bits);
	}

	template <size_t Bits> constexpr auto front() const noexcept -> select_bit_integer_t<Bits> requires(Bits <= capacity()) {
		using output_type = select_bit_integer_t<Bits>;
		assert(size() >= static_cast<size_type>(Bits));
		return static_cast<output_type>((buffer >> (bits_available - Bits))) & mask<Bits>;
	}
};

constexpr size_t calculate_padding_bit_count(size_t number_of_bits_in_buffer, size_t output_size, size_t input_size) {
	size_t n = number_of_bits_in_buffer;
	size_t padding_bits = 0u;

	while (n != 0u) {
		padding_bits += input_size;
		n += input_size;

		while (n >= output_size) {
			n = n - output_size;
		}
	}

	return padding_bits;
}

template <size_t OutBits, size_t InBits = 8u> class bit_buffer: protected basic_bit_buffer<std::lcm(OutBits, InBits)> {
	using super = basic_bit_buffer<std::lcm(OutBits, InBits)>;

public:
	constexpr bit_buffer() noexcept = default;

	using typename super::size_type;
	static constexpr auto out_bits = std::integral_constant<size_type, OutBits>{};
	static constexpr auto in_bits = std::integral_constant<size_type, InBits>{};

	using out_type = select_bit_integer_t<OutBits>;
	using in_type = select_bit_integer_t<InBits>;

	using super::capacity;
	static constexpr auto in_capacity = std::integral_constant<size_type, (capacity() / in_bits())>{};
	static constexpr auto out_capacity = std::integral_constant<size_type, (capacity() / out_bits())>{};

	static constexpr auto aligned = std::bool_constant<capacity() == in_capacity()>{};

	constexpr void push(in_type in) noexcept {
		super::template push<in_bits>(in);
	}

	constexpr void push_empty() noexcept {
		this->push(in_type{0u});
	}

	constexpr size_type push_zeros_to_align() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_to_align() noexcept requires(!aligned()) {
		if (empty()) {
			return 0u;
		}

		assert(out_bits > super::size());
		const size_type missing_bits = static_cast<size_type>(out_bits - super::size());
		super::push_empty_bits(missing_bits);
		return missing_bits;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(!aligned()) {
		const size_type usable_bits = super::size();
		const size_type missing_bits = static_cast<size_type>(calculate_padding_bit_count(super::size(), out_bits, in_bits));
		super::push_empty_bits(missing_bits);
		return usable_bits;
	}

	constexpr void pop() noexcept {
		super::template pop<out_bits>();
	}

	constexpr auto front() const noexcept -> out_type {
		return super::template front<out_bits>();
	}

	constexpr size_type size() const noexcept {
		return static_cast<size_type>(super::size() / out_bits);
	}

	constexpr size_type unused_size() const noexcept {
		return static_cast<size_type>(super::unused_size() / in_bits);
	}

	using super::empty;
	using super::full;

	constexpr bool has_bits_for_pop() const noexcept {
		return super::size() >= out_bits;
	}

	constexpr bool has_capacity_for_push() const noexcept {
		return super::size() <= (capacity() - in_bits);
	}
};

} // namespace cthash

#endif

#include <iostream>
#include <ranges>

namespace cthash {

template <typename Buffer> struct buffer_result_type;

template <typename Buffer> requires(Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	static constexpr Buffer::size_type missing_bits = {0u};

	constexpr bool is_padding() const noexcept {
		return false;
	}
};

template <typename Buffer> requires(!Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	typename Buffer::size_type missing_bits;

	constexpr bool is_padding() const noexcept {
		return missing_bits == Buffer::out_bits;
	}
};

template <typename Buffer, bool AllowPadding> struct buffer_with_missing_bits;

template <typename Buffer, bool AllowPadding> requires(Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};

	struct result_type {
		typename Buffer::out_type value;
		static constexpr Buffer::size_type missing_bits = {0u};

		constexpr bool is_padding() const noexcept {
			return false;
		}
	};

	static constexpr bool aligned = Buffer::aligned();

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		return result_type{buffer.front()};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		while (!buffer.has_bits_for_pop() && (it != end)) {
			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <typename Buffer, bool AllowPadding> requires(!Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};
	Buffer::size_type missing_bits{0};

	static constexpr bool aligned = Buffer::aligned();

	struct result_type {
		typename Buffer::out_type value;
		typename Buffer::size_type missing_bits;

		constexpr bool is_padding() const noexcept {
			return missing_bits == Buffer::out_bits;
		}
	};

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		assert(Buffer::out_bits >= missing_bits);
		return result_type{buffer.front(), missing_bits};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	constexpr void pad_buffer() noexcept requires(AllowPadding) {
		// full multi-chunk padding (for baseN encodings)
		missing_bits = (Buffer::out_bits - buffer.push_zeros_for_padding());
	}

	constexpr void pad_buffer() noexcept requires(!AllowPadding) {
		// only add enough zero to finish current output chunk
		missing_bits = buffer.push_zeros_to_align();
	}

	constexpr void saturate_missing_bits() noexcept requires(AllowPadding) {
		if (missing_bits) {
			missing_bits = Buffer::out_bits;
		}
		// missing_bits = static_cast<buffer_size_t>((unsigned)(bool)missing_bits * output_value_bit_size);
	}

	constexpr void saturate_missing_bits() noexcept requires(!AllowPadding) {
		// do nothing :)
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		for (;;) {
			if (it == end) {
				if (buffer.has_bits_for_pop()) {
					// if this is second pass after padding we can mark all bits as missing
					saturate_missing_bits();
				} else {
					// fill remainder of buffer with zeros
					pad_buffer();
				}

				return;
			}

			if (buffer.has_bits_for_pop()) {
				return;
			}

			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <bool Value> struct conditional;

template <> struct conditional<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional<false> {
	template <typename, typename T> using type = T;
};

template <bool Const, typename T> using maybe_const = typename conditional<Const>::template type<const T, T>;

template <typename T> concept integral_like = std::integral<T> || std::same_as<std::byte, T>;

template <size_t Bits, bool AllowPadding, std::ranges::input_range Input> requires integral_like<std::ranges::range_value_t<Input>> struct chunk_of_bits_view {
	using input_value_type = std::ranges::range_value_t<Input>;

	static constexpr size_t output_value_bit_size = Bits;
	static constexpr size_t input_value_bit_size = sizeof(input_value_type) * 8u;
	using buffer_t = cthash::bit_buffer<output_value_bit_size, input_value_bit_size>;
	using buffer_size_t = buffer_t::size_type;
	Input input;

	static constexpr bool aligned = buffer_t::aligned;

	struct sentinel { };

	template <bool Const> struct iterator {
		using parent = maybe_const<Const, Input>;
		using storage_type = buffer_with_missing_bits<buffer_t, AllowPadding>;
		using value_type = storage_type::result_type;
		using difference_type = intptr_t;

		std::ranges::iterator_t<parent> it;
		[[no_unique_address]] std::ranges::sentinel_t<parent> end;

		storage_type buffer{};

		constexpr iterator(parent & p) noexcept: it{std::ranges::begin(p)}, end{std::ranges::end(p)} {
			// initialize
			buffer.feed_buffer(it, end);
		}

		iterator(const iterator &) = default;
		iterator(iterator &&) = default;

		iterator & operator=(const iterator &) = default;
		iterator & operator=(iterator &&) = default;

		constexpr iterator & operator++() noexcept {
			buffer.pop();
			buffer.feed_buffer(it, end);
			return *this;
		}

		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			this->operator++();
			return copy;
		}

		constexpr auto operator*() const noexcept {
			return buffer.front();
		}

		constexpr friend bool operator==(const iterator & lhs, const iterator & rhs) noexcept = default;

		constexpr friend bool operator==(const iterator & self, sentinel) noexcept {
			return self.buffer.empty();
		}
	};

	static_assert(std::input_iterator<iterator<true>>);
	static_assert(std::input_iterator<iterator<false>>);
	static_assert(std::sentinel_for<sentinel, iterator<true>>);
	static_assert(std::sentinel_for<sentinel, iterator<false>>);

	constexpr chunk_of_bits_view(Input _input) noexcept: input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input};
	}

	constexpr auto end() const noexcept {
		return sentinel{};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && AllowPadding) {
		// calculate with blocks
		return ((std::ranges::size(input) + (buffer_t::in_capacity() - 1u)) / buffer_t::in_capacity()) * buffer_t::out_capacity();
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && !AllowPadding) {
		// calculate with bits
		const size_t bit_size_of_input = std::ranges::size(input) * input_value_bit_size;
		return (bit_size_of_input + (output_value_bit_size - 1u)) / output_value_bit_size;
	}
};

template <size_t Bits, bool AllowPadding> struct chunk_of_bits_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, chunk_of_bits_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) {
		return chunk_of_bits_view<Bits, AllowPadding, R>(std::forward<R>(input));
	}
};

template <size_t Bits, bool AllowPadding = false> constexpr auto chunk_of_bits = chunk_of_bits_action<Bits, AllowPadding>{};

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#include <bit>

namespace cthash {

template <typename Encoding> struct encoding_properties {
	static constexpr size_t size = std::size(Encoding::alphabet) - 1u;
	static_assert(std::popcount(size) == 1u, "Size of encoding's alphabet must be power-of-two");

	static constexpr size_t bits = std::countr_zero(size);

	static constexpr bool has_padding = padded_encoding<Encoding>;

	static constexpr char padding = [] {
		if constexpr (has_padding) {
			return Encoding::padding;
		} else {
			return '\0';
		}
	}();
};

template <typename Encoding, typename CharT, typename R> struct encode_to_view {
	using properties = encoding_properties<Encoding>;
	using chunk_view = cthash::chunk_of_bits_view<properties::bits, properties::has_padding, R>;

	struct sentinel {
		[[no_unique_address]] chunk_view::sentinel end;
	};

	template <bool Const> struct iterator {
		using difference_type = intptr_t;
		using value_type = CharT;

		chunk_view::template iterator<Const> it;

		constexpr iterator & operator++() noexcept {
			++it;
			return *this;
		}
		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			++it;
			return copy;
		}

		constexpr value_type operator*() const noexcept {
			const auto tmp = *it;
			if constexpr (!chunk_view::aligned) {
				// TODO: do without condition
				if (tmp.is_padding()) {
					return properties::padding;
				}
			}
			return static_cast<value_type>(Encoding::alphabet[static_cast<unsigned>(tmp.value)]);
		}

		constexpr friend bool operator==(const iterator &, const iterator &) noexcept = default;

		constexpr friend bool operator==(const iterator & lhs, const sentinel & rhs) noexcept {
			return lhs.it == rhs.end;
		}
	};

	chunk_view input;

	constexpr encode_to_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}

	constexpr auto to_string() const requires(std::ranges::sized_range<R>) {
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(*this);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(size());
		auto [i, o] = std::ranges::copy(begin(), end(), result.begin());
		assert(i == result.end());
		assert(o == result.end());
		return result;
#endif
	}

	constexpr friend std::basic_ostream<CharT> & operator<<(std::basic_ostream<CharT> & out, encode_to_view in) {
		std::ranges::copy(in.begin(), in.end(), std::ostream_iterator<CharT, CharT>(out));
		return out;
	}
};

template <typename Encoding, typename ValueT, typename R> struct decode_from_view {
	R input;

	template <bool Const> struct iterator { };
	struct sentinel { };

	constexpr decode_from_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}
};

template <typename Encoding, typename CharT = char> struct encode_to_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, encode_to_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return encode_to_view<Encoding, CharT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename ValueT = unsigned char> struct decode_from_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, decode_from_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return decode_from_view<Encoding, ValueT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename CharT = char> constexpr auto encode_to = encode_to_action<Encoding, CharT>{};
template <typename Encoding, typename ValueT = unsigned char> constexpr auto decode_from = decode_from_action<Encoding, ValueT>{};

constexpr auto binary_encode = encode_to<encoding::base2, char>;
constexpr auto base2_encode = encode_to<encoding::base2, char>;
constexpr auto base4_encode = encode_to<encoding::base4, char>;
constexpr auto base8_encode = encode_to<encoding::base8, char>;
constexpr auto octal_encode = encode_to<encoding::base8, char>;
constexpr auto hexdec_encode = encode_to<encoding::base16, char>;
constexpr auto hexdec_uppercase_encode = encode_to<encoding::base16_uppercase, char>;
constexpr auto base16_encode = encode_to<encoding::base16, char>;
constexpr auto base32_encode = encode_to<encoding::base32, char>;
constexpr auto base32_no_padding_encode = encode_to<encoding::base32_no_padding, char>;
constexpr auto z_base32_encode = encode_to<encoding::z_base32, char>;
constexpr auto base64_encode = encode_to<encoding::base64, char>;
constexpr auto base64url_encode = encode_to<encoding::base64url, char>;
constexpr auto base64_no_padding_encode = encode_to<encoding::base64_no_padding, char>;

constexpr auto binary_decode = decode_from<encoding::base2, char>;
constexpr auto base2_decode = decode_from<encoding::base2, char>;
constexpr auto base4_decode = decode_from<encoding::base4, char>;
constexpr auto base8_decode = decode_from<encoding::base8, char>;
constexpr auto hexdec_decode = decode_from<encoding::base16, char>;
constexpr auto base16_decode = decode_from<encoding::base16, char>;
constexpr auto base32_decode = decode_from<encoding::base32, char>;
constexpr auto z_base32_decode = decode_from<encoding::z_base32, char>;
constexpr auto base64_decode = decode_from<encoding::base64, char>;
constexpr auto base64url_decode = decode_from<encoding::base64url, char>;
constexpr auto base64_no_padding_decode = decode_from<encoding::base64_no_padding, char>;

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

// template <typename Encoding, typename CharT, typename R> struct encode_to_view

#ifdef CTHASH_STDFMT_AVAILABLE
template <typename Encoding, typename R, typename CharT>
struct formatter<cthash::encode_to_view<Encoding, CharT, R>, CharT> {
	using subject_type = cthash::encode_to_view<Encoding, CharT, R>;

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		return std::ranges::begin(ctx);
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return std::ranges::copy(value, ctx.out()).out;
	}
};

#endif

} // namespace std

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_ALGORITHM_HPP
#define CTHASH_INTERNAL_ALGORITHM_HPP

#include <numeric>
#include <compare>
#include <cstddef>
#include <cstdint>

namespace cthash::internal {

template <typename It1, typename It2> constexpr auto threeway_compare_of_same_size(It1 lhs, It2 rhs, size_t length) -> std::strong_ordering {
	for (size_t i = 0; i != length; ++i) {
		if (const auto r = (*lhs++ <=> *rhs++); std::is_neq(r)) {
			return r;
		}
	}

	return std::strong_ordering::equal;
}

template <typename T, typename It1, typename It2, typename Stream> constexpr auto & push_to_stream_as(It1 f, It2 l, Stream & stream) {
	constexpr auto cast_and_shift = [](Stream * s, const auto & rhs) { (*s) << T{rhs}; return s; };
	return *std::accumulate(f, l, &stream, cast_and_shift);
}

} // namespace cthash::internal

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_HEXDEC_HPP
#define CTHASH_INTERNAL_HEXDEC_HPP

#include <array>
#include <ostream>
#include <span>
#include <type_traits>
#include <cstdint>

namespace cthash::internal {

consteval auto get_hexdec_table() noexcept {
	std::array<uint8_t, 128> result;

	auto char_to_hexdec = [](char c) {
		if (c >= '0' && c <= '9') {
			return static_cast<uint8_t>(c - '0');
		} else if (c >= 'a' && c <= 'f') {
			return static_cast<uint8_t>(c - 'a' + 10);
		} else if (c >= 'A' && c <= 'F') {
			return static_cast<uint8_t>(c - 'A' + 10);
		} else {
			return static_cast<uint8_t>(0);
		}
	};

	for (size_t i = 0; i != result.size(); ++i) {
		result[i] = char_to_hexdec(static_cast<char>(i));
	}

	return result;
}

constexpr auto hexdec_to_value_alphabet = get_hexdec_table();

template <typename CharT> constexpr auto value_to_hexdec_alphabet = std::array<CharT, 16>{CharT('0'), CharT('1'), CharT('2'), CharT('3'), CharT('4'), CharT('5'), CharT('6'), CharT('7'), CharT('8'), CharT('9'), CharT('a'), CharT('b'), CharT('c'), CharT('d'), CharT('e'), CharT('f')};

struct byte_hexdec_value {
	std::byte val;

	template <typename CharT, typename Traits> friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, byte_hexdec_value rhs) {
		return os << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val >> 4u)] << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val) & 0b1111u];
	}
};

template <size_t N, typename CharT> constexpr auto hexdec_to_binary(std::span<const CharT, N * 2> in) -> std::array<std::byte, N> {
	return [in]<size_t... Idx>(std::index_sequence<Idx...>) {
		return std::array<std::byte, N>{static_cast<std::byte>(hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2]) & 0b0111'1111u] << 4u | hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2u + 1u]) & 0b0111'1111u])...};
	}(std::make_index_sequence<N>());
}

template <typename CharT, size_t N>
requires((N - 1) % 2 == 0) // -1 because of zero terminator in literals
constexpr auto literal_hexdec_to_binary(const CharT (&in)[N]) -> std::array<std::byte, (N - 1) / 2> {
	return hexdec_to_binary<N / 2>(std::span<const char, N - 1>(in, N - 1));
}

} // namespace cthash::internal

#endif

#include <algorithm>
#include <array>
#include <format>
#include <span>
#include <string_view>
#include <compare>

namespace cthash {

// hash_value

template <size_t N> struct hash_value: std::array<std::byte, N> {
	using super = std::array<std::byte, N>;

	constexpr hash_value() noexcept: super{} { }
	explicit constexpr hash_value(super && s) noexcept: super(s) { }
	template <typename CharT> explicit constexpr hash_value(const CharT (&in)[N * 2u + 1u]) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in, N * 2u))} { }
	template <typename CharT> explicit constexpr hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in.data(), in.size()))} { }

	// comparison support
	constexpr friend bool operator==(const hash_value & lhs, const hash_value & rhs) noexcept = default;
	constexpr friend auto operator<=>(const hash_value & lhs, const hash_value & rhs) noexcept -> std::strong_ordering {
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), N);
	}

	template <typename Encoding = cthash::encoding::hexdec, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		auto hexdec_view = *this | cthash::encode_to<Encoding, CharT>;
		std::ranges::copy(hexdec_view, std::ostream_iterator<CharT, CharT>(os));
		return os;
	}

	// print to ostream support
	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const hash_value & val) {
		return val.print_into(os);
	}

	template <size_t PrefixN> constexpr auto prefix() const noexcept requires(PrefixN <= N) {
		hash_value<PrefixN> output{};
		std::ranges::copy(this->begin(), this->begin() + PrefixN, output.begin());
		return output;
	}

	template <size_t SuffixN> constexpr auto suffix() const noexcept requires(SuffixN <= N) {
		hash_value<SuffixN> output{};
		std::ranges::copy(this->end() - SuffixN, this->end(), output.begin());
		return output;
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(encoded);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(encoded.size());
		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());
		return result;
#endif
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_fixed_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
		// it's type dependendent so we can calculate the size...
		constexpr size_t size_needed = (hash_value{} | cthash::encode_to<Encoding, CharT>).size();

		auto result = cthash::fixed_string<CharT, size_needed>{nullptr};

		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());

		return result;
	}
};

template <typename CharT, size_t N> hash_value(const CharT (&)[N]) -> hash_value<(N - 1u) / 2u>;
template <typename CharT, size_t N> hash_value(std::span<const CharT, N>) -> hash_value<N / 2u>;
template <typename CharT, size_t N> hash_value(const fixed_string<CharT, N> &) -> hash_value<N / 2u>;

template <typename> struct default_encoding {
	using encoding = cthash::encoding::hexdec;
};

template <typename Tag> concept tag_with_encoding = requires() {
	typename Tag::encoding;
};

template <tag_with_encoding Tag> struct default_encoding<Tag> {
	using encoding = Tag::encoding;
};

template <typename Tag, size_t = internal::digest_bytes_length_of<Tag>> struct tagged_hash_value: hash_value<internal::digest_bytes_length_of<Tag>> {
	static constexpr size_t N = internal::digest_bytes_length_of<Tag>;

	using super = hash_value<N>;
	using super::super;
	template <typename CharT> explicit constexpr tagged_hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{in} { }

	static constexpr size_t digest_length = N;

	template <typename Encoding = default_encoding<Tag>::encoding, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		return super::template print_into<Encoding>(os);
	}

	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const tagged_hash_value & val) {
		return val.print_into(os);
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_string(const tagged_hash_value & value) {
		return to_string<Encoding, CharT>(static_cast<const super &>(value));
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_fixed_string(const tagged_hash_value & value) {
		return to_fixed_string<Encoding, CharT>(static_cast<const super &>(value));
	}
};

template <typename T> concept variable_digest_length = T::digest_length_bit == 0u;

template <size_t N, variable_digest_length Tag> struct variable_bit_length_tag: Tag {
	static constexpr size_t digest_length_bit = N;
};

template <typename T> concept convertible_to_tagged_hash_value = requires(const T & obj) {
	{ tagged_hash_value{obj} };
};

namespace literals {

	template <fixed_string Value>
	constexpr auto operator""_hash() {
		return hash_value(Value);
	}

} // namespace literals

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#if _LIBCPP_VERSION >= 170000
// libc++ will define __cpp_lib_format macro in 19.0
// https://github.com/llvm/llvm-project/issues/77773
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#ifdef CTHASH_STDFMT_AVAILABLE
template <size_t N, typename CharT>
struct formatter<cthash::hash_value<N>, CharT> {
	using subject_type = cthash::hash_value<N>;
	using default_encoding = cthash::encoding::hexdec;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <typename Tag, size_t N, typename CharT>
struct formatter<cthash::tagged_hash_value<Tag, N>, CharT> {
	using subject_type = cthash::tagged_hash_value<Tag, N>;
	using default_encoding = typename cthash::default_encoding<Tag>::encoding;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <cthash::convertible_to_tagged_hash_value Type, typename CharT> struct formatter<Type, CharT>: formatter<decltype(cthash::tagged_hash_value{std::declval<Type>()}), CharT> {
};

#endif

} // namespace std

#endif

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_CONVERT_HPP
#define CTHASH_INTERNAL_CONVERT_HPP

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#include <span>
#include <type_traits>
#include <cstddef>
#include <cstdint>
#include <cstring>

namespace cthash {

template <typename It1, typename It2, typename It3> constexpr auto byte_copy(It1 first, It2 last, It3 destination) {
	return std::transform(first, last, destination, [](byte_like auto v) { return static_cast<std::byte>(v); });
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << ((sizeof(T) - 1u - Idx) * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::little) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_le_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << static_cast<T>(Idx * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::big) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T> struct unwrap_littleendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> (Idx * 8u))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_littleendian_number(std::span<std::byte, 8>) -> unwrap_littleendian_number<uint64_t>;
unwrap_littleendian_number(std::span<std::byte, 4>) -> unwrap_littleendian_number<uint32_t>;

template <std::unsigned_integral T> struct unwrap_bigendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> ((bits - 8u) - 8u * Idx))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_bigendian_number(std::span<std::byte, 8>) -> unwrap_bigendian_number<uint64_t>;
unwrap_bigendian_number(std::span<std::byte, 4>) -> unwrap_bigendian_number<uint32_t>;

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#include <algorithm>
#include <array>
#include <span>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <typename Config> struct internal_hasher {
	static constexpr auto config = Config{};
	static constexpr size_t block_size_bytes = config.block_bits / 8u;
	static constexpr size_t digest_bytes = internal::digest_bytes_length_of<Config>;

	// internal types
	using state_value_t = std::remove_cvref_t<decltype(Config::initial_values)>;
	using state_item_t = typename state_value_t::value_type;

	using block_value_t = std::array<std::byte, block_size_bytes>;
	using block_view_t = std::span<const std::byte, block_size_bytes>;

	using staging_item_t = typename decltype(config.constants)::value_type;
	static constexpr size_t staging_size = config.constants.size();
	using staging_value_t = std::array<staging_item_t, staging_size>;
	using staging_view_t = std::span<const staging_item_t, staging_size>;

	using digest_span_t = std::span<std::byte, digest_bytes>;
	using result_t = cthash::tagged_hash_value<Config>;
	using length_t = typename Config::length_type;

	// internal state
	state_value_t hash;
	length_t total_length;

	block_value_t block;
	unsigned block_used;

	// constructors
	constexpr internal_hasher() noexcept: hash{config.initial_values}, total_length{0u}, block_used{0u} { }
	constexpr internal_hasher(const internal_hasher &) noexcept = default;
	constexpr internal_hasher(internal_hasher &&) noexcept = default;
	constexpr ~internal_hasher() noexcept = default;

	// take buffer and build staging
	template <byte_like Byte> [[gnu::always_inline]] static constexpr auto build_staging(std::span<const Byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		staging_value_t w;

		constexpr auto first_part_size = block_size_bytes / sizeof(staging_item_t);

		// fill first part with chunk
		for (int i = 0; i != int(first_part_size); ++i) {
			w[static_cast<size_t>(i)] = cast_from_bytes<staging_item_t>(chunk.subspan(static_cast<size_t>(i) * sizeof(staging_item_t)).template first<sizeof(staging_item_t)>());
		}

		// fill the rest (generify)
		for (int i = int(first_part_size); i != int(staging_size); ++i) {
			w[static_cast<size_t>(i)] = w[static_cast<size_t>(i - 16)] + config.sigma_0(w[static_cast<size_t>(i - 15)]) + w[static_cast<size_t>(i - 7)] + config.sigma_1(w[static_cast<size_t>(i - 2)]);
		}

		return w;
	}

	[[gnu::always_inline]] static constexpr auto build_staging(std::span<const std::byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		return build_staging<std::byte>(chunk);
	}

	[[gnu::always_inline]] static constexpr void rounds(staging_view_t w, state_value_t & state) noexcept {
		config.rounds(w, state);
	}

	// this implementation works only with input size aligned to bytes (not bits)
	template <byte_like T> [[gnu::always_inline]] constexpr void update_to_buffer_and_process(std::span<const T> in) noexcept {
		// if block is not used, we can build staging directly
		if (block_used) {
			const auto remaining_free_space = std::span<std::byte, block_size_bytes>(block).subspan(block_used);
			const auto to_copy = in.first(std::min(in.size(), remaining_free_space.size()));

			const auto it = byte_copy(to_copy.begin(), to_copy.end(), remaining_free_space.begin());
			total_length += to_copy.size();

			// we didn't fill the block
			if (it != remaining_free_space.end()) {
				assert(to_copy.size() == in.size());
				block_used += static_cast<unsigned>(to_copy.size());
				return;
			} else {
				block_used = 0u;
			}

			// we have block!
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// remove part we processed
			in = in.subspan(to_copy.size());
		}

		// do the work over blocks without copy
		if (not block_used) {
			while (in.size() >= block_size_bytes) {
				const auto local_block = in.template first<block_size_bytes>();
				total_length += block_size_bytes;

				const staging_value_t w = build_staging<T>(local_block);
				rounds(w, hash);

				// remove part we processed
				in = in.subspan(block_size_bytes);
			}
		}

		// remainder is put onto temporary block
		if (not in.empty()) {
			assert(block_used == 0u);
			assert(in.size() < block_size_bytes);

			// copy it to block and let it stay there
			byte_copy(in.begin(), in.end(), block.begin());
			block_used = static_cast<unsigned>(in.size());
			total_length += block_used;
		}
	}

	[[gnu::always_inline]] static constexpr bool finalize_buffer(block_value_t & block, size_t block_used) noexcept {
		assert(block_used < block.size());
		const auto free_space = std::span(block).subspan(block_used);

		auto it = free_space.data();
		*it++ = std::byte{0b1000'0000u};							   // first byte after data contains bit at MSB
		std::fill(it, (block.data() + block.size()), std::byte{0x0u}); // rest is filled with zeros

		// we don't have enough space to write length bits
		return free_space.size() < (1u + (config.length_size_bits / 8u));
	}

	[[gnu::always_inline]] static constexpr void finalize_buffer_by_writing_length(block_value_t & block, length_t total_length) noexcept {
		unwrap_bigendian_number{std::span(block).template last<sizeof(length_t)>()} = (total_length * 8u);
	}

	[[gnu::always_inline]] constexpr void finalize() noexcept {
		if (finalize_buffer(block, block_used)) {
			// we didn't have enough space, we need to process block
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// zero it out
			std::fill(block.begin(), block.end(), std::byte{0x0u});
		}

		// we either have space to write or we have zerod out block
		finalize_buffer_by_writing_length(block, total_length);

		// calculate last round
		const staging_value_t w = build_staging(block);
		rounds(w, hash);
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) == 0u)
	{
		// copy result to byte result
		constexpr size_t values_for_output = digest_bytes / sizeof(state_item_t);
		static_assert(values_for_output <= config.initial_values.size());

		for (int i = 0; i != values_for_output; ++i) {
			unwrap_bigendian_number<state_item_t>{out.subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) != 0u)
	{
		// this is only used when digest doesn't align with output buffer

		// make sure digest size is smaller than hash state
		static_assert(digest_bytes <= config.initial_values.size() * sizeof(state_item_t));

		// copy result to byte result
		std::array<std::byte, sizeof(state_item_t) * config.initial_values.size()> tmp_buffer;

		for (int i = 0; i != (int)config.initial_values.size(); ++i) {
			unwrap_bigendian_number<state_item_t>{std::span(tmp_buffer).subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}

		std::copy_n(tmp_buffer.data(), digest_bytes, out.data());
	}
};

// this is a convinience type for nicer UX...
template <typename Config> struct hasher: private internal_hasher<Config> {
	using super = internal_hasher<Config>;
	using result_t = typename super::result_t;
	using length_t = typename super::length_t;
	using digest_span_t = typename super::digest_span_t;

	constexpr hasher() noexcept: super() { }
	constexpr hasher(const hasher &) noexcept = default;
	constexpr hasher(hasher &&) noexcept = default;
	constexpr ~hasher() noexcept = default;

	// support for various input types
	constexpr hasher & update(std::span<const std::byte> input) noexcept {
		super::update_to_buffer_and_process(input);
		return *this;
	}

	template <convertible_to_byte_span T> constexpr hasher & update(const T & something) noexcept {
		using value_type = typename decltype(std::span(something))::value_type;
		super::update_to_buffer_and_process(std::span<const value_type>(something));
		return *this;
	}

	template <one_byte_char CharT> constexpr hasher & update(std::basic_string_view<CharT> in) noexcept {
		super::update_to_buffer_and_process(std::span(in.data(), in.size()));
		return *this;
	}

	template <string_literal T> constexpr hasher & update(const T & lit) noexcept {
		super::update_to_buffer_and_process(std::span(lit, std::size(lit) - 1u));
		return *this;
	}

	// TODO: any range with value convertible to byte

	// output (by reference or by value)
	constexpr void final(digest_span_t digest) noexcept {
		super::finalize();
		super::write_result_into(digest);
	}

	constexpr auto final() noexcept {
		result_t output;
		this->final(output);
		return output;
	}

	constexpr length_t size() const noexcept {
		return super::total_length;
	}
};

} // namespace cthash

#endif

#include <array>
#include <span>
#include <concepts>
#include <cstdint>

namespace cthash::sha2 {

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto choice(T e, T f, T g) noexcept -> T {
	return (e bitand f) xor (~e bitand g);
}

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto majority(T a, T b, T c) noexcept -> T {
	return (a bitand b) xor (a bitand c) xor (b bitand c);
}

template <typename Config, typename StageT, size_t StageLength, typename StateT, size_t StateLength>
[[gnu::always_inline]] constexpr void rounds(std::span<const StageT, StageLength> w, std::array<StateT, StateLength> & state) noexcept {
	using state_t = std::array<StateT, StateLength>;

	// create copy of internal state
	auto wvar = state_t(state);

	// just give them names
	auto & [a, b, c, d, e, f, g, h] = wvar;

	// number of rounds is same as constants
	static_assert(StageLength == Config::constants.size());

	for (int i = 0; i != Config::constants.size(); ++i) {
		const auto temp1 = h + Config::sum_e(e) + choice(e, f, g) + Config::constants[static_cast<size_t>(i)] + w[static_cast<size_t>(i)];
		const auto temp2 = Config::sum_a(a) + majority(a, b, c);

		// move around (that's rotate)
		std::rotate(wvar.begin(), wvar.begin() + 7u, wvar.end());

		e += temp1;
		a = temp1 + temp2;

		// originally it was:
		// h = g;
		// g = f;
		// f = e;
		// e = d + temp1;
		// d = c;
		// c = b;
		// b = a;
		// a = temp1 + temp2;
	}

	// add store back
	for (int i = 0; i != (int)state.size(); ++i) {
		state[static_cast<size_t>(i)] += wvar[static_cast<size_t>(i)];
	}
}

} // namespace cthash::sha2

#endif

namespace cthash {

struct sha256_config {
	using length_type = uint64_t;
	static constexpr size_t length_size_bits = 64;

	static constexpr size_t block_bits = 512u;

	static constexpr auto initial_values = std::array<uint32_t, 8>{0x6a09e667ul, 0xbb67ae85ul, 0x3c6ef372ul, 0xa54ff53aul, 0x510e527ful, 0x9b05688cul, 0x1f83d9abul, 0x5be0cd19ul};

	// staging sigmas
	[[gnu::always_inline]] static constexpr auto sigma_0(uint32_t w_15) noexcept -> uint32_t {
		return std::rotr(w_15, 7u) xor std::rotr(w_15, 18u) xor (w_15 >> 3u);
	}

	[[gnu::always_inline]] static constexpr auto sigma_1(uint32_t w_2) noexcept -> uint32_t {
		return std::rotr(w_2, 17u) xor std::rotr(w_2, 19u) xor (w_2 >> 10u);
	}

	// rounds constants...
	static constexpr auto constants = std::array<uint32_t, 64>{
		0x428a2f98ul, 0x71374491ul, 0xb5c0fbcful, 0xe9b5dba5ul, 0x3956c25bul, 0x59f111f1ul, 0x923f82a4ul, 0xab1c5ed5ul,
		0xd807aa98ul, 0x12835b01ul, 0x243185beul, 0x550c7dc3ul, 0x72be5d74ul, 0x80deb1feul, 0x9bdc06a7ul, 0xc19bf174ul,
		0xe49b69c1ul, 0xefbe4786ul, 0x0fc19dc6ul, 0x240ca1ccul, 0x2de92c6ful, 0x4a7484aaul, 0x5cb0a9dcul, 0x76f988daul,
		0x983e5152ul, 0xa831c66dul, 0xb00327c8ul, 0xbf597fc7ul, 0xc6e00bf3ul, 0xd5a79147ul, 0x06ca6351ul, 0x14292967ul,
		0x27b70a85ul, 0x2e1b2138ul, 0x4d2c6dfcul, 0x53380d13ul, 0x650a7354ul, 0x766a0abbul, 0x81c2c92eul, 0x92722c85ul,
		0xa2bfe8a1ul, 0xa81a664bul, 0xc24b8b70ul, 0xc76c51a3ul, 0xd192e819ul, 0xd6990624ul, 0xf40e3585ul, 0x106aa070ul,
		0x19a4c116ul, 0x1e376c08ul, 0x2748774cul, 0x34b0bcb5ul, 0x391c0cb3ul, 0x4ed8aa4aul, 0x5b9cca4ful, 0x682e6ff3ul,
		0x748f82eeul, 0x78a5636ful, 0x84c87814ul, 0x8cc70208ul, 0x90befffaul, 0xa4506cebul, 0xbef9a3f7ul, 0xc67178f2ul};

	// rounds sums
	[[gnu::always_inline]] static constexpr auto sum_a(uint32_t a) noexcept -> uint32_t {
		return std::rotr(a, 2u) xor std::rotr(a, 13u) xor std::rotr(a, 22u);
	}

	[[gnu::always_inline]] static constexpr auto sum_e(uint32_t e) noexcept -> uint32_t {
		return std::rotr(e, 6u) xor std::rotr(e, 11u) xor std::rotr(e, 25u);
	}

	// rounds
	[[gnu::always_inline]] static constexpr void rounds(std::span<const uint32_t, 64> w, std::array<uint32_t, 8> & state) noexcept {
		return sha2::rounds<sha256_config>(w, state);
	}
};

static_assert(not cthash::internal::digest_length_provided<sha256_config>);
static_assert(cthash::internal::digest_bytes_length_of<sha256_config> == 32u);

using sha256 = hasher<sha256_config>;
using sha256_value = tagged_hash_value<sha256_config>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_sha256() {
		return sha256_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

namespace cthash {

struct sha224_config: sha256_config {
	// these are only changes against sha256 specification...

	static constexpr size_t digest_length = 28u;

	static constexpr auto initial_values = std::array<uint32_t, 8>{0xc1059ed8ul, 0x367cd507ul, 0x3070dd17ul, 0xf70e5939ul, 0xffc00b31ul, 0x68581511ul, 0x64f98fa7ul, 0xbefa4fa4ul};
};

static_assert(cthash::internal::digest_length_provided<sha224_config>);
static_assert(cthash::internal::digest_bytes_length_of<sha224_config> == 28u);

using sha224 = hasher<sha224_config>;
using sha224_value = tagged_hash_value<sha224_config>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_sha224() {
		return sha224_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

#ifndef CTHASH_SHA2_SHA256_HPP
#define CTHASH_SHA2_SHA256_HPP

#ifndef CTHASH_SHA2_COMMON_HPP
#define CTHASH_SHA2_COMMON_HPP

#ifndef CONSTEXPR_SHA2_HASHER_HPP
#define CONSTEXPR_SHA2_HASHER_HPP

#ifndef CTHASH_SIMPLE_HPP
#define CTHASH_SIMPLE_HPP

#include <utility>

namespace cthash {

template <typename Hasher, typename In, typename... Args> concept hasher_like = requires(Hasher & h, const In & in, Args &&... args) //
{
	{ Hasher{std::forward<Args>(args)...} };
	{ h.update(in) } -> std::same_as<Hasher &>;
	{ h.final() };
};

template <typename Hasher, typename In> concept direct_hasher = requires(Hasher & h, const In & in) //
{
	{ h.update_and_final(in) };
};

template <typename Hasher, typename T, typename... Args>
requires hasher_like<Hasher, T, Args...>
constexpr auto simple(const T & value, Args &&... args) noexcept {
	if constexpr (direct_hasher<Hasher, T>) {
		return Hasher{std::forward<Args>(args)...}.update_and_final(value);
	} else {
		return Hasher{std::forward<Args>(args)...}.update(value).final();
	}
}

} // namespace cthash

#endif

#ifndef CTHASH_VALUE_HPP
#define CTHASH_VALUE_HPP

#ifndef CTHASH_FIXED_STRING_HPP
#define CTHASH_FIXED_STRING_HPP

#include <algorithm>
#include <span>
#include <string_view>

namespace cthash {

template <typename CharT, size_t N> struct fixed_string: std::array<CharT, N> {
	using super = std::array<CharT, N>;

	consteval static auto from_string_literal(const CharT (&in)[N + 1]) -> std::array<CharT, N> {
		std::array<CharT, N> out;
		std::copy_n(in, N, out.data());
		return out;
	}

	explicit constexpr fixed_string(std::nullptr_t) noexcept: super{} { }

	consteval fixed_string(const CharT (&in)[N + 1]) noexcept: super{from_string_literal(in)} { }

	using super::data;
	using super::size;

	constexpr operator std::span<const CharT, N>() const noexcept {
		return std::span<const CharT, N>(data(), size());
	}

	constexpr operator std::span<const CharT>() const noexcept {
		return std::span<const CharT>(data(), size());
	}

	constexpr operator std::basic_string_view<CharT>() const noexcept {
		return std::basic_string_view<CharT>(data(), size());
	}

	constexpr friend bool operator==(const fixed_string &, const fixed_string &) noexcept = default;
	constexpr friend bool operator==(const fixed_string & lhs, std::basic_string_view<CharT> rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == rhs;
	}
	constexpr friend bool operator==(const fixed_string & lhs, const CharT * rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == std::basic_string_view<CharT>{rhs};
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N - 1>;

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_BASE_HPP
#define CTHASH_ENCODING_BASE_HPP

#ifndef CTHASH_ENCODING_CHUNK_OF_BITS_HPP
#define CTHASH_ENCODING_CHUNK_OF_BITS_HPP

#ifndef CTHASH_ENCODING_BIT_BUFFER_HPP
#define CTHASH_ENCODING_BIT_BUFFER_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <bit>
#include <iostream>
#include <numeric>
#include <ranges>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct select_bit_integer;

template <size_t Bits> requires(Bits <= 8) struct select_bit_integer<Bits> {
	using type = uint8_t;
};

template <size_t Bits> requires(Bits > 8 && Bits <= 16) struct select_bit_integer<Bits> {
	using type = uint16_t;
};

template <size_t Bits> requires(Bits > 16 && Bits <= 32) struct select_bit_integer<Bits> {
	using type = uint32_t;
};

template <size_t Bits> requires(Bits > 32 && Bits <= 64) struct select_bit_integer<Bits> {
	using type = uint64_t;
};

template <size_t Bits> using select_bit_integer_t = select_bit_integer<Bits>::type;

template <size_t V> requires(std::popcount(V) == 1u) constexpr auto log2_of_power_of_2 = static_cast<size_t>(std::countr_zero(V));

template <size_t Bits> constexpr auto mask = static_cast<select_bit_integer_t<Bits>>((static_cast<select_bit_integer_t<Bits>>(1u) << Bits) - 1u);

template <size_t Capacity> class basic_bit_buffer {
public:
	static constexpr auto capacity = std::integral_constant<size_t, Capacity>{};
	using storage_type = select_bit_integer_t<capacity()>;
	using size_type = select_bit_integer_t<log2_of_power_of_2<std::bit_ceil(capacity())>>;

public:
	storage_type buffer{0};
	size_type bits_available{0};

public:
	template <size_t Bits> static constexpr auto mask = static_cast<storage_type>((static_cast<storage_type>(1u) << Bits) - 1u);

	constexpr friend bool operator==(const basic_bit_buffer & lhs, const basic_bit_buffer & rhs) noexcept = default;

	constexpr size_type size() const noexcept {
		return bits_available;
	}

	constexpr size_type unused_size() const noexcept {
		return capacity() - bits_available;
	}

	constexpr bool empty() const noexcept {
		return bits_available == 0u;
	}

	constexpr bool full() const noexcept {
		return bits_available == capacity();
	}

	template <size_t Bits> constexpr void push(select_bit_integer_t<Bits> in) noexcept requires(Bits <= capacity()) {
		assert(size() <= capacity() - Bits);
		buffer = static_cast<storage_type>(buffer << Bits) | static_cast<storage_type>(in);
		bits_available += static_cast<size_type>(Bits);
	}
	constexpr void push_empty_bits(size_t count) noexcept {
		buffer = static_cast<storage_type>(buffer << count);
		bits_available += static_cast<unsigned char>(count);
	}

	template <size_t Bits> constexpr void pop() noexcept requires(Bits <= capacity()) {
		assert(size() >= Bits);
		bits_available -= static_cast<size_type>(Bits);
	}

	template <size_t Bits> constexpr auto front() const noexcept -> select_bit_integer_t<Bits> requires(Bits <= capacity()) {
		using output_type = select_bit_integer_t<Bits>;
		assert(size() >= static_cast<size_type>(Bits));
		return static_cast<output_type>((buffer >> (bits_available - Bits))) & mask<Bits>;
	}
};

constexpr size_t calculate_padding_bit_count(size_t number_of_bits_in_buffer, size_t output_size, size_t input_size) {
	size_t n = number_of_bits_in_buffer;
	size_t padding_bits = 0u;

	while (n != 0u) {
		padding_bits += input_size;
		n += input_size;

		while (n >= output_size) {
			n = n - output_size;
		}
	}

	return padding_bits;
}

template <size_t OutBits, size_t InBits = 8u> class bit_buffer: protected basic_bit_buffer<std::lcm(OutBits, InBits)> {
	using super = basic_bit_buffer<std::lcm(OutBits, InBits)>;

public:
	constexpr bit_buffer() noexcept = default;

	using typename super::size_type;
	static constexpr auto out_bits = std::integral_constant<size_type, OutBits>{};
	static constexpr auto in_bits = std::integral_constant<size_type, InBits>{};

	using out_type = select_bit_integer_t<OutBits>;
	using in_type = select_bit_integer_t<InBits>;

	using super::capacity;
	static constexpr auto in_capacity = std::integral_constant<size_type, (capacity() / in_bits())>{};
	static constexpr auto out_capacity = std::integral_constant<size_type, (capacity() / out_bits())>{};

	static constexpr auto aligned = std::bool_constant<capacity() == in_capacity()>{};

	constexpr void push(in_type in) noexcept {
		super::template push<in_bits>(in);
	}

	constexpr void push_empty() noexcept {
		this->push(in_type{0u});
	}

	constexpr size_type push_zeros_to_align() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_to_align() noexcept requires(!aligned()) {
		if (empty()) {
			return 0u;
		}

		assert(out_bits > super::size());
		const size_type missing_bits = static_cast<size_type>(out_bits - super::size());
		super::push_empty_bits(missing_bits);
		return missing_bits;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(!aligned()) {
		const size_type usable_bits = super::size();
		const size_type missing_bits = static_cast<size_type>(calculate_padding_bit_count(super::size(), out_bits, in_bits));
		super::push_empty_bits(missing_bits);
		return usable_bits;
	}

	constexpr void pop() noexcept {
		super::template pop<out_bits>();
	}

	constexpr auto front() const noexcept -> out_type {
		return super::template front<out_bits>();
	}

	constexpr size_type size() const noexcept {
		return static_cast<size_type>(super::size() / out_bits);
	}

	constexpr size_type unused_size() const noexcept {
		return static_cast<size_type>(super::unused_size() / in_bits);
	}

	using super::empty;
	using super::full;

	constexpr bool has_bits_for_pop() const noexcept {
		return super::size() >= out_bits;
	}

	constexpr bool has_capacity_for_push() const noexcept {
		return super::size() <= (capacity() - in_bits);
	}
};

} // namespace cthash

#endif

#include <iostream>
#include <ranges>

namespace cthash {

template <typename Buffer> struct buffer_result_type;

template <typename Buffer> requires(Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	static constexpr Buffer::size_type missing_bits = {0u};

	constexpr bool is_padding() const noexcept {
		return false;
	}
};

template <typename Buffer> requires(!Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	typename Buffer::size_type missing_bits;

	constexpr bool is_padding() const noexcept {
		return missing_bits == Buffer::out_bits;
	}
};

template <typename Buffer, bool AllowPadding> struct buffer_with_missing_bits;

template <typename Buffer, bool AllowPadding> requires(Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};

	struct result_type {
		typename Buffer::out_type value;
		static constexpr Buffer::size_type missing_bits = {0u};

		constexpr bool is_padding() const noexcept {
			return false;
		}
	};

	static constexpr bool aligned = Buffer::aligned();

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		return result_type{buffer.front()};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		while (!buffer.has_bits_for_pop() && (it != end)) {
			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <typename Buffer, bool AllowPadding> requires(!Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};
	Buffer::size_type missing_bits{0};

	static constexpr bool aligned = Buffer::aligned();

	struct result_type {
		typename Buffer::out_type value;
		typename Buffer::size_type missing_bits;

		constexpr bool is_padding() const noexcept {
			return missing_bits == Buffer::out_bits;
		}
	};

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		assert(Buffer::out_bits >= missing_bits);
		return result_type{buffer.front(), missing_bits};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	constexpr void pad_buffer() noexcept requires(AllowPadding) {
		// full multi-chunk padding (for baseN encodings)
		missing_bits = (Buffer::out_bits - buffer.push_zeros_for_padding());
	}

	constexpr void pad_buffer() noexcept requires(!AllowPadding) {
		// only add enough zero to finish current output chunk
		missing_bits = buffer.push_zeros_to_align();
	}

	constexpr void saturate_missing_bits() noexcept requires(AllowPadding) {
		if (missing_bits) {
			missing_bits = Buffer::out_bits;
		}
		// missing_bits = static_cast<buffer_size_t>((unsigned)(bool)missing_bits * output_value_bit_size);
	}

	constexpr void saturate_missing_bits() noexcept requires(!AllowPadding) {
		// do nothing :)
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		for (;;) {
			if (it == end) {
				if (buffer.has_bits_for_pop()) {
					// if this is second pass after padding we can mark all bits as missing
					saturate_missing_bits();
				} else {
					// fill remainder of buffer with zeros
					pad_buffer();
				}

				return;
			}

			if (buffer.has_bits_for_pop()) {
				return;
			}

			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <bool Value> struct conditional;

template <> struct conditional<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional<false> {
	template <typename, typename T> using type = T;
};

template <bool Const, typename T> using maybe_const = typename conditional<Const>::template type<const T, T>;

template <typename T> concept integral_like = std::integral<T> || std::same_as<std::byte, T>;

template <size_t Bits, bool AllowPadding, std::ranges::input_range Input> requires integral_like<std::ranges::range_value_t<Input>> struct chunk_of_bits_view {
	using input_value_type = std::ranges::range_value_t<Input>;

	static constexpr size_t output_value_bit_size = Bits;
	static constexpr size_t input_value_bit_size = sizeof(input_value_type) * 8u;
	using buffer_t = cthash::bit_buffer<output_value_bit_size, input_value_bit_size>;
	using buffer_size_t = buffer_t::size_type;
	Input input;

	static constexpr bool aligned = buffer_t::aligned;

	struct sentinel { };

	template <bool Const> struct iterator {
		using parent = maybe_const<Const, Input>;
		using storage_type = buffer_with_missing_bits<buffer_t, AllowPadding>;
		using value_type = storage_type::result_type;
		using difference_type = intptr_t;

		std::ranges::iterator_t<parent> it;
		[[no_unique_address]] std::ranges::sentinel_t<parent> end;

		storage_type buffer{};

		constexpr iterator(parent & p) noexcept: it{std::ranges::begin(p)}, end{std::ranges::end(p)} {
			// initialize
			buffer.feed_buffer(it, end);
		}

		iterator(const iterator &) = default;
		iterator(iterator &&) = default;

		iterator & operator=(const iterator &) = default;
		iterator & operator=(iterator &&) = default;

		constexpr iterator & operator++() noexcept {
			buffer.pop();
			buffer.feed_buffer(it, end);
			return *this;
		}

		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			this->operator++();
			return copy;
		}

		constexpr auto operator*() const noexcept {
			return buffer.front();
		}

		constexpr friend bool operator==(const iterator & lhs, const iterator & rhs) noexcept = default;

		constexpr friend bool operator==(const iterator & self, sentinel) noexcept {
			return self.buffer.empty();
		}
	};

	static_assert(std::input_iterator<iterator<true>>);
	static_assert(std::input_iterator<iterator<false>>);
	static_assert(std::sentinel_for<sentinel, iterator<true>>);
	static_assert(std::sentinel_for<sentinel, iterator<false>>);

	constexpr chunk_of_bits_view(Input _input) noexcept: input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input};
	}

	constexpr auto end() const noexcept {
		return sentinel{};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && AllowPadding) {
		// calculate with blocks
		return ((std::ranges::size(input) + (buffer_t::in_capacity() - 1u)) / buffer_t::in_capacity()) * buffer_t::out_capacity();
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && !AllowPadding) {
		// calculate with bits
		const size_t bit_size_of_input = std::ranges::size(input) * input_value_bit_size;
		return (bit_size_of_input + (output_value_bit_size - 1u)) / output_value_bit_size;
	}
};

template <size_t Bits, bool AllowPadding> struct chunk_of_bits_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, chunk_of_bits_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) {
		return chunk_of_bits_view<Bits, AllowPadding, R>(std::forward<R>(input));
	}
};

template <size_t Bits, bool AllowPadding = false> constexpr auto chunk_of_bits = chunk_of_bits_action<Bits, AllowPadding>{};

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#include <bit>

namespace cthash {

template <typename Encoding> struct encoding_properties {
	static constexpr size_t size = std::size(Encoding::alphabet) - 1u;
	static_assert(std::popcount(size) == 1u, "Size of encoding's alphabet must be power-of-two");

	static constexpr size_t bits = std::countr_zero(size);

	static constexpr bool has_padding = padded_encoding<Encoding>;

	static constexpr char padding = [] {
		if constexpr (has_padding) {
			return Encoding::padding;
		} else {
			return '\0';
		}
	}();
};

template <typename Encoding, typename CharT, typename R> struct encode_to_view {
	using properties = encoding_properties<Encoding>;
	using chunk_view = cthash::chunk_of_bits_view<properties::bits, properties::has_padding, R>;

	struct sentinel {
		[[no_unique_address]] chunk_view::sentinel end;
	};

	template <bool Const> struct iterator {
		using difference_type = intptr_t;
		using value_type = CharT;

		chunk_view::template iterator<Const> it;

		constexpr iterator & operator++() noexcept {
			++it;
			return *this;
		}
		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			++it;
			return copy;
		}

		constexpr value_type operator*() const noexcept {
			const auto tmp = *it;
			if constexpr (!chunk_view::aligned) {
				// TODO: do without condition
				if (tmp.is_padding()) {
					return properties::padding;
				}
			}
			return static_cast<value_type>(Encoding::alphabet[static_cast<unsigned>(tmp.value)]);
		}

		constexpr friend bool operator==(const iterator &, const iterator &) noexcept = default;

		constexpr friend bool operator==(const iterator & lhs, const sentinel & rhs) noexcept {
			return lhs.it == rhs.end;
		}
	};

	chunk_view input;

	constexpr encode_to_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}

	constexpr auto to_string() const requires(std::ranges::sized_range<R>) {
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(*this);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(size());
		auto [i, o] = std::ranges::copy(begin(), end(), result.begin());
		assert(i == result.end());
		assert(o == result.end());
		return result;
#endif
	}

	constexpr friend std::basic_ostream<CharT> & operator<<(std::basic_ostream<CharT> & out, encode_to_view in) {
		std::ranges::copy(in.begin(), in.end(), std::ostream_iterator<CharT, CharT>(out));
		return out;
	}
};

template <typename Encoding, typename ValueT, typename R> struct decode_from_view {
	R input;

	template <bool Const> struct iterator { };
	struct sentinel { };

	constexpr decode_from_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}
};

template <typename Encoding, typename CharT = char> struct encode_to_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, encode_to_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return encode_to_view<Encoding, CharT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename ValueT = unsigned char> struct decode_from_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, decode_from_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return decode_from_view<Encoding, ValueT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename CharT = char> constexpr auto encode_to = encode_to_action<Encoding, CharT>{};
template <typename Encoding, typename ValueT = unsigned char> constexpr auto decode_from = decode_from_action<Encoding, ValueT>{};

constexpr auto binary_encode = encode_to<encoding::base2, char>;
constexpr auto base2_encode = encode_to<encoding::base2, char>;
constexpr auto base4_encode = encode_to<encoding::base4, char>;
constexpr auto base8_encode = encode_to<encoding::base8, char>;
constexpr auto octal_encode = encode_to<encoding::base8, char>;
constexpr auto hexdec_encode = encode_to<encoding::base16, char>;
constexpr auto hexdec_uppercase_encode = encode_to<encoding::base16_uppercase, char>;
constexpr auto base16_encode = encode_to<encoding::base16, char>;
constexpr auto base32_encode = encode_to<encoding::base32, char>;
constexpr auto base32_no_padding_encode = encode_to<encoding::base32_no_padding, char>;
constexpr auto z_base32_encode = encode_to<encoding::z_base32, char>;
constexpr auto base64_encode = encode_to<encoding::base64, char>;
constexpr auto base64url_encode = encode_to<encoding::base64url, char>;
constexpr auto base64_no_padding_encode = encode_to<encoding::base64_no_padding, char>;

constexpr auto binary_decode = decode_from<encoding::base2, char>;
constexpr auto base2_decode = decode_from<encoding::base2, char>;
constexpr auto base4_decode = decode_from<encoding::base4, char>;
constexpr auto base8_decode = decode_from<encoding::base8, char>;
constexpr auto hexdec_decode = decode_from<encoding::base16, char>;
constexpr auto base16_decode = decode_from<encoding::base16, char>;
constexpr auto base32_decode = decode_from<encoding::base32, char>;
constexpr auto z_base32_decode = decode_from<encoding::z_base32, char>;
constexpr auto base64_decode = decode_from<encoding::base64, char>;
constexpr auto base64url_decode = decode_from<encoding::base64url, char>;
constexpr auto base64_no_padding_decode = decode_from<encoding::base64_no_padding, char>;

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

// template <typename Encoding, typename CharT, typename R> struct encode_to_view

#ifdef CTHASH_STDFMT_AVAILABLE
template <typename Encoding, typename R, typename CharT>
struct formatter<cthash::encode_to_view<Encoding, CharT, R>, CharT> {
	using subject_type = cthash::encode_to_view<Encoding, CharT, R>;

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		return std::ranges::begin(ctx);
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return std::ranges::copy(value, ctx.out()).out;
	}
};

#endif

} // namespace std

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_ALGORITHM_HPP
#define CTHASH_INTERNAL_ALGORITHM_HPP

#include <numeric>
#include <compare>
#include <cstddef>
#include <cstdint>

namespace cthash::internal {

template <typename It1, typename It2> constexpr auto threeway_compare_of_same_size(It1 lhs, It2 rhs, size_t length) -> std::strong_ordering {
	for (size_t i = 0; i != length; ++i) {
		if (const auto r = (*lhs++ <=> *rhs++); std::is_neq(r)) {
			return r;
		}
	}

	return std::strong_ordering::equal;
}

template <typename T, typename It1, typename It2, typename Stream> constexpr auto & push_to_stream_as(It1 f, It2 l, Stream & stream) {
	constexpr auto cast_and_shift = [](Stream * s, const auto & rhs) { (*s) << T{rhs}; return s; };
	return *std::accumulate(f, l, &stream, cast_and_shift);
}

} // namespace cthash::internal

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_HEXDEC_HPP
#define CTHASH_INTERNAL_HEXDEC_HPP

#include <array>
#include <ostream>
#include <span>
#include <type_traits>
#include <cstdint>

namespace cthash::internal {

consteval auto get_hexdec_table() noexcept {
	std::array<uint8_t, 128> result;

	auto char_to_hexdec = [](char c) {
		if (c >= '0' && c <= '9') {
			return static_cast<uint8_t>(c - '0');
		} else if (c >= 'a' && c <= 'f') {
			return static_cast<uint8_t>(c - 'a' + 10);
		} else if (c >= 'A' && c <= 'F') {
			return static_cast<uint8_t>(c - 'A' + 10);
		} else {
			return static_cast<uint8_t>(0);
		}
	};

	for (size_t i = 0; i != result.size(); ++i) {
		result[i] = char_to_hexdec(static_cast<char>(i));
	}

	return result;
}

constexpr auto hexdec_to_value_alphabet = get_hexdec_table();

template <typename CharT> constexpr auto value_to_hexdec_alphabet = std::array<CharT, 16>{CharT('0'), CharT('1'), CharT('2'), CharT('3'), CharT('4'), CharT('5'), CharT('6'), CharT('7'), CharT('8'), CharT('9'), CharT('a'), CharT('b'), CharT('c'), CharT('d'), CharT('e'), CharT('f')};

struct byte_hexdec_value {
	std::byte val;

	template <typename CharT, typename Traits> friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, byte_hexdec_value rhs) {
		return os << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val >> 4u)] << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val) & 0b1111u];
	}
};

template <size_t N, typename CharT> constexpr auto hexdec_to_binary(std::span<const CharT, N * 2> in) -> std::array<std::byte, N> {
	return [in]<size_t... Idx>(std::index_sequence<Idx...>) {
		return std::array<std::byte, N>{static_cast<std::byte>(hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2]) & 0b0111'1111u] << 4u | hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2u + 1u]) & 0b0111'1111u])...};
	}(std::make_index_sequence<N>());
}

template <typename CharT, size_t N>
requires((N - 1) % 2 == 0) // -1 because of zero terminator in literals
constexpr auto literal_hexdec_to_binary(const CharT (&in)[N]) -> std::array<std::byte, (N - 1) / 2> {
	return hexdec_to_binary<N / 2>(std::span<const char, N - 1>(in, N - 1));
}

} // namespace cthash::internal

#endif

#include <algorithm>
#include <array>
#include <format>
#include <span>
#include <string_view>
#include <compare>

namespace cthash {

// hash_value

template <size_t N> struct hash_value: std::array<std::byte, N> {
	using super = std::array<std::byte, N>;

	constexpr hash_value() noexcept: super{} { }
	explicit constexpr hash_value(super && s) noexcept: super(s) { }
	template <typename CharT> explicit constexpr hash_value(const CharT (&in)[N * 2u + 1u]) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in, N * 2u))} { }
	template <typename CharT> explicit constexpr hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in.data(), in.size()))} { }

	// comparison support
	constexpr friend bool operator==(const hash_value & lhs, const hash_value & rhs) noexcept = default;
	constexpr friend auto operator<=>(const hash_value & lhs, const hash_value & rhs) noexcept -> std::strong_ordering {
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), N);
	}

	template <typename Encoding = cthash::encoding::hexdec, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		auto hexdec_view = *this | cthash::encode_to<Encoding, CharT>;
		std::ranges::copy(hexdec_view, std::ostream_iterator<CharT, CharT>(os));
		return os;
	}

	// print to ostream support
	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const hash_value & val) {
		return val.print_into(os);
	}

	template <size_t PrefixN> constexpr auto prefix() const noexcept requires(PrefixN <= N) {
		hash_value<PrefixN> output{};
		std::ranges::copy(this->begin(), this->begin() + PrefixN, output.begin());
		return output;
	}

	template <size_t SuffixN> constexpr auto suffix() const noexcept requires(SuffixN <= N) {
		hash_value<SuffixN> output{};
		std::ranges::copy(this->end() - SuffixN, this->end(), output.begin());
		return output;
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(encoded);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(encoded.size());
		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());
		return result;
#endif
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_fixed_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
		// it's type dependendent so we can calculate the size...
		constexpr size_t size_needed = (hash_value{} | cthash::encode_to<Encoding, CharT>).size();

		auto result = cthash::fixed_string<CharT, size_needed>{nullptr};

		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());

		return result;
	}
};

template <typename CharT, size_t N> hash_value(const CharT (&)[N]) -> hash_value<(N - 1u) / 2u>;
template <typename CharT, size_t N> hash_value(std::span<const CharT, N>) -> hash_value<N / 2u>;
template <typename CharT, size_t N> hash_value(const fixed_string<CharT, N> &) -> hash_value<N / 2u>;

template <typename> struct default_encoding {
	using encoding = cthash::encoding::hexdec;
};

template <typename Tag> concept tag_with_encoding = requires() {
	typename Tag::encoding;
};

template <tag_with_encoding Tag> struct default_encoding<Tag> {
	using encoding = Tag::encoding;
};

template <typename Tag, size_t = internal::digest_bytes_length_of<Tag>> struct tagged_hash_value: hash_value<internal::digest_bytes_length_of<Tag>> {
	static constexpr size_t N = internal::digest_bytes_length_of<Tag>;

	using super = hash_value<N>;
	using super::super;
	template <typename CharT> explicit constexpr tagged_hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{in} { }

	static constexpr size_t digest_length = N;

	template <typename Encoding = default_encoding<Tag>::encoding, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		return super::template print_into<Encoding>(os);
	}

	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const tagged_hash_value & val) {
		return val.print_into(os);
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_string(const tagged_hash_value & value) {
		return to_string<Encoding, CharT>(static_cast<const super &>(value));
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_fixed_string(const tagged_hash_value & value) {
		return to_fixed_string<Encoding, CharT>(static_cast<const super &>(value));
	}
};

template <typename T> concept variable_digest_length = T::digest_length_bit == 0u;

template <size_t N, variable_digest_length Tag> struct variable_bit_length_tag: Tag {
	static constexpr size_t digest_length_bit = N;
};

template <typename T> concept convertible_to_tagged_hash_value = requires(const T & obj) {
	{ tagged_hash_value{obj} };
};

namespace literals {

	template <fixed_string Value>
	constexpr auto operator""_hash() {
		return hash_value(Value);
	}

} // namespace literals

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#if _LIBCPP_VERSION >= 170000
// libc++ will define __cpp_lib_format macro in 19.0
// https://github.com/llvm/llvm-project/issues/77773
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#ifdef CTHASH_STDFMT_AVAILABLE
template <size_t N, typename CharT>
struct formatter<cthash::hash_value<N>, CharT> {
	using subject_type = cthash::hash_value<N>;
	using default_encoding = cthash::encoding::hexdec;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <typename Tag, size_t N, typename CharT>
struct formatter<cthash::tagged_hash_value<Tag, N>, CharT> {
	using subject_type = cthash::tagged_hash_value<Tag, N>;
	using default_encoding = typename cthash::default_encoding<Tag>::encoding;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <cthash::convertible_to_tagged_hash_value Type, typename CharT> struct formatter<Type, CharT>: formatter<decltype(cthash::tagged_hash_value{std::declval<Type>()}), CharT> {
};

#endif

} // namespace std

#endif

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_CONVERT_HPP
#define CTHASH_INTERNAL_CONVERT_HPP

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#include <span>
#include <type_traits>
#include <cstddef>
#include <cstdint>
#include <cstring>

namespace cthash {

template <typename It1, typename It2, typename It3> constexpr auto byte_copy(It1 first, It2 last, It3 destination) {
	return std::transform(first, last, destination, [](byte_like auto v) { return static_cast<std::byte>(v); });
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << ((sizeof(T) - 1u - Idx) * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::little) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_le_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << static_cast<T>(Idx * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::big) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T> struct unwrap_littleendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> (Idx * 8u))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_littleendian_number(std::span<std::byte, 8>) -> unwrap_littleendian_number<uint64_t>;
unwrap_littleendian_number(std::span<std::byte, 4>) -> unwrap_littleendian_number<uint32_t>;

template <std::unsigned_integral T> struct unwrap_bigendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> ((bits - 8u) - 8u * Idx))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_bigendian_number(std::span<std::byte, 8>) -> unwrap_bigendian_number<uint64_t>;
unwrap_bigendian_number(std::span<std::byte, 4>) -> unwrap_bigendian_number<uint32_t>;

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#include <algorithm>
#include <array>
#include <span>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <typename Config> struct internal_hasher {
	static constexpr auto config = Config{};
	static constexpr size_t block_size_bytes = config.block_bits / 8u;
	static constexpr size_t digest_bytes = internal::digest_bytes_length_of<Config>;

	// internal types
	using state_value_t = std::remove_cvref_t<decltype(Config::initial_values)>;
	using state_item_t = typename state_value_t::value_type;

	using block_value_t = std::array<std::byte, block_size_bytes>;
	using block_view_t = std::span<const std::byte, block_size_bytes>;

	using staging_item_t = typename decltype(config.constants)::value_type;
	static constexpr size_t staging_size = config.constants.size();
	using staging_value_t = std::array<staging_item_t, staging_size>;
	using staging_view_t = std::span<const staging_item_t, staging_size>;

	using digest_span_t = std::span<std::byte, digest_bytes>;
	using result_t = cthash::tagged_hash_value<Config>;
	using length_t = typename Config::length_type;

	// internal state
	state_value_t hash;
	length_t total_length;

	block_value_t block;
	unsigned block_used;

	// constructors
	constexpr internal_hasher() noexcept: hash{config.initial_values}, total_length{0u}, block_used{0u} { }
	constexpr internal_hasher(const internal_hasher &) noexcept = default;
	constexpr internal_hasher(internal_hasher &&) noexcept = default;
	constexpr ~internal_hasher() noexcept = default;

	// take buffer and build staging
	template <byte_like Byte> [[gnu::always_inline]] static constexpr auto build_staging(std::span<const Byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		staging_value_t w;

		constexpr auto first_part_size = block_size_bytes / sizeof(staging_item_t);

		// fill first part with chunk
		for (int i = 0; i != int(first_part_size); ++i) {
			w[static_cast<size_t>(i)] = cast_from_bytes<staging_item_t>(chunk.subspan(static_cast<size_t>(i) * sizeof(staging_item_t)).template first<sizeof(staging_item_t)>());
		}

		// fill the rest (generify)
		for (int i = int(first_part_size); i != int(staging_size); ++i) {
			w[static_cast<size_t>(i)] = w[static_cast<size_t>(i - 16)] + config.sigma_0(w[static_cast<size_t>(i - 15)]) + w[static_cast<size_t>(i - 7)] + config.sigma_1(w[static_cast<size_t>(i - 2)]);
		}

		return w;
	}

	[[gnu::always_inline]] static constexpr auto build_staging(std::span<const std::byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		return build_staging<std::byte>(chunk);
	}

	[[gnu::always_inline]] static constexpr void rounds(staging_view_t w, state_value_t & state) noexcept {
		config.rounds(w, state);
	}

	// this implementation works only with input size aligned to bytes (not bits)
	template <byte_like T> [[gnu::always_inline]] constexpr void update_to_buffer_and_process(std::span<const T> in) noexcept {
		// if block is not used, we can build staging directly
		if (block_used) {
			const auto remaining_free_space = std::span<std::byte, block_size_bytes>(block).subspan(block_used);
			const auto to_copy = in.first(std::min(in.size(), remaining_free_space.size()));

			const auto it = byte_copy(to_copy.begin(), to_copy.end(), remaining_free_space.begin());
			total_length += to_copy.size();

			// we didn't fill the block
			if (it != remaining_free_space.end()) {
				assert(to_copy.size() == in.size());
				block_used += static_cast<unsigned>(to_copy.size());
				return;
			} else {
				block_used = 0u;
			}

			// we have block!
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// remove part we processed
			in = in.subspan(to_copy.size());
		}

		// do the work over blocks without copy
		if (not block_used) {
			while (in.size() >= block_size_bytes) {
				const auto local_block = in.template first<block_size_bytes>();
				total_length += block_size_bytes;

				const staging_value_t w = build_staging<T>(local_block);
				rounds(w, hash);

				// remove part we processed
				in = in.subspan(block_size_bytes);
			}
		}

		// remainder is put onto temporary block
		if (not in.empty()) {
			assert(block_used == 0u);
			assert(in.size() < block_size_bytes);

			// copy it to block and let it stay there
			byte_copy(in.begin(), in.end(), block.begin());
			block_used = static_cast<unsigned>(in.size());
			total_length += block_used;
		}
	}

	[[gnu::always_inline]] static constexpr bool finalize_buffer(block_value_t & block, size_t block_used) noexcept {
		assert(block_used < block.size());
		const auto free_space = std::span(block).subspan(block_used);

		auto it = free_space.data();
		*it++ = std::byte{0b1000'0000u};							   // first byte after data contains bit at MSB
		std::fill(it, (block.data() + block.size()), std::byte{0x0u}); // rest is filled with zeros

		// we don't have enough space to write length bits
		return free_space.size() < (1u + (config.length_size_bits / 8u));
	}

	[[gnu::always_inline]] static constexpr void finalize_buffer_by_writing_length(block_value_t & block, length_t total_length) noexcept {
		unwrap_bigendian_number{std::span(block).template last<sizeof(length_t)>()} = (total_length * 8u);
	}

	[[gnu::always_inline]] constexpr void finalize() noexcept {
		if (finalize_buffer(block, block_used)) {
			// we didn't have enough space, we need to process block
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// zero it out
			std::fill(block.begin(), block.end(), std::byte{0x0u});
		}

		// we either have space to write or we have zerod out block
		finalize_buffer_by_writing_length(block, total_length);

		// calculate last round
		const staging_value_t w = build_staging(block);
		rounds(w, hash);
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) == 0u)
	{
		// copy result to byte result
		constexpr size_t values_for_output = digest_bytes / sizeof(state_item_t);
		static_assert(values_for_output <= config.initial_values.size());

		for (int i = 0; i != values_for_output; ++i) {
			unwrap_bigendian_number<state_item_t>{out.subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) != 0u)
	{
		// this is only used when digest doesn't align with output buffer

		// make sure digest size is smaller than hash state
		static_assert(digest_bytes <= config.initial_values.size() * sizeof(state_item_t));

		// copy result to byte result
		std::array<std::byte, sizeof(state_item_t) * config.initial_values.size()> tmp_buffer;

		for (int i = 0; i != (int)config.initial_values.size(); ++i) {
			unwrap_bigendian_number<state_item_t>{std::span(tmp_buffer).subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}

		std::copy_n(tmp_buffer.data(), digest_bytes, out.data());
	}
};

// this is a convinience type for nicer UX...
template <typename Config> struct hasher: private internal_hasher<Config> {
	using super = internal_hasher<Config>;
	using result_t = typename super::result_t;
	using length_t = typename super::length_t;
	using digest_span_t = typename super::digest_span_t;

	constexpr hasher() noexcept: super() { }
	constexpr hasher(const hasher &) noexcept = default;
	constexpr hasher(hasher &&) noexcept = default;
	constexpr ~hasher() noexcept = default;

	// support for various input types
	constexpr hasher & update(std::span<const std::byte> input) noexcept {
		super::update_to_buffer_and_process(input);
		return *this;
	}

	template <convertible_to_byte_span T> constexpr hasher & update(const T & something) noexcept {
		using value_type = typename decltype(std::span(something))::value_type;
		super::update_to_buffer_and_process(std::span<const value_type>(something));
		return *this;
	}

	template <one_byte_char CharT> constexpr hasher & update(std::basic_string_view<CharT> in) noexcept {
		super::update_to_buffer_and_process(std::span(in.data(), in.size()));
		return *this;
	}

	template <string_literal T> constexpr hasher & update(const T & lit) noexcept {
		super::update_to_buffer_and_process(std::span(lit, std::size(lit) - 1u));
		return *this;
	}

	// TODO: any range with value convertible to byte

	// output (by reference or by value)
	constexpr void final(digest_span_t digest) noexcept {
		super::finalize();
		super::write_result_into(digest);
	}

	constexpr auto final() noexcept {
		result_t output;
		this->final(output);
		return output;
	}

	constexpr length_t size() const noexcept {
		return super::total_length;
	}
};

} // namespace cthash

#endif

#include <array>
#include <span>
#include <concepts>
#include <cstdint>

namespace cthash::sha2 {

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto choice(T e, T f, T g) noexcept -> T {
	return (e bitand f) xor (~e bitand g);
}

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto majority(T a, T b, T c) noexcept -> T {
	return (a bitand b) xor (a bitand c) xor (b bitand c);
}

template <typename Config, typename StageT, size_t StageLength, typename StateT, size_t StateLength>
[[gnu::always_inline]] constexpr void rounds(std::span<const StageT, StageLength> w, std::array<StateT, StateLength> & state) noexcept {
	using state_t = std::array<StateT, StateLength>;

	// create copy of internal state
	auto wvar = state_t(state);

	// just give them names
	auto & [a, b, c, d, e, f, g, h] = wvar;

	// number of rounds is same as constants
	static_assert(StageLength == Config::constants.size());

	for (int i = 0; i != Config::constants.size(); ++i) {
		const auto temp1 = h + Config::sum_e(e) + choice(e, f, g) + Config::constants[static_cast<size_t>(i)] + w[static_cast<size_t>(i)];
		const auto temp2 = Config::sum_a(a) + majority(a, b, c);

		// move around (that's rotate)
		std::rotate(wvar.begin(), wvar.begin() + 7u, wvar.end());

		e += temp1;
		a = temp1 + temp2;

		// originally it was:
		// h = g;
		// g = f;
		// f = e;
		// e = d + temp1;
		// d = c;
		// c = b;
		// b = a;
		// a = temp1 + temp2;
	}

	// add store back
	for (int i = 0; i != (int)state.size(); ++i) {
		state[static_cast<size_t>(i)] += wvar[static_cast<size_t>(i)];
	}
}

} // namespace cthash::sha2

#endif

namespace cthash {

struct sha256_config {
	using length_type = uint64_t;
	static constexpr size_t length_size_bits = 64;

	static constexpr size_t block_bits = 512u;

	static constexpr auto initial_values = std::array<uint32_t, 8>{0x6a09e667ul, 0xbb67ae85ul, 0x3c6ef372ul, 0xa54ff53aul, 0x510e527ful, 0x9b05688cul, 0x1f83d9abul, 0x5be0cd19ul};

	// staging sigmas
	[[gnu::always_inline]] static constexpr auto sigma_0(uint32_t w_15) noexcept -> uint32_t {
		return std::rotr(w_15, 7u) xor std::rotr(w_15, 18u) xor (w_15 >> 3u);
	}

	[[gnu::always_inline]] static constexpr auto sigma_1(uint32_t w_2) noexcept -> uint32_t {
		return std::rotr(w_2, 17u) xor std::rotr(w_2, 19u) xor (w_2 >> 10u);
	}

	// rounds constants...
	static constexpr auto constants = std::array<uint32_t, 64>{
		0x428a2f98ul, 0x71374491ul, 0xb5c0fbcful, 0xe9b5dba5ul, 0x3956c25bul, 0x59f111f1ul, 0x923f82a4ul, 0xab1c5ed5ul,
		0xd807aa98ul, 0x12835b01ul, 0x243185beul, 0x550c7dc3ul, 0x72be5d74ul, 0x80deb1feul, 0x9bdc06a7ul, 0xc19bf174ul,
		0xe49b69c1ul, 0xefbe4786ul, 0x0fc19dc6ul, 0x240ca1ccul, 0x2de92c6ful, 0x4a7484aaul, 0x5cb0a9dcul, 0x76f988daul,
		0x983e5152ul, 0xa831c66dul, 0xb00327c8ul, 0xbf597fc7ul, 0xc6e00bf3ul, 0xd5a79147ul, 0x06ca6351ul, 0x14292967ul,
		0x27b70a85ul, 0x2e1b2138ul, 0x4d2c6dfcul, 0x53380d13ul, 0x650a7354ul, 0x766a0abbul, 0x81c2c92eul, 0x92722c85ul,
		0xa2bfe8a1ul, 0xa81a664bul, 0xc24b8b70ul, 0xc76c51a3ul, 0xd192e819ul, 0xd6990624ul, 0xf40e3585ul, 0x106aa070ul,
		0x19a4c116ul, 0x1e376c08ul, 0x2748774cul, 0x34b0bcb5ul, 0x391c0cb3ul, 0x4ed8aa4aul, 0x5b9cca4ful, 0x682e6ff3ul,
		0x748f82eeul, 0x78a5636ful, 0x84c87814ul, 0x8cc70208ul, 0x90befffaul, 0xa4506cebul, 0xbef9a3f7ul, 0xc67178f2ul};

	// rounds sums
	[[gnu::always_inline]] static constexpr auto sum_a(uint32_t a) noexcept -> uint32_t {
		return std::rotr(a, 2u) xor std::rotr(a, 13u) xor std::rotr(a, 22u);
	}

	[[gnu::always_inline]] static constexpr auto sum_e(uint32_t e) noexcept -> uint32_t {
		return std::rotr(e, 6u) xor std::rotr(e, 11u) xor std::rotr(e, 25u);
	}

	// rounds
	[[gnu::always_inline]] static constexpr void rounds(std::span<const uint32_t, 64> w, std::array<uint32_t, 8> & state) noexcept {
		return sha2::rounds<sha256_config>(w, state);
	}
};

static_assert(not cthash::internal::digest_length_provided<sha256_config>);
static_assert(cthash::internal::digest_bytes_length_of<sha256_config> == 32u);

using sha256 = hasher<sha256_config>;
using sha256_value = tagged_hash_value<sha256_config>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_sha256() {
		return sha256_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

#ifndef CTHASH_SHA2_SHA384_HPP
#define CTHASH_SHA2_SHA384_HPP

#ifndef CTHASH_SHA2_SHA512_HPP
#define CTHASH_SHA2_SHA512_HPP

#ifndef CTHASH_SHA2_COMMON_HPP
#define CTHASH_SHA2_COMMON_HPP

#ifndef CONSTEXPR_SHA2_HASHER_HPP
#define CONSTEXPR_SHA2_HASHER_HPP

#ifndef CTHASH_SIMPLE_HPP
#define CTHASH_SIMPLE_HPP

#include <utility>

namespace cthash {

template <typename Hasher, typename In, typename... Args> concept hasher_like = requires(Hasher & h, const In & in, Args &&... args) //
{
	{ Hasher{std::forward<Args>(args)...} };
	{ h.update(in) } -> std::same_as<Hasher &>;
	{ h.final() };
};

template <typename Hasher, typename In> concept direct_hasher = requires(Hasher & h, const In & in) //
{
	{ h.update_and_final(in) };
};

template <typename Hasher, typename T, typename... Args>
requires hasher_like<Hasher, T, Args...>
constexpr auto simple(const T & value, Args &&... args) noexcept {
	if constexpr (direct_hasher<Hasher, T>) {
		return Hasher{std::forward<Args>(args)...}.update_and_final(value);
	} else {
		return Hasher{std::forward<Args>(args)...}.update(value).final();
	}
}

} // namespace cthash

#endif

#ifndef CTHASH_VALUE_HPP
#define CTHASH_VALUE_HPP

#ifndef CTHASH_FIXED_STRING_HPP
#define CTHASH_FIXED_STRING_HPP

#include <algorithm>
#include <span>
#include <string_view>

namespace cthash {

template <typename CharT, size_t N> struct fixed_string: std::array<CharT, N> {
	using super = std::array<CharT, N>;

	consteval static auto from_string_literal(const CharT (&in)[N + 1]) -> std::array<CharT, N> {
		std::array<CharT, N> out;
		std::copy_n(in, N, out.data());
		return out;
	}

	explicit constexpr fixed_string(std::nullptr_t) noexcept: super{} { }

	consteval fixed_string(const CharT (&in)[N + 1]) noexcept: super{from_string_literal(in)} { }

	using super::data;
	using super::size;

	constexpr operator std::span<const CharT, N>() const noexcept {
		return std::span<const CharT, N>(data(), size());
	}

	constexpr operator std::span<const CharT>() const noexcept {
		return std::span<const CharT>(data(), size());
	}

	constexpr operator std::basic_string_view<CharT>() const noexcept {
		return std::basic_string_view<CharT>(data(), size());
	}

	constexpr friend bool operator==(const fixed_string &, const fixed_string &) noexcept = default;
	constexpr friend bool operator==(const fixed_string & lhs, std::basic_string_view<CharT> rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == rhs;
	}
	constexpr friend bool operator==(const fixed_string & lhs, const CharT * rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == std::basic_string_view<CharT>{rhs};
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N - 1>;

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_BASE_HPP
#define CTHASH_ENCODING_BASE_HPP

#ifndef CTHASH_ENCODING_CHUNK_OF_BITS_HPP
#define CTHASH_ENCODING_CHUNK_OF_BITS_HPP

#ifndef CTHASH_ENCODING_BIT_BUFFER_HPP
#define CTHASH_ENCODING_BIT_BUFFER_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <bit>
#include <iostream>
#include <numeric>
#include <ranges>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct select_bit_integer;

template <size_t Bits> requires(Bits <= 8) struct select_bit_integer<Bits> {
	using type = uint8_t;
};

template <size_t Bits> requires(Bits > 8 && Bits <= 16) struct select_bit_integer<Bits> {
	using type = uint16_t;
};

template <size_t Bits> requires(Bits > 16 && Bits <= 32) struct select_bit_integer<Bits> {
	using type = uint32_t;
};

template <size_t Bits> requires(Bits > 32 && Bits <= 64) struct select_bit_integer<Bits> {
	using type = uint64_t;
};

template <size_t Bits> using select_bit_integer_t = select_bit_integer<Bits>::type;

template <size_t V> requires(std::popcount(V) == 1u) constexpr auto log2_of_power_of_2 = static_cast<size_t>(std::countr_zero(V));

template <size_t Bits> constexpr auto mask = static_cast<select_bit_integer_t<Bits>>((static_cast<select_bit_integer_t<Bits>>(1u) << Bits) - 1u);

template <size_t Capacity> class basic_bit_buffer {
public:
	static constexpr auto capacity = std::integral_constant<size_t, Capacity>{};
	using storage_type = select_bit_integer_t<capacity()>;
	using size_type = select_bit_integer_t<log2_of_power_of_2<std::bit_ceil(capacity())>>;

public:
	storage_type buffer{0};
	size_type bits_available{0};

public:
	template <size_t Bits> static constexpr auto mask = static_cast<storage_type>((static_cast<storage_type>(1u) << Bits) - 1u);

	constexpr friend bool operator==(const basic_bit_buffer & lhs, const basic_bit_buffer & rhs) noexcept = default;

	constexpr size_type size() const noexcept {
		return bits_available;
	}

	constexpr size_type unused_size() const noexcept {
		return capacity() - bits_available;
	}

	constexpr bool empty() const noexcept {
		return bits_available == 0u;
	}

	constexpr bool full() const noexcept {
		return bits_available == capacity();
	}

	template <size_t Bits> constexpr void push(select_bit_integer_t<Bits> in) noexcept requires(Bits <= capacity()) {
		assert(size() <= capacity() - Bits);
		buffer = static_cast<storage_type>(buffer << Bits) | static_cast<storage_type>(in);
		bits_available += static_cast<size_type>(Bits);
	}
	constexpr void push_empty_bits(size_t count) noexcept {
		buffer = static_cast<storage_type>(buffer << count);
		bits_available += static_cast<unsigned char>(count);
	}

	template <size_t Bits> constexpr void pop() noexcept requires(Bits <= capacity()) {
		assert(size() >= Bits);
		bits_available -= static_cast<size_type>(Bits);
	}

	template <size_t Bits> constexpr auto front() const noexcept -> select_bit_integer_t<Bits> requires(Bits <= capacity()) {
		using output_type = select_bit_integer_t<Bits>;
		assert(size() >= static_cast<size_type>(Bits));
		return static_cast<output_type>((buffer >> (bits_available - Bits))) & mask<Bits>;
	}
};

constexpr size_t calculate_padding_bit_count(size_t number_of_bits_in_buffer, size_t output_size, size_t input_size) {
	size_t n = number_of_bits_in_buffer;
	size_t padding_bits = 0u;

	while (n != 0u) {
		padding_bits += input_size;
		n += input_size;

		while (n >= output_size) {
			n = n - output_size;
		}
	}

	return padding_bits;
}

template <size_t OutBits, size_t InBits = 8u> class bit_buffer: protected basic_bit_buffer<std::lcm(OutBits, InBits)> {
	using super = basic_bit_buffer<std::lcm(OutBits, InBits)>;

public:
	constexpr bit_buffer() noexcept = default;

	using typename super::size_type;
	static constexpr auto out_bits = std::integral_constant<size_type, OutBits>{};
	static constexpr auto in_bits = std::integral_constant<size_type, InBits>{};

	using out_type = select_bit_integer_t<OutBits>;
	using in_type = select_bit_integer_t<InBits>;

	using super::capacity;
	static constexpr auto in_capacity = std::integral_constant<size_type, (capacity() / in_bits())>{};
	static constexpr auto out_capacity = std::integral_constant<size_type, (capacity() / out_bits())>{};

	static constexpr auto aligned = std::bool_constant<capacity() == in_capacity()>{};

	constexpr void push(in_type in) noexcept {
		super::template push<in_bits>(in);
	}

	constexpr void push_empty() noexcept {
		this->push(in_type{0u});
	}

	constexpr size_type push_zeros_to_align() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_to_align() noexcept requires(!aligned()) {
		if (empty()) {
			return 0u;
		}

		assert(out_bits > super::size());
		const size_type missing_bits = static_cast<size_type>(out_bits - super::size());
		super::push_empty_bits(missing_bits);
		return missing_bits;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(!aligned()) {
		const size_type usable_bits = super::size();
		const size_type missing_bits = static_cast<size_type>(calculate_padding_bit_count(super::size(), out_bits, in_bits));
		super::push_empty_bits(missing_bits);
		return usable_bits;
	}

	constexpr void pop() noexcept {
		super::template pop<out_bits>();
	}

	constexpr auto front() const noexcept -> out_type {
		return super::template front<out_bits>();
	}

	constexpr size_type size() const noexcept {
		return static_cast<size_type>(super::size() / out_bits);
	}

	constexpr size_type unused_size() const noexcept {
		return static_cast<size_type>(super::unused_size() / in_bits);
	}

	using super::empty;
	using super::full;

	constexpr bool has_bits_for_pop() const noexcept {
		return super::size() >= out_bits;
	}

	constexpr bool has_capacity_for_push() const noexcept {
		return super::size() <= (capacity() - in_bits);
	}
};

} // namespace cthash

#endif

#include <iostream>
#include <ranges>

namespace cthash {

template <typename Buffer> struct buffer_result_type;

template <typename Buffer> requires(Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	static constexpr Buffer::size_type missing_bits = {0u};

	constexpr bool is_padding() const noexcept {
		return false;
	}
};

template <typename Buffer> requires(!Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	typename Buffer::size_type missing_bits;

	constexpr bool is_padding() const noexcept {
		return missing_bits == Buffer::out_bits;
	}
};

template <typename Buffer, bool AllowPadding> struct buffer_with_missing_bits;

template <typename Buffer, bool AllowPadding> requires(Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};

	struct result_type {
		typename Buffer::out_type value;
		static constexpr Buffer::size_type missing_bits = {0u};

		constexpr bool is_padding() const noexcept {
			return false;
		}
	};

	static constexpr bool aligned = Buffer::aligned();

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		return result_type{buffer.front()};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		while (!buffer.has_bits_for_pop() && (it != end)) {
			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <typename Buffer, bool AllowPadding> requires(!Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};
	Buffer::size_type missing_bits{0};

	static constexpr bool aligned = Buffer::aligned();

	struct result_type {
		typename Buffer::out_type value;
		typename Buffer::size_type missing_bits;

		constexpr bool is_padding() const noexcept {
			return missing_bits == Buffer::out_bits;
		}
	};

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		assert(Buffer::out_bits >= missing_bits);
		return result_type{buffer.front(), missing_bits};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	constexpr void pad_buffer() noexcept requires(AllowPadding) {
		// full multi-chunk padding (for baseN encodings)
		missing_bits = (Buffer::out_bits - buffer.push_zeros_for_padding());
	}

	constexpr void pad_buffer() noexcept requires(!AllowPadding) {
		// only add enough zero to finish current output chunk
		missing_bits = buffer.push_zeros_to_align();
	}

	constexpr void saturate_missing_bits() noexcept requires(AllowPadding) {
		if (missing_bits) {
			missing_bits = Buffer::out_bits;
		}
		// missing_bits = static_cast<buffer_size_t>((unsigned)(bool)missing_bits * output_value_bit_size);
	}

	constexpr void saturate_missing_bits() noexcept requires(!AllowPadding) {
		// do nothing :)
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		for (;;) {
			if (it == end) {
				if (buffer.has_bits_for_pop()) {
					// if this is second pass after padding we can mark all bits as missing
					saturate_missing_bits();
				} else {
					// fill remainder of buffer with zeros
					pad_buffer();
				}

				return;
			}

			if (buffer.has_bits_for_pop()) {
				return;
			}

			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <bool Value> struct conditional;

template <> struct conditional<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional<false> {
	template <typename, typename T> using type = T;
};

template <bool Const, typename T> using maybe_const = typename conditional<Const>::template type<const T, T>;

template <typename T> concept integral_like = std::integral<T> || std::same_as<std::byte, T>;

template <size_t Bits, bool AllowPadding, std::ranges::input_range Input> requires integral_like<std::ranges::range_value_t<Input>> struct chunk_of_bits_view {
	using input_value_type = std::ranges::range_value_t<Input>;

	static constexpr size_t output_value_bit_size = Bits;
	static constexpr size_t input_value_bit_size = sizeof(input_value_type) * 8u;
	using buffer_t = cthash::bit_buffer<output_value_bit_size, input_value_bit_size>;
	using buffer_size_t = buffer_t::size_type;
	Input input;

	static constexpr bool aligned = buffer_t::aligned;

	struct sentinel { };

	template <bool Const> struct iterator {
		using parent = maybe_const<Const, Input>;
		using storage_type = buffer_with_missing_bits<buffer_t, AllowPadding>;
		using value_type = storage_type::result_type;
		using difference_type = intptr_t;

		std::ranges::iterator_t<parent> it;
		[[no_unique_address]] std::ranges::sentinel_t<parent> end;

		storage_type buffer{};

		constexpr iterator(parent & p) noexcept: it{std::ranges::begin(p)}, end{std::ranges::end(p)} {
			// initialize
			buffer.feed_buffer(it, end);
		}

		iterator(const iterator &) = default;
		iterator(iterator &&) = default;

		iterator & operator=(const iterator &) = default;
		iterator & operator=(iterator &&) = default;

		constexpr iterator & operator++() noexcept {
			buffer.pop();
			buffer.feed_buffer(it, end);
			return *this;
		}

		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			this->operator++();
			return copy;
		}

		constexpr auto operator*() const noexcept {
			return buffer.front();
		}

		constexpr friend bool operator==(const iterator & lhs, const iterator & rhs) noexcept = default;

		constexpr friend bool operator==(const iterator & self, sentinel) noexcept {
			return self.buffer.empty();
		}
	};

	static_assert(std::input_iterator<iterator<true>>);
	static_assert(std::input_iterator<iterator<false>>);
	static_assert(std::sentinel_for<sentinel, iterator<true>>);
	static_assert(std::sentinel_for<sentinel, iterator<false>>);

	constexpr chunk_of_bits_view(Input _input) noexcept: input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input};
	}

	constexpr auto end() const noexcept {
		return sentinel{};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && AllowPadding) {
		// calculate with blocks
		return ((std::ranges::size(input) + (buffer_t::in_capacity() - 1u)) / buffer_t::in_capacity()) * buffer_t::out_capacity();
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && !AllowPadding) {
		// calculate with bits
		const size_t bit_size_of_input = std::ranges::size(input) * input_value_bit_size;
		return (bit_size_of_input + (output_value_bit_size - 1u)) / output_value_bit_size;
	}
};

template <size_t Bits, bool AllowPadding> struct chunk_of_bits_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, chunk_of_bits_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) {
		return chunk_of_bits_view<Bits, AllowPadding, R>(std::forward<R>(input));
	}
};

template <size_t Bits, bool AllowPadding = false> constexpr auto chunk_of_bits = chunk_of_bits_action<Bits, AllowPadding>{};

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#include <bit>

namespace cthash {

template <typename Encoding> struct encoding_properties {
	static constexpr size_t size = std::size(Encoding::alphabet) - 1u;
	static_assert(std::popcount(size) == 1u, "Size of encoding's alphabet must be power-of-two");

	static constexpr size_t bits = std::countr_zero(size);

	static constexpr bool has_padding = padded_encoding<Encoding>;

	static constexpr char padding = [] {
		if constexpr (has_padding) {
			return Encoding::padding;
		} else {
			return '\0';
		}
	}();
};

template <typename Encoding, typename CharT, typename R> struct encode_to_view {
	using properties = encoding_properties<Encoding>;
	using chunk_view = cthash::chunk_of_bits_view<properties::bits, properties::has_padding, R>;

	struct sentinel {
		[[no_unique_address]] chunk_view::sentinel end;
	};

	template <bool Const> struct iterator {
		using difference_type = intptr_t;
		using value_type = CharT;

		chunk_view::template iterator<Const> it;

		constexpr iterator & operator++() noexcept {
			++it;
			return *this;
		}
		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			++it;
			return copy;
		}

		constexpr value_type operator*() const noexcept {
			const auto tmp = *it;
			if constexpr (!chunk_view::aligned) {
				// TODO: do without condition
				if (tmp.is_padding()) {
					return properties::padding;
				}
			}
			return static_cast<value_type>(Encoding::alphabet[static_cast<unsigned>(tmp.value)]);
		}

		constexpr friend bool operator==(const iterator &, const iterator &) noexcept = default;

		constexpr friend bool operator==(const iterator & lhs, const sentinel & rhs) noexcept {
			return lhs.it == rhs.end;
		}
	};

	chunk_view input;

	constexpr encode_to_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}

	constexpr auto to_string() const requires(std::ranges::sized_range<R>) {
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(*this);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(size());
		auto [i, o] = std::ranges::copy(begin(), end(), result.begin());
		assert(i == result.end());
		assert(o == result.end());
		return result;
#endif
	}

	constexpr friend std::basic_ostream<CharT> & operator<<(std::basic_ostream<CharT> & out, encode_to_view in) {
		std::ranges::copy(in.begin(), in.end(), std::ostream_iterator<CharT, CharT>(out));
		return out;
	}
};

template <typename Encoding, typename ValueT, typename R> struct decode_from_view {
	R input;

	template <bool Const> struct iterator { };
	struct sentinel { };

	constexpr decode_from_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}
};

template <typename Encoding, typename CharT = char> struct encode_to_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, encode_to_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return encode_to_view<Encoding, CharT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename ValueT = unsigned char> struct decode_from_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, decode_from_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return decode_from_view<Encoding, ValueT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename CharT = char> constexpr auto encode_to = encode_to_action<Encoding, CharT>{};
template <typename Encoding, typename ValueT = unsigned char> constexpr auto decode_from = decode_from_action<Encoding, ValueT>{};

constexpr auto binary_encode = encode_to<encoding::base2, char>;
constexpr auto base2_encode = encode_to<encoding::base2, char>;
constexpr auto base4_encode = encode_to<encoding::base4, char>;
constexpr auto base8_encode = encode_to<encoding::base8, char>;
constexpr auto octal_encode = encode_to<encoding::base8, char>;
constexpr auto hexdec_encode = encode_to<encoding::base16, char>;
constexpr auto hexdec_uppercase_encode = encode_to<encoding::base16_uppercase, char>;
constexpr auto base16_encode = encode_to<encoding::base16, char>;
constexpr auto base32_encode = encode_to<encoding::base32, char>;
constexpr auto base32_no_padding_encode = encode_to<encoding::base32_no_padding, char>;
constexpr auto z_base32_encode = encode_to<encoding::z_base32, char>;
constexpr auto base64_encode = encode_to<encoding::base64, char>;
constexpr auto base64url_encode = encode_to<encoding::base64url, char>;
constexpr auto base64_no_padding_encode = encode_to<encoding::base64_no_padding, char>;

constexpr auto binary_decode = decode_from<encoding::base2, char>;
constexpr auto base2_decode = decode_from<encoding::base2, char>;
constexpr auto base4_decode = decode_from<encoding::base4, char>;
constexpr auto base8_decode = decode_from<encoding::base8, char>;
constexpr auto hexdec_decode = decode_from<encoding::base16, char>;
constexpr auto base16_decode = decode_from<encoding::base16, char>;
constexpr auto base32_decode = decode_from<encoding::base32, char>;
constexpr auto z_base32_decode = decode_from<encoding::z_base32, char>;
constexpr auto base64_decode = decode_from<encoding::base64, char>;
constexpr auto base64url_decode = decode_from<encoding::base64url, char>;
constexpr auto base64_no_padding_decode = decode_from<encoding::base64_no_padding, char>;

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

// template <typename Encoding, typename CharT, typename R> struct encode_to_view

#ifdef CTHASH_STDFMT_AVAILABLE
template <typename Encoding, typename R, typename CharT>
struct formatter<cthash::encode_to_view<Encoding, CharT, R>, CharT> {
	using subject_type = cthash::encode_to_view<Encoding, CharT, R>;

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		return std::ranges::begin(ctx);
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return std::ranges::copy(value, ctx.out()).out;
	}
};

#endif

} // namespace std

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_ALGORITHM_HPP
#define CTHASH_INTERNAL_ALGORITHM_HPP

#include <numeric>
#include <compare>
#include <cstddef>
#include <cstdint>

namespace cthash::internal {

template <typename It1, typename It2> constexpr auto threeway_compare_of_same_size(It1 lhs, It2 rhs, size_t length) -> std::strong_ordering {
	for (size_t i = 0; i != length; ++i) {
		if (const auto r = (*lhs++ <=> *rhs++); std::is_neq(r)) {
			return r;
		}
	}

	return std::strong_ordering::equal;
}

template <typename T, typename It1, typename It2, typename Stream> constexpr auto & push_to_stream_as(It1 f, It2 l, Stream & stream) {
	constexpr auto cast_and_shift = [](Stream * s, const auto & rhs) { (*s) << T{rhs}; return s; };
	return *std::accumulate(f, l, &stream, cast_and_shift);
}

} // namespace cthash::internal

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_HEXDEC_HPP
#define CTHASH_INTERNAL_HEXDEC_HPP

#include <array>
#include <ostream>
#include <span>
#include <type_traits>
#include <cstdint>

namespace cthash::internal {

consteval auto get_hexdec_table() noexcept {
	std::array<uint8_t, 128> result;

	auto char_to_hexdec = [](char c) {
		if (c >= '0' && c <= '9') {
			return static_cast<uint8_t>(c - '0');
		} else if (c >= 'a' && c <= 'f') {
			return static_cast<uint8_t>(c - 'a' + 10);
		} else if (c >= 'A' && c <= 'F') {
			return static_cast<uint8_t>(c - 'A' + 10);
		} else {
			return static_cast<uint8_t>(0);
		}
	};

	for (size_t i = 0; i != result.size(); ++i) {
		result[i] = char_to_hexdec(static_cast<char>(i));
	}

	return result;
}

constexpr auto hexdec_to_value_alphabet = get_hexdec_table();

template <typename CharT> constexpr auto value_to_hexdec_alphabet = std::array<CharT, 16>{CharT('0'), CharT('1'), CharT('2'), CharT('3'), CharT('4'), CharT('5'), CharT('6'), CharT('7'), CharT('8'), CharT('9'), CharT('a'), CharT('b'), CharT('c'), CharT('d'), CharT('e'), CharT('f')};

struct byte_hexdec_value {
	std::byte val;

	template <typename CharT, typename Traits> friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, byte_hexdec_value rhs) {
		return os << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val >> 4u)] << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val) & 0b1111u];
	}
};

template <size_t N, typename CharT> constexpr auto hexdec_to_binary(std::span<const CharT, N * 2> in) -> std::array<std::byte, N> {
	return [in]<size_t... Idx>(std::index_sequence<Idx...>) {
		return std::array<std::byte, N>{static_cast<std::byte>(hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2]) & 0b0111'1111u] << 4u | hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2u + 1u]) & 0b0111'1111u])...};
	}(std::make_index_sequence<N>());
}

template <typename CharT, size_t N>
requires((N - 1) % 2 == 0) // -1 because of zero terminator in literals
constexpr auto literal_hexdec_to_binary(const CharT (&in)[N]) -> std::array<std::byte, (N - 1) / 2> {
	return hexdec_to_binary<N / 2>(std::span<const char, N - 1>(in, N - 1));
}

} // namespace cthash::internal

#endif

#include <algorithm>
#include <array>
#include <format>
#include <span>
#include <string_view>
#include <compare>

namespace cthash {

// hash_value

template <size_t N> struct hash_value: std::array<std::byte, N> {
	using super = std::array<std::byte, N>;

	constexpr hash_value() noexcept: super{} { }
	explicit constexpr hash_value(super && s) noexcept: super(s) { }
	template <typename CharT> explicit constexpr hash_value(const CharT (&in)[N * 2u + 1u]) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in, N * 2u))} { }
	template <typename CharT> explicit constexpr hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in.data(), in.size()))} { }

	// comparison support
	constexpr friend bool operator==(const hash_value & lhs, const hash_value & rhs) noexcept = default;
	constexpr friend auto operator<=>(const hash_value & lhs, const hash_value & rhs) noexcept -> std::strong_ordering {
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), N);
	}

	template <typename Encoding = cthash::encoding::hexdec, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		auto hexdec_view = *this | cthash::encode_to<Encoding, CharT>;
		std::ranges::copy(hexdec_view, std::ostream_iterator<CharT, CharT>(os));
		return os;
	}

	// print to ostream support
	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const hash_value & val) {
		return val.print_into(os);
	}

	template <size_t PrefixN> constexpr auto prefix() const noexcept requires(PrefixN <= N) {
		hash_value<PrefixN> output{};
		std::ranges::copy(this->begin(), this->begin() + PrefixN, output.begin());
		return output;
	}

	template <size_t SuffixN> constexpr auto suffix() const noexcept requires(SuffixN <= N) {
		hash_value<SuffixN> output{};
		std::ranges::copy(this->end() - SuffixN, this->end(), output.begin());
		return output;
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(encoded);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(encoded.size());
		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());
		return result;
#endif
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_fixed_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
		// it's type dependendent so we can calculate the size...
		constexpr size_t size_needed = (hash_value{} | cthash::encode_to<Encoding, CharT>).size();

		auto result = cthash::fixed_string<CharT, size_needed>{nullptr};

		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());

		return result;
	}
};

template <typename CharT, size_t N> hash_value(const CharT (&)[N]) -> hash_value<(N - 1u) / 2u>;
template <typename CharT, size_t N> hash_value(std::span<const CharT, N>) -> hash_value<N / 2u>;
template <typename CharT, size_t N> hash_value(const fixed_string<CharT, N> &) -> hash_value<N / 2u>;

template <typename> struct default_encoding {
	using encoding = cthash::encoding::hexdec;
};

template <typename Tag> concept tag_with_encoding = requires() {
	typename Tag::encoding;
};

template <tag_with_encoding Tag> struct default_encoding<Tag> {
	using encoding = Tag::encoding;
};

template <typename Tag, size_t = internal::digest_bytes_length_of<Tag>> struct tagged_hash_value: hash_value<internal::digest_bytes_length_of<Tag>> {
	static constexpr size_t N = internal::digest_bytes_length_of<Tag>;

	using super = hash_value<N>;
	using super::super;
	template <typename CharT> explicit constexpr tagged_hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{in} { }

	static constexpr size_t digest_length = N;

	template <typename Encoding = default_encoding<Tag>::encoding, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		return super::template print_into<Encoding>(os);
	}

	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const tagged_hash_value & val) {
		return val.print_into(os);
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_string(const tagged_hash_value & value) {
		return to_string<Encoding, CharT>(static_cast<const super &>(value));
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_fixed_string(const tagged_hash_value & value) {
		return to_fixed_string<Encoding, CharT>(static_cast<const super &>(value));
	}
};

template <typename T> concept variable_digest_length = T::digest_length_bit == 0u;

template <size_t N, variable_digest_length Tag> struct variable_bit_length_tag: Tag {
	static constexpr size_t digest_length_bit = N;
};

template <typename T> concept convertible_to_tagged_hash_value = requires(const T & obj) {
	{ tagged_hash_value{obj} };
};

namespace literals {

	template <fixed_string Value>
	constexpr auto operator""_hash() {
		return hash_value(Value);
	}

} // namespace literals

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#if _LIBCPP_VERSION >= 170000
// libc++ will define __cpp_lib_format macro in 19.0
// https://github.com/llvm/llvm-project/issues/77773
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#ifdef CTHASH_STDFMT_AVAILABLE
template <size_t N, typename CharT>
struct formatter<cthash::hash_value<N>, CharT> {
	using subject_type = cthash::hash_value<N>;
	using default_encoding = cthash::encoding::hexdec;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <typename Tag, size_t N, typename CharT>
struct formatter<cthash::tagged_hash_value<Tag, N>, CharT> {
	using subject_type = cthash::tagged_hash_value<Tag, N>;
	using default_encoding = typename cthash::default_encoding<Tag>::encoding;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <cthash::convertible_to_tagged_hash_value Type, typename CharT> struct formatter<Type, CharT>: formatter<decltype(cthash::tagged_hash_value{std::declval<Type>()}), CharT> {
};

#endif

} // namespace std

#endif

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_CONVERT_HPP
#define CTHASH_INTERNAL_CONVERT_HPP

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#include <span>
#include <type_traits>
#include <cstddef>
#include <cstdint>
#include <cstring>

namespace cthash {

template <typename It1, typename It2, typename It3> constexpr auto byte_copy(It1 first, It2 last, It3 destination) {
	return std::transform(first, last, destination, [](byte_like auto v) { return static_cast<std::byte>(v); });
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << ((sizeof(T) - 1u - Idx) * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::little) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_le_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << static_cast<T>(Idx * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::big) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T> struct unwrap_littleendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> (Idx * 8u))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_littleendian_number(std::span<std::byte, 8>) -> unwrap_littleendian_number<uint64_t>;
unwrap_littleendian_number(std::span<std::byte, 4>) -> unwrap_littleendian_number<uint32_t>;

template <std::unsigned_integral T> struct unwrap_bigendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> ((bits - 8u) - 8u * Idx))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_bigendian_number(std::span<std::byte, 8>) -> unwrap_bigendian_number<uint64_t>;
unwrap_bigendian_number(std::span<std::byte, 4>) -> unwrap_bigendian_number<uint32_t>;

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#include <algorithm>
#include <array>
#include <span>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <typename Config> struct internal_hasher {
	static constexpr auto config = Config{};
	static constexpr size_t block_size_bytes = config.block_bits / 8u;
	static constexpr size_t digest_bytes = internal::digest_bytes_length_of<Config>;

	// internal types
	using state_value_t = std::remove_cvref_t<decltype(Config::initial_values)>;
	using state_item_t = typename state_value_t::value_type;

	using block_value_t = std::array<std::byte, block_size_bytes>;
	using block_view_t = std::span<const std::byte, block_size_bytes>;

	using staging_item_t = typename decltype(config.constants)::value_type;
	static constexpr size_t staging_size = config.constants.size();
	using staging_value_t = std::array<staging_item_t, staging_size>;
	using staging_view_t = std::span<const staging_item_t, staging_size>;

	using digest_span_t = std::span<std::byte, digest_bytes>;
	using result_t = cthash::tagged_hash_value<Config>;
	using length_t = typename Config::length_type;

	// internal state
	state_value_t hash;
	length_t total_length;

	block_value_t block;
	unsigned block_used;

	// constructors
	constexpr internal_hasher() noexcept: hash{config.initial_values}, total_length{0u}, block_used{0u} { }
	constexpr internal_hasher(const internal_hasher &) noexcept = default;
	constexpr internal_hasher(internal_hasher &&) noexcept = default;
	constexpr ~internal_hasher() noexcept = default;

	// take buffer and build staging
	template <byte_like Byte> [[gnu::always_inline]] static constexpr auto build_staging(std::span<const Byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		staging_value_t w;

		constexpr auto first_part_size = block_size_bytes / sizeof(staging_item_t);

		// fill first part with chunk
		for (int i = 0; i != int(first_part_size); ++i) {
			w[static_cast<size_t>(i)] = cast_from_bytes<staging_item_t>(chunk.subspan(static_cast<size_t>(i) * sizeof(staging_item_t)).template first<sizeof(staging_item_t)>());
		}

		// fill the rest (generify)
		for (int i = int(first_part_size); i != int(staging_size); ++i) {
			w[static_cast<size_t>(i)] = w[static_cast<size_t>(i - 16)] + config.sigma_0(w[static_cast<size_t>(i - 15)]) + w[static_cast<size_t>(i - 7)] + config.sigma_1(w[static_cast<size_t>(i - 2)]);
		}

		return w;
	}

	[[gnu::always_inline]] static constexpr auto build_staging(std::span<const std::byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		return build_staging<std::byte>(chunk);
	}

	[[gnu::always_inline]] static constexpr void rounds(staging_view_t w, state_value_t & state) noexcept {
		config.rounds(w, state);
	}

	// this implementation works only with input size aligned to bytes (not bits)
	template <byte_like T> [[gnu::always_inline]] constexpr void update_to_buffer_and_process(std::span<const T> in) noexcept {
		// if block is not used, we can build staging directly
		if (block_used) {
			const auto remaining_free_space = std::span<std::byte, block_size_bytes>(block).subspan(block_used);
			const auto to_copy = in.first(std::min(in.size(), remaining_free_space.size()));

			const auto it = byte_copy(to_copy.begin(), to_copy.end(), remaining_free_space.begin());
			total_length += to_copy.size();

			// we didn't fill the block
			if (it != remaining_free_space.end()) {
				assert(to_copy.size() == in.size());
				block_used += static_cast<unsigned>(to_copy.size());
				return;
			} else {
				block_used = 0u;
			}

			// we have block!
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// remove part we processed
			in = in.subspan(to_copy.size());
		}

		// do the work over blocks without copy
		if (not block_used) {
			while (in.size() >= block_size_bytes) {
				const auto local_block = in.template first<block_size_bytes>();
				total_length += block_size_bytes;

				const staging_value_t w = build_staging<T>(local_block);
				rounds(w, hash);

				// remove part we processed
				in = in.subspan(block_size_bytes);
			}
		}

		// remainder is put onto temporary block
		if (not in.empty()) {
			assert(block_used == 0u);
			assert(in.size() < block_size_bytes);

			// copy it to block and let it stay there
			byte_copy(in.begin(), in.end(), block.begin());
			block_used = static_cast<unsigned>(in.size());
			total_length += block_used;
		}
	}

	[[gnu::always_inline]] static constexpr bool finalize_buffer(block_value_t & block, size_t block_used) noexcept {
		assert(block_used < block.size());
		const auto free_space = std::span(block).subspan(block_used);

		auto it = free_space.data();
		*it++ = std::byte{0b1000'0000u};							   // first byte after data contains bit at MSB
		std::fill(it, (block.data() + block.size()), std::byte{0x0u}); // rest is filled with zeros

		// we don't have enough space to write length bits
		return free_space.size() < (1u + (config.length_size_bits / 8u));
	}

	[[gnu::always_inline]] static constexpr void finalize_buffer_by_writing_length(block_value_t & block, length_t total_length) noexcept {
		unwrap_bigendian_number{std::span(block).template last<sizeof(length_t)>()} = (total_length * 8u);
	}

	[[gnu::always_inline]] constexpr void finalize() noexcept {
		if (finalize_buffer(block, block_used)) {
			// we didn't have enough space, we need to process block
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// zero it out
			std::fill(block.begin(), block.end(), std::byte{0x0u});
		}

		// we either have space to write or we have zerod out block
		finalize_buffer_by_writing_length(block, total_length);

		// calculate last round
		const staging_value_t w = build_staging(block);
		rounds(w, hash);
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) == 0u)
	{
		// copy result to byte result
		constexpr size_t values_for_output = digest_bytes / sizeof(state_item_t);
		static_assert(values_for_output <= config.initial_values.size());

		for (int i = 0; i != values_for_output; ++i) {
			unwrap_bigendian_number<state_item_t>{out.subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) != 0u)
	{
		// this is only used when digest doesn't align with output buffer

		// make sure digest size is smaller than hash state
		static_assert(digest_bytes <= config.initial_values.size() * sizeof(state_item_t));

		// copy result to byte result
		std::array<std::byte, sizeof(state_item_t) * config.initial_values.size()> tmp_buffer;

		for (int i = 0; i != (int)config.initial_values.size(); ++i) {
			unwrap_bigendian_number<state_item_t>{std::span(tmp_buffer).subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}

		std::copy_n(tmp_buffer.data(), digest_bytes, out.data());
	}
};

// this is a convinience type for nicer UX...
template <typename Config> struct hasher: private internal_hasher<Config> {
	using super = internal_hasher<Config>;
	using result_t = typename super::result_t;
	using length_t = typename super::length_t;
	using digest_span_t = typename super::digest_span_t;

	constexpr hasher() noexcept: super() { }
	constexpr hasher(const hasher &) noexcept = default;
	constexpr hasher(hasher &&) noexcept = default;
	constexpr ~hasher() noexcept = default;

	// support for various input types
	constexpr hasher & update(std::span<const std::byte> input) noexcept {
		super::update_to_buffer_and_process(input);
		return *this;
	}

	template <convertible_to_byte_span T> constexpr hasher & update(const T & something) noexcept {
		using value_type = typename decltype(std::span(something))::value_type;
		super::update_to_buffer_and_process(std::span<const value_type>(something));
		return *this;
	}

	template <one_byte_char CharT> constexpr hasher & update(std::basic_string_view<CharT> in) noexcept {
		super::update_to_buffer_and_process(std::span(in.data(), in.size()));
		return *this;
	}

	template <string_literal T> constexpr hasher & update(const T & lit) noexcept {
		super::update_to_buffer_and_process(std::span(lit, std::size(lit) - 1u));
		return *this;
	}

	// TODO: any range with value convertible to byte

	// output (by reference or by value)
	constexpr void final(digest_span_t digest) noexcept {
		super::finalize();
		super::write_result_into(digest);
	}

	constexpr auto final() noexcept {
		result_t output;
		this->final(output);
		return output;
	}

	constexpr length_t size() const noexcept {
		return super::total_length;
	}
};

} // namespace cthash

#endif

#include <array>
#include <span>
#include <concepts>
#include <cstdint>

namespace cthash::sha2 {

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto choice(T e, T f, T g) noexcept -> T {
	return (e bitand f) xor (~e bitand g);
}

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto majority(T a, T b, T c) noexcept -> T {
	return (a bitand b) xor (a bitand c) xor (b bitand c);
}

template <typename Config, typename StageT, size_t StageLength, typename StateT, size_t StateLength>
[[gnu::always_inline]] constexpr void rounds(std::span<const StageT, StageLength> w, std::array<StateT, StateLength> & state) noexcept {
	using state_t = std::array<StateT, StateLength>;

	// create copy of internal state
	auto wvar = state_t(state);

	// just give them names
	auto & [a, b, c, d, e, f, g, h] = wvar;

	// number of rounds is same as constants
	static_assert(StageLength == Config::constants.size());

	for (int i = 0; i != Config::constants.size(); ++i) {
		const auto temp1 = h + Config::sum_e(e) + choice(e, f, g) + Config::constants[static_cast<size_t>(i)] + w[static_cast<size_t>(i)];
		const auto temp2 = Config::sum_a(a) + majority(a, b, c);

		// move around (that's rotate)
		std::rotate(wvar.begin(), wvar.begin() + 7u, wvar.end());

		e += temp1;
		a = temp1 + temp2;

		// originally it was:
		// h = g;
		// g = f;
		// f = e;
		// e = d + temp1;
		// d = c;
		// c = b;
		// b = a;
		// a = temp1 + temp2;
	}

	// add store back
	for (int i = 0; i != (int)state.size(); ++i) {
		state[static_cast<size_t>(i)] += wvar[static_cast<size_t>(i)];
	}
}

} // namespace cthash::sha2

#endif

namespace cthash {

struct sha512_config {
	using length_type = uint64_t;
	static constexpr size_t length_size_bits = 128;

	static constexpr size_t block_bits = 1024u;

	static constexpr auto initial_values = std::array<uint64_t, 8>{0x6a09e667f3bcc908ull, 0xbb67ae8584caa73bull, 0x3c6ef372fe94f82bull, 0xa54ff53a5f1d36f1ull, 0x510e527fade682d1ull, 0x9b05688c2b3e6c1full, 0x1f83d9abfb41bd6bull, 0x5be0cd19137e2179ull};

	// staging functions
	[[gnu::always_inline]] static constexpr auto sigma_0(uint64_t w_15) noexcept -> uint64_t {
		return std::rotr(w_15, 1u) xor std::rotr(w_15, 8u) xor (w_15 >> 7u);
	}

	[[gnu::always_inline]] static constexpr auto sigma_1(uint64_t w_2) noexcept -> uint64_t {
		return std::rotr(w_2, 19u) xor std::rotr(w_2, 61u) xor (w_2 >> 6u);
	}

	// rounds constants...
	static constexpr auto constants = std::array<uint64_t, 80>{
		0x428a2f98d728ae22ull, 0x7137449123ef65cdull, 0xb5c0fbcfec4d3b2full, 0xe9b5dba58189dbbcull, 0x3956c25bf348b538ull,
		0x59f111f1b605d019ull, 0x923f82a4af194f9bull, 0xab1c5ed5da6d8118ull, 0xd807aa98a3030242ull, 0x12835b0145706fbeull,
		0x243185be4ee4b28cull, 0x550c7dc3d5ffb4e2ull, 0x72be5d74f27b896full, 0x80deb1fe3b1696b1ull, 0x9bdc06a725c71235ull,
		0xc19bf174cf692694ull, 0xe49b69c19ef14ad2ull, 0xefbe4786384f25e3ull, 0x0fc19dc68b8cd5b5ull, 0x240ca1cc77ac9c65ull,
		0x2de92c6f592b0275ull, 0x4a7484aa6ea6e483ull, 0x5cb0a9dcbd41fbd4ull, 0x76f988da831153b5ull, 0x983e5152ee66dfabull,
		0xa831c66d2db43210ull, 0xb00327c898fb213full, 0xbf597fc7beef0ee4ull, 0xc6e00bf33da88fc2ull, 0xd5a79147930aa725ull,
		0x06ca6351e003826full, 0x142929670a0e6e70ull, 0x27b70a8546d22ffcull, 0x2e1b21385c26c926ull, 0x4d2c6dfc5ac42aedull,
		0x53380d139d95b3dfull, 0x650a73548baf63deull, 0x766a0abb3c77b2a8ull, 0x81c2c92e47edaee6ull, 0x92722c851482353bull,
		0xa2bfe8a14cf10364ull, 0xa81a664bbc423001ull, 0xc24b8b70d0f89791ull, 0xc76c51a30654be30ull, 0xd192e819d6ef5218ull,
		0xd69906245565a910ull, 0xf40e35855771202aull, 0x106aa07032bbd1b8ull, 0x19a4c116b8d2d0c8ull, 0x1e376c085141ab53ull,
		0x2748774cdf8eeb99ull, 0x34b0bcb5e19b48a8ull, 0x391c0cb3c5c95a63ull, 0x4ed8aa4ae3418acbull, 0x5b9cca4f7763e373ull,
		0x682e6ff3d6b2b8a3ull, 0x748f82ee5defb2fcull, 0x78a5636f43172f60ull, 0x84c87814a1f0ab72ull, 0x8cc702081a6439ecull,
		0x90befffa23631e28ull, 0xa4506cebde82bde9ull, 0xbef9a3f7b2c67915ull, 0xc67178f2e372532bull, 0xca273eceea26619cull,
		0xd186b8c721c0c207ull, 0xeada7dd6cde0eb1eull, 0xf57d4f7fee6ed178ull, 0x06f067aa72176fbaull, 0x0a637dc5a2c898a6ull,
		0x113f9804bef90daeull, 0x1b710b35131c471bull, 0x28db77f523047d84ull, 0x32caab7b40c72493ull, 0x3c9ebe0a15c9bebcull,
		0x431d67c49c100d4cull, 0x4cc5d4becb3e42b6ull, 0x597f299cfc657e2aull, 0x5fcb6fab3ad6faecull, 0x6c44198c4a475817ull};

	[[gnu::always_inline]] static constexpr auto sum_a(uint64_t a) noexcept -> uint64_t {
		return std::rotr(a, 28u) xor std::rotr(a, 34u) xor std::rotr(a, 39u);
	}

	[[gnu::always_inline]] static constexpr auto sum_e(uint64_t e) noexcept -> uint64_t {
		return std::rotr(e, 14u) xor std::rotr(e, 18u) xor std::rotr(e, 41u);
	}

	// rounds
	[[gnu::always_inline]] static constexpr void rounds(std::span<const uint64_t, 80> w, std::array<uint64_t, 8> & state) noexcept {
		return sha2::rounds<sha512_config>(w, state);
	}
};

static_assert(not cthash::internal::digest_length_provided<sha512_config>);
static_assert(cthash::internal::digest_bytes_length_of<sha512_config> == 64u);

using sha512 = hasher<sha512_config>;
using sha512_value = tagged_hash_value<sha512_config>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_sha512() {
		return sha512_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

namespace cthash {

struct sha384_config: sha512_config {
	static constexpr size_t digest_length = 48u;

	static constexpr auto initial_values = std::array<uint64_t, 8>{0xcbbb9d5dc1059ed8ull, 0x629a292a367cd507ull, 0x9159015a3070dd17ull, 0x152fecd8f70e5939ull, 0x67332667ffc00b31ull, 0x8eb44a8768581511ull, 0xdb0c2e0d64f98fa7ull, 0x47b5481dbefa4fa4ull};
};

static_assert(cthash::internal::digest_length_provided<sha384_config>);
static_assert(cthash::internal::digest_bytes_length_of<sha384_config> == 48u);

using sha384 = hasher<sha384_config>;
using sha384_value = tagged_hash_value<sha384_config>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_sha384() {
		return sha384_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

#ifndef CTHASH_SHA2_SHA512_HPP
#define CTHASH_SHA2_SHA512_HPP

#ifndef CTHASH_SHA2_COMMON_HPP
#define CTHASH_SHA2_COMMON_HPP

#ifndef CONSTEXPR_SHA2_HASHER_HPP
#define CONSTEXPR_SHA2_HASHER_HPP

#ifndef CTHASH_SIMPLE_HPP
#define CTHASH_SIMPLE_HPP

#include <utility>

namespace cthash {

template <typename Hasher, typename In, typename... Args> concept hasher_like = requires(Hasher & h, const In & in, Args &&... args) //
{
	{ Hasher{std::forward<Args>(args)...} };
	{ h.update(in) } -> std::same_as<Hasher &>;
	{ h.final() };
};

template <typename Hasher, typename In> concept direct_hasher = requires(Hasher & h, const In & in) //
{
	{ h.update_and_final(in) };
};

template <typename Hasher, typename T, typename... Args>
requires hasher_like<Hasher, T, Args...>
constexpr auto simple(const T & value, Args &&... args) noexcept {
	if constexpr (direct_hasher<Hasher, T>) {
		return Hasher{std::forward<Args>(args)...}.update_and_final(value);
	} else {
		return Hasher{std::forward<Args>(args)...}.update(value).final();
	}
}

} // namespace cthash

#endif

#ifndef CTHASH_VALUE_HPP
#define CTHASH_VALUE_HPP

#ifndef CTHASH_FIXED_STRING_HPP
#define CTHASH_FIXED_STRING_HPP

#include <algorithm>
#include <span>
#include <string_view>

namespace cthash {

template <typename CharT, size_t N> struct fixed_string: std::array<CharT, N> {
	using super = std::array<CharT, N>;

	consteval static auto from_string_literal(const CharT (&in)[N + 1]) -> std::array<CharT, N> {
		std::array<CharT, N> out;
		std::copy_n(in, N, out.data());
		return out;
	}

	explicit constexpr fixed_string(std::nullptr_t) noexcept: super{} { }

	consteval fixed_string(const CharT (&in)[N + 1]) noexcept: super{from_string_literal(in)} { }

	using super::data;
	using super::size;

	constexpr operator std::span<const CharT, N>() const noexcept {
		return std::span<const CharT, N>(data(), size());
	}

	constexpr operator std::span<const CharT>() const noexcept {
		return std::span<const CharT>(data(), size());
	}

	constexpr operator std::basic_string_view<CharT>() const noexcept {
		return std::basic_string_view<CharT>(data(), size());
	}

	constexpr friend bool operator==(const fixed_string &, const fixed_string &) noexcept = default;
	constexpr friend bool operator==(const fixed_string & lhs, std::basic_string_view<CharT> rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == rhs;
	}
	constexpr friend bool operator==(const fixed_string & lhs, const CharT * rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == std::basic_string_view<CharT>{rhs};
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N - 1>;

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_BASE_HPP
#define CTHASH_ENCODING_BASE_HPP

#ifndef CTHASH_ENCODING_CHUNK_OF_BITS_HPP
#define CTHASH_ENCODING_CHUNK_OF_BITS_HPP

#ifndef CTHASH_ENCODING_BIT_BUFFER_HPP
#define CTHASH_ENCODING_BIT_BUFFER_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <bit>
#include <iostream>
#include <numeric>
#include <ranges>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct select_bit_integer;

template <size_t Bits> requires(Bits <= 8) struct select_bit_integer<Bits> {
	using type = uint8_t;
};

template <size_t Bits> requires(Bits > 8 && Bits <= 16) struct select_bit_integer<Bits> {
	using type = uint16_t;
};

template <size_t Bits> requires(Bits > 16 && Bits <= 32) struct select_bit_integer<Bits> {
	using type = uint32_t;
};

template <size_t Bits> requires(Bits > 32 && Bits <= 64) struct select_bit_integer<Bits> {
	using type = uint64_t;
};

template <size_t Bits> using select_bit_integer_t = select_bit_integer<Bits>::type;

template <size_t V> requires(std::popcount(V) == 1u) constexpr auto log2_of_power_of_2 = static_cast<size_t>(std::countr_zero(V));

template <size_t Bits> constexpr auto mask = static_cast<select_bit_integer_t<Bits>>((static_cast<select_bit_integer_t<Bits>>(1u) << Bits) - 1u);

template <size_t Capacity> class basic_bit_buffer {
public:
	static constexpr auto capacity = std::integral_constant<size_t, Capacity>{};
	using storage_type = select_bit_integer_t<capacity()>;
	using size_type = select_bit_integer_t<log2_of_power_of_2<std::bit_ceil(capacity())>>;

public:
	storage_type buffer{0};
	size_type bits_available{0};

public:
	template <size_t Bits> static constexpr auto mask = static_cast<storage_type>((static_cast<storage_type>(1u) << Bits) - 1u);

	constexpr friend bool operator==(const basic_bit_buffer & lhs, const basic_bit_buffer & rhs) noexcept = default;

	constexpr size_type size() const noexcept {
		return bits_available;
	}

	constexpr size_type unused_size() const noexcept {
		return capacity() - bits_available;
	}

	constexpr bool empty() const noexcept {
		return bits_available == 0u;
	}

	constexpr bool full() const noexcept {
		return bits_available == capacity();
	}

	template <size_t Bits> constexpr void push(select_bit_integer_t<Bits> in) noexcept requires(Bits <= capacity()) {
		assert(size() <= capacity() - Bits);
		buffer = static_cast<storage_type>(buffer << Bits) | static_cast<storage_type>(in);
		bits_available += static_cast<size_type>(Bits);
	}
	constexpr void push_empty_bits(size_t count) noexcept {
		buffer = static_cast<storage_type>(buffer << count);
		bits_available += static_cast<unsigned char>(count);
	}

	template <size_t Bits> constexpr void pop() noexcept requires(Bits <= capacity()) {
		assert(size() >= Bits);
		bits_available -= static_cast<size_type>(Bits);
	}

	template <size_t Bits> constexpr auto front() const noexcept -> select_bit_integer_t<Bits> requires(Bits <= capacity()) {
		using output_type = select_bit_integer_t<Bits>;
		assert(size() >= static_cast<size_type>(Bits));
		return static_cast<output_type>((buffer >> (bits_available - Bits))) & mask<Bits>;
	}
};

constexpr size_t calculate_padding_bit_count(size_t number_of_bits_in_buffer, size_t output_size, size_t input_size) {
	size_t n = number_of_bits_in_buffer;
	size_t padding_bits = 0u;

	while (n != 0u) {
		padding_bits += input_size;
		n += input_size;

		while (n >= output_size) {
			n = n - output_size;
		}
	}

	return padding_bits;
}

template <size_t OutBits, size_t InBits = 8u> class bit_buffer: protected basic_bit_buffer<std::lcm(OutBits, InBits)> {
	using super = basic_bit_buffer<std::lcm(OutBits, InBits)>;

public:
	constexpr bit_buffer() noexcept = default;

	using typename super::size_type;
	static constexpr auto out_bits = std::integral_constant<size_type, OutBits>{};
	static constexpr auto in_bits = std::integral_constant<size_type, InBits>{};

	using out_type = select_bit_integer_t<OutBits>;
	using in_type = select_bit_integer_t<InBits>;

	using super::capacity;
	static constexpr auto in_capacity = std::integral_constant<size_type, (capacity() / in_bits())>{};
	static constexpr auto out_capacity = std::integral_constant<size_type, (capacity() / out_bits())>{};

	static constexpr auto aligned = std::bool_constant<capacity() == in_capacity()>{};

	constexpr void push(in_type in) noexcept {
		super::template push<in_bits>(in);
	}

	constexpr void push_empty() noexcept {
		this->push(in_type{0u});
	}

	constexpr size_type push_zeros_to_align() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_to_align() noexcept requires(!aligned()) {
		if (empty()) {
			return 0u;
		}

		assert(out_bits > super::size());
		const size_type missing_bits = static_cast<size_type>(out_bits - super::size());
		super::push_empty_bits(missing_bits);
		return missing_bits;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(!aligned()) {
		const size_type usable_bits = super::size();
		const size_type missing_bits = static_cast<size_type>(calculate_padding_bit_count(super::size(), out_bits, in_bits));
		super::push_empty_bits(missing_bits);
		return usable_bits;
	}

	constexpr void pop() noexcept {
		super::template pop<out_bits>();
	}

	constexpr auto front() const noexcept -> out_type {
		return super::template front<out_bits>();
	}

	constexpr size_type size() const noexcept {
		return static_cast<size_type>(super::size() / out_bits);
	}

	constexpr size_type unused_size() const noexcept {
		return static_cast<size_type>(super::unused_size() / in_bits);
	}

	using super::empty;
	using super::full;

	constexpr bool has_bits_for_pop() const noexcept {
		return super::size() >= out_bits;
	}

	constexpr bool has_capacity_for_push() const noexcept {
		return super::size() <= (capacity() - in_bits);
	}
};

} // namespace cthash

#endif

#include <iostream>
#include <ranges>

namespace cthash {

template <typename Buffer> struct buffer_result_type;

template <typename Buffer> requires(Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	static constexpr Buffer::size_type missing_bits = {0u};

	constexpr bool is_padding() const noexcept {
		return false;
	}
};

template <typename Buffer> requires(!Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	typename Buffer::size_type missing_bits;

	constexpr bool is_padding() const noexcept {
		return missing_bits == Buffer::out_bits;
	}
};

template <typename Buffer, bool AllowPadding> struct buffer_with_missing_bits;

template <typename Buffer, bool AllowPadding> requires(Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};

	struct result_type {
		typename Buffer::out_type value;
		static constexpr Buffer::size_type missing_bits = {0u};

		constexpr bool is_padding() const noexcept {
			return false;
		}
	};

	static constexpr bool aligned = Buffer::aligned();

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		return result_type{buffer.front()};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		while (!buffer.has_bits_for_pop() && (it != end)) {
			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <typename Buffer, bool AllowPadding> requires(!Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};
	Buffer::size_type missing_bits{0};

	static constexpr bool aligned = Buffer::aligned();

	struct result_type {
		typename Buffer::out_type value;
		typename Buffer::size_type missing_bits;

		constexpr bool is_padding() const noexcept {
			return missing_bits == Buffer::out_bits;
		}
	};

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		assert(Buffer::out_bits >= missing_bits);
		return result_type{buffer.front(), missing_bits};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	constexpr void pad_buffer() noexcept requires(AllowPadding) {
		// full multi-chunk padding (for baseN encodings)
		missing_bits = (Buffer::out_bits - buffer.push_zeros_for_padding());
	}

	constexpr void pad_buffer() noexcept requires(!AllowPadding) {
		// only add enough zero to finish current output chunk
		missing_bits = buffer.push_zeros_to_align();
	}

	constexpr void saturate_missing_bits() noexcept requires(AllowPadding) {
		if (missing_bits) {
			missing_bits = Buffer::out_bits;
		}
		// missing_bits = static_cast<buffer_size_t>((unsigned)(bool)missing_bits * output_value_bit_size);
	}

	constexpr void saturate_missing_bits() noexcept requires(!AllowPadding) {
		// do nothing :)
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		for (;;) {
			if (it == end) {
				if (buffer.has_bits_for_pop()) {
					// if this is second pass after padding we can mark all bits as missing
					saturate_missing_bits();
				} else {
					// fill remainder of buffer with zeros
					pad_buffer();
				}

				return;
			}

			if (buffer.has_bits_for_pop()) {
				return;
			}

			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <bool Value> struct conditional;

template <> struct conditional<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional<false> {
	template <typename, typename T> using type = T;
};

template <bool Const, typename T> using maybe_const = typename conditional<Const>::template type<const T, T>;

template <typename T> concept integral_like = std::integral<T> || std::same_as<std::byte, T>;

template <size_t Bits, bool AllowPadding, std::ranges::input_range Input> requires integral_like<std::ranges::range_value_t<Input>> struct chunk_of_bits_view {
	using input_value_type = std::ranges::range_value_t<Input>;

	static constexpr size_t output_value_bit_size = Bits;
	static constexpr size_t input_value_bit_size = sizeof(input_value_type) * 8u;
	using buffer_t = cthash::bit_buffer<output_value_bit_size, input_value_bit_size>;
	using buffer_size_t = buffer_t::size_type;
	Input input;

	static constexpr bool aligned = buffer_t::aligned;

	struct sentinel { };

	template <bool Const> struct iterator {
		using parent = maybe_const<Const, Input>;
		using storage_type = buffer_with_missing_bits<buffer_t, AllowPadding>;
		using value_type = storage_type::result_type;
		using difference_type = intptr_t;

		std::ranges::iterator_t<parent> it;
		[[no_unique_address]] std::ranges::sentinel_t<parent> end;

		storage_type buffer{};

		constexpr iterator(parent & p) noexcept: it{std::ranges::begin(p)}, end{std::ranges::end(p)} {
			// initialize
			buffer.feed_buffer(it, end);
		}

		iterator(const iterator &) = default;
		iterator(iterator &&) = default;

		iterator & operator=(const iterator &) = default;
		iterator & operator=(iterator &&) = default;

		constexpr iterator & operator++() noexcept {
			buffer.pop();
			buffer.feed_buffer(it, end);
			return *this;
		}

		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			this->operator++();
			return copy;
		}

		constexpr auto operator*() const noexcept {
			return buffer.front();
		}

		constexpr friend bool operator==(const iterator & lhs, const iterator & rhs) noexcept = default;

		constexpr friend bool operator==(const iterator & self, sentinel) noexcept {
			return self.buffer.empty();
		}
	};

	static_assert(std::input_iterator<iterator<true>>);
	static_assert(std::input_iterator<iterator<false>>);
	static_assert(std::sentinel_for<sentinel, iterator<true>>);
	static_assert(std::sentinel_for<sentinel, iterator<false>>);

	constexpr chunk_of_bits_view(Input _input) noexcept: input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input};
	}

	constexpr auto end() const noexcept {
		return sentinel{};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && AllowPadding) {
		// calculate with blocks
		return ((std::ranges::size(input) + (buffer_t::in_capacity() - 1u)) / buffer_t::in_capacity()) * buffer_t::out_capacity();
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && !AllowPadding) {
		// calculate with bits
		const size_t bit_size_of_input = std::ranges::size(input) * input_value_bit_size;
		return (bit_size_of_input + (output_value_bit_size - 1u)) / output_value_bit_size;
	}
};

template <size_t Bits, bool AllowPadding> struct chunk_of_bits_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, chunk_of_bits_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) {
		return chunk_of_bits_view<Bits, AllowPadding, R>(std::forward<R>(input));
	}
};

template <size_t Bits, bool AllowPadding = false> constexpr auto chunk_of_bits = chunk_of_bits_action<Bits, AllowPadding>{};

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#include <bit>

namespace cthash {

template <typename Encoding> struct encoding_properties {
	static constexpr size_t size = std::size(Encoding::alphabet) - 1u;
	static_assert(std::popcount(size) == 1u, "Size of encoding's alphabet must be power-of-two");

	static constexpr size_t bits = std::countr_zero(size);

	static constexpr bool has_padding = padded_encoding<Encoding>;

	static constexpr char padding = [] {
		if constexpr (has_padding) {
			return Encoding::padding;
		} else {
			return '\0';
		}
	}();
};

template <typename Encoding, typename CharT, typename R> struct encode_to_view {
	using properties = encoding_properties<Encoding>;
	using chunk_view = cthash::chunk_of_bits_view<properties::bits, properties::has_padding, R>;

	struct sentinel {
		[[no_unique_address]] chunk_view::sentinel end;
	};

	template <bool Const> struct iterator {
		using difference_type = intptr_t;
		using value_type = CharT;

		chunk_view::template iterator<Const> it;

		constexpr iterator & operator++() noexcept {
			++it;
			return *this;
		}
		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			++it;
			return copy;
		}

		constexpr value_type operator*() const noexcept {
			const auto tmp = *it;
			if constexpr (!chunk_view::aligned) {
				// TODO: do without condition
				if (tmp.is_padding()) {
					return properties::padding;
				}
			}
			return static_cast<value_type>(Encoding::alphabet[static_cast<unsigned>(tmp.value)]);
		}

		constexpr friend bool operator==(const iterator &, const iterator &) noexcept = default;

		constexpr friend bool operator==(const iterator & lhs, const sentinel & rhs) noexcept {
			return lhs.it == rhs.end;
		}
	};

	chunk_view input;

	constexpr encode_to_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}

	constexpr auto to_string() const requires(std::ranges::sized_range<R>) {
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(*this);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(size());
		auto [i, o] = std::ranges::copy(begin(), end(), result.begin());
		assert(i == result.end());
		assert(o == result.end());
		return result;
#endif
	}

	constexpr friend std::basic_ostream<CharT> & operator<<(std::basic_ostream<CharT> & out, encode_to_view in) {
		std::ranges::copy(in.begin(), in.end(), std::ostream_iterator<CharT, CharT>(out));
		return out;
	}
};

template <typename Encoding, typename ValueT, typename R> struct decode_from_view {
	R input;

	template <bool Const> struct iterator { };
	struct sentinel { };

	constexpr decode_from_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}
};

template <typename Encoding, typename CharT = char> struct encode_to_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, encode_to_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return encode_to_view<Encoding, CharT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename ValueT = unsigned char> struct decode_from_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, decode_from_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return decode_from_view<Encoding, ValueT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename CharT = char> constexpr auto encode_to = encode_to_action<Encoding, CharT>{};
template <typename Encoding, typename ValueT = unsigned char> constexpr auto decode_from = decode_from_action<Encoding, ValueT>{};

constexpr auto binary_encode = encode_to<encoding::base2, char>;
constexpr auto base2_encode = encode_to<encoding::base2, char>;
constexpr auto base4_encode = encode_to<encoding::base4, char>;
constexpr auto base8_encode = encode_to<encoding::base8, char>;
constexpr auto octal_encode = encode_to<encoding::base8, char>;
constexpr auto hexdec_encode = encode_to<encoding::base16, char>;
constexpr auto hexdec_uppercase_encode = encode_to<encoding::base16_uppercase, char>;
constexpr auto base16_encode = encode_to<encoding::base16, char>;
constexpr auto base32_encode = encode_to<encoding::base32, char>;
constexpr auto base32_no_padding_encode = encode_to<encoding::base32_no_padding, char>;
constexpr auto z_base32_encode = encode_to<encoding::z_base32, char>;
constexpr auto base64_encode = encode_to<encoding::base64, char>;
constexpr auto base64url_encode = encode_to<encoding::base64url, char>;
constexpr auto base64_no_padding_encode = encode_to<encoding::base64_no_padding, char>;

constexpr auto binary_decode = decode_from<encoding::base2, char>;
constexpr auto base2_decode = decode_from<encoding::base2, char>;
constexpr auto base4_decode = decode_from<encoding::base4, char>;
constexpr auto base8_decode = decode_from<encoding::base8, char>;
constexpr auto hexdec_decode = decode_from<encoding::base16, char>;
constexpr auto base16_decode = decode_from<encoding::base16, char>;
constexpr auto base32_decode = decode_from<encoding::base32, char>;
constexpr auto z_base32_decode = decode_from<encoding::z_base32, char>;
constexpr auto base64_decode = decode_from<encoding::base64, char>;
constexpr auto base64url_decode = decode_from<encoding::base64url, char>;
constexpr auto base64_no_padding_decode = decode_from<encoding::base64_no_padding, char>;

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

// template <typename Encoding, typename CharT, typename R> struct encode_to_view

#ifdef CTHASH_STDFMT_AVAILABLE
template <typename Encoding, typename R, typename CharT>
struct formatter<cthash::encode_to_view<Encoding, CharT, R>, CharT> {
	using subject_type = cthash::encode_to_view<Encoding, CharT, R>;

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		return std::ranges::begin(ctx);
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return std::ranges::copy(value, ctx.out()).out;
	}
};

#endif

} // namespace std

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_ALGORITHM_HPP
#define CTHASH_INTERNAL_ALGORITHM_HPP

#include <numeric>
#include <compare>
#include <cstddef>
#include <cstdint>

namespace cthash::internal {

template <typename It1, typename It2> constexpr auto threeway_compare_of_same_size(It1 lhs, It2 rhs, size_t length) -> std::strong_ordering {
	for (size_t i = 0; i != length; ++i) {
		if (const auto r = (*lhs++ <=> *rhs++); std::is_neq(r)) {
			return r;
		}
	}

	return std::strong_ordering::equal;
}

template <typename T, typename It1, typename It2, typename Stream> constexpr auto & push_to_stream_as(It1 f, It2 l, Stream & stream) {
	constexpr auto cast_and_shift = [](Stream * s, const auto & rhs) { (*s) << T{rhs}; return s; };
	return *std::accumulate(f, l, &stream, cast_and_shift);
}

} // namespace cthash::internal

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_HEXDEC_HPP
#define CTHASH_INTERNAL_HEXDEC_HPP

#include <array>
#include <ostream>
#include <span>
#include <type_traits>
#include <cstdint>

namespace cthash::internal {

consteval auto get_hexdec_table() noexcept {
	std::array<uint8_t, 128> result;

	auto char_to_hexdec = [](char c) {
		if (c >= '0' && c <= '9') {
			return static_cast<uint8_t>(c - '0');
		} else if (c >= 'a' && c <= 'f') {
			return static_cast<uint8_t>(c - 'a' + 10);
		} else if (c >= 'A' && c <= 'F') {
			return static_cast<uint8_t>(c - 'A' + 10);
		} else {
			return static_cast<uint8_t>(0);
		}
	};

	for (size_t i = 0; i != result.size(); ++i) {
		result[i] = char_to_hexdec(static_cast<char>(i));
	}

	return result;
}

constexpr auto hexdec_to_value_alphabet = get_hexdec_table();

template <typename CharT> constexpr auto value_to_hexdec_alphabet = std::array<CharT, 16>{CharT('0'), CharT('1'), CharT('2'), CharT('3'), CharT('4'), CharT('5'), CharT('6'), CharT('7'), CharT('8'), CharT('9'), CharT('a'), CharT('b'), CharT('c'), CharT('d'), CharT('e'), CharT('f')};

struct byte_hexdec_value {
	std::byte val;

	template <typename CharT, typename Traits> friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, byte_hexdec_value rhs) {
		return os << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val >> 4u)] << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val) & 0b1111u];
	}
};

template <size_t N, typename CharT> constexpr auto hexdec_to_binary(std::span<const CharT, N * 2> in) -> std::array<std::byte, N> {
	return [in]<size_t... Idx>(std::index_sequence<Idx...>) {
		return std::array<std::byte, N>{static_cast<std::byte>(hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2]) & 0b0111'1111u] << 4u | hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2u + 1u]) & 0b0111'1111u])...};
	}(std::make_index_sequence<N>());
}

template <typename CharT, size_t N>
requires((N - 1) % 2 == 0) // -1 because of zero terminator in literals
constexpr auto literal_hexdec_to_binary(const CharT (&in)[N]) -> std::array<std::byte, (N - 1) / 2> {
	return hexdec_to_binary<N / 2>(std::span<const char, N - 1>(in, N - 1));
}

} // namespace cthash::internal

#endif

#include <algorithm>
#include <array>
#include <format>
#include <span>
#include <string_view>
#include <compare>

namespace cthash {

// hash_value

template <size_t N> struct hash_value: std::array<std::byte, N> {
	using super = std::array<std::byte, N>;

	constexpr hash_value() noexcept: super{} { }
	explicit constexpr hash_value(super && s) noexcept: super(s) { }
	template <typename CharT> explicit constexpr hash_value(const CharT (&in)[N * 2u + 1u]) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in, N * 2u))} { }
	template <typename CharT> explicit constexpr hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in.data(), in.size()))} { }

	// comparison support
	constexpr friend bool operator==(const hash_value & lhs, const hash_value & rhs) noexcept = default;
	constexpr friend auto operator<=>(const hash_value & lhs, const hash_value & rhs) noexcept -> std::strong_ordering {
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), N);
	}

	template <typename Encoding = cthash::encoding::hexdec, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		auto hexdec_view = *this | cthash::encode_to<Encoding, CharT>;
		std::ranges::copy(hexdec_view, std::ostream_iterator<CharT, CharT>(os));
		return os;
	}

	// print to ostream support
	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const hash_value & val) {
		return val.print_into(os);
	}

	template <size_t PrefixN> constexpr auto prefix() const noexcept requires(PrefixN <= N) {
		hash_value<PrefixN> output{};
		std::ranges::copy(this->begin(), this->begin() + PrefixN, output.begin());
		return output;
	}

	template <size_t SuffixN> constexpr auto suffix() const noexcept requires(SuffixN <= N) {
		hash_value<SuffixN> output{};
		std::ranges::copy(this->end() - SuffixN, this->end(), output.begin());
		return output;
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(encoded);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(encoded.size());
		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());
		return result;
#endif
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_fixed_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
		// it's type dependendent so we can calculate the size...
		constexpr size_t size_needed = (hash_value{} | cthash::encode_to<Encoding, CharT>).size();

		auto result = cthash::fixed_string<CharT, size_needed>{nullptr};

		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());

		return result;
	}
};

template <typename CharT, size_t N> hash_value(const CharT (&)[N]) -> hash_value<(N - 1u) / 2u>;
template <typename CharT, size_t N> hash_value(std::span<const CharT, N>) -> hash_value<N / 2u>;
template <typename CharT, size_t N> hash_value(const fixed_string<CharT, N> &) -> hash_value<N / 2u>;

template <typename> struct default_encoding {
	using encoding = cthash::encoding::hexdec;
};

template <typename Tag> concept tag_with_encoding = requires() {
	typename Tag::encoding;
};

template <tag_with_encoding Tag> struct default_encoding<Tag> {
	using encoding = Tag::encoding;
};

template <typename Tag, size_t = internal::digest_bytes_length_of<Tag>> struct tagged_hash_value: hash_value<internal::digest_bytes_length_of<Tag>> {
	static constexpr size_t N = internal::digest_bytes_length_of<Tag>;

	using super = hash_value<N>;
	using super::super;
	template <typename CharT> explicit constexpr tagged_hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{in} { }

	static constexpr size_t digest_length = N;

	template <typename Encoding = default_encoding<Tag>::encoding, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		return super::template print_into<Encoding>(os);
	}

	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const tagged_hash_value & val) {
		return val.print_into(os);
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_string(const tagged_hash_value & value) {
		return to_string<Encoding, CharT>(static_cast<const super &>(value));
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_fixed_string(const tagged_hash_value & value) {
		return to_fixed_string<Encoding, CharT>(static_cast<const super &>(value));
	}
};

template <typename T> concept variable_digest_length = T::digest_length_bit == 0u;

template <size_t N, variable_digest_length Tag> struct variable_bit_length_tag: Tag {
	static constexpr size_t digest_length_bit = N;
};

template <typename T> concept convertible_to_tagged_hash_value = requires(const T & obj) {
	{ tagged_hash_value{obj} };
};

namespace literals {

	template <fixed_string Value>
	constexpr auto operator""_hash() {
		return hash_value(Value);
	}

} // namespace literals

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#if _LIBCPP_VERSION >= 170000
// libc++ will define __cpp_lib_format macro in 19.0
// https://github.com/llvm/llvm-project/issues/77773
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#ifdef CTHASH_STDFMT_AVAILABLE
template <size_t N, typename CharT>
struct formatter<cthash::hash_value<N>, CharT> {
	using subject_type = cthash::hash_value<N>;
	using default_encoding = cthash::encoding::hexdec;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <typename Tag, size_t N, typename CharT>
struct formatter<cthash::tagged_hash_value<Tag, N>, CharT> {
	using subject_type = cthash::tagged_hash_value<Tag, N>;
	using default_encoding = typename cthash::default_encoding<Tag>::encoding;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <cthash::convertible_to_tagged_hash_value Type, typename CharT> struct formatter<Type, CharT>: formatter<decltype(cthash::tagged_hash_value{std::declval<Type>()}), CharT> {
};

#endif

} // namespace std

#endif

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_CONVERT_HPP
#define CTHASH_INTERNAL_CONVERT_HPP

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#include <span>
#include <type_traits>
#include <cstddef>
#include <cstdint>
#include <cstring>

namespace cthash {

template <typename It1, typename It2, typename It3> constexpr auto byte_copy(It1 first, It2 last, It3 destination) {
	return std::transform(first, last, destination, [](byte_like auto v) { return static_cast<std::byte>(v); });
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << ((sizeof(T) - 1u - Idx) * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::little) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_le_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << static_cast<T>(Idx * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::big) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T> struct unwrap_littleendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> (Idx * 8u))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_littleendian_number(std::span<std::byte, 8>) -> unwrap_littleendian_number<uint64_t>;
unwrap_littleendian_number(std::span<std::byte, 4>) -> unwrap_littleendian_number<uint32_t>;

template <std::unsigned_integral T> struct unwrap_bigendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> ((bits - 8u) - 8u * Idx))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_bigendian_number(std::span<std::byte, 8>) -> unwrap_bigendian_number<uint64_t>;
unwrap_bigendian_number(std::span<std::byte, 4>) -> unwrap_bigendian_number<uint32_t>;

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#include <algorithm>
#include <array>
#include <span>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <typename Config> struct internal_hasher {
	static constexpr auto config = Config{};
	static constexpr size_t block_size_bytes = config.block_bits / 8u;
	static constexpr size_t digest_bytes = internal::digest_bytes_length_of<Config>;

	// internal types
	using state_value_t = std::remove_cvref_t<decltype(Config::initial_values)>;
	using state_item_t = typename state_value_t::value_type;

	using block_value_t = std::array<std::byte, block_size_bytes>;
	using block_view_t = std::span<const std::byte, block_size_bytes>;

	using staging_item_t = typename decltype(config.constants)::value_type;
	static constexpr size_t staging_size = config.constants.size();
	using staging_value_t = std::array<staging_item_t, staging_size>;
	using staging_view_t = std::span<const staging_item_t, staging_size>;

	using digest_span_t = std::span<std::byte, digest_bytes>;
	using result_t = cthash::tagged_hash_value<Config>;
	using length_t = typename Config::length_type;

	// internal state
	state_value_t hash;
	length_t total_length;

	block_value_t block;
	unsigned block_used;

	// constructors
	constexpr internal_hasher() noexcept: hash{config.initial_values}, total_length{0u}, block_used{0u} { }
	constexpr internal_hasher(const internal_hasher &) noexcept = default;
	constexpr internal_hasher(internal_hasher &&) noexcept = default;
	constexpr ~internal_hasher() noexcept = default;

	// take buffer and build staging
	template <byte_like Byte> [[gnu::always_inline]] static constexpr auto build_staging(std::span<const Byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		staging_value_t w;

		constexpr auto first_part_size = block_size_bytes / sizeof(staging_item_t);

		// fill first part with chunk
		for (int i = 0; i != int(first_part_size); ++i) {
			w[static_cast<size_t>(i)] = cast_from_bytes<staging_item_t>(chunk.subspan(static_cast<size_t>(i) * sizeof(staging_item_t)).template first<sizeof(staging_item_t)>());
		}

		// fill the rest (generify)
		for (int i = int(first_part_size); i != int(staging_size); ++i) {
			w[static_cast<size_t>(i)] = w[static_cast<size_t>(i - 16)] + config.sigma_0(w[static_cast<size_t>(i - 15)]) + w[static_cast<size_t>(i - 7)] + config.sigma_1(w[static_cast<size_t>(i - 2)]);
		}

		return w;
	}

	[[gnu::always_inline]] static constexpr auto build_staging(std::span<const std::byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		return build_staging<std::byte>(chunk);
	}

	[[gnu::always_inline]] static constexpr void rounds(staging_view_t w, state_value_t & state) noexcept {
		config.rounds(w, state);
	}

	// this implementation works only with input size aligned to bytes (not bits)
	template <byte_like T> [[gnu::always_inline]] constexpr void update_to_buffer_and_process(std::span<const T> in) noexcept {
		// if block is not used, we can build staging directly
		if (block_used) {
			const auto remaining_free_space = std::span<std::byte, block_size_bytes>(block).subspan(block_used);
			const auto to_copy = in.first(std::min(in.size(), remaining_free_space.size()));

			const auto it = byte_copy(to_copy.begin(), to_copy.end(), remaining_free_space.begin());
			total_length += to_copy.size();

			// we didn't fill the block
			if (it != remaining_free_space.end()) {
				assert(to_copy.size() == in.size());
				block_used += static_cast<unsigned>(to_copy.size());
				return;
			} else {
				block_used = 0u;
			}

			// we have block!
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// remove part we processed
			in = in.subspan(to_copy.size());
		}

		// do the work over blocks without copy
		if (not block_used) {
			while (in.size() >= block_size_bytes) {
				const auto local_block = in.template first<block_size_bytes>();
				total_length += block_size_bytes;

				const staging_value_t w = build_staging<T>(local_block);
				rounds(w, hash);

				// remove part we processed
				in = in.subspan(block_size_bytes);
			}
		}

		// remainder is put onto temporary block
		if (not in.empty()) {
			assert(block_used == 0u);
			assert(in.size() < block_size_bytes);

			// copy it to block and let it stay there
			byte_copy(in.begin(), in.end(), block.begin());
			block_used = static_cast<unsigned>(in.size());
			total_length += block_used;
		}
	}

	[[gnu::always_inline]] static constexpr bool finalize_buffer(block_value_t & block, size_t block_used) noexcept {
		assert(block_used < block.size());
		const auto free_space = std::span(block).subspan(block_used);

		auto it = free_space.data();
		*it++ = std::byte{0b1000'0000u};							   // first byte after data contains bit at MSB
		std::fill(it, (block.data() + block.size()), std::byte{0x0u}); // rest is filled with zeros

		// we don't have enough space to write length bits
		return free_space.size() < (1u + (config.length_size_bits / 8u));
	}

	[[gnu::always_inline]] static constexpr void finalize_buffer_by_writing_length(block_value_t & block, length_t total_length) noexcept {
		unwrap_bigendian_number{std::span(block).template last<sizeof(length_t)>()} = (total_length * 8u);
	}

	[[gnu::always_inline]] constexpr void finalize() noexcept {
		if (finalize_buffer(block, block_used)) {
			// we didn't have enough space, we need to process block
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// zero it out
			std::fill(block.begin(), block.end(), std::byte{0x0u});
		}

		// we either have space to write or we have zerod out block
		finalize_buffer_by_writing_length(block, total_length);

		// calculate last round
		const staging_value_t w = build_staging(block);
		rounds(w, hash);
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) == 0u)
	{
		// copy result to byte result
		constexpr size_t values_for_output = digest_bytes / sizeof(state_item_t);
		static_assert(values_for_output <= config.initial_values.size());

		for (int i = 0; i != values_for_output; ++i) {
			unwrap_bigendian_number<state_item_t>{out.subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) != 0u)
	{
		// this is only used when digest doesn't align with output buffer

		// make sure digest size is smaller than hash state
		static_assert(digest_bytes <= config.initial_values.size() * sizeof(state_item_t));

		// copy result to byte result
		std::array<std::byte, sizeof(state_item_t) * config.initial_values.size()> tmp_buffer;

		for (int i = 0; i != (int)config.initial_values.size(); ++i) {
			unwrap_bigendian_number<state_item_t>{std::span(tmp_buffer).subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}

		std::copy_n(tmp_buffer.data(), digest_bytes, out.data());
	}
};

// this is a convinience type for nicer UX...
template <typename Config> struct hasher: private internal_hasher<Config> {
	using super = internal_hasher<Config>;
	using result_t = typename super::result_t;
	using length_t = typename super::length_t;
	using digest_span_t = typename super::digest_span_t;

	constexpr hasher() noexcept: super() { }
	constexpr hasher(const hasher &) noexcept = default;
	constexpr hasher(hasher &&) noexcept = default;
	constexpr ~hasher() noexcept = default;

	// support for various input types
	constexpr hasher & update(std::span<const std::byte> input) noexcept {
		super::update_to_buffer_and_process(input);
		return *this;
	}

	template <convertible_to_byte_span T> constexpr hasher & update(const T & something) noexcept {
		using value_type = typename decltype(std::span(something))::value_type;
		super::update_to_buffer_and_process(std::span<const value_type>(something));
		return *this;
	}

	template <one_byte_char CharT> constexpr hasher & update(std::basic_string_view<CharT> in) noexcept {
		super::update_to_buffer_and_process(std::span(in.data(), in.size()));
		return *this;
	}

	template <string_literal T> constexpr hasher & update(const T & lit) noexcept {
		super::update_to_buffer_and_process(std::span(lit, std::size(lit) - 1u));
		return *this;
	}

	// TODO: any range with value convertible to byte

	// output (by reference or by value)
	constexpr void final(digest_span_t digest) noexcept {
		super::finalize();
		super::write_result_into(digest);
	}

	constexpr auto final() noexcept {
		result_t output;
		this->final(output);
		return output;
	}

	constexpr length_t size() const noexcept {
		return super::total_length;
	}
};

} // namespace cthash

#endif

#include <array>
#include <span>
#include <concepts>
#include <cstdint>

namespace cthash::sha2 {

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto choice(T e, T f, T g) noexcept -> T {
	return (e bitand f) xor (~e bitand g);
}

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto majority(T a, T b, T c) noexcept -> T {
	return (a bitand b) xor (a bitand c) xor (b bitand c);
}

template <typename Config, typename StageT, size_t StageLength, typename StateT, size_t StateLength>
[[gnu::always_inline]] constexpr void rounds(std::span<const StageT, StageLength> w, std::array<StateT, StateLength> & state) noexcept {
	using state_t = std::array<StateT, StateLength>;

	// create copy of internal state
	auto wvar = state_t(state);

	// just give them names
	auto & [a, b, c, d, e, f, g, h] = wvar;

	// number of rounds is same as constants
	static_assert(StageLength == Config::constants.size());

	for (int i = 0; i != Config::constants.size(); ++i) {
		const auto temp1 = h + Config::sum_e(e) + choice(e, f, g) + Config::constants[static_cast<size_t>(i)] + w[static_cast<size_t>(i)];
		const auto temp2 = Config::sum_a(a) + majority(a, b, c);

		// move around (that's rotate)
		std::rotate(wvar.begin(), wvar.begin() + 7u, wvar.end());

		e += temp1;
		a = temp1 + temp2;

		// originally it was:
		// h = g;
		// g = f;
		// f = e;
		// e = d + temp1;
		// d = c;
		// c = b;
		// b = a;
		// a = temp1 + temp2;
	}

	// add store back
	for (int i = 0; i != (int)state.size(); ++i) {
		state[static_cast<size_t>(i)] += wvar[static_cast<size_t>(i)];
	}
}

} // namespace cthash::sha2

#endif

namespace cthash {

struct sha512_config {
	using length_type = uint64_t;
	static constexpr size_t length_size_bits = 128;

	static constexpr size_t block_bits = 1024u;

	static constexpr auto initial_values = std::array<uint64_t, 8>{0x6a09e667f3bcc908ull, 0xbb67ae8584caa73bull, 0x3c6ef372fe94f82bull, 0xa54ff53a5f1d36f1ull, 0x510e527fade682d1ull, 0x9b05688c2b3e6c1full, 0x1f83d9abfb41bd6bull, 0x5be0cd19137e2179ull};

	// staging functions
	[[gnu::always_inline]] static constexpr auto sigma_0(uint64_t w_15) noexcept -> uint64_t {
		return std::rotr(w_15, 1u) xor std::rotr(w_15, 8u) xor (w_15 >> 7u);
	}

	[[gnu::always_inline]] static constexpr auto sigma_1(uint64_t w_2) noexcept -> uint64_t {
		return std::rotr(w_2, 19u) xor std::rotr(w_2, 61u) xor (w_2 >> 6u);
	}

	// rounds constants...
	static constexpr auto constants = std::array<uint64_t, 80>{
		0x428a2f98d728ae22ull, 0x7137449123ef65cdull, 0xb5c0fbcfec4d3b2full, 0xe9b5dba58189dbbcull, 0x3956c25bf348b538ull,
		0x59f111f1b605d019ull, 0x923f82a4af194f9bull, 0xab1c5ed5da6d8118ull, 0xd807aa98a3030242ull, 0x12835b0145706fbeull,
		0x243185be4ee4b28cull, 0x550c7dc3d5ffb4e2ull, 0x72be5d74f27b896full, 0x80deb1fe3b1696b1ull, 0x9bdc06a725c71235ull,
		0xc19bf174cf692694ull, 0xe49b69c19ef14ad2ull, 0xefbe4786384f25e3ull, 0x0fc19dc68b8cd5b5ull, 0x240ca1cc77ac9c65ull,
		0x2de92c6f592b0275ull, 0x4a7484aa6ea6e483ull, 0x5cb0a9dcbd41fbd4ull, 0x76f988da831153b5ull, 0x983e5152ee66dfabull,
		0xa831c66d2db43210ull, 0xb00327c898fb213full, 0xbf597fc7beef0ee4ull, 0xc6e00bf33da88fc2ull, 0xd5a79147930aa725ull,
		0x06ca6351e003826full, 0x142929670a0e6e70ull, 0x27b70a8546d22ffcull, 0x2e1b21385c26c926ull, 0x4d2c6dfc5ac42aedull,
		0x53380d139d95b3dfull, 0x650a73548baf63deull, 0x766a0abb3c77b2a8ull, 0x81c2c92e47edaee6ull, 0x92722c851482353bull,
		0xa2bfe8a14cf10364ull, 0xa81a664bbc423001ull, 0xc24b8b70d0f89791ull, 0xc76c51a30654be30ull, 0xd192e819d6ef5218ull,
		0xd69906245565a910ull, 0xf40e35855771202aull, 0x106aa07032bbd1b8ull, 0x19a4c116b8d2d0c8ull, 0x1e376c085141ab53ull,
		0x2748774cdf8eeb99ull, 0x34b0bcb5e19b48a8ull, 0x391c0cb3c5c95a63ull, 0x4ed8aa4ae3418acbull, 0x5b9cca4f7763e373ull,
		0x682e6ff3d6b2b8a3ull, 0x748f82ee5defb2fcull, 0x78a5636f43172f60ull, 0x84c87814a1f0ab72ull, 0x8cc702081a6439ecull,
		0x90befffa23631e28ull, 0xa4506cebde82bde9ull, 0xbef9a3f7b2c67915ull, 0xc67178f2e372532bull, 0xca273eceea26619cull,
		0xd186b8c721c0c207ull, 0xeada7dd6cde0eb1eull, 0xf57d4f7fee6ed178ull, 0x06f067aa72176fbaull, 0x0a637dc5a2c898a6ull,
		0x113f9804bef90daeull, 0x1b710b35131c471bull, 0x28db77f523047d84ull, 0x32caab7b40c72493ull, 0x3c9ebe0a15c9bebcull,
		0x431d67c49c100d4cull, 0x4cc5d4becb3e42b6ull, 0x597f299cfc657e2aull, 0x5fcb6fab3ad6faecull, 0x6c44198c4a475817ull};

	[[gnu::always_inline]] static constexpr auto sum_a(uint64_t a) noexcept -> uint64_t {
		return std::rotr(a, 28u) xor std::rotr(a, 34u) xor std::rotr(a, 39u);
	}

	[[gnu::always_inline]] static constexpr auto sum_e(uint64_t e) noexcept -> uint64_t {
		return std::rotr(e, 14u) xor std::rotr(e, 18u) xor std::rotr(e, 41u);
	}

	// rounds
	[[gnu::always_inline]] static constexpr void rounds(std::span<const uint64_t, 80> w, std::array<uint64_t, 8> & state) noexcept {
		return sha2::rounds<sha512_config>(w, state);
	}
};

static_assert(not cthash::internal::digest_length_provided<sha512_config>);
static_assert(cthash::internal::digest_bytes_length_of<sha512_config> == 64u);

using sha512 = hasher<sha512_config>;
using sha512_value = tagged_hash_value<sha512_config>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_sha512() {
		return sha512_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

#ifndef CTHASH_SHA2_SHA512_T_HPP
#define CTHASH_SHA2_SHA512_T_HPP

#ifndef CTHASH_SHA2_SHA512_HPP
#define CTHASH_SHA2_SHA512_HPP

#ifndef CTHASH_SHA2_COMMON_HPP
#define CTHASH_SHA2_COMMON_HPP

#ifndef CONSTEXPR_SHA2_HASHER_HPP
#define CONSTEXPR_SHA2_HASHER_HPP

#ifndef CTHASH_SIMPLE_HPP
#define CTHASH_SIMPLE_HPP

#include <utility>

namespace cthash {

template <typename Hasher, typename In, typename... Args> concept hasher_like = requires(Hasher & h, const In & in, Args &&... args) //
{
	{ Hasher{std::forward<Args>(args)...} };
	{ h.update(in) } -> std::same_as<Hasher &>;
	{ h.final() };
};

template <typename Hasher, typename In> concept direct_hasher = requires(Hasher & h, const In & in) //
{
	{ h.update_and_final(in) };
};

template <typename Hasher, typename T, typename... Args>
requires hasher_like<Hasher, T, Args...>
constexpr auto simple(const T & value, Args &&... args) noexcept {
	if constexpr (direct_hasher<Hasher, T>) {
		return Hasher{std::forward<Args>(args)...}.update_and_final(value);
	} else {
		return Hasher{std::forward<Args>(args)...}.update(value).final();
	}
}

} // namespace cthash

#endif

#ifndef CTHASH_VALUE_HPP
#define CTHASH_VALUE_HPP

#ifndef CTHASH_FIXED_STRING_HPP
#define CTHASH_FIXED_STRING_HPP

#include <algorithm>
#include <span>
#include <string_view>

namespace cthash {

template <typename CharT, size_t N> struct fixed_string: std::array<CharT, N> {
	using super = std::array<CharT, N>;

	consteval static auto from_string_literal(const CharT (&in)[N + 1]) -> std::array<CharT, N> {
		std::array<CharT, N> out;
		std::copy_n(in, N, out.data());
		return out;
	}

	explicit constexpr fixed_string(std::nullptr_t) noexcept: super{} { }

	consteval fixed_string(const CharT (&in)[N + 1]) noexcept: super{from_string_literal(in)} { }

	using super::data;
	using super::size;

	constexpr operator std::span<const CharT, N>() const noexcept {
		return std::span<const CharT, N>(data(), size());
	}

	constexpr operator std::span<const CharT>() const noexcept {
		return std::span<const CharT>(data(), size());
	}

	constexpr operator std::basic_string_view<CharT>() const noexcept {
		return std::basic_string_view<CharT>(data(), size());
	}

	constexpr friend bool operator==(const fixed_string &, const fixed_string &) noexcept = default;
	constexpr friend bool operator==(const fixed_string & lhs, std::basic_string_view<CharT> rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == rhs;
	}
	constexpr friend bool operator==(const fixed_string & lhs, const CharT * rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == std::basic_string_view<CharT>{rhs};
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N - 1>;

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_BASE_HPP
#define CTHASH_ENCODING_BASE_HPP

#ifndef CTHASH_ENCODING_CHUNK_OF_BITS_HPP
#define CTHASH_ENCODING_CHUNK_OF_BITS_HPP

#ifndef CTHASH_ENCODING_BIT_BUFFER_HPP
#define CTHASH_ENCODING_BIT_BUFFER_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <bit>
#include <iostream>
#include <numeric>
#include <ranges>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct select_bit_integer;

template <size_t Bits> requires(Bits <= 8) struct select_bit_integer<Bits> {
	using type = uint8_t;
};

template <size_t Bits> requires(Bits > 8 && Bits <= 16) struct select_bit_integer<Bits> {
	using type = uint16_t;
};

template <size_t Bits> requires(Bits > 16 && Bits <= 32) struct select_bit_integer<Bits> {
	using type = uint32_t;
};

template <size_t Bits> requires(Bits > 32 && Bits <= 64) struct select_bit_integer<Bits> {
	using type = uint64_t;
};

template <size_t Bits> using select_bit_integer_t = select_bit_integer<Bits>::type;

template <size_t V> requires(std::popcount(V) == 1u) constexpr auto log2_of_power_of_2 = static_cast<size_t>(std::countr_zero(V));

template <size_t Bits> constexpr auto mask = static_cast<select_bit_integer_t<Bits>>((static_cast<select_bit_integer_t<Bits>>(1u) << Bits) - 1u);

template <size_t Capacity> class basic_bit_buffer {
public:
	static constexpr auto capacity = std::integral_constant<size_t, Capacity>{};
	using storage_type = select_bit_integer_t<capacity()>;
	using size_type = select_bit_integer_t<log2_of_power_of_2<std::bit_ceil(capacity())>>;

public:
	storage_type buffer{0};
	size_type bits_available{0};

public:
	template <size_t Bits> static constexpr auto mask = static_cast<storage_type>((static_cast<storage_type>(1u) << Bits) - 1u);

	constexpr friend bool operator==(const basic_bit_buffer & lhs, const basic_bit_buffer & rhs) noexcept = default;

	constexpr size_type size() const noexcept {
		return bits_available;
	}

	constexpr size_type unused_size() const noexcept {
		return capacity() - bits_available;
	}

	constexpr bool empty() const noexcept {
		return bits_available == 0u;
	}

	constexpr bool full() const noexcept {
		return bits_available == capacity();
	}

	template <size_t Bits> constexpr void push(select_bit_integer_t<Bits> in) noexcept requires(Bits <= capacity()) {
		assert(size() <= capacity() - Bits);
		buffer = static_cast<storage_type>(buffer << Bits) | static_cast<storage_type>(in);
		bits_available += static_cast<size_type>(Bits);
	}
	constexpr void push_empty_bits(size_t count) noexcept {
		buffer = static_cast<storage_type>(buffer << count);
		bits_available += static_cast<unsigned char>(count);
	}

	template <size_t Bits> constexpr void pop() noexcept requires(Bits <= capacity()) {
		assert(size() >= Bits);
		bits_available -= static_cast<size_type>(Bits);
	}

	template <size_t Bits> constexpr auto front() const noexcept -> select_bit_integer_t<Bits> requires(Bits <= capacity()) {
		using output_type = select_bit_integer_t<Bits>;
		assert(size() >= static_cast<size_type>(Bits));
		return static_cast<output_type>((buffer >> (bits_available - Bits))) & mask<Bits>;
	}
};

constexpr size_t calculate_padding_bit_count(size_t number_of_bits_in_buffer, size_t output_size, size_t input_size) {
	size_t n = number_of_bits_in_buffer;
	size_t padding_bits = 0u;

	while (n != 0u) {
		padding_bits += input_size;
		n += input_size;

		while (n >= output_size) {
			n = n - output_size;
		}
	}

	return padding_bits;
}

template <size_t OutBits, size_t InBits = 8u> class bit_buffer: protected basic_bit_buffer<std::lcm(OutBits, InBits)> {
	using super = basic_bit_buffer<std::lcm(OutBits, InBits)>;

public:
	constexpr bit_buffer() noexcept = default;

	using typename super::size_type;
	static constexpr auto out_bits = std::integral_constant<size_type, OutBits>{};
	static constexpr auto in_bits = std::integral_constant<size_type, InBits>{};

	using out_type = select_bit_integer_t<OutBits>;
	using in_type = select_bit_integer_t<InBits>;

	using super::capacity;
	static constexpr auto in_capacity = std::integral_constant<size_type, (capacity() / in_bits())>{};
	static constexpr auto out_capacity = std::integral_constant<size_type, (capacity() / out_bits())>{};

	static constexpr auto aligned = std::bool_constant<capacity() == in_capacity()>{};

	constexpr void push(in_type in) noexcept {
		super::template push<in_bits>(in);
	}

	constexpr void push_empty() noexcept {
		this->push(in_type{0u});
	}

	constexpr size_type push_zeros_to_align() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_to_align() noexcept requires(!aligned()) {
		if (empty()) {
			return 0u;
		}

		assert(out_bits > super::size());
		const size_type missing_bits = static_cast<size_type>(out_bits - super::size());
		super::push_empty_bits(missing_bits);
		return missing_bits;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(!aligned()) {
		const size_type usable_bits = super::size();
		const size_type missing_bits = static_cast<size_type>(calculate_padding_bit_count(super::size(), out_bits, in_bits));
		super::push_empty_bits(missing_bits);
		return usable_bits;
	}

	constexpr void pop() noexcept {
		super::template pop<out_bits>();
	}

	constexpr auto front() const noexcept -> out_type {
		return super::template front<out_bits>();
	}

	constexpr size_type size() const noexcept {
		return static_cast<size_type>(super::size() / out_bits);
	}

	constexpr size_type unused_size() const noexcept {
		return static_cast<size_type>(super::unused_size() / in_bits);
	}

	using super::empty;
	using super::full;

	constexpr bool has_bits_for_pop() const noexcept {
		return super::size() >= out_bits;
	}

	constexpr bool has_capacity_for_push() const noexcept {
		return super::size() <= (capacity() - in_bits);
	}
};

} // namespace cthash

#endif

#include <iostream>
#include <ranges>

namespace cthash {

template <typename Buffer> struct buffer_result_type;

template <typename Buffer> requires(Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	static constexpr Buffer::size_type missing_bits = {0u};

	constexpr bool is_padding() const noexcept {
		return false;
	}
};

template <typename Buffer> requires(!Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	typename Buffer::size_type missing_bits;

	constexpr bool is_padding() const noexcept {
		return missing_bits == Buffer::out_bits;
	}
};

template <typename Buffer, bool AllowPadding> struct buffer_with_missing_bits;

template <typename Buffer, bool AllowPadding> requires(Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};

	struct result_type {
		typename Buffer::out_type value;
		static constexpr Buffer::size_type missing_bits = {0u};

		constexpr bool is_padding() const noexcept {
			return false;
		}
	};

	static constexpr bool aligned = Buffer::aligned();

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		return result_type{buffer.front()};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		while (!buffer.has_bits_for_pop() && (it != end)) {
			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <typename Buffer, bool AllowPadding> requires(!Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};
	Buffer::size_type missing_bits{0};

	static constexpr bool aligned = Buffer::aligned();

	struct result_type {
		typename Buffer::out_type value;
		typename Buffer::size_type missing_bits;

		constexpr bool is_padding() const noexcept {
			return missing_bits == Buffer::out_bits;
		}
	};

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		assert(Buffer::out_bits >= missing_bits);
		return result_type{buffer.front(), missing_bits};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	constexpr void pad_buffer() noexcept requires(AllowPadding) {
		// full multi-chunk padding (for baseN encodings)
		missing_bits = (Buffer::out_bits - buffer.push_zeros_for_padding());
	}

	constexpr void pad_buffer() noexcept requires(!AllowPadding) {
		// only add enough zero to finish current output chunk
		missing_bits = buffer.push_zeros_to_align();
	}

	constexpr void saturate_missing_bits() noexcept requires(AllowPadding) {
		if (missing_bits) {
			missing_bits = Buffer::out_bits;
		}
		// missing_bits = static_cast<buffer_size_t>((unsigned)(bool)missing_bits * output_value_bit_size);
	}

	constexpr void saturate_missing_bits() noexcept requires(!AllowPadding) {
		// do nothing :)
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		for (;;) {
			if (it == end) {
				if (buffer.has_bits_for_pop()) {
					// if this is second pass after padding we can mark all bits as missing
					saturate_missing_bits();
				} else {
					// fill remainder of buffer with zeros
					pad_buffer();
				}

				return;
			}

			if (buffer.has_bits_for_pop()) {
				return;
			}

			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <bool Value> struct conditional;

template <> struct conditional<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional<false> {
	template <typename, typename T> using type = T;
};

template <bool Const, typename T> using maybe_const = typename conditional<Const>::template type<const T, T>;

template <typename T> concept integral_like = std::integral<T> || std::same_as<std::byte, T>;

template <size_t Bits, bool AllowPadding, std::ranges::input_range Input> requires integral_like<std::ranges::range_value_t<Input>> struct chunk_of_bits_view {
	using input_value_type = std::ranges::range_value_t<Input>;

	static constexpr size_t output_value_bit_size = Bits;
	static constexpr size_t input_value_bit_size = sizeof(input_value_type) * 8u;
	using buffer_t = cthash::bit_buffer<output_value_bit_size, input_value_bit_size>;
	using buffer_size_t = buffer_t::size_type;
	Input input;

	static constexpr bool aligned = buffer_t::aligned;

	struct sentinel { };

	template <bool Const> struct iterator {
		using parent = maybe_const<Const, Input>;
		using storage_type = buffer_with_missing_bits<buffer_t, AllowPadding>;
		using value_type = storage_type::result_type;
		using difference_type = intptr_t;

		std::ranges::iterator_t<parent> it;
		[[no_unique_address]] std::ranges::sentinel_t<parent> end;

		storage_type buffer{};

		constexpr iterator(parent & p) noexcept: it{std::ranges::begin(p)}, end{std::ranges::end(p)} {
			// initialize
			buffer.feed_buffer(it, end);
		}

		iterator(const iterator &) = default;
		iterator(iterator &&) = default;

		iterator & operator=(const iterator &) = default;
		iterator & operator=(iterator &&) = default;

		constexpr iterator & operator++() noexcept {
			buffer.pop();
			buffer.feed_buffer(it, end);
			return *this;
		}

		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			this->operator++();
			return copy;
		}

		constexpr auto operator*() const noexcept {
			return buffer.front();
		}

		constexpr friend bool operator==(const iterator & lhs, const iterator & rhs) noexcept = default;

		constexpr friend bool operator==(const iterator & self, sentinel) noexcept {
			return self.buffer.empty();
		}
	};

	static_assert(std::input_iterator<iterator<true>>);
	static_assert(std::input_iterator<iterator<false>>);
	static_assert(std::sentinel_for<sentinel, iterator<true>>);
	static_assert(std::sentinel_for<sentinel, iterator<false>>);

	constexpr chunk_of_bits_view(Input _input) noexcept: input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input};
	}

	constexpr auto end() const noexcept {
		return sentinel{};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && AllowPadding) {
		// calculate with blocks
		return ((std::ranges::size(input) + (buffer_t::in_capacity() - 1u)) / buffer_t::in_capacity()) * buffer_t::out_capacity();
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && !AllowPadding) {
		// calculate with bits
		const size_t bit_size_of_input = std::ranges::size(input) * input_value_bit_size;
		return (bit_size_of_input + (output_value_bit_size - 1u)) / output_value_bit_size;
	}
};

template <size_t Bits, bool AllowPadding> struct chunk_of_bits_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, chunk_of_bits_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) {
		return chunk_of_bits_view<Bits, AllowPadding, R>(std::forward<R>(input));
	}
};

template <size_t Bits, bool AllowPadding = false> constexpr auto chunk_of_bits = chunk_of_bits_action<Bits, AllowPadding>{};

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#include <bit>

namespace cthash {

template <typename Encoding> struct encoding_properties {
	static constexpr size_t size = std::size(Encoding::alphabet) - 1u;
	static_assert(std::popcount(size) == 1u, "Size of encoding's alphabet must be power-of-two");

	static constexpr size_t bits = std::countr_zero(size);

	static constexpr bool has_padding = padded_encoding<Encoding>;

	static constexpr char padding = [] {
		if constexpr (has_padding) {
			return Encoding::padding;
		} else {
			return '\0';
		}
	}();
};

template <typename Encoding, typename CharT, typename R> struct encode_to_view {
	using properties = encoding_properties<Encoding>;
	using chunk_view = cthash::chunk_of_bits_view<properties::bits, properties::has_padding, R>;

	struct sentinel {
		[[no_unique_address]] chunk_view::sentinel end;
	};

	template <bool Const> struct iterator {
		using difference_type = intptr_t;
		using value_type = CharT;

		chunk_view::template iterator<Const> it;

		constexpr iterator & operator++() noexcept {
			++it;
			return *this;
		}
		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			++it;
			return copy;
		}

		constexpr value_type operator*() const noexcept {
			const auto tmp = *it;
			if constexpr (!chunk_view::aligned) {
				// TODO: do without condition
				if (tmp.is_padding()) {
					return properties::padding;
				}
			}
			return static_cast<value_type>(Encoding::alphabet[static_cast<unsigned>(tmp.value)]);
		}

		constexpr friend bool operator==(const iterator &, const iterator &) noexcept = default;

		constexpr friend bool operator==(const iterator & lhs, const sentinel & rhs) noexcept {
			return lhs.it == rhs.end;
		}
	};

	chunk_view input;

	constexpr encode_to_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}

	constexpr auto to_string() const requires(std::ranges::sized_range<R>) {
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(*this);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(size());
		auto [i, o] = std::ranges::copy(begin(), end(), result.begin());
		assert(i == result.end());
		assert(o == result.end());
		return result;
#endif
	}

	constexpr friend std::basic_ostream<CharT> & operator<<(std::basic_ostream<CharT> & out, encode_to_view in) {
		std::ranges::copy(in.begin(), in.end(), std::ostream_iterator<CharT, CharT>(out));
		return out;
	}
};

template <typename Encoding, typename ValueT, typename R> struct decode_from_view {
	R input;

	template <bool Const> struct iterator { };
	struct sentinel { };

	constexpr decode_from_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}
};

template <typename Encoding, typename CharT = char> struct encode_to_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, encode_to_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return encode_to_view<Encoding, CharT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename ValueT = unsigned char> struct decode_from_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, decode_from_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return decode_from_view<Encoding, ValueT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename CharT = char> constexpr auto encode_to = encode_to_action<Encoding, CharT>{};
template <typename Encoding, typename ValueT = unsigned char> constexpr auto decode_from = decode_from_action<Encoding, ValueT>{};

constexpr auto binary_encode = encode_to<encoding::base2, char>;
constexpr auto base2_encode = encode_to<encoding::base2, char>;
constexpr auto base4_encode = encode_to<encoding::base4, char>;
constexpr auto base8_encode = encode_to<encoding::base8, char>;
constexpr auto octal_encode = encode_to<encoding::base8, char>;
constexpr auto hexdec_encode = encode_to<encoding::base16, char>;
constexpr auto hexdec_uppercase_encode = encode_to<encoding::base16_uppercase, char>;
constexpr auto base16_encode = encode_to<encoding::base16, char>;
constexpr auto base32_encode = encode_to<encoding::base32, char>;
constexpr auto base32_no_padding_encode = encode_to<encoding::base32_no_padding, char>;
constexpr auto z_base32_encode = encode_to<encoding::z_base32, char>;
constexpr auto base64_encode = encode_to<encoding::base64, char>;
constexpr auto base64url_encode = encode_to<encoding::base64url, char>;
constexpr auto base64_no_padding_encode = encode_to<encoding::base64_no_padding, char>;

constexpr auto binary_decode = decode_from<encoding::base2, char>;
constexpr auto base2_decode = decode_from<encoding::base2, char>;
constexpr auto base4_decode = decode_from<encoding::base4, char>;
constexpr auto base8_decode = decode_from<encoding::base8, char>;
constexpr auto hexdec_decode = decode_from<encoding::base16, char>;
constexpr auto base16_decode = decode_from<encoding::base16, char>;
constexpr auto base32_decode = decode_from<encoding::base32, char>;
constexpr auto z_base32_decode = decode_from<encoding::z_base32, char>;
constexpr auto base64_decode = decode_from<encoding::base64, char>;
constexpr auto base64url_decode = decode_from<encoding::base64url, char>;
constexpr auto base64_no_padding_decode = decode_from<encoding::base64_no_padding, char>;

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

// template <typename Encoding, typename CharT, typename R> struct encode_to_view

#ifdef CTHASH_STDFMT_AVAILABLE
template <typename Encoding, typename R, typename CharT>
struct formatter<cthash::encode_to_view<Encoding, CharT, R>, CharT> {
	using subject_type = cthash::encode_to_view<Encoding, CharT, R>;

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		return std::ranges::begin(ctx);
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return std::ranges::copy(value, ctx.out()).out;
	}
};

#endif

} // namespace std

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_ALGORITHM_HPP
#define CTHASH_INTERNAL_ALGORITHM_HPP

#include <numeric>
#include <compare>
#include <cstddef>
#include <cstdint>

namespace cthash::internal {

template <typename It1, typename It2> constexpr auto threeway_compare_of_same_size(It1 lhs, It2 rhs, size_t length) -> std::strong_ordering {
	for (size_t i = 0; i != length; ++i) {
		if (const auto r = (*lhs++ <=> *rhs++); std::is_neq(r)) {
			return r;
		}
	}

	return std::strong_ordering::equal;
}

template <typename T, typename It1, typename It2, typename Stream> constexpr auto & push_to_stream_as(It1 f, It2 l, Stream & stream) {
	constexpr auto cast_and_shift = [](Stream * s, const auto & rhs) { (*s) << T{rhs}; return s; };
	return *std::accumulate(f, l, &stream, cast_and_shift);
}

} // namespace cthash::internal

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_HEXDEC_HPP
#define CTHASH_INTERNAL_HEXDEC_HPP

#include <array>
#include <ostream>
#include <span>
#include <type_traits>
#include <cstdint>

namespace cthash::internal {

consteval auto get_hexdec_table() noexcept {
	std::array<uint8_t, 128> result;

	auto char_to_hexdec = [](char c) {
		if (c >= '0' && c <= '9') {
			return static_cast<uint8_t>(c - '0');
		} else if (c >= 'a' && c <= 'f') {
			return static_cast<uint8_t>(c - 'a' + 10);
		} else if (c >= 'A' && c <= 'F') {
			return static_cast<uint8_t>(c - 'A' + 10);
		} else {
			return static_cast<uint8_t>(0);
		}
	};

	for (size_t i = 0; i != result.size(); ++i) {
		result[i] = char_to_hexdec(static_cast<char>(i));
	}

	return result;
}

constexpr auto hexdec_to_value_alphabet = get_hexdec_table();

template <typename CharT> constexpr auto value_to_hexdec_alphabet = std::array<CharT, 16>{CharT('0'), CharT('1'), CharT('2'), CharT('3'), CharT('4'), CharT('5'), CharT('6'), CharT('7'), CharT('8'), CharT('9'), CharT('a'), CharT('b'), CharT('c'), CharT('d'), CharT('e'), CharT('f')};

struct byte_hexdec_value {
	std::byte val;

	template <typename CharT, typename Traits> friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, byte_hexdec_value rhs) {
		return os << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val >> 4u)] << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val) & 0b1111u];
	}
};

template <size_t N, typename CharT> constexpr auto hexdec_to_binary(std::span<const CharT, N * 2> in) -> std::array<std::byte, N> {
	return [in]<size_t... Idx>(std::index_sequence<Idx...>) {
		return std::array<std::byte, N>{static_cast<std::byte>(hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2]) & 0b0111'1111u] << 4u | hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2u + 1u]) & 0b0111'1111u])...};
	}(std::make_index_sequence<N>());
}

template <typename CharT, size_t N>
requires((N - 1) % 2 == 0) // -1 because of zero terminator in literals
constexpr auto literal_hexdec_to_binary(const CharT (&in)[N]) -> std::array<std::byte, (N - 1) / 2> {
	return hexdec_to_binary<N / 2>(std::span<const char, N - 1>(in, N - 1));
}

} // namespace cthash::internal

#endif

#include <algorithm>
#include <array>
#include <format>
#include <span>
#include <string_view>
#include <compare>

namespace cthash {

// hash_value

template <size_t N> struct hash_value: std::array<std::byte, N> {
	using super = std::array<std::byte, N>;

	constexpr hash_value() noexcept: super{} { }
	explicit constexpr hash_value(super && s) noexcept: super(s) { }
	template <typename CharT> explicit constexpr hash_value(const CharT (&in)[N * 2u + 1u]) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in, N * 2u))} { }
	template <typename CharT> explicit constexpr hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in.data(), in.size()))} { }

	// comparison support
	constexpr friend bool operator==(const hash_value & lhs, const hash_value & rhs) noexcept = default;
	constexpr friend auto operator<=>(const hash_value & lhs, const hash_value & rhs) noexcept -> std::strong_ordering {
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), N);
	}

	template <typename Encoding = cthash::encoding::hexdec, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		auto hexdec_view = *this | cthash::encode_to<Encoding, CharT>;
		std::ranges::copy(hexdec_view, std::ostream_iterator<CharT, CharT>(os));
		return os;
	}

	// print to ostream support
	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const hash_value & val) {
		return val.print_into(os);
	}

	template <size_t PrefixN> constexpr auto prefix() const noexcept requires(PrefixN <= N) {
		hash_value<PrefixN> output{};
		std::ranges::copy(this->begin(), this->begin() + PrefixN, output.begin());
		return output;
	}

	template <size_t SuffixN> constexpr auto suffix() const noexcept requires(SuffixN <= N) {
		hash_value<SuffixN> output{};
		std::ranges::copy(this->end() - SuffixN, this->end(), output.begin());
		return output;
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(encoded);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(encoded.size());
		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());
		return result;
#endif
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_fixed_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
		// it's type dependendent so we can calculate the size...
		constexpr size_t size_needed = (hash_value{} | cthash::encode_to<Encoding, CharT>).size();

		auto result = cthash::fixed_string<CharT, size_needed>{nullptr};

		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());

		return result;
	}
};

template <typename CharT, size_t N> hash_value(const CharT (&)[N]) -> hash_value<(N - 1u) / 2u>;
template <typename CharT, size_t N> hash_value(std::span<const CharT, N>) -> hash_value<N / 2u>;
template <typename CharT, size_t N> hash_value(const fixed_string<CharT, N> &) -> hash_value<N / 2u>;

template <typename> struct default_encoding {
	using encoding = cthash::encoding::hexdec;
};

template <typename Tag> concept tag_with_encoding = requires() {
	typename Tag::encoding;
};

template <tag_with_encoding Tag> struct default_encoding<Tag> {
	using encoding = Tag::encoding;
};

template <typename Tag, size_t = internal::digest_bytes_length_of<Tag>> struct tagged_hash_value: hash_value<internal::digest_bytes_length_of<Tag>> {
	static constexpr size_t N = internal::digest_bytes_length_of<Tag>;

	using super = hash_value<N>;
	using super::super;
	template <typename CharT> explicit constexpr tagged_hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{in} { }

	static constexpr size_t digest_length = N;

	template <typename Encoding = default_encoding<Tag>::encoding, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		return super::template print_into<Encoding>(os);
	}

	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const tagged_hash_value & val) {
		return val.print_into(os);
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_string(const tagged_hash_value & value) {
		return to_string<Encoding, CharT>(static_cast<const super &>(value));
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_fixed_string(const tagged_hash_value & value) {
		return to_fixed_string<Encoding, CharT>(static_cast<const super &>(value));
	}
};

template <typename T> concept variable_digest_length = T::digest_length_bit == 0u;

template <size_t N, variable_digest_length Tag> struct variable_bit_length_tag: Tag {
	static constexpr size_t digest_length_bit = N;
};

template <typename T> concept convertible_to_tagged_hash_value = requires(const T & obj) {
	{ tagged_hash_value{obj} };
};

namespace literals {

	template <fixed_string Value>
	constexpr auto operator""_hash() {
		return hash_value(Value);
	}

} // namespace literals

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#if _LIBCPP_VERSION >= 170000
// libc++ will define __cpp_lib_format macro in 19.0
// https://github.com/llvm/llvm-project/issues/77773
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#ifdef CTHASH_STDFMT_AVAILABLE
template <size_t N, typename CharT>
struct formatter<cthash::hash_value<N>, CharT> {
	using subject_type = cthash::hash_value<N>;
	using default_encoding = cthash::encoding::hexdec;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <typename Tag, size_t N, typename CharT>
struct formatter<cthash::tagged_hash_value<Tag, N>, CharT> {
	using subject_type = cthash::tagged_hash_value<Tag, N>;
	using default_encoding = typename cthash::default_encoding<Tag>::encoding;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <cthash::convertible_to_tagged_hash_value Type, typename CharT> struct formatter<Type, CharT>: formatter<decltype(cthash::tagged_hash_value{std::declval<Type>()}), CharT> {
};

#endif

} // namespace std

#endif

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_CONVERT_HPP
#define CTHASH_INTERNAL_CONVERT_HPP

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#include <span>
#include <type_traits>
#include <cstddef>
#include <cstdint>
#include <cstring>

namespace cthash {

template <typename It1, typename It2, typename It3> constexpr auto byte_copy(It1 first, It2 last, It3 destination) {
	return std::transform(first, last, destination, [](byte_like auto v) { return static_cast<std::byte>(v); });
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << ((sizeof(T) - 1u - Idx) * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::little) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_le_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << static_cast<T>(Idx * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::big) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T> struct unwrap_littleendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> (Idx * 8u))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_littleendian_number(std::span<std::byte, 8>) -> unwrap_littleendian_number<uint64_t>;
unwrap_littleendian_number(std::span<std::byte, 4>) -> unwrap_littleendian_number<uint32_t>;

template <std::unsigned_integral T> struct unwrap_bigendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> ((bits - 8u) - 8u * Idx))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_bigendian_number(std::span<std::byte, 8>) -> unwrap_bigendian_number<uint64_t>;
unwrap_bigendian_number(std::span<std::byte, 4>) -> unwrap_bigendian_number<uint32_t>;

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#include <algorithm>
#include <array>
#include <span>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <typename Config> struct internal_hasher {
	static constexpr auto config = Config{};
	static constexpr size_t block_size_bytes = config.block_bits / 8u;
	static constexpr size_t digest_bytes = internal::digest_bytes_length_of<Config>;

	// internal types
	using state_value_t = std::remove_cvref_t<decltype(Config::initial_values)>;
	using state_item_t = typename state_value_t::value_type;

	using block_value_t = std::array<std::byte, block_size_bytes>;
	using block_view_t = std::span<const std::byte, block_size_bytes>;

	using staging_item_t = typename decltype(config.constants)::value_type;
	static constexpr size_t staging_size = config.constants.size();
	using staging_value_t = std::array<staging_item_t, staging_size>;
	using staging_view_t = std::span<const staging_item_t, staging_size>;

	using digest_span_t = std::span<std::byte, digest_bytes>;
	using result_t = cthash::tagged_hash_value<Config>;
	using length_t = typename Config::length_type;

	// internal state
	state_value_t hash;
	length_t total_length;

	block_value_t block;
	unsigned block_used;

	// constructors
	constexpr internal_hasher() noexcept: hash{config.initial_values}, total_length{0u}, block_used{0u} { }
	constexpr internal_hasher(const internal_hasher &) noexcept = default;
	constexpr internal_hasher(internal_hasher &&) noexcept = default;
	constexpr ~internal_hasher() noexcept = default;

	// take buffer and build staging
	template <byte_like Byte> [[gnu::always_inline]] static constexpr auto build_staging(std::span<const Byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		staging_value_t w;

		constexpr auto first_part_size = block_size_bytes / sizeof(staging_item_t);

		// fill first part with chunk
		for (int i = 0; i != int(first_part_size); ++i) {
			w[static_cast<size_t>(i)] = cast_from_bytes<staging_item_t>(chunk.subspan(static_cast<size_t>(i) * sizeof(staging_item_t)).template first<sizeof(staging_item_t)>());
		}

		// fill the rest (generify)
		for (int i = int(first_part_size); i != int(staging_size); ++i) {
			w[static_cast<size_t>(i)] = w[static_cast<size_t>(i - 16)] + config.sigma_0(w[static_cast<size_t>(i - 15)]) + w[static_cast<size_t>(i - 7)] + config.sigma_1(w[static_cast<size_t>(i - 2)]);
		}

		return w;
	}

	[[gnu::always_inline]] static constexpr auto build_staging(std::span<const std::byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		return build_staging<std::byte>(chunk);
	}

	[[gnu::always_inline]] static constexpr void rounds(staging_view_t w, state_value_t & state) noexcept {
		config.rounds(w, state);
	}

	// this implementation works only with input size aligned to bytes (not bits)
	template <byte_like T> [[gnu::always_inline]] constexpr void update_to_buffer_and_process(std::span<const T> in) noexcept {
		// if block is not used, we can build staging directly
		if (block_used) {
			const auto remaining_free_space = std::span<std::byte, block_size_bytes>(block).subspan(block_used);
			const auto to_copy = in.first(std::min(in.size(), remaining_free_space.size()));

			const auto it = byte_copy(to_copy.begin(), to_copy.end(), remaining_free_space.begin());
			total_length += to_copy.size();

			// we didn't fill the block
			if (it != remaining_free_space.end()) {
				assert(to_copy.size() == in.size());
				block_used += static_cast<unsigned>(to_copy.size());
				return;
			} else {
				block_used = 0u;
			}

			// we have block!
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// remove part we processed
			in = in.subspan(to_copy.size());
		}

		// do the work over blocks without copy
		if (not block_used) {
			while (in.size() >= block_size_bytes) {
				const auto local_block = in.template first<block_size_bytes>();
				total_length += block_size_bytes;

				const staging_value_t w = build_staging<T>(local_block);
				rounds(w, hash);

				// remove part we processed
				in = in.subspan(block_size_bytes);
			}
		}

		// remainder is put onto temporary block
		if (not in.empty()) {
			assert(block_used == 0u);
			assert(in.size() < block_size_bytes);

			// copy it to block and let it stay there
			byte_copy(in.begin(), in.end(), block.begin());
			block_used = static_cast<unsigned>(in.size());
			total_length += block_used;
		}
	}

	[[gnu::always_inline]] static constexpr bool finalize_buffer(block_value_t & block, size_t block_used) noexcept {
		assert(block_used < block.size());
		const auto free_space = std::span(block).subspan(block_used);

		auto it = free_space.data();
		*it++ = std::byte{0b1000'0000u};							   // first byte after data contains bit at MSB
		std::fill(it, (block.data() + block.size()), std::byte{0x0u}); // rest is filled with zeros

		// we don't have enough space to write length bits
		return free_space.size() < (1u + (config.length_size_bits / 8u));
	}

	[[gnu::always_inline]] static constexpr void finalize_buffer_by_writing_length(block_value_t & block, length_t total_length) noexcept {
		unwrap_bigendian_number{std::span(block).template last<sizeof(length_t)>()} = (total_length * 8u);
	}

	[[gnu::always_inline]] constexpr void finalize() noexcept {
		if (finalize_buffer(block, block_used)) {
			// we didn't have enough space, we need to process block
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// zero it out
			std::fill(block.begin(), block.end(), std::byte{0x0u});
		}

		// we either have space to write or we have zerod out block
		finalize_buffer_by_writing_length(block, total_length);

		// calculate last round
		const staging_value_t w = build_staging(block);
		rounds(w, hash);
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) == 0u)
	{
		// copy result to byte result
		constexpr size_t values_for_output = digest_bytes / sizeof(state_item_t);
		static_assert(values_for_output <= config.initial_values.size());

		for (int i = 0; i != values_for_output; ++i) {
			unwrap_bigendian_number<state_item_t>{out.subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) != 0u)
	{
		// this is only used when digest doesn't align with output buffer

		// make sure digest size is smaller than hash state
		static_assert(digest_bytes <= config.initial_values.size() * sizeof(state_item_t));

		// copy result to byte result
		std::array<std::byte, sizeof(state_item_t) * config.initial_values.size()> tmp_buffer;

		for (int i = 0; i != (int)config.initial_values.size(); ++i) {
			unwrap_bigendian_number<state_item_t>{std::span(tmp_buffer).subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}

		std::copy_n(tmp_buffer.data(), digest_bytes, out.data());
	}
};

// this is a convinience type for nicer UX...
template <typename Config> struct hasher: private internal_hasher<Config> {
	using super = internal_hasher<Config>;
	using result_t = typename super::result_t;
	using length_t = typename super::length_t;
	using digest_span_t = typename super::digest_span_t;

	constexpr hasher() noexcept: super() { }
	constexpr hasher(const hasher &) noexcept = default;
	constexpr hasher(hasher &&) noexcept = default;
	constexpr ~hasher() noexcept = default;

	// support for various input types
	constexpr hasher & update(std::span<const std::byte> input) noexcept {
		super::update_to_buffer_and_process(input);
		return *this;
	}

	template <convertible_to_byte_span T> constexpr hasher & update(const T & something) noexcept {
		using value_type = typename decltype(std::span(something))::value_type;
		super::update_to_buffer_and_process(std::span<const value_type>(something));
		return *this;
	}

	template <one_byte_char CharT> constexpr hasher & update(std::basic_string_view<CharT> in) noexcept {
		super::update_to_buffer_and_process(std::span(in.data(), in.size()));
		return *this;
	}

	template <string_literal T> constexpr hasher & update(const T & lit) noexcept {
		super::update_to_buffer_and_process(std::span(lit, std::size(lit) - 1u));
		return *this;
	}

	// TODO: any range with value convertible to byte

	// output (by reference or by value)
	constexpr void final(digest_span_t digest) noexcept {
		super::finalize();
		super::write_result_into(digest);
	}

	constexpr auto final() noexcept {
		result_t output;
		this->final(output);
		return output;
	}

	constexpr length_t size() const noexcept {
		return super::total_length;
	}
};

} // namespace cthash

#endif

#include <array>
#include <span>
#include <concepts>
#include <cstdint>

namespace cthash::sha2 {

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto choice(T e, T f, T g) noexcept -> T {
	return (e bitand f) xor (~e bitand g);
}

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto majority(T a, T b, T c) noexcept -> T {
	return (a bitand b) xor (a bitand c) xor (b bitand c);
}

template <typename Config, typename StageT, size_t StageLength, typename StateT, size_t StateLength>
[[gnu::always_inline]] constexpr void rounds(std::span<const StageT, StageLength> w, std::array<StateT, StateLength> & state) noexcept {
	using state_t = std::array<StateT, StateLength>;

	// create copy of internal state
	auto wvar = state_t(state);

	// just give them names
	auto & [a, b, c, d, e, f, g, h] = wvar;

	// number of rounds is same as constants
	static_assert(StageLength == Config::constants.size());

	for (int i = 0; i != Config::constants.size(); ++i) {
		const auto temp1 = h + Config::sum_e(e) + choice(e, f, g) + Config::constants[static_cast<size_t>(i)] + w[static_cast<size_t>(i)];
		const auto temp2 = Config::sum_a(a) + majority(a, b, c);

		// move around (that's rotate)
		std::rotate(wvar.begin(), wvar.begin() + 7u, wvar.end());

		e += temp1;
		a = temp1 + temp2;

		// originally it was:
		// h = g;
		// g = f;
		// f = e;
		// e = d + temp1;
		// d = c;
		// c = b;
		// b = a;
		// a = temp1 + temp2;
	}

	// add store back
	for (int i = 0; i != (int)state.size(); ++i) {
		state[static_cast<size_t>(i)] += wvar[static_cast<size_t>(i)];
	}
}

} // namespace cthash::sha2

#endif

namespace cthash {

struct sha512_config {
	using length_type = uint64_t;
	static constexpr size_t length_size_bits = 128;

	static constexpr size_t block_bits = 1024u;

	static constexpr auto initial_values = std::array<uint64_t, 8>{0x6a09e667f3bcc908ull, 0xbb67ae8584caa73bull, 0x3c6ef372fe94f82bull, 0xa54ff53a5f1d36f1ull, 0x510e527fade682d1ull, 0x9b05688c2b3e6c1full, 0x1f83d9abfb41bd6bull, 0x5be0cd19137e2179ull};

	// staging functions
	[[gnu::always_inline]] static constexpr auto sigma_0(uint64_t w_15) noexcept -> uint64_t {
		return std::rotr(w_15, 1u) xor std::rotr(w_15, 8u) xor (w_15 >> 7u);
	}

	[[gnu::always_inline]] static constexpr auto sigma_1(uint64_t w_2) noexcept -> uint64_t {
		return std::rotr(w_2, 19u) xor std::rotr(w_2, 61u) xor (w_2 >> 6u);
	}

	// rounds constants...
	static constexpr auto constants = std::array<uint64_t, 80>{
		0x428a2f98d728ae22ull, 0x7137449123ef65cdull, 0xb5c0fbcfec4d3b2full, 0xe9b5dba58189dbbcull, 0x3956c25bf348b538ull,
		0x59f111f1b605d019ull, 0x923f82a4af194f9bull, 0xab1c5ed5da6d8118ull, 0xd807aa98a3030242ull, 0x12835b0145706fbeull,
		0x243185be4ee4b28cull, 0x550c7dc3d5ffb4e2ull, 0x72be5d74f27b896full, 0x80deb1fe3b1696b1ull, 0x9bdc06a725c71235ull,
		0xc19bf174cf692694ull, 0xe49b69c19ef14ad2ull, 0xefbe4786384f25e3ull, 0x0fc19dc68b8cd5b5ull, 0x240ca1cc77ac9c65ull,
		0x2de92c6f592b0275ull, 0x4a7484aa6ea6e483ull, 0x5cb0a9dcbd41fbd4ull, 0x76f988da831153b5ull, 0x983e5152ee66dfabull,
		0xa831c66d2db43210ull, 0xb00327c898fb213full, 0xbf597fc7beef0ee4ull, 0xc6e00bf33da88fc2ull, 0xd5a79147930aa725ull,
		0x06ca6351e003826full, 0x142929670a0e6e70ull, 0x27b70a8546d22ffcull, 0x2e1b21385c26c926ull, 0x4d2c6dfc5ac42aedull,
		0x53380d139d95b3dfull, 0x650a73548baf63deull, 0x766a0abb3c77b2a8ull, 0x81c2c92e47edaee6ull, 0x92722c851482353bull,
		0xa2bfe8a14cf10364ull, 0xa81a664bbc423001ull, 0xc24b8b70d0f89791ull, 0xc76c51a30654be30ull, 0xd192e819d6ef5218ull,
		0xd69906245565a910ull, 0xf40e35855771202aull, 0x106aa07032bbd1b8ull, 0x19a4c116b8d2d0c8ull, 0x1e376c085141ab53ull,
		0x2748774cdf8eeb99ull, 0x34b0bcb5e19b48a8ull, 0x391c0cb3c5c95a63ull, 0x4ed8aa4ae3418acbull, 0x5b9cca4f7763e373ull,
		0x682e6ff3d6b2b8a3ull, 0x748f82ee5defb2fcull, 0x78a5636f43172f60ull, 0x84c87814a1f0ab72ull, 0x8cc702081a6439ecull,
		0x90befffa23631e28ull, 0xa4506cebde82bde9ull, 0xbef9a3f7b2c67915ull, 0xc67178f2e372532bull, 0xca273eceea26619cull,
		0xd186b8c721c0c207ull, 0xeada7dd6cde0eb1eull, 0xf57d4f7fee6ed178ull, 0x06f067aa72176fbaull, 0x0a637dc5a2c898a6ull,
		0x113f9804bef90daeull, 0x1b710b35131c471bull, 0x28db77f523047d84ull, 0x32caab7b40c72493ull, 0x3c9ebe0a15c9bebcull,
		0x431d67c49c100d4cull, 0x4cc5d4becb3e42b6ull, 0x597f299cfc657e2aull, 0x5fcb6fab3ad6faecull, 0x6c44198c4a475817ull};

	[[gnu::always_inline]] static constexpr auto sum_a(uint64_t a) noexcept -> uint64_t {
		return std::rotr(a, 28u) xor std::rotr(a, 34u) xor std::rotr(a, 39u);
	}

	[[gnu::always_inline]] static constexpr auto sum_e(uint64_t e) noexcept -> uint64_t {
		return std::rotr(e, 14u) xor std::rotr(e, 18u) xor std::rotr(e, 41u);
	}

	// rounds
	[[gnu::always_inline]] static constexpr void rounds(std::span<const uint64_t, 80> w, std::array<uint64_t, 8> & state) noexcept {
		return sha2::rounds<sha512_config>(w, state);
	}
};

static_assert(not cthash::internal::digest_length_provided<sha512_config>);
static_assert(cthash::internal::digest_bytes_length_of<sha512_config> == 64u);

using sha512 = hasher<sha512_config>;
using sha512_value = tagged_hash_value<sha512_config>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_sha512() {
		return sha512_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

namespace cthash {

namespace sha256t_support {

	static consteval size_t width_of_decimal(unsigned t) {
		if (t < 10u) {
			return 1u;
		} else if (t < 100u) {
			return 2u;
		} else if (t < 1000u) {
			return 3u;
		} else {
			throw "we don't support more than three digits!";
		}
	}

	template <unsigned Width> static consteval auto generate_signature(unsigned t) {
		const char a = '0' + static_cast<char>((t / 100u) % 10u);
		const char b = '0' + static_cast<char>((t / 10u) % 10u);
		const char c = '0' + static_cast<char>((t / 1u) % 10u);

		if constexpr (Width == 1) {
			return std::array<char, Width + 8u>{'S', 'H', 'A', '-', '5', '1', '2', '/', c};
		} else if constexpr (Width == 2) {
			return std::array<char, Width + 8u>{'S', 'H', 'A', '-', '5', '1', '2', '/', b, c};
		} else if constexpr (Width == 3) {
			return std::array<char, Width + 8u>{'S', 'H', 'A', '-', '5', '1', '2', '/', a, b, c};
		} else {
			throw "we don't support greater width than 3";
		}
	}

} // namespace sha256t_support

static consteval auto calculate_sha512t_iv(std::span<const char> in) {
	auto sha512hasher = internal_hasher<sha512_config>{};

	// modify IV
	for (auto & val: sha512hasher.hash) {
		val = val xor 0xa5a5a5a5a5a5a5a5ull;
	}

	sha512hasher.update_to_buffer_and_process(in);
	sha512hasher.finalize();
	return sha512hasher.hash;
}

template <size_t T> constexpr auto signature_for_sha512t = sha256t_support::generate_signature<sha256t_support::width_of_decimal(T)>(T);
template <size_t T> constexpr auto iv_for_sha512t = calculate_sha512t_iv(signature_for_sha512t<T>);

template <unsigned T> struct sha512t_config: sha512_config {
	static_assert(T % 8u == 0u, "only hashes aligned to bytes are supported");
	static_assert(T != 384u, "sha-512/384 is not allowed, use sha-384 instead");
	static_assert(T <= 512u, "T can't be larger than 512");
	static_assert(T != 0u, "T can't be zero");

	static constexpr size_t digest_length = T / 8u;

	static constexpr std::array<uint64_t, 8> initial_values = iv_for_sha512t<T>;
};

static_assert(cthash::internal::digest_length_provided<sha512t_config<224>>);
static_assert(cthash::internal::digest_length_provided<sha512t_config<256>>);
static_assert(cthash::internal::digest_bytes_length_of<sha512t_config<224>> == 28u);
static_assert(cthash::internal::digest_bytes_length_of<sha512t_config<256>> == 32u);

template <unsigned T> using sha512t = hasher<sha512t_config<T>>;
template <unsigned T> using sha512t_value = tagged_hash_value<sha512t_config<T>>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_sha512_224() {
		return sha512t_value<224>(Value);
	}

	template <fixed_string Value>
	consteval auto operator""_sha512_256() {
		return sha512t_value<256>(Value);
	}

} // namespace literals

} // namespace cthash

#endif

// SHA-3 (keccak) family
#ifndef CTHASH_SHA3_KECCAK_HPP
#define CTHASH_SHA3_KECCAK_HPP

#ifndef CTHASH_SHA3_COMMON_HPP
#define CTHASH_SHA3_COMMON_HPP

#ifndef CTHASH_SHA3_KECCAK_BASE_HPP
#define CTHASH_SHA3_KECCAK_BASE_HPP

#include <array>
#include <bit>
#include <span>
#include <type_traits>
#include <utility>
#include <concepts>
#include <cstdint>

namespace cthash::keccak {

// inspired by tiny-keccak (https://github.com/debris/tiny-keccak from Marek Kotewicz)

static constexpr auto rho = std::array<uint8_t, 24>{1u, 3u, 6u, 10u, 15u, 21u, 28u, 36u, 45u, 55u, 2u, 14u, 27u, 41u, 56u, 8u, 25u, 43u, 62u, 18u, 39u, 61u, 20u, 44u};

static constexpr auto pi = std::array<uint8_t, 24>{10u, 7u, 11u, 17u, 18u, 3u, 5u, 16u, 8u, 21u, 24u, 4u, 15u, 23u, 19u, 13u, 12u, 2u, 20u, 14u, 22u, 9u, 6u, 1u};

static constexpr auto rc = std::array<uint64_t, 24>{0x1ULL, 0x8082ULL, 0x800000000000808aULL, 0x8000000080008000ULL, 0x808bULL, 0x80000001ULL, 0x8000000080008081ULL, 0x8000000000008009ULL, 0x8aULL, 0x88ULL, 0x80008009ULL, 0x8000000aULL, 0x8000808bULL, 0x800000000000008bULL, 0x8000000000008089ULL, 0x8000000000008003ULL, 0x8000000000008002ULL, 0x8000000000000080ULL, 0x800aULL, 0x800000008000000aULL, 0x8000000080008081ULL, 0x8000000000008080ULL, 0x80000001ULL, 0x8000000080008008ULL};

struct state_1600: std::array<uint64_t, (5u * 5u)> { };

struct state_1600_ref: std::span<uint64_t, (5u * 5u)> {
	using super = std::span<uint64_t, (5u * 5u)>;
	using super::super;
};

[[gnu::always_inline, gnu::flatten]] constexpr void theta(state_1600_ref state) noexcept {
	// xor of columns
	const auto b = std::array<uint64_t, 5>{
		state[0] xor state[5] xor state[10] xor state[15] xor state[20],
		state[1] xor state[6] xor state[11] xor state[16] xor state[21],
		state[2] xor state[7] xor state[12] xor state[17] xor state[22],
		state[3] xor state[8] xor state[13] xor state[18] xor state[23],
		state[4] xor state[9] xor state[14] xor state[19] xor state[24],
	};

	const auto tmp = std::array<uint64_t, 5>{
		b[4] xor std::rotl(b[1], 1),
		b[0] xor std::rotl(b[2], 1),
		b[1] xor std::rotl(b[3], 1),
		b[2] xor std::rotl(b[4], 1),
		b[3] xor std::rotl(b[0], 1),
	};

	[&]<size_t... Idx>(std::index_sequence<Idx...>) {
		((state[Idx] ^= tmp[Idx % 5u]), ...);
	}(std::make_index_sequence<25>());
}

[[gnu::always_inline, gnu::flatten]] constexpr void rho_pi(state_1600_ref state) noexcept {
	uint64_t tmp = state[1];

	[&]<size_t... Idx>(std::index_sequence<Idx...>) {
		((state[pi[Idx]] = std::rotl(std::exchange(tmp, state[pi[Idx]]), rho[Idx])), ...);
	}(std::make_index_sequence<24>());
}

[[gnu::always_inline, gnu::flatten]] constexpr void chi(state_1600_ref state) noexcept {
	constexpr auto chi_helper = [](std::span<uint64_t, 5> row) {
		const auto b = std::array<uint64_t, 5>{row[0], row[1], row[2], row[3], row[4]};

		row[0] = b[0] xor ((~b[1]) bitand b[2]);
		row[1] = b[1] xor ((~b[2]) bitand b[3]);
		row[2] = b[2] xor ((~b[3]) bitand b[4]);
		row[3] = b[3] xor ((~b[4]) bitand b[0]);
		row[4] = b[4] xor ((~b[0]) bitand b[1]);
	};

	chi_helper(state.subspan<0>().first<5>());
	chi_helper(state.subspan<5>().first<5>());
	chi_helper(state.subspan<10>().first<5>());
	chi_helper(state.subspan<15>().first<5>());
	chi_helper(state.subspan<20>().first<5>());
}

[[gnu::flatten]] constexpr void keccak_f(state_1600 & state) noexcept {
	// rounds
	for (int i = 0; i != 24; ++i) {
		// theta (xor each column together)
		theta(state);
		rho_pi(state);
		chi(state);
		state[0] ^= rc[static_cast<size_t>(i)];
	}
}

} // namespace cthash::keccak

#endif
#ifndef CONSTEXPR_SHA2_HASHER_HPP
#define CONSTEXPR_SHA2_HASHER_HPP

#ifndef CTHASH_SIMPLE_HPP
#define CTHASH_SIMPLE_HPP

#include <utility>

namespace cthash {

template <typename Hasher, typename In, typename... Args> concept hasher_like = requires(Hasher & h, const In & in, Args &&... args) //
{
	{ Hasher{std::forward<Args>(args)...} };
	{ h.update(in) } -> std::same_as<Hasher &>;
	{ h.final() };
};

template <typename Hasher, typename In> concept direct_hasher = requires(Hasher & h, const In & in) //
{
	{ h.update_and_final(in) };
};

template <typename Hasher, typename T, typename... Args>
requires hasher_like<Hasher, T, Args...>
constexpr auto simple(const T & value, Args &&... args) noexcept {
	if constexpr (direct_hasher<Hasher, T>) {
		return Hasher{std::forward<Args>(args)...}.update_and_final(value);
	} else {
		return Hasher{std::forward<Args>(args)...}.update(value).final();
	}
}

} // namespace cthash

#endif

#ifndef CTHASH_VALUE_HPP
#define CTHASH_VALUE_HPP

#ifndef CTHASH_FIXED_STRING_HPP
#define CTHASH_FIXED_STRING_HPP

#include <algorithm>
#include <span>
#include <string_view>

namespace cthash {

template <typename CharT, size_t N> struct fixed_string: std::array<CharT, N> {
	using super = std::array<CharT, N>;

	consteval static auto from_string_literal(const CharT (&in)[N + 1]) -> std::array<CharT, N> {
		std::array<CharT, N> out;
		std::copy_n(in, N, out.data());
		return out;
	}

	explicit constexpr fixed_string(std::nullptr_t) noexcept: super{} { }

	consteval fixed_string(const CharT (&in)[N + 1]) noexcept: super{from_string_literal(in)} { }

	using super::data;
	using super::size;

	constexpr operator std::span<const CharT, N>() const noexcept {
		return std::span<const CharT, N>(data(), size());
	}

	constexpr operator std::span<const CharT>() const noexcept {
		return std::span<const CharT>(data(), size());
	}

	constexpr operator std::basic_string_view<CharT>() const noexcept {
		return std::basic_string_view<CharT>(data(), size());
	}

	constexpr friend bool operator==(const fixed_string &, const fixed_string &) noexcept = default;
	constexpr friend bool operator==(const fixed_string & lhs, std::basic_string_view<CharT> rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == rhs;
	}
	constexpr friend bool operator==(const fixed_string & lhs, const CharT * rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == std::basic_string_view<CharT>{rhs};
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N - 1>;

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_BASE_HPP
#define CTHASH_ENCODING_BASE_HPP

#ifndef CTHASH_ENCODING_CHUNK_OF_BITS_HPP
#define CTHASH_ENCODING_CHUNK_OF_BITS_HPP

#ifndef CTHASH_ENCODING_BIT_BUFFER_HPP
#define CTHASH_ENCODING_BIT_BUFFER_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <bit>
#include <iostream>
#include <numeric>
#include <ranges>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct select_bit_integer;

template <size_t Bits> requires(Bits <= 8) struct select_bit_integer<Bits> {
	using type = uint8_t;
};

template <size_t Bits> requires(Bits > 8 && Bits <= 16) struct select_bit_integer<Bits> {
	using type = uint16_t;
};

template <size_t Bits> requires(Bits > 16 && Bits <= 32) struct select_bit_integer<Bits> {
	using type = uint32_t;
};

template <size_t Bits> requires(Bits > 32 && Bits <= 64) struct select_bit_integer<Bits> {
	using type = uint64_t;
};

template <size_t Bits> using select_bit_integer_t = select_bit_integer<Bits>::type;

template <size_t V> requires(std::popcount(V) == 1u) constexpr auto log2_of_power_of_2 = static_cast<size_t>(std::countr_zero(V));

template <size_t Bits> constexpr auto mask = static_cast<select_bit_integer_t<Bits>>((static_cast<select_bit_integer_t<Bits>>(1u) << Bits) - 1u);

template <size_t Capacity> class basic_bit_buffer {
public:
	static constexpr auto capacity = std::integral_constant<size_t, Capacity>{};
	using storage_type = select_bit_integer_t<capacity()>;
	using size_type = select_bit_integer_t<log2_of_power_of_2<std::bit_ceil(capacity())>>;

public:
	storage_type buffer{0};
	size_type bits_available{0};

public:
	template <size_t Bits> static constexpr auto mask = static_cast<storage_type>((static_cast<storage_type>(1u) << Bits) - 1u);

	constexpr friend bool operator==(const basic_bit_buffer & lhs, const basic_bit_buffer & rhs) noexcept = default;

	constexpr size_type size() const noexcept {
		return bits_available;
	}

	constexpr size_type unused_size() const noexcept {
		return capacity() - bits_available;
	}

	constexpr bool empty() const noexcept {
		return bits_available == 0u;
	}

	constexpr bool full() const noexcept {
		return bits_available == capacity();
	}

	template <size_t Bits> constexpr void push(select_bit_integer_t<Bits> in) noexcept requires(Bits <= capacity()) {
		assert(size() <= capacity() - Bits);
		buffer = static_cast<storage_type>(buffer << Bits) | static_cast<storage_type>(in);
		bits_available += static_cast<size_type>(Bits);
	}
	constexpr void push_empty_bits(size_t count) noexcept {
		buffer = static_cast<storage_type>(buffer << count);
		bits_available += static_cast<unsigned char>(count);
	}

	template <size_t Bits> constexpr void pop() noexcept requires(Bits <= capacity()) {
		assert(size() >= Bits);
		bits_available -= static_cast<size_type>(Bits);
	}

	template <size_t Bits> constexpr auto front() const noexcept -> select_bit_integer_t<Bits> requires(Bits <= capacity()) {
		using output_type = select_bit_integer_t<Bits>;
		assert(size() >= static_cast<size_type>(Bits));
		return static_cast<output_type>((buffer >> (bits_available - Bits))) & mask<Bits>;
	}
};

constexpr size_t calculate_padding_bit_count(size_t number_of_bits_in_buffer, size_t output_size, size_t input_size) {
	size_t n = number_of_bits_in_buffer;
	size_t padding_bits = 0u;

	while (n != 0u) {
		padding_bits += input_size;
		n += input_size;

		while (n >= output_size) {
			n = n - output_size;
		}
	}

	return padding_bits;
}

template <size_t OutBits, size_t InBits = 8u> class bit_buffer: protected basic_bit_buffer<std::lcm(OutBits, InBits)> {
	using super = basic_bit_buffer<std::lcm(OutBits, InBits)>;

public:
	constexpr bit_buffer() noexcept = default;

	using typename super::size_type;
	static constexpr auto out_bits = std::integral_constant<size_type, OutBits>{};
	static constexpr auto in_bits = std::integral_constant<size_type, InBits>{};

	using out_type = select_bit_integer_t<OutBits>;
	using in_type = select_bit_integer_t<InBits>;

	using super::capacity;
	static constexpr auto in_capacity = std::integral_constant<size_type, (capacity() / in_bits())>{};
	static constexpr auto out_capacity = std::integral_constant<size_type, (capacity() / out_bits())>{};

	static constexpr auto aligned = std::bool_constant<capacity() == in_capacity()>{};

	constexpr void push(in_type in) noexcept {
		super::template push<in_bits>(in);
	}

	constexpr void push_empty() noexcept {
		this->push(in_type{0u});
	}

	constexpr size_type push_zeros_to_align() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_to_align() noexcept requires(!aligned()) {
		if (empty()) {
			return 0u;
		}

		assert(out_bits > super::size());
		const size_type missing_bits = static_cast<size_type>(out_bits - super::size());
		super::push_empty_bits(missing_bits);
		return missing_bits;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(!aligned()) {
		const size_type usable_bits = super::size();
		const size_type missing_bits = static_cast<size_type>(calculate_padding_bit_count(super::size(), out_bits, in_bits));
		super::push_empty_bits(missing_bits);
		return usable_bits;
	}

	constexpr void pop() noexcept {
		super::template pop<out_bits>();
	}

	constexpr auto front() const noexcept -> out_type {
		return super::template front<out_bits>();
	}

	constexpr size_type size() const noexcept {
		return static_cast<size_type>(super::size() / out_bits);
	}

	constexpr size_type unused_size() const noexcept {
		return static_cast<size_type>(super::unused_size() / in_bits);
	}

	using super::empty;
	using super::full;

	constexpr bool has_bits_for_pop() const noexcept {
		return super::size() >= out_bits;
	}

	constexpr bool has_capacity_for_push() const noexcept {
		return super::size() <= (capacity() - in_bits);
	}
};

} // namespace cthash

#endif

#include <iostream>
#include <ranges>

namespace cthash {

template <typename Buffer> struct buffer_result_type;

template <typename Buffer> requires(Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	static constexpr Buffer::size_type missing_bits = {0u};

	constexpr bool is_padding() const noexcept {
		return false;
	}
};

template <typename Buffer> requires(!Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	typename Buffer::size_type missing_bits;

	constexpr bool is_padding() const noexcept {
		return missing_bits == Buffer::out_bits;
	}
};

template <typename Buffer, bool AllowPadding> struct buffer_with_missing_bits;

template <typename Buffer, bool AllowPadding> requires(Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};

	struct result_type {
		typename Buffer::out_type value;
		static constexpr Buffer::size_type missing_bits = {0u};

		constexpr bool is_padding() const noexcept {
			return false;
		}
	};

	static constexpr bool aligned = Buffer::aligned();

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		return result_type{buffer.front()};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		while (!buffer.has_bits_for_pop() && (it != end)) {
			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <typename Buffer, bool AllowPadding> requires(!Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};
	Buffer::size_type missing_bits{0};

	static constexpr bool aligned = Buffer::aligned();

	struct result_type {
		typename Buffer::out_type value;
		typename Buffer::size_type missing_bits;

		constexpr bool is_padding() const noexcept {
			return missing_bits == Buffer::out_bits;
		}
	};

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		assert(Buffer::out_bits >= missing_bits);
		return result_type{buffer.front(), missing_bits};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	constexpr void pad_buffer() noexcept requires(AllowPadding) {
		// full multi-chunk padding (for baseN encodings)
		missing_bits = (Buffer::out_bits - buffer.push_zeros_for_padding());
	}

	constexpr void pad_buffer() noexcept requires(!AllowPadding) {
		// only add enough zero to finish current output chunk
		missing_bits = buffer.push_zeros_to_align();
	}

	constexpr void saturate_missing_bits() noexcept requires(AllowPadding) {
		if (missing_bits) {
			missing_bits = Buffer::out_bits;
		}
		// missing_bits = static_cast<buffer_size_t>((unsigned)(bool)missing_bits * output_value_bit_size);
	}

	constexpr void saturate_missing_bits() noexcept requires(!AllowPadding) {
		// do nothing :)
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		for (;;) {
			if (it == end) {
				if (buffer.has_bits_for_pop()) {
					// if this is second pass after padding we can mark all bits as missing
					saturate_missing_bits();
				} else {
					// fill remainder of buffer with zeros
					pad_buffer();
				}

				return;
			}

			if (buffer.has_bits_for_pop()) {
				return;
			}

			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <bool Value> struct conditional;

template <> struct conditional<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional<false> {
	template <typename, typename T> using type = T;
};

template <bool Const, typename T> using maybe_const = typename conditional<Const>::template type<const T, T>;

template <typename T> concept integral_like = std::integral<T> || std::same_as<std::byte, T>;

template <size_t Bits, bool AllowPadding, std::ranges::input_range Input> requires integral_like<std::ranges::range_value_t<Input>> struct chunk_of_bits_view {
	using input_value_type = std::ranges::range_value_t<Input>;

	static constexpr size_t output_value_bit_size = Bits;
	static constexpr size_t input_value_bit_size = sizeof(input_value_type) * 8u;
	using buffer_t = cthash::bit_buffer<output_value_bit_size, input_value_bit_size>;
	using buffer_size_t = buffer_t::size_type;
	Input input;

	static constexpr bool aligned = buffer_t::aligned;

	struct sentinel { };

	template <bool Const> struct iterator {
		using parent = maybe_const<Const, Input>;
		using storage_type = buffer_with_missing_bits<buffer_t, AllowPadding>;
		using value_type = storage_type::result_type;
		using difference_type = intptr_t;

		std::ranges::iterator_t<parent> it;
		[[no_unique_address]] std::ranges::sentinel_t<parent> end;

		storage_type buffer{};

		constexpr iterator(parent & p) noexcept: it{std::ranges::begin(p)}, end{std::ranges::end(p)} {
			// initialize
			buffer.feed_buffer(it, end);
		}

		iterator(const iterator &) = default;
		iterator(iterator &&) = default;

		iterator & operator=(const iterator &) = default;
		iterator & operator=(iterator &&) = default;

		constexpr iterator & operator++() noexcept {
			buffer.pop();
			buffer.feed_buffer(it, end);
			return *this;
		}

		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			this->operator++();
			return copy;
		}

		constexpr auto operator*() const noexcept {
			return buffer.front();
		}

		constexpr friend bool operator==(const iterator & lhs, const iterator & rhs) noexcept = default;

		constexpr friend bool operator==(const iterator & self, sentinel) noexcept {
			return self.buffer.empty();
		}
	};

	static_assert(std::input_iterator<iterator<true>>);
	static_assert(std::input_iterator<iterator<false>>);
	static_assert(std::sentinel_for<sentinel, iterator<true>>);
	static_assert(std::sentinel_for<sentinel, iterator<false>>);

	constexpr chunk_of_bits_view(Input _input) noexcept: input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input};
	}

	constexpr auto end() const noexcept {
		return sentinel{};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && AllowPadding) {
		// calculate with blocks
		return ((std::ranges::size(input) + (buffer_t::in_capacity() - 1u)) / buffer_t::in_capacity()) * buffer_t::out_capacity();
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && !AllowPadding) {
		// calculate with bits
		const size_t bit_size_of_input = std::ranges::size(input) * input_value_bit_size;
		return (bit_size_of_input + (output_value_bit_size - 1u)) / output_value_bit_size;
	}
};

template <size_t Bits, bool AllowPadding> struct chunk_of_bits_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, chunk_of_bits_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) {
		return chunk_of_bits_view<Bits, AllowPadding, R>(std::forward<R>(input));
	}
};

template <size_t Bits, bool AllowPadding = false> constexpr auto chunk_of_bits = chunk_of_bits_action<Bits, AllowPadding>{};

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#include <bit>

namespace cthash {

template <typename Encoding> struct encoding_properties {
	static constexpr size_t size = std::size(Encoding::alphabet) - 1u;
	static_assert(std::popcount(size) == 1u, "Size of encoding's alphabet must be power-of-two");

	static constexpr size_t bits = std::countr_zero(size);

	static constexpr bool has_padding = padded_encoding<Encoding>;

	static constexpr char padding = [] {
		if constexpr (has_padding) {
			return Encoding::padding;
		} else {
			return '\0';
		}
	}();
};

template <typename Encoding, typename CharT, typename R> struct encode_to_view {
	using properties = encoding_properties<Encoding>;
	using chunk_view = cthash::chunk_of_bits_view<properties::bits, properties::has_padding, R>;

	struct sentinel {
		[[no_unique_address]] chunk_view::sentinel end;
	};

	template <bool Const> struct iterator {
		using difference_type = intptr_t;
		using value_type = CharT;

		chunk_view::template iterator<Const> it;

		constexpr iterator & operator++() noexcept {
			++it;
			return *this;
		}
		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			++it;
			return copy;
		}

		constexpr value_type operator*() const noexcept {
			const auto tmp = *it;
			if constexpr (!chunk_view::aligned) {
				// TODO: do without condition
				if (tmp.is_padding()) {
					return properties::padding;
				}
			}
			return static_cast<value_type>(Encoding::alphabet[static_cast<unsigned>(tmp.value)]);
		}

		constexpr friend bool operator==(const iterator &, const iterator &) noexcept = default;

		constexpr friend bool operator==(const iterator & lhs, const sentinel & rhs) noexcept {
			return lhs.it == rhs.end;
		}
	};

	chunk_view input;

	constexpr encode_to_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}

	constexpr auto to_string() const requires(std::ranges::sized_range<R>) {
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(*this);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(size());
		auto [i, o] = std::ranges::copy(begin(), end(), result.begin());
		assert(i == result.end());
		assert(o == result.end());
		return result;
#endif
	}

	constexpr friend std::basic_ostream<CharT> & operator<<(std::basic_ostream<CharT> & out, encode_to_view in) {
		std::ranges::copy(in.begin(), in.end(), std::ostream_iterator<CharT, CharT>(out));
		return out;
	}
};

template <typename Encoding, typename ValueT, typename R> struct decode_from_view {
	R input;

	template <bool Const> struct iterator { };
	struct sentinel { };

	constexpr decode_from_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}
};

template <typename Encoding, typename CharT = char> struct encode_to_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, encode_to_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return encode_to_view<Encoding, CharT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename ValueT = unsigned char> struct decode_from_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, decode_from_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return decode_from_view<Encoding, ValueT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename CharT = char> constexpr auto encode_to = encode_to_action<Encoding, CharT>{};
template <typename Encoding, typename ValueT = unsigned char> constexpr auto decode_from = decode_from_action<Encoding, ValueT>{};

constexpr auto binary_encode = encode_to<encoding::base2, char>;
constexpr auto base2_encode = encode_to<encoding::base2, char>;
constexpr auto base4_encode = encode_to<encoding::base4, char>;
constexpr auto base8_encode = encode_to<encoding::base8, char>;
constexpr auto octal_encode = encode_to<encoding::base8, char>;
constexpr auto hexdec_encode = encode_to<encoding::base16, char>;
constexpr auto hexdec_uppercase_encode = encode_to<encoding::base16_uppercase, char>;
constexpr auto base16_encode = encode_to<encoding::base16, char>;
constexpr auto base32_encode = encode_to<encoding::base32, char>;
constexpr auto base32_no_padding_encode = encode_to<encoding::base32_no_padding, char>;
constexpr auto z_base32_encode = encode_to<encoding::z_base32, char>;
constexpr auto base64_encode = encode_to<encoding::base64, char>;
constexpr auto base64url_encode = encode_to<encoding::base64url, char>;
constexpr auto base64_no_padding_encode = encode_to<encoding::base64_no_padding, char>;

constexpr auto binary_decode = decode_from<encoding::base2, char>;
constexpr auto base2_decode = decode_from<encoding::base2, char>;
constexpr auto base4_decode = decode_from<encoding::base4, char>;
constexpr auto base8_decode = decode_from<encoding::base8, char>;
constexpr auto hexdec_decode = decode_from<encoding::base16, char>;
constexpr auto base16_decode = decode_from<encoding::base16, char>;
constexpr auto base32_decode = decode_from<encoding::base32, char>;
constexpr auto z_base32_decode = decode_from<encoding::z_base32, char>;
constexpr auto base64_decode = decode_from<encoding::base64, char>;
constexpr auto base64url_decode = decode_from<encoding::base64url, char>;
constexpr auto base64_no_padding_decode = decode_from<encoding::base64_no_padding, char>;

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

// template <typename Encoding, typename CharT, typename R> struct encode_to_view

#ifdef CTHASH_STDFMT_AVAILABLE
template <typename Encoding, typename R, typename CharT>
struct formatter<cthash::encode_to_view<Encoding, CharT, R>, CharT> {
	using subject_type = cthash::encode_to_view<Encoding, CharT, R>;

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		return std::ranges::begin(ctx);
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return std::ranges::copy(value, ctx.out()).out;
	}
};

#endif

} // namespace std

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_ALGORITHM_HPP
#define CTHASH_INTERNAL_ALGORITHM_HPP

#include <numeric>
#include <compare>
#include <cstddef>
#include <cstdint>

namespace cthash::internal {

template <typename It1, typename It2> constexpr auto threeway_compare_of_same_size(It1 lhs, It2 rhs, size_t length) -> std::strong_ordering {
	for (size_t i = 0; i != length; ++i) {
		if (const auto r = (*lhs++ <=> *rhs++); std::is_neq(r)) {
			return r;
		}
	}

	return std::strong_ordering::equal;
}

template <typename T, typename It1, typename It2, typename Stream> constexpr auto & push_to_stream_as(It1 f, It2 l, Stream & stream) {
	constexpr auto cast_and_shift = [](Stream * s, const auto & rhs) { (*s) << T{rhs}; return s; };
	return *std::accumulate(f, l, &stream, cast_and_shift);
}

} // namespace cthash::internal

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_HEXDEC_HPP
#define CTHASH_INTERNAL_HEXDEC_HPP

#include <array>
#include <ostream>
#include <span>
#include <type_traits>
#include <cstdint>

namespace cthash::internal {

consteval auto get_hexdec_table() noexcept {
	std::array<uint8_t, 128> result;

	auto char_to_hexdec = [](char c) {
		if (c >= '0' && c <= '9') {
			return static_cast<uint8_t>(c - '0');
		} else if (c >= 'a' && c <= 'f') {
			return static_cast<uint8_t>(c - 'a' + 10);
		} else if (c >= 'A' && c <= 'F') {
			return static_cast<uint8_t>(c - 'A' + 10);
		} else {
			return static_cast<uint8_t>(0);
		}
	};

	for (size_t i = 0; i != result.size(); ++i) {
		result[i] = char_to_hexdec(static_cast<char>(i));
	}

	return result;
}

constexpr auto hexdec_to_value_alphabet = get_hexdec_table();

template <typename CharT> constexpr auto value_to_hexdec_alphabet = std::array<CharT, 16>{CharT('0'), CharT('1'), CharT('2'), CharT('3'), CharT('4'), CharT('5'), CharT('6'), CharT('7'), CharT('8'), CharT('9'), CharT('a'), CharT('b'), CharT('c'), CharT('d'), CharT('e'), CharT('f')};

struct byte_hexdec_value {
	std::byte val;

	template <typename CharT, typename Traits> friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, byte_hexdec_value rhs) {
		return os << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val >> 4u)] << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val) & 0b1111u];
	}
};

template <size_t N, typename CharT> constexpr auto hexdec_to_binary(std::span<const CharT, N * 2> in) -> std::array<std::byte, N> {
	return [in]<size_t... Idx>(std::index_sequence<Idx...>) {
		return std::array<std::byte, N>{static_cast<std::byte>(hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2]) & 0b0111'1111u] << 4u | hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2u + 1u]) & 0b0111'1111u])...};
	}(std::make_index_sequence<N>());
}

template <typename CharT, size_t N>
requires((N - 1) % 2 == 0) // -1 because of zero terminator in literals
constexpr auto literal_hexdec_to_binary(const CharT (&in)[N]) -> std::array<std::byte, (N - 1) / 2> {
	return hexdec_to_binary<N / 2>(std::span<const char, N - 1>(in, N - 1));
}

} // namespace cthash::internal

#endif

#include <algorithm>
#include <array>
#include <format>
#include <span>
#include <string_view>
#include <compare>

namespace cthash {

// hash_value

template <size_t N> struct hash_value: std::array<std::byte, N> {
	using super = std::array<std::byte, N>;

	constexpr hash_value() noexcept: super{} { }
	explicit constexpr hash_value(super && s) noexcept: super(s) { }
	template <typename CharT> explicit constexpr hash_value(const CharT (&in)[N * 2u + 1u]) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in, N * 2u))} { }
	template <typename CharT> explicit constexpr hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in.data(), in.size()))} { }

	// comparison support
	constexpr friend bool operator==(const hash_value & lhs, const hash_value & rhs) noexcept = default;
	constexpr friend auto operator<=>(const hash_value & lhs, const hash_value & rhs) noexcept -> std::strong_ordering {
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), N);
	}

	template <typename Encoding = cthash::encoding::hexdec, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		auto hexdec_view = *this | cthash::encode_to<Encoding, CharT>;
		std::ranges::copy(hexdec_view, std::ostream_iterator<CharT, CharT>(os));
		return os;
	}

	// print to ostream support
	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const hash_value & val) {
		return val.print_into(os);
	}

	template <size_t PrefixN> constexpr auto prefix() const noexcept requires(PrefixN <= N) {
		hash_value<PrefixN> output{};
		std::ranges::copy(this->begin(), this->begin() + PrefixN, output.begin());
		return output;
	}

	template <size_t SuffixN> constexpr auto suffix() const noexcept requires(SuffixN <= N) {
		hash_value<SuffixN> output{};
		std::ranges::copy(this->end() - SuffixN, this->end(), output.begin());
		return output;
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(encoded);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(encoded.size());
		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());
		return result;
#endif
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_fixed_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
		// it's type dependendent so we can calculate the size...
		constexpr size_t size_needed = (hash_value{} | cthash::encode_to<Encoding, CharT>).size();

		auto result = cthash::fixed_string<CharT, size_needed>{nullptr};

		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());

		return result;
	}
};

template <typename CharT, size_t N> hash_value(const CharT (&)[N]) -> hash_value<(N - 1u) / 2u>;
template <typename CharT, size_t N> hash_value(std::span<const CharT, N>) -> hash_value<N / 2u>;
template <typename CharT, size_t N> hash_value(const fixed_string<CharT, N> &) -> hash_value<N / 2u>;

template <typename> struct default_encoding {
	using encoding = cthash::encoding::hexdec;
};

template <typename Tag> concept tag_with_encoding = requires() {
	typename Tag::encoding;
};

template <tag_with_encoding Tag> struct default_encoding<Tag> {
	using encoding = Tag::encoding;
};

template <typename Tag, size_t = internal::digest_bytes_length_of<Tag>> struct tagged_hash_value: hash_value<internal::digest_bytes_length_of<Tag>> {
	static constexpr size_t N = internal::digest_bytes_length_of<Tag>;

	using super = hash_value<N>;
	using super::super;
	template <typename CharT> explicit constexpr tagged_hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{in} { }

	static constexpr size_t digest_length = N;

	template <typename Encoding = default_encoding<Tag>::encoding, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		return super::template print_into<Encoding>(os);
	}

	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const tagged_hash_value & val) {
		return val.print_into(os);
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_string(const tagged_hash_value & value) {
		return to_string<Encoding, CharT>(static_cast<const super &>(value));
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_fixed_string(const tagged_hash_value & value) {
		return to_fixed_string<Encoding, CharT>(static_cast<const super &>(value));
	}
};

template <typename T> concept variable_digest_length = T::digest_length_bit == 0u;

template <size_t N, variable_digest_length Tag> struct variable_bit_length_tag: Tag {
	static constexpr size_t digest_length_bit = N;
};

template <typename T> concept convertible_to_tagged_hash_value = requires(const T & obj) {
	{ tagged_hash_value{obj} };
};

namespace literals {

	template <fixed_string Value>
	constexpr auto operator""_hash() {
		return hash_value(Value);
	}

} // namespace literals

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#if _LIBCPP_VERSION >= 170000
// libc++ will define __cpp_lib_format macro in 19.0
// https://github.com/llvm/llvm-project/issues/77773
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#ifdef CTHASH_STDFMT_AVAILABLE
template <size_t N, typename CharT>
struct formatter<cthash::hash_value<N>, CharT> {
	using subject_type = cthash::hash_value<N>;
	using default_encoding = cthash::encoding::hexdec;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <typename Tag, size_t N, typename CharT>
struct formatter<cthash::tagged_hash_value<Tag, N>, CharT> {
	using subject_type = cthash::tagged_hash_value<Tag, N>;
	using default_encoding = typename cthash::default_encoding<Tag>::encoding;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <cthash::convertible_to_tagged_hash_value Type, typename CharT> struct formatter<Type, CharT>: formatter<decltype(cthash::tagged_hash_value{std::declval<Type>()}), CharT> {
};

#endif

} // namespace std

#endif

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_CONVERT_HPP
#define CTHASH_INTERNAL_CONVERT_HPP

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#include <span>
#include <type_traits>
#include <cstddef>
#include <cstdint>
#include <cstring>

namespace cthash {

template <typename It1, typename It2, typename It3> constexpr auto byte_copy(It1 first, It2 last, It3 destination) {
	return std::transform(first, last, destination, [](byte_like auto v) { return static_cast<std::byte>(v); });
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << ((sizeof(T) - 1u - Idx) * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::little) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_le_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << static_cast<T>(Idx * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::big) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T> struct unwrap_littleendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> (Idx * 8u))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_littleendian_number(std::span<std::byte, 8>) -> unwrap_littleendian_number<uint64_t>;
unwrap_littleendian_number(std::span<std::byte, 4>) -> unwrap_littleendian_number<uint32_t>;

template <std::unsigned_integral T> struct unwrap_bigendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> ((bits - 8u) - 8u * Idx))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_bigendian_number(std::span<std::byte, 8>) -> unwrap_bigendian_number<uint64_t>;
unwrap_bigendian_number(std::span<std::byte, 4>) -> unwrap_bigendian_number<uint32_t>;

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#include <algorithm>
#include <array>
#include <span>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <typename Config> struct internal_hasher {
	static constexpr auto config = Config{};
	static constexpr size_t block_size_bytes = config.block_bits / 8u;
	static constexpr size_t digest_bytes = internal::digest_bytes_length_of<Config>;

	// internal types
	using state_value_t = std::remove_cvref_t<decltype(Config::initial_values)>;
	using state_item_t = typename state_value_t::value_type;

	using block_value_t = std::array<std::byte, block_size_bytes>;
	using block_view_t = std::span<const std::byte, block_size_bytes>;

	using staging_item_t = typename decltype(config.constants)::value_type;
	static constexpr size_t staging_size = config.constants.size();
	using staging_value_t = std::array<staging_item_t, staging_size>;
	using staging_view_t = std::span<const staging_item_t, staging_size>;

	using digest_span_t = std::span<std::byte, digest_bytes>;
	using result_t = cthash::tagged_hash_value<Config>;
	using length_t = typename Config::length_type;

	// internal state
	state_value_t hash;
	length_t total_length;

	block_value_t block;
	unsigned block_used;

	// constructors
	constexpr internal_hasher() noexcept: hash{config.initial_values}, total_length{0u}, block_used{0u} { }
	constexpr internal_hasher(const internal_hasher &) noexcept = default;
	constexpr internal_hasher(internal_hasher &&) noexcept = default;
	constexpr ~internal_hasher() noexcept = default;

	// take buffer and build staging
	template <byte_like Byte> [[gnu::always_inline]] static constexpr auto build_staging(std::span<const Byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		staging_value_t w;

		constexpr auto first_part_size = block_size_bytes / sizeof(staging_item_t);

		// fill first part with chunk
		for (int i = 0; i != int(first_part_size); ++i) {
			w[static_cast<size_t>(i)] = cast_from_bytes<staging_item_t>(chunk.subspan(static_cast<size_t>(i) * sizeof(staging_item_t)).template first<sizeof(staging_item_t)>());
		}

		// fill the rest (generify)
		for (int i = int(first_part_size); i != int(staging_size); ++i) {
			w[static_cast<size_t>(i)] = w[static_cast<size_t>(i - 16)] + config.sigma_0(w[static_cast<size_t>(i - 15)]) + w[static_cast<size_t>(i - 7)] + config.sigma_1(w[static_cast<size_t>(i - 2)]);
		}

		return w;
	}

	[[gnu::always_inline]] static constexpr auto build_staging(std::span<const std::byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		return build_staging<std::byte>(chunk);
	}

	[[gnu::always_inline]] static constexpr void rounds(staging_view_t w, state_value_t & state) noexcept {
		config.rounds(w, state);
	}

	// this implementation works only with input size aligned to bytes (not bits)
	template <byte_like T> [[gnu::always_inline]] constexpr void update_to_buffer_and_process(std::span<const T> in) noexcept {
		// if block is not used, we can build staging directly
		if (block_used) {
			const auto remaining_free_space = std::span<std::byte, block_size_bytes>(block).subspan(block_used);
			const auto to_copy = in.first(std::min(in.size(), remaining_free_space.size()));

			const auto it = byte_copy(to_copy.begin(), to_copy.end(), remaining_free_space.begin());
			total_length += to_copy.size();

			// we didn't fill the block
			if (it != remaining_free_space.end()) {
				assert(to_copy.size() == in.size());
				block_used += static_cast<unsigned>(to_copy.size());
				return;
			} else {
				block_used = 0u;
			}

			// we have block!
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// remove part we processed
			in = in.subspan(to_copy.size());
		}

		// do the work over blocks without copy
		if (not block_used) {
			while (in.size() >= block_size_bytes) {
				const auto local_block = in.template first<block_size_bytes>();
				total_length += block_size_bytes;

				const staging_value_t w = build_staging<T>(local_block);
				rounds(w, hash);

				// remove part we processed
				in = in.subspan(block_size_bytes);
			}
		}

		// remainder is put onto temporary block
		if (not in.empty()) {
			assert(block_used == 0u);
			assert(in.size() < block_size_bytes);

			// copy it to block and let it stay there
			byte_copy(in.begin(), in.end(), block.begin());
			block_used = static_cast<unsigned>(in.size());
			total_length += block_used;
		}
	}

	[[gnu::always_inline]] static constexpr bool finalize_buffer(block_value_t & block, size_t block_used) noexcept {
		assert(block_used < block.size());
		const auto free_space = std::span(block).subspan(block_used);

		auto it = free_space.data();
		*it++ = std::byte{0b1000'0000u};							   // first byte after data contains bit at MSB
		std::fill(it, (block.data() + block.size()), std::byte{0x0u}); // rest is filled with zeros

		// we don't have enough space to write length bits
		return free_space.size() < (1u + (config.length_size_bits / 8u));
	}

	[[gnu::always_inline]] static constexpr void finalize_buffer_by_writing_length(block_value_t & block, length_t total_length) noexcept {
		unwrap_bigendian_number{std::span(block).template last<sizeof(length_t)>()} = (total_length * 8u);
	}

	[[gnu::always_inline]] constexpr void finalize() noexcept {
		if (finalize_buffer(block, block_used)) {
			// we didn't have enough space, we need to process block
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// zero it out
			std::fill(block.begin(), block.end(), std::byte{0x0u});
		}

		// we either have space to write or we have zerod out block
		finalize_buffer_by_writing_length(block, total_length);

		// calculate last round
		const staging_value_t w = build_staging(block);
		rounds(w, hash);
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) == 0u)
	{
		// copy result to byte result
		constexpr size_t values_for_output = digest_bytes / sizeof(state_item_t);
		static_assert(values_for_output <= config.initial_values.size());

		for (int i = 0; i != values_for_output; ++i) {
			unwrap_bigendian_number<state_item_t>{out.subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) != 0u)
	{
		// this is only used when digest doesn't align with output buffer

		// make sure digest size is smaller than hash state
		static_assert(digest_bytes <= config.initial_values.size() * sizeof(state_item_t));

		// copy result to byte result
		std::array<std::byte, sizeof(state_item_t) * config.initial_values.size()> tmp_buffer;

		for (int i = 0; i != (int)config.initial_values.size(); ++i) {
			unwrap_bigendian_number<state_item_t>{std::span(tmp_buffer).subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}

		std::copy_n(tmp_buffer.data(), digest_bytes, out.data());
	}
};

// this is a convinience type for nicer UX...
template <typename Config> struct hasher: private internal_hasher<Config> {
	using super = internal_hasher<Config>;
	using result_t = typename super::result_t;
	using length_t = typename super::length_t;
	using digest_span_t = typename super::digest_span_t;

	constexpr hasher() noexcept: super() { }
	constexpr hasher(const hasher &) noexcept = default;
	constexpr hasher(hasher &&) noexcept = default;
	constexpr ~hasher() noexcept = default;

	// support for various input types
	constexpr hasher & update(std::span<const std::byte> input) noexcept {
		super::update_to_buffer_and_process(input);
		return *this;
	}

	template <convertible_to_byte_span T> constexpr hasher & update(const T & something) noexcept {
		using value_type = typename decltype(std::span(something))::value_type;
		super::update_to_buffer_and_process(std::span<const value_type>(something));
		return *this;
	}

	template <one_byte_char CharT> constexpr hasher & update(std::basic_string_view<CharT> in) noexcept {
		super::update_to_buffer_and_process(std::span(in.data(), in.size()));
		return *this;
	}

	template <string_literal T> constexpr hasher & update(const T & lit) noexcept {
		super::update_to_buffer_and_process(std::span(lit, std::size(lit) - 1u));
		return *this;
	}

	// TODO: any range with value convertible to byte

	// output (by reference or by value)
	constexpr void final(digest_span_t digest) noexcept {
		super::finalize();
		super::write_result_into(digest);
	}

	constexpr auto final() noexcept {
		result_t output;
		this->final(output);
		return output;
	}

	constexpr length_t size() const noexcept {
		return super::total_length;
	}
};

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_CONVERT_HPP
#define CTHASH_INTERNAL_CONVERT_HPP

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#include <span>
#include <type_traits>
#include <cstddef>
#include <cstdint>
#include <cstring>

namespace cthash {

template <typename It1, typename It2, typename It3> constexpr auto byte_copy(It1 first, It2 last, It3 destination) {
	return std::transform(first, last, destination, [](byte_like auto v) { return static_cast<std::byte>(v); });
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << ((sizeof(T) - 1u - Idx) * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::little) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_le_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << static_cast<T>(Idx * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::big) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T> struct unwrap_littleendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> (Idx * 8u))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_littleendian_number(std::span<std::byte, 8>) -> unwrap_littleendian_number<uint64_t>;
unwrap_littleendian_number(std::span<std::byte, 4>) -> unwrap_littleendian_number<uint32_t>;

template <std::unsigned_integral T> struct unwrap_bigendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> ((bits - 8u) - 8u * Idx))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_bigendian_number(std::span<std::byte, 8>) -> unwrap_bigendian_number<uint64_t>;
unwrap_bigendian_number(std::span<std::byte, 4>) -> unwrap_bigendian_number<uint32_t>;

} // namespace cthash

#endif

#ifndef CTHASH_SIMPLE_HPP
#define CTHASH_SIMPLE_HPP

#include <utility>

namespace cthash {

template <typename Hasher, typename In, typename... Args> concept hasher_like = requires(Hasher & h, const In & in, Args &&... args) //
{
	{ Hasher{std::forward<Args>(args)...} };
	{ h.update(in) } -> std::same_as<Hasher &>;
	{ h.final() };
};

template <typename Hasher, typename In> concept direct_hasher = requires(Hasher & h, const In & in) //
{
	{ h.update_and_final(in) };
};

template <typename Hasher, typename T, typename... Args>
requires hasher_like<Hasher, T, Args...>
constexpr auto simple(const T & value, Args &&... args) noexcept {
	if constexpr (direct_hasher<Hasher, T>) {
		return Hasher{std::forward<Args>(args)...}.update_and_final(value);
	} else {
		return Hasher{std::forward<Args>(args)...}.update(value).final();
	}
}

} // namespace cthash

#endif

#ifndef CTHASH_VALUE_HPP
#define CTHASH_VALUE_HPP

#ifndef CTHASH_FIXED_STRING_HPP
#define CTHASH_FIXED_STRING_HPP

#include <algorithm>
#include <span>
#include <string_view>

namespace cthash {

template <typename CharT, size_t N> struct fixed_string: std::array<CharT, N> {
	using super = std::array<CharT, N>;

	consteval static auto from_string_literal(const CharT (&in)[N + 1]) -> std::array<CharT, N> {
		std::array<CharT, N> out;
		std::copy_n(in, N, out.data());
		return out;
	}

	explicit constexpr fixed_string(std::nullptr_t) noexcept: super{} { }

	consteval fixed_string(const CharT (&in)[N + 1]) noexcept: super{from_string_literal(in)} { }

	using super::data;
	using super::size;

	constexpr operator std::span<const CharT, N>() const noexcept {
		return std::span<const CharT, N>(data(), size());
	}

	constexpr operator std::span<const CharT>() const noexcept {
		return std::span<const CharT>(data(), size());
	}

	constexpr operator std::basic_string_view<CharT>() const noexcept {
		return std::basic_string_view<CharT>(data(), size());
	}

	constexpr friend bool operator==(const fixed_string &, const fixed_string &) noexcept = default;
	constexpr friend bool operator==(const fixed_string & lhs, std::basic_string_view<CharT> rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == rhs;
	}
	constexpr friend bool operator==(const fixed_string & lhs, const CharT * rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == std::basic_string_view<CharT>{rhs};
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N - 1>;

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_BASE_HPP
#define CTHASH_ENCODING_BASE_HPP

#ifndef CTHASH_ENCODING_CHUNK_OF_BITS_HPP
#define CTHASH_ENCODING_CHUNK_OF_BITS_HPP

#ifndef CTHASH_ENCODING_BIT_BUFFER_HPP
#define CTHASH_ENCODING_BIT_BUFFER_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <bit>
#include <iostream>
#include <numeric>
#include <ranges>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct select_bit_integer;

template <size_t Bits> requires(Bits <= 8) struct select_bit_integer<Bits> {
	using type = uint8_t;
};

template <size_t Bits> requires(Bits > 8 && Bits <= 16) struct select_bit_integer<Bits> {
	using type = uint16_t;
};

template <size_t Bits> requires(Bits > 16 && Bits <= 32) struct select_bit_integer<Bits> {
	using type = uint32_t;
};

template <size_t Bits> requires(Bits > 32 && Bits <= 64) struct select_bit_integer<Bits> {
	using type = uint64_t;
};

template <size_t Bits> using select_bit_integer_t = select_bit_integer<Bits>::type;

template <size_t V> requires(std::popcount(V) == 1u) constexpr auto log2_of_power_of_2 = static_cast<size_t>(std::countr_zero(V));

template <size_t Bits> constexpr auto mask = static_cast<select_bit_integer_t<Bits>>((static_cast<select_bit_integer_t<Bits>>(1u) << Bits) - 1u);

template <size_t Capacity> class basic_bit_buffer {
public:
	static constexpr auto capacity = std::integral_constant<size_t, Capacity>{};
	using storage_type = select_bit_integer_t<capacity()>;
	using size_type = select_bit_integer_t<log2_of_power_of_2<std::bit_ceil(capacity())>>;

public:
	storage_type buffer{0};
	size_type bits_available{0};

public:
	template <size_t Bits> static constexpr auto mask = static_cast<storage_type>((static_cast<storage_type>(1u) << Bits) - 1u);

	constexpr friend bool operator==(const basic_bit_buffer & lhs, const basic_bit_buffer & rhs) noexcept = default;

	constexpr size_type size() const noexcept {
		return bits_available;
	}

	constexpr size_type unused_size() const noexcept {
		return capacity() - bits_available;
	}

	constexpr bool empty() const noexcept {
		return bits_available == 0u;
	}

	constexpr bool full() const noexcept {
		return bits_available == capacity();
	}

	template <size_t Bits> constexpr void push(select_bit_integer_t<Bits> in) noexcept requires(Bits <= capacity()) {
		assert(size() <= capacity() - Bits);
		buffer = static_cast<storage_type>(buffer << Bits) | static_cast<storage_type>(in);
		bits_available += static_cast<size_type>(Bits);
	}
	constexpr void push_empty_bits(size_t count) noexcept {
		buffer = static_cast<storage_type>(buffer << count);
		bits_available += static_cast<unsigned char>(count);
	}

	template <size_t Bits> constexpr void pop() noexcept requires(Bits <= capacity()) {
		assert(size() >= Bits);
		bits_available -= static_cast<size_type>(Bits);
	}

	template <size_t Bits> constexpr auto front() const noexcept -> select_bit_integer_t<Bits> requires(Bits <= capacity()) {
		using output_type = select_bit_integer_t<Bits>;
		assert(size() >= static_cast<size_type>(Bits));
		return static_cast<output_type>((buffer >> (bits_available - Bits))) & mask<Bits>;
	}
};

constexpr size_t calculate_padding_bit_count(size_t number_of_bits_in_buffer, size_t output_size, size_t input_size) {
	size_t n = number_of_bits_in_buffer;
	size_t padding_bits = 0u;

	while (n != 0u) {
		padding_bits += input_size;
		n += input_size;

		while (n >= output_size) {
			n = n - output_size;
		}
	}

	return padding_bits;
}

template <size_t OutBits, size_t InBits = 8u> class bit_buffer: protected basic_bit_buffer<std::lcm(OutBits, InBits)> {
	using super = basic_bit_buffer<std::lcm(OutBits, InBits)>;

public:
	constexpr bit_buffer() noexcept = default;

	using typename super::size_type;
	static constexpr auto out_bits = std::integral_constant<size_type, OutBits>{};
	static constexpr auto in_bits = std::integral_constant<size_type, InBits>{};

	using out_type = select_bit_integer_t<OutBits>;
	using in_type = select_bit_integer_t<InBits>;

	using super::capacity;
	static constexpr auto in_capacity = std::integral_constant<size_type, (capacity() / in_bits())>{};
	static constexpr auto out_capacity = std::integral_constant<size_type, (capacity() / out_bits())>{};

	static constexpr auto aligned = std::bool_constant<capacity() == in_capacity()>{};

	constexpr void push(in_type in) noexcept {
		super::template push<in_bits>(in);
	}

	constexpr void push_empty() noexcept {
		this->push(in_type{0u});
	}

	constexpr size_type push_zeros_to_align() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_to_align() noexcept requires(!aligned()) {
		if (empty()) {
			return 0u;
		}

		assert(out_bits > super::size());
		const size_type missing_bits = static_cast<size_type>(out_bits - super::size());
		super::push_empty_bits(missing_bits);
		return missing_bits;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(!aligned()) {
		const size_type usable_bits = super::size();
		const size_type missing_bits = static_cast<size_type>(calculate_padding_bit_count(super::size(), out_bits, in_bits));
		super::push_empty_bits(missing_bits);
		return usable_bits;
	}

	constexpr void pop() noexcept {
		super::template pop<out_bits>();
	}

	constexpr auto front() const noexcept -> out_type {
		return super::template front<out_bits>();
	}

	constexpr size_type size() const noexcept {
		return static_cast<size_type>(super::size() / out_bits);
	}

	constexpr size_type unused_size() const noexcept {
		return static_cast<size_type>(super::unused_size() / in_bits);
	}

	using super::empty;
	using super::full;

	constexpr bool has_bits_for_pop() const noexcept {
		return super::size() >= out_bits;
	}

	constexpr bool has_capacity_for_push() const noexcept {
		return super::size() <= (capacity() - in_bits);
	}
};

} // namespace cthash

#endif

#include <iostream>
#include <ranges>

namespace cthash {

template <typename Buffer> struct buffer_result_type;

template <typename Buffer> requires(Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	static constexpr Buffer::size_type missing_bits = {0u};

	constexpr bool is_padding() const noexcept {
		return false;
	}
};

template <typename Buffer> requires(!Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	typename Buffer::size_type missing_bits;

	constexpr bool is_padding() const noexcept {
		return missing_bits == Buffer::out_bits;
	}
};

template <typename Buffer, bool AllowPadding> struct buffer_with_missing_bits;

template <typename Buffer, bool AllowPadding> requires(Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};

	struct result_type {
		typename Buffer::out_type value;
		static constexpr Buffer::size_type missing_bits = {0u};

		constexpr bool is_padding() const noexcept {
			return false;
		}
	};

	static constexpr bool aligned = Buffer::aligned();

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		return result_type{buffer.front()};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		while (!buffer.has_bits_for_pop() && (it != end)) {
			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <typename Buffer, bool AllowPadding> requires(!Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};
	Buffer::size_type missing_bits{0};

	static constexpr bool aligned = Buffer::aligned();

	struct result_type {
		typename Buffer::out_type value;
		typename Buffer::size_type missing_bits;

		constexpr bool is_padding() const noexcept {
			return missing_bits == Buffer::out_bits;
		}
	};

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		assert(Buffer::out_bits >= missing_bits);
		return result_type{buffer.front(), missing_bits};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	constexpr void pad_buffer() noexcept requires(AllowPadding) {
		// full multi-chunk padding (for baseN encodings)
		missing_bits = (Buffer::out_bits - buffer.push_zeros_for_padding());
	}

	constexpr void pad_buffer() noexcept requires(!AllowPadding) {
		// only add enough zero to finish current output chunk
		missing_bits = buffer.push_zeros_to_align();
	}

	constexpr void saturate_missing_bits() noexcept requires(AllowPadding) {
		if (missing_bits) {
			missing_bits = Buffer::out_bits;
		}
		// missing_bits = static_cast<buffer_size_t>((unsigned)(bool)missing_bits * output_value_bit_size);
	}

	constexpr void saturate_missing_bits() noexcept requires(!AllowPadding) {
		// do nothing :)
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		for (;;) {
			if (it == end) {
				if (buffer.has_bits_for_pop()) {
					// if this is second pass after padding we can mark all bits as missing
					saturate_missing_bits();
				} else {
					// fill remainder of buffer with zeros
					pad_buffer();
				}

				return;
			}

			if (buffer.has_bits_for_pop()) {
				return;
			}

			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <bool Value> struct conditional;

template <> struct conditional<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional<false> {
	template <typename, typename T> using type = T;
};

template <bool Const, typename T> using maybe_const = typename conditional<Const>::template type<const T, T>;

template <typename T> concept integral_like = std::integral<T> || std::same_as<std::byte, T>;

template <size_t Bits, bool AllowPadding, std::ranges::input_range Input> requires integral_like<std::ranges::range_value_t<Input>> struct chunk_of_bits_view {
	using input_value_type = std::ranges::range_value_t<Input>;

	static constexpr size_t output_value_bit_size = Bits;
	static constexpr size_t input_value_bit_size = sizeof(input_value_type) * 8u;
	using buffer_t = cthash::bit_buffer<output_value_bit_size, input_value_bit_size>;
	using buffer_size_t = buffer_t::size_type;
	Input input;

	static constexpr bool aligned = buffer_t::aligned;

	struct sentinel { };

	template <bool Const> struct iterator {
		using parent = maybe_const<Const, Input>;
		using storage_type = buffer_with_missing_bits<buffer_t, AllowPadding>;
		using value_type = storage_type::result_type;
		using difference_type = intptr_t;

		std::ranges::iterator_t<parent> it;
		[[no_unique_address]] std::ranges::sentinel_t<parent> end;

		storage_type buffer{};

		constexpr iterator(parent & p) noexcept: it{std::ranges::begin(p)}, end{std::ranges::end(p)} {
			// initialize
			buffer.feed_buffer(it, end);
		}

		iterator(const iterator &) = default;
		iterator(iterator &&) = default;

		iterator & operator=(const iterator &) = default;
		iterator & operator=(iterator &&) = default;

		constexpr iterator & operator++() noexcept {
			buffer.pop();
			buffer.feed_buffer(it, end);
			return *this;
		}

		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			this->operator++();
			return copy;
		}

		constexpr auto operator*() const noexcept {
			return buffer.front();
		}

		constexpr friend bool operator==(const iterator & lhs, const iterator & rhs) noexcept = default;

		constexpr friend bool operator==(const iterator & self, sentinel) noexcept {
			return self.buffer.empty();
		}
	};

	static_assert(std::input_iterator<iterator<true>>);
	static_assert(std::input_iterator<iterator<false>>);
	static_assert(std::sentinel_for<sentinel, iterator<true>>);
	static_assert(std::sentinel_for<sentinel, iterator<false>>);

	constexpr chunk_of_bits_view(Input _input) noexcept: input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input};
	}

	constexpr auto end() const noexcept {
		return sentinel{};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && AllowPadding) {
		// calculate with blocks
		return ((std::ranges::size(input) + (buffer_t::in_capacity() - 1u)) / buffer_t::in_capacity()) * buffer_t::out_capacity();
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && !AllowPadding) {
		// calculate with bits
		const size_t bit_size_of_input = std::ranges::size(input) * input_value_bit_size;
		return (bit_size_of_input + (output_value_bit_size - 1u)) / output_value_bit_size;
	}
};

template <size_t Bits, bool AllowPadding> struct chunk_of_bits_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, chunk_of_bits_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) {
		return chunk_of_bits_view<Bits, AllowPadding, R>(std::forward<R>(input));
	}
};

template <size_t Bits, bool AllowPadding = false> constexpr auto chunk_of_bits = chunk_of_bits_action<Bits, AllowPadding>{};

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#include <bit>

namespace cthash {

template <typename Encoding> struct encoding_properties {
	static constexpr size_t size = std::size(Encoding::alphabet) - 1u;
	static_assert(std::popcount(size) == 1u, "Size of encoding's alphabet must be power-of-two");

	static constexpr size_t bits = std::countr_zero(size);

	static constexpr bool has_padding = padded_encoding<Encoding>;

	static constexpr char padding = [] {
		if constexpr (has_padding) {
			return Encoding::padding;
		} else {
			return '\0';
		}
	}();
};

template <typename Encoding, typename CharT, typename R> struct encode_to_view {
	using properties = encoding_properties<Encoding>;
	using chunk_view = cthash::chunk_of_bits_view<properties::bits, properties::has_padding, R>;

	struct sentinel {
		[[no_unique_address]] chunk_view::sentinel end;
	};

	template <bool Const> struct iterator {
		using difference_type = intptr_t;
		using value_type = CharT;

		chunk_view::template iterator<Const> it;

		constexpr iterator & operator++() noexcept {
			++it;
			return *this;
		}
		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			++it;
			return copy;
		}

		constexpr value_type operator*() const noexcept {
			const auto tmp = *it;
			if constexpr (!chunk_view::aligned) {
				// TODO: do without condition
				if (tmp.is_padding()) {
					return properties::padding;
				}
			}
			return static_cast<value_type>(Encoding::alphabet[static_cast<unsigned>(tmp.value)]);
		}

		constexpr friend bool operator==(const iterator &, const iterator &) noexcept = default;

		constexpr friend bool operator==(const iterator & lhs, const sentinel & rhs) noexcept {
			return lhs.it == rhs.end;
		}
	};

	chunk_view input;

	constexpr encode_to_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}

	constexpr auto to_string() const requires(std::ranges::sized_range<R>) {
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(*this);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(size());
		auto [i, o] = std::ranges::copy(begin(), end(), result.begin());
		assert(i == result.end());
		assert(o == result.end());
		return result;
#endif
	}

	constexpr friend std::basic_ostream<CharT> & operator<<(std::basic_ostream<CharT> & out, encode_to_view in) {
		std::ranges::copy(in.begin(), in.end(), std::ostream_iterator<CharT, CharT>(out));
		return out;
	}
};

template <typename Encoding, typename ValueT, typename R> struct decode_from_view {
	R input;

	template <bool Const> struct iterator { };
	struct sentinel { };

	constexpr decode_from_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}
};

template <typename Encoding, typename CharT = char> struct encode_to_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, encode_to_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return encode_to_view<Encoding, CharT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename ValueT = unsigned char> struct decode_from_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, decode_from_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return decode_from_view<Encoding, ValueT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename CharT = char> constexpr auto encode_to = encode_to_action<Encoding, CharT>{};
template <typename Encoding, typename ValueT = unsigned char> constexpr auto decode_from = decode_from_action<Encoding, ValueT>{};

constexpr auto binary_encode = encode_to<encoding::base2, char>;
constexpr auto base2_encode = encode_to<encoding::base2, char>;
constexpr auto base4_encode = encode_to<encoding::base4, char>;
constexpr auto base8_encode = encode_to<encoding::base8, char>;
constexpr auto octal_encode = encode_to<encoding::base8, char>;
constexpr auto hexdec_encode = encode_to<encoding::base16, char>;
constexpr auto hexdec_uppercase_encode = encode_to<encoding::base16_uppercase, char>;
constexpr auto base16_encode = encode_to<encoding::base16, char>;
constexpr auto base32_encode = encode_to<encoding::base32, char>;
constexpr auto base32_no_padding_encode = encode_to<encoding::base32_no_padding, char>;
constexpr auto z_base32_encode = encode_to<encoding::z_base32, char>;
constexpr auto base64_encode = encode_to<encoding::base64, char>;
constexpr auto base64url_encode = encode_to<encoding::base64url, char>;
constexpr auto base64_no_padding_encode = encode_to<encoding::base64_no_padding, char>;

constexpr auto binary_decode = decode_from<encoding::base2, char>;
constexpr auto base2_decode = decode_from<encoding::base2, char>;
constexpr auto base4_decode = decode_from<encoding::base4, char>;
constexpr auto base8_decode = decode_from<encoding::base8, char>;
constexpr auto hexdec_decode = decode_from<encoding::base16, char>;
constexpr auto base16_decode = decode_from<encoding::base16, char>;
constexpr auto base32_decode = decode_from<encoding::base32, char>;
constexpr auto z_base32_decode = decode_from<encoding::z_base32, char>;
constexpr auto base64_decode = decode_from<encoding::base64, char>;
constexpr auto base64url_decode = decode_from<encoding::base64url, char>;
constexpr auto base64_no_padding_decode = decode_from<encoding::base64_no_padding, char>;

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

// template <typename Encoding, typename CharT, typename R> struct encode_to_view

#ifdef CTHASH_STDFMT_AVAILABLE
template <typename Encoding, typename R, typename CharT>
struct formatter<cthash::encode_to_view<Encoding, CharT, R>, CharT> {
	using subject_type = cthash::encode_to_view<Encoding, CharT, R>;

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		return std::ranges::begin(ctx);
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return std::ranges::copy(value, ctx.out()).out;
	}
};

#endif

} // namespace std

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_ALGORITHM_HPP
#define CTHASH_INTERNAL_ALGORITHM_HPP

#include <numeric>
#include <compare>
#include <cstddef>
#include <cstdint>

namespace cthash::internal {

template <typename It1, typename It2> constexpr auto threeway_compare_of_same_size(It1 lhs, It2 rhs, size_t length) -> std::strong_ordering {
	for (size_t i = 0; i != length; ++i) {
		if (const auto r = (*lhs++ <=> *rhs++); std::is_neq(r)) {
			return r;
		}
	}

	return std::strong_ordering::equal;
}

template <typename T, typename It1, typename It2, typename Stream> constexpr auto & push_to_stream_as(It1 f, It2 l, Stream & stream) {
	constexpr auto cast_and_shift = [](Stream * s, const auto & rhs) { (*s) << T{rhs}; return s; };
	return *std::accumulate(f, l, &stream, cast_and_shift);
}

} // namespace cthash::internal

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_HEXDEC_HPP
#define CTHASH_INTERNAL_HEXDEC_HPP

#include <array>
#include <ostream>
#include <span>
#include <type_traits>
#include <cstdint>

namespace cthash::internal {

consteval auto get_hexdec_table() noexcept {
	std::array<uint8_t, 128> result;

	auto char_to_hexdec = [](char c) {
		if (c >= '0' && c <= '9') {
			return static_cast<uint8_t>(c - '0');
		} else if (c >= 'a' && c <= 'f') {
			return static_cast<uint8_t>(c - 'a' + 10);
		} else if (c >= 'A' && c <= 'F') {
			return static_cast<uint8_t>(c - 'A' + 10);
		} else {
			return static_cast<uint8_t>(0);
		}
	};

	for (size_t i = 0; i != result.size(); ++i) {
		result[i] = char_to_hexdec(static_cast<char>(i));
	}

	return result;
}

constexpr auto hexdec_to_value_alphabet = get_hexdec_table();

template <typename CharT> constexpr auto value_to_hexdec_alphabet = std::array<CharT, 16>{CharT('0'), CharT('1'), CharT('2'), CharT('3'), CharT('4'), CharT('5'), CharT('6'), CharT('7'), CharT('8'), CharT('9'), CharT('a'), CharT('b'), CharT('c'), CharT('d'), CharT('e'), CharT('f')};

struct byte_hexdec_value {
	std::byte val;

	template <typename CharT, typename Traits> friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, byte_hexdec_value rhs) {
		return os << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val >> 4u)] << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val) & 0b1111u];
	}
};

template <size_t N, typename CharT> constexpr auto hexdec_to_binary(std::span<const CharT, N * 2> in) -> std::array<std::byte, N> {
	return [in]<size_t... Idx>(std::index_sequence<Idx...>) {
		return std::array<std::byte, N>{static_cast<std::byte>(hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2]) & 0b0111'1111u] << 4u | hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2u + 1u]) & 0b0111'1111u])...};
	}(std::make_index_sequence<N>());
}

template <typename CharT, size_t N>
requires((N - 1) % 2 == 0) // -1 because of zero terminator in literals
constexpr auto literal_hexdec_to_binary(const CharT (&in)[N]) -> std::array<std::byte, (N - 1) / 2> {
	return hexdec_to_binary<N / 2>(std::span<const char, N - 1>(in, N - 1));
}

} // namespace cthash::internal

#endif

#include <algorithm>
#include <array>
#include <format>
#include <span>
#include <string_view>
#include <compare>

namespace cthash {

// hash_value

template <size_t N> struct hash_value: std::array<std::byte, N> {
	using super = std::array<std::byte, N>;

	constexpr hash_value() noexcept: super{} { }
	explicit constexpr hash_value(super && s) noexcept: super(s) { }
	template <typename CharT> explicit constexpr hash_value(const CharT (&in)[N * 2u + 1u]) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in, N * 2u))} { }
	template <typename CharT> explicit constexpr hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in.data(), in.size()))} { }

	// comparison support
	constexpr friend bool operator==(const hash_value & lhs, const hash_value & rhs) noexcept = default;
	constexpr friend auto operator<=>(const hash_value & lhs, const hash_value & rhs) noexcept -> std::strong_ordering {
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), N);
	}

	template <typename Encoding = cthash::encoding::hexdec, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		auto hexdec_view = *this | cthash::encode_to<Encoding, CharT>;
		std::ranges::copy(hexdec_view, std::ostream_iterator<CharT, CharT>(os));
		return os;
	}

	// print to ostream support
	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const hash_value & val) {
		return val.print_into(os);
	}

	template <size_t PrefixN> constexpr auto prefix() const noexcept requires(PrefixN <= N) {
		hash_value<PrefixN> output{};
		std::ranges::copy(this->begin(), this->begin() + PrefixN, output.begin());
		return output;
	}

	template <size_t SuffixN> constexpr auto suffix() const noexcept requires(SuffixN <= N) {
		hash_value<SuffixN> output{};
		std::ranges::copy(this->end() - SuffixN, this->end(), output.begin());
		return output;
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(encoded);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(encoded.size());
		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());
		return result;
#endif
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_fixed_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
		// it's type dependendent so we can calculate the size...
		constexpr size_t size_needed = (hash_value{} | cthash::encode_to<Encoding, CharT>).size();

		auto result = cthash::fixed_string<CharT, size_needed>{nullptr};

		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());

		return result;
	}
};

template <typename CharT, size_t N> hash_value(const CharT (&)[N]) -> hash_value<(N - 1u) / 2u>;
template <typename CharT, size_t N> hash_value(std::span<const CharT, N>) -> hash_value<N / 2u>;
template <typename CharT, size_t N> hash_value(const fixed_string<CharT, N> &) -> hash_value<N / 2u>;

template <typename> struct default_encoding {
	using encoding = cthash::encoding::hexdec;
};

template <typename Tag> concept tag_with_encoding = requires() {
	typename Tag::encoding;
};

template <tag_with_encoding Tag> struct default_encoding<Tag> {
	using encoding = Tag::encoding;
};

template <typename Tag, size_t = internal::digest_bytes_length_of<Tag>> struct tagged_hash_value: hash_value<internal::digest_bytes_length_of<Tag>> {
	static constexpr size_t N = internal::digest_bytes_length_of<Tag>;

	using super = hash_value<N>;
	using super::super;
	template <typename CharT> explicit constexpr tagged_hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{in} { }

	static constexpr size_t digest_length = N;

	template <typename Encoding = default_encoding<Tag>::encoding, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		return super::template print_into<Encoding>(os);
	}

	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const tagged_hash_value & val) {
		return val.print_into(os);
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_string(const tagged_hash_value & value) {
		return to_string<Encoding, CharT>(static_cast<const super &>(value));
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_fixed_string(const tagged_hash_value & value) {
		return to_fixed_string<Encoding, CharT>(static_cast<const super &>(value));
	}
};

template <typename T> concept variable_digest_length = T::digest_length_bit == 0u;

template <size_t N, variable_digest_length Tag> struct variable_bit_length_tag: Tag {
	static constexpr size_t digest_length_bit = N;
};

template <typename T> concept convertible_to_tagged_hash_value = requires(const T & obj) {
	{ tagged_hash_value{obj} };
};

namespace literals {

	template <fixed_string Value>
	constexpr auto operator""_hash() {
		return hash_value(Value);
	}

} // namespace literals

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#if _LIBCPP_VERSION >= 170000
// libc++ will define __cpp_lib_format macro in 19.0
// https://github.com/llvm/llvm-project/issues/77773
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#ifdef CTHASH_STDFMT_AVAILABLE
template <size_t N, typename CharT>
struct formatter<cthash::hash_value<N>, CharT> {
	using subject_type = cthash::hash_value<N>;
	using default_encoding = cthash::encoding::hexdec;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <typename Tag, size_t N, typename CharT>
struct formatter<cthash::tagged_hash_value<Tag, N>, CharT> {
	using subject_type = cthash::tagged_hash_value<Tag, N>;
	using default_encoding = typename cthash::default_encoding<Tag>::encoding;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <cthash::convertible_to_tagged_hash_value Type, typename CharT> struct formatter<Type, CharT>: formatter<decltype(cthash::tagged_hash_value{std::declval<Type>()}), CharT> {
};

#endif

} // namespace std

#endif

#include <cstdint>

namespace cthash {

template <typename T, typename Y> concept castable_to = requires(T val) { {static_cast<Y>(val)} -> std::same_as<Y>; };

template <size_t N> struct keccak_suffix {
	unsigned bits;
	std::array<std::byte, N> values;

	constexpr keccak_suffix(unsigned b, castable_to<std::byte> auto... v) noexcept: bits{b}, values{static_cast<std::byte>(v)...} { }
};

template <castable_to<std::byte>... Ts> keccak_suffix(unsigned, Ts...) -> keccak_suffix<sizeof...(Ts)>;

template <typename T> struct identify;

template <typename T, byte_like Byte> constexpr auto convert_prefix_into_aligned(std::span<const Byte> input, unsigned pos) noexcept -> std::array<std::byte, sizeof(T)> {
	assert(input.size() <= sizeof(T));
	assert(pos <= sizeof(T));
	assert((input.size() + pos) <= sizeof(T));

	std::array<std::byte, sizeof(T)> buffer{};

	std::fill(buffer.begin(), buffer.end(), std::byte{0});
	std::transform(input.data(), input.data() + input.size(), buffer.data() + pos, [](auto v) { return static_cast<std::byte>(v); });

	return buffer;
}

template <typename T, byte_like Byte> constexpr auto convert_prefix_into_value(std::span<const Byte> input, unsigned pos) noexcept -> uint64_t {
	const auto tmp = convert_prefix_into_aligned<T, Byte>(input, pos);
	return cast_from_le_bytes<T>(std::span<const std::byte, 8>(tmp));
}

template <typename Config> struct basic_keccak_hasher {
	static_assert(Config::digest_length_bit % 8u == 0u);
	static_assert(Config::rate_bit % 8u == 0u);
	static_assert(Config::capacity_bit % 8u == 0u);

	static_assert((Config::rate_bit + Config::capacity_bit) == 1600u, "Only Keccak 1600 is implemented");

	static constexpr size_t digest_length = Config::digest_length_bit / 8u;
	static constexpr size_t rate = Config::rate_bit / 8u;
	static constexpr size_t capacity = Config::capacity_bit / 8u;

	using result_t = cthash::tagged_hash_value<Config>;
	using digest_span_t = std::span<std::byte, digest_length>;

	keccak::state_1600 internal_state{};
	uint8_t position{0u};

	constexpr basic_keccak_hasher() noexcept {
		std::fill(internal_state.begin(), internal_state.end(), uint64_t{0});
	}

	template <byte_like T> constexpr size_t xor_overwrite_block(std::span<const T> input) noexcept {
		using value_t = keccak::state_1600::value_type;

		if ((std::is_constant_evaluated() | (std::endian::native != std::endian::little))) {
			assert((size_t(position) + input.size()) <= rate);

			// unaligned prefix (by copying from left to right it should be little endian)
			if (position % sizeof(value_t) != 0u) {
				// xor unaligned value and move to aligned if possible
				const size_t prefix_size = std::min(input.size(), sizeof(value_t) - (position % sizeof(value_t)));
				internal_state[position / sizeof(uint64_t)] ^= convert_prefix_into_value<value_t>(input.first(prefix_size), static_cast<unsigned>(position % sizeof(value_t)));
				position += static_cast<uint8_t>(prefix_size);
				input = input.subspan(prefix_size);
			}

			// aligned blocks
			while (input.size() >= sizeof(value_t)) {
				// xor aligned value and move to next
				internal_state[position / sizeof(value_t)] ^= cast_from_le_bytes<value_t>(input.template first<sizeof(value_t)>());
				position += static_cast<uint8_t>(sizeof(value_t));
				input = input.subspan(sizeof(value_t));
			}

			// unaligned suffix
			if (not input.empty()) {
				// xor and finish
				internal_state[position / sizeof(value_t)] ^= convert_prefix_into_value<value_t>(input, 0u);
				position += static_cast<uint8_t>(input.size());
			}

			return position;
		} else {
			const auto buffer = std::as_writable_bytes(std::span<uint64_t>(internal_state));
			const auto remaining = buffer.subspan(position);
			const auto place = remaining.first(std::min(input.size(), remaining.size()));

			std::transform(place.data(), place.data() + place.size(), input.data(), place.data(), [](std::byte lhs, auto rhs) { return lhs ^ static_cast<std::byte>(rhs); });

			position += static_cast<uint8_t>(place.size());
			return position;
		}
	}

	template <byte_like T> constexpr auto update(std::span<const T> input) noexcept {
		assert(position < rate);
		const size_t remaining_in_buffer = rate - position;

		if (remaining_in_buffer > input.size()) {
			// xor overwrite as much as we can, and that's all
			xor_overwrite_block(input);
			assert(position < rate);
			return;
		}

		// finish block and call keccak :)
		const auto first_part = input.first(remaining_in_buffer);
		input = input.subspan(remaining_in_buffer);
		xor_overwrite_block(first_part);
		assert(position == rate);
		keccak_f(internal_state);
		position = 0u;

		// for each full block we can absorb directly
		while (input.size() >= rate) {
			const auto block = input.template first<rate>();
			input = input.subspan(rate);
			assert(position == 0u);
			xor_overwrite_block<T>(block);
			keccak_f(internal_state);
			position = 0u;
		}

		// xor overwrite internal state with current remainder, and set position to end of it
		if (not input.empty()) {
			assert(position == 0u);
			xor_overwrite_block(input);
			assert(position < rate);
		}
	}

	// pad the message
	constexpr void xor_padding_block() noexcept {
		assert(position < rate);

		constexpr const auto & suffix = Config::suffix;
		constexpr std::byte suffix_and_start_of_padding = (suffix.values[0] | (std::byte{0b0000'0001u} << suffix.bits));

		internal_state[position / sizeof(uint64_t)] ^= uint64_t(suffix_and_start_of_padding) << ((position % sizeof(uint64_t)) * 8u);
		internal_state[(rate - 1u) / sizeof(uint64_t)] ^= 0x8000000000000000ull; // last bit
	}

	constexpr void final_absorb() noexcept {
		xor_padding_block();
		keccak_f(internal_state);
	}

	// get resulting hash
	constexpr void squeeze(std::span<std::byte> output) noexcept {
		using value_t = keccak::state_1600::value_type;

		static_assert((rate % sizeof(value_t)) == 0u);
		auto r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));

		// aligned results will be processed here...
		while ((output.size() >= sizeof(value_t))) {
			// if we ran out of `rate` part, we need to squeeze another block
			if (r.empty()) {
				keccak_f(internal_state);
				r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));
			}

			// look at current to process
			const value_t current = r.front();
			const auto part = output.first<sizeof(value_t)>();

			// convert
			unwrap_littleendian_number<value_t>{part} = current;

			// move to next
			r = r.subspan(1u);
			output = output.subspan(sizeof(value_t));
		}

		// unaligned result is here
		if (!output.empty()) {
			// if we ran out of `rate` part, we need to squeeze another block
			if (r.empty()) {
				keccak_f(internal_state);
				r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));
			}

			const value_t current = r.front();

			// convert
			std::array<std::byte, sizeof(value_t)> tmp;
			unwrap_littleendian_number<value_t>{tmp} = current;
			assert(tmp.size() > output.size());
			std::copy_n(tmp.data(), output.size(), output.data());
		}
	}

	constexpr void squeeze(digest_span_t output_fixed) noexcept
		requires((digest_length < rate) && digest_length != 0u)
	{
		auto output = std::span<std::byte>(output_fixed);

		// we don't need to squeeze anything
		using value_t = keccak::state_1600::value_type;

		static_assert((rate % sizeof(value_t)) == 0u);
		auto r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));

		// aligned results will be processed here...
		while ((output.size() >= sizeof(value_t))) {
			assert(!r.empty());
			// look at current to process
			const value_t current = r.front();
			const auto part = output.template first<sizeof(value_t)>();

			// convert
			unwrap_littleendian_number<value_t>{part} = current;

			// move to next
			r = r.subspan(1u);
			output = output.subspan(sizeof(value_t));
		}

		if constexpr ((output_fixed.size() % sizeof(value_t)) != 0u) {
			// unaligned result is here
			assert(!output.empty());
			assert(!r.empty());

			const value_t current = r.front();

			// convert
			std::array<std::byte, sizeof(value_t)> tmp;
			unwrap_littleendian_number<value_t>{tmp} = current;
			assert(tmp.size() > output.size());
			std::copy_n(tmp.data(), output.size(), output.data());
		}
	}

	constexpr void final(digest_span_t digest) noexcept
		requires(digest_length != 0u)
	{
		final_absorb();
		squeeze(digest);
	}

	constexpr result_t final() noexcept
		requires(digest_length != 0u)
	{
		result_t output;
		final(output);
		return output;
	}

	template <size_t N> constexpr auto final() noexcept
		requires(digest_length == 0u)
	{
		static_assert(N % 8u == 0u, "Only whole bytes are supported!");
		using result_type = typename Config::template variable_digest<N>;
		result_type output;
		final_absorb();
		squeeze(output);
		return output;
	}
};

template <typename Config> struct keccak_hasher: basic_keccak_hasher<Config> {
	using super = basic_keccak_hasher<Config>;
	using result_t = typename super::result_t;
	using digest_span_t = typename super::digest_span_t;

	constexpr keccak_hasher() noexcept: super() { }
	constexpr keccak_hasher(const keccak_hasher &) noexcept = default;
	constexpr keccak_hasher(keccak_hasher &&) noexcept = default;
	constexpr ~keccak_hasher() noexcept = default;

	constexpr keccak_hasher & update(std::span<const std::byte> input) noexcept {
		super::update(input);
		return *this;
	}

	template <convertible_to_byte_span T> constexpr keccak_hasher & update(const T & something) noexcept {
		using value_type = typename decltype(std::span(something))::value_type;
		super::update(std::span<const value_type>(something));
		return *this;
	}

	template <one_byte_char CharT> constexpr keccak_hasher & update(std::basic_string_view<CharT> in) noexcept {
		super::update(std::span(in.data(), in.size()));
		return *this;
	}

	template <string_literal T> constexpr keccak_hasher & update(const T & lit) noexcept {
		super::update(std::span(lit, std::size(lit) - 1u));
		return *this;
	}

	// TODO: any range with value convertible to byte

	using super::final;
};

template <size_t DigestBits>
struct sha_config {
	static constexpr size_t digest_length_bit = DigestBits;
	static constexpr size_t capacity_bit = DigestBits * 2u;
	static constexpr size_t rate_bit = 1600u - capacity_bit;

	static constexpr auto suffix = keccak_suffix(2, 0b0000'0010u); // in reverse
};

} // namespace cthash

#endif

namespace cthash {

template <unsigned N> struct prenist_keccak_config {
	static constexpr size_t digest_length_bit = N;
	static constexpr size_t capacity_bit = digest_length_bit * 2u;
	static constexpr size_t rate_bit = 1600u - capacity_bit;

	// Keccak (pre-NIST) domain bit = 0x01
	static constexpr auto suffix = keccak_suffix(0, 0x00);
};

static_assert((prenist_keccak_config<256>::capacity_bit + prenist_keccak_config<256>::rate_bit) == 1600u);

using keccak_256 = cthash::keccak_hasher<prenist_keccak_config<256>>;
using keccak_256_value = tagged_hash_value<prenist_keccak_config<256>>;
using keccak_384 = cthash::keccak_hasher<prenist_keccak_config<384>>;
using keccak_384_value = tagged_hash_value<prenist_keccak_config<384>>;
using keccak_512 = cthash::keccak_hasher<prenist_keccak_config<512>>;
using keccak_512_value = tagged_hash_value<prenist_keccak_config<512>>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_keccak_256() {
		return keccak_256_value(Value);
	}

	template <fixed_string Value>
	consteval auto operator""_keccak_384() {
		return keccak_384_value(Value);
	}

	template <fixed_string Value>
	consteval auto operator""_keccak_512() {
		return keccak_512_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

#ifndef CTHASH_SHA3_SHA3_HPP
#define CTHASH_SHA3_SHA3_HPP

#ifndef CTHASH_SHA3_COMMON_HPP
#define CTHASH_SHA3_COMMON_HPP

#ifndef CTHASH_SHA3_KECCAK_BASE_HPP
#define CTHASH_SHA3_KECCAK_BASE_HPP

#include <array>
#include <bit>
#include <span>
#include <type_traits>
#include <utility>
#include <concepts>
#include <cstdint>

namespace cthash::keccak {

// inspired by tiny-keccak (https://github.com/debris/tiny-keccak from Marek Kotewicz)

static constexpr auto rho = std::array<uint8_t, 24>{1u, 3u, 6u, 10u, 15u, 21u, 28u, 36u, 45u, 55u, 2u, 14u, 27u, 41u, 56u, 8u, 25u, 43u, 62u, 18u, 39u, 61u, 20u, 44u};

static constexpr auto pi = std::array<uint8_t, 24>{10u, 7u, 11u, 17u, 18u, 3u, 5u, 16u, 8u, 21u, 24u, 4u, 15u, 23u, 19u, 13u, 12u, 2u, 20u, 14u, 22u, 9u, 6u, 1u};

static constexpr auto rc = std::array<uint64_t, 24>{0x1ULL, 0x8082ULL, 0x800000000000808aULL, 0x8000000080008000ULL, 0x808bULL, 0x80000001ULL, 0x8000000080008081ULL, 0x8000000000008009ULL, 0x8aULL, 0x88ULL, 0x80008009ULL, 0x8000000aULL, 0x8000808bULL, 0x800000000000008bULL, 0x8000000000008089ULL, 0x8000000000008003ULL, 0x8000000000008002ULL, 0x8000000000000080ULL, 0x800aULL, 0x800000008000000aULL, 0x8000000080008081ULL, 0x8000000000008080ULL, 0x80000001ULL, 0x8000000080008008ULL};

struct state_1600: std::array<uint64_t, (5u * 5u)> { };

struct state_1600_ref: std::span<uint64_t, (5u * 5u)> {
	using super = std::span<uint64_t, (5u * 5u)>;
	using super::super;
};

[[gnu::always_inline, gnu::flatten]] constexpr void theta(state_1600_ref state) noexcept {
	// xor of columns
	const auto b = std::array<uint64_t, 5>{
		state[0] xor state[5] xor state[10] xor state[15] xor state[20],
		state[1] xor state[6] xor state[11] xor state[16] xor state[21],
		state[2] xor state[7] xor state[12] xor state[17] xor state[22],
		state[3] xor state[8] xor state[13] xor state[18] xor state[23],
		state[4] xor state[9] xor state[14] xor state[19] xor state[24],
	};

	const auto tmp = std::array<uint64_t, 5>{
		b[4] xor std::rotl(b[1], 1),
		b[0] xor std::rotl(b[2], 1),
		b[1] xor std::rotl(b[3], 1),
		b[2] xor std::rotl(b[4], 1),
		b[3] xor std::rotl(b[0], 1),
	};

	[&]<size_t... Idx>(std::index_sequence<Idx...>) {
		((state[Idx] ^= tmp[Idx % 5u]), ...);
	}(std::make_index_sequence<25>());
}

[[gnu::always_inline, gnu::flatten]] constexpr void rho_pi(state_1600_ref state) noexcept {
	uint64_t tmp = state[1];

	[&]<size_t... Idx>(std::index_sequence<Idx...>) {
		((state[pi[Idx]] = std::rotl(std::exchange(tmp, state[pi[Idx]]), rho[Idx])), ...);
	}(std::make_index_sequence<24>());
}

[[gnu::always_inline, gnu::flatten]] constexpr void chi(state_1600_ref state) noexcept {
	constexpr auto chi_helper = [](std::span<uint64_t, 5> row) {
		const auto b = std::array<uint64_t, 5>{row[0], row[1], row[2], row[3], row[4]};

		row[0] = b[0] xor ((~b[1]) bitand b[2]);
		row[1] = b[1] xor ((~b[2]) bitand b[3]);
		row[2] = b[2] xor ((~b[3]) bitand b[4]);
		row[3] = b[3] xor ((~b[4]) bitand b[0]);
		row[4] = b[4] xor ((~b[0]) bitand b[1]);
	};

	chi_helper(state.subspan<0>().first<5>());
	chi_helper(state.subspan<5>().first<5>());
	chi_helper(state.subspan<10>().first<5>());
	chi_helper(state.subspan<15>().first<5>());
	chi_helper(state.subspan<20>().first<5>());
}

[[gnu::flatten]] constexpr void keccak_f(state_1600 & state) noexcept {
	// rounds
	for (int i = 0; i != 24; ++i) {
		// theta (xor each column together)
		theta(state);
		rho_pi(state);
		chi(state);
		state[0] ^= rc[static_cast<size_t>(i)];
	}
}

} // namespace cthash::keccak

#endif
#ifndef CONSTEXPR_SHA2_HASHER_HPP
#define CONSTEXPR_SHA2_HASHER_HPP

#ifndef CTHASH_SIMPLE_HPP
#define CTHASH_SIMPLE_HPP

#include <utility>

namespace cthash {

template <typename Hasher, typename In, typename... Args> concept hasher_like = requires(Hasher & h, const In & in, Args &&... args) //
{
	{ Hasher{std::forward<Args>(args)...} };
	{ h.update(in) } -> std::same_as<Hasher &>;
	{ h.final() };
};

template <typename Hasher, typename In> concept direct_hasher = requires(Hasher & h, const In & in) //
{
	{ h.update_and_final(in) };
};

template <typename Hasher, typename T, typename... Args>
requires hasher_like<Hasher, T, Args...>
constexpr auto simple(const T & value, Args &&... args) noexcept {
	if constexpr (direct_hasher<Hasher, T>) {
		return Hasher{std::forward<Args>(args)...}.update_and_final(value);
	} else {
		return Hasher{std::forward<Args>(args)...}.update(value).final();
	}
}

} // namespace cthash

#endif

#ifndef CTHASH_VALUE_HPP
#define CTHASH_VALUE_HPP

#ifndef CTHASH_FIXED_STRING_HPP
#define CTHASH_FIXED_STRING_HPP

#include <algorithm>
#include <span>
#include <string_view>

namespace cthash {

template <typename CharT, size_t N> struct fixed_string: std::array<CharT, N> {
	using super = std::array<CharT, N>;

	consteval static auto from_string_literal(const CharT (&in)[N + 1]) -> std::array<CharT, N> {
		std::array<CharT, N> out;
		std::copy_n(in, N, out.data());
		return out;
	}

	explicit constexpr fixed_string(std::nullptr_t) noexcept: super{} { }

	consteval fixed_string(const CharT (&in)[N + 1]) noexcept: super{from_string_literal(in)} { }

	using super::data;
	using super::size;

	constexpr operator std::span<const CharT, N>() const noexcept {
		return std::span<const CharT, N>(data(), size());
	}

	constexpr operator std::span<const CharT>() const noexcept {
		return std::span<const CharT>(data(), size());
	}

	constexpr operator std::basic_string_view<CharT>() const noexcept {
		return std::basic_string_view<CharT>(data(), size());
	}

	constexpr friend bool operator==(const fixed_string &, const fixed_string &) noexcept = default;
	constexpr friend bool operator==(const fixed_string & lhs, std::basic_string_view<CharT> rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == rhs;
	}
	constexpr friend bool operator==(const fixed_string & lhs, const CharT * rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == std::basic_string_view<CharT>{rhs};
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N - 1>;

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_BASE_HPP
#define CTHASH_ENCODING_BASE_HPP

#ifndef CTHASH_ENCODING_CHUNK_OF_BITS_HPP
#define CTHASH_ENCODING_CHUNK_OF_BITS_HPP

#ifndef CTHASH_ENCODING_BIT_BUFFER_HPP
#define CTHASH_ENCODING_BIT_BUFFER_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <bit>
#include <iostream>
#include <numeric>
#include <ranges>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct select_bit_integer;

template <size_t Bits> requires(Bits <= 8) struct select_bit_integer<Bits> {
	using type = uint8_t;
};

template <size_t Bits> requires(Bits > 8 && Bits <= 16) struct select_bit_integer<Bits> {
	using type = uint16_t;
};

template <size_t Bits> requires(Bits > 16 && Bits <= 32) struct select_bit_integer<Bits> {
	using type = uint32_t;
};

template <size_t Bits> requires(Bits > 32 && Bits <= 64) struct select_bit_integer<Bits> {
	using type = uint64_t;
};

template <size_t Bits> using select_bit_integer_t = select_bit_integer<Bits>::type;

template <size_t V> requires(std::popcount(V) == 1u) constexpr auto log2_of_power_of_2 = static_cast<size_t>(std::countr_zero(V));

template <size_t Bits> constexpr auto mask = static_cast<select_bit_integer_t<Bits>>((static_cast<select_bit_integer_t<Bits>>(1u) << Bits) - 1u);

template <size_t Capacity> class basic_bit_buffer {
public:
	static constexpr auto capacity = std::integral_constant<size_t, Capacity>{};
	using storage_type = select_bit_integer_t<capacity()>;
	using size_type = select_bit_integer_t<log2_of_power_of_2<std::bit_ceil(capacity())>>;

public:
	storage_type buffer{0};
	size_type bits_available{0};

public:
	template <size_t Bits> static constexpr auto mask = static_cast<storage_type>((static_cast<storage_type>(1u) << Bits) - 1u);

	constexpr friend bool operator==(const basic_bit_buffer & lhs, const basic_bit_buffer & rhs) noexcept = default;

	constexpr size_type size() const noexcept {
		return bits_available;
	}

	constexpr size_type unused_size() const noexcept {
		return capacity() - bits_available;
	}

	constexpr bool empty() const noexcept {
		return bits_available == 0u;
	}

	constexpr bool full() const noexcept {
		return bits_available == capacity();
	}

	template <size_t Bits> constexpr void push(select_bit_integer_t<Bits> in) noexcept requires(Bits <= capacity()) {
		assert(size() <= capacity() - Bits);
		buffer = static_cast<storage_type>(buffer << Bits) | static_cast<storage_type>(in);
		bits_available += static_cast<size_type>(Bits);
	}
	constexpr void push_empty_bits(size_t count) noexcept {
		buffer = static_cast<storage_type>(buffer << count);
		bits_available += static_cast<unsigned char>(count);
	}

	template <size_t Bits> constexpr void pop() noexcept requires(Bits <= capacity()) {
		assert(size() >= Bits);
		bits_available -= static_cast<size_type>(Bits);
	}

	template <size_t Bits> constexpr auto front() const noexcept -> select_bit_integer_t<Bits> requires(Bits <= capacity()) {
		using output_type = select_bit_integer_t<Bits>;
		assert(size() >= static_cast<size_type>(Bits));
		return static_cast<output_type>((buffer >> (bits_available - Bits))) & mask<Bits>;
	}
};

constexpr size_t calculate_padding_bit_count(size_t number_of_bits_in_buffer, size_t output_size, size_t input_size) {
	size_t n = number_of_bits_in_buffer;
	size_t padding_bits = 0u;

	while (n != 0u) {
		padding_bits += input_size;
		n += input_size;

		while (n >= output_size) {
			n = n - output_size;
		}
	}

	return padding_bits;
}

template <size_t OutBits, size_t InBits = 8u> class bit_buffer: protected basic_bit_buffer<std::lcm(OutBits, InBits)> {
	using super = basic_bit_buffer<std::lcm(OutBits, InBits)>;

public:
	constexpr bit_buffer() noexcept = default;

	using typename super::size_type;
	static constexpr auto out_bits = std::integral_constant<size_type, OutBits>{};
	static constexpr auto in_bits = std::integral_constant<size_type, InBits>{};

	using out_type = select_bit_integer_t<OutBits>;
	using in_type = select_bit_integer_t<InBits>;

	using super::capacity;
	static constexpr auto in_capacity = std::integral_constant<size_type, (capacity() / in_bits())>{};
	static constexpr auto out_capacity = std::integral_constant<size_type, (capacity() / out_bits())>{};

	static constexpr auto aligned = std::bool_constant<capacity() == in_capacity()>{};

	constexpr void push(in_type in) noexcept {
		super::template push<in_bits>(in);
	}

	constexpr void push_empty() noexcept {
		this->push(in_type{0u});
	}

	constexpr size_type push_zeros_to_align() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_to_align() noexcept requires(!aligned()) {
		if (empty()) {
			return 0u;
		}

		assert(out_bits > super::size());
		const size_type missing_bits = static_cast<size_type>(out_bits - super::size());
		super::push_empty_bits(missing_bits);
		return missing_bits;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(!aligned()) {
		const size_type usable_bits = super::size();
		const size_type missing_bits = static_cast<size_type>(calculate_padding_bit_count(super::size(), out_bits, in_bits));
		super::push_empty_bits(missing_bits);
		return usable_bits;
	}

	constexpr void pop() noexcept {
		super::template pop<out_bits>();
	}

	constexpr auto front() const noexcept -> out_type {
		return super::template front<out_bits>();
	}

	constexpr size_type size() const noexcept {
		return static_cast<size_type>(super::size() / out_bits);
	}

	constexpr size_type unused_size() const noexcept {
		return static_cast<size_type>(super::unused_size() / in_bits);
	}

	using super::empty;
	using super::full;

	constexpr bool has_bits_for_pop() const noexcept {
		return super::size() >= out_bits;
	}

	constexpr bool has_capacity_for_push() const noexcept {
		return super::size() <= (capacity() - in_bits);
	}
};

} // namespace cthash

#endif

#include <iostream>
#include <ranges>

namespace cthash {

template <typename Buffer> struct buffer_result_type;

template <typename Buffer> requires(Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	static constexpr Buffer::size_type missing_bits = {0u};

	constexpr bool is_padding() const noexcept {
		return false;
	}
};

template <typename Buffer> requires(!Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	typename Buffer::size_type missing_bits;

	constexpr bool is_padding() const noexcept {
		return missing_bits == Buffer::out_bits;
	}
};

template <typename Buffer, bool AllowPadding> struct buffer_with_missing_bits;

template <typename Buffer, bool AllowPadding> requires(Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};

	struct result_type {
		typename Buffer::out_type value;
		static constexpr Buffer::size_type missing_bits = {0u};

		constexpr bool is_padding() const noexcept {
			return false;
		}
	};

	static constexpr bool aligned = Buffer::aligned();

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		return result_type{buffer.front()};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		while (!buffer.has_bits_for_pop() && (it != end)) {
			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <typename Buffer, bool AllowPadding> requires(!Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};
	Buffer::size_type missing_bits{0};

	static constexpr bool aligned = Buffer::aligned();

	struct result_type {
		typename Buffer::out_type value;
		typename Buffer::size_type missing_bits;

		constexpr bool is_padding() const noexcept {
			return missing_bits == Buffer::out_bits;
		}
	};

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		assert(Buffer::out_bits >= missing_bits);
		return result_type{buffer.front(), missing_bits};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	constexpr void pad_buffer() noexcept requires(AllowPadding) {
		// full multi-chunk padding (for baseN encodings)
		missing_bits = (Buffer::out_bits - buffer.push_zeros_for_padding());
	}

	constexpr void pad_buffer() noexcept requires(!AllowPadding) {
		// only add enough zero to finish current output chunk
		missing_bits = buffer.push_zeros_to_align();
	}

	constexpr void saturate_missing_bits() noexcept requires(AllowPadding) {
		if (missing_bits) {
			missing_bits = Buffer::out_bits;
		}
		// missing_bits = static_cast<buffer_size_t>((unsigned)(bool)missing_bits * output_value_bit_size);
	}

	constexpr void saturate_missing_bits() noexcept requires(!AllowPadding) {
		// do nothing :)
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		for (;;) {
			if (it == end) {
				if (buffer.has_bits_for_pop()) {
					// if this is second pass after padding we can mark all bits as missing
					saturate_missing_bits();
				} else {
					// fill remainder of buffer with zeros
					pad_buffer();
				}

				return;
			}

			if (buffer.has_bits_for_pop()) {
				return;
			}

			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <bool Value> struct conditional;

template <> struct conditional<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional<false> {
	template <typename, typename T> using type = T;
};

template <bool Const, typename T> using maybe_const = typename conditional<Const>::template type<const T, T>;

template <typename T> concept integral_like = std::integral<T> || std::same_as<std::byte, T>;

template <size_t Bits, bool AllowPadding, std::ranges::input_range Input> requires integral_like<std::ranges::range_value_t<Input>> struct chunk_of_bits_view {
	using input_value_type = std::ranges::range_value_t<Input>;

	static constexpr size_t output_value_bit_size = Bits;
	static constexpr size_t input_value_bit_size = sizeof(input_value_type) * 8u;
	using buffer_t = cthash::bit_buffer<output_value_bit_size, input_value_bit_size>;
	using buffer_size_t = buffer_t::size_type;
	Input input;

	static constexpr bool aligned = buffer_t::aligned;

	struct sentinel { };

	template <bool Const> struct iterator {
		using parent = maybe_const<Const, Input>;
		using storage_type = buffer_with_missing_bits<buffer_t, AllowPadding>;
		using value_type = storage_type::result_type;
		using difference_type = intptr_t;

		std::ranges::iterator_t<parent> it;
		[[no_unique_address]] std::ranges::sentinel_t<parent> end;

		storage_type buffer{};

		constexpr iterator(parent & p) noexcept: it{std::ranges::begin(p)}, end{std::ranges::end(p)} {
			// initialize
			buffer.feed_buffer(it, end);
		}

		iterator(const iterator &) = default;
		iterator(iterator &&) = default;

		iterator & operator=(const iterator &) = default;
		iterator & operator=(iterator &&) = default;

		constexpr iterator & operator++() noexcept {
			buffer.pop();
			buffer.feed_buffer(it, end);
			return *this;
		}

		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			this->operator++();
			return copy;
		}

		constexpr auto operator*() const noexcept {
			return buffer.front();
		}

		constexpr friend bool operator==(const iterator & lhs, const iterator & rhs) noexcept = default;

		constexpr friend bool operator==(const iterator & self, sentinel) noexcept {
			return self.buffer.empty();
		}
	};

	static_assert(std::input_iterator<iterator<true>>);
	static_assert(std::input_iterator<iterator<false>>);
	static_assert(std::sentinel_for<sentinel, iterator<true>>);
	static_assert(std::sentinel_for<sentinel, iterator<false>>);

	constexpr chunk_of_bits_view(Input _input) noexcept: input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input};
	}

	constexpr auto end() const noexcept {
		return sentinel{};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && AllowPadding) {
		// calculate with blocks
		return ((std::ranges::size(input) + (buffer_t::in_capacity() - 1u)) / buffer_t::in_capacity()) * buffer_t::out_capacity();
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && !AllowPadding) {
		// calculate with bits
		const size_t bit_size_of_input = std::ranges::size(input) * input_value_bit_size;
		return (bit_size_of_input + (output_value_bit_size - 1u)) / output_value_bit_size;
	}
};

template <size_t Bits, bool AllowPadding> struct chunk_of_bits_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, chunk_of_bits_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) {
		return chunk_of_bits_view<Bits, AllowPadding, R>(std::forward<R>(input));
	}
};

template <size_t Bits, bool AllowPadding = false> constexpr auto chunk_of_bits = chunk_of_bits_action<Bits, AllowPadding>{};

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#include <bit>

namespace cthash {

template <typename Encoding> struct encoding_properties {
	static constexpr size_t size = std::size(Encoding::alphabet) - 1u;
	static_assert(std::popcount(size) == 1u, "Size of encoding's alphabet must be power-of-two");

	static constexpr size_t bits = std::countr_zero(size);

	static constexpr bool has_padding = padded_encoding<Encoding>;

	static constexpr char padding = [] {
		if constexpr (has_padding) {
			return Encoding::padding;
		} else {
			return '\0';
		}
	}();
};

template <typename Encoding, typename CharT, typename R> struct encode_to_view {
	using properties = encoding_properties<Encoding>;
	using chunk_view = cthash::chunk_of_bits_view<properties::bits, properties::has_padding, R>;

	struct sentinel {
		[[no_unique_address]] chunk_view::sentinel end;
	};

	template <bool Const> struct iterator {
		using difference_type = intptr_t;
		using value_type = CharT;

		chunk_view::template iterator<Const> it;

		constexpr iterator & operator++() noexcept {
			++it;
			return *this;
		}
		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			++it;
			return copy;
		}

		constexpr value_type operator*() const noexcept {
			const auto tmp = *it;
			if constexpr (!chunk_view::aligned) {
				// TODO: do without condition
				if (tmp.is_padding()) {
					return properties::padding;
				}
			}
			return static_cast<value_type>(Encoding::alphabet[static_cast<unsigned>(tmp.value)]);
		}

		constexpr friend bool operator==(const iterator &, const iterator &) noexcept = default;

		constexpr friend bool operator==(const iterator & lhs, const sentinel & rhs) noexcept {
			return lhs.it == rhs.end;
		}
	};

	chunk_view input;

	constexpr encode_to_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}

	constexpr auto to_string() const requires(std::ranges::sized_range<R>) {
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(*this);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(size());
		auto [i, o] = std::ranges::copy(begin(), end(), result.begin());
		assert(i == result.end());
		assert(o == result.end());
		return result;
#endif
	}

	constexpr friend std::basic_ostream<CharT> & operator<<(std::basic_ostream<CharT> & out, encode_to_view in) {
		std::ranges::copy(in.begin(), in.end(), std::ostream_iterator<CharT, CharT>(out));
		return out;
	}
};

template <typename Encoding, typename ValueT, typename R> struct decode_from_view {
	R input;

	template <bool Const> struct iterator { };
	struct sentinel { };

	constexpr decode_from_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}
};

template <typename Encoding, typename CharT = char> struct encode_to_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, encode_to_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return encode_to_view<Encoding, CharT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename ValueT = unsigned char> struct decode_from_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, decode_from_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return decode_from_view<Encoding, ValueT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename CharT = char> constexpr auto encode_to = encode_to_action<Encoding, CharT>{};
template <typename Encoding, typename ValueT = unsigned char> constexpr auto decode_from = decode_from_action<Encoding, ValueT>{};

constexpr auto binary_encode = encode_to<encoding::base2, char>;
constexpr auto base2_encode = encode_to<encoding::base2, char>;
constexpr auto base4_encode = encode_to<encoding::base4, char>;
constexpr auto base8_encode = encode_to<encoding::base8, char>;
constexpr auto octal_encode = encode_to<encoding::base8, char>;
constexpr auto hexdec_encode = encode_to<encoding::base16, char>;
constexpr auto hexdec_uppercase_encode = encode_to<encoding::base16_uppercase, char>;
constexpr auto base16_encode = encode_to<encoding::base16, char>;
constexpr auto base32_encode = encode_to<encoding::base32, char>;
constexpr auto base32_no_padding_encode = encode_to<encoding::base32_no_padding, char>;
constexpr auto z_base32_encode = encode_to<encoding::z_base32, char>;
constexpr auto base64_encode = encode_to<encoding::base64, char>;
constexpr auto base64url_encode = encode_to<encoding::base64url, char>;
constexpr auto base64_no_padding_encode = encode_to<encoding::base64_no_padding, char>;

constexpr auto binary_decode = decode_from<encoding::base2, char>;
constexpr auto base2_decode = decode_from<encoding::base2, char>;
constexpr auto base4_decode = decode_from<encoding::base4, char>;
constexpr auto base8_decode = decode_from<encoding::base8, char>;
constexpr auto hexdec_decode = decode_from<encoding::base16, char>;
constexpr auto base16_decode = decode_from<encoding::base16, char>;
constexpr auto base32_decode = decode_from<encoding::base32, char>;
constexpr auto z_base32_decode = decode_from<encoding::z_base32, char>;
constexpr auto base64_decode = decode_from<encoding::base64, char>;
constexpr auto base64url_decode = decode_from<encoding::base64url, char>;
constexpr auto base64_no_padding_decode = decode_from<encoding::base64_no_padding, char>;

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

// template <typename Encoding, typename CharT, typename R> struct encode_to_view

#ifdef CTHASH_STDFMT_AVAILABLE
template <typename Encoding, typename R, typename CharT>
struct formatter<cthash::encode_to_view<Encoding, CharT, R>, CharT> {
	using subject_type = cthash::encode_to_view<Encoding, CharT, R>;

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		return std::ranges::begin(ctx);
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return std::ranges::copy(value, ctx.out()).out;
	}
};

#endif

} // namespace std

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_ALGORITHM_HPP
#define CTHASH_INTERNAL_ALGORITHM_HPP

#include <numeric>
#include <compare>
#include <cstddef>
#include <cstdint>

namespace cthash::internal {

template <typename It1, typename It2> constexpr auto threeway_compare_of_same_size(It1 lhs, It2 rhs, size_t length) -> std::strong_ordering {
	for (size_t i = 0; i != length; ++i) {
		if (const auto r = (*lhs++ <=> *rhs++); std::is_neq(r)) {
			return r;
		}
	}

	return std::strong_ordering::equal;
}

template <typename T, typename It1, typename It2, typename Stream> constexpr auto & push_to_stream_as(It1 f, It2 l, Stream & stream) {
	constexpr auto cast_and_shift = [](Stream * s, const auto & rhs) { (*s) << T{rhs}; return s; };
	return *std::accumulate(f, l, &stream, cast_and_shift);
}

} // namespace cthash::internal

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_HEXDEC_HPP
#define CTHASH_INTERNAL_HEXDEC_HPP

#include <array>
#include <ostream>
#include <span>
#include <type_traits>
#include <cstdint>

namespace cthash::internal {

consteval auto get_hexdec_table() noexcept {
	std::array<uint8_t, 128> result;

	auto char_to_hexdec = [](char c) {
		if (c >= '0' && c <= '9') {
			return static_cast<uint8_t>(c - '0');
		} else if (c >= 'a' && c <= 'f') {
			return static_cast<uint8_t>(c - 'a' + 10);
		} else if (c >= 'A' && c <= 'F') {
			return static_cast<uint8_t>(c - 'A' + 10);
		} else {
			return static_cast<uint8_t>(0);
		}
	};

	for (size_t i = 0; i != result.size(); ++i) {
		result[i] = char_to_hexdec(static_cast<char>(i));
	}

	return result;
}

constexpr auto hexdec_to_value_alphabet = get_hexdec_table();

template <typename CharT> constexpr auto value_to_hexdec_alphabet = std::array<CharT, 16>{CharT('0'), CharT('1'), CharT('2'), CharT('3'), CharT('4'), CharT('5'), CharT('6'), CharT('7'), CharT('8'), CharT('9'), CharT('a'), CharT('b'), CharT('c'), CharT('d'), CharT('e'), CharT('f')};

struct byte_hexdec_value {
	std::byte val;

	template <typename CharT, typename Traits> friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, byte_hexdec_value rhs) {
		return os << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val >> 4u)] << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val) & 0b1111u];
	}
};

template <size_t N, typename CharT> constexpr auto hexdec_to_binary(std::span<const CharT, N * 2> in) -> std::array<std::byte, N> {
	return [in]<size_t... Idx>(std::index_sequence<Idx...>) {
		return std::array<std::byte, N>{static_cast<std::byte>(hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2]) & 0b0111'1111u] << 4u | hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2u + 1u]) & 0b0111'1111u])...};
	}(std::make_index_sequence<N>());
}

template <typename CharT, size_t N>
requires((N - 1) % 2 == 0) // -1 because of zero terminator in literals
constexpr auto literal_hexdec_to_binary(const CharT (&in)[N]) -> std::array<std::byte, (N - 1) / 2> {
	return hexdec_to_binary<N / 2>(std::span<const char, N - 1>(in, N - 1));
}

} // namespace cthash::internal

#endif

#include <algorithm>
#include <array>
#include <format>
#include <span>
#include <string_view>
#include <compare>

namespace cthash {

// hash_value

template <size_t N> struct hash_value: std::array<std::byte, N> {
	using super = std::array<std::byte, N>;

	constexpr hash_value() noexcept: super{} { }
	explicit constexpr hash_value(super && s) noexcept: super(s) { }
	template <typename CharT> explicit constexpr hash_value(const CharT (&in)[N * 2u + 1u]) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in, N * 2u))} { }
	template <typename CharT> explicit constexpr hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in.data(), in.size()))} { }

	// comparison support
	constexpr friend bool operator==(const hash_value & lhs, const hash_value & rhs) noexcept = default;
	constexpr friend auto operator<=>(const hash_value & lhs, const hash_value & rhs) noexcept -> std::strong_ordering {
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), N);
	}

	template <typename Encoding = cthash::encoding::hexdec, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		auto hexdec_view = *this | cthash::encode_to<Encoding, CharT>;
		std::ranges::copy(hexdec_view, std::ostream_iterator<CharT, CharT>(os));
		return os;
	}

	// print to ostream support
	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const hash_value & val) {
		return val.print_into(os);
	}

	template <size_t PrefixN> constexpr auto prefix() const noexcept requires(PrefixN <= N) {
		hash_value<PrefixN> output{};
		std::ranges::copy(this->begin(), this->begin() + PrefixN, output.begin());
		return output;
	}

	template <size_t SuffixN> constexpr auto suffix() const noexcept requires(SuffixN <= N) {
		hash_value<SuffixN> output{};
		std::ranges::copy(this->end() - SuffixN, this->end(), output.begin());
		return output;
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(encoded);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(encoded.size());
		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());
		return result;
#endif
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_fixed_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
		// it's type dependendent so we can calculate the size...
		constexpr size_t size_needed = (hash_value{} | cthash::encode_to<Encoding, CharT>).size();

		auto result = cthash::fixed_string<CharT, size_needed>{nullptr};

		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());

		return result;
	}
};

template <typename CharT, size_t N> hash_value(const CharT (&)[N]) -> hash_value<(N - 1u) / 2u>;
template <typename CharT, size_t N> hash_value(std::span<const CharT, N>) -> hash_value<N / 2u>;
template <typename CharT, size_t N> hash_value(const fixed_string<CharT, N> &) -> hash_value<N / 2u>;

template <typename> struct default_encoding {
	using encoding = cthash::encoding::hexdec;
};

template <typename Tag> concept tag_with_encoding = requires() {
	typename Tag::encoding;
};

template <tag_with_encoding Tag> struct default_encoding<Tag> {
	using encoding = Tag::encoding;
};

template <typename Tag, size_t = internal::digest_bytes_length_of<Tag>> struct tagged_hash_value: hash_value<internal::digest_bytes_length_of<Tag>> {
	static constexpr size_t N = internal::digest_bytes_length_of<Tag>;

	using super = hash_value<N>;
	using super::super;
	template <typename CharT> explicit constexpr tagged_hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{in} { }

	static constexpr size_t digest_length = N;

	template <typename Encoding = default_encoding<Tag>::encoding, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		return super::template print_into<Encoding>(os);
	}

	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const tagged_hash_value & val) {
		return val.print_into(os);
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_string(const tagged_hash_value & value) {
		return to_string<Encoding, CharT>(static_cast<const super &>(value));
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_fixed_string(const tagged_hash_value & value) {
		return to_fixed_string<Encoding, CharT>(static_cast<const super &>(value));
	}
};

template <typename T> concept variable_digest_length = T::digest_length_bit == 0u;

template <size_t N, variable_digest_length Tag> struct variable_bit_length_tag: Tag {
	static constexpr size_t digest_length_bit = N;
};

template <typename T> concept convertible_to_tagged_hash_value = requires(const T & obj) {
	{ tagged_hash_value{obj} };
};

namespace literals {

	template <fixed_string Value>
	constexpr auto operator""_hash() {
		return hash_value(Value);
	}

} // namespace literals

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#if _LIBCPP_VERSION >= 170000
// libc++ will define __cpp_lib_format macro in 19.0
// https://github.com/llvm/llvm-project/issues/77773
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#ifdef CTHASH_STDFMT_AVAILABLE
template <size_t N, typename CharT>
struct formatter<cthash::hash_value<N>, CharT> {
	using subject_type = cthash::hash_value<N>;
	using default_encoding = cthash::encoding::hexdec;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <typename Tag, size_t N, typename CharT>
struct formatter<cthash::tagged_hash_value<Tag, N>, CharT> {
	using subject_type = cthash::tagged_hash_value<Tag, N>;
	using default_encoding = typename cthash::default_encoding<Tag>::encoding;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <cthash::convertible_to_tagged_hash_value Type, typename CharT> struct formatter<Type, CharT>: formatter<decltype(cthash::tagged_hash_value{std::declval<Type>()}), CharT> {
};

#endif

} // namespace std

#endif

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_CONVERT_HPP
#define CTHASH_INTERNAL_CONVERT_HPP

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#include <span>
#include <type_traits>
#include <cstddef>
#include <cstdint>
#include <cstring>

namespace cthash {

template <typename It1, typename It2, typename It3> constexpr auto byte_copy(It1 first, It2 last, It3 destination) {
	return std::transform(first, last, destination, [](byte_like auto v) { return static_cast<std::byte>(v); });
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << ((sizeof(T) - 1u - Idx) * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::little) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_le_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << static_cast<T>(Idx * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::big) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T> struct unwrap_littleendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> (Idx * 8u))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_littleendian_number(std::span<std::byte, 8>) -> unwrap_littleendian_number<uint64_t>;
unwrap_littleendian_number(std::span<std::byte, 4>) -> unwrap_littleendian_number<uint32_t>;

template <std::unsigned_integral T> struct unwrap_bigendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> ((bits - 8u) - 8u * Idx))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_bigendian_number(std::span<std::byte, 8>) -> unwrap_bigendian_number<uint64_t>;
unwrap_bigendian_number(std::span<std::byte, 4>) -> unwrap_bigendian_number<uint32_t>;

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#include <algorithm>
#include <array>
#include <span>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <typename Config> struct internal_hasher {
	static constexpr auto config = Config{};
	static constexpr size_t block_size_bytes = config.block_bits / 8u;
	static constexpr size_t digest_bytes = internal::digest_bytes_length_of<Config>;

	// internal types
	using state_value_t = std::remove_cvref_t<decltype(Config::initial_values)>;
	using state_item_t = typename state_value_t::value_type;

	using block_value_t = std::array<std::byte, block_size_bytes>;
	using block_view_t = std::span<const std::byte, block_size_bytes>;

	using staging_item_t = typename decltype(config.constants)::value_type;
	static constexpr size_t staging_size = config.constants.size();
	using staging_value_t = std::array<staging_item_t, staging_size>;
	using staging_view_t = std::span<const staging_item_t, staging_size>;

	using digest_span_t = std::span<std::byte, digest_bytes>;
	using result_t = cthash::tagged_hash_value<Config>;
	using length_t = typename Config::length_type;

	// internal state
	state_value_t hash;
	length_t total_length;

	block_value_t block;
	unsigned block_used;

	// constructors
	constexpr internal_hasher() noexcept: hash{config.initial_values}, total_length{0u}, block_used{0u} { }
	constexpr internal_hasher(const internal_hasher &) noexcept = default;
	constexpr internal_hasher(internal_hasher &&) noexcept = default;
	constexpr ~internal_hasher() noexcept = default;

	// take buffer and build staging
	template <byte_like Byte> [[gnu::always_inline]] static constexpr auto build_staging(std::span<const Byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		staging_value_t w;

		constexpr auto first_part_size = block_size_bytes / sizeof(staging_item_t);

		// fill first part with chunk
		for (int i = 0; i != int(first_part_size); ++i) {
			w[static_cast<size_t>(i)] = cast_from_bytes<staging_item_t>(chunk.subspan(static_cast<size_t>(i) * sizeof(staging_item_t)).template first<sizeof(staging_item_t)>());
		}

		// fill the rest (generify)
		for (int i = int(first_part_size); i != int(staging_size); ++i) {
			w[static_cast<size_t>(i)] = w[static_cast<size_t>(i - 16)] + config.sigma_0(w[static_cast<size_t>(i - 15)]) + w[static_cast<size_t>(i - 7)] + config.sigma_1(w[static_cast<size_t>(i - 2)]);
		}

		return w;
	}

	[[gnu::always_inline]] static constexpr auto build_staging(std::span<const std::byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		return build_staging<std::byte>(chunk);
	}

	[[gnu::always_inline]] static constexpr void rounds(staging_view_t w, state_value_t & state) noexcept {
		config.rounds(w, state);
	}

	// this implementation works only with input size aligned to bytes (not bits)
	template <byte_like T> [[gnu::always_inline]] constexpr void update_to_buffer_and_process(std::span<const T> in) noexcept {
		// if block is not used, we can build staging directly
		if (block_used) {
			const auto remaining_free_space = std::span<std::byte, block_size_bytes>(block).subspan(block_used);
			const auto to_copy = in.first(std::min(in.size(), remaining_free_space.size()));

			const auto it = byte_copy(to_copy.begin(), to_copy.end(), remaining_free_space.begin());
			total_length += to_copy.size();

			// we didn't fill the block
			if (it != remaining_free_space.end()) {
				assert(to_copy.size() == in.size());
				block_used += static_cast<unsigned>(to_copy.size());
				return;
			} else {
				block_used = 0u;
			}

			// we have block!
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// remove part we processed
			in = in.subspan(to_copy.size());
		}

		// do the work over blocks without copy
		if (not block_used) {
			while (in.size() >= block_size_bytes) {
				const auto local_block = in.template first<block_size_bytes>();
				total_length += block_size_bytes;

				const staging_value_t w = build_staging<T>(local_block);
				rounds(w, hash);

				// remove part we processed
				in = in.subspan(block_size_bytes);
			}
		}

		// remainder is put onto temporary block
		if (not in.empty()) {
			assert(block_used == 0u);
			assert(in.size() < block_size_bytes);

			// copy it to block and let it stay there
			byte_copy(in.begin(), in.end(), block.begin());
			block_used = static_cast<unsigned>(in.size());
			total_length += block_used;
		}
	}

	[[gnu::always_inline]] static constexpr bool finalize_buffer(block_value_t & block, size_t block_used) noexcept {
		assert(block_used < block.size());
		const auto free_space = std::span(block).subspan(block_used);

		auto it = free_space.data();
		*it++ = std::byte{0b1000'0000u};							   // first byte after data contains bit at MSB
		std::fill(it, (block.data() + block.size()), std::byte{0x0u}); // rest is filled with zeros

		// we don't have enough space to write length bits
		return free_space.size() < (1u + (config.length_size_bits / 8u));
	}

	[[gnu::always_inline]] static constexpr void finalize_buffer_by_writing_length(block_value_t & block, length_t total_length) noexcept {
		unwrap_bigendian_number{std::span(block).template last<sizeof(length_t)>()} = (total_length * 8u);
	}

	[[gnu::always_inline]] constexpr void finalize() noexcept {
		if (finalize_buffer(block, block_used)) {
			// we didn't have enough space, we need to process block
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// zero it out
			std::fill(block.begin(), block.end(), std::byte{0x0u});
		}

		// we either have space to write or we have zerod out block
		finalize_buffer_by_writing_length(block, total_length);

		// calculate last round
		const staging_value_t w = build_staging(block);
		rounds(w, hash);
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) == 0u)
	{
		// copy result to byte result
		constexpr size_t values_for_output = digest_bytes / sizeof(state_item_t);
		static_assert(values_for_output <= config.initial_values.size());

		for (int i = 0; i != values_for_output; ++i) {
			unwrap_bigendian_number<state_item_t>{out.subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) != 0u)
	{
		// this is only used when digest doesn't align with output buffer

		// make sure digest size is smaller than hash state
		static_assert(digest_bytes <= config.initial_values.size() * sizeof(state_item_t));

		// copy result to byte result
		std::array<std::byte, sizeof(state_item_t) * config.initial_values.size()> tmp_buffer;

		for (int i = 0; i != (int)config.initial_values.size(); ++i) {
			unwrap_bigendian_number<state_item_t>{std::span(tmp_buffer).subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}

		std::copy_n(tmp_buffer.data(), digest_bytes, out.data());
	}
};

// this is a convinience type for nicer UX...
template <typename Config> struct hasher: private internal_hasher<Config> {
	using super = internal_hasher<Config>;
	using result_t = typename super::result_t;
	using length_t = typename super::length_t;
	using digest_span_t = typename super::digest_span_t;

	constexpr hasher() noexcept: super() { }
	constexpr hasher(const hasher &) noexcept = default;
	constexpr hasher(hasher &&) noexcept = default;
	constexpr ~hasher() noexcept = default;

	// support for various input types
	constexpr hasher & update(std::span<const std::byte> input) noexcept {
		super::update_to_buffer_and_process(input);
		return *this;
	}

	template <convertible_to_byte_span T> constexpr hasher & update(const T & something) noexcept {
		using value_type = typename decltype(std::span(something))::value_type;
		super::update_to_buffer_and_process(std::span<const value_type>(something));
		return *this;
	}

	template <one_byte_char CharT> constexpr hasher & update(std::basic_string_view<CharT> in) noexcept {
		super::update_to_buffer_and_process(std::span(in.data(), in.size()));
		return *this;
	}

	template <string_literal T> constexpr hasher & update(const T & lit) noexcept {
		super::update_to_buffer_and_process(std::span(lit, std::size(lit) - 1u));
		return *this;
	}

	// TODO: any range with value convertible to byte

	// output (by reference or by value)
	constexpr void final(digest_span_t digest) noexcept {
		super::finalize();
		super::write_result_into(digest);
	}

	constexpr auto final() noexcept {
		result_t output;
		this->final(output);
		return output;
	}

	constexpr length_t size() const noexcept {
		return super::total_length;
	}
};

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_CONVERT_HPP
#define CTHASH_INTERNAL_CONVERT_HPP

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#include <span>
#include <type_traits>
#include <cstddef>
#include <cstdint>
#include <cstring>

namespace cthash {

template <typename It1, typename It2, typename It3> constexpr auto byte_copy(It1 first, It2 last, It3 destination) {
	return std::transform(first, last, destination, [](byte_like auto v) { return static_cast<std::byte>(v); });
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << ((sizeof(T) - 1u - Idx) * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::little) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_le_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << static_cast<T>(Idx * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::big) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T> struct unwrap_littleendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> (Idx * 8u))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_littleendian_number(std::span<std::byte, 8>) -> unwrap_littleendian_number<uint64_t>;
unwrap_littleendian_number(std::span<std::byte, 4>) -> unwrap_littleendian_number<uint32_t>;

template <std::unsigned_integral T> struct unwrap_bigendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> ((bits - 8u) - 8u * Idx))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_bigendian_number(std::span<std::byte, 8>) -> unwrap_bigendian_number<uint64_t>;
unwrap_bigendian_number(std::span<std::byte, 4>) -> unwrap_bigendian_number<uint32_t>;

} // namespace cthash

#endif

#ifndef CTHASH_SIMPLE_HPP
#define CTHASH_SIMPLE_HPP

#include <utility>

namespace cthash {

template <typename Hasher, typename In, typename... Args> concept hasher_like = requires(Hasher & h, const In & in, Args &&... args) //
{
	{ Hasher{std::forward<Args>(args)...} };
	{ h.update(in) } -> std::same_as<Hasher &>;
	{ h.final() };
};

template <typename Hasher, typename In> concept direct_hasher = requires(Hasher & h, const In & in) //
{
	{ h.update_and_final(in) };
};

template <typename Hasher, typename T, typename... Args>
requires hasher_like<Hasher, T, Args...>
constexpr auto simple(const T & value, Args &&... args) noexcept {
	if constexpr (direct_hasher<Hasher, T>) {
		return Hasher{std::forward<Args>(args)...}.update_and_final(value);
	} else {
		return Hasher{std::forward<Args>(args)...}.update(value).final();
	}
}

} // namespace cthash

#endif

#ifndef CTHASH_VALUE_HPP
#define CTHASH_VALUE_HPP

#ifndef CTHASH_FIXED_STRING_HPP
#define CTHASH_FIXED_STRING_HPP

#include <algorithm>
#include <span>
#include <string_view>

namespace cthash {

template <typename CharT, size_t N> struct fixed_string: std::array<CharT, N> {
	using super = std::array<CharT, N>;

	consteval static auto from_string_literal(const CharT (&in)[N + 1]) -> std::array<CharT, N> {
		std::array<CharT, N> out;
		std::copy_n(in, N, out.data());
		return out;
	}

	explicit constexpr fixed_string(std::nullptr_t) noexcept: super{} { }

	consteval fixed_string(const CharT (&in)[N + 1]) noexcept: super{from_string_literal(in)} { }

	using super::data;
	using super::size;

	constexpr operator std::span<const CharT, N>() const noexcept {
		return std::span<const CharT, N>(data(), size());
	}

	constexpr operator std::span<const CharT>() const noexcept {
		return std::span<const CharT>(data(), size());
	}

	constexpr operator std::basic_string_view<CharT>() const noexcept {
		return std::basic_string_view<CharT>(data(), size());
	}

	constexpr friend bool operator==(const fixed_string &, const fixed_string &) noexcept = default;
	constexpr friend bool operator==(const fixed_string & lhs, std::basic_string_view<CharT> rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == rhs;
	}
	constexpr friend bool operator==(const fixed_string & lhs, const CharT * rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == std::basic_string_view<CharT>{rhs};
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N - 1>;

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_BASE_HPP
#define CTHASH_ENCODING_BASE_HPP

#ifndef CTHASH_ENCODING_CHUNK_OF_BITS_HPP
#define CTHASH_ENCODING_CHUNK_OF_BITS_HPP

#ifndef CTHASH_ENCODING_BIT_BUFFER_HPP
#define CTHASH_ENCODING_BIT_BUFFER_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <bit>
#include <iostream>
#include <numeric>
#include <ranges>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct select_bit_integer;

template <size_t Bits> requires(Bits <= 8) struct select_bit_integer<Bits> {
	using type = uint8_t;
};

template <size_t Bits> requires(Bits > 8 && Bits <= 16) struct select_bit_integer<Bits> {
	using type = uint16_t;
};

template <size_t Bits> requires(Bits > 16 && Bits <= 32) struct select_bit_integer<Bits> {
	using type = uint32_t;
};

template <size_t Bits> requires(Bits > 32 && Bits <= 64) struct select_bit_integer<Bits> {
	using type = uint64_t;
};

template <size_t Bits> using select_bit_integer_t = select_bit_integer<Bits>::type;

template <size_t V> requires(std::popcount(V) == 1u) constexpr auto log2_of_power_of_2 = static_cast<size_t>(std::countr_zero(V));

template <size_t Bits> constexpr auto mask = static_cast<select_bit_integer_t<Bits>>((static_cast<select_bit_integer_t<Bits>>(1u) << Bits) - 1u);

template <size_t Capacity> class basic_bit_buffer {
public:
	static constexpr auto capacity = std::integral_constant<size_t, Capacity>{};
	using storage_type = select_bit_integer_t<capacity()>;
	using size_type = select_bit_integer_t<log2_of_power_of_2<std::bit_ceil(capacity())>>;

public:
	storage_type buffer{0};
	size_type bits_available{0};

public:
	template <size_t Bits> static constexpr auto mask = static_cast<storage_type>((static_cast<storage_type>(1u) << Bits) - 1u);

	constexpr friend bool operator==(const basic_bit_buffer & lhs, const basic_bit_buffer & rhs) noexcept = default;

	constexpr size_type size() const noexcept {
		return bits_available;
	}

	constexpr size_type unused_size() const noexcept {
		return capacity() - bits_available;
	}

	constexpr bool empty() const noexcept {
		return bits_available == 0u;
	}

	constexpr bool full() const noexcept {
		return bits_available == capacity();
	}

	template <size_t Bits> constexpr void push(select_bit_integer_t<Bits> in) noexcept requires(Bits <= capacity()) {
		assert(size() <= capacity() - Bits);
		buffer = static_cast<storage_type>(buffer << Bits) | static_cast<storage_type>(in);
		bits_available += static_cast<size_type>(Bits);
	}
	constexpr void push_empty_bits(size_t count) noexcept {
		buffer = static_cast<storage_type>(buffer << count);
		bits_available += static_cast<unsigned char>(count);
	}

	template <size_t Bits> constexpr void pop() noexcept requires(Bits <= capacity()) {
		assert(size() >= Bits);
		bits_available -= static_cast<size_type>(Bits);
	}

	template <size_t Bits> constexpr auto front() const noexcept -> select_bit_integer_t<Bits> requires(Bits <= capacity()) {
		using output_type = select_bit_integer_t<Bits>;
		assert(size() >= static_cast<size_type>(Bits));
		return static_cast<output_type>((buffer >> (bits_available - Bits))) & mask<Bits>;
	}
};

constexpr size_t calculate_padding_bit_count(size_t number_of_bits_in_buffer, size_t output_size, size_t input_size) {
	size_t n = number_of_bits_in_buffer;
	size_t padding_bits = 0u;

	while (n != 0u) {
		padding_bits += input_size;
		n += input_size;

		while (n >= output_size) {
			n = n - output_size;
		}
	}

	return padding_bits;
}

template <size_t OutBits, size_t InBits = 8u> class bit_buffer: protected basic_bit_buffer<std::lcm(OutBits, InBits)> {
	using super = basic_bit_buffer<std::lcm(OutBits, InBits)>;

public:
	constexpr bit_buffer() noexcept = default;

	using typename super::size_type;
	static constexpr auto out_bits = std::integral_constant<size_type, OutBits>{};
	static constexpr auto in_bits = std::integral_constant<size_type, InBits>{};

	using out_type = select_bit_integer_t<OutBits>;
	using in_type = select_bit_integer_t<InBits>;

	using super::capacity;
	static constexpr auto in_capacity = std::integral_constant<size_type, (capacity() / in_bits())>{};
	static constexpr auto out_capacity = std::integral_constant<size_type, (capacity() / out_bits())>{};

	static constexpr auto aligned = std::bool_constant<capacity() == in_capacity()>{};

	constexpr void push(in_type in) noexcept {
		super::template push<in_bits>(in);
	}

	constexpr void push_empty() noexcept {
		this->push(in_type{0u});
	}

	constexpr size_type push_zeros_to_align() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_to_align() noexcept requires(!aligned()) {
		if (empty()) {
			return 0u;
		}

		assert(out_bits > super::size());
		const size_type missing_bits = static_cast<size_type>(out_bits - super::size());
		super::push_empty_bits(missing_bits);
		return missing_bits;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(!aligned()) {
		const size_type usable_bits = super::size();
		const size_type missing_bits = static_cast<size_type>(calculate_padding_bit_count(super::size(), out_bits, in_bits));
		super::push_empty_bits(missing_bits);
		return usable_bits;
	}

	constexpr void pop() noexcept {
		super::template pop<out_bits>();
	}

	constexpr auto front() const noexcept -> out_type {
		return super::template front<out_bits>();
	}

	constexpr size_type size() const noexcept {
		return static_cast<size_type>(super::size() / out_bits);
	}

	constexpr size_type unused_size() const noexcept {
		return static_cast<size_type>(super::unused_size() / in_bits);
	}

	using super::empty;
	using super::full;

	constexpr bool has_bits_for_pop() const noexcept {
		return super::size() >= out_bits;
	}

	constexpr bool has_capacity_for_push() const noexcept {
		return super::size() <= (capacity() - in_bits);
	}
};

} // namespace cthash

#endif

#include <iostream>
#include <ranges>

namespace cthash {

template <typename Buffer> struct buffer_result_type;

template <typename Buffer> requires(Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	static constexpr Buffer::size_type missing_bits = {0u};

	constexpr bool is_padding() const noexcept {
		return false;
	}
};

template <typename Buffer> requires(!Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	typename Buffer::size_type missing_bits;

	constexpr bool is_padding() const noexcept {
		return missing_bits == Buffer::out_bits;
	}
};

template <typename Buffer, bool AllowPadding> struct buffer_with_missing_bits;

template <typename Buffer, bool AllowPadding> requires(Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};

	struct result_type {
		typename Buffer::out_type value;
		static constexpr Buffer::size_type missing_bits = {0u};

		constexpr bool is_padding() const noexcept {
			return false;
		}
	};

	static constexpr bool aligned = Buffer::aligned();

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		return result_type{buffer.front()};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		while (!buffer.has_bits_for_pop() && (it != end)) {
			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <typename Buffer, bool AllowPadding> requires(!Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};
	Buffer::size_type missing_bits{0};

	static constexpr bool aligned = Buffer::aligned();

	struct result_type {
		typename Buffer::out_type value;
		typename Buffer::size_type missing_bits;

		constexpr bool is_padding() const noexcept {
			return missing_bits == Buffer::out_bits;
		}
	};

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		assert(Buffer::out_bits >= missing_bits);
		return result_type{buffer.front(), missing_bits};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	constexpr void pad_buffer() noexcept requires(AllowPadding) {
		// full multi-chunk padding (for baseN encodings)
		missing_bits = (Buffer::out_bits - buffer.push_zeros_for_padding());
	}

	constexpr void pad_buffer() noexcept requires(!AllowPadding) {
		// only add enough zero to finish current output chunk
		missing_bits = buffer.push_zeros_to_align();
	}

	constexpr void saturate_missing_bits() noexcept requires(AllowPadding) {
		if (missing_bits) {
			missing_bits = Buffer::out_bits;
		}
		// missing_bits = static_cast<buffer_size_t>((unsigned)(bool)missing_bits * output_value_bit_size);
	}

	constexpr void saturate_missing_bits() noexcept requires(!AllowPadding) {
		// do nothing :)
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		for (;;) {
			if (it == end) {
				if (buffer.has_bits_for_pop()) {
					// if this is second pass after padding we can mark all bits as missing
					saturate_missing_bits();
				} else {
					// fill remainder of buffer with zeros
					pad_buffer();
				}

				return;
			}

			if (buffer.has_bits_for_pop()) {
				return;
			}

			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <bool Value> struct conditional;

template <> struct conditional<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional<false> {
	template <typename, typename T> using type = T;
};

template <bool Const, typename T> using maybe_const = typename conditional<Const>::template type<const T, T>;

template <typename T> concept integral_like = std::integral<T> || std::same_as<std::byte, T>;

template <size_t Bits, bool AllowPadding, std::ranges::input_range Input> requires integral_like<std::ranges::range_value_t<Input>> struct chunk_of_bits_view {
	using input_value_type = std::ranges::range_value_t<Input>;

	static constexpr size_t output_value_bit_size = Bits;
	static constexpr size_t input_value_bit_size = sizeof(input_value_type) * 8u;
	using buffer_t = cthash::bit_buffer<output_value_bit_size, input_value_bit_size>;
	using buffer_size_t = buffer_t::size_type;
	Input input;

	static constexpr bool aligned = buffer_t::aligned;

	struct sentinel { };

	template <bool Const> struct iterator {
		using parent = maybe_const<Const, Input>;
		using storage_type = buffer_with_missing_bits<buffer_t, AllowPadding>;
		using value_type = storage_type::result_type;
		using difference_type = intptr_t;

		std::ranges::iterator_t<parent> it;
		[[no_unique_address]] std::ranges::sentinel_t<parent> end;

		storage_type buffer{};

		constexpr iterator(parent & p) noexcept: it{std::ranges::begin(p)}, end{std::ranges::end(p)} {
			// initialize
			buffer.feed_buffer(it, end);
		}

		iterator(const iterator &) = default;
		iterator(iterator &&) = default;

		iterator & operator=(const iterator &) = default;
		iterator & operator=(iterator &&) = default;

		constexpr iterator & operator++() noexcept {
			buffer.pop();
			buffer.feed_buffer(it, end);
			return *this;
		}

		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			this->operator++();
			return copy;
		}

		constexpr auto operator*() const noexcept {
			return buffer.front();
		}

		constexpr friend bool operator==(const iterator & lhs, const iterator & rhs) noexcept = default;

		constexpr friend bool operator==(const iterator & self, sentinel) noexcept {
			return self.buffer.empty();
		}
	};

	static_assert(std::input_iterator<iterator<true>>);
	static_assert(std::input_iterator<iterator<false>>);
	static_assert(std::sentinel_for<sentinel, iterator<true>>);
	static_assert(std::sentinel_for<sentinel, iterator<false>>);

	constexpr chunk_of_bits_view(Input _input) noexcept: input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input};
	}

	constexpr auto end() const noexcept {
		return sentinel{};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && AllowPadding) {
		// calculate with blocks
		return ((std::ranges::size(input) + (buffer_t::in_capacity() - 1u)) / buffer_t::in_capacity()) * buffer_t::out_capacity();
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && !AllowPadding) {
		// calculate with bits
		const size_t bit_size_of_input = std::ranges::size(input) * input_value_bit_size;
		return (bit_size_of_input + (output_value_bit_size - 1u)) / output_value_bit_size;
	}
};

template <size_t Bits, bool AllowPadding> struct chunk_of_bits_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, chunk_of_bits_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) {
		return chunk_of_bits_view<Bits, AllowPadding, R>(std::forward<R>(input));
	}
};

template <size_t Bits, bool AllowPadding = false> constexpr auto chunk_of_bits = chunk_of_bits_action<Bits, AllowPadding>{};

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#include <bit>

namespace cthash {

template <typename Encoding> struct encoding_properties {
	static constexpr size_t size = std::size(Encoding::alphabet) - 1u;
	static_assert(std::popcount(size) == 1u, "Size of encoding's alphabet must be power-of-two");

	static constexpr size_t bits = std::countr_zero(size);

	static constexpr bool has_padding = padded_encoding<Encoding>;

	static constexpr char padding = [] {
		if constexpr (has_padding) {
			return Encoding::padding;
		} else {
			return '\0';
		}
	}();
};

template <typename Encoding, typename CharT, typename R> struct encode_to_view {
	using properties = encoding_properties<Encoding>;
	using chunk_view = cthash::chunk_of_bits_view<properties::bits, properties::has_padding, R>;

	struct sentinel {
		[[no_unique_address]] chunk_view::sentinel end;
	};

	template <bool Const> struct iterator {
		using difference_type = intptr_t;
		using value_type = CharT;

		chunk_view::template iterator<Const> it;

		constexpr iterator & operator++() noexcept {
			++it;
			return *this;
		}
		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			++it;
			return copy;
		}

		constexpr value_type operator*() const noexcept {
			const auto tmp = *it;
			if constexpr (!chunk_view::aligned) {
				// TODO: do without condition
				if (tmp.is_padding()) {
					return properties::padding;
				}
			}
			return static_cast<value_type>(Encoding::alphabet[static_cast<unsigned>(tmp.value)]);
		}

		constexpr friend bool operator==(const iterator &, const iterator &) noexcept = default;

		constexpr friend bool operator==(const iterator & lhs, const sentinel & rhs) noexcept {
			return lhs.it == rhs.end;
		}
	};

	chunk_view input;

	constexpr encode_to_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}

	constexpr auto to_string() const requires(std::ranges::sized_range<R>) {
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(*this);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(size());
		auto [i, o] = std::ranges::copy(begin(), end(), result.begin());
		assert(i == result.end());
		assert(o == result.end());
		return result;
#endif
	}

	constexpr friend std::basic_ostream<CharT> & operator<<(std::basic_ostream<CharT> & out, encode_to_view in) {
		std::ranges::copy(in.begin(), in.end(), std::ostream_iterator<CharT, CharT>(out));
		return out;
	}
};

template <typename Encoding, typename ValueT, typename R> struct decode_from_view {
	R input;

	template <bool Const> struct iterator { };
	struct sentinel { };

	constexpr decode_from_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}
};

template <typename Encoding, typename CharT = char> struct encode_to_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, encode_to_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return encode_to_view<Encoding, CharT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename ValueT = unsigned char> struct decode_from_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, decode_from_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return decode_from_view<Encoding, ValueT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename CharT = char> constexpr auto encode_to = encode_to_action<Encoding, CharT>{};
template <typename Encoding, typename ValueT = unsigned char> constexpr auto decode_from = decode_from_action<Encoding, ValueT>{};

constexpr auto binary_encode = encode_to<encoding::base2, char>;
constexpr auto base2_encode = encode_to<encoding::base2, char>;
constexpr auto base4_encode = encode_to<encoding::base4, char>;
constexpr auto base8_encode = encode_to<encoding::base8, char>;
constexpr auto octal_encode = encode_to<encoding::base8, char>;
constexpr auto hexdec_encode = encode_to<encoding::base16, char>;
constexpr auto hexdec_uppercase_encode = encode_to<encoding::base16_uppercase, char>;
constexpr auto base16_encode = encode_to<encoding::base16, char>;
constexpr auto base32_encode = encode_to<encoding::base32, char>;
constexpr auto base32_no_padding_encode = encode_to<encoding::base32_no_padding, char>;
constexpr auto z_base32_encode = encode_to<encoding::z_base32, char>;
constexpr auto base64_encode = encode_to<encoding::base64, char>;
constexpr auto base64url_encode = encode_to<encoding::base64url, char>;
constexpr auto base64_no_padding_encode = encode_to<encoding::base64_no_padding, char>;

constexpr auto binary_decode = decode_from<encoding::base2, char>;
constexpr auto base2_decode = decode_from<encoding::base2, char>;
constexpr auto base4_decode = decode_from<encoding::base4, char>;
constexpr auto base8_decode = decode_from<encoding::base8, char>;
constexpr auto hexdec_decode = decode_from<encoding::base16, char>;
constexpr auto base16_decode = decode_from<encoding::base16, char>;
constexpr auto base32_decode = decode_from<encoding::base32, char>;
constexpr auto z_base32_decode = decode_from<encoding::z_base32, char>;
constexpr auto base64_decode = decode_from<encoding::base64, char>;
constexpr auto base64url_decode = decode_from<encoding::base64url, char>;
constexpr auto base64_no_padding_decode = decode_from<encoding::base64_no_padding, char>;

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

// template <typename Encoding, typename CharT, typename R> struct encode_to_view

#ifdef CTHASH_STDFMT_AVAILABLE
template <typename Encoding, typename R, typename CharT>
struct formatter<cthash::encode_to_view<Encoding, CharT, R>, CharT> {
	using subject_type = cthash::encode_to_view<Encoding, CharT, R>;

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		return std::ranges::begin(ctx);
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return std::ranges::copy(value, ctx.out()).out;
	}
};

#endif

} // namespace std

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_ALGORITHM_HPP
#define CTHASH_INTERNAL_ALGORITHM_HPP

#include <numeric>
#include <compare>
#include <cstddef>
#include <cstdint>

namespace cthash::internal {

template <typename It1, typename It2> constexpr auto threeway_compare_of_same_size(It1 lhs, It2 rhs, size_t length) -> std::strong_ordering {
	for (size_t i = 0; i != length; ++i) {
		if (const auto r = (*lhs++ <=> *rhs++); std::is_neq(r)) {
			return r;
		}
	}

	return std::strong_ordering::equal;
}

template <typename T, typename It1, typename It2, typename Stream> constexpr auto & push_to_stream_as(It1 f, It2 l, Stream & stream) {
	constexpr auto cast_and_shift = [](Stream * s, const auto & rhs) { (*s) << T{rhs}; return s; };
	return *std::accumulate(f, l, &stream, cast_and_shift);
}

} // namespace cthash::internal

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_HEXDEC_HPP
#define CTHASH_INTERNAL_HEXDEC_HPP

#include <array>
#include <ostream>
#include <span>
#include <type_traits>
#include <cstdint>

namespace cthash::internal {

consteval auto get_hexdec_table() noexcept {
	std::array<uint8_t, 128> result;

	auto char_to_hexdec = [](char c) {
		if (c >= '0' && c <= '9') {
			return static_cast<uint8_t>(c - '0');
		} else if (c >= 'a' && c <= 'f') {
			return static_cast<uint8_t>(c - 'a' + 10);
		} else if (c >= 'A' && c <= 'F') {
			return static_cast<uint8_t>(c - 'A' + 10);
		} else {
			return static_cast<uint8_t>(0);
		}
	};

	for (size_t i = 0; i != result.size(); ++i) {
		result[i] = char_to_hexdec(static_cast<char>(i));
	}

	return result;
}

constexpr auto hexdec_to_value_alphabet = get_hexdec_table();

template <typename CharT> constexpr auto value_to_hexdec_alphabet = std::array<CharT, 16>{CharT('0'), CharT('1'), CharT('2'), CharT('3'), CharT('4'), CharT('5'), CharT('6'), CharT('7'), CharT('8'), CharT('9'), CharT('a'), CharT('b'), CharT('c'), CharT('d'), CharT('e'), CharT('f')};

struct byte_hexdec_value {
	std::byte val;

	template <typename CharT, typename Traits> friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, byte_hexdec_value rhs) {
		return os << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val >> 4u)] << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val) & 0b1111u];
	}
};

template <size_t N, typename CharT> constexpr auto hexdec_to_binary(std::span<const CharT, N * 2> in) -> std::array<std::byte, N> {
	return [in]<size_t... Idx>(std::index_sequence<Idx...>) {
		return std::array<std::byte, N>{static_cast<std::byte>(hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2]) & 0b0111'1111u] << 4u | hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2u + 1u]) & 0b0111'1111u])...};
	}(std::make_index_sequence<N>());
}

template <typename CharT, size_t N>
requires((N - 1) % 2 == 0) // -1 because of zero terminator in literals
constexpr auto literal_hexdec_to_binary(const CharT (&in)[N]) -> std::array<std::byte, (N - 1) / 2> {
	return hexdec_to_binary<N / 2>(std::span<const char, N - 1>(in, N - 1));
}

} // namespace cthash::internal

#endif

#include <algorithm>
#include <array>
#include <format>
#include <span>
#include <string_view>
#include <compare>

namespace cthash {

// hash_value

template <size_t N> struct hash_value: std::array<std::byte, N> {
	using super = std::array<std::byte, N>;

	constexpr hash_value() noexcept: super{} { }
	explicit constexpr hash_value(super && s) noexcept: super(s) { }
	template <typename CharT> explicit constexpr hash_value(const CharT (&in)[N * 2u + 1u]) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in, N * 2u))} { }
	template <typename CharT> explicit constexpr hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in.data(), in.size()))} { }

	// comparison support
	constexpr friend bool operator==(const hash_value & lhs, const hash_value & rhs) noexcept = default;
	constexpr friend auto operator<=>(const hash_value & lhs, const hash_value & rhs) noexcept -> std::strong_ordering {
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), N);
	}

	template <typename Encoding = cthash::encoding::hexdec, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		auto hexdec_view = *this | cthash::encode_to<Encoding, CharT>;
		std::ranges::copy(hexdec_view, std::ostream_iterator<CharT, CharT>(os));
		return os;
	}

	// print to ostream support
	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const hash_value & val) {
		return val.print_into(os);
	}

	template <size_t PrefixN> constexpr auto prefix() const noexcept requires(PrefixN <= N) {
		hash_value<PrefixN> output{};
		std::ranges::copy(this->begin(), this->begin() + PrefixN, output.begin());
		return output;
	}

	template <size_t SuffixN> constexpr auto suffix() const noexcept requires(SuffixN <= N) {
		hash_value<SuffixN> output{};
		std::ranges::copy(this->end() - SuffixN, this->end(), output.begin());
		return output;
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(encoded);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(encoded.size());
		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());
		return result;
#endif
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_fixed_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
		// it's type dependendent so we can calculate the size...
		constexpr size_t size_needed = (hash_value{} | cthash::encode_to<Encoding, CharT>).size();

		auto result = cthash::fixed_string<CharT, size_needed>{nullptr};

		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());

		return result;
	}
};

template <typename CharT, size_t N> hash_value(const CharT (&)[N]) -> hash_value<(N - 1u) / 2u>;
template <typename CharT, size_t N> hash_value(std::span<const CharT, N>) -> hash_value<N / 2u>;
template <typename CharT, size_t N> hash_value(const fixed_string<CharT, N> &) -> hash_value<N / 2u>;

template <typename> struct default_encoding {
	using encoding = cthash::encoding::hexdec;
};

template <typename Tag> concept tag_with_encoding = requires() {
	typename Tag::encoding;
};

template <tag_with_encoding Tag> struct default_encoding<Tag> {
	using encoding = Tag::encoding;
};

template <typename Tag, size_t = internal::digest_bytes_length_of<Tag>> struct tagged_hash_value: hash_value<internal::digest_bytes_length_of<Tag>> {
	static constexpr size_t N = internal::digest_bytes_length_of<Tag>;

	using super = hash_value<N>;
	using super::super;
	template <typename CharT> explicit constexpr tagged_hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{in} { }

	static constexpr size_t digest_length = N;

	template <typename Encoding = default_encoding<Tag>::encoding, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		return super::template print_into<Encoding>(os);
	}

	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const tagged_hash_value & val) {
		return val.print_into(os);
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_string(const tagged_hash_value & value) {
		return to_string<Encoding, CharT>(static_cast<const super &>(value));
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_fixed_string(const tagged_hash_value & value) {
		return to_fixed_string<Encoding, CharT>(static_cast<const super &>(value));
	}
};

template <typename T> concept variable_digest_length = T::digest_length_bit == 0u;

template <size_t N, variable_digest_length Tag> struct variable_bit_length_tag: Tag {
	static constexpr size_t digest_length_bit = N;
};

template <typename T> concept convertible_to_tagged_hash_value = requires(const T & obj) {
	{ tagged_hash_value{obj} };
};

namespace literals {

	template <fixed_string Value>
	constexpr auto operator""_hash() {
		return hash_value(Value);
	}

} // namespace literals

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#if _LIBCPP_VERSION >= 170000
// libc++ will define __cpp_lib_format macro in 19.0
// https://github.com/llvm/llvm-project/issues/77773
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#ifdef CTHASH_STDFMT_AVAILABLE
template <size_t N, typename CharT>
struct formatter<cthash::hash_value<N>, CharT> {
	using subject_type = cthash::hash_value<N>;
	using default_encoding = cthash::encoding::hexdec;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <typename Tag, size_t N, typename CharT>
struct formatter<cthash::tagged_hash_value<Tag, N>, CharT> {
	using subject_type = cthash::tagged_hash_value<Tag, N>;
	using default_encoding = typename cthash::default_encoding<Tag>::encoding;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <cthash::convertible_to_tagged_hash_value Type, typename CharT> struct formatter<Type, CharT>: formatter<decltype(cthash::tagged_hash_value{std::declval<Type>()}), CharT> {
};

#endif

} // namespace std

#endif

#include <cstdint>

namespace cthash {

template <typename T, typename Y> concept castable_to = requires(T val) { {static_cast<Y>(val)} -> std::same_as<Y>; };

template <size_t N> struct keccak_suffix {
	unsigned bits;
	std::array<std::byte, N> values;

	constexpr keccak_suffix(unsigned b, castable_to<std::byte> auto... v) noexcept: bits{b}, values{static_cast<std::byte>(v)...} { }
};

template <castable_to<std::byte>... Ts> keccak_suffix(unsigned, Ts...) -> keccak_suffix<sizeof...(Ts)>;

template <typename T> struct identify;

template <typename T, byte_like Byte> constexpr auto convert_prefix_into_aligned(std::span<const Byte> input, unsigned pos) noexcept -> std::array<std::byte, sizeof(T)> {
	assert(input.size() <= sizeof(T));
	assert(pos <= sizeof(T));
	assert((input.size() + pos) <= sizeof(T));

	std::array<std::byte, sizeof(T)> buffer{};

	std::fill(buffer.begin(), buffer.end(), std::byte{0});
	std::transform(input.data(), input.data() + input.size(), buffer.data() + pos, [](auto v) { return static_cast<std::byte>(v); });

	return buffer;
}

template <typename T, byte_like Byte> constexpr auto convert_prefix_into_value(std::span<const Byte> input, unsigned pos) noexcept -> uint64_t {
	const auto tmp = convert_prefix_into_aligned<T, Byte>(input, pos);
	return cast_from_le_bytes<T>(std::span<const std::byte, 8>(tmp));
}

template <typename Config> struct basic_keccak_hasher {
	static_assert(Config::digest_length_bit % 8u == 0u);
	static_assert(Config::rate_bit % 8u == 0u);
	static_assert(Config::capacity_bit % 8u == 0u);

	static_assert((Config::rate_bit + Config::capacity_bit) == 1600u, "Only Keccak 1600 is implemented");

	static constexpr size_t digest_length = Config::digest_length_bit / 8u;
	static constexpr size_t rate = Config::rate_bit / 8u;
	static constexpr size_t capacity = Config::capacity_bit / 8u;

	using result_t = cthash::tagged_hash_value<Config>;
	using digest_span_t = std::span<std::byte, digest_length>;

	keccak::state_1600 internal_state{};
	uint8_t position{0u};

	constexpr basic_keccak_hasher() noexcept {
		std::fill(internal_state.begin(), internal_state.end(), uint64_t{0});
	}

	template <byte_like T> constexpr size_t xor_overwrite_block(std::span<const T> input) noexcept {
		using value_t = keccak::state_1600::value_type;

		if ((std::is_constant_evaluated() | (std::endian::native != std::endian::little))) {
			assert((size_t(position) + input.size()) <= rate);

			// unaligned prefix (by copying from left to right it should be little endian)
			if (position % sizeof(value_t) != 0u) {
				// xor unaligned value and move to aligned if possible
				const size_t prefix_size = std::min(input.size(), sizeof(value_t) - (position % sizeof(value_t)));
				internal_state[position / sizeof(uint64_t)] ^= convert_prefix_into_value<value_t>(input.first(prefix_size), static_cast<unsigned>(position % sizeof(value_t)));
				position += static_cast<uint8_t>(prefix_size);
				input = input.subspan(prefix_size);
			}

			// aligned blocks
			while (input.size() >= sizeof(value_t)) {
				// xor aligned value and move to next
				internal_state[position / sizeof(value_t)] ^= cast_from_le_bytes<value_t>(input.template first<sizeof(value_t)>());
				position += static_cast<uint8_t>(sizeof(value_t));
				input = input.subspan(sizeof(value_t));
			}

			// unaligned suffix
			if (not input.empty()) {
				// xor and finish
				internal_state[position / sizeof(value_t)] ^= convert_prefix_into_value<value_t>(input, 0u);
				position += static_cast<uint8_t>(input.size());
			}

			return position;
		} else {
			const auto buffer = std::as_writable_bytes(std::span<uint64_t>(internal_state));
			const auto remaining = buffer.subspan(position);
			const auto place = remaining.first(std::min(input.size(), remaining.size()));

			std::transform(place.data(), place.data() + place.size(), input.data(), place.data(), [](std::byte lhs, auto rhs) { return lhs ^ static_cast<std::byte>(rhs); });

			position += static_cast<uint8_t>(place.size());
			return position;
		}
	}

	template <byte_like T> constexpr auto update(std::span<const T> input) noexcept {
		assert(position < rate);
		const size_t remaining_in_buffer = rate - position;

		if (remaining_in_buffer > input.size()) {
			// xor overwrite as much as we can, and that's all
			xor_overwrite_block(input);
			assert(position < rate);
			return;
		}

		// finish block and call keccak :)
		const auto first_part = input.first(remaining_in_buffer);
		input = input.subspan(remaining_in_buffer);
		xor_overwrite_block(first_part);
		assert(position == rate);
		keccak_f(internal_state);
		position = 0u;

		// for each full block we can absorb directly
		while (input.size() >= rate) {
			const auto block = input.template first<rate>();
			input = input.subspan(rate);
			assert(position == 0u);
			xor_overwrite_block<T>(block);
			keccak_f(internal_state);
			position = 0u;
		}

		// xor overwrite internal state with current remainder, and set position to end of it
		if (not input.empty()) {
			assert(position == 0u);
			xor_overwrite_block(input);
			assert(position < rate);
		}
	}

	// pad the message
	constexpr void xor_padding_block() noexcept {
		assert(position < rate);

		constexpr const auto & suffix = Config::suffix;
		constexpr std::byte suffix_and_start_of_padding = (suffix.values[0] | (std::byte{0b0000'0001u} << suffix.bits));

		internal_state[position / sizeof(uint64_t)] ^= uint64_t(suffix_and_start_of_padding) << ((position % sizeof(uint64_t)) * 8u);
		internal_state[(rate - 1u) / sizeof(uint64_t)] ^= 0x8000000000000000ull; // last bit
	}

	constexpr void final_absorb() noexcept {
		xor_padding_block();
		keccak_f(internal_state);
	}

	// get resulting hash
	constexpr void squeeze(std::span<std::byte> output) noexcept {
		using value_t = keccak::state_1600::value_type;

		static_assert((rate % sizeof(value_t)) == 0u);
		auto r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));

		// aligned results will be processed here...
		while ((output.size() >= sizeof(value_t))) {
			// if we ran out of `rate` part, we need to squeeze another block
			if (r.empty()) {
				keccak_f(internal_state);
				r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));
			}

			// look at current to process
			const value_t current = r.front();
			const auto part = output.first<sizeof(value_t)>();

			// convert
			unwrap_littleendian_number<value_t>{part} = current;

			// move to next
			r = r.subspan(1u);
			output = output.subspan(sizeof(value_t));
		}

		// unaligned result is here
		if (!output.empty()) {
			// if we ran out of `rate` part, we need to squeeze another block
			if (r.empty()) {
				keccak_f(internal_state);
				r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));
			}

			const value_t current = r.front();

			// convert
			std::array<std::byte, sizeof(value_t)> tmp;
			unwrap_littleendian_number<value_t>{tmp} = current;
			assert(tmp.size() > output.size());
			std::copy_n(tmp.data(), output.size(), output.data());
		}
	}

	constexpr void squeeze(digest_span_t output_fixed) noexcept
		requires((digest_length < rate) && digest_length != 0u)
	{
		auto output = std::span<std::byte>(output_fixed);

		// we don't need to squeeze anything
		using value_t = keccak::state_1600::value_type;

		static_assert((rate % sizeof(value_t)) == 0u);
		auto r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));

		// aligned results will be processed here...
		while ((output.size() >= sizeof(value_t))) {
			assert(!r.empty());
			// look at current to process
			const value_t current = r.front();
			const auto part = output.template first<sizeof(value_t)>();

			// convert
			unwrap_littleendian_number<value_t>{part} = current;

			// move to next
			r = r.subspan(1u);
			output = output.subspan(sizeof(value_t));
		}

		if constexpr ((output_fixed.size() % sizeof(value_t)) != 0u) {
			// unaligned result is here
			assert(!output.empty());
			assert(!r.empty());

			const value_t current = r.front();

			// convert
			std::array<std::byte, sizeof(value_t)> tmp;
			unwrap_littleendian_number<value_t>{tmp} = current;
			assert(tmp.size() > output.size());
			std::copy_n(tmp.data(), output.size(), output.data());
		}
	}

	constexpr void final(digest_span_t digest) noexcept
		requires(digest_length != 0u)
	{
		final_absorb();
		squeeze(digest);
	}

	constexpr result_t final() noexcept
		requires(digest_length != 0u)
	{
		result_t output;
		final(output);
		return output;
	}

	template <size_t N> constexpr auto final() noexcept
		requires(digest_length == 0u)
	{
		static_assert(N % 8u == 0u, "Only whole bytes are supported!");
		using result_type = typename Config::template variable_digest<N>;
		result_type output;
		final_absorb();
		squeeze(output);
		return output;
	}
};

template <typename Config> struct keccak_hasher: basic_keccak_hasher<Config> {
	using super = basic_keccak_hasher<Config>;
	using result_t = typename super::result_t;
	using digest_span_t = typename super::digest_span_t;

	constexpr keccak_hasher() noexcept: super() { }
	constexpr keccak_hasher(const keccak_hasher &) noexcept = default;
	constexpr keccak_hasher(keccak_hasher &&) noexcept = default;
	constexpr ~keccak_hasher() noexcept = default;

	constexpr keccak_hasher & update(std::span<const std::byte> input) noexcept {
		super::update(input);
		return *this;
	}

	template <convertible_to_byte_span T> constexpr keccak_hasher & update(const T & something) noexcept {
		using value_type = typename decltype(std::span(something))::value_type;
		super::update(std::span<const value_type>(something));
		return *this;
	}

	template <one_byte_char CharT> constexpr keccak_hasher & update(std::basic_string_view<CharT> in) noexcept {
		super::update(std::span(in.data(), in.size()));
		return *this;
	}

	template <string_literal T> constexpr keccak_hasher & update(const T & lit) noexcept {
		super::update(std::span(lit, std::size(lit) - 1u));
		return *this;
	}

	// TODO: any range with value convertible to byte

	using super::final;
};

template <size_t DigestBits>
struct sha_config {
	static constexpr size_t digest_length_bit = DigestBits;
	static constexpr size_t capacity_bit = DigestBits * 2u;
	static constexpr size_t rate_bit = 1600u - capacity_bit;

	static constexpr auto suffix = keccak_suffix(2, 0b0000'0010u); // in reverse
};

} // namespace cthash

#endif

namespace cthash {

using sha3_224_config = sha_config<224u>;
static_assert((sha3_224_config::capacity_bit + sha3_224_config::rate_bit) == 1600u);

using sha3_256_config = sha_config<256u>;
static_assert((sha3_256_config::capacity_bit + sha3_256_config::rate_bit) == 1600u);

using sha3_384_config = sha_config<384u>;
static_assert((sha3_384_config::capacity_bit + sha3_384_config::rate_bit) == 1600u);

using sha3_512_config = sha_config<512u>;
static_assert((sha3_512_config::capacity_bit + sha3_512_config::rate_bit) == 1600u);

// hasher and value type
using sha3_224 = cthash::keccak_hasher<sha3_224_config>;
using sha3_224_value = tagged_hash_value<sha3_224_config>;
using sha3_256 = cthash::keccak_hasher<sha3_256_config>;
using sha3_256_value = tagged_hash_value<sha3_256_config>;
using sha3_384 = cthash::keccak_hasher<sha3_384_config>;
using sha3_384_value = tagged_hash_value<sha3_384_config>;
using sha3_512 = cthash::keccak_hasher<sha3_512_config>;
using sha3_512_value = tagged_hash_value<sha3_512_config>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_sha3_224() {
		return sha3_224_value(Value);
	}

	template <fixed_string Value>
	consteval auto operator""_sha3_256() {
		return sha3_256_value(Value);
	}

	template <fixed_string Value>
	consteval auto operator""_sha3_384() {
		return sha3_384_value(Value);
	}

	template <fixed_string Value>
	consteval auto operator""_sha3_512() {
		return sha3_512_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

#ifndef CTHASH_SHA3_SHAKE128_HPP
#define CTHASH_SHA3_SHAKE128_HPP

#ifndef CTHASH_SHA3_COMMON_HPP
#define CTHASH_SHA3_COMMON_HPP

#ifndef CTHASH_SHA3_KECCAK_BASE_HPP
#define CTHASH_SHA3_KECCAK_BASE_HPP

#include <array>
#include <bit>
#include <span>
#include <type_traits>
#include <utility>
#include <concepts>
#include <cstdint>

namespace cthash::keccak {

// inspired by tiny-keccak (https://github.com/debris/tiny-keccak from Marek Kotewicz)

static constexpr auto rho = std::array<uint8_t, 24>{1u, 3u, 6u, 10u, 15u, 21u, 28u, 36u, 45u, 55u, 2u, 14u, 27u, 41u, 56u, 8u, 25u, 43u, 62u, 18u, 39u, 61u, 20u, 44u};

static constexpr auto pi = std::array<uint8_t, 24>{10u, 7u, 11u, 17u, 18u, 3u, 5u, 16u, 8u, 21u, 24u, 4u, 15u, 23u, 19u, 13u, 12u, 2u, 20u, 14u, 22u, 9u, 6u, 1u};

static constexpr auto rc = std::array<uint64_t, 24>{0x1ULL, 0x8082ULL, 0x800000000000808aULL, 0x8000000080008000ULL, 0x808bULL, 0x80000001ULL, 0x8000000080008081ULL, 0x8000000000008009ULL, 0x8aULL, 0x88ULL, 0x80008009ULL, 0x8000000aULL, 0x8000808bULL, 0x800000000000008bULL, 0x8000000000008089ULL, 0x8000000000008003ULL, 0x8000000000008002ULL, 0x8000000000000080ULL, 0x800aULL, 0x800000008000000aULL, 0x8000000080008081ULL, 0x8000000000008080ULL, 0x80000001ULL, 0x8000000080008008ULL};

struct state_1600: std::array<uint64_t, (5u * 5u)> { };

struct state_1600_ref: std::span<uint64_t, (5u * 5u)> {
	using super = std::span<uint64_t, (5u * 5u)>;
	using super::super;
};

[[gnu::always_inline, gnu::flatten]] constexpr void theta(state_1600_ref state) noexcept {
	// xor of columns
	const auto b = std::array<uint64_t, 5>{
		state[0] xor state[5] xor state[10] xor state[15] xor state[20],
		state[1] xor state[6] xor state[11] xor state[16] xor state[21],
		state[2] xor state[7] xor state[12] xor state[17] xor state[22],
		state[3] xor state[8] xor state[13] xor state[18] xor state[23],
		state[4] xor state[9] xor state[14] xor state[19] xor state[24],
	};

	const auto tmp = std::array<uint64_t, 5>{
		b[4] xor std::rotl(b[1], 1),
		b[0] xor std::rotl(b[2], 1),
		b[1] xor std::rotl(b[3], 1),
		b[2] xor std::rotl(b[4], 1),
		b[3] xor std::rotl(b[0], 1),
	};

	[&]<size_t... Idx>(std::index_sequence<Idx...>) {
		((state[Idx] ^= tmp[Idx % 5u]), ...);
	}(std::make_index_sequence<25>());
}

[[gnu::always_inline, gnu::flatten]] constexpr void rho_pi(state_1600_ref state) noexcept {
	uint64_t tmp = state[1];

	[&]<size_t... Idx>(std::index_sequence<Idx...>) {
		((state[pi[Idx]] = std::rotl(std::exchange(tmp, state[pi[Idx]]), rho[Idx])), ...);
	}(std::make_index_sequence<24>());
}

[[gnu::always_inline, gnu::flatten]] constexpr void chi(state_1600_ref state) noexcept {
	constexpr auto chi_helper = [](std::span<uint64_t, 5> row) {
		const auto b = std::array<uint64_t, 5>{row[0], row[1], row[2], row[3], row[4]};

		row[0] = b[0] xor ((~b[1]) bitand b[2]);
		row[1] = b[1] xor ((~b[2]) bitand b[3]);
		row[2] = b[2] xor ((~b[3]) bitand b[4]);
		row[3] = b[3] xor ((~b[4]) bitand b[0]);
		row[4] = b[4] xor ((~b[0]) bitand b[1]);
	};

	chi_helper(state.subspan<0>().first<5>());
	chi_helper(state.subspan<5>().first<5>());
	chi_helper(state.subspan<10>().first<5>());
	chi_helper(state.subspan<15>().first<5>());
	chi_helper(state.subspan<20>().first<5>());
}

[[gnu::flatten]] constexpr void keccak_f(state_1600 & state) noexcept {
	// rounds
	for (int i = 0; i != 24; ++i) {
		// theta (xor each column together)
		theta(state);
		rho_pi(state);
		chi(state);
		state[0] ^= rc[static_cast<size_t>(i)];
	}
}

} // namespace cthash::keccak

#endif
#ifndef CONSTEXPR_SHA2_HASHER_HPP
#define CONSTEXPR_SHA2_HASHER_HPP

#ifndef CTHASH_SIMPLE_HPP
#define CTHASH_SIMPLE_HPP

#include <utility>

namespace cthash {

template <typename Hasher, typename In, typename... Args> concept hasher_like = requires(Hasher & h, const In & in, Args &&... args) //
{
	{ Hasher{std::forward<Args>(args)...} };
	{ h.update(in) } -> std::same_as<Hasher &>;
	{ h.final() };
};

template <typename Hasher, typename In> concept direct_hasher = requires(Hasher & h, const In & in) //
{
	{ h.update_and_final(in) };
};

template <typename Hasher, typename T, typename... Args>
requires hasher_like<Hasher, T, Args...>
constexpr auto simple(const T & value, Args &&... args) noexcept {
	if constexpr (direct_hasher<Hasher, T>) {
		return Hasher{std::forward<Args>(args)...}.update_and_final(value);
	} else {
		return Hasher{std::forward<Args>(args)...}.update(value).final();
	}
}

} // namespace cthash

#endif

#ifndef CTHASH_VALUE_HPP
#define CTHASH_VALUE_HPP

#ifndef CTHASH_FIXED_STRING_HPP
#define CTHASH_FIXED_STRING_HPP

#include <algorithm>
#include <span>
#include <string_view>

namespace cthash {

template <typename CharT, size_t N> struct fixed_string: std::array<CharT, N> {
	using super = std::array<CharT, N>;

	consteval static auto from_string_literal(const CharT (&in)[N + 1]) -> std::array<CharT, N> {
		std::array<CharT, N> out;
		std::copy_n(in, N, out.data());
		return out;
	}

	explicit constexpr fixed_string(std::nullptr_t) noexcept: super{} { }

	consteval fixed_string(const CharT (&in)[N + 1]) noexcept: super{from_string_literal(in)} { }

	using super::data;
	using super::size;

	constexpr operator std::span<const CharT, N>() const noexcept {
		return std::span<const CharT, N>(data(), size());
	}

	constexpr operator std::span<const CharT>() const noexcept {
		return std::span<const CharT>(data(), size());
	}

	constexpr operator std::basic_string_view<CharT>() const noexcept {
		return std::basic_string_view<CharT>(data(), size());
	}

	constexpr friend bool operator==(const fixed_string &, const fixed_string &) noexcept = default;
	constexpr friend bool operator==(const fixed_string & lhs, std::basic_string_view<CharT> rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == rhs;
	}
	constexpr friend bool operator==(const fixed_string & lhs, const CharT * rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == std::basic_string_view<CharT>{rhs};
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N - 1>;

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_BASE_HPP
#define CTHASH_ENCODING_BASE_HPP

#ifndef CTHASH_ENCODING_CHUNK_OF_BITS_HPP
#define CTHASH_ENCODING_CHUNK_OF_BITS_HPP

#ifndef CTHASH_ENCODING_BIT_BUFFER_HPP
#define CTHASH_ENCODING_BIT_BUFFER_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <bit>
#include <iostream>
#include <numeric>
#include <ranges>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct select_bit_integer;

template <size_t Bits> requires(Bits <= 8) struct select_bit_integer<Bits> {
	using type = uint8_t;
};

template <size_t Bits> requires(Bits > 8 && Bits <= 16) struct select_bit_integer<Bits> {
	using type = uint16_t;
};

template <size_t Bits> requires(Bits > 16 && Bits <= 32) struct select_bit_integer<Bits> {
	using type = uint32_t;
};

template <size_t Bits> requires(Bits > 32 && Bits <= 64) struct select_bit_integer<Bits> {
	using type = uint64_t;
};

template <size_t Bits> using select_bit_integer_t = select_bit_integer<Bits>::type;

template <size_t V> requires(std::popcount(V) == 1u) constexpr auto log2_of_power_of_2 = static_cast<size_t>(std::countr_zero(V));

template <size_t Bits> constexpr auto mask = static_cast<select_bit_integer_t<Bits>>((static_cast<select_bit_integer_t<Bits>>(1u) << Bits) - 1u);

template <size_t Capacity> class basic_bit_buffer {
public:
	static constexpr auto capacity = std::integral_constant<size_t, Capacity>{};
	using storage_type = select_bit_integer_t<capacity()>;
	using size_type = select_bit_integer_t<log2_of_power_of_2<std::bit_ceil(capacity())>>;

public:
	storage_type buffer{0};
	size_type bits_available{0};

public:
	template <size_t Bits> static constexpr auto mask = static_cast<storage_type>((static_cast<storage_type>(1u) << Bits) - 1u);

	constexpr friend bool operator==(const basic_bit_buffer & lhs, const basic_bit_buffer & rhs) noexcept = default;

	constexpr size_type size() const noexcept {
		return bits_available;
	}

	constexpr size_type unused_size() const noexcept {
		return capacity() - bits_available;
	}

	constexpr bool empty() const noexcept {
		return bits_available == 0u;
	}

	constexpr bool full() const noexcept {
		return bits_available == capacity();
	}

	template <size_t Bits> constexpr void push(select_bit_integer_t<Bits> in) noexcept requires(Bits <= capacity()) {
		assert(size() <= capacity() - Bits);
		buffer = static_cast<storage_type>(buffer << Bits) | static_cast<storage_type>(in);
		bits_available += static_cast<size_type>(Bits);
	}
	constexpr void push_empty_bits(size_t count) noexcept {
		buffer = static_cast<storage_type>(buffer << count);
		bits_available += static_cast<unsigned char>(count);
	}

	template <size_t Bits> constexpr void pop() noexcept requires(Bits <= capacity()) {
		assert(size() >= Bits);
		bits_available -= static_cast<size_type>(Bits);
	}

	template <size_t Bits> constexpr auto front() const noexcept -> select_bit_integer_t<Bits> requires(Bits <= capacity()) {
		using output_type = select_bit_integer_t<Bits>;
		assert(size() >= static_cast<size_type>(Bits));
		return static_cast<output_type>((buffer >> (bits_available - Bits))) & mask<Bits>;
	}
};

constexpr size_t calculate_padding_bit_count(size_t number_of_bits_in_buffer, size_t output_size, size_t input_size) {
	size_t n = number_of_bits_in_buffer;
	size_t padding_bits = 0u;

	while (n != 0u) {
		padding_bits += input_size;
		n += input_size;

		while (n >= output_size) {
			n = n - output_size;
		}
	}

	return padding_bits;
}

template <size_t OutBits, size_t InBits = 8u> class bit_buffer: protected basic_bit_buffer<std::lcm(OutBits, InBits)> {
	using super = basic_bit_buffer<std::lcm(OutBits, InBits)>;

public:
	constexpr bit_buffer() noexcept = default;

	using typename super::size_type;
	static constexpr auto out_bits = std::integral_constant<size_type, OutBits>{};
	static constexpr auto in_bits = std::integral_constant<size_type, InBits>{};

	using out_type = select_bit_integer_t<OutBits>;
	using in_type = select_bit_integer_t<InBits>;

	using super::capacity;
	static constexpr auto in_capacity = std::integral_constant<size_type, (capacity() / in_bits())>{};
	static constexpr auto out_capacity = std::integral_constant<size_type, (capacity() / out_bits())>{};

	static constexpr auto aligned = std::bool_constant<capacity() == in_capacity()>{};

	constexpr void push(in_type in) noexcept {
		super::template push<in_bits>(in);
	}

	constexpr void push_empty() noexcept {
		this->push(in_type{0u});
	}

	constexpr size_type push_zeros_to_align() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_to_align() noexcept requires(!aligned()) {
		if (empty()) {
			return 0u;
		}

		assert(out_bits > super::size());
		const size_type missing_bits = static_cast<size_type>(out_bits - super::size());
		super::push_empty_bits(missing_bits);
		return missing_bits;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(!aligned()) {
		const size_type usable_bits = super::size();
		const size_type missing_bits = static_cast<size_type>(calculate_padding_bit_count(super::size(), out_bits, in_bits));
		super::push_empty_bits(missing_bits);
		return usable_bits;
	}

	constexpr void pop() noexcept {
		super::template pop<out_bits>();
	}

	constexpr auto front() const noexcept -> out_type {
		return super::template front<out_bits>();
	}

	constexpr size_type size() const noexcept {
		return static_cast<size_type>(super::size() / out_bits);
	}

	constexpr size_type unused_size() const noexcept {
		return static_cast<size_type>(super::unused_size() / in_bits);
	}

	using super::empty;
	using super::full;

	constexpr bool has_bits_for_pop() const noexcept {
		return super::size() >= out_bits;
	}

	constexpr bool has_capacity_for_push() const noexcept {
		return super::size() <= (capacity() - in_bits);
	}
};

} // namespace cthash

#endif

#include <iostream>
#include <ranges>

namespace cthash {

template <typename Buffer> struct buffer_result_type;

template <typename Buffer> requires(Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	static constexpr Buffer::size_type missing_bits = {0u};

	constexpr bool is_padding() const noexcept {
		return false;
	}
};

template <typename Buffer> requires(!Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	typename Buffer::size_type missing_bits;

	constexpr bool is_padding() const noexcept {
		return missing_bits == Buffer::out_bits;
	}
};

template <typename Buffer, bool AllowPadding> struct buffer_with_missing_bits;

template <typename Buffer, bool AllowPadding> requires(Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};

	struct result_type {
		typename Buffer::out_type value;
		static constexpr Buffer::size_type missing_bits = {0u};

		constexpr bool is_padding() const noexcept {
			return false;
		}
	};

	static constexpr bool aligned = Buffer::aligned();

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		return result_type{buffer.front()};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		while (!buffer.has_bits_for_pop() && (it != end)) {
			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <typename Buffer, bool AllowPadding> requires(!Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};
	Buffer::size_type missing_bits{0};

	static constexpr bool aligned = Buffer::aligned();

	struct result_type {
		typename Buffer::out_type value;
		typename Buffer::size_type missing_bits;

		constexpr bool is_padding() const noexcept {
			return missing_bits == Buffer::out_bits;
		}
	};

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		assert(Buffer::out_bits >= missing_bits);
		return result_type{buffer.front(), missing_bits};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	constexpr void pad_buffer() noexcept requires(AllowPadding) {
		// full multi-chunk padding (for baseN encodings)
		missing_bits = (Buffer::out_bits - buffer.push_zeros_for_padding());
	}

	constexpr void pad_buffer() noexcept requires(!AllowPadding) {
		// only add enough zero to finish current output chunk
		missing_bits = buffer.push_zeros_to_align();
	}

	constexpr void saturate_missing_bits() noexcept requires(AllowPadding) {
		if (missing_bits) {
			missing_bits = Buffer::out_bits;
		}
		// missing_bits = static_cast<buffer_size_t>((unsigned)(bool)missing_bits * output_value_bit_size);
	}

	constexpr void saturate_missing_bits() noexcept requires(!AllowPadding) {
		// do nothing :)
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		for (;;) {
			if (it == end) {
				if (buffer.has_bits_for_pop()) {
					// if this is second pass after padding we can mark all bits as missing
					saturate_missing_bits();
				} else {
					// fill remainder of buffer with zeros
					pad_buffer();
				}

				return;
			}

			if (buffer.has_bits_for_pop()) {
				return;
			}

			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <bool Value> struct conditional;

template <> struct conditional<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional<false> {
	template <typename, typename T> using type = T;
};

template <bool Const, typename T> using maybe_const = typename conditional<Const>::template type<const T, T>;

template <typename T> concept integral_like = std::integral<T> || std::same_as<std::byte, T>;

template <size_t Bits, bool AllowPadding, std::ranges::input_range Input> requires integral_like<std::ranges::range_value_t<Input>> struct chunk_of_bits_view {
	using input_value_type = std::ranges::range_value_t<Input>;

	static constexpr size_t output_value_bit_size = Bits;
	static constexpr size_t input_value_bit_size = sizeof(input_value_type) * 8u;
	using buffer_t = cthash::bit_buffer<output_value_bit_size, input_value_bit_size>;
	using buffer_size_t = buffer_t::size_type;
	Input input;

	static constexpr bool aligned = buffer_t::aligned;

	struct sentinel { };

	template <bool Const> struct iterator {
		using parent = maybe_const<Const, Input>;
		using storage_type = buffer_with_missing_bits<buffer_t, AllowPadding>;
		using value_type = storage_type::result_type;
		using difference_type = intptr_t;

		std::ranges::iterator_t<parent> it;
		[[no_unique_address]] std::ranges::sentinel_t<parent> end;

		storage_type buffer{};

		constexpr iterator(parent & p) noexcept: it{std::ranges::begin(p)}, end{std::ranges::end(p)} {
			// initialize
			buffer.feed_buffer(it, end);
		}

		iterator(const iterator &) = default;
		iterator(iterator &&) = default;

		iterator & operator=(const iterator &) = default;
		iterator & operator=(iterator &&) = default;

		constexpr iterator & operator++() noexcept {
			buffer.pop();
			buffer.feed_buffer(it, end);
			return *this;
		}

		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			this->operator++();
			return copy;
		}

		constexpr auto operator*() const noexcept {
			return buffer.front();
		}

		constexpr friend bool operator==(const iterator & lhs, const iterator & rhs) noexcept = default;

		constexpr friend bool operator==(const iterator & self, sentinel) noexcept {
			return self.buffer.empty();
		}
	};

	static_assert(std::input_iterator<iterator<true>>);
	static_assert(std::input_iterator<iterator<false>>);
	static_assert(std::sentinel_for<sentinel, iterator<true>>);
	static_assert(std::sentinel_for<sentinel, iterator<false>>);

	constexpr chunk_of_bits_view(Input _input) noexcept: input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input};
	}

	constexpr auto end() const noexcept {
		return sentinel{};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && AllowPadding) {
		// calculate with blocks
		return ((std::ranges::size(input) + (buffer_t::in_capacity() - 1u)) / buffer_t::in_capacity()) * buffer_t::out_capacity();
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && !AllowPadding) {
		// calculate with bits
		const size_t bit_size_of_input = std::ranges::size(input) * input_value_bit_size;
		return (bit_size_of_input + (output_value_bit_size - 1u)) / output_value_bit_size;
	}
};

template <size_t Bits, bool AllowPadding> struct chunk_of_bits_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, chunk_of_bits_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) {
		return chunk_of_bits_view<Bits, AllowPadding, R>(std::forward<R>(input));
	}
};

template <size_t Bits, bool AllowPadding = false> constexpr auto chunk_of_bits = chunk_of_bits_action<Bits, AllowPadding>{};

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#include <bit>

namespace cthash {

template <typename Encoding> struct encoding_properties {
	static constexpr size_t size = std::size(Encoding::alphabet) - 1u;
	static_assert(std::popcount(size) == 1u, "Size of encoding's alphabet must be power-of-two");

	static constexpr size_t bits = std::countr_zero(size);

	static constexpr bool has_padding = padded_encoding<Encoding>;

	static constexpr char padding = [] {
		if constexpr (has_padding) {
			return Encoding::padding;
		} else {
			return '\0';
		}
	}();
};

template <typename Encoding, typename CharT, typename R> struct encode_to_view {
	using properties = encoding_properties<Encoding>;
	using chunk_view = cthash::chunk_of_bits_view<properties::bits, properties::has_padding, R>;

	struct sentinel {
		[[no_unique_address]] chunk_view::sentinel end;
	};

	template <bool Const> struct iterator {
		using difference_type = intptr_t;
		using value_type = CharT;

		chunk_view::template iterator<Const> it;

		constexpr iterator & operator++() noexcept {
			++it;
			return *this;
		}
		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			++it;
			return copy;
		}

		constexpr value_type operator*() const noexcept {
			const auto tmp = *it;
			if constexpr (!chunk_view::aligned) {
				// TODO: do without condition
				if (tmp.is_padding()) {
					return properties::padding;
				}
			}
			return static_cast<value_type>(Encoding::alphabet[static_cast<unsigned>(tmp.value)]);
		}

		constexpr friend bool operator==(const iterator &, const iterator &) noexcept = default;

		constexpr friend bool operator==(const iterator & lhs, const sentinel & rhs) noexcept {
			return lhs.it == rhs.end;
		}
	};

	chunk_view input;

	constexpr encode_to_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}

	constexpr auto to_string() const requires(std::ranges::sized_range<R>) {
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(*this);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(size());
		auto [i, o] = std::ranges::copy(begin(), end(), result.begin());
		assert(i == result.end());
		assert(o == result.end());
		return result;
#endif
	}

	constexpr friend std::basic_ostream<CharT> & operator<<(std::basic_ostream<CharT> & out, encode_to_view in) {
		std::ranges::copy(in.begin(), in.end(), std::ostream_iterator<CharT, CharT>(out));
		return out;
	}
};

template <typename Encoding, typename ValueT, typename R> struct decode_from_view {
	R input;

	template <bool Const> struct iterator { };
	struct sentinel { };

	constexpr decode_from_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}
};

template <typename Encoding, typename CharT = char> struct encode_to_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, encode_to_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return encode_to_view<Encoding, CharT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename ValueT = unsigned char> struct decode_from_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, decode_from_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return decode_from_view<Encoding, ValueT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename CharT = char> constexpr auto encode_to = encode_to_action<Encoding, CharT>{};
template <typename Encoding, typename ValueT = unsigned char> constexpr auto decode_from = decode_from_action<Encoding, ValueT>{};

constexpr auto binary_encode = encode_to<encoding::base2, char>;
constexpr auto base2_encode = encode_to<encoding::base2, char>;
constexpr auto base4_encode = encode_to<encoding::base4, char>;
constexpr auto base8_encode = encode_to<encoding::base8, char>;
constexpr auto octal_encode = encode_to<encoding::base8, char>;
constexpr auto hexdec_encode = encode_to<encoding::base16, char>;
constexpr auto hexdec_uppercase_encode = encode_to<encoding::base16_uppercase, char>;
constexpr auto base16_encode = encode_to<encoding::base16, char>;
constexpr auto base32_encode = encode_to<encoding::base32, char>;
constexpr auto base32_no_padding_encode = encode_to<encoding::base32_no_padding, char>;
constexpr auto z_base32_encode = encode_to<encoding::z_base32, char>;
constexpr auto base64_encode = encode_to<encoding::base64, char>;
constexpr auto base64url_encode = encode_to<encoding::base64url, char>;
constexpr auto base64_no_padding_encode = encode_to<encoding::base64_no_padding, char>;

constexpr auto binary_decode = decode_from<encoding::base2, char>;
constexpr auto base2_decode = decode_from<encoding::base2, char>;
constexpr auto base4_decode = decode_from<encoding::base4, char>;
constexpr auto base8_decode = decode_from<encoding::base8, char>;
constexpr auto hexdec_decode = decode_from<encoding::base16, char>;
constexpr auto base16_decode = decode_from<encoding::base16, char>;
constexpr auto base32_decode = decode_from<encoding::base32, char>;
constexpr auto z_base32_decode = decode_from<encoding::z_base32, char>;
constexpr auto base64_decode = decode_from<encoding::base64, char>;
constexpr auto base64url_decode = decode_from<encoding::base64url, char>;
constexpr auto base64_no_padding_decode = decode_from<encoding::base64_no_padding, char>;

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

// template <typename Encoding, typename CharT, typename R> struct encode_to_view

#ifdef CTHASH_STDFMT_AVAILABLE
template <typename Encoding, typename R, typename CharT>
struct formatter<cthash::encode_to_view<Encoding, CharT, R>, CharT> {
	using subject_type = cthash::encode_to_view<Encoding, CharT, R>;

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		return std::ranges::begin(ctx);
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return std::ranges::copy(value, ctx.out()).out;
	}
};

#endif

} // namespace std

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_ALGORITHM_HPP
#define CTHASH_INTERNAL_ALGORITHM_HPP

#include <numeric>
#include <compare>
#include <cstddef>
#include <cstdint>

namespace cthash::internal {

template <typename It1, typename It2> constexpr auto threeway_compare_of_same_size(It1 lhs, It2 rhs, size_t length) -> std::strong_ordering {
	for (size_t i = 0; i != length; ++i) {
		if (const auto r = (*lhs++ <=> *rhs++); std::is_neq(r)) {
			return r;
		}
	}

	return std::strong_ordering::equal;
}

template <typename T, typename It1, typename It2, typename Stream> constexpr auto & push_to_stream_as(It1 f, It2 l, Stream & stream) {
	constexpr auto cast_and_shift = [](Stream * s, const auto & rhs) { (*s) << T{rhs}; return s; };
	return *std::accumulate(f, l, &stream, cast_and_shift);
}

} // namespace cthash::internal

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_HEXDEC_HPP
#define CTHASH_INTERNAL_HEXDEC_HPP

#include <array>
#include <ostream>
#include <span>
#include <type_traits>
#include <cstdint>

namespace cthash::internal {

consteval auto get_hexdec_table() noexcept {
	std::array<uint8_t, 128> result;

	auto char_to_hexdec = [](char c) {
		if (c >= '0' && c <= '9') {
			return static_cast<uint8_t>(c - '0');
		} else if (c >= 'a' && c <= 'f') {
			return static_cast<uint8_t>(c - 'a' + 10);
		} else if (c >= 'A' && c <= 'F') {
			return static_cast<uint8_t>(c - 'A' + 10);
		} else {
			return static_cast<uint8_t>(0);
		}
	};

	for (size_t i = 0; i != result.size(); ++i) {
		result[i] = char_to_hexdec(static_cast<char>(i));
	}

	return result;
}

constexpr auto hexdec_to_value_alphabet = get_hexdec_table();

template <typename CharT> constexpr auto value_to_hexdec_alphabet = std::array<CharT, 16>{CharT('0'), CharT('1'), CharT('2'), CharT('3'), CharT('4'), CharT('5'), CharT('6'), CharT('7'), CharT('8'), CharT('9'), CharT('a'), CharT('b'), CharT('c'), CharT('d'), CharT('e'), CharT('f')};

struct byte_hexdec_value {
	std::byte val;

	template <typename CharT, typename Traits> friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, byte_hexdec_value rhs) {
		return os << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val >> 4u)] << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val) & 0b1111u];
	}
};

template <size_t N, typename CharT> constexpr auto hexdec_to_binary(std::span<const CharT, N * 2> in) -> std::array<std::byte, N> {
	return [in]<size_t... Idx>(std::index_sequence<Idx...>) {
		return std::array<std::byte, N>{static_cast<std::byte>(hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2]) & 0b0111'1111u] << 4u | hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2u + 1u]) & 0b0111'1111u])...};
	}(std::make_index_sequence<N>());
}

template <typename CharT, size_t N>
requires((N - 1) % 2 == 0) // -1 because of zero terminator in literals
constexpr auto literal_hexdec_to_binary(const CharT (&in)[N]) -> std::array<std::byte, (N - 1) / 2> {
	return hexdec_to_binary<N / 2>(std::span<const char, N - 1>(in, N - 1));
}

} // namespace cthash::internal

#endif

#include <algorithm>
#include <array>
#include <format>
#include <span>
#include <string_view>
#include <compare>

namespace cthash {

// hash_value

template <size_t N> struct hash_value: std::array<std::byte, N> {
	using super = std::array<std::byte, N>;

	constexpr hash_value() noexcept: super{} { }
	explicit constexpr hash_value(super && s) noexcept: super(s) { }
	template <typename CharT> explicit constexpr hash_value(const CharT (&in)[N * 2u + 1u]) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in, N * 2u))} { }
	template <typename CharT> explicit constexpr hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in.data(), in.size()))} { }

	// comparison support
	constexpr friend bool operator==(const hash_value & lhs, const hash_value & rhs) noexcept = default;
	constexpr friend auto operator<=>(const hash_value & lhs, const hash_value & rhs) noexcept -> std::strong_ordering {
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), N);
	}

	template <typename Encoding = cthash::encoding::hexdec, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		auto hexdec_view = *this | cthash::encode_to<Encoding, CharT>;
		std::ranges::copy(hexdec_view, std::ostream_iterator<CharT, CharT>(os));
		return os;
	}

	// print to ostream support
	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const hash_value & val) {
		return val.print_into(os);
	}

	template <size_t PrefixN> constexpr auto prefix() const noexcept requires(PrefixN <= N) {
		hash_value<PrefixN> output{};
		std::ranges::copy(this->begin(), this->begin() + PrefixN, output.begin());
		return output;
	}

	template <size_t SuffixN> constexpr auto suffix() const noexcept requires(SuffixN <= N) {
		hash_value<SuffixN> output{};
		std::ranges::copy(this->end() - SuffixN, this->end(), output.begin());
		return output;
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(encoded);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(encoded.size());
		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());
		return result;
#endif
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_fixed_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
		// it's type dependendent so we can calculate the size...
		constexpr size_t size_needed = (hash_value{} | cthash::encode_to<Encoding, CharT>).size();

		auto result = cthash::fixed_string<CharT, size_needed>{nullptr};

		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());

		return result;
	}
};

template <typename CharT, size_t N> hash_value(const CharT (&)[N]) -> hash_value<(N - 1u) / 2u>;
template <typename CharT, size_t N> hash_value(std::span<const CharT, N>) -> hash_value<N / 2u>;
template <typename CharT, size_t N> hash_value(const fixed_string<CharT, N> &) -> hash_value<N / 2u>;

template <typename> struct default_encoding {
	using encoding = cthash::encoding::hexdec;
};

template <typename Tag> concept tag_with_encoding = requires() {
	typename Tag::encoding;
};

template <tag_with_encoding Tag> struct default_encoding<Tag> {
	using encoding = Tag::encoding;
};

template <typename Tag, size_t = internal::digest_bytes_length_of<Tag>> struct tagged_hash_value: hash_value<internal::digest_bytes_length_of<Tag>> {
	static constexpr size_t N = internal::digest_bytes_length_of<Tag>;

	using super = hash_value<N>;
	using super::super;
	template <typename CharT> explicit constexpr tagged_hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{in} { }

	static constexpr size_t digest_length = N;

	template <typename Encoding = default_encoding<Tag>::encoding, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		return super::template print_into<Encoding>(os);
	}

	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const tagged_hash_value & val) {
		return val.print_into(os);
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_string(const tagged_hash_value & value) {
		return to_string<Encoding, CharT>(static_cast<const super &>(value));
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_fixed_string(const tagged_hash_value & value) {
		return to_fixed_string<Encoding, CharT>(static_cast<const super &>(value));
	}
};

template <typename T> concept variable_digest_length = T::digest_length_bit == 0u;

template <size_t N, variable_digest_length Tag> struct variable_bit_length_tag: Tag {
	static constexpr size_t digest_length_bit = N;
};

template <typename T> concept convertible_to_tagged_hash_value = requires(const T & obj) {
	{ tagged_hash_value{obj} };
};

namespace literals {

	template <fixed_string Value>
	constexpr auto operator""_hash() {
		return hash_value(Value);
	}

} // namespace literals

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#if _LIBCPP_VERSION >= 170000
// libc++ will define __cpp_lib_format macro in 19.0
// https://github.com/llvm/llvm-project/issues/77773
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#ifdef CTHASH_STDFMT_AVAILABLE
template <size_t N, typename CharT>
struct formatter<cthash::hash_value<N>, CharT> {
	using subject_type = cthash::hash_value<N>;
	using default_encoding = cthash::encoding::hexdec;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <typename Tag, size_t N, typename CharT>
struct formatter<cthash::tagged_hash_value<Tag, N>, CharT> {
	using subject_type = cthash::tagged_hash_value<Tag, N>;
	using default_encoding = typename cthash::default_encoding<Tag>::encoding;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <cthash::convertible_to_tagged_hash_value Type, typename CharT> struct formatter<Type, CharT>: formatter<decltype(cthash::tagged_hash_value{std::declval<Type>()}), CharT> {
};

#endif

} // namespace std

#endif

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_CONVERT_HPP
#define CTHASH_INTERNAL_CONVERT_HPP

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#include <span>
#include <type_traits>
#include <cstddef>
#include <cstdint>
#include <cstring>

namespace cthash {

template <typename It1, typename It2, typename It3> constexpr auto byte_copy(It1 first, It2 last, It3 destination) {
	return std::transform(first, last, destination, [](byte_like auto v) { return static_cast<std::byte>(v); });
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << ((sizeof(T) - 1u - Idx) * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::little) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_le_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << static_cast<T>(Idx * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::big) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T> struct unwrap_littleendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> (Idx * 8u))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_littleendian_number(std::span<std::byte, 8>) -> unwrap_littleendian_number<uint64_t>;
unwrap_littleendian_number(std::span<std::byte, 4>) -> unwrap_littleendian_number<uint32_t>;

template <std::unsigned_integral T> struct unwrap_bigendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> ((bits - 8u) - 8u * Idx))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_bigendian_number(std::span<std::byte, 8>) -> unwrap_bigendian_number<uint64_t>;
unwrap_bigendian_number(std::span<std::byte, 4>) -> unwrap_bigendian_number<uint32_t>;

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#include <algorithm>
#include <array>
#include <span>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <typename Config> struct internal_hasher {
	static constexpr auto config = Config{};
	static constexpr size_t block_size_bytes = config.block_bits / 8u;
	static constexpr size_t digest_bytes = internal::digest_bytes_length_of<Config>;

	// internal types
	using state_value_t = std::remove_cvref_t<decltype(Config::initial_values)>;
	using state_item_t = typename state_value_t::value_type;

	using block_value_t = std::array<std::byte, block_size_bytes>;
	using block_view_t = std::span<const std::byte, block_size_bytes>;

	using staging_item_t = typename decltype(config.constants)::value_type;
	static constexpr size_t staging_size = config.constants.size();
	using staging_value_t = std::array<staging_item_t, staging_size>;
	using staging_view_t = std::span<const staging_item_t, staging_size>;

	using digest_span_t = std::span<std::byte, digest_bytes>;
	using result_t = cthash::tagged_hash_value<Config>;
	using length_t = typename Config::length_type;

	// internal state
	state_value_t hash;
	length_t total_length;

	block_value_t block;
	unsigned block_used;

	// constructors
	constexpr internal_hasher() noexcept: hash{config.initial_values}, total_length{0u}, block_used{0u} { }
	constexpr internal_hasher(const internal_hasher &) noexcept = default;
	constexpr internal_hasher(internal_hasher &&) noexcept = default;
	constexpr ~internal_hasher() noexcept = default;

	// take buffer and build staging
	template <byte_like Byte> [[gnu::always_inline]] static constexpr auto build_staging(std::span<const Byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		staging_value_t w;

		constexpr auto first_part_size = block_size_bytes / sizeof(staging_item_t);

		// fill first part with chunk
		for (int i = 0; i != int(first_part_size); ++i) {
			w[static_cast<size_t>(i)] = cast_from_bytes<staging_item_t>(chunk.subspan(static_cast<size_t>(i) * sizeof(staging_item_t)).template first<sizeof(staging_item_t)>());
		}

		// fill the rest (generify)
		for (int i = int(first_part_size); i != int(staging_size); ++i) {
			w[static_cast<size_t>(i)] = w[static_cast<size_t>(i - 16)] + config.sigma_0(w[static_cast<size_t>(i - 15)]) + w[static_cast<size_t>(i - 7)] + config.sigma_1(w[static_cast<size_t>(i - 2)]);
		}

		return w;
	}

	[[gnu::always_inline]] static constexpr auto build_staging(std::span<const std::byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		return build_staging<std::byte>(chunk);
	}

	[[gnu::always_inline]] static constexpr void rounds(staging_view_t w, state_value_t & state) noexcept {
		config.rounds(w, state);
	}

	// this implementation works only with input size aligned to bytes (not bits)
	template <byte_like T> [[gnu::always_inline]] constexpr void update_to_buffer_and_process(std::span<const T> in) noexcept {
		// if block is not used, we can build staging directly
		if (block_used) {
			const auto remaining_free_space = std::span<std::byte, block_size_bytes>(block).subspan(block_used);
			const auto to_copy = in.first(std::min(in.size(), remaining_free_space.size()));

			const auto it = byte_copy(to_copy.begin(), to_copy.end(), remaining_free_space.begin());
			total_length += to_copy.size();

			// we didn't fill the block
			if (it != remaining_free_space.end()) {
				assert(to_copy.size() == in.size());
				block_used += static_cast<unsigned>(to_copy.size());
				return;
			} else {
				block_used = 0u;
			}

			// we have block!
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// remove part we processed
			in = in.subspan(to_copy.size());
		}

		// do the work over blocks without copy
		if (not block_used) {
			while (in.size() >= block_size_bytes) {
				const auto local_block = in.template first<block_size_bytes>();
				total_length += block_size_bytes;

				const staging_value_t w = build_staging<T>(local_block);
				rounds(w, hash);

				// remove part we processed
				in = in.subspan(block_size_bytes);
			}
		}

		// remainder is put onto temporary block
		if (not in.empty()) {
			assert(block_used == 0u);
			assert(in.size() < block_size_bytes);

			// copy it to block and let it stay there
			byte_copy(in.begin(), in.end(), block.begin());
			block_used = static_cast<unsigned>(in.size());
			total_length += block_used;
		}
	}

	[[gnu::always_inline]] static constexpr bool finalize_buffer(block_value_t & block, size_t block_used) noexcept {
		assert(block_used < block.size());
		const auto free_space = std::span(block).subspan(block_used);

		auto it = free_space.data();
		*it++ = std::byte{0b1000'0000u};							   // first byte after data contains bit at MSB
		std::fill(it, (block.data() + block.size()), std::byte{0x0u}); // rest is filled with zeros

		// we don't have enough space to write length bits
		return free_space.size() < (1u + (config.length_size_bits / 8u));
	}

	[[gnu::always_inline]] static constexpr void finalize_buffer_by_writing_length(block_value_t & block, length_t total_length) noexcept {
		unwrap_bigendian_number{std::span(block).template last<sizeof(length_t)>()} = (total_length * 8u);
	}

	[[gnu::always_inline]] constexpr void finalize() noexcept {
		if (finalize_buffer(block, block_used)) {
			// we didn't have enough space, we need to process block
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// zero it out
			std::fill(block.begin(), block.end(), std::byte{0x0u});
		}

		// we either have space to write or we have zerod out block
		finalize_buffer_by_writing_length(block, total_length);

		// calculate last round
		const staging_value_t w = build_staging(block);
		rounds(w, hash);
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) == 0u)
	{
		// copy result to byte result
		constexpr size_t values_for_output = digest_bytes / sizeof(state_item_t);
		static_assert(values_for_output <= config.initial_values.size());

		for (int i = 0; i != values_for_output; ++i) {
			unwrap_bigendian_number<state_item_t>{out.subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) != 0u)
	{
		// this is only used when digest doesn't align with output buffer

		// make sure digest size is smaller than hash state
		static_assert(digest_bytes <= config.initial_values.size() * sizeof(state_item_t));

		// copy result to byte result
		std::array<std::byte, sizeof(state_item_t) * config.initial_values.size()> tmp_buffer;

		for (int i = 0; i != (int)config.initial_values.size(); ++i) {
			unwrap_bigendian_number<state_item_t>{std::span(tmp_buffer).subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}

		std::copy_n(tmp_buffer.data(), digest_bytes, out.data());
	}
};

// this is a convinience type for nicer UX...
template <typename Config> struct hasher: private internal_hasher<Config> {
	using super = internal_hasher<Config>;
	using result_t = typename super::result_t;
	using length_t = typename super::length_t;
	using digest_span_t = typename super::digest_span_t;

	constexpr hasher() noexcept: super() { }
	constexpr hasher(const hasher &) noexcept = default;
	constexpr hasher(hasher &&) noexcept = default;
	constexpr ~hasher() noexcept = default;

	// support for various input types
	constexpr hasher & update(std::span<const std::byte> input) noexcept {
		super::update_to_buffer_and_process(input);
		return *this;
	}

	template <convertible_to_byte_span T> constexpr hasher & update(const T & something) noexcept {
		using value_type = typename decltype(std::span(something))::value_type;
		super::update_to_buffer_and_process(std::span<const value_type>(something));
		return *this;
	}

	template <one_byte_char CharT> constexpr hasher & update(std::basic_string_view<CharT> in) noexcept {
		super::update_to_buffer_and_process(std::span(in.data(), in.size()));
		return *this;
	}

	template <string_literal T> constexpr hasher & update(const T & lit) noexcept {
		super::update_to_buffer_and_process(std::span(lit, std::size(lit) - 1u));
		return *this;
	}

	// TODO: any range with value convertible to byte

	// output (by reference or by value)
	constexpr void final(digest_span_t digest) noexcept {
		super::finalize();
		super::write_result_into(digest);
	}

	constexpr auto final() noexcept {
		result_t output;
		this->final(output);
		return output;
	}

	constexpr length_t size() const noexcept {
		return super::total_length;
	}
};

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_CONVERT_HPP
#define CTHASH_INTERNAL_CONVERT_HPP

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#include <span>
#include <type_traits>
#include <cstddef>
#include <cstdint>
#include <cstring>

namespace cthash {

template <typename It1, typename It2, typename It3> constexpr auto byte_copy(It1 first, It2 last, It3 destination) {
	return std::transform(first, last, destination, [](byte_like auto v) { return static_cast<std::byte>(v); });
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << ((sizeof(T) - 1u - Idx) * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::little) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_le_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << static_cast<T>(Idx * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::big) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T> struct unwrap_littleendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> (Idx * 8u))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_littleendian_number(std::span<std::byte, 8>) -> unwrap_littleendian_number<uint64_t>;
unwrap_littleendian_number(std::span<std::byte, 4>) -> unwrap_littleendian_number<uint32_t>;

template <std::unsigned_integral T> struct unwrap_bigendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> ((bits - 8u) - 8u * Idx))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_bigendian_number(std::span<std::byte, 8>) -> unwrap_bigendian_number<uint64_t>;
unwrap_bigendian_number(std::span<std::byte, 4>) -> unwrap_bigendian_number<uint32_t>;

} // namespace cthash

#endif

#ifndef CTHASH_SIMPLE_HPP
#define CTHASH_SIMPLE_HPP

#include <utility>

namespace cthash {

template <typename Hasher, typename In, typename... Args> concept hasher_like = requires(Hasher & h, const In & in, Args &&... args) //
{
	{ Hasher{std::forward<Args>(args)...} };
	{ h.update(in) } -> std::same_as<Hasher &>;
	{ h.final() };
};

template <typename Hasher, typename In> concept direct_hasher = requires(Hasher & h, const In & in) //
{
	{ h.update_and_final(in) };
};

template <typename Hasher, typename T, typename... Args>
requires hasher_like<Hasher, T, Args...>
constexpr auto simple(const T & value, Args &&... args) noexcept {
	if constexpr (direct_hasher<Hasher, T>) {
		return Hasher{std::forward<Args>(args)...}.update_and_final(value);
	} else {
		return Hasher{std::forward<Args>(args)...}.update(value).final();
	}
}

} // namespace cthash

#endif

#ifndef CTHASH_VALUE_HPP
#define CTHASH_VALUE_HPP

#ifndef CTHASH_FIXED_STRING_HPP
#define CTHASH_FIXED_STRING_HPP

#include <algorithm>
#include <span>
#include <string_view>

namespace cthash {

template <typename CharT, size_t N> struct fixed_string: std::array<CharT, N> {
	using super = std::array<CharT, N>;

	consteval static auto from_string_literal(const CharT (&in)[N + 1]) -> std::array<CharT, N> {
		std::array<CharT, N> out;
		std::copy_n(in, N, out.data());
		return out;
	}

	explicit constexpr fixed_string(std::nullptr_t) noexcept: super{} { }

	consteval fixed_string(const CharT (&in)[N + 1]) noexcept: super{from_string_literal(in)} { }

	using super::data;
	using super::size;

	constexpr operator std::span<const CharT, N>() const noexcept {
		return std::span<const CharT, N>(data(), size());
	}

	constexpr operator std::span<const CharT>() const noexcept {
		return std::span<const CharT>(data(), size());
	}

	constexpr operator std::basic_string_view<CharT>() const noexcept {
		return std::basic_string_view<CharT>(data(), size());
	}

	constexpr friend bool operator==(const fixed_string &, const fixed_string &) noexcept = default;
	constexpr friend bool operator==(const fixed_string & lhs, std::basic_string_view<CharT> rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == rhs;
	}
	constexpr friend bool operator==(const fixed_string & lhs, const CharT * rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == std::basic_string_view<CharT>{rhs};
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N - 1>;

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_BASE_HPP
#define CTHASH_ENCODING_BASE_HPP

#ifndef CTHASH_ENCODING_CHUNK_OF_BITS_HPP
#define CTHASH_ENCODING_CHUNK_OF_BITS_HPP

#ifndef CTHASH_ENCODING_BIT_BUFFER_HPP
#define CTHASH_ENCODING_BIT_BUFFER_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <bit>
#include <iostream>
#include <numeric>
#include <ranges>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct select_bit_integer;

template <size_t Bits> requires(Bits <= 8) struct select_bit_integer<Bits> {
	using type = uint8_t;
};

template <size_t Bits> requires(Bits > 8 && Bits <= 16) struct select_bit_integer<Bits> {
	using type = uint16_t;
};

template <size_t Bits> requires(Bits > 16 && Bits <= 32) struct select_bit_integer<Bits> {
	using type = uint32_t;
};

template <size_t Bits> requires(Bits > 32 && Bits <= 64) struct select_bit_integer<Bits> {
	using type = uint64_t;
};

template <size_t Bits> using select_bit_integer_t = select_bit_integer<Bits>::type;

template <size_t V> requires(std::popcount(V) == 1u) constexpr auto log2_of_power_of_2 = static_cast<size_t>(std::countr_zero(V));

template <size_t Bits> constexpr auto mask = static_cast<select_bit_integer_t<Bits>>((static_cast<select_bit_integer_t<Bits>>(1u) << Bits) - 1u);

template <size_t Capacity> class basic_bit_buffer {
public:
	static constexpr auto capacity = std::integral_constant<size_t, Capacity>{};
	using storage_type = select_bit_integer_t<capacity()>;
	using size_type = select_bit_integer_t<log2_of_power_of_2<std::bit_ceil(capacity())>>;

public:
	storage_type buffer{0};
	size_type bits_available{0};

public:
	template <size_t Bits> static constexpr auto mask = static_cast<storage_type>((static_cast<storage_type>(1u) << Bits) - 1u);

	constexpr friend bool operator==(const basic_bit_buffer & lhs, const basic_bit_buffer & rhs) noexcept = default;

	constexpr size_type size() const noexcept {
		return bits_available;
	}

	constexpr size_type unused_size() const noexcept {
		return capacity() - bits_available;
	}

	constexpr bool empty() const noexcept {
		return bits_available == 0u;
	}

	constexpr bool full() const noexcept {
		return bits_available == capacity();
	}

	template <size_t Bits> constexpr void push(select_bit_integer_t<Bits> in) noexcept requires(Bits <= capacity()) {
		assert(size() <= capacity() - Bits);
		buffer = static_cast<storage_type>(buffer << Bits) | static_cast<storage_type>(in);
		bits_available += static_cast<size_type>(Bits);
	}
	constexpr void push_empty_bits(size_t count) noexcept {
		buffer = static_cast<storage_type>(buffer << count);
		bits_available += static_cast<unsigned char>(count);
	}

	template <size_t Bits> constexpr void pop() noexcept requires(Bits <= capacity()) {
		assert(size() >= Bits);
		bits_available -= static_cast<size_type>(Bits);
	}

	template <size_t Bits> constexpr auto front() const noexcept -> select_bit_integer_t<Bits> requires(Bits <= capacity()) {
		using output_type = select_bit_integer_t<Bits>;
		assert(size() >= static_cast<size_type>(Bits));
		return static_cast<output_type>((buffer >> (bits_available - Bits))) & mask<Bits>;
	}
};

constexpr size_t calculate_padding_bit_count(size_t number_of_bits_in_buffer, size_t output_size, size_t input_size) {
	size_t n = number_of_bits_in_buffer;
	size_t padding_bits = 0u;

	while (n != 0u) {
		padding_bits += input_size;
		n += input_size;

		while (n >= output_size) {
			n = n - output_size;
		}
	}

	return padding_bits;
}

template <size_t OutBits, size_t InBits = 8u> class bit_buffer: protected basic_bit_buffer<std::lcm(OutBits, InBits)> {
	using super = basic_bit_buffer<std::lcm(OutBits, InBits)>;

public:
	constexpr bit_buffer() noexcept = default;

	using typename super::size_type;
	static constexpr auto out_bits = std::integral_constant<size_type, OutBits>{};
	static constexpr auto in_bits = std::integral_constant<size_type, InBits>{};

	using out_type = select_bit_integer_t<OutBits>;
	using in_type = select_bit_integer_t<InBits>;

	using super::capacity;
	static constexpr auto in_capacity = std::integral_constant<size_type, (capacity() / in_bits())>{};
	static constexpr auto out_capacity = std::integral_constant<size_type, (capacity() / out_bits())>{};

	static constexpr auto aligned = std::bool_constant<capacity() == in_capacity()>{};

	constexpr void push(in_type in) noexcept {
		super::template push<in_bits>(in);
	}

	constexpr void push_empty() noexcept {
		this->push(in_type{0u});
	}

	constexpr size_type push_zeros_to_align() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_to_align() noexcept requires(!aligned()) {
		if (empty()) {
			return 0u;
		}

		assert(out_bits > super::size());
		const size_type missing_bits = static_cast<size_type>(out_bits - super::size());
		super::push_empty_bits(missing_bits);
		return missing_bits;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(!aligned()) {
		const size_type usable_bits = super::size();
		const size_type missing_bits = static_cast<size_type>(calculate_padding_bit_count(super::size(), out_bits, in_bits));
		super::push_empty_bits(missing_bits);
		return usable_bits;
	}

	constexpr void pop() noexcept {
		super::template pop<out_bits>();
	}

	constexpr auto front() const noexcept -> out_type {
		return super::template front<out_bits>();
	}

	constexpr size_type size() const noexcept {
		return static_cast<size_type>(super::size() / out_bits);
	}

	constexpr size_type unused_size() const noexcept {
		return static_cast<size_type>(super::unused_size() / in_bits);
	}

	using super::empty;
	using super::full;

	constexpr bool has_bits_for_pop() const noexcept {
		return super::size() >= out_bits;
	}

	constexpr bool has_capacity_for_push() const noexcept {
		return super::size() <= (capacity() - in_bits);
	}
};

} // namespace cthash

#endif

#include <iostream>
#include <ranges>

namespace cthash {

template <typename Buffer> struct buffer_result_type;

template <typename Buffer> requires(Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	static constexpr Buffer::size_type missing_bits = {0u};

	constexpr bool is_padding() const noexcept {
		return false;
	}
};

template <typename Buffer> requires(!Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	typename Buffer::size_type missing_bits;

	constexpr bool is_padding() const noexcept {
		return missing_bits == Buffer::out_bits;
	}
};

template <typename Buffer, bool AllowPadding> struct buffer_with_missing_bits;

template <typename Buffer, bool AllowPadding> requires(Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};

	struct result_type {
		typename Buffer::out_type value;
		static constexpr Buffer::size_type missing_bits = {0u};

		constexpr bool is_padding() const noexcept {
			return false;
		}
	};

	static constexpr bool aligned = Buffer::aligned();

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		return result_type{buffer.front()};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		while (!buffer.has_bits_for_pop() && (it != end)) {
			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <typename Buffer, bool AllowPadding> requires(!Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};
	Buffer::size_type missing_bits{0};

	static constexpr bool aligned = Buffer::aligned();

	struct result_type {
		typename Buffer::out_type value;
		typename Buffer::size_type missing_bits;

		constexpr bool is_padding() const noexcept {
			return missing_bits == Buffer::out_bits;
		}
	};

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		assert(Buffer::out_bits >= missing_bits);
		return result_type{buffer.front(), missing_bits};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	constexpr void pad_buffer() noexcept requires(AllowPadding) {
		// full multi-chunk padding (for baseN encodings)
		missing_bits = (Buffer::out_bits - buffer.push_zeros_for_padding());
	}

	constexpr void pad_buffer() noexcept requires(!AllowPadding) {
		// only add enough zero to finish current output chunk
		missing_bits = buffer.push_zeros_to_align();
	}

	constexpr void saturate_missing_bits() noexcept requires(AllowPadding) {
		if (missing_bits) {
			missing_bits = Buffer::out_bits;
		}
		// missing_bits = static_cast<buffer_size_t>((unsigned)(bool)missing_bits * output_value_bit_size);
	}

	constexpr void saturate_missing_bits() noexcept requires(!AllowPadding) {
		// do nothing :)
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		for (;;) {
			if (it == end) {
				if (buffer.has_bits_for_pop()) {
					// if this is second pass after padding we can mark all bits as missing
					saturate_missing_bits();
				} else {
					// fill remainder of buffer with zeros
					pad_buffer();
				}

				return;
			}

			if (buffer.has_bits_for_pop()) {
				return;
			}

			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <bool Value> struct conditional;

template <> struct conditional<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional<false> {
	template <typename, typename T> using type = T;
};

template <bool Const, typename T> using maybe_const = typename conditional<Const>::template type<const T, T>;

template <typename T> concept integral_like = std::integral<T> || std::same_as<std::byte, T>;

template <size_t Bits, bool AllowPadding, std::ranges::input_range Input> requires integral_like<std::ranges::range_value_t<Input>> struct chunk_of_bits_view {
	using input_value_type = std::ranges::range_value_t<Input>;

	static constexpr size_t output_value_bit_size = Bits;
	static constexpr size_t input_value_bit_size = sizeof(input_value_type) * 8u;
	using buffer_t = cthash::bit_buffer<output_value_bit_size, input_value_bit_size>;
	using buffer_size_t = buffer_t::size_type;
	Input input;

	static constexpr bool aligned = buffer_t::aligned;

	struct sentinel { };

	template <bool Const> struct iterator {
		using parent = maybe_const<Const, Input>;
		using storage_type = buffer_with_missing_bits<buffer_t, AllowPadding>;
		using value_type = storage_type::result_type;
		using difference_type = intptr_t;

		std::ranges::iterator_t<parent> it;
		[[no_unique_address]] std::ranges::sentinel_t<parent> end;

		storage_type buffer{};

		constexpr iterator(parent & p) noexcept: it{std::ranges::begin(p)}, end{std::ranges::end(p)} {
			// initialize
			buffer.feed_buffer(it, end);
		}

		iterator(const iterator &) = default;
		iterator(iterator &&) = default;

		iterator & operator=(const iterator &) = default;
		iterator & operator=(iterator &&) = default;

		constexpr iterator & operator++() noexcept {
			buffer.pop();
			buffer.feed_buffer(it, end);
			return *this;
		}

		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			this->operator++();
			return copy;
		}

		constexpr auto operator*() const noexcept {
			return buffer.front();
		}

		constexpr friend bool operator==(const iterator & lhs, const iterator & rhs) noexcept = default;

		constexpr friend bool operator==(const iterator & self, sentinel) noexcept {
			return self.buffer.empty();
		}
	};

	static_assert(std::input_iterator<iterator<true>>);
	static_assert(std::input_iterator<iterator<false>>);
	static_assert(std::sentinel_for<sentinel, iterator<true>>);
	static_assert(std::sentinel_for<sentinel, iterator<false>>);

	constexpr chunk_of_bits_view(Input _input) noexcept: input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input};
	}

	constexpr auto end() const noexcept {
		return sentinel{};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && AllowPadding) {
		// calculate with blocks
		return ((std::ranges::size(input) + (buffer_t::in_capacity() - 1u)) / buffer_t::in_capacity()) * buffer_t::out_capacity();
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && !AllowPadding) {
		// calculate with bits
		const size_t bit_size_of_input = std::ranges::size(input) * input_value_bit_size;
		return (bit_size_of_input + (output_value_bit_size - 1u)) / output_value_bit_size;
	}
};

template <size_t Bits, bool AllowPadding> struct chunk_of_bits_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, chunk_of_bits_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) {
		return chunk_of_bits_view<Bits, AllowPadding, R>(std::forward<R>(input));
	}
};

template <size_t Bits, bool AllowPadding = false> constexpr auto chunk_of_bits = chunk_of_bits_action<Bits, AllowPadding>{};

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#include <bit>

namespace cthash {

template <typename Encoding> struct encoding_properties {
	static constexpr size_t size = std::size(Encoding::alphabet) - 1u;
	static_assert(std::popcount(size) == 1u, "Size of encoding's alphabet must be power-of-two");

	static constexpr size_t bits = std::countr_zero(size);

	static constexpr bool has_padding = padded_encoding<Encoding>;

	static constexpr char padding = [] {
		if constexpr (has_padding) {
			return Encoding::padding;
		} else {
			return '\0';
		}
	}();
};

template <typename Encoding, typename CharT, typename R> struct encode_to_view {
	using properties = encoding_properties<Encoding>;
	using chunk_view = cthash::chunk_of_bits_view<properties::bits, properties::has_padding, R>;

	struct sentinel {
		[[no_unique_address]] chunk_view::sentinel end;
	};

	template <bool Const> struct iterator {
		using difference_type = intptr_t;
		using value_type = CharT;

		chunk_view::template iterator<Const> it;

		constexpr iterator & operator++() noexcept {
			++it;
			return *this;
		}
		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			++it;
			return copy;
		}

		constexpr value_type operator*() const noexcept {
			const auto tmp = *it;
			if constexpr (!chunk_view::aligned) {
				// TODO: do without condition
				if (tmp.is_padding()) {
					return properties::padding;
				}
			}
			return static_cast<value_type>(Encoding::alphabet[static_cast<unsigned>(tmp.value)]);
		}

		constexpr friend bool operator==(const iterator &, const iterator &) noexcept = default;

		constexpr friend bool operator==(const iterator & lhs, const sentinel & rhs) noexcept {
			return lhs.it == rhs.end;
		}
	};

	chunk_view input;

	constexpr encode_to_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}

	constexpr auto to_string() const requires(std::ranges::sized_range<R>) {
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(*this);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(size());
		auto [i, o] = std::ranges::copy(begin(), end(), result.begin());
		assert(i == result.end());
		assert(o == result.end());
		return result;
#endif
	}

	constexpr friend std::basic_ostream<CharT> & operator<<(std::basic_ostream<CharT> & out, encode_to_view in) {
		std::ranges::copy(in.begin(), in.end(), std::ostream_iterator<CharT, CharT>(out));
		return out;
	}
};

template <typename Encoding, typename ValueT, typename R> struct decode_from_view {
	R input;

	template <bool Const> struct iterator { };
	struct sentinel { };

	constexpr decode_from_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}
};

template <typename Encoding, typename CharT = char> struct encode_to_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, encode_to_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return encode_to_view<Encoding, CharT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename ValueT = unsigned char> struct decode_from_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, decode_from_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return decode_from_view<Encoding, ValueT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename CharT = char> constexpr auto encode_to = encode_to_action<Encoding, CharT>{};
template <typename Encoding, typename ValueT = unsigned char> constexpr auto decode_from = decode_from_action<Encoding, ValueT>{};

constexpr auto binary_encode = encode_to<encoding::base2, char>;
constexpr auto base2_encode = encode_to<encoding::base2, char>;
constexpr auto base4_encode = encode_to<encoding::base4, char>;
constexpr auto base8_encode = encode_to<encoding::base8, char>;
constexpr auto octal_encode = encode_to<encoding::base8, char>;
constexpr auto hexdec_encode = encode_to<encoding::base16, char>;
constexpr auto hexdec_uppercase_encode = encode_to<encoding::base16_uppercase, char>;
constexpr auto base16_encode = encode_to<encoding::base16, char>;
constexpr auto base32_encode = encode_to<encoding::base32, char>;
constexpr auto base32_no_padding_encode = encode_to<encoding::base32_no_padding, char>;
constexpr auto z_base32_encode = encode_to<encoding::z_base32, char>;
constexpr auto base64_encode = encode_to<encoding::base64, char>;
constexpr auto base64url_encode = encode_to<encoding::base64url, char>;
constexpr auto base64_no_padding_encode = encode_to<encoding::base64_no_padding, char>;

constexpr auto binary_decode = decode_from<encoding::base2, char>;
constexpr auto base2_decode = decode_from<encoding::base2, char>;
constexpr auto base4_decode = decode_from<encoding::base4, char>;
constexpr auto base8_decode = decode_from<encoding::base8, char>;
constexpr auto hexdec_decode = decode_from<encoding::base16, char>;
constexpr auto base16_decode = decode_from<encoding::base16, char>;
constexpr auto base32_decode = decode_from<encoding::base32, char>;
constexpr auto z_base32_decode = decode_from<encoding::z_base32, char>;
constexpr auto base64_decode = decode_from<encoding::base64, char>;
constexpr auto base64url_decode = decode_from<encoding::base64url, char>;
constexpr auto base64_no_padding_decode = decode_from<encoding::base64_no_padding, char>;

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

// template <typename Encoding, typename CharT, typename R> struct encode_to_view

#ifdef CTHASH_STDFMT_AVAILABLE
template <typename Encoding, typename R, typename CharT>
struct formatter<cthash::encode_to_view<Encoding, CharT, R>, CharT> {
	using subject_type = cthash::encode_to_view<Encoding, CharT, R>;

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		return std::ranges::begin(ctx);
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return std::ranges::copy(value, ctx.out()).out;
	}
};

#endif

} // namespace std

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_ALGORITHM_HPP
#define CTHASH_INTERNAL_ALGORITHM_HPP

#include <numeric>
#include <compare>
#include <cstddef>
#include <cstdint>

namespace cthash::internal {

template <typename It1, typename It2> constexpr auto threeway_compare_of_same_size(It1 lhs, It2 rhs, size_t length) -> std::strong_ordering {
	for (size_t i = 0; i != length; ++i) {
		if (const auto r = (*lhs++ <=> *rhs++); std::is_neq(r)) {
			return r;
		}
	}

	return std::strong_ordering::equal;
}

template <typename T, typename It1, typename It2, typename Stream> constexpr auto & push_to_stream_as(It1 f, It2 l, Stream & stream) {
	constexpr auto cast_and_shift = [](Stream * s, const auto & rhs) { (*s) << T{rhs}; return s; };
	return *std::accumulate(f, l, &stream, cast_and_shift);
}

} // namespace cthash::internal

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_HEXDEC_HPP
#define CTHASH_INTERNAL_HEXDEC_HPP

#include <array>
#include <ostream>
#include <span>
#include <type_traits>
#include <cstdint>

namespace cthash::internal {

consteval auto get_hexdec_table() noexcept {
	std::array<uint8_t, 128> result;

	auto char_to_hexdec = [](char c) {
		if (c >= '0' && c <= '9') {
			return static_cast<uint8_t>(c - '0');
		} else if (c >= 'a' && c <= 'f') {
			return static_cast<uint8_t>(c - 'a' + 10);
		} else if (c >= 'A' && c <= 'F') {
			return static_cast<uint8_t>(c - 'A' + 10);
		} else {
			return static_cast<uint8_t>(0);
		}
	};

	for (size_t i = 0; i != result.size(); ++i) {
		result[i] = char_to_hexdec(static_cast<char>(i));
	}

	return result;
}

constexpr auto hexdec_to_value_alphabet = get_hexdec_table();

template <typename CharT> constexpr auto value_to_hexdec_alphabet = std::array<CharT, 16>{CharT('0'), CharT('1'), CharT('2'), CharT('3'), CharT('4'), CharT('5'), CharT('6'), CharT('7'), CharT('8'), CharT('9'), CharT('a'), CharT('b'), CharT('c'), CharT('d'), CharT('e'), CharT('f')};

struct byte_hexdec_value {
	std::byte val;

	template <typename CharT, typename Traits> friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, byte_hexdec_value rhs) {
		return os << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val >> 4u)] << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val) & 0b1111u];
	}
};

template <size_t N, typename CharT> constexpr auto hexdec_to_binary(std::span<const CharT, N * 2> in) -> std::array<std::byte, N> {
	return [in]<size_t... Idx>(std::index_sequence<Idx...>) {
		return std::array<std::byte, N>{static_cast<std::byte>(hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2]) & 0b0111'1111u] << 4u | hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2u + 1u]) & 0b0111'1111u])...};
	}(std::make_index_sequence<N>());
}

template <typename CharT, size_t N>
requires((N - 1) % 2 == 0) // -1 because of zero terminator in literals
constexpr auto literal_hexdec_to_binary(const CharT (&in)[N]) -> std::array<std::byte, (N - 1) / 2> {
	return hexdec_to_binary<N / 2>(std::span<const char, N - 1>(in, N - 1));
}

} // namespace cthash::internal

#endif

#include <algorithm>
#include <array>
#include <format>
#include <span>
#include <string_view>
#include <compare>

namespace cthash {

// hash_value

template <size_t N> struct hash_value: std::array<std::byte, N> {
	using super = std::array<std::byte, N>;

	constexpr hash_value() noexcept: super{} { }
	explicit constexpr hash_value(super && s) noexcept: super(s) { }
	template <typename CharT> explicit constexpr hash_value(const CharT (&in)[N * 2u + 1u]) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in, N * 2u))} { }
	template <typename CharT> explicit constexpr hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in.data(), in.size()))} { }

	// comparison support
	constexpr friend bool operator==(const hash_value & lhs, const hash_value & rhs) noexcept = default;
	constexpr friend auto operator<=>(const hash_value & lhs, const hash_value & rhs) noexcept -> std::strong_ordering {
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), N);
	}

	template <typename Encoding = cthash::encoding::hexdec, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		auto hexdec_view = *this | cthash::encode_to<Encoding, CharT>;
		std::ranges::copy(hexdec_view, std::ostream_iterator<CharT, CharT>(os));
		return os;
	}

	// print to ostream support
	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const hash_value & val) {
		return val.print_into(os);
	}

	template <size_t PrefixN> constexpr auto prefix() const noexcept requires(PrefixN <= N) {
		hash_value<PrefixN> output{};
		std::ranges::copy(this->begin(), this->begin() + PrefixN, output.begin());
		return output;
	}

	template <size_t SuffixN> constexpr auto suffix() const noexcept requires(SuffixN <= N) {
		hash_value<SuffixN> output{};
		std::ranges::copy(this->end() - SuffixN, this->end(), output.begin());
		return output;
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(encoded);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(encoded.size());
		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());
		return result;
#endif
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_fixed_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
		// it's type dependendent so we can calculate the size...
		constexpr size_t size_needed = (hash_value{} | cthash::encode_to<Encoding, CharT>).size();

		auto result = cthash::fixed_string<CharT, size_needed>{nullptr};

		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());

		return result;
	}
};

template <typename CharT, size_t N> hash_value(const CharT (&)[N]) -> hash_value<(N - 1u) / 2u>;
template <typename CharT, size_t N> hash_value(std::span<const CharT, N>) -> hash_value<N / 2u>;
template <typename CharT, size_t N> hash_value(const fixed_string<CharT, N> &) -> hash_value<N / 2u>;

template <typename> struct default_encoding {
	using encoding = cthash::encoding::hexdec;
};

template <typename Tag> concept tag_with_encoding = requires() {
	typename Tag::encoding;
};

template <tag_with_encoding Tag> struct default_encoding<Tag> {
	using encoding = Tag::encoding;
};

template <typename Tag, size_t = internal::digest_bytes_length_of<Tag>> struct tagged_hash_value: hash_value<internal::digest_bytes_length_of<Tag>> {
	static constexpr size_t N = internal::digest_bytes_length_of<Tag>;

	using super = hash_value<N>;
	using super::super;
	template <typename CharT> explicit constexpr tagged_hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{in} { }

	static constexpr size_t digest_length = N;

	template <typename Encoding = default_encoding<Tag>::encoding, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		return super::template print_into<Encoding>(os);
	}

	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const tagged_hash_value & val) {
		return val.print_into(os);
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_string(const tagged_hash_value & value) {
		return to_string<Encoding, CharT>(static_cast<const super &>(value));
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_fixed_string(const tagged_hash_value & value) {
		return to_fixed_string<Encoding, CharT>(static_cast<const super &>(value));
	}
};

template <typename T> concept variable_digest_length = T::digest_length_bit == 0u;

template <size_t N, variable_digest_length Tag> struct variable_bit_length_tag: Tag {
	static constexpr size_t digest_length_bit = N;
};

template <typename T> concept convertible_to_tagged_hash_value = requires(const T & obj) {
	{ tagged_hash_value{obj} };
};

namespace literals {

	template <fixed_string Value>
	constexpr auto operator""_hash() {
		return hash_value(Value);
	}

} // namespace literals

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#if _LIBCPP_VERSION >= 170000
// libc++ will define __cpp_lib_format macro in 19.0
// https://github.com/llvm/llvm-project/issues/77773
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#ifdef CTHASH_STDFMT_AVAILABLE
template <size_t N, typename CharT>
struct formatter<cthash::hash_value<N>, CharT> {
	using subject_type = cthash::hash_value<N>;
	using default_encoding = cthash::encoding::hexdec;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <typename Tag, size_t N, typename CharT>
struct formatter<cthash::tagged_hash_value<Tag, N>, CharT> {
	using subject_type = cthash::tagged_hash_value<Tag, N>;
	using default_encoding = typename cthash::default_encoding<Tag>::encoding;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <cthash::convertible_to_tagged_hash_value Type, typename CharT> struct formatter<Type, CharT>: formatter<decltype(cthash::tagged_hash_value{std::declval<Type>()}), CharT> {
};

#endif

} // namespace std

#endif

#include <cstdint>

namespace cthash {

template <typename T, typename Y> concept castable_to = requires(T val) { {static_cast<Y>(val)} -> std::same_as<Y>; };

template <size_t N> struct keccak_suffix {
	unsigned bits;
	std::array<std::byte, N> values;

	constexpr keccak_suffix(unsigned b, castable_to<std::byte> auto... v) noexcept: bits{b}, values{static_cast<std::byte>(v)...} { }
};

template <castable_to<std::byte>... Ts> keccak_suffix(unsigned, Ts...) -> keccak_suffix<sizeof...(Ts)>;

template <typename T> struct identify;

template <typename T, byte_like Byte> constexpr auto convert_prefix_into_aligned(std::span<const Byte> input, unsigned pos) noexcept -> std::array<std::byte, sizeof(T)> {
	assert(input.size() <= sizeof(T));
	assert(pos <= sizeof(T));
	assert((input.size() + pos) <= sizeof(T));

	std::array<std::byte, sizeof(T)> buffer{};

	std::fill(buffer.begin(), buffer.end(), std::byte{0});
	std::transform(input.data(), input.data() + input.size(), buffer.data() + pos, [](auto v) { return static_cast<std::byte>(v); });

	return buffer;
}

template <typename T, byte_like Byte> constexpr auto convert_prefix_into_value(std::span<const Byte> input, unsigned pos) noexcept -> uint64_t {
	const auto tmp = convert_prefix_into_aligned<T, Byte>(input, pos);
	return cast_from_le_bytes<T>(std::span<const std::byte, 8>(tmp));
}

template <typename Config> struct basic_keccak_hasher {
	static_assert(Config::digest_length_bit % 8u == 0u);
	static_assert(Config::rate_bit % 8u == 0u);
	static_assert(Config::capacity_bit % 8u == 0u);

	static_assert((Config::rate_bit + Config::capacity_bit) == 1600u, "Only Keccak 1600 is implemented");

	static constexpr size_t digest_length = Config::digest_length_bit / 8u;
	static constexpr size_t rate = Config::rate_bit / 8u;
	static constexpr size_t capacity = Config::capacity_bit / 8u;

	using result_t = cthash::tagged_hash_value<Config>;
	using digest_span_t = std::span<std::byte, digest_length>;

	keccak::state_1600 internal_state{};
	uint8_t position{0u};

	constexpr basic_keccak_hasher() noexcept {
		std::fill(internal_state.begin(), internal_state.end(), uint64_t{0});
	}

	template <byte_like T> constexpr size_t xor_overwrite_block(std::span<const T> input) noexcept {
		using value_t = keccak::state_1600::value_type;

		if ((std::is_constant_evaluated() | (std::endian::native != std::endian::little))) {
			assert((size_t(position) + input.size()) <= rate);

			// unaligned prefix (by copying from left to right it should be little endian)
			if (position % sizeof(value_t) != 0u) {
				// xor unaligned value and move to aligned if possible
				const size_t prefix_size = std::min(input.size(), sizeof(value_t) - (position % sizeof(value_t)));
				internal_state[position / sizeof(uint64_t)] ^= convert_prefix_into_value<value_t>(input.first(prefix_size), static_cast<unsigned>(position % sizeof(value_t)));
				position += static_cast<uint8_t>(prefix_size);
				input = input.subspan(prefix_size);
			}

			// aligned blocks
			while (input.size() >= sizeof(value_t)) {
				// xor aligned value and move to next
				internal_state[position / sizeof(value_t)] ^= cast_from_le_bytes<value_t>(input.template first<sizeof(value_t)>());
				position += static_cast<uint8_t>(sizeof(value_t));
				input = input.subspan(sizeof(value_t));
			}

			// unaligned suffix
			if (not input.empty()) {
				// xor and finish
				internal_state[position / sizeof(value_t)] ^= convert_prefix_into_value<value_t>(input, 0u);
				position += static_cast<uint8_t>(input.size());
			}

			return position;
		} else {
			const auto buffer = std::as_writable_bytes(std::span<uint64_t>(internal_state));
			const auto remaining = buffer.subspan(position);
			const auto place = remaining.first(std::min(input.size(), remaining.size()));

			std::transform(place.data(), place.data() + place.size(), input.data(), place.data(), [](std::byte lhs, auto rhs) { return lhs ^ static_cast<std::byte>(rhs); });

			position += static_cast<uint8_t>(place.size());
			return position;
		}
	}

	template <byte_like T> constexpr auto update(std::span<const T> input) noexcept {
		assert(position < rate);
		const size_t remaining_in_buffer = rate - position;

		if (remaining_in_buffer > input.size()) {
			// xor overwrite as much as we can, and that's all
			xor_overwrite_block(input);
			assert(position < rate);
			return;
		}

		// finish block and call keccak :)
		const auto first_part = input.first(remaining_in_buffer);
		input = input.subspan(remaining_in_buffer);
		xor_overwrite_block(first_part);
		assert(position == rate);
		keccak_f(internal_state);
		position = 0u;

		// for each full block we can absorb directly
		while (input.size() >= rate) {
			const auto block = input.template first<rate>();
			input = input.subspan(rate);
			assert(position == 0u);
			xor_overwrite_block<T>(block);
			keccak_f(internal_state);
			position = 0u;
		}

		// xor overwrite internal state with current remainder, and set position to end of it
		if (not input.empty()) {
			assert(position == 0u);
			xor_overwrite_block(input);
			assert(position < rate);
		}
	}

	// pad the message
	constexpr void xor_padding_block() noexcept {
		assert(position < rate);

		constexpr const auto & suffix = Config::suffix;
		constexpr std::byte suffix_and_start_of_padding = (suffix.values[0] | (std::byte{0b0000'0001u} << suffix.bits));

		internal_state[position / sizeof(uint64_t)] ^= uint64_t(suffix_and_start_of_padding) << ((position % sizeof(uint64_t)) * 8u);
		internal_state[(rate - 1u) / sizeof(uint64_t)] ^= 0x8000000000000000ull; // last bit
	}

	constexpr void final_absorb() noexcept {
		xor_padding_block();
		keccak_f(internal_state);
	}

	// get resulting hash
	constexpr void squeeze(std::span<std::byte> output) noexcept {
		using value_t = keccak::state_1600::value_type;

		static_assert((rate % sizeof(value_t)) == 0u);
		auto r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));

		// aligned results will be processed here...
		while ((output.size() >= sizeof(value_t))) {
			// if we ran out of `rate` part, we need to squeeze another block
			if (r.empty()) {
				keccak_f(internal_state);
				r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));
			}

			// look at current to process
			const value_t current = r.front();
			const auto part = output.first<sizeof(value_t)>();

			// convert
			unwrap_littleendian_number<value_t>{part} = current;

			// move to next
			r = r.subspan(1u);
			output = output.subspan(sizeof(value_t));
		}

		// unaligned result is here
		if (!output.empty()) {
			// if we ran out of `rate` part, we need to squeeze another block
			if (r.empty()) {
				keccak_f(internal_state);
				r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));
			}

			const value_t current = r.front();

			// convert
			std::array<std::byte, sizeof(value_t)> tmp;
			unwrap_littleendian_number<value_t>{tmp} = current;
			assert(tmp.size() > output.size());
			std::copy_n(tmp.data(), output.size(), output.data());
		}
	}

	constexpr void squeeze(digest_span_t output_fixed) noexcept
		requires((digest_length < rate) && digest_length != 0u)
	{
		auto output = std::span<std::byte>(output_fixed);

		// we don't need to squeeze anything
		using value_t = keccak::state_1600::value_type;

		static_assert((rate % sizeof(value_t)) == 0u);
		auto r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));

		// aligned results will be processed here...
		while ((output.size() >= sizeof(value_t))) {
			assert(!r.empty());
			// look at current to process
			const value_t current = r.front();
			const auto part = output.template first<sizeof(value_t)>();

			// convert
			unwrap_littleendian_number<value_t>{part} = current;

			// move to next
			r = r.subspan(1u);
			output = output.subspan(sizeof(value_t));
		}

		if constexpr ((output_fixed.size() % sizeof(value_t)) != 0u) {
			// unaligned result is here
			assert(!output.empty());
			assert(!r.empty());

			const value_t current = r.front();

			// convert
			std::array<std::byte, sizeof(value_t)> tmp;
			unwrap_littleendian_number<value_t>{tmp} = current;
			assert(tmp.size() > output.size());
			std::copy_n(tmp.data(), output.size(), output.data());
		}
	}

	constexpr void final(digest_span_t digest) noexcept
		requires(digest_length != 0u)
	{
		final_absorb();
		squeeze(digest);
	}

	constexpr result_t final() noexcept
		requires(digest_length != 0u)
	{
		result_t output;
		final(output);
		return output;
	}

	template <size_t N> constexpr auto final() noexcept
		requires(digest_length == 0u)
	{
		static_assert(N % 8u == 0u, "Only whole bytes are supported!");
		using result_type = typename Config::template variable_digest<N>;
		result_type output;
		final_absorb();
		squeeze(output);
		return output;
	}
};

template <typename Config> struct keccak_hasher: basic_keccak_hasher<Config> {
	using super = basic_keccak_hasher<Config>;
	using result_t = typename super::result_t;
	using digest_span_t = typename super::digest_span_t;

	constexpr keccak_hasher() noexcept: super() { }
	constexpr keccak_hasher(const keccak_hasher &) noexcept = default;
	constexpr keccak_hasher(keccak_hasher &&) noexcept = default;
	constexpr ~keccak_hasher() noexcept = default;

	constexpr keccak_hasher & update(std::span<const std::byte> input) noexcept {
		super::update(input);
		return *this;
	}

	template <convertible_to_byte_span T> constexpr keccak_hasher & update(const T & something) noexcept {
		using value_type = typename decltype(std::span(something))::value_type;
		super::update(std::span<const value_type>(something));
		return *this;
	}

	template <one_byte_char CharT> constexpr keccak_hasher & update(std::basic_string_view<CharT> in) noexcept {
		super::update(std::span(in.data(), in.size()));
		return *this;
	}

	template <string_literal T> constexpr keccak_hasher & update(const T & lit) noexcept {
		super::update(std::span(lit, std::size(lit) - 1u));
		return *this;
	}

	// TODO: any range with value convertible to byte

	using super::final;
};

template <size_t DigestBits>
struct sha_config {
	static constexpr size_t digest_length_bit = DigestBits;
	static constexpr size_t capacity_bit = DigestBits * 2u;
	static constexpr size_t rate_bit = 1600u - capacity_bit;

	static constexpr auto suffix = keccak_suffix(2, 0b0000'0010u); // in reverse
};

} // namespace cthash

#endif

namespace cthash {

template <size_t N> struct shake128_value;

struct shake128_config {
	template <size_t N> using variable_digest = shake128_value<N>;

	static constexpr size_t digest_length_bit = 0;

	static constexpr size_t capacity_bit = 256;
	static constexpr size_t rate_bit = 1344;

	static constexpr auto suffix = keccak_suffix(4, 0b0000'1111u); // in reverse
};

static_assert((shake128_config::capacity_bit + shake128_config::rate_bit) == 1600u);

using shake128 = cthash::keccak_hasher<shake128_config>;

template <size_t N> struct shake128_value: tagged_hash_value<variable_bit_length_tag<N, shake128_config>> {
	static_assert(N > 0);
	using super = tagged_hash_value<variable_bit_length_tag<N, shake128_config>>;
	using super::super;

	template <typename CharT> explicit constexpr shake128_value(const fixed_string<CharT, N / 8u> & in) noexcept: super{in} { }

	template <size_t K> constexpr friend bool operator==(const shake128_value & lhs, const shake128_value<K> & rhs) noexcept {
		static_assert(K > 0);
		constexpr auto smallest_n = std::min(N, K);
		const auto lhs_view = std::span<const std::byte, smallest_n / 8u>(lhs.data(), smallest_n / 8u);
		const auto rhs_view = std::span<const std::byte, smallest_n / 8u>(rhs.data(), smallest_n / 8u);
		return std::equal(lhs_view.begin(), lhs_view.end(), rhs_view.begin());
	}

	template <size_t K> constexpr friend auto operator<=>(const shake128_value & lhs, const shake128_value<K> & rhs) noexcept {
		static_assert(K > 0);
		constexpr auto smallest_n = std::min(N, K);
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), smallest_n / 8u);
	}
};

template <typename CharT, size_t N>
requires(N % 2 == 0)
shake128_value(const fixed_string<CharT, N> &) -> shake128_value<N * 4u>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_shake128() {
		return shake128_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

#ifndef CTHASH_SHA3_SHAKE256_HPP
#define CTHASH_SHA3_SHAKE256_HPP

#ifndef CTHASH_SHA3_COMMON_HPP
#define CTHASH_SHA3_COMMON_HPP

#ifndef CTHASH_SHA3_KECCAK_BASE_HPP
#define CTHASH_SHA3_KECCAK_BASE_HPP

#include <array>
#include <bit>
#include <span>
#include <type_traits>
#include <utility>
#include <concepts>
#include <cstdint>

namespace cthash::keccak {

// inspired by tiny-keccak (https://github.com/debris/tiny-keccak from Marek Kotewicz)

static constexpr auto rho = std::array<uint8_t, 24>{1u, 3u, 6u, 10u, 15u, 21u, 28u, 36u, 45u, 55u, 2u, 14u, 27u, 41u, 56u, 8u, 25u, 43u, 62u, 18u, 39u, 61u, 20u, 44u};

static constexpr auto pi = std::array<uint8_t, 24>{10u, 7u, 11u, 17u, 18u, 3u, 5u, 16u, 8u, 21u, 24u, 4u, 15u, 23u, 19u, 13u, 12u, 2u, 20u, 14u, 22u, 9u, 6u, 1u};

static constexpr auto rc = std::array<uint64_t, 24>{0x1ULL, 0x8082ULL, 0x800000000000808aULL, 0x8000000080008000ULL, 0x808bULL, 0x80000001ULL, 0x8000000080008081ULL, 0x8000000000008009ULL, 0x8aULL, 0x88ULL, 0x80008009ULL, 0x8000000aULL, 0x8000808bULL, 0x800000000000008bULL, 0x8000000000008089ULL, 0x8000000000008003ULL, 0x8000000000008002ULL, 0x8000000000000080ULL, 0x800aULL, 0x800000008000000aULL, 0x8000000080008081ULL, 0x8000000000008080ULL, 0x80000001ULL, 0x8000000080008008ULL};

struct state_1600: std::array<uint64_t, (5u * 5u)> { };

struct state_1600_ref: std::span<uint64_t, (5u * 5u)> {
	using super = std::span<uint64_t, (5u * 5u)>;
	using super::super;
};

[[gnu::always_inline, gnu::flatten]] constexpr void theta(state_1600_ref state) noexcept {
	// xor of columns
	const auto b = std::array<uint64_t, 5>{
		state[0] xor state[5] xor state[10] xor state[15] xor state[20],
		state[1] xor state[6] xor state[11] xor state[16] xor state[21],
		state[2] xor state[7] xor state[12] xor state[17] xor state[22],
		state[3] xor state[8] xor state[13] xor state[18] xor state[23],
		state[4] xor state[9] xor state[14] xor state[19] xor state[24],
	};

	const auto tmp = std::array<uint64_t, 5>{
		b[4] xor std::rotl(b[1], 1),
		b[0] xor std::rotl(b[2], 1),
		b[1] xor std::rotl(b[3], 1),
		b[2] xor std::rotl(b[4], 1),
		b[3] xor std::rotl(b[0], 1),
	};

	[&]<size_t... Idx>(std::index_sequence<Idx...>) {
		((state[Idx] ^= tmp[Idx % 5u]), ...);
	}(std::make_index_sequence<25>());
}

[[gnu::always_inline, gnu::flatten]] constexpr void rho_pi(state_1600_ref state) noexcept {
	uint64_t tmp = state[1];

	[&]<size_t... Idx>(std::index_sequence<Idx...>) {
		((state[pi[Idx]] = std::rotl(std::exchange(tmp, state[pi[Idx]]), rho[Idx])), ...);
	}(std::make_index_sequence<24>());
}

[[gnu::always_inline, gnu::flatten]] constexpr void chi(state_1600_ref state) noexcept {
	constexpr auto chi_helper = [](std::span<uint64_t, 5> row) {
		const auto b = std::array<uint64_t, 5>{row[0], row[1], row[2], row[3], row[4]};

		row[0] = b[0] xor ((~b[1]) bitand b[2]);
		row[1] = b[1] xor ((~b[2]) bitand b[3]);
		row[2] = b[2] xor ((~b[3]) bitand b[4]);
		row[3] = b[3] xor ((~b[4]) bitand b[0]);
		row[4] = b[4] xor ((~b[0]) bitand b[1]);
	};

	chi_helper(state.subspan<0>().first<5>());
	chi_helper(state.subspan<5>().first<5>());
	chi_helper(state.subspan<10>().first<5>());
	chi_helper(state.subspan<15>().first<5>());
	chi_helper(state.subspan<20>().first<5>());
}

[[gnu::flatten]] constexpr void keccak_f(state_1600 & state) noexcept {
	// rounds
	for (int i = 0; i != 24; ++i) {
		// theta (xor each column together)
		theta(state);
		rho_pi(state);
		chi(state);
		state[0] ^= rc[static_cast<size_t>(i)];
	}
}

} // namespace cthash::keccak

#endif
#ifndef CONSTEXPR_SHA2_HASHER_HPP
#define CONSTEXPR_SHA2_HASHER_HPP

#ifndef CTHASH_SIMPLE_HPP
#define CTHASH_SIMPLE_HPP

#include <utility>

namespace cthash {

template <typename Hasher, typename In, typename... Args> concept hasher_like = requires(Hasher & h, const In & in, Args &&... args) //
{
	{ Hasher{std::forward<Args>(args)...} };
	{ h.update(in) } -> std::same_as<Hasher &>;
	{ h.final() };
};

template <typename Hasher, typename In> concept direct_hasher = requires(Hasher & h, const In & in) //
{
	{ h.update_and_final(in) };
};

template <typename Hasher, typename T, typename... Args>
requires hasher_like<Hasher, T, Args...>
constexpr auto simple(const T & value, Args &&... args) noexcept {
	if constexpr (direct_hasher<Hasher, T>) {
		return Hasher{std::forward<Args>(args)...}.update_and_final(value);
	} else {
		return Hasher{std::forward<Args>(args)...}.update(value).final();
	}
}

} // namespace cthash

#endif

#ifndef CTHASH_VALUE_HPP
#define CTHASH_VALUE_HPP

#ifndef CTHASH_FIXED_STRING_HPP
#define CTHASH_FIXED_STRING_HPP

#include <algorithm>
#include <span>
#include <string_view>

namespace cthash {

template <typename CharT, size_t N> struct fixed_string: std::array<CharT, N> {
	using super = std::array<CharT, N>;

	consteval static auto from_string_literal(const CharT (&in)[N + 1]) -> std::array<CharT, N> {
		std::array<CharT, N> out;
		std::copy_n(in, N, out.data());
		return out;
	}

	explicit constexpr fixed_string(std::nullptr_t) noexcept: super{} { }

	consteval fixed_string(const CharT (&in)[N + 1]) noexcept: super{from_string_literal(in)} { }

	using super::data;
	using super::size;

	constexpr operator std::span<const CharT, N>() const noexcept {
		return std::span<const CharT, N>(data(), size());
	}

	constexpr operator std::span<const CharT>() const noexcept {
		return std::span<const CharT>(data(), size());
	}

	constexpr operator std::basic_string_view<CharT>() const noexcept {
		return std::basic_string_view<CharT>(data(), size());
	}

	constexpr friend bool operator==(const fixed_string &, const fixed_string &) noexcept = default;
	constexpr friend bool operator==(const fixed_string & lhs, std::basic_string_view<CharT> rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == rhs;
	}
	constexpr friend bool operator==(const fixed_string & lhs, const CharT * rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == std::basic_string_view<CharT>{rhs};
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N - 1>;

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_BASE_HPP
#define CTHASH_ENCODING_BASE_HPP

#ifndef CTHASH_ENCODING_CHUNK_OF_BITS_HPP
#define CTHASH_ENCODING_CHUNK_OF_BITS_HPP

#ifndef CTHASH_ENCODING_BIT_BUFFER_HPP
#define CTHASH_ENCODING_BIT_BUFFER_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <bit>
#include <iostream>
#include <numeric>
#include <ranges>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct select_bit_integer;

template <size_t Bits> requires(Bits <= 8) struct select_bit_integer<Bits> {
	using type = uint8_t;
};

template <size_t Bits> requires(Bits > 8 && Bits <= 16) struct select_bit_integer<Bits> {
	using type = uint16_t;
};

template <size_t Bits> requires(Bits > 16 && Bits <= 32) struct select_bit_integer<Bits> {
	using type = uint32_t;
};

template <size_t Bits> requires(Bits > 32 && Bits <= 64) struct select_bit_integer<Bits> {
	using type = uint64_t;
};

template <size_t Bits> using select_bit_integer_t = select_bit_integer<Bits>::type;

template <size_t V> requires(std::popcount(V) == 1u) constexpr auto log2_of_power_of_2 = static_cast<size_t>(std::countr_zero(V));

template <size_t Bits> constexpr auto mask = static_cast<select_bit_integer_t<Bits>>((static_cast<select_bit_integer_t<Bits>>(1u) << Bits) - 1u);

template <size_t Capacity> class basic_bit_buffer {
public:
	static constexpr auto capacity = std::integral_constant<size_t, Capacity>{};
	using storage_type = select_bit_integer_t<capacity()>;
	using size_type = select_bit_integer_t<log2_of_power_of_2<std::bit_ceil(capacity())>>;

public:
	storage_type buffer{0};
	size_type bits_available{0};

public:
	template <size_t Bits> static constexpr auto mask = static_cast<storage_type>((static_cast<storage_type>(1u) << Bits) - 1u);

	constexpr friend bool operator==(const basic_bit_buffer & lhs, const basic_bit_buffer & rhs) noexcept = default;

	constexpr size_type size() const noexcept {
		return bits_available;
	}

	constexpr size_type unused_size() const noexcept {
		return capacity() - bits_available;
	}

	constexpr bool empty() const noexcept {
		return bits_available == 0u;
	}

	constexpr bool full() const noexcept {
		return bits_available == capacity();
	}

	template <size_t Bits> constexpr void push(select_bit_integer_t<Bits> in) noexcept requires(Bits <= capacity()) {
		assert(size() <= capacity() - Bits);
		buffer = static_cast<storage_type>(buffer << Bits) | static_cast<storage_type>(in);
		bits_available += static_cast<size_type>(Bits);
	}
	constexpr void push_empty_bits(size_t count) noexcept {
		buffer = static_cast<storage_type>(buffer << count);
		bits_available += static_cast<unsigned char>(count);
	}

	template <size_t Bits> constexpr void pop() noexcept requires(Bits <= capacity()) {
		assert(size() >= Bits);
		bits_available -= static_cast<size_type>(Bits);
	}

	template <size_t Bits> constexpr auto front() const noexcept -> select_bit_integer_t<Bits> requires(Bits <= capacity()) {
		using output_type = select_bit_integer_t<Bits>;
		assert(size() >= static_cast<size_type>(Bits));
		return static_cast<output_type>((buffer >> (bits_available - Bits))) & mask<Bits>;
	}
};

constexpr size_t calculate_padding_bit_count(size_t number_of_bits_in_buffer, size_t output_size, size_t input_size) {
	size_t n = number_of_bits_in_buffer;
	size_t padding_bits = 0u;

	while (n != 0u) {
		padding_bits += input_size;
		n += input_size;

		while (n >= output_size) {
			n = n - output_size;
		}
	}

	return padding_bits;
}

template <size_t OutBits, size_t InBits = 8u> class bit_buffer: protected basic_bit_buffer<std::lcm(OutBits, InBits)> {
	using super = basic_bit_buffer<std::lcm(OutBits, InBits)>;

public:
	constexpr bit_buffer() noexcept = default;

	using typename super::size_type;
	static constexpr auto out_bits = std::integral_constant<size_type, OutBits>{};
	static constexpr auto in_bits = std::integral_constant<size_type, InBits>{};

	using out_type = select_bit_integer_t<OutBits>;
	using in_type = select_bit_integer_t<InBits>;

	using super::capacity;
	static constexpr auto in_capacity = std::integral_constant<size_type, (capacity() / in_bits())>{};
	static constexpr auto out_capacity = std::integral_constant<size_type, (capacity() / out_bits())>{};

	static constexpr auto aligned = std::bool_constant<capacity() == in_capacity()>{};

	constexpr void push(in_type in) noexcept {
		super::template push<in_bits>(in);
	}

	constexpr void push_empty() noexcept {
		this->push(in_type{0u});
	}

	constexpr size_type push_zeros_to_align() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_to_align() noexcept requires(!aligned()) {
		if (empty()) {
			return 0u;
		}

		assert(out_bits > super::size());
		const size_type missing_bits = static_cast<size_type>(out_bits - super::size());
		super::push_empty_bits(missing_bits);
		return missing_bits;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(!aligned()) {
		const size_type usable_bits = super::size();
		const size_type missing_bits = static_cast<size_type>(calculate_padding_bit_count(super::size(), out_bits, in_bits));
		super::push_empty_bits(missing_bits);
		return usable_bits;
	}

	constexpr void pop() noexcept {
		super::template pop<out_bits>();
	}

	constexpr auto front() const noexcept -> out_type {
		return super::template front<out_bits>();
	}

	constexpr size_type size() const noexcept {
		return static_cast<size_type>(super::size() / out_bits);
	}

	constexpr size_type unused_size() const noexcept {
		return static_cast<size_type>(super::unused_size() / in_bits);
	}

	using super::empty;
	using super::full;

	constexpr bool has_bits_for_pop() const noexcept {
		return super::size() >= out_bits;
	}

	constexpr bool has_capacity_for_push() const noexcept {
		return super::size() <= (capacity() - in_bits);
	}
};

} // namespace cthash

#endif

#include <iostream>
#include <ranges>

namespace cthash {

template <typename Buffer> struct buffer_result_type;

template <typename Buffer> requires(Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	static constexpr Buffer::size_type missing_bits = {0u};

	constexpr bool is_padding() const noexcept {
		return false;
	}
};

template <typename Buffer> requires(!Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	typename Buffer::size_type missing_bits;

	constexpr bool is_padding() const noexcept {
		return missing_bits == Buffer::out_bits;
	}
};

template <typename Buffer, bool AllowPadding> struct buffer_with_missing_bits;

template <typename Buffer, bool AllowPadding> requires(Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};

	struct result_type {
		typename Buffer::out_type value;
		static constexpr Buffer::size_type missing_bits = {0u};

		constexpr bool is_padding() const noexcept {
			return false;
		}
	};

	static constexpr bool aligned = Buffer::aligned();

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		return result_type{buffer.front()};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		while (!buffer.has_bits_for_pop() && (it != end)) {
			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <typename Buffer, bool AllowPadding> requires(!Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};
	Buffer::size_type missing_bits{0};

	static constexpr bool aligned = Buffer::aligned();

	struct result_type {
		typename Buffer::out_type value;
		typename Buffer::size_type missing_bits;

		constexpr bool is_padding() const noexcept {
			return missing_bits == Buffer::out_bits;
		}
	};

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		assert(Buffer::out_bits >= missing_bits);
		return result_type{buffer.front(), missing_bits};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	constexpr void pad_buffer() noexcept requires(AllowPadding) {
		// full multi-chunk padding (for baseN encodings)
		missing_bits = (Buffer::out_bits - buffer.push_zeros_for_padding());
	}

	constexpr void pad_buffer() noexcept requires(!AllowPadding) {
		// only add enough zero to finish current output chunk
		missing_bits = buffer.push_zeros_to_align();
	}

	constexpr void saturate_missing_bits() noexcept requires(AllowPadding) {
		if (missing_bits) {
			missing_bits = Buffer::out_bits;
		}
		// missing_bits = static_cast<buffer_size_t>((unsigned)(bool)missing_bits * output_value_bit_size);
	}

	constexpr void saturate_missing_bits() noexcept requires(!AllowPadding) {
		// do nothing :)
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		for (;;) {
			if (it == end) {
				if (buffer.has_bits_for_pop()) {
					// if this is second pass after padding we can mark all bits as missing
					saturate_missing_bits();
				} else {
					// fill remainder of buffer with zeros
					pad_buffer();
				}

				return;
			}

			if (buffer.has_bits_for_pop()) {
				return;
			}

			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <bool Value> struct conditional;

template <> struct conditional<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional<false> {
	template <typename, typename T> using type = T;
};

template <bool Const, typename T> using maybe_const = typename conditional<Const>::template type<const T, T>;

template <typename T> concept integral_like = std::integral<T> || std::same_as<std::byte, T>;

template <size_t Bits, bool AllowPadding, std::ranges::input_range Input> requires integral_like<std::ranges::range_value_t<Input>> struct chunk_of_bits_view {
	using input_value_type = std::ranges::range_value_t<Input>;

	static constexpr size_t output_value_bit_size = Bits;
	static constexpr size_t input_value_bit_size = sizeof(input_value_type) * 8u;
	using buffer_t = cthash::bit_buffer<output_value_bit_size, input_value_bit_size>;
	using buffer_size_t = buffer_t::size_type;
	Input input;

	static constexpr bool aligned = buffer_t::aligned;

	struct sentinel { };

	template <bool Const> struct iterator {
		using parent = maybe_const<Const, Input>;
		using storage_type = buffer_with_missing_bits<buffer_t, AllowPadding>;
		using value_type = storage_type::result_type;
		using difference_type = intptr_t;

		std::ranges::iterator_t<parent> it;
		[[no_unique_address]] std::ranges::sentinel_t<parent> end;

		storage_type buffer{};

		constexpr iterator(parent & p) noexcept: it{std::ranges::begin(p)}, end{std::ranges::end(p)} {
			// initialize
			buffer.feed_buffer(it, end);
		}

		iterator(const iterator &) = default;
		iterator(iterator &&) = default;

		iterator & operator=(const iterator &) = default;
		iterator & operator=(iterator &&) = default;

		constexpr iterator & operator++() noexcept {
			buffer.pop();
			buffer.feed_buffer(it, end);
			return *this;
		}

		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			this->operator++();
			return copy;
		}

		constexpr auto operator*() const noexcept {
			return buffer.front();
		}

		constexpr friend bool operator==(const iterator & lhs, const iterator & rhs) noexcept = default;

		constexpr friend bool operator==(const iterator & self, sentinel) noexcept {
			return self.buffer.empty();
		}
	};

	static_assert(std::input_iterator<iterator<true>>);
	static_assert(std::input_iterator<iterator<false>>);
	static_assert(std::sentinel_for<sentinel, iterator<true>>);
	static_assert(std::sentinel_for<sentinel, iterator<false>>);

	constexpr chunk_of_bits_view(Input _input) noexcept: input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input};
	}

	constexpr auto end() const noexcept {
		return sentinel{};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && AllowPadding) {
		// calculate with blocks
		return ((std::ranges::size(input) + (buffer_t::in_capacity() - 1u)) / buffer_t::in_capacity()) * buffer_t::out_capacity();
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && !AllowPadding) {
		// calculate with bits
		const size_t bit_size_of_input = std::ranges::size(input) * input_value_bit_size;
		return (bit_size_of_input + (output_value_bit_size - 1u)) / output_value_bit_size;
	}
};

template <size_t Bits, bool AllowPadding> struct chunk_of_bits_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, chunk_of_bits_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) {
		return chunk_of_bits_view<Bits, AllowPadding, R>(std::forward<R>(input));
	}
};

template <size_t Bits, bool AllowPadding = false> constexpr auto chunk_of_bits = chunk_of_bits_action<Bits, AllowPadding>{};

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#include <bit>

namespace cthash {

template <typename Encoding> struct encoding_properties {
	static constexpr size_t size = std::size(Encoding::alphabet) - 1u;
	static_assert(std::popcount(size) == 1u, "Size of encoding's alphabet must be power-of-two");

	static constexpr size_t bits = std::countr_zero(size);

	static constexpr bool has_padding = padded_encoding<Encoding>;

	static constexpr char padding = [] {
		if constexpr (has_padding) {
			return Encoding::padding;
		} else {
			return '\0';
		}
	}();
};

template <typename Encoding, typename CharT, typename R> struct encode_to_view {
	using properties = encoding_properties<Encoding>;
	using chunk_view = cthash::chunk_of_bits_view<properties::bits, properties::has_padding, R>;

	struct sentinel {
		[[no_unique_address]] chunk_view::sentinel end;
	};

	template <bool Const> struct iterator {
		using difference_type = intptr_t;
		using value_type = CharT;

		chunk_view::template iterator<Const> it;

		constexpr iterator & operator++() noexcept {
			++it;
			return *this;
		}
		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			++it;
			return copy;
		}

		constexpr value_type operator*() const noexcept {
			const auto tmp = *it;
			if constexpr (!chunk_view::aligned) {
				// TODO: do without condition
				if (tmp.is_padding()) {
					return properties::padding;
				}
			}
			return static_cast<value_type>(Encoding::alphabet[static_cast<unsigned>(tmp.value)]);
		}

		constexpr friend bool operator==(const iterator &, const iterator &) noexcept = default;

		constexpr friend bool operator==(const iterator & lhs, const sentinel & rhs) noexcept {
			return lhs.it == rhs.end;
		}
	};

	chunk_view input;

	constexpr encode_to_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}

	constexpr auto to_string() const requires(std::ranges::sized_range<R>) {
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(*this);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(size());
		auto [i, o] = std::ranges::copy(begin(), end(), result.begin());
		assert(i == result.end());
		assert(o == result.end());
		return result;
#endif
	}

	constexpr friend std::basic_ostream<CharT> & operator<<(std::basic_ostream<CharT> & out, encode_to_view in) {
		std::ranges::copy(in.begin(), in.end(), std::ostream_iterator<CharT, CharT>(out));
		return out;
	}
};

template <typename Encoding, typename ValueT, typename R> struct decode_from_view {
	R input;

	template <bool Const> struct iterator { };
	struct sentinel { };

	constexpr decode_from_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}
};

template <typename Encoding, typename CharT = char> struct encode_to_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, encode_to_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return encode_to_view<Encoding, CharT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename ValueT = unsigned char> struct decode_from_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, decode_from_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return decode_from_view<Encoding, ValueT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename CharT = char> constexpr auto encode_to = encode_to_action<Encoding, CharT>{};
template <typename Encoding, typename ValueT = unsigned char> constexpr auto decode_from = decode_from_action<Encoding, ValueT>{};

constexpr auto binary_encode = encode_to<encoding::base2, char>;
constexpr auto base2_encode = encode_to<encoding::base2, char>;
constexpr auto base4_encode = encode_to<encoding::base4, char>;
constexpr auto base8_encode = encode_to<encoding::base8, char>;
constexpr auto octal_encode = encode_to<encoding::base8, char>;
constexpr auto hexdec_encode = encode_to<encoding::base16, char>;
constexpr auto hexdec_uppercase_encode = encode_to<encoding::base16_uppercase, char>;
constexpr auto base16_encode = encode_to<encoding::base16, char>;
constexpr auto base32_encode = encode_to<encoding::base32, char>;
constexpr auto base32_no_padding_encode = encode_to<encoding::base32_no_padding, char>;
constexpr auto z_base32_encode = encode_to<encoding::z_base32, char>;
constexpr auto base64_encode = encode_to<encoding::base64, char>;
constexpr auto base64url_encode = encode_to<encoding::base64url, char>;
constexpr auto base64_no_padding_encode = encode_to<encoding::base64_no_padding, char>;

constexpr auto binary_decode = decode_from<encoding::base2, char>;
constexpr auto base2_decode = decode_from<encoding::base2, char>;
constexpr auto base4_decode = decode_from<encoding::base4, char>;
constexpr auto base8_decode = decode_from<encoding::base8, char>;
constexpr auto hexdec_decode = decode_from<encoding::base16, char>;
constexpr auto base16_decode = decode_from<encoding::base16, char>;
constexpr auto base32_decode = decode_from<encoding::base32, char>;
constexpr auto z_base32_decode = decode_from<encoding::z_base32, char>;
constexpr auto base64_decode = decode_from<encoding::base64, char>;
constexpr auto base64url_decode = decode_from<encoding::base64url, char>;
constexpr auto base64_no_padding_decode = decode_from<encoding::base64_no_padding, char>;

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

// template <typename Encoding, typename CharT, typename R> struct encode_to_view

#ifdef CTHASH_STDFMT_AVAILABLE
template <typename Encoding, typename R, typename CharT>
struct formatter<cthash::encode_to_view<Encoding, CharT, R>, CharT> {
	using subject_type = cthash::encode_to_view<Encoding, CharT, R>;

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		return std::ranges::begin(ctx);
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return std::ranges::copy(value, ctx.out()).out;
	}
};

#endif

} // namespace std

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_ALGORITHM_HPP
#define CTHASH_INTERNAL_ALGORITHM_HPP

#include <numeric>
#include <compare>
#include <cstddef>
#include <cstdint>

namespace cthash::internal {

template <typename It1, typename It2> constexpr auto threeway_compare_of_same_size(It1 lhs, It2 rhs, size_t length) -> std::strong_ordering {
	for (size_t i = 0; i != length; ++i) {
		if (const auto r = (*lhs++ <=> *rhs++); std::is_neq(r)) {
			return r;
		}
	}

	return std::strong_ordering::equal;
}

template <typename T, typename It1, typename It2, typename Stream> constexpr auto & push_to_stream_as(It1 f, It2 l, Stream & stream) {
	constexpr auto cast_and_shift = [](Stream * s, const auto & rhs) { (*s) << T{rhs}; return s; };
	return *std::accumulate(f, l, &stream, cast_and_shift);
}

} // namespace cthash::internal

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_HEXDEC_HPP
#define CTHASH_INTERNAL_HEXDEC_HPP

#include <array>
#include <ostream>
#include <span>
#include <type_traits>
#include <cstdint>

namespace cthash::internal {

consteval auto get_hexdec_table() noexcept {
	std::array<uint8_t, 128> result;

	auto char_to_hexdec = [](char c) {
		if (c >= '0' && c <= '9') {
			return static_cast<uint8_t>(c - '0');
		} else if (c >= 'a' && c <= 'f') {
			return static_cast<uint8_t>(c - 'a' + 10);
		} else if (c >= 'A' && c <= 'F') {
			return static_cast<uint8_t>(c - 'A' + 10);
		} else {
			return static_cast<uint8_t>(0);
		}
	};

	for (size_t i = 0; i != result.size(); ++i) {
		result[i] = char_to_hexdec(static_cast<char>(i));
	}

	return result;
}

constexpr auto hexdec_to_value_alphabet = get_hexdec_table();

template <typename CharT> constexpr auto value_to_hexdec_alphabet = std::array<CharT, 16>{CharT('0'), CharT('1'), CharT('2'), CharT('3'), CharT('4'), CharT('5'), CharT('6'), CharT('7'), CharT('8'), CharT('9'), CharT('a'), CharT('b'), CharT('c'), CharT('d'), CharT('e'), CharT('f')};

struct byte_hexdec_value {
	std::byte val;

	template <typename CharT, typename Traits> friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, byte_hexdec_value rhs) {
		return os << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val >> 4u)] << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val) & 0b1111u];
	}
};

template <size_t N, typename CharT> constexpr auto hexdec_to_binary(std::span<const CharT, N * 2> in) -> std::array<std::byte, N> {
	return [in]<size_t... Idx>(std::index_sequence<Idx...>) {
		return std::array<std::byte, N>{static_cast<std::byte>(hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2]) & 0b0111'1111u] << 4u | hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2u + 1u]) & 0b0111'1111u])...};
	}(std::make_index_sequence<N>());
}

template <typename CharT, size_t N>
requires((N - 1) % 2 == 0) // -1 because of zero terminator in literals
constexpr auto literal_hexdec_to_binary(const CharT (&in)[N]) -> std::array<std::byte, (N - 1) / 2> {
	return hexdec_to_binary<N / 2>(std::span<const char, N - 1>(in, N - 1));
}

} // namespace cthash::internal

#endif

#include <algorithm>
#include <array>
#include <format>
#include <span>
#include <string_view>
#include <compare>

namespace cthash {

// hash_value

template <size_t N> struct hash_value: std::array<std::byte, N> {
	using super = std::array<std::byte, N>;

	constexpr hash_value() noexcept: super{} { }
	explicit constexpr hash_value(super && s) noexcept: super(s) { }
	template <typename CharT> explicit constexpr hash_value(const CharT (&in)[N * 2u + 1u]) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in, N * 2u))} { }
	template <typename CharT> explicit constexpr hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in.data(), in.size()))} { }

	// comparison support
	constexpr friend bool operator==(const hash_value & lhs, const hash_value & rhs) noexcept = default;
	constexpr friend auto operator<=>(const hash_value & lhs, const hash_value & rhs) noexcept -> std::strong_ordering {
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), N);
	}

	template <typename Encoding = cthash::encoding::hexdec, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		auto hexdec_view = *this | cthash::encode_to<Encoding, CharT>;
		std::ranges::copy(hexdec_view, std::ostream_iterator<CharT, CharT>(os));
		return os;
	}

	// print to ostream support
	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const hash_value & val) {
		return val.print_into(os);
	}

	template <size_t PrefixN> constexpr auto prefix() const noexcept requires(PrefixN <= N) {
		hash_value<PrefixN> output{};
		std::ranges::copy(this->begin(), this->begin() + PrefixN, output.begin());
		return output;
	}

	template <size_t SuffixN> constexpr auto suffix() const noexcept requires(SuffixN <= N) {
		hash_value<SuffixN> output{};
		std::ranges::copy(this->end() - SuffixN, this->end(), output.begin());
		return output;
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(encoded);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(encoded.size());
		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());
		return result;
#endif
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_fixed_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
		// it's type dependendent so we can calculate the size...
		constexpr size_t size_needed = (hash_value{} | cthash::encode_to<Encoding, CharT>).size();

		auto result = cthash::fixed_string<CharT, size_needed>{nullptr};

		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());

		return result;
	}
};

template <typename CharT, size_t N> hash_value(const CharT (&)[N]) -> hash_value<(N - 1u) / 2u>;
template <typename CharT, size_t N> hash_value(std::span<const CharT, N>) -> hash_value<N / 2u>;
template <typename CharT, size_t N> hash_value(const fixed_string<CharT, N> &) -> hash_value<N / 2u>;

template <typename> struct default_encoding {
	using encoding = cthash::encoding::hexdec;
};

template <typename Tag> concept tag_with_encoding = requires() {
	typename Tag::encoding;
};

template <tag_with_encoding Tag> struct default_encoding<Tag> {
	using encoding = Tag::encoding;
};

template <typename Tag, size_t = internal::digest_bytes_length_of<Tag>> struct tagged_hash_value: hash_value<internal::digest_bytes_length_of<Tag>> {
	static constexpr size_t N = internal::digest_bytes_length_of<Tag>;

	using super = hash_value<N>;
	using super::super;
	template <typename CharT> explicit constexpr tagged_hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{in} { }

	static constexpr size_t digest_length = N;

	template <typename Encoding = default_encoding<Tag>::encoding, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		return super::template print_into<Encoding>(os);
	}

	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const tagged_hash_value & val) {
		return val.print_into(os);
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_string(const tagged_hash_value & value) {
		return to_string<Encoding, CharT>(static_cast<const super &>(value));
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_fixed_string(const tagged_hash_value & value) {
		return to_fixed_string<Encoding, CharT>(static_cast<const super &>(value));
	}
};

template <typename T> concept variable_digest_length = T::digest_length_bit == 0u;

template <size_t N, variable_digest_length Tag> struct variable_bit_length_tag: Tag {
	static constexpr size_t digest_length_bit = N;
};

template <typename T> concept convertible_to_tagged_hash_value = requires(const T & obj) {
	{ tagged_hash_value{obj} };
};

namespace literals {

	template <fixed_string Value>
	constexpr auto operator""_hash() {
		return hash_value(Value);
	}

} // namespace literals

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#if _LIBCPP_VERSION >= 170000
// libc++ will define __cpp_lib_format macro in 19.0
// https://github.com/llvm/llvm-project/issues/77773
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#ifdef CTHASH_STDFMT_AVAILABLE
template <size_t N, typename CharT>
struct formatter<cthash::hash_value<N>, CharT> {
	using subject_type = cthash::hash_value<N>;
	using default_encoding = cthash::encoding::hexdec;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <typename Tag, size_t N, typename CharT>
struct formatter<cthash::tagged_hash_value<Tag, N>, CharT> {
	using subject_type = cthash::tagged_hash_value<Tag, N>;
	using default_encoding = typename cthash::default_encoding<Tag>::encoding;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <cthash::convertible_to_tagged_hash_value Type, typename CharT> struct formatter<Type, CharT>: formatter<decltype(cthash::tagged_hash_value{std::declval<Type>()}), CharT> {
};

#endif

} // namespace std

#endif

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_CONVERT_HPP
#define CTHASH_INTERNAL_CONVERT_HPP

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#include <span>
#include <type_traits>
#include <cstddef>
#include <cstdint>
#include <cstring>

namespace cthash {

template <typename It1, typename It2, typename It3> constexpr auto byte_copy(It1 first, It2 last, It3 destination) {
	return std::transform(first, last, destination, [](byte_like auto v) { return static_cast<std::byte>(v); });
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << ((sizeof(T) - 1u - Idx) * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::little) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_le_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << static_cast<T>(Idx * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::big) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T> struct unwrap_littleendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> (Idx * 8u))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_littleendian_number(std::span<std::byte, 8>) -> unwrap_littleendian_number<uint64_t>;
unwrap_littleendian_number(std::span<std::byte, 4>) -> unwrap_littleendian_number<uint32_t>;

template <std::unsigned_integral T> struct unwrap_bigendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> ((bits - 8u) - 8u * Idx))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_bigendian_number(std::span<std::byte, 8>) -> unwrap_bigendian_number<uint64_t>;
unwrap_bigendian_number(std::span<std::byte, 4>) -> unwrap_bigendian_number<uint32_t>;

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#include <algorithm>
#include <array>
#include <span>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <typename Config> struct internal_hasher {
	static constexpr auto config = Config{};
	static constexpr size_t block_size_bytes = config.block_bits / 8u;
	static constexpr size_t digest_bytes = internal::digest_bytes_length_of<Config>;

	// internal types
	using state_value_t = std::remove_cvref_t<decltype(Config::initial_values)>;
	using state_item_t = typename state_value_t::value_type;

	using block_value_t = std::array<std::byte, block_size_bytes>;
	using block_view_t = std::span<const std::byte, block_size_bytes>;

	using staging_item_t = typename decltype(config.constants)::value_type;
	static constexpr size_t staging_size = config.constants.size();
	using staging_value_t = std::array<staging_item_t, staging_size>;
	using staging_view_t = std::span<const staging_item_t, staging_size>;

	using digest_span_t = std::span<std::byte, digest_bytes>;
	using result_t = cthash::tagged_hash_value<Config>;
	using length_t = typename Config::length_type;

	// internal state
	state_value_t hash;
	length_t total_length;

	block_value_t block;
	unsigned block_used;

	// constructors
	constexpr internal_hasher() noexcept: hash{config.initial_values}, total_length{0u}, block_used{0u} { }
	constexpr internal_hasher(const internal_hasher &) noexcept = default;
	constexpr internal_hasher(internal_hasher &&) noexcept = default;
	constexpr ~internal_hasher() noexcept = default;

	// take buffer and build staging
	template <byte_like Byte> [[gnu::always_inline]] static constexpr auto build_staging(std::span<const Byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		staging_value_t w;

		constexpr auto first_part_size = block_size_bytes / sizeof(staging_item_t);

		// fill first part with chunk
		for (int i = 0; i != int(first_part_size); ++i) {
			w[static_cast<size_t>(i)] = cast_from_bytes<staging_item_t>(chunk.subspan(static_cast<size_t>(i) * sizeof(staging_item_t)).template first<sizeof(staging_item_t)>());
		}

		// fill the rest (generify)
		for (int i = int(first_part_size); i != int(staging_size); ++i) {
			w[static_cast<size_t>(i)] = w[static_cast<size_t>(i - 16)] + config.sigma_0(w[static_cast<size_t>(i - 15)]) + w[static_cast<size_t>(i - 7)] + config.sigma_1(w[static_cast<size_t>(i - 2)]);
		}

		return w;
	}

	[[gnu::always_inline]] static constexpr auto build_staging(std::span<const std::byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		return build_staging<std::byte>(chunk);
	}

	[[gnu::always_inline]] static constexpr void rounds(staging_view_t w, state_value_t & state) noexcept {
		config.rounds(w, state);
	}

	// this implementation works only with input size aligned to bytes (not bits)
	template <byte_like T> [[gnu::always_inline]] constexpr void update_to_buffer_and_process(std::span<const T> in) noexcept {
		// if block is not used, we can build staging directly
		if (block_used) {
			const auto remaining_free_space = std::span<std::byte, block_size_bytes>(block).subspan(block_used);
			const auto to_copy = in.first(std::min(in.size(), remaining_free_space.size()));

			const auto it = byte_copy(to_copy.begin(), to_copy.end(), remaining_free_space.begin());
			total_length += to_copy.size();

			// we didn't fill the block
			if (it != remaining_free_space.end()) {
				assert(to_copy.size() == in.size());
				block_used += static_cast<unsigned>(to_copy.size());
				return;
			} else {
				block_used = 0u;
			}

			// we have block!
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// remove part we processed
			in = in.subspan(to_copy.size());
		}

		// do the work over blocks without copy
		if (not block_used) {
			while (in.size() >= block_size_bytes) {
				const auto local_block = in.template first<block_size_bytes>();
				total_length += block_size_bytes;

				const staging_value_t w = build_staging<T>(local_block);
				rounds(w, hash);

				// remove part we processed
				in = in.subspan(block_size_bytes);
			}
		}

		// remainder is put onto temporary block
		if (not in.empty()) {
			assert(block_used == 0u);
			assert(in.size() < block_size_bytes);

			// copy it to block and let it stay there
			byte_copy(in.begin(), in.end(), block.begin());
			block_used = static_cast<unsigned>(in.size());
			total_length += block_used;
		}
	}

	[[gnu::always_inline]] static constexpr bool finalize_buffer(block_value_t & block, size_t block_used) noexcept {
		assert(block_used < block.size());
		const auto free_space = std::span(block).subspan(block_used);

		auto it = free_space.data();
		*it++ = std::byte{0b1000'0000u};							   // first byte after data contains bit at MSB
		std::fill(it, (block.data() + block.size()), std::byte{0x0u}); // rest is filled with zeros

		// we don't have enough space to write length bits
		return free_space.size() < (1u + (config.length_size_bits / 8u));
	}

	[[gnu::always_inline]] static constexpr void finalize_buffer_by_writing_length(block_value_t & block, length_t total_length) noexcept {
		unwrap_bigendian_number{std::span(block).template last<sizeof(length_t)>()} = (total_length * 8u);
	}

	[[gnu::always_inline]] constexpr void finalize() noexcept {
		if (finalize_buffer(block, block_used)) {
			// we didn't have enough space, we need to process block
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// zero it out
			std::fill(block.begin(), block.end(), std::byte{0x0u});
		}

		// we either have space to write or we have zerod out block
		finalize_buffer_by_writing_length(block, total_length);

		// calculate last round
		const staging_value_t w = build_staging(block);
		rounds(w, hash);
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) == 0u)
	{
		// copy result to byte result
		constexpr size_t values_for_output = digest_bytes / sizeof(state_item_t);
		static_assert(values_for_output <= config.initial_values.size());

		for (int i = 0; i != values_for_output; ++i) {
			unwrap_bigendian_number<state_item_t>{out.subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) != 0u)
	{
		// this is only used when digest doesn't align with output buffer

		// make sure digest size is smaller than hash state
		static_assert(digest_bytes <= config.initial_values.size() * sizeof(state_item_t));

		// copy result to byte result
		std::array<std::byte, sizeof(state_item_t) * config.initial_values.size()> tmp_buffer;

		for (int i = 0; i != (int)config.initial_values.size(); ++i) {
			unwrap_bigendian_number<state_item_t>{std::span(tmp_buffer).subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}

		std::copy_n(tmp_buffer.data(), digest_bytes, out.data());
	}
};

// this is a convinience type for nicer UX...
template <typename Config> struct hasher: private internal_hasher<Config> {
	using super = internal_hasher<Config>;
	using result_t = typename super::result_t;
	using length_t = typename super::length_t;
	using digest_span_t = typename super::digest_span_t;

	constexpr hasher() noexcept: super() { }
	constexpr hasher(const hasher &) noexcept = default;
	constexpr hasher(hasher &&) noexcept = default;
	constexpr ~hasher() noexcept = default;

	// support for various input types
	constexpr hasher & update(std::span<const std::byte> input) noexcept {
		super::update_to_buffer_and_process(input);
		return *this;
	}

	template <convertible_to_byte_span T> constexpr hasher & update(const T & something) noexcept {
		using value_type = typename decltype(std::span(something))::value_type;
		super::update_to_buffer_and_process(std::span<const value_type>(something));
		return *this;
	}

	template <one_byte_char CharT> constexpr hasher & update(std::basic_string_view<CharT> in) noexcept {
		super::update_to_buffer_and_process(std::span(in.data(), in.size()));
		return *this;
	}

	template <string_literal T> constexpr hasher & update(const T & lit) noexcept {
		super::update_to_buffer_and_process(std::span(lit, std::size(lit) - 1u));
		return *this;
	}

	// TODO: any range with value convertible to byte

	// output (by reference or by value)
	constexpr void final(digest_span_t digest) noexcept {
		super::finalize();
		super::write_result_into(digest);
	}

	constexpr auto final() noexcept {
		result_t output;
		this->final(output);
		return output;
	}

	constexpr length_t size() const noexcept {
		return super::total_length;
	}
};

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_CONVERT_HPP
#define CTHASH_INTERNAL_CONVERT_HPP

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#include <span>
#include <type_traits>
#include <cstddef>
#include <cstdint>
#include <cstring>

namespace cthash {

template <typename It1, typename It2, typename It3> constexpr auto byte_copy(It1 first, It2 last, It3 destination) {
	return std::transform(first, last, destination, [](byte_like auto v) { return static_cast<std::byte>(v); });
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << ((sizeof(T) - 1u - Idx) * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::little) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_le_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << static_cast<T>(Idx * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::big) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T> struct unwrap_littleendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> (Idx * 8u))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_littleendian_number(std::span<std::byte, 8>) -> unwrap_littleendian_number<uint64_t>;
unwrap_littleendian_number(std::span<std::byte, 4>) -> unwrap_littleendian_number<uint32_t>;

template <std::unsigned_integral T> struct unwrap_bigendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> ((bits - 8u) - 8u * Idx))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_bigendian_number(std::span<std::byte, 8>) -> unwrap_bigendian_number<uint64_t>;
unwrap_bigendian_number(std::span<std::byte, 4>) -> unwrap_bigendian_number<uint32_t>;

} // namespace cthash

#endif

#ifndef CTHASH_SIMPLE_HPP
#define CTHASH_SIMPLE_HPP

#include <utility>

namespace cthash {

template <typename Hasher, typename In, typename... Args> concept hasher_like = requires(Hasher & h, const In & in, Args &&... args) //
{
	{ Hasher{std::forward<Args>(args)...} };
	{ h.update(in) } -> std::same_as<Hasher &>;
	{ h.final() };
};

template <typename Hasher, typename In> concept direct_hasher = requires(Hasher & h, const In & in) //
{
	{ h.update_and_final(in) };
};

template <typename Hasher, typename T, typename... Args>
requires hasher_like<Hasher, T, Args...>
constexpr auto simple(const T & value, Args &&... args) noexcept {
	if constexpr (direct_hasher<Hasher, T>) {
		return Hasher{std::forward<Args>(args)...}.update_and_final(value);
	} else {
		return Hasher{std::forward<Args>(args)...}.update(value).final();
	}
}

} // namespace cthash

#endif

#ifndef CTHASH_VALUE_HPP
#define CTHASH_VALUE_HPP

#ifndef CTHASH_FIXED_STRING_HPP
#define CTHASH_FIXED_STRING_HPP

#include <algorithm>
#include <span>
#include <string_view>

namespace cthash {

template <typename CharT, size_t N> struct fixed_string: std::array<CharT, N> {
	using super = std::array<CharT, N>;

	consteval static auto from_string_literal(const CharT (&in)[N + 1]) -> std::array<CharT, N> {
		std::array<CharT, N> out;
		std::copy_n(in, N, out.data());
		return out;
	}

	explicit constexpr fixed_string(std::nullptr_t) noexcept: super{} { }

	consteval fixed_string(const CharT (&in)[N + 1]) noexcept: super{from_string_literal(in)} { }

	using super::data;
	using super::size;

	constexpr operator std::span<const CharT, N>() const noexcept {
		return std::span<const CharT, N>(data(), size());
	}

	constexpr operator std::span<const CharT>() const noexcept {
		return std::span<const CharT>(data(), size());
	}

	constexpr operator std::basic_string_view<CharT>() const noexcept {
		return std::basic_string_view<CharT>(data(), size());
	}

	constexpr friend bool operator==(const fixed_string &, const fixed_string &) noexcept = default;
	constexpr friend bool operator==(const fixed_string & lhs, std::basic_string_view<CharT> rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == rhs;
	}
	constexpr friend bool operator==(const fixed_string & lhs, const CharT * rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == std::basic_string_view<CharT>{rhs};
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N - 1>;

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_BASE_HPP
#define CTHASH_ENCODING_BASE_HPP

#ifndef CTHASH_ENCODING_CHUNK_OF_BITS_HPP
#define CTHASH_ENCODING_CHUNK_OF_BITS_HPP

#ifndef CTHASH_ENCODING_BIT_BUFFER_HPP
#define CTHASH_ENCODING_BIT_BUFFER_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <bit>
#include <iostream>
#include <numeric>
#include <ranges>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct select_bit_integer;

template <size_t Bits> requires(Bits <= 8) struct select_bit_integer<Bits> {
	using type = uint8_t;
};

template <size_t Bits> requires(Bits > 8 && Bits <= 16) struct select_bit_integer<Bits> {
	using type = uint16_t;
};

template <size_t Bits> requires(Bits > 16 && Bits <= 32) struct select_bit_integer<Bits> {
	using type = uint32_t;
};

template <size_t Bits> requires(Bits > 32 && Bits <= 64) struct select_bit_integer<Bits> {
	using type = uint64_t;
};

template <size_t Bits> using select_bit_integer_t = select_bit_integer<Bits>::type;

template <size_t V> requires(std::popcount(V) == 1u) constexpr auto log2_of_power_of_2 = static_cast<size_t>(std::countr_zero(V));

template <size_t Bits> constexpr auto mask = static_cast<select_bit_integer_t<Bits>>((static_cast<select_bit_integer_t<Bits>>(1u) << Bits) - 1u);

template <size_t Capacity> class basic_bit_buffer {
public:
	static constexpr auto capacity = std::integral_constant<size_t, Capacity>{};
	using storage_type = select_bit_integer_t<capacity()>;
	using size_type = select_bit_integer_t<log2_of_power_of_2<std::bit_ceil(capacity())>>;

public:
	storage_type buffer{0};
	size_type bits_available{0};

public:
	template <size_t Bits> static constexpr auto mask = static_cast<storage_type>((static_cast<storage_type>(1u) << Bits) - 1u);

	constexpr friend bool operator==(const basic_bit_buffer & lhs, const basic_bit_buffer & rhs) noexcept = default;

	constexpr size_type size() const noexcept {
		return bits_available;
	}

	constexpr size_type unused_size() const noexcept {
		return capacity() - bits_available;
	}

	constexpr bool empty() const noexcept {
		return bits_available == 0u;
	}

	constexpr bool full() const noexcept {
		return bits_available == capacity();
	}

	template <size_t Bits> constexpr void push(select_bit_integer_t<Bits> in) noexcept requires(Bits <= capacity()) {
		assert(size() <= capacity() - Bits);
		buffer = static_cast<storage_type>(buffer << Bits) | static_cast<storage_type>(in);
		bits_available += static_cast<size_type>(Bits);
	}
	constexpr void push_empty_bits(size_t count) noexcept {
		buffer = static_cast<storage_type>(buffer << count);
		bits_available += static_cast<unsigned char>(count);
	}

	template <size_t Bits> constexpr void pop() noexcept requires(Bits <= capacity()) {
		assert(size() >= Bits);
		bits_available -= static_cast<size_type>(Bits);
	}

	template <size_t Bits> constexpr auto front() const noexcept -> select_bit_integer_t<Bits> requires(Bits <= capacity()) {
		using output_type = select_bit_integer_t<Bits>;
		assert(size() >= static_cast<size_type>(Bits));
		return static_cast<output_type>((buffer >> (bits_available - Bits))) & mask<Bits>;
	}
};

constexpr size_t calculate_padding_bit_count(size_t number_of_bits_in_buffer, size_t output_size, size_t input_size) {
	size_t n = number_of_bits_in_buffer;
	size_t padding_bits = 0u;

	while (n != 0u) {
		padding_bits += input_size;
		n += input_size;

		while (n >= output_size) {
			n = n - output_size;
		}
	}

	return padding_bits;
}

template <size_t OutBits, size_t InBits = 8u> class bit_buffer: protected basic_bit_buffer<std::lcm(OutBits, InBits)> {
	using super = basic_bit_buffer<std::lcm(OutBits, InBits)>;

public:
	constexpr bit_buffer() noexcept = default;

	using typename super::size_type;
	static constexpr auto out_bits = std::integral_constant<size_type, OutBits>{};
	static constexpr auto in_bits = std::integral_constant<size_type, InBits>{};

	using out_type = select_bit_integer_t<OutBits>;
	using in_type = select_bit_integer_t<InBits>;

	using super::capacity;
	static constexpr auto in_capacity = std::integral_constant<size_type, (capacity() / in_bits())>{};
	static constexpr auto out_capacity = std::integral_constant<size_type, (capacity() / out_bits())>{};

	static constexpr auto aligned = std::bool_constant<capacity() == in_capacity()>{};

	constexpr void push(in_type in) noexcept {
		super::template push<in_bits>(in);
	}

	constexpr void push_empty() noexcept {
		this->push(in_type{0u});
	}

	constexpr size_type push_zeros_to_align() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_to_align() noexcept requires(!aligned()) {
		if (empty()) {
			return 0u;
		}

		assert(out_bits > super::size());
		const size_type missing_bits = static_cast<size_type>(out_bits - super::size());
		super::push_empty_bits(missing_bits);
		return missing_bits;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(!aligned()) {
		const size_type usable_bits = super::size();
		const size_type missing_bits = static_cast<size_type>(calculate_padding_bit_count(super::size(), out_bits, in_bits));
		super::push_empty_bits(missing_bits);
		return usable_bits;
	}

	constexpr void pop() noexcept {
		super::template pop<out_bits>();
	}

	constexpr auto front() const noexcept -> out_type {
		return super::template front<out_bits>();
	}

	constexpr size_type size() const noexcept {
		return static_cast<size_type>(super::size() / out_bits);
	}

	constexpr size_type unused_size() const noexcept {
		return static_cast<size_type>(super::unused_size() / in_bits);
	}

	using super::empty;
	using super::full;

	constexpr bool has_bits_for_pop() const noexcept {
		return super::size() >= out_bits;
	}

	constexpr bool has_capacity_for_push() const noexcept {
		return super::size() <= (capacity() - in_bits);
	}
};

} // namespace cthash

#endif

#include <iostream>
#include <ranges>

namespace cthash {

template <typename Buffer> struct buffer_result_type;

template <typename Buffer> requires(Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	static constexpr Buffer::size_type missing_bits = {0u};

	constexpr bool is_padding() const noexcept {
		return false;
	}
};

template <typename Buffer> requires(!Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	typename Buffer::size_type missing_bits;

	constexpr bool is_padding() const noexcept {
		return missing_bits == Buffer::out_bits;
	}
};

template <typename Buffer, bool AllowPadding> struct buffer_with_missing_bits;

template <typename Buffer, bool AllowPadding> requires(Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};

	struct result_type {
		typename Buffer::out_type value;
		static constexpr Buffer::size_type missing_bits = {0u};

		constexpr bool is_padding() const noexcept {
			return false;
		}
	};

	static constexpr bool aligned = Buffer::aligned();

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		return result_type{buffer.front()};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		while (!buffer.has_bits_for_pop() && (it != end)) {
			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <typename Buffer, bool AllowPadding> requires(!Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};
	Buffer::size_type missing_bits{0};

	static constexpr bool aligned = Buffer::aligned();

	struct result_type {
		typename Buffer::out_type value;
		typename Buffer::size_type missing_bits;

		constexpr bool is_padding() const noexcept {
			return missing_bits == Buffer::out_bits;
		}
	};

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		assert(Buffer::out_bits >= missing_bits);
		return result_type{buffer.front(), missing_bits};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	constexpr void pad_buffer() noexcept requires(AllowPadding) {
		// full multi-chunk padding (for baseN encodings)
		missing_bits = (Buffer::out_bits - buffer.push_zeros_for_padding());
	}

	constexpr void pad_buffer() noexcept requires(!AllowPadding) {
		// only add enough zero to finish current output chunk
		missing_bits = buffer.push_zeros_to_align();
	}

	constexpr void saturate_missing_bits() noexcept requires(AllowPadding) {
		if (missing_bits) {
			missing_bits = Buffer::out_bits;
		}
		// missing_bits = static_cast<buffer_size_t>((unsigned)(bool)missing_bits * output_value_bit_size);
	}

	constexpr void saturate_missing_bits() noexcept requires(!AllowPadding) {
		// do nothing :)
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		for (;;) {
			if (it == end) {
				if (buffer.has_bits_for_pop()) {
					// if this is second pass after padding we can mark all bits as missing
					saturate_missing_bits();
				} else {
					// fill remainder of buffer with zeros
					pad_buffer();
				}

				return;
			}

			if (buffer.has_bits_for_pop()) {
				return;
			}

			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <bool Value> struct conditional;

template <> struct conditional<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional<false> {
	template <typename, typename T> using type = T;
};

template <bool Const, typename T> using maybe_const = typename conditional<Const>::template type<const T, T>;

template <typename T> concept integral_like = std::integral<T> || std::same_as<std::byte, T>;

template <size_t Bits, bool AllowPadding, std::ranges::input_range Input> requires integral_like<std::ranges::range_value_t<Input>> struct chunk_of_bits_view {
	using input_value_type = std::ranges::range_value_t<Input>;

	static constexpr size_t output_value_bit_size = Bits;
	static constexpr size_t input_value_bit_size = sizeof(input_value_type) * 8u;
	using buffer_t = cthash::bit_buffer<output_value_bit_size, input_value_bit_size>;
	using buffer_size_t = buffer_t::size_type;
	Input input;

	static constexpr bool aligned = buffer_t::aligned;

	struct sentinel { };

	template <bool Const> struct iterator {
		using parent = maybe_const<Const, Input>;
		using storage_type = buffer_with_missing_bits<buffer_t, AllowPadding>;
		using value_type = storage_type::result_type;
		using difference_type = intptr_t;

		std::ranges::iterator_t<parent> it;
		[[no_unique_address]] std::ranges::sentinel_t<parent> end;

		storage_type buffer{};

		constexpr iterator(parent & p) noexcept: it{std::ranges::begin(p)}, end{std::ranges::end(p)} {
			// initialize
			buffer.feed_buffer(it, end);
		}

		iterator(const iterator &) = default;
		iterator(iterator &&) = default;

		iterator & operator=(const iterator &) = default;
		iterator & operator=(iterator &&) = default;

		constexpr iterator & operator++() noexcept {
			buffer.pop();
			buffer.feed_buffer(it, end);
			return *this;
		}

		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			this->operator++();
			return copy;
		}

		constexpr auto operator*() const noexcept {
			return buffer.front();
		}

		constexpr friend bool operator==(const iterator & lhs, const iterator & rhs) noexcept = default;

		constexpr friend bool operator==(const iterator & self, sentinel) noexcept {
			return self.buffer.empty();
		}
	};

	static_assert(std::input_iterator<iterator<true>>);
	static_assert(std::input_iterator<iterator<false>>);
	static_assert(std::sentinel_for<sentinel, iterator<true>>);
	static_assert(std::sentinel_for<sentinel, iterator<false>>);

	constexpr chunk_of_bits_view(Input _input) noexcept: input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input};
	}

	constexpr auto end() const noexcept {
		return sentinel{};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && AllowPadding) {
		// calculate with blocks
		return ((std::ranges::size(input) + (buffer_t::in_capacity() - 1u)) / buffer_t::in_capacity()) * buffer_t::out_capacity();
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && !AllowPadding) {
		// calculate with bits
		const size_t bit_size_of_input = std::ranges::size(input) * input_value_bit_size;
		return (bit_size_of_input + (output_value_bit_size - 1u)) / output_value_bit_size;
	}
};

template <size_t Bits, bool AllowPadding> struct chunk_of_bits_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, chunk_of_bits_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) {
		return chunk_of_bits_view<Bits, AllowPadding, R>(std::forward<R>(input));
	}
};

template <size_t Bits, bool AllowPadding = false> constexpr auto chunk_of_bits = chunk_of_bits_action<Bits, AllowPadding>{};

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#include <bit>

namespace cthash {

template <typename Encoding> struct encoding_properties {
	static constexpr size_t size = std::size(Encoding::alphabet) - 1u;
	static_assert(std::popcount(size) == 1u, "Size of encoding's alphabet must be power-of-two");

	static constexpr size_t bits = std::countr_zero(size);

	static constexpr bool has_padding = padded_encoding<Encoding>;

	static constexpr char padding = [] {
		if constexpr (has_padding) {
			return Encoding::padding;
		} else {
			return '\0';
		}
	}();
};

template <typename Encoding, typename CharT, typename R> struct encode_to_view {
	using properties = encoding_properties<Encoding>;
	using chunk_view = cthash::chunk_of_bits_view<properties::bits, properties::has_padding, R>;

	struct sentinel {
		[[no_unique_address]] chunk_view::sentinel end;
	};

	template <bool Const> struct iterator {
		using difference_type = intptr_t;
		using value_type = CharT;

		chunk_view::template iterator<Const> it;

		constexpr iterator & operator++() noexcept {
			++it;
			return *this;
		}
		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			++it;
			return copy;
		}

		constexpr value_type operator*() const noexcept {
			const auto tmp = *it;
			if constexpr (!chunk_view::aligned) {
				// TODO: do without condition
				if (tmp.is_padding()) {
					return properties::padding;
				}
			}
			return static_cast<value_type>(Encoding::alphabet[static_cast<unsigned>(tmp.value)]);
		}

		constexpr friend bool operator==(const iterator &, const iterator &) noexcept = default;

		constexpr friend bool operator==(const iterator & lhs, const sentinel & rhs) noexcept {
			return lhs.it == rhs.end;
		}
	};

	chunk_view input;

	constexpr encode_to_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}

	constexpr auto to_string() const requires(std::ranges::sized_range<R>) {
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(*this);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(size());
		auto [i, o] = std::ranges::copy(begin(), end(), result.begin());
		assert(i == result.end());
		assert(o == result.end());
		return result;
#endif
	}

	constexpr friend std::basic_ostream<CharT> & operator<<(std::basic_ostream<CharT> & out, encode_to_view in) {
		std::ranges::copy(in.begin(), in.end(), std::ostream_iterator<CharT, CharT>(out));
		return out;
	}
};

template <typename Encoding, typename ValueT, typename R> struct decode_from_view {
	R input;

	template <bool Const> struct iterator { };
	struct sentinel { };

	constexpr decode_from_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}
};

template <typename Encoding, typename CharT = char> struct encode_to_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, encode_to_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return encode_to_view<Encoding, CharT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename ValueT = unsigned char> struct decode_from_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, decode_from_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return decode_from_view<Encoding, ValueT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename CharT = char> constexpr auto encode_to = encode_to_action<Encoding, CharT>{};
template <typename Encoding, typename ValueT = unsigned char> constexpr auto decode_from = decode_from_action<Encoding, ValueT>{};

constexpr auto binary_encode = encode_to<encoding::base2, char>;
constexpr auto base2_encode = encode_to<encoding::base2, char>;
constexpr auto base4_encode = encode_to<encoding::base4, char>;
constexpr auto base8_encode = encode_to<encoding::base8, char>;
constexpr auto octal_encode = encode_to<encoding::base8, char>;
constexpr auto hexdec_encode = encode_to<encoding::base16, char>;
constexpr auto hexdec_uppercase_encode = encode_to<encoding::base16_uppercase, char>;
constexpr auto base16_encode = encode_to<encoding::base16, char>;
constexpr auto base32_encode = encode_to<encoding::base32, char>;
constexpr auto base32_no_padding_encode = encode_to<encoding::base32_no_padding, char>;
constexpr auto z_base32_encode = encode_to<encoding::z_base32, char>;
constexpr auto base64_encode = encode_to<encoding::base64, char>;
constexpr auto base64url_encode = encode_to<encoding::base64url, char>;
constexpr auto base64_no_padding_encode = encode_to<encoding::base64_no_padding, char>;

constexpr auto binary_decode = decode_from<encoding::base2, char>;
constexpr auto base2_decode = decode_from<encoding::base2, char>;
constexpr auto base4_decode = decode_from<encoding::base4, char>;
constexpr auto base8_decode = decode_from<encoding::base8, char>;
constexpr auto hexdec_decode = decode_from<encoding::base16, char>;
constexpr auto base16_decode = decode_from<encoding::base16, char>;
constexpr auto base32_decode = decode_from<encoding::base32, char>;
constexpr auto z_base32_decode = decode_from<encoding::z_base32, char>;
constexpr auto base64_decode = decode_from<encoding::base64, char>;
constexpr auto base64url_decode = decode_from<encoding::base64url, char>;
constexpr auto base64_no_padding_decode = decode_from<encoding::base64_no_padding, char>;

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

// template <typename Encoding, typename CharT, typename R> struct encode_to_view

#ifdef CTHASH_STDFMT_AVAILABLE
template <typename Encoding, typename R, typename CharT>
struct formatter<cthash::encode_to_view<Encoding, CharT, R>, CharT> {
	using subject_type = cthash::encode_to_view<Encoding, CharT, R>;

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		return std::ranges::begin(ctx);
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return std::ranges::copy(value, ctx.out()).out;
	}
};

#endif

} // namespace std

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_ALGORITHM_HPP
#define CTHASH_INTERNAL_ALGORITHM_HPP

#include <numeric>
#include <compare>
#include <cstddef>
#include <cstdint>

namespace cthash::internal {

template <typename It1, typename It2> constexpr auto threeway_compare_of_same_size(It1 lhs, It2 rhs, size_t length) -> std::strong_ordering {
	for (size_t i = 0; i != length; ++i) {
		if (const auto r = (*lhs++ <=> *rhs++); std::is_neq(r)) {
			return r;
		}
	}

	return std::strong_ordering::equal;
}

template <typename T, typename It1, typename It2, typename Stream> constexpr auto & push_to_stream_as(It1 f, It2 l, Stream & stream) {
	constexpr auto cast_and_shift = [](Stream * s, const auto & rhs) { (*s) << T{rhs}; return s; };
	return *std::accumulate(f, l, &stream, cast_and_shift);
}

} // namespace cthash::internal

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_HEXDEC_HPP
#define CTHASH_INTERNAL_HEXDEC_HPP

#include <array>
#include <ostream>
#include <span>
#include <type_traits>
#include <cstdint>

namespace cthash::internal {

consteval auto get_hexdec_table() noexcept {
	std::array<uint8_t, 128> result;

	auto char_to_hexdec = [](char c) {
		if (c >= '0' && c <= '9') {
			return static_cast<uint8_t>(c - '0');
		} else if (c >= 'a' && c <= 'f') {
			return static_cast<uint8_t>(c - 'a' + 10);
		} else if (c >= 'A' && c <= 'F') {
			return static_cast<uint8_t>(c - 'A' + 10);
		} else {
			return static_cast<uint8_t>(0);
		}
	};

	for (size_t i = 0; i != result.size(); ++i) {
		result[i] = char_to_hexdec(static_cast<char>(i));
	}

	return result;
}

constexpr auto hexdec_to_value_alphabet = get_hexdec_table();

template <typename CharT> constexpr auto value_to_hexdec_alphabet = std::array<CharT, 16>{CharT('0'), CharT('1'), CharT('2'), CharT('3'), CharT('4'), CharT('5'), CharT('6'), CharT('7'), CharT('8'), CharT('9'), CharT('a'), CharT('b'), CharT('c'), CharT('d'), CharT('e'), CharT('f')};

struct byte_hexdec_value {
	std::byte val;

	template <typename CharT, typename Traits> friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, byte_hexdec_value rhs) {
		return os << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val >> 4u)] << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val) & 0b1111u];
	}
};

template <size_t N, typename CharT> constexpr auto hexdec_to_binary(std::span<const CharT, N * 2> in) -> std::array<std::byte, N> {
	return [in]<size_t... Idx>(std::index_sequence<Idx...>) {
		return std::array<std::byte, N>{static_cast<std::byte>(hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2]) & 0b0111'1111u] << 4u | hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2u + 1u]) & 0b0111'1111u])...};
	}(std::make_index_sequence<N>());
}

template <typename CharT, size_t N>
requires((N - 1) % 2 == 0) // -1 because of zero terminator in literals
constexpr auto literal_hexdec_to_binary(const CharT (&in)[N]) -> std::array<std::byte, (N - 1) / 2> {
	return hexdec_to_binary<N / 2>(std::span<const char, N - 1>(in, N - 1));
}

} // namespace cthash::internal

#endif

#include <algorithm>
#include <array>
#include <format>
#include <span>
#include <string_view>
#include <compare>

namespace cthash {

// hash_value

template <size_t N> struct hash_value: std::array<std::byte, N> {
	using super = std::array<std::byte, N>;

	constexpr hash_value() noexcept: super{} { }
	explicit constexpr hash_value(super && s) noexcept: super(s) { }
	template <typename CharT> explicit constexpr hash_value(const CharT (&in)[N * 2u + 1u]) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in, N * 2u))} { }
	template <typename CharT> explicit constexpr hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in.data(), in.size()))} { }

	// comparison support
	constexpr friend bool operator==(const hash_value & lhs, const hash_value & rhs) noexcept = default;
	constexpr friend auto operator<=>(const hash_value & lhs, const hash_value & rhs) noexcept -> std::strong_ordering {
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), N);
	}

	template <typename Encoding = cthash::encoding::hexdec, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		auto hexdec_view = *this | cthash::encode_to<Encoding, CharT>;
		std::ranges::copy(hexdec_view, std::ostream_iterator<CharT, CharT>(os));
		return os;
	}

	// print to ostream support
	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const hash_value & val) {
		return val.print_into(os);
	}

	template <size_t PrefixN> constexpr auto prefix() const noexcept requires(PrefixN <= N) {
		hash_value<PrefixN> output{};
		std::ranges::copy(this->begin(), this->begin() + PrefixN, output.begin());
		return output;
	}

	template <size_t SuffixN> constexpr auto suffix() const noexcept requires(SuffixN <= N) {
		hash_value<SuffixN> output{};
		std::ranges::copy(this->end() - SuffixN, this->end(), output.begin());
		return output;
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(encoded);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(encoded.size());
		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());
		return result;
#endif
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_fixed_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
		// it's type dependendent so we can calculate the size...
		constexpr size_t size_needed = (hash_value{} | cthash::encode_to<Encoding, CharT>).size();

		auto result = cthash::fixed_string<CharT, size_needed>{nullptr};

		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());

		return result;
	}
};

template <typename CharT, size_t N> hash_value(const CharT (&)[N]) -> hash_value<(N - 1u) / 2u>;
template <typename CharT, size_t N> hash_value(std::span<const CharT, N>) -> hash_value<N / 2u>;
template <typename CharT, size_t N> hash_value(const fixed_string<CharT, N> &) -> hash_value<N / 2u>;

template <typename> struct default_encoding {
	using encoding = cthash::encoding::hexdec;
};

template <typename Tag> concept tag_with_encoding = requires() {
	typename Tag::encoding;
};

template <tag_with_encoding Tag> struct default_encoding<Tag> {
	using encoding = Tag::encoding;
};

template <typename Tag, size_t = internal::digest_bytes_length_of<Tag>> struct tagged_hash_value: hash_value<internal::digest_bytes_length_of<Tag>> {
	static constexpr size_t N = internal::digest_bytes_length_of<Tag>;

	using super = hash_value<N>;
	using super::super;
	template <typename CharT> explicit constexpr tagged_hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{in} { }

	static constexpr size_t digest_length = N;

	template <typename Encoding = default_encoding<Tag>::encoding, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		return super::template print_into<Encoding>(os);
	}

	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const tagged_hash_value & val) {
		return val.print_into(os);
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_string(const tagged_hash_value & value) {
		return to_string<Encoding, CharT>(static_cast<const super &>(value));
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_fixed_string(const tagged_hash_value & value) {
		return to_fixed_string<Encoding, CharT>(static_cast<const super &>(value));
	}
};

template <typename T> concept variable_digest_length = T::digest_length_bit == 0u;

template <size_t N, variable_digest_length Tag> struct variable_bit_length_tag: Tag {
	static constexpr size_t digest_length_bit = N;
};

template <typename T> concept convertible_to_tagged_hash_value = requires(const T & obj) {
	{ tagged_hash_value{obj} };
};

namespace literals {

	template <fixed_string Value>
	constexpr auto operator""_hash() {
		return hash_value(Value);
	}

} // namespace literals

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#if _LIBCPP_VERSION >= 170000
// libc++ will define __cpp_lib_format macro in 19.0
// https://github.com/llvm/llvm-project/issues/77773
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#ifdef CTHASH_STDFMT_AVAILABLE
template <size_t N, typename CharT>
struct formatter<cthash::hash_value<N>, CharT> {
	using subject_type = cthash::hash_value<N>;
	using default_encoding = cthash::encoding::hexdec;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <typename Tag, size_t N, typename CharT>
struct formatter<cthash::tagged_hash_value<Tag, N>, CharT> {
	using subject_type = cthash::tagged_hash_value<Tag, N>;
	using default_encoding = typename cthash::default_encoding<Tag>::encoding;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <cthash::convertible_to_tagged_hash_value Type, typename CharT> struct formatter<Type, CharT>: formatter<decltype(cthash::tagged_hash_value{std::declval<Type>()}), CharT> {
};

#endif

} // namespace std

#endif

#include <cstdint>

namespace cthash {

template <typename T, typename Y> concept castable_to = requires(T val) { {static_cast<Y>(val)} -> std::same_as<Y>; };

template <size_t N> struct keccak_suffix {
	unsigned bits;
	std::array<std::byte, N> values;

	constexpr keccak_suffix(unsigned b, castable_to<std::byte> auto... v) noexcept: bits{b}, values{static_cast<std::byte>(v)...} { }
};

template <castable_to<std::byte>... Ts> keccak_suffix(unsigned, Ts...) -> keccak_suffix<sizeof...(Ts)>;

template <typename T> struct identify;

template <typename T, byte_like Byte> constexpr auto convert_prefix_into_aligned(std::span<const Byte> input, unsigned pos) noexcept -> std::array<std::byte, sizeof(T)> {
	assert(input.size() <= sizeof(T));
	assert(pos <= sizeof(T));
	assert((input.size() + pos) <= sizeof(T));

	std::array<std::byte, sizeof(T)> buffer{};

	std::fill(buffer.begin(), buffer.end(), std::byte{0});
	std::transform(input.data(), input.data() + input.size(), buffer.data() + pos, [](auto v) { return static_cast<std::byte>(v); });

	return buffer;
}

template <typename T, byte_like Byte> constexpr auto convert_prefix_into_value(std::span<const Byte> input, unsigned pos) noexcept -> uint64_t {
	const auto tmp = convert_prefix_into_aligned<T, Byte>(input, pos);
	return cast_from_le_bytes<T>(std::span<const std::byte, 8>(tmp));
}

template <typename Config> struct basic_keccak_hasher {
	static_assert(Config::digest_length_bit % 8u == 0u);
	static_assert(Config::rate_bit % 8u == 0u);
	static_assert(Config::capacity_bit % 8u == 0u);

	static_assert((Config::rate_bit + Config::capacity_bit) == 1600u, "Only Keccak 1600 is implemented");

	static constexpr size_t digest_length = Config::digest_length_bit / 8u;
	static constexpr size_t rate = Config::rate_bit / 8u;
	static constexpr size_t capacity = Config::capacity_bit / 8u;

	using result_t = cthash::tagged_hash_value<Config>;
	using digest_span_t = std::span<std::byte, digest_length>;

	keccak::state_1600 internal_state{};
	uint8_t position{0u};

	constexpr basic_keccak_hasher() noexcept {
		std::fill(internal_state.begin(), internal_state.end(), uint64_t{0});
	}

	template <byte_like T> constexpr size_t xor_overwrite_block(std::span<const T> input) noexcept {
		using value_t = keccak::state_1600::value_type;

		if ((std::is_constant_evaluated() | (std::endian::native != std::endian::little))) {
			assert((size_t(position) + input.size()) <= rate);

			// unaligned prefix (by copying from left to right it should be little endian)
			if (position % sizeof(value_t) != 0u) {
				// xor unaligned value and move to aligned if possible
				const size_t prefix_size = std::min(input.size(), sizeof(value_t) - (position % sizeof(value_t)));
				internal_state[position / sizeof(uint64_t)] ^= convert_prefix_into_value<value_t>(input.first(prefix_size), static_cast<unsigned>(position % sizeof(value_t)));
				position += static_cast<uint8_t>(prefix_size);
				input = input.subspan(prefix_size);
			}

			// aligned blocks
			while (input.size() >= sizeof(value_t)) {
				// xor aligned value and move to next
				internal_state[position / sizeof(value_t)] ^= cast_from_le_bytes<value_t>(input.template first<sizeof(value_t)>());
				position += static_cast<uint8_t>(sizeof(value_t));
				input = input.subspan(sizeof(value_t));
			}

			// unaligned suffix
			if (not input.empty()) {
				// xor and finish
				internal_state[position / sizeof(value_t)] ^= convert_prefix_into_value<value_t>(input, 0u);
				position += static_cast<uint8_t>(input.size());
			}

			return position;
		} else {
			const auto buffer = std::as_writable_bytes(std::span<uint64_t>(internal_state));
			const auto remaining = buffer.subspan(position);
			const auto place = remaining.first(std::min(input.size(), remaining.size()));

			std::transform(place.data(), place.data() + place.size(), input.data(), place.data(), [](std::byte lhs, auto rhs) { return lhs ^ static_cast<std::byte>(rhs); });

			position += static_cast<uint8_t>(place.size());
			return position;
		}
	}

	template <byte_like T> constexpr auto update(std::span<const T> input) noexcept {
		assert(position < rate);
		const size_t remaining_in_buffer = rate - position;

		if (remaining_in_buffer > input.size()) {
			// xor overwrite as much as we can, and that's all
			xor_overwrite_block(input);
			assert(position < rate);
			return;
		}

		// finish block and call keccak :)
		const auto first_part = input.first(remaining_in_buffer);
		input = input.subspan(remaining_in_buffer);
		xor_overwrite_block(first_part);
		assert(position == rate);
		keccak_f(internal_state);
		position = 0u;

		// for each full block we can absorb directly
		while (input.size() >= rate) {
			const auto block = input.template first<rate>();
			input = input.subspan(rate);
			assert(position == 0u);
			xor_overwrite_block<T>(block);
			keccak_f(internal_state);
			position = 0u;
		}

		// xor overwrite internal state with current remainder, and set position to end of it
		if (not input.empty()) {
			assert(position == 0u);
			xor_overwrite_block(input);
			assert(position < rate);
		}
	}

	// pad the message
	constexpr void xor_padding_block() noexcept {
		assert(position < rate);

		constexpr const auto & suffix = Config::suffix;
		constexpr std::byte suffix_and_start_of_padding = (suffix.values[0] | (std::byte{0b0000'0001u} << suffix.bits));

		internal_state[position / sizeof(uint64_t)] ^= uint64_t(suffix_and_start_of_padding) << ((position % sizeof(uint64_t)) * 8u);
		internal_state[(rate - 1u) / sizeof(uint64_t)] ^= 0x8000000000000000ull; // last bit
	}

	constexpr void final_absorb() noexcept {
		xor_padding_block();
		keccak_f(internal_state);
	}

	// get resulting hash
	constexpr void squeeze(std::span<std::byte> output) noexcept {
		using value_t = keccak::state_1600::value_type;

		static_assert((rate % sizeof(value_t)) == 0u);
		auto r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));

		// aligned results will be processed here...
		while ((output.size() >= sizeof(value_t))) {
			// if we ran out of `rate` part, we need to squeeze another block
			if (r.empty()) {
				keccak_f(internal_state);
				r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));
			}

			// look at current to process
			const value_t current = r.front();
			const auto part = output.first<sizeof(value_t)>();

			// convert
			unwrap_littleendian_number<value_t>{part} = current;

			// move to next
			r = r.subspan(1u);
			output = output.subspan(sizeof(value_t));
		}

		// unaligned result is here
		if (!output.empty()) {
			// if we ran out of `rate` part, we need to squeeze another block
			if (r.empty()) {
				keccak_f(internal_state);
				r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));
			}

			const value_t current = r.front();

			// convert
			std::array<std::byte, sizeof(value_t)> tmp;
			unwrap_littleendian_number<value_t>{tmp} = current;
			assert(tmp.size() > output.size());
			std::copy_n(tmp.data(), output.size(), output.data());
		}
	}

	constexpr void squeeze(digest_span_t output_fixed) noexcept
		requires((digest_length < rate) && digest_length != 0u)
	{
		auto output = std::span<std::byte>(output_fixed);

		// we don't need to squeeze anything
		using value_t = keccak::state_1600::value_type;

		static_assert((rate % sizeof(value_t)) == 0u);
		auto r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));

		// aligned results will be processed here...
		while ((output.size() >= sizeof(value_t))) {
			assert(!r.empty());
			// look at current to process
			const value_t current = r.front();
			const auto part = output.template first<sizeof(value_t)>();

			// convert
			unwrap_littleendian_number<value_t>{part} = current;

			// move to next
			r = r.subspan(1u);
			output = output.subspan(sizeof(value_t));
		}

		if constexpr ((output_fixed.size() % sizeof(value_t)) != 0u) {
			// unaligned result is here
			assert(!output.empty());
			assert(!r.empty());

			const value_t current = r.front();

			// convert
			std::array<std::byte, sizeof(value_t)> tmp;
			unwrap_littleendian_number<value_t>{tmp} = current;
			assert(tmp.size() > output.size());
			std::copy_n(tmp.data(), output.size(), output.data());
		}
	}

	constexpr void final(digest_span_t digest) noexcept
		requires(digest_length != 0u)
	{
		final_absorb();
		squeeze(digest);
	}

	constexpr result_t final() noexcept
		requires(digest_length != 0u)
	{
		result_t output;
		final(output);
		return output;
	}

	template <size_t N> constexpr auto final() noexcept
		requires(digest_length == 0u)
	{
		static_assert(N % 8u == 0u, "Only whole bytes are supported!");
		using result_type = typename Config::template variable_digest<N>;
		result_type output;
		final_absorb();
		squeeze(output);
		return output;
	}
};

template <typename Config> struct keccak_hasher: basic_keccak_hasher<Config> {
	using super = basic_keccak_hasher<Config>;
	using result_t = typename super::result_t;
	using digest_span_t = typename super::digest_span_t;

	constexpr keccak_hasher() noexcept: super() { }
	constexpr keccak_hasher(const keccak_hasher &) noexcept = default;
	constexpr keccak_hasher(keccak_hasher &&) noexcept = default;
	constexpr ~keccak_hasher() noexcept = default;

	constexpr keccak_hasher & update(std::span<const std::byte> input) noexcept {
		super::update(input);
		return *this;
	}

	template <convertible_to_byte_span T> constexpr keccak_hasher & update(const T & something) noexcept {
		using value_type = typename decltype(std::span(something))::value_type;
		super::update(std::span<const value_type>(something));
		return *this;
	}

	template <one_byte_char CharT> constexpr keccak_hasher & update(std::basic_string_view<CharT> in) noexcept {
		super::update(std::span(in.data(), in.size()));
		return *this;
	}

	template <string_literal T> constexpr keccak_hasher & update(const T & lit) noexcept {
		super::update(std::span(lit, std::size(lit) - 1u));
		return *this;
	}

	// TODO: any range with value convertible to byte

	using super::final;
};

template <size_t DigestBits>
struct sha_config {
	static constexpr size_t digest_length_bit = DigestBits;
	static constexpr size_t capacity_bit = DigestBits * 2u;
	static constexpr size_t rate_bit = 1600u - capacity_bit;

	static constexpr auto suffix = keccak_suffix(2, 0b0000'0010u); // in reverse
};

} // namespace cthash

#endif

namespace cthash {

template <size_t N> struct shake256_value;

struct shake256_config {
	template <size_t N> using variable_digest = shake256_value<N>;

	static constexpr size_t digest_length_bit = 0;

	static constexpr size_t capacity_bit = 512;
	static constexpr size_t rate_bit = 1088;

	static constexpr auto suffix = keccak_suffix(4, 0b0000'1111u); // in reverse
};

static_assert((shake256_config::capacity_bit + shake256_config::rate_bit) == 1600u);

using shake256 = cthash::keccak_hasher<shake256_config>;

template <size_t N> struct shake256_value: tagged_hash_value<variable_bit_length_tag<N, shake256_config>> {
	static_assert(N > 0);
	using super = tagged_hash_value<variable_bit_length_tag<N, shake256_config>>;
	using super::super;

	template <typename CharT> explicit constexpr shake256_value(const fixed_string<CharT, N / 8u> & in) noexcept: super{in} { }

	template <size_t K> constexpr friend bool operator==(const shake256_value & lhs, const shake256_value<K> & rhs) noexcept {
		constexpr auto smallest_n = std::min(N, K);
		const auto lhs_view = std::span<const std::byte, smallest_n / 8u>(lhs.data(), smallest_n / 8u);
		const auto rhs_view = std::span<const std::byte, smallest_n / 8u>(rhs.data(), smallest_n / 8u);
		return std::equal(lhs_view.begin(), lhs_view.end(), rhs_view.begin());
	}

	template <size_t K> constexpr friend auto operator<=>(const shake256_value & lhs, const shake256_value<K> & rhs) noexcept {
		constexpr auto smallest_n = std::min(N, K);
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), smallest_n / 8u);
	}
};

template <typename CharT, size_t N>
requires(N % 2 == 0)
shake256_value(const fixed_string<CharT, N> &) -> shake256_value<N * 4u>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_shake256() {
		return shake256_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

// xxhash (non-crypto fast hash)
#ifndef CTHASH_XXHASH_HPP
#define CTHASH_XXHASH_HPP

#ifndef CTHASH_SIMPLE_HPP
#define CTHASH_SIMPLE_HPP

#include <utility>

namespace cthash {

template <typename Hasher, typename In, typename... Args> concept hasher_like = requires(Hasher & h, const In & in, Args &&... args) //
{
	{ Hasher{std::forward<Args>(args)...} };
	{ h.update(in) } -> std::same_as<Hasher &>;
	{ h.final() };
};

template <typename Hasher, typename In> concept direct_hasher = requires(Hasher & h, const In & in) //
{
	{ h.update_and_final(in) };
};

template <typename Hasher, typename T, typename... Args>
requires hasher_like<Hasher, T, Args...>
constexpr auto simple(const T & value, Args &&... args) noexcept {
	if constexpr (direct_hasher<Hasher, T>) {
		return Hasher{std::forward<Args>(args)...}.update_and_final(value);
	} else {
		return Hasher{std::forward<Args>(args)...}.update(value).final();
	}
}

} // namespace cthash

#endif

#ifndef CTHASH_VALUE_HPP
#define CTHASH_VALUE_HPP

#ifndef CTHASH_FIXED_STRING_HPP
#define CTHASH_FIXED_STRING_HPP

#include <algorithm>
#include <span>
#include <string_view>

namespace cthash {

template <typename CharT, size_t N> struct fixed_string: std::array<CharT, N> {
	using super = std::array<CharT, N>;

	consteval static auto from_string_literal(const CharT (&in)[N + 1]) -> std::array<CharT, N> {
		std::array<CharT, N> out;
		std::copy_n(in, N, out.data());
		return out;
	}

	explicit constexpr fixed_string(std::nullptr_t) noexcept: super{} { }

	consteval fixed_string(const CharT (&in)[N + 1]) noexcept: super{from_string_literal(in)} { }

	using super::data;
	using super::size;

	constexpr operator std::span<const CharT, N>() const noexcept {
		return std::span<const CharT, N>(data(), size());
	}

	constexpr operator std::span<const CharT>() const noexcept {
		return std::span<const CharT>(data(), size());
	}

	constexpr operator std::basic_string_view<CharT>() const noexcept {
		return std::basic_string_view<CharT>(data(), size());
	}

	constexpr friend bool operator==(const fixed_string &, const fixed_string &) noexcept = default;
	constexpr friend bool operator==(const fixed_string & lhs, std::basic_string_view<CharT> rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == rhs;
	}
	constexpr friend bool operator==(const fixed_string & lhs, const CharT * rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == std::basic_string_view<CharT>{rhs};
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N - 1>;

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_BASE_HPP
#define CTHASH_ENCODING_BASE_HPP

#ifndef CTHASH_ENCODING_CHUNK_OF_BITS_HPP
#define CTHASH_ENCODING_CHUNK_OF_BITS_HPP

#ifndef CTHASH_ENCODING_BIT_BUFFER_HPP
#define CTHASH_ENCODING_BIT_BUFFER_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <bit>
#include <iostream>
#include <numeric>
#include <ranges>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct select_bit_integer;

template <size_t Bits> requires(Bits <= 8) struct select_bit_integer<Bits> {
	using type = uint8_t;
};

template <size_t Bits> requires(Bits > 8 && Bits <= 16) struct select_bit_integer<Bits> {
	using type = uint16_t;
};

template <size_t Bits> requires(Bits > 16 && Bits <= 32) struct select_bit_integer<Bits> {
	using type = uint32_t;
};

template <size_t Bits> requires(Bits > 32 && Bits <= 64) struct select_bit_integer<Bits> {
	using type = uint64_t;
};

template <size_t Bits> using select_bit_integer_t = select_bit_integer<Bits>::type;

template <size_t V> requires(std::popcount(V) == 1u) constexpr auto log2_of_power_of_2 = static_cast<size_t>(std::countr_zero(V));

template <size_t Bits> constexpr auto mask = static_cast<select_bit_integer_t<Bits>>((static_cast<select_bit_integer_t<Bits>>(1u) << Bits) - 1u);

template <size_t Capacity> class basic_bit_buffer {
public:
	static constexpr auto capacity = std::integral_constant<size_t, Capacity>{};
	using storage_type = select_bit_integer_t<capacity()>;
	using size_type = select_bit_integer_t<log2_of_power_of_2<std::bit_ceil(capacity())>>;

public:
	storage_type buffer{0};
	size_type bits_available{0};

public:
	template <size_t Bits> static constexpr auto mask = static_cast<storage_type>((static_cast<storage_type>(1u) << Bits) - 1u);

	constexpr friend bool operator==(const basic_bit_buffer & lhs, const basic_bit_buffer & rhs) noexcept = default;

	constexpr size_type size() const noexcept {
		return bits_available;
	}

	constexpr size_type unused_size() const noexcept {
		return capacity() - bits_available;
	}

	constexpr bool empty() const noexcept {
		return bits_available == 0u;
	}

	constexpr bool full() const noexcept {
		return bits_available == capacity();
	}

	template <size_t Bits> constexpr void push(select_bit_integer_t<Bits> in) noexcept requires(Bits <= capacity()) {
		assert(size() <= capacity() - Bits);
		buffer = static_cast<storage_type>(buffer << Bits) | static_cast<storage_type>(in);
		bits_available += static_cast<size_type>(Bits);
	}
	constexpr void push_empty_bits(size_t count) noexcept {
		buffer = static_cast<storage_type>(buffer << count);
		bits_available += static_cast<unsigned char>(count);
	}

	template <size_t Bits> constexpr void pop() noexcept requires(Bits <= capacity()) {
		assert(size() >= Bits);
		bits_available -= static_cast<size_type>(Bits);
	}

	template <size_t Bits> constexpr auto front() const noexcept -> select_bit_integer_t<Bits> requires(Bits <= capacity()) {
		using output_type = select_bit_integer_t<Bits>;
		assert(size() >= static_cast<size_type>(Bits));
		return static_cast<output_type>((buffer >> (bits_available - Bits))) & mask<Bits>;
	}
};

constexpr size_t calculate_padding_bit_count(size_t number_of_bits_in_buffer, size_t output_size, size_t input_size) {
	size_t n = number_of_bits_in_buffer;
	size_t padding_bits = 0u;

	while (n != 0u) {
		padding_bits += input_size;
		n += input_size;

		while (n >= output_size) {
			n = n - output_size;
		}
	}

	return padding_bits;
}

template <size_t OutBits, size_t InBits = 8u> class bit_buffer: protected basic_bit_buffer<std::lcm(OutBits, InBits)> {
	using super = basic_bit_buffer<std::lcm(OutBits, InBits)>;

public:
	constexpr bit_buffer() noexcept = default;

	using typename super::size_type;
	static constexpr auto out_bits = std::integral_constant<size_type, OutBits>{};
	static constexpr auto in_bits = std::integral_constant<size_type, InBits>{};

	using out_type = select_bit_integer_t<OutBits>;
	using in_type = select_bit_integer_t<InBits>;

	using super::capacity;
	static constexpr auto in_capacity = std::integral_constant<size_type, (capacity() / in_bits())>{};
	static constexpr auto out_capacity = std::integral_constant<size_type, (capacity() / out_bits())>{};

	static constexpr auto aligned = std::bool_constant<capacity() == in_capacity()>{};

	constexpr void push(in_type in) noexcept {
		super::template push<in_bits>(in);
	}

	constexpr void push_empty() noexcept {
		this->push(in_type{0u});
	}

	constexpr size_type push_zeros_to_align() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_to_align() noexcept requires(!aligned()) {
		if (empty()) {
			return 0u;
		}

		assert(out_bits > super::size());
		const size_type missing_bits = static_cast<size_type>(out_bits - super::size());
		super::push_empty_bits(missing_bits);
		return missing_bits;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(!aligned()) {
		const size_type usable_bits = super::size();
		const size_type missing_bits = static_cast<size_type>(calculate_padding_bit_count(super::size(), out_bits, in_bits));
		super::push_empty_bits(missing_bits);
		return usable_bits;
	}

	constexpr void pop() noexcept {
		super::template pop<out_bits>();
	}

	constexpr auto front() const noexcept -> out_type {
		return super::template front<out_bits>();
	}

	constexpr size_type size() const noexcept {
		return static_cast<size_type>(super::size() / out_bits);
	}

	constexpr size_type unused_size() const noexcept {
		return static_cast<size_type>(super::unused_size() / in_bits);
	}

	using super::empty;
	using super::full;

	constexpr bool has_bits_for_pop() const noexcept {
		return super::size() >= out_bits;
	}

	constexpr bool has_capacity_for_push() const noexcept {
		return super::size() <= (capacity() - in_bits);
	}
};

} // namespace cthash

#endif

#include <iostream>
#include <ranges>

namespace cthash {

template <typename Buffer> struct buffer_result_type;

template <typename Buffer> requires(Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	static constexpr Buffer::size_type missing_bits = {0u};

	constexpr bool is_padding() const noexcept {
		return false;
	}
};

template <typename Buffer> requires(!Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	typename Buffer::size_type missing_bits;

	constexpr bool is_padding() const noexcept {
		return missing_bits == Buffer::out_bits;
	}
};

template <typename Buffer, bool AllowPadding> struct buffer_with_missing_bits;

template <typename Buffer, bool AllowPadding> requires(Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};

	struct result_type {
		typename Buffer::out_type value;
		static constexpr Buffer::size_type missing_bits = {0u};

		constexpr bool is_padding() const noexcept {
			return false;
		}
	};

	static constexpr bool aligned = Buffer::aligned();

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		return result_type{buffer.front()};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		while (!buffer.has_bits_for_pop() && (it != end)) {
			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <typename Buffer, bool AllowPadding> requires(!Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};
	Buffer::size_type missing_bits{0};

	static constexpr bool aligned = Buffer::aligned();

	struct result_type {
		typename Buffer::out_type value;
		typename Buffer::size_type missing_bits;

		constexpr bool is_padding() const noexcept {
			return missing_bits == Buffer::out_bits;
		}
	};

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		assert(Buffer::out_bits >= missing_bits);
		return result_type{buffer.front(), missing_bits};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	constexpr void pad_buffer() noexcept requires(AllowPadding) {
		// full multi-chunk padding (for baseN encodings)
		missing_bits = (Buffer::out_bits - buffer.push_zeros_for_padding());
	}

	constexpr void pad_buffer() noexcept requires(!AllowPadding) {
		// only add enough zero to finish current output chunk
		missing_bits = buffer.push_zeros_to_align();
	}

	constexpr void saturate_missing_bits() noexcept requires(AllowPadding) {
		if (missing_bits) {
			missing_bits = Buffer::out_bits;
		}
		// missing_bits = static_cast<buffer_size_t>((unsigned)(bool)missing_bits * output_value_bit_size);
	}

	constexpr void saturate_missing_bits() noexcept requires(!AllowPadding) {
		// do nothing :)
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		for (;;) {
			if (it == end) {
				if (buffer.has_bits_for_pop()) {
					// if this is second pass after padding we can mark all bits as missing
					saturate_missing_bits();
				} else {
					// fill remainder of buffer with zeros
					pad_buffer();
				}

				return;
			}

			if (buffer.has_bits_for_pop()) {
				return;
			}

			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <bool Value> struct conditional;

template <> struct conditional<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional<false> {
	template <typename, typename T> using type = T;
};

template <bool Const, typename T> using maybe_const = typename conditional<Const>::template type<const T, T>;

template <typename T> concept integral_like = std::integral<T> || std::same_as<std::byte, T>;

template <size_t Bits, bool AllowPadding, std::ranges::input_range Input> requires integral_like<std::ranges::range_value_t<Input>> struct chunk_of_bits_view {
	using input_value_type = std::ranges::range_value_t<Input>;

	static constexpr size_t output_value_bit_size = Bits;
	static constexpr size_t input_value_bit_size = sizeof(input_value_type) * 8u;
	using buffer_t = cthash::bit_buffer<output_value_bit_size, input_value_bit_size>;
	using buffer_size_t = buffer_t::size_type;
	Input input;

	static constexpr bool aligned = buffer_t::aligned;

	struct sentinel { };

	template <bool Const> struct iterator {
		using parent = maybe_const<Const, Input>;
		using storage_type = buffer_with_missing_bits<buffer_t, AllowPadding>;
		using value_type = storage_type::result_type;
		using difference_type = intptr_t;

		std::ranges::iterator_t<parent> it;
		[[no_unique_address]] std::ranges::sentinel_t<parent> end;

		storage_type buffer{};

		constexpr iterator(parent & p) noexcept: it{std::ranges::begin(p)}, end{std::ranges::end(p)} {
			// initialize
			buffer.feed_buffer(it, end);
		}

		iterator(const iterator &) = default;
		iterator(iterator &&) = default;

		iterator & operator=(const iterator &) = default;
		iterator & operator=(iterator &&) = default;

		constexpr iterator & operator++() noexcept {
			buffer.pop();
			buffer.feed_buffer(it, end);
			return *this;
		}

		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			this->operator++();
			return copy;
		}

		constexpr auto operator*() const noexcept {
			return buffer.front();
		}

		constexpr friend bool operator==(const iterator & lhs, const iterator & rhs) noexcept = default;

		constexpr friend bool operator==(const iterator & self, sentinel) noexcept {
			return self.buffer.empty();
		}
	};

	static_assert(std::input_iterator<iterator<true>>);
	static_assert(std::input_iterator<iterator<false>>);
	static_assert(std::sentinel_for<sentinel, iterator<true>>);
	static_assert(std::sentinel_for<sentinel, iterator<false>>);

	constexpr chunk_of_bits_view(Input _input) noexcept: input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input};
	}

	constexpr auto end() const noexcept {
		return sentinel{};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && AllowPadding) {
		// calculate with blocks
		return ((std::ranges::size(input) + (buffer_t::in_capacity() - 1u)) / buffer_t::in_capacity()) * buffer_t::out_capacity();
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && !AllowPadding) {
		// calculate with bits
		const size_t bit_size_of_input = std::ranges::size(input) * input_value_bit_size;
		return (bit_size_of_input + (output_value_bit_size - 1u)) / output_value_bit_size;
	}
};

template <size_t Bits, bool AllowPadding> struct chunk_of_bits_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, chunk_of_bits_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) {
		return chunk_of_bits_view<Bits, AllowPadding, R>(std::forward<R>(input));
	}
};

template <size_t Bits, bool AllowPadding = false> constexpr auto chunk_of_bits = chunk_of_bits_action<Bits, AllowPadding>{};

} // namespace cthash

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#include <bit>

namespace cthash {

template <typename Encoding> struct encoding_properties {
	static constexpr size_t size = std::size(Encoding::alphabet) - 1u;
	static_assert(std::popcount(size) == 1u, "Size of encoding's alphabet must be power-of-two");

	static constexpr size_t bits = std::countr_zero(size);

	static constexpr bool has_padding = padded_encoding<Encoding>;

	static constexpr char padding = [] {
		if constexpr (has_padding) {
			return Encoding::padding;
		} else {
			return '\0';
		}
	}();
};

template <typename Encoding, typename CharT, typename R> struct encode_to_view {
	using properties = encoding_properties<Encoding>;
	using chunk_view = cthash::chunk_of_bits_view<properties::bits, properties::has_padding, R>;

	struct sentinel {
		[[no_unique_address]] chunk_view::sentinel end;
	};

	template <bool Const> struct iterator {
		using difference_type = intptr_t;
		using value_type = CharT;

		chunk_view::template iterator<Const> it;

		constexpr iterator & operator++() noexcept {
			++it;
			return *this;
		}
		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			++it;
			return copy;
		}

		constexpr value_type operator*() const noexcept {
			const auto tmp = *it;
			if constexpr (!chunk_view::aligned) {
				// TODO: do without condition
				if (tmp.is_padding()) {
					return properties::padding;
				}
			}
			return static_cast<value_type>(Encoding::alphabet[static_cast<unsigned>(tmp.value)]);
		}

		constexpr friend bool operator==(const iterator &, const iterator &) noexcept = default;

		constexpr friend bool operator==(const iterator & lhs, const sentinel & rhs) noexcept {
			return lhs.it == rhs.end;
		}
	};

	chunk_view input;

	constexpr encode_to_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}

	constexpr auto to_string() const requires(std::ranges::sized_range<R>) {
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(*this);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(size());
		auto [i, o] = std::ranges::copy(begin(), end(), result.begin());
		assert(i == result.end());
		assert(o == result.end());
		return result;
#endif
	}

	constexpr friend std::basic_ostream<CharT> & operator<<(std::basic_ostream<CharT> & out, encode_to_view in) {
		std::ranges::copy(in.begin(), in.end(), std::ostream_iterator<CharT, CharT>(out));
		return out;
	}
};

template <typename Encoding, typename ValueT, typename R> struct decode_from_view {
	R input;

	template <bool Const> struct iterator { };
	struct sentinel { };

	constexpr decode_from_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}
};

template <typename Encoding, typename CharT = char> struct encode_to_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, encode_to_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return encode_to_view<Encoding, CharT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename ValueT = unsigned char> struct decode_from_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, decode_from_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return decode_from_view<Encoding, ValueT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename CharT = char> constexpr auto encode_to = encode_to_action<Encoding, CharT>{};
template <typename Encoding, typename ValueT = unsigned char> constexpr auto decode_from = decode_from_action<Encoding, ValueT>{};

constexpr auto binary_encode = encode_to<encoding::base2, char>;
constexpr auto base2_encode = encode_to<encoding::base2, char>;
constexpr auto base4_encode = encode_to<encoding::base4, char>;
constexpr auto base8_encode = encode_to<encoding::base8, char>;
constexpr auto octal_encode = encode_to<encoding::base8, char>;
constexpr auto hexdec_encode = encode_to<encoding::base16, char>;
constexpr auto hexdec_uppercase_encode = encode_to<encoding::base16_uppercase, char>;
constexpr auto base16_encode = encode_to<encoding::base16, char>;
constexpr auto base32_encode = encode_to<encoding::base32, char>;
constexpr auto base32_no_padding_encode = encode_to<encoding::base32_no_padding, char>;
constexpr auto z_base32_encode = encode_to<encoding::z_base32, char>;
constexpr auto base64_encode = encode_to<encoding::base64, char>;
constexpr auto base64url_encode = encode_to<encoding::base64url, char>;
constexpr auto base64_no_padding_encode = encode_to<encoding::base64_no_padding, char>;

constexpr auto binary_decode = decode_from<encoding::base2, char>;
constexpr auto base2_decode = decode_from<encoding::base2, char>;
constexpr auto base4_decode = decode_from<encoding::base4, char>;
constexpr auto base8_decode = decode_from<encoding::base8, char>;
constexpr auto hexdec_decode = decode_from<encoding::base16, char>;
constexpr auto base16_decode = decode_from<encoding::base16, char>;
constexpr auto base32_decode = decode_from<encoding::base32, char>;
constexpr auto z_base32_decode = decode_from<encoding::z_base32, char>;
constexpr auto base64_decode = decode_from<encoding::base64, char>;
constexpr auto base64url_decode = decode_from<encoding::base64url, char>;
constexpr auto base64_no_padding_decode = decode_from<encoding::base64_no_padding, char>;

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

// template <typename Encoding, typename CharT, typename R> struct encode_to_view

#ifdef CTHASH_STDFMT_AVAILABLE
template <typename Encoding, typename R, typename CharT>
struct formatter<cthash::encode_to_view<Encoding, CharT, R>, CharT> {
	using subject_type = cthash::encode_to_view<Encoding, CharT, R>;

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		return std::ranges::begin(ctx);
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return std::ranges::copy(value, ctx.out()).out;
	}
};

#endif

} // namespace std

#endif

#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_ALGORITHM_HPP
#define CTHASH_INTERNAL_ALGORITHM_HPP

#include <numeric>
#include <compare>
#include <cstddef>
#include <cstdint>

namespace cthash::internal {

template <typename It1, typename It2> constexpr auto threeway_compare_of_same_size(It1 lhs, It2 rhs, size_t length) -> std::strong_ordering {
	for (size_t i = 0; i != length; ++i) {
		if (const auto r = (*lhs++ <=> *rhs++); std::is_neq(r)) {
			return r;
		}
	}

	return std::strong_ordering::equal;
}

template <typename T, typename It1, typename It2, typename Stream> constexpr auto & push_to_stream_as(It1 f, It2 l, Stream & stream) {
	constexpr auto cast_and_shift = [](Stream * s, const auto & rhs) { (*s) << T{rhs}; return s; };
	return *std::accumulate(f, l, &stream, cast_and_shift);
}

} // namespace cthash::internal

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#ifndef CTHASH_INTERNAL_HEXDEC_HPP
#define CTHASH_INTERNAL_HEXDEC_HPP

#include <array>
#include <ostream>
#include <span>
#include <type_traits>
#include <cstdint>

namespace cthash::internal {

consteval auto get_hexdec_table() noexcept {
	std::array<uint8_t, 128> result;

	auto char_to_hexdec = [](char c) {
		if (c >= '0' && c <= '9') {
			return static_cast<uint8_t>(c - '0');
		} else if (c >= 'a' && c <= 'f') {
			return static_cast<uint8_t>(c - 'a' + 10);
		} else if (c >= 'A' && c <= 'F') {
			return static_cast<uint8_t>(c - 'A' + 10);
		} else {
			return static_cast<uint8_t>(0);
		}
	};

	for (size_t i = 0; i != result.size(); ++i) {
		result[i] = char_to_hexdec(static_cast<char>(i));
	}

	return result;
}

constexpr auto hexdec_to_value_alphabet = get_hexdec_table();

template <typename CharT> constexpr auto value_to_hexdec_alphabet = std::array<CharT, 16>{CharT('0'), CharT('1'), CharT('2'), CharT('3'), CharT('4'), CharT('5'), CharT('6'), CharT('7'), CharT('8'), CharT('9'), CharT('a'), CharT('b'), CharT('c'), CharT('d'), CharT('e'), CharT('f')};

struct byte_hexdec_value {
	std::byte val;

	template <typename CharT, typename Traits> friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, byte_hexdec_value rhs) {
		return os << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val >> 4u)] << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val) & 0b1111u];
	}
};

template <size_t N, typename CharT> constexpr auto hexdec_to_binary(std::span<const CharT, N * 2> in) -> std::array<std::byte, N> {
	return [in]<size_t... Idx>(std::index_sequence<Idx...>) {
		return std::array<std::byte, N>{static_cast<std::byte>(hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2]) & 0b0111'1111u] << 4u | hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2u + 1u]) & 0b0111'1111u])...};
	}(std::make_index_sequence<N>());
}

template <typename CharT, size_t N>
requires((N - 1) % 2 == 0) // -1 because of zero terminator in literals
constexpr auto literal_hexdec_to_binary(const CharT (&in)[N]) -> std::array<std::byte, (N - 1) / 2> {
	return hexdec_to_binary<N / 2>(std::span<const char, N - 1>(in, N - 1));
}

} // namespace cthash::internal

#endif

#include <algorithm>
#include <array>
#include <format>
#include <span>
#include <string_view>
#include <compare>

namespace cthash {

// hash_value

template <size_t N> struct hash_value: std::array<std::byte, N> {
	using super = std::array<std::byte, N>;

	constexpr hash_value() noexcept: super{} { }
	explicit constexpr hash_value(super && s) noexcept: super(s) { }
	template <typename CharT> explicit constexpr hash_value(const CharT (&in)[N * 2u + 1u]) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in, N * 2u))} { }
	template <typename CharT> explicit constexpr hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in.data(), in.size()))} { }

	// comparison support
	constexpr friend bool operator==(const hash_value & lhs, const hash_value & rhs) noexcept = default;
	constexpr friend auto operator<=>(const hash_value & lhs, const hash_value & rhs) noexcept -> std::strong_ordering {
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), N);
	}

	template <typename Encoding = cthash::encoding::hexdec, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		auto hexdec_view = *this | cthash::encode_to<Encoding, CharT>;
		std::ranges::copy(hexdec_view, std::ostream_iterator<CharT, CharT>(os));
		return os;
	}

	// print to ostream support
	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const hash_value & val) {
		return val.print_into(os);
	}

	template <size_t PrefixN> constexpr auto prefix() const noexcept requires(PrefixN <= N) {
		hash_value<PrefixN> output{};
		std::ranges::copy(this->begin(), this->begin() + PrefixN, output.begin());
		return output;
	}

	template <size_t SuffixN> constexpr auto suffix() const noexcept requires(SuffixN <= N) {
		hash_value<SuffixN> output{};
		std::ranges::copy(this->end() - SuffixN, this->end(), output.begin());
		return output;
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(encoded);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(encoded.size());
		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());
		return result;
#endif
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_fixed_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
		// it's type dependendent so we can calculate the size...
		constexpr size_t size_needed = (hash_value{} | cthash::encode_to<Encoding, CharT>).size();

		auto result = cthash::fixed_string<CharT, size_needed>{nullptr};

		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());

		return result;
	}
};

template <typename CharT, size_t N> hash_value(const CharT (&)[N]) -> hash_value<(N - 1u) / 2u>;
template <typename CharT, size_t N> hash_value(std::span<const CharT, N>) -> hash_value<N / 2u>;
template <typename CharT, size_t N> hash_value(const fixed_string<CharT, N> &) -> hash_value<N / 2u>;

template <typename> struct default_encoding {
	using encoding = cthash::encoding::hexdec;
};

template <typename Tag> concept tag_with_encoding = requires() {
	typename Tag::encoding;
};

template <tag_with_encoding Tag> struct default_encoding<Tag> {
	using encoding = Tag::encoding;
};

template <typename Tag, size_t = internal::digest_bytes_length_of<Tag>> struct tagged_hash_value: hash_value<internal::digest_bytes_length_of<Tag>> {
	static constexpr size_t N = internal::digest_bytes_length_of<Tag>;

	using super = hash_value<N>;
	using super::super;
	template <typename CharT> explicit constexpr tagged_hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{in} { }

	static constexpr size_t digest_length = N;

	template <typename Encoding = default_encoding<Tag>::encoding, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		return super::template print_into<Encoding>(os);
	}

	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const tagged_hash_value & val) {
		return val.print_into(os);
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_string(const tagged_hash_value & value) {
		return to_string<Encoding, CharT>(static_cast<const super &>(value));
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_fixed_string(const tagged_hash_value & value) {
		return to_fixed_string<Encoding, CharT>(static_cast<const super &>(value));
	}
};

template <typename T> concept variable_digest_length = T::digest_length_bit == 0u;

template <size_t N, variable_digest_length Tag> struct variable_bit_length_tag: Tag {
	static constexpr size_t digest_length_bit = N;
};

template <typename T> concept convertible_to_tagged_hash_value = requires(const T & obj) {
	{ tagged_hash_value{obj} };
};

namespace literals {

	template <fixed_string Value>
	constexpr auto operator""_hash() {
		return hash_value(Value);
	}

} // namespace literals

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#if _LIBCPP_VERSION >= 170000
// libc++ will define __cpp_lib_format macro in 19.0
// https://github.com/llvm/llvm-project/issues/77773
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#ifdef CTHASH_STDFMT_AVAILABLE
template <size_t N, typename CharT>
struct formatter<cthash::hash_value<N>, CharT> {
	using subject_type = cthash::hash_value<N>;
	using default_encoding = cthash::encoding::hexdec;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <typename Tag, size_t N, typename CharT>
struct formatter<cthash::tagged_hash_value<Tag, N>, CharT> {
	using subject_type = cthash::tagged_hash_value<Tag, N>;
	using default_encoding = typename cthash::default_encoding<Tag>::encoding;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <cthash::convertible_to_tagged_hash_value Type, typename CharT> struct formatter<Type, CharT>: formatter<decltype(cthash::tagged_hash_value{std::declval<Type>()}), CharT> {
};

#endif

} // namespace std

#endif

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_CONVERT_HPP
#define CTHASH_INTERNAL_CONVERT_HPP

#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

#include <span>
#include <type_traits>
#include <cstddef>
#include <cstdint>
#include <cstring>

namespace cthash {

template <typename It1, typename It2, typename It3> constexpr auto byte_copy(It1 first, It2 last, It3 destination) {
	return std::transform(first, last, destination, [](byte_like auto v) { return static_cast<std::byte>(v); });
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << ((sizeof(T) - 1u - Idx) * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::little) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_le_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << static_cast<T>(Idx * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::big) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T> struct unwrap_littleendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> (Idx * 8u))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_littleendian_number(std::span<std::byte, 8>) -> unwrap_littleendian_number<uint64_t>;
unwrap_littleendian_number(std::span<std::byte, 4>) -> unwrap_littleendian_number<uint32_t>;

template <std::unsigned_integral T> struct unwrap_bigendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> ((bits - 8u) - 8u * Idx))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_bigendian_number(std::span<std::byte, 8>) -> unwrap_bigendian_number<uint64_t>;
unwrap_bigendian_number(std::span<std::byte, 4>) -> unwrap_bigendian_number<uint32_t>;

} // namespace cthash

#endif

#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
#include <array>
#include <span>
#include <string_view>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct xxhash_types;

template <std::unsigned_integral T, byte_like Byte> constexpr auto read_le_number_from(std::span<const Byte> & input) noexcept {
	assert(input.size() >= sizeof(T));

	const auto r = cast_from_le_bytes<T>(input.template first<sizeof(T)>());
	input = input.subspan(sizeof(T));

	return r;
}

template <std::unsigned_integral T, size_t Off, byte_like Byte, size_t N> constexpr auto get_le_number_from(std::span<const Byte, N> input) noexcept {
	return cast_from_le_bytes<T>(input.template subspan<Off * sizeof(T), sizeof(T)>());
}

template <> struct xxhash_types<32> {
	using value_type = uint32_t;
	using acc_array = std::array<value_type, 4>;
	static constexpr auto primes = std::array<value_type, 5>{2654435761U, 2246822519U, 3266489917U, 668265263U, 374761393U};

	static constexpr auto round(value_type accN, value_type laneN) noexcept -> value_type {
		return std::rotl(accN + (laneN * primes[1]), 13u) * primes[0];
	}

	static constexpr auto convergence(const acc_array & accs) noexcept -> value_type {
		return std::rotl(accs[0], 1u) + std::rotl(accs[1], 7u) + std::rotl(accs[2], 12u) + std::rotl(accs[3], 18u);
	}

	template <byte_like Byte> static constexpr auto consume_remaining(value_type acc, std::span<const Byte> input) noexcept -> value_type {
		assert(input.size() < sizeof(acc_array));

		while (input.size() >= sizeof(uint32_t)) {
			const auto lane = read_le_number_from<uint32_t>(input);
			acc = std::rotl(acc + (lane * primes[2]), 17u) * primes[3];
		}

		while (input.size() >= 1u) {
			const auto lane = read_le_number_from<uint8_t>(input);
			acc = std::rotl(acc + lane * primes[4], 11u) * primes[0];
		}

		return acc;
	}

	static constexpr auto avalanche(value_type acc) noexcept -> value_type {
		acc = (acc xor (acc >> 15u)) * primes[1];
		acc = (acc xor (acc >> 13u)) * primes[2];
		return (acc xor (acc >> 16u));
	}
};

template <> struct xxhash_types<64> {
	using value_type = uint64_t;
	using acc_array = std::array<value_type, 4>;
	static constexpr auto primes = std::array<value_type, 5>{11400714785074694791ULL, 14029467366897019727ULL, 1609587929392839161ULL, 9650029242287828579ULL, 2870177450012600261ULL};

	static constexpr auto round(value_type accN, value_type laneN) noexcept -> value_type {
		return std::rotl(accN + (laneN * primes[1]), 31u) * primes[0];
	}

	static constexpr auto convergence(const acc_array & accs) noexcept -> value_type {
		constexpr auto merge = [](value_type acc, value_type accN) {
			return ((acc xor round(0, accN)) * primes[0]) + primes[3];
		};

		value_type acc = std::rotl(accs[0], 1u) + std::rotl(accs[1], 7u) + std::rotl(accs[2], 12u) + std::rotl(accs[3], 18u);
		acc = merge(acc, accs[0]);
		acc = merge(acc, accs[1]);
		acc = merge(acc, accs[2]);
		return merge(acc, accs[3]);
	}

	template <byte_like Byte> static constexpr auto consume_remaining(value_type acc, std::span<const Byte> input) noexcept -> value_type {
		assert(input.size() < sizeof(acc_array));

		while (input.size() >= sizeof(uint64_t)) {
			const auto lane = read_le_number_from<uint64_t>(input);
			acc = (std::rotl(acc xor round(0, lane), 27u) * primes[0]) + primes[3];
		}

		if (input.size() >= sizeof(uint32_t)) {
			const auto lane = read_le_number_from<uint32_t>(input);
			acc = (std::rotl(acc xor (lane * primes[0]), 23u) * primes[1]) + primes[2];
		}

		while (input.size() >= 1u) {
			const auto lane = read_le_number_from<uint8_t>(input);
			acc = (std::rotl(acc xor (lane * primes[4]), 11u) * primes[0]);
		}

		return acc;
	}

	static constexpr auto avalanche(value_type acc) noexcept -> value_type {
		acc = (acc xor (acc >> 33u)) * primes[1];
		acc = (acc xor (acc >> 29u)) * primes[2];
		return (acc xor (acc >> 32u));
	}
};

template <size_t Bits> struct xxhash {
	static_assert(Bits == 32u || Bits == 64u);

	struct tag {
		static constexpr size_t digest_length = Bits / 8u;
	};

	using config = xxhash_types<Bits>;
	using acc_array = typename config::acc_array;
	using value_type = typename config::value_type;

	using digest_span_t = std::span<std::byte, Bits / 8u>;

	// members
	value_type seed{0u};
	value_type length{0u};
	acc_array internal_state{};
	std::array<std::byte, sizeof(value_type) * 4u> buffer{};

	// step 1 in constructor
	explicit constexpr xxhash(value_type s = 0u) noexcept: seed{s}, internal_state{seed + config::primes[0] + config::primes[1], seed + config::primes[1], seed, seed - config::primes[0]} { }

	template <byte_like Byte> constexpr void process_lanes(std::span<const Byte, sizeof(acc_array)> lanes) noexcept {
		// step 2: process lanes
		internal_state[0] = config::round(internal_state[0], get_le_number_from<value_type, 0>(lanes));
		internal_state[1] = config::round(internal_state[1], get_le_number_from<value_type, 1>(lanes));
		internal_state[2] = config::round(internal_state[2], get_le_number_from<value_type, 2>(lanes));
		internal_state[3] = config::round(internal_state[3], get_le_number_from<value_type, 3>(lanes));
	}

	constexpr size_t buffer_usage() const noexcept {
		return length % buffer.size();
	}

	template <byte_like Byte> constexpr void process_blocks(std::span<const Byte> & input) noexcept {
		while (input.size() >= buffer.size()) {
			const auto current_lanes = input.template first<sizeof(acc_array)>();
			input = input.subspan(buffer.size());

			process_lanes(current_lanes);
		}
	}

	template <byte_like Byte> [[gnu::flatten]] constexpr xxhash & update(std::span<const Byte> input) noexcept {
		const auto buffer_remaining = std::span(buffer).subspan(buffer_usage());

		// everything we insert here is counting as part of input (even if we process it later)
		length += static_cast<uint8_t>(input.size());

		// if there is remaining data from previous...
		if (buffer_remaining.size() != buffer.size()) {
			const auto to_copy = input.first(std::min(input.size(), buffer_remaining.size()));
			byte_copy(to_copy.begin(), to_copy.end(), buffer_remaining.begin());
			input = input.subspan(to_copy.size());

			// if we didn't fill current block, we will do it later
			if (buffer_remaining.size() != to_copy.size()) {
				assert(input.size() == 0u);
				return *this;
			}

			// but if we did, we need to process it
			const auto full_buffer_view = std::span<const std::byte, sizeof(acc_array)>(buffer);
			process_lanes(full_buffer_view);
		}

		// process blocks
		process_blocks(input);

		// copy remainder of input to the buffer, so it's processed later
		byte_copy(input.begin(), input.end(), buffer.begin());
		return *this;
	}

	template <one_byte_char CharT> [[gnu::flatten]] constexpr xxhash & update(std::basic_string_view<CharT> input) noexcept {
		return update(std::span<const CharT>(input.data(), input.size()));
	}

	template <string_literal T> [[gnu::flatten]] constexpr xxhash & update(const T & input) noexcept {
		return update(std::span(std::data(input), std::size(input) - 1u));
	}

	// TODO: any range with value convertible to byte

	template <byte_like Byte> [[gnu::flatten]] constexpr auto update_and_final(std::span<const Byte> input) noexcept {
		length = static_cast<value_type>(input.size());
		process_blocks(input);
		tagged_hash_value<tag> output;
		final_from(input, output);
		return output;
	}

	template <one_byte_char CharT> [[gnu::flatten]] constexpr auto update_and_final(std::basic_string_view<CharT> input) noexcept {
		return update_and_final(std::span<const CharT>(input.data(), input.size()));
	}

	template <string_literal T> [[gnu::flatten]] constexpr auto update_and_final(const T & input) noexcept {
		return update_and_final(std::span(std::data(input), std::size(input) - 1u));
	}

	constexpr auto converge_conditionaly() const noexcept -> value_type {
		// step 1 shortcut for short input
		if (length < buffer.size()) {
			return seed + config::primes[4];
		}

		// otherwise we need to merge&converge internal state
		return config::convergence(internal_state);
	}

	template <byte_like Byte> constexpr void final_from(std::span<const Byte> source, digest_span_t out) const noexcept {
		assert(source.size() < buffer.size());

		value_type acc = converge_conditionaly();

		// step 4: add input length
		acc += static_cast<value_type>(length);

		// step 5: consume remainder (not finished block from buffer)
		acc = config::consume_remaining(acc, source);

		// step 6: final mix/avalanche
		acc = config::avalanche(acc);

		// convert to big endian representation
		unwrap_bigendian_number<value_type>{out} = acc;
	}

	[[gnu::flatten]] constexpr void final(digest_span_t out) const noexcept {
		const auto buffer_used = std::span<const std::byte>(buffer).first(buffer_usage());
		final_from(buffer_used, out);
	}

	[[gnu::flatten]] constexpr auto final() const noexcept -> tagged_hash_value<tag> {
		tagged_hash_value<tag> output;
		this->final(output);
		return output;
	}
};

using xxhash32 = cthash::xxhash<32>;
using xxhash32_value = tagged_hash_value<xxhash32::tag>;

using xxhash64 = cthash::xxhash<64>;
using xxhash64_value = tagged_hash_value<xxhash64::tag>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_xxh32() {
		return xxhash32_value(Value);
	}

	template <fixed_string Value>
	consteval auto operator""_xxh64() {
		return xxhash64_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

#endif

```

`include/cthash/cthash.hpp`:

```hpp
#ifndef CTHASH_CTHASH_HPP
#define CTHASH_CTHASH_HPP

// SHA-2 family
#include "sha2/sha224.hpp"
#include "sha2/sha256.hpp"
#include "sha2/sha384.hpp"
#include "sha2/sha512.hpp"
#include "sha2/sha512/t.hpp"

// SHA-3 (keccak) family
#include "sha3/keccak.hpp"
#include "sha3/sha3.hpp"
#include "sha3/shake128.hpp"
#include "sha3/shake256.hpp"

// xxhash (non-crypto fast hash)
#include "xxhash.hpp"

#endif

```

`include/cthash/encoding/base.hpp`:

```hpp
#ifndef CTHASH_ENCODING_BASE_HPP
#define CTHASH_ENCODING_BASE_HPP

#include "chunk-of-bits.hpp"
#include "encodings.hpp"
#include <bit>

namespace cthash {

template <typename Encoding> struct encoding_properties {
	static constexpr size_t size = std::size(Encoding::alphabet) - 1u;
	static_assert(std::popcount(size) == 1u, "Size of encoding's alphabet must be power-of-two");

	static constexpr size_t bits = std::countr_zero(size);

	static constexpr bool has_padding = padded_encoding<Encoding>;

	static constexpr char padding = [] {
		if constexpr (has_padding) {
			return Encoding::padding;
		} else {
			return '\0';
		}
	}();
};

template <typename Encoding, typename CharT, typename R> struct encode_to_view {
	using properties = encoding_properties<Encoding>;
	using chunk_view = cthash::chunk_of_bits_view<properties::bits, properties::has_padding, R>;

	struct sentinel {
		[[no_unique_address]] chunk_view::sentinel end;
	};

	template <bool Const> struct iterator {
		using difference_type = intptr_t;
		using value_type = CharT;

		chunk_view::template iterator<Const> it;

		constexpr iterator & operator++() noexcept {
			++it;
			return *this;
		}
		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			++it;
			return copy;
		}

		constexpr value_type operator*() const noexcept {
			const auto tmp = *it;
			if constexpr (!chunk_view::aligned) {
				// TODO: do without condition
				if (tmp.is_padding()) {
					return properties::padding;
				}
			}
			return static_cast<value_type>(Encoding::alphabet[static_cast<unsigned>(tmp.value)]);
		}

		constexpr friend bool operator==(const iterator &, const iterator &) noexcept = default;

		constexpr friend bool operator==(const iterator & lhs, const sentinel & rhs) noexcept {
			return lhs.it == rhs.end;
		}
	};

	chunk_view input;

	constexpr encode_to_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}

	constexpr auto to_string() const requires(std::ranges::sized_range<R>) {
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(*this);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(size());
		auto [i, o] = std::ranges::copy(begin(), end(), result.begin());
		assert(i == result.end());
		assert(o == result.end());
		return result;
#endif
	}

	constexpr friend std::basic_ostream<CharT> & operator<<(std::basic_ostream<CharT> & out, encode_to_view in) {
		std::ranges::copy(in.begin(), in.end(), std::ostream_iterator<CharT, CharT>(out));
		return out;
	}
};

template <typename Encoding, typename ValueT, typename R> struct decode_from_view {
	R input;

	template <bool Const> struct iterator { };
	struct sentinel { };

	constexpr decode_from_view(R _input): input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input.begin()};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input.begin()};
	}

	constexpr auto end() const noexcept {
		return sentinel{input.end()};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<R>) {
		return input.size();
	}
};

template <typename Encoding, typename CharT = char> struct encode_to_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, encode_to_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return encode_to_view<Encoding, CharT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename ValueT = unsigned char> struct decode_from_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, decode_from_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) const {
		return decode_from_view<Encoding, ValueT, R>(std::forward<R>(input));
	}
};

template <typename Encoding, typename CharT = char> constexpr auto encode_to = encode_to_action<Encoding, CharT>{};
template <typename Encoding, typename ValueT = unsigned char> constexpr auto decode_from = decode_from_action<Encoding, ValueT>{};

constexpr auto binary_encode = encode_to<encoding::base2, char>;
constexpr auto base2_encode = encode_to<encoding::base2, char>;
constexpr auto base4_encode = encode_to<encoding::base4, char>;
constexpr auto base8_encode = encode_to<encoding::base8, char>;
constexpr auto octal_encode = encode_to<encoding::base8, char>;
constexpr auto hexdec_encode = encode_to<encoding::base16, char>;
constexpr auto hexdec_uppercase_encode = encode_to<encoding::base16_uppercase, char>;
constexpr auto base16_encode = encode_to<encoding::base16, char>;
constexpr auto base32_encode = encode_to<encoding::base32, char>;
constexpr auto base32_no_padding_encode = encode_to<encoding::base32_no_padding, char>;
constexpr auto z_base32_encode = encode_to<encoding::z_base32, char>;
constexpr auto base64_encode = encode_to<encoding::base64, char>;
constexpr auto base64url_encode = encode_to<encoding::base64url, char>;
constexpr auto base64_no_padding_encode = encode_to<encoding::base64_no_padding, char>;

constexpr auto binary_decode = decode_from<encoding::base2, char>;
constexpr auto base2_decode = decode_from<encoding::base2, char>;
constexpr auto base4_decode = decode_from<encoding::base4, char>;
constexpr auto base8_decode = decode_from<encoding::base8, char>;
constexpr auto hexdec_decode = decode_from<encoding::base16, char>;
constexpr auto base16_decode = decode_from<encoding::base16, char>;
constexpr auto base32_decode = decode_from<encoding::base32, char>;
constexpr auto z_base32_decode = decode_from<encoding::z_base32, char>;
constexpr auto base64_decode = decode_from<encoding::base64, char>;
constexpr auto base64url_decode = decode_from<encoding::base64url, char>;
constexpr auto base64_no_padding_decode = decode_from<encoding::base64_no_padding, char>;

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

// template <typename Encoding, typename CharT, typename R> struct encode_to_view

#ifdef CTHASH_STDFMT_AVAILABLE
template <typename Encoding, typename R, typename CharT>
struct formatter<cthash::encode_to_view<Encoding, CharT, R>, CharT> {
	using subject_type = cthash::encode_to_view<Encoding, CharT, R>;

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		return std::ranges::begin(ctx);
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return std::ranges::copy(value, ctx.out()).out;
	}
};

#endif

} // namespace std

#endif

```

`include/cthash/encoding/bit-buffer.hpp`:

```hpp
#ifndef CTHASH_ENCODING_BIT_BUFFER_HPP
#define CTHASH_ENCODING_BIT_BUFFER_HPP

#include "concepts.hpp"
#include <bit>
#include <iostream>
#include <numeric>
#include <ranges>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct select_bit_integer;

template <size_t Bits> requires(Bits <= 8) struct select_bit_integer<Bits> {
	using type = uint8_t;
};

template <size_t Bits> requires(Bits > 8 && Bits <= 16) struct select_bit_integer<Bits> {
	using type = uint16_t;
};

template <size_t Bits> requires(Bits > 16 && Bits <= 32) struct select_bit_integer<Bits> {
	using type = uint32_t;
};

template <size_t Bits> requires(Bits > 32 && Bits <= 64) struct select_bit_integer<Bits> {
	using type = uint64_t;
};

template <size_t Bits> using select_bit_integer_t = select_bit_integer<Bits>::type;

template <size_t V> requires(std::popcount(V) == 1u) constexpr auto log2_of_power_of_2 = static_cast<size_t>(std::countr_zero(V));

template <size_t Bits> constexpr auto mask = static_cast<select_bit_integer_t<Bits>>((static_cast<select_bit_integer_t<Bits>>(1u) << Bits) - 1u);

template <size_t Capacity> class basic_bit_buffer {
public:
	static constexpr auto capacity = std::integral_constant<size_t, Capacity>{};
	using storage_type = select_bit_integer_t<capacity()>;
	using size_type = select_bit_integer_t<log2_of_power_of_2<std::bit_ceil(capacity())>>;

public:
	storage_type buffer{0};
	size_type bits_available{0};

public:
	template <size_t Bits> static constexpr auto mask = static_cast<storage_type>((static_cast<storage_type>(1u) << Bits) - 1u);

	constexpr friend bool operator==(const basic_bit_buffer & lhs, const basic_bit_buffer & rhs) noexcept = default;

	constexpr size_type size() const noexcept {
		return bits_available;
	}

	constexpr size_type unused_size() const noexcept {
		return capacity() - bits_available;
	}

	constexpr bool empty() const noexcept {
		return bits_available == 0u;
	}

	constexpr bool full() const noexcept {
		return bits_available == capacity();
	}

	template <size_t Bits> constexpr void push(select_bit_integer_t<Bits> in) noexcept requires(Bits <= capacity()) {
		assert(size() <= capacity() - Bits);
		buffer = static_cast<storage_type>(buffer << Bits) | static_cast<storage_type>(in);
		bits_available += static_cast<size_type>(Bits);
	}
	constexpr void push_empty_bits(size_t count) noexcept {
		buffer = static_cast<storage_type>(buffer << count);
		bits_available += static_cast<unsigned char>(count);
	}

	template <size_t Bits> constexpr void pop() noexcept requires(Bits <= capacity()) {
		assert(size() >= Bits);
		bits_available -= static_cast<size_type>(Bits);
	}

	template <size_t Bits> constexpr auto front() const noexcept -> select_bit_integer_t<Bits> requires(Bits <= capacity()) {
		using output_type = select_bit_integer_t<Bits>;
		assert(size() >= static_cast<size_type>(Bits));
		return static_cast<output_type>((buffer >> (bits_available - Bits))) & mask<Bits>;
	}
};

constexpr size_t calculate_padding_bit_count(size_t number_of_bits_in_buffer, size_t output_size, size_t input_size) {
	size_t n = number_of_bits_in_buffer;
	size_t padding_bits = 0u;

	while (n != 0u) {
		padding_bits += input_size;
		n += input_size;

		while (n >= output_size) {
			n = n - output_size;
		}
	}

	return padding_bits;
}

template <size_t OutBits, size_t InBits = 8u> class bit_buffer: protected basic_bit_buffer<std::lcm(OutBits, InBits)> {
	using super = basic_bit_buffer<std::lcm(OutBits, InBits)>;

public:
	constexpr bit_buffer() noexcept = default;

	using typename super::size_type;
	static constexpr auto out_bits = std::integral_constant<size_type, OutBits>{};
	static constexpr auto in_bits = std::integral_constant<size_type, InBits>{};

	using out_type = select_bit_integer_t<OutBits>;
	using in_type = select_bit_integer_t<InBits>;

	using super::capacity;
	static constexpr auto in_capacity = std::integral_constant<size_type, (capacity() / in_bits())>{};
	static constexpr auto out_capacity = std::integral_constant<size_type, (capacity() / out_bits())>{};

	static constexpr auto aligned = std::bool_constant<capacity() == in_capacity()>{};

	constexpr void push(in_type in) noexcept {
		super::template push<in_bits>(in);
	}

	constexpr void push_empty() noexcept {
		this->push(in_type{0u});
	}

	constexpr size_type push_zeros_to_align() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(aligned()) {
		return 0u;
	}

	constexpr size_type push_zeros_to_align() noexcept requires(!aligned()) {
		if (empty()) {
			return 0u;
		}

		assert(out_bits > super::size());
		const size_type missing_bits = static_cast<size_type>(out_bits - super::size());
		super::push_empty_bits(missing_bits);
		return missing_bits;
	}

	constexpr size_type push_zeros_for_padding() noexcept requires(!aligned()) {
		const size_type usable_bits = super::size();
		const size_type missing_bits = static_cast<size_type>(calculate_padding_bit_count(super::size(), out_bits, in_bits));
		super::push_empty_bits(missing_bits);
		return usable_bits;
	}

	constexpr void pop() noexcept {
		super::template pop<out_bits>();
	}

	constexpr auto front() const noexcept -> out_type {
		return super::template front<out_bits>();
	}

	constexpr size_type size() const noexcept {
		return static_cast<size_type>(super::size() / out_bits);
	}

	constexpr size_type unused_size() const noexcept {
		return static_cast<size_type>(super::unused_size() / in_bits);
	}

	using super::empty;
	using super::full;

	constexpr bool has_bits_for_pop() const noexcept {
		return super::size() >= out_bits;
	}

	constexpr bool has_capacity_for_push() const noexcept {
		return super::size() <= (capacity() - in_bits);
	}
};

} // namespace cthash

#endif

```

`include/cthash/encoding/chunk-of-bits.hpp`:

```hpp
#ifndef CTHASH_ENCODING_CHUNK_OF_BITS_HPP
#define CTHASH_ENCODING_CHUNK_OF_BITS_HPP

#include "bit-buffer.hpp"
#include <iostream>
#include <ranges>

namespace cthash {

template <typename Buffer> struct buffer_result_type;

template <typename Buffer> requires(Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	static constexpr Buffer::size_type missing_bits = {0u};

	constexpr bool is_padding() const noexcept {
		return false;
	}
};

template <typename Buffer> requires(!Buffer::aligned()) struct buffer_result_type<Buffer> {
	typename Buffer::out_type value;
	typename Buffer::size_type missing_bits;

	constexpr bool is_padding() const noexcept {
		return missing_bits == Buffer::out_bits;
	}
};

template <typename Buffer, bool AllowPadding> struct buffer_with_missing_bits;

template <typename Buffer, bool AllowPadding> requires(Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};

	struct result_type {
		typename Buffer::out_type value;
		static constexpr Buffer::size_type missing_bits = {0u};

		constexpr bool is_padding() const noexcept {
			return false;
		}
	};

	static constexpr bool aligned = Buffer::aligned();

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		return result_type{buffer.front()};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		while (!buffer.has_bits_for_pop() && (it != end)) {
			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <typename Buffer, bool AllowPadding> requires(!Buffer::aligned()) struct buffer_with_missing_bits<Buffer, AllowPadding> {
	Buffer buffer{};
	Buffer::size_type missing_bits{0};

	static constexpr bool aligned = Buffer::aligned();

	struct result_type {
		typename Buffer::out_type value;
		typename Buffer::size_type missing_bits;

		constexpr bool is_padding() const noexcept {
			return missing_bits == Buffer::out_bits;
		}
	};

	constexpr friend bool operator==(const buffer_with_missing_bits & lhs, const buffer_with_missing_bits & rhs) noexcept = default;

	constexpr auto front() const noexcept {
		assert(Buffer::out_bits >= missing_bits);
		return result_type{buffer.front(), missing_bits};
	}

	constexpr bool empty() const noexcept {
		return buffer.empty();
	}

	constexpr void pop() noexcept {
		return buffer.pop();
	}

	constexpr void pad_buffer() noexcept requires(AllowPadding) {
		// full multi-chunk padding (for baseN encodings)
		missing_bits = (Buffer::out_bits - buffer.push_zeros_for_padding());
	}

	constexpr void pad_buffer() noexcept requires(!AllowPadding) {
		// only add enough zero to finish current output chunk
		missing_bits = buffer.push_zeros_to_align();
	}

	constexpr void saturate_missing_bits() noexcept requires(AllowPadding) {
		if (missing_bits) {
			missing_bits = Buffer::out_bits;
		}
		// missing_bits = static_cast<buffer_size_t>((unsigned)(bool)missing_bits * output_value_bit_size);
	}

	constexpr void saturate_missing_bits() noexcept requires(!AllowPadding) {
		// do nothing :)
	}

	template <typename It, typename End> constexpr void feed_buffer(It & it, End end) noexcept {
		using input_value_type = std::iterator_traits<It>::value_type;

		for (;;) {
			if (it == end) {
				if (buffer.has_bits_for_pop()) {
					// if this is second pass after padding we can mark all bits as missing
					saturate_missing_bits();
				} else {
					// fill remainder of buffer with zeros
					pad_buffer();
				}

				return;
			}

			if (buffer.has_bits_for_pop()) {
				return;
			}

			buffer.push(static_cast<std::make_unsigned_t<input_value_type>>(*it));
			++it;
		}
	}
};

template <bool Value> struct conditional;

template <> struct conditional<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional<false> {
	template <typename, typename T> using type = T;
};

template <bool Const, typename T> using maybe_const = typename conditional<Const>::template type<const T, T>;

template <typename T> concept integral_like = std::integral<T> || std::same_as<std::byte, T>;

template <size_t Bits, bool AllowPadding, std::ranges::input_range Input> requires integral_like<std::ranges::range_value_t<Input>> struct chunk_of_bits_view {
	using input_value_type = std::ranges::range_value_t<Input>;

	static constexpr size_t output_value_bit_size = Bits;
	static constexpr size_t input_value_bit_size = sizeof(input_value_type) * 8u;
	using buffer_t = cthash::bit_buffer<output_value_bit_size, input_value_bit_size>;
	using buffer_size_t = buffer_t::size_type;
	Input input;

	static constexpr bool aligned = buffer_t::aligned;

	struct sentinel { };

	template <bool Const> struct iterator {
		using parent = maybe_const<Const, Input>;
		using storage_type = buffer_with_missing_bits<buffer_t, AllowPadding>;
		using value_type = storage_type::result_type;
		using difference_type = intptr_t;

		std::ranges::iterator_t<parent> it;
		[[no_unique_address]] std::ranges::sentinel_t<parent> end;

		storage_type buffer{};

		constexpr iterator(parent & p) noexcept: it{std::ranges::begin(p)}, end{std::ranges::end(p)} {
			// initialize
			buffer.feed_buffer(it, end);
		}

		iterator(const iterator &) = default;
		iterator(iterator &&) = default;

		iterator & operator=(const iterator &) = default;
		iterator & operator=(iterator &&) = default;

		constexpr iterator & operator++() noexcept {
			buffer.pop();
			buffer.feed_buffer(it, end);
			return *this;
		}

		constexpr iterator operator++(int) noexcept {
			auto copy = *this;
			this->operator++();
			return copy;
		}

		constexpr auto operator*() const noexcept {
			return buffer.front();
		}

		constexpr friend bool operator==(const iterator & lhs, const iterator & rhs) noexcept = default;

		constexpr friend bool operator==(const iterator & self, sentinel) noexcept {
			return self.buffer.empty();
		}
	};

	static_assert(std::input_iterator<iterator<true>>);
	static_assert(std::input_iterator<iterator<false>>);
	static_assert(std::sentinel_for<sentinel, iterator<true>>);
	static_assert(std::sentinel_for<sentinel, iterator<false>>);

	constexpr chunk_of_bits_view(Input _input) noexcept: input{_input} { }

	constexpr auto begin() const noexcept {
		return iterator<true>{input};
	}

	constexpr auto begin() noexcept {
		return iterator<false>{input};
	}

	constexpr auto end() const noexcept {
		return sentinel{};
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && AllowPadding) {
		// calculate with blocks
		return ((std::ranges::size(input) + (buffer_t::in_capacity() - 1u)) / buffer_t::in_capacity()) * buffer_t::out_capacity();
	}

	constexpr size_t size() const noexcept requires(std::ranges::sized_range<Input> && !AllowPadding) {
		// calculate with bits
		const size_t bit_size_of_input = std::ranges::size(input) * input_value_bit_size;
		return (bit_size_of_input + (output_value_bit_size - 1u)) / output_value_bit_size;
	}
};

template <size_t Bits, bool AllowPadding> struct chunk_of_bits_action {
	template <std::ranges::input_range R> constexpr friend auto operator|(R && input, chunk_of_bits_action action) {
		return action.operator()<R>(std::forward<R>(input));
	}
	template <std::ranges::input_range R> constexpr auto operator()(R && input) {
		return chunk_of_bits_view<Bits, AllowPadding, R>(std::forward<R>(input));
	}
};

template <size_t Bits, bool AllowPadding = false> constexpr auto chunk_of_bits = chunk_of_bits_action<Bits, AllowPadding>{};

} // namespace cthash

#endif

```

`include/cthash/encoding/concepts.hpp`:

```hpp
#ifndef CTHASH_ENCODING_CONCEPTS_HPP
#define CTHASH_ENCODING_CONCEPTS_HPP

#include <ranges>
#include <concepts>
#include <cstdint>

namespace cthash {

template <auto Value> struct fixed { };
template <auto Value> constexpr auto fixed_cast = fixed<Value>{};

template <typename T, typename... Types> concept one_of = (std::same_as<T, Types> || ...);

template <typename T> concept byte = one_of<std::remove_cvref_t<T>, char, unsigned char, signed char, uint8_t, int8_t, std::byte>;

template <typename Encoding> concept padded_encoding = requires() {
	{ Encoding::padding } -> cthash::byte;
};

template <typename T> concept byte_range = requires() {
	requires std::ranges::range<T>;
	requires cthash::byte<std::ranges::range_value_t<T>>;
};

} // namespace cthash

#endif

```

`include/cthash/encoding/encodings.hpp`:

```hpp
#ifndef CTHASH_ENCODING_ENCODINGS_HPP
#define CTHASH_ENCODING_ENCODINGS_HPP

#include "concepts.hpp"
#include <optional>
#include <variant>

namespace cthash {

namespace encoding {

	template <typename...> struct list { };

	struct base64 {
		static constexpr std::string_view name = "base64";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		static constexpr char padding = '=';
	};

	struct base64_no_padding {
		static constexpr std::string_view name = "base64_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	};

	struct base64url {
		static constexpr std::string_view name = "base64url";
		static constexpr std::string_view alt_name = "base64_url";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	};

	static_assert(padded_encoding<base64>);

	struct base32 {
		static constexpr std::string_view name = "base32";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
		static constexpr char padding = '=';
	};

	struct base32_no_padding {
		static constexpr std::string_view name = "base32_no_padding";

		static constexpr char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	};

	struct z_base32 {
		static constexpr std::string_view name = "z_base32";
		static constexpr std::string_view alt_name = "zbase32";

		static constexpr char alphabet[] = "ybndrfg8ejkmcpqxot1uwisza345h769";
	};

	struct base16 {
		static constexpr std::string_view name = "base16";
		static constexpr std::string_view alt_name = "hexdec";

		static constexpr char alphabet[] = "0123456789abcdef";
	};

	using hexdec = base16;

	struct base16_uppercase {
		static constexpr std::string_view name = "BASE16";
		static constexpr std::string_view alt_name = "HEXDEC";

		static constexpr char alphabet[] = "0123456789ABCDEF";
	};

	using hexdec_uppercase = base16_uppercase;

	struct base8 {
		static constexpr std::string_view name = "base8";
		static constexpr std::string_view alt_name = "octal";

		static constexpr char alphabet[] = "01234567";
		static constexpr char padding = '=';
	};

	using octal = base8;

	struct base4 {
		static constexpr std::string_view name = "base4";

		static constexpr char alphabet[] = "0123";
	};

	struct base2 {
		static constexpr std::string_view name = "base2";
		static constexpr std::string_view alt_name = "binary";

		static constexpr char alphabet[] = "01";
	};

	using binary = base2;

	using known_encodings = list<base64, base64_no_padding, base64url, base32, base32_no_padding, z_base32, base16, base16_uppercase, base8, base4, base2>;

} // namespace encoding

template <typename Defs> struct dynamic_encodings;

template <typename Encoding> concept has_alt_name = requires {
	{ Encoding::alt_name } -> std::same_as<const std::string_view &>;
};

static_assert(has_alt_name<encoding::hexdec>);

template <typename T, typename... Ts> concept one_from = (std::same_as<T, Ts> || ... || false);

template <typename Encoding> constexpr size_t longest_name_for = Encoding::name.size();
template <has_alt_name Encoding> constexpr size_t longest_name_for<Encoding> = std::max(Encoding::name.size(), Encoding::alt_name.size());

template <typename Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name;
}

template <has_alt_name Encoding> constexpr bool match_encoding(std::string_view name) noexcept {
	return Encoding::name == name || Encoding::alt_name == name;
}

template <typename... List> struct dynamic_encodings<encoding::list<List...>>: std::variant<List...> {
	using super = std::variant<List...>;

	template <typename Encoding> static constexpr bool assign_encoding(std::string_view name, std::optional<super> & output) noexcept {
		auto r = match_encoding<Encoding>(name);

		if (!r) {
			return false;
		}

		output = Encoding{};
		return true;
	}

	static constexpr auto select_encoding(std::string_view name) -> super {
		std::optional<super> output{std::nullopt};

		// I'm not using bool to avoid warning to have better code coverage
		const auto success = (unsigned(assign_encoding<List>(name, output)) | ... | 0u);

		if (!success) {
			throw std::invalid_argument{"unknown encoding name"};
		}

		assert(output.has_value());

		return *output;
	}

	static constexpr size_t longest_name_size = std::max({longest_name_for<List>...});

	constexpr dynamic_encodings(std::string_view name): super(select_encoding(name)) { }
	constexpr dynamic_encodings(one_from<List...> auto enc) noexcept: super(enc) { }

	template <typename Fnc> constexpr auto visit(Fnc && fnc) const {
		return std::visit(std::forward<Fnc>(fnc), static_cast<const super &>(*this));
	}
};

template <typename Encoding, typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_encoding(InputContext && input) {
	using iterator_t = decltype(std::ranges::begin(input));

	struct result {
		Encoding encoding;
		iterator_t iterator;
	};

	auto it = std::ranges::begin(input);

	if (it == std::ranges::end(input) || *it == '}') {
		return result{.encoding = DefaultEncoding{}, .iterator = it};
	}

	// this will copy it into buffer to compare
	std::array<char, Encoding::longest_name_size> buffer{};
	auto out = buffer.begin();

	for (;;) {
		if (it == std::ranges::end(input)) {
			break;
		}

		const char c = *it;

		if (c == '}') {
			break;
		}

		if (out != buffer.end()) {
			*out++ = c;
		}

		++it;
	}

	const std::string_view name = std::string_view(buffer.data(), static_cast<size_t>(std::distance(buffer.begin(), out)));

	return result{.encoding = Encoding(name), .iterator = it};
}

using runtime_encoding = dynamic_encodings<encoding::known_encodings>;

template <typename DefaultEncoding = encoding::hexdec, typename InputContext> constexpr auto select_runtime_encoding(InputContext && input) {
	return select_encoding<runtime_encoding, DefaultEncoding>(std::forward<InputContext>(input));
}

} // namespace cthash

#endif

```

`include/cthash/fixed-string.hpp`:

```hpp
#ifndef CTHASH_FIXED_STRING_HPP
#define CTHASH_FIXED_STRING_HPP

#include <algorithm>
#include <span>
#include <string_view>

namespace cthash {

template <typename CharT, size_t N> struct fixed_string: std::array<CharT, N> {
	using super = std::array<CharT, N>;

	consteval static auto from_string_literal(const CharT (&in)[N + 1]) -> std::array<CharT, N> {
		std::array<CharT, N> out;
		std::copy_n(in, N, out.data());
		return out;
	}

	explicit constexpr fixed_string(std::nullptr_t) noexcept: super{} { }

	consteval fixed_string(const CharT (&in)[N + 1]) noexcept: super{from_string_literal(in)} { }

	using super::data;
	using super::size;

	constexpr operator std::span<const CharT, N>() const noexcept {
		return std::span<const CharT, N>(data(), size());
	}

	constexpr operator std::span<const CharT>() const noexcept {
		return std::span<const CharT>(data(), size());
	}

	constexpr operator std::basic_string_view<CharT>() const noexcept {
		return std::basic_string_view<CharT>(data(), size());
	}

	constexpr friend bool operator==(const fixed_string &, const fixed_string &) noexcept = default;
	constexpr friend bool operator==(const fixed_string & lhs, std::basic_string_view<CharT> rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == rhs;
	}
	constexpr friend bool operator==(const fixed_string & lhs, const CharT * rhs) noexcept {
		return std::basic_string_view<CharT>{lhs} == std::basic_string_view<CharT>{rhs};
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N - 1>;

} // namespace cthash

#endif

```

`include/cthash/hasher.hpp`:

```hpp
#ifndef CONSTEXPR_SHA2_HASHER_HPP
#define CONSTEXPR_SHA2_HASHER_HPP

#include "simple.hpp"
#include "value.hpp"
#include "internal/bit.hpp"
#include "internal/concepts.hpp"
#include "internal/convert.hpp"
#include "internal/deduce.hpp"
#include <algorithm>
#include <array>
#include <span>
#include <cassert>
#include <concepts>
#include <cstdint>

namespace cthash {

template <typename Config> struct internal_hasher {
	static constexpr auto config = Config{};
	static constexpr size_t block_size_bytes = config.block_bits / 8u;
	static constexpr size_t digest_bytes = internal::digest_bytes_length_of<Config>;

	// internal types
	using state_value_t = std::remove_cvref_t<decltype(Config::initial_values)>;
	using state_item_t = typename state_value_t::value_type;

	using block_value_t = std::array<std::byte, block_size_bytes>;
	using block_view_t = std::span<const std::byte, block_size_bytes>;

	using staging_item_t = typename decltype(config.constants)::value_type;
	static constexpr size_t staging_size = config.constants.size();
	using staging_value_t = std::array<staging_item_t, staging_size>;
	using staging_view_t = std::span<const staging_item_t, staging_size>;

	using digest_span_t = std::span<std::byte, digest_bytes>;
	using result_t = cthash::tagged_hash_value<Config>;
	using length_t = typename Config::length_type;

	// internal state
	state_value_t hash;
	length_t total_length;

	block_value_t block;
	unsigned block_used;

	// constructors
	constexpr internal_hasher() noexcept: hash{config.initial_values}, total_length{0u}, block_used{0u} { }
	constexpr internal_hasher(const internal_hasher &) noexcept = default;
	constexpr internal_hasher(internal_hasher &&) noexcept = default;
	constexpr ~internal_hasher() noexcept = default;

	// take buffer and build staging
	template <byte_like Byte> [[gnu::always_inline]] static constexpr auto build_staging(std::span<const Byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		staging_value_t w;

		constexpr auto first_part_size = block_size_bytes / sizeof(staging_item_t);

		// fill first part with chunk
		for (int i = 0; i != int(first_part_size); ++i) {
			w[static_cast<size_t>(i)] = cast_from_bytes<staging_item_t>(chunk.subspan(static_cast<size_t>(i) * sizeof(staging_item_t)).template first<sizeof(staging_item_t)>());
		}

		// fill the rest (generify)
		for (int i = int(first_part_size); i != int(staging_size); ++i) {
			w[static_cast<size_t>(i)] = w[static_cast<size_t>(i - 16)] + config.sigma_0(w[static_cast<size_t>(i - 15)]) + w[static_cast<size_t>(i - 7)] + config.sigma_1(w[static_cast<size_t>(i - 2)]);
		}

		return w;
	}

	[[gnu::always_inline]] static constexpr auto build_staging(std::span<const std::byte, block_size_bytes> chunk) noexcept -> staging_value_t {
		return build_staging<std::byte>(chunk);
	}

	[[gnu::always_inline]] static constexpr void rounds(staging_view_t w, state_value_t & state) noexcept {
		config.rounds(w, state);
	}

	// this implementation works only with input size aligned to bytes (not bits)
	template <byte_like T> [[gnu::always_inline]] constexpr void update_to_buffer_and_process(std::span<const T> in) noexcept {
		// if block is not used, we can build staging directly
		if (block_used) {
			const auto remaining_free_space = std::span<std::byte, block_size_bytes>(block).subspan(block_used);
			const auto to_copy = in.first(std::min(in.size(), remaining_free_space.size()));

			const auto it = byte_copy(to_copy.begin(), to_copy.end(), remaining_free_space.begin());
			total_length += to_copy.size();

			// we didn't fill the block
			if (it != remaining_free_space.end()) {
				assert(to_copy.size() == in.size());
				block_used += static_cast<unsigned>(to_copy.size());
				return;
			} else {
				block_used = 0u;
			}

			// we have block!
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// remove part we processed
			in = in.subspan(to_copy.size());
		}

		// do the work over blocks without copy
		if (not block_used) {
			while (in.size() >= block_size_bytes) {
				const auto local_block = in.template first<block_size_bytes>();
				total_length += block_size_bytes;

				const staging_value_t w = build_staging<T>(local_block);
				rounds(w, hash);

				// remove part we processed
				in = in.subspan(block_size_bytes);
			}
		}

		// remainder is put onto temporary block
		if (not in.empty()) {
			assert(block_used == 0u);
			assert(in.size() < block_size_bytes);

			// copy it to block and let it stay there
			byte_copy(in.begin(), in.end(), block.begin());
			block_used = static_cast<unsigned>(in.size());
			total_length += block_used;
		}
	}

	[[gnu::always_inline]] static constexpr bool finalize_buffer(block_value_t & block, size_t block_used) noexcept {
		assert(block_used < block.size());
		const auto free_space = std::span(block).subspan(block_used);

		auto it = free_space.data();
		*it++ = std::byte{0b1000'0000u};							   // first byte after data contains bit at MSB
		std::fill(it, (block.data() + block.size()), std::byte{0x0u}); // rest is filled with zeros

		// we don't have enough space to write length bits
		return free_space.size() < (1u + (config.length_size_bits / 8u));
	}

	[[gnu::always_inline]] static constexpr void finalize_buffer_by_writing_length(block_value_t & block, length_t total_length) noexcept {
		unwrap_bigendian_number{std::span(block).template last<sizeof(length_t)>()} = (total_length * 8u);
	}

	[[gnu::always_inline]] constexpr void finalize() noexcept {
		if (finalize_buffer(block, block_used)) {
			// we didn't have enough space, we need to process block
			const staging_value_t w = build_staging(block);
			rounds(w, hash);

			// zero it out
			std::fill(block.begin(), block.end(), std::byte{0x0u});
		}

		// we either have space to write or we have zerod out block
		finalize_buffer_by_writing_length(block, total_length);

		// calculate last round
		const staging_value_t w = build_staging(block);
		rounds(w, hash);
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) == 0u)
	{
		// copy result to byte result
		constexpr size_t values_for_output = digest_bytes / sizeof(state_item_t);
		static_assert(values_for_output <= config.initial_values.size());

		for (int i = 0; i != values_for_output; ++i) {
			unwrap_bigendian_number<state_item_t>{out.subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}
	}

	[[gnu::always_inline]] constexpr void write_result_into(digest_span_t out) noexcept
		requires(digest_bytes % sizeof(state_item_t) != 0u)
	{
		// this is only used when digest doesn't align with output buffer

		// make sure digest size is smaller than hash state
		static_assert(digest_bytes <= config.initial_values.size() * sizeof(state_item_t));

		// copy result to byte result
		std::array<std::byte, sizeof(state_item_t) * config.initial_values.size()> tmp_buffer;

		for (int i = 0; i != (int)config.initial_values.size(); ++i) {
			unwrap_bigendian_number<state_item_t>{std::span(tmp_buffer).subspan(static_cast<size_t>(i) * sizeof(state_item_t)).template first<sizeof(state_item_t)>()} = hash[static_cast<size_t>(i)];
		}

		std::copy_n(tmp_buffer.data(), digest_bytes, out.data());
	}
};

// this is a convinience type for nicer UX...
template <typename Config> struct hasher: private internal_hasher<Config> {
	using super = internal_hasher<Config>;
	using result_t = typename super::result_t;
	using length_t = typename super::length_t;
	using digest_span_t = typename super::digest_span_t;

	constexpr hasher() noexcept: super() { }
	constexpr hasher(const hasher &) noexcept = default;
	constexpr hasher(hasher &&) noexcept = default;
	constexpr ~hasher() noexcept = default;

	// support for various input types
	constexpr hasher & update(std::span<const std::byte> input) noexcept {
		super::update_to_buffer_and_process(input);
		return *this;
	}

	template <convertible_to_byte_span T> constexpr hasher & update(const T & something) noexcept {
		using value_type = typename decltype(std::span(something))::value_type;
		super::update_to_buffer_and_process(std::span<const value_type>(something));
		return *this;
	}

	template <one_byte_char CharT> constexpr hasher & update(std::basic_string_view<CharT> in) noexcept {
		super::update_to_buffer_and_process(std::span(in.data(), in.size()));
		return *this;
	}

	template <string_literal T> constexpr hasher & update(const T & lit) noexcept {
		super::update_to_buffer_and_process(std::span(lit, std::size(lit) - 1u));
		return *this;
	}

	// TODO: any range with value convertible to byte

	// output (by reference or by value)
	constexpr void final(digest_span_t digest) noexcept {
		super::finalize();
		super::write_result_into(digest);
	}

	constexpr auto final() noexcept {
		result_t output;
		this->final(output);
		return output;
	}

	constexpr length_t size() const noexcept {
		return super::total_length;
	}
};

} // namespace cthash

#endif

```

`include/cthash/internal/algorithm.hpp`:

```hpp
#ifndef CTHASH_INTERNAL_ALGORITHM_HPP
#define CTHASH_INTERNAL_ALGORITHM_HPP

#include <numeric>
#include <compare>
#include <cstddef>
#include <cstdint>

namespace cthash::internal {

template <typename It1, typename It2> constexpr auto threeway_compare_of_same_size(It1 lhs, It2 rhs, size_t length) -> std::strong_ordering {
	for (size_t i = 0; i != length; ++i) {
		if (const auto r = (*lhs++ <=> *rhs++); std::is_neq(r)) {
			return r;
		}
	}

	return std::strong_ordering::equal;
}

template <typename T, typename It1, typename It2, typename Stream> constexpr auto & push_to_stream_as(It1 f, It2 l, Stream & stream) {
	constexpr auto cast_and_shift = [](Stream * s, const auto & rhs) { (*s) << T{rhs}; return s; };
	return *std::accumulate(f, l, &stream, cast_and_shift);
}

} // namespace cthash::internal

#endif

```

`include/cthash/internal/bit.hpp`:

```hpp
#ifndef CTHASH_INTERNAL_BIT_HPP
#define CTHASH_INTERNAL_BIT_HPP

#include <bit>

namespace cthash::internal {

#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto byteswap(T val) noexcept {
	return std::byteswap(val);
}

#else

template <typename T, size_t N> concept unsigned_integral_of_size = (sizeof(T) == N) && std::unsigned_integral<T>;

template <unsigned_integral_of_size<1> T> constexpr auto byteswap(T val) noexcept {
	return val;
}

template <unsigned_integral_of_size<2> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap16(val));
}

template <unsigned_integral_of_size<4> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap32(val));
}

template <unsigned_integral_of_size<8> T> constexpr auto byteswap(T val) noexcept {
	return static_cast<T>(__builtin_bswap64(val));
}

#endif

} // namespace cthash::internal

#endif
```

`include/cthash/internal/concepts.hpp`:

```hpp
#ifndef CTHASH_CONCEPTS_HPP
#define CTHASH_CONCEPTS_HPP

#include <span>

namespace cthash {

template <typename T> concept one_byte_char = (sizeof(T) == 1u);

template <typename T> concept byte_like = (sizeof(T) == 1u) && (std::same_as<T, char> || std::same_as<T, unsigned char> || std::same_as<T, char8_t> || std::same_as<T, std::byte> || std::same_as<T, uint8_t> || std::same_as<T, int8_t>);

template <one_byte_char CharT, size_t N> void string_literal_helper(const CharT (&)[N]);

template <typename T> concept string_literal = requires(const T & in) //
{
	string_literal_helper(in);
};

template <typename T> concept convertible_to_byte_span = requires(T && obj) //
{
	{ std::span(obj) };
	requires byte_like<typename decltype(std::span(obj))::value_type>;
	requires !string_literal<T>;
};

} // namespace cthash

#endif

```

`include/cthash/internal/convert.hpp`:

```hpp
#ifndef CTHASH_INTERNAL_CONVERT_HPP
#define CTHASH_INTERNAL_CONVERT_HPP

#include "bit.hpp"
#include "concepts.hpp"
#include <span>
#include <type_traits>
#include <cstddef>
#include <cstdint>
#include <cstring>

namespace cthash {

template <typename It1, typename It2, typename It3> constexpr auto byte_copy(It1 first, It2 last, It3 destination) {
	return std::transform(first, last, destination, [](byte_like auto v) { return static_cast<std::byte>(v); });
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << ((sizeof(T) - 1u - Idx) * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::little) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T, byte_like Byte> constexpr auto cast_from_le_bytes(std::span<const Byte, sizeof(T)> in) noexcept -> T {
	if consteval {
		return [&]<size_t... Idx>(std::index_sequence<Idx...>) -> T {
			return static_cast<T>(((static_cast<T>(in[Idx]) << static_cast<T>(Idx * 8u)) | ...));
		}(std::make_index_sequence<sizeof(T)>());
	} else {
		T t;
		std::memcpy(&t, in.data(), sizeof(T));
		if constexpr (std::endian::native == std::endian::big) {
			return internal::byteswap(t);
		} else {
			return t;
		}
	}
}

template <std::unsigned_integral T> struct unwrap_littleendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> (Idx * 8u))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_littleendian_number(std::span<std::byte, 8>) -> unwrap_littleendian_number<uint64_t>;
unwrap_littleendian_number(std::span<std::byte, 4>) -> unwrap_littleendian_number<uint32_t>;

template <std::unsigned_integral T> struct unwrap_bigendian_number {
	static constexpr size_t bytes = sizeof(T);
	static constexpr size_t bits = bytes * 8u;

	std::span<std::byte, bytes> ref;

	constexpr void operator=(T value) noexcept {
		[&]<size_t... Idx>(std::index_sequence<Idx...>) {
			((ref[Idx] = static_cast<std::byte>(value >> ((bits - 8u) - 8u * Idx))), ...);
		}(std::make_index_sequence<bytes>());
	}
};

unwrap_bigendian_number(std::span<std::byte, 8>) -> unwrap_bigendian_number<uint64_t>;
unwrap_bigendian_number(std::span<std::byte, 4>) -> unwrap_bigendian_number<uint32_t>;

} // namespace cthash

#endif

```

`include/cthash/internal/deduce.hpp`:

```hpp
#ifndef CTHASH_INTERNAL_DEDUCE_HPP
#define CTHASH_INTERNAL_DEDUCE_HPP

#include <concepts>
#include <cstdint>

namespace cthash::internal {

// support

template <typename T> concept digest_length_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length) } -> std::same_as<size_t>;
};

template <typename T> concept digest_length_bit_provided = requires() //
{
	{ static_cast<size_t>(T::digest_length_bit) } -> std::same_as<size_t>;
};

template <typename T> concept initial_values_provided = requires() //
{
	{ static_cast<size_t>(T::initial_values.size() * sizeof(typename decltype(T::initial_values)::value_type)) } -> std::same_as<size_t>;
};

template <typename> static constexpr bool dependent_false = false;

template <typename Config> constexpr size_t digest_bytes_length_of = [] {
	if constexpr (digest_length_provided<Config>) {
		return static_cast<size_t>(Config::digest_length);
	} else if constexpr (digest_length_bit_provided<Config>) {
		return static_cast<size_t>(Config::digest_length_bit) / 8u;
	} else if constexpr (initial_values_provided<Config>) {
		return static_cast<size_t>(Config::initial_values.size() * sizeof(typename decltype(Config::initial_values)::value_type));
	} else {
		static_assert(dependent_false<Config>);
	}
}();

} // namespace cthash::internal

#endif
```

`include/cthash/internal/hexdec.hpp`:

```hpp
#ifndef CTHASH_INTERNAL_HEXDEC_HPP
#define CTHASH_INTERNAL_HEXDEC_HPP

#include <array>
#include <ostream>
#include <span>
#include <type_traits>
#include <cstdint>

namespace cthash::internal {

consteval auto get_hexdec_table() noexcept {
	std::array<uint8_t, 128> result;

	auto char_to_hexdec = [](char c) {
		if (c >= '0' && c <= '9') {
			return static_cast<uint8_t>(c - '0');
		} else if (c >= 'a' && c <= 'f') {
			return static_cast<uint8_t>(c - 'a' + 10);
		} else if (c >= 'A' && c <= 'F') {
			return static_cast<uint8_t>(c - 'A' + 10);
		} else {
			return static_cast<uint8_t>(0);
		}
	};

	for (size_t i = 0; i != result.size(); ++i) {
		result[i] = char_to_hexdec(static_cast<char>(i));
	}

	return result;
}

constexpr auto hexdec_to_value_alphabet = get_hexdec_table();

template <typename CharT> constexpr auto value_to_hexdec_alphabet = std::array<CharT, 16>{CharT('0'), CharT('1'), CharT('2'), CharT('3'), CharT('4'), CharT('5'), CharT('6'), CharT('7'), CharT('8'), CharT('9'), CharT('a'), CharT('b'), CharT('c'), CharT('d'), CharT('e'), CharT('f')};

struct byte_hexdec_value {
	std::byte val;

	template <typename CharT, typename Traits> friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, byte_hexdec_value rhs) {
		return os << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val >> 4u)] << value_to_hexdec_alphabet<CharT>[unsigned(rhs.val) & 0b1111u];
	}
};

template <size_t N, typename CharT> constexpr auto hexdec_to_binary(std::span<const CharT, N * 2> in) -> std::array<std::byte, N> {
	return [in]<size_t... Idx>(std::index_sequence<Idx...>) {
		return std::array<std::byte, N>{static_cast<std::byte>(hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2]) & 0b0111'1111u] << 4u | hexdec_to_value_alphabet[static_cast<size_t>(in[Idx * 2u + 1u]) & 0b0111'1111u])...};
	}(std::make_index_sequence<N>());
}

template <typename CharT, size_t N>
requires((N - 1) % 2 == 0) // -1 because of zero terminator in literals
constexpr auto literal_hexdec_to_binary(const CharT (&in)[N]) -> std::array<std::byte, (N - 1) / 2> {
	return hexdec_to_binary<N / 2>(std::span<const char, N - 1>(in, N - 1));
}

} // namespace cthash::internal

#endif

```

`include/cthash/sha2/common.hpp`:

```hpp
#ifndef CTHASH_SHA2_COMMON_HPP
#define CTHASH_SHA2_COMMON_HPP

#include "../hasher.hpp"
#include <array>
#include <span>
#include <concepts>
#include <cstdint>

namespace cthash::sha2 {

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto choice(T e, T f, T g) noexcept -> T {
	return (e bitand f) xor (~e bitand g);
}

template <std::unsigned_integral T> [[gnu::always_inline]] constexpr auto majority(T a, T b, T c) noexcept -> T {
	return (a bitand b) xor (a bitand c) xor (b bitand c);
}

template <typename Config, typename StageT, size_t StageLength, typename StateT, size_t StateLength>
[[gnu::always_inline]] constexpr void rounds(std::span<const StageT, StageLength> w, std::array<StateT, StateLength> & state) noexcept {
	using state_t = std::array<StateT, StateLength>;

	// create copy of internal state
	auto wvar = state_t(state);

	// just give them names
	auto & [a, b, c, d, e, f, g, h] = wvar;

	// number of rounds is same as constants
	static_assert(StageLength == Config::constants.size());

	for (int i = 0; i != Config::constants.size(); ++i) {
		const auto temp1 = h + Config::sum_e(e) + choice(e, f, g) + Config::constants[static_cast<size_t>(i)] + w[static_cast<size_t>(i)];
		const auto temp2 = Config::sum_a(a) + majority(a, b, c);

		// move around (that's rotate)
		std::rotate(wvar.begin(), wvar.begin() + 7u, wvar.end());

		e += temp1;
		a = temp1 + temp2;

		// originally it was:
		// h = g;
		// g = f;
		// f = e;
		// e = d + temp1;
		// d = c;
		// c = b;
		// b = a;
		// a = temp1 + temp2;
	}

	// add store back
	for (int i = 0; i != (int)state.size(); ++i) {
		state[static_cast<size_t>(i)] += wvar[static_cast<size_t>(i)];
	}
}

} // namespace cthash::sha2

#endif
```

`include/cthash/sha2/sha224.hpp`:

```hpp
#ifndef CTHASH_SHA2_SHA224_HPP
#define CTHASH_SHA2_SHA224_HPP

#include "sha256.hpp"

namespace cthash {

struct sha224_config: sha256_config {
	// these are only changes against sha256 specification...

	static constexpr size_t digest_length = 28u;

	static constexpr auto initial_values = std::array<uint32_t, 8>{0xc1059ed8ul, 0x367cd507ul, 0x3070dd17ul, 0xf70e5939ul, 0xffc00b31ul, 0x68581511ul, 0x64f98fa7ul, 0xbefa4fa4ul};
};

static_assert(cthash::internal::digest_length_provided<sha224_config>);
static_assert(cthash::internal::digest_bytes_length_of<sha224_config> == 28u);

using sha224 = hasher<sha224_config>;
using sha224_value = tagged_hash_value<sha224_config>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_sha224() {
		return sha224_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

```

`include/cthash/sha2/sha256.hpp`:

```hpp
#ifndef CTHASH_SHA2_SHA256_HPP
#define CTHASH_SHA2_SHA256_HPP

#include "common.hpp"

namespace cthash {

struct sha256_config {
	using length_type = uint64_t;
	static constexpr size_t length_size_bits = 64;

	static constexpr size_t block_bits = 512u;

	static constexpr auto initial_values = std::array<uint32_t, 8>{0x6a09e667ul, 0xbb67ae85ul, 0x3c6ef372ul, 0xa54ff53aul, 0x510e527ful, 0x9b05688cul, 0x1f83d9abul, 0x5be0cd19ul};

	// staging sigmas
	[[gnu::always_inline]] static constexpr auto sigma_0(uint32_t w_15) noexcept -> uint32_t {
		return std::rotr(w_15, 7u) xor std::rotr(w_15, 18u) xor (w_15 >> 3u);
	}

	[[gnu::always_inline]] static constexpr auto sigma_1(uint32_t w_2) noexcept -> uint32_t {
		return std::rotr(w_2, 17u) xor std::rotr(w_2, 19u) xor (w_2 >> 10u);
	}

	// rounds constants...
	static constexpr auto constants = std::array<uint32_t, 64>{
		0x428a2f98ul, 0x71374491ul, 0xb5c0fbcful, 0xe9b5dba5ul, 0x3956c25bul, 0x59f111f1ul, 0x923f82a4ul, 0xab1c5ed5ul,
		0xd807aa98ul, 0x12835b01ul, 0x243185beul, 0x550c7dc3ul, 0x72be5d74ul, 0x80deb1feul, 0x9bdc06a7ul, 0xc19bf174ul,
		0xe49b69c1ul, 0xefbe4786ul, 0x0fc19dc6ul, 0x240ca1ccul, 0x2de92c6ful, 0x4a7484aaul, 0x5cb0a9dcul, 0x76f988daul,
		0x983e5152ul, 0xa831c66dul, 0xb00327c8ul, 0xbf597fc7ul, 0xc6e00bf3ul, 0xd5a79147ul, 0x06ca6351ul, 0x14292967ul,
		0x27b70a85ul, 0x2e1b2138ul, 0x4d2c6dfcul, 0x53380d13ul, 0x650a7354ul, 0x766a0abbul, 0x81c2c92eul, 0x92722c85ul,
		0xa2bfe8a1ul, 0xa81a664bul, 0xc24b8b70ul, 0xc76c51a3ul, 0xd192e819ul, 0xd6990624ul, 0xf40e3585ul, 0x106aa070ul,
		0x19a4c116ul, 0x1e376c08ul, 0x2748774cul, 0x34b0bcb5ul, 0x391c0cb3ul, 0x4ed8aa4aul, 0x5b9cca4ful, 0x682e6ff3ul,
		0x748f82eeul, 0x78a5636ful, 0x84c87814ul, 0x8cc70208ul, 0x90befffaul, 0xa4506cebul, 0xbef9a3f7ul, 0xc67178f2ul};

	// rounds sums
	[[gnu::always_inline]] static constexpr auto sum_a(uint32_t a) noexcept -> uint32_t {
		return std::rotr(a, 2u) xor std::rotr(a, 13u) xor std::rotr(a, 22u);
	}

	[[gnu::always_inline]] static constexpr auto sum_e(uint32_t e) noexcept -> uint32_t {
		return std::rotr(e, 6u) xor std::rotr(e, 11u) xor std::rotr(e, 25u);
	}

	// rounds
	[[gnu::always_inline]] static constexpr void rounds(std::span<const uint32_t, 64> w, std::array<uint32_t, 8> & state) noexcept {
		return sha2::rounds<sha256_config>(w, state);
	}
};

static_assert(not cthash::internal::digest_length_provided<sha256_config>);
static_assert(cthash::internal::digest_bytes_length_of<sha256_config> == 32u);

using sha256 = hasher<sha256_config>;
using sha256_value = tagged_hash_value<sha256_config>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_sha256() {
		return sha256_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

```

`include/cthash/sha2/sha384.hpp`:

```hpp
#ifndef CTHASH_SHA2_SHA384_HPP
#define CTHASH_SHA2_SHA384_HPP

#include "sha512.hpp"

namespace cthash {

struct sha384_config: sha512_config {
	static constexpr size_t digest_length = 48u;

	static constexpr auto initial_values = std::array<uint64_t, 8>{0xcbbb9d5dc1059ed8ull, 0x629a292a367cd507ull, 0x9159015a3070dd17ull, 0x152fecd8f70e5939ull, 0x67332667ffc00b31ull, 0x8eb44a8768581511ull, 0xdb0c2e0d64f98fa7ull, 0x47b5481dbefa4fa4ull};
};

static_assert(cthash::internal::digest_length_provided<sha384_config>);
static_assert(cthash::internal::digest_bytes_length_of<sha384_config> == 48u);

using sha384 = hasher<sha384_config>;
using sha384_value = tagged_hash_value<sha384_config>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_sha384() {
		return sha384_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

```

`include/cthash/sha2/sha512.hpp`:

```hpp
#ifndef CTHASH_SHA2_SHA512_HPP
#define CTHASH_SHA2_SHA512_HPP

#include "common.hpp"

namespace cthash {

struct sha512_config {
	using length_type = uint64_t;
	static constexpr size_t length_size_bits = 128;

	static constexpr size_t block_bits = 1024u;

	static constexpr auto initial_values = std::array<uint64_t, 8>{0x6a09e667f3bcc908ull, 0xbb67ae8584caa73bull, 0x3c6ef372fe94f82bull, 0xa54ff53a5f1d36f1ull, 0x510e527fade682d1ull, 0x9b05688c2b3e6c1full, 0x1f83d9abfb41bd6bull, 0x5be0cd19137e2179ull};

	// staging functions
	[[gnu::always_inline]] static constexpr auto sigma_0(uint64_t w_15) noexcept -> uint64_t {
		return std::rotr(w_15, 1u) xor std::rotr(w_15, 8u) xor (w_15 >> 7u);
	}

	[[gnu::always_inline]] static constexpr auto sigma_1(uint64_t w_2) noexcept -> uint64_t {
		return std::rotr(w_2, 19u) xor std::rotr(w_2, 61u) xor (w_2 >> 6u);
	}

	// rounds constants...
	static constexpr auto constants = std::array<uint64_t, 80>{
		0x428a2f98d728ae22ull, 0x7137449123ef65cdull, 0xb5c0fbcfec4d3b2full, 0xe9b5dba58189dbbcull, 0x3956c25bf348b538ull,
		0x59f111f1b605d019ull, 0x923f82a4af194f9bull, 0xab1c5ed5da6d8118ull, 0xd807aa98a3030242ull, 0x12835b0145706fbeull,
		0x243185be4ee4b28cull, 0x550c7dc3d5ffb4e2ull, 0x72be5d74f27b896full, 0x80deb1fe3b1696b1ull, 0x9bdc06a725c71235ull,
		0xc19bf174cf692694ull, 0xe49b69c19ef14ad2ull, 0xefbe4786384f25e3ull, 0x0fc19dc68b8cd5b5ull, 0x240ca1cc77ac9c65ull,
		0x2de92c6f592b0275ull, 0x4a7484aa6ea6e483ull, 0x5cb0a9dcbd41fbd4ull, 0x76f988da831153b5ull, 0x983e5152ee66dfabull,
		0xa831c66d2db43210ull, 0xb00327c898fb213full, 0xbf597fc7beef0ee4ull, 0xc6e00bf33da88fc2ull, 0xd5a79147930aa725ull,
		0x06ca6351e003826full, 0x142929670a0e6e70ull, 0x27b70a8546d22ffcull, 0x2e1b21385c26c926ull, 0x4d2c6dfc5ac42aedull,
		0x53380d139d95b3dfull, 0x650a73548baf63deull, 0x766a0abb3c77b2a8ull, 0x81c2c92e47edaee6ull, 0x92722c851482353bull,
		0xa2bfe8a14cf10364ull, 0xa81a664bbc423001ull, 0xc24b8b70d0f89791ull, 0xc76c51a30654be30ull, 0xd192e819d6ef5218ull,
		0xd69906245565a910ull, 0xf40e35855771202aull, 0x106aa07032bbd1b8ull, 0x19a4c116b8d2d0c8ull, 0x1e376c085141ab53ull,
		0x2748774cdf8eeb99ull, 0x34b0bcb5e19b48a8ull, 0x391c0cb3c5c95a63ull, 0x4ed8aa4ae3418acbull, 0x5b9cca4f7763e373ull,
		0x682e6ff3d6b2b8a3ull, 0x748f82ee5defb2fcull, 0x78a5636f43172f60ull, 0x84c87814a1f0ab72ull, 0x8cc702081a6439ecull,
		0x90befffa23631e28ull, 0xa4506cebde82bde9ull, 0xbef9a3f7b2c67915ull, 0xc67178f2e372532bull, 0xca273eceea26619cull,
		0xd186b8c721c0c207ull, 0xeada7dd6cde0eb1eull, 0xf57d4f7fee6ed178ull, 0x06f067aa72176fbaull, 0x0a637dc5a2c898a6ull,
		0x113f9804bef90daeull, 0x1b710b35131c471bull, 0x28db77f523047d84ull, 0x32caab7b40c72493ull, 0x3c9ebe0a15c9bebcull,
		0x431d67c49c100d4cull, 0x4cc5d4becb3e42b6ull, 0x597f299cfc657e2aull, 0x5fcb6fab3ad6faecull, 0x6c44198c4a475817ull};

	[[gnu::always_inline]] static constexpr auto sum_a(uint64_t a) noexcept -> uint64_t {
		return std::rotr(a, 28u) xor std::rotr(a, 34u) xor std::rotr(a, 39u);
	}

	[[gnu::always_inline]] static constexpr auto sum_e(uint64_t e) noexcept -> uint64_t {
		return std::rotr(e, 14u) xor std::rotr(e, 18u) xor std::rotr(e, 41u);
	}

	// rounds
	[[gnu::always_inline]] static constexpr void rounds(std::span<const uint64_t, 80> w, std::array<uint64_t, 8> & state) noexcept {
		return sha2::rounds<sha512_config>(w, state);
	}
};

static_assert(not cthash::internal::digest_length_provided<sha512_config>);
static_assert(cthash::internal::digest_bytes_length_of<sha512_config> == 64u);

using sha512 = hasher<sha512_config>;
using sha512_value = tagged_hash_value<sha512_config>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_sha512() {
		return sha512_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

```

`include/cthash/sha2/sha512/t.hpp`:

```hpp
#ifndef CTHASH_SHA2_SHA512_T_HPP
#define CTHASH_SHA2_SHA512_T_HPP

#include "../sha512.hpp"

namespace cthash {

namespace sha256t_support {

	static consteval size_t width_of_decimal(unsigned t) {
		if (t < 10u) {
			return 1u;
		} else if (t < 100u) {
			return 2u;
		} else if (t < 1000u) {
			return 3u;
		} else {
			throw "we don't support more than three digits!";
		}
	}

	template <unsigned Width> static consteval auto generate_signature(unsigned t) {
		const char a = '0' + static_cast<char>((t / 100u) % 10u);
		const char b = '0' + static_cast<char>((t / 10u) % 10u);
		const char c = '0' + static_cast<char>((t / 1u) % 10u);

		if constexpr (Width == 1) {
			return std::array<char, Width + 8u>{'S', 'H', 'A', '-', '5', '1', '2', '/', c};
		} else if constexpr (Width == 2) {
			return std::array<char, Width + 8u>{'S', 'H', 'A', '-', '5', '1', '2', '/', b, c};
		} else if constexpr (Width == 3) {
			return std::array<char, Width + 8u>{'S', 'H', 'A', '-', '5', '1', '2', '/', a, b, c};
		} else {
			throw "we don't support greater width than 3";
		}
	}

} // namespace sha256t_support

static consteval auto calculate_sha512t_iv(std::span<const char> in) {
	auto sha512hasher = internal_hasher<sha512_config>{};

	// modify IV
	for (auto & val: sha512hasher.hash) {
		val = val xor 0xa5a5a5a5a5a5a5a5ull;
	}

	sha512hasher.update_to_buffer_and_process(in);
	sha512hasher.finalize();
	return sha512hasher.hash;
}

template <size_t T> constexpr auto signature_for_sha512t = sha256t_support::generate_signature<sha256t_support::width_of_decimal(T)>(T);
template <size_t T> constexpr auto iv_for_sha512t = calculate_sha512t_iv(signature_for_sha512t<T>);

template <unsigned T> struct sha512t_config: sha512_config {
	static_assert(T % 8u == 0u, "only hashes aligned to bytes are supported");
	static_assert(T != 384u, "sha-512/384 is not allowed, use sha-384 instead");
	static_assert(T <= 512u, "T can't be larger than 512");
	static_assert(T != 0u, "T can't be zero");

	static constexpr size_t digest_length = T / 8u;

	static constexpr std::array<uint64_t, 8> initial_values = iv_for_sha512t<T>;
};

static_assert(cthash::internal::digest_length_provided<sha512t_config<224>>);
static_assert(cthash::internal::digest_length_provided<sha512t_config<256>>);
static_assert(cthash::internal::digest_bytes_length_of<sha512t_config<224>> == 28u);
static_assert(cthash::internal::digest_bytes_length_of<sha512t_config<256>> == 32u);

template <unsigned T> using sha512t = hasher<sha512t_config<T>>;
template <unsigned T> using sha512t_value = tagged_hash_value<sha512t_config<T>>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_sha512_224() {
		return sha512t_value<224>(Value);
	}

	template <fixed_string Value>
	consteval auto operator""_sha512_256() {
		return sha512t_value<256>(Value);
	}

} // namespace literals

} // namespace cthash

#endif

```

`include/cthash/sha3/common.hpp`:

```hpp
#ifndef CTHASH_SHA3_COMMON_HPP
#define CTHASH_SHA3_COMMON_HPP

#include "keccak-base.hpp"
#include "../hasher.hpp"
#include "../internal/bit.hpp"
#include "../internal/convert.hpp"
#include "../simple.hpp"
#include "../value.hpp"
#include <cstdint>

namespace cthash {

template <typename T, typename Y> concept castable_to = requires(T val) { {static_cast<Y>(val)} -> std::same_as<Y>; };

template <size_t N> struct keccak_suffix {
	unsigned bits;
	std::array<std::byte, N> values;

	constexpr keccak_suffix(unsigned b, castable_to<std::byte> auto... v) noexcept: bits{b}, values{static_cast<std::byte>(v)...} { }
};

template <castable_to<std::byte>... Ts> keccak_suffix(unsigned, Ts...) -> keccak_suffix<sizeof...(Ts)>;

template <typename T> struct identify;

template <typename T, byte_like Byte> constexpr auto convert_prefix_into_aligned(std::span<const Byte> input, unsigned pos) noexcept -> std::array<std::byte, sizeof(T)> {
	assert(input.size() <= sizeof(T));
	assert(pos <= sizeof(T));
	assert((input.size() + pos) <= sizeof(T));

	std::array<std::byte, sizeof(T)> buffer{};

	std::fill(buffer.begin(), buffer.end(), std::byte{0});
	std::transform(input.data(), input.data() + input.size(), buffer.data() + pos, [](auto v) { return static_cast<std::byte>(v); });

	return buffer;
}

template <typename T, byte_like Byte> constexpr auto convert_prefix_into_value(std::span<const Byte> input, unsigned pos) noexcept -> uint64_t {
	const auto tmp = convert_prefix_into_aligned<T, Byte>(input, pos);
	return cast_from_le_bytes<T>(std::span<const std::byte, 8>(tmp));
}

template <typename Config> struct basic_keccak_hasher {
	static_assert(Config::digest_length_bit % 8u == 0u);
	static_assert(Config::rate_bit % 8u == 0u);
	static_assert(Config::capacity_bit % 8u == 0u);

	static_assert((Config::rate_bit + Config::capacity_bit) == 1600u, "Only Keccak 1600 is implemented");

	static constexpr size_t digest_length = Config::digest_length_bit / 8u;
	static constexpr size_t rate = Config::rate_bit / 8u;
	static constexpr size_t capacity = Config::capacity_bit / 8u;

	using result_t = cthash::tagged_hash_value<Config>;
	using digest_span_t = std::span<std::byte, digest_length>;

	keccak::state_1600 internal_state{};
	uint8_t position{0u};

	constexpr basic_keccak_hasher() noexcept {
		std::fill(internal_state.begin(), internal_state.end(), uint64_t{0});
	}

	template <byte_like T> constexpr size_t xor_overwrite_block(std::span<const T> input) noexcept {
		using value_t = keccak::state_1600::value_type;

		if ((std::is_constant_evaluated() | (std::endian::native != std::endian::little))) {
			assert((size_t(position) + input.size()) <= rate);

			// unaligned prefix (by copying from left to right it should be little endian)
			if (position % sizeof(value_t) != 0u) {
				// xor unaligned value and move to aligned if possible
				const size_t prefix_size = std::min(input.size(), sizeof(value_t) - (position % sizeof(value_t)));
				internal_state[position / sizeof(uint64_t)] ^= convert_prefix_into_value<value_t>(input.first(prefix_size), static_cast<unsigned>(position % sizeof(value_t)));
				position += static_cast<uint8_t>(prefix_size);
				input = input.subspan(prefix_size);
			}

			// aligned blocks
			while (input.size() >= sizeof(value_t)) {
				// xor aligned value and move to next
				internal_state[position / sizeof(value_t)] ^= cast_from_le_bytes<value_t>(input.template first<sizeof(value_t)>());
				position += static_cast<uint8_t>(sizeof(value_t));
				input = input.subspan(sizeof(value_t));
			}

			// unaligned suffix
			if (not input.empty()) {
				// xor and finish
				internal_state[position / sizeof(value_t)] ^= convert_prefix_into_value<value_t>(input, 0u);
				position += static_cast<uint8_t>(input.size());
			}

			return position;
		} else {
			const auto buffer = std::as_writable_bytes(std::span<uint64_t>(internal_state));
			const auto remaining = buffer.subspan(position);
			const auto place = remaining.first(std::min(input.size(), remaining.size()));

			std::transform(place.data(), place.data() + place.size(), input.data(), place.data(), [](std::byte lhs, auto rhs) { return lhs ^ static_cast<std::byte>(rhs); });

			position += static_cast<uint8_t>(place.size());
			return position;
		}
	}

	template <byte_like T> constexpr auto update(std::span<const T> input) noexcept {
		assert(position < rate);
		const size_t remaining_in_buffer = rate - position;

		if (remaining_in_buffer > input.size()) {
			// xor overwrite as much as we can, and that's all
			xor_overwrite_block(input);
			assert(position < rate);
			return;
		}

		// finish block and call keccak :)
		const auto first_part = input.first(remaining_in_buffer);
		input = input.subspan(remaining_in_buffer);
		xor_overwrite_block(first_part);
		assert(position == rate);
		keccak_f(internal_state);
		position = 0u;

		// for each full block we can absorb directly
		while (input.size() >= rate) {
			const auto block = input.template first<rate>();
			input = input.subspan(rate);
			assert(position == 0u);
			xor_overwrite_block<T>(block);
			keccak_f(internal_state);
			position = 0u;
		}

		// xor overwrite internal state with current remainder, and set position to end of it
		if (not input.empty()) {
			assert(position == 0u);
			xor_overwrite_block(input);
			assert(position < rate);
		}
	}

	// pad the message
	constexpr void xor_padding_block() noexcept {
		assert(position < rate);

		constexpr const auto & suffix = Config::suffix;
		constexpr std::byte suffix_and_start_of_padding = (suffix.values[0] | (std::byte{0b0000'0001u} << suffix.bits));

		internal_state[position / sizeof(uint64_t)] ^= uint64_t(suffix_and_start_of_padding) << ((position % sizeof(uint64_t)) * 8u);
		internal_state[(rate - 1u) / sizeof(uint64_t)] ^= 0x8000000000000000ull; // last bit
	}

	constexpr void final_absorb() noexcept {
		xor_padding_block();
		keccak_f(internal_state);
	}

	// get resulting hash
	constexpr void squeeze(std::span<std::byte> output) noexcept {
		using value_t = keccak::state_1600::value_type;

		static_assert((rate % sizeof(value_t)) == 0u);
		auto r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));

		// aligned results will be processed here...
		while ((output.size() >= sizeof(value_t))) {
			// if we ran out of `rate` part, we need to squeeze another block
			if (r.empty()) {
				keccak_f(internal_state);
				r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));
			}

			// look at current to process
			const value_t current = r.front();
			const auto part = output.first<sizeof(value_t)>();

			// convert
			unwrap_littleendian_number<value_t>{part} = current;

			// move to next
			r = r.subspan(1u);
			output = output.subspan(sizeof(value_t));
		}

		// unaligned result is here
		if (!output.empty()) {
			// if we ran out of `rate` part, we need to squeeze another block
			if (r.empty()) {
				keccak_f(internal_state);
				r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));
			}

			const value_t current = r.front();

			// convert
			std::array<std::byte, sizeof(value_t)> tmp;
			unwrap_littleendian_number<value_t>{tmp} = current;
			assert(tmp.size() > output.size());
			std::copy_n(tmp.data(), output.size(), output.data());
		}
	}

	constexpr void squeeze(digest_span_t output_fixed) noexcept
		requires((digest_length < rate) && digest_length != 0u)
	{
		auto output = std::span<std::byte>(output_fixed);

		// we don't need to squeeze anything
		using value_t = keccak::state_1600::value_type;

		static_assert((rate % sizeof(value_t)) == 0u);
		auto r = std::span<const value_t>(internal_state).first(rate / sizeof(value_t));

		// aligned results will be processed here...
		while ((output.size() >= sizeof(value_t))) {
			assert(!r.empty());
			// look at current to process
			const value_t current = r.front();
			const auto part = output.template first<sizeof(value_t)>();

			// convert
			unwrap_littleendian_number<value_t>{part} = current;

			// move to next
			r = r.subspan(1u);
			output = output.subspan(sizeof(value_t));
		}

		if constexpr ((output_fixed.size() % sizeof(value_t)) != 0u) {
			// unaligned result is here
			assert(!output.empty());
			assert(!r.empty());

			const value_t current = r.front();

			// convert
			std::array<std::byte, sizeof(value_t)> tmp;
			unwrap_littleendian_number<value_t>{tmp} = current;
			assert(tmp.size() > output.size());
			std::copy_n(tmp.data(), output.size(), output.data());
		}
	}

	constexpr void final(digest_span_t digest) noexcept
		requires(digest_length != 0u)
	{
		final_absorb();
		squeeze(digest);
	}

	constexpr result_t final() noexcept
		requires(digest_length != 0u)
	{
		result_t output;
		final(output);
		return output;
	}

	template <size_t N> constexpr auto final() noexcept
		requires(digest_length == 0u)
	{
		static_assert(N % 8u == 0u, "Only whole bytes are supported!");
		using result_type = typename Config::template variable_digest<N>;
		result_type output;
		final_absorb();
		squeeze(output);
		return output;
	}
};

template <typename Config> struct keccak_hasher: basic_keccak_hasher<Config> {
	using super = basic_keccak_hasher<Config>;
	using result_t = typename super::result_t;
	using digest_span_t = typename super::digest_span_t;

	constexpr keccak_hasher() noexcept: super() { }
	constexpr keccak_hasher(const keccak_hasher &) noexcept = default;
	constexpr keccak_hasher(keccak_hasher &&) noexcept = default;
	constexpr ~keccak_hasher() noexcept = default;

	constexpr keccak_hasher & update(std::span<const std::byte> input) noexcept {
		super::update(input);
		return *this;
	}

	template <convertible_to_byte_span T> constexpr keccak_hasher & update(const T & something) noexcept {
		using value_type = typename decltype(std::span(something))::value_type;
		super::update(std::span<const value_type>(something));
		return *this;
	}

	template <one_byte_char CharT> constexpr keccak_hasher & update(std::basic_string_view<CharT> in) noexcept {
		super::update(std::span(in.data(), in.size()));
		return *this;
	}

	template <string_literal T> constexpr keccak_hasher & update(const T & lit) noexcept {
		super::update(std::span(lit, std::size(lit) - 1u));
		return *this;
	}

	// TODO: any range with value convertible to byte

	using super::final;
};

template <size_t DigestBits>
struct sha_config {
	static constexpr size_t digest_length_bit = DigestBits;
	static constexpr size_t capacity_bit = DigestBits * 2u;
	static constexpr size_t rate_bit = 1600u - capacity_bit;

	static constexpr auto suffix = keccak_suffix(2, 0b0000'0010u); // in reverse
};

} // namespace cthash

#endif

```

`include/cthash/sha3/keccak-base.hpp`:

```hpp
#ifndef CTHASH_SHA3_KECCAK_BASE_HPP
#define CTHASH_SHA3_KECCAK_BASE_HPP

#include <array>
#include <bit>
#include <span>
#include <type_traits>
#include <utility>
#include <concepts>
#include <cstdint>

namespace cthash::keccak {

// inspired by tiny-keccak (https://github.com/debris/tiny-keccak from Marek Kotewicz)

static constexpr auto rho = std::array<uint8_t, 24>{1u, 3u, 6u, 10u, 15u, 21u, 28u, 36u, 45u, 55u, 2u, 14u, 27u, 41u, 56u, 8u, 25u, 43u, 62u, 18u, 39u, 61u, 20u, 44u};

static constexpr auto pi = std::array<uint8_t, 24>{10u, 7u, 11u, 17u, 18u, 3u, 5u, 16u, 8u, 21u, 24u, 4u, 15u, 23u, 19u, 13u, 12u, 2u, 20u, 14u, 22u, 9u, 6u, 1u};

static constexpr auto rc = std::array<uint64_t, 24>{0x1ULL, 0x8082ULL, 0x800000000000808aULL, 0x8000000080008000ULL, 0x808bULL, 0x80000001ULL, 0x8000000080008081ULL, 0x8000000000008009ULL, 0x8aULL, 0x88ULL, 0x80008009ULL, 0x8000000aULL, 0x8000808bULL, 0x800000000000008bULL, 0x8000000000008089ULL, 0x8000000000008003ULL, 0x8000000000008002ULL, 0x8000000000000080ULL, 0x800aULL, 0x800000008000000aULL, 0x8000000080008081ULL, 0x8000000000008080ULL, 0x80000001ULL, 0x8000000080008008ULL};

struct state_1600: std::array<uint64_t, (5u * 5u)> { };

struct state_1600_ref: std::span<uint64_t, (5u * 5u)> {
	using super = std::span<uint64_t, (5u * 5u)>;
	using super::super;
};

[[gnu::always_inline, gnu::flatten]] constexpr void theta(state_1600_ref state) noexcept {
	// xor of columns
	const auto b = std::array<uint64_t, 5>{
		state[0] xor state[5] xor state[10] xor state[15] xor state[20],
		state[1] xor state[6] xor state[11] xor state[16] xor state[21],
		state[2] xor state[7] xor state[12] xor state[17] xor state[22],
		state[3] xor state[8] xor state[13] xor state[18] xor state[23],
		state[4] xor state[9] xor state[14] xor state[19] xor state[24],
	};

	const auto tmp = std::array<uint64_t, 5>{
		b[4] xor std::rotl(b[1], 1),
		b[0] xor std::rotl(b[2], 1),
		b[1] xor std::rotl(b[3], 1),
		b[2] xor std::rotl(b[4], 1),
		b[3] xor std::rotl(b[0], 1),
	};

	[&]<size_t... Idx>(std::index_sequence<Idx...>) {
		((state[Idx] ^= tmp[Idx % 5u]), ...);
	}(std::make_index_sequence<25>());
}

[[gnu::always_inline, gnu::flatten]] constexpr void rho_pi(state_1600_ref state) noexcept {
	uint64_t tmp = state[1];

	[&]<size_t... Idx>(std::index_sequence<Idx...>) {
		((state[pi[Idx]] = std::rotl(std::exchange(tmp, state[pi[Idx]]), rho[Idx])), ...);
	}(std::make_index_sequence<24>());
}

[[gnu::always_inline, gnu::flatten]] constexpr void chi(state_1600_ref state) noexcept {
	constexpr auto chi_helper = [](std::span<uint64_t, 5> row) {
		const auto b = std::array<uint64_t, 5>{row[0], row[1], row[2], row[3], row[4]};

		row[0] = b[0] xor ((~b[1]) bitand b[2]);
		row[1] = b[1] xor ((~b[2]) bitand b[3]);
		row[2] = b[2] xor ((~b[3]) bitand b[4]);
		row[3] = b[3] xor ((~b[4]) bitand b[0]);
		row[4] = b[4] xor ((~b[0]) bitand b[1]);
	};

	chi_helper(state.subspan<0>().first<5>());
	chi_helper(state.subspan<5>().first<5>());
	chi_helper(state.subspan<10>().first<5>());
	chi_helper(state.subspan<15>().first<5>());
	chi_helper(state.subspan<20>().first<5>());
}

[[gnu::flatten]] constexpr void keccak_f(state_1600 & state) noexcept {
	// rounds
	for (int i = 0; i != 24; ++i) {
		// theta (xor each column together)
		theta(state);
		rho_pi(state);
		chi(state);
		state[0] ^= rc[static_cast<size_t>(i)];
	}
}

} // namespace cthash::keccak

#endif
```

`include/cthash/sha3/keccak.hpp`:

```hpp
#ifndef CTHASH_SHA3_KECCAK_HPP
#define CTHASH_SHA3_KECCAK_HPP

#include "common.hpp"

namespace cthash {

template <unsigned N> struct prenist_keccak_config {
	static constexpr size_t digest_length_bit = N;
	static constexpr size_t capacity_bit = digest_length_bit * 2u;
	static constexpr size_t rate_bit = 1600u - capacity_bit;

	// Keccak (pre-NIST) domain bit = 0x01
	static constexpr auto suffix = keccak_suffix(0, 0x00);
};

static_assert((prenist_keccak_config<256>::capacity_bit + prenist_keccak_config<256>::rate_bit) == 1600u);

using keccak_256 = cthash::keccak_hasher<prenist_keccak_config<256>>;
using keccak_256_value = tagged_hash_value<prenist_keccak_config<256>>;
using keccak_384 = cthash::keccak_hasher<prenist_keccak_config<384>>;
using keccak_384_value = tagged_hash_value<prenist_keccak_config<384>>;
using keccak_512 = cthash::keccak_hasher<prenist_keccak_config<512>>;
using keccak_512_value = tagged_hash_value<prenist_keccak_config<512>>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_keccak_256() {
		return keccak_256_value(Value);
	}

	template <fixed_string Value>
	consteval auto operator""_keccak_384() {
		return keccak_384_value(Value);
	}

	template <fixed_string Value>
	consteval auto operator""_keccak_512() {
		return keccak_512_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

```

`include/cthash/sha3/sha3-224.hpp`:

```hpp
#ifndef CTHASH_SHA3_SHA3_224_HPP
#define CTHASH_SHA3_SHA3_224_HPP

#include "sha3.hpp"

#endif

```

`include/cthash/sha3/sha3-256.hpp`:

```hpp
#ifndef CTHASH_SHA3_SHA3_256_HPP
#define CTHASH_SHA3_SHA3_256_HPP

#include "sha3.hpp"

#endif

```

`include/cthash/sha3/sha3-384.hpp`:

```hpp
#ifndef CTHASH_SHA3_SHA3_384_HPP
#define CTHASH_SHA3_SHA3_384_HPP

#include "sha3.hpp"

#endif

```

`include/cthash/sha3/sha3-512.hpp`:

```hpp
#ifndef CTHASH_SHA3_SHA3_512_HPP
#define CTHASH_SHA3_SHA3_512_HPP

#include "sha3.hpp"

#endif

```

`include/cthash/sha3/sha3.hpp`:

```hpp
#ifndef CTHASH_SHA3_SHA3_HPP
#define CTHASH_SHA3_SHA3_HPP

#include "common.hpp"

namespace cthash {

using sha3_224_config = sha_config<224u>;
static_assert((sha3_224_config::capacity_bit + sha3_224_config::rate_bit) == 1600u);

using sha3_256_config = sha_config<256u>;
static_assert((sha3_256_config::capacity_bit + sha3_256_config::rate_bit) == 1600u);

using sha3_384_config = sha_config<384u>;
static_assert((sha3_384_config::capacity_bit + sha3_384_config::rate_bit) == 1600u);

using sha3_512_config = sha_config<512u>;
static_assert((sha3_512_config::capacity_bit + sha3_512_config::rate_bit) == 1600u);

// hasher and value type
using sha3_224 = cthash::keccak_hasher<sha3_224_config>;
using sha3_224_value = tagged_hash_value<sha3_224_config>;
using sha3_256 = cthash::keccak_hasher<sha3_256_config>;
using sha3_256_value = tagged_hash_value<sha3_256_config>;
using sha3_384 = cthash::keccak_hasher<sha3_384_config>;
using sha3_384_value = tagged_hash_value<sha3_384_config>;
using sha3_512 = cthash::keccak_hasher<sha3_512_config>;
using sha3_512_value = tagged_hash_value<sha3_512_config>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_sha3_224() {
		return sha3_224_value(Value);
	}

	template <fixed_string Value>
	consteval auto operator""_sha3_256() {
		return sha3_256_value(Value);
	}

	template <fixed_string Value>
	consteval auto operator""_sha3_384() {
		return sha3_384_value(Value);
	}

	template <fixed_string Value>
	consteval auto operator""_sha3_512() {
		return sha3_512_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

```

`include/cthash/sha3/shake128.hpp`:

```hpp
#ifndef CTHASH_SHA3_SHAKE128_HPP
#define CTHASH_SHA3_SHAKE128_HPP

#include "common.hpp"

namespace cthash {

template <size_t N> struct shake128_value;

struct shake128_config {
	template <size_t N> using variable_digest = shake128_value<N>;

	static constexpr size_t digest_length_bit = 0;

	static constexpr size_t capacity_bit = 256;
	static constexpr size_t rate_bit = 1344;

	static constexpr auto suffix = keccak_suffix(4, 0b0000'1111u); // in reverse
};

static_assert((shake128_config::capacity_bit + shake128_config::rate_bit) == 1600u);

using shake128 = cthash::keccak_hasher<shake128_config>;

template <size_t N> struct shake128_value: tagged_hash_value<variable_bit_length_tag<N, shake128_config>> {
	static_assert(N > 0);
	using super = tagged_hash_value<variable_bit_length_tag<N, shake128_config>>;
	using super::super;

	template <typename CharT> explicit constexpr shake128_value(const fixed_string<CharT, N / 8u> & in) noexcept: super{in} { }

	template <size_t K> constexpr friend bool operator==(const shake128_value & lhs, const shake128_value<K> & rhs) noexcept {
		static_assert(K > 0);
		constexpr auto smallest_n = std::min(N, K);
		const auto lhs_view = std::span<const std::byte, smallest_n / 8u>(lhs.data(), smallest_n / 8u);
		const auto rhs_view = std::span<const std::byte, smallest_n / 8u>(rhs.data(), smallest_n / 8u);
		return std::equal(lhs_view.begin(), lhs_view.end(), rhs_view.begin());
	}

	template <size_t K> constexpr friend auto operator<=>(const shake128_value & lhs, const shake128_value<K> & rhs) noexcept {
		static_assert(K > 0);
		constexpr auto smallest_n = std::min(N, K);
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), smallest_n / 8u);
	}
};

template <typename CharT, size_t N>
requires(N % 2 == 0)
shake128_value(const fixed_string<CharT, N> &) -> shake128_value<N * 4u>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_shake128() {
		return shake128_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

```

`include/cthash/sha3/shake256.hpp`:

```hpp
#ifndef CTHASH_SHA3_SHAKE256_HPP
#define CTHASH_SHA3_SHAKE256_HPP

#include "common.hpp"

namespace cthash {

template <size_t N> struct shake256_value;

struct shake256_config {
	template <size_t N> using variable_digest = shake256_value<N>;

	static constexpr size_t digest_length_bit = 0;

	static constexpr size_t capacity_bit = 512;
	static constexpr size_t rate_bit = 1088;

	static constexpr auto suffix = keccak_suffix(4, 0b0000'1111u); // in reverse
};

static_assert((shake256_config::capacity_bit + shake256_config::rate_bit) == 1600u);

using shake256 = cthash::keccak_hasher<shake256_config>;

template <size_t N> struct shake256_value: tagged_hash_value<variable_bit_length_tag<N, shake256_config>> {
	static_assert(N > 0);
	using super = tagged_hash_value<variable_bit_length_tag<N, shake256_config>>;
	using super::super;

	template <typename CharT> explicit constexpr shake256_value(const fixed_string<CharT, N / 8u> & in) noexcept: super{in} { }

	template <size_t K> constexpr friend bool operator==(const shake256_value & lhs, const shake256_value<K> & rhs) noexcept {
		constexpr auto smallest_n = std::min(N, K);
		const auto lhs_view = std::span<const std::byte, smallest_n / 8u>(lhs.data(), smallest_n / 8u);
		const auto rhs_view = std::span<const std::byte, smallest_n / 8u>(rhs.data(), smallest_n / 8u);
		return std::equal(lhs_view.begin(), lhs_view.end(), rhs_view.begin());
	}

	template <size_t K> constexpr friend auto operator<=>(const shake256_value & lhs, const shake256_value<K> & rhs) noexcept {
		constexpr auto smallest_n = std::min(N, K);
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), smallest_n / 8u);
	}
};

template <typename CharT, size_t N>
requires(N % 2 == 0)
shake256_value(const fixed_string<CharT, N> &) -> shake256_value<N * 4u>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_shake256() {
		return shake256_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

```

`include/cthash/simple.hpp`:

```hpp
#ifndef CTHASH_SIMPLE_HPP
#define CTHASH_SIMPLE_HPP

#include <utility>

namespace cthash {

template <typename Hasher, typename In, typename... Args> concept hasher_like = requires(Hasher & h, const In & in, Args &&... args) //
{
	{ Hasher{std::forward<Args>(args)...} };
	{ h.update(in) } -> std::same_as<Hasher &>;
	{ h.final() };
};

template <typename Hasher, typename In> concept direct_hasher = requires(Hasher & h, const In & in) //
{
	{ h.update_and_final(in) };
};

template <typename Hasher, typename T, typename... Args>
requires hasher_like<Hasher, T, Args...>
constexpr auto simple(const T & value, Args &&... args) noexcept {
	if constexpr (direct_hasher<Hasher, T>) {
		return Hasher{std::forward<Args>(args)...}.update_and_final(value);
	} else {
		return Hasher{std::forward<Args>(args)...}.update(value).final();
	}
}

} // namespace cthash

#endif

```

`include/cthash/value.hpp`:

```hpp
#ifndef CTHASH_VALUE_HPP
#define CTHASH_VALUE_HPP

#include "fixed-string.hpp"
#include "encoding/base.hpp"
#include "encoding/encodings.hpp"
#include "internal/algorithm.hpp"
#include "internal/deduce.hpp"
#include "internal/hexdec.hpp"
#include <algorithm>
#include <array>
#include <format>
#include <span>
#include <string_view>
#include <compare>

namespace cthash {

// hash_value

template <size_t N> struct hash_value: std::array<std::byte, N> {
	using super = std::array<std::byte, N>;

	constexpr hash_value() noexcept: super{} { }
	explicit constexpr hash_value(super && s) noexcept: super(s) { }
	template <typename CharT> explicit constexpr hash_value(const CharT (&in)[N * 2u + 1u]) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in, N * 2u))} { }
	template <typename CharT> explicit constexpr hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{internal::hexdec_to_binary<N>(std::span<const CharT, N * 2u>(in.data(), in.size()))} { }

	// comparison support
	constexpr friend bool operator==(const hash_value & lhs, const hash_value & rhs) noexcept = default;
	constexpr friend auto operator<=>(const hash_value & lhs, const hash_value & rhs) noexcept -> std::strong_ordering {
		return internal::threeway_compare_of_same_size(lhs.data(), rhs.data(), N);
	}

	template <typename Encoding = cthash::encoding::hexdec, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		auto hexdec_view = *this | cthash::encode_to<Encoding, CharT>;
		std::ranges::copy(hexdec_view, std::ostream_iterator<CharT, CharT>(os));
		return os;
	}

	// print to ostream support
	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const hash_value & val) {
		return val.print_into(os);
	}

	template <size_t PrefixN> constexpr auto prefix() const noexcept requires(PrefixN <= N) {
		hash_value<PrefixN> output{};
		std::ranges::copy(this->begin(), this->begin() + PrefixN, output.begin());
		return output;
	}

	template <size_t SuffixN> constexpr auto suffix() const noexcept requires(SuffixN <= N) {
		hash_value<SuffixN> output{};
		std::ranges::copy(this->end() - SuffixN, this->end(), output.begin());
		return output;
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
#if __cpp_lib_ranges_to_container >= 202202L
		return std::ranges::to<std::basic_string<CharT>>(encoded);
#else
		auto result = std::basic_string<CharT>{};
		result.resize(encoded.size());
		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());
		return result;
#endif
	}
	template <typename Encoding = cthash::encoding::hexdec, typename CharT = char> constexpr friend auto to_fixed_string(const hash_value & value) {
		const auto encoded = value | cthash::encode_to<Encoding, CharT>;
		// it's type dependendent so we can calculate the size...
		constexpr size_t size_needed = (hash_value{} | cthash::encode_to<Encoding, CharT>).size();

		auto result = cthash::fixed_string<CharT, size_needed>{nullptr};

		auto [i, o] = std::ranges::copy(encoded.begin(), encoded.end(), result.begin());
		assert(i == encoded.end());
		assert(o == result.end());

		return result;
	}
};

template <typename CharT, size_t N> hash_value(const CharT (&)[N]) -> hash_value<(N - 1u) / 2u>;
template <typename CharT, size_t N> hash_value(std::span<const CharT, N>) -> hash_value<N / 2u>;
template <typename CharT, size_t N> hash_value(const fixed_string<CharT, N> &) -> hash_value<N / 2u>;

template <typename> struct default_encoding {
	using encoding = cthash::encoding::hexdec;
};

template <typename Tag> concept tag_with_encoding = requires() {
	typename Tag::encoding;
};

template <tag_with_encoding Tag> struct default_encoding<Tag> {
	using encoding = Tag::encoding;
};

template <typename Tag, size_t = internal::digest_bytes_length_of<Tag>> struct tagged_hash_value: hash_value<internal::digest_bytes_length_of<Tag>> {
	static constexpr size_t N = internal::digest_bytes_length_of<Tag>;

	using super = hash_value<N>;
	using super::super;
	template <typename CharT> explicit constexpr tagged_hash_value(const fixed_string<CharT, N * 2u> & in) noexcept: super{in} { }

	static constexpr size_t digest_length = N;

	template <typename Encoding = default_encoding<Tag>::encoding, typename CharT, typename Traits> constexpr auto & print_into(std::basic_ostream<CharT, Traits> & os) const {
		return super::template print_into<Encoding>(os);
	}

	template <typename CharT, typename Traits> constexpr friend auto & operator<<(std::basic_ostream<CharT, Traits> & os, const tagged_hash_value & val) {
		return val.print_into(os);
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_string(const tagged_hash_value & value) {
		return to_string<Encoding, CharT>(static_cast<const super &>(value));
	}

	template <typename Encoding = typename cthash::default_encoding<Tag>::encoding, typename CharT = char> constexpr friend auto to_fixed_string(const tagged_hash_value & value) {
		return to_fixed_string<Encoding, CharT>(static_cast<const super &>(value));
	}
};

template <typename T> concept variable_digest_length = T::digest_length_bit == 0u;

template <size_t N, variable_digest_length Tag> struct variable_bit_length_tag: Tag {
	static constexpr size_t digest_length_bit = N;
};

template <typename T> concept convertible_to_tagged_hash_value = requires(const T & obj) {
	{ tagged_hash_value{obj} };
};

namespace literals {

	template <fixed_string Value>
	constexpr auto operator""_hash() {
		return hash_value(Value);
	}

} // namespace literals

} // namespace cthash

namespace std {

#if __cpp_lib_format >= 201907L
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#if _LIBCPP_VERSION >= 170000
// libc++ will define __cpp_lib_format macro in 19.0
// https://github.com/llvm/llvm-project/issues/77773
#define CTHASH_STDFMT_AVAILABLE 1
#endif

#ifdef CTHASH_STDFMT_AVAILABLE
template <size_t N, typename CharT>
struct formatter<cthash::hash_value<N>, CharT> {
	using subject_type = cthash::hash_value<N>;
	using default_encoding = cthash::encoding::hexdec;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <typename Tag, size_t N, typename CharT>
struct formatter<cthash::tagged_hash_value<Tag, N>, CharT> {
	using subject_type = cthash::tagged_hash_value<Tag, N>;
	using default_encoding = typename cthash::default_encoding<Tag>::encoding;

	cthash::runtime_encoding encoding{default_encoding{}};

	template <typename ParseContext> constexpr auto parse(ParseContext & ctx) {
		auto [enc, out] = cthash::select_encoding<cthash::runtime_encoding, default_encoding>(ctx);
		this->encoding = enc;
		return out;
	}

	template <typename FormatContext> constexpr auto format(const subject_type & value, FormatContext & ctx) const {
		return encoding.visit([&]<typename SelectedEncoding>(SelectedEncoding) {
			return std::ranges::copy(value | cthash::encode_to<SelectedEncoding, CharT>, ctx.out()).out;
		});
	}
};

template <cthash::convertible_to_tagged_hash_value Type, typename CharT> struct formatter<Type, CharT>: formatter<decltype(cthash::tagged_hash_value{std::declval<Type>()}), CharT> {
};

#endif

} // namespace std

#endif

```

`include/cthash/xxhash.hpp`:

```hpp
#ifndef CTHASH_XXHASH_HPP
#define CTHASH_XXHASH_HPP

#include "simple.hpp"
#include "value.hpp"
#include "internal/bit.hpp"
#include "internal/concepts.hpp"
#include "internal/convert.hpp"
#include "internal/deduce.hpp"
#include <array>
#include <span>
#include <string_view>
#include <cstdint>

namespace cthash {

template <size_t Bits> struct xxhash_types;

template <std::unsigned_integral T, byte_like Byte> constexpr auto read_le_number_from(std::span<const Byte> & input) noexcept {
	assert(input.size() >= sizeof(T));

	const auto r = cast_from_le_bytes<T>(input.template first<sizeof(T)>());
	input = input.subspan(sizeof(T));

	return r;
}

template <std::unsigned_integral T, size_t Off, byte_like Byte, size_t N> constexpr auto get_le_number_from(std::span<const Byte, N> input) noexcept {
	return cast_from_le_bytes<T>(input.template subspan<Off * sizeof(T), sizeof(T)>());
}

template <> struct xxhash_types<32> {
	using value_type = uint32_t;
	using acc_array = std::array<value_type, 4>;
	static constexpr auto primes = std::array<value_type, 5>{2654435761U, 2246822519U, 3266489917U, 668265263U, 374761393U};

	static constexpr auto round(value_type accN, value_type laneN) noexcept -> value_type {
		return std::rotl(accN + (laneN * primes[1]), 13u) * primes[0];
	}

	static constexpr auto convergence(const acc_array & accs) noexcept -> value_type {
		return std::rotl(accs[0], 1u) + std::rotl(accs[1], 7u) + std::rotl(accs[2], 12u) + std::rotl(accs[3], 18u);
	}

	template <byte_like Byte> static constexpr auto consume_remaining(value_type acc, std::span<const Byte> input) noexcept -> value_type {
		assert(input.size() < sizeof(acc_array));

		while (input.size() >= sizeof(uint32_t)) {
			const auto lane = read_le_number_from<uint32_t>(input);
			acc = std::rotl(acc + (lane * primes[2]), 17u) * primes[3];
		}

		while (input.size() >= 1u) {
			const auto lane = read_le_number_from<uint8_t>(input);
			acc = std::rotl(acc + lane * primes[4], 11u) * primes[0];
		}

		return acc;
	}

	static constexpr auto avalanche(value_type acc) noexcept -> value_type {
		acc = (acc xor (acc >> 15u)) * primes[1];
		acc = (acc xor (acc >> 13u)) * primes[2];
		return (acc xor (acc >> 16u));
	}
};

template <> struct xxhash_types<64> {
	using value_type = uint64_t;
	using acc_array = std::array<value_type, 4>;
	static constexpr auto primes = std::array<value_type, 5>{11400714785074694791ULL, 14029467366897019727ULL, 1609587929392839161ULL, 9650029242287828579ULL, 2870177450012600261ULL};

	static constexpr auto round(value_type accN, value_type laneN) noexcept -> value_type {
		return std::rotl(accN + (laneN * primes[1]), 31u) * primes[0];
	}

	static constexpr auto convergence(const acc_array & accs) noexcept -> value_type {
		constexpr auto merge = [](value_type acc, value_type accN) {
			return ((acc xor round(0, accN)) * primes[0]) + primes[3];
		};

		value_type acc = std::rotl(accs[0], 1u) + std::rotl(accs[1], 7u) + std::rotl(accs[2], 12u) + std::rotl(accs[3], 18u);
		acc = merge(acc, accs[0]);
		acc = merge(acc, accs[1]);
		acc = merge(acc, accs[2]);
		return merge(acc, accs[3]);
	}

	template <byte_like Byte> static constexpr auto consume_remaining(value_type acc, std::span<const Byte> input) noexcept -> value_type {
		assert(input.size() < sizeof(acc_array));

		while (input.size() >= sizeof(uint64_t)) {
			const auto lane = read_le_number_from<uint64_t>(input);
			acc = (std::rotl(acc xor round(0, lane), 27u) * primes[0]) + primes[3];
		}

		if (input.size() >= sizeof(uint32_t)) {
			const auto lane = read_le_number_from<uint32_t>(input);
			acc = (std::rotl(acc xor (lane * primes[0]), 23u) * primes[1]) + primes[2];
		}

		while (input.size() >= 1u) {
			const auto lane = read_le_number_from<uint8_t>(input);
			acc = (std::rotl(acc xor (lane * primes[4]), 11u) * primes[0]);
		}

		return acc;
	}

	static constexpr auto avalanche(value_type acc) noexcept -> value_type {
		acc = (acc xor (acc >> 33u)) * primes[1];
		acc = (acc xor (acc >> 29u)) * primes[2];
		return (acc xor (acc >> 32u));
	}
};

template <size_t Bits> struct xxhash {
	static_assert(Bits == 32u || Bits == 64u);

	struct tag {
		static constexpr size_t digest_length = Bits / 8u;
	};

	using config = xxhash_types<Bits>;
	using acc_array = typename config::acc_array;
	using value_type = typename config::value_type;

	using digest_span_t = std::span<std::byte, Bits / 8u>;

	// members
	value_type seed{0u};
	value_type length{0u};
	acc_array internal_state{};
	std::array<std::byte, sizeof(value_type) * 4u> buffer{};

	// step 1 in constructor
	explicit constexpr xxhash(value_type s = 0u) noexcept: seed{s}, internal_state{seed + config::primes[0] + config::primes[1], seed + config::primes[1], seed, seed - config::primes[0]} { }

	template <byte_like Byte> constexpr void process_lanes(std::span<const Byte, sizeof(acc_array)> lanes) noexcept {
		// step 2: process lanes
		internal_state[0] = config::round(internal_state[0], get_le_number_from<value_type, 0>(lanes));
		internal_state[1] = config::round(internal_state[1], get_le_number_from<value_type, 1>(lanes));
		internal_state[2] = config::round(internal_state[2], get_le_number_from<value_type, 2>(lanes));
		internal_state[3] = config::round(internal_state[3], get_le_number_from<value_type, 3>(lanes));
	}

	constexpr size_t buffer_usage() const noexcept {
		return length % buffer.size();
	}

	template <byte_like Byte> constexpr void process_blocks(std::span<const Byte> & input) noexcept {
		while (input.size() >= buffer.size()) {
			const auto current_lanes = input.template first<sizeof(acc_array)>();
			input = input.subspan(buffer.size());

			process_lanes(current_lanes);
		}
	}

	template <byte_like Byte> [[gnu::flatten]] constexpr xxhash & update(std::span<const Byte> input) noexcept {
		const auto buffer_remaining = std::span(buffer).subspan(buffer_usage());

		// everything we insert here is counting as part of input (even if we process it later)
		length += static_cast<uint8_t>(input.size());

		// if there is remaining data from previous...
		if (buffer_remaining.size() != buffer.size()) {
			const auto to_copy = input.first(std::min(input.size(), buffer_remaining.size()));
			byte_copy(to_copy.begin(), to_copy.end(), buffer_remaining.begin());
			input = input.subspan(to_copy.size());

			// if we didn't fill current block, we will do it later
			if (buffer_remaining.size() != to_copy.size()) {
				assert(input.size() == 0u);
				return *this;
			}

			// but if we did, we need to process it
			const auto full_buffer_view = std::span<const std::byte, sizeof(acc_array)>(buffer);
			process_lanes(full_buffer_view);
		}

		// process blocks
		process_blocks(input);

		// copy remainder of input to the buffer, so it's processed later
		byte_copy(input.begin(), input.end(), buffer.begin());
		return *this;
	}

	template <one_byte_char CharT> [[gnu::flatten]] constexpr xxhash & update(std::basic_string_view<CharT> input) noexcept {
		return update(std::span<const CharT>(input.data(), input.size()));
	}

	template <string_literal T> [[gnu::flatten]] constexpr xxhash & update(const T & input) noexcept {
		return update(std::span(std::data(input), std::size(input) - 1u));
	}

	// TODO: any range with value convertible to byte

	template <byte_like Byte> [[gnu::flatten]] constexpr auto update_and_final(std::span<const Byte> input) noexcept {
		length = static_cast<value_type>(input.size());
		process_blocks(input);
		tagged_hash_value<tag> output;
		final_from(input, output);
		return output;
	}

	template <one_byte_char CharT> [[gnu::flatten]] constexpr auto update_and_final(std::basic_string_view<CharT> input) noexcept {
		return update_and_final(std::span<const CharT>(input.data(), input.size()));
	}

	template <string_literal T> [[gnu::flatten]] constexpr auto update_and_final(const T & input) noexcept {
		return update_and_final(std::span(std::data(input), std::size(input) - 1u));
	}

	constexpr auto converge_conditionaly() const noexcept -> value_type {
		// step 1 shortcut for short input
		if (length < buffer.size()) {
			return seed + config::primes[4];
		}

		// otherwise we need to merge&converge internal state
		return config::convergence(internal_state);
	}

	template <byte_like Byte> constexpr void final_from(std::span<const Byte> source, digest_span_t out) const noexcept {
		assert(source.size() < buffer.size());

		value_type acc = converge_conditionaly();

		// step 4: add input length
		acc += static_cast<value_type>(length);

		// step 5: consume remainder (not finished block from buffer)
		acc = config::consume_remaining(acc, source);

		// step 6: final mix/avalanche
		acc = config::avalanche(acc);

		// convert to big endian representation
		unwrap_bigendian_number<value_type>{out} = acc;
	}

	[[gnu::flatten]] constexpr void final(digest_span_t out) const noexcept {
		const auto buffer_used = std::span<const std::byte>(buffer).first(buffer_usage());
		final_from(buffer_used, out);
	}

	[[gnu::flatten]] constexpr auto final() const noexcept -> tagged_hash_value<tag> {
		tagged_hash_value<tag> output;
		this->final(output);
		return output;
	}
};

using xxhash32 = cthash::xxhash<32>;
using xxhash32_value = tagged_hash_value<xxhash32::tag>;

using xxhash64 = cthash::xxhash<64>;
using xxhash64_value = tagged_hash_value<xxhash64::tag>;

namespace literals {

	template <fixed_string Value>
	consteval auto operator""_xxh32() {
		return xxhash32_value(Value);
	}

	template <fixed_string Value>
	consteval auto operator""_xxh64() {
		return xxhash64_value(Value);
	}

} // namespace literals

} // namespace cthash

#endif

```

`tests/CMakeLists.txt`:

```txt
if (NOT TARGET Catch2)
find_package(Catch2 3 REQUIRED)
endif()

add_executable(test-runner
	benchmark/sha3-256.cpp
	benchmark/sha512.cpp
	benchmark/sha256.cpp
	sha2/sha512.cpp
	sha2/sha256.cpp
	sha2/sha512t.cpp
	sha2/sha384.cpp
	sha2/sha224.cpp
	sha3/sha3-384.cpp
	sha3/sha3-224.cpp
	sha3/sha3-256.cpp
	sha3/keccak-256.cpp
	sha3/keccak-384.cpp
	sha3/keccak-512.cpp
	sha3/shake256.cpp
	sha3/shake128.cpp
	sha3/sha3-512.cpp
	sha3/xor-overwrite.cpp
	encoding/bit-buffer.cpp
	encoding/base.cpp
	encoding/chunk-of-bits.cpp
	encoding/selection.cpp
	value.cpp
	xxhash/basics.cpp
	keccak.cpp
	hexdec.cpp
)

option(MEASURE_OPENSSL "Measure also OpenSSL" OFF)

if (MEASURE_OPENSSL)
find_package(OpenSSL COMPONENTS Crypto)
if (OpenSSL_FOUND)
target_link_libraries(test-runner PRIVATE OpenSSL::Crypto)
target_compile_definitions(test-runner PRIVATE OPENSSL_BENCHMARK OPENSSL_SUPPRESS_DEPRECATED)
endif()
endif()

target_link_libraries(test-runner PRIVATE Catch2::Catch2WithMain cthash)
target_compile_features(test-runner PUBLIC cxx_std_20)

add_custom_target(test test-runner --skip-benchmarks --colour-mode ansi "" DEPENDS test-runner)
add_custom_target(long-test test-runner --skip-benchmarks --colour-mode ansi "*,[.long]" DEPENDS test-runner)
add_custom_target(benchmark test-runner --colour-mode ansi "" DEPENDS test-runner)


if (CTHASH_COVERAGE)
	coverage_report_after(test test-runner)
endif()
```

`tests/benchmark/sha256.cpp`:

```cpp
#include "../internal/support.hpp"
#include <cthash/sha2/sha256.hpp>
#include <catch2/benchmark/catch_benchmark.hpp>
#include <catch2/catch_test_macros.hpp>

using namespace cthash::literals;

TEST_CASE("sha256 measurements") {
	std::array<std::byte, 1024> input{};

	for (int i = 0; i != (int)input.size(); ++i) {
		input[static_cast<size_t>(i)] = static_cast<std::byte>(i);
	}

	BENCHMARK("16 byte input") {
		return cthash::sha256{}.update(std::span(runtime_pass(input)).first(16)).final();
	};

	BENCHMARK("32 byte input") {
		return cthash::sha256{}.update(std::span(runtime_pass(input)).first(32)).final();
	};

	BENCHMARK("48 byte input") {
		return cthash::sha256{}.update(std::span(runtime_pass(input)).first(48)).final();
	};

	BENCHMARK("64 byte input") {
		return cthash::sha256{}.update(std::span(runtime_pass(input)).first(64)).final();
	};

	BENCHMARK("96 byte input") {
		return cthash::sha256{}.update(std::span(runtime_pass(input)).first(96)).final();
	};

	BENCHMARK("10kB input") {
		auto h = cthash::sha256{};
		for (int i = 0; i != 10; ++i) {
			h.update(std::span(runtime_pass(input)).first(1024));
		}
		return h.final();
	};

	BENCHMARK("1MB input") {
		auto h = cthash::sha256{};
		for (int i = 0; i != 1024; ++i) {
			h.update(std::span(runtime_pass(input)).first(1024));
		}
		return h.final();
	};

	BENCHMARK("10MB input") {
		auto h = cthash::sha256{};
		for (int i = 0; i != 10 * 1024; ++i) {
			h.update(std::span(runtime_pass(input)).first(1024));
		}
		return h.final();
	};
}

#ifdef OPENSSL_BENCHMARK

#include <openssl/sha.h>

TEST_CASE("openssl sha256 measurements") {
	std::array<std::byte, 1024> input{};

	for (int i = 0; i != (int)input.size(); ++i) {
		input[static_cast<size_t>(i)] = static_cast<std::byte>(i);
	}

	BENCHMARK("16 byte input") {
		SHA256_CTX ctx;
		SHA256_Init(&ctx);
		const auto data = std::span(runtime_pass(input)).first(16);
		SHA256_Update(&ctx, data.data(), data.size());
		std::array<unsigned char, 32> res;
		SHA256_Final(res.data(), &ctx);
		return res;
	};

	BENCHMARK("32 byte input") {
		SHA256_CTX ctx;
		SHA256_Init(&ctx);
		const auto data = std::span(runtime_pass(input)).first(32);
		SHA256_Update(&ctx, data.data(), data.size());
		std::array<unsigned char, 32> res;
		SHA256_Final(res.data(), &ctx);
		return res;
	};

	BENCHMARK("48 byte input") {
		SHA256_CTX ctx;
		SHA256_Init(&ctx);
		const auto data = std::span(runtime_pass(input)).first(48);
		SHA256_Update(&ctx, data.data(), data.size());
		std::array<unsigned char, 32> res;
		SHA256_Final(res.data(), &ctx);
		return res;
	};

	BENCHMARK("64 byte input") {
		SHA256_CTX ctx;
		SHA256_Init(&ctx);
		const auto data = std::span(runtime_pass(input)).first(64);
		SHA256_Update(&ctx, data.data(), data.size());
		std::array<unsigned char, 32> res;
		SHA256_Final(res.data(), &ctx);
		return res;
	};

	BENCHMARK("96 byte input") {
		SHA256_CTX ctx;
		SHA256_Init(&ctx);
		const auto data = std::span(runtime_pass(input)).first(96);
		SHA256_Update(&ctx, data.data(), data.size());
		std::array<unsigned char, 32> res;
		SHA256_Final(res.data(), &ctx);
		return res;
	};

	BENCHMARK("10kB input") {
		SHA256_CTX ctx;
		SHA256_Init(&ctx);

		for (int i = 0; i != 10; ++i) {
			const auto data = std::span(runtime_pass(input)).first(1024);
			SHA256_Update(&ctx, data.data(), data.size());
		}

		std::array<unsigned char, 32> res;
		SHA256_Final(res.data(), &ctx);
		return res;
	};

	BENCHMARK("1MB input") {
		SHA256_CTX ctx;
		SHA256_Init(&ctx);

		for (int i = 0; i != 1024; ++i) {
			const auto data = std::span(runtime_pass(input)).first(1024);
			SHA256_Update(&ctx, data.data(), data.size());
		}

		std::array<unsigned char, 32> res;
		SHA256_Final(res.data(), &ctx);
		return res;
	};

	BENCHMARK("10MB input") {
		SHA256_CTX ctx;
		SHA256_Init(&ctx);

		for (int i = 0; i != 10 * 1024; ++i) {
			const auto data = std::span(runtime_pass(input)).first(1024);
			SHA256_Update(&ctx, data.data(), data.size());
		}

		std::array<unsigned char, 32> res;
		SHA256_Final(res.data(), &ctx);
		return res;
	};
}

#endif
```

`tests/benchmark/sha3-256.cpp`:

```cpp
#include "../internal/support.hpp"
#include <cthash/sha3/sha3-256.hpp>
#include <memory>
#include <catch2/benchmark/catch_benchmark.hpp>
#include <catch2/catch_test_macros.hpp>

using namespace cthash::literals;

TEST_CASE("sha3-256 measurements", "[keccak-bench]") {
	std::array<std::byte, 1024> input{};

	for (int i = 0; i != (int)input.size(); ++i) {
		input[size_t(i)] = static_cast<std::byte>(i);
	}

	BENCHMARK("16 byte input") {
		return cthash::sha3_256{}.update(std::span(runtime_pass(input)).first(16)).final();
	};

	BENCHMARK("32 byte input") {
		return cthash::sha3_256{}.update(std::span(runtime_pass(input)).first(32)).final();
	};

	BENCHMARK("48 byte input") {
		return cthash::sha3_256{}.update(std::span(runtime_pass(input)).first(48)).final();
	};

	BENCHMARK("64 byte input") {
		return cthash::sha3_256{}.update(std::span(runtime_pass(input)).first(64)).final();
	};

	BENCHMARK("96 byte input") {
		return cthash::sha3_256{}.update(std::span(runtime_pass(input)).first(96)).final();
	};

	BENCHMARK("10kB input") {
		auto h = cthash::sha3_256{};
		for (int i = 0; i != 10; ++i) {
			h.update(std::span(runtime_pass(input)).first(1024));
		}
		return h.final();
	};

	BENCHMARK("1MB input") {
		auto h = cthash::sha3_256{};
		for (int i = 0; i != 1024; ++i) {
			h.update(std::span(runtime_pass(input)).first(1024));
		}
		return h.final();
	};

	BENCHMARK("2MB input") {
		auto h = cthash::sha3_256{};
		for (int i = 0; i != 2 * 1024; ++i) {
			h.update(std::span(runtime_pass(input)).first(1024));
		}
		return h.final();
	};

	BENCHMARK("4MB input") {
		auto h = cthash::sha3_256{};
		for (int i = 0; i != 4 * 1024; ++i) {
			h.update(std::span(runtime_pass(input)).first(1024));
		}
		return h.final();
	};

	BENCHMARK("8MB input") {
		auto h = cthash::sha3_256{};
		for (int i = 0; i != 8 * 1024; ++i) {
			h.update(std::span(runtime_pass(input)).first(1024));
		}
		return h.final();
	};
}

#ifdef OPENSSL_BENCHMARK

#include <openssl/evp.h>
#include <openssl/sha.h>

struct EVP_destroy {
	void operator()(EVP_MD_CTX * ptr) noexcept {
		EVP_MD_CTX_destroy(ptr);
	}
};

using unique_evp_ptr = std::unique_ptr<EVP_MD_CTX, EVP_destroy>;

unique_evp_ptr openssl_sha3_256_init() {
	const EVP_MD * algorithm = EVP_sha3_256();
	REQUIRE(algorithm != nullptr);
	EVP_MD_CTX * context = EVP_MD_CTX_create();
	EVP_DigestInit_ex(context, algorithm, nullptr);
	return unique_evp_ptr(context);
}

template <cthash::byte_like Byte> void openssl_sha3_256_update(unique_evp_ptr & ctx, std::span<const Byte> in) {
	EVP_DigestUpdate(ctx.get(), in.data(), in.size());
}

auto openssl_sha3_256_final(unique_evp_ptr & ctx) -> cthash::sha3_256_value {
	cthash::sha3_256_value out;
	unsigned length{0};
	EVP_DigestFinal_ex(ctx.get(), reinterpret_cast<unsigned char *>(out.data()), &length);
	REQUIRE(size_t(length) == out.size());
	return out;
}

TEST_CASE("check openssl first", "[openssl-test]") {
	using namespace std::string_view_literals;

	auto ctx = openssl_sha3_256_init();
	openssl_sha3_256_update(ctx, std::span<const char>("hanicka"sv));
	const auto res = openssl_sha3_256_final(ctx);
	bool correct = res == "8f8b0b8af4c371e91791b1ddb2d0788661dd687060404af6320971bcc53b44fb"_sha3_256;
	REQUIRE(correct);
}

TEST_CASE("openssl sha3-256 measurements", "[keccak-bench][openssl]") {
	std::array<std::byte, 1024> input{};

	for (int i = 0; i != (int)input.size(); ++i) {
		input[static_cast<size_t>(i)] = static_cast<std::byte>(i);
	}

	BENCHMARK("16 byte input") {
		auto ctx = openssl_sha3_256_init();
		const auto data = std::span(runtime_pass(input)).first(16);
		openssl_sha3_256_update(ctx, data);
		return openssl_sha3_256_final(ctx);
	};

	BENCHMARK("32 byte input") {
		auto ctx = openssl_sha3_256_init();
		const auto data = std::span(runtime_pass(input)).first(32);
		openssl_sha3_256_update(ctx, data);
		return openssl_sha3_256_final(ctx);
	};

	BENCHMARK("48 byte input") {
		auto ctx = openssl_sha3_256_init();
		const auto data = std::span(runtime_pass(input)).first(48);
		openssl_sha3_256_update(ctx, data);
		return openssl_sha3_256_final(ctx);
	};

	BENCHMARK("64 byte input") {
		auto ctx = openssl_sha3_256_init();
		const auto data = std::span(runtime_pass(input)).first(64);
		openssl_sha3_256_update(ctx, data);
		return openssl_sha3_256_final(ctx);
	};

	BENCHMARK("96 byte input") {
		auto ctx = openssl_sha3_256_init();
		const auto data = std::span(runtime_pass(input)).first(96);
		openssl_sha3_256_update(ctx, data);
		return openssl_sha3_256_final(ctx);
	};

	BENCHMARK("10kB input") {
		auto ctx = openssl_sha3_256_init();

		for (int i = 0; i != 10; ++i) {
			const auto data = std::span(runtime_pass(input)).first(1024);
			openssl_sha3_256_update(ctx, data);
		}

		return openssl_sha3_256_final(ctx);
	};

	BENCHMARK("1MB input") {
		auto ctx = openssl_sha3_256_init();

		for (int i = 0; i != 1024; ++i) {
			const auto data = std::span(runtime_pass(input)).first(1024);
			openssl_sha3_256_update(ctx, data);
		}

		return openssl_sha3_256_final(ctx);
	};

	BENCHMARK("2MB input") {
		auto ctx = openssl_sha3_256_init();

		for (int i = 0; i != 2 * 1024; ++i) {
			const auto data = std::span(runtime_pass(input)).first(1024);
			openssl_sha3_256_update(ctx, data);
		}

		return openssl_sha3_256_final(ctx);
	};

	BENCHMARK("4MB input") {
		auto ctx = openssl_sha3_256_init();

		for (int i = 0; i != 4 * 1024; ++i) {
			const auto data = std::span(runtime_pass(input)).first(1024);
			openssl_sha3_256_update(ctx, data);
		}

		return openssl_sha3_256_final(ctx);
	};

	BENCHMARK("8MB input") {
		auto ctx = openssl_sha3_256_init();

		for (int i = 0; i != 8 * 1024; ++i) {
			const auto data = std::span(runtime_pass(input)).first(1024);
			openssl_sha3_256_update(ctx, data);
		}

		return openssl_sha3_256_final(ctx);
	};
}

#endif
```

`tests/benchmark/sha512.cpp`:

```cpp
#include "../internal/support.hpp"
#include <cthash/sha2/sha512.hpp>
#include <catch2/benchmark/catch_benchmark.hpp>
#include <catch2/catch_test_macros.hpp>

using namespace cthash::literals;

TEST_CASE("sha512 measurements") {
	std::array<std::byte, 1024> input{};

	for (int i = 0; i != (int)input.size(); ++i) {
		input[static_cast<size_t>(i)] = static_cast<std::byte>(i);
	}

	BENCHMARK("16 byte input") {
		return cthash::sha512{}.update(std::span(runtime_pass(input)).first(16)).final();
	};

	BENCHMARK("32 byte input") {
		return cthash::sha512{}.update(std::span(runtime_pass(input)).first(32)).final();
	};

	BENCHMARK("48 byte input") {
		return cthash::sha512{}.update(std::span(runtime_pass(input)).first(48)).final();
	};

	BENCHMARK("64 byte input") {
		return cthash::sha512{}.update(std::span(runtime_pass(input)).first(64)).final();
	};

	BENCHMARK("96 byte input") {
		return cthash::sha512{}.update(std::span(runtime_pass(input)).first(96)).final();
	};

	BENCHMARK("10kB input") {
		auto h = cthash::sha512{};
		for (int i = 0; i != 10; ++i) {
			h.update(std::span(runtime_pass(input)).first(1024));
		}
		return h.final();
	};

	BENCHMARK("1MB input") {
		auto h = cthash::sha512{};
		for (int i = 0; i != 1024; ++i) {
			h.update(std::span(runtime_pass(input)).first(1024));
		}
		return h.final();
	};

	BENCHMARK("10MB input") {
		auto h = cthash::sha512{};
		for (int i = 0; i != 10 * 1024; ++i) {
			h.update(std::span(runtime_pass(input)).first(1024));
		}
		return h.final();
	};
}

#ifdef OPENSSL_BENCHMARK

#include <openssl/sha.h>

TEST_CASE("openssl sha512 measurements") {
	std::array<std::byte, 1024> input{};

	for (int i = 0; i != (int)input.size(); ++i) {
		input[static_cast<size_t>(i)] = static_cast<std::byte>(i);
	}

	BENCHMARK("16 byte input") {
		SHA512_CTX ctx;
		SHA512_Init(&ctx);
		const auto data = std::span(runtime_pass(input)).first(16);
		SHA512_Update(&ctx, data.data(), data.size());
		std::array<unsigned char, 64> res;
		SHA512_Final(res.data(), &ctx);
		return res;
	};

	BENCHMARK("32 byte input") {
		SHA512_CTX ctx;
		SHA512_Init(&ctx);
		const auto data = std::span(runtime_pass(input)).first(32);
		SHA512_Update(&ctx, data.data(), data.size());
		std::array<unsigned char, 64> res;
		SHA512_Final(res.data(), &ctx);
		return res;
	};

	BENCHMARK("48 byte input") {
		SHA512_CTX ctx;
		SHA512_Init(&ctx);
		const auto data = std::span(runtime_pass(input)).first(48);
		SHA512_Update(&ctx, data.data(), data.size());
		std::array<unsigned char, 64> res;
		SHA512_Final(res.data(), &ctx);
		return res;
	};

	BENCHMARK("64 byte input") {
		SHA512_CTX ctx;
		SHA512_Init(&ctx);
		const auto data = std::span(runtime_pass(input)).first(64);
		SHA512_Update(&ctx, data.data(), data.size());
		std::array<unsigned char, 64> res;
		SHA512_Final(res.data(), &ctx);
		return res;
	};

	BENCHMARK("96 byte input") {
		SHA512_CTX ctx;
		SHA512_Init(&ctx);
		const auto data = std::span(runtime_pass(input)).first(96);
		SHA512_Update(&ctx, data.data(), data.size());
		std::array<unsigned char, 64> res;
		SHA512_Final(res.data(), &ctx);
		return res;
	};

	BENCHMARK("10kB input") {
		SHA512_CTX ctx;
		SHA512_Init(&ctx);

		for (int i = 0; i != 10; ++i) {
			const auto data = std::span(runtime_pass(input)).first(1024);
			SHA512_Update(&ctx, data.data(), data.size());
		}

		std::array<unsigned char, 64> res;
		SHA512_Final(res.data(), &ctx);
		return res;
	};

	BENCHMARK("1MB input") {
		SHA512_CTX ctx;
		SHA512_Init(&ctx);

		for (int i = 0; i != 1024; ++i) {
			const auto data = std::span(runtime_pass(input)).first(1024);
			SHA512_Update(&ctx, data.data(), data.size());
		}

		std::array<unsigned char, 64> res;
		SHA512_Final(res.data(), &ctx);
		return res;
	};

	BENCHMARK("10MB input") {
		SHA512_CTX ctx;
		SHA512_Init(&ctx);

		for (int i = 0; i != 10 * 1024; ++i) {
			const auto data = std::span(runtime_pass(input)).first(1024);
			SHA512_Update(&ctx, data.data(), data.size());
		}

		std::array<unsigned char, 64> res;
		SHA512_Final(res.data(), &ctx);
		return res;
	};
}

#endif
```

`tests/encoding/base.cpp`:

```cpp
#include <catch2/catch_test_macros.hpp>
#include <cthash/encoding/base.hpp>
#include <sstream>

using namespace std::string_view_literals;

static auto materialize(const auto & range) {
	using char_type = std::ranges::range_value_t<decltype(range)>;
	std::basic_string<char_type> output;
	for (char_type c: range) {
		output += c;
	}

	std::basic_string<char_type> output2;
	output2.resize(range.size());
	auto it = output2.begin();
	const auto end = output2.end();
	const auto [in, out] = std::ranges::copy(range.begin(), range.end(), it);

	REQUIRE(out == end);
	REQUIRE(in == range.end());
	REQUIRE(output.size() == output2.size());
	REQUIRE(range.size() == output2.size());

	return output2;
}

static auto result_size(const auto & range) {
	return range.size();
}

template <typename ValueT, typename... Args> auto build_array(Args... args) {
	return std::array<ValueT, sizeof...(args)>{static_cast<ValueT>(args)...};
}

TEST_CASE("lazy base64 basics") {
	const auto view1 = "Man"sv | cthash::base64_encode;
	REQUIRE(materialize(view1) == "TWFu");

	const auto view2 = "Ma"sv | cthash::base64_encode;
	REQUIRE(materialize(view2) == "TWE=");

	const auto view3 = "M"sv | cthash::base64_encode;
	REQUIRE(materialize(view3) == "TQ==");

	const auto empty = ""sv | cthash::base64_encode;
	REQUIRE(materialize(empty) == "");
}

TEST_CASE("bytes to base64") {
	const auto bytes = build_array<std::byte>('M', 'a', 'n');
	const auto view1 = std::span(bytes) | cthash::base64_encode;

	REQUIRE(materialize(view1) == "TWFu");

	const auto view2 = std::span(bytes).first(2) | cthash::base64_encode;
	REQUIRE(materialize(view2) == "TWE=");

	const auto view3 = std::span(bytes).first(1) | cthash::base64_encode;
	REQUIRE(materialize(view3) == "TQ==");

	const auto empty = std::span(bytes).first(0) | cthash::base64_encode;
	REQUIRE(materialize(empty) == "");
}

TEST_CASE("lazy base64 without padding basics") {
	const auto view1 = "Man"sv | cthash::base64_no_padding_encode;
	REQUIRE(materialize(view1) == "TWFu");

	const auto view2 = "Ma"sv | cthash::base64_no_padding_encode;
	REQUIRE(materialize(view2) == "TWE");

	const auto view3 = "M"sv | cthash::base64_no_padding_encode;
	REQUIRE(materialize(view3) == "TQ");

	const auto empty = ""sv | cthash::base64_no_padding_encode;
	REQUIRE(materialize(empty) == "");
}

template <typename T> constexpr auto make_array(std::convertible_to<T> auto... values) {
	return std::array<T, sizeof...(values)>{static_cast<T>(values)...};
}

TEST_CASE("lazy base64 value corner-cases") {
	const auto arr = make_array<unsigned char>(0, 0xFFu, 0, 0xFF, 0, 0xFF);
	const auto view1 = arr | cthash::base64_encode;
	static_assert(std::input_iterator<decltype(view1.begin())>);
	static_assert(std::ranges::input_range<decltype(view1)>);
	REQUIRE(materialize(view1) == "AP8A/wD/");
}

TEST_CASE("lazy base64url value corner-cases") {
	const auto arr = make_array<unsigned char>(0, 0xFFu, 0, 0xFF, 0, 0xFF);
	const auto view1 = arr | cthash::base64url_encode;
	static_assert(std::input_iterator<decltype(view1.begin())>);
	static_assert(std::ranges::input_range<decltype(view1)>);
	REQUIRE(materialize(view1) == "AP8A_wD_");
}

TEST_CASE("lazy base64 value corner-cases (construct from temporary)") {
	const auto view1 = make_array<unsigned char>(0, 0xFFu, 0, 0xFF, 0, 0xFF) | cthash::base64_encode;
	static_assert(std::input_iterator<decltype(view1.begin())>);
	static_assert(std::ranges::input_range<decltype(view1)>);
	REQUIRE(materialize(view1) == "AP8A/wD/");
}

TEST_CASE("lazy base64url basics") {
	const auto view1 = "Man"sv | cthash::base64url_encode;
	REQUIRE(materialize(view1) == "TWFu");

	const auto view2 = "Ma"sv | cthash::base64url_encode;
	REQUIRE(materialize(view2) == "TWE");

	const auto view3 = "M"sv | cthash::base64url_encode;
	REQUIRE(materialize(view3) == "TQ");

	const auto view4 = "ab~"sv | cthash::base64url_encode;
	REQUIRE(materialize(view4) == "YWJ-");

	const auto empty = ""sv | cthash::base64url_encode;
	REQUIRE(materialize(empty) == "");
}

TEST_CASE("lazy base32 basics") {
	const auto view1 = "abcde"sv | cthash::base32_encode;
	REQUIRE(materialize(view1) == "MFRGGZDF");

	const auto view2 = "abcd"sv | cthash::base32_encode;
	REQUIRE(materialize(view2) == "MFRGGZA=");

	const auto view3 = "abc"sv | cthash::base32_encode;
	REQUIRE(materialize(view3) == "MFRGG===");

	const auto view4 = "ab"sv | cthash::base32_encode;
	REQUIRE(materialize(view4) == "MFRA====");

	const auto view5 = "a"sv | cthash::base32_encode;
	REQUIRE(materialize(view5) == "ME======");

	const auto empty = ""sv | cthash::base32_encode;
	REQUIRE(materialize(empty) == "");
}

TEST_CASE("lazy z-base32 basics") {
	const auto view1 = "abcde"sv | cthash::z_base32_encode;
	REQUIRE(materialize(view1) == "cftgg3df");

	const auto view2 = "abcd"sv | cthash::z_base32_encode;
	REQUIRE(materialize(view2) == "cftgg3y");

	const auto view3 = "abc"sv | cthash::z_base32_encode;
	REQUIRE(materialize(view3) == "cftgg");

	const auto view4 = "ab"sv | cthash::z_base32_encode;
	REQUIRE(materialize(view4) == "cfty");

	const auto view5 = "a"sv | cthash::z_base32_encode;
	REQUIRE(materialize(view5) == "cr");

	const auto empty = ""sv | cthash::z_base32_encode;
	REQUIRE(materialize(empty) == "");
}

TEST_CASE("lazy hexdec basics") {
	const auto view1 = "Aloha"sv | cthash::hexdec_encode;
	REQUIRE(materialize(view1) ==
		"41"
		"6c"
		"6f"
		"68"
		"61");

	const auto empty = ""sv | cthash::hexdec_encode;
	REQUIRE(materialize(empty) == "");
}

TEST_CASE("lazy binary basics") {
	const auto view1 = "Aloha"sv | cthash::binary_encode;
	REQUIRE(materialize(view1) ==
		"01000001"
		"01101100"
		"01101111"
		"01101000"
		"01100001");

	const auto empty = ""sv | cthash::binary_encode;
	REQUIRE(materialize(empty) == "");
}

```

`tests/encoding/bit-buffer.cpp`:

```cpp
#include <catch2/catch_test_macros.hpp>
#include <cthash/encoding/bit-buffer.hpp>

using namespace std::string_view_literals;

TEST_CASE("bit_buffer(1)") {
	auto buffer = cthash::bit_buffer<6, 8>{};
	REQUIRE(buffer.empty());
	REQUIRE(buffer.has_capacity_for_push());
	buffer.push(0xFFu);
	REQUIRE(!buffer.empty());
	REQUIRE(buffer.has_bits_for_pop());
	REQUIRE(buffer.size() == 1u);

	const auto out1 = buffer.front();
	buffer.pop();
	REQUIRE(out1 == 0b111111u);
}

TEST_CASE("bit_buffer(2)") {
	auto buffer = cthash::bit_buffer<6, 8>{};
	REQUIRE(buffer.empty());
	REQUIRE(buffer.has_capacity_for_push());

	buffer.push(0xFFu);
	REQUIRE(buffer.size() == 1u);

	REQUIRE(buffer.has_bits_for_pop());
	REQUIRE_FALSE(buffer.empty());
	REQUIRE(buffer.has_capacity_for_push());
	buffer.push(0xFFu);
	REQUIRE(buffer.size() == 2u);

	REQUIRE(buffer.has_bits_for_pop());
	REQUIRE_FALSE(buffer.empty());
	REQUIRE(buffer.has_capacity_for_push());
	buffer.push(0xFFu);
	REQUIRE(buffer.size() == 4u);

	REQUIRE(buffer.has_bits_for_pop());
	REQUIRE_FALSE(buffer.empty());
	REQUIRE_FALSE(buffer.has_capacity_for_push());

	const auto out1 = buffer.front();
	buffer.pop();
	REQUIRE(out1 == 0b111111u);

	const auto out2 = buffer.front();
	buffer.pop();
	REQUIRE(out2 == 0b111111u);

	const auto out3 = buffer.front();
	buffer.pop();
	REQUIRE(out3 == 0b111111u);

	const auto out4 = buffer.front();
	buffer.pop();
	REQUIRE(out4 == 0b111111u);

	REQUIRE(buffer.empty());
	REQUIRE(buffer.has_capacity_for_push());
	REQUIRE_FALSE(buffer.has_bits_for_pop());
}

TEST_CASE("bit_buffer(3) check patterns") {
	auto buffer = cthash::bit_buffer<6, 8>{};
	REQUIRE(buffer.capacity() == 24); // bits

	REQUIRE(buffer.empty());
	REQUIRE(buffer.has_capacity_for_push());
	REQUIRE(buffer.size() == 0u);
	REQUIRE(buffer.unused_size() == 3u);

	REQUIRE_FALSE(buffer.full());

	buffer.push(0x86u);
	REQUIRE(buffer.unused_size() == 2u);
	REQUIRE(buffer.size() == 1u);
	REQUIRE(buffer.has_capacity_for_push());

	buffer.push(0x18u);
	REQUIRE(buffer.unused_size() == 1u);
	REQUIRE(buffer.size() == 2u);
	REQUIRE(buffer.has_capacity_for_push());

	buffer.push(0x61u);
	REQUIRE(buffer.unused_size() == 0u);
	REQUIRE(buffer.size() == 4u);

	REQUIRE_FALSE(buffer.empty());
	REQUIRE_FALSE(buffer.has_capacity_for_push());
	REQUIRE(buffer.full());

	auto front_and_pop = [&] {
		REQUIRE_FALSE(buffer.empty());
		const auto out1 = buffer.front();
		buffer.pop();
		return out1;
	};

	REQUIRE(front_and_pop() == 0b100001u);
	REQUIRE(front_and_pop() == 0b100001u);
	REQUIRE(front_and_pop() == 0b100001u);
	REQUIRE(front_and_pop() == 0b100001u);

	REQUIRE(buffer.empty());
}

TEST_CASE("calculating capacity for typical BASE-n") {
	const auto base2 = cthash::bit_buffer<1>{};
	REQUIRE(base2.capacity() == 8u);
	REQUIRE(base2.in_capacity() == 1u);
	REQUIRE(base2.out_capacity() == 8u);

	const auto base4 = cthash::bit_buffer<2>{};
	REQUIRE(base4.capacity() == 8u);
	REQUIRE(base4.in_capacity() == 1u);
	REQUIRE(base4.out_capacity() == 4u);

	const auto base8 = cthash::bit_buffer<3>{};
	REQUIRE(base8.capacity() == 24u);
	REQUIRE(base8.in_capacity() == 3u);
	REQUIRE(base8.out_capacity() == 8u);

	const auto base16 = cthash::bit_buffer<4>{};
	REQUIRE(base16.capacity() == 8u);
	REQUIRE(base16.in_capacity() == 1u);
	REQUIRE(base16.out_capacity() == 2u);

	const auto base32 = cthash::bit_buffer<5>{};
	REQUIRE(base32.capacity() == 40u);
	REQUIRE(base32.in_capacity() == 5u);
	REQUIRE(base32.out_capacity() == 8u);

	const auto base64 = cthash::bit_buffer<6>{};
	REQUIRE(base64.capacity() == 24u);
	REQUIRE(base64.in_capacity() == 3u);
	REQUIRE(base64.out_capacity() == 4u);

	const auto base128 = cthash::bit_buffer<7>{};
	REQUIRE(base128.capacity() == 56u);
	REQUIRE(base128.in_capacity() == 7u);
	REQUIRE(base128.out_capacity() == 8u);

	const auto base256 = cthash::bit_buffer<8>{};
	REQUIRE(base256.capacity() == 8u);
	REQUIRE(base256.in_capacity() == 1u);
	REQUIRE(base256.out_capacity() == 1u);
}

TEST_CASE("calculate padding for base64") {
	REQUIRE(cthash::calculate_padding_bit_count(0, 6, 8) == 0);
	REQUIRE(cthash::calculate_padding_bit_count(2, 6, 8) == 16);
	REQUIRE(cthash::calculate_padding_bit_count(4, 6, 8) == 8);
}

```

`tests/encoding/chunk-of-bits.cpp`:

```cpp
#include <catch2/catch_test_macros.hpp>
#include <cthash/encoding/chunk-of-bits.hpp>
#include <sstream>

using namespace std::string_view_literals;

auto convert_to_vector(auto && range) {
	std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype(range)>>> output{};

	for (auto && value: range) {
		output.emplace_back(value);
	}

	return output;
}

template <typename...> struct identify;

TEST_CASE("construction from a reference") {
	auto x = std::array<uint8_t, 4>{1, 2, 3, 4};
	auto v = x | cthash::chunk_of_bits<4>;
	REQUIRE(v.size() == 8);
}

TEST_CASE("construction from a const reference") {
	const auto x = std::array<uint8_t, 4>{1, 2, 3, 4};
	auto v = x | cthash::chunk_of_bits<4>;
	REQUIRE(v.size() == 8);
}

TEST_CASE("construction from a temporary") {
	auto v = std::array<uint8_t, 4>{1, 2, 3, 4} | cthash::chunk_of_bits<4>;
	REQUIRE(v.size() == 8);
}

TEST_CASE("construction of chunk view (8bit => 4bit)") {
	const auto v = "aloha"sv | cthash::chunk_of_bits<4>;

	static_assert(std::input_iterator<std::remove_cvref_t<decltype(v.begin())>>);
	static_assert(std::ranges::input_range<std::remove_cvref_t<decltype(v)>>);

	const auto result = convert_to_vector(v);

	REQUIRE(result.size() == 10u);

	REQUIRE(result[0].value == 0x6);
	REQUIRE(result[1].value == 0x1);

	REQUIRE(result[2].value == 0x6);
	REQUIRE(result[3].value == 0xC);

	REQUIRE(result[4].value == 0x6);
	REQUIRE(result[5].value == 0xF);

	REQUIRE(result[6].value == 0x6);
	REQUIRE(result[7].value == 0x8);

	REQUIRE(result[8].value == 0x6);
	REQUIRE(result[9].value == 0x1);
}

TEST_CASE("construction of chunk view (8bit => 6bit)") {
	const auto v = "Man"sv | cthash::chunk_of_bits<6>;

	static_assert(std::input_iterator<std::remove_cvref_t<decltype(v.begin())>>);
	static_assert(std::ranges::input_range<std::remove_cvref_t<decltype(v)>>);

	const auto result = convert_to_vector(v);

	REQUIRE(result.size() == 4u);

	REQUIRE(result[0].value == 0b010011u);
	REQUIRE(result[1].value == 0b010110u);
	REQUIRE(result[2].value == 0b000101u);
	REQUIRE(result[3].value == 0b101110u);
}

TEST_CASE("construction of chunk view (8bit => 6bit, unaligned, without padding)") {
	const auto v = "Ma"sv | cthash::chunk_of_bits<6, false>;

	static_assert(std::input_iterator<std::remove_cvref_t<decltype(v.begin())>>);
	static_assert(std::ranges::input_range<std::remove_cvref_t<decltype(v)>>);

	const auto result = convert_to_vector(v);

	auto it = result.begin();
	const auto end = result.end();

	REQUIRE(it != end);
	REQUIRE(it->value == 0b010011u);
	REQUIRE(it->missing_bits == 0u);
	++it;

	REQUIRE(it != end);
	REQUIRE(it->value == 0b010110u);
	REQUIRE(it->missing_bits == 0u);
	++it;

	REQUIRE(it != end);
	REQUIRE(it->value == 0b000100u);
	REQUIRE(it->missing_bits == 2u);
	++it;

	REQUIRE(it == end);
}

TEST_CASE("construction of chunk view (8bit => 6bit, unaligned, with padding)") {
	const auto v = "Ma"sv | cthash::chunk_of_bits<6, true>;

	static_assert(std::input_iterator<std::remove_cvref_t<decltype(v.begin())>>);
	static_assert(std::ranges::input_range<std::remove_cvref_t<decltype(v)>>);

	const auto result = convert_to_vector(v);

	auto it = result.begin();
	const auto end = result.end();

	REQUIRE(it != end);
	REQUIRE(it->value == 0b010011u);
	REQUIRE(it->missing_bits == 0u);
	++it;

	REQUIRE(it != end);
	REQUIRE(it->value == 0b010110u);
	REQUIRE(it->missing_bits == 0u);
	++it;

	REQUIRE(it != end);
	REQUIRE(it->value == 0b000100u);
	REQUIRE(it->missing_bits == 2u);
	++it;

	REQUIRE(it != end);
	REQUIRE(it->value == 0b000000u);
	// REQUIRE(it->missing_bits == 6u);
	// REQUIRE(it->is_padding());
	++it;

	REQUIRE(it == end);
}

TEST_CASE("construction of chunk view (8bit => 6bit, unaligned, with padding, second)") {
	const auto v = "M"sv | cthash::chunk_of_bits<6, true>;

	static_assert(std::input_iterator<std::remove_cvref_t<decltype(v.begin())>>);
	static_assert(std::ranges::input_range<std::remove_cvref_t<decltype(v)>>);

	const auto result = convert_to_vector(v);

	auto it = result.begin();
	const auto end = result.end();

	REQUIRE(it != end);
	REQUIRE(it->value == 0b010011u);
	REQUIRE(it->missing_bits == 0u);
	++it;

	REQUIRE(it != end);
	REQUIRE(it->value == 0b010000u);
	REQUIRE(it->missing_bits == 4u);
	++it;

	REQUIRE(it != end);
	REQUIRE(it->value == 0b000000u);
	// REQUIRE(it->missing_bits == 6u);
	// REQUIRE(it->is_padding());
	++it;

	REQUIRE(it != end);
	REQUIRE(it->value == 0b000000u);
	// REQUIRE(it->missing_bits == 6u);
	// REQUIRE(it->is_padding());
	++it;

	REQUIRE(it == end);
}

TEST_CASE("construction of chunk view (8bit => 6bit, unaligned, with padding, empty)") {
	const auto v = ""sv | cthash::chunk_of_bits<6, true>;

	static_assert(std::input_iterator<std::remove_cvref_t<decltype(v.begin())>>);
	static_assert(std::ranges::input_range<std::remove_cvref_t<decltype(v)>>);

	const auto result = convert_to_vector(v);

	auto it = result.begin();
	const auto end = result.end();

	REQUIRE(it == end);
}

TEST_CASE("construction of chunk view (8bit => 1bit)") {
	auto arr = std::array<unsigned char, 1>{0xF8};
	const auto v = arr | cthash::chunk_of_bits<1>;

	static_assert(std::input_iterator<std::remove_cvref_t<decltype(v.begin())>>);
	static_assert(std::ranges::input_range<std::remove_cvref_t<decltype(v)>>);

	const auto result = convert_to_vector(v);

	REQUIRE(result.size() == 8u);

	REQUIRE(result[0].value == 0b1);
	REQUIRE(result[1].value == 0b1);
	REQUIRE(result[2].value == 0b1);
	REQUIRE(result[3].value == 0b1);
	REQUIRE(result[4].value == 0b1);
	REQUIRE(result[5].value == 0b0);
	REQUIRE(result[6].value == 0b0);
	REQUIRE(result[7].value == 0b0);
}
```

`tests/encoding/selection.cpp`:

```cpp
#include <catch2/catch_test_macros.hpp>
#include <cthash/encoding/encodings.hpp>
#include <sstream>

using namespace std::string_view_literals;

template <typename> struct identify;

template <typename E> bool match_encoding(E, std::string_view expected) {
	return cthash::match_encoding<E>(expected);
}

TEST_CASE("select hexdec encoding") {
	const auto enc_default = cthash::select_runtime_encoding(""sv).encoding;
	enc_default.visit([]<typename E>(E e) {
		INFO(E::name);
		REQUIRE(match_encoding(e, "base16"));
	});

	const auto enc1 = cthash::select_runtime_encoding("hexdec"sv).encoding;
	enc1.visit([]<typename E>(E e) {
		REQUIRE(match_encoding(e, "hexdec"));
	});

	const auto enc2 = cthash::select_runtime_encoding("base64"sv).encoding;
	enc2.visit([]<typename E>(E e) {
		INFO(E::name);
		REQUIRE(match_encoding(e, "base64"));
	});

	const auto enc3 = cthash::select_runtime_encoding("base64_no_padding"sv).encoding;
	enc3.visit([]<typename E>(E e) {
		INFO(E::name);
		REQUIRE(match_encoding(e, "base64_no_padding"));
	});

	REQUIRE_THROWS_AS(cthash::select_runtime_encoding("unexisting"sv), std::invalid_argument);
}

```

`tests/hexdec.cpp`:

```cpp
#include <cthash/internal/hexdec.hpp>
#include <catch2/catch_test_macros.hpp>

TEST_CASE("hexdec basics") {
	constexpr auto v1 = cthash::internal::literal_hexdec_to_binary("");
	REQUIRE((v1 == std::array<std::byte, 0>{}));

	constexpr auto v2 = cthash::internal::literal_hexdec_to_binary("00");
	REQUIRE((v2 == std::array<std::byte, 1>{std::byte{0x00}}));

	constexpr auto v3 = cthash::internal::literal_hexdec_to_binary("abcdef01");
	REQUIRE((v3 == std::array<std::byte, 4>{std::byte{0xab}, std::byte{0xcd}, std::byte{0xef}, std::byte{0x01}}));
}

template <typename T> decltype(auto) runtime_pass(T && val) {
	return val;
}

TEST_CASE("hexdec conversion") {
	auto a = cthash::internal::literal_hexdec_to_binary(runtime_pass(""));
	REQUIRE((a == std::array<std::byte, 0>{}));

	auto b = cthash::internal::literal_hexdec_to_binary(runtime_pass("ab"));
	REQUIRE((b == std::array<std::byte, 1>{std::byte{0xab}}));
}
```

`tests/internal/support.hpp`:

```hpp
#ifndef CTHASH_TESTS_INTERNAL_SUPPORT_HPP
#define CTHASH_TESTS_INTERNAL_SUPPORT_HPP

#include <array>
#include <span>
#include <string>
#include <string_view>
#include <cstddef>

template <typename T> const auto & runtime_pass(const T & val) {
	return val;
}

template <typename T, size_t N> auto runtime_pass(const std::array<T, N> & val) {
	return std::span<const T>(val.data(), val.size());
}

template <size_t N, typename T = std::byte> consteval auto array_of(T value) {
	std::array<T, N> output;
	for (T & val: output) val = value;
	return output;
}

template <size_t N, typename T = std::byte> consteval auto array_of_zeros() {
	return array_of<N, T>(T{0});
}

template <size_t N> constexpr auto to_sv(const std::array<char, N> & in) {
	return std::string_view{in.data(), in.size()};
}

template <size_t N> constexpr auto to_str(const std::array<char, N> & in) {
	return std::string{in.data(), in.size()};
}

#endif

```

`tests/keccak.cpp`:

```cpp
#include <catch2/benchmark/catch_benchmark.hpp>
#include <catch2/catch_test_macros.hpp>
#include "internal/support.hpp"
#include <cthash/sha3/keccak-base.hpp>

TEST_CASE("keccakF") {
	auto s = cthash::keccak::state_1600{};
	cthash::keccak::keccak_f(s);
	const auto expected = cthash::keccak::state_1600{
		0xf1258f7940e1dde7ull,
		0x84d5ccf933c0478aull,
		0xd598261ea65aa9eeull,
		0xbd1547306f80494dull,
		0x8b284e056253d057ull,
		0xff97a42d7f8e6fd4ull,
		0x90fee5a0a44647c4ull,
		0x8c5bda0cd6192e76ull,
		0xad30a6f71b19059cull,
		0x30935ab7d08ffc64ull,
		0xeb5aa93f2317d635ull,
		0xa9a6e6260d712103ull,
		0x81a57c16dbcf555full,
		0x43b831cd0347c826ull,
		0x1f22f1a11a5569full,
		0x05e5635a21d9ae61ull,
		0x64befef28cc970f2ull,
		0x613670957bc46611ull,
		0xb87c5a554fd00ecbull,
		0x8c3ee88a1ccf32c8ull,
		0x940c7922ae3a2614ull,
		0x1841f924a2c509e4ull,
		0x16f53526e70465c2ull,
		0x75f644e97f30a13bull,
		0xeaf1ff7b5ceca249ull,
	};
	REQUIRE(s == expected);
}

```

`tests/sha2/sha224.cpp`:

```cpp
#include "../internal/support.hpp"
#include <cthash/sha2/sha224.hpp>
#include <catch2/benchmark/catch_benchmark.hpp>
#include <catch2/catch_test_macros.hpp>

using namespace cthash::literals;

TEST_CASE("sha224 basics") {
	constexpr auto v1 = cthash::sha224{}.update("").final();
	auto v1r = cthash::sha224{}.update(runtime_pass("")).final();
	REQUIRE(v1 == "d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f"_sha224);
	REQUIRE(v1 == v1r);

	constexpr auto v2 = cthash::sha224{}.update("hana").final();
	auto v2r = cthash::sha224{}.update(runtime_pass("hana")).final();
	REQUIRE(v2 == "a814c3122b1a3f2402bbcd0faffe28a9a7c24d389af78b596c752684"_sha224);
	REQUIRE(v2 == v2r);

	constexpr auto v3 = cthash::sha224{}.update(array_of_zeros<32>()).final();
	auto v3r = cthash::sha224{}.update(runtime_pass(array_of_zeros<32>())).final();
	REQUIRE(v3 == "b338c76bcffa1a0b3ead8de58dfbff47b63ab1150e10d8f17f2bafdf"_sha224);
	REQUIRE(v3 == v3r);

	constexpr auto v4 = cthash::sha224{}.update(array_of_zeros<64>()).final();
	auto v4r = cthash::sha224{}.update(runtime_pass(array_of_zeros<64>())).final();
	REQUIRE(v4 == "750d81a39c18d3ce27ff3e5ece30b0088f12d8fd0450fe435326294b"_sha224);
	REQUIRE(v4 == v4r);

	constexpr auto v5 = cthash::sha224{}.update(array_of_zeros<120>()).final();
	auto v5r = cthash::sha224{}.update(runtime_pass(array_of_zeros<120>())).final();
	REQUIRE(v5 == "83438028e7817c90b386a11c9a4e051f821b37c818bb4b5c08279584"_sha224);
	REQUIRE(v5 == v5r);

	constexpr auto v6 = cthash::sha224{}.update(array_of_zeros<128>()).final();
	auto v6r = cthash::sha224{}.update(runtime_pass(array_of_zeros<128>())).final();
	REQUIRE(v6 == "2fbd823ebcd9909d265827e4bce793a4fc572e3f39c7c3dd67749f3e"_sha224);
	REQUIRE(v6 == v6r);

	constexpr auto v7 = cthash::sha224{}.update(array_of_zeros<512>()).final();
	auto v7r = cthash::sha224{}.update(runtime_pass(array_of_zeros<512, char>())).final();
	REQUIRE(v7 == "4026dd4dbeb4d8a951dfd9a592897f46203ebe2d99c4a8837aa3afc9"_sha224);
	REQUIRE(v7 == v7r);
}

```

`tests/sha2/sha256.cpp`:

```cpp
#include <catch2/benchmark/catch_benchmark.hpp>
#include <catch2/catch_test_macros.hpp>
#include "../internal/support.hpp"
#include <cthash/sha2/sha256.hpp>

using namespace cthash::literals;

TEST_CASE("sha256 size") {
	auto h = cthash::sha256{};
	h.update("aloha");
	REQUIRE(h.size() == 5u);
	h.update("hana");
	REQUIRE(h.size() == 9u);
}

TEST_CASE("sha256 zero staging should be empty") {
	const auto block = array_of_zeros<64>();
	const auto staging = cthash::internal_hasher<cthash::sha256_config>::build_staging(block);

	for (auto val: staging) {
		REQUIRE(val == static_cast<decltype(val)>(0));
	}
}

TEST_CASE("sha256 empty input") {
	const auto block = [] {
		auto r = array_of_zeros<64>();
		r[0] = std::byte{0b1000'0000};
		return r;
	}();
	const auto staging = cthash::internal_hasher<cthash::sha256_config>::build_staging(block);

	auto it = staging.begin();

	// from the block
	REQUIRE(*it++ == 0x80000000ul);
	for (int i = 1; i != 16; ++i) {
		REQUIRE(*it++ == 0ull);
	}

	// calculated by staging function
	REQUIRE(staging[16] == 0b10000000000000000000000000000000ul);
	REQUIRE(staging[17] == 0b00000000000000000000000000000000ul);
	REQUIRE(staging[18] == 0b00000000001000000101000000000000ul);
	REQUIRE(staging[19] == 0b00000000000000000000000000000000ul);
	REQUIRE(staging[20] == 0b00100010000000000000100000000000ul);
	REQUIRE(staging[21] == 0b00000000000000000000000000000000ul);
	REQUIRE(staging[22] == 0b00000101000010001001010101000010ul);
	REQUIRE(staging[23] == 0b10000000000000000000000000000000ul);
	REQUIRE(staging[24] == 0b01011000000010000000000000000000ul);
	REQUIRE(staging[25] == 0b00000000010000001010000000000000ul);
	REQUIRE(staging[26] == 0b00000000000101100010010100000101ul);
	REQUIRE(staging[27] == 0b01100110000000000001100000000000ul);
	REQUIRE(staging[28] == 0b11010110001000100010010110000000ul);
	REQUIRE(staging[29] == 0b00010100001000100101010100001000ul);
	REQUIRE(staging[30] == 0b11010110010001011111100101011100ul);
	REQUIRE(staging[31] == 0b11001001001010000010000000000000ul);
	REQUIRE(staging[32] == 0b11000011111100010000000010010100ul);
	REQUIRE(staging[33] == 0b00101000010011001010011101100110ul);
	REQUIRE(staging[34] == 0b00000110100010000110110111000110ul);
	REQUIRE(staging[35] == 0b10100011011110111111000100010110ul);
	REQUIRE(staging[36] == 0b01110001011111001011111010010110ul);
	REQUIRE(staging[37] == 0b11111110110000101101011101001010ul);
	REQUIRE(staging[38] == 0b10100111101101100111111100000000ul);
	REQUIRE(staging[39] == 0b10000001000101011001011010100010ul);
	REQUIRE(staging[40] == 0b10011000101001101110011101101000ul);
	REQUIRE(staging[41] == 0b00000011101100100000110010000010ul);
	REQUIRE(staging[42] == 0b01011101000111011010011111001001ul);
	REQUIRE(staging[43] == 0b10110001010101101011100100110101ul);
	REQUIRE(staging[44] == 0b11000011110111011100101000010001ul);
	REQUIRE(staging[45] == 0b00100100100111000001000001111111ul);
	REQUIRE(staging[46] == 0b11000100100011010010010011101111ul);
	REQUIRE(staging[47] == 0b01011101111001010100110000110000ul);
	REQUIRE(staging[48] == 0b11011110111111101100111001100101ul);
	REQUIRE(staging[49] == 0b00101100101000010100100000001101ul);
	REQUIRE(staging[50] == 0b00111100000101010011001100101100ul);
	REQUIRE(staging[51] == 0b00000001110011101100100110101101ul);
	REQUIRE(staging[52] == 0b00010110000011001100110011010000ul);
	REQUIRE(staging[53] == 0b00001011101011001101101010011000ul);
	REQUIRE(staging[54] == 0b00110110000110111000111111100000ul);
	REQUIRE(staging[55] == 0b11010010001100100000101110100110ul);
	REQUIRE(staging[56] == 0b00000010100110110111000000000111ul);
	REQUIRE(staging[57] == 0b01110101010001100101100001111100ul);
	REQUIRE(staging[58] == 0b00000111111101010100111100111001ul);
	REQUIRE(staging[59] == 0b11111000000010001101110111000011ul);
	REQUIRE(staging[60] == 0b11011100110010100111011000001000ul);
	REQUIRE(staging[61] == 0b01011110010000100111000110001000ul);
	REQUIRE(staging[62] == 0b01000100101111001110110001011101ul);
	REQUIRE(staging[63] == 0b00111011010111101100010010011011ul);

	REQUIRE(64 == staging.size());
}

TEST_CASE("sha256 basics (constexpr and runtime)") {
	constexpr auto v1 = cthash::sha256{}.update("").final();
	auto v1r = cthash::sha256{}.update(runtime_pass("")).final();
	REQUIRE(v1 == "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"_sha256);
	REQUIRE(v1 == v1r);

	constexpr auto v2 = cthash::sha256{}.update("hana").final();
	auto v2r = cthash::sha256{}.update(runtime_pass("hana")).final();
	REQUIRE(v2 == "599ba25a0d7c7d671bee93172ca7e272fc87f0c0e02e44df9e9436819067ea28"_sha256);
	REQUIRE(v2 == v2r);

	constexpr auto v3 = cthash::sha256{}.update(array_of_zeros<96>()).final();
	auto v3r = cthash::sha256{}.update(runtime_pass(array_of_zeros<96>())).final();
	REQUIRE(v3 == "2ea9ab9198d1638007400cd2c3bef1cc745b864b76011a0e1bc52180ac6452d4"_sha256);
	REQUIRE(v3 == v3r);

	constexpr auto v4 = cthash::sha256{}.update(array_of_zeros<120>()).final();
	auto v4r = cthash::sha256{}.update(runtime_pass(array_of_zeros<120>())).final();
	auto v4b = cthash::sha256{}.update(runtime_pass(array_of_zeros<120, char>())).final();
	REQUIRE(v4 == "6edd9f6f9cc92cded36e6c4a580933f9c9f1b90562b46903b806f21902a1a54f"_sha256);
	REQUIRE(v4 == v4r);
	REQUIRE(v4 == v4b);

	constexpr auto v5 = cthash::sha256{}.update(array_of_zeros<128>()).final();
	auto v5r = cthash::sha256{}.update(runtime_pass(array_of_zeros<128>())).final();
	REQUIRE(v5 == "38723a2e5e8a17aa7950dc008209944e898f69a7bd10a23c839d341e935fd5ca"_sha256);
	REQUIRE(v5 == v5r);
}

TEST_CASE("sha256 long hash over 512MB", "[.long]") {
	cthash::sha256 h{};
	for (int i = 0; i != 512 * 1024; ++i) {
		h.update(array_of_zeros<1024>());
	}
	REQUIRE(h.size() == 512u * 1024u * 1024u);
	const auto r = h.final();

	REQUIRE(r == "9acca8e8c22201155389f65abbf6bc9723edc7384ead80503839f49dcc56d767"_sha256);
}

TEST_CASE("sha256 formatting") {
	auto hash = cthash::sha256().update("hi there!").final();
	auto str = std::format("{:base64}", hash);

	REQUIRE(str == "PjbTYi9a2tAQgMwhILtywHFOzsYRjrlSNYZBC3Q1roA=");
}

TEST_CASE("sha256 to_string") {
	auto hash = cthash::sha256().update("hi there!").final();
	auto str1 = to_string(hash);

	REQUIRE(str1 == "3e36d3622f5adad01080cc2120bb72c0714ecec6118eb9523586410b7435ae80");

	auto str2 = to_string<cthash::encoding::base64>(hash);
	REQUIRE(str2 == "PjbTYi9a2tAQgMwhILtywHFOzsYRjrlSNYZBC3Q1roA=");
}

TEST_CASE("sha256 to_fixed_string") {
	constexpr auto hash = cthash::sha256().update("hi there!").final();
	constexpr auto str1 = to_fixed_string(hash);

	REQUIRE(str1 == "3e36d3622f5adad01080cc2120bb72c0714ecec6118eb9523586410b7435ae80");

	constexpr auto str2 = to_fixed_string<cthash::encoding::base64>(hash);
	REQUIRE(str2 == "PjbTYi9a2tAQgMwhILtywHFOzsYRjrlSNYZBC3Q1roA=");
}

```

`tests/sha2/sha384.cpp`:

```cpp
#include "../internal/support.hpp"
#include <cthash/sha2/sha384.hpp>
#include <catch2/benchmark/catch_benchmark.hpp>
#include <catch2/catch_test_macros.hpp>

using namespace cthash::literals;

TEST_CASE("sha384 basics") {
	constexpr auto v1 = cthash::sha384{}.update("").final();
	auto v1r = cthash::sha384{}.update(runtime_pass("")).final();
	REQUIRE(v1 == "38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b"_sha384);
	REQUIRE(v1 == v1r);

	constexpr auto v2 = cthash::sha384{}.update("hana").final();
	auto v2r = cthash::sha384{}.update(runtime_pass("hana")).final();
	REQUIRE(v2 == "f365fd3e040e79a664d21de719128557b1188463d2d92be43522ccd4c316958b29f1189750b0f8d55aca50b8492982e8"_sha384);
	REQUIRE(v2 == v2r);

	constexpr auto v3 = cthash::sha384{}.update(array_of_zeros<32>()).final();
	auto v3r = cthash::sha384{}.update(runtime_pass(array_of_zeros<32>())).final();
	REQUIRE(v3 == "a38fff4ba26c15e4ac9cde8c03103ac89080fd47545fde9446c8f192729eab7bd03a4d5c3187f75fe2a71b0ee50a4a40"_sha384);
	REQUIRE(v3 == v3r);

	constexpr auto v4 = cthash::sha384{}.update(array_of_zeros<64>()).final();
	auto v4r = cthash::sha384{}.update(runtime_pass(array_of_zeros<64>())).final();
	REQUIRE(v4 == "c516aa8d3b457c636c6826937099c0d23a13f2c3701a388b3c8fe4bc2073281b0c4462610369884c4ababa8e97b6debe"_sha384);
	REQUIRE(v4 == v4r);

	constexpr auto v5 = cthash::sha384{}.update(array_of_zeros<120>()).final();
	auto v5r = cthash::sha384{}.update(runtime_pass(array_of_zeros<120>())).final();
	REQUIRE(v5 == "7212d895f4250ce1daa72e9e0caaef7132aed2e965885c55376818e45470de06fb6ebf7349c62fd342043f18010e46ac"_sha384);
	REQUIRE(v5 == v5r);

	constexpr auto v6 = cthash::sha384{}.update(array_of_zeros<128>()).final();
	auto v6r = cthash::sha384{}.update(runtime_pass(array_of_zeros<128>())).final();
	REQUIRE(v6 == "f809b88323411f24a6f152e5e9d9d1b5466b77e0f3c7550f8b242c31b6e7b99bcb45bdecb6124bc23283db3b9fc4f5b3"_sha384);
	REQUIRE(v6 == v6r);

	constexpr auto v7 = cthash::sha384{}.update(array_of_zeros<512, char>()).final();
	auto v7r = cthash::sha384{}.update(runtime_pass(array_of_zeros<512, char>())).final();
	REQUIRE(v7 == "d83d9a38c238ef3b7bc207bbea3287a8b37b37e731480a8d240d2a6953086c5ecbdf7ee4c72fec3a3e9d4a87f4f9b4fe"_sha384);
	REQUIRE(v7 == v7r);
}

```

`tests/sha2/sha512.cpp`:

```cpp
#include "../internal/support.hpp"
#include <cthash/sha2/sha512.hpp>
#include <catch2/benchmark/catch_benchmark.hpp>
#include <catch2/catch_test_macros.hpp>

using namespace cthash::literals;

template <typename Id> struct identify;

TEST_CASE("sha512 zero staging should be empty") {
	const auto block = array_of_zeros<128>();
	const auto staging = cthash::internal_hasher<cthash::sha512_config>::build_staging(block);

	for (auto val: staging) {
		REQUIRE(val == static_cast<decltype(val)>(0));
	}
}

TEST_CASE("sha512 internal buffer at the end (two bytes)") {
	using sha512_hasher = cthash::internal_hasher<cthash::sha512_config>;

	auto h = sha512_hasher{};
	h.update_to_buffer_and_process<std::byte>(std::array<std::byte, 2>{std::byte{'a'}, std::byte{'b'}});
	h.finalize();

	// message
	REQUIRE(unsigned(h.block[0]) == unsigned('a'));
	REQUIRE(unsigned(h.block[1]) == unsigned('b'));

	// terminator
	REQUIRE(unsigned(h.block[2]) == 0b1000'0000u);

	// bit length
	REQUIRE(unsigned(h.block[127]) == 16u); // 2*8 = 16

	STATIC_REQUIRE(h.block.size() == 128u);

	// rest of the block must be zeros
	for (int i = 0; i != 128; ++i) {
		if (i > 2 && i < 127) {
			REQUIRE(unsigned(h.block[static_cast<size_t>(i)]) == unsigned{0b0000'0000u});
		}
	}
}

TEST_CASE("sha512 internal buffer at the end (111B)") {
	using sha512_hasher = cthash::internal_hasher<cthash::sha512_config>;

	auto h = sha512_hasher{};
	h.update_to_buffer_and_process<std::byte>(array_of<111>(std::byte{42}));
	h.finalize();

	// message
	for (int i = 0; i != 111; ++i) {
		REQUIRE(unsigned(h.block[static_cast<size_t>(i)]) == unsigned(42));
	}

	// terminator
	REQUIRE(unsigned(h.block[111]) == 0b1000'0000u);

	// bit length
	REQUIRE(unsigned(h.block[112]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[113]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[114]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[115]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[116]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[117]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[118]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[119]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[120]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[121]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[122]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[123]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[124]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[125]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[126]) == 0b0000'0011u);
	REQUIRE(unsigned(h.block[127]) == 0b0111'1000u);

	STATIC_REQUIRE(h.block.size() == 128u);
}

TEST_CASE("sha512 internal buffer at the end (112B, first block)") {
	using sha512_hasher = cthash::internal_hasher<cthash::sha512_config>;

	auto h = sha512_hasher{};
	h.update_to_buffer_and_process<std::byte>(array_of<112>(std::byte{42}));
	const bool overflow = sha512_hasher::finalize_buffer(h.block, h.block_used);
	REQUIRE(overflow);

	// there is no message (as it was in previous block)
	for (int i = 0; i != 112; ++i) {
		REQUIRE(unsigned(h.block[static_cast<size_t>(i)]) == 42u);
	}

	// terminator
	REQUIRE(unsigned(h.block[112]) == 0b1000'0000u);

	// zero-padding
	for (int i = 113; i != 128; ++i) {
		REQUIRE(unsigned(h.block[static_cast<size_t>(i)]) == 0u);
	}

	STATIC_REQUIRE(h.block.size() == 128u);
}

TEST_CASE("sha512 internal buffer at the end (112B, second block)") {
	using sha512_hasher = cthash::internal_hasher<cthash::sha512_config>;

	auto h = sha512_hasher{};
	h.update_to_buffer_and_process<std::byte>(array_of<112>(std::byte{42}));
	h.finalize();

	// there is no message (as it was in previous block)
	for (int i = 0; i != 112; ++i) {
		REQUIRE(unsigned(h.block[static_cast<size_t>(i)]) == unsigned(0));
	}

	// bit length
	REQUIRE(unsigned(h.block[112]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[113]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[114]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[115]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[116]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[117]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[118]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[119]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[120]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[121]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[122]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[123]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[124]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[125]) == 0b0000'0000u);
	REQUIRE(unsigned(h.block[126]) == 0b0000'0011u);
	REQUIRE(unsigned(h.block[127]) == 0b1000'0000u);

	STATIC_REQUIRE(h.block.size() == 128u);
}

TEST_CASE("sha512 empty input") {
	const auto block = [] {
		auto r = array_of_zeros<128>();
		r[0] = std::byte{0b1000'0000};
		return r;
	}();
	const auto staging = cthash::internal_hasher<cthash::sha512_config>::build_staging(block);

	auto it = staging.begin();

	// from the block
	REQUIRE(*it++ == 0x80000000'00000000ull);
	for (int i = 1; i != 16; ++i) {
		REQUIRE(*it++ == 0ull);
	}

	// calculated by staging function
	REQUIRE(staging[16] == 0x80000000'00000000ull);
	REQUIRE(80 == staging.size());

	REQUIRE(staging[17] == 0x0000000000000000ull);
	REQUIRE(staging[18] == 0x0200100000000004ull);
	REQUIRE(staging[19] == 0x0000000000000000ull);
	REQUIRE(staging[20] == 0x1008000002000020ull);
	REQUIRE(staging[21] == 0x0000000000000000ull);
	REQUIRE(staging[22] == 0x8004220110080140ull);
	REQUIRE(staging[23] == 0x8000000000000000ull);
	REQUIRE(staging[24] == 0x0209108000400800ull);
	REQUIRE(staging[25] == 0x0400200000000008ull);
	REQUIRE(staging[26] == 0x1140a00320114028ull);
	REQUIRE(staging[27] == 0x3018000006000060ull);
	REQUIRE(staging[28] == 0xa24500b1180a2042ull);
	REQUIRE(staging[29] == 0x0010880440200500ull);
	REQUIRE(staging[30] == 0xd4a945c2a4270995ull);
	REQUIRE(staging[31] == 0x43ad128001402810ull);
	REQUIRE(staging[32] == 0xcb2a519703108414ull);
	REQUIRE(staging[33] == 0x2faad072c8658034ull);
	REQUIRE(staging[34] == 0x7d14cc9b14ba8338ull);
	REQUIRE(staging[35] == 0x9867c5d3eb13eeffull);
	REQUIRE(staging[36] == 0xc94dc04c92359678ull);
	REQUIRE(staging[37] == 0x92aba5ae1ee4675dull);
	REQUIRE(staging[38] == 0x00b560cd2d362129ull);
	REQUIRE(staging[39] == 0x682916bbbf1eb0d9ull);
	REQUIRE(staging[40] == 0xfd4ce54fb9c1fca2ull);
	REQUIRE(staging[41] == 0x389bbafedf01a2ffull);
	REQUIRE(staging[42] == 0xf80ad4187a704534ull);
	REQUIRE(staging[43] == 0xfc8a6db46b916fabull);
	REQUIRE(staging[44] == 0x0009308c4ca7d22bull);
	REQUIRE(staging[45] == 0x49437d8543e9c98cull);
	REQUIRE(staging[46] == 0x67f19b9756071662ull);
	REQUIRE(staging[47] == 0x23d1b6fd5980db71ull);
	REQUIRE(staging[48] == 0x044afa0ab38edb37ull);
	REQUIRE(staging[49] == 0x332fd4ee79f5c755ull);
	REQUIRE(staging[50] == 0xa55aa02bebfa6ad4ull);
	REQUIRE(staging[51] == 0xd7c6eb0c613c793aull);
	REQUIRE(staging[52] == 0x0d8e6b8077ea417cull);
	REQUIRE(staging[53] == 0xd647ca451bde7ccbull);
	REQUIRE(staging[54] == 0xb69eec4d0e03246full);
	REQUIRE(staging[55] == 0xc913f017b2ac853aull);
	REQUIRE(staging[56] == 0x66221af93a4225bbull);
	REQUIRE(staging[57] == 0x022066fa965f2dbfull);
	REQUIRE(staging[58] == 0x98519af83ac7c4d8ull);
	REQUIRE(staging[59] == 0xa9d9b257ea80f60full);
	REQUIRE(staging[60] == 0xb741f8b59c416c21ull);
	REQUIRE(staging[61] == 0xa3de4a86a2cdbefbull);
	REQUIRE(staging[62] == 0xa6e929fabf4b5fa6ull);
	REQUIRE(staging[63] == 0xeabfcd669f8d15a1ull);
}

TEST_CASE("sha512 basics", "") {
	constexpr auto v1 = cthash::sha512{}.update("").final();
	auto v1r = cthash::sha512{}.update(runtime_pass("")).final();
	REQUIRE(v1 == "cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e"_sha512);
	REQUIRE(v1 == v1r);

	constexpr auto v2 = cthash::sha512{}.update("hana").final();
	auto v2r = cthash::sha512{}.update(runtime_pass("hana")).final();
	REQUIRE(v2 == "74d15692038cd747dce0f4ff287ce1d5a7930c7e5948183419584f142039b3b25a94d1bf7f321f2fd2da37af1b6552f3e5bfc6c40d0bd8e16ecde338ee153a02"_sha512);
	REQUIRE(v2 == v2r);

	constexpr auto v3 = cthash::sha512{}.update(array_of_zeros<96>()).final();
	auto v3r = cthash::sha512{}.update(array_of_zeros<96>()).final();
	auto v3rb = cthash::sha512{}.update(array_of_zeros<96, char>()).final();
	REQUIRE(v3 == "e866b15da9e5b18d4b3bde250fc08a208399440f37471313c5b4006e4151b0f4464b2cd7246899935d58660c0749cd11570bb8240760a6e46bb175be18cdaffe"_sha512);
	REQUIRE(v3 == v3r);
	REQUIRE(v3 == v3rb);

	constexpr auto v4 = cthash::sha512{}.update(array_of_zeros<120>()).final();
	auto v4r = cthash::sha512{}.update(array_of_zeros<120, char>()).final();
	REQUIRE(v4 == "c106c47ad6eb79cd2290681cb04cb183effbd0b49402151385b2d07be966e2d50bc9db78e00bf30bb567ccdd3a1c7847260c94173ba215a0feabb0edeb643ff0"_sha512);
	REQUIRE(v4 == v4r);

	constexpr auto v5 = cthash::sha512{}.update(array_of_zeros<128>()).final();
	auto v5r = cthash::sha512{}.update(array_of_zeros<128, char>()).final();
	REQUIRE(v5 == "ab942f526272e456ed68a979f50202905ca903a141ed98443567b11ef0bf25a552d639051a01be58558122c58e3de07d749ee59ded36acf0c55cd91924d6ba11"_sha512);
	REQUIRE(v5 == v5r);

	constexpr auto v6 = cthash::sha512{}.update(array_of_zeros<512>()).final();
	auto v6r = cthash::sha512{}.update(array_of_zeros<512, char>()).final();
	auto v6rb = cthash::sha512{}.update(array_of_zeros<512>()).final();
	REQUIRE(v6 == "df40d4a774e0b453a5b87c00d6f0ef5d753143454e88ee5f7b607134598294c7905ccbcf94bbc46e474db6eb44e56a6dbb6d9a1be9d4fb5d1b5f2d0c6ed34bfe"_sha512);
	REQUIRE(v6 == v6r);
	REQUIRE(v6 == v6rb);
}

```

`tests/sha2/sha512t.cpp`:

```cpp
#include "../internal/support.hpp"
#include <cthash/sha2/sha512/t.hpp>
#include <catch2/benchmark/catch_benchmark.hpp>
#include <catch2/catch_test_macros.hpp>

using namespace cthash::literals;
using namespace std::string_literals;

TEST_CASE("sha512/t (init strings)") {
	REQUIRE(to_str(cthash::signature_for_sha512t<8>) == "SHA-512/8"s);
	REQUIRE(to_str(cthash::signature_for_sha512t<16>) == "SHA-512/16"s);
	REQUIRE(to_str(cthash::signature_for_sha512t<128>) == "SHA-512/128"s);
	REQUIRE(to_str(cthash::signature_for_sha512t<224>) == "SHA-512/224"s);
	REQUIRE(to_str(cthash::signature_for_sha512t<256>) == "SHA-512/256"s);
}

TEST_CASE("sha512/224 (iv)") {
	constexpr auto & iv = cthash::sha512t_config<224>::initial_values;
	REQUIRE(iv[0] == 0x8C3D37C819544DA2ull);
	REQUIRE(iv[1] == 0x73E1996689DCD4D6ull);
	REQUIRE(iv[2] == 0x1DFAB7AE32FF9C82ull);
	REQUIRE(iv[3] == 0x679DD514582F9FCFull);
	REQUIRE(iv[4] == 0x0F6D2B697BD44DA8ull);
	REQUIRE(iv[5] == 0x77E36F7304C48942ull);
	REQUIRE(iv[6] == 0x3F9D85A86A1D36C8ull);
	REQUIRE(iv[7] == 0x1112E6AD91D692A1ull);
}

TEST_CASE("sha512/256 (iv)") {
	constexpr auto & iv = cthash::sha512t_config<256>::initial_values;
	REQUIRE(iv[0] == 0x22312194FC2BF72Cull);
	REQUIRE(iv[1] == 0x9F555FA3C84C64C2ull);
	REQUIRE(iv[2] == 0x2393B86B6F53B151ull);
	REQUIRE(iv[3] == 0x963877195940EABDull);
	REQUIRE(iv[4] == 0x96283EE2A88EFFE3ull);
	REQUIRE(iv[5] == 0xBE5E1E2553863992ull);
	REQUIRE(iv[6] == 0x2B0199FC2C85B8AAull);
	REQUIRE(iv[7] == 0x0EB72DDC81C52CA2ull);
}

TEST_CASE("sha512/224 (literals)") {
	[[maybe_unused]] const auto v1 = "750d81a39c18d3ce27ff3e5ece30b0088f12d8fd0450fe435326294b"_sha512_224;
}

TEST_CASE("sha512/224 (basics)") {
	constexpr auto v1 = cthash::sha512t<224>{}.update("").final();
	auto v1r = cthash::sha512t<224>{}.update(runtime_pass("")).final();
	REQUIRE(v1 == "6ed0dd02806fa89e25de060c19d3ac86cabb87d6a0ddd05c333b84f4"_sha512_224);
	REQUIRE(v1 == v1r);

	constexpr auto v2 = cthash::sha512t<224>{}.update("hana").final();
	auto v2r = cthash::sha512t<224>{}.update(runtime_pass("hana")).final();
	REQUIRE(v2 == "53a276b702c0133dcec23f6ec5dc1ad56b224f386fdd57710dc53f9f"_sha512_224);
	REQUIRE(v2 == v2r);

	constexpr auto v3 = cthash::sha512t<224>{}.update(array_of_zeros<32>()).final();
	auto v3r = cthash::sha512t<224>{}.update(runtime_pass(array_of_zeros<32, char>())).final();
	REQUIRE(v3 == "9e7d6080def4e1ccf4aeaac6f7fad008d060a6cf87062038d6166774"_sha512_224);
	REQUIRE(v3 == v3r);

	constexpr auto v4 = cthash::sha512t<224>{}.update(array_of_zeros<64>()).final();
	auto v4r = cthash::sha512t<224>{}.update(runtime_pass(array_of_zeros<64>())).final();
	REQUIRE(v4 == "1319d9b322452068e6f43c0ed3da115fbeccc169711dbbaee2846f90"_sha512_224);
	REQUIRE(v4 == v4r);

	constexpr auto v5 = cthash::sha512t<224>{}.update(array_of_zeros<120>()).final();
	auto v5r = cthash::sha512t<224>{}.update(runtime_pass(array_of_zeros<120, char>())).final();
	REQUIRE(v5 == "d4dfc5c3449b4e3b180d9fda54e1bd86e2c40e2b790db950b4b3d297"_sha512_224);
	REQUIRE(v5 == v5r);

	constexpr auto v6 = cthash::sha512t<224>{}.update(array_of_zeros<128>()).final();
	auto v6r = cthash::sha512t<224>{}.update(runtime_pass(array_of_zeros<128>())).final();
	REQUIRE(v6 == "9ae639d7038fa1946a6f032dc72cb38afb0de1765a82a31621196f44"_sha512_224);
	REQUIRE(v6 == v6r);

	constexpr auto v7 = cthash::sha512t<224>{}.update(array_of_zeros<512>()).final();
	auto v7r = cthash::sha512t<224>{}.update(runtime_pass(array_of_zeros<512>())).final();
	REQUIRE(v7 == "6992572b245cb279973a119cb7f2859e75dff8c5fb9ace89566ae06d"_sha512_224);
	REQUIRE(v7 == v7r);
}

TEST_CASE("sha512/256 (basics)") {
	constexpr auto v1 = cthash::sha512t<256>{}.update("").final();
	auto v1r = cthash::sha512t<256>{}.update(runtime_pass("")).final();
	REQUIRE(v1 == "c672b8d1ef56ed28ab87c3622c5114069bdd3ad7b8f9737498d0c01ecef0967a"_sha512_256);
	REQUIRE(v1 == v1r);

	constexpr auto v2 = cthash::sha512t<256>{}.update("hana").final();
	auto v2r = cthash::sha512t<256>{}.update(runtime_pass("hana")).final();
	REQUIRE(v2 == "2a0e3f7643580859507710f4569a60a86c83c025955298e7a93d766f71e8e399"_sha512_256);
	REQUIRE(v2 == v2r);

	constexpr auto v3 = cthash::sha512t<256>{}.update(array_of_zeros<32>()).final();
	auto v3r = cthash::sha512t<256>{}.update(runtime_pass(array_of_zeros<32, char>())).final();
	REQUIRE(v3 == "af13c048991224a5e4c664446b688aaf48fb5456db3629601b00ec160c74e554"_sha512_256);
	REQUIRE(v3 == v3r);

	constexpr auto v4 = cthash::sha512t<256>{}.update(array_of_zeros<64>()).final();
	auto v4r = cthash::sha512t<256>{}.update(runtime_pass(array_of_zeros<64>())).final();
	REQUIRE(v4 == "8aeecfa0b9f2ac7818863b1362241e4f32d06b100ae9d1c0fbcc4ed61b91b17a"_sha512_256);
	REQUIRE(v4 == v4r);

	constexpr auto v5 = cthash::sha512t<256>{}.update(array_of_zeros<120>()).final();
	auto v5r = cthash::sha512t<256>{}.update(runtime_pass(array_of_zeros<120, char>())).final();
	REQUIRE(v5 == "067880a5256c0584cff10526ed4c9761e584bf0ecdb1b12c2ae7f1dcedaf3dbf"_sha512_256);
	REQUIRE(v5 == v5r);

	constexpr auto v6 = cthash::sha512t<256>{}.update(array_of_zeros<128>()).final();
	auto v6r = cthash::sha512t<256>{}.update(runtime_pass(array_of_zeros<128>())).final();
	REQUIRE(v6 == "fe3d375e149b888e08e2521007764b422d2cd6f7b0606881b7fe1b1370d5fa88"_sha512_256);
	REQUIRE(v6 == v6r);

	constexpr auto v7 = cthash::sha512t<256>{}.update(array_of_zeros<512>()).final();
	auto v7r = cthash::sha512t<256>{}.update(runtime_pass(array_of_zeros<512>())).final();
	REQUIRE(v7 == "552b405c9716945bfc0caee69baec21b2a05560bfbf58db8bd1a4c2cc42b42a6"_sha512_256);
	REQUIRE(v7 == v7r);
}
```

`tests/sha3/keccak-256.cpp`:

```cpp
#include <catch2/catch_test_macros.hpp>
#include "../internal/support.hpp"
#include <cthash/sha3/keccak.hpp>
#include <iostream>

using namespace cthash::literals;

TEST_CASE("keccak-256 basics") {
	const auto a = "5891b5b522d5df086d0ff0b110fbd9d21bb4fc7163af34d08286a2e846f6be03"_keccak_256;
	REQUIRE(a.size() == 256u / 8u);
}

TEST_CASE("keccak-256 test strings") {
	SECTION("empty") {
		constexpr auto calculation = []() {
			return cthash::keccak_256().update("").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470"_keccak_256);
		REQUIRE(r0 == r1);
	}

	SECTION("empty with bytes") {
		constexpr auto calculation = []() {
			return cthash::keccak_256().update(std::span<const std::byte>()).final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470"_keccak_256);
		REQUIRE(r0 == r1);
	}
	SECTION("one letter") {
		constexpr auto calculation = []() {
			return cthash::keccak_256().update("a").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "3ac225168df54212a25c1c01fd35bebfea408fdac2e31ddd6f80a4bbf9a5f1cb"_keccak_256);
		REQUIRE(r0 == r1);
	}
	SECTION("two letters") {
		constexpr auto calculation = []() {
			return cthash::keccak_256().update("ab").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "67fad3bfa1e0321bd021ca805ce14876e50acac8ca8532eda8cbf924da565160"_keccak_256);
		REQUIRE(r0 == r1);
	}
	SECTION("test") {
		constexpr auto calculation = []() {
			return cthash::keccak_256().update("test").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "9c22ff5f21f0b81b113e63f7db6da94fedef11b2119b4088b89664fb9a3cb658"_keccak_256);
		REQUIRE(r0 == r1);
	}
	SECTION("experiment") {
		constexpr auto calculation = []() {
			return cthash::keccak_256().update("experiment").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "047dbe311ff69923d959629005cb27fb9d3c725f890180fb93365b03a25f0a58"_keccak_256);
		REQUIRE(r0 == r1);
	}
	SECTION("ethereum") {
		constexpr auto calculation = []() {
			return cthash::keccak_256().update("Hello, Ethereum!").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "0a1e2723bd7f1996832b7ed7406df8ad975deba1aa04020b5bfc3e6fe70ecc29"_keccak_256);
		REQUIRE(r0 == r1);
	}

	SECTION("hello world") {
		constexpr auto calculation = []() {
			return cthash::keccak_256().update("Hello, world! Keccak-256 Hash").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "536c0a47629a8e5051078a4e01af79782e43cb62bd70b685fd5847a1ff0d4968"_keccak_256);
		REQUIRE(r0 == r1);
	}

	SECTION("hanicka") {
		constexpr auto calculation = []() {
			return cthash::keccak_256().update("hanicka").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "9be9c6b5bc2daec3e078ec9ee811f878b4b101eb0981a63756f8c766bb367a6b"_keccak_256);
		REQUIRE(r0 == r1);
	}

	SECTION("*136 characters (exactly block size)") {
		constexpr auto calculation = []() {
			auto in = std::string(size_t(136), '*'); // size of block
			return cthash::keccak_256().update(in).final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "e60d5160227cb1b8dc8547deb9c6a2c5e6c3306a1ca155611a73ed2c2324bfc0"_keccak_256);
		REQUIRE(r0 == r1);
	}

	SECTION("*137 characters (exactly block + 1 size)") {
		constexpr auto calculation = []() {
			auto in = std::string(size_t(136 + 1), '*'); // size of block
			return cthash::keccak_256().update(in).final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "6c882042bcc30221e6461507497574e018538e65d2006f9b1137d13347e31ed9"_keccak_256);
		REQUIRE(r0 == r1);
	}

	SECTION("*2500 characters") {
		auto in = std::string(size_t(2500), '*'); // size of block + 1
		const auto r0 = cthash::keccak_256().update(in).final();
		REQUIRE(r0 == "8e123b2ca404436c18353fb7770c97485d1be96ca0730907fc523896aac95e12"_keccak_256);
	}

	SECTION("*2500 by one") {
		auto h = cthash::keccak_256();
		for (int i = 0; i != 2500; ++i) {
			h.update("*");
		}
		const auto r0 = h.final();
		REQUIRE(r0 == "8e123b2ca404436c18353fb7770c97485d1be96ca0730907fc523896aac95e12"_keccak_256);
	}
}

TEST_CASE("keccak-256 stability") {
	auto h = cthash::keccak_256();

	constexpr int end = int(h.rate) * 2;

	for (int i = 0; i != end; ++i) {
		const auto piece = std::string(size_t(i), '#');
		h.update(piece);
	}

	const auto r0 = h.final();
	REQUIRE(r0 == "9afd724feebce0415a9669f2003b27b510ff7d77d8ad50a31c590d8409efeb41"_keccak_256);
}

TEST_CASE("keccak-256 printing") {
	auto hash = cthash::keccak_256().final();
	std::ostringstream ss;
	ss << hash;

	REQUIRE(ss.str() == "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470");
}

TEST_CASE("keccak-256 formatting") {
	auto hash = cthash::keccak_256().final();
	auto str = std::format("{}", hash);

	REQUIRE(str == "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470");
}

TEST_CASE("keccak-256 formatting (hexdec explicitly)") {
	auto hash = cthash::keccak_256().final();
	auto str = std::format("{:hexdec}", hash);

	REQUIRE(str == "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470");
}

TEST_CASE("keccak-256 formatting (z_base32 explicitly)") {
	auto hash = cthash::keccak_256().final();
	auto str = std::format("{:zbase32}", hash);

	REQUIRE(str == "azjrcycg6htu3ru6xs3p3tadad1obp1u3kbnqq559mcyezcfwtay");
}

TEST_CASE("keccak-256 formatting (base64url explicitly)") {
	auto hash = cthash::keccak_256().update("hanicka").final();
	auto str = std::format("{:base64url}", hash);

	REQUIRE(str == "m-nGtbwtrsPgeOye6BH4eLSxAesJgaY3VvjHZrs2ems");
}

TEST_CASE("keccak-256 formatting (binary explicitly)") {
	auto hash = cthash::keccak_256().update("hanicka").final();
	auto str = std::format("{:binary}", hash);

	REQUIRE(str ==
		"1001101111101001110001101011010110111100001011011010111011000011111000000111"
		"1000111011001001111011101000000100011111100001111000101101001011000100000001"
		"1110101100001001100000011010011000110111010101101111100011000111011001101011"
		"1011001101100111101001101011");
}

template <typename Container = std::string> auto materialize(auto && range) {
	auto result = Container{};
	result.resize(range.size());
	auto [in, out] = std::ranges::copy(range, result.begin());
	REQUIRE(in == range.end());
	REQUIRE(out == result.end());
	return result;
}

TEST_CASE("static and dynamic path generates same results (keccak256)") {
	auto hash = cthash::keccak_256().update("hanicka").final();

	REQUIRE(std::format("{:base2}", hash) == materialize(hash | cthash::base2_encode));
	REQUIRE(std::format("{:binary}", hash) == materialize(hash | cthash::binary_encode));
	REQUIRE(std::format("{:base4}", hash) == materialize(hash | cthash::base4_encode));
	REQUIRE(std::format("{:base8}", hash) == materialize(hash | cthash::base8_encode));
	REQUIRE(std::format("{:octal}", hash) == materialize(hash | cthash::octal_encode));
	REQUIRE(std::format("{:base16}", hash) == materialize(hash | cthash::base16_encode));
	REQUIRE(std::format("{:hexdec}", hash) == materialize(hash | cthash::hexdec_encode));
	REQUIRE(std::format("{:base32}", hash) == materialize(hash | cthash::base32_encode));
	REQUIRE(std::format("{:base32_no_padding}", hash) == materialize(hash | cthash::base32_no_padding_encode));
	REQUIRE(std::format("{:z_base32}", hash) == materialize(hash | cthash::z_base32_encode));
	REQUIRE(std::format("{:base64}", hash) == materialize(hash | cthash::base64_encode));
	REQUIRE(std::format("{:base64url}", hash) == materialize(hash | cthash::base64url_encode));
	REQUIRE(std::format("{:base64_no_padding}", hash) == materialize(hash | cthash::base64_no_padding_encode));
}

TEST_CASE("keccak-256 formatting (shortening)") {
	auto hash = cthash::keccak_256().final();
	auto str = std::format("{:hexdec}..{:hexdec}", hash.prefix<3>(), hash.suffix<3>());

	REQUIRE(str == "c5d246..85a470");
}

```

`tests/sha3/keccak-384.cpp`:

```cpp
#include <catch2/catch_test_macros.hpp>
#include "../internal/support.hpp"
#include <cthash/sha3/keccak.hpp>
#include <iostream>

using namespace cthash::literals;

TEST_CASE("keccak-384 basics") {
	const auto a = "2c23146a63a29acf99e73b88f8c24eaa7dc60aa771780ccc006afbfa8fe2479b2dd2b21362337441ac12b515911957ff"_keccak_384;
	REQUIRE(a.size() == 384u / 8u);
}

TEST_CASE("keccak-384 test strings") {
	SECTION("empty") {
		constexpr auto calculation = []() {
			return cthash::keccak_384().update("").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "2c23146a63a29acf99e73b88f8c24eaa7dc60aa771780ccc006afbfa8fe2479b2dd2b21362337441ac12b515911957ff"_keccak_384);
		REQUIRE(r0 == r1);
	}

	SECTION("empty with bytes") {
		constexpr auto calculation = []() {
			return cthash::keccak_384().update(std::span<const std::byte>()).final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "2c23146a63a29acf99e73b88f8c24eaa7dc60aa771780ccc006afbfa8fe2479b2dd2b21362337441ac12b515911957ff"_keccak_384);
		REQUIRE(r0 == r1);
	}
	SECTION("one letter") {
		constexpr auto calculation = []() {
			return cthash::keccak_384().update("a").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "85e964c0843a7ee32e6b5889d50e130e6485cffc826a30167d1dc2b3a0cc79cba303501a1eeaba39915f13baab5abacf"_keccak_384);
		REQUIRE(r0 == r1);
	}
	SECTION("two letters") {
		constexpr auto calculation = []() {
			return cthash::keccak_384().update("ab").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "d1112a0665627802eb0ff3225564b9cf6e99e1d58867a093095d16894e868549091d37e109da5c3bd671b39625e73591"_keccak_384);
		REQUIRE(r0 == r1);
	}
	SECTION("test") {
		constexpr auto calculation = []() {
			return cthash::keccak_384().update("test").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "53d0ba137307d4c2f9b6674c83edbd58b70c0f4340133ed0adc6fba1d2478a6a03b7788229e775d2de8ae8c0759d0527"_keccak_384);
		REQUIRE(r0 == r1);
	}
	SECTION("experiment") {
		constexpr auto calculation = []() {
			return cthash::keccak_384().update("experiment").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "0f7777b310667f6bb0fae78815639f360590aa1cb81658ce8e907643bb67be725f15064347d871f5f64587545efca431"_keccak_384);
		REQUIRE(r0 == r1);
	}
	SECTION("ethereum") {
		constexpr auto calculation = []() {
			return cthash::keccak_384().update("Hello, Ethereum!").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "756394287ae243a6c67ec0197ebdcd713d4b27e318c2f531fd40123948d2e768d516274e602c9eaafaa8f016037160ec"_keccak_384);
		REQUIRE(r0 == r1);
	}

	SECTION("hello world") {
		constexpr auto calculation = []() {
			return cthash::keccak_384().update("Hello, world! Keccak-384 Hash").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "e9ab8b2dd0ea09100a8646b8f72f67ac55074dbd9ab2a7446f585fa6275c4a3209b012a68e38fd4c57d11c446a02578d"_keccak_384);
		REQUIRE(r0 == r1);
	}

	SECTION("hanicka") {
		constexpr auto calculation = []() {
			return cthash::keccak_384().update("hanicka").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "bf4d65386c7ea9b6a95f0b35acf81ebc1666e70470d6e8e3343073207af63ff7e2124d6e216a677acd650bb4f44b01fe"_keccak_384);
		REQUIRE(r0 == r1);
	}

	SECTION("*136 characters (exactly block size)") {
		constexpr auto calculation = []() {
			auto in = std::string(size_t(136), '*'); // size of block
			return cthash::keccak_384().update(in).final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "767218950b7f7aea367e3d78b3866ebe0d2c9f890d27ec3350dd3b0d21ed109234d231e15da1ca6f942665826396677e"_keccak_384);
		REQUIRE(r0 == r1);
	}

	SECTION("*137 characters (exactly block + 1 size)") {
		constexpr auto calculation = []() {
			auto in = std::string(size_t(136 + 1), '*'); // size of block
			return cthash::keccak_384().update(in).final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "8c7e02a3f295c4117b03d7f5cc58ca1350d493053e1e9a1817a7cc12be29548f9321bd6ca7dca87a244464bf3e005ed4"_keccak_384);
		REQUIRE(r0 == r1);
	}

	SECTION("*2500 characters") {
		auto in = std::string(size_t(2500), '*'); // size of block + 1
		const auto r0 = cthash::keccak_384().update(in).final();
		REQUIRE(r0 == "5cf7bab34903785ab0dce2eb4497ac80dc0601816ed5fd0147f0eb3fc93930186f32b6762c2e507e2e8856c87678fa0f"_keccak_384);
	}

	SECTION("*2500 by one") {
		auto h = cthash::keccak_384();
		for (int i = 0; i != 2500; ++i) {
			h.update("*");
		}
		const auto r0 = h.final();
		REQUIRE(r0 == "5cf7bab34903785ab0dce2eb4497ac80dc0601816ed5fd0147f0eb3fc93930186f32b6762c2e507e2e8856c87678fa0f"_keccak_384);
	}
}

TEST_CASE("keccak-384 stability") {
	auto h = cthash::keccak_384();

	constexpr int end = int(h.rate) * 2;

	for (int i = 0; i != end; ++i) {
		const auto piece = std::string(size_t(i), '#');
		h.update(piece);
	}

	const auto r0 = h.final();
	REQUIRE(r0 == "52532d103f21bd143314e7b5b1bd7a79ebfc3c8e56e2689ee6527523a4c26baeee3065775163f43148e08aeefd302889"_keccak_384);
}

TEST_CASE("keccak-384 printing") {
	auto hash = cthash::keccak_384().final();
	std::ostringstream ss;
	ss << hash;

	REQUIRE(ss.str() == "2c23146a63a29acf99e73b88f8c24eaa7dc60aa771780ccc006afbfa8fe2479b2dd2b21362337441ac12b515911957ff");
}

TEST_CASE("keccak-384 formatting") {
	auto hash = cthash::keccak_384().final();
	auto str = std::format("{}", hash);

	REQUIRE(str == "2c23146a63a29acf99e73b88f8c24eaa7dc60aa771780ccc006afbfa8fe2479b2dd2b21362337441ac12b515911957ff");
}

TEST_CASE("keccak-384 formatting (hexdec explicitly)") {
	auto hash = cthash::keccak_384().final();
	auto str = std::format("{:hexdec}", hash);

	REQUIRE(str == "2c23146a63a29acf99e73b88f8c24eaa7dc60aa771780ccc006afbfa8fe2479b2dd2b21362337441ac12b515911957ff");
}

TEST_CASE("keccak-384 formatting (z_base32 explicitly)") {
	auto hash = cthash::keccak_384().final();
	auto str = std::format("{:zbase32}", hash);

	REQUIRE(str == "fotte4udwkpc9gx88qrxto1qij6hcni8qfhy3uyypm79id9ne6p15wi1nptdg7nbiojmkfctdfm96");
}

TEST_CASE("keccak-384 formatting (base64url explicitly)") {
	auto hash = cthash::keccak_384().update("hanicka").final();
	auto str = std::format("{:base64url}", hash);

	REQUIRE(str == "v01lOGx-qbapXws1rPgevBZm5wRw1ujjNDBzIHr2P_fiEk1uIWpnes1lC7T0SwH-");
}

TEST_CASE("keccak-384 formatting (binary explicitly)") {
	auto hash = cthash::keccak_384().update("hanicka").final();
	auto str = std::format("{:binary}", hash);

	REQUIRE(str ==
		"1011111101001101011001010011100001101100011111101010100110110110101010010101"
		"1111000010110011010110101100111110000001111010111100000101100110011011100111"
		"0000010001110000110101101110100011100011001101000011000001110011001000000111"
		"1010111101100011111111110111111000100001001001001101011011100010000101101010"
		"0110011101111010110011010110010100001011101101001111010001001011000000011111"
		"1110");
}

template <typename Container = std::string> auto materialize(auto && range) {
	auto result = Container{};
	result.resize(range.size());
	auto [in, out] = std::ranges::copy(range, result.begin());
	REQUIRE(in == range.end());
	REQUIRE(out == result.end());
	return result;
}

TEST_CASE("static and dynamic path generates same results (keccak384)") {
	auto hash = cthash::keccak_384().update("hanicka").final();

	REQUIRE(std::format("{:base2}", hash) == materialize(hash | cthash::base2_encode));
	REQUIRE(std::format("{:binary}", hash) == materialize(hash | cthash::binary_encode));
	REQUIRE(std::format("{:base4}", hash) == materialize(hash | cthash::base4_encode));
	REQUIRE(std::format("{:base8}", hash) == materialize(hash | cthash::base8_encode));
	REQUIRE(std::format("{:octal}", hash) == materialize(hash | cthash::octal_encode));
	REQUIRE(std::format("{:base16}", hash) == materialize(hash | cthash::base16_encode));
	REQUIRE(std::format("{:hexdec}", hash) == materialize(hash | cthash::hexdec_encode));
	REQUIRE(std::format("{:base32}", hash) == materialize(hash | cthash::base32_encode));
	REQUIRE(std::format("{:base32_no_padding}", hash) == materialize(hash | cthash::base32_no_padding_encode));
	REQUIRE(std::format("{:z_base32}", hash) == materialize(hash | cthash::z_base32_encode));
	REQUIRE(std::format("{:base64}", hash) == materialize(hash | cthash::base64_encode));
	REQUIRE(std::format("{:base64url}", hash) == materialize(hash | cthash::base64url_encode));
	REQUIRE(std::format("{:base64_no_padding}", hash) == materialize(hash | cthash::base64_no_padding_encode));
}

TEST_CASE("keccak-384 formatting (shortening)") {
	auto hash = cthash::keccak_384().final();
	auto str = std::format("{:hexdec}..{:hexdec}", hash.prefix<3>(), hash.suffix<3>());

	REQUIRE(str == "2c2314..1957ff");
}

```

`tests/sha3/keccak-512.cpp`:

```cpp
#include <catch2/catch_test_macros.hpp>
#include "../internal/support.hpp"
#include <cthash/sha3/keccak.hpp>
#include <iostream>

using namespace cthash::literals;

TEST_CASE("keccak-512 basics") {
	const auto a = "0eab42de4c3ceb9235fc91acffe746b29c29a8c366b7c60e4e67c466f36a4304c00fa9caf9d87976ba469bcbe06713b435f091ef2769fb160cdab33d3670680e"_keccak_512;
	REQUIRE(a.size() == 512u / 8u);
}

TEST_CASE("keccak-512 test strings") {
	SECTION("empty") {
		constexpr auto calculation = []() {
			return cthash::keccak_512().update("").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "0eab42de4c3ceb9235fc91acffe746b29c29a8c366b7c60e4e67c466f36a4304c00fa9caf9d87976ba469bcbe06713b435f091ef2769fb160cdab33d3670680e"_keccak_512);
		REQUIRE(r0 == r1);
	}

	SECTION("empty with bytes") {
		constexpr auto calculation = []() {
			return cthash::keccak_512().update(std::span<const std::byte>()).final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "0eab42de4c3ceb9235fc91acffe746b29c29a8c366b7c60e4e67c466f36a4304c00fa9caf9d87976ba469bcbe06713b435f091ef2769fb160cdab33d3670680e"_keccak_512);
		REQUIRE(r0 == r1);
	}
	SECTION("one letter") {
		constexpr auto calculation = []() {
			return cthash::keccak_512().update("a").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "9c46dbec5d03f74352cc4a4da354b4e9796887eeb66ac292617692e765dbe400352559b16229f97b27614b51dbfbbb14613f2c10350435a8feaf53f73ba01c7c"_keccak_512);
		REQUIRE(r0 == r1);
	}
	SECTION("two letters") {
		constexpr auto calculation = []() {
			return cthash::keccak_512().update("ab").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "b4828cc4e3fe9e5bc17013579be02b2a900c7afd7084c1f29450fcb267dcf1bc4def62a2cbefda507735547c203a3699f8a0d972fd13139dd73af0a3c30501e7"_keccak_512);
		REQUIRE(r0 == r1);
	}
	SECTION("test") {
		constexpr auto calculation = []() {
			return cthash::keccak_512().update("test").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "1e2e9fc2002b002d75198b7503210c05a1baac4560916a3c6d93bcce3a50d7f00fd395bf1647b9abb8d1afcc9c76c289b0c9383ba386a956da4b38934417789e"_keccak_512);
		REQUIRE(r0 == r1);
	}
	SECTION("experiment") {
		constexpr auto calculation = []() {
			return cthash::keccak_512().update("experiment").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "b4b480639fdd156014226bd64471df71658e66821b30c14b257ebc6fe921c50fb870eeff0b9eb4c6849e5deb129a68bca6ac847116da789231a7dc32fae4f14b"_keccak_512);
		REQUIRE(r0 == r1);
	}
	SECTION("ethereum") {
		constexpr auto calculation = []() {
			return cthash::keccak_512().update("Hello, Ethereum!").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "17081fdd12b66dce0adabc0b44d7c29b75670b5630437d1fc57df3dda6b85200c2e691f9480f3ed85b1d415ec638efa77529de36e24d77b5987bced369b752be"_keccak_512);
		REQUIRE(r0 == r1);
	}

	SECTION("hello world") {
		constexpr auto calculation = []() {
			return cthash::keccak_512().update("Hello, world! Keccak-512 Hash").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "94c3f40f39347cc633814f9391cdcfe0536a232458f8015d2189b08b69466fee7480bf1cfc8479a834edf84c06b1f02f8440681bfefeb3faf6c59b75002717ad"_keccak_512);
		REQUIRE(r0 == r1);
	}

	SECTION("hanicka") {
		constexpr auto calculation = []() {
			return cthash::keccak_512().update("hanicka").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "0900ff64ae4960c1c157a026ecbfd22c96cfdc3bb3a68092b73e2e893d32c95623eb3a7a5f9e03264296c55684dcc0276795a92fa4e2e40432b2b5d822ff999b"_keccak_512);
		REQUIRE(r0 == r1);
	}

	SECTION("*136 characters (exactly block size)") {
		constexpr auto calculation = []() {
			auto in = std::string(size_t(136), '*'); // size of block
			return cthash::keccak_512().update(in).final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "85684d78ee7b7833d89e3eed902fed74eabebe02e0880e842f03d47576330a3b0d699129d0d33f0f60d31cd5f10c8ecf806b466ded8e611843cefd05b07fa1c6"_keccak_512);
		REQUIRE(r0 == r1);
	}

	SECTION("*137 characters (exactly block + 1 size)") {
		constexpr auto calculation = []() {
			auto in = std::string(size_t(136 + 1), '*'); // size of block
			return cthash::keccak_512().update(in).final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "d8e0a98d46aaf3d9911c929d7be6bfa6c897009a296533fbc6083fb7302e2f6ad35a5117dcdf59645f9efca9a2e2241c71e7c5f115b94044a21e3715b4534c10"_keccak_512);
		REQUIRE(r0 == r1);
	}

	SECTION("*2500 characters") {
		auto in = std::string(size_t(2500), '*'); // size of block + 1
		const auto r0 = cthash::keccak_512().update(in).final();
		REQUIRE(r0 == "1bcec0f93dd40948c8b2eceeb48a2b39dae57e8ea9150da3273708204e2e6e27a680c9e559e46ff6ce3649d96f949e03389cdd5eff65a74346996d48b2eb4d91"_keccak_512);
	}

	SECTION("*2500 by one") {
		auto h = cthash::keccak_512();
		for (int i = 0; i != 2500; ++i) {
			h.update("*");
		}
		const auto r0 = h.final();
		REQUIRE(r0 == "1bcec0f93dd40948c8b2eceeb48a2b39dae57e8ea9150da3273708204e2e6e27a680c9e559e46ff6ce3649d96f949e03389cdd5eff65a74346996d48b2eb4d91"_keccak_512);
	}
}

TEST_CASE("keccak-512 stability") {
	auto h = cthash::keccak_512();

	constexpr int end = int(h.rate) * 2;

	for (int i = 0; i != end; ++i) {
		const auto piece = std::string(size_t(i), '#');
		h.update(piece);
	}

	const auto r0 = h.final();
	REQUIRE(r0 == "5e5d103f89e8d19a870fa4d495593ba5fa270db723c611d05c1ffc70c717a236fd18614b69c93f2773e4361843c5bd06c153b2229ed9120506cab4339643a7bd"_keccak_512);
}

TEST_CASE("keccak-512 printing") {
	auto hash = cthash::keccak_512().final();
	std::ostringstream ss;
	ss << hash;

	REQUIRE(ss.str() == "0eab42de4c3ceb9235fc91acffe746b29c29a8c366b7c60e4e67c466f36a4304c00fa9caf9d87976ba469bcbe06713b435f091ef2769fb160cdab33d3670680e");
}

TEST_CASE("keccak-512 formatting") {
	auto hash = cthash::keccak_512().final();
	auto str = std::format("{}", hash);

	REQUIRE(str == "0eab42de4c3ceb9235fc91acffe746b29c29a8c366b7c60e4e67c466f36a4304c00fa9caf9d87976ba469bcbe06713b435f091ef2769fb160cdab33d3670680e");
}

TEST_CASE("keccak-512 formatting (hexdec explicitly)") {
	auto hash = cthash::keccak_512().final();
	auto str = std::format("{:hexdec}", hash);

	REQUIRE(str == "0eab42de4c3ceb9235fc91acffe746b29c29a8c366b7c60e4e67c466f36a4304c00fa9caf9d87976ba469bcbe06713b435f091ef2769fb160cdab33d3670680e");
}

TEST_CASE("keccak-512 formatting (z_base32 explicitly)") {
	auto hash = cthash::keccak_512().final();
	auto str = std::format("{:zbase32}", hash);

	REQUIRE(str == "b4iwfz1c8ui3rpxh1gsx934gskqnukgdc45hcd1qc9ngph5kecncyd7j3mh7o6mszjdjz19ychj5epxo18z1q4x5nagpic37g3agodo");
}

TEST_CASE("keccak-512 formatting (base64url explicitly)") {
	auto hash = cthash::keccak_512().update("hanicka").final();
	auto str = std::format("{:base64url}", hash);

	REQUIRE(str == "CQD_ZK5JYMHBV6Am7L_SLJbP3DuzpoCStz4uiT0yyVYj6zp6X54DJkKWxVaE3MAnZ5WpL6Ti5AQysrXYIv-Zmw");
}

TEST_CASE("keccak-512 formatting (binary explicitly)") {
	auto hash = cthash::keccak_512().update("hanicka").final();
	auto str = std::format("{:binary}", hash);

	REQUIRE(str ==
		"0000100100000000111111110110010010101110010010010110000011000001110000010101"
		"0111101000000010011011101100101111111101001000101100100101101100111111011100"
		"0011101110110011101001101000000010010010101101110011111000101110100010010011"
		"1101001100101100100101010110001000111110101100111010011110100101111110011110"
		"0000001100100110010000101001011011000101010101101000010011011100110000000010"
		"0111011001111001010110101001001011111010010011100010111001000000010000110010"
		"10110010101101011101100000100010111111111001100110011011");
}

template <typename Container = std::string> auto materialize(auto && range) {
	auto result = Container{};
	result.resize(range.size());
	auto [in, out] = std::ranges::copy(range, result.begin());
	REQUIRE(in == range.end());
	REQUIRE(out == result.end());
	return result;
}

TEST_CASE("static and dynamic path generates same results (keccak512)") {
	auto hash = cthash::keccak_512().update("hanicka").final();

	REQUIRE(std::format("{:base2}", hash) == materialize(hash | cthash::base2_encode));
	REQUIRE(std::format("{:binary}", hash) == materialize(hash | cthash::binary_encode));
	REQUIRE(std::format("{:base4}", hash) == materialize(hash | cthash::base4_encode));
	REQUIRE(std::format("{:base8}", hash) == materialize(hash | cthash::base8_encode));
	REQUIRE(std::format("{:octal}", hash) == materialize(hash | cthash::octal_encode));
	REQUIRE(std::format("{:base16}", hash) == materialize(hash | cthash::base16_encode));
	REQUIRE(std::format("{:hexdec}", hash) == materialize(hash | cthash::hexdec_encode));
	REQUIRE(std::format("{:base32}", hash) == materialize(hash | cthash::base32_encode));
	REQUIRE(std::format("{:base32_no_padding}", hash) == materialize(hash | cthash::base32_no_padding_encode));
	REQUIRE(std::format("{:z_base32}", hash) == materialize(hash | cthash::z_base32_encode));
	REQUIRE(std::format("{:base64}", hash) == materialize(hash | cthash::base64_encode));
	REQUIRE(std::format("{:base64url}", hash) == materialize(hash | cthash::base64url_encode));
	REQUIRE(std::format("{:base64_no_padding}", hash) == materialize(hash | cthash::base64_no_padding_encode));
}

TEST_CASE("keccak-512 formatting (shortening)") {
	auto hash = cthash::keccak_512().final();
	auto str = std::format("{:hexdec}..{:hexdec}", hash.prefix<3>(), hash.suffix<3>());

	REQUIRE(str == "0eab42..70680e");
}

```

`tests/sha3/sha3-224.cpp`:

```cpp
#include "../internal/support.hpp"
#include <cthash/sha3/sha3-224.hpp>
#include <catch2/catch_test_macros.hpp>
#include <iostream>

using namespace cthash::literals;

TEST_CASE("sha3-224 basics") {
	const auto a = "6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7"_sha3_224;
	REQUIRE(a.size() == 224u / 8u);
}

TEST_CASE("sha3-224 test strings") {
	SECTION("empty") {
		const auto r0 = cthash::sha3_224().update("").final();
		REQUIRE(r0 == "6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7"_sha3_224);
	}

	SECTION("empty with bytes") {
		const auto r0 = cthash::sha3_224().update(std::span<const std::byte>()).final();
		REQUIRE(r0 == "6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7"_sha3_224);
	}

	SECTION("test") {
		const auto r0 = cthash::sha3_224().update("test").final();
		REQUIRE(r0 == "3797bf0afbbfca4a7bbba7602a2b552746876517a7f9b7ce2db0ae7b"_sha3_224);
	}

	SECTION("hanicka") {
		const auto r0 = cthash::sha3_224().update("hanicka").final();
		REQUIRE(r0 == "bb8c7c352111f9e6e024c9aae448a25da287590ce6ff9be8063b6206"_sha3_224);
	}

	SECTION("*136 characters (exactly block size)") {
		auto in = std::string(size_t(136), '*'); // size of block
		const auto r0 = cthash::sha3_224().update(in).final();
		REQUIRE(r0 == "e6b935498d1db267b4eb1b71fcc6b0598f46ffb689ce2df273d70ee4"_sha3_224);
	}

	SECTION("*137 characters (exactly block + 1 size)") {
		auto in = std::string(size_t(137), '*'); // size of block + 1
		const auto r0 = cthash::sha3_224().update(in).final();
		REQUIRE(r0 == "3527595762e032bc0cc0974f6df0c8f2454ab09b6139a117f2b78467"_sha3_224);
	}

	SECTION("*2500 characters") {
		auto in = std::string(size_t(2500), '*'); // size of block + 1
		const auto r0 = cthash::sha3_224().update(in).final();
		REQUIRE(r0 == "7d4b80d6adeb7ba20723a0635b6582bd38c011389688305d381fa2cc"_sha3_224);
	}

	SECTION("*2500 by one") {
		auto h = cthash::sha3_224();
		for (int i = 0; i != 2500; ++i) {
			h.update("*");
		}
		const auto r0 = h.final();
		REQUIRE(r0 == "7d4b80d6adeb7ba20723a0635b6582bd38c011389688305d381fa2cc"_sha3_224);
	}
}

TEST_CASE("sha3-224 stability") {
	auto h = cthash::sha3_224();

	constexpr int end = int(h.rate) * 2;

	for (int i = 0; i != end; ++i) {
		const auto piece = std::string(size_t(i), '#');
		h.update(piece);
	}

	const auto r0 = h.final();
	REQUIRE(r0 == "2409c68f45c73652fef9ef6ca701560557fb01747b52f92ffffd0477"_sha3_224);
}
```

`tests/sha3/sha3-256.cpp`:

```cpp
#include <catch2/catch_test_macros.hpp>
#include "../internal/support.hpp"
#include <cthash/sha3/sha3-256.hpp>
#include <iostream>

using namespace cthash::literals;

TEST_CASE("sha3-256 basics") {
	const auto a = "5891b5b522d5df086d0ff0b110fbd9d21bb4fc7163af34d08286a2e846f6be03"_sha3_256;
	REQUIRE(a.size() == 256u / 8u);
}

TEST_CASE("sha3-256 test strings") {
	SECTION("empty") {
		constexpr auto calculation = []() {
			return cthash::sha3_256().update("").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a"_sha3_256);
		REQUIRE(r0 == r1);
	}

	SECTION("empty with bytes") {
		constexpr auto calculation = []() {
			return cthash::sha3_256().update(std::span<const std::byte>()).final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a"_sha3_256);
		REQUIRE(r0 == r1);
	}

	SECTION("test") {
		constexpr auto calculation = []() {
			return cthash::sha3_256().update("test").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "36f028580bb02cc8272a9a020f4200e346e276ae664e45ee80745574e2f5ab80"_sha3_256);
		REQUIRE(r0 == r1);
	}

	SECTION("hanicka") {
		constexpr auto calculation = []() {
			return cthash::sha3_256().update("hanicka").final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "8f8b0b8af4c371e91791b1ddb2d0788661dd687060404af6320971bcc53b44fb"_sha3_256);
		REQUIRE(r0 == r1);
	}

	SECTION("*136 characters (exactly block size)") {
		constexpr auto calculation = []() {
			auto in = std::string(size_t(136), '*'); // size of block
			return cthash::sha3_256().update(in).final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "5224abc95021feafd89e36b41067884a08b39ff8e5ce0905c3a67d1857169e8a"_sha3_256);
		REQUIRE(r0 == r1);
	}

	SECTION("*137 characters (exactly block + 1 size)") {
		constexpr auto calculation = []() {
			auto in = std::string(size_t(136 + 1), '*'); // size of block
			return cthash::sha3_256().update(in).final();
		};

		auto r0 = calculation();
		constexpr auto r1 = calculation();

		REQUIRE(r0 == "596fe83ba2cb6199c98be88ca31fc21511e0e7244465c0bdfece933e9daa59bd"_sha3_256);
		REQUIRE(r0 == r1);
	}

	SECTION("*2500 characters") {
		auto in = std::string(size_t(2500), '*'); // size of block + 1
		const auto r0 = cthash::sha3_256().update(in).final();
		REQUIRE(r0 == "d406a008de11740c60173ea37a9c67d4f1dea8fbfc3a41a2cbef8037b32e7541"_sha3_256);
	}

	SECTION("*2500 by one") {
		auto h = cthash::sha3_256();
		for (int i = 0; i != 2500; ++i) {
			h.update("*");
		}
		const auto r0 = h.final();
		REQUIRE(r0 == "d406a008de11740c60173ea37a9c67d4f1dea8fbfc3a41a2cbef8037b32e7541"_sha3_256);
	}
}

TEST_CASE("sha3-256 stability") {
	auto h = cthash::sha3_256();

	constexpr int end = int(h.rate) * 2;

	for (int i = 0; i != end; ++i) {
		const auto piece = std::string(size_t(i), '#');
		h.update(piece);
	}

	const auto r0 = h.final();
	REQUIRE(r0 == "af2e33605dbcb6f37facfcf7b999e068d25c38e12c86c33786cc207134812e6b"_sha3_256);
}

TEST_CASE("sha3-256 printing") {
	auto hash = cthash::sha3_256().final();
	std::ostringstream ss;
	ss << hash;

	REQUIRE(ss.str() == "a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a");
}

TEST_CASE("sha3-256 formatting") {
	auto hash = cthash::sha3_256().final();
	auto str = std::format("{}", hash);

	REQUIRE(str == "a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a");
}

TEST_CASE("sha3-256 formatting (hexdec explicitly)") {
	auto hash = cthash::sha3_256().final();
	auto str = std::format("{:hexdec}", hash);

	REQUIRE(str == "a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a");
}

TEST_CASE("sha3-256 formatting (z_base32 explicitly)") {
	auto hash = cthash::sha3_256().final();
	auto str = std::format("{:zbase32}", hash);

	REQUIRE(str == "w99hp6f9d5mscwqbe7mkyaqscm4ab94pho7wu6wn5yfrzy8aepfy");
}

TEST_CASE("sha3-256 formatting (base64url explicitly)") {
	auto hash = cthash::sha3_256().update("hanicka").final();
	auto str = std::format("{:base64url}", hash);

	REQUIRE(str == "j4sLivTDcekXkbHdstB4hmHdaHBgQEr2MglxvMU7RPs");
}

TEST_CASE("sha3-256 formatting (binary explicitly)") {
	auto hash = cthash::sha3_256().update("hanicka").final();
	auto str = std::format("{:binary}", hash);

	REQUIRE(str ==
		"1000111110001011000010111000101011110100110000110111000111101001000101111001"
		"0001101100011101110110110010110100000111100010000110011000011101110101101000"
		"0111000001100000010000000100101011110110001100100000100101110001101111001100"
		"0101001110110100010011111011");
}

template <typename Container = std::string> auto materialize(auto && range) {
	auto result = Container{};
	result.resize(range.size());
	auto [in, out] = std::ranges::copy(range, result.begin());
	REQUIRE(in == range.end());
	REQUIRE(out == result.end());
	return result;
}

TEST_CASE("static and dynamic path generates same results") {
	auto hash = cthash::sha3_256().update("hanicka").final();

	REQUIRE(std::format("{:base2}", hash) == materialize(hash | cthash::base2_encode));
	REQUIRE(std::format("{:binary}", hash) == materialize(hash | cthash::binary_encode));
	REQUIRE(std::format("{:base4}", hash) == materialize(hash | cthash::base4_encode));
	REQUIRE(std::format("{:base8}", hash) == materialize(hash | cthash::base8_encode));
	REQUIRE(std::format("{:octal}", hash) == materialize(hash | cthash::octal_encode));
	REQUIRE(std::format("{:base16}", hash) == materialize(hash | cthash::base16_encode));
	REQUIRE(std::format("{:hexdec}", hash) == materialize(hash | cthash::hexdec_encode));
	REQUIRE(std::format("{:base32}", hash) == materialize(hash | cthash::base32_encode));
	REQUIRE(std::format("{:base32_no_padding}", hash) == materialize(hash | cthash::base32_no_padding_encode));
	REQUIRE(std::format("{:z_base32}", hash) == materialize(hash | cthash::z_base32_encode));
	REQUIRE(std::format("{:base64}", hash) == materialize(hash | cthash::base64_encode));
	REQUIRE(std::format("{:base64url}", hash) == materialize(hash | cthash::base64url_encode));
	REQUIRE(std::format("{:base64_no_padding}", hash) == materialize(hash | cthash::base64_no_padding_encode));
}

TEST_CASE("sha3-256 formatting (shortening)") {
	auto hash = cthash::sha3_256().final();
	auto str = std::format("{:hexdec}..{:hexdec}", hash.prefix<3>(), hash.suffix<3>());

	REQUIRE(str == "a7ffc6..f8434a");
}

```

`tests/sha3/sha3-384.cpp`:

```cpp
#include "../internal/support.hpp"
#include <cthash/sha3/sha3-384.hpp>
#include <catch2/catch_test_macros.hpp>
#include <iostream>

using namespace cthash::literals;

TEST_CASE("sha3-384 basics") {
	const auto a = "9c87cb0b9a8924030b93b4b3fd397c70030a57c6f98a051e0cc87d6d671e4da02e5fe4c6e8fe9d1ca46f085434092a99"_sha3_384;
	REQUIRE(a.size() == 384u / 8u);
}

TEST_CASE("sha3-384 test strings") {
	SECTION("empty") {
		const auto r0 = cthash::sha3_384().update("").final();
		REQUIRE(r0 == "0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004"_sha3_384);
	}

	SECTION("empty with bytes") {
		const auto r0 = cthash::sha3_384().update(std::span<const std::byte>()).final();
		REQUIRE(r0 == "0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004"_sha3_384);
	}

	SECTION("test") {
		const auto r0 = cthash::sha3_384().update("test").final();
		REQUIRE(r0 == "e516dabb23b6e30026863543282780a3ae0dccf05551cf0295178d7ff0f1b41eecb9db3ff219007c4e097260d58621bd"_sha3_384);
	}

	SECTION("hanicka") {
		const auto r0 = cthash::sha3_384().update("hanicka").final();
		REQUIRE(r0 == "9c87cb0b9a8924030b93b4b3fd397c70030a57c6f98a051e0cc87d6d671e4da02e5fe4c6e8fe9d1ca46f085434092a99"_sha3_384);
	}

	SECTION("*136 characters (exactly block size)") {
		auto in = std::string(size_t(136), '*'); // size of block
		const auto r0 = cthash::sha3_384().update(in).final();
		REQUIRE(r0 == "d86290cbc1abedee2f677b4938836ce984d8ddd955beefa2b421a55747ddcd3a2c5e5d0aae4e3173e92e2a2c80891980"_sha3_384);
	}

	SECTION("*137 characters (exactly block + 1 size)") {
		auto in = std::string(size_t(137), '*'); // size of block + 1
		const auto r0 = cthash::sha3_384().update(in).final();
		REQUIRE(r0 == "23082738027c7f6aa5aaf64312869e586352ee0077aa246bb4ac7a9459210af9397af84160ee335f6585f86148a9d396"_sha3_384);
	}

	SECTION("*2500 characters") {
		auto in = std::string(size_t(2500), '*'); // size of block + 1
		const auto r0 = cthash::sha3_384().update(in).final();
		REQUIRE(r0 == "2f5adba183a526a1c34e38575846001c5bc749c02af04beb6b0bd4bfc94f6f34ef1af3471fc438b28c78e652fc166129"_sha3_384);
	}

	SECTION("*2500 by one") {
		auto h = cthash::sha3_384();
		for (int i = 0; i != 2500; ++i) {
			h.update("*");
		}
		const auto r0 = h.final();
		REQUIRE(r0 == "2f5adba183a526a1c34e38575846001c5bc749c02af04beb6b0bd4bfc94f6f34ef1af3471fc438b28c78e652fc166129"_sha3_384);
	}
}

TEST_CASE("sha3-384 stability") {
	auto h = cthash::sha3_384();

	constexpr int end = int(h.rate) * 2;

	for (int i = 0; i != end; ++i) {
		const auto piece = std::string(size_t(i), '#');
		h.update(piece);
	}

	const auto r0 = h.final();
	REQUIRE(r0 == "83c6f40bf077d3f198ff2acc88eb2b82bab09bd9733e82fae081f7a50597160d02254357c352064a37104e8108d2d2bc"_sha3_384);
}
```

`tests/sha3/sha3-512.cpp`:

```cpp
#include "../internal/support.hpp"
#include <cthash/sha3/sha3-512.hpp>
#include <catch2/catch_test_macros.hpp>
#include <iostream>

using namespace cthash::literals;

TEST_CASE("sha3-512 basics") {
	const auto a = "5891b5b522d5df086d0ff0b110fbd9d21bb4fc7163af34d08286a2e846f6be035891b5b522d5df086d0ff0b110fbd9d21bb4fc7163af34d08286a2e846f6be03"_sha3_512;
	REQUIRE(a.size() == 512u / 8u);
}

TEST_CASE("sha3-512 test strings") {
	SECTION("empty") {
		const auto r0 = cthash::sha3_512().update("").final();
		REQUIRE(r0 == "a69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26"_sha3_512);
	}

	SECTION("empty with bytes") {
		const auto r0 = cthash::sha3_512().update(std::span<const std::byte>()).final();
		REQUIRE(r0 == "a69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26"_sha3_512);
	}

	SECTION("test") {
		const auto r0 = cthash::sha3_512().update("test").final();
		REQUIRE(r0 == "9ece086e9bac491fac5c1d1046ca11d737b92a2b2ebd93f005d7b710110c0a678288166e7fbe796883a4f2e9b3ca9f484f521d0ce464345cc1aec96779149c14"_sha3_512);
	}

	SECTION("hanicka") {
		const auto r0 = cthash::sha3_512().update("hanicka").final();
		REQUIRE(r0 == "6d8826eec43e037dca9a7c92ffede543c067aa72d3aa55033f76f1789e0054a19f19f6636fc909744b85f26e334c77be8bea4cc70a520ca1ef6db88da98a9ecf"_sha3_512);
	}

	SECTION("*136 characters (exactly block size)") {
		auto in = std::string(size_t(136), '*'); // size of block
		const auto r0 = cthash::sha3_512().update(in).final();
		REQUIRE(r0 == "0b5070207de47faf3fca6aa3c44cef2f79f970151f283d2a36857437002e0ae76543f3c5d9818d6341ea1562a4d2329e3d1a9f4dc821c792bc69e3b51aef76cc"_sha3_512);
	}

	SECTION("*137 characters (exactly block + 1 size)") {
		auto in = std::string(size_t(137), '*'); // size of block + 1
		const auto r0 = cthash::sha3_512().update(in).final();
		REQUIRE(r0 == "844698f1032311721397d3189cfcfcb7199bc1309bc87bc20223cf6b7d27100dd37d21fde6557994aa330c0f493fc09eb600cbe0a8a6c63477d5f7a36077eb8b"_sha3_512);
	}

	SECTION("*2500 characters") {
		auto in = std::string(size_t(2500), '*'); // size of block + 1
		const auto r0 = cthash::sha3_512().update(in).final();
		REQUIRE(r0 == "e4163add44fed59d52141fe016088b98a9716e0fde36c9f0fce75937414bdcb8b4211d1909a5ccd7f32df8af6d991a7fe1f65238e6da7e591d946b289b6b0a49"_sha3_512);
	}

	SECTION("*2500 by one") {
		const auto star = std::string_view{"*"};
		REQUIRE(star.size() == 1u);
		auto h = cthash::sha3_512();
		for (int i = 0; i != 2500; ++i) {
			h.update(star);
		}
		const auto r0 = h.final();
		REQUIRE(r0 == "e4163add44fed59d52141fe016088b98a9716e0fde36c9f0fce75937414bdcb8b4211d1909a5ccd7f32df8af6d991a7fe1f65238e6da7e591d946b289b6b0a49"_sha3_512);
	}
}

TEST_CASE("sha3-512 stability") {
	auto h = cthash::sha3_512();

	constexpr int end = int(h.rate) * 2;

	for (int i = 0; i != end; ++i) {
		const auto piece = std::string(size_t(i), '#');
		h.update(piece);
	}

	const auto r0 = h.final();
	REQUIRE(r0 == "62a8487cf7d35dd2688962c80581436171c93c7250da289944ac95abd597baa12cca5c022a19addfaaae48f144da2e6dd9f24c02c63c8ca25bb3fc288277179c"_sha3_512);
}
```

`tests/sha3/shake128.cpp`:

```cpp
#include <catch2/catch_test_macros.hpp>
#include "../internal/support.hpp"
#include <cthash/sha3/shake128.hpp>
#include <iostream>
#include <compare>

using namespace cthash::literals;

TEST_CASE("shake128 literal basics") {
	const auto a = "1234"_shake128;
	REQUIRE(a.size() == 2u);

	const auto b = "12345678"_shake128;
	REQUIRE(b.size() == 4u);

	const auto c = "1234567890abcdef"_shake128;
	REQUIRE(c.size() == 8u);

	const auto d = "1234567800000000"_shake128;
	REQUIRE(d.size() == 8u);

	REQUIRE(a == b);
	REQUIRE(a == c);

	REQUIRE(a == d);
	REQUIRE(b == d);

	REQUIRE(c != d);

	REQUIRE(std::is_eq(a <=> b));
	REQUIRE(std::is_eq(a <=> c));
}

TEST_CASE("shake128 calculation") {
	const auto expected = "f4202e3c5852f9182a0430fd8144f0a74b95e7417ecae17db0f8cfeed0e3e66eb5585ec6f86021cacf272c798bcf97d368b886b18fec3a571f096086a523717a3732d50db2b0b7998b4117ae66a761ccf1847a1616f4c07d5178d0d965f9feba351420f8bfb6f5ab9a0cb102568eabf3dfa4e22279f8082dce8143eb78235a1a54914ab71abb07f2f3648468370b9fbb071e074f1c030a4030225f40c39480339f3dc71d0f04f71326de1381674cc89e259e219927fae8ea2799a03da862a55afafe670957a2af3318d919d0a3358f3b891236d6a8e8d19999d1076b529968faefbd880d77bb300829dca87e9c8e4c28e0800ff37490a5bd8c36c0b0bdb2701a"_shake128;

	SECTION("16 bits") {
		auto r0 = cthash::shake128().update("The quick brown fox jumps over the lazy dog").final<16>();

		REQUIRE(r0 == expected);
	}

	SECTION("32 bits") {
		auto r0 = cthash::shake128().update("The quick brown fox jumps over the lazy dog").final<32>();

		REQUIRE(r0 == expected);
	}

	SECTION("64 bits") {
		auto r0 = cthash::shake128().update("The quick brown fox jumps over the lazy dog").final<64>();

		REQUIRE(r0 == expected);
	}

	SECTION("128 bits") {
		auto r0 = cthash::shake128().update("The quick brown fox jumps over the lazy dog").final<128>();

		REQUIRE(r0 == expected);
	}

	SECTION("256 bits") {
		auto r0 = cthash::shake128().update("The quick brown fox jumps over the lazy dog").final<256>();

		REQUIRE(r0 == expected);
	}

	SECTION("2048 bits") {
		auto r0 = cthash::shake128().update("The quick brown fox jumps over the lazy dog").final<2048>();

		REQUIRE(r0 == expected);
	}
}

TEST_CASE("shake128 calculation (b)") {
	const auto expected = "853f4538be0db9621a6cea659a06c1107b1f83f02b13d18297bd39d7411cf10c79229b22a2d29332019fca1dde63ad893e9b2fb2cf1e710e591a7dfaab201f528373514e015d872edb70b59eb04480dc669851e9f72272e33e382701575e9cd0a3247ffd784d968801c3e40bf9c0ec3b118e838329d89f16a081a1201e8350f5c839c846ec0262a6dec85450e0b350786b2e47b93de4f9a566b5220300d19cb9783af4a6242c19e36881cbcf328e5419009af9906634c37a37fecb35b8a96476a7e3fae1be94b90a9a635fac947bf633f5280d580e571ec3b019086e8166fcceb2478a2834ce35651b662be28382ceb1b5f6f6f7263c57037e58336fd1c354bb"_shake128;

	SECTION("16 bits") {
		auto r0 = cthash::shake128().update("The quick brown fox jumps over the lazy dof").final<16>();
		REQUIRE(sizeof(r0) == 2);
		REQUIRE(r0 == expected);
	}

	SECTION("32 bits") {
		auto r0 = cthash::shake128().update("The quick brown fox jumps over the lazy dof").final<32>();

		REQUIRE(r0 == expected);
	}

	SECTION("64 bits") {
		auto r0 = cthash::shake128().update("The quick brown fox jumps over the lazy dof").final<64>();

		REQUIRE(r0 == expected);
	}

	SECTION("128 bits") {
		auto r0 = cthash::shake128().update("The quick brown fox jumps over the lazy dof").final<128>();

		REQUIRE(r0 == expected);
	}

	SECTION("256 bits") {
		auto r0 = cthash::shake128().update("The quick brown fox jumps over the lazy dof").final<256>();

		REQUIRE(r0 == expected);
	}

	SECTION("2048 bits") {
		auto r0 = cthash::shake128().update("The quick brown fox jumps over the lazy dof").final<2048>();

		REQUIRE(r0 == expected);
	}
}
```

`tests/sha3/shake256.cpp`:

```cpp
#include <catch2/catch_test_macros.hpp>
#include "../internal/support.hpp"
#include <cthash/sha3/shake256.hpp>
#include <iostream>
#include <compare>

using namespace cthash::literals;

TEST_CASE("shake256 literal basics") {
	const auto a = "1234"_shake256;
	REQUIRE(a.size() == 2u);

	const auto b = "12345678"_shake256;
	REQUIRE(b.size() == 4u);

	const auto c = "1234567890abcdef"_shake256;
	REQUIRE(c.size() == 8u);

	REQUIRE(a == b);
	REQUIRE(a == c);

	REQUIRE(std::is_eq((a <=> b)));
	REQUIRE(std::is_eq((a <=> c)));
}

TEST_CASE("shake256 calculation") {
	const auto expected = "2f671343d9b2e1604dc9dcf0753e5fe15c7c64a0d283cbbf722d411a0e36f6ca1d01d1369a23539cd80f7c054b6e5daf9c962cad5b8ed5bd11998b40d5734442bed798f6e5c915bd8bb07e0188d0a55c1290074f1c287af06352299184492cbdec9acba737ee292e5adaa445547355e72a03a3bac3aac770fe5d6b66600ff15d37d5b4789994ea2aeb097f550aa5e88e4d8ff0ba07b88c1c88573063f5d96df820abc2abd177ab037f351c375e553af917132cf2f563c79a619e1bb76e8e2266b0c5617d695f2c496a25f4073b6840c1833757ebb386f16757a8e16a21e9355e9b248f3b33be672da700266be99b8f8725e8ab06075f0219e655ebc188976364"_shake256;

	SECTION("16 bits") {
		auto r0 = cthash::shake256().update("The quick brown fox jumps over the lazy dog").final<16>();

		REQUIRE(r0 == expected);
	}

	SECTION("32 bits") {
		auto r0 = cthash::shake256().update("The quick brown fox jumps over the lazy dog").final<32>();

		REQUIRE(r0 == expected);
	}

	SECTION("64 bits") {
		auto r0 = cthash::shake256().update("The quick brown fox jumps over the lazy dog").final<64>();

		REQUIRE(r0 == expected);
	}

	SECTION("128 bits") {
		auto r0 = cthash::shake256().update("The quick brown fox jumps over the lazy dog").final<128>();

		REQUIRE(r0 == expected);
	}

	SECTION("256 bits") {
		auto r0 = cthash::shake256().update("The quick brown fox jumps over the lazy dog").final<256>();

		REQUIRE(r0 == expected);
	}

	SECTION("2048 bits") {
		auto r0 = cthash::shake256().update("The quick brown fox jumps over the lazy dog").final<2048>();

		REQUIRE(r0 == expected);
	}
}

TEST_CASE("shake256 calculation (b)") {
	const auto expected = "46b1ebb2e142c38b9ac9081bef72877fe4723959640fa57119b366ce6899d4013af024f4222921320bee7d3bfaba07a758cd0fde5d27bbd2f8d709f4307d2c34a0baacb6f2ca73e5bdfe951c4f6f80ccf14a216c17512129d7afdccbc31aee975c41c66c24a2367820d2d5914fab194fea6b5749372aabf0276c3424d3145ec41645053272fe036dd13daab3b80e959290e885838a5e57a509d2785e99f83ce3efd810959d2a97f0e244a1b8382405ca3d6673f382054794f74d73af2765452442e72e6d199fe83ecf663cc6a14b57b2f16ccf3a83a613e7475c4b0761711e216e68051ca97c3b6cc9a91e35d442506443599f42921bba9558c62a5fdcf1ea42"_shake256;

	SECTION("16 bits") {
		auto r0 = cthash::shake256().update("The quick brown fox jumps over the lazy dof").final<16>();

		REQUIRE(r0 == expected);
	}

	SECTION("32 bits") {
		auto r0 = cthash::shake256().update("The quick brown fox jumps over the lazy dof").final<32>();

		REQUIRE(r0 == expected);
	}

	SECTION("64 bits") {
		auto r0 = cthash::shake256().update("The quick brown fox jumps over the lazy dof").final<64>();

		REQUIRE(r0 == expected);
	}

	SECTION("128 bits") {
		auto r0 = cthash::shake256().update("The quick brown fox jumps over the lazy dof").final<128>();

		REQUIRE(r0 == expected);
	}

	SECTION("256 bits") {
		auto r0 = cthash::shake256().update("The quick brown fox jumps over the lazy dof").final<256>();

		REQUIRE(r0 == expected);
	}

	SECTION("2048 bits") {
		auto r0 = cthash::shake256().update("The quick brown fox jumps over the lazy dof").final<2048>();

		REQUIRE(r0 == expected);
	}
}
```

`tests/sha3/xor-overwrite.cpp`:

```cpp
#include "../internal/support.hpp"
#include <cthash/sha3/sha3-256.hpp>
#include <catch2/catch_template_test_macros.hpp>
#include <iostream>

using namespace cthash::literals;

TEMPLATE_TEST_CASE("sha3 common xor_overwrite_block", "[xor]", std::byte, char) {
	using T = TestType;

	auto h = cthash::sha3_256();

	h.xor_overwrite_block(std::span<const T>(std::array<T, 4>{static_cast<T>(0xFAu), static_cast<T>(0xFBu), static_cast<T>(0xFCu), static_cast<T>(0xFDu)}));

	REQUIRE(h.position == 4u);

	REQUIRE(h.internal_state[0] == 0X00000000'FDFCFBFAull);
	REQUIRE(h.internal_state[1] == 0ull);

	h.xor_overwrite_block(std::span<const T>(std::array<T, 6>{static_cast<T>(0xF0u), static_cast<T>(0xF1u), static_cast<T>(0xF2u), static_cast<T>(0xF3u), static_cast<T>(0xA0u), static_cast<T>(0xA1u)}));

	REQUIRE(h.internal_state[0] == 0XF3F2F1F0'FDFCFBFAull);
	REQUIRE(h.internal_state[1] == 0X00000000'0000A1A0ull);
	REQUIRE(h.internal_state[2] == 0ull);

	REQUIRE(h.position == 10u);

	h.xor_overwrite_block(std::span<const T>(std::array<T, 33>{
		static_cast<T>(0xCCu),
		static_cast<T>(0xCCu),
		static_cast<T>(0xCCu),
		static_cast<T>(0xCCu),
		static_cast<T>(0xCCu),
		static_cast<T>(0xCCu),
		// aligned blocks
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		static_cast<T>(0xDDu),
		// suffix
		static_cast<T>(0xBBu),
		static_cast<T>(0xBBu),
		static_cast<T>(0xBBu)}));

	REQUIRE(h.internal_state[0] == 0XF3F2F1F0'FDFCFBFAull);
	REQUIRE(h.internal_state[1] == 0XCCCCCCCC'CCCCA1A0ull);
	REQUIRE(h.internal_state[2] == 0XDDDDDDDD'DDDDDDDDull);
	REQUIRE(h.internal_state[3] == 0XDDDDDDDD'DDDDDDDDull);
	REQUIRE(h.internal_state[4] == 0XDDDDDDDD'DDDDDDDDull);
	REQUIRE(h.internal_state[5] == 0X00000000'00BBBBBBull);
	REQUIRE(h.internal_state[6] == 0ull);

	REQUIRE(h.position == 43u);

	h.xor_overwrite_block(std::span<const T>(std::array<T, 5>{static_cast<T>(0x11u), static_cast<T>(0x11u), static_cast<T>(0x11u), static_cast<T>(0x11u), static_cast<T>(0x11u)}));

	REQUIRE(h.internal_state[0] == 0XF3F2F1F0'FDFCFBFAull);
	REQUIRE(h.internal_state[1] == 0XCCCCCCCC'CCCCA1A0ull);
	REQUIRE(h.internal_state[2] == 0XDDDDDDDD'DDDDDDDDull);
	REQUIRE(h.internal_state[3] == 0XDDDDDDDD'DDDDDDDDull);
	REQUIRE(h.internal_state[4] == 0XDDDDDDDD'DDDDDDDDull);
	REQUIRE(h.internal_state[5] == 0X11111111'11BBBBBBull);
	REQUIRE(h.internal_state[6] == 0ull);

	REQUIRE(h.position == 48u);

	h.xor_overwrite_block(std::span<const T>(std::array<T, 10>{static_cast<T>(0x23u), static_cast<T>(0x22u), static_cast<T>(0x22u), static_cast<T>(0x22u), static_cast<T>(0x22u), static_cast<T>(0x22u), static_cast<T>(0x22u), static_cast<T>(0x22u), static_cast<T>(0x44u), static_cast<T>(0x45u)}));

	REQUIRE(h.internal_state[0] == 0XF3F2F1F0'FDFCFBFAull);
	REQUIRE(h.internal_state[1] == 0XCCCCCCCC'CCCCA1A0ull);
	REQUIRE(h.internal_state[2] == 0XDDDDDDDD'DDDDDDDDull);
	REQUIRE(h.internal_state[3] == 0XDDDDDDDD'DDDDDDDDull);
	REQUIRE(h.internal_state[4] == 0XDDDDDDDD'DDDDDDDDull);
	REQUIRE(h.internal_state[5] == 0X11111111'11BBBBBBull);
	REQUIRE(h.internal_state[6] == 0X22222222'22222223ull);
	REQUIRE(h.internal_state[7] == 0X00000000'00004544ull);

	REQUIRE(h.position == 58u);
}

/*
TEST_CASE("sha3 common xor_overwrite_block final (old)", "[xor]") {
	auto h = cthash::sha3_256();

	REQUIRE(h.rate == (1088u / 8u)); // bytes

	h.final_absorb_old();
	REQUIRE(cthash::cast_from_le_bytes<uint64_t>(std::span<const std::byte>(h.buffer.storage).first<8u>()) == 0b0000'0110ull); // it's reverted
	REQUIRE(unsigned(h.buffer.storage[0]) == unsigned(std::byte{0b0000'0110u}));

	// in between
	for (unsigned i = 1; i != 16; ++i) {
		REQUIRE(cthash::cast_from_le_bytes<uint64_t>(std::span<const std::byte>(h.buffer.storage).subspan(i * 8u).template first<8u>()) == 0ull);
	}

	// end of padding
	constexpr auto end_of_padding = std::byte{0b1000'0000u};
	constexpr uint64_t end_of_padding_num = 0b1000'0000ull << (7u * 8u);
	REQUIRE(cthash::cast_from_le_bytes<uint64_t>(std::span<const std::byte>(h.buffer.storage).subspan(16u * 8u).first<8u>()) == end_of_padding_num);
	REQUIRE(unsigned(h.buffer.storage[135]) == unsigned(end_of_padding));
	REQUIRE(136 == h.buffer.storage.size());
	REQUIRE(h.rate == h.buffer.storage.size());
}*/

TEST_CASE("sha3 common xor_padding_block final", "[xor]") {
	auto h = cthash::sha3_256();
	REQUIRE(h.rate == (1088u / 8u)); // bytes
	h.xor_padding_block();
	REQUIRE(h.internal_state[0] == 0b0000'0110ull); // it's reverted

	// in between is all zero
	REQUIRE(h.internal_state[1] == 0ull);
	REQUIRE(h.internal_state[2] == 0ull);
	REQUIRE(h.internal_state[3] == 0ull);
	REQUIRE(h.internal_state[4] == 0ull);
	REQUIRE(h.internal_state[5] == 0ull);
	REQUIRE(h.internal_state[6] == 0ull);
	REQUIRE(h.internal_state[7] == 0ull);
	REQUIRE(h.internal_state[8] == 0ull);
	REQUIRE(h.internal_state[9] == 0ull);
	REQUIRE(h.internal_state[10] == 0ull);
	REQUIRE(h.internal_state[11] == 0ull);
	REQUIRE(h.internal_state[12] == 0ull);
	REQUIRE(h.internal_state[13] == 0ull);
	REQUIRE(h.internal_state[14] == 0ull);
	REQUIRE(h.internal_state[15] == 0ull);

	// end of padding
	constexpr uint64_t end_of_padding = 0b1000'0000ull << (7u * 8u);
	REQUIRE(h.internal_state[16] == end_of_padding);

	// capacity
	REQUIRE(h.internal_state[17] == 0ull);
	REQUIRE(h.internal_state[18] == 0ull);
	REQUIRE(h.internal_state[19] == 0ull);
	REQUIRE(h.internal_state[20] == 0ull);
	REQUIRE(h.internal_state[21] == 0ull);
	REQUIRE(h.internal_state[22] == 0ull);
	REQUIRE(h.internal_state[23] == 0ull);
	REQUIRE(h.internal_state[24] == 0ull);
}

constexpr auto to_span = []<typename T, size_t N>(const std::array<T, N> & in) {
	return std::span<const T>(in);
};

TEMPLATE_TEST_CASE("sha3 unaligned prefix", "[xor]", std::byte, char) {
	using T = TestType;

	SECTION("one") {
		const auto r0 = cthash::convert_prefix_into_aligned<uint64_t>(to_span(std::array{static_cast<T>(0x12u)}), 7u);
		bool m0 = r0 == std::array<std::byte, 8>{std::byte{0}, std::byte{0}, std::byte{0}, std::byte{0}, std::byte{0}, std::byte{0}, std::byte{0}, std::byte{0x12u}};
		REQUIRE(m0);
	}

	SECTION("two") {
		const auto r0 = cthash::convert_prefix_into_aligned<uint64_t>(to_span(std::array{static_cast<T>(0x12u), static_cast<T>(0x34u)}), 6u);
		bool m0 = r0 == std::array<std::byte, 8>{std::byte{0}, std::byte{0}, std::byte{0}, std::byte{0}, std::byte{0}, std::byte{0}, std::byte{0x12u}, std::byte{0x34u}};
		REQUIRE(m0);
	}

	SECTION("three") {
		const auto r0 = cthash::convert_prefix_into_aligned<uint64_t>(to_span(std::array{static_cast<T>(0x12u), static_cast<T>(0x34u), static_cast<T>(0x56u)}), 5u);
		bool m0 = r0 == std::array<std::byte, 8>{std::byte{0}, std::byte{0}, std::byte{0}, std::byte{0}, std::byte{0}, std::byte{0x12u}, std::byte{0x34u}, std::byte{0x56u}};
		REQUIRE(m0);
	}

	SECTION("four") {
		const auto r0 = cthash::convert_prefix_into_aligned<uint64_t>(to_span(std::array{static_cast<T>(0x12u), static_cast<T>(0x34u), static_cast<T>(0x56u), static_cast<T>(0x78u)}), 4u);
		bool m0 = r0 == std::array<std::byte, 8>{std::byte{0}, std::byte{0}, std::byte{0}, std::byte{0}, std::byte{0x12u}, std::byte{0x34u}, std::byte{0x56u}, std::byte{0x78u}};
		REQUIRE(m0);
	}

	SECTION("five") {
		const auto r0 = cthash::convert_prefix_into_aligned<uint64_t>(to_span(std::array{static_cast<T>(0x12u), static_cast<T>(0x34u), static_cast<T>(0x56u), static_cast<T>(0x78u), static_cast<T>(0x90u)}), 3u);
		bool m0 = r0 == std::array<std::byte, 8>{std::byte{0}, std::byte{0}, std::byte{0}, std::byte{0x12u}, std::byte{0x34u}, std::byte{0x56u}, std::byte{0x78u}, std::byte{0x90u}};
		REQUIRE(m0);
	}

	SECTION("six") {
		const auto r0 = cthash::convert_prefix_into_aligned<uint64_t>(to_span(std::array{static_cast<T>(0x12u), static_cast<T>(0x34u), static_cast<T>(0x56u), static_cast<T>(0x78u), static_cast<T>(0x90u), static_cast<T>(0xABu)}), 2u);
		bool m0 = r0 == std::array<std::byte, 8>{std::byte{0}, std::byte{0}, std::byte{0x12u}, std::byte{0x34u}, std::byte{0x56u}, std::byte{0x78u}, std::byte{0x90u}, std::byte{0xABu}};
		REQUIRE(m0);
	}

	SECTION("seven") {
		const auto r0 = cthash::convert_prefix_into_aligned<uint64_t>(to_span(std::array{static_cast<T>(0x12u), static_cast<T>(0x34u), static_cast<T>(0x56u), static_cast<T>(0x78u), static_cast<T>(0x90u), static_cast<T>(0xABu), static_cast<T>(0xCDu)}), 1u);
		bool m0 = r0 == std::array<std::byte, 8>{std::byte{0}, std::byte{0x12u}, std::byte{0x34u}, std::byte{0x56u}, std::byte{0x78u}, std::byte{0x90u}, std::byte{0xABu}, std::byte{0xCDu}};
		REQUIRE(m0);
	}

	SECTION("eight") {
		const auto r0 = cthash::convert_prefix_into_aligned<uint64_t>(to_span(std::array{static_cast<T>(0x12u), static_cast<T>(0x34u), static_cast<T>(0x56u), static_cast<T>(0x78u), static_cast<T>(0x90u), static_cast<T>(0xABu), static_cast<T>(0xCDu), static_cast<T>(0xEFu)}), 0u);
		bool m0 = r0 == std::array<std::byte, 8>{std::byte{0x12u}, std::byte{0x34u}, std::byte{0x56u}, std::byte{0x78u}, std::byte{0x90u}, std::byte{0xABu}, std::byte{0xCDu}, std::byte{0xEFu}};
		REQUIRE(m0);
	}
}

TEMPLATE_TEST_CASE("sha3 sequence of overwrites", "[xor]", std::byte, char) {
	using T = TestType;

	auto h = cthash::sha3_256();

	auto in = std::array<TestType, 1>{static_cast<T>('*')};

	h.update(in);
	REQUIRE(h.position == 1u);
	REQUIRE(h.internal_state[0] == 0x2Aull);
	REQUIRE(h.internal_state[1] == 0x0ull);

	h.update(in);
	REQUIRE(h.position == 2u);
	REQUIRE(h.internal_state[0] == 0x2A2Aull);
	REQUIRE(h.internal_state[1] == 0x0ull);

	h.update(in);
	REQUIRE(h.position == 3u);
	REQUIRE(h.internal_state[0] == 0x2A2A2Aull);
	REQUIRE(h.internal_state[1] == 0x0ull);

	h.update(in);
	REQUIRE(h.position == 4u);
	REQUIRE(h.internal_state[0] == 0x2A2A2A2Aull);
	REQUIRE(h.internal_state[1] == 0x0ull);

	h.update(in);
	REQUIRE(h.position == 5u);
	REQUIRE(h.internal_state[0] == 0x2A2A2A2A2Aull);
	REQUIRE(h.internal_state[1] == 0x0ull);

	h.update(in);
	REQUIRE(h.position == 6u);
	REQUIRE(h.internal_state[0] == 0x2A2A2A2A2A2Aull);
	REQUIRE(h.internal_state[1] == 0x0ull);

	h.update(in);
	REQUIRE(h.position == 7u);
	REQUIRE(h.internal_state[0] == 0x2A2A2A2A2A2A2Aull);
	REQUIRE(h.internal_state[1] == 0x0ull);

	h.update(in);
	REQUIRE(h.position == 8u);
	REQUIRE(h.internal_state[0] == 0x2A2A2A2A2A2A2A2Aull);
	REQUIRE(h.internal_state[1] == 0x0ull);

	h.update(in);
	REQUIRE(h.position == 9u);
	REQUIRE(h.internal_state[0] == 0x2A2A2A2A2A2A2A2Aull);
	REQUIRE(h.internal_state[1] == 0x2Aull);
	REQUIRE(h.internal_state[2] == 0ull);
}
```

`tests/value.cpp`:

```cpp
#include <catch2/catch_test_macros.hpp>
#include <cthash/value.hpp>
#include <sstream>

using namespace cthash::literals;

TEST_CASE("hash_value (constexpr basics)") {
	constexpr auto v1 = cthash::hash_value{"0011223300112233"};
	constexpr auto v2 = cthash::hash_value{"00112233aabbccdd"};

	STATIC_REQUIRE(std::is_eq(v1 <=> v1));
	STATIC_REQUIRE(v1 == v1);
	STATIC_REQUIRE(v1 < v2);
	STATIC_REQUIRE(v2 > v1);
	STATIC_REQUIRE(v1 != v2);

	constexpr auto v3 = cthash::hash_value{u8"00112233aabbccdd"};

	STATIC_REQUIRE(v1 != v2);
	STATIC_REQUIRE(v2 == v3);

	[[maybe_unused]] constexpr auto v4 = "599ba25a0d7c7d671bee93172ca7e272fc87f0c0e02e44df9e9436819067ea28"_hash;
	constexpr auto v5 = "00112233aabbccdd"_hash;

	STATIC_REQUIRE(v5 == v3);

	// constexpr bool comparable = requires(cthash::hash_value<8> l, cthash::hash_value<4> r) { v1 == v2; };
}

TEST_CASE("hash_value (runtime basics)") {
	auto v1 = cthash::hash_value{"0011223300112233"};
	auto v2 = cthash::hash_value{"00112233aabbccdd"};

	REQUIRE(std::is_eq(v1 <=> v1)); // appleclang doesn't have std::is_eq
	REQUIRE(v1 == v1);
	REQUIRE(v1 < v2);
	REQUIRE(v2 > v1);
	REQUIRE(v1 != v2);

	auto v3 = cthash::hash_value{u8"00112233aabbccdd"};

	REQUIRE(v1 != v2);
	REQUIRE(v2 == v3);

	[[maybe_unused]] auto v4 = "599ba25a0d7c7d671bee93172ca7e272fc87f0c0e02e44df9e9436819067ea28"_hash;
	auto v5 = "00112233aabbccdd"_hash;

	REQUIRE(v5 == v3);

	// constexpr bool comparable = requires(cthash::hash_value<8> l, cthash::hash_value<4> r) { v1 == v2; };
}

auto convert_to_string(auto && val) {
	std::ostringstream os;
	os << val;
	return std::move(os).str();
}

TEST_CASE("hash stringification") {
	auto v1 = cthash::hash_value{"00112233aabbccdd"};
	REQUIRE(convert_to_string(v1) == "00112233aabbccdd");
}

```

`tests/xxhash/basics.cpp`:

```cpp
#include "../internal/support.hpp"
#include <cthash/xxhash.hpp>
#include <catch2/benchmark/catch_benchmark.hpp>
#include <catch2/catch_test_macros.hpp>

using namespace cthash::literals;

TEST_CASE("xxhash update", "[xxh-basic]") {
	const auto arr = array_of<32>(std::byte(0xEF));

	cthash::xxhash<32> h{};

	// IV
	REQUIRE(h.seed == 0u);
	REQUIRE(h.internal_state[0] == cthash::xxhash_types<32>::primes[0] + cthash::xxhash_types<32>::primes[1]);
	REQUIRE(h.internal_state[1] == cthash::xxhash_types<32>::primes[1]);
	REQUIRE(h.internal_state[2] == 0u);
	REQUIRE(h.internal_state[3] == 0u - cthash::xxhash_types<32>::primes[0]);

	REQUIRE(h.length == 0u);
	REQUIRE(h.buffer_usage() == 0u);

	// process
	h.update(std::span(arr).first(1));
	REQUIRE(h.length == 1u);
	REQUIRE(h.buffer_usage() == 1u);

	REQUIRE(h.buffer.size() == 16u);
	REQUIRE(unsigned(h.buffer[0]) == 0xEFu);
	for (int i = 1; i != h.buffer.size(); ++i) {
		REQUIRE(unsigned(h.buffer[static_cast<size_t>(i)]) == 0u);
	}

	h.update(std::span(arr).first(1));
	REQUIRE(h.length == 2u);
	REQUIRE(h.buffer_usage() == 2u);

	REQUIRE(unsigned(h.buffer[0]) == 0xEFu);
	REQUIRE(unsigned(h.buffer[1]) == 0xEFu);
	for (int i = 2; i != h.buffer.size(); ++i) {
		REQUIRE(unsigned(h.buffer[static_cast<size_t>(i)]) == 0u);
	}

	h.update(std::span(arr).first(14));
	REQUIRE(h.length == 16u);
	for (int i = 0; i != h.buffer.size(); ++i) {
		REQUIRE(unsigned(h.buffer[static_cast<size_t>(i)]) == 0xEFu);
	}
	REQUIRE(h.buffer_usage() == 0u);

	// buffer is untouched
	REQUIRE(cthash::get_le_number_from<uint32_t, 0>(std::span<const std::byte>(h.buffer)) == 0xEFEFEFEFu);
	REQUIRE(cthash::get_le_number_from<uint32_t, 1>(std::span<const std::byte>(h.buffer)) == 0xEFEFEFEFu);
	REQUIRE(cthash::get_le_number_from<uint32_t, 2>(std::span<const std::byte>(h.buffer)) == 0xEFEFEFEFu);
	REQUIRE(cthash::get_le_number_from<uint32_t, 3>(std::span<const std::byte>(h.buffer)) == 0xEFEFEFEFu);

	// first step should be called here, so internal state is different than it was
	REQUIRE(h.internal_state[0] == 0x659373acu);
	REQUIRE(h.internal_state[1] == 0x6015b815u);
	REQUIRE(h.internal_state[2] == 0xd21cf068u);
	REQUIRE(h.internal_state[3] == 0xcc9f34d1u);

	// additional block
	h.update(std::span(arr).first(16));
	REQUIRE(h.length == 32u);
	for (int i = 0; i != h.buffer.size(); ++i) {
		REQUIRE(unsigned(h.buffer[static_cast<size_t>(i)]) == 0xEFu);
	}
	REQUIRE(h.buffer_usage() == 0u);

	REQUIRE(h.internal_state[0] == 0xd721597au);
	REQUIRE(h.internal_state[1] == 0xceb0cfcau);
	REQUIRE(h.internal_state[2] == 0x59c4a3bbu);
	REQUIRE(h.internal_state[3] == 0x51541a0bu);

	SECTION("stop now") {
		const auto c = h.converge_conditionaly();
		REQUIRE(c == 0xb9139348u);
		const auto len = c + h.length;
		REQUIRE(len == 0xb9139368u);
		const auto cons = decltype(h)::config::consume_remaining(len, std::span<const std::byte>(h.buffer).first(h.buffer_usage()));
		REQUIRE(cons == 0xb9139368u);
		const auto aval = decltype(h)::config::avalanche(cons);
		REQUIRE(aval == 0xbea54e50u);
		REQUIRE(h.final() == "bea54e50"_xxh32);
	}

	SECTION("continue") {
		// additional block 2
		const auto arr2 = array_of<32>(std::byte(0xAB));
		REQUIRE(h.buffer_usage() == 0u);
		h.update(std::span(arr2).first(20));
		REQUIRE(h.length == 52u);
		REQUIRE(h.buffer_usage() == 4u);
		REQUIRE(unsigned(h.buffer[0]) == 0xABu);
		REQUIRE(unsigned(h.buffer[1]) == 0xABu);
		REQUIRE(unsigned(h.buffer[2]) == 0xABu);
		REQUIRE(unsigned(h.buffer[3]) == 0xABu);

		REQUIRE(h.internal_state[0] == 0x3f316f5bu);
		REQUIRE(h.internal_state[1] == 0xf45916adu);
		REQUIRE(h.internal_state[2] == 0x73c86d6fu);
		REQUIRE(h.internal_state[3] == 0x28f014c1u);

		SECTION("finish") {
			const auto c = h.converge_conditionaly();
			REQUIRE(c == 0x84c9d0acu);
			const auto len = c + h.length;
			REQUIRE(len == 0x84c9d0e0u);
			const auto cons = decltype(h)::config::consume_remaining(len, std::span<const std::byte>(h.buffer).first(h.buffer_usage()));
			REQUIRE(cons == 0xeab6d685u);
			const auto aval = decltype(h)::config::avalanche(cons);
			REQUIRE(aval == 0x78c3c388u);
			REQUIRE(h.final() == "78c3c388"_xxh32);
		}

		// const auto iv3 = h.internal_state;
	}
}

TEST_CASE("xxhash_fnc basics", "[xxh]") {
	SECTION("empty string") {
		const std::string_view empty = "";

		// REQUIRE(cthash::xxhash<32>{}.update(empty).final() == "02cc5d05"_xxh32);
		// REQUIRE(cthash::xxhash<64>{}.update(empty).final() == "ef46db3751d8e999"_xxh64);

		REQUIRE(cthash::simple<cthash::xxhash<32>>(empty, 0u) == "02cc5d05"_xxh32);
		REQUIRE(cthash::simple<cthash::xxhash<64>>(empty, 0u) == "ef46db3751d8e999"_xxh64);

		REQUIRE(cthash::simple<cthash::xxhash<32>>(empty, 42u) == "d5be6eb8"_xxh32);
		REQUIRE(cthash::simple<cthash::xxhash<64>>(empty, 42u) == "98b1582b0977e704"_xxh64);
	}

	SECTION("empty string") {
		const std::string_view in = "hello there";

		REQUIRE(cthash::simple<cthash::xxhash<32>>(in, 0u) == "371c3e72"_xxh32);
		REQUIRE(cthash::simple<cthash::xxhash<64>>(in, 0u) == "08f296af889a203c"_xxh64);

		REQUIRE(cthash::simple<cthash::xxhash<32>>(in, 42u) == "4a90b3c2"_xxh32);
		REQUIRE(cthash::simple<cthash::xxhash<64>>(in, 42u) == "1a910e9618a06c28"_xxh64);
	}

	SECTION("longer string") {
		const std::string_view in = "hello there, from somehow long string! really this should be enought :)";

		REQUIRE(cthash::simple<cthash::xxhash<32>>(in, 0u) == "2daeaacd"_xxh32);
		REQUIRE(cthash::simple<cthash::xxhash<64>>(in, 0u) == "4f6f14232e5ab579"_xxh64);

		REQUIRE(cthash::simple<cthash::xxhash<32>>(in, 42u) == "b66e8e53"_xxh32);
		REQUIRE(cthash::simple<cthash::xxhash<64>>(in, 42u) == "62eee52b8dbf7af9"_xxh64);
	}

	SECTION("longer string via multiple update") {
		cthash::xxhash<32> h1{};
		cthash::xxhash<64> h2{};

		h1.update("hello there, ").update("from somehow long string!").update(" really this should be enought :)");
		h2.update("hello there, ").update("from somehow long string!").update(" really this should be enought :)");

		SECTION("32 bits") {
			REQUIRE(h1.internal_state[0] == 0x2c7844f7u);
			REQUIRE(h1.internal_state[1] == 0xdf8adc4fu);
			REQUIRE(h1.internal_state[2] == 0x502598e7u);
			REQUIRE(h1.internal_state[3] == 0x032d3506u);

			REQUIRE(h1.final() == "2daeaacd"_xxh32);
		}

		SECTION("64 bits") {
			REQUIRE(h2.final() == "4f6f14232e5ab579"_xxh64);
		}
	}

	SECTION("longer string") {
		const std::string_view lit = "hello there, from somehow long string! really this should be enought :)";

		cthash::xxhash<32> h1{};
		cthash::xxhash<64> h2{};

		for (int i = 0; i != 1000; ++i) {
			h1.update(lit);
			h2.update(lit);
		}

		SECTION("32 bits") {
			REQUIRE(h1.final() == "a7d7a81d"_xxh32);
		}

		SECTION("64 bits") {
			REQUIRE(h2.final() == "bd6f22acc408272d"_xxh64);
		}
	}
}

TEST_CASE("xxhash_fnc benchmarks", "[xxh]") {
	auto val = std::string(10u * 1024u * 1024u, '*');

	BENCHMARK("really long string (32bit) (10MB)") {
		return cthash::simple<cthash::xxhash<32>>(std::string_view(val));
	};

	BENCHMARK("really long string (64bit) (10MB)") {
		return cthash::simple<cthash::xxhash<64>>(std::string_view(val));
	};

	auto val2 = std::string(1024u * 1024u * 1024u, '*');

	BENCHMARK("really long string (32bit) (1GB)") {
		return cthash::simple<cthash::xxhash<32>>(std::string_view(val2));
	};

	BENCHMARK("really long string (64bit) (1GB)") {
		return cthash::simple<cthash::xxhash<64>>(std::string_view(val2));
	};
}
```