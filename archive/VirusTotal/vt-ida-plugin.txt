Project Path: arc_VirusTotal_vt-ida-plugin_0wtkytek

Source Tree:

```txt
arc_VirusTotal_vt-ida-plugin_0wtkytek
├── CODEOWNERS
├── LICENSE
├── README.md
├── VERSION
├── ida-plugin.json
├── images
│   ├── function.gif
│   └── main_window_menu.png
└── plugin
    ├── virustotal
    │   ├── __init__.py
    │   ├── ci_notebook.py
    │   ├── codeinsight.py
    │   ├── config.py
    │   ├── vt_ida
    │   │   ├── __init__.py
    │   │   ├── disassembler.py
    │   │   ├── plugin_loader.py
    │   │   ├── ui
    │   │   │   ├── __init__.py
    │   │   │   ├── qt5logo.py
    │   │   │   ├── qt5panel.py
    │   │   │   ├── qt6logo.py
    │   │   │   ├── qt6panel.py
    │   │   │   └── resources
    │   │   │       ├── vt_icon.png
    │   │   │       ├── vt_logo.png
    │   │   │       └── vt_logo.qrc
    │   │   ├── vtpanel.py
    │   │   └── vtwidgets.py
    │   └── vtgrep.py
    └── vt.py

```

`CODEOWNERS`:

```
# Lines starting with '#' are comments.
# Each line is a file pattern followed by one or more owners.

# These owners will be the default owners for everything in the repo.
*       @gerardofn @escipion @guspascual


```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# VirusTotal Plugin for IDA Pro

This is the official VirusTotal plugin for Hex-Rays IDA Pro. It seamlessly integrates VirusTotal's powerful analysis capabilities directly into your reverse engineering workflow.

The plugin offers two core functionalities:
1.  **Code Similarity Search**: Perform advanced searches for code, bytes, and strings across VirusTotal's massive dataset directly from IDA's disassembly and strings views.

![Code Similarity Visualization](images/function.gif)

2.  **Code Insight Notebook**: Leverage VirusTotal's Code Insight to get summaries and descriptions of functions. Keep track of your findings in a persistent, shareable notebook within the IDA sidebar.

![Code Insight Notebook Visualization](images/main_window_menu.png)

## Features

### Code Insight Notebook

The Code Insight Notebook is a powerful feature that lives in its own dockable panel (`View -> Open subviews -> VirusTotal`).

- **Code Insight Analysis**: Request an AI-generated summary and detailed description for any function (disassembled or decompiled).
- **Persistent Workspace**: All analyses are saved in a "notebook" that can be loaded again across IDA sessions.
- **Edit and Refine**: You can edit the AI-generated analysis to correct it or add your own insights.
- **Automatic Commenting**: Automatically populate IDA's function comments with the analysis summary for all functions in your notebook.
- **Import/Export**: Share your analysis with colleagues by exporting the notebook to a JSON file, or import one to get up to speed on a shared binary.

### Code Similarity Search (Right-Click Context Menu)

From the **Disassembly View**:

- **Search for bytes**: Performs a raw byte search in VirusTotal for the selected sequence.
- **Search for similar code**: Searches for functionally similar code by wildcarding memory addresses and offsets.
- **Search for similar code (strict)**: A more aggressive version of the above that also wildcards all immediate values (constants).
- **Search for similar functions**: Automatically detects the boundaries of the current function and searches for similar functions, so you don't have to select it manually.

From the **Strings View**:

- **Search for string**: Searches for the selected string(s) in VirusTotal.

## Requirements

- **IDA Pro**: Tested with versions 8 or newer. Please note that IDA Pro v9.2+ requires PySide6.
- **Python**: Use Python Version 3.x with the requests module. Version 3.9 and later are recommended.
- **VirusTotal API Key**: A valid VirusTotal API key is **required** for using Code Insight. VTGrep searches rely on an active VirusTotal Enterprise session in your web browser.

## Installation

1.  Install the `requests` module for Python:
    ```bash
    $ pip install requests
    ```
2.  Copy the entire `plugins/virustotal` directory into your IDA Pro plugins folder.

| OS      | Default Plugin Path             |
| ------- | ------------------------------- |
| Linux   | `/opt/ida-pro-X.X/plugins`      |
| macOS   | `~/.idapro/plugins`             |
| Windows | `%ProgramFiles%\IDA Pro X.X\plugins`|

3.  Start IDA Pro.

## Configuration

### First-Time Run

On the first run, the plugin will ask for your consent to automatically upload samples to VirusTotal. This choice is saved in a configuration file.

- **OK**: Agree to the terms and enable automatic uploads for files not found on VirusTotal.
- **No**: Disable automatic uploads.
- **Cancel**: Disable the plugin for the current session.

### API Key

To use the **Code Insight** features, you must add your VirusTotal API key to the configuration file:

1.  Locate the configuration file: `[USER_IDA_DIR]/plugins/virustotal/config.py`
2.  Open the file and add your key:
    ```ini
    API_KEY = 'YOUR_VT_API_KEY_HERE'
    ```

The plugin creates a `virustotal.conf` file in your user IDA directory (e.g., `%APPDATA%\Hex-Rays\IDA Pro` on Windows or `~/.idapro` on macOS/Linux) to store your preferences.

## Usage

### Code Insight Notebook

1.  Open the panel via `View -> Open subviews -> VirusTotal`.
2.  In the IDA Disassembly or Decompiler view, place your cursor inside a function.
3.  Right-click and select `VirusTotal -> Ask Code Insight` or just click on the `Ask CI` button in the `Code Insight Notebook` panel.
4.  The analysis will appear in the VirusTotal panel. You can now:
    - Edit the summary or description.
    - Click **Accept** to save the analysis (including your edits) to the notebook.
    - Click **Discard** to remove the analysis.
    - Click **Autocomment** to add all saved analyses as comments to their respective functions in IDA.

### Code Similarity Search

1.  In the Disassembly or Strings view, select a piece of code or a string.
2.  Right-click and choose the desired search option under the `VirusTotal` menu.
3.  A new tab will open in your default web browser with the VTGrep search results.

### Usage examples

In this VirusTotal blog post, we use practical examples to demonstrate how to get the most out of the tool:

https://blog.virustotal.com/2025/08/integrating-code-insight-into-reverse.html

## Supported Architectures

The "Search for similar code" features are fully supported on the following processor architectures:
- **Intel x86/x64** (metapc)
- **ARM**

While other architectures may work, they have not been officially tested. Raw byte and string searches work on all architectures.

Check IDA Pro's output window for any message that may need your attention.

## Changelog

- v1.08 : Added support for configuration via the IDA Pro plugin manager (kevimuoz).
- v1.07 : Improved error handling, now CodeInsight works with other CPU architectures identified by IDA Pro.
- v1.06 : Updated plugin metadata to support HCLI Plugin Manager ecosystem.
- v1.05 : Fixes crash when Code Insight returns an invalid response.
- v1.04 : Fixes issue that left IDA hanging while a query was being performed.
- v1.03 : BUG fixed (wrongly showing an invalid api key msg).
- v1.02 : Added support for IDA Pro 9.2
- v1.00 : Added Code Insight panel.
- v0.11 : Added support for IDA Pro 8.x
- v0.10 : Initial release.
```

`VERSION`:

```
1.08
```

`ida-plugin.json`:

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "vt-ida-plugin",
    "entryPoint": "plugin/vt.py",
    "version": "1.0.8",
    "idaVersions": ">=8",
    "description": "Integrates VirusTotal's powerful analysis capabilities directly into your reverse engineering workflow.",
    "license": "Apache 2.0",
    "logoPath": "plugin/virustotal/vt_ida/ui/resources/vt_logo.png",
    "categories": [
      "ui-ux-and-visualization",
      "integration-with-third-parties-interoperability"
    ],
    "keywords": [
      "virustotal",
      "vt",
      "code-similarity",
      "code-insight"
    ],
    "pythonDependencies": ["requests"],
    "urls": {
      "repository": "https://github.com/VirusTotal/vt-ida-plugin"
    },
    "authors": [{
      "name": "Gerardo Fernandez",
      "email": "gerardofn@virustotal.com"
    }],
    "settings": [
      {
        "name": "VirusTotal Api Key",
        "key": "api_key",
        "title": "VirusTotal API Key for Code Insight",
        "type": "string",
        "required": false,
        "documentation": "Your VirusTotal API key is required to access Code Insight features. You can obtain an API key by creating a free account on VirusTotal's website."
      },
      {
        "name": "Enable Debug Mode",
        "key": "debug",
        "title": "Enable Debug Mode", 
        "type": "boolean",
        "default": false,
        "required": false,
        "documentation": "Enable debug mode to log detailed information for troubleshooting purposes."
      }
    ]
  }
}

```

`plugin/virustotal/ci_notebook.py`:

```py
# Copyright 2025 Google LLC. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

__author__ = 'gerardofn@virustotal.com'


import logging
import json
import base64


class CI_Notebook(object):
  """Manages a collection of Code Insight analysis results.

  This class acts as an in-memory database for storing, retrieving, and
  managing analysis "pages" for different functions within a binary. Each page
  is keyed by the function's memory address.
  """

  def __init__(self):
    """Initializes a new, empty Code Insight notebook."""
    self.notebook = {}

  def import_data(self, ci_dict):
    """Imports data from a dictionary, merging it into the current notebook.

    Args:
      ci_dict (dict): Dictionary containing data to import. Existing keys
                      in the current notebook will be overwritten if they
                      match keys in the imported dictionary.
    """
    try:
      self.notebook.update(ci_dict)
    except (TypeError, ValueError):
      logging.error('[VT Plugin] ERROR importing the file.')

  def get_total(self):
    """Gets the total number of pages (functions) in the notebook.

    Returns:
      int: The total number of pages, or 0 if the notebook is empty.
    """
    return len(self.notebook)

  def get_functions(self):
    """Gets all function addresses (keys) present in the notebook.

    Returns:
      A view of the notebook's keys (function addresses as hex strings).
    """
    return self.notebook.keys()

  def get_page(self, func_addr):
    """
    Retrieves the data for a specific page from the notebook.

    Args:
      func_addr (str): The function address (key as a hex string)
                       for the page to retrieve.

    Returns:
      dict: A dictionary containing the page data if found,
            or None if the address does not exist in the notebook.
    """
    return self.notebook.get(func_addr)

  @staticmethod
  def encode_response(summary, description):
    """
    Encodes a summary and description into a Base64-encoded JSON string.

    Args:
      summary (str): The summary to encode.
      description (str): The description to encode.

    Returns:
      str: The Base64 encoded JSON string (ASCII format).
    """
    response = {
      "summary": summary,
      "description": description
    }
    try:
      response_str = json.dumps(response)
    except TypeError:
      logging.error('[VT Plugin] ERROR encoding CI response (not serializable).')
      response_str = "{}"
    encoded_response = base64.b64encode(response_str.encode('utf-8'))
    return encoded_response.decode('ascii')

  def add_page(self, func_name, func_addr, code_type, b64code, summary, description, expected_summary, expected_description):
    """Adds a new page to the notebook or updates an existing one.

    Args:
      func_name (str): Name of the function.
      func_addr (str): Function address (key as a hex string).
      code_type (str): Type of code (e.g., 'disassembled', 'decompiled').
      b64code (str): Base64 encoded source code of the function.
      summary (str): Original summary provided by CodeInsight.
      description (str): Original description provided by CodeInsight.
      expected_summary (str): User-expected or modified summary.
      expected_description (str): User-expected or modified description.
    """
    logging.debug("[VT Plugin] Adding or updating page for %s", func_addr)
    page = {
        'func_name': func_name,
        'code_type': code_type,
        'b64code': b64code,
        'summary': summary,
        'description': description,
        'expected_summary': expected_summary or None,
        'expected_description': expected_description or None,
    }
    self.notebook[func_addr] = page
    logging.debug("[VT Plugin] CI Notebook content: %s", self.show_pages())


  def discard_page(self, func_addr):
    """
    Removes a page from the notebook.

    Args:
      func_addr (str): The function address (key as a hex string)
                       of the page to be removed.
    """
    if self.notebook.pop(func_addr, None):
      logging.debug('[VT Plugin] Page for %s discarded.', func_addr)
      self.show_pages()
    else:
      logging.debug('[VT Plugin] Attempted to discard non-existent page for %s', func_addr)

  def show_pages(self):
    """
    Logs the current function keys (debug level) and returns the entire notebook.

    Returns:
      dict: The complete notebook dictionary.
    """
    logging.debug("[VT Plugin] Current functions: %s", str(self.notebook.keys()))
    return self.notebook

```

`plugin/virustotal/codeinsight.py`:

```py
# Copyright 2025 Google LLC. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

__author__ = 'gerardofn@virustotal.com'

import logging
import binascii
import requests
from virustotal import config
from virustotal.vt_ida.disassembler import Disassembler
import threading
import json
import base64
from virustotal.ci_notebook import CI_Notebook
from virustotal.vt_ida.vtwidgets import VTWidgets

try:
  from urllib import quote
except ImportError:
  from urllib.parse import quote

CI_DECOMPILED= 'decompiled'
CI_DISASSEMBLED = 'disassembled'
ci_notebook = CI_Notebook()

class QueryCodeInsight(threading.Thread):
  """A thread to query the VirusTotal Code Insight API."""
  use_codetype = None
  encoded_src = None
  _return = None
  _error_msg = None
    
  def __init__(self, *args, **kwargs):
    """Initializes the QueryCodeInsight thread.

    Args:
      *args: Variable length argument list (not used).
      **kwargs: Arbitrary keyword arguments.
        use_codetype (str): The type of code being sent ('decompiled' or
          'disassembled').
        code (str): The source code to analyze.
    """
    self.use_codetype = kwargs.get('use_codetype', '')
    self.code = kwargs.get('code', '')

    if self.use_codetype: 
      logging.debug('[VT Plugin] Code Insight using src code type: %s', self.use_codetype)

    if self.code == '':
      logging.error('[VT Plugin] No proper query created for Code Insight')
      exit()

    threading.Thread.__init__(self)

  def get_encoded_src(self):
    """Returns the base64 encoded source code of the query.

    Returns:
      str: The base64 encoded source code.
    """
    return self.encoded_src

  def get_error_msg(self):
    """Returns the error message if the query failed.

    Returns:
      str: The error message, or None if there was no error.
    """
    return self._error_msg

  def _process_request(self, query):
    """Encodes the query string in base64.

    Args:
      query (str): The code to be sent to Code Insight.

    Returns:
      str: The base64 encoded query.
    """
    ci_request = base64.urlsafe_b64encode(query.encode('utf-8'))
    self.encoded_src = ci_request.decode('ascii')
    return self.encoded_src
   
  def _process_output(self, response):
    """Processes the JSON response from the Code Insight API.

    It decodes the response, checks for errors, and extracts the answer.

    Args:
      response (str): The JSON response from the API as a string.

    Returns:
      str: The decoded answer from Code Insight, or None if an error occurred.
    """
    decoded_str = ''
    json_data = json.loads(response)
    answer = json_data['data']
   
    if 'error' in answer:
      error_content = answer.get('error')
      error_response = {}
      # The error content from the API can be a string (sometimes JSON), or a dict.
      if isinstance(error_content, str):
          try:
              # Try to parse it as JSON
              error_response = json.loads(error_content)
              self._error_msg = error_response.get('message', error_content)
          except json.JSONDecodeError:
              # It's just a plain string
              self._error_msg = error_content
      elif isinstance(error_content, dict):
          self._error_msg = error_content.get('message', str(error_content))
          error_response = error_content
      else: # Fallback for other types like None
          self._error_msg = str(error_content)
      
      if 'not_parsed_output' in error_response:
        logging.debug('[VT Plugin] ERROR output: %s', error_response['not_parsed_output'])
      elif 'original_message' in error_response:  
        logging.debug('[VT Plugin] ERROR output: %s', error_response['original_message'])        
      else:
        logging.debug('[VT Plugin] ERROR message: %s', self._error_msg)
      return None
    
    try:
      decoded_str = base64.urlsafe_b64decode(answer)
    except (binascii.Error, ValueError): 
      logging.debug('[VT Plugin] ERROR decoding Code Insight response: %s', response)
      return None
        
    return decoded_str
  
  def run(self):
    """The main execution method for the thread.

    Constructs and sends a request to the Code Insight API and processes the
    response. The result is stored in self._return and any error message in
    self._error_msg.
    """
    global CI_DISASSEMBLED, CI_DECOMPILED
    global ci_notebook
 
    API_URL = 'https://www.virustotal.com'
    endpoint = 'api/v3/codeinsights/analyse-binary'
    headers_apiv3 = {
      'Accept': 'application/json',
      'Content-Type': 'application/json',
      'x-apikey': config.API_KEY}  

    payload = {
        'code': self._process_request(self.code),
      }
        
    if self.use_codetype == CI_DECOMPILED:
      payload['code_type'] = self.use_codetype
    else:
      payload['code_type'] = CI_DISASSEMBLED

    if ci_notebook.get_total():
      history = []

      for key in ci_notebook.get_functions():
        page= {}

        summary = ci_notebook.get_page(key)['summary']
        description = ci_notebook.get_page(key)['description']
        
        expected_summary = ci_notebook.get_page(key)['expected_summary']
        expected_description = ci_notebook.get_page(key)['expected_description']
        
        if expected_summary:
          summary = expected_summary
        
        if expected_description:
          description = expected_description
        
        encoded_response = CI_Notebook.encode_response(summary, description)
        page['request'] = ci_notebook.get_page(key)['b64code']
        page['response'] = encoded_response
        history.append(page)

      payload['history'] = history
      
    logging.debug('[VT Plugin] Sending request to Code Insight')
    logging.debug('[VT Plugin] Payload: %s', payload)

    try:
      response = requests.post(f'{API_URL}/{endpoint}', json = {'data': payload}, headers=headers_apiv3)
    except requests.RequestException:
      logging.debug('[VT Plugin] ERROR: unable to connect to Code Insight')
      self._error_msg = 'ERROR: unable to connect to Code Insight'
      return

    # Handle non-JSON responses first (e.g. HTML error pages for 429/5xx)
    try:
      json.loads(response.text)
    except json.JSONDecodeError:
      self._error_msg = f"API Error (HTTP {response.status_code}): {response.text}"
      return

    if response.status_code == 200:
        self._return = self._process_output(response.text)
    else:
        self._error_msg = self._process_output(response.text)
  
  def join(self, *args):
    """Waits for the thread to complete and returns the result.

    Overrides `threading.Thread.join` to return the value from the API call.

    Args:
      *args: Variable length argument list passed to `threading.Thread.join`.

    Returns:
      The result from the Code Insight query, or None if an error occurred.
    """
    threading.Thread.join(self, *args)
    return self._return


class CodeInsightASM(object):
  """Handles Code Insight queries for assembly code."""
  def __init__(self, *args, **kwargs):
    """Initializes the CodeInsightASM object.

    Args:
      *args: Variable length argument list (not used).
      **kwargs: Arbitrary keyword arguments.
        addr_start (int): The starting memory address for disassembly.
        addr_end (int): The ending memory address for disassembly.
        code_src (str): Pre-generated assembly source code.
    """
    self._MIN_QUERY_SIZE = 40      # number of bytes
    self._MAX_QUERY_SIZE = 4096    # Maximun length of a query string

    self._addr_start = kwargs.get('addr_start', 0)
    self._addr_end = kwargs.get('addr_end', 0)
    self.code_src = kwargs.get('code_src', None)
    self.encoded_src = None
    self.encoded_response = None
    self.error_msg = None

  def get_src(self):
    """Returns the raw assembly source code generated for the query.

    Returns:
      str: The assembly source code.
    """
    return self.code_src

  def get_encoded_src(self):
    """Returns the base64 encoded assembly source code of the query.

    Returns:
      str: The base64 encoded source code.
    """
    return self.encoded_src

  def get_encoded_response(self):
    """Returns the base64 encoded response from a previous query.

    Note: This seems to be intended for storing the response, but
    `self.encoded_response` is never set.

    Returns:
      The value of self.encoded_response, which is initialized to None.
    """
    return self.encoded_response
  
  def create_query(self):
    """Creates an assembly query string from the selected address range.

    Gathers disassembly from the start to the end address, including a
    function header and footer.

    Returns:
      str: A string containing the formatted assembly code for the query,
           or None if the address range is invalid or too large.
    """
    current = self._addr_start
    str_buf = ''
    disasm_engine = Disassembler()

    # Check if current selection is in a valid range
    if not disasm_engine.valid_address_range(self._addr_start, self._addr_end):
      logging.error('[CodeInsight] Select a valid function.')
      return None
    elif not disasm_engine.valid_range_size(
        self._addr_start,
        self._addr_end,
        self._MAX_QUERY_SIZE
        ):
      logging.error('[CodeInsight] The function selected is too large.')
      return None
    
    # Selected area is valid

    while current < self._addr_end:
      new_instr = disasm_engine.get_ASM_string(current)
      if new_instr == 0:
        break  # Unable to disassemble current address
      else:
        str_buf += '\n'
        str_buf += hex(current)
        str_buf += ' '
        str_buf += new_instr
      current = disasm_engine.next_address(current)

    if str_buf:
      header = disasm_engine.get_ASM_function_header(self._addr_start)
      footer = disasm_engine.get_ASM_function_footer(self._addr_start)
      return_str = '{}\n{}\n{}\n'.format(header, str_buf, footer)
      return return_str
    else:
      return None

  def get_error_msg(self):
    """Returns the error message if the query failed.

    Returns:
      str: The error message, or None if there was no error.
    """
    return self.error_msg

  def askCI(self, *args, **kwargs):
    """Sends an assembly code query to Code Insight.

    It creates the query, validates its size, runs the query in a separate
    thread, and processes the response.

    Args:
      *args: Variable length argument list (not used).
      **kwargs: Arbitrary keyword arguments.
        use_codetype (str): The type of code being sent.

    Returns:
      dict: The parsed JSON response from Code Insight, or None if an error
            occurred.
    """
    global widget_panel

    codetype = kwargs.get('use_codetype', '')
    if not self.code_src:
      self.code_src = self.create_query()

    # After creating the search string, checks if new size is valid
    if self.code_src is None:
      logging.error('[CodeInsight] Final query length is too long.')
      VTWidgets.show_warning('Invalid query length or function selected.')
      return None

    len_query = len(self.code_src)
    logging.debug('[CodeInsight] Final query length is: %d', len_query)
    if len_query and self._MIN_QUERY_SIZE >= len_query:
      logging.error('[CodeInsight] The query produced is too short.')
      VTWidgets.show_warning('The query produced is too short.')
      return None

    logging.debug('[CodeInsight] Query created for CodeInsight')
    ci = QueryCodeInsight(code=self.code_src, 
                          use_codetype=codetype)
    ci.start()
    json_str = ci.join()

    self.encoded_src = ci.get_encoded_src()
        
    if json_str:
      try:
        return json.loads(json_str)
      except json.JSONDecodeError:
         logging.debug('[CodeInsight] Error processing the returned json file.')
    else:
      self.error_msg = ci.get_error_msg()
    
    return None 


class CodeInsightDecompiled(object):
  """Handles Code Insight queries for decompiled C-like code."""
  def __init__(self, *args, **kwargs):
    """Initializes the CodeInsightDecompiled object.

    Args:
      *args: Variable length argument list (not used).
      **kwargs: Arbitrary keyword arguments.
        code_src (str): The decompiled source code to analyze.
    """
    self._MIN_QUERY_SIZE = 40      # number of bytes
    self.code_src = str(kwargs.get('code_src', ''))
    self.encoded_src = None

    if self.code_src:
      self.code_src += '\n'
    
  def get_src(self):
    """Returns the raw decompiled source code for the query.

    Returns:
      str: The decompiled source code.
    """
    return self.code_src

  def get_error_msg(self):
    """Returns the error message if the query failed.

    Returns:
      str: The error message, or None if there was no error.
    """
    return self.error_msg
  
  def get_encoded_src(self):
    """Returns the base64 encoded decompiled source code of the query.

    Returns:
      str: The base64 encoded source code.
    """
    return self.encoded_src
  
  def askCI(self, *args, **kwargs):
    """Sends a decompiled code query to Code Insight.

    It validates the code size, runs the query in a separate thread, and
    processes the response.

    Args:
      *args: Variable length argument list (not used).
      **kwargs: Arbitrary keyword arguments (not used).

    Returns:
      dict: The parsed JSON response from Code Insight, or None if an error
            occurred.
    """
    global widget_panel

    # After creating the search string, checks if new size is valid
    if not self.code_src:
      logging.error('[CodeInsight] Final query length is too long.')
      VTWidgets.show_warning('Invalid query length or function selected.')
      return None

    len_query = len(self.code_src)
    logging.debug('[CodeInsight] Final query length is: %d', len_query)
    if len_query and self._MIN_QUERY_SIZE >= len_query:
      logging.error('[CodeInsight] The query produced is too short.')
      VTWidgets.show_warning('The query produced is too short.')
      return None
    
    logging.debug('[VT Plugin] Query created for CodeInsight')
    ci = QueryCodeInsight(code=self.code_src, use_codetype=CI_DECOMPILED)
    ci.start()
    json_str = ci.join()

    self.encoded_src = ci.get_encoded_src()
    
    if json_str:
      try:
        return json.loads(json_str)
      except json.JSONDecodeError:
         logging.debug('[CodeInsight] Error processing the returned json file.')
    else:
      self.error_msg = ci.get_error_msg()
    
    return None

```

`plugin/virustotal/config.py`:

```py

# VT-IDA plugin global configuration file

API_KEY = ''  # Mandatory for CodeInsight
DEBUG = False

try:
    import ida_settings

    vt_api_key = ida_settings.get_current_plugin_setting("api_key")
    if vt_api_key:
        API_KEY = vt_api_key

    vt_debug = ida_settings.get_current_plugin_setting("debug")
    if vt_debug is not None:
        DEBUG = bool(vt_debug)
except:
    pass
```

`plugin/virustotal/vt_ida/disassembler.py`:

```py
# Copyright 2019 Google LLC. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

__author__ = 'gerardofn@virustotal.com'

import binascii
import ida_idp
import idaapi
import idautils
import idc
import logging


class Disassembler(object):

  @staticmethod
  def bad_address():
    return idaapi.BADADDR

  @staticmethod
  def next_address(addr):
    return idc.next_head(addr)

  @staticmethod
  def get_bytes(start_addr, end_addr):
    return idc.get_bytes(
        start_addr,
        end_addr - start_addr
        )

  @staticmethod
  def valid_address_range(start_addr, end_addr):
    if (start_addr == Disassembler.bad_address() or
        end_addr == Disassembler.bad_address()):
      return False
    else:
      return True

  @staticmethod
  def valid_range_size(start_addr, end_addr, max_size):
    if (end_addr - start_addr) > max_size:
      return False
    else:
      return True

  @staticmethod
  def wildcard_instruction(addr):
    """Replaces bytes related to memory addresses with wildcards.

    Args:
      addr: the address of the current instruction to be wildcarded

    Returns:
      String: hex-encoded representation of the bytes obtained at addr where
              all the operands that refers to memmory addresses are wildcarded.
    """

    pattern = ''
    mask = ida_idp.ph_calcrel(addr)
    # IDA > 7.5 return a list, < 7.5 returns a byte object
    if idaapi.IDA_SDK_VERSION >= 750:
      mask_bytes = mask[0]
      mask_str = binascii.hexlify(mask_bytes).decode('utf-8')
    else:
      mask_str = binascii.hexlify(mask).decode('utf-8')

    logging.debug(
        '[VTGREP] Wildcarding: %s',
        idc.generate_disasm_line(addr, 0)
        )

    current_byte = 0
    index_instr = 0
    pattern = ' '

    while current_byte < len(mask_str):
      if mask_str[current_byte] != '0' or mask_str[current_byte+1] != '0':
        pattern += '?? '
      else:
        instr_bytes = idc.get_bytes(addr+index_instr, 1)
        pattern += binascii.hexlify(instr_bytes).decode('utf-8') + ' '
      current_byte += 2
      index_instr += 1

    logging.debug('[VTGREP] Wildcarded: %s', pattern)

    return pattern

  @staticmethod
  def get_opcodes(addr, strict):
    """Get current bytes of the instruction pointed at addr.

    Args:
      addr: address of the current instruction
      strict: be more restrictive when applying wildcards (True) or not (False)

    Returns:
      String: hex-encoded representation of the bytes obtained at addr
    """

    if strict:
      offsets_types = {idaapi.o_far, idaapi.o_mem, idaapi.o_imm}
    else:
      offsets_types = {idaapi.o_far, idaapi.o_mem}

    pattern = ''
    mnem = idautils.DecodeInstruction(addr)

    if mnem is not None:
      op1_type = mnem.Op1.type
      op2_type = mnem.Op2.type

      logging.debug(
          '[VTGREP] Instruction: %s  [%d, %d, %d]',
          idc.generate_disasm_line(addr, 0),
          mnem.itype,
          op1_type,
          op2_type
          )

      inst_len = idc.get_item_size(addr)
      drefs = [x for x in idautils.DataRefsFrom(addr)]

      # Checks if any operand constains a memory address
      if (drefs and
          ((op1_type == idaapi.o_imm) or (op2_type == idaapi.o_imm)) or
          op1_type in offsets_types or op2_type in offsets_types):
        pattern = Disassembler.wildcard_instruction(addr)
      # Checks if the instruction is a CALL (near or far) or
      # if it's a JMP (excluding near jumps)
      else:
        if ((mnem.itype == idaapi.NN_call) or
            (mnem.itype == idaapi.NN_jmp and op1_type != idaapi.o_near)):
          pattern = Disassembler.wildcard_instruction(addr)
        # In any other case, concatenate the raw bytes to the current string
        else:
          pattern = binascii.hexlify(idc.get_bytes(addr, inst_len))
          pattern = pattern.decode('utf-8')
      return pattern
    else: return 0


  @staticmethod
  def get_ASM_string(addr):
    """Get current disassembled string of the instruction pointed at addr.

    Args:
      addr: address of the current instruction

    Returns:
      String: disassembled line with comments created by IDA Pro
    """
    return idc.GetDisasm(addr)

  @staticmethod
  def get_ASM_function_header(addr):
    """Get current function header of the instruction pointed at addr.

    Args:
      addr: address of the current instruction

    Returns:
      String: function header string (with comments when available)
    """
    comment = idc.get_func_cmt(addr,0)
    if not comment:
      comment = idc.get_func_cmt(addr,1)

    addrc = '; {}\n; Function name: {}'.format(comment, idc.get_func_name(addr))
    
    return addrc
  
  @staticmethod
  def get_ASM_function_footer(addr):
    """Get current function footer of the instruction pointed at addr.

    Args:
      addr: address of the current instruction

    Returns:
      String: function footer string (with comments when available)
    """

    addrc = '; {} endp'.format(idc.get_func_name(addr))
    
    return addrc
```

`plugin/virustotal/vt_ida/plugin_loader.py`:

```py
# Copyright 2019 Google LLC. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

__author__ = 'gerardofn@virustotal.com'

import sys
import hashlib
import ida_kernwin
import idaapi
import idc
import idautils
import logging
import os
import requests
import pathlib
import threading
from virustotal import config
from virustotal import vtgrep
from virustotal import codeinsight
from virustotal.vt_ida.vtpanel import VTPanel
from virustotal.vt_ida.vtwidgets import VTWidgets

if idaapi.IDA_SDK_VERSION >= 900:
  import ida_ida

try:
  import ConfigParser as configparser
except ImportError:
  import configparser

VT_IDA_PLUGIN_VERSION = '1.08'
widget_panel = VTPanel()

if config.DEBUG:
  logging.basicConfig(
      stream=sys.stdout,
      level=logging.DEBUG,
      format='%(message)s'
      )
else:
  logging.basicConfig(
      stream=sys.stdout,
      level=logging.INFO,
      format='%(message)s'
      )

def PLUGIN_ENTRY():
  return VTplugin()

def calculate_hash(input_file):
  """Return hash if the file hash has been properly calculated."""

  file_hash = None
  
  try:
    path_obj = pathlib.Path(input_file)
  except TypeError:
    logging.debug('[VT Plugin] Invalid path format: %s', input_file)
    path_obj = None

  if path_obj and path_obj.is_file():
    hash_f = hashlib.sha256()
    logging.debug('[VT Plugin] Input file available.')
    try:
      with path_obj.open('rb') as file_r:
        for file_buffer in iter(lambda: file_r.read(8192), b''):
          hash_f.update(file_buffer)
      file_hash = hash_f.hexdigest()
      logging.debug('[VT Plugin] Input file hash been calculated.')
    except OSError:
      logging.debug('[VT Plugin] Can\'t load the input file.')
  else:
    logging.debug('[VT Plugin] Input file not available.')
    tmp_hash = idautils.GetInputFileMD5()
    if len(tmp_hash) != 32:
      logging.error('[VT Plugin] IDAPYTHON API returned a wrong hash value.')
    else:
      file_hash = tmp_hash

  if file_hash:
    return file_hash
  
  logging.error('[VT Plugin] Input file hash error.')
  return None


class CodeInsightASM(idaapi.action_handler_t):
  """Performs the right click operation: query Code Insight for disassembled code."""

  @classmethod
  def get_name(cls):
    return cls.__name__

  @classmethod
  def get_label(cls):
    return cls.label

  @classmethod
  def activate(cls, ctx):
    cls.plugin.query_codeinsight(code_type=codeinsight.CI_DISASSEMBLED)
    return 1

  @classmethod
  def register(cls, plugin, label):
    cls.plugin = plugin
    cls.label = label
    instance = cls()

    return idaapi.register_action(idaapi.action_desc_t(
        cls.get_name(),
        instance.get_label(),
        instance
        ))

  @classmethod
  def unregister(cls):
    idaapi.unregister_action(cls.get_name())

  @classmethod
  def update(cls, ctx):
    global widget_panel

    if ctx.widget_type == idaapi.BWN_DISASM:
      return ida_kernwin.AST_ENABLE_FOR_WIDGET
    else:
      return ida_kernwin.AST_DISABLE_FOR_WIDGET

class CodeInsightDecompiled(idaapi.action_handler_t):
  """Performs the right click operation: query Code Insight for decompiled code."""

  @classmethod
  def get_name(cls):
    return cls.__name__

  @classmethod
  def get_label(cls):
    return cls.label

  @classmethod
  def activate(cls, ctx):
    cls.plugin.query_codeinsight(code_type=codeinsight.CI_DECOMPILED)
    return 1

  @classmethod
  def register(cls, plugin, label):
    cls.plugin = plugin
    cls.label = label
    instance = cls()

    return idaapi.register_action(idaapi.action_desc_t(
        cls.get_name(),
        instance.get_label(),
        instance
        ))

  @classmethod
  def unregister(cls):
    idaapi.unregister_action(cls.get_name())

  @classmethod
  def update(cls, ctx):
    global widget_panel
  
    if ctx.widget_type == idaapi.BWN_PSEUDOCODE:
      return ida_kernwin.AST_ENABLE_FOR_WIDGET
    else:
      return ida_kernwin.AST_DISABLE_FOR_WIDGET

class VTGrepStrings(idaapi.action_handler_t):
  """Performs the right click operation: Search for string."""

  @classmethod
  def get_name(cls):
    return cls.__name__

  @classmethod
  def get_label(cls):
    return cls.label

  @classmethod
  def activate(cls, ctx):
    for idx in ctx.chooser_selection:
      _, _, _, selected_string = ida_kernwin.get_chooser_data(
          ctx.widget_title,
          idx
          )
      cls.plugin.search_string(selected_string)
    return 0

  @classmethod
  def register(cls, plugin, label):
    cls.plugin = plugin
    cls.label = label
    instance = cls()

    return idaapi.register_action(idaapi.action_desc_t(
        cls.get_name(),
        instance.get_label(),
        instance
        ))

  @classmethod
  def unregister(cls):
    idaapi.unregister_action(cls.get_name())

  @classmethod
  def update(cls, ctx):
    if ctx.widget_type == idaapi.BWN_STRINGS:
      return ida_kernwin.AST_ENABLE_FOR_WIDGET
    else:
      return ida_kernwin.AST_DISABLE_FOR_WIDGET


class VTGrepWildcards(idaapi.action_handler_t):
  """Performs the right click operation: Search for wildcards."""

  @classmethod
  def get_name(cls):
    return cls.__name__

  @classmethod
  def get_label(cls):
    return cls.label

  @classmethod
  def register(cls, plugin, label):
    cls.plugin = plugin
    cls.label = label
    instance = cls()

    return idaapi.register_action(idaapi.action_desc_t(
        cls.get_name(),
        instance.get_label(),
        instance
        ))

  @classmethod
  def unregister(cls):
    idaapi.unregister_action(cls.get_name())

  @classmethod
  def activate(cls, ctx):
    cls.plugin.search_with_wildcards(False)
    return 1

  @classmethod
  def update(cls, ctx):
    if ctx.widget_type == idaapi.BWN_DISASM:
      return ida_kernwin.AST_ENABLE_FOR_WIDGET
    else:
      return ida_kernwin.AST_DISABLE_FOR_WIDGET


class VTGrepWildCardsStrict(VTGrepWildcards):
  """Performs the right click operation: Search for wildcards (strict)."""

  @classmethod
  def activate(cls, ctx):
    cls.plugin.search_with_wildcards(True)
    return 1


class VTGrepWildCardsFunction(VTGrepWildcards):
  """Performs the right click operation: Search for similar function."""

  @classmethod
  def activate(cls, ctx):
    cls.plugin.search_function_with_wildcards()
    return 1


class VTGrepBytes(idaapi.action_handler_t):
  """Performs the right click operation: Search for bytes."""

  @classmethod
  def get_name(cls):
    return cls.__name__

  @classmethod
  def get_label(cls):
    return cls.label

  @classmethod
  def register(cls, plugin, label):
    cls.plugin = plugin
    cls.label = label
    instance = cls()

    return idaapi.register_action(idaapi.action_desc_t(
        cls.get_name(),
        instance.get_label(),
        instance
        ))

  @classmethod
  def unregister(cls):
    idaapi.unregister_action(cls.get_name())

  @classmethod
  def activate(cls, ctx):
    cls.plugin.search_for_bytes()
    return 1

  @classmethod
  def update(cls, ctx):
    if ctx.widget_type == idaapi.BWN_DISASM:
      return ida_kernwin.AST_ENABLE_FOR_WIDGET
    else:
      return ida_kernwin.AST_DISABLE_FOR_WIDGET


class MenuVTPanel(idaapi.action_handler_t):

  @classmethod
  def activate(cls, ctx):
    global widget_panel

    if len(config.API_KEY) > 0:
      # Find the panel if it already exists
      panel = ida_kernwin.find_widget("VirusTotal")
      if panel:
        # If it exists, just bring it to the front
        ida_kernwin.activate_widget(panel, True)
      else:
        # If it doesn't exist, create a new instance and show it.
        widget_panel = VTPanel()
        widget_panel.Show("VirusTotal")
        idaapi.set_dock_pos('VirusTotal', '', idaapi.DP_RIGHT)
        file_path = idaapi.get_input_file_path()
        widget_panel.set_data(fhash=calculate_hash(file_path))
    else:
      if len(config.API_KEY) == 0:
        logging.error('[VT Plugin] VirusTotal\'s API_KEY not configured or invalid.')
        VTWidgets.show_warning('A VirusTotal API Key has not been configured,\nplease indicate your API KEY in the \"config.py\" file.')

  @classmethod
  def update(cls, ctx):
    return ida_kernwin.AST_ENABLE_ALWAYS


class Popups(idaapi.UI_Hooks):
  """Declares methods to be called on right click operations."""

  @staticmethod
  def finish_populating_widget_popup(form, popup):
    if idaapi.get_widget_type(form) == idaapi.BWN_DISASM:
      idaapi.attach_action_to_popup(
          form,
          popup,
          CodeInsightASM.get_name(),
          'VirusTotal/',
          )
      idaapi.attach_action_to_popup(
            form,
            popup,
            None,
            "VirusTotal/",
            idaapi.SETMENU_INS
          )
      idaapi.attach_action_to_popup(
          form,
          popup,
          VTGrepBytes.get_name(),
          'VirusTotal/'
          )
      idaapi.attach_action_to_popup(
          form,
          popup,
          VTGrepWildcards.get_name(),
          'VirusTotal/',
          )
      idaapi.attach_action_to_popup(
          form,
          popup,
          VTGrepWildCardsStrict.get_name(),
          'VirusTotal/',
          )
      idaapi.attach_action_to_popup(
          form,
          popup,
          VTGrepWildCardsFunction.get_name(),
          'VirusTotal/',
          )
    elif idaapi.get_widget_type(form) == idaapi.BWN_STRINGS:
      idaapi.attach_action_to_popup(
          form,
          popup,
          VTGrepStrings.get_name(),
          'VirusTotal/')
    elif idaapi.get_widget_type(form) == idaapi.BWN_PSEUDOCODE:
      idaapi.attach_action_to_popup(
          form,
          popup,
          CodeInsightDecompiled.get_name(),
          'VirusTotal/')


class WarningForm(ida_kernwin.Form):

  def __init__(self):
    self.invert = False
    ida_kernwin.Form.__init__(self, r"""STARTITEM 0
BUTTON YES Ok
BUTTON NO*  No
BUTTON Cancel Cancel
VirusTotal Plugin for IDA Pro

Welcome to the Beta Version of the VirusTotal IDA Pro Plugin !

This plugin can be configured to automatically upload you 
samples. By submitting your file to VirusTotal you are asking 
VirusTotal to share your submission with the security community 
and agree to our Terms of Service and Privacy Policy. 

For further information click on the following links:
- {cHtml1}
- {cHtml2}

Press "Ok" to agree, "No" to disable uploads or "Cancel"
to stop using this plugin.
 
""", {
    'cHtml1': ida_kernwin.Form.StringLabel(
        '<a href=\"https://docs.virustotal.com/docs/terms-of-service\">Terms of Service</a>',
        tp=ida_kernwin.Form.FT_HTML_LABEL
    ),
    'cHtml2': ida_kernwin.Form.StringLabel(
        '<a href=\"https://docs.virustotal.com/docs/privacy-policy\">Privacy Policy</a>',
        tp=ida_kernwin.Form.FT_HTML_LABEL
    )
})
   

class CheckSample(threading.Thread):
  auto_upload = None
  input_file = None
  file_hash = None

  def __init__(self, upload, path):
    self.auto_upload = upload
    self.input_file = path
    self.file_hash = calculate_hash(input_file=path)
    threading.Thread.__init__(self)

  def check_file_missing_in_VT(self):
    """Return True if the file is not available at VirusTotal."""

    if config.API_KEY:
      user_agent = 'IDA Pro VT Plugin checkhash - v'
      user_agent += VT_IDA_PLUGIN_VERSION
      headers = {
          'User-Agent': user_agent,
          'Accept': 'application/json',
          'x-apikey': config.API_KEY
      }

      url = 'https://www.virustotal.com/api/v3/files/%s' % self.file_hash

      logging.debug('[VT Plugin] Checking hash: %s', self.file_hash)
      try:
        response = requests.get(url, headers=headers)
      except requests.RequestException:
        logging.error('[VT Plugin] Unable to connect to VirusTotal.com')
        return False

      if response.status_code == 404:  # file not found in VirusTotal
        return True
      elif response.status_code == 200:
        logging.debug('[VT Plugin] File already available in VirusTotal.')
    elif self.auto_upload:
        logging.info('[VT Plugin] No API KEY is configured: unable to check file in VirusTotal.')
    return False

  def upload_file_to_VT(self):
    """Upload input file to VirusTotal."""

    if config.API_KEY:
      user_agent = 'IDA Pro VT Plugin upload - v' 
      user_agent += VT_IDA_PLUGIN_VERSION

      headers = {
          'User-Agent': user_agent,
          'x-apikey': config.API_KEY,
      }

      norm_path = os.path.normpath(self.input_file)
      file_path, file_name = os.path.split(norm_path)

      if os.path.isfile(self.input_file):
        logging.info('[VT Plugin] Uploading input file to VirusTotal.')
        url = 'https://www.virustotal.com/api/v3/files'
        files = {'file': (file_name, open(self.input_file, 'rb'))}

        try:
          response = requests.post(url, files=files, headers=headers)
        except requests.RequestException:
          logging.error('[VT Plugin] Unable to connect to VirusTotal.com')
          return

        if response.ok:
          logging.debug('[VT Plugin] Uploaded successfully.')
        else:
          logging.error('[VT Plugin] Upload failed.')
      else:
        logging.error('[VT Plugin] Uploading error: invalidad input file path.')
    else:
      logging.info('[VT Plugin] API Key not configured.')

  def run(self):
    if self.check_file_missing_in_VT() and self.auto_upload:
      self.upload_file_to_VT()


class VTpluginSetup(object):
  """Check and setup global parameters."""

  auto_upload = True
  vt_cfgfile = ''
  valid_setup = False
  file_path = ''
  file_name = ''
  file_hash = None
  vt_plugin_logger = None

  @staticmethod
  def show_warning():
    """Shows a popup window to ask for user consent in order to upload files."""

    warning_f = WarningForm()
    warning_f.Compile()
    change_config = warning_f.Execute()
    warning_f.Free()

    return change_config

  def read_config(self):
    """Read the user's configuration file."""

    logging.debug('[VT Plugin] Reading user config file: %s', self.vt_cfgfile)
    config_file = configparser.RawConfigParser()
    config_file.read(self.vt_cfgfile)

    try:
      if config_file.get('General', 'auto_upload') == 'True':
        self.auto_upload = True
      else:
        self.auto_upload = False
      return True
    except configparser.Error:
      logging.error('[VT Plugin] Error reading the user config file.')
      return False

  def write_config(self):
    """Write user's configuration file."""

    logging.debug('[VT Plugin] Writing user config file: %s', self.vt_cfgfile)

    try:
      parser = configparser.ConfigParser()
      config_file = open(self.vt_cfgfile, 'w')
      parser.add_section('General')
      parser.set('General', 'auto_upload', str(self.auto_upload))
      parser.write(config_file)
      config_file.close()
    except (OSError, configparser.Error):
      logging.error('[VT Plugin] Error while creating the user config file.')
      return False
    return True

  @staticmethod
  def __normalize(a, b):
    while len(a) > len(b):
      b = '0' + b
    while len(b) > len(a):
      a = '0' + a
    return a, b

  def __compare_versions(self, current, new):
    current_ver = current.split('.', 1)
    new_ver = new.split('.', 1)

    current_ver[0], new_ver[0] = self.__normalize(current_ver[0], new_ver[0])
    current_ver[1], new_ver[1] = self.__normalize(current_ver[1], new_ver[1])

    if (new_ver[0] > current_ver[0] or
        (new_ver[0] == current_ver[0] and new_ver[1] > current_ver[1])):
      return True
    return False

  def check_version(self):
    """Return True if there's an update available."""

    user_agent = 'IDA Pro VT Plugin checkversion - v' + VT_IDA_PLUGIN_VERSION
    headers = {
        'User-Agent': user_agent,
        'Accept': 'application/json'
    }
    url = 'https://raw.githubusercontent.com/VirusTotal/vt-ida-plugin/master/VERSION'

    try:
      response = requests.get(url, headers=headers)
    except requests.RequestException:
      logging.error('[VT Plugin] Unable to check for updates.')
      return False

    if response.status_code == 200:
      version = response.text.rstrip('\n')
      if self.__compare_versions(VT_IDA_PLUGIN_VERSION, version):
        logging.debug('[VT Plugin] Version %s is available !', version)
        return True
    return False

  def __init__(self, cfgfile):
    self.vt_cfgfile = cfgfile
    self.file_path = idaapi.get_input_file_path()
    self.file_name = idc.get_root_filename()
    self.file_hash = calculate_hash(self.file_path)

    logging.info(
        '\n** VT Plugin for IDA Pro v%s (c) Google, 2025',
        VT_IDA_PLUGIN_VERSION
    )
    logging.info('** VirusTotal integration plugin for Hex-Ray\'s IDA Pro')
    logging.info('\n** This plugin provides two main features:')
    logging.info('** 1. Code Similarity Search (VTGrep):')
    logging.info('**    - Right-click in the Disassembly or Strings view to search for.')
    logging.info('**    - Exact bytes, similar code (ignoring addresses/constants), and similar functions.')
    logging.info('**    - Selected strings from the Strings window.')
    logging.info('** 2. Code Insight Notebook:')
    logging.info('**    - Get AI-powered analysis for any function (disassembled or decompiled).')
    logging.info('**    - Manage analyses in a persistent, dockable panel (View -> Open subviews -> VirusTotal).')
    logging.info('**    - Automatically add analysis summaries as comments to your functions.')
    logging.info('**    - Import/Export notebooks to share your work.')
    logging.info('\n** To get started with Code Insight, add your VT API key to config.py\n')


class Error(Exception):
  pass


class IncompatibleIdaVersion(Error):
  pass


def get_procname(arch_info):
  try:
    return arch_info.procname
  except AttributeError:
    pass
  try:
    return arch_info.procName
  except AttributeError:
    pass
  # IDA has changed the API, complain loudly and raise an exception.
  logging.error('[VT Plugin] Could not get procname from arch_info.')
  raise IncompatibleIdaVersion('[VT Plugin] Could not get procname from arch_info.')


class VTplugin(idaapi.plugin_t):
  """VirusTotal plugin interface for IDA Pro."""

  SEARCH_CODE_SUPPORTED = ['80286r', '80286p', '80386r', '80386p', '80486r',
                           '80486p', '80586r', '80586p', '80686p', 'k62', 'p2',
                           'p3', 'athlon', 'p4', 'metapc', 'ARM']
  SEARCH_STRICT_SUPPORTED = ['80286r', '80286p', '80386r', '80386p', '80486r',
                             '80486p', '80586r', '80586p', '80686p', 'k62',
                             'p2', 'p3', 'athlon', 'p4', 'metapc']

  flags = idaapi.PLUGIN_UNL
  comment = 'VirusTotal Plugin for IDA Pro'
  help = 'VirusTotal integration plugin for Hex-Ray\'s IDA Pro'
  wanted_name = 'VirusTotal'
  wanted_hotkey = ''
  vtpanel = None
  vtsetup = None

  def _safe_register_action(self, action_cls, label):
    """Helper to safely register an action, logging any failures without crashing."""
    try:
      action_cls.register(self, label)
    except Exception:
      logging.exception('[VT Plugin] Failed to register action: %s', label)

  def init(self):
    """Set up menu hooks and implements search methods."""

    valid_config = False
    self.menu = None
    config_file = os.path.join(idaapi.get_user_idadir(), 'virustotal.conf')
    self.vtsetup = VTpluginSetup(config_file)

    if self.vtsetup.check_version():
      ida_kernwin.info('VirusTotal\'s IDA Pro Plugin\nNew version available!')
      logging.info('[VT Plugin] There\'s a new version of this plugin!')
    else:
      logging.debug('[VT Plugin] No update available.')

    if os.path.exists(config_file):
      valid_config = self.vtsetup.read_config()
    else:
      answer = self.vtsetup.show_warning()
      if answer == 1:     # OK
        self.vtsetup.auto_upload = True
        valid_config = self.vtsetup.write_config()
      elif answer == 0:   # NO
        self.vtsetup.auto_upload = False
        valid_config = self.vtsetup.write_config()
      elif answer == -1:  # Cancel
        valid_config = False

    if valid_config:
      file_sample = CheckSample(self.vtsetup.auto_upload, self.vtsetup.file_path)
      file_sample.start()

      self.menu = Popups()
      self.menu.hook()
      
      if idaapi.IDA_SDK_VERSION >= 900:
        proc_name = ida_ida.inf_get_procname()
      else:
        arch_info = idaapi.get_inf_structure()
        proc_name = get_procname(arch_info)

      logging.debug('[VT Plugin] Processor detected by IDA: %s', proc_name)

      if len(config.API_KEY) > 0:
        self._safe_register_action(CodeInsightASM, 'Ask Code Insight')
        self._safe_register_action(CodeInsightDecompiled, 'Ask Code Insight')

        ### Register VirusTotal menu entry
        vticon_data = None
        current_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '.'))
        file_icon = os.path.join(current_path,
                                 'ui',
                                 'resources',
                                 'vt_icon.png')
        try:
          vticon_data = open(file_icon, 'rb').read()
        except OSError:
          logging.error('[VT Plugin] Failed to load icon file: %s', file_icon)

        if vticon_data:
          try:
            vtmenu = idaapi.load_custom_icon(data=vticon_data)
            action_desc = idaapi.action_desc_t(
                'my:vtpanel',
                'VirusTotal',
                MenuVTPanel(),
                '',
                'Show VirusTotal panel with information about the current file',
                vtmenu)

            idaapi.register_action(action_desc)
            idaapi.attach_action_to_menu(
                'View/Open subviews/',
                'my:vtpanel',
                idaapi.SETMENU_APP)
          except Exception:
            logging.exception('[VT Plugin] Failed to register VirusTotal menu icon/action.')

      if (proc_name in self.SEARCH_STRICT_SUPPORTED) | (proc_name in self.SEARCH_CODE_SUPPORTED):
        self._safe_register_action(VTGrepWildcards, 'Search for similar code')
        self._safe_register_action(VTGrepWildCardsFunction, 'Search for similar functions')
        
        if proc_name in self.SEARCH_STRICT_SUPPORTED:
          self._safe_register_action(VTGrepWildCardsStrict, 'Search for similar code (strict)')

      else:
        logging.info(' - Processor detected: %s', proc_name)
        logging.info(' - Searching for similar code is not available.')
      
      self._safe_register_action(VTGrepBytes, 'Search for bytes')
      self._safe_register_action(VTGrepStrings, 'Search for string')

    else:
      logging.info('[VT Plugin] Plugin disabled, restart IDA to proceed. ')
      ida_kernwin.warning('Plugin disabled, restart IDA to proceed.')
    return idaapi.PLUGIN_KEEP

  @staticmethod
  def search_string(selected_string):
    search_vt = vtgrep.VTGrepSearch(string=selected_string)
    search_vt.search(False)

  @staticmethod
  def search_with_wildcards(strict):
    search_vt = vtgrep.VTGrepSearch(
        addr_start=idc.read_selection_start(),
        addr_end=idc.read_selection_end()
        )
    search_vt.search(True, strict)

  @staticmethod
  def search_function_with_wildcards():
    addr_current = idc.get_screen_ea()
    addr_func = idaapi.get_func(addr_current)

    if not addr_func:
      logging.error('[VT Plugin] Current address doesn\'t belong to a function')
      ida_kernwin.warning('Point the cursor in an area beneath a function.')
      return

    search_vt = vtgrep.VTGrepSearch(
        addr_start=addr_func.start_ea,
        addr_end=addr_func.end_ea
        )
    search_vt.search(True, False)

  def query_codeinsight(self, *args, **kwargs):
    code_type = kwargs.get('code_type', None)
    current_address = idc.get_screen_ea()
    addr_func = idaapi.get_func(current_address)
  
    if not widget_panel.isVisible():
      widget_panel.Show("VirusTotal")
      idaapi.set_dock_pos('VirusTotal', '', idaapi.DP_RIGHT)

    try:
      faddr = addr_func.start_ea
    except:
      faddr = None

    if faddr:
      widget_panel.set_data(faddr,
                              fhash = self.vtsetup.file_hash,
                              ctype = code_type)
    else:
      logging.info('[VT Plugin] Current address doesn\'t belong to a function')


  @staticmethod
  def search_for_bytes():
    search_vt = vtgrep.VTGrepSearch(
        addr_start=idc.read_selection_start(),
        addr_end=idc.read_selection_end()
        )
    search_vt.search(False)

  @staticmethod
  def run(arg):
    pass

  def term(self):
    if self.menu:
      self.menu.unhook()
```

`plugin/virustotal/vt_ida/ui/__init__.py`:

```py
# Copyright 2025 Google Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Initializes the UI package by selecting the correct Qt-based panel."""

import idaapi

if idaapi.IDA_SDK_VERSION >= 920:
  from .qt6panel import Qt6Ui_panelUI as Ui_panelUI
else:
  from .qt5panel import Qt5Ui_panelUI as Ui_panelUI
```

`plugin/virustotal/vt_ida/ui/qt5logo.py`:

```py
# -*- coding: utf-8 -*-
# Copyright 2025 Google LLC. All Rights Reserved.

# Resource object code
#
# Created by: The Resource Compiler for PyQt5 (Qt v5.14.1)
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore

qt_resource_data = b"\
\x00\x00\x05\xd9\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x5a\x00\x00\x00\x4f\x08\x06\x00\x00\x00\x6b\xb3\xd2\x2a\
\x00\x00\x00\x01\x73\x52\x47\x42\x00\xae\xce\x1c\xe9\x00\x00\x00\
\x84\x65\x58\x49\x66\x4d\x4d\x00\x2a\x00\x00\x00\x08\x00\x05\x01\
\x12\x00\x03\x00\x00\x00\x01\x00\x01\x00\x00\x01\x1a\x00\x05\x00\
\x00\x00\x01\x00\x00\x00\x4a\x01\x1b\x00\x05\x00\x00\x00\x01\x00\
\x00\x00\x52\x01\x28\x00\x03\x00\x00\x00\x01\x00\x02\x00\x00\x87\
\x69\x00\x04\x00\x00\x00\x01\x00\x00\x00\x5a\x00\x00\x00\x00\x00\
\x00\x00\x48\x00\x00\x00\x01\x00\x00\x00\x48\x00\x00\x00\x01\x00\
\x03\xa0\x01\x00\x03\x00\x00\x00\x01\x00\x01\x00\x00\xa0\x02\x00\
\x04\x00\x00\x00\x01\x00\x00\x00\x5a\xa0\x03\x00\x04\x00\x00\x00\
\x01\x00\x00\x00\x4f\x00\x00\x00\x00\x12\x46\xfe\x46\x00\x00\x00\
\x09\x70\x48\x59\x73\x00\x00\x0b\x13\x00\x00\x0b\x13\x01\x00\x9a\
\x9c\x18\x00\x00\x01\x59\x69\x54\x58\x74\x58\x4d\x4c\x3a\x63\x6f\
\x6d\x2e\x61\x64\x6f\x62\x65\x2e\x78\x6d\x70\x00\x00\x00\x00\x00\
\x3c\x78\x3a\x78\x6d\x70\x6d\x65\x74\x61\x20\x78\x6d\x6c\x6e\x73\
\x3a\x78\x3d\x22\x61\x64\x6f\x62\x65\x3a\x6e\x73\x3a\x6d\x65\x74\
\x61\x2f\x22\x20\x78\x3a\x78\x6d\x70\x74\x6b\x3d\x22\x58\x4d\x50\
\x20\x43\x6f\x72\x65\x20\x35\x2e\x34\x2e\x30\x22\x3e\x0a\x20\x20\
\x20\x3c\x72\x64\x66\x3a\x52\x44\x46\x20\x78\x6d\x6c\x6e\x73\x3a\
\x72\x64\x66\x3d\x22\x68\x74\x74\x70\x3a\x2f\x2f\x77\x77\x77\x2e\
\x77\x33\x2e\x6f\x72\x67\x2f\x31\x39\x39\x39\x2f\x30\x32\x2f\x32\
\x32\x2d\x72\x64\x66\x2d\x73\x79\x6e\x74\x61\x78\x2d\x6e\x73\x23\
\x22\x3e\x0a\x20\x20\x20\x20\x20\x20\x3c\x72\x64\x66\x3a\x44\x65\
\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x20\x72\x64\x66\x3a\x61\x62\
\x6f\x75\x74\x3d\x22\x22\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x78\x6d\x6c\x6e\x73\x3a\x74\x69\x66\x66\x3d\x22\x68\
\x74\x74\x70\x3a\x2f\x2f\x6e\x73\x2e\x61\x64\x6f\x62\x65\x2e\x63\
\x6f\x6d\x2f\x74\x69\x66\x66\x2f\x31\x2e\x30\x2f\x22\x3e\x0a\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x3c\x74\x69\x66\x66\x3a\x4f\x72\
\x69\x65\x6e\x74\x61\x74\x69\x6f\x6e\x3e\x31\x3c\x2f\x74\x69\x66\
\x66\x3a\x4f\x72\x69\x65\x6e\x74\x61\x74\x69\x6f\x6e\x3e\x0a\x20\
\x20\x20\x20\x20\x20\x3c\x2f\x72\x64\x66\x3a\x44\x65\x73\x63\x72\
\x69\x70\x74\x69\x6f\x6e\x3e\x0a\x20\x20\x20\x3c\x2f\x72\x64\x66\
\x3a\x52\x44\x46\x3e\x0a\x3c\x2f\x78\x3a\x78\x6d\x70\x6d\x65\x74\
\x61\x3e\x0a\x4c\xc2\x27\x59\x00\x00\x03\x89\x49\x44\x41\x54\x78\
\x01\xed\xdd\x4d\x72\x9b\x30\x14\x07\xf0\x27\xc6\x33\xcd\x2e\xbd\
\x41\xdd\x13\xd4\xcb\x4c\x37\xa1\x07\xe8\x94\x1b\xb4\xbd\x41\x6e\
\xd0\xf4\x06\x39\x42\x7a\x03\xea\x5e\xc0\xdd\xa4\x5e\x26\x37\xc8\
\x11\xe2\x5d\xa6\x0b\xe8\x7b\x38\xb2\x01\x4b\x06\x61\xbe\x8a\xfe\
\x9a\xf1\x00\x42\x12\xe1\xc7\xb3\x2c\x9b\x8f\xa8\x8b\x28\x0d\x83\
\x84\x42\x42\x6a\x55\x20\x49\xe9\x71\xfd\x4b\xdd\xea\x46\x67\x67\
\x44\xf7\xcf\x44\x37\x8a\xe8\x9d\xce\xc4\xf4\x64\x81\x1f\x4a\x65\
\xc1\x7b\xab\x5b\x0a\x56\xb1\x7a\x3a\x0b\x28\x4c\x89\x1e\x74\x26\
\xa6\x8d\x05\x7e\xa6\x01\xbd\x35\xd5\x0e\x24\x13\xd8\x26\x9a\xfa\
\x79\x12\xa4\x0c\xfc\xe1\xcf\x52\x45\x5c\x6b\xce\xaf\xcf\xe5\xda\
\x19\xb4\x64\x02\xbb\x4c\x53\x6b\x79\x93\xa6\xf4\x75\xbd\x54\x8b\
\x75\xac\x56\x52\x43\x25\x74\x2d\xd3\x72\xda\x41\xcb\x0a\x60\x97\
\x79\xec\xcb\xfc\x99\xf6\xfd\x55\x40\xf3\xfc\x07\xde\xc5\xc7\xf4\
\x0b\xd7\xb8\x34\xd5\x2a\x40\x4b\x01\x60\x9b\x98\x0a\x79\x59\x3f\
\x7c\xb7\x54\xd7\x62\xa5\xd7\x84\x51\xfa\x5a\x05\xe6\x68\x96\x32\
\x07\xd0\x92\x09\x6c\x51\x28\xa6\x7c\x3f\xcc\xdd\xc4\x63\x71\x2d\
\xd1\xdf\x84\xae\x28\xa5\x37\xe5\x7c\xbd\x6c\x84\x96\x95\xc0\xd6\
\x44\x74\xd0\x0f\xef\xd6\xbc\xcc\xf0\x77\x91\x39\x1f\x88\x6f\xe5\
\xfc\xfc\xf2\x2c\xbf\x50\x9e\x17\x6c\x7e\x4b\x84\xcf\x09\xad\x1c\
\xc6\xd9\xbf\xb9\xef\x8a\xf2\x6f\xab\x72\xbb\x53\x5b\xe6\x0f\xc0\
\x9b\xaa\x7d\xb2\x46\xb4\xae\xd8\x20\xb2\x2f\xe5\xc0\x48\x9f\xa5\
\xdb\x98\xf2\x54\xbe\x59\xf3\xfe\x7d\xaa\xda\xc7\x4a\x68\x69\xc0\
\x15\x5b\xa2\xdf\x1b\xec\x1a\xd1\x2c\x86\xb5\xa0\x81\x2d\x02\x87\
\x49\x86\x73\x75\xbb\xd4\xda\xd0\xb2\x19\x44\xf6\x1e\x3b\x1b\xce\
\xa9\xea\xbe\x59\xd7\x70\x82\x06\xb6\x66\x7b\x19\xce\x11\x9d\xef\
\x73\x8e\xcf\x39\x43\x03\x7b\x0b\xca\xc3\xb9\xf0\x38\x6d\x71\x6d\
\x23\x68\x69\xa2\x69\x37\xf2\x3e\x4a\x17\xc5\x3f\xc1\x8f\xa5\xc6\
\xd0\x4d\xb1\x53\x1e\xfa\xf9\x88\x7d\x12\x74\x13\x6c\xae\x73\xee\
\x23\xf6\xc9\xd0\xc0\x16\x81\xea\xd4\x0a\xb4\x6c\xc6\xb5\xcf\xe6\
\x2a\x5e\x45\x76\x6b\xd0\xc0\x16\x01\x7b\x6a\x15\x5a\x36\x83\xc8\
\x36\x63\xb7\x0e\x0d\xec\x1e\xa1\x81\x7d\x88\xdd\x49\x44\xeb\xcd\
\xa0\x1b\xd1\x12\x0e\xbf\xde\xed\xab\xb8\xcd\x01\x7b\xeb\xd5\x69\
\x44\xeb\x43\x02\xec\x1e\x22\x1a\xd8\x3d\x46\x34\xb0\x7b\x8c\x68\
\xdf\xb1\x7b\xe9\xa3\x35\xb2\x9e\xfa\xd8\x67\x0f\x02\x2d\xe0\xbe\
\x61\x0f\x06\xed\x1b\xf6\xa0\xd0\x3e\x61\x0f\x0e\xed\x0b\xf6\x28\
\xa0\x7d\xc0\x1e\x0d\xf4\xd4\xb1\x47\x05\x3d\x65\xec\xd1\x41\x6b\
\x6c\xbe\x58\x2d\x92\xf9\x9a\xe9\x9c\x6f\x71\x88\x6b\x96\x1d\xa4\
\xd8\x28\xa1\xb3\x2b\x51\x13\x27\xb8\x0d\xdf\x6e\xe6\x72\x60\x7a\
\xc7\x1e\x1d\xb4\x20\x3b\x5e\x8f\xbd\xe1\x5b\x1a\xc2\xbb\x58\xdd\
\xf7\xae\xe7\xb0\xc1\x51\x41\x4f\x15\x59\x8e\xc7\x68\xa0\xa7\x8c\
\x3c\x1a\xe8\xa9\x23\x8f\x02\xda\x07\xe4\xc1\xa1\x7d\x41\x1e\x14\
\xda\x27\xe4\xc1\xa0\x7d\x43\x1e\x04\xda\x47\xe4\xde\xa1\x7d\x45\
\xee\x15\xda\x67\xe4\xde\xa0\x7d\x47\xee\x05\x1a\xc8\xc2\xdc\xf1\
\x57\x70\x20\x6f\x91\x3b\x85\x06\xf2\x1e\xb9\x33\x68\x20\x17\x91\
\x3b\x81\x06\xf2\x21\x72\xeb\xd0\x40\x36\x23\xb7\x0a\x0d\x64\x3b\
\x72\x6b\xd0\x40\x3e\x8e\xdc\x0a\x34\x90\xab\x91\x4f\x86\x76\x45\
\xe6\x47\x2f\x3c\xfc\x0f\x27\x52\xeb\xd1\x1d\x2d\x25\x27\x8c\xaf\
\xf2\x25\x8e\x3e\x25\x2c\x5f\xb0\x3c\xdf\x04\x59\x1e\x36\x2b\x97\
\xeb\x96\xdb\x9a\xd8\xb2\xf1\xac\x7c\xa3\x93\xb3\x40\xb6\x86\x86\
\x11\x59\x4a\x3b\x43\x03\xd9\x1d\xd9\x19\x1a\xc8\xcd\x90\x9d\xa0\
\x81\xdc\x1c\xb9\x36\x34\x90\x4f\x43\xae\x05\x0d\x64\x2b\xf2\x93\
\xcb\x50\x95\x1f\x44\x68\x4f\xae\xc8\xf6\x96\x26\xb7\xc6\x3a\xba\
\xb0\xed\xa9\x15\x1a\xc8\x36\x32\x72\x46\x96\x96\x8c\xd0\x40\x6e\
\x17\xd9\x08\x0d\xe4\xf6\x91\x0f\xa0\x81\xdc\x0d\x72\x01\x1a\xc8\
\xdd\x21\xef\xa0\x81\xdc\x2d\x72\x06\x0d\xe4\xee\x91\x65\x0b\x33\
\xfe\x87\x64\x0b\xfe\x65\x29\xe6\x79\x79\x21\x69\x81\x80\xe2\x36\
\x6f\x40\xfa\x07\x2a\xfc\xd4\x85\x96\x46\x39\x88\x00\x00\x00\x00\
\x49\x45\x4e\x44\xae\x42\x60\x82\
"

qt_resource_name = b"\
\x00\x06\
\x07\xdb\x35\xdf\
\x00\x76\
\x00\x74\x00\x6c\x00\x6f\x00\x67\x00\x6f\
\x00\x0b\
\x05\x5d\x1b\x27\
\x00\x76\
\x00\x74\x00\x5f\x00\x6c\x00\x6f\x00\x67\x00\x6f\x00\x2e\x00\x70\x00\x6e\x00\x67\
"

qt_resource_struct_v1 = b"\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x01\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x02\
\x00\x00\x00\x12\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\
"

qt_resource_struct_v2 = b"\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x01\
\x00\x00\x00\x00\x00\x00\x00\x00\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x02\
\x00\x00\x00\x00\x00\x00\x00\x00\
\x00\x00\x00\x12\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\
\x00\x00\x01\x77\x25\xce\x6b\xc8\
"

qt_version = [int(v) for v in QtCore.qVersion().split('.')]
if qt_version < [5, 8, 0]:
    rcc_version = 1
    qt_resource_struct = qt_resource_struct_v1
else:
    rcc_version = 2
    qt_resource_struct = qt_resource_struct_v2

def qInitResources():
    QtCore.qRegisterResourceData(rcc_version, qt_resource_struct, qt_resource_name, qt_resource_data)

def qCleanupResources():
    QtCore.qUnregisterResourceData(rcc_version, qt_resource_struct, qt_resource_name, qt_resource_data)

qInitResources()

```

`plugin/virustotal/vt_ida/ui/qt5panel.py`:

```py
# -*- coding: utf-8 -*-
# Copyright 2025 Google LLC. All Rights Reserved.

# Form implementation generated from reading ui file 'vtpanel.ui'
#
# Created by: PyQt5 UI code generator 5.15.11
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

__author__ = 'gerardofn@virustotal.com'

from PyQt5 import QtCore, QtGui, QtWidgets
from . import qt5logo


class Qt5Ui_panelUI(object):
    def setupUi(self, panelUI):
        panelUI.setObjectName("panelUI")
        panelUI.resize(600, 1051)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.MinimumExpanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(panelUI.sizePolicy().hasHeightForWidth())
        panelUI.setSizePolicy(sizePolicy)
        panelUI.setMinimumSize(QtCore.QSize(400, 0))
        panelUI.setMaximumSize(QtCore.QSize(16777215, 16777215))
        panelUI.setAutoFillBackground(False)
        panelUI.setLocale(QtCore.QLocale(QtCore.QLocale.English, QtCore.QLocale.UnitedStates))
        self.verticalLayout_11 = QtWidgets.QVBoxLayout(panelUI)
        self.verticalLayout_11.setObjectName("verticalLayout_11")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.tabWidget = QtWidgets.QTabWidget(panelUI)
        self.tabWidget.setEnabled(True)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tabWidget.sizePolicy().hasHeightForWidth())
        self.tabWidget.setSizePolicy(sizePolicy)
        self.tabWidget.setMinimumSize(QtCore.QSize(0, 0))
        font = QtGui.QFont()
        font.setKerning(True)
        self.tabWidget.setFont(font)
        self.tabWidget.setAutoFillBackground(False)
        self.tabWidget.setStyleSheet("QTabBar::tab { \n"
"border: 2px;\n"
"height: 20px;\n"
"width: 100%;\n"
"color: white;\n"
"background-color: rgb(248, 248, 248);\n"
"} \n"
"\n"
"QTabWidget::pane  { \n"
"border-left: 1px solid rgb(35, 61, 255);\n"
"border-right: 1px solid rgb(35, 61, 255);\n"
"border-bottom: 1px solid rgb(35, 61, 255);\n"
"border-top: 1px solid rgb(35, 61, 255);\n"
"}\n"
"\n"
"QTabBar::tab:selected { \n"
"color: white;\n"
"min-width: 10em;\n"
"background-color: rgb(42, 45, 255);\n"
"border-left: 1px solid rgb(42, 45, 255);\n"
"border-right: 1px solid rgb(42, 45, 255);\n"
"border-top: 1px solid rgb(42, 45, 255);\n"
"border-bottom: 1px solid rgb(42, 45, 255);\n"
"}\n"
"\n"
"QTabBar::tab:!selected {\n"
"color: black;\n"
"min-width: 10em;\n"
"background-color: rgb(248, 248, 248);\n"
"border-left: 1px solid gray;\n"
"border-right: 1px solid gray;\n"
"border-top: 1px solid gray;\n"
"}\n"
"\n"
"QTabBarWidget::tab-bar {\n"
"color: black;\n"
"background-color: rgb(248, 248, 248);\n"
"border-bottom: 1px solid  rgb(35, 61, 255);\n"
"}")
        self.tabWidget.setTabPosition(QtWidgets.QTabWidget.North)
        self.tabWidget.setTabShape(QtWidgets.QTabWidget.Rounded)
        self.tabWidget.setElideMode(QtCore.Qt.ElideLeft)
        self.tabWidget.setUsesScrollButtons(False)
        self.tabWidget.setDocumentMode(False)
        self.tabWidget.setTabsClosable(False)
        self.tabWidget.setMovable(False)
        self.tabWidget.setTabBarAutoHide(False)
        self.tabWidget.setObjectName("tabWidget")
        self.tab_codeinsight = QtWidgets.QWidget()
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.MinimumExpanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tab_codeinsight.sizePolicy().hasHeightForWidth())
        self.tab_codeinsight.setSizePolicy(sizePolicy)
        self.tab_codeinsight.setObjectName("tab_codeinsight")
        self.verticalLayout_20 = QtWidgets.QVBoxLayout(self.tab_codeinsight)
        self.verticalLayout_20.setObjectName("verticalLayout_20")
        self.info = QtWidgets.QGroupBox(self.tab_codeinsight)
        self.info.setAutoFillBackground(False)
        self.info.setTitle("")
        self.info.setFlat(True)
        self.info.setObjectName("info")
        self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.info)
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        self.gridLayout = QtWidgets.QGridLayout()
        self.gridLayout.setSizeConstraint(QtWidgets.QLayout.SetMaximumSize)
        self.gridLayout.setObjectName("gridLayout")
        self.cb_faddress = QtWidgets.QComboBox(self.info)
        self.cb_faddress.setObjectName("cb_faddress")
        self.gridLayout.addWidget(self.cb_faddress, 0, 2, 1, 1)
        self.le_codetype = QtWidgets.QLineEdit(self.info)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.le_codetype.sizePolicy().hasHeightForWidth())
        self.le_codetype.setSizePolicy(sizePolicy)
        self.le_codetype.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.le_codetype.setText("")
        self.le_codetype.setReadOnly(True)
        self.le_codetype.setPlaceholderText("")
        self.le_codetype.setObjectName("le_codetype")
        self.gridLayout.addWidget(self.le_codetype, 5, 2, 1, 1)
        self.label_2 = QtWidgets.QLabel(self.info)
        self.label_2.setObjectName("label_2")
        self.gridLayout.addWidget(self.label_2, 5, 0, 1, 1)
        self.label_8 = QtWidgets.QLabel(self.info)
        self.label_8.setObjectName("label_8")
        self.gridLayout.addWidget(self.label_8, 2, 0, 1, 1)
        self.label = QtWidgets.QLabel(self.info)
        self.label.setObjectName("label")
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        self.le_fname = QtWidgets.QLineEdit(self.info)
        self.le_fname.setObjectName("le_fname")
        self.le_fname.setReadOnly(True)
        self.gridLayout.addWidget(self.le_fname, 2, 2, 1, 1)
        self.label_4 = QtWidgets.QLabel(self.info)
        self.label_4.setObjectName("label_4")
        self.gridLayout.addWidget(self.label_4, 1, 0, 1, 1)
        self.le_faddress = QtWidgets.QLineEdit(self.info)
        self.le_faddress.setObjectName("le_faddress")
        self.le_faddress.setReadOnly(True)
        self.gridLayout.addWidget(self.le_faddress, 1, 2, 1, 1)
        self.horizontalLayout_10.addLayout(self.gridLayout)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_10.addItem(spacerItem)
        self.verticalLayout_16 = QtWidgets.QVBoxLayout()
        self.verticalLayout_16.setSizeConstraint(QtWidgets.QLayout.SetFixedSize)
        self.verticalLayout_16.setObjectName("verticalLayout_16")
        self.label_15 = QtWidgets.QLabel(self.info)
        self.label_15.setAlignment(QtCore.Qt.AlignCenter)
        self.label_15.setObjectName("label_15")
        self.verticalLayout_16.addWidget(self.label_15)
        self.horizontalLayout_10.addLayout(self.verticalLayout_16)
        self.verticalLayout_7.addLayout(self.horizontalLayout_10)
        self.verticalLayout_20.addWidget(self.info)
        self.summary = QtWidgets.QGroupBox(self.tab_codeinsight)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.summary.sizePolicy().hasHeightForWidth())
        self.summary.setSizePolicy(sizePolicy)
        self.summary.setMinimumSize(QtCore.QSize(0, 80))
        font = QtGui.QFont()
        font.setBold(True)
        self.summary.setFont(font)
        self.summary.setFlat(True)
        self.summary.setObjectName("summary")
        self.verticalLayout_15 = QtWidgets.QVBoxLayout(self.summary)
        self.verticalLayout_15.setObjectName("verticalLayout_15")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.te_ci_summary = QtWidgets.QTextEdit(self.summary)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.te_ci_summary.sizePolicy().hasHeightForWidth())
        self.te_ci_summary.setSizePolicy(sizePolicy)
        self.te_ci_summary.setMinimumSize(QtCore.QSize(0, 80))
        self.te_ci_summary.setAutoFormatting(QtWidgets.QTextEdit.AutoAll)
        self.te_ci_summary.setObjectName("te_ci_summary")
        self.verticalLayout_2.addWidget(self.te_ci_summary)
        self.verticalLayout_15.addLayout(self.verticalLayout_2)
        self.verticalLayout_20.addWidget(self.summary)
        self.description = QtWidgets.QGroupBox(self.tab_codeinsight)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.description.sizePolicy().hasHeightForWidth())
        self.description.setSizePolicy(sizePolicy)
        self.description.setMinimumSize(QtCore.QSize(40, 12))
        font = QtGui.QFont()
        font.setBold(True)
        self.description.setFont(font)
        self.description.setFlat(True)
        self.description.setObjectName("description")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.description)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.te_ci_description = QtWidgets.QTextEdit(self.description)
        self.te_ci_description.setObjectName("te_ci_description")
        self.verticalLayout_3.addWidget(self.te_ci_description)
        self.verticalLayout_20.addWidget(self.description)
        self.evaluation_widgets = QtWidgets.QHBoxLayout()
        self.evaluation_widgets.setObjectName("evaluation_widgets")
        spacerItem1 = QtWidgets.QSpacerItem(363, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.evaluation_widgets.addItem(spacerItem1)
        self.label_3 = QtWidgets.QLabel(self.tab_codeinsight)
        self.label_3.setObjectName("label_3")
        self.evaluation_widgets.addWidget(self.label_3)
        self.pb_accept = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_accept.setObjectName("pb_accept")
        self.evaluation_widgets.addWidget(self.pb_accept)
        self.pb_discard = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_discard.setObjectName("pb_discard")
        self.evaluation_widgets.addWidget(self.pb_discard)
        self.pb_refresh = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_refresh.setObjectName("pb_refresh")
        self.evaluation_widgets.addWidget(self.pb_refresh)
        self.verticalLayout_20.addLayout(self.evaluation_widgets)
        self.line = QtWidgets.QFrame(self.tab_codeinsight)
        font = QtGui.QFont()
        font.setWeight(QtGui.QFont.Weight.Normal)
        self.line.setFont(font)
        self.line.setStyleSheet("color: black;\n"
" ")
        self.line.setFrameShadow(QtWidgets.QFrame.Raised)
        self.line.setLineWidth(2)
        self.line.setFrameShape(QtWidgets.QFrame.HLine)
        self.line.setObjectName("line")
        self.verticalLayout_20.addWidget(self.line)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem2)
        self.pb_askCI = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_askCI.setObjectName("pb_askCI")
        self.horizontalLayout_4.addWidget(self.pb_askCI)
        self.pb_go = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_go.setObjectName("pb_go")
        self.horizontalLayout_4.addWidget(self.pb_go)
        self.pb_autocomment = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_autocomment.setObjectName("pb_autocomment")
        self.horizontalLayout_4.addWidget(self.pb_autocomment)
        self.pb_load = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_load.setObjectName("pb_load")
        self.horizontalLayout_4.addWidget(self.pb_load)
        self.pb_export = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_export.setObjectName("pb_export")
        self.horizontalLayout_4.addWidget(self.pb_export)
        self.verticalLayout_20.addLayout(self.horizontalLayout_4)
        self.tabWidget.addTab(self.tab_codeinsight, "")
        self.verticalLayout.addWidget(self.tabWidget)
        self.verticalLayout_11.addLayout(self.verticalLayout)

        self.retranslateUi(panelUI)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(panelUI)

    def retranslateUi(self, panelUI):
        _translate = QtCore.QCoreApplication.translate
        panelUI.setWindowTitle(_translate("panelUI", "VirusTotal"))
        self.info.setAccessibleName(_translate("panelUI", "General"))
        self.label_2.setText(_translate("panelUI", "Code type:"))
        self.label_8.setText(_translate("panelUI", "Function name"))
        self.label.setText(_translate("panelUI", "Analyzed functions"))
        self.label_4.setText(_translate("panelUI", "Function address"))
        self.label_15.setText(_translate("panelUI", "<html><head/><body><p><img src=\":/vtlogo/vt_logo.png\"/></p></body></html>"))
        self.summary.setTitle(_translate("panelUI", "Summary"))
        self.description.setTitle(_translate("panelUI", "Description"))
        self.label_3.setText(_translate("panelUI", "Evaluate analysis:"))
        self.pb_accept.setText(_translate("panelUI", "Accept"))
        self.pb_discard.setText(_translate("panelUI", "Discard"))
        self.pb_refresh.setText(_translate("panelUI", "Refresh"))
        self.pb_askCI.setText(_translate("panelUI", "Ask CI"))
        self.pb_go.setText(_translate("panelUI", "Go"))
        self.pb_autocomment.setText(_translate("panelUI", "Autocomment"))
        self.pb_load.setText(_translate("panelUI", "Load"))
        self.pb_export.setText(_translate("panelUI", "Export"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_codeinsight), _translate("panelUI", "Code Insight Notebook"))

```

`plugin/virustotal/vt_ida/ui/qt6logo.py`:

```py
# -*- coding: utf-8 -*-
# Copyright 2025 Google LLC. All Rights Reserved.

# Resource object code
#
# Created by: The Resource Compiler for PySide6 (Qt v6.x)
#
# WARNING! All changes made in this file will be lost!

from PySide6 import QtCore

qt_resource_data = b"\
\x00\x00\x05\xd9\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x5a\x00\x00\x00\x4f\x08\x06\x00\x00\x00\x6b\xb3\xd2\x2a\
\x00\x00\x00\x01\x73\x52\x47\x42\x00\xae\xce\x1c\xe9\x00\x00\x00\
\x84\x65\x58\x49\x66\x4d\x4d\x00\x2a\x00\x00\x00\x08\x00\x05\x01\
\x12\x00\x03\x00\x00\x00\x01\x00\x01\x00\x00\x01\x1a\x00\x05\x00\
\x00\x00\x01\x00\x00\x00\x4a\x01\x1b\x00\x05\x00\x00\x00\x01\x00\
\x00\x00\x52\x01\x28\x00\x03\x00\x00\x00\x01\x00\x02\x00\x00\x87\
\x69\x00\x04\x00\x00\x00\x01\x00\x00\x00\x5a\x00\x00\x00\x00\x00\
\x00\x00\x48\x00\x00\x00\x01\x00\x00\x00\x48\x00\x00\x00\x01\x00\
\x03\xa0\x01\x00\x03\x00\x00\x00\x01\x00\x01\x00\x00\xa0\x02\x00\
\x04\x00\x00\x00\x01\x00\x00\x00\x5a\xa0\x03\x00\x04\x00\x00\x00\
\x01\x00\x00\x00\x4f\x00\x00\x00\x00\x12\x46\xfe\x46\x00\x00\x00\
\x09\x70\x48\x59\x73\x00\x00\x0b\x13\x00\x00\x0b\x13\x01\x00\x9a\
\x9c\x18\x00\x00\x01\x59\x69\x54\x58\x74\x58\x4d\x4c\x3a\x63\x6f\
\x6d\x2e\x61\x64\x6f\x62\x65\x2e\x78\x6d\x70\x00\x00\x00\x00\x00\
\x3c\x78\x3a\x78\x6d\x70\x6d\x65\x74\x61\x20\x78\x6d\x6c\x6e\x73\
\x3a\x78\x3d\x22\x61\x64\x6f\x62\x65\x3a\x6e\x73\x3a\x6d\x65\x74\
\x61\x2f\x22\x20\x78\x3a\x78\x6d\x70\x74\x6b\x3d\x22\x58\x4d\x50\
\x20\x43\x6f\x72\x65\x20\x35\x2e\x34\x2e\x30\x22\x3e\x0a\x20\x20\
\x20\x3c\x72\x64\x66\x3a\x52\x44\x46\x20\x78\x6d\x6c\x6e\x73\x3a\
\x72\x64\x66\x3d\x22\x68\x74\x74\x70\x3a\x2f\x2f\x77\x77\x77\x2e\
\x77\x33\x2e\x6f\x72\x67\x2f\x31\x39\x39\x39\x2f\x30\x32\x2f\x32\
\x32\x2d\x72\x64\x66\x2d\x73\x79\x6e\x74\x61\x78\x2d\x6e\x73\x23\
\x22\x3e\x0a\x20\x20\x20\x20\x20\x20\x3c\x72\x64\x66\x3a\x44\x65\
\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x20\x72\x64\x66\x3a\x61\x62\
\x6f\x75\x74\x3d\x22\x22\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x78\x6d\x6c\x6e\x73\x3a\x74\x69\x66\x66\x3d\x22\x68\
\x74\x74\x70\x3a\x2f\x2f\x6e\x73\x2e\x61\x64\x6f\x62\x65\x2e\x63\
\x6f\x6d\x2f\x74\x69\x66\x66\x2f\x31\x2e\x30\x2f\x22\x3e\x0a\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x3c\x74\x69\x66\x66\x3a\x4f\x72\
\x69\x65\x6e\x74\x61\x74\x69\x6f\x6e\x3e\x31\x3c\x2f\x74\x69\x66\
\x66\x3a\x4f\x72\x69\x65\x6e\x74\x61\x74\x69\x6f\x6e\x3e\x0a\x20\
\x20\x20\x20\x20\x20\x3c\x2f\x72\x64\x66\x3a\x44\x65\x73\x63\x72\
\x69\x70\x74\x69\x6f\x6e\x3e\x0a\x20\x20\x20\x3c\x2f\x72\x64\x66\
\x3a\x52\x44\x46\x3e\x0a\x3c\x2f\x78\x3a\x78\x6d\x70\x6d\x65\x74\
\x61\x3e\x0a\x4c\xc2\x27\x59\x00\x00\x03\x89\x49\x44\x41\x54\x78\
\x01\xed\xdd\x4d\x72\x9b\x30\x14\x07\xf0\x27\xc6\x33\xcd\x2e\xbd\
\x41\xdd\x13\xd4\xcb\x4c\x37\xa1\x07\xe8\x94\x1b\xb4\xbd\x41\x6e\
\xd0\xf4\x06\x39\x42\x7a\x03\xea\x5e\xc0\xdd\xa4\x5e\x26\x37\xc8\
\x11\xe2\x5d\xa6\x0b\xe8\x7b\x38\xb2\x01\x4b\x06\x61\xbe\x8a\xfe\
\x9a\xf1\x00\x42\x12\xe1\xc7\xb3\x2c\x9b\x8f\xa8\x8b\x28\x0d\x83\
\x84\x42\x42\x6a\x55\x20\x49\xe9\x71\xfd\x4b\xdd\xea\x46\x67\x67\
\x44\xf7\xcf\x44\x37\x8a\xe8\x9d\xce\xc4\xf4\x64\x81\x1f\x4a\x65\
\xc1\x7b\xab\x5b\x0a\x56\xb1\x7a\x3a\x0b\x28\x4c\x89\x1e\x74\x26\
\xa6\x8d\x05\x7e\xa6\x01\xbd\x35\xd5\x0e\x24\x13\xd8\x26\x9a\xfa\
\x79\x12\xa4\x0c\xfc\xe1\xcf\x52\x45\x5c\x6b\xce\xaf\xcf\xe5\xda\
\x19\xb4\x64\x02\xbb\x4c\x53\x6b\x79\x93\xa6\xf4\x75\xbd\x54\x8b\
\x75\xac\x56\x52\x43\x25\x74\x2d\xd3\x72\xda\x41\xcb\x0a\x60\x97\
\x79\xec\xcb\xfc\x99\xf6\xfd\x55\x40\xf3\xfc\x07\xde\xc5\xc7\xf4\
\x0b\xd7\xb8\x34\xd5\x2a\x40\x4b\x01\x60\x9b\x98\x0a\x79\x59\x3f\
\x7c\xb7\x54\xd7\x62\xa5\xd7\x84\x51\xfa\x5a\x05\xe6\x68\x96\x32\
\x07\xd0\x92\x09\x6c\x51\x28\xa6\x7c\x3f\xcc\xdd\xc4\x63\x71\x2d\
\xd1\xdf\x84\xae\x28\xa5\x37\xe5\x7c\xbd\x6c\x84\x96\x95\xc0\xd6\
\x44\x74\xd0\x0f\xef\xd6\xbc\xcc\xf0\x77\x91\x39\x1f\x88\x6f\xe5\
\xfc\xfc\xf2\x2c\xbf\x50\x9e\x17\x6c\x7e\x4b\x84\xcf\x09\xad\x1c\
\xc6\xd9\xbf\xb9\xef\x8a\xf2\x6f\xab\x72\xbb\x53\x5b\xe6\x0f\xc0\
\x9b\xaa\x7d\xb2\x46\xb4\xae\xd8\x20\xb2\x2f\xe5\xc0\x48\x9f\xa5\
\xdb\x98\xf2\x54\xbe\x59\xf3\xfe\x7d\xaa\xda\xc7\x4a\x68\x69\xc0\
\x15\x5b\xa2\xdf\x1b\xec\x1a\xd1\x2c\x86\xb5\xa0\x81\x2d\x02\x87\
\x49\x86\x73\x75\xbb\xd4\xda\xd0\xb2\x19\x44\xf6\x1e\x3b\x1b\xce\
\xa9\xea\xbe\x59\xd7\x70\x82\x06\xb6\x66\x7b\x19\xce\x11\x9d\xef\
\x73\x8e\xcf\x39\x43\x03\x7b\x0b\xca\xc3\xb9\xf0\x38\x6d\x71\x6d\
\x23\x68\x69\xa2\x69\x37\xf2\x3e\x4a\x17\xc5\x3f\xc1\x8f\xa5\xc6\
\xd0\x4d\xb1\x53\x1e\xfa\xf9\x88\x7d\x12\x74\x13\x6c\xae\x73\xee\
\x23\xf6\xc9\xd0\xc0\x16\x81\xea\xd4\x0a\xb4\x6c\xc6\xb5\xcf\xe6\
\x2a\x5e\x45\x76\x6b\xd0\xc0\x16\x01\x7b\x6a\x15\x5a\x36\x83\xc8\
\x36\x63\xb7\x0e\x0d\xec\x1e\xa1\x81\x7d\x88\xdd\x49\x44\xeb\xcd\
\xa0\x1b\xd1\x12\x0e\xbf\xde\xed\xab\xb8\xcd\x01\x7b\xeb\xd5\x69\
\x44\xeb\x43\x02\xec\x1e\x22\x1a\xd8\x3d\x46\x34\xb0\x7b\x8c\x68\
\xdf\xb1\x7b\xe9\xa3\x35\xb2\x9e\xfa\xd8\x67\x0f\x02\x2d\xe0\xbe\
\x61\x0f\x06\xed\x1b\xf6\xa0\xd0\x3e\x61\x0f\x0e\xed\x0b\xf6\x28\
\xa0\x7d\xc0\x1e\x0d\xf4\xd4\xb1\x47\x05\x3d\x65\xec\xd1\x41\x6b\
\x6c\xbe\x58\x2d\x92\xf9\x9a\xe9\x9c\x6f\x71\x88\x6b\x96\x1d\xa4\
\xd8\x28\xa1\xb3\x2b\x51\x13\x27\xb8\x0d\xdf\x6e\xe6\x72\x60\x7a\
\xc7\x1e\x1d\xb4\x20\x3b\x5e\x8f\xbd\xe1\x5b\x1a\xc2\xbb\x58\xdd\
\xf7\xae\xe7\xb0\xc1\x51\x41\x4f\x15\x59\x8e\xc7\x68\xa0\xa7\x8c\
\x3c\x1a\xe8\xa9\x23\x8f\x02\xda\x07\xe4\xc1\xa1\x7d\x41\x1e\x14\
\xda\x27\xe4\xc1\xa0\x7d\x43\x1e\x04\xda\x47\xe4\xde\xa1\x7d\x45\
\xee\x15\xda\x67\xe4\xde\xa0\x7d\x47\xee\x05\x1a\xc8\xc2\xdc\xf1\
\x57\x70\x20\x6f\x91\x3b\x85\x06\xf2\x1e\xb9\x33\x68\x20\x17\x91\
\x3b\x81\x06\xf2\x21\x72\xeb\xd0\x40\x36\x23\xb7\x0a\x0d\x64\x3b\
\x72\x6b\xd0\x40\x3e\x8e\xdc\x0a\x34\x90\xab\x91\x4f\x86\x76\x45\
\xe6\x47\x2f\x3c\xfc\x0f\x27\x52\xeb\xd1\x1d\x2d\x25\x27\x8c\xaf\
\xf2\x25\x8e\x3e\x25\x2c\x5f\xb0\x3c\xdf\x04\x59\x1e\x36\x2b\x97\
\xeb\x96\xdb\x9a\xd8\xb2\xf1\xac\x7c\xa3\x93\xb3\x40\xb6\x86\x86\
\x11\x59\x4a\x3b\x43\x03\xd9\x1d\xd9\x19\x1a\xc8\xcd\x90\x9d\xa0\
\x81\xdc\x1c\xb9\x36\x34\x90\x4f\x43\xae\x05\x0d\x64\x2b\xf2\x93\
\xcb\x50\x95\x1f\x44\x68\x4f\xae\xc8\xf6\x96\x26\xb7\xc6\x3a\xba\
\xb0\xed\xa9\x15\x1a\xc8\x36\x32\x72\x46\x96\x96\x8c\xd0\x40\x6e\
\x17\xd9\x08\x0d\xe4\xf6\x91\x0f\xa0\x81\xdc\x0d\x72\x01\x1a\xc8\
\xdd\x21\xef\xa0\x81\xdc\x2d\x72\x06\x0d\xe4\xee\x91\x65\x0b\x33\
\xfe\x87\x64\x0b\xfe\x65\x29\xe6\x79\x79\x21\x69\x81\x80\xe2\x36\
\x6f\x40\xfa\x07\x2a\xfc\xd4\x85\x96\x46\x39\x88\x00\x00\x00\x00\
\x49\x45\x4e\x44\xae\x42\x60\x82\
"

qt_resource_name = b"\
\x00\x06\
\x07\xdb\x35\xdf\
\x00\x76\
\x00\x74\x00\x6c\x00\x6f\x00\x67\x00\x6f\
\x00\x0b\
\x05\x5d\x1b\x27\
\x00\x76\
\x00\x74\x00\x5f\x00\x6c\x00\x6f\x00\x67\x00\x6f\x00\x2e\x00\x70\x00\x6e\x00\x67\
"

qt_resource_struct = b"\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x01\
\x00\x00\x00\x00\x00\x00\x00\x00\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x02\
\x00\x00\x00\x00\x00\x00\x00\x00\
\x00\x00\x00\x12\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\
\x00\x00\x01\x77\x25\xce\x6b\xc8\
"

def qInitResources():
    QtCore.qRegisterResourceData(2, qt_resource_struct, qt_resource_name, qt_resource_data)

def qCleanupResources():
    QtCore.qUnregisterResourceData(2, qt_resource_struct, qt_resource_name, qt_resource_data)

qInitResources()
```

`plugin/virustotal/vt_ida/ui/qt6panel.py`:

```py
# Copyright 2025 Google LLC. All Rights Reserved.
# Form implementation generated from reading ui file 'vtpanel.ui'
#
# Created by: PyQt6 UI code generator 6.9.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.

__author__ = 'gerardofn@virustotal.com'

from PySide6 import QtCore, QtGui, QtWidgets
from . import qt6logo


class Qt6Ui_panelUI(object):
    def setupUi(self, panelUI):
        panelUI.setObjectName("panelUI")
        panelUI.resize(600, 1051)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.MinimumExpanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(panelUI.sizePolicy().hasHeightForWidth())
        panelUI.setSizePolicy(sizePolicy)
        panelUI.setMinimumSize(QtCore.QSize(400, 0))
        panelUI.setMaximumSize(QtCore.QSize(16777215, 16777215))
        panelUI.setAutoFillBackground(False)
        panelUI.setLocale(QtCore.QLocale(QtCore.QLocale.Language.English, QtCore.QLocale.Country.UnitedStates))
        self.verticalLayout_11 = QtWidgets.QVBoxLayout(panelUI)
        self.verticalLayout_11.setObjectName("verticalLayout_11")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.tabWidget = QtWidgets.QTabWidget(panelUI)
        self.tabWidget.setEnabled(True)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tabWidget.sizePolicy().hasHeightForWidth())
        self.tabWidget.setSizePolicy(sizePolicy)
        self.tabWidget.setMinimumSize(QtCore.QSize(0, 0))
        font = QtGui.QFont()
        font.setKerning(True)
        self.tabWidget.setFont(font)
        self.tabWidget.setAutoFillBackground(False)
        self.tabWidget.setStyleSheet("QTabBar::tab { \n"
"border: 2px;\n"
"height: 20px;\n"
"width: 100%;\n"
"color: white;\n"
"background-color: rgb(248, 248, 248);\n"
"} \n"
"\n"
"QTabWidget::pane  { \n"
"border-left: 1px solid rgb(35, 61, 255);\n"
"border-right: 1px solid rgb(35, 61, 255);\n"
"border-bottom: 1px solid rgb(35, 61, 255);\n"
"border-top: 1px solid rgb(35, 61, 255);\n"
"}\n"
"\n"
"QTabBar::tab:selected { \n"
"color: white;\n"
"min-width: 10em;\n"
"background-color: rgb(42, 45, 255);\n"
"border-left: 1px solid rgb(42, 45, 255);\n"
"border-right: 1px solid rgb(42, 45, 255);\n"
"border-top: 1px solid rgb(42, 45, 255);\n"
"border-bottom: 1px solid rgb(42, 45, 255);\n"
"}\n"
"\n"
"QTabBar::tab:!selected {\n"
"color: black;\n"
"min-width: 10em;\n"
"background-color: rgb(248, 248, 248);\n"
"border-left: 1px solid gray;\n"
"border-right: 1px solid gray;\n"
"border-top: 1px solid gray;\n"
"}\n"
"\n"
"QTabBarWidget::tab-bar {\n"
"color: black;\n"
"background-color: rgb(248, 248, 248);\n"
"border-bottom: 1px solid  rgb(35, 61, 255);\n"
"}")
        self.tabWidget.setTabPosition(QtWidgets.QTabWidget.TabPosition.North)
        self.tabWidget.setTabShape(QtWidgets.QTabWidget.TabShape.Rounded)
        self.tabWidget.setElideMode(QtCore.Qt.TextElideMode.ElideLeft)
        self.tabWidget.setUsesScrollButtons(False)
        self.tabWidget.setDocumentMode(False)
        self.tabWidget.setTabsClosable(False)
        self.tabWidget.setMovable(False)
        self.tabWidget.setTabBarAutoHide(False)
        self.tabWidget.setObjectName("tabWidget")
        self.tab_codeinsight = QtWidgets.QWidget()
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.MinimumExpanding, QtWidgets.QSizePolicy.Policy.MinimumExpanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tab_codeinsight.sizePolicy().hasHeightForWidth())
        self.tab_codeinsight.setSizePolicy(sizePolicy)
        self.tab_codeinsight.setObjectName("tab_codeinsight")
        self.verticalLayout_20 = QtWidgets.QVBoxLayout(self.tab_codeinsight)
        self.verticalLayout_20.setObjectName("verticalLayout_20")
        self.info = QtWidgets.QGroupBox(self.tab_codeinsight)
        self.info.setAutoFillBackground(False)
        self.info.setTitle("")
        self.info.setFlat(True)
        self.info.setObjectName("info")
        self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.info)
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        self.gridLayout = QtWidgets.QGridLayout()
        self.gridLayout.setSizeConstraint(QtWidgets.QLayout.SizeConstraint.SetMaximumSize)
        self.gridLayout.setObjectName("gridLayout")
        self.cb_faddress = QtWidgets.QComboBox(self.info)
        self.cb_faddress.setObjectName("cb_faddress")
        self.gridLayout.addWidget(self.cb_faddress, 0, 2, 1, 1)
        self.le_codetype = QtWidgets.QLineEdit(self.info)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.MinimumExpanding, QtWidgets.QSizePolicy.Policy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.le_codetype.sizePolicy().hasHeightForWidth())
        self.le_codetype.setSizePolicy(sizePolicy)
        self.le_codetype.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.le_codetype.setText("")
        self.le_codetype.setReadOnly(True)
        self.le_codetype.setPlaceholderText("")
        self.le_codetype.setObjectName("le_codetype")
        self.gridLayout.addWidget(self.le_codetype, 5, 2, 1, 1)
        self.label_2 = QtWidgets.QLabel(self.info)
        self.label_2.setObjectName("label_2")
        self.gridLayout.addWidget(self.label_2, 5, 0, 1, 1)
        self.label_8 = QtWidgets.QLabel(self.info)
        self.label_8.setObjectName("label_8")
        self.gridLayout.addWidget(self.label_8, 2, 0, 1, 1)
        self.label = QtWidgets.QLabel(self.info)
        self.label.setObjectName("label")
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        self.le_fname = QtWidgets.QLineEdit(self.info)
        self.le_fname.setObjectName("le_fname")
        self.le_fname.setReadOnly(True)
        self.gridLayout.addWidget(self.le_fname, 2, 2, 1, 1)
        self.label_4 = QtWidgets.QLabel(self.info)
        self.label_4.setObjectName("label_4")
        self.gridLayout.addWidget(self.label_4, 1, 0, 1, 1)
        self.le_faddress = QtWidgets.QLineEdit(self.info)
        self.le_faddress.setObjectName("le_faddress")
        self.le_faddress.setReadOnly(True)
        self.gridLayout.addWidget(self.le_faddress, 1, 2, 1, 1)
        self.horizontalLayout_10.addLayout(self.gridLayout)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_10.addItem(spacerItem)
        self.verticalLayout_16 = QtWidgets.QVBoxLayout()
        self.verticalLayout_16.setSizeConstraint(QtWidgets.QLayout.SizeConstraint.SetFixedSize)
        self.verticalLayout_16.setObjectName("verticalLayout_16")
        self.label_15 = QtWidgets.QLabel(self.info)
        self.label_15.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.label_15.setObjectName("label_15")
        self.verticalLayout_16.addWidget(self.label_15)
        self.horizontalLayout_10.addLayout(self.verticalLayout_16)
        self.verticalLayout_7.addLayout(self.horizontalLayout_10)
        self.verticalLayout_20.addWidget(self.info)
        self.summary = QtWidgets.QGroupBox(self.tab_codeinsight)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.summary.sizePolicy().hasHeightForWidth())
        self.summary.setSizePolicy(sizePolicy)
        self.summary.setMinimumSize(QtCore.QSize(0, 80))
        font = QtGui.QFont()
        font.setBold(True)
        self.summary.setFont(font)
        self.summary.setFlat(True)
        self.summary.setObjectName("summary")
        self.verticalLayout_15 = QtWidgets.QVBoxLayout(self.summary)
        self.verticalLayout_15.setObjectName("verticalLayout_15")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.te_ci_summary = QtWidgets.QTextEdit(self.summary)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.te_ci_summary.sizePolicy().hasHeightForWidth())
        self.te_ci_summary.setSizePolicy(sizePolicy)
        self.te_ci_summary.setMinimumSize(QtCore.QSize(0, 60))
        self.te_ci_summary.setObjectName("te_ci_summary")
        self.verticalLayout_2.addWidget(self.te_ci_summary)
        self.verticalLayout_15.addLayout(self.verticalLayout_2)
        self.verticalLayout_20.addWidget(self.summary)
        self.description = QtWidgets.QGroupBox(self.tab_codeinsight)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.description.sizePolicy().hasHeightForWidth())
        self.description.setSizePolicy(sizePolicy)
        self.description.setMinimumSize(QtCore.QSize(40, 12))
        font = QtGui.QFont()
        font.setBold(True)
        self.description.setFont(font)
        self.description.setFlat(True)
        self.description.setObjectName("description")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.description)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.te_ci_description = QtWidgets.QTextEdit(self.description)
        self.te_ci_description.setObjectName("te_ci_description")
        self.verticalLayout_3.addWidget(self.te_ci_description)
        self.verticalLayout_20.addWidget(self.description)
        self.evaluation_widgets = QtWidgets.QHBoxLayout()
        self.evaluation_widgets.setObjectName("evaluation_widgets")
        spacerItem1 = QtWidgets.QSpacerItem(363, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.evaluation_widgets.addItem(spacerItem1)
        self.label_3 = QtWidgets.QLabel(self.tab_codeinsight)
        self.label_3.setObjectName("label_3")
        self.evaluation_widgets.addWidget(self.label_3)
        self.pb_accept = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_accept.setObjectName("pb_accept")
        self.evaluation_widgets.addWidget(self.pb_accept)
        self.pb_discard = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_discard.setObjectName("pb_discard")
        self.evaluation_widgets.addWidget(self.pb_discard)
        self.pb_refresh = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_refresh.setObjectName("pb_refresh")
        self.evaluation_widgets.addWidget(self.pb_refresh)
        self.verticalLayout_20.addLayout(self.evaluation_widgets)
        self.line = QtWidgets.QFrame(self.tab_codeinsight)
        font = QtGui.QFont()
        font.setWeight(QtGui.QFont.Weight.Normal)
        self.line.setFont(font)
        self.line.setStyleSheet("color: black;\n"
" ")
        self.line.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.line.setLineWidth(2)
        self.line.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line.setObjectName("line")
        self.verticalLayout_20.addWidget(self.line)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem2)
        self.pb_askCI = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_askCI.setObjectName("pb_askCI")
        self.horizontalLayout_4.addWidget(self.pb_askCI)
        self.pb_go = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_go.setObjectName("pb_go")
        self.horizontalLayout_4.addWidget(self.pb_go)
        self.pb_autocomment = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_autocomment.setObjectName("pb_autocomment")
        self.horizontalLayout_4.addWidget(self.pb_autocomment)
        self.pb_load = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_load.setObjectName("pb_load")
        self.horizontalLayout_4.addWidget(self.pb_load)
        self.pb_export = QtWidgets.QPushButton(self.tab_codeinsight)
        self.pb_export.setObjectName("pb_export")
        self.horizontalLayout_4.addWidget(self.pb_export)
        self.verticalLayout_20.addLayout(self.horizontalLayout_4)
        self.tabWidget.addTab(self.tab_codeinsight, "")
        self.verticalLayout.addWidget(self.tabWidget)
        self.verticalLayout_11.addLayout(self.verticalLayout)

        self.retranslateUi(panelUI)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(panelUI)

    def retranslateUi(self, panelUI):
        _translate = QtCore.QCoreApplication.translate
        panelUI.setWindowTitle(_translate("panelUI", "VirusTotal"))
        self.info.setAccessibleName(_translate("panelUI", "General"))
        self.label_2.setText(_translate("panelUI", "Code type:"))
        self.label_8.setText(_translate("panelUI", "Function name"))
        self.label.setText(_translate("panelUI", "Analyzed functions"))
        self.label_4.setText(_translate("panelUI", "Function address"))
        self.label_15.setText(_translate("panelUI", "<html><head/><body><p><img src=\":/vtlogo/vt_logo.png\"/></p></body></html>"))
        self.summary.setTitle(_translate("panelUI", "Summary"))
        self.description.setTitle(_translate("panelUI", "Description"))
        self.label_3.setText(_translate("panelUI", "Evaluate analysis:"))
        self.pb_accept.setText(_translate("panelUI", "Accept"))
        self.pb_discard.setText(_translate("panelUI", "Discard"))
        self.pb_refresh.setText(_translate("panelUI", "Refresh"))
        self.pb_askCI.setText(_translate("panelUI", "Ask CI"))
        self.pb_go.setText(_translate("panelUI", "Go"))
        self.pb_autocomment.setText(_translate("panelUI", "Autocomment"))
        self.pb_load.setText(_translate("panelUI", "Load"))
        self.pb_export.setText(_translate("panelUI", "Export"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_codeinsight), _translate("panelUI", "Code Insight Notebook"))

```

`plugin/virustotal/vt_ida/ui/resources/vt_logo.qrc`:

```qrc
<RCC>
  <qresource prefix="vtlogo">
    <file>vt_logo.png</file>
  </qresource>
</RCC>

```

`plugin/virustotal/vt_ida/vtpanel.py`:

```py
# Copyright 2025 Google LLC. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

__author__ = 'gerardofn@virustotal.com'

import idaapi
import ida_kernwin
import ida_hexrays
import idc
from idaapi import PluginForm
from virustotal import codeinsight
from virustotal.vt_ida.ui import Ui_panelUI
from virustotal.codeinsight import ci_notebook
from virustotal.vt_ida.vtwidgets import VTWidgets
import logging
import base64
import textwrap
import json
import threading


class VTPanel(PluginForm, Ui_panelUI):
  """A PluginForm that displays VirusTotal Code Insight analysis within IDA.

  This panel allows users to request analysis for functions, view the results,
  edit them, and manage a "notebook" of analyzed functions.
  """
  visible = False
  summary = None
  description = None
  expected_summary = None
  expected_description = None
  faddr = None
  fname = None
  ctype = None
  code_src = None
  encoded_src = None
  ci_search = None
  fhash = None
 

  def OnCreate(self, form):
    """Called by IDA when the form is created.

    Initializes the UI, connects widget signals to their corresponding slots,
    and sets the initial state of the UI elements.

    Args:
      form: The TForm object created by IDA.
    """
    self.query_in_progress = False # Initialize as instance attribute
   
    self.parent = self.FormToPyQtWidget(form)
    self.setupUi(self.parent)
    self.pb_accept.setEnabled(False)
    self.pb_discard.setEnabled(False)
    self.cb_faddress.setEnabled(False)
    self.le_faddress.setEnabled(False)
    self.le_fname.setEnabled(False)
    self.le_codetype.setEnabled(False)

    self.te_ci_summary.textChanged.connect(self._summary_updated)
    self.te_ci_description.textChanged.connect(self._description_updated)
    self.cb_faddress.currentIndexChanged.connect(self._faddress_selected)
    self.pb_accept.clicked.connect(self._accept_analysis)
    self.pb_discard.clicked.connect(self._discard_analysis)
    self.pb_go.clicked.connect(self._go)
    self.pb_autocomment.clicked.connect(self._auto_comment)
    self.pb_askCI.clicked.connect(self.askCI_EA)
    self.pb_refresh.clicked.connect(self._refreshCI)
    self.pb_load.clicked.connect(self._load)
    self.pb_export.clicked.connect(self._export)

  def _go(self):
    """Jumps the IDA disassembly view to the address of the current function."""
    if self.faddr:
      if not ida_kernwin.jumpto(self.faddr):
        logging.info('[VT Plugin] Functions address can\'t be found: %s', hex(self.faddr))

  def _load(self):
    """Handles importing a Code Insight notebook from a JSON file.

    Prompts the user to select a file. If a file is selected, it replaces
    the current notebook with the data from the file and updates the UI.
    Warns the user if a notebook is already loaded, as this action will
    overwrite it.
    """
    global ci_notebook

    if self.cb_faddress.count() != 0:
      msg = """Importing a new Code Insight Notebook

The current notebook will be replaced with a new one.

"""
      proceed_import = idaapi.ask_form(msg)
    else:
      proceed_import = 1

    if proceed_import == 1:  # Yes

      filename = ida_kernwin.ask_file(0, "*.json", "Select file to import:")
      
      if filename:
        logging.info('[VT Plugin] Importing file: %s', filename)

        try:
          logging.debug('[VT Plugin] Loading CodeInsight Notebook file: %s', filename)
          with open(filename, 'r', encoding='utf-8') as f:
            imported_json = json.load(f)
        except (OSError, json.JSONDecodeError):
            logging.error('[VT Plugin] ERROR importing file: %s', filename)
            return

        ci_notebook.import_data(imported_json)
        self._read_notebook()
        self.clean_view()
      else:
        logging.debug('[VT Plugin] No file selected to import CI Notebook')
    
    else:  # Cancelled
        logging.debug('[VT Plugin] User canceled the import of a new notebook')

  def _export(self):
    """Exports the current Code Insight notebook to a JSON file.

    Prompts the user for a filename and saves the entire contents of the
    current notebook.
    """
    global ci_notebook

    filename = ida_kernwin.ask_file(1, "*.json", "Enter name of the file:")
    logging.info('[VT Plugin] File will be saved in: %s', filename)

    try:
      logging.debug('[VT Plugin] Exporting CodeInsight Notebook to file: %s', filename)
      with open(filename, 'w', encoding='utf-8') as f:
        json.dump(ci_notebook.show_pages(), f)
    except (OSError, TypeError):
        logging.error('[VT Plugin] ERROR saving file: %s', filename)


  def askCI_EA(self):
    """Initiates a Code Insight query for the function at the current cursor
    position.

    Clears the view and then triggers a new analysis for the function under the
    current effective address (EA) in IDA's disassembly view.

    """

    current_address = idc.get_screen_ea()
    addr_func = idaapi.get_func(current_address) 

    if not addr_func:
      logging.error('[VT Plugin] Current address doesn\'t belong to a function')
      VTWidgets.show_warning('The cursor must be within a function.')
      return

    # Determine the active window type to set the correct code type for the query.
    widget_ida = idaapi.get_current_widget()
    widget_ida_type = idaapi.get_widget_type(widget_ida)

    if widget_ida_type == idaapi.BWN_DISASM:
        code_type = codeinsight.CI_DISASSEMBLED
    elif widget_ida_type == idaapi.BWN_PSEUDOCODE:
        code_type = codeinsight.CI_DECOMPILED
    else:
        # If the active window is neither, we can't proceed.
        logging.warning('[VT Plugin] "Ask CI" can only be used from the Disassembly or Pseudocode views.')
        VTWidgets.show_warning('This functionality can only be used from the\nDisassembly or Pseudocode views.')
        return

    self.clean_view()

    # Pepare the data and start the query thread.
    self.set_data(faddr=addr_func.start_ea, ctype=code_type)

  def _askCI_Disassembled(self, code_src):
    """Performs a Code Insight query using the disassembly of a function.

    Args:
      addr_start (int): The starting address of the function to analyze.
      addr_end (int): The ending address of the function to analyze.
    """
    
    ci_search = codeinsight.CodeInsightASM(code_src=code_src)
    self.ci_report = ci_search.askCI(use_codetype=codeinsight.CI_DISASSEMBLED)

    try:
      self.summary = self.ci_report['summary']
      self.description = self.ci_report['description']
    except (KeyError, TypeError):
      logging.error('[VT Plugin] Invalid answer received from Code Insight')
      return False

    self.ctype = codeinsight.CI_DISASSEMBLED
    self.encoded_src = ci_search.get_encoded_src()
    self.code_src =  ci_search.get_src()
    return True

  def _askCI_Decompiled(self, code_src):
    """Performs a Code Insight query using the decompiled C-like code of a
    function.

    Args:
      faddr (int, optional): The starting address of the function to analyze.
    """
    ci_search = codeinsight.CodeInsightDecompiled(code_src=code_src)
    self.ci_report = ci_search.askCI(use_codetype = codeinsight.CI_DECOMPILED)

    try:
      self.summary = self.ci_report['summary']
      self.description = self.ci_report['description']
    except (KeyError, TypeError):
      logging.error('[VT Plugin] Invalid answer received from Code Insight')
      return False
    
    self.ctype = codeinsight.CI_DECOMPILED
    self.encoded_src = ci_search.get_encoded_src()    
    self.code_src =  ci_search.get_src()
    return True

  def _refreshCI(self):   
    """Refreshes the Code Insight analysis for the currently viewed function."""
    self.set_data(self.faddr, self.ctype)


  def _auto_comment(self): 
    """Adds or updates IDA function comments for all functions in the notebook.

    Iterates through each function in the `ci_notebook`. For each function, it
    takes the 'expected_summary' (if available) or the 'summary' and adds it
    as a repeatable function comment in IDA.

    If a Code Insight comment block (marked with `[CodeInsight start]` and
    `[CodeInsight end]`) already exists, it is replaced. Otherwise, the new
    comment is appended to any existing comments.
    """

    global ci_notebook

    n_func = ci_notebook.get_total()

    if n_func > 0:
      logging.debug('[VT Plugin] Adding/updating comments for %d functions', n_func)
      for key_str in ci_notebook.get_functions():
        key = int(key_str, 16)  # Convert hex string key to integer address.
        page = ci_notebook.get_page(key_str)

        # Determine the summary to be used for the comment.
        if page.get('expected_summary'):
          summary = page['expected_summary']
        else:
          summary = page.get('summary', '')
   
        if not summary:
          logging.debug('[VT Plugin] No summary for function %s, skipping.', key_str)
          continue
        
        # Prepare the new comment block with markers.
        wrapped_summary = textwrap.fill(summary, width=80)
        new_comment_block = "[CodeInsight start]\n {} \n[CodeInsight end]".format(wrapped_summary)
        
        # The plugin will consistently work with the "repeatable" comment (type 0).
        current_comment = idc.get_func_cmt(key, 0) or ""

        start_marker = "[CodeInsight start]"
        end_marker = "[CodeInsight end]"
        start_pos = current_comment.find(start_marker)

        final_comment = ""
        if start_pos != -1:
          # An old CodeInsight comment exists, so replace it.
          logging.debug('[VT Plugin] Updating existing Code Insight comment for %s.', key_str)
          end_pos = current_comment.find(end_marker, start_pos)
          if end_pos != -1:
            # Preserve text before and after the old block.
            before_block = current_comment[:start_pos]
            after_block = current_comment[end_pos + len(end_marker):]
            # Reconstruct the comment to ensure clean separation.
            final_comment = before_block.rstrip() + '\n' + new_comment_block + '\n' + after_block.lstrip()
          else:
            # Malformed comment (start without end). Append new block to be safe.
            logging.warning('[VT Plugin] Malformed comment in %s. Appending.', key_str)
            final_comment = current_comment + '\n\n' + new_comment_block
        else:
          # No old Code Insight comment. Append the new block to existing comments.
          logging.debug('[VT Plugin] Adding new Code Insight comment for %s.', key_str)
          if current_comment:
            final_comment = current_comment + '\n\n' + new_comment_block
          else:
            final_comment = new_comment_block
            
        # Set the new repeatable comment, stripping excess whitespace.
        idc.set_func_cmt(key, final_comment.strip(), 0)

      ida_kernwin.info("Comments updated for {} function(s).".format(n_func))
      self.pb_autocomment.setEnabled(False)

  def query_in_progress(self):
    return self.query_in_progress

  def _summary_updated(self):
    """Slot connected to the summary text edit's `textChanged` signal.

    It detects if the user has modified the summary text provided by Code
    Insight. If so, it enables the 'Accept' and 'Discard' buttons and stores
    the new text in `self.expected_summary`.
    """
    new_summary = self.te_ci_summary.toPlainText()
    if not (self.summary == new_summary):
      self.pb_accept.setEnabled(True)
      self.pb_discard.setEnabled(True)
      self.expected_summary = self.te_ci_summary.toPlainText()

  def _description_updated(self):
    """Slot connected to the description text edit's `textChanged` signal.

    It detects if the user has modified the description text provided by Code
    Insight. If so, it enables the 'Accept' and 'Discard' buttons and stores
    the new text in `self.expected_description`.
    """
    new_description = self.te_ci_description.toPlainText()
    if not (self.description == new_description):
      self.pb_accept.setEnabled(True)
      self.pb_discard.setEnabled(True)
      self.expected_description = self.te_ci_description.toPlainText()

  def _faddress_selected(self, index):
    """Slot connected to the function address combo box's
    `currentIndexChanged` signal.

    When a user selects a function from the dropdown, this method loads the
    corresponding analysis from the `ci_notebook` and updates the entire view.

    Args:
      index (int): The index of the item selected in the combo box.
    """
    selected_item = self.cb_faddress.itemText(index)

    if selected_item != "":
      logging.debug('[VT Plugin] Function selected: %s', selected_item)
      self.clean_view()

      if selected_item:
        selected_analysis = ci_notebook.get_page(selected_item)
        self.pb_accept.setEnabled(False)

        if selected_analysis: 
          logging.debug("[VT Plugin] Selected function %s from CI_Notebook: %s", 
                        selected_item, 
                        selected_analysis)
          self.faddr = int(selected_item,16)
      
          if 'expected_summary' in selected_analysis:
            self.expected_summary = selected_analysis['expected_summary']

          if 'expected_description' in selected_analysis:
            self.expected_description = selected_analysis['expected_description']

          self.summary = selected_analysis['summary']
          self.description = selected_analysis['description']
          self.fname = selected_analysis['func_name']
          self.ctype = selected_analysis['code_type']
          self.encoded_src = selected_analysis['b64code']
          code = base64.b64decode(self.encoded_src)
          self.code_src = code.decode('ascii')   
          
          self._update_view()
          self.cb_faddress.setCurrentIndex(0)
          self.pb_discard.setEnabled(True)
          self.pb_refresh.setEnabled(True)
          self.pb_go.setEnabled(True)
        else:
          self.pb_discard.setEnabled(False)

  def clean_view(self):
    """Clears all data from the UI panel and resets internal state variables.

    This is used to prepare the panel for a new query or when discarding an
    analysis. It also resets the enabled state of various buttons.
    """

    self.te_ci_summary.clear()
    self.te_ci_description.clear()
    self.le_codetype.clear()
    self.le_fname.clear()
    self.le_faddress.clear()
    self.le_faddress.setEnabled(False)
    self.le_fname.setEnabled(False)
    self.le_codetype.setEnabled(False)
    self.summary = None
    self.description = None
    self.expected_summary = None
    self.expected_description = None
    self.faddr = None
    self.fname = None
    self.ctype = None
    self.code_src = None
    self.encoded_src = None
    self.ci_report = None
    self.ci_search = None
    self.pb_accept.setEnabled(False)
    self.pb_discard.setEnabled(False)
    self.pb_go.setEnabled(False)

    if self.cb_faddress.count() <= 1:
      # We have some functions in the functions list
      self.pb_export.setEnabled(False)
      self.pb_autocomment.setEnabled(False)
      self.cb_faddress.setEnabled(False)
    else:
      self.pb_export.setEnabled(True)
      self.pb_autocomment.setEnabled(True)
      self.cb_faddress.setEnabled(True)


  def _discard_analysis(self):
    """Discards the analysis for the currently displayed function.

    Removes the function's page from the `ci_notebook`, removes its entry
    from the function dropdown, and cleans the view. If other functions remain
    in the notebook, it displays the next one.
    """
    global ci_notebook

    # Check if current function address is in the Code Insight Notebook
    if ci_notebook.get_page(hex(self.faddr)):
      logging.debug('[VT Plugin] Discarding analysis for %s', hex(self.faddr))
      ci_notebook.discard_page(hex(self.faddr))
      self.cb_faddress.removeItem(self.cb_faddress.findText(hex(self.faddr)))

    self.clean_view()

    self.pb_accept.setEnabled(False)
    self.pb_discard.setEnabled(False)
    self.pb_refresh.setEnabled(False)

    if self.cb_faddress.count() > 1:
      # Show next page in the notebook
      self._faddress_selected(self.cb_faddress.currentIndex())

  def _update_view(self):
    """Populates the UI widgets with the current function's analysis data.

    It sets the text for summary, description, code type, function name, and
    address, using the user-edited "expected" values if they exist.
    """

    self.le_faddress.setEnabled(True)
    self.le_fname.setEnabled(True)
    self.le_codetype.setEnabled(True)

    if self.expected_summary:
      self.te_ci_summary.setText(self.expected_summary)
    else:
      self.te_ci_summary.setText(self.summary)
    
    if self.expected_description:
      self.te_ci_description.setText(self.expected_description)
    else:
      self.te_ci_description.setText(self.description)
    
    self.le_codetype.setText(self.ctype)
    self.le_fname.setText(self.fname)
    self.le_faddress.setText(hex(self.faddr))
    
  def _accept_analysis(self):
    """Saves the current analysis to the Code Insight notebook.

    This is called when the user clicks the 'Accept' button. It takes the
    current data (including any user edits) and adds or updates a page in the
    `ci_notebook`. It also updates the UI state accordingly.
    """
    global ci_notebook   
    
    ci_notebook.add_page(func_name = self.fname, 
                          func_addr = hex(self.faddr), 
                          code_type = self.ctype,
                          b64code = self.encoded_src, 
                          summary = self.summary,
                          description = self.description,
                          expected_summary = self.expected_summary,
                          expected_description = self.expected_description
                          )

    list_faddress = [self.cb_faddress.itemText(i) for i in range(self.cb_faddress.count())]
    
    if self.cb_faddress.count() == 0:
      self.cb_faddress.addItem("")

    if hex(self.faddr) not in list_faddress:
      logging.debug('[VT Plugin] Including current function in the notebook: %s', hex(self.faddr))
      self.cb_faddress.addItem(hex(self.faddr))

    self.pb_discard.setEnabled(True)
    self.cb_faddress.setEnabled(True)
    self.pb_export.setEnabled(True)
    self.pb_autocomment.setEnabled(True)
    self.pb_accept.setEnabled(False)
    self.pb_go.setEnabled(True)
    

  def _read_notebook(self):
    """Reads the global `ci_notebook` and populates the function address
    combo box.

    This is used when loading a notebook from a file to make all its analyzed
    functions available in the dropdown list.
    """
    global ci_notebook
    
    logging.debug('[VT Plugin] Importing notebook.')

    # Clean the list bar erasing any previous content.
    self.cb_faddress.clear()

    if ci_notebook:

      # Add functions to the list bar
      list_faddress = [self.cb_faddress.itemText(i) for i in range(self.cb_faddress.count())]

      if self.cb_faddress.count() == 0:
        self.cb_faddress.addItem("")

      # Iterate over every function in the Notebook
      for address in ci_notebook.get_functions():
        if address not in list_faddress:
          self.cb_faddress.addItem(address)

  def _query_thread(self, faddr, ctype, fhash, code_src):
    """Worker thread to perform the Code Insight query."""
    if ctype == codeinsight.CI_DECOMPILED:
      success = self._askCI_Decompiled(code_src)
    else:  # Disassembled function selected or null ctype
      success = self._askCI_Disassembled(code_src)

    if success:
      # Schedule UI updates on the main thread
      def ui_update_callback():
        self.faddr = faddr
        self.fname = idc.get_func_name(faddr)
        self._post_query_update(fhash)

      ida_kernwin.execute_ui_requests([ui_update_callback])
    else:
      # Restore UI state on error
      def error_callback():
        VTWidgets.show_warning('Invalid answer received from Code Insight')
        self.clean_view()
        self.pb_askCI.setEnabled(True)
        self.pb_refresh.setEnabled(False)
        self.query_in_progress = False
      ida_kernwin.execute_ui_requests([error_callback])

  def _post_query_update(self, fhash):
    """Updates the UI after the query thread is finished."""
    self.te_ci_summary.clear()
    self.te_ci_description.clear()

    if self.summary:
      # Updating display
      self._update_view()
      self.fhash = fhash
      self.pb_accept.setEnabled(True)
    
    # Re-enable buttons
    self.pb_askCI.setEnabled(True)
    self.pb_refresh.setEnabled(True)
    self.query_in_progress = False


  def set_data(self, faddr=None, fhash=None, ctype=None):
    """The main entry point to populate the panel with data.

    If `faddr` is provided, it initiates a new Code Insight query for that
    function address.

    If `faddr` is not provided, it checks if the notebook contains any data
    (e.g., after closing and reopening the panel) and loads it.

    Args:
      faddr (int, optional): The starting address of the function to analyze.
      fhash (str, optional): The hash of the file being analyzed (not currently
        used for queries).
      ctype (str, optional): The type of code to analyze ('decompiled' or
        'disassembled'). Defaults to 'disassembled'.
    """

    global ci_notebook

    if faddr:
      # Prevent new queries if one is already running.
      if self.query_in_progress:
        VTWidgets.show_warning('A current query to Code Insight is in process.\n Please wait.')
        return

      # Set lock and disable UI elements 
      self.query_in_progress = True
      self.pb_askCI.setEnabled(False)
      self.pb_refresh.setEnabled(False)

      logging.debug('[VT Plugin] Creating VTPanel, function: %s', hex(faddr))

      # Get function boundaries in the main thread before starting the worker
      addr_func = idaapi.get_func(faddr)
      if not addr_func:
          logging.error('[VT Plugin] Could not find function at address %s', hex(faddr))
          self.pb_askCI.setEnabled(True)

          # No query was started, so re-enable refresh if a function was previously selected.
          self.pb_refresh.setEnabled(self.faddr is not None)
          self.query_in_progress = False
          return

      # Prepare the source code in the main thread.
      code_src = None
      if ctype == codeinsight.CI_DECOMPILED:
          code_src = str(ida_hexrays.decompile(faddr))
      else: # Disassembled
          query_builder = codeinsight.CodeInsightASM(addr_start=addr_func.start_ea, addr_end=addr_func.end_ea)
          code_src = query_builder.create_query()

      if not code_src:
          logging.error('[VT Plugin] Failed to generate source code for the query.')
          self.pb_askCI.setEnabled(True)
          self.pb_refresh.setEnabled(True)
          self.query_in_progress = False
          return
      
      self.clean_view()
      self.te_ci_summary.setText("Waiting for response from Code Insight...")
      self.te_ci_description.setText("Waiting for response from Code Insight...")
      self.pb_accept.setEnabled(False)
      self.pb_discard.setEnabled(False)

      query_thread = threading.Thread(target=self._query_thread, args=(faddr, ctype, fhash, code_src))
      query_thread.start()

    else:
      self.clean_view() # Clean view when initializing panel without a specific query
      self.pb_askCI.setEnabled(True)
      if ci_notebook.get_total():
        
        # If the list of functions is empty but there are functions in the CI Notebook 
        # it means that the user closed the VTPanel widget. We need to load all the 
        # functions in the notebook and import them into the current panel.

        self.cb_faddress.addItem("")

        for address in ci_notebook.get_functions():
          logging.debug('[VT Plugin] Adding function to the list bar: %s', address)
          self.cb_faddress.addItem(address)
      else:
        logging.debug('[VT Plugin] Creating an empty VTPanel')

  def OnClose(self, form):
    """Called by IDA when the plugin form is closed.

    Args:
      form: The TForm object being closed.
    """
    self.clean_view()
    self.visible = False
    pass
  
  def isVisible(self):
    """Returns the visibility state of the panel.

    Returns:
      bool: True if the panel is currently visible, False otherwise.
    """
    return self.visible

  def Show(self, title):
    """Creates the form or shows it if it already exists."""

    flags = (
              idaapi.PluginForm.WOPN_TAB
              | idaapi.PluginForm.WOPN_MENU
              | idaapi.PluginForm.WOPN_PERSIST
    )

    vtpanel_window = PluginForm.Show(self,
                           title,
                           options = flags)
    self.visible = True
    
    return vtpanel_window

```

`plugin/virustotal/vt_ida/vtwidgets.py`:

```py
# Copyright 2025 Google LLC. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

__author__ = 'gerardofn@virustotal.com'

import ida_kernwin

class VTWidgets(object):

  @staticmethod
  def show_info(msg):
    ida_kernwin.info(msg)

  @staticmethod
  def show_warning(msg):
    ida_kernwin.warning(msg)

  @staticmethod
  def show_wait(msg):
    ida_kernwin.show_wait_box(msg)

  @staticmethod
  def hide_wait():
    ida_kernwin.hide_wait_box()



```

`plugin/virustotal/vtgrep.py`:

```py
# Copyright 2019 Google LLC. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

__author__ = 'gerardofn@virustotal.com'

import binascii
import logging
from virustotal.vt_ida.disassembler import Disassembler
from virustotal.vt_ida.vtpanel import VTWidgets
import webbrowser

try:
  from urllib import quote
except ImportError:
  from urllib.parse import quote


class Bytes(object):
  """Class representing a slice of bytes in a search query."""

  bytes_stream = ''

  def __init__(self, buf):
    self.bytes_stream = buf

  def append(self, qslice):
    if not isinstance(qslice, Bytes):
      self.bytes_stream += qslice
    else:
      self.bytes_stream += qslice.get()

  def get(self):
    return self.bytes_stream

  def len(self):
    return len(self.bytes_stream)

  def same_type(self, next_slice):
    if isinstance(next_slice, Bytes):
      return True
    return False

  def combinable(self, next_slice):
    # Check if current slice can be combined with the next slice

    if next_slice:
      if not isinstance(next_slice, Bytes) and self.len() >= 8:
        return False
    elif self.len() >= 8:
      return False
    return True

  def combine(self, next_slice):
    # Combine current slice with the next one
    
    if next_slice:
      if isinstance(next_slice, Bytes):
        self.append(next_slice)
        return self
      else:
        wcs_stream = '?' * self.len()
        next_slice.append(wcs_stream)
        return next_slice
    else:
      return self


class WildCards(object):
  """Class representing a slice of wildcards in a search query."""

  wcs_stream = ''
  packed = False

  def __init__(self, buf):
    self.wcs_stream = buf
    self.pack()

  def append(self, qslice):
    # slice can be a WildCards instance or a string of wildcards
    if not self.packed and not isinstance(qslice, WildCards):
      self.wcs_stream += qslice
      self.pack()
    else:
      if isinstance(qslice, WildCards):
        wcs_len = self.len() + qslice.len()
      else:
        wcs_len = self.len() + len(qslice)
      wcs_count = wcs_len / 2
      self.wcs_stream = '[{}]'.format(str(int(wcs_count))) + '?' * (wcs_len % 2)
      self.packed = True

  def get(self):
    return self.wcs_stream

  def len(self):
    str_len = 0
    if self.packed:
      wcs_len = self.wcs_stream.lstrip('[').rstrip(']')
      question_index = self.wcs_stream.find('?')
      if question_index != -1:
        str_len = int(float(wcs_len.rstrip(']?'))) * 2
        str_len += 1
      else:
        str_len = int(float(wcs_len)) * 2
      return str_len
    else:
      return len(self.wcs_stream)

  def pack(self):
    if not self.packed:
      wcs_len = len(self.wcs_stream)
      if wcs_len > 3:
        wcs_count = (wcs_len / 2)
        self.wcs_stream = '[{}]'.format(str(int(wcs_count)))
        self.wcs_stream += '?' * (wcs_len % 2)
        self.packed = True

  def same_type(self, next_slice):
    if isinstance(next_slice, Bytes):
      return False
    return True

  def combinable(self, next_slice):
    # Check if the current slice can be combined with the next slice
    if next_slice:
      if isinstance(next_slice, Bytes) and next_slice.len() >= 8:
        return False
    return True

  def combine(self, next_slice):
    # Combine current slice with the next one
    if next_slice:
      if isinstance(next_slice, Bytes):
        wcs_stream = '?' * next_slice.len()
        self.append(wcs_stream)
      else:
        self.append(next_slice)
    return self


class VTGrepSearch(object):
  """Implements all the methods to launch queries to VTGrep.

    This class implements the whole process of receiving a range of memory
    addresses as input (or a string), creating a string buffer containing all
    the bytes in the range, and transforming some bytes (if desired) into
    wildcards to avoid memory addresses and offsets.

    The constructor has three parameters:
    - string: when searching a string selected in the strings window
    - addr_start and addr_end: begining and ending of an area cointainig code.
  """

  _MIN_QUERY_SIZE = 5      # number of bytes
  _MAX_QUERY_SIZE = 2048   # Maximun length of a query string

  def __init__(self, *args, **kwargs):
    self.string_searching = kwargs.get('string', False)
    if self.string_searching:
      self.string_searching = self.string_searching.encode('utf-8')
    self.addr_start = kwargs.get('addr_start', 0)
    self.addr_end = kwargs.get('addr_end', 0)

  @staticmethod
  def _generate_slices(buf):
    """Read a string buffer and generates wildcards and bytes objects."""

    list_slices = buf.split()
    for qslice in list_slices:
      if qslice[0] == '?':
        yield WildCards(qslice)
      else:
        yield Bytes(qslice)

  @staticmethod
  def __sanitize(query_list):
    """Applies some checks to the current query for VTGrep syntax compliance.

    Args:
      query_list: list of slices that must be checked according to VTGrep syntax

    Checks performed:
      - No ending []
      - No consecutive [][]
      - No consecutive byte strings
      - each slice must be 4 bytes long, at the very least

    Returns:
      String: hex-encoded representation of the bytes obtained at addr
    """
    modified = True

    while modified:
      modified = False
      query_len = len(query_list)
      qslice_index = 0

      for qslice_index in range(0, query_len):
        next_qslice_index = qslice_index + 1

        if (next_qslice_index) != query_len:
          next_qslice = query_list[next_qslice_index]
          if query_list[qslice_index].combinable(next_qslice):
            qslice = query_list[qslice_index].combine(next_qslice)
            query_list[qslice_index] = qslice
            query_list.pop(next_qslice_index)
            modified = True
            break
        else:  # Last slice
          if query_list[qslice_index].combinable(None):
            query_list[qslice_index].combine(None)
            query_list.pop(qslice_index)
            modified = True
          break

    buf = ''.join(str(element.get()) for element in query_list)
    logging.debug('[VTGREP] Optimized query: %s', buf)
    return buf

  @staticmethod
  def __reduce_query(buf):
    """Receives a string buffer and returns a shorter version when possible.

    Args:
      buf: receives a string buffer and produces a simplifyed version of the
      query string, where adjacents slices are combined when possible.

    Returns:
      List: list of slices where each slice can be a Bytes or WildCards object.
    """

    query_slices = VTGrepSearch._generate_slices(buf)
    reduced_list = []

    logging.debug('[VTGREP] Original query: %s', buf)

    for current in query_slices:
      if not reduced_list:
        reduced_list.append(current)
      else:
        prev = len(reduced_list) - 1
        if reduced_list[prev].same_type(current):
          reduced_list[prev] = reduced_list[prev].combine(current)
        else:
          reduced_list.append(current)

    buf = ''.join(str(element.get()) for element in reduced_list)
    return reduced_list

  def _create_query(self, wildcards, strict):
    """Returns a buffer containing all the bytes of the instructions selected.

      If there are instructions that contain offsets or memory addresses,
    their operands will be wildcarded.

    Args:
      wildcards: True -> wildcards will be applied, False -> raw bytes
      strict: True -> all constants will be wildcarded
    Returns:
      Bytes: all the bytes belonging to the current selected instructions.
    """

    current = self.addr_start
    str_buf = ''

    # Check if current selection is in a valid range
    if not Disassembler.valid_address_range(self.addr_start, self.addr_end):
      logging.error('[VTGREP] Select a valid area.')
      return None
    elif not Disassembler.valid_range_size(
        self.addr_start,
        self.addr_end,
        self._MAX_QUERY_SIZE
        ):
      logging.error('[VTGREP] The area selected is too large.')
      return None
    else:  # Selected area is valid
      if wildcards:  # Search for similar code
        while current < self.addr_end:
          new_opcodes = Disassembler.get_opcodes(current, strict)
          if new_opcodes == 0:
            break  # Unable to disassemble current address
          else:
            str_buf += new_opcodes
          current = Disassembler.next_address(current)
      else:  # Search bytes
        str_buf = Disassembler.get_bytes(self.addr_start, self.addr_end)
        str_buf = binascii.hexlify(str_buf).decode('utf-8')

    if str_buf:
      return str_buf
    else:
      return None

  def search(self, wildcards=False, strict=False):
    """Processes current selection and generates a valid query for VTGrep.

    Args:
      wildcards: search replacing offsets and memory locations with
        widlcards (True) or look for a sequence of bytes (False)
      strict: All the inmediate values (constants) are wildcarded (True)
        or wildcard only values that are identified as offsets or
        memory addresses (False)

    Checks current lines selected in the disassembly window, call the
    appropriate method to generate a valid query. Finally, open the
    (default) web browser to launch the query.
    """

    str_buf = None

    if self.string_searching:
      str_buf = binascii.hexlify(self.string_searching).decode('utf-8')
    else:
      str_buf = self._create_query(wildcards, strict)
      if wildcards and str_buf is not None:
        str_buf = self.__sanitize(self.__reduce_query(str_buf))

    # After creating the search string, checks if new size is valid
    if str_buf is None:
      logging.error('[VTGREP] Invalid query length or area selected.')
      VTWidgets.show_warning('Invalid query length or area selected.')
    else:
      len_query = len(str_buf)

      if len_query and self._MIN_QUERY_SIZE >= len_query:
        logging.error('[VTGREP] The query produced is too short.')
        VTWidgets.show_warning('The query produced is too short.')
      elif len_query and len_query > self._MAX_QUERY_SIZE:
        logging.error('[VTGREP] The query produced is too long.')
        VTWidgets.show_warning('The query produced is too long.')
      else:
        str_buf = '{' + str_buf + '}'
        vtgrep_url = 'www.virustotal.com/gui/search/content:{}/files'
        url = 'https://{}'.format(quote(vtgrep_url.format(str_buf)))
        url += '?utm=vt_ida'

        try:
          webbrowser.open_new(url)
        except webbrowser.Error:
          logging.error('[VTGREP] Error while opening the web browser.')
          VTWidgets.show_warning('Error while opening the web browser.')

```

`plugin/vt.py`:

```py

# Copyright 2019 Google LLC. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

__author__ = 'gerardofn@virustotal.com'

from virustotal.vt_ida.plugin_loader import PLUGIN_ENTRY, VTplugin




```