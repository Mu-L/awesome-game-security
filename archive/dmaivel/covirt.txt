Project Path: arc_dmaivel_covirt_37viqy1u

Source Tree:

```txt
arc_dmaivel_covirt_37viqy1u
├── CMakeLists.txt
├── LICENSE
├── README.md
├── covirt
│   ├── analysis
│   │   ├── basic_block.cpp
│   │   ├── basic_block.hpp
│   │   ├── binary.cpp
│   │   ├── binary.hpp
│   │   ├── disasm.cpp
│   │   └── disasm.hpp
│   ├── compiler
│   │   ├── default_vm_enter.cpp
│   │   ├── default_vm_enter.hpp
│   │   ├── generic_emitter.hpp
│   │   ├── generic_lifter.cpp
│   │   ├── generic_lifter.hpp
│   │   ├── generic_vm.cpp
│   │   ├── generic_vm.hpp
│   │   └── generic_vm_enter.hpp
│   ├── main.cpp
│   ├── obfuscator
│   │   ├── expression.cpp
│   │   ├── expression.hpp
│   │   ├── generic_transform.hpp
│   │   └── passes
│   │       ├── mba_pass.cpp
│   │       ├── mba_pass.hpp
│   │       ├── smc_pass.cpp
│   │       └── smc_pass.hpp
│   ├── utils
│   │   ├── argparse.hpp
│   │   ├── indicators.hpp
│   │   ├── log.hpp
│   │   ├── rand.hpp
│   │   └── termcolors.h
│   └── vm
│       ├── v0.cpp
│       └── v0.hpp
├── include
│   └── covirt_stub.h
├── media
│   ├── covirt.png
│   ├── ss.png
│   ├── ss2.png
│   └── ss3.png
└── version.h.in

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.25)
project(covirt VERSION 0.1.0 LANGUAGES C CXX)

SET(CMAKE_CXX_STANDARD 23)

configure_file(version.h.in version.h)
include_directories(${CMAKE_CURRENT_BINARY_DIR})

include_directories(${CMAKE_SOURCE_DIR}/include)
include_directories(${CMAKE_SOURCE_DIR}/covirt)

include(FetchContent)

find_package(Zydis QUIET)
if (NOT Zydis_FOUND)
    FetchContent_Declare(
        Zydis
        GIT_REPOSITORY https://github.com/zyantific/zydis.git
        GIT_TAG v4.1.0
    )

    FetchContent_MakeAvailable(Zydis)
endif()

find_package(LIEF QUIET)
if (NOT LIEF_FOUND)
    FetchContent_Declare(
        LIEF
        GIT_REPOSITORY https://github.com/lief-project/LIEF
        GIT_TAG 0.15.1
    )

    FetchContent_MakeAvailable(LIEF)
endif()

find_package(zasm QUIET)
if (NOT zasm_FOUND)
    FetchContent_Declare(
        zasm
        GIT_REPOSITORY https://github.com/zyantific/zasm
        GIT_BRANCH master
    )

    FetchContent_MakeAvailable(zasm)
endif()

file(GLOB_RECURSE COVIRT_GLOB_SRC CONFIGURE_DEPENDS "covirt/*.cpp")

add_executable(covirt ${COVIRT_GLOB_SRC})
target_link_libraries(covirt LIEF::LIEF Zydis zasm)

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 dmaivel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
<img align="right" width="35%" src="media/covirt.png">

# covirt ![license](https://img.shields.io/badge/license-MIT-blue)

An x86-64 code virtualizer for VM based obfuscation.

## Features

- Stack-based virtual machine architecture
- MBA, self-modifying code obfuscation
- Support for both PE* and ELF binaries
- Code markers to define protected regions

*\*PE support only tested on binaries compiled via MinGW-w64*

# Getting started

## Dependencies

`CMake` will fetch all these dependencies, so installing them yourself is not necessary.

| Name | Version |
| ---- | ------- |
| [CMake](https://cmake.org/) | 3.25+ |
| [Zydis](https://github.com/zyantific/zydis) | 4.1.0+ |
| [zasm](https://github.com/zyantific/zasm) | Latest |
| [LIEF](https://github.com/lief-project/LIEF) | 0.15.1+ |

## Building

A `C++23` compatible compiler is required in order to build.

```bash
git clone https://github.com/dmaivel/covirt.git
cd covirt
mkdir build
cd build
cmake ..
cmake --build . --config Release
```

If you are compiling on Windows via Visual Studio, you must use `clang-cl`: `cmake .. -T ClangCL -A x64`.

# Usage

```bash
Usage: covirt [--help] [--version] [--output OUTPUT_PATH] [--vm_code_size MAX] [--vm_stack_size SIZE] [--no_self_modifying_code] [--no_mixed_boolean_arith] [--show_dump_table] INPUT_PATH

Code virtualizer for x86-64 ELF & PE binaries

Positional arguments:
  INPUT_PATH                         path to input binary to virtualize 

Optional arguments:
  -h, --help                         shows help message and exits 
  -v, --version                      prints version information and exits 
  -o, --output OUTPUT_PATH           specify the output file [default: INPUT_PATH.covirt] 
  -vcode, --vm_code_size MAX         specify the maximum allowed total lifted bytes [default: 2048]
  -vstack, --vm_stack_size SIZE      specify the size of the virtual stack [default: 2048]
  -no_smc, --no_self_modifying_code  disable smc pass 
  -no_mba, --no_mixed_boolean_arith  disable mba pass 
  -d, --show_dump_table              show disassembly of the vm instructions
```

## Code markers

For `covirt` to know which functions need to be virtualized, you must add the start and end markers into your source code, like so:

```c
#include "covirt_stub.h"

int my_function(...)
{
    int result = 0;
  
    __covirt_vm_start();
    // ...
    __covirt_vm_end();

    return result;
}
```

> [!IMPORTANT]
>  - Do not place `__covirt_vm_end` in unreachable locations (i.e. after a return), as it will prevent the end stub from emitting
>  - `__covirt_vm_...();` stubs won't work using `MSVC` because they use inline assembly
>  - `SSE4` support is required

## Demo

<img align="right" width="55%" src="media/ss.png">

```c
#include <covirt_stub.h>
#include <stdio.h>

int calculate(int a, int b)
{
    int result = 0;

    __covirt_vm_start();
    
    for (int i = 0; i < 10; i++)
        if (i > 5)
            result += result + a;
        else
            result += (result >> 1) + b;
    printf("result = %d\n", result);

    __covirt_vm_end();

    return result;
}

int main()
{
    calculate(5, 12);
}

```

The example application above was virtualized using `covirt a.out -d`, which outputs a dump of the VM instructions following obfuscation and virtualization. The current VM implementation pushes most operands onto the stack to process them, reducing the complexity of encoding the VM instructions. For instructions that don't have a defined VM handler, they will be executed natively (`vm_exit` -> `native instruction` -> `vm_enter`). Calling functions follows the same pipeline, in which we exit, call the function, and reenter the VM. All together, the transformations make the binaries grow significantly in size:
 - `a.out` as an `ELF`: 15.5 kB -> 1.0 MB
 - `a.out` as a `PE`: 259.3 kB -> 1.3 MB

## Obfuscation

| Description | IDA |
|-|-----------------|
IDA decompilation of `vm_entry`, which has been obfuscated via the MBA pass only. Over 27k LOC were generated by the decompiler. | ![cpp](media/ss2.png)
IDA disassembly of `vm_entry`, which has been obfuscated via the MBA & SMC passes. Decompilation doesn't work. | ![cpp](media/ss3.png)

## Known issues
- **Can't call another VM protected function from within a protected region**
  - Causes segfault if VM is obfuscated
  - No return value if VM isn't obfuscated 

```

`covirt/analysis/basic_block.cpp`:

```cpp
#include "basic_block.hpp"
#include "disasm.hpp"

#include <utils/log.hpp>

#include <queue>
#include <set>

covirt::subroutine covirt::decompose_bb(basic_block &bb)
{
    std::priority_queue<uintptr_t, std::vector<uintptr_t>, std::greater<uintptr_t>> visit;
    std::set<uintptr_t> addresses;

    for (auto& [bytes, ins] : bb)
        if (is_jump(ins)) {
            addresses.insert(zydis_operand(ins.operands[0]).immediate() + ins.runtime_address + ins.info.length);
            if (ins.info.mnemonic != zasm::x86::Mnemonic::Jmp)
                addresses.insert(ins.runtime_address + ins.info.length);
        }

    for (auto &a : addresses)
        visit.push(a);
    visit.push(bb.end_va);

    auto size = visit.size();

    covirt::subroutine result(bb);
    auto current = result.basic_blocks;

    // we need to clear because we copied 'bb', so the first
    // basic block contains every
    //
    current->clear();

    auto start_address = bb.start_va;
    for (int i = 0; i < size; i++) {
        auto end_address = visit.top(); 
        visit.pop();

        current->start_va = start_address;
        current->end_va = end_address;

        // to-do: find more effecient method
        //
        for (auto& [bytes, ins] : bb) {
            if (ins.runtime_address >= start_address && ins.runtime_address < end_address)
                current->push_back({bytes, ins});
        }

        current->next = new covirt::basic_block;
        current = current->next;

        start_address = end_address;

        // we emit one last basic block, which acts as the vm_exit block
        //
        if (visit.empty()) {
            current->start_va = start_address;
            current->end_va = end_address + 1;
        }
    }

    return result;
}
```

`covirt/analysis/basic_block.hpp`:

```hpp
#pragma once

#include <Zydis/Zydis.h>
#include <vector>

namespace covirt {
    class basic_block : public std::vector<std::pair<uint8_t*, ZydisDisassembledInstruction>> {
    public:
        uintptr_t start_va;
        uintptr_t end_va;
        uint32_t offset_into_lift;

        basic_block *next = nullptr;
    };

    class subroutine {
    public:
        subroutine() { }
        subroutine(basic_block &bb) :
            start_va(bb.start_va), end_va(bb.end_va)
        {
            basic_blocks = new basic_block;
            basic_blocks[0] = bb;
        }

        uintptr_t start_va;
        uintptr_t end_va;

        auto length() const { return end_va - start_va; }

        uint32_t offset_into_lift = 0;
        basic_block *basic_blocks = nullptr;
    };

    subroutine decompose_bb(basic_block &bb);
}

```

`covirt/analysis/binary.cpp`:

```cpp
#include "binary.hpp"
#include <utils/log.hpp>

covirt::binary::binary(const std::string &file) : generic(LIEF::Parser::parse(file)), out_path(file + suffix) 
{
    switch (generic->format()) {
    case LIEF::Binary::FORMATS::ELF:
        specific = dynamic_cast<LIEF::ELF::Binary*>(generic.get());
        break;
    case LIEF::Binary::FORMATS::PE:
        specific = dynamic_cast<LIEF::PE::Binary*>(generic.get());
        break;
    default:
        out::assertion(false, "unknown file format");
    }
}

void covirt::binary::add_section(const std::string &string, std::vector<uint8_t> content, bool ex, bool wr)
{
    using enum lief_elf_flags_t;
    using enum lief_pe_flags_t;

    std::visit([&](auto &&x){
        using T = std::decay_t<decltype(x)>;

        if constexpr (std::is_same_v<T, LIEF::ELF::Binary*>) {
            LIEF::ELF::Section new_section(string.c_str());
            new_section.flags(uint64_t(ex ? EXECINSTR : NONE) | uint64_t(wr ? WRITE : NONE));
            new_section.content(content);
            x->add(new_section);
        }
        else if constexpr (std::is_same_v<T, LIEF::PE::Binary*>) {
            LIEF::PE::Section new_section(string.c_str());
            new_section.characteristics(uint64_t(ex ? MEM_EXECUTE : lief_pe_flags_t(0)) | uint64_t(wr ? MEM_WRITE : lief_pe_flags_t(0)));
            new_section.content(content);
            x->add_section(new_section);
        }
    }, specific);

    update();
}

lief_sections_iterator_t covirt::binary::sections()
{
    return std::visit([](auto&& x) { return dynamic_cast<LIEF::Binary*>(x)->sections(); }, specific);
}

bool covirt::binary::is_section_executable(lief_section &section)
{
    return std::visit([&](auto&& x) { 
        using T = std::decay_t<decltype(x)>;

        if constexpr (std::is_same_v<T, LIEF::ELF::Binary*>) 
            return as_elf(section)->has(lief_elf_flags_t::EXECINSTR);
        else if constexpr (std::is_same_v<T, LIEF::PE::Binary*>) 
            return as_pe(section)->has_characteristic(lief_pe_flags_t::MEM_EXECUTE);
    }, specific);
}

uint64_t covirt::binary::imagebase()
{
    return std::visit([](auto&& x) { return x->imagebase(); }, specific);
}

lief_section *covirt::binary::get_section(const std::string &name)
{
    return std::visit([&](auto&& x) {
        auto sections = x->sections();
        auto it = std::find_if(sections.begin(), sections.end(), [&](lief_section &section) { return section.name() == name.c_str(); });
        
        return dynamic_cast<lief_section*>(&(*it));
    }, specific);
}

lief_section *covirt::binary::get_section(uint64_t address)
{
    return std::visit([&](auto&& x) {
        auto sections = x->sections();
        auto it = std::find_if(sections.begin(), sections.end(), [&](lief_section &section) { 
            auto va_start = x->imagebase() + section.virtual_address();
            return address >= va_start && address < va_start + section.size();
        });
        
        return dynamic_cast<lief_section*>(&(*it));
    }, specific);
}

void covirt::binary::update()
{
    std::visit([this](auto&& x) { x->write(out_path); }, specific);
}

void covirt::binary::write_vm_entries(std::vector<covirt::subroutine> &routines, covirt::generic_vm_enter &vm_enter)
{
    auto vm_section = get_section(".covirt0");
    auto section_of_block = get_section(routines[0].start_va);
    auto base = imagebase() + section_of_block->virtual_address();

    std::vector<uint8_t> content;
    auto cc = section_of_block->content();
    content.assign(cc.begin(), cc.end());

    for (auto & routine : routines) {
        for (uintptr_t i = routine.start_va; i < routine.end_va; i++)
            content[i - base] = covirt::rand<uint8_t>();

        auto offset = routine.start_va - base - __covirt_vm_stub_length;

        vm_enter.set_call_offset(base, imagebase() + vm_section->virtual_address(), offset);
        vm_enter.set_vm_bytecode_offset(routine.offset_into_lift);

        auto vm_enter_bytes = vm_enter.get_bytes();

        std::memcpy(&content[offset], vm_enter_bytes.get(), vm_enter.get_length());
        section_of_block->content(content);
    }

    section_of_block->content(content);
}

void covirt::binary::write_vm_bytecode(std::vector<uint8_t> &lifted_bytes, std::vector<uint8_t> &vm_section_bytes, size_t data_start, size_t vcode_size)
{
    auto vm_section = get_section(".covirt0");
    std::memcpy(&vm_section_bytes[data_start], &lifted_bytes[0], lifted_bytes.size());
    for (int i = 0; i < vcode_size - lifted_bytes.size(); i++)
        vm_section_bytes[data_start + lifted_bytes.size() + i] = covirt::rand<uint8_t>();
    vm_section->content(vm_section_bytes);
    update();
}
```

`covirt/analysis/binary.hpp`:

```hpp
#pragma once

#include <LIEF/LIEF.hpp>
#include <LIEF/ELF/Binary.hpp>
#include <LIEF/ELF/Section.hpp>
#include <LIEF/PE/Binary.hpp>
#include <LIEF/PE/Section.hpp>

#include <memory>
#include <variant>
#include <print>

#include <covirt_stub.h>

#include "basic_block.hpp"

#include <utils/rand.hpp>
#include <compiler/generic_vm_enter.hpp>

/*
 * stupid lief wrapper to look nice and abstraction
 */

using lief_elf_flags_t = LIEF::ELF::Section::FLAGS;
using lief_pe_flags_t = LIEF::PE::Section::CHARACTERISTICS;
using lief_sections_iterator_t = LIEF::Binary::it_sections;
using lief_section = LIEF::Section;

namespace covirt {
    class binary {
    public:
        std::string suffix = ".covirt";

        binary(const std::string &file);

        void set_out_path(const std::string &out)
        {
            out_path = out;
        }

        void add_section(const std::string &string, std::vector<uint8_t> content, bool ex, bool wr);
        lief_sections_iterator_t sections();
        bool is_section_executable(lief_section &section);
        uint64_t imagebase();
        lief_section *get_section(const std::string &name);
        lief_section *get_section(uint64_t address);
        void update();
        void write_vm_entries(std::vector<covirt::subroutine> &routines, covirt::generic_vm_enter &vm_enter);
        void write_vm_bytecode(std::vector<uint8_t> &lifted_bytes, std::vector<uint8_t> &vm_section_bytes, size_t data_start, size_t vcode_size);
        
    private:
        std::string out_path;

        // generic can't go out of scope, or else silly seg faults
        //
        std::unique_ptr<LIEF::Binary> generic;
        std::variant<LIEF::ELF::Binary*, LIEF::PE::Binary*> specific;

        LIEF::ELF::Section* as_elf(LIEF::Section &section) { return dynamic_cast<LIEF::ELF::Section*>(&section); }
        LIEF::PE::Section* as_pe(LIEF::Section &section) { return dynamic_cast<LIEF::PE::Section*>(&section); }
    };
}

```

`covirt/analysis/disasm.cpp`:

```cpp
#include "disasm.hpp"

#include <utils/log.hpp>
#include <print>

covirt::zydis_operand::zydis_operand(ZydisDecodedOperand &op)
{
    assign(op);
}

void covirt::zydis_operand::assign(ZydisDecodedOperand &op)
{
    size = op.size / 8;
    switch (op.type) {
    case ZYDIS_OPERAND_TYPE_REGISTER: value = op.reg; break;
    case ZYDIS_OPERAND_TYPE_IMMEDIATE: value = op.imm; break;
    case ZYDIS_OPERAND_TYPE_MEMORY: value = op.mem; break;
    default: value = std::monostate{}; break;
    }
}

int covirt::zydis_operand::register_index(bool use_index)
{
    auto reg = ZYDIS_REGISTER_NONE;

    if (is_register()) reg = as_register().value;
    if (is_memory()) reg = !use_index ? as_memory().base : as_memory().index;
    
    out::assertion(reg != ZYDIS_REGISTER_NONE, "zydis_operand isn't a register");

    switch (reg) {
    case ZYDIS_REGISTER_AL ... ZYDIS_REGISTER_R15B: return reg - ZYDIS_REGISTER_AL;
    case ZYDIS_REGISTER_AX ... ZYDIS_REGISTER_R15W: return reg - ZYDIS_REGISTER_AX;
    case ZYDIS_REGISTER_EAX ... ZYDIS_REGISTER_R15D: return reg - ZYDIS_REGISTER_EAX;
    case ZYDIS_REGISTER_RAX ... ZYDIS_REGISTER_R15: return reg - ZYDIS_REGISTER_RAX;
    default: return -1;
    }
}

void covirt::disasm(std::span<const uint8_t> content, uint64_t base_address, std::function<void(uint64_t, ZydisDisassembledInstruction)> callback)
{
    ZydisDisassembledInstruction ins;
    size_t offset = 0;

    while (ZYAN_SUCCESS(ZydisDisassembleIntel(
        ZYDIS_MACHINE_MODE_LONG_64,
        base_address,
        &content[0] + offset,
        content.size() - offset,
        &ins
    ))) {
        callback(base_address, ins);
        
        base_address += ins.info.length;
        offset += ins.info.length;
    }
}

```

`covirt/analysis/disasm.hpp`:

```hpp
#pragma once

#include "basic_block.hpp"
#include "zasm/x86/mnemonic.hpp"

#include <utils/log.hpp>

#include <span>
#include <functional>
#include <variant>

#include <zasm/zasm.hpp>

namespace covirt {
    using zydis_reg = ZydisDecodedOperandReg_;
    using zydis_imm = ZydisDecodedOperandImm_;
    using zydis_mem = ZydisDecodedOperandMem_;

    struct zydis_operand {
        zydis_operand() {}
        zydis_operand(ZydisDecodedOperand &op);

        std::variant<std::monostate, zydis_reg, zydis_imm, zydis_mem> value;
        size_t size;

        std::optional<basic_block*> references_bb;
        std::optional<uintptr_t> references_rva;

        void assign(ZydisDecodedOperand &op);

        constexpr bool is_register() {  return std::holds_alternative<zydis_reg>(value); }
        constexpr bool is_immediate() { return std::holds_alternative<zydis_imm>(value); }
        constexpr bool is_memory() {    return std::holds_alternative<zydis_mem>(value); }
        constexpr bool is_empty() {     return std::holds_alternative<std::monostate>(value); }

        constexpr auto as_register() {  return std::get<zydis_reg>(value); }
        constexpr auto as_immediate() { return std::get<zydis_imm>(value); }
        constexpr auto as_memory() {    return std::get<zydis_mem>(value); }

        int register_index(bool use_index = false);
        
        constexpr int64_t immediate()
        {
            out::assertion(is_immediate(), "zydis_operand is not an immediate");
            return as_immediate().value.s;
        }
    };

    void disasm(std::span<const uint8_t> content, uint64_t base_address, std::function<void(uint64_t, ZydisDisassembledInstruction)> callback);

    constexpr bool is_jump(ZydisDisassembledInstruction &ins) { return ins.info.mnemonic >= zasm::x86::Mnemonic::Jb && ins.info.mnemonic <= zasm::x86::Mnemonic::Jz; }
    constexpr bool is_jcc(ZydisDisassembledInstruction &ins) { return is_jump(ins) && ins.info.mnemonic != zasm::x86::Mnemonic::Jmp; }
}

```

`covirt/compiler/default_vm_enter.cpp`:

```cpp
#include "default_vm_enter.hpp"
#include <cstring>
#include <memory>

// sub rsp, 0x200
// push <offset_into_lifted_bytes>
// call <vm_entry>
//
uint8_t covirt::default_vm_enter::vm_enter[] = { 0x48, 0x81, 0xEC, 0x00, 0x02, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0xe8, 0x00, 0x00, 0x00, 0x00 };

std::unique_ptr<uint8_t> covirt::default_vm_enter::get_bytes()
{
    auto result_vm_enter = std::make_unique<uint8_t>(get_length());
    
    *(uint32_t*)&vm_enter[8] = lift_offset;
    *(uint32_t*)&vm_enter[13] = call_offset;

    std::memcpy(result_vm_enter.get(), vm_enter, get_length());
    return std::move(result_vm_enter);
}

size_t covirt::default_vm_enter::get_length()
{
    return sizeof(vm_enter);
}

void covirt::default_vm_enter::assemble_effects(zasm::x86::Assembler &a)
{
    a.sub(zasm::x86::rsp, 0x200);
}

void covirt::default_vm_enter::revert_effects(zasm::x86::Assembler &a)
{
    a.add(zasm::x86::rsp, 0x200);
}
```

`covirt/compiler/default_vm_enter.hpp`:

```hpp
#pragma once 

#include "generic_vm_enter.hpp"

namespace covirt {
    class default_vm_enter : public generic_vm_enter {
    public:
        std::unique_ptr<uint8_t> get_bytes() override;
        size_t get_length() override;
        void assemble_effects(zasm::x86::Assembler &a) override;
        void revert_effects(zasm::x86::Assembler &a) override;
    private:
        static uint8_t vm_enter[];
    };
}
```

`covirt/compiler/generic_emitter.hpp`:

```hpp
#pragma once

#include <cassert>
#include <cstdint>
#include <vector>
#include <variant>

#include <utils/log.hpp>

namespace covirt {
    class generic_emitter {
    protected:
        std::vector<uint8_t> bytes;
        int count = 0;
        int cached_size = 0;

    public:
        constexpr std::vector<uint8_t>& get() { return bytes; }
        constexpr int get_count() const { return count; }

        template <typename O, typename S, typename... Tx>
        std::vector<uint8_t> emit(O opcode, S size, Tx&&... args)
        {
            bytes.push_back(opcode(opcode, size));

            ([&](auto &x) {
                bytes.insert(bytes.end(), reinterpret_cast<uint8_t*>(&x), reinterpret_cast<uint8_t*>(&x) + sizeof(x));
            }(args), ...);
        }

        template <typename O, typename S>
        uint8_t opcode(O opcode, S size)
        {
            static constexpr auto encode_size = []<typename X>(X x, int &cached_size) -> uint8_t {
                static_assert(std::is_same_v<X, int> || std::is_same_v<X, size_t>, "expected int size");
                cached_size = int(x);

                switch (x) {
                case 1: return 0b00 << 6;
                case 2: return 0b01 << 6;
                case 4: return 0b10 << 6;
                case 8: return 0b11 << 6;
                }

                return 0;
            };

            count++;
            return static_cast<uint8_t>(uint8_t(opcode) | encode_size(size, cached_size));
        }

        template <typename T>
        std::variant<uint8_t, uint16_t, uint32_t, uint64_t> cast(T x, std::optional<size_t> size_override = {}) const
        {
            auto size = size_override.value_or(cached_size);

            switch (size) {
            case 1: return uint8_t(x);
            case 2: return uint16_t(x);
            case 4: return uint32_t(x);
            case 8: return uint64_t(x);
            }

            return uint32_t(x);
        }

        template <typename T>
        auto& operator >> (T x) 
        {
            bytes.insert(bytes.end(), reinterpret_cast<uint8_t*>(&x), reinterpret_cast<uint8_t*>(&x) + sizeof(T));
            return *this;
        }

        auto& operator >> (std::variant<uint8_t, uint16_t, uint32_t, uint64_t> x) 
        {
            std::visit([this](auto &&x) {
                bytes.insert(bytes.end(), reinterpret_cast<uint8_t*>(&x), reinterpret_cast<uint8_t*>(&x) + sizeof(x));
            }, x);
            return *this;
        }

        template <typename... Tx>
        void emplace(Tx&&... args)
        {
            ((*this) >> ... >> std::forward<Tx>(args));
        }
    };
}
```

`covirt/compiler/generic_lifter.cpp`:

```cpp
#include "generic_lifter.hpp"
#include "analysis/basic_block.hpp"

#include <utils/log.hpp>
#include <covirt_stub.h>

// clear??
//
static inline covirt::basic_block *get_bb_which_address_resides_in(covirt::subroutine &routine, uintptr_t addr)
{
    for (auto bb = routine.basic_blocks; bb != nullptr; bb = bb->next) {
        if (addr >= bb->start_va && addr < bb->end_va)
            return bb;
    }

    return nullptr;
}

covirt::lift_result covirt::lift(std::vector<covirt::subroutine> &routines, generic_lifter &lifter, generic_vm &vm)
{
    auto table = lifter.get_translation_table();
    dump_index_table_t dump_index_table;

    auto vm_entry_length = vm.get_vm_enter().get_length();

    for (auto & bb_routine : routines) {
        auto bb_length = bb_routine.length() + __covirt_vm_stub_length + __covirt_vm_stub_length;
        auto bb_unused_length = bb_length - vm_entry_length;

        bb_routine.offset_into_lift = lifter.get_emitter().get().size();

        for (auto bb = bb_routine.basic_blocks; bb != nullptr; bb = bb->next) {
            bb->offset_into_lift = lifter.get_emitter().get().size();

            int skip = 0;
            for (auto& [bytes, ins] : *bb) {
                auto fn_translate = table[ins.info.mnemonic];
                auto retaddr = bb_routine.start_va - __covirt_vm_stub_length + vm_entry_length;

                bool liftable_and_lifted = fn_translate != nullptr;

                dump_index_table[lifter.get_emitter().get_count()] = ins.text;

                if (liftable_and_lifted) {
                    zydis_operand dst(ins.operands[0]);
                    zydis_operand src(ins.operands[1]);

                    if (is_jump(ins)) {
                        dst.references_bb = get_bb_which_address_resides_in(bb_routine, dst.immediate() + ins.runtime_address + ins.info.length);
                        out::assertion(dst.references_bb.value() != nullptr, "attempted to jump out of the protected region");
                    }
                    else if (ins.info.mnemonic == ZYDIS_MNEMONIC_LEA && src.is_memory()) {
                        // assumes 'base' is rip, because if it isn't fn_translate will fail
                        //
                        // we want to translate the rva from:
                        // [rva relative to current rip] => [rva relative to retaddr]
                        //
                        // (old_addr+old_disp)−(new_addr)
                        // + ins.info.length so that we don't have to calc in the vm

                        dst.references_rva = (ins.runtime_address + src.as_memory().disp.value) - retaddr + ins.info.length;
                    }
                    else if (ins.info.mnemonic == ZYDIS_MNEMONIC_CALL) {
                        // same concept as before, we need an rva relative to the retaddr
                        //
                        dst.references_rva = ((ins.runtime_address + dst.immediate()) - retaddr + ins.info.length);
                    }

                    if (!fn_translate(dst, src))
                        liftable_and_lifted = false;
                }

                if (!liftable_and_lifted) {
                    lifter.native(bytes, ins.info.length);
                    out::warn("instruction '{}' has no defined vm handler, will execute natively", out::name(ins.text));
                }

                skip += ins.info.length;
            }
        }

        lifter.vm_exit(bb_unused_length);
    }

    // fill in jumps inside of the lifted bytecode
    //
    auto& bytecode = lifter.get_emitter().get();
    for (auto& fill_in : lifter.get_fill_in_gaps()) {
        size_t bb_offset = fill_in.bb->offset_into_lift;
        // std::memcpy(&bytecode[fill_in.offset_write_into_lift], &bb_offset, fill_in.size);
        *(uint16_t*)&bytecode[fill_in.offset_write_into_lift] = fill_in.bb->offset_into_lift;
    }

    out::info("generated {} total vm instructions", out::value(lifter.get_emitter().get_count()));

    // to-do: the copy here is sub-optimal, pass around as reference instead without crashing?
    //
    return covirt::lift_result{ lifter.get_emitter().get(), dump_index_table };
}
```

`covirt/compiler/generic_lifter.hpp`:

```hpp
#pragma once

#include "generic_emitter.hpp"
#include "generic_vm.hpp"

#include <analysis/basic_block.hpp>
#include <analysis/disasm.hpp>

#include <functional>
#include <map>
#include <string>

namespace covirt {
    using fn_instruction_translator_t = std::function<bool(covirt::zydis_operand&, covirt::zydis_operand&)>;
    using dump_index_table_t = std::map<int, std::string>;
    using fn_dump_t = std::function<void(std::vector<uint8_t>&, dump_index_table_t&)>;

    struct lift_result {
        std::vector<uint8_t> bytes;
        dump_index_table_t dump_index_table;
    };

    class generic_lifter {
    protected:
        struct fill_in_data {
            // basic block that we need to jump to
            //
            basic_block *bb;

            // offset into the lifted bytecode that we need to write
            // this value into
            //
            size_t offset_write_into_lift;

            // sizeof basically
            // 
            size_t size;
        };

        std::vector<fill_in_data> fill_in_gaps;
    public:
        virtual std::map<ZydisMnemonic, fn_instruction_translator_t>& get_translation_table() = 0;
        virtual void vm_exit(uint16_t bytes_to_skip) = 0;
        virtual void native(uint8_t *ins_bytes, size_t length) = 0;
        virtual generic_emitter& get_emitter() = 0;

        auto get_fill_in_gaps() { return fill_in_gaps; }
    };

    lift_result lift(std::vector<covirt::subroutine> &routines, covirt::generic_lifter &lifter, covirt::generic_vm &vm);
}
```

`covirt/compiler/generic_vm.cpp`:

```cpp
#include "generic_vm.hpp"
#include <utils/log.hpp>

constexpr std::size_t page_size = 4096;
#define PAGE_ROUND_DOWN(x) (x & (~(page_size-1)))
#define PAGE_ROUND_UP(x) ((x + page_size-1) & (~(page_size-1))) 

std::pair<std::vector<uint8_t>, std::size_t> covirt::generic_vm::assemble(std::vector<generic_transform_pass*> &passes)
{
    zasm::Program program(zasm::MachineMode::AMD64);
    zasm::x86::Assembler assembler(program);
    zasm::Serializer serializer{};

    initialize(assembler);
    for (auto && [opcode, handler] : get_handlers())
        handler(assembler);
    finalize(assembler);

    for (auto &apply_transform : passes)
        apply_transform->pass(program, assembler);

    auto res = serializer.serialize(program, 0);
    out::assertion(res == zasm::ErrorCode::None, "failed to serialize vm: {}:{}", res.getErrorName(), res.getErrorMessage());

    size_t size = 0;
    for (int i = 0; i < serializer.getSectionCount(); i++)
        size += serializer.getSectionInfo(i)->virtualSize;

    std::vector<uint8_t> bytes;
    auto v0 = std::vector<uint8_t>(serializer.getCode() + serializer.getSectionInfo(0)->offset, serializer.getCode() + serializer.getSectionInfo(0)->offset + serializer.getSectionInfo(0)->physicalSize);
    auto v1 = std::vector<uint8_t>(serializer.getCode() + serializer.getSectionInfo(1)->offset, serializer.getCode() + serializer.getSectionInfo(1)->offset + serializer.getSectionInfo(1)->physicalSize);
    bytes.insert(bytes.end(), v0.begin(), v0.end());

    size_t data_start = PAGE_ROUND_UP(bytes.size());
    for (auto i = bytes.size(); i < data_start; i++)
        bytes.push_back(covirt::rand<uint8_t>());
    bytes.insert(bytes.end(), v1.begin(), v1.end());
    
    return { bytes, data_start };
}
```

`covirt/compiler/generic_vm.hpp`:

```hpp
#pragma once

#include "generic_vm_enter.hpp"

#include <utils/rand.hpp>
#include <obfuscator/generic_transform.hpp>

#include <functional>
#include <map>
#include <print>
#include <zasm/zasm.hpp>

namespace covirt {
    // to-do: make vm_handler_t return this
    //
    struct vm_handler_metadata {
        std::vector<zasm::x86::Reg> available_registers;

        // to-do: add more bloat here
        //
    };
    
    using fn_vm_handler_t = std::function<void(zasm::x86::Assembler &)>;
    
    // to-do: support opcodes beyond uint8_t?
    //
    class generic_vm {
    public:
        // first function that gets called; label creation
        //
        virtual void initialize(zasm::x86::Assembler &a) = 0;

        // middle function; output handlers
        // 
        virtual std::map<uint8_t, fn_vm_handler_t>& get_handlers() = 0;

        // last function that gets called; data setup
        // 
        virtual void finalize(zasm::x86::Assembler &a) = 0;

        // get the vm_enter emitter
        //
        virtual generic_vm_enter& get_vm_enter() = 0;

        // set size of code "section"
        //
        virtual void set_code_size(size_t size) = 0;

        // set size of stack "section"
        //
        virtual void set_stack_size(size_t size) = 0;

        // assemble
        //
        std::pair<std::vector<uint8_t>, std::size_t> assemble(std::vector<generic_transform_pass*> &transform_passes);
    };
}
```

`covirt/compiler/generic_vm_enter.hpp`:

```hpp
#pragma once

#include <zasm/zasm.hpp>

#include <memory>

namespace covirt {
    class generic_vm_enter {
    public:
        void set_call_offset(uintptr_t base_of_call, uintptr_t base_of_vm, uintptr_t offset_of_call)
        {
            call_offset = base_of_vm - (base_of_call + offset_of_call) - get_length();
        }

        void set_vm_bytecode_offset(uintptr_t offset_into_lift)
        {
            lift_offset = offset_into_lift;
        }

        virtual std::unique_ptr<uint8_t> get_bytes() = 0;
        virtual size_t get_length() = 0;

        // this is used to assemble everything that comes before `push, call`
        //
        virtual void assemble_effects(zasm::x86::Assembler &a) = 0;

        // if the vm_enter modified any registers before jumping to vm_entry,
        // this function should provide the instructions to revert such changes
        //
        virtual void revert_effects(zasm::x86::Assembler &a) = 0;
    protected:
        uintptr_t call_offset = 0;
        uintptr_t lift_offset = 0;
    };
}
```

`covirt/main.cpp`:

```cpp
#include <analysis/binary.hpp>
#include <obfuscator/passes/smc_pass.hpp>
#include <obfuscator/passes/mba_pass.hpp>
#include <utils/log.hpp>
#include <vm/v0.hpp>

#include <utils/argparse.hpp>

#include <filesystem>
#include "version.h"

int main(int argc, char **argv)
{
    int stack_size = 0;
    int code_size = 0;

    argparse::ArgumentParser program("covirt", COVIRT_VERSION);
    program.add_argument("file_input").help("path to input binary to virtualize").metavar("INPUT_PATH");
    program.add_argument("-o", "--output")
           .help("specify the output file [default: INPUT_PATH.covirt]")
           .metavar("OUTPUT_PATH")
           .nargs(1);
    program.add_argument("-vcode", "--vm_code_size")
           .default_value(int(2048))
           .help("specify the maximum allowed total lifted bytes")
           .metavar("MAX")
           .nargs(1)
           .store_into(code_size);
    program.add_argument("-vstack", "--vm_stack_size")
           .default_value(int(2048))
           .help("specify the size of the virtual stack")
           .metavar("SIZE")
           .nargs(1)
           .store_into(stack_size);
    program.add_argument("-no_smc", "--no_self_modifying_code")
           .default_value(false)
           .implicit_value(true)
           .help("disable smc pass");
    program.add_argument("-no_mba", "--no_mixed_boolean_arith")
           .default_value(false)
           .implicit_value(true)
           .help("disable mba pass");
    program.add_argument("-d", "--show_dump_table")
           .default_value(false)
           .implicit_value(true)
           .help("show disassembly of the vm instructions");
    program.add_description("Code virtualizer for x86-64 ELF & PE binaries");

    try {
        program.parse_args(argc, argv);
    }
    catch (const std::exception& err) {
        out::fail("{}\n\n{}", err.what(), program.help().str());
        return 0;
    }

    auto input_file_path = program.get("file_input");

    if (!std::filesystem::exists(input_file_path) || !std::filesystem::is_regular_file(input_file_path)) {
        std::println("{} no such file exists, or is a directory: '{}'", out::bad("fatal error:"), input_file_path);
        return 0;
    }

    covirt::binary file(input_file_path);
    try { file.set_out_path(program.get("-o")); } catch (...) { }

    covirt::vm::v0_vm x;
    x.set_code_size(uint32_t(code_size));
    x.set_stack_size(uint32_t(stack_size));

    std::vector<covirt::generic_transform_pass*> passes;

    if (!program.get<bool>("-no_smc")) passes.push_back(new covirt::smc_pass());
    if (!program.get<bool>("-no_mba")) passes.push_back(new covirt::mba_pass());

    if (!passes.empty()) out::info("obfuscating virtual machine...");
    else out::warn("assembling vm without any obfuscation passes");

    auto [bytes, data_start] = x.assemble(passes);
    file.add_section(".covirt0", bytes, true, true);

    std::vector<covirt::basic_block> basic_blocks;
    for (auto& section : file.sections()) {
        if (file.is_section_executable(section)) {
            auto content = section.content();
            auto runtime_address = file.imagebase() + section.virtual_address();
            auto bb = covirt::basic_block{};
            
            covirt::disasm(content, runtime_address, [&](uint64_t address, ZydisDisassembledInstruction ins) {
                auto offset = address - runtime_address; 

                if (std::memcmp(&content[0] + offset - 16, __covirt_vm_start_bytes, 16) == 0)
                    bb.start_va = address;
                if (std::memcmp(&content[0] + offset, __covirt_vm_end_bytes, 16) == 0)
                    bb.end_va = address;

                if (bb.end_va) {
                    out::assertion(bb.start_va, "binary appears to be missing marker '__covirt_vm_start()'");
                    basic_blocks.push_back(bb);
                    bb = {};
                }

                if (bb.start_va)
                    bb.push_back({(uint8_t*)content.data() + offset, ins});
            });

            out::assertion(!(bb.start_va && !bb.end_va), "binary appears to be missing marker '__covirt_vm_end()'");
        }
    }

    out::assertion(!basic_blocks.empty(), "found no code markers in binary");

    std::vector<covirt::subroutine> routines;
    for (auto& bb : basic_blocks)
        routines.push_back(decompose_bb(bb));
    
    size_t count = 0;
    for (auto& r : routines)
        for (auto bb = r.basic_blocks; bb != nullptr; bb = bb->next)
            count++;

    out::info("found {} regions which decomposed into {} total basic blocks", out::value(basic_blocks.size()), out::value(count));

    covirt::vm::v0_lifter lifter;
    auto lifted = lift(routines, lifter, x);

    out::assertion(lifted.bytes.size() < code_size, "ran out of code space, try using '-vcode {}'", lifted.bytes.size() + 1);

    if (program.get<bool>("-d"))
        covirt::vm::debug::dump_v0(lifted);

    file.write_vm_entries(routines, x.get_vm_enter());
    file.write_vm_bytecode(lifted.bytes, bytes, data_start, code_size);

    out::ok("virtualization complete");
}

```

`covirt/obfuscator/expression.cpp`:

```cpp
#include "expression.hpp"

std::pair<zasm::Node*, size_t> expression::assemble_steps(zasm::x86::Assembler &a, zasm::Operand &A, zasm::Operand &B, std::vector<zasm::x86::Gp> &avail_registers, size_t size, std::optional<zasm::Label> label)
{
    std::vector<asm_step> steps;
    assemble_steps_state state(avail_registers);

    auto result = generate_asm_steps(A, B, steps, state, size);

    constexpr auto binop_safe_to_rotate = [](char op) -> bool {
        switch (op) {
        case '+': 
        case '-':
            return false;
        case '^': 
        case '&': 
        case '|': 
        case '~':
            return true;
        default:
            return false;
        }
    };

    for (auto &step : steps)
        std::visit([&](auto &&x) {
            using T = std::decay_t<decltype(x)>;

            auto rot = covirt::rand<uint8_t>();
            auto rot_op = zasm::Operand(zasm::Imm(rot));
            auto rot_op_x86 = to_x86_type(rot_op, 8);

            if constexpr (std::is_same_v<T, binary_asm>) {
                auto dst = to_x86_type(x.dst, size);
                auto lhs = to_x86_type(x.lhs, size);
                auto rhs = to_x86_type(x.rhs, size);

                safe_asm(a, [](auto &a, auto &dst, auto &src) { a.mov(dst, src); }, dst, lhs);

                if (binop_safe_to_rotate(x.op)) {
                    if (std::holds_alternative<zasm::x86::Gp>(lhs) && std::holds_alternative<zasm::x86::Gp>(rhs)) {
                        safe_rot(a, [](auto &a, auto &dst, auto &src) { a.rol(dst, src); }, dst, rot_op_x86);
                        safe_rot(a, [](auto &a, auto &dst, auto &src) { a.rol(dst, src); }, rhs, rot_op_x86);
                    }
                } else {
                    // if its not safe to rotate, we just put in a dummy rotation. this still manages to mess up ida
                    //
                    if (std::holds_alternative<zasm::x86::Gp>(lhs) && std::holds_alternative<zasm::x86::Gp>(rhs)) {
                        safe_rot(a, [](auto &a, auto &dst, auto &src) { a.rol(dst, src); }, dst, rot_op_x86);
                        safe_rot(a, [](auto &a, auto &dst, auto &src) { a.rol(dst, src); }, rhs, rot_op_x86);
                        safe_rot(a, [](auto &a, auto &dst, auto &src) { a.ror(dst, src); }, dst, rot_op_x86);
                        safe_rot(a, [](auto &a, auto &dst, auto &src) { a.ror(dst, src); }, rhs, rot_op_x86);
                    }
                }

                switch (x.op) {
                case '+': safe_asm(a, [](auto &a, auto &dst, auto &src) { a.add(dst, src); }, dst, rhs); break;
                case '-': safe_asm(a, [](auto &a, auto &dst, auto &src) { a.sub(dst, src); }, dst, rhs); break;
                case '^': safe_asm(a, [](auto &a, auto &dst, auto &src) { a.xor_(dst, src); }, dst, rhs); break;
                case '&': safe_asm(a, [](auto &a, auto &dst, auto &src) { a.and_(dst, src); }, dst, rhs); break;
                case '|': safe_asm(a, [](auto &a, auto &dst, auto &src) { a.or_(dst, src); }, dst, rhs); break;
                }

                if (binop_safe_to_rotate(x.op)) {
                    if (std::holds_alternative<zasm::x86::Gp>(lhs) && std::holds_alternative<zasm::x86::Gp>(rhs) ) {
                        safe_rot(a, [](auto &a, auto &dst, auto &src) { a.ror(dst, src); }, dst, rot_op_x86);
                        safe_rot(a, [](auto &a, auto &dst, auto &src) { a.ror(dst, src); }, rhs, rot_op_x86);
                    }
                } else {
                    if (std::holds_alternative<zasm::x86::Gp>(lhs) && std::holds_alternative<zasm::x86::Gp>(rhs)) {
                        safe_rot(a, [](auto &a, auto &dst, auto &src) { a.rol(dst, src); }, dst, rot_op_x86);
                        safe_rot(a, [](auto &a, auto &dst, auto &src) { a.rol(dst, src); }, rhs, rot_op_x86);
                        safe_rot(a, [](auto &a, auto &dst, auto &src) { a.ror(dst, src); }, dst, rot_op_x86);
                        safe_rot(a, [](auto &a, auto &dst, auto &src) { a.ror(dst, src); }, rhs, rot_op_x86);
                    }
                }
            }
            else if constexpr (std::is_same_v<std::decay_t<decltype(x)>, unary_asm>) {
                auto dst = to_x86_type(x.dst, size);
                auto src = to_x86_type(x.operand, size);

                safe_asm(a, [](auto &a, auto &dst, auto &src) { a.mov(dst, src); }, dst, src);
                
                if (binop_safe_to_rotate(x.op) && std::holds_alternative<zasm::x86::Gp>(dst))
                    safe_rot(a, [](auto &a, auto &dst, auto &src) { a.rol(dst, src); }, dst, rot_op_x86);
                else {
                    safe_rot(a, [](auto &a, auto &dst, auto &src) { a.rol(dst, src); }, dst, rot_op_x86);
                    safe_rot(a, [](auto &a, auto &dst, auto &src) { a.ror(dst, src); }, dst, rot_op_x86);
                }

                switch (x.op) {
                case '-': safe_asm(a, [](auto &a, auto &dst, auto &src) { a.neg(dst); }, dst, dst); break;
                case '~': safe_asm(a, [](auto &a, auto &dst, auto &src) { a.not_(dst); }, dst, dst); break;
                }

                if (binop_safe_to_rotate(x.op) && std::holds_alternative<zasm::x86::Gp>(dst))
                    safe_rot(a, [](auto &a, auto &dst, auto &src) { a.ror(dst, src); }, dst, rot_op_x86);
                else {
                    safe_rot(a, [](auto &a, auto &dst, auto &src) { a.rol(dst, src); }, dst, rot_op_x86);
                    safe_rot(a, [](auto &a, auto &dst, auto &src) { a.ror(dst, src); }, dst, rot_op_x86);
                }
            }
        }, step);

    auto x = to_x86_type(A, size);
    auto y = to_x86_type(result, size);
    safe_asm(a, [label](auto &a, auto &dst, auto &src) { a.mov(dst, src); }, x, y);
    if (label.has_value())
        a.bind(label.value());

    auto saved_count = asm_count;
    asm_count = 0;

    return { a.getCursor(), saved_count };
}

std::string expression::to_string() const 
{
    if (std::holds_alternative<std::string>(data)) {
        return std::get<std::string>(data);
    } else if (std::holds_alternative<size_t>(data)) {
        return std::to_string(std::get<size_t>(data));
    } else if (std::holds_alternative<binary_op>(data)) {
        const auto& op = std::get<binary_op>(data);
        return "(" + op.lhs->to_string() + op.op + op.rhs->to_string() + ")";
    } else {
        const auto& op = std::get<unary_op>(data);
        return std::string() + op.op + "(" + op.operand->to_string() + ")";
    }
}

std::variant<zasm::Imm, zasm::x86::Gp, zasm::x86::Mem> expression::to_x86_type(zasm::Operand &op, size_t size)
{
    if (op.holds<zasm::Imm>()) {
        return op.get<zasm::Imm>();
    } else if (op.holds<zasm::Reg>()) {
        auto reg = op.get<zasm::Reg>().as<zasm::x86::Reg>().as<zasm::x86::Gp>();
        switch (size) {
        case 8: return reg.r8lo();
        case 16: return reg.r16();
        case 32: return reg.r32();
        case 64: return reg.r64();
        }
    } else if (op.holds<zasm::Mem>()) {
        return op.get<zasm::x86::Mem>();
    } else {
        out::assertion(false, "unsupported operand type");
    }
    return {};
}

zasm::Operand expression::generate_asm_steps(zasm::Operand &A, zasm::Operand &B, std::vector<asm_step>& steps, assemble_steps_state &state, size_t size) const 
{
    if (std::holds_alternative<std::string>(data)) {
        // to-do: don't hardcode "A"
        //
        return std::get<std::string>(data) == "A" ? A : B;
    } else if (std::holds_alternative<size_t>(data)) {
        auto value = std::get<size_t>(data);
        switch (size) {
        case 8: return zasm::Imm8(int8_t(value));
        case 16: return zasm::Imm16(int16_t(value));
        case 32: 
        case 64: return zasm::Imm32(int32_t(value));
        }
    } else if (std::holds_alternative<binary_op>(data)) {
        const auto& op = std::get<binary_op>(data);
        auto lhs = op.lhs->generate_asm_steps(A, B, steps, state, size);
        auto rhs = op.rhs->generate_asm_steps(A, B, steps, state, size);
        
        state.throw_away_register(lhs);
        auto result_reg = state.collect_register();
        steps.push_back(binary_asm{op.op, result_reg, lhs, rhs});

        state.throw_away_register(rhs);

        return result_reg;
    } else {
        const auto& op = std::get<unary_op>(data);
        auto operand = op.operand->generate_asm_steps(A, B, steps, state, size);

        state.throw_away_register(operand);
        auto result_reg = state.collect_register();
        steps.push_back(unary_asm{op.op, result_reg, operand});

        return result_reg;
    }

    out::assertion(false, "unexpectedly reached unreachable code path");
    return {};
}

expression expression::transform_impl(const expression& match, const expression& new_expr) const 
{
    if (equals(match))
        return new_expr;

    if (std::holds_alternative<binary_op>(data)) {
        const auto& op = std::get<binary_op>(data);
        auto new_lhs = op.lhs->transform_impl(match, new_expr);
        auto new_rhs = op.rhs->transform_impl(match, new_expr);
        return expression(op.op, new_lhs, new_rhs);
    } else if (std::holds_alternative<unary_op>(data)) {
        const auto& op = std::get<unary_op>(data);
        auto new_operand = op.operand->transform_impl(match, new_expr);
        return expression(op.op, new_operand);
    } else {
        return *this;
    }
}
```

`covirt/obfuscator/expression.hpp`:

```hpp
#pragma once 

#include <functional>
#include <memory>
#include <optional>
#include <vector>
#include <map>
#include <expected>

#include <zasm/zasm.hpp>
#include <utils/log.hpp>
#include <utils/rand.hpp>

class expression {
public:
    expression() {}

    expression(const std::string& name) : data(name) {}

    expression(size_t constant) : data(constant) {}

    expression(char op, const expression& lhs, const expression& rhs)
        : data(binary_op{op, std::make_shared<expression>(lhs), std::make_shared<expression>(rhs)}) {}

    expression(char op, const expression& operand)
        : data(unary_op{op, std::make_shared<expression>(operand)}) {}

    expression operator+(const expression& other) const { return expression('+', *this, other); }
    expression operator-(const expression& other) const { return expression('-', *this, other); }
    expression operator*(const expression& other) const { return expression('*', *this, other); }
    expression operator&(const expression& other) const { return expression('&', *this, other); }
    expression operator|(const expression& other) const { return expression('|', *this, other); }
    expression operator^(const expression& other) const { return expression('^', *this, other); }

    expression operator~() const { return expression('~', *this); }
    expression operator-() const { return expression('-', *this); }

    expression transform(const expression& match, const expression& new_expr) const { return transform_impl(match, new_expr); }

    template <typename T>
    static expression transform_constant(T target, int depth = 1) 
    {
        if (depth == 0)
            return expression(target);

        auto left = transform_constant<T>(covirt::rand<T>(), depth - 1);
        auto right = transform_constant<T>(covirt::rand<T>(), depth - 1);

        std::vector<std::function<expression(const expression&, const expression&)>> operations = {
            [](const expression& l, const expression& r) { return l + r; },
            [](const expression& l, const expression& r) { return l - r; },
            [](const expression& l, const expression& r) { return l ^ r; },
            [](const expression& l, const expression& r) { return l & r; },
            [](const expression& l, const expression& r) { return l | r; }
        };

        auto expr = operations[covirt::rand<int>() % operations.size()](left, right);

        T correction = target - expr.template evaluate<T>();
        auto correction_expr = expr + expression(correction);

        return correction_expr;
    }

    std::pair<zasm::Node*, size_t> assemble_steps(zasm::x86::Assembler &a, zasm::Operand &A, zasm::Operand &B, std::vector<zasm::x86::Gp> &avail_registers, size_t size, std::optional<zasm::Label> label = {});

private:
    struct binary_op {
        char op;
        std::shared_ptr<expression> lhs;
        std::shared_ptr<expression> rhs;
    };

    struct unary_op {
        char op;
        std::shared_ptr<expression> operand;
    };

    struct binary_asm {
        char op;
        zasm::Operand dst;
        zasm::Operand lhs;
        zasm::Operand rhs;
    };

    struct unary_asm {
        char op;
        zasm::Operand dst;
        zasm::Operand operand;
    };

    struct assemble_steps_state {
        assemble_steps_state(std::vector<zasm::x86::Gp> &avail_registers) 
        {
            for (auto &r : avail_registers)
                avail[r] = true;
        }

        zasm::Operand collect_register()
        {
            for (auto& [reg, state] : avail)
                if (state) {
                    state = false;
                    return reg;
                }

            out::assertion(false, "cant collect register, ran out of registers");
            return {};
        }

        void throw_away_register(zasm::Operand &reg)
        {
            if (reg.holds<zasm::Reg>())
                if (avail.contains(reg.get<zasm::Reg>().as<zasm::x86::Gp>()))
                    avail[reg.get<zasm::Reg>().as<zasm::x86::Gp>()] = true;
        }

        std::map<zasm::x86::Gp, bool> avail;
    };

    using asm_step = std::variant<binary_asm, unary_asm>;

    size_t asm_count = 0;
    std::variant<std::string, size_t, binary_op, unary_op> data;

    bool equals(const expression& other) const { return to_string() == other.to_string(); }

    template <typename Op>
    void safe_asm(zasm::x86::Assembler &a, Op operation, std::variant<zasm::Imm, zasm::x86::Gp, zasm::x86::Mem> &dst, std::variant<zasm::Imm, zasm::x86::Gp, zasm::x86::Mem> &src) 
    {
        std::visit([&a, operation](auto &&dst, auto &&src) {
            using dst_t = std::decay_t<decltype(dst)>;
            using src_t = std::decay_t<decltype(src)>;

            if constexpr ((std::is_same_v<dst_t, zasm::x86::Gp> && (std::is_same_v<src_t, zasm::x86::Gp> || std::is_same_v<src_t, zasm::Imm> || std::is_same_v<src_t, zasm::x86::Mem>))
                       || (std::is_same_v<dst_t, zasm::x86::Mem> && (std::is_same_v<src_t, zasm::x86::Gp> || std::is_same_v<src_t, zasm::Imm>))) {
                operation(a, dst, src);
            }
            else {
                out::fail("safe_asm did not emit an instruction!");
            }
        }, dst, src);

        asm_count++;
    }

    template <typename Op>
    void safe_rot(zasm::x86::Assembler &a, Op operation, std::variant<zasm::Imm, zasm::x86::Gp, zasm::x86::Mem> &dst, std::variant<zasm::Imm, zasm::x86::Gp, zasm::x86::Mem> &src) 
    {
        std::visit([&a, operation](auto &&dst, auto &&src) {
            using dst_t = std::decay_t<decltype(dst)>;
            using src_t = std::decay_t<decltype(src)>;

            if constexpr ((std::is_same_v<dst_t, zasm::x86::Gp> && (std::is_same_v<src_t, zasm::x86::Gp> || std::is_same_v<src_t, zasm::Imm>))
                       || (std::is_same_v<dst_t, zasm::x86::Mem> && (std::is_same_v<src_t, zasm::x86::Gp> || std::is_same_v<src_t, zasm::Imm>))) {
                operation(a, dst, src);
            }
            else {
                out::fail("safe_asm did not emit an instruction!");
            }
        }, dst, src);

        asm_count++;
    }

    // to-do: remove this function; currently its used to match patterns, however
    // it is more of a remnant from when i was debugging this class and needed
    // to print out the expression
    //
    std::string to_string() const;
    
    std::variant<zasm::Imm, zasm::x86::Gp, zasm::x86::Mem> to_x86_type(zasm::Operand &op, size_t size);
    
    zasm::Operand generate_asm_steps(zasm::Operand &A, zasm::Operand &B, std::vector<asm_step>& steps, assemble_steps_state &state, size_t size) const;
    
    expression transform_impl(const expression& match, const expression& new_expr) const;

    template <typename T>
    T evaluate() const 
    {
        out::assertion(!std::holds_alternative<std::string>(data), "can't evaluate a variable");
        
        if (std::holds_alternative<size_t>(data)) {
            return T(std::get<size_t>(data));
        } else if (std::holds_alternative<binary_op>(data)) {
            const auto& op = std::get<binary_op>(data);
            T lhs = op.lhs->evaluate<T>();
            T rhs = op.rhs->evaluate<T>();
            switch (op.op) {
            case '+': return lhs + rhs;
            case '-': return lhs - rhs;
            case '^': return lhs ^ rhs;
            case '&': return lhs & rhs;
            case '|': return lhs | rhs;
            default: 
                out::assertion(false, "unknown binary operator ({})", op.op);
            }
        } else {
            const auto& op = std::get<unary_op>(data);
            T operand = op.operand->evaluate<T>();
            switch (op.op) {
            case '~': return ~operand;
            case '-': return -operand;
            default: 
                out::assertion(false, "unknown unary operator ({})", op.op);
            }
        }

        out::assertion(false, "hit unexpected codepath");
        return {};
    }
};

static expression A("A");
static expression B("B");
```

`covirt/obfuscator/generic_transform.hpp`:

```hpp
#pragma once

#include <zasm/zasm.hpp>

namespace covirt {
    class generic_transform_pass {
    public:
        virtual void pass(zasm::Program &p, zasm::x86::Assembler &a) = 0;
    };
}
```

`covirt/obfuscator/passes/mba_pass.cpp`:

```cpp
#include "mba_pass.hpp"

#include <obfuscator/expression.hpp>
#include <utils/log.hpp>
#include <utils/indicators.hpp>

using namespace indicators;

expression transform_by_bitsize(zasm::Imm &imm, int depth = 1)
{
    auto bit_size = zasm::getBitSize(imm.getBitSize());
    switch (bit_size) {
    case 8: return expression::transform_constant(imm.value<int8_t>(), depth);
    case 16: return expression::transform_constant(imm.value<int16_t>(), depth);
    case 32: return expression::transform_constant(imm.value<int32_t>(), depth);
    case 64: out::assertion(false, "can't transform a 64-bit value"); return {};
    }
    out::assertion(false, "can't transform an unknown bit-sized value");
    return {};
}

void covirt::mba_pass::pass(zasm::Program &p, zasm::x86::Assembler &a)
{
    uintptr_t start_addr = uintptr_t(p.getHead());
    uintptr_t end_addr = uintptr_t(p.getTail());

    ProgressBar bar{
        option::BarWidth{50},
        option::Start{"["},
        option::Fill{"="},
        option::Lead{">"},
        option::Remainder{" "},
        option::End{"]"},
        option::PrefixText{std::format("[{}] [{}] {}: ", out::get_timestamp(), out::yellow("wait"), "mba_pass")},
        option::ForegroundColor{Color::yellow},
        option::ShowElapsedTime{true},
        option::ShowRemainingTime{true},
        option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}
    };

    size_t total_count = p.size();
    size_t curnt_count = 0;

    size_t n_total = 0;
    size_t n_trans = 0;
    size_t n_new_total = 0;

    auto x = p.getHead();
    for (auto node = p.getHead(); node != p.getTail(); node = node->getNext()) {
        node->visit([&](auto &&x) {
            bar.set_progress(size_t(float(float(curnt_count++) / total_count) * 100));

            if constexpr (!std::is_same_v<std::decay_t<decltype(x)>, zasm::Instruction>)
                return;

            n_total++;

            zasm::Instruction &instruction = node->get<zasm::Instruction>();
            expression exp{};

            if (instruction.getOperandCount() != 2)
                return;

            auto op0 = instruction.getOperand(0);
            auto op1 = instruction.getOperand(1);
            auto mnemonic = instruction.getMnemonic().value();

            switch (mnemonic) {
            case zasm::x86::Mnemonic::Mov: if (!op1.holds<zasm::Imm>()) return; exp = transform_by_bitsize(op1.get<zasm::Imm>(), 6); break;
            case zasm::x86::Mnemonic::Add: exp = A + B; break;
            case zasm::x86::Mnemonic::Sub: exp = A - B; break;
            case zasm::x86::Mnemonic::Xor: exp = A ^ B; break;
            case zasm::x86::Mnemonic::And: exp = A & B; break;
            case zasm::x86::Mnemonic::Or: exp = A | B; break;
            case zasm::x86::Mnemonic::Not: exp = ~A; break;
            case zasm::x86::Mnemonic::Neg: exp = -A; break;
            default:
                return;
            };

            // bc we modify rsp in vm op 'call', this will mess up the registers we were
            // supposed to be reserving/restoring
            //
            // to-do: refer to to-do in smc_pass about protecting sections of code from obfuscation
            // or simply define what registers are available at what time? (i like this idea more)
            //
            if (op0.holds<zasm::Reg>()) {
                if (op0.get<zasm::Reg>().as<zasm::x86::Gp>() == zasm::x86::rsp)
                    return;
            }

            if (mnemonic != zasm::x86::Mnemonic::Mov) {
                // to-do: investigate why combining `transform_constant` with variables
                // results in such stupid undefined behavior, only *half* of the time...
                //
                // i think this issue has some relation to the issue described with preserving
                // rsp and certain registers being modified after push/pop?
                //
                std::vector<std::pair<expression, expression>> mba_transformations = {
                    { (A^B), (A|B)-(A&B) },
                    { (A+B), (A&B)+(A|B) },
                    { (A-B), (A^-B)+(A&-B)+(A&-B) },
                    { (A&B), (A+B)-(A|B) },
                    { (A|B), (A+B)+(~A|~B)+/*expression::transform_constant<uint8_t>*/(1) },
                    { (~A),  (-A+/*expression::transform_constant<uint8_t>*/(-1)) },
                    { (-A),  (~A|A)-A+/*expression::transform_constant<uint8_t>*/(1) }
                };

                for (int i = 0; i < 3; i++)
                    for (auto& [match, transform] : mba_transformations)
                        exp = exp.transform(match, transform);
            }

            std::vector<zasm::x86::Gp> avail = { zasm::x86::r15, zasm::x86::r14, zasm::x86::r13, zasm::x86::r12, zasm::x86::r8, zasm::x86::rdi, zasm::x86::rbx };
            if (instruction.getOperandCount() == 2) {
                a.setCursor(node);

                auto size = zasm::getBitSize(std::max(op0.getBitSize(zasm::MachineMode::AMD64), op1.getBitSize(zasm::MachineMode::AMD64)));
                // for (auto &x : avail)
                //     a.xor_(x, x);
                auto [end, count] = exp.assemble_steps(a, op0, op1, avail, size);

                n_trans++;
                n_new_total += count;

                p.destroy(node);

                //node = end->getPrev();
                node = end;
            }
        });
    }

    out::clear();
    out::ok("mba_pass: transformed {} ({:.1f}%) instructions into {}", out::value(n_trans), float(n_trans) / n_total * 100.f, out::value(n_new_total));
}
```

`covirt/obfuscator/passes/mba_pass.hpp`:

```hpp
#pragma once 

#include "../generic_transform.hpp"

namespace covirt {
    class mba_pass final : public generic_transform_pass {
    public:
        void pass(zasm::Program &p, zasm::x86::Assembler &a);
    };
}

```

`covirt/obfuscator/passes/smc_pass.cpp`:

```cpp
#include "smc_pass.hpp"

#include <utils/log.hpp>
#include <utils/rand.hpp>
#include <utils/indicators.hpp>

using namespace indicators;

void covirt::smc_pass::pass(zasm::Program &p, zasm::x86::Assembler &a)
{
    uintptr_t start_addr = uintptr_t(p.getHead());
    uintptr_t end_addr = uintptr_t(p.getTail());

    ProgressBar bar{
        option::BarWidth{50},
        option::Start{"["},
        option::Fill{"="},
        option::Lead{">"},
        option::Remainder{" "},
        option::End{"]"},
        option::PrefixText{std::format("[{}] [{}] {}: ", out::get_timestamp(), out::yellow("wait"), "smc_pass")},
        option::ForegroundColor{Color::yellow},
        option::ShowElapsedTime{true},
        option::ShowRemainingTime{true},
        option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}
    };

    size_t total_count = p.size();
    size_t curnt_count = 0;

    size_t n_total = 0;
    size_t n_trans = 0;

    zasm::Program mini_program(zasm::MachineMode::AMD64);
    zasm::x86::Assembler mini_assembler(mini_program);
    zasm::Serializer serializer{};
    
    for (auto node = p.getHead(); node != p.getTail(); node = node->getNext()) {
        node->visit([&](auto &&x) {
            bar.set_progress(size_t(float(float(curnt_count++) / total_count) * 100));

            if constexpr (!std::is_same_v<std::decay_t<decltype(x)>, zasm::Instruction>)
                return;

            n_total++;

            zasm::Instruction &instruction = node->get<zasm::Instruction>();

            // this isn't ideal, but if pop becomes smc'd and we apply mba to it, we end up
            // modifying some previously popped into registers, which messes it all up
            //
            // to-do: add ability to mark sections of code as to keep safe from obfuscation
            //        covirt::no_transform_start();
            //        covirt::no_transform_end(); 
            // 
            if (instruction.getMnemonic() == zasm::x86::Mnemonic::Pop)
                return;

            // we need these to stick around because they get overwritten when we do native execution
            //
            if (instruction.getMnemonic() == zasm::x86::Mnemonic::Nop)
                return;

            mini_program.clear();
            mini_assembler.emit(instruction);
                
            auto res = serializer.serialize(mini_program, 0);
            if (res != zasm::ErrorCode::None)
                return;

            auto code = serializer.getCode();
            auto length = serializer.getCodeSize();

            if (length != 1 && length != 2 && length != 4)
                return;

            a.setCursor(node);

            a.pushfq();

            auto lap = a.createLabel();
            switch (length) {
            case 1: a.mov(zasm::x86::byte_ptr(zasm::x86::rip, lap), zasm::Imm8(code[0])); break;
            case 2: a.mov(zasm::x86::word_ptr(zasm::x86::rip, lap), zasm::Imm16(*(uint16_t*)code)); break;
            case 4: a.mov(zasm::x86::dword_ptr(zasm::x86::rip, lap), zasm::Imm32(*(uint32_t*)code)); break;
            }

            a.popfq();

            a.bind(lap);
            for (int i = 0; i < length; i++) {
                auto r = covirt::rand<uint8_t>();
                a.embed(&r, 1);
            }

            auto end = a.getCursor();
            p.destroy(node);
            node = end;

            n_trans++;
        });
    }

    out::clear();
    out::ok("smc_pass: transformed {} ({:.1f}%) instructions", out::value(n_trans), float(n_trans) / n_total * 100.f);
}

```

`covirt/obfuscator/passes/smc_pass.hpp`:

```hpp
#pragma once

#include "../generic_transform.hpp"

namespace covirt {
    class smc_pass final : public generic_transform_pass {
    public:
        void pass(zasm::Program &p, zasm::x86::Assembler &a);
    };
}
```

`covirt/utils/argparse.hpp`:

```hpp
/*
  __ _ _ __ __ _ _ __   __ _ _ __ ___  ___
 / _` | '__/ _` | '_ \ / _` | '__/ __|/ _ \ Argument Parser for Modern C++
| (_| | | | (_| | |_) | (_| | |  \__ \  __/ http://github.com/p-ranav/argparse
 \__,_|_|  \__, | .__/ \__,_|_|  |___/\___|
           |___/|_|

Licensed under the MIT License <http://opensource.org/licenses/MIT>.
SPDX-License-Identifier: MIT
Copyright (c) 2019-2022 Pranav Srinivas Kumar <pranav.srinivas.kumar@gmail.com>
and other contributors.

Permission is hereby  granted, free of charge, to any  person obtaining a copy
of this software and associated  documentation files (the "Software"), to deal
in the Software  without restriction, including without  limitation the rights
to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#pragma once

#include <cerrno>

#ifndef ARGPARSE_MODULE_USE_STD_MODULE
#include <algorithm>
#include <any>
#include <array>
#include <set>
#include <charconv>
#include <cstdlib>
#include <functional>
#include <iomanip>
#include <iostream>
#include <iterator>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <optional>
#include <sstream>
#include <stdexcept>
#include <string>
#include <string_view>
#include <tuple>
#include <type_traits>
#include <utility>
#include <variant>
#include <vector>
#endif

#ifndef ARGPARSE_CUSTOM_STRTOF
#define ARGPARSE_CUSTOM_STRTOF strtof
#endif

#ifndef ARGPARSE_CUSTOM_STRTOD
#define ARGPARSE_CUSTOM_STRTOD strtod
#endif

#ifndef ARGPARSE_CUSTOM_STRTOLD
#define ARGPARSE_CUSTOM_STRTOLD strtold
#endif

namespace argparse {

namespace details { // namespace for helper methods

template <typename T, typename = void>
struct HasContainerTraits : std::false_type {};

template <> struct HasContainerTraits<std::string> : std::false_type {};

template <> struct HasContainerTraits<std::string_view> : std::false_type {};

template <typename T>
struct HasContainerTraits<
    T, std::void_t<typename T::value_type, decltype(std::declval<T>().begin()),
                   decltype(std::declval<T>().end()),
                   decltype(std::declval<T>().size())>> : std::true_type {};

template <typename T>
inline constexpr bool IsContainer = HasContainerTraits<T>::value;

template <typename T, typename = void>
struct HasStreamableTraits : std::false_type {};

template <typename T>
struct HasStreamableTraits<
    T,
    std::void_t<decltype(std::declval<std::ostream &>() << std::declval<T>())>>
    : std::true_type {};

template <typename T>
inline constexpr bool IsStreamable = HasStreamableTraits<T>::value;

constexpr std::size_t repr_max_container_size = 5;

template <typename T> std::string repr(T const &val) {
  if constexpr (std::is_same_v<T, bool>) {
    return val ? "true" : "false";
  } else if constexpr (std::is_convertible_v<T, std::string_view>) {
    return '"' + std::string{std::string_view{val}} + '"';
  } else if constexpr (IsContainer<T>) {
    std::stringstream out;
    out << "{";
    const auto size = val.size();
    if (size > 1) {
      out << repr(*val.begin());
      std::for_each(
          std::next(val.begin()),
          std::next(
              val.begin(),
              static_cast<typename T::iterator::difference_type>(
                  std::min<std::size_t>(size, repr_max_container_size) - 1)),
          [&out](const auto &v) { out << " " << repr(v); });
      if (size <= repr_max_container_size) {
        out << " ";
      } else {
        out << "...";
      }
    }
    if (size > 0) {
      out << repr(*std::prev(val.end()));
    }
    out << "}";
    return out.str();
  } else if constexpr (IsStreamable<T>) {
    std::stringstream out;
    out << val;
    return out.str();
  } else {
    return "<not representable>";
  }
}

namespace {

template <typename T> constexpr bool standard_signed_integer = false;
template <> constexpr bool standard_signed_integer<signed char> = true;
template <> constexpr bool standard_signed_integer<short int> = true;
template <> constexpr bool standard_signed_integer<int> = true;
template <> constexpr bool standard_signed_integer<long int> = true;
template <> constexpr bool standard_signed_integer<long long int> = true;

template <typename T> constexpr bool standard_unsigned_integer = false;
template <> constexpr bool standard_unsigned_integer<unsigned char> = true;
template <> constexpr bool standard_unsigned_integer<unsigned short int> = true;
template <> constexpr bool standard_unsigned_integer<unsigned int> = true;
template <> constexpr bool standard_unsigned_integer<unsigned long int> = true;
template <>
constexpr bool standard_unsigned_integer<unsigned long long int> = true;

} // namespace

constexpr int radix_2 = 2;
constexpr int radix_8 = 8;
constexpr int radix_10 = 10;
constexpr int radix_16 = 16;

template <typename T>
constexpr bool standard_integer =
    standard_signed_integer<T> || standard_unsigned_integer<T>;

template <class F, class Tuple, class Extra, std::size_t... I>
constexpr decltype(auto)
apply_plus_one_impl(F &&f, Tuple &&t, Extra &&x,
                    std::index_sequence<I...> /*unused*/) {
  return std::invoke(std::forward<F>(f), std::get<I>(std::forward<Tuple>(t))...,
                     std::forward<Extra>(x));
}

template <class F, class Tuple, class Extra>
constexpr decltype(auto) apply_plus_one(F &&f, Tuple &&t, Extra &&x) {
  return details::apply_plus_one_impl(
      std::forward<F>(f), std::forward<Tuple>(t), std::forward<Extra>(x),
      std::make_index_sequence<
          std::tuple_size_v<std::remove_reference_t<Tuple>>>{});
}

constexpr auto pointer_range(std::string_view s) noexcept {
  return std::tuple(s.data(), s.data() + s.size());
}

template <class CharT, class Traits>
constexpr bool starts_with(std::basic_string_view<CharT, Traits> prefix,
                           std::basic_string_view<CharT, Traits> s) noexcept {
  return s.substr(0, prefix.size()) == prefix;
}

enum class chars_format {
  scientific = 0xf1,
  fixed = 0xf2,
  hex = 0xf4,
  binary = 0xf8,
  general = fixed | scientific
};

struct ConsumeBinaryPrefixResult {
  bool is_binary;
  std::string_view rest;
};

constexpr auto consume_binary_prefix(std::string_view s)
    -> ConsumeBinaryPrefixResult {
  if (starts_with(std::string_view{"0b"}, s) ||
      starts_with(std::string_view{"0B"}, s)) {
    s.remove_prefix(2);
    return {true, s};
  }
  return {false, s};
}

struct ConsumeHexPrefixResult {
  bool is_hexadecimal;
  std::string_view rest;
};

using namespace std::literals;

constexpr auto consume_hex_prefix(std::string_view s)
    -> ConsumeHexPrefixResult {
  if (starts_with("0x"sv, s) || starts_with("0X"sv, s)) {
    s.remove_prefix(2);
    return {true, s};
  }
  return {false, s};
}

template <class T, auto Param>
inline auto do_from_chars(std::string_view s) -> T {
  T x{0};
  auto [first, last] = pointer_range(s);
  auto [ptr, ec] = std::from_chars(first, last, x, Param);
  if (ec == std::errc()) {
    if (ptr == last) {
      return x;
    }
    throw std::invalid_argument{"pattern '" + std::string(s) +
                                "' does not match to the end"};
  }
  if (ec == std::errc::invalid_argument) {
    throw std::invalid_argument{"pattern '" + std::string(s) + "' not found"};
  }
  if (ec == std::errc::result_out_of_range) {
    throw std::range_error{"'" + std::string(s) + "' not representable"};
  }
  return x; // unreachable
}

template <class T, auto Param = 0> struct parse_number {
  auto operator()(std::string_view s) -> T {
    return do_from_chars<T, Param>(s);
  }
};

template <class T> struct parse_number<T, radix_2> {
  auto operator()(std::string_view s) -> T {
    if (auto [ok, rest] = consume_binary_prefix(s); ok) {
      return do_from_chars<T, radix_2>(rest);
    }
    throw std::invalid_argument{"pattern not found"};
  }
};

template <class T> struct parse_number<T, radix_16> {
  auto operator()(std::string_view s) -> T {
    if (starts_with("0x"sv, s) || starts_with("0X"sv, s)) {
      if (auto [ok, rest] = consume_hex_prefix(s); ok) {
        try {
          return do_from_chars<T, radix_16>(rest);
        } catch (const std::invalid_argument &err) {
          throw std::invalid_argument("Failed to parse '" + std::string(s) +
                                      "' as hexadecimal: " + err.what());
        } catch (const std::range_error &err) {
          throw std::range_error("Failed to parse '" + std::string(s) +
                                 "' as hexadecimal: " + err.what());
        }
      }
    } else {
      // Allow passing hex numbers without prefix
      // Shape 'x' already has to be specified
      try {
        return do_from_chars<T, radix_16>(s);
      } catch (const std::invalid_argument &err) {
        throw std::invalid_argument("Failed to parse '" + std::string(s) +
                                    "' as hexadecimal: " + err.what());
      } catch (const std::range_error &err) {
        throw std::range_error("Failed to parse '" + std::string(s) +
                               "' as hexadecimal: " + err.what());
      }
    }

    throw std::invalid_argument{"pattern '" + std::string(s) +
                                "' not identified as hexadecimal"};
  }
};

template <class T> struct parse_number<T> {
  auto operator()(std::string_view s) -> T {
    auto [ok, rest] = consume_hex_prefix(s);
    if (ok) {
      try {
        return do_from_chars<T, radix_16>(rest);
      } catch (const std::invalid_argument &err) {
        throw std::invalid_argument("Failed to parse '" + std::string(s) +
                                    "' as hexadecimal: " + err.what());
      } catch (const std::range_error &err) {
        throw std::range_error("Failed to parse '" + std::string(s) +
                               "' as hexadecimal: " + err.what());
      }
    }

    auto [ok_binary, rest_binary] = consume_binary_prefix(s);
    if (ok_binary) {
      try {
        return do_from_chars<T, radix_2>(rest_binary);
      } catch (const std::invalid_argument &err) {
        throw std::invalid_argument("Failed to parse '" + std::string(s) +
                                    "' as binary: " + err.what());
      } catch (const std::range_error &err) {
        throw std::range_error("Failed to parse '" + std::string(s) +
                               "' as binary: " + err.what());
      }
    }

    if (starts_with("0"sv, s)) {
      try {
        return do_from_chars<T, radix_8>(rest);
      } catch (const std::invalid_argument &err) {
        throw std::invalid_argument("Failed to parse '" + std::string(s) +
                                    "' as octal: " + err.what());
      } catch (const std::range_error &err) {
        throw std::range_error("Failed to parse '" + std::string(s) +
                               "' as octal: " + err.what());
      }
    }

    try {
      return do_from_chars<T, radix_10>(rest);
    } catch (const std::invalid_argument &err) {
      throw std::invalid_argument("Failed to parse '" + std::string(s) +
                                  "' as decimal integer: " + err.what());
    } catch (const std::range_error &err) {
      throw std::range_error("Failed to parse '" + std::string(s) +
                             "' as decimal integer: " + err.what());
    }
  }
};

namespace {

template <class T> inline const auto generic_strtod = nullptr;
template <> inline const auto generic_strtod<float> = ARGPARSE_CUSTOM_STRTOF;
template <> inline const auto generic_strtod<double> = ARGPARSE_CUSTOM_STRTOD;
template <>
inline const auto generic_strtod<long double> = ARGPARSE_CUSTOM_STRTOLD;

} // namespace

template <class T> inline auto do_strtod(std::string const &s) -> T {
  if (isspace(static_cast<unsigned char>(s[0])) || s[0] == '+') {
    throw std::invalid_argument{"pattern '" + s + "' not found"};
  }

  auto [first, last] = pointer_range(s);
  char *ptr;

  errno = 0;
  auto x = generic_strtod<T>(first, &ptr);
  if (errno == 0) {
    if (ptr == last) {
      return x;
    }
    throw std::invalid_argument{"pattern '" + s +
                                "' does not match to the end"};
  }
  if (errno == ERANGE) {
    throw std::range_error{"'" + s + "' not representable"};
  }
  return x; // unreachable
}

template <class T> struct parse_number<T, chars_format::general> {
  auto operator()(std::string const &s) -> T {
    if (auto r = consume_hex_prefix(s); r.is_hexadecimal) {
      throw std::invalid_argument{
          "chars_format::general does not parse hexfloat"};
    }
    if (auto r = consume_binary_prefix(s); r.is_binary) {
      throw std::invalid_argument{
          "chars_format::general does not parse binfloat"};
    }

    try {
      return do_strtod<T>(s);
    } catch (const std::invalid_argument &err) {
      throw std::invalid_argument("Failed to parse '" + s +
                                  "' as number: " + err.what());
    } catch (const std::range_error &err) {
      throw std::range_error("Failed to parse '" + s +
                             "' as number: " + err.what());
    }
  }
};

template <class T> struct parse_number<T, chars_format::hex> {
  auto operator()(std::string const &s) -> T {
    if (auto r = consume_hex_prefix(s); !r.is_hexadecimal) {
      throw std::invalid_argument{"chars_format::hex parses hexfloat"};
    }
    if (auto r = consume_binary_prefix(s); r.is_binary) {
      throw std::invalid_argument{"chars_format::hex does not parse binfloat"};
    }

    try {
      return do_strtod<T>(s);
    } catch (const std::invalid_argument &err) {
      throw std::invalid_argument("Failed to parse '" + s +
                                  "' as hexadecimal: " + err.what());
    } catch (const std::range_error &err) {
      throw std::range_error("Failed to parse '" + s +
                             "' as hexadecimal: " + err.what());
    }
  }
};

template <class T> struct parse_number<T, chars_format::binary> {
  auto operator()(std::string const &s) -> T {
    if (auto r = consume_hex_prefix(s); r.is_hexadecimal) {
      throw std::invalid_argument{
          "chars_format::binary does not parse hexfloat"};
    }
    if (auto r = consume_binary_prefix(s); !r.is_binary) {
      throw std::invalid_argument{"chars_format::binary parses binfloat"};
    }

    return do_strtod<T>(s);
  }
};

template <class T> struct parse_number<T, chars_format::scientific> {
  auto operator()(std::string const &s) -> T {
    if (auto r = consume_hex_prefix(s); r.is_hexadecimal) {
      throw std::invalid_argument{
          "chars_format::scientific does not parse hexfloat"};
    }
    if (auto r = consume_binary_prefix(s); r.is_binary) {
      throw std::invalid_argument{
          "chars_format::scientific does not parse binfloat"};
    }
    if (s.find_first_of("eE") == std::string::npos) {
      throw std::invalid_argument{
          "chars_format::scientific requires exponent part"};
    }

    try {
      return do_strtod<T>(s);
    } catch (const std::invalid_argument &err) {
      throw std::invalid_argument("Failed to parse '" + s +
                                  "' as scientific notation: " + err.what());
    } catch (const std::range_error &err) {
      throw std::range_error("Failed to parse '" + s +
                             "' as scientific notation: " + err.what());
    }
  }
};

template <class T> struct parse_number<T, chars_format::fixed> {
  auto operator()(std::string const &s) -> T {
    if (auto r = consume_hex_prefix(s); r.is_hexadecimal) {
      throw std::invalid_argument{
          "chars_format::fixed does not parse hexfloat"};
    }
    if (auto r = consume_binary_prefix(s); r.is_binary) {
      throw std::invalid_argument{
          "chars_format::fixed does not parse binfloat"};
    }
    if (s.find_first_of("eE") != std::string::npos) {
      throw std::invalid_argument{
          "chars_format::fixed does not parse exponent part"};
    }

    try {
      return do_strtod<T>(s);
    } catch (const std::invalid_argument &err) {
      throw std::invalid_argument("Failed to parse '" + s +
                                  "' as fixed notation: " + err.what());
    } catch (const std::range_error &err) {
      throw std::range_error("Failed to parse '" + s +
                             "' as fixed notation: " + err.what());
    }
  }
};

template <typename StrIt>
std::string join(StrIt first, StrIt last, const std::string &separator) {
  if (first == last) {
    return "";
  }
  std::stringstream value;
  value << *first;
  ++first;
  while (first != last) {
    value << separator << *first;
    ++first;
  }
  return value.str();
}

template <typename T> struct can_invoke_to_string {
  template <typename U>
  static auto test(int)
      -> decltype(std::to_string(std::declval<U>()), std::true_type{});

  template <typename U> static auto test(...) -> std::false_type;

  static constexpr bool value = decltype(test<T>(0))::value;
};

template <typename T> struct IsChoiceTypeSupported {
  using CleanType = typename std::decay<T>::type;
  static const bool value = std::is_integral<CleanType>::value ||
                            std::is_same<CleanType, std::string>::value ||
                            std::is_same<CleanType, std::string_view>::value ||
                            std::is_same<CleanType, const char *>::value;
};

template <typename StringType>
std::size_t get_levenshtein_distance(const StringType &s1,
                                     const StringType &s2) {
  std::vector<std::vector<std::size_t>> dp(
      s1.size() + 1, std::vector<std::size_t>(s2.size() + 1, 0));

  for (std::size_t i = 0; i <= s1.size(); ++i) {
    for (std::size_t j = 0; j <= s2.size(); ++j) {
      if (i == 0) {
        dp[i][j] = j;
      } else if (j == 0) {
        dp[i][j] = i;
      } else if (s1[i - 1] == s2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = 1 + std::min<std::size_t>({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]});
      }
    }
  }

  return dp[s1.size()][s2.size()];
}

template <typename ValueType>
std::string get_most_similar_string(const std::map<std::string, ValueType> &map,
                                    const std::string &input) {
  std::string most_similar{};
  std::size_t min_distance = (std::numeric_limits<std::size_t>::max)();

  for (const auto &entry : map) {
    std::size_t distance = get_levenshtein_distance(entry.first, input);
    if (distance < min_distance) {
      min_distance = distance;
      most_similar = entry.first;
    }
  }

  return most_similar;
}

} // namespace details

enum class nargs_pattern { optional, any, at_least_one };

enum class default_arguments : unsigned int {
  none = 0,
  help = 1,
  version = 2,
  all = help | version,
};

inline default_arguments operator&(const default_arguments &a,
                                   const default_arguments &b) {
  return static_cast<default_arguments>(
      static_cast<std::underlying_type<default_arguments>::type>(a) &
      static_cast<std::underlying_type<default_arguments>::type>(b));
}

class ArgumentParser;

class Argument {
  friend class ArgumentParser;
  friend auto operator<<(std::ostream &stream, const ArgumentParser &parser)
      -> std::ostream &;

  template <std::size_t N, std::size_t... I>
  explicit Argument(std::string_view prefix_chars,
                    std::array<std::string_view, N> &&a,
                    std::index_sequence<I...> /*unused*/)
      : m_accepts_optional_like_value(false),
        m_is_optional((is_optional(a[I], prefix_chars) || ...)),
        m_is_required(false), m_is_repeatable(false), m_is_used(false),
        m_is_hidden(false), m_prefix_chars(prefix_chars) {
    ((void)m_names.emplace_back(a[I]), ...);
    std::sort(
        m_names.begin(), m_names.end(), [](const auto &lhs, const auto &rhs) {
          return lhs.size() == rhs.size() ? lhs < rhs : lhs.size() < rhs.size();
        });
  }

public:
  template <std::size_t N>
  explicit Argument(std::string_view prefix_chars,
                    std::array<std::string_view, N> &&a)
      : Argument(prefix_chars, std::move(a), std::make_index_sequence<N>{}) {}

  Argument &help(std::string help_text) {
    m_help = std::move(help_text);
    return *this;
  }

  Argument &metavar(std::string metavar) {
    m_metavar = std::move(metavar);
    return *this;
  }

  template <typename T> Argument &default_value(T &&value) {
    m_num_args_range = NArgsRange{0, m_num_args_range.get_max()};
    m_default_value_repr = details::repr(value);

    if constexpr (std::is_convertible_v<T, std::string_view>) {
      m_default_value_str = std::string{std::string_view{value}};
    } else if constexpr (details::can_invoke_to_string<T>::value) {
      m_default_value_str = std::to_string(value);
    }

    m_default_value = std::forward<T>(value);
    return *this;
  }

  Argument &default_value(const char *value) {
    return default_value(std::string(value));
  }

  Argument &required() {
    m_is_required = true;
    return *this;
  }

  Argument &implicit_value(std::any value) {
    m_implicit_value = std::move(value);
    m_num_args_range = NArgsRange{0, 0};
    return *this;
  }

  // This is shorthand for:
  //   program.add_argument("foo")
  //     .default_value(false)
  //     .implicit_value(true)
  Argument &flag() {
    default_value(false);
    implicit_value(true);
    return *this;
  }

  template <class F, class... Args>
  auto action(F &&callable, Args &&... bound_args)
      -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                          Argument &> {
    using action_type = std::conditional_t<
        std::is_void_v<std::invoke_result_t<F, Args..., std::string const>>,
        void_action, valued_action>;
    if constexpr (sizeof...(Args) == 0) {
      m_action.emplace<action_type>(std::forward<F>(callable));
    } else {
      m_action.emplace<action_type>(
          [f = std::forward<F>(callable),
           tup = std::make_tuple(std::forward<Args>(bound_args)...)](
              std::string const &opt) mutable {
            return details::apply_plus_one(f, tup, opt);
          });
    }
    return *this;
  }

  auto &store_into(bool &var) {
    if ((!m_default_value.has_value()) && (!m_implicit_value.has_value())) {
      flag();
    }
    if (m_default_value.has_value()) {
      var = std::any_cast<bool>(m_default_value);
    }
    action([&var](const auto & /*unused*/) { var = true; });
    return *this;
  }

  template <typename T, typename std::enable_if<std::is_integral<T>::value>::type * = nullptr>
  auto &store_into(T &var) {
    if (m_default_value.has_value()) {
      var = std::any_cast<T>(m_default_value);
    }
    action([&var](const auto &s) {
      var = details::parse_number<T, details::radix_10>()(s);
    });
    return *this;
  }

  auto &store_into(double &var) {
    if (m_default_value.has_value()) {
      var = std::any_cast<double>(m_default_value);
    }
    action([&var](const auto &s) {
      var = details::parse_number<double, details::chars_format::general>()(s);
    });
    return *this;
  }

  auto &store_into(std::string &var) {
    if (m_default_value.has_value()) {
      var = std::any_cast<std::string>(m_default_value);
    }
    action([&var](const std::string &s) { var = s; });
    return *this;
  }

  auto &store_into(std::vector<std::string> &var) {
    if (m_default_value.has_value()) {
      var = std::any_cast<std::vector<std::string>>(m_default_value);
    }
    action([this, &var](const std::string &s) {
      if (!m_is_used) {
        var.clear();
      }
      m_is_used = true;
      var.push_back(s);
    });
    return *this;
  }

  auto &store_into(std::vector<int> &var) {
    if (m_default_value.has_value()) {
      var = std::any_cast<std::vector<int>>(m_default_value);
    }
    action([this, &var](const std::string &s) {
      if (!m_is_used) {
        var.clear();
      }
      m_is_used = true;
      var.push_back(details::parse_number<int, details::radix_10>()(s));
    });
    return *this;
  }

  auto &store_into(std::set<std::string> &var) {
    if (m_default_value.has_value()) {
      var = std::any_cast<std::set<std::string>>(m_default_value);
    }
    action([this, &var](const std::string &s) {
      if (!m_is_used) {
        var.clear();
      }
      m_is_used = true;
      var.insert(s);
    });
    return *this;
  }

  auto &store_into(std::set<int> &var) {
    if (m_default_value.has_value()) {
      var = std::any_cast<std::set<int>>(m_default_value);
    }
    action([this, &var](const std::string &s) {
      if (!m_is_used) {
        var.clear();
      }
      m_is_used = true;
      var.insert(details::parse_number<int, details::radix_10>()(s));
    });
    return *this;
  }

  auto &append() {
    m_is_repeatable = true;
    return *this;
  }

  // Cause the argument to be invisible in usage and help
  auto &hidden() {
    m_is_hidden = true;
    return *this;
  }

  template <char Shape, typename T>
  auto scan() -> std::enable_if_t<std::is_arithmetic_v<T>, Argument &> {
    static_assert(!(std::is_const_v<T> || std::is_volatile_v<T>),
                  "T should not be cv-qualified");
    auto is_one_of = [](char c, auto... x) constexpr {
      return ((c == x) || ...);
    };

    if constexpr (is_one_of(Shape, 'd') && details::standard_integer<T>) {
      action(details::parse_number<T, details::radix_10>());
    } else if constexpr (is_one_of(Shape, 'i') &&
                         details::standard_integer<T>) {
      action(details::parse_number<T>());
    } else if constexpr (is_one_of(Shape, 'u') &&
                         details::standard_unsigned_integer<T>) {
      action(details::parse_number<T, details::radix_10>());
    } else if constexpr (is_one_of(Shape, 'b') &&
                         details::standard_unsigned_integer<T>) {
      action(details::parse_number<T, details::radix_2>());
    } else if constexpr (is_one_of(Shape, 'o') &&
                         details::standard_unsigned_integer<T>) {
      action(details::parse_number<T, details::radix_8>());
    } else if constexpr (is_one_of(Shape, 'x', 'X') &&
                         details::standard_unsigned_integer<T>) {
      action(details::parse_number<T, details::radix_16>());
    } else if constexpr (is_one_of(Shape, 'a', 'A') &&
                         std::is_floating_point_v<T>) {
      action(details::parse_number<T, details::chars_format::hex>());
    } else if constexpr (is_one_of(Shape, 'e', 'E') &&
                         std::is_floating_point_v<T>) {
      action(details::parse_number<T, details::chars_format::scientific>());
    } else if constexpr (is_one_of(Shape, 'f', 'F') &&
                         std::is_floating_point_v<T>) {
      action(details::parse_number<T, details::chars_format::fixed>());
    } else if constexpr (is_one_of(Shape, 'g', 'G') &&
                         std::is_floating_point_v<T>) {
      action(details::parse_number<T, details::chars_format::general>());
    } else {
      static_assert(alignof(T) == 0, "No scan specification for T");
    }

    return *this;
  }

  Argument &nargs(std::size_t num_args) {
    m_num_args_range = NArgsRange{num_args, num_args};
    return *this;
  }

  Argument &nargs(std::size_t num_args_min, std::size_t num_args_max) {
    m_num_args_range = NArgsRange{num_args_min, num_args_max};
    return *this;
  }

  Argument &nargs(nargs_pattern pattern) {
    switch (pattern) {
    case nargs_pattern::optional:
      m_num_args_range = NArgsRange{0, 1};
      break;
    case nargs_pattern::any:
      m_num_args_range =
          NArgsRange{0, (std::numeric_limits<std::size_t>::max)()};
      break;
    case nargs_pattern::at_least_one:
      m_num_args_range =
          NArgsRange{1, (std::numeric_limits<std::size_t>::max)()};
      break;
    }
    return *this;
  }

  Argument &remaining() {
    m_accepts_optional_like_value = true;
    return nargs(nargs_pattern::any);
  }

  template <typename T> void add_choice(T &&choice) {
    static_assert(details::IsChoiceTypeSupported<T>::value,
                  "Only string or integer type supported for choice");
    static_assert(std::is_convertible_v<T, std::string_view> ||
                      details::can_invoke_to_string<T>::value,
                  "Choice is not convertible to string_type");
    if (!m_choices.has_value()) {
      m_choices = std::vector<std::string>{};
    }

    if constexpr (std::is_convertible_v<T, std::string_view>) {
      m_choices.value().push_back(
          std::string{std::string_view{std::forward<T>(choice)}});
    } else if constexpr (details::can_invoke_to_string<T>::value) {
      m_choices.value().push_back(std::to_string(std::forward<T>(choice)));
    }
  }

  Argument &choices() {
    if (!m_choices.has_value()) {
      throw std::runtime_error("Zero choices provided");
    }
    return *this;
  }

  template <typename T, typename... U>
  Argument &choices(T &&first, U &&... rest) {
    add_choice(std::forward<T>(first));
    choices(std::forward<U>(rest)...);
    return *this;
  }

  void find_default_value_in_choices_or_throw() const {

    const auto &choices = m_choices.value();

    if (m_default_value.has_value()) {
      if (std::find(choices.begin(), choices.end(), m_default_value_str) ==
          choices.end()) {
        // provided arg not in list of allowed choices
        // report error

        std::string choices_as_csv =
            std::accumulate(choices.begin(), choices.end(), std::string(),
                            [](const std::string &a, const std::string &b) {
                              return a + (a.empty() ? "" : ", ") + b;
                            });

        throw std::runtime_error(
            std::string{"Invalid default value "} + m_default_value_repr +
            " - allowed options: {" + choices_as_csv + "}");
      }
    }
  }

  template <typename Iterator>
  bool is_value_in_choices(Iterator option_it) const {

    const auto &choices = m_choices.value();

    return (std::find(choices.begin(), choices.end(), *option_it) !=
            choices.end());
  }

  template <typename Iterator>
  void throw_invalid_arguments_error(Iterator option_it) const {
    const auto &choices = m_choices.value();
    const std::string choices_as_csv = std::accumulate(
        choices.begin(), choices.end(), std::string(),
        [](const std::string &option_a, const std::string &option_b) {
          return option_a + (option_a.empty() ? "" : ", ") + option_b;
        });

    throw std::runtime_error(std::string{"Invalid argument "} +
                             details::repr(*option_it) +
                             " - allowed options: {" + choices_as_csv + "}");
  }

  /* The dry_run parameter can be set to true to avoid running the actions,
   * and setting m_is_used. This may be used by a pre-processing step to do
   * a first iteration over arguments.
   */
  template <typename Iterator>
  Iterator consume(Iterator start, Iterator end,
                   std::string_view used_name = {}, bool dry_run = false) {
    if (!m_is_repeatable && m_is_used) {
      throw std::runtime_error(
          std::string("Duplicate argument ").append(used_name));
    }
    m_used_name = used_name;

    std::size_t passed_options = 0;

    if (m_choices.has_value()) {
      // Check each value in (start, end) and make sure
      // it is in the list of allowed choices/options
      const auto max_number_of_args = m_num_args_range.get_max();
      const auto min_number_of_args = m_num_args_range.get_min();
      for (auto it = start; it != end; ++it) {
        if (is_value_in_choices(it)) {
          passed_options += 1;
          continue;
        }

        if ((passed_options >= min_number_of_args) &&
            (passed_options <= max_number_of_args)) {
          break;
        }

        throw_invalid_arguments_error(it);
      }
    }

    const auto num_args_max =
        (m_choices.has_value()) ? passed_options : m_num_args_range.get_max();
    const auto num_args_min = m_num_args_range.get_min();
    std::size_t dist = 0;
    if (num_args_max == 0) {
      if (!dry_run) {
        m_values.emplace_back(m_implicit_value);
        std::visit([](const auto &f) { f({}); }, m_action);
        m_is_used = true;
      }
      return start;
    }
    if ((dist = static_cast<std::size_t>(std::distance(start, end))) >=
        num_args_min) {
      if (num_args_max < dist) {
        end = std::next(start, static_cast<typename Iterator::difference_type>(
                                   num_args_max));
      }
      if (!m_accepts_optional_like_value) {
        end = std::find_if(
            start, end,
            std::bind(is_optional, std::placeholders::_1, m_prefix_chars));
        dist = static_cast<std::size_t>(std::distance(start, end));
        if (dist < num_args_min) {
          throw std::runtime_error("Too few arguments for '" +
                                   std::string(m_used_name) + "'.");
        }
      }
      struct ActionApply {
        void operator()(valued_action &f) {
          std::transform(first, last, std::back_inserter(self.m_values), f);
        }

        void operator()(void_action &f) {
          std::for_each(first, last, f);
          if (!self.m_default_value.has_value()) {
            if (!self.m_accepts_optional_like_value) {
              self.m_values.resize(
                  static_cast<std::size_t>(std::distance(first, last)));
            }
          }
        }

        Iterator first, last;
        Argument &self;
      };
      if (!dry_run) {
        std::visit(ActionApply{start, end, *this}, m_action);
        m_is_used = true;
      }
      return end;
    }
    if (m_default_value.has_value()) {
      if (!dry_run) {
        m_is_used = true;
      }
      return start;
    }
    throw std::runtime_error("Too few arguments for '" +
                             std::string(m_used_name) + "'.");
  }

  /*
   * @throws std::runtime_error if argument values are not valid
   */
  void validate() const {
    if (m_is_optional) {
      // TODO: check if an implicit value was programmed for this argument
      if (!m_is_used && !m_default_value.has_value() && m_is_required) {
        throw_required_arg_not_used_error();
      }
      if (m_is_used && m_is_required && m_values.empty()) {
        throw_required_arg_no_value_provided_error();
      }
    } else {
      if (!m_num_args_range.contains(m_values.size()) &&
          !m_default_value.has_value()) {
        throw_nargs_range_validation_error();
      }
    }

    if (m_choices.has_value()) {
      // Make sure the default value (if provided)
      // is in the list of choices
      find_default_value_in_choices_or_throw();
    }
  }

  std::string get_names_csv(char separator = ',') const {
    return std::accumulate(
        m_names.begin(), m_names.end(), std::string{""},
        [&](const std::string &result, const std::string &name) {
          return result.empty() ? name : result + separator + name;
        });
  }

  std::string get_usage_full() const {
    std::stringstream usage;

    usage << get_names_csv('/');
    const std::string metavar = !m_metavar.empty() ? m_metavar : "VAR";
    if (m_num_args_range.get_max() > 0) {
      usage << " " << metavar;
      if (m_num_args_range.get_max() > 1) {
        usage << "...";
      }
    }
    return usage.str();
  }

  std::string get_inline_usage() const {
    std::stringstream usage;
    // Find the longest variant to show in the usage string
    std::string longest_name = m_names.front();
    for (const auto &s : m_names) {
      if (s.size() > longest_name.size()) {
        longest_name = s;
      }
    }
    if (!m_is_required) {
      usage << "[";
    }
    usage << longest_name;
    const std::string metavar = !m_metavar.empty() ? m_metavar : "VAR";
    if (m_num_args_range.get_max() > 0) {
      usage << " " << metavar;
      if (m_num_args_range.get_max() > 1 &&
          m_metavar.find("> <") == std::string::npos) {
        usage << "...";
      }
    }
    if (!m_is_required) {
      usage << "]";
    }
    if (m_is_repeatable) {
      usage << "...";
    }
    return usage.str();
  }

  std::size_t get_arguments_length() const {

    std::size_t names_size = std::accumulate(
        std::begin(m_names), std::end(m_names), std::size_t(0),
        [](const auto &sum, const auto &s) { return sum + s.size(); });

    if (is_positional(m_names.front(), m_prefix_chars)) {
      // A set metavar means this replaces the names
      if (!m_metavar.empty()) {
        // Indent and metavar
        return 2 + m_metavar.size();
      }

      // Indent and space-separated
      return 2 + names_size + (m_names.size() - 1);
    }
    // Is an option - include both names _and_ metavar
    // size = text + (", " between names)
    std::size_t size = names_size + 2 * (m_names.size() - 1);
    if (!m_metavar.empty() && m_num_args_range == NArgsRange{1, 1}) {
      size += m_metavar.size() + 1;
    }
    return size + 2; // indent
  }

  friend std::ostream &operator<<(std::ostream &stream,
                                  const Argument &argument) {
    std::stringstream name_stream;
    name_stream << "  "; // indent
    if (argument.is_positional(argument.m_names.front(),
                               argument.m_prefix_chars)) {
      if (!argument.m_metavar.empty()) {
        name_stream << argument.m_metavar;
      } else {
        name_stream << details::join(argument.m_names.begin(),
                                     argument.m_names.end(), " ");
      }
    } else {
      name_stream << details::join(argument.m_names.begin(),
                                   argument.m_names.end(), ", ");
      // If we have a metavar, and one narg - print the metavar
      if (!argument.m_metavar.empty() &&
          argument.m_num_args_range == NArgsRange{1, 1}) {
        name_stream << " " << argument.m_metavar;
      }
      else if (!argument.m_metavar.empty() &&
               argument.m_num_args_range.get_min() == argument.m_num_args_range.get_max() &&
               argument.m_metavar.find("> <") != std::string::npos) {
        name_stream << " " << argument.m_metavar;
      }
    }

    // align multiline help message
    auto stream_width = stream.width();
    auto name_padding = std::string(name_stream.str().size(), ' ');
    auto pos = std::string::size_type{};
    auto prev = std::string::size_type{};
    auto first_line = true;
    auto hspace = "  "; // minimal space between name and help message
    stream << name_stream.str();
    std::string_view help_view(argument.m_help);
    while ((pos = argument.m_help.find('\n', prev)) != std::string::npos) {
      auto line = help_view.substr(prev, pos - prev + 1);
      if (first_line) {
        stream << hspace << line;
        first_line = false;
      } else {
        stream.width(stream_width);
        stream << name_padding << hspace << line;
      }
      prev += pos - prev + 1;
    }
    if (first_line) {
      stream << hspace << argument.m_help;
    } else {
      auto leftover = help_view.substr(prev, argument.m_help.size() - prev);
      if (!leftover.empty()) {
        stream.width(stream_width);
        stream << name_padding << hspace << leftover;
      }
    }

    // print nargs spec
    if (!argument.m_help.empty()) {
      stream << " ";
    }
    stream << argument.m_num_args_range;

    bool add_space = false;
    if (argument.m_default_value.has_value() &&
        argument.m_num_args_range != NArgsRange{0, 0}) {
      stream << "[default: " << argument.m_default_value_repr << "]";
      add_space = true;
    } else if (argument.m_is_required) {
      stream << "[required]";
      add_space = true;
    }
    if (argument.m_is_repeatable) {
      if (add_space) {
        stream << " ";
      }
      stream << "[may be repeated]";
    }
    stream << "\n";
    return stream;
  }

  template <typename T> bool operator!=(const T &rhs) const {
    return !(*this == rhs);
  }

  /*
   * Compare to an argument value of known type
   * @throws std::logic_error in case of incompatible types
   */
  template <typename T> bool operator==(const T &rhs) const {
    if constexpr (!details::IsContainer<T>) {
      return get<T>() == rhs;
    } else {
      using ValueType = typename T::value_type;
      auto lhs = get<T>();
      return std::equal(std::begin(lhs), std::end(lhs), std::begin(rhs),
                        std::end(rhs), [](const auto &a, const auto &b) {
                          return std::any_cast<const ValueType &>(a) == b;
                        });
    }
  }

  /*
   * positional:
   *    _empty_
   *    '-'
   *    '-' decimal-literal
   *    !'-' anything
   */
  static bool is_positional(std::string_view name,
                            std::string_view prefix_chars) {
    auto first = lookahead(name);

    if (first == eof) {
      return true;
    }
    if (prefix_chars.find(static_cast<char>(first)) !=
                          std::string_view::npos) {
      name.remove_prefix(1);
      if (name.empty()) {
        return true;
      }
      return is_decimal_literal(name);
    }
    return true;
  }

private:
  class NArgsRange {
    std::size_t m_min;
    std::size_t m_max;

  public:
    NArgsRange(std::size_t minimum, std::size_t maximum)
        : m_min(minimum), m_max(maximum) {
      if (minimum > maximum) {
        throw std::logic_error("Range of number of arguments is invalid");
      }
    }

    bool contains(std::size_t value) const {
      return value >= m_min && value <= m_max;
    }

    bool is_exact() const { return m_min == m_max; }

    bool is_right_bounded() const {
      return m_max < (std::numeric_limits<std::size_t>::max)();
    }

    std::size_t get_min() const { return m_min; }

    std::size_t get_max() const { return m_max; }

    // Print help message
    friend auto operator<<(std::ostream &stream, const NArgsRange &range)
        -> std::ostream & {
      if (range.m_min == range.m_max) {
        if (range.m_min != 0 && range.m_min != 1) {
          stream << "[nargs: " << range.m_min << "] ";
        }
      } else {
        if (range.m_max == (std::numeric_limits<std::size_t>::max)()) {
          stream << "[nargs: " << range.m_min << " or more] ";
        } else {
          stream << "[nargs=" << range.m_min << ".." << range.m_max << "] ";
        }
      }
      return stream;
    }

    bool operator==(const NArgsRange &rhs) const {
      return rhs.m_min == m_min && rhs.m_max == m_max;
    }

    bool operator!=(const NArgsRange &rhs) const { return !(*this == rhs); }
  };

  void throw_nargs_range_validation_error() const {
    std::stringstream stream;
    if (!m_used_name.empty()) {
      stream << m_used_name << ": ";
    } else {
      stream << m_names.front() << ": ";
    }
    if (m_num_args_range.is_exact()) {
      stream << m_num_args_range.get_min();
    } else if (m_num_args_range.is_right_bounded()) {
      stream << m_num_args_range.get_min() << " to "
             << m_num_args_range.get_max();
    } else {
      stream << m_num_args_range.get_min() << " or more";
    }
    stream << " argument(s) expected. " << m_values.size() << " provided.";
    throw std::runtime_error(stream.str());
  }

  void throw_required_arg_not_used_error() const {
    std::stringstream stream;
    stream << m_names.front() << ": required.";
    throw std::runtime_error(stream.str());
  }

  void throw_required_arg_no_value_provided_error() const {
    std::stringstream stream;
    stream << m_used_name << ": no value provided.";
    throw std::runtime_error(stream.str());
  }

  static constexpr int eof = std::char_traits<char>::eof();

  static auto lookahead(std::string_view s) -> int {
    if (s.empty()) {
      return eof;
    }
    return static_cast<int>(static_cast<unsigned char>(s[0]));
  }

  /*
   * decimal-literal:
   *    '0'
   *    nonzero-digit digit-sequence_opt
   *    integer-part fractional-part
   *    fractional-part
   *    integer-part '.' exponent-part_opt
   *    integer-part exponent-part
   *
   * integer-part:
   *    digit-sequence
   *
   * fractional-part:
   *    '.' post-decimal-point
   *
   * post-decimal-point:
   *    digit-sequence exponent-part_opt
   *
   * exponent-part:
   *    'e' post-e
   *    'E' post-e
   *
   * post-e:
   *    sign_opt digit-sequence
   *
   * sign: one of
   *    '+' '-'
   */
  static bool is_decimal_literal(std::string_view s) {
    auto is_digit = [](auto c) constexpr {
      switch (c) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        return true;
      default:
        return false;
      }
    };

    // precondition: we have consumed or will consume at least one digit
    auto consume_digits = [=](std::string_view sd) {
      // NOLINTNEXTLINE(readability-qualified-auto)
      auto it = std::find_if_not(std::begin(sd), std::end(sd), is_digit);
      return sd.substr(static_cast<std::size_t>(it - std::begin(sd)));
    };

    switch (lookahead(s)) {
    case '0': {
      s.remove_prefix(1);
      if (s.empty()) {
        return true;
      }
      goto integer_part;
    }
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': {
      s = consume_digits(s);
      if (s.empty()) {
        return true;
      }
      goto integer_part_consumed;
    }
    case '.': {
      s.remove_prefix(1);
      goto post_decimal_point;
    }
    default:
      return false;
    }

  integer_part:
    s = consume_digits(s);
  integer_part_consumed:
    switch (lookahead(s)) {
    case '.': {
      s.remove_prefix(1);
      if (is_digit(lookahead(s))) {
        goto post_decimal_point;
      } else {
        goto exponent_part_opt;
      }
    }
    case 'e':
    case 'E': {
      s.remove_prefix(1);
      goto post_e;
    }
    default:
      return false;
    }

  post_decimal_point:
    if (is_digit(lookahead(s))) {
      s = consume_digits(s);
      goto exponent_part_opt;
    }
    return false;

  exponent_part_opt:
    switch (lookahead(s)) {
    case eof:
      return true;
    case 'e':
    case 'E': {
      s.remove_prefix(1);
      goto post_e;
    }
    default:
      return false;
    }

  post_e:
    switch (lookahead(s)) {
    case '-':
    case '+':
      s.remove_prefix(1);
    }
    if (is_digit(lookahead(s))) {
      s = consume_digits(s);
      return s.empty();
    }
    return false;
  }

  static bool is_optional(std::string_view name,
                          std::string_view prefix_chars) {
    return !is_positional(name, prefix_chars);
  }

  /*
   * Get argument value given a type
   * @throws std::logic_error in case of incompatible types
   */
  template <typename T> T get() const {
    if (!m_values.empty()) {
      if constexpr (details::IsContainer<T>) {
        return any_cast_container<T>(m_values);
      } else {
        return std::any_cast<T>(m_values.front());
      }
    }
    if (m_default_value.has_value()) {
      return std::any_cast<T>(m_default_value);
    }
    if constexpr (details::IsContainer<T>) {
      if (!m_accepts_optional_like_value) {
        return any_cast_container<T>(m_values);
      }
    }

    throw std::logic_error("No value provided for '" + m_names.back() + "'.");
  }

  /*
   * Get argument value given a type.
   * @pre The object has no default value.
   * @returns The stored value if any, std::nullopt otherwise.
   */
  template <typename T> auto present() const -> std::optional<T> {
    if (m_default_value.has_value()) {
      throw std::logic_error("Argument with default value always presents");
    }
    if (m_values.empty()) {
      return std::nullopt;
    }
    if constexpr (details::IsContainer<T>) {
      return any_cast_container<T>(m_values);
    }
    return std::any_cast<T>(m_values.front());
  }

  template <typename T>
  static auto any_cast_container(const std::vector<std::any> &operand) -> T {
    using ValueType = typename T::value_type;

    T result;
    std::transform(
        std::begin(operand), std::end(operand), std::back_inserter(result),
        [](const auto &value) { return std::any_cast<ValueType>(value); });
    return result;
  }

  void set_usage_newline_counter(int i) { m_usage_newline_counter = i; }

  void set_group_idx(std::size_t i) { m_group_idx = i; }

  std::vector<std::string> m_names;
  std::string_view m_used_name;
  std::string m_help;
  std::string m_metavar;
  std::any m_default_value;
  std::string m_default_value_repr;
  std::optional<std::string>
      m_default_value_str; // used for checking default_value against choices
  std::any m_implicit_value;
  std::optional<std::vector<std::string>> m_choices{std::nullopt};
  using valued_action = std::function<std::any(const std::string &)>;
  using void_action = std::function<void(const std::string &)>;
  std::variant<valued_action, void_action> m_action{
      std::in_place_type<valued_action>,
      [](const std::string &value) { return value; }};
  std::vector<std::any> m_values;
  NArgsRange m_num_args_range{1, 1};
  // Bit field of bool values. Set default value in ctor.
  bool m_accepts_optional_like_value : 1;
  bool m_is_optional : 1;
  bool m_is_required : 1;
  bool m_is_repeatable : 1;
  bool m_is_used : 1;
  bool m_is_hidden : 1;            // if set, does not appear in usage or help
  std::string_view m_prefix_chars; // ArgumentParser has the prefix_chars
  int m_usage_newline_counter = 0;
  std::size_t m_group_idx = 0;
};

class ArgumentParser {
public:
  explicit ArgumentParser(std::string program_name = {},
                          std::string version = "1.0",
                          default_arguments add_args = default_arguments::all,
                          bool exit_on_default_arguments = true,
                          std::ostream &os = std::cout)
      : m_program_name(std::move(program_name)), m_version(std::move(version)),
        m_exit_on_default_arguments(exit_on_default_arguments),
        m_parser_path(m_program_name) {
    if ((add_args & default_arguments::help) == default_arguments::help) {
      add_argument("-h", "--help")
          .action([&](const auto & /*unused*/) {
            os << help().str();
            if (m_exit_on_default_arguments) {
              std::exit(0);
            }
          })
          .default_value(false)
          .help("shows help message and exits")
          .implicit_value(true)
          .nargs(0);
    }
    if ((add_args & default_arguments::version) == default_arguments::version) {
      add_argument("-v", "--version")
          .action([&](const auto & /*unused*/) {
            os << m_version << std::endl;
            if (m_exit_on_default_arguments) {
              std::exit(0);
            }
          })
          .default_value(false)
          .help("prints version information and exits")
          .implicit_value(true)
          .nargs(0);
    }
  }

  ~ArgumentParser() = default;

  // ArgumentParser is meant to be used in a single function.
  // Setup everything and parse arguments in one place.
  //
  // ArgumentParser internally uses std::string_views,
  // references, iterators, etc.
  // Many of these elements become invalidated after a copy or move.
  ArgumentParser(const ArgumentParser &other) = delete;
  ArgumentParser &operator=(const ArgumentParser &other) = delete;
  ArgumentParser(ArgumentParser &&) noexcept = delete;
  ArgumentParser &operator=(ArgumentParser &&) = delete;

  explicit operator bool() const {
    auto arg_used = std::any_of(m_argument_map.cbegin(), m_argument_map.cend(),
                                [](auto &it) { return it.second->m_is_used; });
    auto subparser_used =
        std::any_of(m_subparser_used.cbegin(), m_subparser_used.cend(),
                    [](auto &it) { return it.second; });

    return m_is_parsed && (arg_used || subparser_used);
  }

  // Parameter packing
  // Call add_argument with variadic number of string arguments
  template <typename... Targs> Argument &add_argument(Targs... f_args) {
    using array_of_sv = std::array<std::string_view, sizeof...(Targs)>;
    auto argument =
        m_optional_arguments.emplace(std::cend(m_optional_arguments),
                                     m_prefix_chars, array_of_sv{f_args...});

    if (!argument->m_is_optional) {
      m_positional_arguments.splice(std::cend(m_positional_arguments),
                                    m_optional_arguments, argument);
    }
    argument->set_usage_newline_counter(m_usage_newline_counter);
    argument->set_group_idx(m_group_names.size());

    index_argument(argument);
    return *argument;
  }

  class MutuallyExclusiveGroup {
    friend class ArgumentParser;

  public:
    MutuallyExclusiveGroup() = delete;

    explicit MutuallyExclusiveGroup(ArgumentParser &parent,
                                    bool required = false)
        : m_parent(parent), m_required(required), m_elements({}) {}

    MutuallyExclusiveGroup(const MutuallyExclusiveGroup &other) = delete;
    MutuallyExclusiveGroup &
    operator=(const MutuallyExclusiveGroup &other) = delete;

    MutuallyExclusiveGroup(MutuallyExclusiveGroup &&other) noexcept
        : m_parent(other.m_parent), m_required(other.m_required),
          m_elements(std::move(other.m_elements)) {
      other.m_elements.clear();
    }

    template <typename... Targs> Argument &add_argument(Targs... f_args) {
      auto &argument = m_parent.add_argument(std::forward<Targs>(f_args)...);
      m_elements.push_back(&argument);
      argument.set_usage_newline_counter(m_parent.m_usage_newline_counter);
      argument.set_group_idx(m_parent.m_group_names.size());
      return argument;
    }

  private:
    ArgumentParser &m_parent;
    bool m_required{false};
    std::vector<Argument *> m_elements{};
  };

  MutuallyExclusiveGroup &add_mutually_exclusive_group(bool required = false) {
    m_mutually_exclusive_groups.emplace_back(*this, required);
    return m_mutually_exclusive_groups.back();
  }

  // Parameter packed add_parents method
  // Accepts a variadic number of ArgumentParser objects
  template <typename... Targs>
  ArgumentParser &add_parents(const Targs &... f_args) {
    for (const ArgumentParser &parent_parser : {std::ref(f_args)...}) {
      for (const auto &argument : parent_parser.m_positional_arguments) {
        auto it = m_positional_arguments.insert(
            std::cend(m_positional_arguments), argument);
        index_argument(it);
      }
      for (const auto &argument : parent_parser.m_optional_arguments) {
        auto it = m_optional_arguments.insert(std::cend(m_optional_arguments),
                                              argument);
        index_argument(it);
      }
    }
    return *this;
  }

  // Ask for the next optional arguments to be displayed on a separate
  // line in usage() output. Only effective if set_usage_max_line_width() is
  // also used.
  ArgumentParser &add_usage_newline() {
    ++m_usage_newline_counter;
    return *this;
  }

  // Ask for the next optional arguments to be displayed in a separate section
  // in usage() and help (<< *this) output.
  // For usage(), this is only effective if set_usage_max_line_width() is
  // also used.
  ArgumentParser &add_group(std::string group_name) {
    m_group_names.emplace_back(std::move(group_name));
    return *this;
  }

  ArgumentParser &add_description(std::string description) {
    m_description = std::move(description);
    return *this;
  }

  ArgumentParser &add_epilog(std::string epilog) {
    m_epilog = std::move(epilog);
    return *this;
  }

  // Add a un-documented/hidden alias for an argument.
  // Ideally we'd want this to be a method of Argument, but Argument
  // does not own its owing ArgumentParser.
  ArgumentParser &add_hidden_alias_for(Argument &arg, std::string_view alias) {
    for (auto it = m_optional_arguments.begin();
         it != m_optional_arguments.end(); ++it) {
      if (&(*it) == &arg) {
        m_argument_map.insert_or_assign(std::string(alias), it);
        return *this;
      }
    }
    throw std::logic_error(
        "Argument is not an optional argument of this parser");
  }

  /* Getter for arguments and subparsers.
   * @throws std::logic_error in case of an invalid argument or subparser name
   */
  template <typename T = Argument> T &at(std::string_view name) {
    if constexpr (std::is_same_v<T, Argument>) {
      return (*this)[name];
    } else {
      std::string str_name(name);
      auto subparser_it = m_subparser_map.find(str_name);
      if (subparser_it != m_subparser_map.end()) {
        return subparser_it->second->get();
      }
      throw std::logic_error("No such subparser: " + str_name);
    }
  }

  ArgumentParser &set_prefix_chars(std::string prefix_chars) {
    m_prefix_chars = std::move(prefix_chars);
    return *this;
  }

  ArgumentParser &set_assign_chars(std::string assign_chars) {
    m_assign_chars = std::move(assign_chars);
    return *this;
  }

  /* Call parse_args_internal - which does all the work
   * Then, validate the parsed arguments
   * This variant is used mainly for testing
   * @throws std::runtime_error in case of any invalid argument
   */
  void parse_args(const std::vector<std::string> &arguments) {
    parse_args_internal(arguments);
    // Check if all arguments are parsed
    for ([[maybe_unused]] const auto &[unused, argument] : m_argument_map) {
      argument->validate();
    }

    // Check each mutually exclusive group and make sure
    // there are no constraint violations
    for (const auto &group : m_mutually_exclusive_groups) {
      auto mutex_argument_used{false};
      Argument *mutex_argument_it{nullptr};
      for (Argument *arg : group.m_elements) {
        if (!mutex_argument_used && arg->m_is_used) {
          mutex_argument_used = true;
          mutex_argument_it = arg;
        } else if (mutex_argument_used && arg->m_is_used) {
          // Violation
          throw std::runtime_error("Argument '" + arg->get_usage_full() +
                                   "' not allowed with '" +
                                   mutex_argument_it->get_usage_full() + "'");
        }
      }

      if (!mutex_argument_used && group.m_required) {
        // at least one argument from the group is
        // required
        std::string argument_names{};
        std::size_t i = 0;
        std::size_t size = group.m_elements.size();
        for (Argument *arg : group.m_elements) {
          if (i + 1 == size) {
            // last
            argument_names += std::string("'") + arg->get_usage_full() + std::string("' ");
          } else {
            argument_names += std::string("'") + arg->get_usage_full() + std::string("' or ");
          }
          i += 1;
        }
        throw std::runtime_error("One of the arguments " + argument_names +
                                 "is required");
      }
    }
  }

  /* Call parse_known_args_internal - which does all the work
   * Then, validate the parsed arguments
   * This variant is used mainly for testing
   * @throws std::runtime_error in case of any invalid argument
   */
  std::vector<std::string>
  parse_known_args(const std::vector<std::string> &arguments) {
    auto unknown_arguments = parse_known_args_internal(arguments);
    // Check if all arguments are parsed
    for ([[maybe_unused]] const auto &[unused, argument] : m_argument_map) {
      argument->validate();
    }
    return unknown_arguments;
  }

  /* Main entry point for parsing command-line arguments using this
   * ArgumentParser
   * @throws std::runtime_error in case of any invalid argument
   */
  // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays)
  void parse_args(int argc, const char *const argv[]) {
    parse_args({argv, argv + argc});
  }

  /* Main entry point for parsing command-line arguments using this
   * ArgumentParser
   * @throws std::runtime_error in case of any invalid argument
   */
  // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays)
  auto parse_known_args(int argc, const char *const argv[]) {
    return parse_known_args({argv, argv + argc});
  }

  /* Getter for options with default values.
   * @throws std::logic_error if parse_args() has not been previously called
   * @throws std::logic_error if there is no such option
   * @throws std::logic_error if the option has no value
   * @throws std::bad_any_cast if the option is not of type T
   */
  template <typename T = std::string> T get(std::string_view arg_name) const {
    if (!m_is_parsed) {
      throw std::logic_error("Nothing parsed, no arguments are available.");
    }
    return (*this)[arg_name].get<T>();
  }

  /* Getter for options without default values.
   * @pre The option has no default value.
   * @throws std::logic_error if there is no such option
   * @throws std::bad_any_cast if the option is not of type T
   */
  template <typename T = std::string>
  auto present(std::string_view arg_name) const -> std::optional<T> {
    return (*this)[arg_name].present<T>();
  }

  /* Getter that returns true for user-supplied options. Returns false if not
   * user-supplied, even with a default value.
   */
  auto is_used(std::string_view arg_name) const {
    return (*this)[arg_name].m_is_used;
  }

  /* Getter that returns true if a subcommand is used.
   */
  auto is_subcommand_used(std::string_view subcommand_name) const {
    return m_subparser_used.at(std::string(subcommand_name));
  }

  /* Getter that returns true if a subcommand is used.
   */
  auto is_subcommand_used(const ArgumentParser &subparser) const {
    return is_subcommand_used(subparser.m_program_name);
  }

  /* Indexing operator. Return a reference to an Argument object
   * Used in conjunction with Argument.operator== e.g., parser["foo"] == true
   * @throws std::logic_error in case of an invalid argument name
   */
  Argument &operator[](std::string_view arg_name) const {
    std::string name(arg_name);
    auto it = m_argument_map.find(name);
    if (it != m_argument_map.end()) {
      return *(it->second);
    }
    if (!is_valid_prefix_char(arg_name.front())) {
      const auto legal_prefix_char = get_any_valid_prefix_char();
      const auto prefix = std::string(1, legal_prefix_char);

      // "-" + arg_name
      name = prefix + name;
      it = m_argument_map.find(name);
      if (it != m_argument_map.end()) {
        return *(it->second);
      }
      // "--" + arg_name
      name = prefix + name;
      it = m_argument_map.find(name);
      if (it != m_argument_map.end()) {
        return *(it->second);
      }
    }
    throw std::logic_error("No such argument: " + std::string(arg_name));
  }

  // Print help message
  friend auto operator<<(std::ostream &stream, const ArgumentParser &parser)
      -> std::ostream & {
    stream.setf(std::ios_base::left);

    auto longest_arg_length = parser.get_length_of_longest_argument();

    stream << parser.usage() << "\n\n";

    if (!parser.m_description.empty()) {
      stream << parser.m_description << "\n\n";
    }

    const bool has_visible_positional_args = std::find_if(
      parser.m_positional_arguments.begin(),
      parser.m_positional_arguments.end(),
      [](const auto &argument) {
      return !argument.m_is_hidden; }) !=
      parser.m_positional_arguments.end();
    if (has_visible_positional_args) {
      stream << "Positional arguments:\n";
    }

    for (const auto &argument : parser.m_positional_arguments) {
      if (!argument.m_is_hidden) {
        stream.width(static_cast<std::streamsize>(longest_arg_length));
        stream << argument;
      }
    }

    if (!parser.m_optional_arguments.empty()) {
      stream << (!has_visible_positional_args ? "" : "\n")
             << "Optional arguments:\n";
    }

    for (const auto &argument : parser.m_optional_arguments) {
      if (argument.m_group_idx == 0 && !argument.m_is_hidden) {
        stream.width(static_cast<std::streamsize>(longest_arg_length));
        stream << argument;
      }
    }

    for (size_t i_group = 0; i_group < parser.m_group_names.size(); ++i_group) {
      stream << "\n" << parser.m_group_names[i_group] << " (detailed usage):\n";
      for (const auto &argument : parser.m_optional_arguments) {
        if (argument.m_group_idx == i_group + 1 && !argument.m_is_hidden) {
          stream.width(static_cast<std::streamsize>(longest_arg_length));
          stream << argument;
        }
      }
    }

    bool has_visible_subcommands = std::any_of(
        parser.m_subparser_map.begin(), parser.m_subparser_map.end(),
        [](auto &p) { return !p.second->get().m_suppress; });

    if (has_visible_subcommands) {
      stream << (parser.m_positional_arguments.empty()
                     ? (parser.m_optional_arguments.empty() ? "" : "\n")
                     : "\n")
             << "Subcommands:\n";
      for (const auto &[command, subparser] : parser.m_subparser_map) {
        if (subparser->get().m_suppress) {
          continue;
        }

        stream << std::setw(2) << " ";
        stream << std::setw(static_cast<int>(longest_arg_length - 2))
               << command;
        stream << " " << subparser->get().m_description << "\n";
      }
    }

    if (!parser.m_epilog.empty()) {
      stream << '\n';
      stream << parser.m_epilog << "\n\n";
    }

    return stream;
  }

  // Format help message
  auto help() const -> std::stringstream {
    std::stringstream out;
    out << *this;
    return out;
  }

  // Sets the maximum width for a line of the Usage message
  ArgumentParser &set_usage_max_line_width(size_t w) {
    this->m_usage_max_line_width = w;
    return *this;
  }

  // Asks to display arguments of mutually exclusive group on separate lines in
  // the Usage message
  ArgumentParser &set_usage_break_on_mutex() {
    this->m_usage_break_on_mutex = true;
    return *this;
  }

  // Format usage part of help only
  auto usage() const -> std::string {
    std::stringstream stream;

    std::string curline("Usage: ");
    curline += this->m_program_name;
    const bool multiline_usage =
        this->m_usage_max_line_width < (std::numeric_limits<std::size_t>::max)();
    const size_t indent_size = curline.size();

    const auto deal_with_options_of_group = [&](std::size_t group_idx) {
      bool found_options = false;
      // Add any options inline here
      const MutuallyExclusiveGroup *cur_mutex = nullptr;
      int usage_newline_counter = -1;
      for (const auto &argument : this->m_optional_arguments) {
        if (argument.m_is_hidden) {
          continue;
        }
        if (multiline_usage) {
          if (argument.m_group_idx != group_idx) {
            continue;
          }
          if (usage_newline_counter != argument.m_usage_newline_counter) {
            if (usage_newline_counter >= 0) {
              if (curline.size() > indent_size) {
                stream << curline << std::endl;
                curline = std::string(indent_size, ' ');
              }
            }
            usage_newline_counter = argument.m_usage_newline_counter;
          }
        }
        found_options = true;
        const std::string arg_inline_usage = argument.get_inline_usage();
        const MutuallyExclusiveGroup *arg_mutex =
            get_belonging_mutex(&argument);
        if ((cur_mutex != nullptr) && (arg_mutex == nullptr)) {
          curline += ']';
          if (this->m_usage_break_on_mutex) {
            stream << curline << std::endl;
            curline = std::string(indent_size, ' ');
          }
        } else if ((cur_mutex == nullptr) && (arg_mutex != nullptr)) {
          if ((this->m_usage_break_on_mutex && curline.size() > indent_size) ||
              curline.size() + 3 + arg_inline_usage.size() >
                  this->m_usage_max_line_width) {
            stream << curline << std::endl;
            curline = std::string(indent_size, ' ');
          }
          curline += " [";
        } else if ((cur_mutex != nullptr) && (arg_mutex != nullptr)) {
          if (cur_mutex != arg_mutex) {
            curline += ']';
            if (this->m_usage_break_on_mutex ||
                curline.size() + 3 + arg_inline_usage.size() >
                    this->m_usage_max_line_width) {
              stream << curline << std::endl;
              curline = std::string(indent_size, ' ');
            }
            curline += " [";
          } else {
            curline += '|';
          }
        }
        cur_mutex = arg_mutex;
        if (curline.size() + 1 + arg_inline_usage.size() >
            this->m_usage_max_line_width) {
          stream << curline << std::endl;
          curline = std::string(indent_size, ' ');
          curline += " ";
        } else if (cur_mutex == nullptr) {
          curline += " ";
        }
        curline += arg_inline_usage;
      }
      if (cur_mutex != nullptr) {
        curline += ']';
      }
      return found_options;
    };

    const bool found_options = deal_with_options_of_group(0);

    if (found_options && multiline_usage &&
        !this->m_positional_arguments.empty()) {
      stream << curline << std::endl;
      curline = std::string(indent_size, ' ');
    }
    // Put positional arguments after the optionals
    for (const auto &argument : this->m_positional_arguments) {
      if (argument.m_is_hidden) {
        continue;
      }
      const std::string pos_arg = !argument.m_metavar.empty()
                                      ? argument.m_metavar
                                      : argument.m_names.front();
      if (curline.size() + 1 + pos_arg.size() > this->m_usage_max_line_width) {
        stream << curline << std::endl;
        curline = std::string(indent_size, ' ');
      }
      curline += " ";
      if (argument.m_num_args_range.get_min() == 0 &&
          !argument.m_num_args_range.is_right_bounded()) {
        curline += "[";
        curline += pos_arg;
        curline += "]...";
      } else if (argument.m_num_args_range.get_min() == 1 &&
                 !argument.m_num_args_range.is_right_bounded()) {
        curline += pos_arg;
        curline += "...";
      } else {
        curline += pos_arg;
      }
    }

    if (multiline_usage) {
      // Display options of other groups
      for (std::size_t i = 0; i < m_group_names.size(); ++i) {
        stream << curline << std::endl << std::endl;
        stream << m_group_names[i] << ":" << std::endl;
        curline = std::string(indent_size, ' ');
        deal_with_options_of_group(i + 1);
      }
    }

    stream << curline;

    // Put subcommands after positional arguments
    if (!m_subparser_map.empty()) {
      stream << " {";
      std::size_t i{0};
      for (const auto &[command, subparser] : m_subparser_map) {
        if (subparser->get().m_suppress) {
          continue;
        }

        if (i == 0) {
          stream << command;
        } else {
          stream << "," << command;
        }
        ++i;
      }
      stream << "}";
    }

    return stream.str();
  }

  // Printing the one and only help message
  // I've stuck with a simple message format, nothing fancy.
  [[deprecated("Use cout << program; instead.  See also help().")]] std::string
  print_help() const {
    auto out = help();
    std::cout << out.rdbuf();
    return out.str();
  }

  void add_subparser(ArgumentParser &parser) {
    parser.m_parser_path = m_program_name + " " + parser.m_program_name;
    auto it = m_subparsers.emplace(std::cend(m_subparsers), parser);
    m_subparser_map.insert_or_assign(parser.m_program_name, it);
    m_subparser_used.insert_or_assign(parser.m_program_name, false);
  }

  void set_suppress(bool suppress) { m_suppress = suppress; }

protected:
  const MutuallyExclusiveGroup *get_belonging_mutex(const Argument *arg) const {
    for (const auto &mutex : m_mutually_exclusive_groups) {
      if (std::find(mutex.m_elements.begin(), mutex.m_elements.end(), arg) !=
          mutex.m_elements.end()) {
        return &mutex;
      }
    }
    return nullptr;
  }

  bool is_valid_prefix_char(char c) const {
    return m_prefix_chars.find(c) != std::string::npos;
  }

  char get_any_valid_prefix_char() const { return m_prefix_chars[0]; }

  /*
   * Pre-process this argument list. Anything starting with "--", that
   * contains an =, where the prefix before the = has an entry in the
   * options table, should be split.
   */
  std::vector<std::string>
  preprocess_arguments(const std::vector<std::string> &raw_arguments) const {
    std::vector<std::string> arguments{};
    for (const auto &arg : raw_arguments) {
      
      const auto argument_starts_with_prefix_chars =
          [this](const std::string &a) -> bool {
        if (!a.empty()) {

          const auto legal_prefix = [this](char c) -> bool {
            return m_prefix_chars.find(c) != std::string::npos;
          };

          // Windows-style
          // if '/' is a legal prefix char
          // then allow single '/' followed by argument name, followed by an
          // assign char, e.g., ':' e.g., 'test.exe /A:Foo'
          const auto windows_style = legal_prefix('/');

          if (windows_style) {
            if (legal_prefix(a[0])) {
              return true;
            }
          } else {
            // Slash '/' is not a legal prefix char
            // For all other characters, only support long arguments
            // i.e., the argument must start with 2 prefix chars, e.g,
            // '--foo' e,g, './test --foo=Bar -DARG=yes'
            if (a.size() > 1) {
              return (legal_prefix(a[0]) && legal_prefix(a[1]));
            }
          }
        }
        return false;
      };

      // Check that:
      // - We don't have an argument named exactly this
      // - The argument starts with a prefix char, e.g., "--"
      // - The argument contains an assign char, e.g., "="
      auto assign_char_pos = arg.find_first_of(m_assign_chars);

      if (m_argument_map.find(arg) == m_argument_map.end() &&
          argument_starts_with_prefix_chars(arg) &&
          assign_char_pos != std::string::npos) {
        // Get the name of the potential option, and check it exists
        std::string opt_name = arg.substr(0, assign_char_pos);
        if (m_argument_map.find(opt_name) != m_argument_map.end()) {
          // This is the name of an option! Split it into two parts
          arguments.push_back(std::move(opt_name));
          arguments.push_back(arg.substr(assign_char_pos + 1));
          continue;
        }
      }
      // If we've fallen through to here, then it's a standard argument
      arguments.push_back(arg);
    }
    return arguments;
  }

  /*
   * @throws std::runtime_error in case of any invalid argument
   */
  void parse_args_internal(const std::vector<std::string> &raw_arguments) {
    auto arguments = preprocess_arguments(raw_arguments);
    if (m_program_name.empty() && !arguments.empty()) {
      m_program_name = arguments.front();
    }
    auto end = std::end(arguments);
    auto positional_argument_it = std::begin(m_positional_arguments);
    for (auto it = std::next(std::begin(arguments)); it != end;) {
      const auto &current_argument = *it;
      if (Argument::is_positional(current_argument, m_prefix_chars)) {
        if (positional_argument_it == std::end(m_positional_arguments)) {

          // Check sub-parsers
          auto subparser_it = m_subparser_map.find(current_argument);
          if (subparser_it != m_subparser_map.end()) {

            // build list of remaining args
            const auto unprocessed_arguments =
                std::vector<std::string>(it, end);

            // invoke subparser
            m_is_parsed = true;
            m_subparser_used[current_argument] = true;
            return subparser_it->second->get().parse_args(
                unprocessed_arguments);
          }

          if (m_positional_arguments.empty()) {

            // Ask the user if they argument they provided was a typo
            // for some sub-parser,
            // e.g., user provided `git totes` instead of `git notes`
            if (!m_subparser_map.empty()) {
              throw std::runtime_error(
                  "Failed to parse '" + current_argument + "', did you mean '" +
                  std::string{details::get_most_similar_string(
                      m_subparser_map, current_argument)} +
                  "'");
            }

            // Ask the user if they meant to use a specific optional argument
            if (!m_optional_arguments.empty()) {
              for (const auto &opt : m_optional_arguments) {
                if (!opt.m_implicit_value.has_value()) {
                  // not a flag, requires a value
                  if (!opt.m_is_used) {
                    throw std::runtime_error(
                        "Zero positional arguments expected, did you mean " +
                        opt.get_usage_full());
                  }
                }
              }

              throw std::runtime_error("Zero positional arguments expected");
            } else {
              throw std::runtime_error("Zero positional arguments expected");
            }
          } else {
            throw std::runtime_error("Maximum number of positional arguments "
                                     "exceeded, failed to parse '" +
                                     current_argument + "'");
          }
        }
        auto argument = positional_argument_it++;

        // Deal with the situation of <positional_arg1>... <positional_arg2>
        if (argument->m_num_args_range.get_min() == 1 &&
            argument->m_num_args_range.get_max() == (std::numeric_limits<std::size_t>::max)() &&
            positional_argument_it != std::end(m_positional_arguments) &&
            std::next(positional_argument_it) == std::end(m_positional_arguments) &&
            positional_argument_it->m_num_args_range.get_min() == 1 &&
            positional_argument_it->m_num_args_range.get_max() == 1 ) {
          if (std::next(it) != end) {
            positional_argument_it->consume(std::prev(end), end);
            end = std::prev(end);
          } else {
            throw std::runtime_error("Missing " + positional_argument_it->m_names.front());
          }
        }

        it = argument->consume(it, end);
        continue;
      }

      auto arg_map_it = m_argument_map.find(current_argument);
      if (arg_map_it != m_argument_map.end()) {
        auto argument = arg_map_it->second;
        it = argument->consume(std::next(it), end, arg_map_it->first);
      } else if (const auto &compound_arg = current_argument;
                 compound_arg.size() > 1 &&
                 is_valid_prefix_char(compound_arg[0]) &&
                 !is_valid_prefix_char(compound_arg[1])) {
        ++it;
        for (std::size_t j = 1; j < compound_arg.size(); j++) {
          auto hypothetical_arg = std::string{'-', compound_arg[j]};
          auto arg_map_it2 = m_argument_map.find(hypothetical_arg);
          if (arg_map_it2 != m_argument_map.end()) {
            auto argument = arg_map_it2->second;
            it = argument->consume(it, end, arg_map_it2->first);
          } else {
            throw std::runtime_error("Unknown argument: " + current_argument);
          }
        }
      } else {
        throw std::runtime_error("Unknown argument: " + current_argument);
      }
    }
    m_is_parsed = true;
  }

  /*
   * Like parse_args_internal but collects unused args into a vector<string>
   */
  std::vector<std::string>
  parse_known_args_internal(const std::vector<std::string> &raw_arguments) {
    auto arguments = preprocess_arguments(raw_arguments);

    std::vector<std::string> unknown_arguments{};

    if (m_program_name.empty() && !arguments.empty()) {
      m_program_name = arguments.front();
    }
    auto end = std::end(arguments);
    auto positional_argument_it = std::begin(m_positional_arguments);
    for (auto it = std::next(std::begin(arguments)); it != end;) {
      const auto &current_argument = *it;
      if (Argument::is_positional(current_argument, m_prefix_chars)) {
        if (positional_argument_it == std::end(m_positional_arguments)) {

          // Check sub-parsers
          auto subparser_it = m_subparser_map.find(current_argument);
          if (subparser_it != m_subparser_map.end()) {

            // build list of remaining args
            const auto unprocessed_arguments =
                std::vector<std::string>(it, end);

            // invoke subparser
            m_is_parsed = true;
            m_subparser_used[current_argument] = true;
            return subparser_it->second->get().parse_known_args_internal(
                unprocessed_arguments);
          }

          // save current argument as unknown and go to next argument
          unknown_arguments.push_back(current_argument);
          ++it;
        } else {
          // current argument is the value of a positional argument
          // consume it
          auto argument = positional_argument_it++;
          it = argument->consume(it, end);
        }
        continue;
      }

      auto arg_map_it = m_argument_map.find(current_argument);
      if (arg_map_it != m_argument_map.end()) {
        auto argument = arg_map_it->second;
        it = argument->consume(std::next(it), end, arg_map_it->first);
      } else if (const auto &compound_arg = current_argument;
                 compound_arg.size() > 1 &&
                 is_valid_prefix_char(compound_arg[0]) &&
                 !is_valid_prefix_char(compound_arg[1])) {
        ++it;
        for (std::size_t j = 1; j < compound_arg.size(); j++) {
          auto hypothetical_arg = std::string{'-', compound_arg[j]};
          auto arg_map_it2 = m_argument_map.find(hypothetical_arg);
          if (arg_map_it2 != m_argument_map.end()) {
            auto argument = arg_map_it2->second;
            it = argument->consume(it, end, arg_map_it2->first);
          } else {
            unknown_arguments.push_back(current_argument);
            break;
          }
        }
      } else {
        // current argument is an optional-like argument that is unknown
        // save it and move to next argument
        unknown_arguments.push_back(current_argument);
        ++it;
      }
    }
    m_is_parsed = true;
    return unknown_arguments;
  }

  // Used by print_help.
  std::size_t get_length_of_longest_argument() const {
    if (m_argument_map.empty()) {
      return 0;
    }
    std::size_t max_size = 0;
    for ([[maybe_unused]] const auto &[unused, argument] : m_argument_map) {
      max_size =
          std::max<std::size_t>(max_size, argument->get_arguments_length());
    }
    for ([[maybe_unused]] const auto &[command, unused] : m_subparser_map) {
      max_size = std::max<std::size_t>(max_size, command.size());
    }
    return max_size;
  }

  using argument_it = std::list<Argument>::iterator;
  using mutex_group_it = std::vector<MutuallyExclusiveGroup>::iterator;
  using argument_parser_it =
      std::list<std::reference_wrapper<ArgumentParser>>::iterator;

  void index_argument(argument_it it) {
    for (const auto &name : std::as_const(it->m_names)) {
      m_argument_map.insert_or_assign(name, it);
    }
  }

  std::string m_program_name;
  std::string m_version;
  std::string m_description;
  std::string m_epilog;
  bool m_exit_on_default_arguments = true;
  std::string m_prefix_chars{"-"};
  std::string m_assign_chars{"="};
  bool m_is_parsed = false;
  std::list<Argument> m_positional_arguments;
  std::list<Argument> m_optional_arguments;
  std::map<std::string, argument_it> m_argument_map;
  std::string m_parser_path;
  std::list<std::reference_wrapper<ArgumentParser>> m_subparsers;
  std::map<std::string, argument_parser_it> m_subparser_map;
  std::map<std::string, bool> m_subparser_used;
  std::vector<MutuallyExclusiveGroup> m_mutually_exclusive_groups;
  bool m_suppress = false;
  std::size_t m_usage_max_line_width = (std::numeric_limits<std::size_t>::max)();
  bool m_usage_break_on_mutex = false;
  int m_usage_newline_counter = 0;
  std::vector<std::string> m_group_names;
};

} // namespace argparse
```

`covirt/utils/indicators.hpp`:

```hpp
// MIT License

// Copyright (c) 2019 Pranav

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef INDICATORS_COLOR
#define INDICATORS_COLOR

namespace indicators {
enum class Color { grey, red, green, yellow, blue, magenta, cyan, white, unspecified };
}

#endif



#ifndef INDICATORS_FONT_STYLE
#define INDICATORS_FONT_STYLE

namespace indicators {
enum class FontStyle { bold, dark, italic, underline, blink, reverse, concealed, crossed };
}

#endif



#ifndef INDICATORS_PROGRESS_TYPE
#define INDICATORS_PROGRESS_TYPE

namespace indicators {
enum class ProgressType { incremental, decremental };
}

#endif

//!
//! termcolor
//! ~~~~~~~~~
//!
//! termcolor is a header-only c++ library for printing colored messages
//! to the terminal. Written just for fun with a help of the Force.
//!
//! :copyright: (c) 2013 by Ihor Kalnytskyi
//! :license: BSD, see LICENSE for details
//!

#ifndef TERMCOLOR_HPP_
#define TERMCOLOR_HPP_

#include <iostream>
#include <cstdio>
#include <cstdint>

// Detect target's platform and set some macros in order to wrap platform
// specific code this library depends on.
#if defined(_WIN32) || defined(_WIN64)
#   define TERMCOLOR_TARGET_WINDOWS
#elif defined(__unix__) || defined(__unix) || (defined(__APPLE__) && defined(__MACH__))
#   define TERMCOLOR_TARGET_POSIX
#endif

// If implementation has not been explicitly set, try to choose one based on
// target platform.
#if !defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES) && !defined(TERMCOLOR_USE_WINDOWS_API) && !defined(TERMCOLOR_USE_NOOP)
#   if defined(TERMCOLOR_TARGET_POSIX)
#       define TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES
#       define TERMCOLOR_AUTODETECTED_IMPLEMENTATION
#   elif defined(TERMCOLOR_TARGET_WINDOWS)
#       define TERMCOLOR_USE_WINDOWS_API
#       define TERMCOLOR_AUTODETECTED_IMPLEMENTATION
#   endif
#endif

// These headers provide isatty()/fileno() functions, which are used for
// testing whether a standard stream refers to the terminal.
#if defined(TERMCOLOR_TARGET_POSIX)
#   include <unistd.h>
#elif defined(TERMCOLOR_TARGET_WINDOWS)
#if defined(_MSC_VER)
#if !defined(NOMINMAX)
#define NOMINMAX
#endif
#endif
#   include <io.h>
#   include <windows.h>
#endif


namespace termcolor
{
    // Forward declaration of the `_internal` namespace.
    // All comments are below.
    namespace _internal
    {
        inline int colorize_index();
        inline FILE* get_standard_stream(const std::ostream& stream);
        inline bool is_colorized(std::ostream& stream);
        inline bool is_atty(const std::ostream& stream);

    #if defined(TERMCOLOR_TARGET_WINDOWS)
        inline void win_change_attributes(std::ostream& stream, int foreground, int background=-1);
    #endif
    }

    inline
    std::ostream& colorize(std::ostream& stream)
    {
        stream.iword(_internal::colorize_index()) = 1L;
        return stream;
    }

    inline
    std::ostream& nocolorize(std::ostream& stream)
    {
        stream.iword(_internal::colorize_index()) = 0L;
        return stream;
    }

    inline
    std::ostream& reset(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[00m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1, -1);
        #endif
        }
        return stream;
    }

    inline
    std::ostream& bold(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[1m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
        #endif
        }
        return stream;
    }

    inline
    std::ostream& dark(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[2m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
        #endif
        }
        return stream;
    }

    inline
    std::ostream& italic(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[3m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
        #endif
        }
        return stream;
    }

    inline
    std::ostream& underline(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[4m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1, COMMON_LVB_UNDERSCORE);
        #endif
        }
        return stream;
    }

    inline
    std::ostream& blink(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[5m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
        #endif
        }
        return stream;
    }

    inline
    std::ostream& reverse(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[7m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
        #endif
        }
        return stream;
    }

    inline
    std::ostream& concealed(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[8m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
        #endif
        }
        return stream;
    }

    inline
    std::ostream& crossed(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[9m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
        #endif
        }
        return stream;
    }

    template <uint8_t code> inline
    std::ostream& color(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            char command[12];
            std::snprintf(command, sizeof(command), "\033[38;5;%dm", code);
            stream << command;
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
        #endif
        }
        return stream;
    }

    template <uint8_t code> inline
    std::ostream& on_color(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            char command[12];
            std::snprintf(command, sizeof(command), "\033[48;5;%dm", code);
            stream << command;
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
        #endif
        }
        return stream;
    }

    template <uint8_t r, uint8_t g, uint8_t b> inline
    std::ostream& color(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            char command[20];
            std::snprintf(command, sizeof(command), "\033[38;2;%d;%d;%dm", r, g, b);
            stream << command;
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
        #endif
        }
        return stream;
    }

    template <uint8_t r, uint8_t g, uint8_t b> inline
    std::ostream& on_color(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            char command[20];
            std::snprintf(command, sizeof(command), "\033[48;2;%d;%d;%dm", r, g, b);
            stream << command;
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
        #endif
        }
        return stream;
    }

    inline
    std::ostream& grey(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[30m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                0   // grey (black)
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& red(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[31m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                FOREGROUND_RED
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& green(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[32m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                FOREGROUND_GREEN
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& yellow(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[33m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                FOREGROUND_GREEN | FOREGROUND_RED
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& blue(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[34m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                FOREGROUND_BLUE
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& magenta(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[35m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                FOREGROUND_BLUE | FOREGROUND_RED
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& cyan(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[36m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                FOREGROUND_BLUE | FOREGROUND_GREEN
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& white(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[37m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED
            );
        #endif
        }
        return stream;
    }


    inline
    std::ostream& bright_grey(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[90m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                0 | FOREGROUND_INTENSITY   // grey (black)
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& bright_red(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[91m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                FOREGROUND_RED | FOREGROUND_INTENSITY
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& bright_green(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[92m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                FOREGROUND_GREEN | FOREGROUND_INTENSITY
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& bright_yellow(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[93m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& bright_blue(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[94m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                FOREGROUND_BLUE | FOREGROUND_INTENSITY
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& bright_magenta(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[95m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_INTENSITY
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& bright_cyan(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[96m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_INTENSITY
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& bright_white(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[97m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream,
                FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY
            );
        #endif
        }
        return stream;
    }


    inline
    std::ostream& on_grey(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[40m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                0   // grey (black)
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& on_red(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[41m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                BACKGROUND_RED
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& on_green(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[42m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                BACKGROUND_GREEN
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& on_yellow(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[43m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                BACKGROUND_GREEN | BACKGROUND_RED
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& on_blue(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[44m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                BACKGROUND_BLUE
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& on_magenta(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[45m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                BACKGROUND_BLUE | BACKGROUND_RED
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& on_cyan(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[46m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                BACKGROUND_GREEN | BACKGROUND_BLUE
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& on_white(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[47m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                BACKGROUND_GREEN | BACKGROUND_BLUE | BACKGROUND_RED
            );
        #endif
        }

        return stream;
    }


    inline
    std::ostream& on_bright_grey(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[100m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                0 | BACKGROUND_INTENSITY   // grey (black)
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& on_bright_red(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[101m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                BACKGROUND_RED | BACKGROUND_INTENSITY
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& on_bright_green(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[102m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                BACKGROUND_GREEN | BACKGROUND_INTENSITY
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& on_bright_yellow(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[103m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& on_bright_blue(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[104m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                BACKGROUND_BLUE | BACKGROUND_INTENSITY
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& on_bright_magenta(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[105m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                BACKGROUND_BLUE | BACKGROUND_RED | BACKGROUND_INTENSITY
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& on_bright_cyan(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[106m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                BACKGROUND_GREEN | BACKGROUND_BLUE | BACKGROUND_INTENSITY
            );
        #endif
        }
        return stream;
    }

    inline
    std::ostream& on_bright_white(std::ostream& stream)
    {
        if (_internal::is_colorized(stream))
        {
        #if defined(TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES)
            stream << "\033[107m";
        #elif defined(TERMCOLOR_USE_WINDOWS_API)
            _internal::win_change_attributes(stream, -1,
                BACKGROUND_GREEN | BACKGROUND_BLUE | BACKGROUND_RED | BACKGROUND_INTENSITY
            );
        #endif
        }

        return stream;
    }



    //! Since C++ hasn't a way to hide something in the header from
    //! the outer access, I have to introduce this namespace which
    //! is used for internal purpose and should't be access from
    //! the user code.
    namespace _internal
    {
        // An index to be used to access a private storage of I/O streams. See
        // colorize / nocolorize I/O manipulators for details. Due to the fact
        // that static variables ain't shared between translation units, inline
        // function with local static variable is used to do the trick and share
        // the variable value between translation units.
        inline int colorize_index()
        {
            static int colorize_index = std::ios_base::xalloc();
            return colorize_index;
        }

        //! Since C++ hasn't a true way to extract stream handler
        //! from the a given `std::ostream` object, I have to write
        //! this kind of hack.
        inline
        FILE* get_standard_stream(const std::ostream& stream)
        {
            if (&stream == &std::cout)
                return stdout;
            else if ((&stream == &std::cerr) || (&stream == &std::clog))
                return stderr;

            return nullptr;
        }

        // Say whether a given stream should be colorized or not. It's always
        // true for ATTY streams and may be true for streams marked with
        // colorize flag.
        inline
        bool is_colorized(std::ostream& stream)
        {
            return is_atty(stream) || static_cast<bool>(stream.iword(colorize_index()));
        }

        //! Test whether a given `std::ostream` object refers to
        //! a terminal.
        inline
        bool is_atty(const std::ostream& stream)
        {
            FILE* std_stream = get_standard_stream(stream);

            // Unfortunately, fileno() ends with segmentation fault
            // if invalid file descriptor is passed. So we need to
            // handle this case gracefully and assume it's not a tty
            // if standard stream is not detected, and 0 is returned.
            if (!std_stream)
                return false;

        #if defined(TERMCOLOR_TARGET_POSIX)
            return ::isatty(fileno(std_stream));
        #elif defined(TERMCOLOR_TARGET_WINDOWS)
            return ::_isatty(_fileno(std_stream));
        #else
            return false;
        #endif
        }

    #if defined(TERMCOLOR_TARGET_WINDOWS)
        //! Change Windows Terminal colors attribute. If some
        //! parameter is `-1` then attribute won't changed.
        inline void win_change_attributes(std::ostream& stream, int foreground, int background)
        {
            // yeah, i know.. it's ugly, it's windows.
            static WORD defaultAttributes = 0;

            // Windows doesn't have ANSI escape sequences and so we use special
            // API to change Terminal output color. That means we can't
            // manipulate colors by means of "std::stringstream" and hence
            // should do nothing in this case.
            if (!_internal::is_atty(stream))
                return;

            // get terminal handle
            HANDLE hTerminal = INVALID_HANDLE_VALUE;
            if (&stream == &std::cout)
                hTerminal = GetStdHandle(STD_OUTPUT_HANDLE);
            else if (&stream == &std::cerr)
                hTerminal = GetStdHandle(STD_ERROR_HANDLE);

            // save default terminal attributes if it unsaved
            if (!defaultAttributes)
            {
                CONSOLE_SCREEN_BUFFER_INFO info;
                if (!GetConsoleScreenBufferInfo(hTerminal, &info))
                    return;
                defaultAttributes = info.wAttributes;
            }

            // restore all default settings
            if (foreground == -1 && background == -1)
            {
                SetConsoleTextAttribute(hTerminal, defaultAttributes);
                return;
            }

            // get current settings
            CONSOLE_SCREEN_BUFFER_INFO info;
            if (!GetConsoleScreenBufferInfo(hTerminal, &info))
                return;

            if (foreground != -1)
            {
                info.wAttributes &= ~(info.wAttributes & 0x0F);
                info.wAttributes |= static_cast<WORD>(foreground);
            }

            if (background != -1)
            {
                info.wAttributes &= ~(info.wAttributes & 0xF0);
                info.wAttributes |= static_cast<WORD>(background);
            }

            SetConsoleTextAttribute(hTerminal, info.wAttributes);
        }
    #endif // TERMCOLOR_TARGET_WINDOWS

    } // namespace _internal

} // namespace termcolor


#undef TERMCOLOR_TARGET_POSIX
#undef TERMCOLOR_TARGET_WINDOWS

#if defined(TERMCOLOR_AUTODETECTED_IMPLEMENTATION)
#   undef TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES
#   undef TERMCOLOR_USE_WINDOWS_API
#endif

#endif // TERMCOLOR_HPP_



#ifndef INDICATORS_TERMINAL_SIZE
#define INDICATORS_TERMINAL_SIZE
#include <utility>


#if defined(_WIN32)
#include <windows.h>

namespace indicators {

static inline std::pair<size_t, size_t> terminal_size() {
  CONSOLE_SCREEN_BUFFER_INFO csbi;
  int cols, rows;
  GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
  cols = csbi.srWindow.Right - csbi.srWindow.Left + 1;
  rows = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
  return {static_cast<size_t>(rows), static_cast<size_t>(cols)};
}

static inline size_t terminal_width() { return terminal_size().second; }

} // namespace indicators

#else

#include <sys/ioctl.h> //ioctl() and TIOCGWINSZ
#include <unistd.h>    // for STDOUT_FILENO

namespace indicators {

static inline std::pair<size_t, size_t> terminal_size() {
  struct winsize size{};
  ioctl(STDOUT_FILENO, TIOCGWINSZ, &size);
  return {static_cast<size_t>(size.ws_row), static_cast<size_t>(size.ws_col)};
}

static inline size_t terminal_width() { return terminal_size().second; }

} // namespace indicators

#endif

#endif


/*
Activity Indicators for Modern C++
https://github.com/p-ranav/indicators

Licensed under the MIT License <http://opensource.org/licenses/MIT>.
SPDX-License-Identifier: MIT
Copyright (c) 2019 Dawid Pilarski <dawid.pilarski@panicsoftware.com>.

Permission is hereby  granted, free of charge, to any  person obtaining a copy
of this software and associated  documentation files (the "Software"), to deal
in the Software  without restriction, including without  limitation the rights
to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#ifndef INDICATORS_SETTING
#define INDICATORS_SETTING

#include <cstddef>
// #include <indicators/color.hpp>
// #include <indicators/font_style.hpp>
// #include <indicators/progress_type.hpp>
#include <string>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>

namespace indicators {

namespace details {

template <bool condition> struct if_else;

template <> struct if_else<true> { using type = std::true_type; };

template <> struct if_else<false> { using type = std::false_type; };

template <bool condition, typename True, typename False> struct if_else_type;

template <typename True, typename False> struct if_else_type<true, True, False> {
  using type = True;
};

template <typename True, typename False> struct if_else_type<false, True, False> {
  using type = False;
};

template <typename... Ops> struct conjuction;

template <> struct conjuction<> : std::true_type {};

template <typename Op, typename... TailOps>
struct conjuction<Op, TailOps...>
    : if_else_type<!Op::value, std::false_type, conjuction<TailOps...>>::type {};

template <typename... Ops> struct disjunction;

template <> struct disjunction<> : std::false_type {};

template <typename Op, typename... TailOps>
struct disjunction<Op, TailOps...>
    : if_else_type<Op::value, std::true_type, disjunction<TailOps...>>::type {};

enum class ProgressBarOption {
  bar_width = 0,
  prefix_text,
  postfix_text,
  start,
  end,
  fill,
  lead,
  remainder,
  max_postfix_text_len,
  completed,
  show_percentage,
  show_elapsed_time,
  show_remaining_time,
  saved_start_time,
  foreground_color,
  spinner_show,
  spinner_states,
  font_styles,
  hide_bar_when_complete,
  min_progress,
  max_progress,
  progress_type,
  stream
};

template <typename T, ProgressBarOption Id> struct Setting {
  template <typename... Args,
            typename = typename std::enable_if<std::is_constructible<T, Args...>::value>::type>
  explicit Setting(Args &&... args) : value(std::forward<Args>(args)...) {}
  Setting(const Setting &) = default;
  Setting(Setting &&) = default;

  static constexpr auto id = Id;
  using type = T;

  T value{};
};

template <typename T> struct is_setting : std::false_type {};

template <ProgressBarOption Id, typename T> struct is_setting<Setting<T, Id>> : std::true_type {};

template <typename... Args>
struct are_settings : if_else<conjuction<is_setting<Args>...>::value>::type {};

template <> struct are_settings<> : std::true_type {};

template <typename Setting, typename Tuple> struct is_setting_from_tuple;

template <typename Setting> struct is_setting_from_tuple<Setting, std::tuple<>> : std::true_type {};

template <typename Setting, typename... TupleTypes>
struct is_setting_from_tuple<Setting, std::tuple<TupleTypes...>>
    : if_else<disjunction<std::is_same<Setting, TupleTypes>...>::value>::type {};

template <typename Tuple, typename... Settings>
struct are_settings_from_tuple
    : if_else<conjuction<is_setting_from_tuple<Settings, Tuple>...>::value>::type {};

template <ProgressBarOption Id> struct always_true { static constexpr auto value = true; };

template <ProgressBarOption Id, typename Default> Default &&get_impl(Default &&def) {
  return std::forward<Default>(def);
}

template <ProgressBarOption Id, typename Default, typename T, typename... Args>
auto get_impl(Default && /*def*/, T &&first, Args &&... /*tail*/) ->
    typename std::enable_if<(std::decay<T>::type::id == Id),
                            decltype(std::forward<T>(first))>::type {
  return std::forward<T>(first);
}

template <ProgressBarOption Id, typename Default, typename T, typename... Args>
auto get_impl(Default &&def, T && /*first*/, Args &&... tail) ->
    typename std::enable_if<(std::decay<T>::type::id != Id),
                            decltype(get_impl<Id>(std::forward<Default>(def),
                                                  std::forward<Args>(tail)...))>::type {
  return get_impl<Id>(std::forward<Default>(def), std::forward<Args>(tail)...);
}

template <ProgressBarOption Id, typename Default, typename... Args,
          typename = typename std::enable_if<are_settings<Args...>::value, void>::type>
auto get(Default &&def, Args &&... args)
    -> decltype(details::get_impl<Id>(std::forward<Default>(def), std::forward<Args>(args)...)) {
  return details::get_impl<Id>(std::forward<Default>(def), std::forward<Args>(args)...);
}

template <ProgressBarOption Id> using StringSetting = Setting<std::string, Id>;

template <ProgressBarOption Id> using IntegerSetting = Setting<std::size_t, Id>;

template <ProgressBarOption Id> using BooleanSetting = Setting<bool, Id>;

template <ProgressBarOption Id, typename Tuple, std::size_t counter = 0> struct option_idx;

template <ProgressBarOption Id, typename T, typename... Settings, std::size_t counter>
struct option_idx<Id, std::tuple<T, Settings...>, counter>
    : if_else_type<(Id == T::id), std::integral_constant<std::size_t, counter>,
                   option_idx<Id, std::tuple<Settings...>, counter + 1>>::type {};

template <ProgressBarOption Id, std::size_t counter> struct option_idx<Id, std::tuple<>, counter> {
  static_assert(always_true<(ProgressBarOption)Id>::value, "No such option was found");
};

template <ProgressBarOption Id, typename Settings>
auto get_value(Settings &&settings)
    -> decltype((std::get<option_idx<Id, typename std::decay<Settings>::type>::value>(
        std::declval<Settings &&>()))) {
  return std::get<option_idx<Id, typename std::decay<Settings>::type>::value>(
      std::forward<Settings>(settings));
}

} // namespace details

namespace option {
using BarWidth = details::IntegerSetting<details::ProgressBarOption::bar_width>;
using PrefixText = details::StringSetting<details::ProgressBarOption::prefix_text>;
using PostfixText = details::StringSetting<details::ProgressBarOption::postfix_text>;
using Start = details::StringSetting<details::ProgressBarOption::start>;
using End = details::StringSetting<details::ProgressBarOption::end>;
using Fill = details::StringSetting<details::ProgressBarOption::fill>;
using Lead = details::StringSetting<details::ProgressBarOption::lead>;
using Remainder = details::StringSetting<details::ProgressBarOption::remainder>;
using MaxPostfixTextLen = details::IntegerSetting<details::ProgressBarOption::max_postfix_text_len>;
using Completed = details::BooleanSetting<details::ProgressBarOption::completed>;
using ShowPercentage = details::BooleanSetting<details::ProgressBarOption::show_percentage>;
using ShowElapsedTime = details::BooleanSetting<details::ProgressBarOption::show_elapsed_time>;
using ShowRemainingTime = details::BooleanSetting<details::ProgressBarOption::show_remaining_time>;
using SavedStartTime = details::BooleanSetting<details::ProgressBarOption::saved_start_time>;
using ForegroundColor = details::Setting<Color, details::ProgressBarOption::foreground_color>;
using ShowSpinner = details::BooleanSetting<details::ProgressBarOption::spinner_show>;
using SpinnerStates =
    details::Setting<std::vector<std::string>, details::ProgressBarOption::spinner_states>;
using HideBarWhenComplete =
    details::BooleanSetting<details::ProgressBarOption::hide_bar_when_complete>;
using FontStyles =
    details::Setting<std::vector<FontStyle>, details::ProgressBarOption::font_styles>;
using MinProgress = details::IntegerSetting<details::ProgressBarOption::min_progress>;
using MaxProgress = details::IntegerSetting<details::ProgressBarOption::max_progress>;
using ProgressType = details::Setting<ProgressType, details::ProgressBarOption::progress_type>;
using Stream = details::Setting<std::ostream &, details::ProgressBarOption::stream>;
} // namespace option
} // namespace indicators

#endif


#ifndef INDICATORS_CURSOR_CONTROL
#define INDICATORS_CURSOR_CONTROL

#if defined(_MSC_VER)
#if !defined(NOMINMAX)
#define NOMINMAX
#endif
#include <io.h>
#include <windows.h>
#else
#include <cstdio>
#endif

namespace indicators {

#if defined(_MSC_VER)

static inline void show_console_cursor(bool const show) {
  HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE);

  CONSOLE_CURSOR_INFO cursorInfo;

  GetConsoleCursorInfo(out, &cursorInfo);
  cursorInfo.bVisible = show; // set the cursor visibility
  SetConsoleCursorInfo(out, &cursorInfo);
}

static inline void erase_line() {
  auto hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
  if (!hStdout)
    return;

  CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
  GetConsoleScreenBufferInfo(hStdout, &csbiInfo);

  COORD cursor;

  cursor.X = 0;
  cursor.Y = csbiInfo.dwCursorPosition.Y;

  DWORD count = 0;

  FillConsoleOutputCharacterA(hStdout, ' ', csbiInfo.dwSize.X, cursor, &count);

  FillConsoleOutputAttribute(hStdout, csbiInfo.wAttributes, csbiInfo.dwSize.X,
                             cursor, &count);

  SetConsoleCursorPosition(hStdout, cursor);
}

#else

static inline void show_console_cursor(bool const show) {
  std::fputs(show ? "\033[?25h" : "\033[?25l", stdout);
}

static inline void erase_line() {
  std::fputs("\r\033[K", stdout);
}

#endif

} // namespace indicators

#endif


#ifndef INDICATORS_CURSOR_MOVEMENT
#define INDICATORS_CURSOR_MOVEMENT

#if defined(_MSC_VER)
#if !defined(NOMINMAX)
#define NOMINMAX
#endif
#include <io.h>
#include <windows.h>
#else
#include <iostream>
#endif

namespace indicators {

#ifdef _MSC_VER

static inline void move(int x, int y) {
  auto hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
  if (!hStdout)
    return;

  CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
  GetConsoleScreenBufferInfo(hStdout, &csbiInfo);

  COORD cursor;

  cursor.X = csbiInfo.dwCursorPosition.X + x;
  cursor.Y = csbiInfo.dwCursorPosition.Y + y;
  SetConsoleCursorPosition(hStdout, cursor);
}

static inline void move_up(int lines) { move(0, -lines); }
static inline void move_down(int lines) { move(0, -lines); }
static inline void move_right(int cols) { move(cols, 0); }
static inline void move_left(int cols) { move(-cols, 0); }

#else

static inline void move_up(int lines) { std::cout << "\033[" << lines << "A"; }
static inline void move_down(int lines) { std::cout << "\033[" << lines << "B"; }
static inline void move_right(int cols) { std::cout << "\033[" << cols << "C"; }
static inline void move_left(int cols) { std::cout << "\033[" << cols << "D"; }

#endif

} // namespace indicators

#endif


#ifndef INDICATORS_STREAM_HELPER
#define INDICATORS_STREAM_HELPER

// #include <indicators/display_width.hpp>
#ifndef INDICATORS_DISPLAY_WIDTH
#define INDICATORS_DISPLAY_WIDTH

#include <clocale>
#include <cstdlib>
#include <locale>
#include <string>
#include <wchar.h>

namespace unicode {

namespace details {

/*
 * This is an implementation of wcwidth() and wcswidth() (defined in
 * IEEE Std 1002.1-2001) for Unicode.
 *
 * http://www.opengroup.org/onlinepubs/007904975/functions/wcwidth.html
 * http://www.opengroup.org/onlinepubs/007904975/functions/wcswidth.html
 *
 * In fixed-width output devices, Latin characters all occupy a single
 * "cell" position of equal width, whereas ideographic CJK characters
 * occupy two such cells. Interoperability between terminal-line
 * applications and (teletype-style) character terminals using the
 * UTF-8 encoding requires agreement on which character should advance
 * the cursor by how many cell positions. No established formal
 * standards exist at present on which Unicode character shall occupy
 * how many cell positions on character terminals. These routines are
 * a first attempt of defining such behavior based on simple rules
 * applied to data provided by the Unicode Consortium.
 *
 * For some graphical characters, the Unicode standard explicitly
 * defines a character-cell width via the definition of the East Asian
 * FullWidth (F), Wide (W), Half-width (H), and Narrow (Na) classes.
 * In all these cases, there is no ambiguity about which width a
 * terminal shall use. For characters in the East Asian Ambiguous (A)
 * class, the width choice depends purely on a preference of backward
 * compatibility with either historic CJK or Western practice.
 * Choosing single-width for these characters is easy to justify as
 * the appropriate long-term solution, as the CJK practice of
 * displaying these characters as double-width comes from historic
 * implementation simplicity (8-bit encoded characters were displayed
 * single-width and 16-bit ones double-width, even for Greek,
 * Cyrillic, etc.) and not any typographic considerations.
 *
 * Much less clear is the choice of width for the Not East Asian
 * (Neutral) class. Existing practice does not dictate a width for any
 * of these characters. It would nevertheless make sense
 * typographically to allocate two character cells to characters such
 * as for instance EM SPACE or VOLUME INTEGRAL, which cannot be
 * represented adequately with a single-width glyph. The following
 * routines at present merely assign a single-cell width to all
 * neutral characters, in the interest of simplicity. This is not
 * entirely satisfactory and should be reconsidered before
 * establishing a formal standard in this area. At the moment, the
 * decision which Not East Asian (Neutral) characters should be
 * represented by double-width glyphs cannot yet be answered by
 * applying a simple rule from the Unicode database content. Setting
 * up a proper standard for the behavior of UTF-8 character terminals
 * will require a careful analysis not only of each Unicode character,
 * but also of each presentation form, something the author of these
 * routines has avoided to do so far.
 *
 * http://www.unicode.org/unicode/reports/tr11/
 *
 * Markus Kuhn -- 2007-05-26 (Unicode 5.0)
 *
 * Permission to use, copy, modify, and distribute this software
 * for any purpose and without fee is hereby granted. The author
 * disclaims all warranties with regard to this software.
 *
 * Latest version: http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c
 */

struct interval {
  int first;
  int last;
};

/* auxiliary function for binary search in interval table */
static inline int bisearch(wchar_t ucs, const struct interval *table, int max) {
  int min = 0;
  int mid;

  if (ucs < table[0].first || ucs > table[max].last)
    return 0;
  while (max >= min) {
    mid = (min + max) / 2;
    if (ucs > table[mid].last)
      min = mid + 1;
    else if (ucs < table[mid].first)
      max = mid - 1;
    else
      return 1;
  }

  return 0;
}

/* The following two functions define the column width of an ISO 10646
 * character as follows:
 *
 *    - The null character (U+0000) has a column width of 0.
 *
 *    - Other C0/C1 control characters and DEL will lead to a return
 *      value of -1.
 *
 *    - Non-spacing and enclosing combining characters (general
 *      category code Mn or Me in the Unicode database) have a
 *      column width of 0.
 *
 *    - SOFT HYPHEN (U+00AD) has a column width of 1.
 *
 *    - Other format characters (general category code Cf in the Unicode
 *      database) and ZERO WIDTH SPACE (U+200B) have a column width of 0.
 *
 *    - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
 *      have a column width of 0.
 *
 *    - Spacing characters in the East Asian Wide (W) or East Asian
 *      Full-width (F) category as defined in Unicode Technical
 *      Report #11 have a column width of 2.
 *
 *    - All remaining characters (including all printable
 *      ISO 8859-1 and WGL4 characters, Unicode control characters,
 *      etc.) have a column width of 1.
 *
 * This implementation assumes that wchar_t characters are encoded
 * in ISO 10646.
 */

static inline int mk_wcwidth(wchar_t ucs) {
  /* sorted list of non-overlapping intervals of non-spacing characters */
  /* generated by "uniset +cat=Me +cat=Mn +cat=Cf -00AD +1160-11FF +200B c" */
  static const struct interval combining[] = {
      {0x0300, 0x036F},   {0x0483, 0x0486},   {0x0488, 0x0489},
      {0x0591, 0x05BD},   {0x05BF, 0x05BF},   {0x05C1, 0x05C2},
      {0x05C4, 0x05C5},   {0x05C7, 0x05C7},   {0x0600, 0x0603},
      {0x0610, 0x0615},   {0x064B, 0x065E},   {0x0670, 0x0670},
      {0x06D6, 0x06E4},   {0x06E7, 0x06E8},   {0x06EA, 0x06ED},
      {0x070F, 0x070F},   {0x0711, 0x0711},   {0x0730, 0x074A},
      {0x07A6, 0x07B0},   {0x07EB, 0x07F3},   {0x0901, 0x0902},
      {0x093C, 0x093C},   {0x0941, 0x0948},   {0x094D, 0x094D},
      {0x0951, 0x0954},   {0x0962, 0x0963},   {0x0981, 0x0981},
      {0x09BC, 0x09BC},   {0x09C1, 0x09C4},   {0x09CD, 0x09CD},
      {0x09E2, 0x09E3},   {0x0A01, 0x0A02},   {0x0A3C, 0x0A3C},
      {0x0A41, 0x0A42},   {0x0A47, 0x0A48},   {0x0A4B, 0x0A4D},
      {0x0A70, 0x0A71},   {0x0A81, 0x0A82},   {0x0ABC, 0x0ABC},
      {0x0AC1, 0x0AC5},   {0x0AC7, 0x0AC8},   {0x0ACD, 0x0ACD},
      {0x0AE2, 0x0AE3},   {0x0B01, 0x0B01},   {0x0B3C, 0x0B3C},
      {0x0B3F, 0x0B3F},   {0x0B41, 0x0B43},   {0x0B4D, 0x0B4D},
      {0x0B56, 0x0B56},   {0x0B82, 0x0B82},   {0x0BC0, 0x0BC0},
      {0x0BCD, 0x0BCD},   {0x0C3E, 0x0C40},   {0x0C46, 0x0C48},
      {0x0C4A, 0x0C4D},   {0x0C55, 0x0C56},   {0x0CBC, 0x0CBC},
      {0x0CBF, 0x0CBF},   {0x0CC6, 0x0CC6},   {0x0CCC, 0x0CCD},
      {0x0CE2, 0x0CE3},   {0x0D41, 0x0D43},   {0x0D4D, 0x0D4D},
      {0x0DCA, 0x0DCA},   {0x0DD2, 0x0DD4},   {0x0DD6, 0x0DD6},
      {0x0E31, 0x0E31},   {0x0E34, 0x0E3A},   {0x0E47, 0x0E4E},
      {0x0EB1, 0x0EB1},   {0x0EB4, 0x0EB9},   {0x0EBB, 0x0EBC},
      {0x0EC8, 0x0ECD},   {0x0F18, 0x0F19},   {0x0F35, 0x0F35},
      {0x0F37, 0x0F37},   {0x0F39, 0x0F39},   {0x0F71, 0x0F7E},
      {0x0F80, 0x0F84},   {0x0F86, 0x0F87},   {0x0F90, 0x0F97},
      {0x0F99, 0x0FBC},   {0x0FC6, 0x0FC6},   {0x102D, 0x1030},
      {0x1032, 0x1032},   {0x1036, 0x1037},   {0x1039, 0x1039},
      {0x1058, 0x1059},   {0x1160, 0x11FF},   {0x135F, 0x135F},
      {0x1712, 0x1714},   {0x1732, 0x1734},   {0x1752, 0x1753},
      {0x1772, 0x1773},   {0x17B4, 0x17B5},   {0x17B7, 0x17BD},
      {0x17C6, 0x17C6},   {0x17C9, 0x17D3},   {0x17DD, 0x17DD},
      {0x180B, 0x180D},   {0x18A9, 0x18A9},   {0x1920, 0x1922},
      {0x1927, 0x1928},   {0x1932, 0x1932},   {0x1939, 0x193B},
      {0x1A17, 0x1A18},   {0x1B00, 0x1B03},   {0x1B34, 0x1B34},
      {0x1B36, 0x1B3A},   {0x1B3C, 0x1B3C},   {0x1B42, 0x1B42},
      {0x1B6B, 0x1B73},   {0x1DC0, 0x1DCA},   {0x1DFE, 0x1DFF},
      {0x200B, 0x200F},   {0x202A, 0x202E},   {0x2060, 0x2063},
      {0x206A, 0x206F},   {0x20D0, 0x20EF},   {0x302A, 0x302F},
      {0x3099, 0x309A},   {0xA806, 0xA806},   {0xA80B, 0xA80B},
      {0xA825, 0xA826},   {0xFB1E, 0xFB1E},   {0xFE00, 0xFE0F},
      {0xFE20, 0xFE23},   {0xFEFF, 0xFEFF},   {0xFFF9, 0xFFFB},
      {0x10A01, 0x10A03}, {0x10A05, 0x10A06}, {0x10A0C, 0x10A0F},
      {0x10A38, 0x10A3A}, {0x10A3F, 0x10A3F}, {0x1D167, 0x1D169},
      {0x1D173, 0x1D182}, {0x1D185, 0x1D18B}, {0x1D1AA, 0x1D1AD},
      {0x1D242, 0x1D244}, {0xE0001, 0xE0001}, {0xE0020, 0xE007F},
      {0xE0100, 0xE01EF}};

  /* test for 8-bit control characters */
  if (ucs == 0)
    return 0;
  if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0))
    return -1;

  /* binary search in table of non-spacing characters */
  if (bisearch(ucs, combining, sizeof(combining) / sizeof(struct interval) - 1))
    return 0;

  /* if we arrive here, ucs is not a combining or C0/C1 control character */

  return 1 +
         (ucs >= 0x1100 &&
          (ucs <= 0x115f || /* Hangul Jamo init. consonants */
           ucs == 0x2329 || ucs == 0x232a ||
           (ucs >= 0x2e80 && ucs <= 0xa4cf && ucs != 0x303f) || /* CJK ... Yi */
           (ucs >= 0xac00 && ucs <= 0xd7a3) || /* Hangul Syllables */
           (ucs >= 0xf900 &&
            ucs <= 0xfaff) || /* CJK Compatibility Ideographs */
           (ucs >= 0xfe10 && ucs <= 0xfe19) || /* Vertical forms */
           (ucs >= 0xfe30 && ucs <= 0xfe6f) || /* CJK Compatibility Forms */
           (ucs >= 0xff00 && ucs <= 0xff60) || /* Fullwidth Forms */
           (ucs >= 0xffe0 && ucs <= 0xffe6) ||
           (ucs >= 0x20000 && ucs <= 0x2fffd) ||
           (ucs >= 0x30000 && ucs <= 0x3fffd)));
}

static inline int mk_wcswidth(const wchar_t *pwcs, size_t n) {
  int w, width = 0;

  for (; *pwcs && n-- > 0; pwcs++)
    if ((w = mk_wcwidth(*pwcs)) < 0)
      return -1;
    else
      width += w;

  return width;
}

/*
 * The following functions are the same as mk_wcwidth() and
 * mk_wcswidth(), except that spacing characters in the East Asian
 * Ambiguous (A) category as defined in Unicode Technical Report #11
 * have a column width of 2. This variant might be useful for users of
 * CJK legacy encodings who want to migrate to UCS without changing
 * the traditional terminal character-width behaviour. It is not
 * otherwise recommended for general use.
 */
static inline int mk_wcwidth_cjk(wchar_t ucs) {
  /* sorted list of non-overlapping intervals of East Asian Ambiguous
   * characters, generated by "uniset +WIDTH-A -cat=Me -cat=Mn -cat=Cf c" */
  static const struct interval ambiguous[] = {
      {0x00A1, 0x00A1}, {0x00A4, 0x00A4},   {0x00A7, 0x00A8},
      {0x00AA, 0x00AA}, {0x00AE, 0x00AE},   {0x00B0, 0x00B4},
      {0x00B6, 0x00BA}, {0x00BC, 0x00BF},   {0x00C6, 0x00C6},
      {0x00D0, 0x00D0}, {0x00D7, 0x00D8},   {0x00DE, 0x00E1},
      {0x00E6, 0x00E6}, {0x00E8, 0x00EA},   {0x00EC, 0x00ED},
      {0x00F0, 0x00F0}, {0x00F2, 0x00F3},   {0x00F7, 0x00FA},
      {0x00FC, 0x00FC}, {0x00FE, 0x00FE},   {0x0101, 0x0101},
      {0x0111, 0x0111}, {0x0113, 0x0113},   {0x011B, 0x011B},
      {0x0126, 0x0127}, {0x012B, 0x012B},   {0x0131, 0x0133},
      {0x0138, 0x0138}, {0x013F, 0x0142},   {0x0144, 0x0144},
      {0x0148, 0x014B}, {0x014D, 0x014D},   {0x0152, 0x0153},
      {0x0166, 0x0167}, {0x016B, 0x016B},   {0x01CE, 0x01CE},
      {0x01D0, 0x01D0}, {0x01D2, 0x01D2},   {0x01D4, 0x01D4},
      {0x01D6, 0x01D6}, {0x01D8, 0x01D8},   {0x01DA, 0x01DA},
      {0x01DC, 0x01DC}, {0x0251, 0x0251},   {0x0261, 0x0261},
      {0x02C4, 0x02C4}, {0x02C7, 0x02C7},   {0x02C9, 0x02CB},
      {0x02CD, 0x02CD}, {0x02D0, 0x02D0},   {0x02D8, 0x02DB},
      {0x02DD, 0x02DD}, {0x02DF, 0x02DF},   {0x0391, 0x03A1},
      {0x03A3, 0x03A9}, {0x03B1, 0x03C1},   {0x03C3, 0x03C9},
      {0x0401, 0x0401}, {0x0410, 0x044F},   {0x0451, 0x0451},
      {0x2010, 0x2010}, {0x2013, 0x2016},   {0x2018, 0x2019},
      {0x201C, 0x201D}, {0x2020, 0x2022},   {0x2024, 0x2027},
      {0x2030, 0x2030}, {0x2032, 0x2033},   {0x2035, 0x2035},
      {0x203B, 0x203B}, {0x203E, 0x203E},   {0x2074, 0x2074},
      {0x207F, 0x207F}, {0x2081, 0x2084},   {0x20AC, 0x20AC},
      {0x2103, 0x2103}, {0x2105, 0x2105},   {0x2109, 0x2109},
      {0x2113, 0x2113}, {0x2116, 0x2116},   {0x2121, 0x2122},
      {0x2126, 0x2126}, {0x212B, 0x212B},   {0x2153, 0x2154},
      {0x215B, 0x215E}, {0x2160, 0x216B},   {0x2170, 0x2179},
      {0x2190, 0x2199}, {0x21B8, 0x21B9},   {0x21D2, 0x21D2},
      {0x21D4, 0x21D4}, {0x21E7, 0x21E7},   {0x2200, 0x2200},
      {0x2202, 0x2203}, {0x2207, 0x2208},   {0x220B, 0x220B},
      {0x220F, 0x220F}, {0x2211, 0x2211},   {0x2215, 0x2215},
      {0x221A, 0x221A}, {0x221D, 0x2220},   {0x2223, 0x2223},
      {0x2225, 0x2225}, {0x2227, 0x222C},   {0x222E, 0x222E},
      {0x2234, 0x2237}, {0x223C, 0x223D},   {0x2248, 0x2248},
      {0x224C, 0x224C}, {0x2252, 0x2252},   {0x2260, 0x2261},
      {0x2264, 0x2267}, {0x226A, 0x226B},   {0x226E, 0x226F},
      {0x2282, 0x2283}, {0x2286, 0x2287},   {0x2295, 0x2295},
      {0x2299, 0x2299}, {0x22A5, 0x22A5},   {0x22BF, 0x22BF},
      {0x2312, 0x2312}, {0x2460, 0x24E9},   {0x24EB, 0x254B},
      {0x2550, 0x2573}, {0x2580, 0x258F},   {0x2592, 0x2595},
      {0x25A0, 0x25A1}, {0x25A3, 0x25A9},   {0x25B2, 0x25B3},
      {0x25B6, 0x25B7}, {0x25BC, 0x25BD},   {0x25C0, 0x25C1},
      {0x25C6, 0x25C8}, {0x25CB, 0x25CB},   {0x25CE, 0x25D1},
      {0x25E2, 0x25E5}, {0x25EF, 0x25EF},   {0x2605, 0x2606},
      {0x2609, 0x2609}, {0x260E, 0x260F},   {0x2614, 0x2615},
      {0x261C, 0x261C}, {0x261E, 0x261E},   {0x2640, 0x2640},
      {0x2642, 0x2642}, {0x2660, 0x2661},   {0x2663, 0x2665},
      {0x2667, 0x266A}, {0x266C, 0x266D},   {0x266F, 0x266F},
      {0x273D, 0x273D}, {0x2776, 0x277F},   {0xE000, 0xF8FF},
      {0xFFFD, 0xFFFD}, {0xF0000, 0xFFFFD}, {0x100000, 0x10FFFD}};

  /* binary search in table of non-spacing characters */
  if (bisearch(ucs, ambiguous, sizeof(ambiguous) / sizeof(struct interval) - 1))
    return 2;

  return mk_wcwidth(ucs);
}

static inline int mk_wcswidth_cjk(const wchar_t *pwcs, size_t n) {
  int w, width = 0;

  for (; *pwcs && n-- > 0; pwcs++)
    if ((w = mk_wcwidth_cjk(*pwcs)) < 0)
      return -1;
    else
      width += w;

  return width;
}

// convert UTF-8 string to wstring
#ifdef _MSC_VER
static inline std::wstring utf8_decode(const std::string& s) {
    auto r = setlocale(LC_ALL, "");
    std::string curLocale;
    if (r)
      curLocale = r;
    const char* _Source = s.c_str();
    size_t _Dsize = std::strlen(_Source) + 1;
    wchar_t* _Dest = new wchar_t[_Dsize];
    size_t _Osize;
    mbstowcs_s(&_Osize, _Dest, _Dsize, _Source, _Dsize);
    std::wstring result = _Dest;
    delete[] _Dest;
    setlocale(LC_ALL, curLocale.c_str());
    return result;
}
#else 
static inline std::wstring utf8_decode(const std::string& s) {
    auto r = setlocale(LC_ALL, "");
    std::string curLocale;
    if (r)
      curLocale = r;
    const char* _Source = s.c_str();
    size_t _Dsize = mbstowcs(NULL, _Source, 0) + 1;
    wchar_t* _Dest = new wchar_t[_Dsize];
    wmemset(_Dest, 0, _Dsize);
    mbstowcs(_Dest, _Source, _Dsize);
    std::wstring result = _Dest;
    delete[] _Dest;
    setlocale(LC_ALL, curLocale.c_str());
    return result;
}
#endif

} // namespace details

static inline int display_width(const std::string &input) {
  using namespace unicode::details;
  return mk_wcswidth(utf8_decode(input).c_str(), input.size());
}

static inline int display_width(const std::wstring &input) {
  return details::mk_wcswidth(input.c_str(), input.size());
}

} // namespace unicode

#endif
// #include <indicators/setting.hpp>
// #include <indicators/termcolor.hpp>

#include <algorithm>
#include <chrono>
#include <iomanip>
#include <ostream>
#include <string>
#include <vector>

#include <cassert>
#include <cmath>

namespace indicators {
namespace details {

inline void set_stream_color(std::ostream &os, Color color) {
  switch (color) {
  case Color::grey:
    os << termcolor::grey;
    break;
  case Color::red:
    os << termcolor::red;
    break;
  case Color::green:
    os << termcolor::green;
    break;
  case Color::yellow:
    os << termcolor::yellow;
    break;
  case Color::blue:
    os << termcolor::blue;
    break;
  case Color::magenta:
    os << termcolor::magenta;
    break;
  case Color::cyan:
    os << termcolor::cyan;
    break;
  case Color::white:
    os << termcolor::white;
    break;
  default:
    assert(false);
  }
}

inline void set_font_style(std::ostream &os, FontStyle style) {
  switch (style) {
  case FontStyle::bold:
    os << termcolor::bold;
    break;
  case FontStyle::dark:
    os << termcolor::dark;
    break;
  case FontStyle::italic:
    os << termcolor::italic;
    break;
  case FontStyle::underline:
    os << termcolor::underline;
    break;
  case FontStyle::blink:
    os << termcolor::blink;
    break;
  case FontStyle::reverse:
    os << termcolor::reverse;
    break;
  case FontStyle::concealed:
    os << termcolor::concealed;
    break;
  case FontStyle::crossed:
    os << termcolor::crossed;
    break;
  default:
    break;
  }
}

inline std::ostream &write_duration(std::ostream &os, std::chrono::nanoseconds ns) {
  using namespace std;
  using namespace std::chrono;
  using days = duration<int, ratio<86400>>;
  char fill = os.fill();
  os.fill('0');
  auto d = duration_cast<days>(ns);
  ns -= d;
  auto h = duration_cast<hours>(ns);
  ns -= h;
  auto m = duration_cast<minutes>(ns);
  ns -= m;
  auto s = duration_cast<seconds>(ns);
  if (d.count() > 0)
    os << setw(2) << d.count() << "d:";
  if (h.count() > 0)
    os << setw(2) << h.count() << "h:";
  os << setw(2) << m.count() << "m:" << setw(2) << s.count() << 's';
  os.fill(fill);
  return os;
}

class BlockProgressScaleWriter {
public:
  BlockProgressScaleWriter(std::ostream &os, size_t bar_width) : os(os), bar_width(bar_width) {}

  std::ostream &write(float progress) {
    std::string fill_text{"█"};
    std::vector<std::string> lead_characters{" ", "▏", "▎", "▍", "▌", "▋", "▊", "▉"};
    auto value = (std::min)(1.0f, (std::max)(0.0f, progress / 100.0f));
    auto whole_width = std::floor(value * bar_width);
    auto remainder_width = fmod((value * bar_width), 1.0f);
    auto part_width = std::floor(remainder_width * lead_characters.size());
    std::string lead_text = lead_characters[size_t(part_width)];
    if ((bar_width - whole_width - 1) < 0)
      lead_text = "";
    for (size_t i = 0; i < whole_width; ++i)
      os << fill_text;
    os << lead_text;
    for (size_t i = 0; i < (bar_width - whole_width - 1); ++i)
      os << " ";
    return os;
  }

private:
  std::ostream &os;
  size_t bar_width = 0;
};

class ProgressScaleWriter {
public:
  ProgressScaleWriter(std::ostream &os, size_t bar_width, const std::string &fill,
                      const std::string &lead, const std::string &remainder)
      : os(os), bar_width(bar_width), fill(fill), lead(lead), remainder(remainder) {}

  std::ostream &write(float progress) {
    auto pos = static_cast<size_t>(progress * bar_width / 100.0);
    for (size_t i = 0, current_display_width = 0; i < bar_width;) {
      std::string next;

      if (i < pos) {
        next = fill;
        current_display_width = unicode::display_width(fill);
      } else if (i == pos) {
        next = lead;
        current_display_width = unicode::display_width(lead);
      } else {
        next = remainder;
        current_display_width = unicode::display_width(remainder);
      }

      i += current_display_width;

      if (i > bar_width) {
        // `next` is larger than the allowed bar width
        // fill with empty space instead
        os << std::string((bar_width - (i - current_display_width)), ' ');
        break;
      }

      os << next;
    }
    return os;
  }

private:
  std::ostream &os;
  size_t bar_width = 0;
  std::string fill;
  std::string lead;
  std::string remainder;
};

class IndeterminateProgressScaleWriter {
public:
  IndeterminateProgressScaleWriter(std::ostream &os, size_t bar_width, const std::string &fill,
                                   const std::string &lead)
      : os(os), bar_width(bar_width), fill(fill), lead(lead) {}

  std::ostream &write(size_t progress) {
    for (size_t i = 0; i < bar_width;) {
      std::string next;
      size_t current_display_width = 0;

      if (i < progress) {
        next = fill;
        current_display_width = unicode::display_width(fill);
      } else if (i == progress) {
        next = lead;
        current_display_width = unicode::display_width(lead);
      } else {
        next = fill;
        current_display_width = unicode::display_width(fill);
      }

      i += current_display_width;

      if (i > bar_width) {
        // `next` is larger than the allowed bar width
        // fill with empty space instead
        os << std::string((bar_width - (i - current_display_width)), ' ');
        break;
      }

      os << next;
    }
    return os;
  }

private:
  std::ostream &os;
  size_t bar_width = 0;
  std::string fill;
  std::string lead;
};

} // namespace details
} // namespace indicators

#endif


#ifndef INDICATORS_PROGRESS_BAR
#define INDICATORS_PROGRESS_BAR

// #include <indicators/details/stream_helper.hpp>

#include <algorithm>
#include <atomic>
#include <chrono>
#include <cmath>
// #include <indicators/color.hpp>
// #include <indicators/setting.hpp>
// #include <indicators/terminal_size.hpp>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <mutex>
#include <string>
#include <thread>
#include <tuple>
#include <type_traits>
#include <utility>

namespace indicators {

class ProgressBar {
  using Settings =
      std::tuple<option::BarWidth, option::PrefixText, option::PostfixText,
                 option::Start, option::End, option::Fill, option::Lead,
                 option::Remainder, option::MaxPostfixTextLen,
                 option::Completed, option::ShowPercentage,
                 option::ShowElapsedTime, option::ShowRemainingTime,
                 option::SavedStartTime, option::ForegroundColor,
                 option::FontStyles, option::MinProgress, option::MaxProgress,
                 option::ProgressType, option::Stream>;

public:
  template <typename... Args,
            typename std::enable_if<
                details::are_settings_from_tuple<
                    Settings, typename std::decay<Args>::type...>::value,
                void *>::type = nullptr>
  explicit ProgressBar(Args &&... args)
      : settings_(
            details::get<details::ProgressBarOption::bar_width>(
                option::BarWidth{100}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::prefix_text>(
                option::PrefixText{}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::postfix_text>(
                option::PostfixText{}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::start>(
                option::Start{"["}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::end>(
                option::End{"]"}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::fill>(
                option::Fill{"="}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::lead>(
                option::Lead{">"}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::remainder>(
                option::Remainder{" "}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::max_postfix_text_len>(
                option::MaxPostfixTextLen{0}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::completed>(
                option::Completed{false}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::show_percentage>(
                option::ShowPercentage{false}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::show_elapsed_time>(
                option::ShowElapsedTime{false}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::show_remaining_time>(
                option::ShowRemainingTime{false}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::saved_start_time>(
                option::SavedStartTime{false}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::foreground_color>(
                option::ForegroundColor{Color::unspecified},
                std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::font_styles>(
                option::FontStyles{std::vector<FontStyle>{}},
                std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::min_progress>(
                option::MinProgress{0}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::max_progress>(
                option::MaxProgress{100}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::progress_type>(
                option::ProgressType{ProgressType::incremental},
                std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::stream>(
                option::Stream{std::cout}, std::forward<Args>(args)...)) {

    // if progress is incremental, start from min_progress
    // else start from max_progress
    const auto type = get_value<details::ProgressBarOption::progress_type>();
    if (type == ProgressType::incremental)
      progress_ = get_value<details::ProgressBarOption::min_progress>();
    else
      progress_ = get_value<details::ProgressBarOption::max_progress>();
  }

  template <typename T, details::ProgressBarOption id>
  void set_option(details::Setting<T, id> &&setting) {
    static_assert(
        !std::is_same<T, typename std::decay<decltype(details::get_value<id>(
                             std::declval<Settings>()))>::type>::value,
        "Setting has wrong type!");
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<id>() = std::move(setting).value;
  }

  template <typename T, details::ProgressBarOption id>
  void set_option(const details::Setting<T, id> &setting) {
    static_assert(
        !std::is_same<T, typename std::decay<decltype(details::get_value<id>(
                             std::declval<Settings>()))>::type>::value,
        "Setting has wrong type!");
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<id>() = setting.value;
  }

  void
  set_option(const details::Setting<
             std::string, details::ProgressBarOption::postfix_text> &setting) {
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<details::ProgressBarOption::postfix_text>() = setting.value;
    if (setting.value.length() >
        get_value<details::ProgressBarOption::max_postfix_text_len>()) {
      get_value<details::ProgressBarOption::max_postfix_text_len>() =
          setting.value.length();
    }
  }

  void set_option(
      details::Setting<std::string, details::ProgressBarOption::postfix_text>
          &&setting) {
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<details::ProgressBarOption::postfix_text>() =
        std::move(setting).value;
    auto &new_value = get_value<details::ProgressBarOption::postfix_text>();
    if (new_value.length() >
        get_value<details::ProgressBarOption::max_postfix_text_len>()) {
      get_value<details::ProgressBarOption::max_postfix_text_len>() =
          new_value.length();
    }
  }

  void set_progress(size_t new_progress) {
    {
      std::lock_guard<std::mutex> lock(mutex_);
      progress_ = new_progress;
    }

    save_start_time();
    print_progress();
  }

  void tick() {
    {
      std::lock_guard<std::mutex> lock{mutex_};
      const auto type = get_value<details::ProgressBarOption::progress_type>();
      if (type == ProgressType::incremental)
        progress_ += 1;
      else
        progress_ -= 1;
    }
    save_start_time();
    print_progress();
  }

  size_t current() {
    std::lock_guard<std::mutex> lock{mutex_};
    return (std::min)(
        progress_,
        size_t(get_value<details::ProgressBarOption::max_progress>()));
  }

  bool is_completed() const {
    return get_value<details::ProgressBarOption::completed>();
  }

  void mark_as_completed() {
    get_value<details::ProgressBarOption::completed>() = true;
    print_progress();
  }

private:
  template <details::ProgressBarOption id>
  auto get_value()
      -> decltype((details::get_value<id>(std::declval<Settings &>()).value)) {
    return details::get_value<id>(settings_).value;
  }

  template <details::ProgressBarOption id>
  auto get_value() const -> decltype(
      (details::get_value<id>(std::declval<const Settings &>()).value)) {
    return details::get_value<id>(settings_).value;
  }

  size_t progress_{0};
  Settings settings_;
  std::chrono::nanoseconds elapsed_;
  std::chrono::time_point<std::chrono::high_resolution_clock> start_time_point_;
  std::mutex mutex_;

  template <typename Indicator, size_t count> friend class MultiProgress;
  template <typename Indicator> friend class DynamicProgress;
  std::atomic<bool> multi_progress_mode_{false};

  void save_start_time() {
    auto &show_elapsed_time =
        get_value<details::ProgressBarOption::show_elapsed_time>();
    auto &saved_start_time =
        get_value<details::ProgressBarOption::saved_start_time>();
    auto &show_remaining_time =
        get_value<details::ProgressBarOption::show_remaining_time>();
    if ((show_elapsed_time || show_remaining_time) && !saved_start_time) {
      start_time_point_ = std::chrono::high_resolution_clock::now();
      saved_start_time = true;
    }
  }

  std::pair<std::string, int> get_prefix_text() {
    std::stringstream os;
    os << get_value<details::ProgressBarOption::prefix_text>();
    const auto result = os.str();
    const auto result_size = unicode::display_width(result);
    return {result, result_size};
  }

  std::pair<std::string, int> get_postfix_text() {
    std::stringstream os;
    const auto max_progress =
        get_value<details::ProgressBarOption::max_progress>();

    if (get_value<details::ProgressBarOption::show_percentage>()) {
      os << " "
         << (std::min)(static_cast<size_t>(static_cast<float>(progress_) /
                                         max_progress * 100),
                     size_t(100))
         << "%";
    }

    auto &saved_start_time =
        get_value<details::ProgressBarOption::saved_start_time>();

    if (get_value<details::ProgressBarOption::show_elapsed_time>()) {
      os << " [";
      if (saved_start_time)
        details::write_duration(os, elapsed_);
      else
        os << "00:00s";
    }

    if (get_value<details::ProgressBarOption::show_remaining_time>()) {
      if (get_value<details::ProgressBarOption::show_elapsed_time>())
        os << "<";
      else
        os << " [";

      if (saved_start_time) {
        auto eta = std::chrono::nanoseconds(
            progress_ > 0
                ? static_cast<long long>(std::ceil(float(elapsed_.count()) *
                                                   max_progress / progress_))
                : 0);
        auto remaining = eta > elapsed_ ? (eta - elapsed_) : (elapsed_ - eta);
        details::write_duration(os, remaining);
      } else {
        os << "00:00s";
      }

      os << "]";
    } else {
      if (get_value<details::ProgressBarOption::show_elapsed_time>())
        os << "]";
    }

    os << " " << get_value<details::ProgressBarOption::postfix_text>();

    const auto result = os.str();
    const auto result_size = unicode::display_width(result);
    return {result, result_size};
  }

public:
  void print_progress(bool from_multi_progress = false) {
    std::lock_guard<std::mutex> lock{mutex_};

    auto &os = get_value<details::ProgressBarOption::stream>();

    const auto type = get_value<details::ProgressBarOption::progress_type>();
    const auto min_progress =
        get_value<details::ProgressBarOption::min_progress>();
    const auto max_progress =
        get_value<details::ProgressBarOption::max_progress>();
    if (multi_progress_mode_ && !from_multi_progress) {
      if ((type == ProgressType::incremental && progress_ >= max_progress) ||
          (type == ProgressType::decremental && progress_ <= min_progress)) {
        get_value<details::ProgressBarOption::completed>() = true;
      }
      return;
    }
    auto now = std::chrono::high_resolution_clock::now();
    if (!get_value<details::ProgressBarOption::completed>())
      elapsed_ = std::chrono::duration_cast<std::chrono::nanoseconds>(
          now - start_time_point_);

    if (get_value<details::ProgressBarOption::foreground_color>() !=
        Color::unspecified)
      details::set_stream_color(
          os, get_value<details::ProgressBarOption::foreground_color>());

    for (auto &style : get_value<details::ProgressBarOption::font_styles>())
      details::set_font_style(os, style);

    const auto prefix_pair = get_prefix_text();
    const auto prefix_text = prefix_pair.first;
    const auto prefix_length = prefix_pair.second;
    os << "\r" << prefix_text;

    os << get_value<details::ProgressBarOption::start>();

    details::ProgressScaleWriter writer{
        os, get_value<details::ProgressBarOption::bar_width>(),
        get_value<details::ProgressBarOption::fill>(),
        get_value<details::ProgressBarOption::lead>(),
        get_value<details::ProgressBarOption::remainder>()};
    writer.write(double(progress_) / double(max_progress) * 100.0f);

    os << get_value<details::ProgressBarOption::end>();

    const auto postfix_pair = get_postfix_text();
    const auto postfix_text = postfix_pair.first;
    const auto postfix_length = postfix_pair.second;
    os << postfix_text;

    // Get length of prefix text and postfix text
    const auto start_length = get_value<details::ProgressBarOption::start>().size();
    const auto bar_width = get_value<details::ProgressBarOption::bar_width>();
    const auto end_length = get_value<details::ProgressBarOption::end>().size();
    const auto terminal_width = terminal_size().second;
    // prefix + bar_width + postfix should be <= terminal_width
    const int remaining = terminal_width - (prefix_length + start_length + bar_width + end_length + postfix_length);
    if (prefix_length == -1 || postfix_length == -1) {
      os << "\r";
    } else if (remaining > 0) {
      os << std::string(remaining, ' ') << "\r";
    } else if (remaining < 0) {
      // Do nothing. Maybe in the future truncate postfix with ...
    }
    os.flush();

    if ((type == ProgressType::incremental && progress_ >= max_progress) ||
        (type == ProgressType::decremental && progress_ <= min_progress)) {
      get_value<details::ProgressBarOption::completed>() = true;
    }
    if (get_value<details::ProgressBarOption::completed>() &&
        !from_multi_progress) // Don't std::endl if calling from MultiProgress
      os << termcolor::reset << std::endl;
  }
};

} // namespace indicators

#endif


#ifndef INDICATORS_BLOCK_PROGRESS_BAR
#define INDICATORS_BLOCK_PROGRESS_BAR

// #include <indicators/color.hpp>
// #include <indicators/details/stream_helper.hpp>

#include <algorithm>
#include <atomic>
#include <chrono>
// #include <indicators/setting.hpp>
// #include <indicators/terminal_size.hpp>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <mutex>
#include <string>
#include <thread>
#include <tuple>
#include <utility>

namespace indicators {

class BlockProgressBar {
  using Settings = std::tuple<option::ForegroundColor, option::BarWidth, option::Start, option::End,
                              option::PrefixText, option::PostfixText, option::ShowPercentage,
                              option::ShowElapsedTime, option::ShowRemainingTime, option::Completed,
                              option::SavedStartTime, option::MaxPostfixTextLen, option::FontStyles,
                              option::MaxProgress, option::Stream>;

public:
  template <typename... Args,
            typename std::enable_if<details::are_settings_from_tuple<
                                        Settings, typename std::decay<Args>::type...>::value,
                                    void *>::type = nullptr>
  explicit BlockProgressBar(Args &&... args)
      : settings_(details::get<details::ProgressBarOption::foreground_color>(
                      option::ForegroundColor{Color::unspecified}, std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::bar_width>(option::BarWidth{100},
                                                                      std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::start>(option::Start{"["},
                                                                  std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::end>(option::End{"]"},
                                                                std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::prefix_text>(
                      option::PrefixText{""}, std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::postfix_text>(
                      option::PostfixText{""}, std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::show_percentage>(
                      option::ShowPercentage{true}, std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::show_elapsed_time>(
                      option::ShowElapsedTime{false}, std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::show_remaining_time>(
                      option::ShowRemainingTime{false}, std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::completed>(option::Completed{false},
                                                                      std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::saved_start_time>(
                      option::SavedStartTime{false}, std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::max_postfix_text_len>(
                      option::MaxPostfixTextLen{0}, std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::font_styles>(
                      option::FontStyles{std::vector<FontStyle>{}}, std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::max_progress>(
                      option::MaxProgress{100}, std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::stream>(option::Stream{std::cout},
                                                                   std::forward<Args>(args)...)) {}

  template <typename T, details::ProgressBarOption id>
  void set_option(details::Setting<T, id> &&setting) {
    static_assert(!std::is_same<T, typename std::decay<decltype(details::get_value<id>(
                                       std::declval<Settings>()))>::type>::value,
                  "Setting has wrong type!");
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<id>() = std::move(setting).value;
  }

  template <typename T, details::ProgressBarOption id>
  void set_option(const details::Setting<T, id> &setting) {
    static_assert(!std::is_same<T, typename std::decay<decltype(details::get_value<id>(
                                       std::declval<Settings>()))>::type>::value,
                  "Setting has wrong type!");
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<id>() = setting.value;
  }

  void set_option(
      const details::Setting<std::string, details::ProgressBarOption::postfix_text> &setting) {
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<details::ProgressBarOption::postfix_text>() = setting.value;
    if (setting.value.length() > get_value<details::ProgressBarOption::max_postfix_text_len>()) {
      get_value<details::ProgressBarOption::max_postfix_text_len>() = setting.value.length();
    }
  }

  void
  set_option(details::Setting<std::string, details::ProgressBarOption::postfix_text> &&setting) {
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<details::ProgressBarOption::postfix_text>() = std::move(setting).value;
    auto &new_value = get_value<details::ProgressBarOption::postfix_text>();
    if (new_value.length() > get_value<details::ProgressBarOption::max_postfix_text_len>()) {
      get_value<details::ProgressBarOption::max_postfix_text_len>() = new_value.length();
    }
  }

  void set_progress(float value) {
    {
      std::lock_guard<std::mutex> lock{mutex_};
      progress_ = value;
    }
    save_start_time();
    print_progress();
  }

  void tick() {
    {
      std::lock_guard<std::mutex> lock{mutex_};
      progress_ += 1;
    }
    save_start_time();
    print_progress();
  }

  size_t current() {
    std::lock_guard<std::mutex> lock{mutex_};
    return (std::min)(static_cast<size_t>(progress_),
                    size_t(get_value<details::ProgressBarOption::max_progress>()));
  }

  bool is_completed() const { return get_value<details::ProgressBarOption::completed>(); }

  void mark_as_completed() {
    get_value<details::ProgressBarOption::completed>() = true;
    print_progress();
  }

private:
  template <details::ProgressBarOption id>
  auto get_value() -> decltype((details::get_value<id>(std::declval<Settings &>()).value)) {
    return details::get_value<id>(settings_).value;
  }

  template <details::ProgressBarOption id>
  auto get_value() const
      -> decltype((details::get_value<id>(std::declval<const Settings &>()).value)) {
    return details::get_value<id>(settings_).value;
  }

  Settings settings_;
  float progress_{0.0};
  std::chrono::time_point<std::chrono::high_resolution_clock> start_time_point_;
  std::mutex mutex_;

  template <typename Indicator, size_t count> friend class MultiProgress;
  template <typename Indicator> friend class DynamicProgress;
  std::atomic<bool> multi_progress_mode_{false};

  void save_start_time() {
    auto &show_elapsed_time = get_value<details::ProgressBarOption::show_elapsed_time>();
    auto &saved_start_time = get_value<details::ProgressBarOption::saved_start_time>();
    auto &show_remaining_time = get_value<details::ProgressBarOption::show_remaining_time>();
    if ((show_elapsed_time || show_remaining_time) && !saved_start_time) {
      start_time_point_ = std::chrono::high_resolution_clock::now();
      saved_start_time = true;
    }
  }

  std::pair<std::string, int> get_prefix_text() {
    std::stringstream os;
    os << get_value<details::ProgressBarOption::prefix_text>();
    const auto result = os.str();
    const auto result_size = unicode::display_width(result);
    return {result, result_size};
  }

  std::pair<std::string, int> get_postfix_text() {
    std::stringstream os;
    const auto max_progress = get_value<details::ProgressBarOption::max_progress>();
    auto now = std::chrono::high_resolution_clock::now();
    auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(now - start_time_point_);

    if (get_value<details::ProgressBarOption::show_percentage>()) {
      os << " " << (std::min)(static_cast<size_t>(progress_ / max_progress * 100.0), size_t(100))
         << "%";
    }

    auto &saved_start_time = get_value<details::ProgressBarOption::saved_start_time>();

    if (get_value<details::ProgressBarOption::show_elapsed_time>()) {
      os << " [";
      if (saved_start_time)
        details::write_duration(os, elapsed);
      else
        os << "00:00s";
    }

    if (get_value<details::ProgressBarOption::show_remaining_time>()) {
      if (get_value<details::ProgressBarOption::show_elapsed_time>())
        os << "<";
      else
        os << " [";

      if (saved_start_time) {
        auto eta = std::chrono::nanoseconds(
            progress_ > 0
                ? static_cast<long long>(std::ceil(float(elapsed.count()) *
                                                   max_progress / progress_))
                : 0);
        auto remaining = eta > elapsed ? (eta - elapsed) : (elapsed - eta);
        details::write_duration(os, remaining);
      } else {
        os << "00:00s";
      }

      os << "]";
    } else {
      if (get_value<details::ProgressBarOption::show_elapsed_time>())
        os << "]";
    }

    os << " " << get_value<details::ProgressBarOption::postfix_text>();

    const auto result = os.str();
    const auto result_size = unicode::display_width(result);
    return {result, result_size};
  }

public:
  void print_progress(bool from_multi_progress = false) {
    std::lock_guard<std::mutex> lock{mutex_};

    auto &os = get_value<details::ProgressBarOption::stream>();

    const auto max_progress = get_value<details::ProgressBarOption::max_progress>();
    if (multi_progress_mode_ && !from_multi_progress) {
      if (progress_ > max_progress) {
        get_value<details::ProgressBarOption::completed>() = true;
      }
      return;
    }

    if (get_value<details::ProgressBarOption::foreground_color>() != Color::unspecified)
      details::set_stream_color(os, get_value<details::ProgressBarOption::foreground_color>());

    for (auto &style : get_value<details::ProgressBarOption::font_styles>())
      details::set_font_style(os, style);

    const auto prefix_pair = get_prefix_text();
    const auto prefix_text = prefix_pair.first;
    const auto prefix_length = prefix_pair.second;
    os << "\r" << prefix_text;

    os << get_value<details::ProgressBarOption::start>();

    details::BlockProgressScaleWriter writer{os,
                                             get_value<details::ProgressBarOption::bar_width>()};
    writer.write(progress_ / max_progress * 100);

    os << get_value<details::ProgressBarOption::end>();

    const auto postfix_pair = get_postfix_text();
    const auto postfix_text = postfix_pair.first;
    const auto postfix_length = postfix_pair.second;
    os << postfix_text;

    // Get length of prefix text and postfix text
    const auto start_length = get_value<details::ProgressBarOption::start>().size();
    const auto bar_width = get_value<details::ProgressBarOption::bar_width>();
    const auto end_length = get_value<details::ProgressBarOption::end>().size();
    const auto terminal_width = terminal_size().second;
    // prefix + bar_width + postfix should be <= terminal_width
    const int remaining = terminal_width - (prefix_length + start_length + bar_width + end_length + postfix_length);
    if (prefix_length == -1 || postfix_length == -1) {
      os << "\r";
    } else if (remaining > 0) {
      os << std::string(remaining, ' ') << "\r";
    } else if (remaining < 0) {
      // Do nothing. Maybe in the future truncate postfix with ...
    }
    os.flush();

    if (progress_ > max_progress) {
      get_value<details::ProgressBarOption::completed>() = true;
    }
    if (get_value<details::ProgressBarOption::completed>() &&
        !from_multi_progress) // Don't std::endl if calling from MultiProgress
      os << termcolor::reset << std::endl;
  }
};

} // namespace indicators

#endif


#ifndef INDICATORS_INDETERMINATE_PROGRESS_BAR
#define INDICATORS_INDETERMINATE_PROGRESS_BAR

// #include <indicators/details/stream_helper.hpp>

#include <algorithm>
#include <atomic>
#include <chrono>
#include <cmath>
// #include <indicators/color.hpp>
// #include <indicators/setting.hpp>
// #include <indicators/terminal_size.hpp>
#include <iomanip>
#include <iostream>
#include <mutex>
#include <string>
#include <thread>
#include <tuple>
#include <type_traits>
#include <sstream>
#include <utility>

namespace indicators {

class IndeterminateProgressBar {
  using Settings =
      std::tuple<option::BarWidth, option::PrefixText, option::PostfixText, option::Start,
                 option::End, option::Fill, option::Lead, option::MaxPostfixTextLen,
                 option::Completed, option::ForegroundColor, option::FontStyles, option::Stream>;

  enum class Direction { forward, backward };

  Direction direction_{Direction::forward};

public:
  template <typename... Args,
            typename std::enable_if<details::are_settings_from_tuple<
                                        Settings, typename std::decay<Args>::type...>::value,
                                    void *>::type = nullptr>
  explicit IndeterminateProgressBar(Args &&... args)
      : settings_(details::get<details::ProgressBarOption::bar_width>(option::BarWidth{100},
                                                                      std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::prefix_text>(
                      option::PrefixText{}, std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::postfix_text>(
                      option::PostfixText{}, std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::start>(option::Start{"["},
                                                                  std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::end>(option::End{"]"},
                                                                std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::fill>(option::Fill{"."},
                                                                 std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::lead>(option::Lead{"<==>"},
                                                                 std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::max_postfix_text_len>(
                      option::MaxPostfixTextLen{0}, std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::completed>(option::Completed{false},
                                                                      std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::foreground_color>(
                      option::ForegroundColor{Color::unspecified}, std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::font_styles>(
                      option::FontStyles{std::vector<FontStyle>{}}, std::forward<Args>(args)...),
                  details::get<details::ProgressBarOption::stream>(option::Stream{std::cout},
                                                                   std::forward<Args>(args)...)) {
    // starts with [<==>...........]
    // progress_ = 0

    // ends with   [...........<==>]
    //             ^^^^^^^^^^^^^^^^^ bar_width
    //             ^^^^^^^^^^^^ (bar_width - len(lead))
    // progress_ = bar_width - len(lead)
    progress_ = 0;
    max_progress_ = get_value<details::ProgressBarOption::bar_width>() -
                    get_value<details::ProgressBarOption::lead>().size() +
                    get_value<details::ProgressBarOption::start>().size() +
                    get_value<details::ProgressBarOption::end>().size();
  }

  template <typename T, details::ProgressBarOption id>
  void set_option(details::Setting<T, id> &&setting) {
    static_assert(!std::is_same<T, typename std::decay<decltype(details::get_value<id>(
                                       std::declval<Settings>()))>::type>::value,
                  "Setting has wrong type!");
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<id>() = std::move(setting).value;
  }

  template <typename T, details::ProgressBarOption id>
  void set_option(const details::Setting<T, id> &setting) {
    static_assert(!std::is_same<T, typename std::decay<decltype(details::get_value<id>(
                                       std::declval<Settings>()))>::type>::value,
                  "Setting has wrong type!");
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<id>() = setting.value;
  }

  void set_option(
      const details::Setting<std::string, details::ProgressBarOption::postfix_text> &setting) {
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<details::ProgressBarOption::postfix_text>() = setting.value;
    if (setting.value.length() > get_value<details::ProgressBarOption::max_postfix_text_len>()) {
      get_value<details::ProgressBarOption::max_postfix_text_len>() = setting.value.length();
    }
  }

  void
  set_option(details::Setting<std::string, details::ProgressBarOption::postfix_text> &&setting) {
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<details::ProgressBarOption::postfix_text>() = std::move(setting).value;
    auto &new_value = get_value<details::ProgressBarOption::postfix_text>();
    if (new_value.length() > get_value<details::ProgressBarOption::max_postfix_text_len>()) {
      get_value<details::ProgressBarOption::max_postfix_text_len>() = new_value.length();
    }
  }

  void tick() {
    {
      std::lock_guard<std::mutex> lock{mutex_};
      if (get_value<details::ProgressBarOption::completed>())
        return;

      progress_ += (direction_ == Direction::forward) ? 1 : -1;
      if (direction_ == Direction::forward && progress_ == max_progress_) {
        // time to go back
        direction_ = Direction::backward;
      } else if (direction_ == Direction::backward && progress_ == 0) {
        direction_ = Direction::forward;
      }
    }
    print_progress();
  }

  bool is_completed() { return get_value<details::ProgressBarOption::completed>(); }

  void mark_as_completed() {
    get_value<details::ProgressBarOption::completed>() = true;
    print_progress();
  }

private:
  template <details::ProgressBarOption id>
  auto get_value() -> decltype((details::get_value<id>(std::declval<Settings &>()).value)) {
    return details::get_value<id>(settings_).value;
  }

  template <details::ProgressBarOption id>
  auto get_value() const
      -> decltype((details::get_value<id>(std::declval<const Settings &>()).value)) {
    return details::get_value<id>(settings_).value;
  }

  size_t progress_{0};
  size_t max_progress_;
  Settings settings_;
  std::chrono::nanoseconds elapsed_;
  std::mutex mutex_;

  template <typename Indicator, size_t count> friend class MultiProgress;
  template <typename Indicator> friend class DynamicProgress;
  std::atomic<bool> multi_progress_mode_{false};

  std::pair<std::string, int> get_prefix_text() {
    std::stringstream os;
    os << get_value<details::ProgressBarOption::prefix_text>();
    const auto result = os.str();
    const auto result_size = unicode::display_width(result);
    return {result, result_size};
  }

  std::pair<std::string, int> get_postfix_text() {
    std::stringstream os;
    os << " " << get_value<details::ProgressBarOption::postfix_text>();

    const auto result = os.str();
    const auto result_size = unicode::display_width(result);
    return {result, result_size};
  }

public:
  void print_progress(bool from_multi_progress = false) {
    std::lock_guard<std::mutex> lock{mutex_};

    auto &os = get_value<details::ProgressBarOption::stream>();

    if (multi_progress_mode_ && !from_multi_progress) {
      return;
    }
    if (get_value<details::ProgressBarOption::foreground_color>() != Color::unspecified)
      details::set_stream_color(os, get_value<details::ProgressBarOption::foreground_color>());

    for (auto &style : get_value<details::ProgressBarOption::font_styles>())
      details::set_font_style(os, style);

    const auto prefix_pair = get_prefix_text();
    const auto prefix_text = prefix_pair.first;
    const auto prefix_length = prefix_pair.second;
    os << "\r" << prefix_text;

    os << get_value<details::ProgressBarOption::start>();

    details::IndeterminateProgressScaleWriter writer{
        os, get_value<details::ProgressBarOption::bar_width>(),
        get_value<details::ProgressBarOption::fill>(),
        get_value<details::ProgressBarOption::lead>()};
    writer.write(progress_);

    os << get_value<details::ProgressBarOption::end>();

    const auto postfix_pair = get_postfix_text();
    const auto postfix_text = postfix_pair.first;
    const auto postfix_length = postfix_pair.second;
    os << postfix_text;

    // Get length of prefix text and postfix text
    const auto start_length = get_value<details::ProgressBarOption::start>().size();
    const auto bar_width = get_value<details::ProgressBarOption::bar_width>();
    const auto end_length = get_value<details::ProgressBarOption::end>().size();
    const auto terminal_width = terminal_size().second;
    // prefix + bar_width + postfix should be <= terminal_width
    const int remaining = terminal_width - (prefix_length + start_length + bar_width + end_length + postfix_length);
    if (prefix_length == -1 || postfix_length == -1) {
      os << "\r";
    } else if (remaining > 0) {
      os << std::string(remaining, ' ') << "\r";
    } else if (remaining < 0) {
      // Do nothing. Maybe in the future truncate postfix with ...
    }
    os.flush();

    if (get_value<details::ProgressBarOption::completed>() &&
        !from_multi_progress) // Don't std::endl if calling from MultiProgress
      os << termcolor::reset << std::endl;
  }
};

} // namespace indicators

#endif


#ifndef INDICATORS_MULTI_PROGRESS
#define INDICATORS_MULTI_PROGRESS
#include <atomic>
#include <functional>
#include <iostream>
#include <mutex>
#include <vector>

// #include <indicators/color.hpp>
// #include <indicators/cursor_movement.hpp>
// #include <indicators/details/stream_helper.hpp>

namespace indicators {

template <typename Indicator, size_t count> class MultiProgress {
public:
  template <typename... Indicators,
            typename = typename std::enable_if<(sizeof...(Indicators) == count)>::type>
  explicit MultiProgress(Indicators &... bars) {
    bars_ = {bars...};
    for (auto &bar : bars_) {
      bar.get().multi_progress_mode_ = true;
    }
  }

  template <size_t index>
  typename std::enable_if<(index >= 0 && index < count), void>::type set_progress(size_t value) {
    if (!bars_[index].get().is_completed())
      bars_[index].get().set_progress(value);
    print_progress();
  }

  template <size_t index>
  typename std::enable_if<(index >= 0 && index < count), void>::type set_progress(float value) {
    if (!bars_[index].get().is_completed())
      bars_[index].get().set_progress(value);
    print_progress();
  }

  template <size_t index>
  typename std::enable_if<(index >= 0 && index < count), void>::type tick() {
    if (!bars_[index].get().is_completed())
      bars_[index].get().tick();
    print_progress();
  }

  template <size_t index>
  typename std::enable_if<(index >= 0 && index < count), bool>::type is_completed() const {
    return bars_[index].get().is_completed();
  }

private:
  std::atomic<bool> started_{false};
  std::mutex mutex_;
  std::vector<std::reference_wrapper<Indicator>> bars_;

  bool _all_completed() {
    bool result{true};
    for (size_t i = 0; i < count; ++i)
      result &= bars_[i].get().is_completed();
    return result;
  }

public:
  void print_progress() {
    std::lock_guard<std::mutex> lock{mutex_};
    if (started_)
      move_up(count);
    for (auto &bar : bars_) {
      bar.get().print_progress(true);
      std::cout << "\n";
    }
    std::cout << termcolor::reset;
    if (!started_)
      started_ = true;
  }
};

} // namespace indicators

#endif


#ifndef INDICATORS_DYNAMIC_PROGRESS
#define INDICATORS_DYNAMIC_PROGRESS

#include <atomic>
#include <functional>
// #include <indicators/color.hpp>
// #include <indicators/setting.hpp>
// #include <indicators/cursor_control.hpp>
// #include <indicators/cursor_movement.hpp>
// #include <indicators/details/stream_helper.hpp>
#include <iostream>
#include <mutex>
#include <vector>

namespace indicators {

template <typename Indicator> class DynamicProgress {
  using Settings = std::tuple<option::HideBarWhenComplete>;

public:
  template <typename... Indicators> explicit DynamicProgress(Indicators &... bars) {
    bars_ = {bars...};
    for (auto &bar : bars_) {
      bar.get().multi_progress_mode_ = true;
      ++total_count_;
      ++incomplete_count_;
    }
  }

  Indicator &operator[](size_t index) {
    print_progress();
    std::lock_guard<std::mutex> lock{mutex_};
    return bars_[index].get();
  }

  size_t push_back(Indicator &bar) {
    std::lock_guard<std::mutex> lock{mutex_};
    bar.multi_progress_mode_ = true;
    bars_.push_back(bar);
    return bars_.size() - 1;
  }

  template <typename T, details::ProgressBarOption id>
  void set_option(details::Setting<T, id> &&setting) {
    static_assert(!std::is_same<T, typename std::decay<decltype(details::get_value<id>(
                                       std::declval<Settings>()))>::type>::value,
                  "Setting has wrong type!");
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<id>() = std::move(setting).value;
  }

  template <typename T, details::ProgressBarOption id>
  void set_option(const details::Setting<T, id> &setting) {
    static_assert(!std::is_same<T, typename std::decay<decltype(details::get_value<id>(
                                       std::declval<Settings>()))>::type>::value,
                  "Setting has wrong type!");
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<id>() = setting.value;
  }

private:
  Settings settings_;
  std::atomic<bool> started_{false};
  std::mutex mutex_;
  std::vector<std::reference_wrapper<Indicator>> bars_;
  std::atomic<size_t> total_count_{0};
  std::atomic<size_t> incomplete_count_{0};

  template <details::ProgressBarOption id>
  auto get_value() -> decltype((details::get_value<id>(std::declval<Settings &>()).value)) {
    return details::get_value<id>(settings_).value;
  }

  template <details::ProgressBarOption id>
  auto get_value() const
      -> decltype((details::get_value<id>(std::declval<const Settings &>()).value)) {
    return details::get_value<id>(settings_).value;
  }

public:
  void print_progress() {
    std::lock_guard<std::mutex> lock{mutex_};
    auto &hide_bar_when_complete = get_value<details::ProgressBarOption::hide_bar_when_complete>();
    if (hide_bar_when_complete) {
      // Hide completed bars
      if (started_) {
        for (size_t i = 0; i < incomplete_count_; ++i) {
          move_up(1);
          erase_line();
          std::cout << std::flush;
        }
      }
      incomplete_count_ = 0;
      for (auto &bar : bars_) {
        if (!bar.get().is_completed()) {
          bar.get().print_progress(true);
          std::cout << "\n";
          ++incomplete_count_;
        }
      }
      if (!started_)
        started_ = true;
    } else {
      // Don't hide any bars
      if (started_)
        move_up(static_cast<int>(total_count_));
      for (auto &bar : bars_) {
        bar.get().print_progress(true);
        std::cout << "\n";
      }
      if (!started_)
        started_ = true;
    }
    total_count_ = bars_.size();
    std::cout << termcolor::reset;
  }
};

} // namespace indicators

#endif


#ifndef INDICATORS_PROGRESS_SPINNER
#define INDICATORS_PROGRESS_SPINNER

// #include <indicators/details/stream_helper.hpp>

#include <algorithm>
#include <atomic>
#include <chrono>
#include <cmath>
// #include <indicators/color.hpp>
// #include <indicators/setting.hpp>
#include <iomanip>
#include <iostream>
#include <mutex>
#include <string>
#include <thread>
#include <tuple>
#include <vector>

namespace indicators {

class ProgressSpinner {
  using Settings =
      std::tuple<option::ForegroundColor, option::PrefixText, option::PostfixText,
                 option::ShowPercentage, option::ShowElapsedTime, option::ShowRemainingTime,
                 option::ShowSpinner, option::SavedStartTime, option::Completed,
                 option::MaxPostfixTextLen, option::SpinnerStates, option::FontStyles,
                 option::MaxProgress, option::Stream>;

public:
  template <typename... Args,
            typename std::enable_if<details::are_settings_from_tuple<
                                        Settings, typename std::decay<Args>::type...>::value,
                                    void *>::type = nullptr>
  explicit ProgressSpinner(Args &&... args)
      : settings_(
            details::get<details::ProgressBarOption::foreground_color>(
                option::ForegroundColor{Color::unspecified}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::prefix_text>(option::PrefixText{},
                                                                  std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::postfix_text>(option::PostfixText{},
                                                                   std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::show_percentage>(option::ShowPercentage{true},
                                                                      std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::show_elapsed_time>(
                option::ShowElapsedTime{false}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::show_remaining_time>(
                option::ShowRemainingTime{false}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::spinner_show>(option::ShowSpinner{true},
                                                                   std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::saved_start_time>(
                option::SavedStartTime{false}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::completed>(option::Completed{false},
                                                                std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::max_postfix_text_len>(
                option::MaxPostfixTextLen{0}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::spinner_states>(
                option::SpinnerStates{
                    std::vector<std::string>{"⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"}},
                std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::font_styles>(
                option::FontStyles{std::vector<FontStyle>{}}, std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::max_progress>(option::MaxProgress{100},
                                                                   std::forward<Args>(args)...),
            details::get<details::ProgressBarOption::stream>(option::Stream{std::cout},
                                                             std::forward<Args>(args)...)) {}

  template <typename T, details::ProgressBarOption id>
  void set_option(details::Setting<T, id> &&setting) {
    static_assert(!std::is_same<T, typename std::decay<decltype(details::get_value<id>(
                                       std::declval<Settings>()))>::type>::value,
                  "Setting has wrong type!");
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<id>() = std::move(setting).value;
  }

  template <typename T, details::ProgressBarOption id>
  void set_option(const details::Setting<T, id> &setting) {
    static_assert(!std::is_same<T, typename std::decay<decltype(details::get_value<id>(
                                       std::declval<Settings>()))>::type>::value,
                  "Setting has wrong type!");
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<id>() = setting.value;
  }

  void set_option(
      const details::Setting<std::string, details::ProgressBarOption::postfix_text> &setting) {
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<details::ProgressBarOption::postfix_text>() = setting.value;
    if (setting.value.length() > get_value<details::ProgressBarOption::max_postfix_text_len>()) {
      get_value<details::ProgressBarOption::max_postfix_text_len>() = setting.value.length();
    }
  }

  void
  set_option(details::Setting<std::string, details::ProgressBarOption::postfix_text> &&setting) {
    std::lock_guard<std::mutex> lock(mutex_);
    get_value<details::ProgressBarOption::postfix_text>() = std::move(setting).value;
    auto &new_value = get_value<details::ProgressBarOption::postfix_text>();
    if (new_value.length() > get_value<details::ProgressBarOption::max_postfix_text_len>()) {
      get_value<details::ProgressBarOption::max_postfix_text_len>() = new_value.length();
    }
  }

  void set_progress(size_t value) {
    {
      std::lock_guard<std::mutex> lock{mutex_};
      progress_ = value;
    }
    save_start_time();
    print_progress();
  }

  void tick() {
    {
      std::lock_guard<std::mutex> lock{mutex_};
      progress_ += 1;
    }
    save_start_time();
    print_progress();
  }

  size_t current() {
    std::lock_guard<std::mutex> lock{mutex_};
    return (std::min)(progress_, size_t(get_value<details::ProgressBarOption::max_progress>()));
  }

  bool is_completed() const { return get_value<details::ProgressBarOption::completed>(); }

  void mark_as_completed() {
    get_value<details::ProgressBarOption::completed>() = true;
    print_progress();
  }

private:
  Settings settings_;
  size_t progress_{0};
  size_t index_{0};
  std::chrono::time_point<std::chrono::high_resolution_clock> start_time_point_;
  std::mutex mutex_;

  template <details::ProgressBarOption id>
  auto get_value() -> decltype((details::get_value<id>(std::declval<Settings &>()).value)) {
    return details::get_value<id>(settings_).value;
  }

  template <details::ProgressBarOption id>
  auto get_value() const
      -> decltype((details::get_value<id>(std::declval<const Settings &>()).value)) {
    return details::get_value<id>(settings_).value;
  }

  void save_start_time() {
    auto &show_elapsed_time = get_value<details::ProgressBarOption::show_elapsed_time>();
    auto &show_remaining_time = get_value<details::ProgressBarOption::show_remaining_time>();
    auto &saved_start_time = get_value<details::ProgressBarOption::saved_start_time>();
    if ((show_elapsed_time || show_remaining_time) && !saved_start_time) {
      start_time_point_ = std::chrono::high_resolution_clock::now();
      saved_start_time = true;
    }
  }

public:
  void print_progress() {
    std::lock_guard<std::mutex> lock{mutex_};

    auto &os = get_value<details::ProgressBarOption::stream>();

    const auto max_progress = get_value<details::ProgressBarOption::max_progress>();
    auto now = std::chrono::high_resolution_clock::now();
    auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(now - start_time_point_);

    if (get_value<details::ProgressBarOption::foreground_color>() != Color::unspecified)
      details::set_stream_color(os, get_value<details::ProgressBarOption::foreground_color>());

    for (auto &style : get_value<details::ProgressBarOption::font_styles>())
      details::set_font_style(os, style);

    os << get_value<details::ProgressBarOption::prefix_text>();
    if (get_value<details::ProgressBarOption::spinner_show>())
      os << get_value<details::ProgressBarOption::spinner_states>()
              [index_ % get_value<details::ProgressBarOption::spinner_states>().size()];
    if (get_value<details::ProgressBarOption::show_percentage>()) {
      os << " " << std::size_t(progress_ / double(max_progress) * 100) << "%";
    }

    if (get_value<details::ProgressBarOption::show_elapsed_time>()) {
      os << " [";
      details::write_duration(os, elapsed);
    }

    if (get_value<details::ProgressBarOption::show_remaining_time>()) {
      if (get_value<details::ProgressBarOption::show_elapsed_time>())
        os << "<";
      else
        os << " [";
      auto eta = std::chrono::nanoseconds(
          progress_ > 0
              ? static_cast<long long>(std::ceil(float(elapsed.count()) *
                                                 max_progress / progress_))
              : 0);
      auto remaining = eta > elapsed ? (eta - elapsed) : (elapsed - eta);
      details::write_duration(os, remaining);
      os << "]";
    } else {
      if (get_value<details::ProgressBarOption::show_elapsed_time>())
        os << "]";
    }

    if (get_value<details::ProgressBarOption::max_postfix_text_len>() == 0)
      get_value<details::ProgressBarOption::max_postfix_text_len>() = 10;
    os << " " << get_value<details::ProgressBarOption::postfix_text>()
       << std::string(get_value<details::ProgressBarOption::max_postfix_text_len>(), ' ') << "\r";
    os.flush();
    index_ += 1;
    if (progress_ > max_progress) {
      get_value<details::ProgressBarOption::completed>() = true;
    }
    if (get_value<details::ProgressBarOption::completed>())
      os << termcolor::reset << std::endl;
  }
};

} // namespace indicators

#endif

```

`covirt/utils/log.hpp`:

```hpp
#pragma once

#include <print>
#include <format>
#include <chrono>

#include "termcolors.h"

namespace out {
    enum class prefix : bool {
        no_prefix = false,
        with_prefix = true
    };

    enum class fmt : bool {
        x = false,
        X = true
    };

    static inline void clear() { std::print("\33[2K\r"); }

    static inline std::string get_timestamp() 
    {
        auto now = std::chrono::system_clock::now();
        auto now_time_t = std::chrono::system_clock::to_time_t(now);
        std::tm now_tm = *std::localtime(&now_time_t);
        return std::format("{}{:04}-{:02}-{:02} {:02}:{:02}:{:02}{}", COLOR_INPUT,
                        now_tm.tm_year + 1900, now_tm.tm_mon + 1, now_tm.tm_mday,
                        now_tm.tm_hour, now_tm.tm_min, now_tm.tm_sec, COLOR_RESET);
    }

    template<typename... Args>
    static inline void error(std::format_string<Args...> fmt, Args&&... args) 
    {
        std::print("{}error: {}", COLOR_ERROR, COLOR_RESET);
        std::print(fmt, std::forward<Args>(args)...);
    }

    // template<typename... Args>
    // static inline void warn(std::format_string<Args...> fmt, Args&&... args) 
    // {
    //     std::print("{}warn: {}", COLOR_WARN, COLOR_RESET);
    //     std::print(fmt, std::forward<Args>(args)...);
    // }

    template<typename... Args>
    static inline void special(std::format_string<Args...> fmt, Args&&... args) 
    {
        std::print("{}", COLOR_WARN);
        std::print(fmt, std::forward<Args>(args)...);
        std::print("{}", COLOR_RESET);
    }

    static inline std::string indent(int lvl = 1)
    {
        return std::string((lvl * 4) - 1, ' ');
    }

    template <typename T = uint64_t>
    static inline std::string value(T v)
    {
        return std::format("{}{}{}", COLOR_VALUE, v, COLOR_RESET);
    }

    static inline std::string name(const std::string &s)
    {
        return std::format("{}{}{}", COLOR_NAME, s, COLOR_RESET);
    }

    template <typename T>
    static inline std::string green(T v)
    {
        return std::format("{}{}{}", COLOR_GREEN, v, COLOR_RESET);
    }

    template <typename T>
    static inline std::string red(T v)
    {
        return std::format("{}{}{}", COLOR_RED, v, COLOR_RESET);
    }

    template <typename T>
    static inline std::string purple(T v)
    {
        return std::format("{}{}{}", COLOR_WARN, v, COLOR_RESET);
    }

    template <typename T>
    static inline std::string yellow(T v)
    {
        return std::format("{}{}{}", COLOR_YELLOW, v, COLOR_RESET);
    }

    template <typename T>
    static inline std::string good(T v)
    {
        return std::format("{}{}{}", COLOR_GOOD, v, COLOR_RESET);
    }

    template <typename T>
    static inline std::string bad(T v)
    {
        return std::format("{}{}{}", COLOR_BAD, v, COLOR_RESET);
    }

    template <typename T>
    static inline std::string blue(T v)
    {
        return std::format("{}{}{}", COLOR_NOTE, v, COLOR_RESET);
    }

    template <typename... Tx>
    static inline void ok(std::format_string<Tx...> fmt, Tx&&... args)
    {
        std::print("[{}] [{}] ", get_timestamp(), out::good("done"));
        std::println(fmt, std::forward<Tx>(args)...);
    }

    template <typename... Tx>
    static inline void fail(std::format_string<Tx...> fmt, Tx&&... args)
    {
        std::print("[{}] [{}] ", get_timestamp(), out::bad("fail"));
        std::println(fmt, std::forward<Tx>(args)...);
    }

    template <typename... Tx>
    static inline void warn(std::format_string<Tx...> fmt, Tx&&... args)
    {
        std::print("[{}] [{}] ",get_timestamp(), out::purple("warn"));
        std::println(fmt, std::forward<Tx>(args)...);
    }
    
    template <typename... Tx>
    static inline void info(std::format_string<Tx...> fmt, Tx&&... args)
    {
        std::print("[{}] [{}] ", get_timestamp(), out::blue("info"));
        std::println(fmt, std::forward<Tx>(args)...);
    }

    template <typename... Tx>
    static inline void wait(std::format_string<Tx...> fmt, Tx&&... args)
    {
        std::print("[{}] [{}] ", get_timestamp(), out::yellow("wait"));
        std::print(fmt, std::forward<Tx>(args)...);
    }

    template <typename... Tx>
    static inline void assertion(bool expr, std::format_string<Tx...> fmt, Tx&&... args)
    {
        if (!expr) {
            fail(fmt, std::forward<Tx>(args)...);
            abort();
        }
    }

    template<typename... Args>
    [[nodiscard]] static inline auto vformat(std::string_view fmt, Args&&... args)
    {
        return std::vformat(fmt, std::make_format_args(args...));
    }

    template <int bytes = 16>
    static inline std::string address(uint64_t v, fmt c = fmt::x, prefix p = prefix::no_prefix)
    {
        auto prefix = static_cast<bool>(p) ? "0x" : "";
        auto letter_case = static_cast<bool>(c) ? "X" : "x";
        return vformat(vformat("{{}}{}{{:0{}{}}}{{}}", prefix, bytes, letter_case), COLOR_ADDRESS, v, COLOR_RESET);
    }

    template <int bytes = 16>
    static inline std::string value_hex(uint64_t v, fmt c = fmt::x, prefix p = prefix::no_prefix)
    {
        auto prefix = static_cast<bool>(p) ? "0x" : "";
        auto letter_case = static_cast<bool>(c) ? "X" : "x";
        return vformat(vformat("{{}}{}{{:0{}{}}}{{}}", prefix, bytes, letter_case), COLOR_VALUE, v, COLOR_RESET);
    }

    static inline std::string hex_arr(uint8_t *bytes, size_t length, const std::string &suffix = "")
    {
        std::string result;
        for (int i = 0; i < length; i++)
            result = vformat("{}{:02x}{}", result, bytes[i], suffix);
        return result;
    }

    static inline std::string char_arr(uint8_t *bytes, size_t length, const std::string &suffix = "")
    {
        std::string result;
        for (int i = 0; i < length; i++)
            result = vformat("{}{:c}{}", result, std::isprint(bytes[i]) ? bytes[i] : '.', suffix);
        return result;
    }

    static inline std::string align(int max_count, int count, int spaces = 1)
    {
        auto rem = max_count - count;
        return rem <= 0 ? "" : std::string(rem * spaces, ' ');
    }
}

```

`covirt/utils/rand.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <random>
#include <ranges>

namespace covirt {
    template <typename T>
    inline T rand()
    {
        static std::random_device rd;
        static std::mt19937 generator(rd());

        if constexpr (!std::is_same_v<T, int8_t> && !std::is_same_v<T, uint8_t>) {
            static std::uniform_int_distribution<T> distribution(std::numeric_limits<T>::min(), std::numeric_limits<T>::max());
            return distribution(generator);
        }
        else {
            return T(rand<int>() & 0xff);
        }
    }
}

```

`covirt/utils/termcolors.h`:

```h
#pragma once

#define COLOR_ESC "\x1b["
#define COLOR_RESET COLOR_ESC "0m"

#define COLOR_ATTR_RESET "0;"
#define COLOR_ATTR_BOLD "1;"
#define COLOR_ATTR_DIM "2;"
#define COLOR_ATTR_UNDERLINE "3;"
#define COLOR_ATTR_BLINK "5;"
#define COLOR_ATTR_REVERSE "7;"
#define COLOR_ATTR_HIDDEN "8;"

#define COLOR_FG_BLACK "30"
#define COLOR_FG_RED "31"
#define COLOR_FG_GREEN "32"
#define COLOR_FG_YELLOW "33"
#define COLOR_FG_BLUE "34"
#define COLOR_FG_MAGENTA "35"
#define COLOR_FG_CYAN "36"
#define COLOR_FG_WHITE "37"
#define COLOR_FG_GRAY "90"

#define COLOR_BG_BLACK ";40m"
#define COLOR_BG_RED ";41m"
#define COLOR_BG_GREEN ";42m"
#define COLOR_BG_YELLOW ";43m"
#define COLOR_BG_BLUE ";44m"
#define COLOR_BG_MAGENTA ";45m"
#define COLOR_BG_CYAN ";46m"
#define COLOR_BG_WHITE ";47m"

#define COLOR_BG_NONE "m"

#ifndef NO_VERBOSE_COLOR_OUTPUT
#define COLOR(...) COLOR_ESC __VA_ARGS__
#else
#define COLOR(...) ""
#endif

#define COLOR_ADDRESS COLOR(COLOR_FG_YELLOW COLOR_BG_NONE) 
#define COLOR_VALUE COLOR(COLOR_FG_CYAN COLOR_BG_NONE) 
#define COLOR_ERROR COLOR(COLOR_ATTR_BOLD COLOR_FG_RED COLOR_BG_NONE) 
#define COLOR_WARN COLOR(COLOR_ATTR_BOLD COLOR_FG_MAGENTA COLOR_BG_NONE)
#define COLOR_GOOD COLOR(COLOR_ATTR_BOLD COLOR_FG_GREEN COLOR_BG_NONE)
#define COLOR_BAD COLOR(COLOR_ATTR_BOLD COLOR_FG_RED COLOR_BG_NONE)
#define COLOR_NOTE COLOR(COLOR_ATTR_BOLD COLOR_FG_BLUE COLOR_BG_NONE)
#define COLOR_INPUT COLOR(COLOR_FG_GRAY COLOR_BG_NONE)
#define COLOR_NAME COLOR(COLOR_FG_GREEN COLOR_BG_NONE)

#define COLOR_GREEN COLOR(COLOR_FG_GREEN COLOR_BG_NONE)
#define COLOR_RED COLOR(COLOR_FG_RED COLOR_BG_NONE)
#define COLOR_YELLOW COLOR(COLOR_ATTR_BOLD COLOR_FG_YELLOW COLOR_BG_NONE)

```

`covirt/vm/v0.cpp`:

```cpp
#include "v0.hpp"

#include <stack>
#include <utils/log.hpp>

void covirt::vm::v0_lifter::push_address(covirt::zydis_operand &operand)
{
    e.push_reg(8, uint8_t(operand.register_index()))
     .push_imm(8, uint64_t(operand.as_memory().disp.value))
     .add(8);
}

void covirt::vm::v0_lifter::push_operand(covirt::zydis_operand &operand, std::optional<int> override_size)
{
    int size = override_size.value_or(operand.size);
    
    if (operand.is_register())
        e.push_reg(size, uint8_t(operand.register_index()));
    else if (operand.is_immediate())
        e.push_imm(size, e.cast(operand.immediate(), size));
    else /* if (operand.is_memory()) */ {
        push_address(operand);
        e.read(size);
    }
}

void covirt::vm::v0_lifter::pop_operand(covirt::zydis_operand &operand, std::optional<int> override_size, std::optional<covirt::zydis_operand> src)
{
    int size = override_size.value_or(operand.size);
    auto src_operand = src.value_or(covirt::zydis_operand());

    if (operand.is_register())
        e.pop(size, uint8_t(operand.register_index()));
    else /* if (operand.is_memory()) */ {
        if (src_operand.is_empty() || src_operand.is_immediate()) {
            e.pop(size, uint8_t(tmp_reg_idx));
            push_address(operand);
            e.write(size, uint8_t(tmp_reg_idx));
        }
        else {
            push_address(operand);
            e.write(size, uint8_t(src_operand.register_index()));
        }
    }
}

void covirt::vm::v0_vm::initialize(zasm::x86::Assembler &a)
{
    for (auto& [name, label] : global_labels)
        label = a.createLabel(name.c_str());

    vip = zasm::x86::rax;
    vsp = zasm::x86::rsi;
    
    a.section(".text");
}

void covirt::vm::v0_vm::finalize(zasm::x86::Assembler& a) 
{
    a.section(".data", zasm::Section::Attribs::Data);

    a.bind(global_labels["vcode"]); a.db(0, code_size);
    a.bind(global_labels["saved_rsp"]); a.dq(0);
    a.bind(global_labels["_vsp"]); a.dq(stack_size);
    a.bind(global_labels["_vip"]); a.dq(0);
    a.bind(global_labels["vstack"]); a.db(0, stack_size);
    a.bind(global_labels["retaddr"]); a.dq(0);

    a.bind(global_labels["vtable"]);
    a.dq(0, 8);
}

void covirt::vm::v0_vm::vm_next_instruction(zasm::x86::Assembler& a, std::optional<zasm::Label> label) 
{
    if (label.has_value())
        a.bind(label.value());

    a.movzx(zasm::x86::rcx, zasm::x86::byte_ptr(vip));
    a.and_(zasm::x86::cl, 0b00111111);
    a.lea(zasm::x86::r9, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vtable"]));
    a.jmp(zasm::x86::qword_ptr(zasm::x86::r9, zasm::x86::rcx, 8));
}

void covirt::vm::v0_vm::jump_using_table(zasm::x86::Assembler& a, zasm::Label &paths)
{
    a.lea(zasm::x86::r9, zasm::x86::qword_ptr(zasm::x86::rip, paths));
    a.jmp(zasm::x86::qword_ptr(zasm::x86::r9, zasm::x86::rcx, 8));

    a.bind(paths);
    a.dq(0, 4);
}

void covirt::vm::v0_vm::get_size_from_opcode(zasm::x86::Assembler& a, zasm::Label &start)
{
    a.bind(start);
    a.movzx(zasm::x86::rcx, zasm::x86::byte_ptr(vip));
    a.shr(zasm::x86::cl, 6);
    a.add(vip, 1);
}

void covirt::vm::v0_vm::get_vreg_address(zasm::x86::Assembler& a)
{
    a.mov(zasm::x86::r9, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["saved_rsp"]));
    a.sub(zasm::x86::r9, 16*8);
    a.movzx(zasm::x86::r10, zasm::x86::byte_ptr(vip));
    a.lea(zasm::x86::rdx, zasm::x86::qword_ptr(zasm::x86::r9, zasm::x86::r10, 8));
    a.add(vip, 1);
}

void covirt::vm::v0_vm::get_vreg_value(zasm::x86::Assembler& a)
{
    a.mov(zasm::x86::r9, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["saved_rsp"]));
    a.sub(zasm::x86::r9, 16*8);
    a.movzx(zasm::x86::r10, zasm::x86::byte_ptr(vip));
    a.mov(zasm::x86::rdx, zasm::x86::qword_ptr(zasm::x86::r9, zasm::x86::r10, 8));
    a.add(vip, 1);
}

// to-do: ugly code, refactor plz, this was rush job
//
void covirt::vm::debug::dump_v0(lift_result &result)
{
    auto bytes = result.bytes;
    auto equivs = result.dump_index_table;

    static char suffix[] = { 'b', 'w', 'd', 'q' };
    int x = 0;
    int r = 0;

    std::stack<std::string> expression_stack;

    std::println("");
    std::println("| off | idx | lifted from                          | vm instruction             | expression");
    std::println("|-----|-----|--------------------------------------|----------------------------|---------------------------");

    for (int i = 0; i < bytes.size();) {
        uint8_t opcode = bytes[i] & 0b00111111;
        uint8_t size = 1 << (bytes[i] >> 6);

        std::print("| {:>12} | {:>12} | {:<36} | ", out::red(i), out::red(x), equivs.contains(x) ? equivs[x] : "");
        x++;

        switch (opcode) {
        using enum v0_op;
        case int(vm_exit):
            std::println("{:<26} | goto {} + {}", "vmexit", out::purple("retaddr"), out::value(*(uint16_t*)(&bytes[i + 1])));
            i += 2;
            break;
        case int(push_imm):
            std::print("push{} ", suffix[bytes[i] >> 6]);
            switch (size) {
            case 1: std::println("{:<29} | ", out::value_hex(*(uint8_t*)(&bytes[i + 1]))); expression_stack.push(out::value(*(int8_t*)(&bytes[i + 1]))); break;
            case 2: std::println("{:<29} | ", out::value_hex(*(uint16_t*)(&bytes[i + 1]))); expression_stack.push(out::value(*(int16_t*)(&bytes[i + 1]))); break;
            case 4: std::println("{:<29} | ", out::value_hex(*(uint32_t*)(&bytes[i + 1]))); expression_stack.push(out::value(*(int32_t*)(&bytes[i + 1]))); break;
            case 8: std::println("{:<29} | ", out::value_hex(*(uint64_t*)(&bytes[i + 1]))); expression_stack.push(out::value(*(int64_t*)(&bytes[i + 1]))); break;
            }
            i += size;
            break;
        case int(push_reg):
            std::println("{:<35} | ", std::format("push{} {}", suffix[bytes[i] >> 6], out::green(std::format("v{}", bytes[i + 1]))));
            if (bytes[i + 1] == 5) expression_stack.push(out::green(std::format("vbp", bytes[i + 1])));
            else expression_stack.push(out::green(std::format("v{}", bytes[i + 1])));
            i++;
            break;
        case int(pop):
            std::print("{:<35} | ", std::format("pop{} {}", suffix[bytes[i] >> 6], out::green(std::format("v{}", bytes[i + 1]))));
            {
                auto a = expression_stack.top(); expression_stack.pop();
                std::println("{} = ({}){}", out::green(std::format("v{}", bytes[i + 1])), out::yellow(std::format("u{}", size * 8)), a); 
            }
            i++;
            break;
        case int(read):
            std::print("{:<26} | ", std::format("read{}", suffix[bytes[i] >> 6]));
            {
                auto a = expression_stack.top(); expression_stack.pop();
                std::println("{} = *({}*)({})", out::purple(std::format("t{}", r)), out::yellow(std::format("u{}", size * 8)), a); 
            }
            expression_stack.push(out::purple(std::format("t{}", r++)));
            break;
        case int(write):
            std::print("{:<35} | ", std::format("write{} {}", suffix[bytes[i] >> 6], out::green(std::format("v{}", bytes[i + 1]))));
            {
                auto a = expression_stack.top(); expression_stack.pop();
                std::println("*({}*)({}) = {}", out::yellow(std::format("u{}", size * 8)), a, out::green(std::format("v{}", bytes[i + 1]))); 
            }
            i++;
            break;
        case int(add):
            std::print("{:<26} | ", std::format("add{}", suffix[bytes[i] >> 6]));
            { 
                auto a = expression_stack.top(); expression_stack.pop();
                auto b = expression_stack.top(); expression_stack.pop();
                std::println("{} = {} + {}", out::purple(std::format("t{}", r)), b, a); 
            }
            expression_stack.push(out::purple(std::format("t{}", r++)));
            break;
        case int(sub):
            std::print("{:<26} | ", std::format("sub{}", suffix[bytes[i] >> 6]));
            { 
                auto a = expression_stack.top(); expression_stack.pop();
                auto b = expression_stack.top(); expression_stack.pop();
                std::println("{} = {} - {}", out::purple(std::format("t{}", r)), b, a); 
            }
            expression_stack.push(out::purple(std::format("t{}", r++)));
            break;
        case int(bxor):
            std::print("{:<26} | ", std::format("xor{}", suffix[bytes[i] >> 6]));
            { 
                auto a = expression_stack.top(); expression_stack.pop();
                auto b = expression_stack.top(); expression_stack.pop();
                std::println("{} = {} ^ {}", out::purple(std::format("t{}", r)), b, a); 
            }
            expression_stack.push(out::purple(std::format("t{}", r++)));
            break;
        case int(cmp):
            std::println("{:<26} | ", std::format("cmp{}", suffix[bytes[i] >> 6]));
            expression_stack.push(out::purple(std::format("flags", r++)));
            break;
        case int(jz) ... int(jnle):
            {
                auto a = expression_stack.top(); expression_stack.pop();
                std::println("{:<26} | using {} goto {}", "jcc", a, out::red(*(uint16_t*)(&bytes[i + 1])));
                i += 2;
            }
            break;
        case int(jmp):
            {
                std::println("{:<26} | goto {}", "jmp", out::red(*(uint16_t*)(&bytes[i + 1])));
                i += 2;
            }
            break;
        case int(call):
            {
                std::println("{:<26} | goto {}", "call", out::red(*(uint16_t*)(&bytes[i + 1])));
                i += 4;
            }
            break;
        case int(lea):
            {
                std::println("{:<26} | goto {}", "lea", out::red(*(uint16_t*)(&bytes[i + 1])));
                i += 4;
            }
            break;
        case int(execute_native):
            {
                std::println("{:<26} | ", "exe_native");
                i += bytes[i + 1] + 1;
            }
            break;
        default:
            std::println("{:<35} | ", std::format("(bad:{:x})", bytes[i]));
            break;
        }

        i++;
    }

    std::println("");
}

```

`covirt/vm/v0.hpp`:

```hpp
#include <compiler/generic_lifter.hpp>
#include <compiler/generic_emitter.hpp>
#include <compiler/generic_vm.hpp>
#include <compiler/default_vm_enter.hpp>

#include <optional>

#include <zasm/zasm.hpp>

namespace covirt::vm {
    enum class v0_op : uint8_t {
        vm_enter, vm_exit, push_imm, push_reg, pop, read, write, add, sub, bxor, band, bor, cmp, jmp, jz, jnz, jb, jnb, jbe, jnbe, jl, jle, jnl, jnle, call, lea, execute_native
    };

    class v0_emitter : public generic_emitter {
    public:
    #define LAZY_EMIT(x) \
        template <typename S, typename... Tx> \
        auto& x(S encode_size, Tx&&... args) \
        { \
            emplace(opcode(v0_op::x, int(encode_size)), std::forward<Tx>(args)...); \
            return *this; \
        }

        LAZY_EMIT(push_reg);
        LAZY_EMIT(push_imm);
        LAZY_EMIT(pop);
        LAZY_EMIT(read);
        LAZY_EMIT(write);
        LAZY_EMIT(add);
        LAZY_EMIT(sub);
        LAZY_EMIT(bxor);
        LAZY_EMIT(band);
        LAZY_EMIT(bor);
        LAZY_EMIT(cmp);
        LAZY_EMIT(lea);
        LAZY_EMIT(call);
    #undef LAZY_EMIT
    };

    class v0_lifter : public generic_lifter {
    public:
        v0_emitter e;

        std::map<ZydisMnemonic, fn_instruction_translator_t>& get_translation_table() override
        {
            return lift_impl;
        }

        generic_emitter& get_emitter() override 
        {
            return e;
        }

        void vm_exit(uint16_t bytes_to_skip) override
        {
            e >> e.opcode(v0_op::vm_exit, 1) >> uint16_t(bytes_to_skip);
        }

        void native(uint8_t *ins_bytes, size_t length) override
        {
            e >> e.opcode(v0_op::execute_native, 1) >> uint8_t(length);
            for (int i = 0; i < length; i++) e >> ins_bytes[i];
        } 

    private:
        static constexpr uint8_t tmp_reg_idx = 14;

        void push_address(covirt::zydis_operand &operand);
        void push_operand(covirt::zydis_operand &operand, std::optional<int> override_size = {});
        void pop_operand(covirt::zydis_operand &operand, std::optional<int> override_size = {}, std::optional<covirt::zydis_operand> src = {});

        std::map<ZydisMnemonic, fn_instruction_translator_t> lift_impl = {
            {
                ZYDIS_MNEMONIC_MOV, [&](covirt::zydis_operand &dst, covirt::zydis_operand &src) {
                    push_operand(src, dst.size);
                    pop_operand(dst, {}, src);
                    return true;
                }
            },

#define LAZY_ARITH(mnemonic, op) \
            { \
                mnemonic, [&](covirt::zydis_operand &dst, covirt::zydis_operand &src) { \
                    push_operand(dst); \
                    push_operand(src, dst.size); \
                    e.op(dst.size); \
                    pop_operand(dst); \
                    return true; \
                } \
            }

            LAZY_ARITH(ZYDIS_MNEMONIC_ADD, add),
            LAZY_ARITH(ZYDIS_MNEMONIC_SUB, sub),
            LAZY_ARITH(ZYDIS_MNEMONIC_XOR, bxor),
            LAZY_ARITH(ZYDIS_MNEMONIC_AND, band),
            LAZY_ARITH(ZYDIS_MNEMONIC_OR, bor),
#undef LAZY_ARITH

            {
                ZYDIS_MNEMONIC_CMP, [&](covirt::zydis_operand &dst, covirt::zydis_operand &src) {
                    push_operand(dst);
                    push_operand(src, dst.size);
                    e.cmp(dst.size);
                    return true; \
                }
            },

#define LAZY_JUMP(mnemonic, op) \
            { \
                mnemonic, [&](covirt::zydis_operand &dst, covirt::zydis_operand &src) { \
                    e >> e.opcode(op, 1) >> uint16_t(0); \
                    fill_in_gaps.push_back({ dst.references_bb.value(), e.get().size() - sizeof(uint16_t), sizeof(uint16_t) }); \
                    return true; \
                } \
            }

            LAZY_JUMP(ZYDIS_MNEMONIC_JMP, v0_op::jmp),
            LAZY_JUMP(ZYDIS_MNEMONIC_JZ, v0_op::jz),
            LAZY_JUMP(ZYDIS_MNEMONIC_JNZ, v0_op::jnz),
            LAZY_JUMP(ZYDIS_MNEMONIC_JB, v0_op::jb),
            LAZY_JUMP(ZYDIS_MNEMONIC_JNB, v0_op::jnb),
            LAZY_JUMP(ZYDIS_MNEMONIC_JBE, v0_op::jbe),
            LAZY_JUMP(ZYDIS_MNEMONIC_JNBE, v0_op::jnbe),
            LAZY_JUMP(ZYDIS_MNEMONIC_JL, v0_op::jl),
            LAZY_JUMP(ZYDIS_MNEMONIC_JLE, v0_op::jle),
            LAZY_JUMP(ZYDIS_MNEMONIC_JNL, v0_op::jnl),
            LAZY_JUMP(ZYDIS_MNEMONIC_JNLE, v0_op::jnle),
#undef LAZY_JUMP

            {
                ZYDIS_MNEMONIC_LEA, [&](covirt::zydis_operand &dst, covirt::zydis_operand &src) {
                    if (src.as_memory().base != ZYDIS_REGISTER_RIP)
                        return false;

                    e.lea(dst.size, int32_t(dst.references_rva.value()));
                    pop_operand(dst);
                    return true;
                }
            },
            {
                ZYDIS_MNEMONIC_CALL, [&](covirt::zydis_operand &dst, covirt::zydis_operand &src) {
                    e.call(1, int32_t(dst.references_rva.value()));
                    return true;
                }
            },
        };
    };

    class v0_vm : public generic_vm {
    public:
        void initialize(zasm::x86::Assembler &a) override;
        void finalize(zasm::x86::Assembler& a) override;

        std::map<uint8_t, fn_vm_handler_t>& get_handlers() override { return vm_impl; }
        generic_vm_enter& get_vm_enter() override { return vm_enter_emitter; }

        void set_code_size(size_t size) override { code_size = size; };
        void set_stack_size(size_t size) override { stack_size = size; };

    private:
        zasm::x86::Gp64 vip, vsp;

        size_t code_size = 0;
        size_t stack_size = 0;

        std::map<std::string, zasm::Label> global_labels = {
            {"saved_rsp", {}},
            {"_vsp", {}},
            {"_vip", {}},
            {"vstack", {}},
            {"vcode", {}},
            {"vtable", {}},
            {"retaddr", {}},
            {"venter", {}},
            {"vexit", {}},
            {"vpush_imm", {}},
            {"vpush_reg", {}},
            {"vpop", {}},
            {"vread", {}},
            {"vwrite", {}},
            {"vadd", {}},
            {"vsub", {}},
            {"vxor", {}},
            {"vand", {}},
            {"vor", {}},
            {"vcmp", {}},
            {"vjmp", {}},
            {"vjz", {}},
            {"vjnz", {}},
            {"vjb", {}},
            {"vjnb", {}},
            {"vjbe", {}},
            {"vjnbe", {}},
            {"vjl", {}},
            {"vjle", {}},
            {"vjnl", {}},
            {"vjnle", {}},
            {"vcall", {}},
            {"vlea", {}},
            {"vexenative", {}}
        };

        default_vm_enter vm_enter_emitter;

        // to-do: look into `embedLabelRel` instead of runtime creation? idk
        //
        template <typename T, typename... Tx>
        void create_jump_table_once(zasm::x86::Assembler& a, T table, Tx&&... entries)
        {
            auto pass = a.createLabel();

            a.cmp(zasm::x86::qword_ptr(zasm::x86::rip, table), 0);
            a.jnz(pass);

            a.lea(zasm::x86::r9, zasm::x86::qword_ptr(zasm::x86::rip, table));
            (([&](auto &&label) { 
                a.lea(zasm::x86::r10, zasm::x86::qword_ptr(zasm::x86::rip, label));
                a.mov(zasm::x86::qword_ptr(zasm::x86::r9), zasm::x86::r10);
                a.add(zasm::x86::r9, 8);
            })(entries), ...);

            a.bind(pass);
        }

        void vm_next_instruction(zasm::x86::Assembler& a, std::optional<zasm::Label> label = {});
        void jump_using_table(zasm::x86::Assembler& a, zasm::Label &paths);
        void get_size_from_opcode(zasm::x86::Assembler& a, zasm::Label &start);
        void get_vreg_address(zasm::x86::Assembler& a);
        void get_vreg_value(zasm::x86::Assembler& a);

        std::map<uint8_t, fn_vm_handler_t> vm_impl = {
            {
                uint8_t(v0_op::vm_enter), [&](zasm::x86::Assembler& a) {
                    a.bind(global_labels["venter"]);

                    a.pop(zasm::x86::r11);
                    a.mov(zasm::x86::qword_ptr(zasm::x86::rip, global_labels["retaddr"]), zasm::x86::r11);
                    a.pop(zasm::x86::r11);
                    a.mov(zasm::x86::qword_ptr(zasm::x86::rip, global_labels["saved_rsp"]), zasm::x86::rsp);

                    // to-do: save r9, r10 before?
                    // to-do: not ideal, this is repetitive

                    create_jump_table_once(a, global_labels["vtable"], global_labels["venter"], global_labels["vexit"], 
                            global_labels["vpush_imm"], global_labels["vpush_reg"], global_labels["vpop"], global_labels["vread"], global_labels["vwrite"], 
                            global_labels["vadd"], global_labels["vsub"], global_labels["vxor"], global_labels["vand"], global_labels["vor"], 
                            global_labels["vcmp"], global_labels["vjmp"], global_labels["vjz"], global_labels["vjnz"], global_labels["vjb"], 
                            global_labels["vjnb"], global_labels["vjbe"], global_labels["vjnbe"], global_labels["vjl"], global_labels["vjle"],
                            global_labels["vjnl"], global_labels["vjnle"], global_labels["vcall"], global_labels["vlea"], global_labels["vexenative"]);

                    a.push(zasm::x86::r15); // -8
                    a.push(zasm::x86::r14); // -16
                    a.push(zasm::x86::r13); // -24
                    a.push(zasm::x86::r12); // -32
                    a.push(zasm::x86::r11); // -40
                    a.push(zasm::x86::r10); // -48
                    a.push(zasm::x86::r9); // -56
                    a.push(zasm::x86::r8); // -64
                    a.push(zasm::x86::rdi); // -72
                    a.push(zasm::x86::rsi); // -80
                    a.push(zasm::x86::rbp); // -88
                    a.push(zasm::x86::qword_ptr(zasm::x86::rip, global_labels["saved_rsp"])); // -96
                    a.push(zasm::x86::rbx); // -104
                    a.push(zasm::x86::rdx); // -112
                    a.push(zasm::x86::rcx); // -120
                    a.push(zasm::x86::rax); // -128
                    a.pushfq(); // -136

                    a.lea(vsp, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vstack"]));
                    a.add(vsp, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["_vsp"]));
                    a.lea(vip, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vcode"]));
                    a.add(vip, zasm::x86::r11);
                    vm_next_instruction(a);
                }
            },
            {
                uint8_t(v0_op::vm_exit), [&](zasm::x86::Assembler& a) {
                    a.bind(global_labels["vexit"]);

                    a.add(vip, 1);
                    a.mov(zasm::x86::r10w, zasm::x86::word_ptr(vip));
                    a.add(zasm::x86::word_ptr(zasm::x86::rip, global_labels["retaddr"]), zasm::x86::r10w);

                    a.popfq();
                    a.pop(zasm::x86::rax);
                    a.pop(zasm::x86::rcx);
                    a.pop(zasm::x86::rdx);
                    a.pop(zasm::x86::rbx);
                    a.pop(zasm::x86::rbp); // rsp
                    a.pop(zasm::x86::rbp);
                    a.pop(zasm::x86::rsi);
                    a.pop(zasm::x86::rdi);
                    a.pop(zasm::x86::r8);
                    a.pop(zasm::x86::r9);
                    a.pop(zasm::x86::r10);
                    a.pop(zasm::x86::r11);
                    a.pop(zasm::x86::r12);
                    a.pop(zasm::x86::r13);
                    a.pop(zasm::x86::r14);
                    a.pop(zasm::x86::r15);

                    vm_enter_emitter.revert_effects(a);

                    a.jmp(zasm::x86::qword_ptr(zasm::x86::rip, global_labels["retaddr"]));
                }
            },
            {
                uint8_t(v0_op::push_imm), [&](zasm::x86::Assembler& a) {
                    auto labels = [&]{ std::array<zasm::Label, 6> res; for (auto&x:res) x = a.createLabel(); return res; }();

                    auto vpushz = [&]<typename T>(int size, zasm::x86::Gp v, T ptr) {
                        a.bind(labels[1 + size]);
                        a.sub(vsp, 1 << size);
                        a.mov(v, ptr(std::forward<zasm::x86::Gp64>(vip)));
                        a.mov(ptr(std::forward<zasm::x86::Gp64>(vsp)), v);
                        a.add(vip, 1 << size);
                        a.jmp(labels[5]);
                    };

                    get_size_from_opcode(a, global_labels["vpush_imm"]);

                    create_jump_table_once(a, labels[0], labels[1], labels[2], labels[3], labels[4]);
                    jump_using_table(a, labels[0]);

                    vpushz(0b00, zasm::x86::cl, zasm::x86::byte_ptr<zasm::x86::Gp64>);
                    vpushz(0b01, zasm::x86::cx, zasm::x86::word_ptr<zasm::x86::Gp64>);
                    vpushz(0b10, zasm::x86::ecx, zasm::x86::dword_ptr<zasm::x86::Gp64>);
                    vpushz(0b11, zasm::x86::rcx, zasm::x86::qword_ptr<zasm::x86::Gp64>);
                    
                    vm_next_instruction(a, labels[5]);
                }
            },
            {
                uint8_t(v0_op::push_reg), [&](zasm::x86::Assembler& a) {
                    auto labels = [&]{ std::array<zasm::Label, 6> res; for (auto&x:res) x = a.createLabel(); return res; }();

                    auto vpushz = [&]<typename T>(int size, zasm::x86::Gp v, T ptr) {
                        a.bind(labels[1 + size]);
                        a.sub(vsp, 1 << size);
                        a.mov(ptr(std::forward<zasm::x86::Gp64>(vsp)), v);
                        a.jmp(labels[5]);
                    };

                    get_size_from_opcode(a, global_labels["vpush_reg"]);
                    get_vreg_value(a);

                    create_jump_table_once(a, labels[0], labels[1], labels[2], labels[3], labels[4]);
                    jump_using_table(a, labels[0]);

                    vpushz(0b00, zasm::x86::dl, zasm::x86::byte_ptr<zasm::x86::Gp64>);
                    vpushz(0b01, zasm::x86::dx, zasm::x86::word_ptr<zasm::x86::Gp64>);
                    vpushz(0b10, zasm::x86::edx, zasm::x86::dword_ptr<zasm::x86::Gp64>);
                    vpushz(0b11, zasm::x86::rdx, zasm::x86::qword_ptr<zasm::x86::Gp64>);
                    
                    vm_next_instruction(a, labels[5]);
                }
            },
            {
                uint8_t(v0_op::pop), [&](zasm::x86::Assembler& a) {
                    auto labels = [&]{ std::array<zasm::Label, 6> res; for (auto&x:res) x = a.createLabel(); return res; }();

                    auto vpopz = [&]<typename T>(int size, zasm::x86::Gp v, T ptr) {
                        a.bind(labels[1 + size]);
                        a.mov(v, ptr(std::forward<zasm::x86::Gp64>(vsp)));
                        a.add(vsp, 1 << size);
                        a.mov(ptr(const_cast<zasm::x86::Gp64&&>(zasm::x86::rdx)), v);
                        a.jmp(labels[5]);
                    };

                    get_size_from_opcode(a, global_labels["vpop"]);
                    get_vreg_address(a);

                    create_jump_table_once(a, labels[0], labels[1], labels[2], labels[3], labels[4]);
                    jump_using_table(a, labels[0]);

                    vpopz(0b00, zasm::x86::cl, zasm::x86::byte_ptr<zasm::x86::Gp64>);
                    vpopz(0b01, zasm::x86::cx, zasm::x86::word_ptr<zasm::x86::Gp64>);
                    vpopz(0b10, zasm::x86::ecx, zasm::x86::dword_ptr<zasm::x86::Gp64>);
                    vpopz(0b11, zasm::x86::rcx, zasm::x86::qword_ptr<zasm::x86::Gp64>);
                    
                    vm_next_instruction(a, labels[5]);
                }
            },
            {
                uint8_t(v0_op::read), [&](zasm::x86::Assembler& a) {
                    auto labels = [&]{ std::array<zasm::Label, 6> res; for (auto&x:res) x = a.createLabel(); return res; }();

                    auto vreadz = [&]<typename T>(int size, zasm::x86::Gp v, T ptr) {
                        a.bind(labels[1 + size]);
                        a.mov(zasm::x86::rdx, zasm::x86::qword_ptr(vsp));
                        a.add(vsp, 8 - (1 << size));
                        a.mov(v, ptr(const_cast<zasm::x86::Gp64&&>(zasm::x86::rdx)));
                        a.mov(ptr(std::forward<zasm::x86::Gp64>(vsp)), v);
                        a.jmp(labels[5]);
                    };

                    get_size_from_opcode(a, global_labels["vread"]);

                    create_jump_table_once(a, labels[0], labels[1], labels[2], labels[3], labels[4]);
                    jump_using_table(a, labels[0]);

                    vreadz(0b00, zasm::x86::cl, zasm::x86::byte_ptr<zasm::x86::Gp64>);
                    vreadz(0b01, zasm::x86::cx, zasm::x86::word_ptr<zasm::x86::Gp64>);
                    vreadz(0b10, zasm::x86::ecx, zasm::x86::dword_ptr<zasm::x86::Gp64>);
                    vreadz(0b11, zasm::x86::rcx, zasm::x86::qword_ptr<zasm::x86::Gp64>);

                    vm_next_instruction(a, labels[5]);
                }
            },
            {
                uint8_t(v0_op::write), [&](zasm::x86::Assembler& a) {
                    auto labels = [&]{ std::array<zasm::Label, 6> res; for (auto&x:res) x = a.createLabel(); return res; }();

                    auto vwritez = [&]<typename T>(int size, zasm::x86::Gp v, T ptr) {
                        a.bind(labels[1 + size]);
                        a.mov(zasm::x86::r10, zasm::x86::qword_ptr(vsp));
                        a.mov(ptr(const_cast<zasm::x86::Gp64&&>(zasm::x86::r10)), v);
                        a.add(vsp, 8);
                        a.jmp(labels[5]);
                    };

                    get_size_from_opcode(a, global_labels["vwrite"]);
                    get_vreg_value(a);

                    create_jump_table_once(a, labels[0], labels[1], labels[2], labels[3], labels[4]);
                    jump_using_table(a, labels[0]);

                    vwritez(0b00, zasm::x86::dl, zasm::x86::byte_ptr<zasm::x86::Gp64>);
                    vwritez(0b01, zasm::x86::dx, zasm::x86::word_ptr<zasm::x86::Gp64>);
                    vwritez(0b10, zasm::x86::edx, zasm::x86::dword_ptr<zasm::x86::Gp64>);
                    vwritez(0b11, zasm::x86::rdx, zasm::x86::qword_ptr<zasm::x86::Gp64>);

                    vm_next_instruction(a, labels[5]);
                }
            },
            {
                uint8_t(v0_op::add), [&](zasm::x86::Assembler& a) {
                    auto labels = [&]{ std::array<zasm::Label, 6> res; for (auto&x:res) x = a.createLabel(); return res; }();

                    auto varith = [&]<typename T>(int size, zasm::x86::Gp v0, zasm::x86::Gp v1, T ptr) {
                        a.bind(labels[1 + size]);
                        a.mov(v0, ptr(std::forward<zasm::x86::Gp64>(vsp)));
                        a.add(vsp, 1 << size);
                        a.mov(v1, ptr(std::forward<zasm::x86::Gp64>(vsp)));
                        a.add(v0, v1);
                        a.mov(ptr(std::forward<zasm::x86::Gp64>(vsp)), v0);
                        a.jmp(labels[5]);
                    };

                    get_size_from_opcode(a, global_labels["vadd"]);

                    create_jump_table_once(a, labels[0], labels[1], labels[2], labels[3], labels[4]);
                    jump_using_table(a, labels[0]);

                    varith(0b00, zasm::x86::cl, zasm::x86::dl, zasm::x86::byte_ptr<zasm::x86::Gp64>);
                    varith(0b01, zasm::x86::cx, zasm::x86::dx, zasm::x86::word_ptr<zasm::x86::Gp64>);
                    varith(0b10, zasm::x86::ecx, zasm::x86::edx, zasm::x86::dword_ptr<zasm::x86::Gp64>);
                    varith(0b11, zasm::x86::rcx, zasm::x86::rdx, zasm::x86::qword_ptr<zasm::x86::Gp64>);

                    vm_next_instruction(a, labels[5]);
                }
            },
            {
                uint8_t(v0_op::sub), [&](zasm::x86::Assembler& a) {
                    auto labels = [&]{ std::array<zasm::Label, 6> res; for (auto&x:res) x = a.createLabel(); return res; }();

                    auto varith = [&]<typename T>(int size, zasm::x86::Gp v0, zasm::x86::Gp v1, T ptr) {
                        a.bind(labels[1 + size]);
                        a.mov(v0, ptr(std::forward<zasm::x86::Gp64>(vsp)));
                        a.add(vsp, 1 << size);
                        a.mov(v1, ptr(std::forward<zasm::x86::Gp64>(vsp)));
                        a.sub(v1, v0);
                        a.mov(ptr(std::forward<zasm::x86::Gp64>(vsp)), v1);
                        a.jmp(labels[5]);
                    };

                    get_size_from_opcode(a, global_labels["vsub"]);

                    create_jump_table_once(a, labels[0], labels[1], labels[2], labels[3], labels[4]);
                    jump_using_table(a, labels[0]);

                    varith(0b00, zasm::x86::cl, zasm::x86::dl, zasm::x86::byte_ptr<zasm::x86::Gp64>);
                    varith(0b01, zasm::x86::cx, zasm::x86::dx, zasm::x86::word_ptr<zasm::x86::Gp64>);
                    varith(0b10, zasm::x86::ecx, zasm::x86::edx, zasm::x86::dword_ptr<zasm::x86::Gp64>);
                    varith(0b11, zasm::x86::rcx, zasm::x86::rdx, zasm::x86::qword_ptr<zasm::x86::Gp64>);

                    vm_next_instruction(a, labels[5]);
                }
            },
            {
                uint8_t(v0_op::bxor), [&](zasm::x86::Assembler& a) {
                    auto labels = [&]{ std::array<zasm::Label, 6> res; for (auto&x:res) x = a.createLabel(); return res; }();

                    auto varith = [&]<typename T>(int size, zasm::x86::Gp v0, zasm::x86::Gp v1, T ptr) {
                        a.bind(labels[1 + size]);
                        a.mov(v0, ptr(std::forward<zasm::x86::Gp64>(vsp)));
                        a.add(vsp, 1 << size);
                        a.mov(v1, ptr(std::forward<zasm::x86::Gp64>(vsp)));
                        a.xor_(v1, v0);
                        a.mov(ptr(std::forward<zasm::x86::Gp64>(vsp)), v1);
                        a.jmp(labels[5]);
                    };

                    get_size_from_opcode(a, global_labels["vxor"]);

                    create_jump_table_once(a, labels[0], labels[1], labels[2], labels[3], labels[4]);
                    jump_using_table(a, labels[0]);

                    varith(0b00, zasm::x86::cl, zasm::x86::dl, zasm::x86::byte_ptr<zasm::x86::Gp64>);
                    varith(0b01, zasm::x86::cx, zasm::x86::dx, zasm::x86::word_ptr<zasm::x86::Gp64>);
                    varith(0b10, zasm::x86::ecx, zasm::x86::edx, zasm::x86::dword_ptr<zasm::x86::Gp64>);
                    varith(0b11, zasm::x86::rcx, zasm::x86::rdx, zasm::x86::qword_ptr<zasm::x86::Gp64>);

                    vm_next_instruction(a, labels[5]);
                }
            },
            {
                uint8_t(v0_op::band), [&](zasm::x86::Assembler& a) {
                    auto labels = [&]{ std::array<zasm::Label, 6> res; for (auto&x:res) x = a.createLabel(); return res; }();

                    auto varith = [&]<typename T>(int size, zasm::x86::Gp v0, zasm::x86::Gp v1, T ptr) {
                        a.bind(labels[1 + size]);
                        a.mov(v0, ptr(std::forward<zasm::x86::Gp64>(vsp)));
                        a.add(vsp, 1 << size);
                        a.mov(v1, ptr(std::forward<zasm::x86::Gp64>(vsp)));
                        a.and_(v1, v0);
                        a.mov(ptr(std::forward<zasm::x86::Gp64>(vsp)), v1);
                        a.jmp(labels[5]);
                    };

                    get_size_from_opcode(a, global_labels["vand"]);

                    create_jump_table_once(a, labels[0], labels[1], labels[2], labels[3], labels[4]);
                    jump_using_table(a, labels[0]);

                    varith(0b00, zasm::x86::cl, zasm::x86::dl, zasm::x86::byte_ptr<zasm::x86::Gp64>);
                    varith(0b01, zasm::x86::cx, zasm::x86::dx, zasm::x86::word_ptr<zasm::x86::Gp64>);
                    varith(0b10, zasm::x86::ecx, zasm::x86::edx, zasm::x86::dword_ptr<zasm::x86::Gp64>);
                    varith(0b11, zasm::x86::rcx, zasm::x86::rdx, zasm::x86::qword_ptr<zasm::x86::Gp64>);

                    vm_next_instruction(a, labels[5]);
                }
            },
            {
                uint8_t(v0_op::bor), [&](zasm::x86::Assembler& a) {
                    auto labels = [&]{ std::array<zasm::Label, 6> res; for (auto&x:res) x = a.createLabel(); return res; }();

                    auto varith = [&]<typename T>(int size, zasm::x86::Gp v0, zasm::x86::Gp v1, T ptr) {
                        a.bind(labels[1 + size]);
                        a.mov(v0, ptr(std::forward<zasm::x86::Gp64>(vsp)));
                        a.add(vsp, 1 << size);
                        a.mov(v1, ptr(std::forward<zasm::x86::Gp64>(vsp)));
                        a.or_(v1, v0);
                        a.mov(ptr(std::forward<zasm::x86::Gp64>(vsp)), v1);
                        a.jmp(labels[5]);
                    };

                    get_size_from_opcode(a, global_labels["vor"]);

                    create_jump_table_once(a, labels[0], labels[1], labels[2], labels[3], labels[4]);
                    jump_using_table(a, labels[0]);

                    varith(0b00, zasm::x86::cl, zasm::x86::dl, zasm::x86::byte_ptr<zasm::x86::Gp64>);
                    varith(0b01, zasm::x86::cx, zasm::x86::dx, zasm::x86::word_ptr<zasm::x86::Gp64>);
                    varith(0b10, zasm::x86::ecx, zasm::x86::edx, zasm::x86::dword_ptr<zasm::x86::Gp64>);
                    varith(0b11, zasm::x86::rcx, zasm::x86::rdx, zasm::x86::qword_ptr<zasm::x86::Gp64>);

                    vm_next_instruction(a, labels[5]);
                }
            },
            {
                uint8_t(v0_op::cmp), [&](zasm::x86::Assembler& a) {
                    auto labels = [&]{ std::array<zasm::Label, 6> res; for (auto&x:res) x = a.createLabel(); return res; }();

                    auto varith = [&]<typename T>(int size, zasm::x86::Gp v0, zasm::x86::Gp v1, T ptr) {
                        a.bind(labels[1 + size]);
                        a.mov(v0, ptr(std::forward<zasm::x86::Gp64>(vsp)));
                        a.add(vsp, 1 << size);
                        a.mov(v1, ptr(std::forward<zasm::x86::Gp64>(vsp)));
                        a.cmp(v1, v0);
                        a.pushfq();
                        a.pop(v0.r64());
                        a.add(vsp, 1 << size);
                        a.sub(vsp, 2);
                        a.mov(zasm::x86::word_ptr(std::forward<zasm::x86::Gp64>(vsp)), v0.r16());
                        a.jmp(labels[5]);
                    };

                    get_size_from_opcode(a, global_labels["vcmp"]);

                    create_jump_table_once(a, labels[0], labels[1], labels[2], labels[3], labels[4]);
                    jump_using_table(a, labels[0]);

                    varith(0b00, zasm::x86::cl, zasm::x86::dl, zasm::x86::byte_ptr<zasm::x86::Gp64>);
                    varith(0b01, zasm::x86::cx, zasm::x86::dx, zasm::x86::word_ptr<zasm::x86::Gp64>);
                    varith(0b10, zasm::x86::ecx, zasm::x86::edx, zasm::x86::dword_ptr<zasm::x86::Gp64>);
                    varith(0b11, zasm::x86::rcx, zasm::x86::rdx, zasm::x86::qword_ptr<zasm::x86::Gp64>);

                    vm_next_instruction(a, labels[5]);
                }
            },
            {
                uint8_t(v0_op::jmp), [&](zasm::x86::Assembler& a) {
                    a.bind(global_labels["vjmp"]);
                    a.add(vip, 1);
                    a.movzx(zasm::x86::rcx, zasm::x86::word_ptr(vip));
                    a.lea(vip, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vcode"]));
                    a.add(vip, zasm::x86::rcx);
                    vm_next_instruction(a);
                }
            },
            {
                uint8_t(v0_op::jz), [&](zasm::x86::Assembler& a) {
                    auto vnext = a.createLabel(), truth = a.createLabel();

                    a.bind(global_labels["vjz"]);
                    a.add(vip, 1);
                    a.movzx(zasm::x86::rdx, zasm::x86::word_ptr(vsp)); // ZF = 1?
                    a.and_(zasm::x86::rdx, 0x0040);
                    a.test(zasm::x86::rdx, zasm::x86::rdx);
                    a.jnz(truth);
                    a.add(vip, 2);
                    a.jmp(vnext);
                    
                    a.bind(truth);
                    a.movzx(zasm::x86::rcx, zasm::x86::word_ptr(vip));
                    a.lea(vip, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vcode"]));
                    a.add(vip, zasm::x86::rcx);
                    a.bind(vnext);
                    a.add(vsp, 2);
                    vm_next_instruction(a);
                }
            },
            {
                uint8_t(v0_op::jnz), [&](zasm::x86::Assembler& a) {
                    auto vnext = a.createLabel(), truth = a.createLabel();

                    a.bind(global_labels["vjnz"]);
                    a.add(vip, 1);
                    a.movzx(zasm::x86::rdx, zasm::x86::word_ptr(vsp)); // ZF = 0?
                    a.and_(zasm::x86::rdx, 0x0040);
                    a.test(zasm::x86::rdx, zasm::x86::rdx);
                    a.jz(truth);
                    a.add(vip, 2);
                    a.jmp(vnext);
                    
                    a.bind(truth);
                    a.movzx(zasm::x86::rcx, zasm::x86::word_ptr(vip));
                    a.lea(vip, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vcode"]));
                    a.add(vip, zasm::x86::rcx);
                    a.bind(vnext);
                    a.add(vsp, 2);
                    vm_next_instruction(a);
                }
            },
            {
                uint8_t(v0_op::jb), [&](zasm::x86::Assembler& a) {
                    auto vnext = a.createLabel(), truth = a.createLabel();

                    a.bind(global_labels["vjb"]);
                    a.add(vip, 1);
                    a.movzx(zasm::x86::rdx, zasm::x86::word_ptr(vsp)); // CF = 1?
                    a.and_(zasm::x86::rdx, 0x0001);
                    a.test(zasm::x86::rdx, zasm::x86::rdx);
                    a.jnz(truth);
                    a.add(vip, 2);
                    a.jmp(vnext);
                    
                    a.bind(truth);
                    a.movzx(zasm::x86::rcx, zasm::x86::word_ptr(vip));
                    a.lea(vip, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vcode"]));
                    a.add(vip, zasm::x86::rcx);
                    a.bind(vnext);
                    a.add(vsp, 2);
                    vm_next_instruction(a);
                }
            },
            {
                uint8_t(v0_op::jnb), [&](zasm::x86::Assembler& a) {
                    auto vnext = a.createLabel(), truth = a.createLabel();

                    a.bind(global_labels["vjnb"]);
                    a.add(vip, 1);
                    a.movzx(zasm::x86::rdx, zasm::x86::word_ptr(vsp)); // CF = 0?
                    a.and_(zasm::x86::rdx, 0x0001);
                    a.test(zasm::x86::rdx, zasm::x86::rdx);
                    a.jz(truth);
                    a.add(vip, 2);
                    a.jmp(vnext);
                    
                    a.bind(truth);
                    a.movzx(zasm::x86::rcx, zasm::x86::word_ptr(vip));
                    a.lea(vip, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vcode"]));
                    a.add(vip, zasm::x86::rcx);
                    a.bind(vnext);
                    a.add(vsp, 2);
                    vm_next_instruction(a);
                }
            },
            {
                uint8_t(v0_op::jbe), [&](zasm::x86::Assembler& a) {
                    auto vnext = a.createLabel(), truth = a.createLabel();

                    a.bind(global_labels["vjbe"]);
                    a.add(vip, 1);
                    a.movzx(zasm::x86::rdx, zasm::x86::word_ptr(vsp)); // CF = 1?
                    a.and_(zasm::x86::rdx, 0x0001);
                    a.test(zasm::x86::rdx, zasm::x86::rdx);
                    a.jnz(truth);
                    a.movzx(zasm::x86::rdx, zasm::x86::word_ptr(vsp)); // or ZF = 1?
                    a.and_(zasm::x86::rdx, 0x0040);
                    a.test(zasm::x86::rdx, zasm::x86::rdx);
                    a.jnz(truth);
                    a.add(vip, 2);
                    a.jmp(vnext);
                    
                    a.bind(truth);
                    a.movzx(zasm::x86::rcx, zasm::x86::word_ptr(vip));
                    a.lea(vip, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vcode"]));
                    a.add(vip, zasm::x86::rcx);
                    a.bind(vnext);
                    a.add(vsp, 2);
                    vm_next_instruction(a);
                }
            },
            {
                uint8_t(v0_op::jnbe), [&](zasm::x86::Assembler& a) {
                    auto vnext = a.createLabel(), truth = a.createLabel(), ntruth = a.createLabel();

                    a.bind(global_labels["vjnbe"]);
                    a.add(vip, 1);
                    a.movzx(zasm::x86::rdx, zasm::x86::word_ptr(vsp)); // CF = 0?
                    a.and_(zasm::x86::rdx, 0x0001);
                    a.test(zasm::x86::rdx, zasm::x86::rdx);
                    a.jnz(ntruth);
                    a.movzx(zasm::x86::rdx, zasm::x86::word_ptr(vsp)); // and ZF = 0?
                    a.and_(zasm::x86::rdx, 0x0040);
                    a.test(zasm::x86::rdx, zasm::x86::rdx);
                    a.jnz(ntruth);
                    a.jmp(truth);
                    a.bind(ntruth);
                    a.add(vip, 2);
                    a.jmp(vnext);
                    
                    a.bind(truth);
                    a.movzx(zasm::x86::rcx, zasm::x86::word_ptr(vip));
                    a.lea(vip, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vcode"]));
                    a.add(vip, zasm::x86::rcx);
                    a.bind(vnext);
                    a.add(vsp, 2);
                    vm_next_instruction(a);
                }
            },
            {
                uint8_t(v0_op::jl), [&](zasm::x86::Assembler& a) {
                    auto vnext = a.createLabel(), truth = a.createLabel();

                    a.bind(global_labels["vjl"]);
                    a.add(vip, 1);
                    a.movzx(zasm::x86::rdx, zasm::x86::word_ptr(vsp)); // or SF != OF?
                    a.and_(zasm::x86::rdx, 0x0880);
                    a.popcnt(zasm::x86::rdx, zasm::x86::rdx);
                    a.cmp(zasm::x86::rdx, 1);
                    a.jz(truth);
                    a.add(vip, 2);
                    a.jmp(vnext);
                    
                    a.bind(truth);
                    a.movzx(zasm::x86::rcx, zasm::x86::word_ptr(vip));
                    a.lea(vip, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vcode"]));
                    a.add(vip, zasm::x86::rcx);
                    a.bind(vnext);
                    a.add(vsp, 2);
                    vm_next_instruction(a);
                }
            },
            {
                uint8_t(v0_op::jle), [&](zasm::x86::Assembler& a) {
                    auto vnext = a.createLabel(), truth = a.createLabel();

                    a.bind(global_labels["vjle"]);
                    a.add(vip, 1);
                    a.movzx(zasm::x86::rdx, zasm::x86::word_ptr(vsp)); // ZF = 1?
                    a.and_(zasm::x86::rdx, 0x0040);
                    a.test(zasm::x86::rdx, zasm::x86::rdx);
                    a.jnz(truth);
                    a.movzx(zasm::x86::rdx, zasm::x86::word_ptr(vsp)); // or SF != OF?
                    a.and_(zasm::x86::rdx, 0x0880);
                    a.popcnt(zasm::x86::rdx, zasm::x86::rdx);
                    a.cmp(zasm::x86::rdx, 1);
                    a.jz(truth);
                    a.add(vip, 2);
                    a.jmp(vnext);
                    
                    a.bind(truth);
                    a.movzx(zasm::x86::rcx, zasm::x86::word_ptr(vip));
                    a.lea(vip, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vcode"]));
                    a.add(vip, zasm::x86::rcx);
                    a.bind(vnext);
                    a.add(vsp, 2);
                    vm_next_instruction(a);
                }
            },
            {
                uint8_t(v0_op::jnl), [&](zasm::x86::Assembler& a) {
                    auto vnext = a.createLabel(), truth = a.createLabel();

                    a.bind(global_labels["vjnl"]);
                    a.add(vip, 1);
                    a.movzx(zasm::x86::rdx, zasm::x86::word_ptr(vsp)); // or SF == OF?
                    a.and_(zasm::x86::rdx, 0x0880);
                    a.popcnt(zasm::x86::rdx, zasm::x86::rdx);
                    a.cmp(zasm::x86::rdx, 1);
                    a.jnz(truth);
                    a.add(vip, 2);
                    a.jmp(vnext);
                    
                    a.bind(truth);
                    a.movzx(zasm::x86::rcx, zasm::x86::word_ptr(vip));
                    a.lea(vip, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vcode"]));
                    a.add(vip, zasm::x86::rcx);
                    a.bind(vnext);
                    a.add(vsp, 2);
                    vm_next_instruction(a);
                }
            },
            {
                uint8_t(v0_op::jnle), [&](zasm::x86::Assembler& a) {
                    auto vnext = a.createLabel(), truth = a.createLabel(), ntruth = a.createLabel();

                    a.bind(global_labels["vjnle"]);
                    a.add(vip, 1);
                    a.movzx(zasm::x86::rdx, zasm::x86::word_ptr(vsp)); // ZF = 0?
                    a.and_(zasm::x86::rdx, 0x0040);
                    a.test(zasm::x86::rdx, zasm::x86::rdx);
                    a.jnz(ntruth);
                    a.movzx(zasm::x86::rdx, zasm::x86::word_ptr(vsp)); // and SF == OF?
                    a.and_(zasm::x86::rdx, 0x0880);
                    a.popcnt(zasm::x86::rdx, zasm::x86::rdx);
                    a.cmp(zasm::x86::rdx, 1);
                    a.jz(ntruth);
                    a.jmp(truth);
                    a.bind(ntruth);
                    a.add(vip, 2);
                    a.jmp(vnext);
                    
                    a.bind(truth);
                    a.movzx(zasm::x86::rcx, zasm::x86::word_ptr(vip));
                    a.lea(vip, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vcode"]));
                    a.add(vip, zasm::x86::rcx);
                    a.bind(vnext);
                    a.add(vsp, 2);
                    vm_next_instruction(a);
                }
            },
            {
                uint8_t(v0_op::call), [&](zasm::x86::Assembler& a) {
                    a.bind(global_labels["vcall"]);
                    a.add(vip, 1);
                    a.mov(zasm::x86::r11, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["retaddr"]));
                    a.movsxd(zasm::x86::r9, zasm::x86::dword_ptr(vip));
                    a.add(zasm::x86::r11, zasm::x86::r9);

                    // push original global_labels["retaddr"] to global_labels["vstack"], incase we vmenter somewhere else
                    a.sub(vsp, 8);
                    a.mov(zasm::x86::r9, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["retaddr"]));
                    a.mov(zasm::x86::qword_ptr(vsp), zasm::x86::r9);

                    // push current vip to global_labels["vstack"], in case we vmenter somewhere else
                    a.add(vip, 4);
                    a.sub(vsp, 8);
                    a.mov(zasm::x86::qword_ptr(vsp), vip);

                    // set vsp offset in case we vmenter somewhere else
                    a.mov(zasm::x86::qword_ptr(zasm::x86::rip, global_labels["_vsp"]), vsp);
                    a.lea(zasm::x86::r9, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vstack"]));
                    a.sub(zasm::x86::qword_ptr(zasm::x86::rip, global_labels["_vsp"]), zasm::x86::r9);

                    // vmexit proc
                    a.popfq();
                    a.pop(zasm::x86::rax);
                    a.pop(zasm::x86::rcx);
                    a.pop(zasm::x86::rdx);
                    a.pop(zasm::x86::rbx);
                    a.pop(zasm::x86::rbp); // rsp
                    a.pop(zasm::x86::rbp);
                    a.pop(zasm::x86::rsi);
                    a.pop(zasm::x86::rdi);
                    a.pop(zasm::x86::r8);
                    a.pop(zasm::x86::r9);
                    a.pop(zasm::x86::r10);
                    a.pop(zasm::x86::r12); // r11
                    a.pop(zasm::x86::r12);
                    a.pop(zasm::x86::r13);
                    a.pop(zasm::x86::r14);
                    a.pop(zasm::x86::r15);

                    vm_enter_emitter.revert_effects(a);

                    a.call(zasm::x86::r11);

                    // vmenter proc
                    vm_enter_emitter.assemble_effects(a);

                    a.push(zasm::x86::r15); // -8
                    a.push(zasm::x86::r14); // -16
                    a.push(zasm::x86::r13); // -24
                    a.push(zasm::x86::r12); // -32
                    a.push(zasm::x86::r11); // -40
                    a.push(zasm::x86::r10); // -48
                    a.push(zasm::x86::r9); // -56
                    a.push(zasm::x86::r8); // -64
                    a.push(zasm::x86::rdi); // -72
                    a.push(zasm::x86::rsi); // -80
                    a.push(zasm::x86::rbp); // -88
                    a.push(zasm::x86::qword_ptr(zasm::x86::rip, global_labels["saved_rsp"])); // -96
                    a.push(zasm::x86::rbx); // -104
                    a.push(zasm::x86::rdx); // -112
                    a.push(zasm::x86::rcx); // -120
                    a.push(zasm::x86::rax); // -128
                    a.pushfq(); // -136

                    a.lea(vsp, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vstack"]));
                    a.add(vsp, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["_vsp"]));

                    a.mov(vip, zasm::x86::qword_ptr(vsp));
                    a.add(vsp, 8);
                    a.mov(zasm::x86::r11, zasm::x86::qword_ptr(vsp));
                    a.mov(zasm::x86::qword_ptr(zasm::x86::rip, global_labels["retaddr"]), zasm::x86::r11);

                    vm_next_instruction(a);
                }
            },
            {
                uint8_t(v0_op::lea), [&](zasm::x86::Assembler& a) {
                    a.bind(global_labels["vlea"]);
                    a.add(vip, 1);
                    a.movsxd(zasm::x86::ecx, zasm::x86::dword_ptr(vip));
                    a.add(vip, 4);
                    a.add(zasm::x86::rcx, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["retaddr"]));
                    a.sub(vsp, 8);
                    a.mov(zasm::x86::qword_ptr(vsp), zasm::x86::rcx);
                    vm_next_instruction(a);
                }
            },
            {
                uint8_t(v0_op::execute_native), [&](zasm::x86::Assembler& a) {
                    a.bind(global_labels["vexenative"]);
                    
                    auto loop = a.createLabel();
                    auto native_code_section = a.createLabel();
                    auto done = a.createLabel();
                    
                    a.add(vip, 1);
                    a.movzx(zasm::x86::rcx, zasm::x86::byte_ptr(vip));
                    a.lea(zasm::x86::rdx, zasm::x86::qword_ptr(zasm::x86::rip, native_code_section));

                    a.add(vip, 1);

                    // to-do: use rep movsb? (bc currently mba is hardcoded to use rdi)
                    //
                    a.bind(loop);
                    a.test(zasm::x86::rcx, zasm::x86::rcx);
                    a.jz(done);
                    a.mov(zasm::x86::r9b, zasm::x86::byte_ptr(vip));
                    a.mov(zasm::x86::byte_ptr(zasm::x86::rdx), zasm::x86::r9b);
                    a.add(zasm::x86::rdx, 1);
                    a.add(vip, 1);
                    a.sub(zasm::x86::rcx, 1);
                    a.jmp(loop);
                    a.bind(done);

                    // push current vip to global_labels["vstack"], in case we vmenter somewhere else
                    a.sub(vsp, 8);
                    a.mov(zasm::x86::qword_ptr(vsp), vip);

                    // set vsp offset in case we vmenter somewhere else
                    a.mov(zasm::x86::qword_ptr(zasm::x86::rip, global_labels["_vsp"]), vsp);
                    a.lea(zasm::x86::r9, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vstack"]));
                    a.sub(zasm::x86::qword_ptr(zasm::x86::rip, global_labels["_vsp"]), zasm::x86::r9);

                    a.popfq();
                    a.pop(zasm::x86::rax);
                    a.pop(zasm::x86::rcx);
                    a.pop(zasm::x86::rdx);
                    a.pop(zasm::x86::rbx);
                    a.pop(zasm::x86::rbp); // rsp
                    a.pop(zasm::x86::rbp);
                    a.pop(zasm::x86::rsi);
                    a.pop(zasm::x86::rdi);
                    a.pop(zasm::x86::r8);
                    a.pop(zasm::x86::r9);
                    a.pop(zasm::x86::r10);
                    a.pop(zasm::x86::r12); // r11
                    a.pop(zasm::x86::r12);
                    a.pop(zasm::x86::r13);
                    a.pop(zasm::x86::r14);
                    a.pop(zasm::x86::r15);

                    vm_enter_emitter.revert_effects(a);

                    a.bind(native_code_section);
                    for (int i = 0; i < 16; i++)
                        a.nop();

                    vm_enter_emitter.assemble_effects(a);

                    a.push(zasm::x86::r15); // -8
                    a.push(zasm::x86::r14); // -16
                    a.push(zasm::x86::r13); // -24
                    a.push(zasm::x86::r12); // -32
                    a.push(zasm::x86::r11); // -40
                    a.push(zasm::x86::r10); // -48
                    a.push(zasm::x86::r9); // -56
                    a.push(zasm::x86::r8); // -64
                    a.push(zasm::x86::rdi); // -72
                    a.push(zasm::x86::rsi); // -80
                    a.push(zasm::x86::rbp); // -88
                    a.push(zasm::x86::qword_ptr(zasm::x86::rip, global_labels["saved_rsp"])); // -96
                    a.push(zasm::x86::rbx); // -104
                    a.push(zasm::x86::rdx); // -112
                    a.push(zasm::x86::rcx); // -120
                    a.push(zasm::x86::rax); // -128
                    a.pushfq(); // -136

                    a.lea(vsp, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["vstack"]));
                    a.add(vsp, zasm::x86::qword_ptr(zasm::x86::rip, global_labels["_vsp"]));

                    a.mov(vip, zasm::x86::qword_ptr(vsp));
                    a.add(vsp, 8);

                    a.lea(zasm::x86::rdx, zasm::x86::qword_ptr(zasm::x86::rip, native_code_section));
                    a.mov(zasm::x86::dword_ptr(zasm::x86::rdx), 0x90909090);
                    a.mov(zasm::x86::dword_ptr(zasm::x86::rdx, 4), 0x90909090);
                    a.mov(zasm::x86::dword_ptr(zasm::x86::rdx, 8), 0x90909090);
                    a.mov(zasm::x86::dword_ptr(zasm::x86::rdx, 12), 0x90909090);

                    vm_next_instruction(a);
                }
            }
        };
    };

    namespace debug {
        void dump_v0(lift_result &result);
    }
}

```

`include/covirt_stub.h`:

```h
#pragma once

#define __covirt_vm_start() \
    __asm__ __volatile__ (".byte 0x67, 0x48, 0x0F, 0x1F, 0x84, 0x00, 0xDE, 0xAD, 0xBE, 0xEF, 0x66, 0x67, 0x0F, 0x1F, 0x04, 0x00\n\t")

#define __covirt_vm_end() \
    __asm__ __volatile__ (".byte 0x67, 0x48, 0x0F, 0x1F, 0x84, 0x00, 0xDE, 0xAD, 0xBE, 0xEF, 0x66, 0x67, 0x0F, 0x1F, 0x04, 0x01\n\t")

#define __covirt_vm_start_bytes \
    "\x67\x48\x0F\x1F\x84\x00\xDE\xAD\xBE\xEF\x66\x67\x0F\x1F\x04\x00"

#define __covirt_vm_end_bytes \
    "\x67\x48\x0F\x1F\x84\x00\xDE\xAD\xBE\xEF\x66\x67\x0F\x1F\x04\x01"

#define __covirt_vm_stub_length0 \
    10

#define __covirt_vm_stub_length1 \
    6

#define __covirt_vm_stub_length \
    (__covirt_vm_stub_length0 + __covirt_vm_stub_length1)
    
```

`version.h.in`:

```in
#pragma once

#define COVIRT_VERSION_MAJOR @covirt_VERSION_MAJOR@
#define COVIRT_VERSION_MINOR @covirt_VERSION_MINOR@
#define COVIRT_VERSION_PATCH @covirt_VERSION_PATCH@
#define COVIRT_VERSION "@covirt_VERSION@"
```