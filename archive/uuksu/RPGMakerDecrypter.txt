Project Path: arc_uuksu_RPGMakerDecrypter_hfz68_pu

Source Tree:

```txt
arc_uuksu_RPGMakerDecrypter_hfz68_pu
├── CHANGELOG.MD
├── LICENSE.txt
├── README.MD
├── RPGMakerDecrypter.Cli
│   ├── CommandLineOptions.cs
│   ├── Exceptions
│   │   └── InvalidUsageException.cs
│   ├── MVMZHandler.cs
│   ├── Program.cs
│   ├── RGSSADHandler.cs
│   ├── RPGMakerDecrypter.Cli.csproj
│   └── icon_256x256_cli.ico
├── RPGMakerDecrypter.Common
│   ├── ExceptionLogger.cs
│   ├── RPGMakerDecrypter.Common.csproj
│   └── RPGMakerVersion.cs
├── RPGMakerDecrypter.MVMZ
│   ├── Constants.cs
│   ├── DirectoryFilesDecrypter.cs
│   ├── EncryptionKeyFinder.cs
│   ├── Exceptions
│   │   └── EncryptionKeyException.cs
│   ├── FileDecrypter.cs
│   ├── MV
│   │   ├── MVProjectReconstructor.cs
│   │   └── MvDirectoryFilesDecrypter.cs
│   ├── MZ
│   │   ├── MZProjectReconstructor.cs
│   │   └── MzDirectoryFilesDecrypter.cs
│   ├── ProjectReconstructor.cs
│   ├── RPGMakerDecrypter.MVMZ.csproj
│   └── RPGMakerVersionFinder.cs
├── RPGMakerDecrypter.RGSSAD
│   ├── ArchiveFileNameUtils.cs
│   ├── ArchivedFile.cs
│   ├── BinaryUtils.cs
│   ├── Constants.cs
│   ├── Exceptions
│   │   ├── InvalidArchiveException.cs
│   │   └── UnsupportedArchiveException.cs
│   ├── ProjectGenerator.cs
│   ├── RGSSAD.cs
│   ├── RGSSADv1.cs
│   ├── RGSSADv3.cs
│   └── RPGMakerDecrypter.RGSSAD.csproj
├── RPGMakerDecrypter.Tests
│   ├── BinaryUtilsTests.cs
│   ├── EncryptedArchives
│   │   ├── Game.rgss2a
│   │   ├── Game.rgss3a
│   │   └── Game.rgssad
│   ├── EncryptedFiles
│   │   ├── AudioMpeg
│   │   ├── AudioOrbis
│   │   └── Image
│   ├── FileDecrypterTests.cs
│   ├── FileHelpers.cs
│   ├── RGSSADv1Tests.cs
│   ├── RGSSADv3Tests.cs
│   └── RPGMakerDecrypter.Tests.csproj
├── RPGMakerDecrypter.sln
└── Resources
    └── icon_256x256.xcf

```

`CHANGELOG.MD`:

```MD
# Changed in this release

After a major architectural overhaul, I've decided to upgrade the RPG Maker Decrypter version to v3.0.0!

Biggest change in this release is the new and exiting support for the RPG Maker MV and MZ decryption. With this change, the RPG Maker Decrypter has become the only tool you will ever need to decrypt RPG Maker games made with any version.

With this change also becomes sad news for the fans of the GUI version. Because I do not have a personal Windows development environment anymore and thus am unable to update the Forms application, I've decided to drop its support. I removed the sources (including the experimental GTK UI), but they remain available in this [commit](https://github.com/uuksu/RPGMakerDecrypter/tree/1a24e8c0a9bbf7b9b1cb030a6a2eb20882e6df15). Maybe someone else would like to create a cross-platform UI (for example with Avalonia) or create a web service utilizing my code (that will be always FOSS with liberal license).

Application has also a new (not really) fancy icon! 
```

`LICENSE.txt`:

```txt
The MIT License (MIT)

Copyright (c) 2016 Mikko Uuksulainen

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.MD`:

```MD
# RPG Maker Decrypter

RPG Maker Decrypter can be used to extract encrypted archives and files created with **RPG Maker XP, VX VX Ace, MV or MZ**.
It can be also used to recreate a best guess of the original project.

## Usage

RPG Maker Decrypter is an advanced CLI application. To use it, you have a have basic skills of running terminal applications.

To decrypt RPG Maker XP, VX and VX Ace games, give the encrypted archive file as input (usually files with .rgssad, .rgss2a or .rgss3a extension, but these might also be renamed to something else). To decrypt MV or MZ games, give the game deployment root directory as the input.

To get available commands, use:

	RPGMakerDecrypter-cli
	
To extract archive to same directory where it exists, use

	RPGMakerDecrypter-cli C:\MyRPGMakerGame\Game.rgssad
	
To extract RPG Maker XP, VX or VX Ace archive to some other directory, use

	RPGMakerDecrypter-cli C:\MyRPGMakerGame\Game.rgssad --output=C:\OtherDirectory

To extract RPG Maker MV or MZ game to some other directory, use

	RPGMakerDecrypter-cli C:\MyRPGMakerGame\Game --output=C:\OtherDirectory
	
To give a best guess in creating the original project, use

	RPGMakerDecrypter-cli C:\MyRPGMakerGame\Game.rgssad --recreate-project

You must always specify the output directory when recreating a project for MV or MZ.

	RPGMakerDecrypter-cli C:\MyRPGMakerGame\Game.rgssad --recreate-project --output=C:\OtherDirectory

## RPG Maker Decrypter GUI

Unfortunately, support for GUI has ended. Sources still exist in [history](https://github.com/uuksu/RPGMakerDecrypter/tree/1a24e8c0a9bbf7b9b1cb030a6a2eb20882e6df15). Maybe you would like to continue the development of the Windows-only Forms GUI or create a totally new cross-platform alternative?

## Requirements

*  Application works with any platform .NET 8.0 targets.
* .NET Runtime is not required for prebuilt binaries on selected platforms as it is packaged in the executable.

## Binaries

Prebuilt binaries are available for selected platforms. See [Releases](https://github.com/uuksu/RPGMakerDecrypter/releases).

## Building

CLI application will compile with .NET 8.0 SDK, libraries target .NET Standard 2.0.
```

`RPGMakerDecrypter.Cli/CommandLineOptions.cs`:

```cs
using CommandLine;

namespace RPGMakerDecrypter.Cli
{
    public class CommandLineOptions
    {
        [Value(0, Required = true, HelpText = "Path to the .rgssad, .rgss2a or .rgss3a file or to MV and MZ deployment directory.")]
        public string InputPath { get; set; }

        [Option('o', "output", Required = false, HelpText = "Optional output directory path. Required if --reconstruct-project is set to true and input path is a MV or MZ directory.")]
        public string OutputDirectoryPath { get; set; }

        [Option('p', "reconstruct-project", Required = false, HelpText = "If set to true, tries to reconstruct the original project.")]
        public bool ReconstructProject { get; set; }
        
        [Option('w', "overwrite", Required = false, HelpText = "If set to true, destination files are overwritten.")]
        public bool Overwrite { get; set; }
    }
}

```

`RPGMakerDecrypter.Cli/Exceptions/InvalidUsageException.cs`:

```cs
using System;

namespace RPGMakerDecrypter.Cli.Exceptions;

public class InvalidUsageException(string message) : Exception(message);
```

`RPGMakerDecrypter.Cli/MVMZHandler.cs`:

```cs
using System;
using System.IO;
using RPGMakerDecrypter.Cli.Exceptions;
using RPGMakerDecrypter.Common;
using RPGMakerDecrypter.MVMZ;
using RPGMakerDecrypter.MVMZ.Exceptions;
using RPGMakerDecrypter.MVMZ.MV;
using RPGMakerDecrypter.MVMZ.MZ;
using RPGMakerDecrypter.RGSSAD;

namespace RPGMakerDecrypter.Cli
{
    public class MVMZHandler
    {
        public void Handle(CommandLineOptions commandLineOptions, RPGMakerVersion version)
        {
            if (commandLineOptions.ReconstructProject &&
                string.IsNullOrWhiteSpace(commandLineOptions.OutputDirectoryPath))
            {
                throw new InvalidUsageException("MV and MZ project reconstruction requires an output path. Please specify a path with -o or --output option.");
            }

            if (Directory.Exists(commandLineOptions.OutputDirectoryPath) && !commandLineOptions.Overwrite)
            {
                throw new InvalidUsageException("Output directory already exists. Please specify a different path or use the -w or --overwrite option.");
            }

            try
            {
                var workingDirectoryPath = commandLineOptions.InputPath;
                var deleteEncrypted = false;

                if (commandLineOptions.ReconstructProject)
                {
                    switch (version)
                    {
                        case RPGMakerVersion.MV:
                            new MVProjectReconstructor().Reconstruct(
                                commandLineOptions.InputPath,
                                commandLineOptions.OutputDirectoryPath);
                            break;
                        case RPGMakerVersion.MZ:
                            new MZProjectReconstructor().Reconstruct(
                                commandLineOptions.InputPath,
                                commandLineOptions.OutputDirectoryPath);
                            break;
                    }

                    // Change working directory to the project directory where all the necessary files are too
                    workingDirectoryPath = commandLineOptions.OutputDirectoryPath;
                    deleteEncrypted = true;
                }

                var encryptionKeyFinder = new EncryptionKeyFinder();
                var encryptionKey = encryptionKeyFinder.FindKey(workingDirectoryPath);

                switch (version)
                {
                    case RPGMakerVersion.MV:
                        new MvDirectoryFilesDecrypter().DecryptFiles(
                            encryptionKey, 
                            workingDirectoryPath,
                            deleteEncrypted,
                            commandLineOptions.Overwrite);
                        break;
                    case RPGMakerVersion.MZ:
                        new MzDirectoryFilesDecrypter().DecryptFiles(
                            encryptionKey, 
                            workingDirectoryPath,
                            deleteEncrypted,
                            commandLineOptions.Overwrite);
                        break;
                }
            }
            catch (EncryptionKeyException ex)
            {
                Console.WriteLine(ex.Message);
                Environment.Exit(1);
            }
        }   
    }
}


```

`RPGMakerDecrypter.Cli/Program.cs`:

```cs
using System;
using System.Linq;
using CommandLine;
using RPGMakerDecrypter.Cli.Exceptions;
using RPGMakerDecrypter.Common;
using RPGMakerDecrypter.MVMZ;
using RPGMakerDecrypter.RGSSAD;

namespace RPGMakerDecrypter.Cli
{
    static class Program
    {
        private static CommandLineOptions _commandLineOptions;

        static void Main(string[] args)
        {
            try
            {
                var parsedResult = Parser.Default.ParseArguments<CommandLineOptions>(args);
                _commandLineOptions = parsedResult.Value;

                if (parsedResult.Errors.Any())
                {
                    Environment.Exit(1);
                }
                
                var version = RGSSAD.RGSSAD.GetRPGMakerVersion(_commandLineOptions.InputPath);
                if (version == RPGMakerVersion.Unknown)
                {
                    var mvMzVersionFinder = new RPGMakerVersionFinder();
                    version = mvMzVersionFinder.FindVersion(_commandLineOptions.InputPath);
                }
                
                switch (version)
                {
                    case RPGMakerVersion.Xp:
                    case RPGMakerVersion.Vx:
                    case RPGMakerVersion.VxAce:
                        new RGSSADHandler().Handle(_commandLineOptions, version);
                        break;
                    case RPGMakerVersion.MV:
                    case RPGMakerVersion.MZ:
                        new MVMZHandler().Handle(_commandLineOptions, version);
                        break;
                    case RPGMakerVersion.Unknown:
                    default:
                        Console.WriteLine("Unable to determinite RPG Maker version. " +
                                          "Please rename RGSSAD file with a extension corresponding to version: " +
                                          "XP: .rgssad, VX: .rgss2a, VX Ace: .rgss3a " +
                                          "or point to MZ or MV directory (.");
                        Environment.Exit(1);
                        break;
                } 
            } catch (InvalidUsageException ex)
            {
                Console.WriteLine(ex.Message);
                Environment.Exit(1);
            }
            catch (Exception ex)
            {
                var logFilePath = ExceptionLogger.LogException(ex);
                Console.WriteLine("Unexpected error happened while trying to extract the archive.");
                Console.WriteLine($"Error log has been written to '{logFilePath}'");
                Console.WriteLine("Please create a issue and include the log contents there: https://github.com/uuksu/RPGMakerDecrypter/issues");
                Environment.Exit(1);
            }
        }
    }
}

```

`RPGMakerDecrypter.Cli/RGSSADHandler.cs`:

```cs
using System;
using System.IO;
using RPGMakerDecrypter.Cli.Exceptions;
using RPGMakerDecrypter.Common;
using RPGMakerDecrypter.RGSSAD;
using RPGMakerDecrypter.RGSSAD.Exceptions;

namespace RPGMakerDecrypter.Cli
{
    public class RGSSADHandler
    {
        public void Handle(CommandLineOptions commandLineOptions, RPGMakerVersion version)
        {
            string outputDirectoryPath;

            if (commandLineOptions.OutputDirectoryPath != null)
            {
                if (Directory.Exists(commandLineOptions.OutputDirectoryPath) && !commandLineOptions.Overwrite)
                {
                    throw new InvalidUsageException("Output directory already exists. Please specify a different path or use the -w or --overwrite option.");
                }
                
                if (!Directory.Exists(commandLineOptions.OutputDirectoryPath))
                {
                    Directory.CreateDirectory(commandLineOptions.OutputDirectoryPath);
                }
                
                outputDirectoryPath = commandLineOptions.OutputDirectoryPath;
            }
            else
            {
                var fi = new FileInfo(commandLineOptions.InputPath);
                outputDirectoryPath = fi.DirectoryName;
            }
            
            try
            {
                switch (version)
                {
                    case RPGMakerVersion.Xp:
                    case RPGMakerVersion.Vx:
                        var rgssadv1 = new RGSSADv1(commandLineOptions.InputPath);
                        rgssadv1.ExtractAllFiles(outputDirectoryPath, commandLineOptions.Overwrite);
                        break;
                    case RPGMakerVersion.VxAce:
                        var rgssadv2 = new RGSSADv3(commandLineOptions.InputPath);
                        rgssadv2.ExtractAllFiles(outputDirectoryPath, commandLineOptions.Overwrite);
                        break;
                }
            }
            catch (InvalidArchiveException)
            {
                Console.WriteLine("Archive is invalid or corrupted. Reading failed.");
                Console.WriteLine("Please create a issue: https://github.com/uuksu/RPGMakerDecrypter/issues");
                Environment.Exit(1);
            }
            catch (UnsupportedArchiveException)
            {
                Console.WriteLine("Archive is not supported or it is corrupted.");
                Console.WriteLine("Please create a issue: https://github.com/uuksu/RPGMakerDecrypter/issues");
                Environment.Exit(1);
            }

            if (commandLineOptions.ReconstructProject)
            {
                var outputSameAsArchivePath = new FileInfo(commandLineOptions.InputPath).Directory.FullName == new DirectoryInfo(outputDirectoryPath).FullName;
                ProjectGenerator.GenerateProject(version, outputDirectoryPath, !outputSameAsArchivePath);
            }
        }   
    }
}


```

`RPGMakerDecrypter.Cli/RPGMakerDecrypter.Cli.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <OutputType>Exe</OutputType>
    <AssemblyName>RPGMakerDecrypter-cli</AssemblyName>
    <GenerateAssemblyInfo>true</GenerateAssemblyInfo>
	<EnableWindowsTargeting>true</EnableWindowsTargeting>
    <PublishTrimmed>true</PublishTrimmed>
    <TrimMode>partial</TrimMode>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>icon_256x256_cli.ico</ApplicationIcon>
    <Title>RPG Maker Decrypter</Title>
	<AssemblyTitle>RPG Maker Decrypter</AssemblyTitle>
    <Description>Tool for decrypting RPG Maker XP, VX and VX Ace RGSSAD archives.</Description>
    <Copyright>Mikko Uuksulainen © 2015-2025</Copyright>
    <PackageProjectUrl>https://github.com/uuksu/RPGMakerDecrypter</PackageProjectUrl>
	<Version>3.0.0</Version>
	<MinVerMinimumMajorMinor>3.0</MinVerMinimumMajorMinor>
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="..\RPGMakerDecrypter.Common\RPGMakerDecrypter.Common.csproj" />
    <ProjectReference Include="..\RPGMakerDecrypter.MVMZ\RPGMakerDecrypter.MVMZ.csproj" />
    <ProjectReference Include="..\RPGMakerDecrypter.RGSSAD\RPGMakerDecrypter.RGSSAD.csproj" />
  </ItemGroup>
  <ItemGroup>
    <Content Include="icon_256x256_cli.ico" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="CommandLineParser" Version="2.9.1" />
	<PackageReference Include="MinVer" Version="4.2.0">
		<IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
		<PrivateAssets>all</PrivateAssets>
	</PackageReference>
  </ItemGroup>
</Project>
```

`RPGMakerDecrypter.Common/ExceptionLogger.cs`:

```cs
using System;
using System.IO;

namespace RPGMakerDecrypter.Common
{
    public static class ExceptionLogger
    {
        public static string LogException(Exception exception)
        {
            var outputFilePath = Path.Combine(Path.GetTempPath(), $"RPGMakerDecrypter-{Guid.NewGuid()}.log");
            File.WriteAllText(outputFilePath, exception.ToString());

            return outputFilePath;
        }
    }
}

```

`RPGMakerDecrypter.Common/RPGMakerDecrypter.Common.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
  </PropertyGroup>

</Project>

```

`RPGMakerDecrypter.Common/RPGMakerVersion.cs`:

```cs
namespace RPGMakerDecrypter.RGSSAD
{
    public enum RPGMakerVersion
    {
        Unknown,
        Xp,
        Vx,
        VxAce,
        MV,
        MZ
    }
}

```

`RPGMakerDecrypter.MVMZ/Constants.cs`:

```cs
using System.Collections.Generic;
using System.IO;

namespace RPGMakerDecrypter.MVMZ
{
    public static class Constants
    {
        public static readonly Dictionary<string, string> MVFileExtensionMaps = new Dictionary<string, string>()
        {
            { ".rpgmvo", ".ogg" },
            { ".rpgmvp", ".png" },
            { ".rpgmvm", ".m4a" }
        };
        
        public const string MVProjectFileName = "Game.rpgproject";
        public const string MVProjectFileContent = "RPGMV 1.6.3";

        
        public static readonly Dictionary<string, string> MZFileExtensionMaps = new Dictionary<string, string>()
        {
            { ".ogg_", ".ogg" },
            { ".png_", ".png" },
            { ".m4a_", ".m4a" }
        };
        
        public const string MZProjectFileName = "game.rmmzproject";
        public const string MZProjectFileContent = "RPGMZ 1.8.0";
        
        public static readonly string MacOSBundleDirectory = Path.Combine("Contents", "Resources", "app.nw");
    }
}
```

`RPGMakerDecrypter.MVMZ/DirectoryFilesDecrypter.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace RPGMakerDecrypter.MVMZ
{
    public abstract class DirectoryFilesDecrypter
    {
        private readonly FileDecrypter _fileDecrypter = new FileDecrypter();
        
        /// <summary>
        /// Decrypts files in a directory based on the provided key and file extension mappings.
        /// </summary>
        /// <param name="key">The encryption key.</param>
        /// <param name="inputPath">The path to the directory containing the encrypted files.</param>
        /// <param name="fileExtensionMaps">A dictionary mapping encrypted file extensions to their original extensions.</param>
        /// <param name="deleteEncrypted">Whether to delete the original encrypted files after decryption.</param>
        /// <param name="overwrite">Whether to overwrite existing decrypted files.</param>
        protected void Decrypt(byte[] key, string inputPath, Dictionary<string, string> fileExtensionMaps,
            bool deleteEncrypted, bool overwrite)
        {
            var directory = new DirectoryInfo(inputPath);

            var extensions = fileExtensionMaps.Keys.ToArray();
            
            var encryptedFiles = GetEncryptedFiles(directory, extensions);
            if (!encryptedFiles.Any())
            {
                return;
            }
            
            foreach (var encryptedFile in encryptedFiles)
            {
                // Encrypted files have a changed extensions, map back to the original extension and create the target path for new file
                var fileNameWithoutExtension = new string(encryptedFile.Name.Take(encryptedFile.Name.Length - encryptedFile.Extension.Length).ToArray());
                var realExtension = fileExtensionMaps[encryptedFile.Extension];
                var targetDirectory = encryptedFile.Directory.FullName;
                var targetFilePath = Path.Combine(targetDirectory, $"{fileNameWithoutExtension}{realExtension}");

                if (!overwrite && File.Exists(targetFilePath))
                {
                    continue;
                }
                
                var decryptedFile = _fileDecrypter.Decrypt(key, encryptedFile.FullName);
                
                File.WriteAllBytes(targetFilePath, decryptedFile);

                if (deleteEncrypted)
                {
                    File.Delete(encryptedFile.FullName);
                }
            }
        }

        private FileInfo[] GetEncryptedFiles(DirectoryInfo directory, string[] fileExtensions)
        {
            List<FileInfo> encryptedFiles = new List<FileInfo>();
            
            foreach (var fileExtension in fileExtensions)
            {
                encryptedFiles.AddRange(directory.GetFiles($"*{fileExtension}", SearchOption.AllDirectories));
            }

            return encryptedFiles.ToArray();
        }
    }
}
```

`RPGMakerDecrypter.MVMZ/EncryptionKeyFinder.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using RPGMakerDecrypter.MVMZ.Exceptions;

namespace RPGMakerDecrypter.MVMZ
{
    public class EncryptionKeyFinder
    {
        /// <summary>
        /// Finds the encryption key from the System.json file in the given input path.
        /// </summary>
        /// <param name="inputPath">The path to search for the System.json file.</param>
        /// <returns>The encryption key as a byte array.</returns>
        /// <exception cref="EncryptionKeyException">Thrown if the System.json file is not found, or if it does not contain a valid encryption key.</exception>
        public byte[] FindKey(string inputPath)
        {
            // System.json file contains the encryption key
            var systemFile = Directory.GetFiles(inputPath, "System.json", SearchOption.AllDirectories).FirstOrDefault();

            if (systemFile == null || !File.Exists(systemFile))
            {
                throw new EncryptionKeyException("Unable to find the System.json file from the input path.");
            }
            
            var systemFileJson = File.ReadAllText(systemFile);
            var systemObject = Newtonsoft.Json.JsonConvert.DeserializeObject<Dictionary<string, object>>(systemFileJson);

            if (!systemObject.TryGetValue("encryptionKey", out var hashValue))
            {
                throw new EncryptionKeyException(
                    "System.json file does not contain encryption key, unable to decrypt files. " +
                    "It's also possible that the files are not encrypted.");
            }

            // Encryption key is a MD5 hash of the key given when deploying the game.
            var md5Hash = (string)hashValue;
                
            if (string.IsNullOrWhiteSpace(md5Hash) || md5Hash.Length != 32)
            {
                throw new EncryptionKeyException("Found encryption key but it is too short.");
            }
            
            // MD5 hash to be split into 16 bytes to get the actual encryption key
            return MD5HashToByteArray(md5Hash);

        }
        
        private byte[] MD5HashToByteArray(string md5HashString)
        {
            var byteArray = new byte[16];
            
            for (var i = 0; i < 16; i++)
            {
                byteArray[i] = Convert.ToByte(md5HashString.Substring(i * 2, 2), 16);
            }
            
            return byteArray;
        }
    }
}
```

`RPGMakerDecrypter.MVMZ/Exceptions/EncryptionKeyException.cs`:

```cs
using System;

namespace RPGMakerDecrypter.MVMZ.Exceptions
{
    public class EncryptionKeyException : Exception
    {
        public EncryptionKeyException(string message) : base(message)
        {
            
        }
    }
}
```

`RPGMakerDecrypter.MVMZ/FileDecrypter.cs`:

```cs
using System.IO;
using System.Linq;

namespace RPGMakerDecrypter.MVMZ
{
    public class FileDecrypter
    {
        /// <summary>
        /// Decrypts a encrypted RPG Maker file using the provided key and input path.
        /// </summary>
        /// <param name="key">The encryption key.</param>
        /// <param name="inputPath">The path to the file to be decrypted.</param>
        /// <returns>The decrypted file data as a byte array.</returns>
        public byte[] Decrypt(byte[] key, string inputPath)
        {
            // Skip first 16 bytes from beginning of file (aka. fake header)
            var output = File.ReadAllBytes(inputPath).Skip(16).ToArray();
            
            // XOR back the first 16 bytes of the file that are encrypted with the key to get the decrypted bytes
            for (var i = 0; i < 16; i++)
            {
                output[i] = (byte) (output[i] ^ key[i]);
            }

            return output;
        }

    }
}
```

`RPGMakerDecrypter.MVMZ/MV/MVProjectReconstructor.cs`:

```cs
using System.IO;
using System.Linq;

namespace RPGMakerDecrypter.MVMZ.MV
{
    public class MVProjectReconstructor : ProjectReconstructor
    {
        public override void Reconstruct(string deploymentPath, string outputPath)
        {
            // Windows, Linux and Web and Android/iOS deployments have a separate www-directory
            var dataFilesPath = Path.Combine(deploymentPath, "www");

            // MacOS deployments have a different structure that needs to be handled separately
            var macOSBundleDirectory = Directory.GetDirectories(deploymentPath, "*.app", 
                SearchOption.TopDirectoryOnly).SingleOrDefault();
            
            if (!string.IsNullOrWhiteSpace(macOSBundleDirectory))
            {
                dataFilesPath = Path.Combine(macOSBundleDirectory, Constants.MacOSBundleDirectory);
            }
            
            // www-directory essentially contains the project files
            base.Reconstruct(dataFilesPath, outputPath);
        }

        protected override void CreateProjectFile(string outputPath)
        {
            File.WriteAllText(
                Path.Combine(outputPath, Constants.MVProjectFileName),
                Constants.MVProjectFileContent);
        }
    }
}
```

`RPGMakerDecrypter.MVMZ/MV/MvDirectoryFilesDecrypter.cs`:

```cs
namespace RPGMakerDecrypter.MVMZ.MV
{
    public class MvDirectoryFilesDecrypter : DirectoryFilesDecrypter
    {
        public void DecryptFiles(byte[] key, string inputPath, bool deleteEncrypted, bool overwrite)
        {
            Decrypt(key, inputPath, Constants.MVFileExtensionMaps, deleteEncrypted, overwrite);
        }
    }
}
```

`RPGMakerDecrypter.MVMZ/MZ/MZProjectReconstructor.cs`:

```cs
using System.IO;
using System.Linq;

namespace RPGMakerDecrypter.MVMZ.MZ
{
    public class MZProjectReconstructor : ProjectReconstructor
    {
        public override void Reconstruct(string deploymentPath, string outputPath)
        {
            // Windows, Linux and Web and Android/iOS deployments all files are in root of the deployment
            var dataFilesPath = deploymentPath;

            // MacOS deployments have a different structure that needs to be handled separately
            var macOSBundleDirectory = Directory.GetDirectories(deploymentPath, "*.app", 
                SearchOption.TopDirectoryOnly).SingleOrDefault();
            
            if (!string.IsNullOrWhiteSpace(macOSBundleDirectory))
            {
                dataFilesPath = Path.Combine(macOSBundleDirectory, Constants.MacOSBundleDirectory);
            }
            
            base.Reconstruct(dataFilesPath, outputPath);    
        }
        
        protected override void CreateProjectFile(string outputPath)
        {
            File.WriteAllText(
                Path.Combine(outputPath, Constants.MZProjectFileName),
                Constants.MZProjectFileContent);
        }
    }
}
```

`RPGMakerDecrypter.MVMZ/MZ/MzDirectoryFilesDecrypter.cs`:

```cs
namespace RPGMakerDecrypter.MVMZ.MZ
{
    public class MzDirectoryFilesDecrypter : DirectoryFilesDecrypter
    {
        public void DecryptFiles(byte[] key, string inputPath, bool deleteEncrypted, bool overwrite)
        {
            Decrypt(key, inputPath, Constants.MZFileExtensionMaps, deleteEncrypted, overwrite);
        }
    }
}
```

`RPGMakerDecrypter.MVMZ/ProjectReconstructor.cs`:

```cs
using System.IO;

namespace RPGMakerDecrypter.MVMZ
{
    public abstract class ProjectReconstructor
    {
        // Directories that should exist in the project directory
        private readonly string[] _directories = {
            "audio",
            "css",
            "data",
            "effects",
            "fonts",
            "icon",
            "img",
            "js",
            "movies"
        };

        // Files that should exist in the project directory
        private readonly string[] _files =
        {
            "index.html",
            "package.json"
        };

        protected abstract void CreateProjectFile(string outputPath);
        
        public virtual void Reconstruct(string deploymentPath, string outputPath)
        {
            if (Directory.Exists(outputPath))
            {
                Directory.Delete(outputPath, true);
                Directory.CreateDirectory(outputPath);
            }

            foreach (var directory in _directories)
            {
                CopyDirectory(Path.Combine(deploymentPath, directory), Path.Combine(outputPath, directory));
            }
            
            foreach (var file in _files)
            {
                File.Copy(Path.Combine(deploymentPath, file), Path.Combine(outputPath, file));
            }
            
            CreateProjectFile(outputPath);
        }

        private void CopyDirectory(string sourceDir, string destinationDir)
        {
            if (!Directory.Exists(sourceDir))
            {
                return;
            }
            
            Directory.CreateDirectory(destinationDir);

            foreach (var file in Directory.GetFiles(sourceDir))
            {
                var destFilePath = Path.Combine(destinationDir, Path.GetFileName(file));
                File.Copy(file, destFilePath);
            }

            foreach (var directory in Directory.GetDirectories(sourceDir))
            {
                var destDirectoryPath = Path.Combine(destinationDir, Path.GetFileName(directory));
                CopyDirectory(directory, destDirectoryPath);
            }
        }
    }
}
```

`RPGMakerDecrypter.MVMZ/RPGMakerDecrypter.MVMZ.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>netstandard2.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\RPGMakerDecrypter.Common\RPGMakerDecrypter.Common.csproj" />
    </ItemGroup>

</Project>

```

`RPGMakerDecrypter.MVMZ/RPGMakerVersionFinder.cs`:

```cs
using System.IO;
using System.Linq;
using RPGMakerDecrypter.RGSSAD;

namespace RPGMakerDecrypter.MVMZ
{
    public class RPGMakerVersionFinder
    {
        /// <summary>
        /// Attempts to determine the RPG Maker version based on the directory structure of the input path.
        /// Can detect only MV or MZ deployments.
        /// </summary>
        /// <param name="deploymentPath">The path to the RPG Maker deployment directory.</param>
        /// <returns>The RPG Maker version, or RPGMakerVersion.Unknown if the input path does not exist or its structure is unrecognized.</returns>
        public RPGMakerVersion FindVersion(string deploymentPath)
        {
            if (!Directory.Exists(deploymentPath))
            {
                return RPGMakerVersion.Unknown;
            }
            
            var directoryInfo = new DirectoryInfo(deploymentPath);

            // MV deployments have a separate www-directory that contains the data
            if (directoryInfo.GetDirectories().Any(d => d.Name == "www"))
            {
                return RPGMakerVersion.MV;
            }
            
            // MacOS deployments look same on both version, but they have a slightly different structure
            var macOSBundleDirectory = Directory.GetDirectories(deploymentPath, "*.app", SearchOption.TopDirectoryOnly).SingleOrDefault();
            if (!string.IsNullOrWhiteSpace(macOSBundleDirectory))
            {
                // Framework directory is missing from MV, it only exists in MZ
                if (Directory.Exists(Path.Combine(macOSBundleDirectory, "Contents", "Frameworks")))
                {
                    return RPGMakerVersion.MZ;
                }

                return RPGMakerVersion.MV;
            }

            // MZ deployments have the files in the root directory
            return RPGMakerVersion.MZ;
        }
    }
}
```

`RPGMakerDecrypter.RGSSAD/ArchiveFileNameUtils.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace RPGMakerDecrypter.RGSSAD
{
    public static class ArchivedFileNameUtils
    {
        public static string GetFileName(string name)
        {
            return GetPathParts(name).Last();
        }

        public static string GetPlatformSpecificPath(string name)
        {
            var pathParts = GetPathParts(name);

            pathParts = CleanUnicodeCharacters(pathParts);
            pathParts = CleanInvalidPathCharacters(pathParts);

            return Path.Combine(pathParts);
        }

        private static string[] GetPathParts(string name)
        {
            // Paths in RGSSAD file names are always with Windows-style delimeters
            return name.Split('\\');
        }

        private static string[] CleanUnicodeCharacters(string[] pathParts)
        {
            var cleanedPathParts = new List<string>();
            var unicodeConstantRegex = new Regex(@"(?i)\\(u|U)([0-9]|[A-F])([0-9]|[A-F])([0-9]|[A-F])([0-9]|[A-F])");

            foreach (var pathPart in pathParts)
            {
                cleanedPathParts.Add(unicodeConstantRegex.Replace(pathPart, string.Empty));
            }

            return cleanedPathParts.ToArray();
        }

        private static string[] CleanInvalidPathCharacters(string[] pathParts)
        {
            var cleanedPathParts = new List<string>();

            foreach (var pathPart in pathParts)
            {
                var cleanedPathPart = pathPart;

                foreach(var invalidFileNameChar in Path.GetInvalidFileNameChars())
                {
                    cleanedPathPart = cleanedPathPart.Replace($"{invalidFileNameChar}", string.Empty);
                }

                cleanedPathParts.Add(cleanedPathPart);
            }

            return cleanedPathParts.ToArray();
        }
    }
}

```

`RPGMakerDecrypter.RGSSAD/ArchivedFile.cs`:

```cs
namespace RPGMakerDecrypter.RGSSAD
{
    public class ArchivedFile
    {
        public string Name { get; set; }

        public int Size { get; set; }

        public long Offset { get; set; }

        public uint Key { get; set; }
    }
}

```

`RPGMakerDecrypter.RGSSAD/BinaryUtils.cs`:

```cs
using System.IO;
using System.Text;

namespace RPGMakerDecrypter.RGSSAD
{
    public static class BinaryUtils
    {
        /// <summary>
        /// Reads C style string from given binary reader.
        /// Seeks to end of the string after reading.
        /// </summary>
        /// <param name="binaryReader">The binary reader.</param>
        /// <param name="maxLength">The maximum length of the string</param>
        /// <returns>Found string</returns>
        public static string ReadCString(BinaryReader binaryReader, int maxLength)
        {
            var beginPosition = binaryReader.BaseStream.Position;
            var stringLenght = 0;

            // Searching for end of the C string (byte == 0, NUL character)
            do
            {
                var readByte = binaryReader.ReadByte();
                if (readByte == 0)
                    break;

                stringLenght += 1;
            } while (stringLenght < maxLength);

            // Seeking back to beginning
            binaryReader.BaseStream.Seek(beginPosition, SeekOrigin.Begin);

            var result = Encoding.ASCII.GetString(binaryReader.ReadBytes(stringLenght));

            // Seeking to end position of the string
            binaryReader.BaseStream.Seek(beginPosition + stringLenght + 1, SeekOrigin.Begin);

            return result;
        }
    }
}

```

`RPGMakerDecrypter.RGSSAD/Constants.cs`:

```cs
using System.Linq;

namespace RPGMakerDecrypter.RGSSAD
{
    public class Constants
    {
        public const string RpgMakerXpArchiveName = "Game.rgssad";
        public const string RpgMakerVxArchiveName = "Game.rgss2a";
        public const string RpgMakerVxAceArchiveName = "Game.rgss3a";

        public static string RpgMakerXpArchiveExtension = RpgMakerXpArchiveName.Split('.').Last();
        public static string RpgMakerVxArchiveExtension = RpgMakerVxArchiveName.Split('.').Last();
        public static string RpgMakerVxAceArchiveExtension = RpgMakerVxAceArchiveName.Split('.').Last();

        public const string RpgMakerXpProjectFileContent = "RPGXP 1.02";
        public const string RpgMakerVxProjectFileContent = "RPGVX 1.02";
        public const string RpgMakerVxAceProjectFileContent = "RPGVXAce 1.00";

        public const string RpgMakerXpProjectFileExtension = "rxproj";
        public const string RpgMakerVxProjectFileExtension = "rvproj";
        public const string RpgMakerVxAceProjectFileExtension = "rvproj2";

        public static readonly string RGSSADHeader = "RGSSAD";

        public const int RGASSDv1 = 1;
        public const int RGASSDv3 = 3;

        public static readonly int[] SupportedRGSSVersions = { RGASSDv1, RGASSDv3 };

        public static readonly uint RGASSADv1Key = 0xDEADCAFE;

        public const string RPGMakerXpIniFileContents =
            "[Game]\r\nLibrary=RGSS104E.dll\r\nScripts=Data\\Scripts.rxdata\r\nTitle=DecryptedProject\r\nRTP1=Standard\r\nRTP2=\r\nRTP3=";

        public const string RPGMakerVxIniFileContents =
            "[Game]\r\nRTP=RPGVX\r\nLibrary=RGSS202E.dll\r\nScripts=Data\\Scripts.rvdata\r\nTitle=DecryptedProject";

        public const string RPGMakerVxAceIniFileContents =
            "[Game]\r\nRTP=RPGVXAce\r\nLibrary=System\\RGSS300.dll\r\nScripts=Data\\Scripts.rvdata2\r\nTitle=DecryptedProject";
    }
}

```

`RPGMakerDecrypter.RGSSAD/Exceptions/InvalidArchiveException.cs`:

```cs
using System;

namespace RPGMakerDecrypter.RGSSAD.Exceptions
{
    public class InvalidArchiveException : Exception
    {
        public InvalidArchiveException(string message) : base(message)
        {
        }
    }
}

```

`RPGMakerDecrypter.RGSSAD/Exceptions/UnsupportedArchiveException.cs`:

```cs
using System;

namespace RPGMakerDecrypter.RGSSAD.Exceptions
{
    public class UnsupportedArchiveException : Exception
    {
        public UnsupportedArchiveException(string message) : base(message)
        {
        }
    }
}

```

`RPGMakerDecrypter.RGSSAD/ProjectGenerator.cs`:

```cs
using System.IO;

namespace RPGMakerDecrypter.RGSSAD
{
    public static class ProjectGenerator
    {
        /// <summary>
        /// Generates the project file and ini for given RPG Maker.
        /// </summary>
        /// <param name="version">The version.</param>
        /// <param name="outputDirectoryPath">The output directory path.</param>
        /// <param name="overwrite">If set to true, will overwrite existing project file.</param>
        public static void GenerateProject(RPGMakerVersion version, string outputDirectoryPath, bool overwrite)
        {
            string projectFileContent = null;
            string projectFileExtension = null;
            string iniFileContent = null;

            switch (version)
            {
                case RPGMakerVersion.Xp:
                    projectFileContent = Constants.RpgMakerXpProjectFileContent;
                    projectFileExtension = Constants.RpgMakerXpProjectFileExtension;
                    iniFileContent = Constants.RPGMakerXpIniFileContents;
                    break;
                case RPGMakerVersion.Vx:
                    projectFileContent = Constants.RpgMakerVxProjectFileContent;
                    projectFileExtension = Constants.RpgMakerVxProjectFileExtension;
                    iniFileContent = Constants.RPGMakerVxIniFileContents;
                    break;
                case RPGMakerVersion.VxAce:
                    projectFileContent = Constants.RpgMakerVxAceProjectFileContent;
                    projectFileExtension = Constants.RpgMakerVxAceProjectFileExtension;
                    iniFileContent = Constants.RPGMakerVxAceIniFileContents;
                    break;
            }

            var projectFilePath = Path.Combine(outputDirectoryPath, $"Game.{projectFileExtension}");
            var iniFilePath = Path.Combine(outputDirectoryPath, "Game.ini");

            if(overwrite)
            {
                File.WriteAllText(projectFilePath, projectFileContent);
            }

            if(overwrite)
            {
                File.WriteAllText(iniFilePath, iniFileContent);
            }
        }
    }
}

```

`RPGMakerDecrypter.RGSSAD/RGSSAD.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using RPGMakerDecrypter.RGSSAD.Exceptions;

namespace RPGMakerDecrypter.RGSSAD
{
    /// <summary>
    /// Represents RPG Maker RGSS Encrypted Archive.
    /// </summary>
    public class RGSSAD : IDisposable
    {
        protected readonly string FilePath;
        protected readonly BinaryReader BinaryReader;

        public List<ArchivedFile> ArchivedFiles { get; set; }

        protected RGSSAD(string filePath)
        {
            this.FilePath = filePath;
            BinaryReader = new BinaryReader(new FileStream(filePath, FileMode.Open));
        }

        /// <summary>
        /// Gets the version of RGSSAD.
        /// </summary>
        /// <param name="path">FilePath to RGSSAD archive</param>
        /// <returns></returns>
        /// <exception cref="InvalidArchiveException">
        /// Archive is in invalid format.
        /// or
        /// Header was not found for archive.
        /// </exception>
        protected int GetVersion()
        {
            string header;

            try
            {
                header = BinaryUtils.ReadCString(BinaryReader, 7);
            }
            catch (Exception)
            {
                throw new InvalidArchiveException("Archive is in invalid format.");
            }

            if (header != Constants.RGSSADHeader)
            {
                throw new InvalidArchiveException("Header was not found for archive.");
            }

            int result = BinaryReader.ReadByte();

            if (!Constants.SupportedRGSSVersions.Contains(result))
            {
                result =  -1;
            }

            BinaryReader.BaseStream.Seek(0, SeekOrigin.Begin);

            return result;
        }

        /// <summary>
        /// Extracts all files.
        /// </summary>
        /// <param name="outputDirectoryPath">Output directory path</param>
        /// <param name="overrideExisting">if set to true, overrides existing files</param>
        public void ExtractAllFiles(string outputDirectoryPath, bool overrideExisting = false)
        {
            foreach (var archivedFile in ArchivedFiles)
            {
                ExtractFile(archivedFile, outputDirectoryPath, overrideExisting);
            }
        }

        /// <summary>
        /// Extracts single file from the file.
        /// </summary>
        /// <param name="archivedFile">Archived file</param>
        /// <param name="outputDirectoryPath">Output directory path</param>
        /// <param name="overrideExisting">If set to true, overrides existing files</param>
        /// <param name="createDirectory">If set to true, creates directory specified in encrypted file name</param>
        /// <exception cref="System.Exception">Invalid file path. Archive could be corrupted.</exception>
        private void ExtractFile(ArchivedFile archivedFile, string outputDirectoryPath, bool overrideExisting = false, bool createDirectory = true)
        {
            var platformSpecificArchiveFilePath = ArchivedFileNameUtils.GetPlatformSpecificPath(archivedFile.Name);

            string outputPath;

            if (createDirectory)
            {
                var directoryPath = Path.GetDirectoryName(platformSpecificArchiveFilePath);

                if (directoryPath == null)
                {
                    throw new Exception("Invalid file path. Archive could be corrupted.");
                }

                if (!Directory.Exists(Path.Combine(outputDirectoryPath, directoryPath)))
                {
                    Directory.CreateDirectory(Path.Combine(outputDirectoryPath, directoryPath));
                }

                outputPath = Path.Combine(outputDirectoryPath, platformSpecificArchiveFilePath);
            }
            else
            {
                var fileName = Path.GetFileName(platformSpecificArchiveFilePath);
                outputPath = Path.Combine(outputDirectoryPath, fileName);
            }

            // Override existing file flag is set to true
            if (File.Exists(outputPath) && !overrideExisting)
            {
                return;
            }

            BinaryReader.BaseStream.Seek(archivedFile.Offset, SeekOrigin.Begin);
            var data = BinaryReader.ReadBytes(archivedFile.Size);

            var binaryWriter = new BinaryWriter(File.OpenWrite(outputPath));

            binaryWriter.Write(DecryptFileData(data, archivedFile.Key));

            binaryWriter.Close();
        }

        /// <summary>
        /// Decrypts the file from given bytes using given key.
        /// </summary>
        /// <param name="encryptedFileData">The encrypted file data.</param>
        /// <param name="key">The key.</param>
        /// <returns></returns>
        private byte[] DecryptFileData(byte[] encryptedFileData, uint key)
        {
            var decryptedFileData = new byte[encryptedFileData.Length];

            var tempKey = key;
            var keyBytes = BitConverter.GetBytes(key);
            var j = 0;

            for (var i = 0; i <= encryptedFileData.Length - 1; i++)
            {
                if (j == 4)
                {
                    j = 0;
                    tempKey *= 7;
                    tempKey += 3;
                    keyBytes = BitConverter.GetBytes(tempKey);
                }

                decryptedFileData[i] = (byte)(encryptedFileData[i] ^ keyBytes[j]);

                j += 1;
            }

            return decryptedFileData;
        }

        public void Dispose()
        {
            BinaryReader.Close();
            BinaryReader.Dispose();
        }

        /// <summary>
        /// Gets the RPG Maker version based on RGASSD file extension.
        /// </summary>
        /// <param name="inputPath">Path to RGSSAD file</param>
        public static RPGMakerVersion GetRPGMakerVersion(string inputPath)
        {
            if (!File.Exists(inputPath))
            {
                return RPGMakerVersion.Unknown;
            }
            
            var fi = new FileInfo(inputPath);

            if(fi.Extension.EndsWith(Constants.RpgMakerXpArchiveExtension))
            {
                return RPGMakerVersion.Xp;
            }

            if (fi.Extension.EndsWith(Constants.RpgMakerVxArchiveExtension))
            {
                return RPGMakerVersion.Vx;
            }

            if (fi.Extension.EndsWith(Constants.RpgMakerVxAceArchiveExtension))
            {
                return RPGMakerVersion.VxAce;
            }

            return RPGMakerVersion.Unknown;
        }
    }
}

```

`RPGMakerDecrypter.RGSSAD/RGSSADv1.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Text;
using RPGMakerDecrypter.RGSSAD.Exceptions;

namespace RPGMakerDecrypter.RGSSAD
{
    /// <summary>
    /// Represents RGSSAD format used in RPG Maker XP and VX.
    /// </summary>
    public class RGSSADv1 : RGSSAD
    {
        public RGSSADv1(string filePath) : base(filePath)
        {
            var version = GetVersion();

            if (version != Constants.RGASSDv1)
            {
                throw new InvalidArchiveException("Archive is in invalid format.");
            }

            ReadRGSSAD();
        }

        /// <summary>
        /// Reads the contents of RGSSAD archive and populates ArchivedFiles property.
        /// </summary>
        private void ReadRGSSAD()
        {
            var key = Constants.RGASSADv1Key;

            ArchivedFiles = new List<ArchivedFile>();

            BinaryReader.BaseStream.Seek(8, SeekOrigin.Begin);
            while (true)
            {
                var archivedFile = new ArchivedFile();

                var length = DecryptInteger(BinaryReader.ReadInt32(), ref key);
                archivedFile.Name = DecryptFilename(BinaryReader.ReadBytes(length), ref key);
                archivedFile.Size = DecryptInteger(BinaryReader.ReadInt32(), ref key);
                archivedFile.Offset = BinaryReader.BaseStream.Position;
                archivedFile.Key = key;
                ArchivedFiles.Add(archivedFile);

                BinaryReader.BaseStream.Seek(archivedFile.Size, SeekOrigin.Current);
                if (BinaryReader.BaseStream.Position == BinaryReader.BaseStream.Length)
                    break;
            }
        }
        /// <summary>
        /// Decrypts integer from given value.
        /// Proceeds key forward by calculating new value.
        /// </summary>
        /// <param name="value">Encrypted value</param>
        /// <param name="key">Key</param>
        /// <returns>Decrypted integer</returns>
        private int DecryptInteger(int value, ref uint key)
        {
            var result = value ^ key;

            key *= 7;
            key += 3;

            return (int)result;
        }

        /// <summary>
        /// Decrypts file name from given bytes using given key.
        /// Proceeds key forward by calculating new value.
        /// </summary>
        /// <param name="encryptedName">Encrypted filename</param>
        /// <param name="key">Key</param>
        /// <returns>Decrypted filename</returns>
        private string DecryptFilename(byte[] encryptedName, ref uint key)
        {
            var decryptedName = new byte[encryptedName.Length];

            for (var i = 0; i <= encryptedName.Length - 1; i++)
            {
                decryptedName[i] = (byte)(encryptedName[i] ^ (key & 0xff));

                key *= 7;
                key += 3;
            }

            var result = Encoding.UTF8.GetString(decryptedName);

            return result;
        }
    }
}

```

`RPGMakerDecrypter.RGSSAD/RGSSADv3.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using RPGMakerDecrypter.RGSSAD.Exceptions;

namespace RPGMakerDecrypter.RGSSAD
{
    /// <summary>
    /// Represents RGSSAD format used in RPG Maker VX Ace.
    /// </summary>
    public class RGSSADv3 : RGSSAD
    {
        public RGSSADv3(string filePath) : base(filePath)
        {
            var version = GetVersion();

            if (version != Constants.RGASSDv3)
            {
                throw new InvalidArchiveException("Archive is in invalid format.");
            }

            ReadRGSSAD();
        }

        /// <summary>
        /// Reads the contents of RGSSAD archive and populates ArchivedFiles property.
        /// </summary>
        private void ReadRGSSAD()
        {
            BinaryReader.BaseStream.Seek(8, SeekOrigin.Begin);

            var key = (uint)BinaryReader.ReadInt32();
            key *= 9;
            key += 3;

            ArchivedFiles = new List<ArchivedFile>();

            while (true)
            {
                var archivedFile = new ArchivedFile();
                archivedFile.Offset = DecryptInteger(BinaryReader.ReadInt32(), key);
                archivedFile.Size = DecryptInteger(BinaryReader.ReadInt32(), key);
                archivedFile.Key = (uint)DecryptInteger(BinaryReader.ReadInt32(), key);

                var length = DecryptInteger(BinaryReader.ReadInt32(), key);

                if (archivedFile.Offset == 0)
                {
                    break;
                }

                archivedFile.Name = DecryptFilename(BinaryReader.ReadBytes(length), key);

                ArchivedFiles.Add(archivedFile);
            }
        }

        /// <summary>
        /// Decrypts integer from given value.
        /// </summary>
        /// <param name="value">Encrypted value</param>
        /// <param name="key">Key</param>
        /// <returns>Decrypted integer</returns>
        private int DecryptInteger(int value, uint key)
        {
            var result = value ^ key;
            return (int)result;
        }

        /// <summary>
        /// Decrypts file name from given bytes using given key.
        /// </summary>
        /// <param name="encryptedName">Encrypted filename</param>
        /// <param name="key">Key</param>
        /// <returns>Decrypted filename</returns>
        private string DecryptFilename(byte[] encryptedName, uint key)
        {
            var decryptedName = new byte[encryptedName.Length];

            var keyBytes = BitConverter.GetBytes(key);

            var j = 0;
            for (var i = 0; i <= encryptedName.Length - 1; i++)
            {
                if (j == 4)
                    j = 0;
                decryptedName[i] = (byte)(encryptedName[i] ^ keyBytes[j]);
                j += 1;
            }

            var result = Encoding.UTF8.GetString(decryptedName);

            return result;
        }
    }
}

```

`RPGMakerDecrypter.RGSSAD/RPGMakerDecrypter.RGSSAD.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>netstandard2.0</TargetFramework>
		<RootNamespace>RPGMakerDecrypter.RGSSAD</RootNamespace>
	</PropertyGroup>

	<PropertyGroup>
		<Title>RPG Maker Decrypter</Title>
		<AssemblyTitle>RPG Maker Decrypter</AssemblyTitle>
		<Description>Tool for decrypting RPG Maker XP, VX and VX Ace RGSSAD archives.</Description>
		<Copyright>Mikko Uuksulainen © 2015-2023</Copyright>
		<PackageProjectUrl>https://github.com/uuksu/RPGMakerDecrypter</PackageProjectUrl>
		<Version>2.0.0</Version>
	</PropertyGroup>

	<ItemGroup>
	  <ProjectReference Include="..\RPGMakerDecrypter.Common\RPGMakerDecrypter.Common.csproj" />
	</ItemGroup>

</Project>

```

`RPGMakerDecrypter.Tests/BinaryUtilsTests.cs`:

```cs
using System;
using System.IO;
using System.Security.AccessControl;
using NUnit;
using NUnit.Framework;
using RPGMakerDecrypter.RGSSAD;

namespace RPGMakerDecrypter.Tests
{
    public class BinaryUtilsTests
    {
        [Test]
        public void RPGMakerXpArchiveVersionIsOne()
        {
            FileHelpers.CopyArchives();

            using (var binaryReader = new BinaryReader(new FileStream(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerXpArchiveName), FileMode.Open)))
            {
                var s = BinaryUtils.ReadCString(binaryReader, 7);
                var version = binaryReader.ReadByte();

                Assert.That(version, Is.EqualTo(1));
            }

            FileHelpers.CleanupArchives();
        }

        [Test]
        public void RPGMakerVxArchiveVersionIsOne()
        {
            FileHelpers.CopyArchives();

            using (var binaryReader = new BinaryReader(new FileStream(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerVxArchiveName), FileMode.Open)))
            {
                var s = BinaryUtils.ReadCString(binaryReader, 7);
                var version = binaryReader.ReadByte();

                Assert.That(version, Is.EqualTo(1));
            }

            FileHelpers.CleanupArchives();
        }

        [Test]
        public void RPGMakerVxAceArchiveVersionIsThree()
        {
            FileHelpers.CopyArchives();

            using (var binaryReader = new BinaryReader(new FileStream(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerVxAceArchiveName), FileMode.Open)))
            {
                var s = BinaryUtils.ReadCString(binaryReader, 7);
                var version = binaryReader.ReadByte();

                Assert.That(version, Is.EqualTo(3));
            }

            FileHelpers.CleanupArchives();
        }

        [Test]
        public void ReadCStringReturnsCorrectHeaderForArchives()
        {
            FileHelpers.CopyArchives();

            using (var binaryReader = new BinaryReader(new FileStream(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerXpArchiveName), FileMode.Open)))
            {
                var s = BinaryUtils.ReadCString(binaryReader, 7);
                Assert.That(s, Is.EqualTo(Constants.RGSSADHeader));
            }

            using (var binaryReader = new BinaryReader(new FileStream(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerVxArchiveName), FileMode.Open)))
            {
                var s = BinaryUtils.ReadCString(binaryReader, 7);
                Assert.That(s, Is.EqualTo(Constants.RGSSADHeader));
            }

            using (var binaryReader = new BinaryReader(new FileStream(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerVxAceArchiveName), FileMode.Open)))
            {
                var s = BinaryUtils.ReadCString(binaryReader, 7);
                Assert.That(s, Is.EqualTo(Constants.RGSSADHeader));
            }

            FileHelpers.CleanupArchives();
        }


    }
}
```

`RPGMakerDecrypter.Tests/FileDecrypterTests.cs`:

```cs
using System.Security.Cryptography;
using NUnit.Framework;
using RPGMakerDecrypter.MVMZ;

namespace RPGMakerDecrypter.Tests;

public class FileDecrypterTests
{
    [Test]
    public void FilesDecryptsCorrectly()
    {
        FileHelpers.CopyEncryptedFiles();

        // Bytes of "12345" hashed to "827ccb0eea8a706c4c34a16891f84e7b"
        byte[] key =
        [
            130, 124, 203, 14, 234, 138, 112, 108, 76, 52, 161, 104, 145, 248, 78, 123
        ];
        
        var fileDecryptor = new FileDecrypter();
        
        var imageBytes = fileDecryptor.Decrypt(key, Path.Combine(FileHelpers.TempDirectoryPath, "Image"));
        var audioOrbisBytes = fileDecryptor.Decrypt(key, Path.Combine(FileHelpers.TempDirectoryPath, "AudioOrbis"));
        var audioMpegBytes = fileDecryptor.Decrypt(key, Path.Combine(FileHelpers.TempDirectoryPath, "AudioMpeg"));
        
        var imageSha1 = Convert.ToHexString(SHA1.HashData(imageBytes)).ToLower();
        var audioOrbisSha1 = Convert.ToHexString(SHA1.HashData(audioOrbisBytes)).ToLower();
        var audioMpegSha1 = Convert.ToHexString(SHA1.HashData(audioMpegBytes)).ToLower();
        
        Assert.That(imageSha1 == "1d47f411bf4f6df654398faeae8f944f954258bf", Is.True);
        Assert.That(audioOrbisSha1 == "90d87198849f7bdfdd4eacd611de3a2540925813", Is.True);
        Assert.That(audioMpegSha1 == "f59b4b2f293d1964d85bc1a2e96e345ba22996b4", Is.True);
        
        FileHelpers.CleanupEncryptedFiles();
    }
}
```

`RPGMakerDecrypter.Tests/FileHelpers.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using RPGMakerDecrypter.RGSSAD;

namespace RPGMakerDecrypter.Tests
{
    static class FileHelpers
    {
        public static string TempDirectoryPath = "Temp";

        public static void CopyArchives()
        {
            if (Directory.Exists(TempDirectoryPath))
            {
                Directory.Delete(TempDirectoryPath, true);
            }

            Directory.CreateDirectory(TempDirectoryPath);

            File.Copy(Path.Combine("EncryptedArchives", Constants.RpgMakerXpArchiveName), Path.Combine(TempDirectoryPath, Constants.RpgMakerXpArchiveName));
            File.Copy(Path.Combine("EncryptedArchives", Constants.RpgMakerVxArchiveName), Path.Combine(TempDirectoryPath, Constants.RpgMakerVxArchiveName));
            File.Copy(Path.Combine("EncryptedArchives", Constants.RpgMakerVxAceArchiveName), Path.Combine(TempDirectoryPath, Constants.RpgMakerVxAceArchiveName));
        }

        public static void CopyEncryptedFiles()
        {
            if (Directory.Exists(TempDirectoryPath))
            {
                Directory.Delete(TempDirectoryPath, true);
            }

            Directory.CreateDirectory(TempDirectoryPath);
            
            File.Copy(Path.Combine("EncryptedFiles", "Image"), Path.Combine(TempDirectoryPath, "Image"));
            File.Copy(Path.Combine("EncryptedFiles", "AudioOrbis"), Path.Combine(TempDirectoryPath, "AudioOrbis"));
            File.Copy(Path.Combine("EncryptedFiles", "AudioMpeg"), Path.Combine(TempDirectoryPath, "AudioMpeg"));
        }

        public static void CleanupArchives()
        {
            File.Delete(Path.Combine(TempDirectoryPath, Constants.RpgMakerXpArchiveName));
            File.Delete(Path.Combine(TempDirectoryPath, Constants.RpgMakerVxArchiveName));
            File.Delete(Path.Combine(TempDirectoryPath, Constants.RpgMakerVxAceArchiveName));

            Directory.Delete(TempDirectoryPath);
        }
        
        public static void CleanupEncryptedFiles()
        {
            File.Delete(Path.Combine(TempDirectoryPath, "Image"));
            File.Delete(Path.Combine(TempDirectoryPath, "AudioOrbis"));
            File.Delete(Path.Combine(TempDirectoryPath, "AudioMpeg"));

            Directory.Delete(TempDirectoryPath);
        }
    }
}

```

`RPGMakerDecrypter.Tests/RGSSADv1Tests.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using NUnit.Framework;
using RPGMakerDecrypter.RGSSAD;

namespace RPGMakerDecrypter.Tests
{
    public class RGSSADv1Tests
    {
        [Test]
        public void CorrectAmountOfArchivedFilesIsReadFromXpArchive()
        {
            FileHelpers.CopyArchives();

            var rgssad = new RGSSADv1(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerXpArchiveName));

            Assert.That(rgssad.ArchivedFiles.Count, Is.EqualTo(16));

            rgssad.Dispose();

            FileHelpers.CleanupArchives();
        }

        [Test]
        public void CorrectFileNamesAreReadFromXpArchive()
        {
            FileHelpers.CopyArchives();

            var rgssad = new RGSSADv1(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerXpArchiveName));

            // Verified with Falos RPG Maker Decrypter
            Assert.That(rgssad.ArchivedFiles[0].Name, Is.EqualTo(@"Data\Actors.rxdata"));
            Assert.That(rgssad.ArchivedFiles[1].Name, Is.EqualTo(@"Data\Animations.rxdata"));
            Assert.That(rgssad.ArchivedFiles[2].Name, Is.EqualTo(@"Data\Armors.rxdata"));

            rgssad.Dispose();

            FileHelpers.CleanupArchives();
        }

        [Test]
        public void CorrectOffsetsAreReadFromXpArchive()
        {
            FileHelpers.CopyArchives();

            var rgssad = new RGSSADv1(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerXpArchiveName));

            // Verified with Falos RPG Maker Decrypter
            Assert.That(rgssad.ArchivedFiles[0].Offset, Is.EqualTo(34));
            Assert.That(rgssad.ArchivedFiles[1].Offset, Is.EqualTo(11045));
            Assert.That(rgssad.ArchivedFiles[2].Offset, Is.EqualTo(147314));

            rgssad.Dispose();

            FileHelpers.CleanupArchives();
        }

        [Test]
        public void CorrectSizesAreReadFromXpArchive()
        {
            FileHelpers.CopyArchives();

            var rgssad = new RGSSADv1(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerXpArchiveName));

            // Verified with Falos RPG Maker Decrypter
            Assert.That(rgssad.ArchivedFiles[0].Size, Is.EqualTo(10981));
            Assert.That(rgssad.ArchivedFiles[1].Size, Is.EqualTo(136243));
            Assert.That(rgssad.ArchivedFiles[2].Size, Is.EqualTo(4285));

            rgssad.Dispose();

            FileHelpers.CleanupArchives();
        }

        [Test]
        public void CorrectKeysAreReadFromXpArchive()
        {
            FileHelpers.CopyArchives();

            var rgssad = new RGSSADv1(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerXpArchiveName));

            // Verified with Falos RPG Maker Decrypter
            Assert.That(rgssad.ArchivedFiles[0].Key, Is.EqualTo((uint)0x7B7448AE));
            Assert.That(rgssad.ArchivedFiles[1].Key, Is.EqualTo((uint)0x366D564E));
            Assert.That(rgssad.ArchivedFiles[2].Key, Is.EqualTo((uint)0x222699FE));

            rgssad.Dispose();

            FileHelpers.CleanupArchives();
        }

        [Test]
        public void CorrectFileNamesAreReadFromVxArchive()
        {
            FileHelpers.CopyArchives();

            var rgssad = new RGSSADv1(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerVxArchiveName));

            // Verified with Falos RPG Maker Decrypter
            Assert.That(rgssad.ArchivedFiles[0].Name, Is.EqualTo(@"Data\Actors.rvdata"));
            Assert.That(rgssad.ArchivedFiles[1].Name, Is.EqualTo(@"Data\Animations.rvdata"));
            Assert.That(rgssad.ArchivedFiles[2].Name, Is.EqualTo(@"Data\Areas.rvdata"));

            rgssad.Dispose();

            FileHelpers.CleanupArchives();
        }

        [Test]
        public void CorrectOffsetsAreReadFromVxArchive()
        {
            FileHelpers.CopyArchives();

            var rgssad = new RGSSADv1(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerVxArchiveName));

            // Verified with Falos RPG Maker Decrypter
            Assert.That(rgssad.ArchivedFiles[0].Offset, Is.EqualTo(34));
            Assert.That(rgssad.ArchivedFiles[1].Offset, Is.EqualTo(10951));
            Assert.That(rgssad.ArchivedFiles[2].Offset, Is.EqualTo(139280));

            rgssad.Dispose();

            FileHelpers.CleanupArchives();
        }

        [Test]
        public void CorrectSizesAreReadFromVxArchive()
        {
            FileHelpers.CopyArchives();

            var rgssad = new RGSSADv1(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerVxArchiveName));

            // Verified with Falos RPG Maker Decrypter
            Assert.That(rgssad.ArchivedFiles[0].Size, Is.EqualTo(10887));
            Assert.That(rgssad.ArchivedFiles[1].Size, Is.EqualTo(128304));
            Assert.That(rgssad.ArchivedFiles[2].Size, Is.EqualTo(4));

            rgssad.Dispose();

            FileHelpers.CleanupArchives();
        }

        [Test]
        public void CorrectKeysAreReadFromVxArchive()
        {
            FileHelpers.CopyArchives();

            var rgssad = new RGSSADv1(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerVxArchiveName));

            // Verified with Falos RPG Maker Decrypter
            Assert.That(rgssad.ArchivedFiles[0].Key, Is.EqualTo((uint)0x7B7448AE));
            Assert.That(rgssad.ArchivedFiles[1].Key, Is.EqualTo((uint)0x366D564E));
            Assert.That(rgssad.ArchivedFiles[2].Key, Is.EqualTo((uint)0x04E0F16D));

            rgssad.Dispose();

            FileHelpers.CleanupArchives();
        }


    }
}

```

`RPGMakerDecrypter.Tests/RGSSADv3Tests.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using NUnit.Framework;
using RPGMakerDecrypter.RGSSAD;

namespace RPGMakerDecrypter.Tests
{
    public class RGSSADv3Tests
    {
        [Test]
        public void CorrectAmountOfArchivedFilesIsReadFromVxAceArchive()
        {
            FileHelpers.CopyArchives();

            var rgssad = new RGSSADv3(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerVxAceArchiveName));

            Assert.That(rgssad.ArchivedFiles.Count, Is.EqualTo(16));

            rgssad.Dispose();

            FileHelpers.CleanupArchives();
        }

        [Test]
        public void CorrectFileNamesAreReadFromVxAceArchive()
        {
            FileHelpers.CopyArchives();

            var rgssad = new RGSSADv3(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerVxAceArchiveName));

            // Verified with Falos RPG Maker Decrypter
            Assert.That(rgssad.ArchivedFiles[0].Name, Is.EqualTo(@"Data\Actors.rvdata2"));
            Assert.That(rgssad.ArchivedFiles[1].Name, Is.EqualTo(@"Data\Animations.rvdata2"));
            Assert.That(rgssad.ArchivedFiles[2].Name, Is.EqualTo(@"Data\Armors.rvdata2"));

            rgssad.Dispose();

            FileHelpers.CleanupArchives();
        }

        [Test]
        public void CorrectOffsetsAreReadFromVxAceArchive()
        {
            FileHelpers.CopyArchives();

            var rgssad = new RGSSADv3(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerVxAceArchiveName));

            // Verified with Falos RPG Maker Decrypter
            Assert.That(rgssad.ArchivedFiles[0].Offset, Is.EqualTo(605));
            Assert.That(rgssad.ArchivedFiles[1].Offset, Is.EqualTo(3637));
            Assert.That(rgssad.ArchivedFiles[2].Offset, Is.EqualTo(222096));

            rgssad.Dispose();

            FileHelpers.CleanupArchives();
        }

        [Test]
        public void CorrectSizesAreReadFromVxAceArchive()
        {
            FileHelpers.CopyArchives();

            var rgssad = new RGSSADv3(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerVxAceArchiveName));

            // Verified with Falos RPG Maker Decrypter
            Assert.That(rgssad.ArchivedFiles[0].Size, Is.EqualTo(3032));
            Assert.That(rgssad.ArchivedFiles[1].Size, Is.EqualTo(218459));
            Assert.That(rgssad.ArchivedFiles[2].Size, Is.EqualTo(11472));

            rgssad.Dispose();

            FileHelpers.CleanupArchives();
        }

        [Test]
        public void CorrectKeysAreReadFromVxAceArchive()
        {
            FileHelpers.CopyArchives();

            var rgssad = new RGSSADv3(Path.Combine(FileHelpers.TempDirectoryPath, Constants.RpgMakerVxAceArchiveName));

            // Verified with Falos RPG Maker Decrypter
            Assert.That(rgssad.ArchivedFiles[0].Key, Is.EqualTo((uint)0x00000029));
            Assert.That(rgssad.ArchivedFiles[1].Key, Is.EqualTo((uint)0x00004823));
            Assert.That(rgssad.ArchivedFiles[2].Key, Is.EqualTo((uint)0x000018BE));

            rgssad.Dispose();

            FileHelpers.CleanupArchives();
        }
    }
}

```

`RPGMakerDecrypter.Tests/RPGMakerDecrypter.Tests.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>net8.0</TargetFramework>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>

		<IsPackable>false</IsPackable>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.1.0" />
		<PackageReference Include="NUnit" Version="3.13.3" />
		<PackageReference Include="NUnit3TestAdapter" Version="4.2.1" />
		<PackageReference Include="NUnit.Analyzers" Version="3.3.0" />
		<PackageReference Include="coverlet.collector" Version="3.1.2" />
	</ItemGroup>

	<ItemGroup>
	  <ProjectReference Include="..\RPGMakerDecrypter.MVMZ\RPGMakerDecrypter.MVMZ.csproj" />
	  <ProjectReference Include="..\RPGMakerDecrypter.RGSSAD\RPGMakerDecrypter.RGSSAD.csproj" />
	</ItemGroup>

	<ItemGroup>
	  <Folder Include="Properties\" />
	</ItemGroup>

	<ItemGroup>
	  <None Update="EncryptedArchives\Game.rgss2a">
	    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
	  </None>
	  <None Update="EncryptedArchives\Game.rgss3a">
	    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
	  </None>
	  <None Update="EncryptedArchives\Game.rgssad">
	    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
	  </None>
	  <None Update="EncryptedFiles\Image">
	    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
	  </None>
	  <None Update="EncryptedFiles\AudioOrbis">
	    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
	  </None>
	  <None Update="EncryptedFiles\AudioMpeg">
	    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
	  </None>
	</ItemGroup>

</Project>

```

`RPGMakerDecrypter.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32901.215
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "RPGMakerDecrypter.RGSSAD", "RPGMakerDecrypter.RGSSAD\RPGMakerDecrypter.RGSSAD.csproj", "{BAEEE442-1888-4340-94BE-FE743C696AE1}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "RPGMakerDecrypter.Tests", "RPGMakerDecrypter.Tests\RPGMakerDecrypter.Tests.csproj", "{CDFB3E01-DE4D-4FC2-8369-21D9F70595C2}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "RPGMakerDecrypter.Cli", "RPGMakerDecrypter.Cli\RPGMakerDecrypter.Cli.csproj", "{D03BC34B-EEB1-4A26-B4FB-190CE153E06A}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Resources", "Resources", "{48D60675-A06B-4683-99A2-F44188D93693}"
	ProjectSection(SolutionItems) = preProject
		Resources\icon_256x256.pdn = Resources\icon_256x256.pdn
	EndProjectSection
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "RPGMakerDecrypter.Common", "RPGMakerDecrypter.Common\RPGMakerDecrypter.Common.csproj", "{41DB3BF6-A576-4D78-8E77-89A906C9A49A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "RPGMakerDecrypter.MVMZ", "RPGMakerDecrypter.MVMZ\RPGMakerDecrypter.MVMZ.csproj", "{9AE7DB4F-7F8F-4A25-B680-6BE6AF385286}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{BAEEE442-1888-4340-94BE-FE743C696AE1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BAEEE442-1888-4340-94BE-FE743C696AE1}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BAEEE442-1888-4340-94BE-FE743C696AE1}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BAEEE442-1888-4340-94BE-FE743C696AE1}.Release|Any CPU.Build.0 = Release|Any CPU
		{CDFB3E01-DE4D-4FC2-8369-21D9F70595C2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CDFB3E01-DE4D-4FC2-8369-21D9F70595C2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CDFB3E01-DE4D-4FC2-8369-21D9F70595C2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CDFB3E01-DE4D-4FC2-8369-21D9F70595C2}.Release|Any CPU.Build.0 = Release|Any CPU
		{D03BC34B-EEB1-4A26-B4FB-190CE153E06A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D03BC34B-EEB1-4A26-B4FB-190CE153E06A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D03BC34B-EEB1-4A26-B4FB-190CE153E06A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D03BC34B-EEB1-4A26-B4FB-190CE153E06A}.Release|Any CPU.Build.0 = Release|Any CPU
		{41DB3BF6-A576-4D78-8E77-89A906C9A49A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{41DB3BF6-A576-4D78-8E77-89A906C9A49A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{41DB3BF6-A576-4D78-8E77-89A906C9A49A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{41DB3BF6-A576-4D78-8E77-89A906C9A49A}.Release|Any CPU.Build.0 = Release|Any CPU
		{9AE7DB4F-7F8F-4A25-B680-6BE6AF385286}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9AE7DB4F-7F8F-4A25-B680-6BE6AF385286}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9AE7DB4F-7F8F-4A25-B680-6BE6AF385286}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9AE7DB4F-7F8F-4A25-B680-6BE6AF385286}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {2B50EE10-517D-4BAE-A617-97CAD2922589}
	EndGlobalSection
EndGlobal

```