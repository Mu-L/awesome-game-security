Project Path: arc_EvilBytecode_GhostVEH_j_e4cs78

Source Tree:

```txt
arc_EvilBytecode_GhostVEH_j_e4cs78
‚îú‚îÄ‚îÄ GhostVEH
‚îÇ   ‚îú‚îÄ‚îÄ GhostVEH.cpp
‚îÇ   ‚îú‚îÄ‚îÄ GhostVEH.vcxproj
‚îÇ   ‚îú‚îÄ‚îÄ GhostVEH.vcxproj.filters
‚îÇ   ‚îî‚îÄ‚îÄ GhostVEH.vcxproj.user
‚îú‚îÄ‚îÄ GhostVEH.sln
‚îú‚îÄ‚îÄ LICENSE
‚îî‚îÄ‚îÄ README.md

```

`GhostVEH.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36203.30 d17.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GhostVEH", "GhostVEH\GhostVEH.vcxproj", "{373D098F-4DD2-4F8F-B7F5-09649F7EC606}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{373D098F-4DD2-4F8F-B7F5-09649F7EC606}.Debug|x64.ActiveCfg = Debug|x64
		{373D098F-4DD2-4F8F-B7F5-09649F7EC606}.Debug|x64.Build.0 = Debug|x64
		{373D098F-4DD2-4F8F-B7F5-09649F7EC606}.Debug|x86.ActiveCfg = Debug|Win32
		{373D098F-4DD2-4F8F-B7F5-09649F7EC606}.Debug|x86.Build.0 = Debug|Win32
		{373D098F-4DD2-4F8F-B7F5-09649F7EC606}.Release|x64.ActiveCfg = Release|x64
		{373D098F-4DD2-4F8F-B7F5-09649F7EC606}.Release|x64.Build.0 = Release|x64
		{373D098F-4DD2-4F8F-B7F5-09649F7EC606}.Release|x86.ActiveCfg = Release|Win32
		{373D098F-4DD2-4F8F-B7F5-09649F7EC606}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {37764DF8-783A-4769-B0DE-9128B73E9263}
	EndGlobalSection
EndGlobal

```

`GhostVEH/GhostVEH.cpp`:

```cpp
#include <windows.h>

typedef struct _VEH_ENTRY
{
    LIST_ENTRY list;
    ULONG_PTR* refcnt;
    DWORD unk;
    DWORD pad;
    PVOID enc_handler;
} VEH_ENTRY, * PVEH_ENTRY;

typedef PVOID(WINAPI* fnRtlEncodePointer)(PVOID);
typedef PVOID(WINAPI* fnRtlDecodePointer)(PVOID);
typedef VOID(*fnLdrProtectMrdata)(BOOL);

static ULONG_PTR g_list = 0;
static ULONG_PTR g_rtlp = 0;
static ULONG_PTR g_prot = 0;

__forceinline BOOL chk
(
    PVOID p,
    SIZE_T sz
)
{
    __try
    {
        volatile char c = *(char*)p;
        if (sz > 1) c = *((char*)p + sz - 1);
        return 1;
    }
    __except (1)
    {
        return 0;
    }
}

VOID dbg
(
    const CHAR* s
)
{
    HANDLE h;
    DWORD w;

    h = GetStdHandle(STD_OUTPUT_HANDLE);
    WriteConsoleA(h, s, lstrlenA(s), &w, 0);
}

BOOL find_prot
(
    VOID
)
{
    BYTE* code;
    int i, rel;
    ULONG_PTR tgt;
    BYTE* fn;

    if (!g_rtlp) return 0;

    dbg("[*]  scanning for LdrProtectMrdata...\n");

    code = (BYTE*)g_rtlp;

    for (i = 0; i < 0x400; i++)
    {
        if (!chk(&code[i], 5)) continue;
        if (code[i] != 0xE8) continue;
        if (!chk(&code[i + 1], 4)) continue;

        rel = *(int*)&code[i + 1];
        tgt = (ULONG_PTR)(&code[i + 5]) + rel;

        if (tgt < 0x10000 || tgt > 0x7FFFFFFFFFFF) continue;
        if (!chk((PVOID)tgt, 15)) continue;

        fn = (BYTE*)tgt;

        if (fn[0] == 0x48 && fn[1] == 0x89 && fn[2] == 0x5C && fn[3] == 0x24 && fn[4] == 0x08 &&
            fn[5] == 0x48 && fn[6] == 0x89 && fn[7] == 0x74 && fn[8] == 0x24 && fn[9] == 0x10 &&
            fn[10] == 0x57 && fn[11] == 0x48 && fn[12] == 0x83 && fn[13] == 0xEC && fn[14] == 0x20)
        {
            g_prot = tgt;
            dbg("[+]  found!\n");
            return 1;
        }
    }

    dbg("[-]  not found\n");
    return 0;
}

BOOL find_list
(
    VOID
)
{
    HMODULE ntdll;
    ULONG_PTR rtladd;
    BYTE* code;
    int rel;
    ULONG_PTR rtlp;
    BYTE* fn;
    int i, rel2;
    ULONG_PTR tgt;

    dbg("\n===  GhostVEH  ===\n\n");

    ntdll = GetModuleHandleA("ntdll");
    if (!ntdll) goto fail;

    rtladd = (ULONG_PTR)GetProcAddress(ntdll, "RtlAddVectoredExceptionHandler");
    if (!rtladd) goto fail;

    dbg("[*]  locating internals...\n");

    code = (BYTE*)rtladd;

    if (code[0] != 0x41 && code[0] != 0x45) goto fail;
    if (code[3] != 0xE9) goto fail;

    rel = *(int*)&code[4];
    rtlp = (ULONG_PTR)(&code[8]) + rel;

    g_rtlp = rtlp;

    dbg("[+]  RtlpAddVectoredHandler\n");

    fn = (BYTE*)rtlp;

    for (i = 0; i < 0x400; i++)
    {
        if (fn[i] != 0x48 || fn[i + 1] != 0x8D || fn[i + 2] != 0x3D) continue;

        rel2 = *(int*)&fn[i + 3];
        tgt = (ULONG_PTR)(&fn[i + 7]) + rel2;

        if (fn[i + 7] == 0x48 && fn[i + 8] == 0x8D && fn[i + 9] == 0x7F && fn[i + 10] == 0x08)
        {
            g_list = tgt;
            dbg("[+]  LdrpVectorHandlerList\n");
            if (!find_prot()) goto fail;
            dbg("\n");
            return 1;
        }
    }

fail:
    dbg("[-]  failed to locate\n");
    return 0;
}

LONG CALLBACK veh_handler
(
    EXCEPTION_POINTERS* ep
)
{
    dbg("[!]  stealth veh triggered\n");
    return EXCEPTION_CONTINUE_SEARCH;
}

BOOL add_veh
(
    PVECTORED_EXCEPTION_HANDLER h,
    BOOL first
)
{
    HMODULE ntdll;
    fnRtlEncodePointer enc;
    fnLdrProtectMrdata prot;
    PVEH_ENTRY ent;
    PVOID* base;
    PSRWLOCK lock;
    PLIST_ENTRY head;

    if (!g_list || !g_prot) return 0;

    dbg("[*]  installing GhostVEH...\n");

    ntdll = GetModuleHandleA("ntdll");
    enc = (fnRtlEncodePointer)GetProcAddress(ntdll, "RtlEncodePointer");
    if (!enc) return 0;

    prot = (fnLdrProtectMrdata)g_prot;

    ent = (PVEH_ENTRY)HeapAlloc(GetProcessHeap(), 8, sizeof(VEH_ENTRY));
    if (!ent) return 0;

    ent->refcnt = (ULONG_PTR*)HeapAlloc(GetProcessHeap(), 8, sizeof(ULONG_PTR));
    if (!ent->refcnt)
    {
        HeapFree(GetProcessHeap(), 0, ent);
        return 0;
    }

    *ent->refcnt = 1;
    ent->unk = 0;
    ent->pad = 0;
    ent->enc_handler = enc(h);

    base = (PVOID*)g_list;
    lock = (PSRWLOCK)&base[0];
    head = (PLIST_ENTRY)&base[1];

    if (!head->Flink || !head->Blink) goto cleanup;

    dbg("    unlocking .mrdata\n");
    prot(0);
    AcquireSRWLockExclusive(lock);

    if (first)
    {
        ent->list.Flink = head->Flink;
        ent->list.Blink = head;
        head->Flink->Blink = &ent->list;
        head->Flink = &ent->list;
    }
    else
    {
        ent->list.Flink = head;
        ent->list.Blink = head->Blink;
        head->Blink->Flink = &ent->list;
        head->Blink = &ent->list;
    }

    ReleaseSRWLockExclusive(lock);
    dbg("    locking .mrdata\n");
    prot(1);

    dbg("[+]  handler installed\n\n");
    return 1;

cleanup:
    HeapFree(GetProcessHeap(), 0, ent->refcnt);
    HeapFree(GetProcessHeap(), 0, ent);
    return 0;
}

VOID enum_veh
(
    VOID
)
{
    HMODULE ntdll;
    fnRtlDecodePointer dec;
    PVOID* base;
    PLIST_ENTRY head;
    PLIST_ENTRY cur;
    int idx;
    PVEH_ENTRY ent;
    PVOID decoded;
    CHAR buf[64];

    if (!g_list) return;

    ntdll = GetModuleHandleA("ntdll");
    dec = (fnRtlDecodePointer)GetProcAddress(ntdll, "RtlDecodePointer");

    base = (PVOID*)g_list;
    head = (PLIST_ENTRY)&base[1];

    dbg("---  veh chain  ---\n");

    if (head->Flink == head)
    {
        dbg("    empty\n");
        dbg("---  end  ---\n\n");
        return;
    }

    cur = head->Flink;
    idx = 0;

    while (cur != head && idx < 100)
    {
        if ((ULONG_PTR)cur < 0x10000) break;

        ent = CONTAINING_RECORD(cur, VEH_ENTRY, list);

        if (dec && ent->enc_handler)
        {
            decoded = dec(ent->enc_handler);
            wsprintfA(buf, "    [%d]  handler @ %p\n", idx, decoded);
            dbg(buf);
        }

        cur = cur->Flink;
        idx++;
    }

    dbg("---  end  ---\n\n");
}

LONG CALLBACK normal_veh
(
    EXCEPTION_POINTERS* p
)
{
    dbg("[!]  normal veh triggered\n");
    return EXCEPTION_CONTINUE_SEARCH;
}

int main
(
    VOID
)
{
    int x, y;

    if (!find_list()) return 1;

    enum_veh();

    dbg("[*]  adding normal veh via api...\n");
    AddVectoredExceptionHandler(1, normal_veh);
    dbg("[+]  normal veh added\n\n");

    enum_veh();

    if (add_veh(veh_handler, 1))
    {
        enum_veh();

        dbg("[*]  triggering exception...\n");
        __try
        {
            x = 0;
            y = 5 / x;
            (void)y;
        }
        __except (1)
        {
            dbg("[+]  exception handled\n");
        }
    }

    dbg("\n");
    Sleep(2000);
    return 0;
}
```

`GhostVEH/GhostVEH.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{373d098f-4dd2-4f8f-b7f5-09649f7ec606}</ProjectGuid>
    <RootNamespace>GhostVEH</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="GhostVEH.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`GhostVEH/GhostVEH.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="GhostVEH.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`GhostVEH/GhostVEH.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`LICENSE`:

```
MIT License

Copyright (c) 2026 EvilBytecode

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# GhostVEH üëª

Registers Vectored Exception Handlers by directly manipulating ntdll's internal `LdrpVectorHandlerList` structure instead of calling `RtlAddVectoredExceptionHandler`. 

**Tested on:** Windows 11 25H2 (Build 26200.7623)
- ToDo: Add BoyerMoore search / AOB - use zydis/capstone to disassm at runtime instead of hardcoding.
- For Sig look into: https://github.com/C5Hackr/WinDumper
## What Is This?

Instead of calling `RtlAddVectoredExceptionHandler` like a normal person, we locate the internal handler list in ntdll and insert our handler directly.

```
Normal:  Your Code ‚Üí RtlAddVectoredExceptionHandler ‚Üí RtlpAddVectoredHandler ‚Üí List
This:    Your Code ‚Üí Manual List Insert ‚Üí List
```

## Execution Flow

### Step 1: Locate RtlpAddVectoredHandler

```asm
RtlAddVectoredExceptionHandler:
    xor r8d, r8d
    jmp RtlpAddVectoredHandler
```

Pattern match the `E9` (JMP) instruction and calculate target from relative offset.

‚Üì

### Step 2: Find LdrpVectorHandlerList

Scan `RtlpAddVectoredHandler` for this pattern:

```asm
lea rsi, ds:0[rbp*2]
mov [rbx+20h], rax
add rsi, rbp
lea rdi, LdrpVectorHandlerList      ; 48 8D 3D XX XX XX XX
lea rdi, [rdi+8]                    ; 48 8D 7F 08
```

The `lea rdi, [rdi+8]` confirms we found the right address (adding 8 skips the SRWLOCK to get to the ExceptionList).

‚Üì

### Step 3: Find LdrProtectMrdata

Scan for `CALL` instructions in `RtlpAddVectoredHandler`:

```asm
xor ecx, ecx
lea rdi, [rdi+rsi*8]
call LdrProtectMrdata               ; E8 XX XX XX XX
```

Validate the target function starts with:

```asm
mov [rsp+arg_0], rbx               ; 48 89 5C 24 08
mov [rsp+arg_8], rsi               ; 48 89 74 24 10
push rdi                           ; 57
sub rsp, 20h                       ; 48 83 EC 20
```

‚Üì

### Step 4: Allocate Handler Entry

From the disassembly, we allocate 0x28 bytes:

```asm
call LdrControlFlowGuardEnforced
xor edx, edx
lea r8d, [rdx+28h]                 ; Size = 0x28 (40 bytes)
test eax, eax
jz loc_18004F619
mov rcx, cs:LdrpMrdataHeap
```

Then allocate refcount (8 bytes):

```asm
and dword ptr [rax+18h], 0
xor edx, edx
mov rcx, gs:60h
lea r8d, [rdx+8]                   ; Size = 8 bytes
mov rcx, [rcx+30h]
call RtlAllocateHeap
mov [rbx+10h], rax                 ; Store at offset +0x10
```

‚Üì

### Step 5: Initialize Handler Entry

Set refcount to 1 and encode the handler pointer:

```asm
mov rcx, rsi
mov qword ptr [rax], 1             ; *RefCount = 1
call RtlEncodePointer
lea rsi, ds:0[rbp*2]
mov [rbx+20h], rax                 ; Store encoded handler at +0x20
add rsi, rbp
```

The `lea rsi, ds:0[rbp*2]` and `add rsi, rbp` calculates the index (0 for VEH, 1 for VCH):
- If `rbp = 0` (VEH): `rsi = 0*2 + 0 = 0`
- If `rbp = 1` (VCH): `rsi = 1*2 + 1 = 3`

‚Üì

### Step 6: Unlock .mrdata Protection

```asm
xor ecx, ecx                       ; ecx = 0 (unlock)
call LdrProtectMrdata
```

Inside `LdrProtectMrdata`, the unlock path:

```asm
mov ebx, cs:LdrpMrdataUnprotected
test edi, edi                      ; Check if Protect == 0
jz loc_18004F29D

loc_18004F29D:
test ebx, ebx                      ; If counter == 0
jz loc_18004F2BF

loc_18004F2BF:
mov ecx, 4                         ; PAGE_READWRITE
call LdrpChangeMrdataProtection

loc_18004F2C9:
inc ebx                            ; counter++
mov cs:LdrpMrdataUnprotected, ebx
```

‚Üì

### Step 7: Acquire List Lock

```asm
lea rcx, LdrpVectorHandlerList
mov rcx, [rcx+rsi*8]               ; Get lock for VEH (index 0) or VCH
call RtlAcquireSRWLockExclusive
```

‚Üì

### Step 8: Insert Into Linked List

Check if this is the first handler:

```asm
cmp [rdi], rdi                     ; Is list empty?
jnz short loc_18004F5FC
mov rax, gs:60h
lea ecx, [rbp+2]
lock bts [rax+50h], ecx            ; Set flag in TEB
```

Then insert based on `r14d` (FirstHandler parameter):

```asm
test r14d, r14d                    ; FirstHandler?
jz loc_18004F6EF                   ; Jump if 0 (insert at tail)

; Insert at head (FirstHandler = 1):
mov rax, [rdi]                     ; rax = list_head->Flink
cmp [rax+8], rdi                   ; Validate list integrity
jz loc_18004F6C2

loc_18004F6C2:
mov [rbx], rax                     ; entry->List.Flink = list_head->Flink
mov [rbx+8], rdi                   ; entry->List.Blink = list_head
mov [rax+8], rbx                   ; list_head->Flink->Blink = entry
mov [rdi], rbx                     ; list_head->Flink = entry

; Insert at tail (FirstHandler = 0):
loc_18004F6EF:
mov rax, [rdi+8]                   ; rax = list_head->Blink
cmp [rax], rdi                     ; Validate list integrity
jnz loc_18004F612

mov [rbx], rdi                     ; entry->List.Flink = list_head
mov [rbx+8], rax                   ; entry->List.Blink = list_head->Blink
mov [rax], rbx                     ; list_head->Blink->Flink = entry
mov [rdi+8], rbx                   ; list_head->Blink = entry
```

‚Üì

### Step 9: Release Lock and Restore Protection

```asm
lea rax, LdrpVectorHandlerList
mov rcx, [rax+rsi*8]
call RtlReleaseSRWLockExclusive

mov ecx, 1                         ; ecx = 1 (lock)
call LdrProtectMrdata
```

Inside `LdrProtectMrdata`, the lock path:

```asm
mov ebx, cs:LdrpMrdataUnprotected
add ebx, 0FFFFFFFFh                ; ebx-- (decrement)
mov cs:LdrpMrdataUnprotected, ebx
jnz short loc_18004F282            ; If not zero, skip protection change

test ebx, ebx
jz short loc_18004F2A6
mov ecx, 2                         ; PAGE_READONLY
call LdrpChangeMrdataProtection

loc_18004F282:
mov rcx, rsi
call RtlReleaseSRWLockExclusive
```

‚Üì

### Step 10: Handler is Now Active

When an exception occurs, Windows walks the list and calls your handler normally.

## The Handler Structure

Based on the disassembly:

```cpp
typedef struct _VECTORED_HANDLER_ENTRY {
    LIST_ENTRY List;           // +0x00: Doubly-linked list
    PULONG_PTR RefCount;       // +0x10: Pointer to refcount
    DWORD Unknown;             // +0x18: Zeroed out
    DWORD Padding;             // +0x1C
    PVOID EncodedHandler;      // +0x20: RtlEncodePointer result
} VECTORED_HANDLER_ENTRY;      // Total size: 0x28
```

`LdrpVectorHandlerList` structure:

```cpp
struct {
    SRWLOCK Lock;              // +0x00: At index [0]
    LIST_ENTRY ExceptionList;  // +0x08: At index [1] (VEH)
    LIST_ENTRY ContinueList;   // +0x18: At index [3] (VCH)
};
```

The `lea rdi, [rdi+8]` in the disassembly confirms the +8 offset to skip the SRWLOCK.

## Example Output

```
=== GhostVEH POC ===

RtlAddVectoredExceptionHandler = 00007FF8A1B2C3D0
RtlpAddVectoredHandler = 00007FF8A1B2E450
[+] Found 'lea rdi, [rip+0x12ABC]' at offset +0x8E -> 00007FF8A1C4F120
[+] CONFIRMED: This is LdrpVectorHandlerList!

[*] Searching for LdrProtectMrdata...
    [+] Found LdrProtectMrdata at offset +0x1A2 -> 00007FF8A1B2C5F0

Adding normal VEH...
=== VEH Handler Chain ===
[0] Entry: 000001D4B2E10A80
    Decoded: 00007FF6F2A11234
=== End (1 handlers) ===

Adding GhostVEH VEH...
[DEBUG] Calling LdrProtectMrdata(0)...
[DEBUG] Acquiring lock...
[DEBUG] Lock released!
[DEBUG] Calling LdrProtectMrdata(1)...
[+] GhostVEH VEH ADDED!

=== VEH Handler Chain ===
[0] Entry: 000001D4B2E11C40
    Decoded: 00007FF6F2A15678  ‚Üê Stealth handler
[1] Entry: 000001D4B2E10A80
    Decoded: 00007FF6F2A11234  ‚Üê Normal handler
=== End (2 handlers) ===

Triggering exception...
[STEALTH VEH] Exception: 0xC0000094 at RIP: 00007FF6F2A1ABCD
[NORMAL VEH] Exception: 0xC0000094
Caught!
```
## ‚ö†Ô∏è Legal Notice

**By using this code, you accept full responsibility for your actions. The author assumes zero liability for misuse.**
---

```