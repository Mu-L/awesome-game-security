Project Path: arc_EvilBytecode_GoDefender_ihskeflk

Source Tree:

```txt
arc_EvilBytecode_GoDefender_ihskeflk
‚îú‚îÄ‚îÄ GoDefenderLogo.png
‚îú‚îÄ‚îÄ Install.bat
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ go.sum
‚îú‚îÄ‚îÄ internal
‚îÇ   ‚îú‚îÄ‚îÄ antidebug
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ antidebug.go
‚îÇ   ‚îú‚îÄ‚îÄ antidll
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ antidll.go
‚îÇ   ‚îú‚îÄ‚îÄ antivm
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ antivm.go
‚îÇ   ‚îú‚îÄ‚îÄ hooks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ hook_detector.go
‚îÇ   ‚îî‚îÄ‚îÄ utils
‚îÇ       ‚îú‚îÄ‚îÄ debug.go
‚îÇ       ‚îî‚îÄ‚îÄ winapi.go
‚îî‚îÄ‚îÄ main.go

```

`Install.bat`:

```bat
@Echo off
title DOWNLOADING MODULES
go mod init GoDefender
go get github.com/EvilBytecode/GoDefender
pause

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 EvilBytecode

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to use the Software for educational and authorized cybersecurity research purposes only, subject to the following conditions:

The above copyright notice, this permission notice, and the following disclaimer shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS (INCLUDING EvilBytecode) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE, COPYING, DOWNLOADING, OR OTHER DEALINGS IN THE SOFTWARE.

DISCLAIMER: I, EvilBytecode, release this project strictly for educational, academic, and authorized cybersecurity research purposes.  
By accessing, downloading, copying, using, or modifying this software, you agree to these terms.  
You must obtain explicit written permission from system owners before conducting any testing using this software.  
Unauthorized use, distribution, or deployment of this software against any third party, device, network, or system without prior consent is strictly forbidden and illegal.  
I, EvilBytecode, disclaim all responsibility, liability, or consequences arising from any misuse, illegal activities, damages, or losses resulting from this software.
```

`README.md`:

```md
<p align="center">
  <a href="#"><img src="https://img.shields.io/github/stars/EvilBytecode/GoDefender?style=for-the-badge"></a>
  <a href="#"><img src="https://img.shields.io/badge/LANGUAGE-GO-blue?style=for-the-badge"></a>
  <a href="#"><img src="https://img.shields.io/badge/PLATFORM-WINDOWS-green?style=for-the-badge"></a>
</p>

# üõ°Ô∏è GoDefender üõ°Ô∏è

A powerful Go-based security toolkit designed to detect and defend against debugging, virtualization, and DLL injection attacks. GoDefender provides comprehensive protection mechanisms to make reverse engineering and analysis significantly more difficult.

**‚ö†Ô∏è WINDOWS ONLY - Designed for Windows systems**

![GoDefender](GoDefenderLogo.png)

## üöÄ Quick Start

```bash
install.bat
```

## Features

### Anti-Virtualization
* VMware Detection (video controller analysis)
* VirtualBox Detection (driver and file scanning)
* KVM Detection (hypervisor identification)
* QEMU Detection (emulator detection)
* Parallels Detection (macOS virtualization)
* Display Refresh Rate Analysis (< 29Hz detection)
* Screen Resolution Validation
* USB Device History Checking
* VM Artifact File Scanning
* Port Configuration Analysis
* Named Pipes Detection
* Blacklisted Username Checking

### Anti-Debugging
* IsDebuggerPresent API monitoring
* Remote Debugger Detection
* Parent Process Validation (explorer.exe, cmd.exe)
* Process Blacklist Detection (OllyDbg, x64dbg, IDA Pro, WinDbg)
* Window Title Scanning (analysis tool detection)
* Process Count Monitoring
* Repetitive Process Pattern Detection
* Critical Function Patching (DbgUiRemoteBreakin, DbgBreakPoint)
* Debug Filter State Protection
* Memory Zeroing and Cleanup
* Internet Connection Validation
* Process Inheritance Analysis

### Anti-DLL Injection
* LoadLibrary Function Patching
- Patching Dll Taking Advantage of Binary Image Signature Mitigation Policy to prevent injecting Non-Microsoft Binaries.

### Quick Nutshell
- Detects most anti-anti-debugging hooking methods on common anti-debugging functions by checking for bad instructions on function addresses (most effective on x64). It also detects user-mode anti-anti-debuggers like ScyllaHide and can detect some sandboxes that use hooking to monitor application behavior/activity (like [Tria.ge](https://tria.ge/)).

## Telegram:
- https://t.me/ebytelabs

## ü§ù Contributing

Feel free to open issues for additional anti-debugging features, improvements, or bug reports. Contributions are welcome!
Linux support is welcome

## üìú License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ‚ö†Ô∏è Disclaimer

This software is provided for educational and legitimate security research purposes only. Use responsibly and only on systems you own or have explicit permission to test.

## üôè Credits

- **AdvDebug** - Initial inspiration - [GitHub](https://github.com/AdvDebug)
- **MmCopyMemory** - Technical insights and ideas - [GitHub](https://github.com/MmCopyMemory)
- **baum1810** - Port Check Idea - [GitHub](https://github.com/baum1810)
- **HydraDragonAntivirus** - replacing WMIC with WMI - [GitHub](https://github.com/HydraDragonAntivirus)

---

**Star this project if you found it useful! It encourages continued development and improvement.**

```

`go.mod`:

```mod
module github.com/EvilBytecode/GoDefender

go 1.24.4

require (
	github.com/StackExchange/wmi v1.2.1
	golang.org/x/sys v0.35.0
)

require github.com/go-ole/go-ole v1.2.5 // indirect

```

`go.sum`:

```sum
github.com/StackExchange/wmi v1.2.1 h1:VIkavFPXSjcnS+O8yTq7NI32k0R5Aj+v39y29VYDOSA=
github.com/StackExchange/wmi v1.2.1/go.mod h1:rcmrprowKIVzvc+NUiLncP2uuArMWLCbu9SBzvHz7e8=
github.com/go-ole/go-ole v1.2.5 h1:t4MGB5xEDZvXI+0rMjjsfBsD7yAgp/s9ZDkL1JndXwY=
github.com/go-ole/go-ole v1.2.5/go.mod h1:pprOEPIfldk/42T2oK7lQ4v4JSDwmV0As9GaiUsvbm0=
golang.org/x/sys v0.0.0-20190916202348-b4ddaad3f8a3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.35.0 h1:vz1N37gP5bs89s7He8XuIYXpyY0+QlsKmzipCbUtyxI=
golang.org/x/sys v0.35.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=

```

`internal/antidebug/antidebug.go`:

```go
package antidebug

import (
	"GoDefender/internal/utils"
	"net"
	"path/filepath"
	"strings"
	"syscall"
	"unsafe"
	"golang.org/x/sys/windows"
)

type Debugger struct {
	Winapi               *utils.WinAPI
	blacklistedProcesses []string
	blacklistedWindows   []string
}

type ProcessInfo struct {
	Res1             uintptr
	PebAddr          uintptr
	Res2             [2]uintptr
	PID              uintptr
	InheritedFromPID uintptr
}

func New() *Debugger {
	return &Debugger{
		Winapi: utils.NewWinAPI(),
		blacklistedProcesses: []string{
			"taskmgr.exe", "process.exe", "processhacker.exe", "ksdumper.exe", "fiddler.exe",
			"httpdebuggerui.exe", "wireshark.exe", "httpanalyzerv7.exe", "decoder.exe",
			"regedit.exe", "procexp.exe", "dnspy.exe", "vboxservice.exe", "burpsuite.exe",
			"DbgX.Shell.exe", "ILSpy.exe", "ollydbg.exe", "x32dbg.exe", "x64dbg.exe", "gdb.exe",
			"idaq.exe", "idag.exe", "idaw.exe", "ida64.exe", "idag64.exe", "idaw64.exe",
			"idaq64.exe", "windbg.exe", "immunitydebugger.exe", "windasm.exe",
		},
		blacklistedWindows: []string{
			"proxifier", "graywolf", "extremedumper", "zed", "exeinfope", "dnspy",
			"titanHide", "ilspy", "titanhide", "x32dbg", "codecracker", "simpleassembly",
			"process hacker 2", "pc-ret", "http debugger", "debug", "ILSpy",
			"simpleassemblyexplorer", "process", "de4dotmodded", "pizza", "crack",
			"strongod", "ida -", "brute", "dump", "StringDecryptor", "wireshark",
			"debugger", "httpdebugger", "gdb", "windbg", "x64_dbg", "x64netdumper",
			"ollydbg", "immunitydebugger",
		},
	}
}

func (d *Debugger) PatchAntiDebug() bool {
	ntdllModule := d.Winapi.GetModuleHandle("ntdll.dll")
	if ntdllModule == 0 {
		return false
	}

	dbgUiRemoteBreakinAddr := d.Winapi.GetProcAddress(ntdllModule, "DbgUiRemoteBreakin")
	dbgBreakPointAddr := d.Winapi.GetProcAddress(ntdllModule, "DbgBreakPoint")

	if dbgUiRemoteBreakinAddr == 0 || dbgBreakPointAddr == 0 {
		return false
	}

	int3InvalidCode := []byte{0xCC}
	retCode := []byte{0xC3}

	status1 := d.Winapi.WriteProcessMemory(dbgUiRemoteBreakinAddr, int3InvalidCode)
	status2 := d.Winapi.WriteProcessMemory(dbgBreakPointAddr, retCode)

	return status1 && status2
}

func (d *Debugger) SetDebugFilterState() bool {
	return d.Winapi.SetDebugFilterState(0, 0, true)
}

func (d *Debugger) CheckRemoteDebugger() (bool, error) {
	return d.Winapi.CheckRemoteDebugger()
}

func (d *Debugger) GetRunningProcessCount() (int, error) {
	return d.Winapi.GetRunningProcessCount()
}

func (d *Debugger) CheckInternetConnection() (bool, error) {
	conn, err := net.Dial("tcp", "google.com:80")
	if err != nil {
		return false, err
	}
	defer conn.Close()
	return true, nil
}

func (d *Debugger) CheckBlacklistedProcesses() (bool, error) {
	processNames, err := d.Winapi.GetRunningProcessNames()
	if err != nil {
		return false, err
	}

	for _, processName := range processNames {
		processNameLower := strings.ToLower(processName)
		for _, badProcess := range d.blacklistedProcesses {
			if processNameLower == strings.ToLower(badProcess) {
				return true, nil
			}
		}
	}

	return false, nil
}

func (d *Debugger) CheckRepetitiveProcesses(threshold int) (bool, error) {
	processNames, err := d.Winapi.GetRunningProcessNames()
	if err != nil {
		return false, err
	}

	processCounts := make(map[string]int)
	for _, processName := range processNames {
		processName = strings.ToLower(processName)
		if processName != "svchost.exe" {
			processCounts[processName]++
		}
	}

	for _, count := range processCounts {
		if count > threshold {
			return true, nil
		}
	}

	return false, nil
}

func (d *Debugger) CheckParentProcess() bool {
	const ProcInfo = 0
	var p ProcessInfo
	
	handle := syscall.Handle(windows.CurrentProcess())
	
	r1, _, err := d.Winapi.QueryInformationProcess(
		handle,
		ProcInfo,
		uintptr(unsafe.Pointer(&p)),
		uint32(unsafe.Sizeof(p)),
	)
	
	if r1 != 0 || err != nil && err != syscall.Errno(0) {
		return false
	}
	
	parentPID := int32(p.InheritedFromPID)
	if parentPID == 0 {
		return false
	}
	
	parentHandle, err := syscall.OpenProcess(syscall.PROCESS_QUERY_INFORMATION, false, uint32(parentPID))
	if err != nil {
		return false
	}
	defer syscall.CloseHandle(parentHandle)
	
	var nameBuffer [windows.MAX_PATH]uint16
	size := uint32(len(nameBuffer))
	err = windows.QueryFullProcessImageName(windows.Handle(parentHandle), 0, &nameBuffer[0], &size)
	if err != nil {
		return false
	}
	
	parentName := filepath.Base(syscall.UTF16ToString(nameBuffer[:size]))
	return parentName == "explorer.exe" || parentName == "cmd.exe"
}

func (d *Debugger) CheckBlacklistedWindows() bool {
	user32 := windows.NewLazySystemDLL("user32.dll")
	procGetWindowText := user32.NewProc("GetWindowTextW")
	procEnumWindows := user32.NewProc("EnumWindows")
    found = false
	var enumWindowsProc = func(hwnd windows.HWND, lparam uintptr) uintptr {
		var title [256]uint16
		procGetWindowText.Call(
			uintptr(hwnd),
			uintptr(unsafe.Pointer(&title[0])),
			uintptr(len(title)),
		)
		windowTitle := syscall.UTF16ToString(title[:])
		
		for _, blacklisted := range d.blacklistedWindows {
			if strings.Contains(strings.ToLower(windowTitle), strings.ToLower(blacklisted)) {
				found = true
				return 0
			}
		}
		return 1
	}

	procEnumWindows.Call(
		windows.NewCallback(enumWindowsProc),
		0,
	)
	return found
}

```

`internal/antidll/antidll.go`:

```go
package antidll

import (
	"GoDefender/internal/utils"
	"unsafe"
)

type DLLProtector struct {
	winapi *utils.WinAPI
}

type PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY struct {
	MicrosoftSignedOnly uint32
}

const (
	ProcessSignaturePolicyMitigation = 8
)

func New() *DLLProtector {
	return &DLLProtector{
		winapi: utils.NewWinAPI(),
	}
}

func (d *DLLProtector) PreventDLLInjection() error {
	var onlyMicrosoftBinaries PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY
	onlyMicrosoftBinaries.MicrosoftSignedOnly = 1

	kernelbase := d.winapi.GetModuleHandle("kernelbase.dll")
	if kernelbase == 0 {
		return d.winapi.LastError()
	}

	procSetProcessMitigationPolicy := d.winapi.GetProcAddress(kernelbase, "SetProcessMitigationPolicy")
	if procSetProcessMitigationPolicy == 0 {
		return d.winapi.LastError()
	}

	ret, _, err := d.winapi.CallProc(
		procSetProcessMitigationPolicy,
		uintptr(ProcessSignaturePolicyMitigation),
		uintptr(unsafe.Pointer(&onlyMicrosoftBinaries)),
		uintptr(unsafe.Sizeof(onlyMicrosoftBinaries)),
	)

	if ret == 0 {
		return err
	}

	return nil
}

func (d *DLLProtector) PatchAllLoadLibrary() error {
	kernelbase := d.winapi.GetModuleHandle("kernelbase.dll")
	ntdll := d.winapi.GetModuleHandle("ntdll.dll")
	
	if kernelbase == 0 {
		return d.winapi.LastError()
	}
    // remember go uses loadlib, so we patch it but issue is the program will crash (access violation, so thats why i put it as last lol)
	kernelbaseFunctions := []string{"LoadLibraryA", "LoadLibraryW", "LoadLibraryExA", "LoadLibraryExW"}
	ntdllFunctions := []string{"LdrLoadDll"}
	/*
	you might be confused why its not 0xc3 (ret)
	ret imm16 (C2 xx xx) pops the return address, then additionally
	adds imm16 bytes to ESP. This is commonly used in stdcall functions
	to clean up arguments. Here, 'C2 04 00' means 'ret 4', which pops
	the return address AND cleans up 4 bytes (one argument).
	It's not just "ret + N"; it's specifically callee stack cleanup.
	*/
	// i saw this back then in a advdebugs code so i just recoded it, but he removed it i think...
	// but anyways i opened x64, ctrl+g (Function we want to patch) and yes if you check start bytes you can check that its been patched.
	hookedCode := []byte{0xC2, 0x04, 0x00}
	for _, funcName := range kernelbaseFunctions {
		funcAddr := d.winapi.GetProcAddress(kernelbase, funcName)
		if funcAddr == 0 {
			continue 
		}
		success := d.winapi.WriteProcessMemory(funcAddr, hookedCode)
		if !success {
			//utils.Print("Failed to patch %s", funcName)
		}
	}

	if ntdll != 0 {
		for _, funcName := range ntdllFunctions {
			funcAddr := d.winapi.GetProcAddress(ntdll, funcName)
			if funcAddr == 0 {
				//utils.Print("Function %s not found in ntdll.dll", funcName)
				continue 
			}

			//utils.Print("Patching %s at address 0x%x", funcName, funcAddr)
			success := d.winapi.WriteProcessMemory(funcAddr, hookedCode)
			if !success {
				//utils.Print("Failed to patch %s", funcName)
			} else {
				//utils.Print("Successfully patched %s", funcName)
			}
		}
	}

	return nil
}
```

`internal/antivm/antivm.go`:

```go
package antivm

import (
	"github.com/StackExchange/wmi"
	"golang.org/x/sys/windows/registry"
	"os"
	"path/filepath"
	"strings"
	"syscall"
	"GoDefender/internal/utils"
)

type VMDetector struct {
	winapi        *utils.WinAPI
	badFileNames  []string
	badDirs       []string
	badDrivers    []string
	anyRunUUIDs   []string
}

func New() *VMDetector {
	return &VMDetector{
		winapi: utils.NewWinAPI(),
		badFileNames: []string{
			"VBoxMouse.sys", "VBoxGuest.sys", "VBoxSF.sys",
			"VBoxVideo.sys", "vmmouse.sys", "vboxogl.dll",
			"vmhgfs.sys", "vmscsi.sys", "vmci.sys",
			"vmusb.sys", "vmxnet.sys", "vmx_svga.sys", "vmxnet3.sys",
			"hv_vmbus.sys", "hv_storvsc.sys", "hv_netvsc.sys", "hv_balloon.sys",
			"hv_kvp.sys", "hv_fcopy.sys", "hv_vss.sys", "hv_rdv.sys",
			"hv_utils.sys", "hv_ide.sys", "hv_serial.sys", "hv_socket.sys",
			"hv_shutdown.sys", "hv_acpi.sys", "hv_pci.sys", "hv_time.sys",
			"hv_heartbeat.sys", "hv_keyboard.sys", "hv_mouse.sys", "hv_dxgkrnl.sys",
		},
		badDirs: []string{
			`C:\Program Files\VMware`,
			`C:\Program Files\oracle\virtualbox guest additions`,
		},
		badDrivers: []string{
			"balloon.sys", "netkvm.sys", "vioinput",
			"viofs.sys", "vioser.sys", "qemu-ga",
			"qemuwmi", "prl_sf", "prl_tg", "prl_eth",
		},
		anyRunUUIDs: []string{
			"bb926e54-e3ca-40fd-ae90-2764341e7792",
			"90059c37-1320-41a4-b58d-2b75a9850d2f",
		},
	}
}

func (v *VMDetector) getSystem32Path() string {
	systemDir := os.Getenv("SYSTEMROOT")
	if systemDir == "" {
		systemDir = `C:\Windows`
	}
	return filepath.Join(systemDir, "System32")
}

func (v *VMDetector) CheckDisplayRefreshRate() (bool, error) {
	refreshRate, err := v.winapi.GetDisplayRefreshRate()
	if err != nil {
		return false, err
	}
	return refreshRate < 29, nil
}

func (v *VMDetector) CheckVMware() (bool, error) {
	var videoControllers []struct{ Name string }
	err := wmi.Query("SELECT Name FROM Win32_VideoController", &videoControllers)
	if err != nil {
		return false, err
	}

	for _, controller := range videoControllers {
		if strings.Contains(strings.ToLower(controller.Name), "vmware") {
			return true, nil
		}
	}
	return false, nil
}

func (v *VMDetector) CheckVirtualBox() (bool, error) {
	var videoControllers []struct{ Name string }
	err := wmi.Query("SELECT Name FROM Win32_VideoController", &videoControllers)
	if err != nil {
		return false, err
	}

	for _, controller := range videoControllers {
		if strings.Contains(strings.ToLower(controller.Name), "virtualbox") {
			return true, nil
		}
	}
	return false, nil
}

func (v *VMDetector) CheckKVM() (bool, error) {
	for _, driver := range v.badDrivers[:5] {
		files, err := filepath.Glob(filepath.Join(v.getSystem32Path(), driver))
		if err != nil {
			continue
		}
		if len(files) > 0 {
			return true, nil
		}
	}
	return false, nil
}

func (v *VMDetector) CheckQEMU() (bool, error) {
	files, err := os.ReadDir(v.getSystem32Path())
	if err != nil {
		return false, err
	}

	for _, file := range files {
		for _, driver := range v.badDrivers[5:7] {
			if strings.Contains(file.Name(), driver) {
				return true, nil
			}
		}
	}
	return false, nil
}

func (v *VMDetector) CheckParallels() (bool, error) {
	files, err := os.ReadDir(v.getSystem32Path())
	if err != nil {
		return false, err
	}

	for _, file := range files {
		for _, driver := range v.badDrivers[7:] {
			if strings.Contains(file.Name(), driver) {
				return true, nil
			}
		}
	}
	return false, nil
}

func (v *VMDetector) CheckVMFiles() bool {
	files, err := os.ReadDir(v.getSystem32Path())
	if err == nil {
		for _, file := range files {
			fileName := strings.ToLower(file.Name())
			for _, badFile := range v.badFileNames {
				if fileName == strings.ToLower(badFile) {
					return true
				}
			}
		}
	}

	for _, badDir := range v.badDirs {
		if _, err := os.Stat(strings.ToLower(badDir)); err == nil {
			return true
		}
	}
	return false
}

// credits to baum1810;
// https://github.com/baum1810/vmdetection/blob/main/vmdetect.bat
func (v *VMDetector) CheckPortConnectors() (bool, error) {
	var portConnectors []struct{ Tag string }
	err := wmi.Query("SELECT * FROM Win32_PortConnector", &portConnectors)
	if err != nil {
		return false, err
	}
	return len(portConnectors) == 0, nil
}

func (v *VMDetector) CheckScreenSize() (bool, error) {
	getSystemMetrics := syscall.NewLazyDLL("user32.dll").NewProc("GetSystemMetrics")
	width, _, err := getSystemMetrics.Call(0)
	if err != nil && err.Error() != "The operation completed successfully." {
		return false, err
	}
	height, _, err := getSystemMetrics.Call(1)
	if err != nil && err.Error() != "The operation completed successfully." {
		return false, err
	}
	return width < 800 || height < 600, nil
}

func (v *VMDetector) CheckAnyRun() bool {
	key, err := registry.OpenKey(registry.LOCAL_MACHINE, `SOFTWARE\Microsoft\Cryptography`, registry.QUERY_VALUE)
	if err != nil {
		return false
	}
	defer key.Close()

	machineGuid, _, err := key.GetStringValue("MachineGuid")
	if err != nil {
		return false
	}

	for _, uuid := range v.anyRunUUIDs {
		if uuid == machineGuid {
			return true
		}
	}
	return false
}

func (v *VMDetector) CheckUSBDevices() (bool, error) {
	key, err := registry.OpenKey(registry.LOCAL_MACHINE, `SYSTEM\ControlSet001\Services\USBSTOR`, registry.QUERY_VALUE)
	if err == nil {
		defer key.Close()
		return true, nil
	}
	
	key, err = registry.OpenKey(registry.LOCAL_MACHINE, `SYSTEM\ControlSet001\Enum\USBSTOR`, registry.ENUMERATE_SUB_KEYS)
	if err != nil {
		return false, nil
	}
	defer key.Close()
	
	subKeys, err := key.ReadSubKeyNames(0)
	if err != nil {
		return false, err
	}
	return len(subKeys) == 0, nil
}

// im not fan of this one, but its a good way to check if the user is a sandboxed user. 
// con: if regular user has a blacklisted username, it will be detected as a sandboxed user.
func (v *VMDetector) CheckBlacklistedUsernames() bool {
	blacklistedNames := []string{
		"Johnson", "Miller", "malware", "maltest", "CurrentUser", "Sandbox", 
		"virus", "John Doe", "test user", "sand box", "WDAGUtilityAccount",
		"Bruno", "george", "Harry Johnson",
	}
	
	username := strings.ToLower(os.Getenv("USERNAME"))
	for _, name := range blacklistedNames {
		if username == strings.ToLower(name) {
			return true
		}
	}
	return false
}

func (v *VMDetector) CheckSandboxie() bool {
	handle := v.winapi.GetModuleHandle("SbieDll.dll")
	return handle != 0
}

func (v *VMDetector) CheckComodoSandbox() bool {
	handle32 := v.winapi.GetModuleHandle("cmdvrt32.dll")
	handle64 := v.winapi.GetModuleHandle("cmdvrt64.dll")
	return handle32 != 0 || handle64 != 0
}

func (v *VMDetector) CheckQihoo360Sandbox() bool {
	handle := v.winapi.GetModuleHandle("SxIn.dll")
	return handle != 0
}

func (v *VMDetector) CheckCuckooSandbox() bool {
	handle := v.winapi.GetModuleHandle("cuckoomon.dll")
	return handle != 0
}

func (v *VMDetector) CheckWine() bool {
	moduleHandle := v.winapi.GetModuleHandle("kernel32.dll")
	if moduleHandle == 0 {
		return false
	}
	
	procAddr := v.winapi.GetProcAddress(moduleHandle, "wine_get_unix_file_name")
	return procAddr != 0
}

func (v *VMDetector) CheckNamedPipes() bool {
	suspiciousDevices := []string{
		"\\\\.\\pipe\\cuckoo",
		"\\\\.\\HGFS",
		"\\\\.\\vmci",
		"\\\\.\\VBoxMiniRdrDN",
		"\\\\.\\VBoxGuest",
		"\\\\.\\pipe\\VBoxMiniRdDN",
		"\\\\.\\VBoxTrayIPC",
		"\\\\.\\pipe\\VBoxTrayIPC",
		"\\\\.\\pipe\\sandbox",
		"\\\\.\\pipe\\vmware",
		"\\\\.\\pipe\\vbox",
		"\\\\.\\pipe\\qemu",
		"\\\\.\\pipe\\analysis",
		"\\\\.\\pipe\\debug",
		"\\\\.\\pipe\\monitor",
	}

	for _, device := range suspiciousDevices {
		file := v.winapi.Fopen(device, "r")
		if file != 0 {
			v.winapi.Fclose(file)
			return true
		}
	}
	return false
}



```

`internal/hooks/hook_detector.go`:

```go
package hooks

import (
	"syscall"
	"unsafe"
	"GoDefender/internal/utils"
)

func DetectHooksOnCommonWinAPIFunctions(moduleName string, functions []string) bool {
	api := utils.NewWinAPI()
	libraries := []string{"kernel32.dll", "kernelbase.dll", "ntdll.dll", "user32.dll", "win32u.dll"}
	kernellibfunc := []string{"IsDebuggerPresent", "CheckRemoteDebuggerPresent", "GetThreadContext", "CloseHandle", "OutputDebugStringA", "GetTickCount", "SetHandleInformation"}
	ntdllfunc := []string{"NtQueryInformationProcess", "NtSetInformationThread", "NtClose", "NtGetContextThread", "NtQuerySystemInformation", "NtCreateFile", "NtCreateProcess", "NtCreateSection", "NtCreateThread", "NtYieldExecution", "NtCreateUserProcess"}
	user32func := []string{"FindWindowW", "FindWindowA", "FindWindowExW", "FindWindowExA", "GetForegroundWindow", "GetWindowTextLengthA", "GetWindowTextA", "BlockInput", "CreateWindowExW", "CreateWindowExA"}
	win32ufunc := []string{"NtUserBlockInput", "NtUserFindWindowEx", "NtUserQueryWindow", "NtUserGetForegroundWindow"}

	for _, library := range libraries {
		hModule := api.LowLevelGetModuleHandle(library)
		if hModule != 0 {
			switch library {
			case "kernel32.dll", "kernelbase.dll", "ntdll.dll", "win32u.dll":
				var commonFunctions []string
				switch library {
				case "kernel32.dll", "kernelbase.dll":
					commonFunctions = kernellibfunc
				case "ntdll.dll":
					commonFunctions = ntdllfunc
				case "win32u.dll":
					commonFunctions = win32ufunc
				}
				for _, winAPIFunction := range commonFunctions {
					function := api.LowLevelGetProcAddress(hModule, winAPIFunction)
					var functionBytes [1]byte
					syscall.Syscall(uintptr(function), 1, uintptr(unsafe.Pointer(&functionBytes[0])), 0, 0)
					if functionBytes[0] == 0x90 || functionBytes[0] == 0xE9 {
						return true
					}
				}
			case "user32.dll":
				for _, winAPIFunction := range user32func {
					function := api.LowLevelGetProcAddress(hModule, winAPIFunction)
					var functionBytes [1]byte
					syscall.Syscall(uintptr(function), 1, uintptr(unsafe.Pointer(&functionBytes[0])), 0, 0)
					if functionBytes[0] == 0x90 || functionBytes[0] == 0xE9 {
						return true
					}
				}
			}
		}
	}

	if moduleName != "" && functions != nil {
		for _, winAPIFunction := range functions {
			hModule := api.LowLevelGetModuleHandle(moduleName)
			function := api.LowLevelGetProcAddress(hModule, winAPIFunction)
			var functionBytes [1]byte
			syscall.Syscall(uintptr(function), 1, uintptr(unsafe.Pointer(&functionBytes[0])), 0, 0)
			if functionBytes[0] == 0x90 || functionBytes[0] == 0xE9 {
				return true
			}
		}
	}
	return false
}

type HookDetector struct{}

func New() *HookDetector {
	return &HookDetector{}
}

func (h *HookDetector) AntiAntiDebug() bool {
	return DetectHooksOnCommonWinAPIFunctions("", nil)
}
```

`internal/utils/debug.go`:

```go
package utils

import (
	"fmt"
	"log"
	"syscall"
	"unsafe"
)

var (
	DebugEnabled bool = true
	api *WinAPI = NewWinAPI()
)

func DbgPrint(format string, args ...interface{}) {
	if !DebugEnabled {
		return
	}
	msg := fmt.Sprintf(format, args...)
	messagePtr, _ := syscall.UTF16PtrFromString(msg)
	api.CallProc(api.ProcOutputDebugString.Addr(), 
	uintptr(unsafe.Pointer(messagePtr)))
}

func Print(format string, args ...interface{}) {
	if !DebugEnabled {
		return
	}
	log.Printf("[DEBUG] %s", fmt.Sprintf(format, args...))
}


```

`internal/utils/winapi.go`:

```go
package utils

import (
	"syscall"
	"unsafe"
	"golang.org/x/sys/windows"
)

type UNICODE_STRING struct {
	Length        uint16
	MaximumLength uint16
	Buffer        uintptr
}

type ANSI_STRING struct {
	Length        int16
	MaximumLength int16
	Buffer        *byte
}

type DEVMODE struct {
	DmDeviceName       [32]uint16
	DmSpecVersion      uint16
	DmDriverVersion    uint16
	DmSize             uint16
	DmDriverExtra      uint16
	DmFields           uint32
	DmOrientation      int16
	DmPaperSize        int16
	DmPaperLength      int16
	DmPaperWidth       int16
	DmScale            int16
	DmCopies           int16
	DmDefaultSource    int16
	DmPrintQuality     int16
	DmColor           int16
	DmDuplex          int16
	DmYResolution     int16
	DmTTOption        int16
	DmCollate         int16
	DmFormName        [32]uint16
	DmLogPixels       uint16
	DmBitsPerPel      uint32
	DmPelsWidth       uint32
	DmPelsHeight      uint32
	DmDisplayFlags    uint32
	DmDisplayFrequency uint32
	DmICMMethod       uint32
	DmICMIntent       uint32
	DmMediaType       uint32
	DmDitherType      uint32
	DmReserved1       uint32
	DmReserved2       uint32
	DmPanningWidth    uint32
	DmPanningHeight   uint32
}

type WinAPI struct {
	Kernel32              *syscall.LazyDLL
	Ntdll                 *syscall.LazyDLL
	Psapi                 *syscall.LazyDLL
	User32                *syscall.LazyDLL
	Kernelbase            *syscall.LazyDLL
	Win32u                *syscall.LazyDLL

	ProcGetModuleHandle   *syscall.LazyProc
	ProcGetProcAddress    *syscall.LazyProc
	ProcEnumProcesses     *syscall.LazyProc
	ProcOpenProcess       *syscall.LazyProc
	ProcCreateFile        *syscall.LazyProc
	ProcCloseHandle       *syscall.LazyProc
	ProcGetModuleBaseName *syscall.LazyProc
	ProcWriteProcessMemory *syscall.LazyProc
	ProcGetCurrentProcess  *syscall.LazyProc

	ProcIsDebuggerPresent  *syscall.LazyProc
	ProcCheckRemoteDebugger *syscall.LazyProc
	ProcNtSetDebugFilterState *syscall.LazyProc
	ProcNtQueryInformationProcess *syscall.LazyProc

	ProcRtlInitUnicodeString         *syscall.LazyProc
	ProcRtlUnicodeStringToAnsiString *syscall.LazyProc
	ProcLdrGetDllHandleEx            *syscall.LazyProc
	ProcLdrGetProcedureAddressForCall *syscall.LazyProc
	ProcEnumDisplaySettingsW          *syscall.LazyProc
	ProcSetLastError                  *syscall.LazyProc
	ProcGetLastError                  *syscall.LazyProc
	ProcOutputDebugString            *syscall.LazyProc
	ProcFopen                       *syscall.LazyProc
	ProcFclose                      *syscall.LazyProc
	ProcVirtualProtect              *syscall.LazyProc
	ProcVirtualFree                 *syscall.LazyProc
}

func NewWinAPI() *WinAPI {
	w := &WinAPI{
		Kernel32:    syscall.NewLazyDLL("kernel32.dll"),
		Ntdll:       syscall.NewLazyDLL("ntdll.dll"),
		Psapi:       syscall.NewLazyDLL("psapi.dll"),
		User32:      syscall.NewLazyDLL("user32.dll"),
		Kernelbase:  syscall.NewLazyDLL("kernelbase.dll"),
		Win32u:      syscall.NewLazyDLL("win32u.dll"),
	}

	w.ProcGetModuleHandle = w.Kernel32.NewProc("GetModuleHandleW")
	w.ProcGetProcAddress = w.Kernel32.NewProc("GetProcAddress")
	w.ProcEnumProcesses = w.Psapi.NewProc("EnumProcesses")
	w.ProcOpenProcess = w.Kernel32.NewProc("OpenProcess")
	w.ProcCreateFile = w.Kernel32.NewProc("CreateFileW")
	w.ProcCloseHandle = w.Kernel32.NewProc("CloseHandle")
	w.ProcGetModuleBaseName = w.Psapi.NewProc("GetModuleBaseNameW")
	w.ProcWriteProcessMemory = w.Kernel32.NewProc("WriteProcessMemory")
	w.ProcGetCurrentProcess = w.Kernel32.NewProc("GetCurrentProcess")

	w.ProcIsDebuggerPresent = w.Kernel32.NewProc("IsDebuggerPresent")
	w.ProcCheckRemoteDebugger = w.Kernel32.NewProc("CheckRemoteDebuggerPresent")
	w.ProcNtSetDebugFilterState = w.Ntdll.NewProc("NtSetDebugFilterState")
	w.ProcNtQueryInformationProcess = w.Ntdll.NewProc("NtQueryInformationProcess")

	w.ProcRtlInitUnicodeString = w.Ntdll.NewProc("RtlInitUnicodeString")
	w.ProcRtlUnicodeStringToAnsiString = w.Ntdll.NewProc("RtlUnicodeStringToAnsiString")
	w.ProcLdrGetDllHandleEx = w.Ntdll.NewProc("LdrGetDllHandleEx")
	w.ProcLdrGetProcedureAddressForCall = w.Ntdll.NewProc("LdrGetProcedureAddressForCaller")
	w.ProcEnumDisplaySettingsW = w.User32.NewProc("EnumDisplaySettingsW")
	w.ProcSetLastError = w.Kernel32.NewProc("SetLastError")
	w.ProcGetLastError = w.Kernel32.NewProc("GetLastError")
	w.ProcOutputDebugString = w.Kernel32.NewProc("OutputDebugStringW")

	w.ProcFopen = syscall.NewLazyDLL("ucrtbase.dll").NewProc("fopen")
	w.ProcFclose = syscall.NewLazyDLL("ucrtbase.dll").NewProc("fclose")

	w.ProcVirtualProtect = w.Kernel32.NewProc("VirtualProtect")
	w.ProcVirtualFree = w.Kernel32.NewProc("VirtualFree")

	return w
}

func (w *WinAPI) RtlInitUnicodeString(destinationString *UNICODE_STRING, sourceString string) {
	sourcePtr, _ := syscall.UTF16PtrFromString(sourceString)
	syscall.Syscall(w.ProcRtlInitUnicodeString.Addr(), 2, uintptr(unsafe.Pointer(destinationString)), uintptr(unsafe.Pointer(sourcePtr)), 0)
}

func (w *WinAPI) RtlUnicodeStringToAnsiString(destinationString *ANSI_STRING, unicodeString *UNICODE_STRING, allocateDestinationString bool) {
	syscall.Syscall(w.ProcRtlUnicodeStringToAnsiString.Addr(), 3, uintptr(unsafe.Pointer(destinationString)), uintptr(unsafe.Pointer(unicodeString)), uintptr(boolToInt(allocateDestinationString)))
}

func (w *WinAPI) GetModuleHandle(dllName string) uintptr {
	dllNamePtr, _ := syscall.UTF16PtrFromString(dllName)
	handle, _, _ := w.ProcGetModuleHandle.Call(uintptr(unsafe.Pointer(dllNamePtr)))
	return handle
}

func (w *WinAPI) GetProcAddress(moduleHandle uintptr, procName string) uintptr {
	procNamePtr, _ := syscall.BytePtrFromString(procName)
	addr, _, _ := w.ProcGetProcAddress.Call(moduleHandle, uintptr(unsafe.Pointer(procNamePtr)))
	return addr
}

func (w *WinAPI) LdrGetProcedureAddressForCaller(moduleHandle uintptr, procedureName *ANSI_STRING, procedureNumber uint16, functionHandle *uintptr, flags uint64, callback uintptr) uint32 {
	ret, _, _ := w.ProcLdrGetProcedureAddressForCall.Call(moduleHandle, uintptr(unsafe.Pointer(procedureName)), uintptr(procedureNumber), uintptr(unsafe.Pointer(functionHandle)), uintptr(flags), callback)
	return uint32(ret)
}

func (w *WinAPI) LdrGetDllHandleEx(flags uint64, dllPath string, dllCharacteristics string, libraryName *UNICODE_STRING, dllHandle *uintptr) uint32 {
	ret, _, _ := w.ProcLdrGetDllHandleEx.Call(uintptr(flags), 0, 0, uintptr(unsafe.Pointer(libraryName)), uintptr(unsafe.Pointer(dllHandle)))
	return uint32(ret)
}

func (w *WinAPI) LowLevelGetModuleHandle(library string) uintptr {
	var hModule uintptr
	var unicodeString UNICODE_STRING
	w.RtlInitUnicodeString(&unicodeString, library)
	w.LdrGetDllHandleEx(0, "", "", &unicodeString, &hModule)
	return hModule
}

func (w *WinAPI) LowLevelGetProcAddress(hModule uintptr, function string) uintptr {
	var functionHandle uintptr
	var unicodeString UNICODE_STRING
	var ansiString ANSI_STRING
	w.RtlInitUnicodeString(&unicodeString, function)
	w.RtlUnicodeStringToAnsiString(&ansiString, &unicodeString, true)
	w.LdrGetProcedureAddressForCaller(hModule, &ansiString, 0, &functionHandle, 0, 0)
	return functionHandle
}

func (w *WinAPI) WriteProcessMemory(baseAddress uintptr, buffer []byte) bool {
	currentProcess, _, _ := w.ProcGetCurrentProcess.Call()
	if currentProcess == 0 {
		return false
	}

	var bytesWritten uintptr
	ret, _, _ := w.ProcWriteProcessMemory.Call(
		currentProcess,
		baseAddress,
		uintptr(unsafe.Pointer(&buffer[0])),
		uintptr(len(buffer)),
		uintptr(unsafe.Pointer(&bytesWritten)),
	)
	return ret != 0 && bytesWritten == uintptr(len(buffer))
}

func (w *WinAPI) IsDebuggerPresent() bool {
	flag, _, _ := w.ProcIsDebuggerPresent.Call()
	return flag != 0
}

func (w *WinAPI) CheckRemoteDebugger() (bool, error) {
	var isDebuggerPresent bool
	r1, _, err := w.ProcCheckRemoteDebugger.Call(^uintptr(0), uintptr(unsafe.Pointer(&isDebuggerPresent)))
	if r1 == 0 {
		return false, err
	}
	return isDebuggerPresent, nil
}

func (w *WinAPI) EnumProcesses() ([]uint32, error) {
	var processIds [1024]uint32
	var bytesReturned uint32
	
	ret, _, err := w.ProcEnumProcesses.Call(
		uintptr(unsafe.Pointer(&processIds[0])),
		uintptr(len(processIds)*4),
		uintptr(unsafe.Pointer(&bytesReturned)),
	)
	
	if ret == 0 {
		return nil, err
	}
	
	numProcesses := bytesReturned / 4
	result := make([]uint32, numProcesses)
	copy(result, processIds[:numProcesses])
	
	return result, nil
}

func (w *WinAPI) GetProcessName(processId uint32) (string, error) {
	handle, _, err := w.ProcOpenProcess.Call(
		windows.PROCESS_QUERY_INFORMATION|windows.PROCESS_VM_READ,
		0,
		uintptr(processId),
	)
	
	if handle == 0 {
		return "", err
	}
	defer w.ProcCloseHandle.Call(handle)
	
	var processName [260]uint16
	ret, _, err := w.ProcGetModuleBaseName.Call(
		handle,
		0,
		uintptr(unsafe.Pointer(&processName[0])),
		uintptr(len(processName)),
	)
	
	if ret == 0 {
		return "", err
	}
	
	return syscall.UTF16ToString(processName[:]), nil
}

func (w *WinAPI) GetRunningProcessNames() ([]string, error) {
	processIds, err := w.EnumProcesses()
	if err != nil {
		return nil, err
	}
	
	var processNames []string
	for _, pid := range processIds {
		if pid == 0 {
			continue
		}
		
		name, err := w.GetProcessName(pid)
		if err == nil && name != "" {
			processNames = append(processNames, name)
		}
	}
	
	return processNames, nil
}

func (w *WinAPI) GetRunningProcessCount() (int, error) {
	var ids [1024]uint32
	var needed uint32
	r1, _, err := w.ProcEnumProcesses.Call(
		uintptr(unsafe.Pointer(&ids[0])),
		uintptr(len(ids)*4),
		uintptr(unsafe.Pointer(&needed)),
	)
	if r1 == 0 {
		return 0, err
	}
	return int(needed / 4), nil
}

func (w *WinAPI) CallProc(proc uintptr, args ...uintptr) (uintptr, uintptr, error) {
	return syscall.SyscallN(proc, args...)
}

func (w *WinAPI) LastError() error {
	return syscall.GetLastError()
}

func (w *WinAPI) CreateFile(fileName string, desiredAccess uint32, shareMode uint32, securityAttributes uintptr, creationDisposition uint32, flagsAndAttributes uint32, templateFile uintptr) uintptr {
	fileNamePtr, _ := syscall.UTF16PtrFromString(fileName)
	handle, _, _ := w.ProcCreateFile.Call(
		uintptr(unsafe.Pointer(fileNamePtr)),
		uintptr(desiredAccess),
		uintptr(shareMode),
		securityAttributes,
		uintptr(creationDisposition),
		uintptr(flagsAndAttributes),
		templateFile,
	)
	return handle
}

func (w *WinAPI) Fopen(filename string, mode string) uintptr {
	filenamePtr, _ := syscall.BytePtrFromString(filename)
	modePtr, _ := syscall.BytePtrFromString(mode)
	file, _, _ := w.ProcFopen.Call(uintptr(unsafe.Pointer(filenamePtr)), uintptr(unsafe.Pointer(modePtr)))
	return file
}

func (w *WinAPI) Fclose(file uintptr) int {
	ret, _, _ := w.ProcFclose.Call(file)
	return int(ret)
}

func (w *WinAPI) ZeroOutMemory(start uintptr, length int) bool {
	var oldProtect uint32
	
	ret, _, _ := w.ProcVirtualProtect.Call(
		start,
		uintptr(length),
		uintptr(0x04), 
		uintptr(unsafe.Pointer(&oldProtect)),
	)
	if ret == 0 {
		return false
	}
	
	for i := 0; i < length; i++ {
		*(*byte)(unsafe.Pointer(start + uintptr(i))) = 0
	}
	
	ret, _, _ = w.ProcVirtualProtect.Call(
		start,
		uintptr(length),
		uintptr(oldProtect),
		uintptr(unsafe.Pointer(&oldProtect)),
	)
	
	return ret != 0
}

func (w *WinAPI) FreeMemory(address uintptr) bool {
	ret, _, _ := w.ProcVirtualFree.Call(address,0, uintptr(0x8000))
	return ret != 0
}

func (w *WinAPI) GetCurrentProcess() uintptr {
	handle, _, _ := w.ProcGetCurrentProcess.Call()
	return handle
}

func (w *WinAPI) SetLastError(errCode uint32) {
	w.ProcSetLastError.Call(uintptr(errCode))
}

func (w *WinAPI) GetLastError() uint32 {
	ret, _, _ := w.ProcGetLastError.Call()
	return uint32(ret)
}

func (w *WinAPI) SetDebugFilterState(componentId uint64, level uint32, state bool) bool {
	ret, _, _ := w.ProcNtSetDebugFilterState.Call(
		uintptr(componentId),
		uintptr(level),
		uintptr(boolToInt(state)),
	)
	return ret == 0
}

func (w *WinAPI) QueryInformationProcess(handle syscall.Handle, infoClass uint32, info uintptr, infoLen uint32) (uintptr, uintptr, error) {
	return w.ProcNtQueryInformationProcess.Call(
		uintptr(handle),
		uintptr(infoClass),
		info,
		uintptr(infoLen),
		0,
	)
}

func (w *WinAPI) GetDisplayRefreshRate() (uint32, error) {
	const ENUM_CURRENT_SETTINGS = 0xFFFFFFFF

	var devMode DEVMODE
	devMode.DmSize = uint16(unsafe.Sizeof(devMode))

	ret, _, err := w.ProcEnumDisplaySettingsW.Call(
		0,
		uintptr(ENUM_CURRENT_SETTINGS),
		uintptr(unsafe.Pointer(&devMode)),
	)

	if ret == 0 {
		return 0, err
	}

	return devMode.DmDisplayFrequency, nil
}

func boolToInt(b bool) int {
	if b {
		return 1
	}
	return 0
}
```

`main.go`:

```go
package main

import (
	"GoDefender/internal/antivm"
	"GoDefender/internal/antidebug"
	"GoDefender/internal/antidll"
	"GoDefender/internal/hooks"
	"GoDefender/internal/utils"
	"fmt"
)

func main() {
	utils.Print("Starting GoDefender checks...")

	vmDetector := antivm.New()
	debugger := antidebug.New()
	dllProtector := antidll.New()
	hookDetector := hooks.New()

	if lowRefresh, err := vmDetector.CheckDisplayRefreshRate(); err == nil && lowRefresh {
		utils.Print("Suspicious display refresh rate detected (< 29Hz)")
	}

	if err := dllProtector.PreventDLLInjection(); err != nil {
		utils.Print("Failed to set DLL injection protection")
	}

	if hookDetector.AntiAntiDebug() {
		utils.Print("API hooks detected")
	}
	
	if debugger.PatchAntiDebug() {
		utils.Print("Anti-debug patches applied")
	}
	
	if debugger.SetDebugFilterState() {
		utils.Print("Debug filter state protected")
	}

	usbPluggedIn, err := vmDetector.CheckUSBDevices()
	if err != nil || !usbPluggedIn {
		utils.Print("USB check failed")
	}

	if vmDetector.CheckBlacklistedUsernames() {
		utils.Print("Blacklisted username detected")
	}

	if !debugger.CheckParentProcess() {
		utils.Print("Suspicious parent process detected")
	}

	if vmware, _ := vmDetector.CheckVMware(); vmware {
		utils.Print("VMWare detected")
	}

	if vbox, _ := vmDetector.CheckVirtualBox(); vbox {
		utils.Print("VirtualBox detected")
	}

	if kvm, _ := vmDetector.CheckKVM(); kvm {
		utils.Print("KVM detected")
	}

	if parallels, _ := vmDetector.CheckParallels(); parallels {
		utils.Print("Parallels detected")
	}

	if qemu, _ := vmDetector.CheckQEMU(); qemu {
		utils.Print("QEMU detected")
	}

	if vmDetector.CheckVMFiles() {
		utils.Print("VM files detected")
	}

	if vmDetector.CheckAnyRun() {
		utils.Print("Any.Run detected")
	}

	if portCheck, _ := vmDetector.CheckPortConnectors(); portCheck {
		utils.Print("Suspicious port configuration")
	}

	if screenSmall, _ := vmDetector.CheckScreenSize(); screenSmall {
		utils.Print("Suspicious screen metrics")
	}

	if vmDetector.CheckNamedPipes() {
		utils.Print("Suspicious named pipes detected")
	}


	if remoteDbg, _ := debugger.CheckRemoteDebugger(); remoteDbg {
		utils.Print("Remote debugger detected")
	}

	if debugger.CheckBlacklistedWindows() {
		utils.Print("Analysis tool window detected")
	}

	if badProc, _ := debugger.CheckBlacklistedProcesses(); badProc {
		utils.Print("Malicious process detected")
	}

	if repProc, _ := debugger.CheckRepetitiveProcesses(60); repProc {
		utils.Print("Suspicious process pattern")
	}

	if connected, _ := debugger.CheckInternetConnection(); !connected {
		utils.Print("No internet connection")
	}

	procCount, _ := debugger.GetRunningProcessCount()
	if procCount < 50 {
		utils.Print("Abnormal process count")
	}

	utils.Print("‚úÖ All security checks passed!")

	if err := dllProtector.PatchAllLoadLibrary(); err != nil {
		utils.Print("Failed to patch LoadLibrary functions")
	} else {
		utils.Print("All LoadLibrary functions patched successfully")
	}

	fmt.Scanln()
}	

```