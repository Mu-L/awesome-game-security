Project Path: arc_EvilBytecode_CustomDpapi_93oaw5o9

Source Tree:

```txt
arc_EvilBytecode_CustomDpapi_93oaw5o9
├── LICENSE
├── README.md
├── customdpapi
│   ├── customdpapi.cpp
│   ├── customdpapi.vcxproj
│   ├── customdpapi.vcxproj.filters
│   └── customdpapi.vcxproj.user
└── customdpapi.sln

```

`LICENSE`:

```
MIT License

Copyright (c) 2026 EvilBytecode

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# DPAPI RPC Internals and Custom Decryption

Calling the undocumented DPAPI RPC interface directly

## tl;dr

CryptUnprotectData is just a wrapper around an RPC call to lsass. we can skip the API and call NdrClientCall3 directly with the right parameters. disassembled dpapi.dll to figure out the exact calling convention.

## why did i reverse this

good question. it started with "i wonder how DPAPI actually works under the hood" and ended with me at 3am staring at RPC stubs in IDA wondering what i'm doing with my life.

also CryptUnprotectData is boring and i wanted to see if i could do it the cool way. turns out Microsoft's "security through obscurity" approach to internal APIs isn't that secure when you have IDA Pro and too much free time.

spoiler: it wasn't worth it, the high level API works fine, but now i know way too much about MIDL_STUBLESS_PROXY_INFO structures and i need to tell someone about it. so here we are.

## Background

DPAPI uses a local RPC server (protected_storage endpoint) running in lsass.exe for all crypto operations. the high level API (CryptProtectData/CryptUnprotectData) is basically just doing parameter marshalling and calling into this RPC interface.

interesting parts:
- RPC endpoint runs in lsass context so it has access to user's master keys
- communication happens over ncalrpc (local RPC, no network)
- actual decryption happens in two stages: RPC call returns encrypted memory, then SystemFunction041 decrypts it ( RtlEncryptMemory / RtlDecryptMemory )

## Reverse Engineering CryptUnprotectDataNoUI

started with dpapi.dll from Windows 10 22H2 (probably works on other versions too but offsets might differ)

### Initial RPC Setup

```asm
.text:00000001800012A0 CryptUnprotectDataNoUI proc near
.text:00000001800012B6                 and     [rsp+78h+Binding], 0
.text:00000001800012BB                 and     [rsp+78h+String], 0
.text:00000001800012C0                 mov     rsi, r9
.text:00000001800012C3                 test    r9, r9
.text:00000001800012C6                 jz      short error_invalid_param
.text:00000001800012C8                 test    rcx, rcx
.text:00000001800012CB                 jz      short error_invalid_param
.text:00000001800012CD                 cmp     qword ptr [rcx+8], 0
.text:00000001800012D2                 jz      short error_invalid_param
```

basic parameter validation, nothing special

### Binding String Composition

```asm
.text:0000000180001320                 lea     r9, [rsp+78h+String]
.text:0000000180001325                 xor     r8d, r8d
.text:0000000180001328                 lea     rdx, ProtectedStorage
.text:000000018000132F                 xor     ecx, ecx
.text:0000000180001331                 mov     qword ptr [rsp+78h+var_58], r9
.text:0000000180001336                 lea     r9, Ncalrpc
.text:000000018000133D                 call    cs:RpcStringBindingComposeW
.text:0000000180001343                 mov     ebx, eax
.text:0000000180001345                 test    eax, eax
.text:0000000180001347                 jnz     cleanup_and_exit
.text:000000018000134D                 mov     rcx, [rsp+78h+String]
.text:0000000180001352                 lea     rdx, [rsp+78h+Binding]
.text:0000000180001357                 call    cs:RpcBindingFromStringBindingW
```

the important strings here:

```asm
.rdata:0000000180003000 Ncalrpc         dq offset aNcalrpc        ; "ncalrpc"
.rdata:0000000180003008 ProtectedStorage dq offset aProtectedStor ; "protected_storage"
```

so it's composing a binding string for local RPC (ncalrpc) to the "protected_storage" endpoint. this endpoint is hosted by lsass.exe

### The Actual RPC Call

this is where it gets interesting

```asm
.text:00000001800013A0                 lea     rcx, pProxyInfo
.text:00000001800013A7                 mov     edx, 1
.text:00000001800013AC                 xor     r8d, r8d
.text:00000001800013AF                 mov     r9, [rsp+78h+Binding]
.text:00000001800013B4                 mov     [rsp+78h+var_58], r12
.text:00000001800013B9                 mov     [rsp+78h+var_50], rsi
.text:00000001800013BE                 mov     rax, [r15+8]
.text:00000001800013C2                 mov     [rsp+78h+var_48], rax
.text:00000001800013C7                 mov     ecx, [r15]
.text:00000001800013CA                 mov     [rsp+78h+var_40], rcx
.text:00000001800013CF                 lea     rax, [rsp+78h+hMem]
.text:00000001800013D4                 mov     [rsp+78h+var_38], rax
.text:00000001800013D9                 mov     rax, [r14+8]
.text:00000001800013DD                 mov     [rsp+78h+var_30], rax
.text:00000001800013E2                 mov     ecx, [r14]
.text:00000001800013E5                 mov     [rsp+78h+var_28], rcx
.text:00000001800013EA                 lea     rax, [rsp+78h+var_60]
.text:00000001800013EF                 mov     [rsp+78h+var_20], rax
.text:00000001800013F4                 mov     [rsp+78h+var_18], r13d
.text:00000001800013F9                 mov     [rsp+78h+var_10], r8
.text:00000001800013FE                 mov     [rsp+78h+var_8], r8d
.text:0000000180001403                 call    cs:NdrClientCall3
```

NdrClientCall3 is the key here. it's a function from rpcrt4.dll that handles RPC calls for stubless proxies

parameters being pushed on stack:
- rcx = pProxyInfo (pointer to MIDL_STUBLESS_PROXY_INFO structure)
- edx = 1 (procedure number, ie which RPC method to call)
- r8d = 0 
- r9 = binding handle
- stack[0] = pointer to output buffer pointer
- stack[1] = pointer to output size
- stack[2] = encrypted data pointer
- stack[3] = encrypted data size
- stack[4] = pointer to description HLOCAL
- stack[5] = optional entropy data pointer
- stack[6] = optional entropy size
- stack[7] = flags pointer (set to 8, which is CRYPTPROTECT_UI_FORBIDDEN)
- stack[8] = reserved
- stack[9] = prompt struct pointer
- stack[10] = reserved

### Proxy Info Structure

the pProxyInfo is located at dpapi.dll + 0x3000

```asm
.rdata:0000000180003000 pProxyInfo      MIDL_STUBLESS_PROXY_INFO <offset stru_180003080, \
.rdata:0000000180003000                                           offset word_180003060, \
.rdata:0000000180003000                                           offset word_180004680, \
.rdata:0000000180003000                                           offset unk_180004660, \
.rdata:0000000180003000                                           offset unk_180004640>
```

this structure contains format strings and type information needed by the NDR (Network Data Representation) engine to marshal parameters. basically tells the RPC runtime how to serialize and deserialize the function arguments

we can just use this structure directly from dpapi.dll instead of trying to reconstruct it

### Return Value Handling

```asm
.text:0000000180001409                 mov     ebx, eax
.text:000000018000140B                 mov     [rsp+78h+var_68], rax
.text:0000000180001410                 test    eax, eax
.text:0000000180001412                 jz      short rpc_success
.text:0000000180001414                 cmp     eax, 90E52h
.text:0000000180001419                 jnz     cleanup_and_exit
```

interesting: return value of 0 is success, but 0x90E52 (593938) is also treated as success. didn't dig into why but probably some legacy compatibility thing

### Stage 2: SystemFunction041 Decryption

after RPC call succeeds, it returns an encrypted memory buffer that needs another decryption step

```asm
.text:0000000180001450                 mov     rcx, [r12]
.text:0000000180001454                 mov     edx, [rsi]
.text:0000000180001456                 mov     r8d, 2
.text:000000018000145C                 call    cs:SystemFunction041
.text:0000000180001462                 test    eax, eax
.text:0000000180001464                 js      short decrypt_failed
```

SystemFunction041 is an undocumented function in advapi32.dll (well it's documented now i guess)

parameters:
- rcx = buffer to decrypt (in place modification)
- edx = buffer size
- r8d = operation (1 = encrypt, 2 = decrypt)

this function does AES decryption using session keys. the RPC server encrypted the plaintext before sending it back to protect it during the local RPC transfer

### PKCS7 Padding Removal

after decryption, need to strip the padding

```asm
.text:0000000180001480                 mov     edx, [rsi]
.text:0000000180001482                 mov     rcx, [r12]
.text:0000000180001486                 lea     rax, [rdx-1]
.text:000000018000148A                 movzx   r8d, byte ptr [rcx+rax]
.text:000000018000148F                 test    r8b, r8b
.text:0000000180001492                 jz      short no_padding
.text:0000000180001494                 cmp     r8d, edx
.text:0000000180001497                 ja      short invalid_padding
.text:0000000180001499                 cmp     r8d, 8
.text:000000018000149D                 ja      short invalid_padding
.text:000000018000149F                 sub     edx, r8d
.text:00000001800014A2                 mov     [rsi], edx
```

standard PKCS7 padding check:
- get last byte value
- verify it's between 1 and 8
- verify it's not larger than buffer size
- subtract that many bytes from total size

## Implementation

putting it all together into working code

### RPC Binding

```c
RPC_WSTR Protocol = (RPC_WSTR)L"ncalrpc";
RPC_WSTR Endpoint = (RPC_WSTR)L"protected_storage";

RpcStringBindingComposeW(
    NULL,
    Protocol,
    NULL,
    Endpoint,
    NULL,
    &BindingString
);

RpcBindingFromStringBindingW(BindingString, &BindingHandle);
```

### Getting Proxy Info

```c
HMODULE DpapiModule = LoadLibraryA("dpapi.dll");
void* ProxyInfo = (void*)((BYTE*)DpapiModule + 0x3000);
```

hardcoded offset, might break on different windows versions but works on everything i tested (win10 1809 through win11 23H2)

### Calling NdrClientCall3

```c
PNdrClientCall3 NdrCall = (PNdrClientCall3)GetProcAddress(
    LoadLibraryA("rpcrt4.dll"),
    "NdrClientCall3"
);

void* Result = NdrCall(
    ProxyInfo,
    1,
    NULL,
    BindingHandle,
    &OutputData,
    &OutputSize,
    EncryptedData,
    EncryptedSize,
    &Description,
    NULL,
    0,
    &Flags,
    0,
    NULL,
    0
);
```

### Stage 2 Decryption

```c
PSystemFunction041 Decrypt = (PSystemFunction041)GetProcAddress(
    LoadLibraryA("advapi32.dll"),
    "SystemFunction041"
);

Decrypt(OutputData, OutputSize, 2);
```

### Padding Removal

```c
BYTE PaddingSize = OutputData[OutputSize - 1];
if (PaddingSize > 0 && PaddingSize <= 8 && PaddingSize <= OutputSize) {
    OutputSize -= PaddingSize;
}
```

## Testing

```
C:\> customdpapi.exe
[+] Original data: This is my secret password: SuperSecret123!
[+] Data length: 43 bytes

[*] Encrypting with official CryptProtectData...
[+] Encrypted blob size: 280 bytes
[+] Encrypted data saved to: encrypted.bin

[*] Decrypting with RPC call...

[*] Calling NdrClientCall3 via RPC...
[*] RPC call returned: 0x0
[*] RPC returned 48 bytes of encrypted memory
[*] Decrypting memory with SystemFunction041...
[*] Memory decrypted successfully
[*] Stripping 4 bytes of PKCS#7 padding
[*] Description from RPC: My Secret

[+] Decryption successful!
[+] Decrypted data: This is my secret password: SuperSecret123!
[+] Decrypted length: 44 bytes
```

works perfectly (btw i just saw it returns 44 bytes, its cuz of a nullterminator)

## Notes and Quirks

### Memory Management

don't try to free the buffer returned by NdrClientCall3 using regular free(). it's allocated by the RPC runtime using different allocators. just leak it or let process exit clean it up. 

tried using RpcFree but that's not available in normal rpcrt4. could implement MIDL_user_free properly but easier to just not care about a 48 byte memory leak. we're hackers not software engineers, memory leaks build character

### Why Does This Work

DPAPI doesn't do any special authentication or verification that the caller is actually dpapi.dll. the RPC endpoint is available to any process running in the same user context. all the security comes from:
1. the encrypted blob is bound to the user's master key (stored in user profile)
2. lsass verifies the calling user has access to decrypt (same user who encrypted)
3. local RPC only, can't call remotely

so we're not bypassing any security, just using a lower level interface than intended

## Disclaimer

**IMPORTANT: READ THIS BEFORE USING THIS CODE**

this project is for educational and research purposes only. the techniques described here demonstrate how DPAPI works internally and should only be used in authorized security research, penetration testing with proper authorization, or educational environments.

**DO NOT:**
- use this to decrypt other people's data without authorization
- deploy this in malware or malicious tools
- use this to steal credentials from systems you don't own
- violate any computer fraud and abuse laws in your jurisdiction

**unauthorized access to computer systems is illegal.** just because you can do something doesn't mean you should. violating the CFAA (US), Computer Misuse Act (UK), or equivalent laws in other countries can result in serious criminal penalties.

if you're doing legitimate security research, get proper authorization first. if you're just messing around, use a VM with your own data.

the author is not responsible for misuse of this code. you've been warned.

## Credits and References

**author:** Evilbytecode

**tools used:**
- IDA Pro 9.1 for disassembly and reverse engineering
- Ghidra (also useful, free alternative to IDA)

if you're into this kind of stuff, there's way more rabbit holes to go down. have fun

## Legal Notice

this code is provided "as is" without warranty of any kind. use at your own risk. seriously, don't be stupid with this.

- if you're a security researcher: document your findings responsibly
- if you're a pentester: get it in writing from the client
- if you're a defender: use this knowledge to protect your systems
- if you're a bad guy: go away

---

made with IDA Pro, redbull, and questionable life choices

if this helped you, cool. if you're mad about something, open an issue and i'll probably ignore it

remember kids: just because you CAN reverse engineer something doesn't mean you SHOULD. but where's the fun in that

2026

```

`customdpapi.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36203.30 d17.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "customdpapi", "customdpapi\customdpapi.vcxproj", "{741A3061-1DA8-4A7D-A9B6-F53377C80741}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{741A3061-1DA8-4A7D-A9B6-F53377C80741}.Debug|x64.ActiveCfg = Debug|x64
		{741A3061-1DA8-4A7D-A9B6-F53377C80741}.Debug|x64.Build.0 = Debug|x64
		{741A3061-1DA8-4A7D-A9B6-F53377C80741}.Debug|x86.ActiveCfg = Debug|Win32
		{741A3061-1DA8-4A7D-A9B6-F53377C80741}.Debug|x86.Build.0 = Debug|Win32
		{741A3061-1DA8-4A7D-A9B6-F53377C80741}.Release|x64.ActiveCfg = Release|x64
		{741A3061-1DA8-4A7D-A9B6-F53377C80741}.Release|x64.Build.0 = Release|x64
		{741A3061-1DA8-4A7D-A9B6-F53377C80741}.Release|x86.ActiveCfg = Release|Win32
		{741A3061-1DA8-4A7D-A9B6-F53377C80741}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F96A8992-1C95-41F6-AC8B-C8AE5A8A894C}
	EndGlobalSection
EndGlobal

```

`customdpapi/customdpapi.cpp`:

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <rpc.h>
#include <rpcndr.h>
#include <stdio.h>
#include <dpapi.h>

#pragma comment(lib, "rpcrt4.lib")
#pragma comment(lib, "crypt32.lib")

typedef void* (__stdcall* PNdrClientCall3)(void*, unsigned int, void*, ...);
typedef NTSTATUS(WINAPI* PSystemFunction041)(PVOID, ULONG, ULONG);

void __RPC_FAR* __RPC_USER
MidlUserAllocate(
    size_t Length
)
{
    return malloc(Length);
}

void __RPC_USER
MidlUserFree(
    void __RPC_FAR* Pointer
)
{
    if (Pointer) {
        free(Pointer);
    }
}

BOOL
RpcUnprotectData(
    BYTE* EncryptedData,
    DWORD EncryptedSize,
    BYTE** PlainData,
    DWORD* PlainSize
)
{
    BOOL Success = FALSE;
    RPC_BINDING_HANDLE BindingHandle = NULL;
    RPC_WSTR BindingString = NULL;
    HMODULE DpapiModule = NULL;
    HMODULE Rpcrt4Module = NULL;
    HMODULE AdvApi32Module = NULL;
    BYTE* OutputData = NULL;
    DWORD OutputSize = 0;
    HLOCAL Description = NULL;
    PNdrClientCall3 NdrCall = NULL;
    PSystemFunction041 SystemFunc041 = NULL;
    void* ProxyInfo = NULL;
    DWORD Flags = 8;
    RPC_STATUS Status;
    void* Result;
    DWORD ResultCode;
    NTSTATUS NtStatus;
    BYTE PaddingSize;

    RPC_WSTR Protocol = (RPC_WSTR)L"ncalrpc";
    RPC_WSTR Endpoint = (RPC_WSTR)L"protected_storage";

    Status = RpcStringBindingComposeW(
        NULL,
        Protocol,
        NULL,
        Endpoint,
        NULL,
        &BindingString
    );
    if (Status != RPC_S_OK) {
        printf("[-] RpcStringBindingComposeW failed: 0x%X\n", Status);
        goto Cleanup;
    }

    Status = RpcBindingFromStringBindingW(BindingString, &BindingHandle);
    if (Status != RPC_S_OK) {
        printf("[-] RpcBindingFromStringBindingW failed: 0x%X\n", Status);
        goto Cleanup;
    }

    DpapiModule = LoadLibraryA("dpapi.dll");
    if (!DpapiModule) {
        printf("[-] Failed to load dpapi.dll: %d\n", GetLastError());
        goto Cleanup;
    }

    ProxyInfo = (void*)((BYTE*)DpapiModule + 0x3000);

    Rpcrt4Module = LoadLibraryA("rpcrt4.dll");
    if (!Rpcrt4Module) {
        printf("[-] Failed to load rpcrt4.dll: %d\n", GetLastError());
        goto Cleanup;
    }

    NdrCall = (PNdrClientCall3)GetProcAddress(Rpcrt4Module, "NdrClientCall3");
    if (!NdrCall) {
        printf("[-] Failed to get NdrClientCall3: %d\n", GetLastError());
        goto Cleanup;
    }

    printf("[*] Calling NdrClientCall3 via RPC...\n");

    Result = NdrCall(
        ProxyInfo,
        1,
        NULL,
        BindingHandle,
        &OutputData,
        &OutputSize,
        EncryptedData,
        EncryptedSize,
        &Description,
        NULL,
        0,
        &Flags,
        0,
        NULL,
        0
    );

    ResultCode = (DWORD)(DWORD_PTR)Result;
    printf("[*] RPC call returned: 0x%X\n", ResultCode);

    if (ResultCode != 0 && ResultCode != 593938) {
        printf("[-] RPC failed with error: 0x%X\n", ResultCode);
        goto Cleanup;
    }

    if (!OutputData || OutputSize == 0) {
        printf("[-] No data returned from RPC\n");
        goto Cleanup;
    }

    printf("[*] RPC returned %d bytes of encrypted memory\n", OutputSize);

    AdvApi32Module = LoadLibraryA("advapi32.dll");
    if (!AdvApi32Module) {
        printf("[-] Failed to load advapi32.dll: %d\n", GetLastError());
        goto Cleanup;
    }

    SystemFunc041 = (PSystemFunction041)GetProcAddress(AdvApi32Module, "SystemFunction041");
    if (!SystemFunc041) {
        printf("[-] Failed to get SystemFunction041: %d\n", GetLastError());
        goto Cleanup;
    }

    printf("[*] Decrypting memory with SystemFunction041...\n");

    NtStatus = SystemFunc041(OutputData, OutputSize, 2);
    if (NtStatus < 0) {
        printf("[-] SystemFunction041 failed: 0x%X\n", NtStatus);
        goto Cleanup;
    }

    printf("[*] Memory decrypted successfully\n");

    PaddingSize = OutputData[OutputSize - 1];
    if (PaddingSize > 0 && PaddingSize <= 8 && PaddingSize <= OutputSize) {
        printf("[*] Stripping %d bytes of PKCS#7 padding\n", PaddingSize);
        OutputSize -= PaddingSize;
    }

    if (Description) {
        printf("[*] Description from RPC: %ls\n", Description);
    }

    *PlainData = (BYTE*)malloc(OutputSize);
    if (!*PlainData) {
        printf("[-] Failed to allocate output buffer\n");
        goto Cleanup;
    }

    memcpy(*PlainData, OutputData, OutputSize);
    *PlainSize = OutputSize;

    Success = TRUE;

Cleanup:
    if (BindingString) {
        RpcStringFreeW(&BindingString);
    }
    if (BindingHandle) {
        RpcBindingFree(&BindingHandle);
    }
    if (Description) {
        LocalFree(Description);
    }
    if (DpapiModule) {
        FreeLibrary(DpapiModule);
    }
    if (Rpcrt4Module) {
        FreeLibrary(Rpcrt4Module);
    }
    if (AdvApi32Module) {
        FreeLibrary(AdvApi32Module);
    }

    return Success;
}

BOOL
ProtectData(
    const char* SecretData,
    BYTE** EncryptedData,
    DWORD* EncryptedSize
)
{
    BOOL Success = FALSE;
    DATA_BLOB BlobIn = { 0 };
    DATA_BLOB BlobOut = { 0 };

    BlobIn.pbData = (BYTE*)SecretData;
    BlobIn.cbData = (DWORD)strlen(SecretData) + 1;

    printf("[*] Encrypting with official CryptProtectData...\n");

    if (!CryptProtectData(
        &BlobIn,
        L"My Secret",
        NULL,
        NULL,
        NULL,
        0,
        &BlobOut
    ))
    {
        printf("[-] CryptProtectData failed: %d\n", GetLastError());
        goto Cleanup;
    }

    printf("[+] Encrypted blob size: %d bytes\n", BlobOut.cbData);

    *EncryptedData = (BYTE*)malloc(BlobOut.cbData);
    if (!*EncryptedData) {
        printf("[-] Failed to allocate encrypted buffer\n");
        goto Cleanup;
    }

    memcpy(*EncryptedData, BlobOut.pbData, BlobOut.cbData);
    *EncryptedSize = BlobOut.cbData;

    Success = TRUE;

Cleanup:
    if (BlobOut.pbData) {
        LocalFree(BlobOut.pbData);
    }

    return Success;
}

BOOL
WriteDataToFile(
    const char* Filename,
    BYTE* Data,
    DWORD Size
)
{
    BOOL Success = FALSE;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    DWORD BytesWritten = 0;
    char FilePath[MAX_PATH];

    GetCurrentDirectoryA(MAX_PATH, FilePath);
    strcat(FilePath, "\\");
    strcat(FilePath, Filename);

    FileHandle = CreateFileA(
        FilePath,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        0,
        NULL
    );

    if (FileHandle == INVALID_HANDLE_VALUE) {
        printf("[-] Failed to create file %s: %d\n", FilePath, GetLastError());
        goto Cleanup;
    }

    if (!WriteFile(FileHandle, Data, Size, &BytesWritten, NULL)) {
        printf("[-] Failed to write file: %d\n", GetLastError());
        goto Cleanup;
    }

    printf("[+] Data saved to: %s\n", FilePath);
    Success = TRUE;

Cleanup:
    if (FileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(FileHandle);
    }

    return Success;
}

int
main(
    void
)
{
    int ExitCode = 1;
    char SecretData[] = "This is my secret password: SuperSecret123!";
    BYTE* EncryptedData = NULL;
    DWORD EncryptedSize = 0;
    BYTE* DecryptedData = NULL;
    DWORD DecryptedSize = 0;

    printf("[+] Original data: %s\n", SecretData);
    printf("[+] Data length: %d bytes\n\n", (int)strlen(SecretData));

    if (!ProtectData(SecretData, &EncryptedData, &EncryptedSize)) {
        goto Cleanup;
    }

    WriteDataToFile("encrypted.bin", EncryptedData, EncryptedSize);

    printf("\n[*] Decrypting with REAL RPC call...\n\n");

    if (!RpcUnprotectData(EncryptedData, EncryptedSize, &DecryptedData, &DecryptedSize)) {
        printf("[-] Custom RPC decryption failed!\n");
        goto Cleanup;
    }

    printf("\n[+] Decryption successful!\n");
    printf("[+] Decrypted data: %s\n", (char*)DecryptedData);
    printf("[+] Decrypted length: %d bytes\n\n", DecryptedSize);

    WriteDataToFile("decrypted.txt", DecryptedData, DecryptedSize);

    ExitCode = 0;

Cleanup:
    if (EncryptedData) {
        free(EncryptedData);
    }
    if (DecryptedData) {
        free(DecryptedData);
    }

    printf("\n[*] Done!\n");
    return ExitCode;
}
```

`customdpapi/customdpapi.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{741a3061-1da8-4a7d-a9b6-f53377c80741}</ProjectGuid>
    <RootNamespace>customdpapi</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="customdpapi.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`customdpapi/customdpapi.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="customdpapi.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`customdpapi/customdpapi.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```