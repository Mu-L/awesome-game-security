Project Path: arc_YMY1666527646_ue4_base_6dayrfvq

Source Tree:

```txt
arc_YMY1666527646_ue4_base_6dayrfvq
├── readme.md
├── ue4_base
│   ├── hooks
│   │   ├── hooks.cpp
│   │   ├── hooks.h
│   │   └── post_render
│   │       └── post_render.cpp
│   ├── includes.h
│   ├── render
│   │   ├── render.cpp
│   │   └── render.h
│   ├── ue4
│   │   ├── components
│   │   │   ├── scene_component
│   │   │   │   └── scene_component.h
│   │   │   └── skeletal_mesh_component
│   │   │       ├── skeletal_mesh_component.cpp
│   │   │       └── skeletal_mesh_component.h
│   │   ├── containers
│   │   │   ├── array.h
│   │   │   ├── enum_as_byte.h
│   │   │   └── string.h
│   │   ├── core_object
│   │   │   ├── class
│   │   │   │   └── class.h
│   │   │   ├── field
│   │   │   │   └── field.h
│   │   │   ├── name
│   │   │   │   ├── name.cpp
│   │   │   │   └── name.h
│   │   │   ├── object
│   │   │   │   ├── object.cpp
│   │   │   │   └── object.h
│   │   │   └── struct
│   │   │       └── struct.h
│   │   ├── engine
│   │   │   ├── canvas
│   │   │   │   ├── canvas.cpp
│   │   │   │   └── canvas.h
│   │   │   ├── game_instance
│   │   │   │   └── game_instance.h
│   │   │   ├── level
│   │   │   │   └── level.h
│   │   │   ├── player
│   │   │   │   └── player.h
│   │   │   └── world
│   │   │       └── world.h
│   │   ├── game_framework
│   │   │   ├── actor
│   │   │   │   ├── actor.cpp
│   │   │   │   └── actor.h
│   │   │   ├── controller
│   │   │   │   └── controller.h
│   │   │   ├── game_state_base
│   │   │   │   └── game_state_base.h
│   │   │   ├── pawn
│   │   │   │   └── pawn.h
│   │   │   ├── player_controller
│   │   │   │   ├── player_controller.cpp
│   │   │   │   └── player_controller.h
│   │   │   └── player_state
│   │   │       └── player_state.h
│   │   ├── math
│   │   │   ├── color.h
│   │   │   ├── matrix.h
│   │   │   ├── rotator.h
│   │   │   ├── vector.h
│   │   │   └── vector_2d.h
│   │   ├── sdk.cpp
│   │   └── sdk.h
│   ├── ue4_base.cpp
│   ├── ue4_base.vcxproj
│   ├── ue4_base.vcxproj.filters
│   ├── ue4_base.vcxproj.user
│   └── utils
│       ├── libraries
│       │   ├── lazy_importer.h
│       │   ├── minhook
│       │   └── xor.h
│       ├── utils.cpp
│       └── utils.h
└── ue4_base.sln

```

`readme.md`:

```md
# ue4_base
unreal engine 4 base for cheating purposes

## tutorial
[<img src="https://i9.ytimg.com/vi_webp/D0ArJJYcPfE/mqdefault.webp?sqp=CNTPs5EG&rs=AOn4CLCI7_eTn6e4MbZ_yslRGNnVIlPy_Q">](https://youtu.be/D0ArJJYcPfE)

## libraries used
[lazy_importer](https://github.com/JustasMasiulis/lazy_importer) <br>
[minhook](https://github.com/TsudaKageyu/minhook) <br>
[xorstr](https://github.com/JustasMasiulis/xorstr)
```

`ue4_base.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.32126.317
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ue4_base", "ue4_base/ue4_base.vcxproj", "{B479C0F2-2A5A-400A-90BE-D2A1F8E9341B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B479C0F2-2A5A-400A-90BE-D2A1F8E9341B}.Debug|x64.ActiveCfg = Debug|x64
		{B479C0F2-2A5A-400A-90BE-D2A1F8E9341B}.Debug|x64.Build.0 = Debug|x64
		{B479C0F2-2A5A-400A-90BE-D2A1F8E9341B}.Release|x64.ActiveCfg = Release|x64
		{B479C0F2-2A5A-400A-90BE-D2A1F8E9341B}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {99FA59A6-F0D3-43D7-9635-A8FBEA07178A}
	EndGlobalSection
EndGlobal

```

`ue4_base/hooks/hooks.cpp`:

```cpp
#include <includes.h>
#include "hooks.h"

bool hooks::initialize() {
	const auto world = *reinterpret_cast<decltype(ue4::engine::world)*>(ue4::engine::world);
	if (!world) return false;

	const auto local_player = world->owning_game_instance->local_players[0];
	if (!local_player) return false;

	const auto viewport_client = local_player->viewport_client;
	if (!viewport_client) return false;

	void** viewport_client_vtable = viewport_client->vf_table;
	if (!viewport_client_vtable) return false;

	if (MH_Initialize() != MH_OK) throw std::runtime_error("failed to initialize min_hook");

	if (MH_CreateHook(viewport_client_vtable[hooks::post_render::index], &hooks::post_render::hook, reinterpret_cast<void**>(&hooks::post_render::original)) != MH_OK) {
		throw std::runtime_error("failed to hook post_render");
	}

	if (MH_EnableHook(nullptr) != MH_OK) throw std::runtime_error(_("failed to initialize hooks"));

	return true;
}

bool hooks::release() {
	MH_Uninitialize();

	MH_DisableHook(nullptr);
	MH_RemoveHook(nullptr);

	utils::console::release();

	return true;
}
```

`ue4_base/hooks/hooks.h`:

```h
#pragma once

namespace hooks {
	bool initialize();
	bool release();
}

namespace hooks::post_render {
	static constexpr auto index = 0x62;
	using fn = void(__thiscall*)(ue4::core_object::u_object*, ue4::engine::u_canvas*);
	inline fn original;
	void __stdcall hook(ue4::core_object::u_object* viewport_client, ue4::engine::u_canvas* canvas);
}
```

`ue4_base/hooks/post_render/post_render.cpp`:

```cpp
#include <includes.h>
#include "../hooks.h"

void __stdcall hooks::post_render::hook(ue4::core_object::u_object* viewport_client, ue4::engine::u_canvas* canvas) {
	render::canvas = canvas;

	render::text({ 50.f, 50.f }, L"ue4_base", { 1.f, 1.f, 1.f, 1.f });

	const auto world = *reinterpret_cast<decltype(ue4::engine::world)*>(ue4::engine::world);
	if (!world) return;

	const auto local_player = world->owning_game_instance->local_players[0];
	if (!local_player) return;

	const auto player_controller = local_player->player_controller;
	if (!player_controller) return;

	const auto my_player = player_controller->acknowledged_pawn;
	if (!my_player) return;

	auto actors = world->persistent_level->actors;
	for (auto i = 0; i < actors.size(); i++) {
		const auto actor = actors[i];
		if (!actor || !actor->root_component) continue;
		if (actor == my_player) continue;

		const auto get_name = actor->get_name();
		const auto name = std::wstring(get_name.begin(), get_name.end());

		const auto location = actor->get_location();

		ue4::math::vector_2d position{};
		if (player_controller->world_to_screen(location, position)) {
			render::text(position, name.c_str(), { 1.f, 1.f, 1.f, 1.f });
		}
	}

	hooks::post_render::original(viewport_client, canvas);
}
```

`ue4_base/includes.h`:

```h
#pragma once

#include <Windows.h>
#include <iostream>
#include <string>
#include <cstdint>
#include <algorithm>
#include <iomanip>
#include <list>
#include <sstream>
#include <mutex>
#include <utility>
#include <cstdint>
#include <future>

#include "utils/utils.h"
#include "utils/libraries/minhook/include/MinHook.h"
#include "utils/libraries/xor.h"
#include "utils/libraries/lazy_importer.h"

#include "ue4/sdk.h"

#include "ue4/math/vector.h"
#include "ue4/math/vector_2d.h"
#include "ue4/math/rotator.h"
#include "ue4/math/color.h"
#include "ue4/math/matrix.h"
#include "ue4/containers/array.h"
#include "ue4/containers/string.h"
#include "ue4/containers/enum_as_byte.h"

#include "ue4/engine/world/world.h"
#include "ue4/core_object/name/name.h"
#include "ue4/core_object/object/object.h"

#include "ue4/core_object/field/field.h"
#include "ue4/core_object/struct/struct.h"
#include "ue4/core_object/class/class.h"
#include "ue4/engine/canvas/canvas.h"
#include "ue4/engine/game_instance/game_instance.h"
#include "ue4/engine/player/player.h"
#include "ue4/engine/level/level.h"
#include "ue4/game_framework/actor/actor.h"
#include "ue4/game_framework/pawn/pawn.h"
#include "ue4/game_framework/controller/controller.h"
#include "ue4/game_framework/player_controller/player_controller.h"
#include "ue4/game_framework/player_state/player_state.h"
#include "ue4/game_framework/game_state_base/game_state_base.h"
#include "ue4/components/scene_component/scene_component.h"
#include "ue4/components/skeletal_mesh_component/skeletal_mesh_component.h"

#include "render/render.h"
```

`ue4_base/render/render.cpp`:

```cpp
#include <includes.h>

void render::text(const ue4::math::vector_2d position, const ue4::containers::f_string text, const ue4::math::color color) {
	if (canvas) {
		canvas->draw_text(text, position, { 1.f, 1.f }, color, 1.f, ue4::math::color(), ue4::math::vector_2d(), true, false, true, { 0.f, 0.f, 0.f, 1.f });
	}
}

void render::circle(const ue4::math::vector_2d position, const float radius, const ue4::math::color color) {
	if (canvas) {
		constexpr float step = 3.14f / 16;

		for (auto i = 0.f; i < 2.f * 3.14f; i += step) {
			const ue4::math::vector_2d from{ position.x + std::cosf(i - step) * radius, position.y + std::sinf(i - step) * radius };
			const ue4::math::vector_2d to{ position.x + std::cosf(i) * radius, position.y + std::sinf(i) * radius };

			render::line(from, to, 1.f, color);
		}
	}
}

void render::filled_circle(const ue4::math::vector_2d position, const float radius, const ue4::math::color color) {
	if (canvas) {
		canvas->draw_polygon(nullptr, position, { radius, radius }, 32, color);
	}
}

void render::line(const ue4::math::vector_2d position_1, const ue4::math::vector_2d position_2, const float thickness, const ue4::math::color color) {
	if (canvas) {
		canvas->draw_line(position_1, position_2, thickness, color);
	}
}

ue4::math::vector_2d render::text_size(const ue4::containers::f_string text) {
	if (canvas) {
		const auto text_size = canvas->text_size(text, { 1.f, 1.f });
		return { text_size.x, text_size.y };
	}

	return { 0, 0 };
}
```

`ue4_base/render/render.h`:

```h
#pragma once

namespace render {
	inline ue4::engine::u_canvas* canvas;
	inline ue4::math::vector_2d screen{ 0.f, 0.f };

	void text(ue4::math::vector_2d position, ue4::containers::f_string text, ue4::math::color color);
	void circle(ue4::math::vector_2d position, float radius, ue4::math::color color);
	void filled_circle(ue4::math::vector_2d position, float radius, ue4::math::color color);
	void line(ue4::math::vector_2d position_1, ue4::math::vector_2d position_2, float thickness, ue4::math::color color);
	ue4::math::vector_2d text_size(ue4::containers::f_string text);
}
```

`ue4_base/ue4/components/scene_component/scene_component.h`:

```h
#pragma once

namespace ue4::components {
	class u_scene_component{
	public:
		char pad_0001[0x11c]; // 0x00(0x11c)
		ue4::math::vector relative_location; // 0x11c(0x0c)
		ue4::math::rotator relative_rotation; // 0x128(0x0c)
	};
}
```

`ue4_base/ue4/components/skeletal_mesh_component/skeletal_mesh_component.cpp`:

```cpp
#include <includes.h>

ue4::core_object::u_name ue4::components::u_skeletal_mesh_component::get_bone_name(const int index) {
	struct {
		int index;
		ue4::core_object::u_name return_value;
	} params{};

	params.index = index;

	ue4::sdk::process_event(this, ue4::sdk::get_bone_name, &params);

	return params.return_value;
}

ue4::math::vector ue4::components::u_skeletal_mesh_component::get_bone_matrix(const int index) {
	const auto fn = reinterpret_cast<ue4::math::matrix * (*)(ue4::components::u_skeletal_mesh_component*, ue4::math::matrix*, int)>(ue4::sdk::bone_matrix);

	ue4::math::matrix matrix{};
	fn(this, &matrix, index);

	return ue4::math::vector({ matrix.m[3][0], matrix.m[3][1], matrix.m[3][2] });
}

ue4::math::vector_2d ue4::components::u_skeletal_mesh_component::get_bone(const int index, ue4::game_framework::a_player_controller* player_controller) {
	const auto world = this->get_bone_matrix(index);
	ue4::math::vector_2d screen{};

	if (player_controller->world_to_screen(world, screen)) {
		if (screen.x != 0.f && screen.y != 0.f) return screen;
	}

	return { 0.f,0.f };
}

void ue4::components::u_skeletal_mesh_component::dump_bones() {
	for (auto i = 0; i < 200; i++) {
		std::string bone_name = this->get_bone_name(i).get_name();
		if (bone_name.find("None") != std::string::npos) break;

		std::ranges::transform(bone_name.begin(), bone_name.end(), bone_name.begin(), ::tolower);
		std::cout << bone_name << " = " << i << "," << std::endl;
	}
}
```

`ue4_base/ue4/components/skeletal_mesh_component/skeletal_mesh_component.h`:

```h
#pragma once

namespace ue4::components {
	class u_skeletal_mesh_component : ue4::core_object::u_object {
		ue4::core_object::u_name get_bone_name(int index);
		ue4::math::vector get_bone_matrix(int index);
		ue4::math::vector_2d get_bone(int index, ue4::game_framework::a_player_controller* player_controller);
		void dump_bones();
	};
}
```

`ue4_base/ue4/containers/array.h`:

```h
#pragma once

namespace ue4::containers {
	template<class T>
	class t_array {
		friend class f_string;
	public:
		T& operator[](int i) {
			return data[i];
		}

		int size() const {
			return count;
		}

		bool is_valid(const int i) const {
			return i < size();
		}
	private:
		T* data;
		std::int32_t count;
		std::int32_t max;
	};
}
```

`ue4_base/ue4/containers/enum_as_byte.h`:

```h
#pragma once

namespace ue4::containers {
	template<class T>
	class t_enum_as_byte {
	public:
		t_enum_as_byte() {}
		t_enum_as_byte(T _value) : value(static_cast<std::uint8_t>(_value)) {}
		explicit t_enum_as_byte(const std::int32_t _value) : value(static_cast<std::uint8_t>(_value)) {}
		explicit t_enum_as_byte(const std::uint8_t _value) : value(_value) {}

		operator T() const {
			return static_cast<T>(value);
		}

		T get_value() const {
			return static_cast<T>(value);
		}

	private:
		std::uint8_t value;
	};
}
```

`ue4_base/ue4/containers/string.h`:

```h
#pragma once

namespace ue4::containers {
	class f_string : ue4::containers::t_array<wchar_t> {
	public:
		f_string() = default;
		f_string(const wchar_t* other) {
			max = count = *other ? std::wcslen(other) + 1 : 0;

			if (count) {
				data = const_cast<wchar_t*>(other);
			}
		}

		bool is_valid() const {
			return data != nullptr;
		}

		const wchar_t* c_str() const {
			return data;
		}

		std::string to_string() const {
			const auto length = std::wcslen(data);

			std::string str(length, '\0');
			std::use_facet<std::ctype<wchar_t>>(std::locale()).narrow(data, data + length, '?', &str[0]);

			return str;
		}
	};
}
```

`ue4_base/ue4/core_object/class/class.h`:

```h
#pragma once

namespace ue4::core_object {
	class u_class : public ue4::core_object::u_struct {
	public:
		char pad_0001[0x180]; // 0xb8(0x180)
	};
}
```

`ue4_base/ue4/core_object/field/field.h`:

```h
#pragma once

namespace ue4::core_object {
	class u_field : public ue4::core_object::u_object {
	public:
		char pad_0001[0x08]; // 0x28(0x08)
	};
}
```

`ue4_base/ue4/core_object/name/name.cpp`:

```cpp
#include <includes.h>

std::string ue4::core_object::u_name_entry::string() const {
	if (is_wide) {
		return std::string{};
	}

	return { ansi_name, len };
}

ue4::core_object::u_name_entry* ue4::core_object::u_name_pool::get_entry(const ue4::core_object::u_name_entry_handle handle) const {
	return reinterpret_cast<ue4::core_object::u_name_entry*>(blocks[handle.block] + stride * static_cast<std::uint64_t>(handle.offset));
}

std::string ue4::core_object::u_name::get_name() const {
	const auto entry = ue4::core_object::names->get_entry(index);

	auto name = entry->string();
	if (number > 0) {
		name += '_' + std::to_string(number);
	}

	const auto pos = name.rfind('/');
	if (pos != std::string::npos) {
		name = name.substr(pos + 1);
	}

	return name;
}
```

`ue4_base/ue4/core_object/name/name.h`:

```h
#pragma once

namespace ue4::core_object {
	class u_name_entry_handle {
	public:
		std::uint32_t block = 0;
		std::uint32_t offset = 0;

		u_name_entry_handle(const std::uint32_t block, const std::uint32_t offset) : block(block), offset(offset) {}
		u_name_entry_handle(std::uint32_t id) : block(id >> 16), offset(id & 65535) {}

		operator std::uint32_t() const {
			return (block << 16 | offset);
		}
	};

	class u_name_entry {
	public:
	#ifdef with_case_preserving_name
		std::uint32_t comparison_id;
		std::uint16_t is_wide : 1;
		std::uint16_t len : 15;
	#else
		std::uint16_t is_wide : 1;
		std::uint16_t lowercase_probe_hash : 5;
		std::uint16_t len : 10;
	#endif

		union {
			char ansi_name[1024];
			wchar_t wide_name[1024];
		};

		std::string string() const;
	};

	class u_name_pool {
	public:
		unsigned char lock[8];
	#ifdef with_case_preserving_name
		static constexpr int stride = 0x04;
	#else
		static constexpr int stride = 0x02;
	#endif
		std::uint32_t current_block;
		std::uint32_t current_byte_cursor;
		unsigned char* blocks[8192];

		ue4::core_object::u_name_entry* get_entry(ue4::core_object::u_name_entry_handle handle) const;
	};

	class u_name {
		friend class u_object;
	public:
	#ifdef with_case_preserving_name
		std::uint32_t comparison_index;
	#endif
		std::uint32_t index;
		std::uint32_t number;

		std::string get_name() const;
	};

	inline ue4::core_object::u_name_pool* names;
}
```

`ue4_base/ue4/core_object/object/object.cpp`:

```cpp
#include <includes.h>

std::string ue4::core_object::u_object::get_name() const {
	return name.get_name();
}

std::string ue4::core_object::u_object::get_full_name() const {
	std::string name;
	for (auto _outer = outer; _outer; _outer = _outer->outer) {
		name = _outer->get_name() + "." + name;
	}

	name = _class->get_name() + " " + name + this->get_name();
	return name;
}

bool ue4::core_object::u_object::is_a(void* cmp) const {
	for (auto super = _class; super; super = reinterpret_cast<ue4::core_object::u_class*>(super->super_struct)) {
		if (super == cmp) {
			return true;
		}
	}

	return false;
}

ue4::core_object::u_object* ue4::core_object::object_array::find(const char* name) const {
	for (auto i = 0u; i < num_elements; i++) {
		const auto object = get(i);
		if (object && object->get_full_name() == name) {
			return object;
		}
	}

	return nullptr;
}

ue4::core_object::u_object* ue4::core_object::object_array::get(const std::uint32_t id) const {
	if (id >= num_elements) return nullptr;

	const std::uint64_t chunk_index = id / 65536;
	if (chunk_index >= num_chunks) return nullptr;

	const auto chunk = objects[chunk_index];
	if (!chunk) return nullptr;

	const std::uint32_t within_chhunk_index = id % 65536 * 24;
	const auto item = *reinterpret_cast<ue4::core_object::u_object**>(chunk + within_chhunk_index);

	return item;
}

void ue4::sdk::process_event(void* object, void* u_function, void* params) {
	const auto vtable = *static_cast<void***>(object);
	reinterpret_cast<void(*)(void*, void*, void*)>(vtable[0x43])(object, u_function, params);
}
```

`ue4_base/ue4/core_object/object/object.h`:

```h
#pragma once

namespace ue4::core_object {
	class object_array;
	class u_class;

	class u_object {
		friend class object_array;
	public:
		static ue4::core_object::object_array* objects;
		void** vf_table; // 0x00(0x08)
		std::int32_t flags; // 0x08(0x04)
		std::int32_t internal_index; // 0xc(0x4)
		ue4::core_object::u_class* _class; // 0x10(0x8)
		ue4::core_object::u_name name; // 0x18(0x8)
		ue4::core_object::u_object* outer; // 0x20(0x8)

		std::string get_name() const;
		std::string get_full_name() const;
		bool is_a(void* cmp) const;
	};

	class object_array {
	public:
		unsigned char** objects;
		unsigned char* pre_allocated_objects;
		std::uint32_t max_elements;
		std::uint32_t num_elements;
		std::uint32_t max_chunks;
		std::uint32_t num_chunks;

		ue4::core_object::u_object* get(std::uint32_t id) const;
		ue4::core_object::u_object* find(const char* name) const;
	};

	inline ue4::core_object::object_array* objects;
}
```

`ue4_base/ue4/core_object/struct/struct.h`:

```h
#pragma once

namespace ue4::core_object {
	class u_struct : public ue4::core_object::u_field {
	public:
		char pad_0001[0x10]; // 0x30(0x10)
		ue4::core_object::u_struct* super_struct; // 0x40(0x8)
		char pad_0002[0x68]; // 0x48(0x80)
	};
}
```

`ue4_base/ue4/engine/canvas/canvas.cpp`:

```cpp
#include <includes.h>

void ue4::engine::u_canvas::draw_box(const ue4::math::vector_2d& screen, const ue4::math::vector_2d& size, const float thickness, const ue4::math::color& color) {
	struct {
		ue4::math::vector_2d screen{};
		ue4::math::vector_2d size{};
		float thickness{};
		ue4::math::color color{};
	} params;

	params.screen = screen;
	params.size = size;
	params.thickness = thickness;
	params.color = color;

	const auto flags = ue4::sdk::draw_box->flags;
	ue4::sdk::draw_box->flags |= 0x00000400;

	ue4::sdk::process_event(this, ue4::sdk::draw_box, &params);
	ue4::sdk::draw_box->flags = flags;
}

void ue4::engine::u_canvas::draw_line(const ue4::math::vector_2d screen_a, const ue4::math::vector_2d screen_b, const float thickness, const ue4::math::color color) {
	struct {
		ue4::math::vector_2d screen_a{};
		ue4::math::vector_2d screen_b{};
		float thickness{};
		ue4::math::color color{};
	} params{};

	params.screen_a = screen_a;
	params.screen_b = screen_b;
	params.thickness = thickness;
	params.color = color;

	ue4::sdk::process_event(this, ue4::sdk::draw_line, &params);
}

void ue4::engine::u_canvas::draw_text(const ue4::containers::f_string text, const ue4::math::vector_2d screen, const ue4::math::vector_2d scale, const ue4::math::color color, const float kerning, const ue4::math::color shadow_color, const ue4::math::vector_2d shadow_offset, const bool center_x, const bool center_y, const bool outlined, const ue4::math::color outline_color) {
	struct {
		ue4::core_object::u_object* font{};
		ue4::containers::f_string text;
		ue4::math::vector_2d screen{};
		ue4::math::vector_2d scale{};
		ue4::math::color color{};
		float kerning{};
		ue4::math::color shadow_color{};
		ue4::math::vector_2d shadow_offset{};
		bool center_x{};
		bool center_y{};
		bool outlined{};
		ue4::math::color outline_color{};
	} params{};

	params.font = ue4::sdk::font;
	params.text = text;
	params.screen = screen;
	params.scale = scale;
	params.color = color;
	params.kerning = kerning;
	params.shadow_color = shadow_color;
	params.shadow_offset = shadow_offset;
	params.center_x = center_x;
	params.center_y = center_y;
	params.outlined = outlined;
	params.outline_color = outline_color;

	ue4::sdk::process_event(this, ue4::sdk::draw_text, &params);
}

void ue4::engine::u_canvas::draw_polygon(class u_texture* texture, const ue4::math::vector_2d& screen, const ue4::math::vector_2d& radius, const int side_number, const ue4::math::color& color) {
	struct {
		class u_texture* texture{};
		ue4::math::vector_2d screen{};
		ue4::math::vector_2d radius{};
		int side_number{};
		ue4::math::color color{};
	} params{};

	params.texture = texture;
	params.screen = screen;
	params.radius = radius;
	params.side_number = side_number;
	params.color = color;

	const auto flags = ue4::sdk::draw_polygon->flags;
	ue4::sdk::draw_polygon->flags |= 0x00000400;

	ue4::sdk::process_event(this, ue4::sdk::draw_polygon, &params);
	ue4::sdk::draw_polygon->flags = flags;
}

ue4::math::vector_2d ue4::engine::u_canvas::text_size(const ue4::containers::f_string& text, const ue4::math::vector_2d& scale) {
	struct {
		ue4::core_object::u_object* font;
		ue4::containers::f_string text;
		ue4::math::vector_2d scale;
		ue4::math::vector_2d return_value;
	} params{};

	params.font = ue4::sdk::font;
	params.text = text;
	params.scale = scale;

	const auto flags = ue4::sdk::text_size->flags;
	ue4::sdk::text_size->flags |= 0x00000400;

	ue4::sdk::process_event(this, ue4::sdk::text_size, &params);
	ue4::sdk::text_size->flags = flags;

	return params.return_value;
}
```

`ue4_base/ue4/engine/canvas/canvas.h`:

```h
#pragma once

namespace ue4::engine {
	class u_canvas : public ue4::core_object::u_object {
	public:
		void draw_box(const ue4::math::vector_2d& screen, const ue4::math::vector_2d& size, float thickness, const ue4::math::color& color);
		void draw_line(ue4::math::vector_2d screen_a, ue4::math::vector_2d screen_b, float thickness, ue4::math::color color);
		void draw_text(ue4::containers::f_string text, ue4::math::vector_2d screen, ue4::math::vector_2d scale, ue4::math::color color, float kerning, ue4::math::color shadow_color, ue4::math::vector_2d shadow_offset, bool center_x, bool center_y, bool outlined, ue4::math::color outline_color);
		void draw_polygon(class u_texture* texture, const ue4::math::vector_2d& screen, const ue4::math::vector_2d& radius, int side_number, const ue4::math::color& color);
		ue4::math::vector_2d text_size(const ue4::containers::f_string& text, const ue4::math::vector_2d& scale);
	};
}
```

`ue4_base/ue4/engine/game_instance/game_instance.h`:

```h
#pragma once

namespace ue4::engine {
	class u_game_instance {
	public:
		char pad_0001[0x38]; // 0x00(0x38)
		ue4::containers::t_array<class u_player*> local_players; // 0x38(0x10)
	};
}
```

`ue4_base/ue4/engine/level/level.h`:

```h
#pragma once

namespace ue4::game_framework {
	class a_actor;
}

namespace ue4::engine {
	class u_level {
	public:
		char pad_0001[0x98]; // 0x00(0x98)
		ue4::containers::t_array<ue4::game_framework::a_actor*> actors; // 0x98(0x10)
	};
}
```

`ue4_base/ue4/engine/player/player.h`:

```h
#pragma once

namespace ue4::game_framework {
	class a_player_controller;
}

namespace ue4::engine {
	class u_player {
	public:
		char pad_0001[0x30]; // 0x00(0x30)
		ue4::game_framework::a_player_controller* player_controller; // 0x30(0x08)
		char pad_0002[0x38]; // 0x38(0x38)
		ue4::core_object::u_object* viewport_client; // 0x70(0x08)
	};
}
```

`ue4_base/ue4/engine/world/world.h`:

```h
#pragma once

namespace ue4::game_framework {
	class a_game_state_base;
}

namespace ue4::engine {
	class u_level;
	class u_game_instance;

	class u_world {
	public:
		char pad_0001[0x30]; // 0x00(0x30)
		ue4::engine::u_level* persistent_level; // 0x30(0x08)
		char pad_0002[0xE8]; // 0x38(0xE8)
		ue4::game_framework::a_game_state_base* game_state; // 0x120(0x08)
		char pad_0003[0x10]; // 0x128(0x10)
		ue4::containers::t_array<ue4::engine::u_level*> levels; // 0x138(0x10)
		char pad_0004[0x38]; // 0x148(0x38)
		ue4::engine::u_game_instance* owning_game_instance; // 0x180(0x08)
	};

	inline u_world* world;
}
```

`ue4_base/ue4/game_framework/actor/actor.cpp`:

```cpp
#include <includes.h>

ue4::math::vector ue4::game_framework::a_actor::get_location() {
	struct {
		ue4::math::vector return_value;
	} params{};

	ue4::sdk::process_event(this, ue4::sdk::get_actor_location, &params);

	return params.return_value;
}

ue4::math::rotator ue4::game_framework::a_actor::get_rotation() {
	struct {
		ue4::math::rotator return_value;
	} params{};

	const auto flags = ue4::sdk::get_actor_rotation->flags;
	ue4::sdk::get_actor_rotation->flags |= 0x00000400;

	ue4::sdk::process_event(this, ue4::sdk::get_actor_rotation, &params);
	ue4::sdk::get_actor_rotation->flags = flags;

	return params.return_value;
}

void ue4::game_framework::a_actor::get_bounds(const bool only_colliding_components, ue4::math::vector* origin, ue4::math::vector* extent) {
	struct {
		bool only_colliding_components;
		ue4::math::vector origin;
		ue4::math::vector extent;
	} params{};

	params.only_colliding_components = only_colliding_components;

	ue4::sdk::process_event(this, ue4::sdk::get_actor_bounds, &params);

	if (origin != nullptr)
		*origin = params.origin;

	if (extent != nullptr)
		*extent = params.extent;
}

float ue4::game_framework::a_actor::get_distance_to(ue4::game_framework::a_actor* actor) {
	struct {
		ue4::game_framework::a_actor* actor;
		float return_value;
	} params{};

	params.actor = actor;

	ue4::sdk::process_event(this, ue4::sdk::get_distance_to, &params);

	return params.return_value;
}
```

`ue4_base/ue4/game_framework/actor/actor.h`:

```h
#pragma once

namespace ue4::core_object {
	class u_object;
}

namespace ue4::components {
	class u_scene_component;
}

namespace ue4::game_framework {
	class a_pawn;

	class a_actor : public ue4::core_object::u_object {
	public:
		char pad_0001[0xF0]; // 0x28(0xF0)
		ue4::game_framework::a_pawn* instigator; // 0x118(0x08)
		char pad_0002[0x10]; // 0x120(0x10)
		ue4::components::u_scene_component* root_component; // 0x130(0x08)

		ue4::math::vector get_location();
		ue4::math::rotator get_rotation();
		void get_bounds(bool only_colliding_components, ue4::math::vector* origin, ue4::math::vector* extent);
		float get_distance_to(ue4::game_framework::a_actor* actor);
	};
}
```

`ue4_base/ue4/game_framework/controller/controller.h`:

```h
#pragma once

namespace ue4::game_framework {
	class a_player_state;

	class a_controller : public ue4::game_framework::a_actor {
	public:
		char pad_0001[0xf0]; // 0x138(0xf0)
		ue4::game_framework::a_player_state* player_state; // 0x228(0x08)
	};
}
```

`ue4_base/ue4/game_framework/game_state_base/game_state_base.h`:

```h
#pragma once

namespace ue4::game_framework {
	class a_game_state_base {
	public:
		char pad_0001[0x238]; // 0x00(0x238)
		ue4::containers::t_array <ue4::game_framework::a_player_state*> player_array; // 0x238(0x10)
	};
}
```

`ue4_base/ue4/game_framework/pawn/pawn.h`:

```h
#pragma once

namespace ue4::components {
	class u_skeletal_mesh_component;
}

namespace ue4::game_framework {
	class a_player_state;

	class a_pawn : public ue4::game_framework::a_actor {
	public:
		char pad_0001[0x108]; // 0x138(0x108)
		ue4::game_framework::a_player_state* player_state; // 0x240(0x08)
		char pad_0002[0x38]; // 0x248(0x38)
		ue4::components::u_skeletal_mesh_component* mesh; // 0x280(0x08)
	};
}
```

`ue4_base/ue4/game_framework/player_controller/player_controller.cpp`:

```cpp
#include <includes.h>

bool ue4::game_framework::a_player_controller::world_to_screen(const ue4::math::vector& world, ue4::math::vector_2d& screen) {
	struct {
		ue4::math::vector world;
		ue4::math::vector_2d screen;
		bool player_viewport_relative;
		bool return_value;
	} params{};

	params.world = world;
	params.screen = screen;
	params.player_viewport_relative = false;

	ue4::sdk::process_event(this, ue4::sdk::world_to_screen, &params);

	screen = params.screen;

	return params.return_value;
}
```

`ue4_base/ue4/game_framework/player_controller/player_controller.h`:

```h
#pragma once

namespace ue4::game_framework {
	class a_player_controller : public ue4::game_framework::a_controller {
	public:
		char pad_0001[0x68]; // 0x230(0x68)
		ue4::engine::u_player* player; // 0x298(0x08)
		ue4::game_framework::a_pawn* acknowledged_pawn; // 0x2a0(0x08)

		bool world_to_screen(const ue4::math::vector& world, ue4::math::vector_2d& screen);
	};
}
```

`ue4_base/ue4/game_framework/player_state/player_state.h`:

```h
#pragma once

namespace ue4::game_framework {
	class a_player_state : public ue4::game_framework::a_actor {
	public:
		char pad_0001[0x148]; // 0x138(0x148)
		ue4::game_framework::a_pawn* pawn_private; // 0x280(0x08)
		char pad_0002[0x78]; // 0x288(0x78)
		ue4::containers::f_string player_name_private; // 0x300(0x10)
	};
}
```

`ue4_base/ue4/math/color.h`:

```h
#pragma once

namespace ue4::math {
	class color {
	public:
		float r, g, b, a;

		color() : r{ 0.f }, g{ 0.f }, b{ 0.f }, a{ 0.f } { }
		color(const float r, const float g, const float b, const float a) : r{ r }, g{ g }, b{ b }, a{ a } { }
	};
}
```

`ue4_base/ue4/math/matrix.h`:

```h
#pragma once

namespace ue4::math {
	class matrix {
	public:
		float m[4][4];
	};
}
```

`ue4_base/ue4/math/rotator.h`:

```h
#pragma once

namespace ue4::math {
	class rotator {
	public:
		float x, y, z;
	};
}
```

`ue4_base/ue4/math/vector.h`:

```h
#pragma once

namespace ue4::math {
	class vector {
	public:
		float x, y, z;
	};
}
```

`ue4_base/ue4/math/vector_2d.h`:

```h
#pragma once

namespace ue4::math {
	class vector_2d {
	public:
		float x, y;

		bool is_zero() const {
			if (x == 0.f && y == 0.f) return true;

			return false;
		}
	};
}
```

`ue4_base/ue4/sdk.cpp`:

```cpp
#include <includes.h>

bool ue4::sdk::initialize() {
	const auto main = reinterpret_cast<std::uintptr_t>(LI_FN(GetModuleHandleA)(nullptr));
	if (!main) return false;

	ue4::core_object::names = reinterpret_cast<decltype(ue4::core_object::names)>(utils::pattern_scan(main, _("48 8D 05 ? ? ? ? EB 13 48 8D 0D ? ? ? ? E8 ? ? ? ? C6 05 ? ? ? ? ? 0F 10"), true));
	if (!ue4::core_object::names) throw std::runtime_error(_("failed to get ue4::core_object::names"));

	ue4::core_object::objects = reinterpret_cast<decltype(ue4::core_object::objects)>(utils::pattern_scan(main, _("48 8B 05 ? ? ? ? 48 8B 0C C8 4C 8D 04 D1 EB 03"), true));
	if (!ue4::core_object::objects) throw std::runtime_error(_("failed to get ue4::core_object::objects"));

	ue4::engine::world = reinterpret_cast<decltype(ue4::engine::world)>(utils::pattern_scan(main, _("48 8B 1D ? ? ? ? 48 85 DB 74 3B 41 B0 01 33 D2 48 8B CB E8"), true));
	if (!ue4::engine::world) throw std::runtime_error(_("failed to get ue4::engine::world"));

	ue4::sdk::bone_matrix = utils::pattern_scan(main, _("48 8B C4 48 89 58 08 48 89 70 10 57 48 81 EC ? ? ? ? F6"));
	if (!sdk::bone_matrix) throw std::runtime_error(_("failed to get ue4::sdk::bone_matrix"));

	// u_canvas
	ue4::sdk::font = ue4::core_object::objects->find("Font Roboto.Roboto");
	ue4::sdk::draw_box = ue4::core_object::objects->find("Function Engine.Canvas.K2_DrawBox");
	ue4::sdk::draw_line = ue4::core_object::objects->find("Function Engine.Canvas.K2_DrawLine");
	ue4::sdk::draw_text = ue4::core_object::objects->find("Function Engine.Canvas.K2_DrawText");
	ue4::sdk::draw_polygon = ue4::core_object::objects->find("Function Engine.Canvas.K2_DrawPolygon");
	ue4::sdk::text_size = ue4::core_object::objects->find("Function Engine.Canvas.K2_TextSize");

	// a_player_controller
	ue4::sdk::world_to_screen = ue4::core_object::objects->find("Function Engine.PlayerController.ProjectWorldLocationToScreen");

	// a_actor
	ue4::sdk::get_actor_location = ue4::core_object::objects->find("Function Engine.Actor.K2_GetActorLocation");
	ue4::sdk::get_actor_rotation = ue4::core_object::objects->find("Function Engine.Actor.K2_GetActorRotation");
	ue4::sdk::get_actor_bounds = ue4::core_object::objects->find("Function Engine.Actor.GetActorBounds");
	ue4::sdk::get_distance_to = ue4::core_object::objects->find("Function Engine.Actor.GetDistanceTo");

	// u_skeletal_mesh_component
	ue4::sdk::get_bone_name = ue4::core_object::objects->find("Function Engine.SkinnedMeshComponent.GetBoneName");

	return true;
}

```

`ue4_base/ue4/sdk.h`:

```h
#pragma once

namespace ue4::core_object {
	class u_object;
}

namespace ue4::sdk {
	// u_canvas
	inline ue4::core_object::u_object* font;
	inline ue4::core_object::u_object* draw_box;
	inline ue4::core_object::u_object* draw_line;
	inline ue4::core_object::u_object* draw_text;
	inline ue4::core_object::u_object* draw_polygon;
	inline ue4::core_object::u_object* text_size;

	// a_player_controller
	inline ue4::core_object::u_object* world_to_screen;

	// a_actor
	inline ue4::core_object::u_object* get_actor_location;
	inline ue4::core_object::u_object* get_actor_rotation;
	inline ue4::core_object::u_object* get_actor_bounds;
	inline ue4::core_object::u_object* get_distance_to;

	// u_skeletal_mesh_component
	inline std::uintptr_t bone_matrix;
	inline ue4::core_object::u_object* get_bone_name;

	bool initialize();

	void process_event(void* object, void* u_function, void* params);
}

```

`ue4_base/ue4_base.cpp`:

```cpp
#include <includes.h>
#include "hooks/hooks.h"

void initialize(const HMODULE module) {
	try {
		// utils::console::initialize("ue4_base");
		ue4::sdk::initialize();
		hooks::initialize();
	}

	catch (const std::runtime_error& error) {
		LI_FN(MessageBoxA)(nullptr, error.what(), _("ue4_base"), MB_OK | MB_ICONERROR);
		LI_FN(FreeLibraryAndExitThread)(module, 0);
	}

	while (!LI_FN(GetAsyncKeyState)(VK_END)) {
		std::this_thread::sleep_for(std::chrono::milliseconds(50));
	}

	LI_FN(FreeLibraryAndExitThread)(module, 0);
}

bool DllMain(const HMODULE module, const std::uint32_t call_reason, void* reserved [[maybe_unused]] ) {
	LI_FN(DisableThreadLibraryCalls)(module);

	switch (call_reason) {
		case DLL_PROCESS_ATTACH:
			if (const auto handle = LI_FN(CreateThread)(nullptr, NULL, reinterpret_cast<unsigned long(__stdcall*)(void*)>(initialize), module, NULL, nullptr)) {
				LI_FN(CloseHandle)(handle);
			}
			break;
		case DLL_PROCESS_DETACH:
			hooks::release();
			break;
		default:
			break;
	}

	return true;
}
```

`ue4_base/ue4_base.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="hooks\hooks.cpp" />
    <ClCompile Include="hooks\post_render\post_render.cpp" />
    <ClCompile Include="render\render.cpp" />
    <ClCompile Include="ue4\components\skeletal_mesh_component\skeletal_mesh_component.cpp" />
    <ClCompile Include="ue4\core_object\name\name.cpp" />
    <ClCompile Include="ue4\core_object\object\object.cpp" />
    <ClCompile Include="ue4\engine\canvas\canvas.cpp" />
    <ClCompile Include="ue4\game_framework\actor\actor.cpp" />
    <ClCompile Include="ue4\game_framework\player_controller\player_controller.cpp" />
    <ClCompile Include="ue4\sdk.cpp" />
    <ClCompile Include="ue4_base.cpp" />
    <ClCompile Include="utils\libraries\minhook\src\buffer.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="utils\libraries\minhook\src\hde\hde32.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="utils\libraries\minhook\src\hde\hde64.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="utils\libraries\minhook\src\hook.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="utils\libraries\minhook\src\trampoline.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="utils\utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="hooks\hooks.h" />
    <ClInclude Include="includes.h" />
    <ClInclude Include="render\render.h" />
    <ClInclude Include="ue4\components\scene_component\scene_component.h" />
    <ClInclude Include="ue4\components\skeletal_mesh_component\skeletal_mesh_component.h" />
    <ClInclude Include="ue4\containers\array.h" />
    <ClInclude Include="ue4\containers\enum_as_byte.h" />
    <ClInclude Include="ue4\containers\string.h" />
    <ClInclude Include="ue4\core_object\class\class.h" />
    <ClInclude Include="ue4\core_object\field\field.h" />
    <ClInclude Include="ue4\core_object\name\name.h" />
    <ClInclude Include="ue4\core_object\object\object.h" />
    <ClInclude Include="ue4\core_object\struct\struct.h" />
    <ClInclude Include="ue4\engine\canvas\canvas.h" />
    <ClInclude Include="ue4\engine\game_instance\game_instance.h" />
    <ClInclude Include="ue4\engine\level\level.h" />
    <ClInclude Include="ue4\engine\player\player.h" />
    <ClInclude Include="ue4\engine\world\world.h" />
    <ClInclude Include="ue4\game_framework\actor\actor.h" />
    <ClInclude Include="ue4\game_framework\controller\controller.h" />
    <ClInclude Include="ue4\game_framework\game_state_base\game_state_base.h" />
    <ClInclude Include="ue4\game_framework\pawn\pawn.h" />
    <ClInclude Include="ue4\game_framework\player_controller\player_controller.h" />
    <ClInclude Include="ue4\game_framework\player_state\player_state.h" />
    <ClInclude Include="ue4\math\color.h" />
    <ClInclude Include="ue4\math\matrix.h" />
    <ClInclude Include="ue4\math\rotator.h" />
    <ClInclude Include="ue4\math\vector.h" />
    <ClInclude Include="ue4\math\vector_2d.h" />
    <ClInclude Include="ue4\sdk.h" />
    <ClInclude Include="utils\libraries\lazy_importer.h" />
    <ClInclude Include="utils\libraries\minhook\include\MinHook.h" />
    <ClInclude Include="utils\libraries\minhook\src\buffer.h" />
    <ClInclude Include="utils\libraries\minhook\src\hde\hde32.h" />
    <ClInclude Include="utils\libraries\minhook\src\hde\hde64.h" />
    <ClInclude Include="utils\libraries\minhook\src\hde\pstdint.h" />
    <ClInclude Include="utils\libraries\minhook\src\hde\table32.h" />
    <ClInclude Include="utils\libraries\minhook\src\hde\table64.h" />
    <ClInclude Include="utils\libraries\minhook\src\trampoline.h" />
    <ClInclude Include="utils\libraries\min_hook\buffer.h" />
    <ClInclude Include="utils\libraries\min_hook\hde\hde32.h" />
    <ClInclude Include="utils\libraries\min_hook\hde\hde64.h" />
    <ClInclude Include="utils\libraries\min_hook\hde\pstdint.h" />
    <ClInclude Include="utils\libraries\min_hook\hde\table32.h" />
    <ClInclude Include="utils\libraries\min_hook\hde\table64.h" />
    <ClInclude Include="utils\libraries\min_hook\trampoline.h" />
    <ClInclude Include="utils\libraries\xor.h" />
    <ClInclude Include="utils\utils.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{b479c0f2-2a5a-400a-90be-d2a1f8e9341b}</ProjectGuid>
    <RootNamespace>ue4_base</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>ue4_base</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)intermediates\</IntDir>
    <IncludePath>$(SolutionDir)ue4_base\;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <Optimization>MinSpace</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <PrecompiledHeaderFile>includes.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ue4_base/ue4_base.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="ue4_base.cpp" />
    <ClCompile Include="utils\utils.cpp" />
    <ClCompile Include="ue4\core_object\object\object.cpp" />
    <ClCompile Include="ue4\sdk.cpp" />
    <ClCompile Include="ue4\core_object\name\name.cpp" />
    <ClCompile Include="hooks\hooks.cpp" />
    <ClCompile Include="ue4\engine\canvas\canvas.cpp" />
    <ClCompile Include="ue4\game_framework\actor\actor.cpp" />
    <ClCompile Include="ue4\components\skeletal_mesh_component\skeletal_mesh_component.cpp" />
    <ClCompile Include="hooks\post_render\post_render.cpp" />
    <ClCompile Include="ue4\game_framework\player_controller\player_controller.cpp" />
    <ClCompile Include="render\render.cpp" />
    <ClCompile Include="utils\libraries\minhook\src\hde\hde32.c" />
    <ClCompile Include="utils\libraries\minhook\src\hde\hde64.c" />
    <ClCompile Include="utils\libraries\minhook\src\buffer.c" />
    <ClCompile Include="utils\libraries\minhook\src\hook.c" />
    <ClCompile Include="utils\libraries\minhook\src\trampoline.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes.h" />
    <ClInclude Include="utils\utils.h" />
    <ClInclude Include="utils\libraries\lazy_importer.h" />
    <ClInclude Include="utils\libraries\xor.h" />
    <ClInclude Include="utils\libraries\min_hook\hde\hde32.h" />
    <ClInclude Include="utils\libraries\min_hook\hde\hde64.h" />
    <ClInclude Include="utils\libraries\min_hook\hde\pstdint.h" />
    <ClInclude Include="utils\libraries\min_hook\hde\table32.h" />
    <ClInclude Include="utils\libraries\min_hook\hde\table64.h" />
    <ClInclude Include="utils\libraries\min_hook\buffer.h" />
    <ClInclude Include="utils\libraries\min_hook\trampoline.h" />
    <ClInclude Include="ue4\game_framework\actor\actor.h" />
    <ClInclude Include="ue4\core_object\object\object.h" />
    <ClInclude Include="ue4\core_object\class\class.h" />
    <ClInclude Include="ue4\core_object\struct\struct.h" />
    <ClInclude Include="ue4\core_object\field\field.h" />
    <ClInclude Include="ue4\core_object\name\name.h" />
    <ClInclude Include="ue4\sdk.h" />
    <ClInclude Include="ue4\engine\world\world.h" />
    <ClInclude Include="hooks\hooks.h" />
    <ClInclude Include="ue4\engine\canvas\canvas.h" />
    <ClInclude Include="ue4\math\vector.h" />
    <ClInclude Include="ue4\math\vector_2d.h" />
    <ClInclude Include="ue4\math\rotator.h" />
    <ClInclude Include="ue4\math\color.h" />
    <ClInclude Include="ue4\containers\array.h" />
    <ClInclude Include="ue4\containers\string.h" />
    <ClInclude Include="ue4\engine\game_instance\game_instance.h" />
    <ClInclude Include="ue4\engine\player\player.h" />
    <ClInclude Include="ue4\containers\enum_as_byte.h" />
    <ClInclude Include="ue4\game_framework\player_controller\player_controller.h" />
    <ClInclude Include="ue4\game_framework\controller\controller.h" />
    <ClInclude Include="ue4\game_framework\player_state\player_state.h" />
    <ClInclude Include="ue4\game_framework\pawn\pawn.h" />
    <ClInclude Include="ue4\components\skeletal_mesh_component\skeletal_mesh_component.h" />
    <ClInclude Include="ue4\math\matrix.h" />
    <ClInclude Include="ue4\components\scene_component\scene_component.h" />
    <ClInclude Include="ue4\engine\level\level.h" />
    <ClInclude Include="ue4\game_framework\game_state_base\game_state_base.h" />
    <ClInclude Include="render\render.h" />
    <ClInclude Include="utils\libraries\minhook\include\MinHook.h" />
    <ClInclude Include="utils\libraries\minhook\src\hde\hde32.h" />
    <ClInclude Include="utils\libraries\minhook\src\hde\hde64.h" />
    <ClInclude Include="utils\libraries\minhook\src\hde\pstdint.h" />
    <ClInclude Include="utils\libraries\minhook\src\hde\table32.h" />
    <ClInclude Include="utils\libraries\minhook\src\hde\table64.h" />
    <ClInclude Include="utils\libraries\minhook\src\buffer.h" />
    <ClInclude Include="utils\libraries\minhook\src\trampoline.h" />
  </ItemGroup>
</Project>
```

`ue4_base/ue4_base.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`ue4_base/utils/libraries/lazy_importer.h`:

```h
/*
 * Copyright 2018-2020 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 // documentation is available at https://github.com/JustasMasiulis/lazy_importer

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP

#define LI_FN(name) \
    ::li::detail::lazy_function<::li::detail::khash(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<::li::detail::khash(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<::li::detail::khash(name)>()

// NOTE only std::forward is used from this header.
// If there is a need to eliminate this dependency the function itself is very small.

#include <utility>
#include <cstddef>
#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif

#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_TOLOWER(c) (c >= 'A' && c <= 'Z' ? (c | (1 << 5)) : c)
#else
#define LAZY_IMPORTER_TOLOWER(c) (c)
#endif

namespace li {
    namespace detail {

        template<class First, class Second>
        struct pair {
            First  first;
            Second second;
        };

        namespace win {

            struct LIST_ENTRY_T {
                const char* Flink;
                const char* Blink;
            };

            struct UNICODE_STRING_T {
                unsigned short Length;
                unsigned short MaximumLength;
                wchar_t* Buffer;
            };

            struct PEB_LDR_DATA_T {
                unsigned long Length;
                unsigned long Initialized;
                const char* SsHandle;
                LIST_ENTRY_T  InLoadOrderModuleList;
            };

            struct PEB_T {
                unsigned char   Reserved1[2];
                unsigned char   BeingDebugged;
                unsigned char   Reserved2[1];
                const char* Reserved3[2];
                PEB_LDR_DATA_T* Ldr;
            };

            struct LDR_DATA_TABLE_ENTRY_T {
                LIST_ENTRY_T InLoadOrderLinks;
                LIST_ENTRY_T InMemoryOrderLinks;
                LIST_ENTRY_T InInitializationOrderLinks;
                const char* DllBase;
                const char* EntryPoint;
                union {
                    unsigned long SizeOfImage;
                    const char* _dummy;
                };
                UNICODE_STRING_T FullDllName;
                UNICODE_STRING_T BaseDllName;

                LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
                    load_order_next() const noexcept {
                    return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
                        InLoadOrderLinks.Flink);
                }
            };

            struct IMAGE_DOS_HEADER { // DOS .EXE header
                unsigned short e_magic; // Magic number
                unsigned short e_cblp; // Bytes on last page of file
                unsigned short e_cp; // Pages in file
                unsigned short e_crlc; // Relocations
                unsigned short e_cparhdr; // Size of header in paragraphs
                unsigned short e_minalloc; // Minimum extra paragraphs needed
                unsigned short e_maxalloc; // Maximum extra paragraphs needed
                unsigned short e_ss; // Initial (relative) SS value
                unsigned short e_sp; // Initial SP value
                unsigned short e_csum; // Checksum
                unsigned short e_ip; // Initial IP value
                unsigned short e_cs; // Initial (relative) CS value
                unsigned short e_lfarlc; // File address of relocation table
                unsigned short e_ovno; // Overlay number
                unsigned short e_res[4]; // Reserved words
                unsigned short e_oemid; // OEM identifier (for e_oeminfo)
                unsigned short e_oeminfo; // OEM information; e_oemid specific
                unsigned short e_res2[10]; // Reserved words
                long           e_lfanew; // File address of new exe header
            };

            struct IMAGE_FILE_HEADER {
                unsigned short Machine;
                unsigned short NumberOfSections;
                unsigned long  TimeDateStamp;
                unsigned long  PointerToSymbolTable;
                unsigned long  NumberOfSymbols;
                unsigned short SizeOfOptionalHeader;
                unsigned short Characteristics;
            };

            struct IMAGE_EXPORT_DIRECTORY {
                unsigned long  Characteristics;
                unsigned long  TimeDateStamp;
                unsigned short MajorVersion;
                unsigned short MinorVersion;
                unsigned long  Name;
                unsigned long  Base;
                unsigned long  NumberOfFunctions;
                unsigned long  NumberOfNames;
                unsigned long  AddressOfFunctions; // RVA from base of image
                unsigned long  AddressOfNames; // RVA from base of image
                unsigned long  AddressOfNameOrdinals; // RVA from base of image
            };

            struct IMAGE_DATA_DIRECTORY {
                unsigned long VirtualAddress;
                unsigned long Size;
            };

            struct IMAGE_OPTIONAL_HEADER64 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long long   ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long long   SizeOfStackReserve;
                unsigned long long   SizeOfStackCommit;
                unsigned long long   SizeOfHeapReserve;
                unsigned long long   SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            };

            struct IMAGE_OPTIONAL_HEADER32 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long        BaseOfData;
                unsigned long        ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long        SizeOfStackReserve;
                unsigned long        SizeOfStackCommit;
                unsigned long        SizeOfHeapReserve;
                unsigned long        SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            };

            struct IMAGE_NT_HEADERS {
                unsigned long     Signature;
                IMAGE_FILE_HEADER FileHeader;
            #ifdef _WIN64
                IMAGE_OPTIONAL_HEADER64 OptionalHeader;
            #else
                IMAGE_OPTIONAL_HEADER32 OptionalHeader;
            #endif
            };

        } // namespace win

        // hashing stuff
        struct hash_t {
            using value_type = unsigned long;
            constexpr static value_type         offset = 2166136261;
            constexpr static value_type         prime = 16777619;
            constexpr static unsigned long long prime64 = prime;

            LAZY_IMPORTER_FORCEINLINE constexpr static value_type single(value_type value,
                                                                         char c) noexcept {
                return static_cast<hash_t::value_type>(
                    (value ^ LAZY_IMPORTER_TOLOWER(c)) *
                    static_cast<unsigned long long>(prime));
            }
        };

        template<class CharT = char>
        LAZY_IMPORTER_FORCEINLINE constexpr hash_t::value_type
            khash(const CharT* str, hash_t::value_type value = hash_t::offset) noexcept {
            return (*str ? khash(str + 1, hash_t::single(value, *str)) : value);
        }

        template<class CharT = char>
        LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(const CharT* str) noexcept {
            hash_t::value_type value = hash_t::offset;

            for (;;) {
                char c = *str++;
                if (!c)
                    return value;
                value = hash_t::single(value, c);
            }
        }

        LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(
            const win::UNICODE_STRING_T& str) noexcept {
            auto       first = str.Buffer;
            const auto last = first + (str.Length / sizeof(wchar_t));
            auto       value = hash_t::offset;
            for (; first != last; ++first)
                value = hash_t::single(value, static_cast<char>(*first));

            return value;
        }

        LAZY_IMPORTER_FORCEINLINE pair<hash_t::value_type, hash_t::value_type> hash_forwarded(
            const char* str) noexcept {
            pair<hash_t::value_type, hash_t::value_type> module_and_function{
                hash_t::offset, hash_t::offset
            };

            for (; *str != '.'; ++str)
                module_and_function.first = hash_t::single(module_and_function.first, *str);

            ++str;

            for (; *str; ++str)
                module_and_function.second = hash_t::single(module_and_function.second, *str);

            return module_and_function;
        }


        // some helper functions
        LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept {
        #if defined(_M_X64) || defined(__amd64__)
            return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
        #elif defined(_M_IX86) || defined(__i386__)
            return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
        #elif defined(_M_ARM) || defined(__arm__)
            return *reinterpret_cast<const win::PEB_T**>(_MoveFromCoprocessor(15, 0, 13, 0, 2) + 0x30);
        #elif defined(_M_ARM64) || defined(__aarch64__)
            return *reinterpret_cast<const win::PEB_T**>(__getReg(18) + 0x60);
        #elif defined(_M_IA64) || defined(__ia64__)
            return *reinterpret_cast<const win::PEB_T**>(static_cast<char*>(_rdteb()) + 0x60);
        #else
        #error Unsupported platform. Open an issue and I'll probably add support.
        #endif
        }

        LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr() {
            return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
            const char* base) noexcept {
            return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
                base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
            const char* base) noexcept {
            return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
        }

        LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept {
            return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
                ldr()->InLoadOrderModuleList.Flink);
        }

        struct exports_directory {
            const char* _base;
            const win::IMAGE_EXPORT_DIRECTORY* _ied;
            unsigned long                      _ied_size;

            public:
            using size_type = unsigned long;

            LAZY_IMPORTER_FORCEINLINE
                exports_directory(const char* base) noexcept : _base(base) {
                const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
                _ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                    base + ied_data_dir.VirtualAddress);
                _ied_size = ied_data_dir.Size;
            }

            LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept {
                return reinterpret_cast<const char*>(_ied) != _base;
            }

            LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept {
                return _ied->NumberOfNames;
            }

            LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept {
                return _base;
            }
            LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept {
                return _ied;
            }

            LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept {
                return reinterpret_cast<const char*>(
                    _base + reinterpret_cast<const unsigned long*>(
                    _base + _ied->AddressOfNames)[index]);
            }

            LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept {
                const auto* const rva_table =
                    reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

                const auto* const ord_table = reinterpret_cast<const unsigned short*>(
                    _base + _ied->AddressOfNameOrdinals);

                return _base + rva_table[ord_table[index]];
            }

            LAZY_IMPORTER_FORCEINLINE bool is_forwarded(
                const char* export_address) const noexcept {
                const auto ui_ied = reinterpret_cast<const char*>(_ied);
                return (export_address > ui_ied && export_address < ui_ied + _ied_size);
            }
        };

        struct safe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
            value_type* value;
            value_type* head;

            LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
                : safe_module_enumerator(ldr_data_entry()) {
            }

            LAZY_IMPORTER_FORCEINLINE
                safe_module_enumerator(const detail::win::LDR_DATA_TABLE_ENTRY_T* ldr) noexcept
                : value(ldr->load_order_next()), head(value) {
            }

            LAZY_IMPORTER_FORCEINLINE void reset() noexcept {
                value = head->load_order_next();
            }

            LAZY_IMPORTER_FORCEINLINE bool next() noexcept {
                value = value->load_order_next();

                return value != head && value->DllBase;
            }
        };

        struct unsafe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
            value_type value;

            LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
                : value(ldr_data_entry()) {
            }

            LAZY_IMPORTER_FORCEINLINE void reset() noexcept {
                value = ldr_data_entry();
            }

            LAZY_IMPORTER_FORCEINLINE bool next() noexcept {
                value = value->load_order_next();
                return true;
            }
        };

        // provides the cached functions which use Derive classes methods
        template<class Derived, class DefaultType = void*>
        class lazy_base {
            protected:
            // This function is needed because every templated function
            // with different args has its own static buffer
            LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept {
                static void* value = nullptr;
                return value;
            }

            public:
            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe() noexcept {
                return Derived::template get<T, safe_module_enumerator>();
            }

            template<class T = DefaultType, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T cached() noexcept {
                auto& cached = _cache();
                if (!cached)
                    cached = Derived::template get<void*, Enum>();

                return (T)(cached);
            }

            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept {
                return cached<T, safe_module_enumerator>();
            }
        };

        template<hash_t::value_type Hash>
        struct lazy_module : lazy_base<lazy_module<Hash>> {
            template<class T = void*, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T get() noexcept {
                Enum e;
                do {
                    if (hash(e.value->BaseDllName) == Hash)
                        return (T)(e.value->DllBase);
                } while (e.next());
                return {};
            }

            template<class T = void*, class Ldr>
            LAZY_IMPORTER_FORCEINLINE static T in(Ldr ldr) noexcept {
                safe_module_enumerator e((const detail::win::LDR_DATA_TABLE_ENTRY_T*)(ldr));
                do {
                    if (hash(e.value->BaseDllName) == Hash)
                        return (T)(e.value->DllBase);
                } while (e.next());
                return {};
            }

            template<class T = void*, class Ldr>
            LAZY_IMPORTER_FORCEINLINE static T in_cached(Ldr ldr) noexcept {
                auto& cached = lazy_base<lazy_module<Hash>>::_cache();
                if (!cached)
                    cached = in(ldr);

                return (T)(cached);
            }
        };

        template<hash_t::value_type Hash, class T>
        struct lazy_function : lazy_base<lazy_function<Hash, T>, T> {
            using base_type = lazy_base<lazy_function<Hash, T>, T>;

            template<class... Args>
            LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&&... args) const {
            #ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
                return get()(std::forward<Args>(args)...);
            #else
                return this->cached()(std::forward<Args>(args)...);
            #endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F get() noexcept {
                // for backwards compatability.
                // Before 2.0 it was only possible to resolve forwarded exports when
                // this macro was enabled
            #ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
                return forwarded<F, Enum>();
            #else

                Enum e;

                do {
                #ifdef LAZY_IMPORTER_HARDENED_MODULE_CHECKS
                    if (!e.value->DllBase || !e.value->FullDllName.Length)
                        continue;
                #endif

                    const exports_directory exports(e.value->DllBase);

                    if (exports) {
                        auto export_index = exports.size();
                        while (export_index--)
                            if (hash(exports.name(export_index)) == Hash)
                                return (F)(exports.address(export_index));
                    }
                } while (e.next());
                return {};
            #endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept {
                hash_t::value_type            module_hash = 0;
                auto                          function_hash = Hash;

                Enum e;
                do {
                    detail::win::UNICODE_STRING_T name = e.value->BaseDllName;
                    name.Length -= 8; // get rid of .dll extension

                    if (!module_hash || hash(name) == module_hash) {
                        const exports_directory exports(e.value->DllBase);

                        if (exports) {
                            auto export_index = exports.size();
                            while (export_index--)
                                if (hash(exports.name(export_index)) == function_hash) {
                                    const auto addr = exports.address(export_index);

                                    if (exports.is_forwarded(addr)) {
                                        auto hashes = hash_forwarded(
                                            reinterpret_cast<const char*>(addr));

                                        function_hash = hashes.second;
                                        module_hash = hashes.first;

                                        e.reset();
                                        break;
                                    }
                                    return (F)(addr);
                                }
                        }
                    }
                } while (e.next());
                return {};
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept {
                return forwarded<F, safe_module_enumerator>();
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept {
                auto& value = base_type::_cache();
                if (!value)
                    value = forwarded<void*, Enum>();
                return (F)(value);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept {
                return forwarded_cached<F, safe_module_enumerator>();
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept {
                if (IsSafe && !m)
                    return {};

                const exports_directory exports((const char*)(m));
                if (IsSafe && !exports)
                    return {};

                for (unsigned long i{};; ++i) {
                    if (IsSafe && i == exports.size())
                        break;

                    if (hash(exports.name(i)) == Hash)
                        return (F)(exports.address(i));
                }
                return {};
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept {
                return in<F, true>(m);
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept {
                auto& value = base_type::_cache();
                if (!value)
                    value = in<void*, IsSafe>(m);
                return (F)(value);
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept {
                return in_cached<F, true>(m);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt() noexcept {
                return in<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept {
                return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept {
                return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept {
                return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
            }
        };

    }
} // namespace li::detail

#endif // include guard
```

`ue4_base/utils/libraries/xor.h`:

```h
/*
 * Copyright 2017 - 2018 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP

#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>

#define xorstr(str)                                              \
    ::jm::make_xorstr(                                           \
        []() { return str; },                                    \
        std::make_index_sequence<sizeof(str) / sizeof(*str)>{},  \
        std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{})
#define _(str) xorstr(str).crypt_get()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline))
#endif

 // you can define this macro to get possibly faster code on gcc/clang
 // at the expense of constants being put into data section.
#if !defined(XORSTR_ALLOW_DATA)
// MSVC - no volatile
// GCC and clang - volatile everywhere
#if defined(__clang__) || defined(__GNUC__)
#define XORSTR_VOLATILE volatile
#endif

#endif
#ifndef XORSTR_VOLATILE
#define XORSTR_VOLATILE
#endif

namespace jm {

    namespace detail {

        template<std::size_t S>
        struct unsigned_;

        template<>
        struct unsigned_<1> {
            using type = std::uint8_t;
        };
        template<>
        struct unsigned_<2> {
            using type = std::uint16_t;
        };
        template<>
        struct unsigned_<4> {
            using type = std::uint32_t;
        };

        template<auto C, auto...>
        struct pack_value_type {
            using type = decltype(C);
        };

        template<std::size_t Size>
        constexpr std::size_t _buffer_size() {
            return ((Size / 16) + (Size % 16 != 0)) * 2;
        }

        template<auto... Cs>
        struct tstring_ {
            using value_type = typename pack_value_type<Cs...>::type;
            constexpr static std::size_t size = sizeof...(Cs);
            constexpr static value_type  str[size] = { Cs... };

            constexpr static std::size_t buffer_size = _buffer_size<sizeof(str)>();
            constexpr static std::size_t buffer_align =
            #ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            ((sizeof(str) > 16) ? 32 : 16);
        #else
                16;
        #endif
        };

        template<std::size_t I, std::uint64_t K>
        struct _ki {
            constexpr static std::size_t   idx = I;
            constexpr static std::uint64_t key = K;
        };

        template<std::uint32_t Seed>
        constexpr std::uint32_t key4() noexcept {
            std::uint32_t value = Seed;
            for (const char c : __TIME__)
                value = static_cast<std::uint32_t>((value ^ c) * 16777619ull);
            return value;
        }

        template<std::size_t S>
        constexpr std::uint64_t key8() {
            constexpr auto first_part = key4<2166136261 + S>();
            constexpr auto second_part = key4<first_part>();
            return (static_cast<std::uint64_t>(first_part) << 32) | second_part;
        }

        // clang and gcc try really hard to place the constants in data
        // sections. to counter that there was a need to create an intermediate
        // constexpr string and then copy it into a non constexpr container with
        // volatile storage so that the constants would be placed directly into
        // code.
        template<class T, std::uint64_t... Keys>
        struct string_storage {
            std::uint64_t storage[T::buffer_size];

            XORSTR_FORCEINLINE constexpr string_storage() noexcept : storage{ Keys... } {
                using cast_type =
                    typename unsigned_<sizeof(typename T::value_type)>::type;
                constexpr auto value_size = sizeof(typename T::value_type);
                // puts the string into 64 bit integer blocks in a constexpr
                // fashion
                for (std::size_t i = 0; i < T::size; ++i)
                    storage[i / (8 / value_size)] ^=
                    (std::uint64_t{ static_cast<cast_type>(T::str[i]) }
                << ((i % (8 / value_size)) * 8 * value_size));
            }
        };

    } // namespace detail

    template<class T, class... Keys>
    class xor_string {
        alignas(T::buffer_align) std::uint64_t _storage[T::buffer_size];

        // _single functions needed because MSVC crashes without them
        XORSTR_FORCEINLINE void _crypt_256_single(const std::uint64_t* keys,
                                                  std::uint64_t* storage) noexcept

        {
            _mm256_store_si256(
                reinterpret_cast<__m256i*>(storage),
                _mm256_xor_si256(
                _mm256_load_si256(reinterpret_cast<const __m256i*>(storage)),
                _mm256_load_si256(reinterpret_cast<const __m256i*>(keys))));
        }

        template<std::size_t... Idxs>
        XORSTR_FORCEINLINE void _crypt_256(const std::uint64_t* keys,
                                           std::index_sequence<Idxs...>) noexcept {
            (_crypt_256_single(keys + Idxs * 4, _storage + Idxs * 4), ...);
        }

        XORSTR_FORCEINLINE void _crypt_128_single(const std::uint64_t* keys,
                                                  std::uint64_t* storage) noexcept {
            _mm_store_si128(
                reinterpret_cast<__m128i*>(storage),
                _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(storage)),
                _mm_load_si128(reinterpret_cast<const __m128i*>(keys))));
        }

        template<std::size_t... Idxs>
        XORSTR_FORCEINLINE void _crypt_128(const std::uint64_t* keys,
                                           std::index_sequence<Idxs...>) noexcept {
            (_crypt_128_single(keys + Idxs * 2, _storage + Idxs * 2), ...);
        }

        // loop generates vectorized code which places constants in data dir
        XORSTR_FORCEINLINE constexpr void _copy() noexcept {
            constexpr detail::string_storage<T, Keys::key...> storage;
            static_cast<void>(std::initializer_list<std::uint64_t>{
                (const_cast<XORSTR_VOLATILE std::uint64_t*>(_storage))[Keys::idx] =
                    storage.storage[Keys::idx]... });
        }

        public:
        using value_type = typename T::value_type;
        using size_type = std::size_t;
        using pointer = value_type*;
        using const_pointer = const pointer;

        XORSTR_FORCEINLINE xor_string() noexcept {
            _copy();
        }

        XORSTR_FORCEINLINE constexpr size_type size() const noexcept {
            return T::size - 1;
        }

        XORSTR_FORCEINLINE void crypt() noexcept {
            alignas(T::buffer_align) std::uint64_t keys[T::buffer_size];
            static_cast<void>(std::initializer_list<std::uint64_t>{
                (const_cast<XORSTR_VOLATILE std::uint64_t*>(keys))[Keys::idx] =
                    Keys::key... });

            _copy();

        #ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            _crypt_256(keys, std::make_index_sequence<T::buffer_size / 4>{});
            if constexpr (T::buffer_size % 4 != 0)
                _crypt_128(keys, std::index_sequence<T::buffer_size / 2 - 1>{});
        #else
            _crypt_128(keys, std::make_index_sequence<T::buffer_size / 2>{});
        #endif
        }

        XORSTR_FORCEINLINE const_pointer get() const noexcept {
            return reinterpret_cast<const_pointer>(_storage);
        }

        XORSTR_FORCEINLINE const_pointer crypt_get() noexcept {
            crypt();
            return reinterpret_cast<const_pointer>(_storage);
        }
    };

    template<class Tstr, std::size_t... StringIndices, std::size_t... KeyIndices>
    XORSTR_FORCEINLINE constexpr auto
        make_xorstr(Tstr str_lambda,
                    std::index_sequence<StringIndices...>,
                    std::index_sequence<KeyIndices...>) noexcept {
        return xor_string<detail::tstring_<str_lambda()[StringIndices]...>,
            detail::_ki<KeyIndices, detail::key8<KeyIndices>()>...>{};
    }

} // namespace jm

#endif // include guard
```

`ue4_base/utils/utils.cpp`:

```cpp
#include <includes.h>
#include "utils.h"

std::uintptr_t utils::pattern_scan(const std::uintptr_t address, const char* signature, const bool relative) {
	static auto pattern_to_byte = [](const char* pattern) {
		auto bytes = std::vector<int>{};
		const auto start = const_cast<char*>(pattern);
		const auto end = const_cast<char*>(pattern) + LI_FN(strlen)(pattern);

		for (auto current = start; current < end; ++current) {
			if (*current == '?') {
				++current;
				bytes.push_back(-1);
			} else {
				bytes.push_back(LI_FN(strtoul)(current, &current, 16));
			}
		}
		return bytes;
	};

	const auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(address);
	const auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<std::uint8_t*>(address) + dos_header->e_lfanew);

	const auto size_of_image = nt_headers->OptionalHeader.SizeOfImage;
	const auto pattern_bytes = pattern_to_byte(signature);
	const auto scan_bytes = reinterpret_cast<std::uint8_t*>(address);

	const auto s = pattern_bytes.size();
	const auto d = pattern_bytes.data();

	for (auto i = 0ul; i < size_of_image - s; ++i) {
		bool found = true;
		for (auto j = 0ul; j < s; ++j) {
			if (scan_bytes[i + j] != d[j] && d[j] != -1) {
				found = false;
				break;
			}
		}

		if (found) {
			const auto offset = *reinterpret_cast<int*>(&scan_bytes[i] + 3);
			return relative ? reinterpret_cast<std::uintptr_t>(&scan_bytes[i]) + offset + 7 : reinterpret_cast<std::uintptr_t>(&scan_bytes[i]);
		}
	}

	return 0;
}

bool utils::console::initialize(const std::string& title) {
	AllocConsole();

	freopen_s(reinterpret_cast<_iobuf**>(__acrt_iob_func(0)), _("conin$"), _("r"), __acrt_iob_func(0));
	freopen_s(reinterpret_cast<_iobuf**>(__acrt_iob_func(1)), _("conout$"), _("w"), __acrt_iob_func(1));
	freopen_s(reinterpret_cast<_iobuf**>(__acrt_iob_func(2)), _("conout$"), _("w"), __acrt_iob_func(2));


	SetConsoleTitleA(title.c_str());

	return true;
}

void utils::console::release() {
	fclose(__acrt_iob_func(0));
	fclose(__acrt_iob_func(1));
	fclose(__acrt_iob_func(2));

	FreeConsole();
}
```

`ue4_base/utils/utils.h`:

```h
#pragma once

namespace utils {
	std::uintptr_t pattern_scan(std::uintptr_t address, const char* signature, bool relative = false);
}

namespace utils::console {
	bool initialize(const std::string& title);
	void release();
}
```