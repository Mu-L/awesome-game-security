Project Path: arc_dumbasPL_fumo_loader_wc0tcbfe

Source Tree:

```txt
arc_dumbasPL_fumo_loader_wc0tcbfe
├── CMakeLists.txt
├── CMakePresets.json
├── LICENSE
├── README.md
├── cmake
│   └── CPM.cmake
└── src
    ├── CMakeLists.txt
    ├── driver
    │   ├── CMakeLists.txt
    │   ├── driver.c
    │   ├── driver.h
    │   ├── imports.h
    │   ├── memory.c
    │   ├── memory.h
    │   ├── thread.c
    │   └── thread.h
    ├── driver_interface
    │   ├── CMakeLists.txt
    │   ├── driver_interface.cpp
    │   └── driver_interface.h
    ├── encoder
    │   ├── CMakeLists.txt
    │   └── fumo_encoder.cpp
    ├── fumo_generator
    │   ├── CMakeLists.txt
    │   └── fumo_generator.cpp
    ├── include
    │   ├── bootstrap.h
    │   ├── fomo_common.h
    │   ├── fumo_data_header.h
    │   └── util.h
    ├── initial_loader
    │   ├── CMakeLists.txt
    │   ├── extract_lib.bat
    │   └── initial_loader.cpp
    ├── resource_generator
    │   ├── CMakeLists.txt
    │   └── resource_generator.cpp
    ├── shellcode_extractor
    │   ├── CMakeLists.txt
    │   └── shellcode_extractor.cpp
    ├── stage1
    │   ├── CMakeLists.txt
    │   ├── anti_idiot.cpp
    │   ├── fumo_preloader.cpp
    │   ├── fumo_preloader.h
    │   └── stage1.cpp
    └── stage2
        ├── CMakeLists.txt
        ├── fumo_loader.cpp
        ├── fumo_loader.h
        ├── stage2.cpp
        ├── stage2.h
        ├── tray_icon.cpp
        └── tray_icon.h

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.15 FATAL_ERROR)
project(fumo_loader VERSION 1.0.0)

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)

# multi-processor compilation
if(MSVC)
    include(ProcessorCount)
    ProcessorCount(PROCESSOR_COUNT)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /MP${PROCESSOR_COUNT}")
    set(CMAKE_VS_MSBUILD_COMMAND "${CMAKE_VS_MSBUILD_COMMAND} /p:CL_MPCount=${PROCESSOR_COUNT} /m")
endif()

set(CPM_SOURCE_CACHE "${CMAKE_SOURCE_DIR}/.cache/cpm")
include(cmake/CPM.cmake)

set(FUMO_DRIVER_DEBUG OFF CACHE BOOL "Enable driver debug logs/force reload")
set(FUMO_DEBUG OFF CACHE BOOL "Disable creating new executables")

if (FUMO_DEBUG)
    add_compile_definitions(FUMO_DEBUG)
endif()

add_subdirectory(src)
```

`CMakePresets.json`:

```json
{
  "version": 6,
  "cmakeMinimumRequired": {
    "major": 3,
    "minor": 15,
    "patch": 0
  },
  "configurePresets": [
    {
      "name": "x64-windows",
      "binaryDir": "${sourceDir}/build",
      "generator": "Visual Studio 17 2022",
      "architecture": {
        "value": "x64",
        "strategy": "set"
      },
      "cacheVariables": {
        "FUMO_DEBUG": "OFF",
        "FUMO_DRIVER_DEBUG": "OFF"
      }
    },
    {
      "name": "x64-windows-debug",
      "inherits": "x64-windows",
      "cacheVariables": {
        "FUMO_DEBUG": "ON",
        "FUMO_DRIVER_DEBUG": "ON"
      }
    },
    {
      "name": "linux-embedding-tools",
      "binaryDir": "${sourceDir}/build",
      "generator": "Ninja",
      "architecture": {
        "value": "x64",
        "strategy": "external"
      },
      "cacheVariables": {
        "FUMO_DEBUG": "OFF",
        "FUMO_DRIVER_DEBUG": "OFF"
      }
    }
  ],
  "buildPresets": [
    {
      "name": "Release",
      "configurePreset": "x64-windows",
      "configuration": "Release"
    },
    {
      "name": "Debug",
      "configurePreset": "x64-windows-debug",
      "configuration": "Release"
    },
    {
      "name": "Linux Embedding Tools",
      "configurePreset": "linux-embedding-tools",
      "configuration": "Release"
    }
  ]
}
```

`LICENSE`:

```
Copyright (c) 2023 nezu

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# fumo loader

All-in-one kernel-based DLL injector

## Features

- Manual map a DLL into kernel memory and expose it to user mode via page table manipulation
- Re-generate a unique, encrypted executable each time it is run and delete the old one
- Store the target DLL in a compressed and encrypted form on disk (.fumo file)
- Tray icon and notifications that tell you about the status of the loader and allow you to abort the injection process
- Wait for certain modules to be loaded in the target process before injecting
- No running processes during injection (injects itself into a different process, explorer.exe by default)
- No open handles to the target process
- No new threads in the target process (injects using APCs from the kernel)
- Compatible with:
  - Windows 10 20H1 to Windows 11 24H2 (x64) (in theory, only tested on W11 22H2-24H2)
  - Secure boot
  - PatchGuard
  - Driver Signature Enforcement
  - Vulnerable driver blocklist

## Limitations

- **NOT** Compatible with:
  - 32-bit Windows and 32-bit processes
  - Hypervisor code integrity (HVCI)
  - KVA Shadowing (aka the Meltdown mitigation). Modern CPUs aren't affected, disable Meltdown protection on older ones.
  - Good anti-cheats (this is designed for defeating user-mode anti-cheats)
  - Probably a bunch of anti-virus software
  - Old versions of Windows (before 20H1)
- Target DLL **MUST NOT** have:
  - Thread-local storage (TLS)
  - Vectored exception handlers (VEH) (adding a global handler manually is fine though)

## Caveats

- (Currently) it does not clean any traces of the vulnerable driver
  - Reboot before loading any "decent" anti-cheat if you don't feel like being insta banned
- The target process needs to have a thread that we can schedule APCs on (this is usually not an issue outside of very simple hello world programs that only have one thread)
- You might get random DEP violations because memory above 0x7FFF'FFFEFFFF is technically not valid user-mode memory (at least as far as Windows APIs are concerned, your CPU doesn't care and will happily execute it, that's the whole idea behind this loader)
  - You will have to register an exception handler in your DLL that will catch the exception and return `EXCEPTION_CONTINUE_EXECUTION` whenever it encounters a DEP violation above 0x7FFF'FFFEFFFF

## Usage

### Prepare the .fumo file

1. Download the latest release or build it yourself
2. Drag and drop a DLL onto `fumo_encoder.exe`
  1. Fill out the process name
  2. Fill out what DLL(s) to wait for before injecting

### Inject

1. Drag and drop the generated .fumo file onto `fumo.exe`
2. Wait for the success notification or error message box
3. Open the target process
4. Wait for the target DLL(s) to be loaded
5. ...
6. Profit

## Building

### Requirements

- Visual Studio 2022 build tools (lower might work, but not tested)
- Windows Driver Kit 10 (WDK)
- CMake

### Configure and build

```sh
# configure the x64-windows preset
cmake --preset=x64-windows
# build the project
cmake --build --preset=Release
```

Or use the CMake integration built into your IDE of choice

## TODO (feel free to contribute)

- [ ] Add support for TLS
- [ ] Add support for VEH
- [ ] Add support for KVA Shadowing
- [ ] Do some trace cleaning

## Credits

### Libraries and tools used

- [KDU](https://github.com/hfiref0x/KDU) - the driver vulnerable mapper
- [libKDU](https://github.com/dumbasPL/libKDU) - My wrapper around KDU that turns it into a static library
- [lazy_importer](https://github.com/JustasMasiulis/lazy_importer) - inlined import resolution (used for position-independent code)
- [xorstr](https://github.com/JustasMasiulis/xorstr) - inlined and encrypted strings (also used for position-independent code)
- [FindWDK](https://github.com/SergiusTheBest/FindWDK) - CMake module for building Windows drivers
- [lz4](https://github.com/lz4/lz4) - compression for the .fumo files
- [CMake](https://cmake.org/) - amazing build system
- [@slnchyt](https://www.pixiv.net/en/artworks/35678304) - the tray icon

### Inspiration

- [ThePerfectInjector](https://github.com/can1357/ThePerfectInjector) - the original idea for this injection method
- [Blackbone](https://github.com/DarthTon/Blackbone) - well-written kernel code that I used as a reference (and stole some code from)

## License

[MIT](LICENSE)

## ~~Number of Pasters~~ Star History

<a href="https://star-history.com/#dumbasPL/fumo_loader&Date">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://api.star-history.com/svg?repos=dumbasPL/fumo_loader&type=Date&theme=dark" />
    <source media="(prefers-color-scheme: light)" srcset="https://api.star-history.com/svg?repos=dumbasPL/fumo_loader&type=Date" />
    <img alt="Star History Chart" src="https://api.star-history.com/svg?repos=dumbasPL/fumo_loader&type=Date" />
  </picture>
</a>

```

`cmake/CPM.cmake`:

```cmake
# SPDX-License-Identifier: MIT
#
# SPDX-FileCopyrightText: Copyright (c) 2019-2023 Lars Melchior and contributors

set(CPM_DOWNLOAD_VERSION 0.40.4)
set(CPM_HASH_SUM "67dcc1deb6e12a2f0705647ccc5f7023e3d15746b944e14352b82373e09b8a0a")

if(CPM_SOURCE_CACHE)
  set(CPM_DOWNLOAD_LOCATION "${CPM_SOURCE_CACHE}/cpm/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
elseif(DEFINED ENV{CPM_SOURCE_CACHE})
  set(CPM_DOWNLOAD_LOCATION "$ENV{CPM_SOURCE_CACHE}/cpm/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
else()
  set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
endif()

# Expand relative path. This is important if the provided path contains a tilde (~)
get_filename_component(CPM_DOWNLOAD_LOCATION ${CPM_DOWNLOAD_LOCATION} ABSOLUTE)

file(DOWNLOAD
     https://github.com/cpm-cmake/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake
     ${CPM_DOWNLOAD_LOCATION} EXPECTED_HASH SHA256=${CPM_HASH_SUM}
)

include(${CPM_DOWNLOAD_LOCATION})

```

`src/CMakeLists.txt`:

```txt
# disable C4711, C5045, C4820 (caused by lz4)
if(MSVC)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /wd4711 /wd5045 /wd4820")
endif()

CPMAddPackage(
    NAME lz4
    GITHUB_REPOSITORY lz4/lz4
    VERSION 1.10.0
    SOURCE_SUBDIR build/cmake
    OPTIONS
        "LZ4_BUILD_CLI OFF"
        "LZ4_BUILD_LEGACY_LZ4C OFF"
)
find_package(lz4 REQUIRED)

CPMAddPackage("gh:can1357/linux-pe#master")
find_package(linux-pe REQUIRED)

if (CMAKE_SYSTEM_NAME STREQUAL "Windows")
    CPMAddPackage(
        NAME xorstr
        GITHUB_REPOSITORY JustasMasiulis/xorstr
        GIT_TAG master
        DOWNLOAD_ONLY True
    )

    if (xorstr_ADDED)
        add_library(xorstr INTERFACE)
        target_include_directories(xorstr INTERFACE ${xorstr_SOURCE_DIR}/include)
    endif()

    CPMAddPackage(
        NAME lazy_importer
        GITHUB_REPOSITORY JustasMasiulis/lazy_importer
        GIT_TAG master
        DOWNLOAD_ONLY True
    )

    if (lazy_importer_ADDED)
        add_library(lazy_importer INTERFACE)
        target_include_directories(lazy_importer INTERFACE ${lazy_importer_SOURCE_DIR}/include)
    endif()

    CPMAddPackage("gh:SergiusTheBest/FindWDK#master")
    list(APPEND CMAKE_MODULE_PATH "${FindWDK_SOURCE_DIR}/cmake")
    find_package(WDK REQUIRED)

    CPMAddPackage("gh:dumbasPL/libKDU@1.4.3")

    add_subdirectory(driver)
    add_subdirectory(driver_interface)
    add_subdirectory(resource_generator)
    add_subdirectory(stage1)
    add_subdirectory(stage2)
    add_subdirectory(initial_loader)
    add_subdirectory(shellcode_extractor)
endif()

add_subdirectory(fumo_generator)
add_subdirectory(encoder)

if (CMAKE_SYSTEM_NAME STREQUAL "Windows")
    add_custom_command(
        COMMENT "building final executable"
        DEPENDS fumo_generator initial_loader stage1
            $<TARGET_PROPERTY:initial_loader,RUNTIME_OUTPUT_DIRECTORY>/initial_loader.bin
            $<TARGET_FILE:stage1>
        COMMAND fumo_generator ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/fumo.exe
            $<TARGET_PROPERTY:initial_loader,RUNTIME_OUTPUT_DIRECTORY>/initial_loader.bin
            $<TARGET_FILE:stage1>
        OUTPUT ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/fumo.exe
    )

    add_custom_target(
        fumo ALL
        DEPENDS ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/fumo.exe
    )
endif()

```

`src/driver/CMakeLists.txt`:

```txt
wdk_add_driver(fumo_drv WINVER 0x4A61 driver.c memory.c thread.c)
target_include_directories(fumo_drv PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../include)
target_link_options(fumo_drv PRIVATE /NOCOFFGRPINFO /ENTRY:DriverEntry)
set_target_properties(fumo_drv PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

if (FUMO_DRIVER_DEBUG)
    target_compile_definitions(fumo_drv PRIVATE -DFUMO_DRIVER_DEBUG)
endif()
```

`src/driver/driver.c`:

```c
#include "driver.h"
#include "memory.h"
#include "thread.h"
#include <fomo_common.h>

PVOID gOriginalDispatchFunctionArray[IRP_MJ_MAXIMUM_FUNCTION];

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
    UNREFERENCED_PARAMETER(RegistryPath);
    UNREFERENCED_PARAMETER(DriverObject);

    RTL_OSVERSIONINFOW version = { 0 };
    RtlGetVersion(&version);
    if (version.dwMajorVersion < MIN_OS_MAJOR_VERSION || version.dwBuildNumber < MIN_OS_BUILD_NUMBER) {
        Log("Unsupported OS version: %d.%d.%d", version.dwMajorVersion, version.dwMinorVersion, version.dwBuildNumber);
        return STATUS_NOT_SUPPORTED;
    }

    SetHook(TRUE);

    Log("loaded version %d running on %d.%d %d", FUMO_DRIVER_VERSION, version.dwMajorVersion, version.dwMinorVersion, version.dwBuildNumber);
    return STATUS_SUCCESS;
}

NTSTATUS SetHook(BOOL setHook) {
    UNICODE_STRING driverName;
    RtlInitUnicodeString(&driverName, FUMO_HOOKED_DRIVER_NAME);

    PDRIVER_OBJECT DriverObject = NULL;
    NTSTATUS status = ObReferenceObjectByName(&driverName, OBJ_CASE_INSENSITIVE, NULL, 0,
        *IoDriverObjectType, KernelMode, NULL, (PVOID*)&DriverObject);

    if (!NT_SUCCESS(status)) {
        Log("Failed to obtain DriverObject (0x%08X)", status);
        return status;
    }

    if (setHook) {
        Log("Hooking %ws major funcs", FUMO_HOOKED_DRIVER_NAME);
        RtlCopyMemory(gOriginalDispatchFunctionArray, DriverObject->MajorFunction, sizeof(gOriginalDispatchFunctionArray));
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = Hk_DeviceControl;
        Log("Hooked %ws major funcs", FUMO_HOOKED_DRIVER_NAME);
    } else {
        Log("Unhooking %ws major funcs", FUMO_HOOKED_DRIVER_NAME);
        RtlCopyMemory(DriverObject->MajorFunction, gOriginalDispatchFunctionArray, sizeof(gOriginalDispatchFunctionArray));
        Log("Unhooked %ws major funcs", FUMO_HOOKED_DRIVER_NAME);
    }

    ObDereferenceObject(DriverObject);
    return STATUS_SUCCESS;
}

NTSTATUS Hk_DeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
    PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;
    ULONG bytes = 0;

    switch (stack->Parameters.DeviceIoControl.IoControlCode)
    {
    case IO_VERSION_REQUEST: {
        if (stack->Parameters.DeviceIoControl.OutputBufferLength != sizeof(IO_VERSION_RESPONSE_DATA)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        PIO_VERSION_RESPONSE_DATA output = (PIO_VERSION_RESPONSE_DATA)Irp->AssociatedIrp.SystemBuffer;

        Log("IO_VERSION_REQUEST received");

        output->Version = FUMO_DRIVER_VERSION;
        bytes = sizeof(IO_VERSION_RESPONSE_DATA);
        status = STATUS_SUCCESS;
        break;
    }
    case IO_UNLOAD_REQUEST: {
        Log("IO_UNLOAD_REQUEST received");
        SetHook(FALSE);
        status = STATUS_SUCCESS;
        break;
    }
    case IO_ALLOC_REQUEST: {
        if (stack->Parameters.DeviceIoControl.InputBufferLength != sizeof(IO_ALLOC_REQUEST_DATA)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (stack->Parameters.DeviceIoControl.OutputBufferLength != sizeof(IO_ALLOC_RESPONSE_DATA)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        PIO_ALLOC_REQUEST_DATA input = (PIO_ALLOC_REQUEST_DATA)Irp->AssociatedIrp.SystemBuffer;
        PIO_ALLOC_RESPONSE_DATA output = (PIO_ALLOC_RESPONSE_DATA)Irp->AssociatedIrp.SystemBuffer;

        Log("IO_ALLOC_REQUEST received with size %d", input->Size);

        PVOID address = ExAllocatePool2(POOL_FLAG_NON_PAGED_EXECUTE, input->Size, POOL_TAG);
        if (address == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        Log("Allocated %d bytes at 0x%p", input->Size, address);

        if (!ExposeKernelMemoryToProcess(PsGetCurrentProcess(), address, input->Size)) {
            status = STATUS_UNSUCCESSFUL;
            break;
        }

        output->Address = address;
        bytes = sizeof(IO_ALLOC_RESPONSE_DATA);
        status = STATUS_SUCCESS;
        break;
    }
    case IO_MAP_MEMORY_REQUEST: {
        if (stack->Parameters.DeviceIoControl.InputBufferLength != sizeof(IO_MAP_MEMORY_REQUEST_DATA)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        PIO_MAP_MEMORY_REQUEST_DATA input = (PIO_MAP_MEMORY_REQUEST_DATA)Irp->AssociatedIrp.SystemBuffer;

        Log("IO_MAP_MEMORY_REQUEST received with pid %d, address 0x%p, size %d", input->Pid, input->Address, input->Size);

        PEPROCESS pProcess = NULL;
        status = PsLookupProcessByProcessId((HANDLE)input->Pid, &pProcess);
        if (!NT_SUCCESS(status)) {
            Log("Failed to lookup process by pid (0x%08X)", status);
            break;
        }

        KAPC_STATE apcState;
        KeStackAttachProcess(pProcess, &apcState);

        if (!ExposeKernelMemoryToProcess(pProcess, input->Address, input->Size)) {
            Log("Failed to expose kernel memory to process");
            KeUnstackDetachProcess(&apcState);
            ObDereferenceObject(pProcess);
            status = STATUS_UNSUCCESSFUL;
            break;
        }

        KeUnstackDetachProcess(&apcState);
        ObDereferenceObject(pProcess);

        bytes = 0;
        status = STATUS_SUCCESS;
        break;
    }
    case IO_EXECUTE_REQUEST: {
        if (stack->Parameters.DeviceIoControl.InputBufferLength != sizeof(IO_EXECUTE_REQUEST_DATA)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        PIO_EXECUTE_REQUEST_DATA input = (PIO_EXECUTE_REQUEST_DATA)Irp->AssociatedIrp.SystemBuffer;

        Log("IO_EXECUTE_REQUEST received with pid %d, address 0x%p, Argument 0x%p", input->Pid, input->Address, input->Argument);

        PEPROCESS pProcess = NULL;
        status = PsLookupProcessByProcessId((HANDLE)input->Pid, &pProcess);
        if (!NT_SUCCESS(status)) {
            Log("Failed to lookup process by pid (0x%08X)", status);
            break;
        }

        KAPC_STATE apcState;
        KeStackAttachProcess(pProcess, &apcState);

        PETHREAD pThread = NULL;
        status = FindProcessThread(pProcess, &pThread);
        if (!NT_SUCCESS(status)) {
            Log("Failed to find process thread (0x%08X)", status);
            KeUnstackDetachProcess(&apcState);
            ObDereferenceObject(pProcess);
            break;
        }

        status = QueueUserApc(pThread, input->Address, input->Argument);
        if (!NT_SUCCESS(status)) {
            Log("Failed to queue user apc (0x%08X)", status);
            KeUnstackDetachProcess(&apcState);
            ObDereferenceObject(pThread);
            ObDereferenceObject(pProcess);
            break;
        }

        KeUnstackDetachProcess(&apcState);
        ObDereferenceObject(pThread);
        ObDereferenceObject(pProcess);

        bytes = 0;
        status = STATUS_SUCCESS;
        break;
    }
    case IO_FIND_MODULE_REQUEST: {
        if (stack->Parameters.DeviceIoControl.InputBufferLength != sizeof(IO_FIND_MODULE_REQUEST_DATA)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (stack->Parameters.DeviceIoControl.OutputBufferLength != sizeof(IO_FIND_MODULE_RESPONSE_DATA)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        PIO_FIND_MODULE_REQUEST_DATA input = (PIO_FIND_MODULE_REQUEST_DATA)Irp->AssociatedIrp.SystemBuffer;
        PIO_FIND_MODULE_RESPONSE_DATA output = (PIO_FIND_MODULE_RESPONSE_DATA)Irp->AssociatedIrp.SystemBuffer;

        Log("IO_FIND_MODULE_REQUEST received with pid %d, module name %ws", input->Pid, input->ModuleName);

        PEPROCESS pProcess = NULL;
        status = PsLookupProcessByProcessId((HANDLE)input->Pid, &pProcess);
        if (!NT_SUCCESS(status)) {
            Log("Failed to lookup process by pid (0x%08X)", status);
            break;
        }

        KAPC_STATE apcState;
        KeStackAttachProcess(pProcess, &apcState);

        UNICODE_STRING moduleName;
        RtlInitUnicodeString(&moduleName, input->ModuleName);

        output->Address = FindModule(pProcess, &moduleName);

        KeUnstackDetachProcess(&apcState);
        ObDereferenceObject(pProcess);

        bytes = sizeof(IO_FIND_MODULE_RESPONSE_DATA);
        status = STATUS_SUCCESS;
        break;
    }
    default:
        Log("Unknown IOCTL received: 0x%08X", stack->Parameters.DeviceIoControl.IoControlCode);
        return ((DevCtrlPtr)(gOriginalDispatchFunctionArray[IRP_MJ_DEVICE_CONTROL]))(DeviceObject, Irp);
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = bytes;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}


```

`src/driver/driver.h`:

```h
#pragma once
#include "imports.h"

#ifdef FUMO_DRIVER_DEBUG

// FUMO
#define POOL_TAG 'OMUF'
#define Log(format, ...) DbgPrint("[FUMO] " format "\n", ##__VA_ARGS__)

#else

// None
#define POOL_TAG 'enoN'
#define Log(format, ...) 

#endif

DRIVER_INITIALIZE DriverEntry;
NTSTATUS SetHook(BOOL setHook);
NTSTATUS Hk_DeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp);
```

`src/driver/imports.h`:

```h
#pragma once
#include <ntifs.h>
#include <windef.h>
#include <wdm.h>

typedef struct _PEB_LDR_DATA {
    ULONG Length;
    UCHAR Initialized;
    PVOID SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB {
    UCHAR InheritedAddressSpace;
    UCHAR ReadImageFileExecOptions;
    UCHAR BeingDebugged;
    UCHAR BitField;
    PVOID Mutant;
    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PVOID ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PVOID FastPebLock;
    PVOID AtlThunkSListPtr;
    PVOID IFEOKey;
    PVOID CrossProcessFlags;
    PVOID KernelCallbackTable;
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    PVOID ApiSetMap;
} PEB, *PPEB;

typedef enum _KTHREAD_STATE {
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition,
    DeferredReady,
    GateWaitObsolete,
    WaitingForProcessInSwap,
    MaximumThreadState
} KTHREAD_STATE, *PKTHREAD_STATE;

typedef struct _SYSTEM_THREAD_INFORMATION {
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    KPRIORITY BasePriority;
    ULONG ContextSwitches;
    KTHREAD_STATE ThreadState;
    KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _TEB *PTEB;

// private
typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION {
    SYSTEM_THREAD_INFORMATION ThreadInfo;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID Win32StartAddress;
    PTEB TebBase; // since VISTA
    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;
} SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER WorkingSetPrivateSize; // since VISTA
    ULONG HardFaultCount; // since WIN7
    ULONG NumberOfThreadsHighWatermark; // since WIN7
    ULONGLONG CycleTime; // since WIN7
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR UniqueProcessKey; // since VISTA (requires SystemExtendedProcessInformation)
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
    SYSTEM_THREAD_INFORMATION Threads[1]; // SystemProcessInformation
    // SYSTEM_EXTENDED_THREAD_INFORMATION Threads[1]; // SystemExtendedProcessinformation
    // SYSTEM_EXTENDED_THREAD_INFORMATION + SYSTEM_PROCESS_INFORMATION_EXTENSION // SystemFullProcessInformation
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation, // q: SYSTEM_BASIC_INFORMATION
    SystemProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION
    SystemPerformanceInformation, // q: SYSTEM_PERFORMANCE_INFORMATION
    SystemTimeOfDayInformation, // q: SYSTEM_TIMEOFDAY_INFORMATION
    SystemPathInformation, // not implemented
    SystemProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
    SystemCallCountInformation, // q: SYSTEM_CALL_COUNT_INFORMATION
    SystemDeviceInformation, // q: SYSTEM_DEVICE_INFORMATION
    SystemProcessorPerformanceInformation, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemFlagsInformation, // q: SYSTEM_FLAGS_INFORMATION
    SystemCallTimeInformation, // not implemented // SYSTEM_CALL_TIME_INFORMATION // 10
    SystemModuleInformation, // q: RTL_PROCESS_MODULES
    SystemLocksInformation, // q: RTL_PROCESS_LOCKS
    SystemStackTraceInformation, // q: RTL_PROCESS_BACKTRACES
    SystemPagedPoolInformation, // not implemented
    SystemNonPagedPoolInformation, // not implemented
    SystemHandleInformation, // q: SYSTEM_HANDLE_INFORMATION
    SystemObjectInformation, // q: SYSTEM_OBJECTTYPE_INFORMATION mixed with SYSTEM_OBJECT_INFORMATION
    SystemPageFileInformation, // q: SYSTEM_PAGEFILE_INFORMATION
    SystemVdmInstemulInformation, // q: SYSTEM_VDM_INSTEMUL_INFO
    SystemVdmBopInformation, // not implemented // 20
    SystemFileCacheInformation, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemCache)
    SystemPoolTagInformation, // q: SYSTEM_POOLTAG_INFORMATION
    SystemInterruptInformation, // q: SYSTEM_INTERRUPT_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemDpcBehaviorInformation, // q: SYSTEM_DPC_BEHAVIOR_INFORMATION; s: SYSTEM_DPC_BEHAVIOR_INFORMATION (requires SeLoadDriverPrivilege)
    SystemFullMemoryInformation, // not implemented // SYSTEM_MEMORY_USAGE_INFORMATION
    SystemLoadGdiDriverInformation, // s (kernel-mode only)
    SystemUnloadGdiDriverInformation, // s (kernel-mode only)
    SystemTimeAdjustmentInformation, // q: SYSTEM_QUERY_TIME_ADJUST_INFORMATION; s: SYSTEM_SET_TIME_ADJUST_INFORMATION (requires SeSystemtimePrivilege)
    SystemSummaryMemoryInformation, // not implemented // SYSTEM_MEMORY_USAGE_INFORMATION
    SystemMirrorMemoryInformation, // s (requires license value "Kernel-MemoryMirroringSupported") (requires SeShutdownPrivilege) // 30
    SystemPerformanceTraceInformation, // q; s: (type depends on EVENT_TRACE_INFORMATION_CLASS)
    SystemObsolete0, // not implemented
    SystemExceptionInformation, // q: SYSTEM_EXCEPTION_INFORMATION
    SystemCrashDumpStateInformation, // s: SYSTEM_CRASH_DUMP_STATE_INFORMATION (requires SeDebugPrivilege)
    SystemKernelDebuggerInformation, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION
    SystemContextSwitchInformation, // q: SYSTEM_CONTEXT_SWITCH_INFORMATION
    SystemRegistryQuotaInformation, // q: SYSTEM_REGISTRY_QUOTA_INFORMATION; s (requires SeIncreaseQuotaPrivilege)
    SystemExtendServiceTableInformation, // s (requires SeLoadDriverPrivilege) // loads win32k only
    SystemPrioritySeperation, // s (requires SeTcbPrivilege)
    SystemVerifierAddDriverInformation, // s (requires SeDebugPrivilege) // 40
    SystemVerifierRemoveDriverInformation, // s (requires SeDebugPrivilege)
    SystemProcessorIdleInformation, // q: SYSTEM_PROCESSOR_IDLE_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemLegacyDriverInformation, // q: SYSTEM_LEGACY_DRIVER_INFORMATION
    SystemCurrentTimeZoneInformation, // q; s: RTL_TIME_ZONE_INFORMATION
    SystemLookasideInformation, // q: SYSTEM_LOOKASIDE_INFORMATION
    SystemTimeSlipNotification, // s: HANDLE (NtCreateEvent) (requires SeSystemtimePrivilege)
    SystemSessionCreate, // not implemented
    SystemSessionDetach, // not implemented
    SystemSessionInformation, // not implemented (SYSTEM_SESSION_INFORMATION)
    SystemRangeStartInformation, // q: SYSTEM_RANGE_START_INFORMATION // 50
    SystemVerifierInformation, // q: SYSTEM_VERIFIER_INFORMATION; s (requires SeDebugPrivilege)
    SystemVerifierThunkExtend, // s (kernel-mode only)
    SystemSessionProcessInformation, // q: SYSTEM_SESSION_PROCESS_INFORMATION
    SystemLoadGdiDriverInSystemSpace, // s: SYSTEM_GDI_DRIVER_INFORMATION (kernel-mode only) (same as SystemLoadGdiDriverInformation)
    SystemNumaProcessorMap, // q: SYSTEM_NUMA_INFORMATION
    SystemPrefetcherInformation, // q; s: PREFETCHER_INFORMATION // PfSnQueryPrefetcherInformation
    SystemExtendedProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
    SystemRecommendedSharedDataAlignment, // q: ULONG // KeGetRecommendedSharedDataAlignment
    SystemComPlusPackage, // q; s: ULONG
    SystemNumaAvailableMemory, // q: SYSTEM_NUMA_INFORMATION // 60
    SystemProcessorPowerInformation, // q: SYSTEM_PROCESSOR_POWER_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemEmulationBasicInformation, // q: SYSTEM_BASIC_INFORMATION
    SystemEmulationProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION
    SystemExtendedHandleInformation, // q: SYSTEM_HANDLE_INFORMATION_EX
    SystemLostDelayedWriteInformation, // q: ULONG
    SystemBigPoolInformation, // q: SYSTEM_BIGPOOL_INFORMATION
    SystemSessionPoolTagInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION
    SystemSessionMappedViewInformation, // q: SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
    SystemHotpatchInformation, // q; s: SYSTEM_HOTPATCH_CODE_INFORMATION
    SystemObjectSecurityMode, // q: ULONG // 70
    SystemWatchdogTimerHandler, // s: SYSTEM_WATCHDOG_HANDLER_INFORMATION // (kernel-mode only)
    SystemWatchdogTimerInformation, // q: SYSTEM_WATCHDOG_TIMER_INFORMATION // (kernel-mode only)
    SystemLogicalProcessorInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemWow64SharedInformationObsolete, // not implemented
    SystemRegisterFirmwareTableInformationHandler, // s: SYSTEM_FIRMWARE_TABLE_HANDLER // (kernel-mode only)
    SystemFirmwareTableInformation, // SYSTEM_FIRMWARE_TABLE_INFORMATION
    SystemModuleInformationEx, // q: RTL_PROCESS_MODULE_INFORMATION_EX
    SystemVerifierTriageInformation, // not implemented
    SystemSuperfetchInformation, // q; s: SUPERFETCH_INFORMATION // PfQuerySuperfetchInformation
    SystemMemoryListInformation, // q: SYSTEM_MEMORY_LIST_INFORMATION; s: SYSTEM_MEMORY_LIST_COMMAND (requires SeProfileSingleProcessPrivilege) // 80
    SystemFileCacheInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (same as SystemFileCacheInformation)
    SystemThreadPriorityClientIdInformation, // s: SYSTEM_THREAD_CID_PRIORITY_INFORMATION (requires SeIncreaseBasePriorityPrivilege)
    SystemProcessorIdleCycleTimeInformation, // q: SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION[] (EX in: USHORT ProcessorGroup)
    SystemVerifierCancellationInformation, // SYSTEM_VERIFIER_CANCELLATION_INFORMATION // name:wow64:whNT32QuerySystemVerifierCancellationInformation
    SystemProcessorPowerInformationEx, // not implemented
    SystemRefTraceInformation, // q; s: SYSTEM_REF_TRACE_INFORMATION // ObQueryRefTraceInformation
    SystemSpecialPoolInformation, // q; s: SYSTEM_SPECIAL_POOL_INFORMATION (requires SeDebugPrivilege) // MmSpecialPoolTag, then MmSpecialPoolCatchOverruns != 0
    SystemProcessIdInformation, // q: SYSTEM_PROCESS_ID_INFORMATION
    SystemErrorPortInformation, // s (requires SeTcbPrivilege)
    SystemBootEnvironmentInformation, // q: SYSTEM_BOOT_ENVIRONMENT_INFORMATION // 90
    SystemHypervisorInformation, // q: SYSTEM_HYPERVISOR_QUERY_INFORMATION
    SystemVerifierInformationEx, // q; s: SYSTEM_VERIFIER_INFORMATION_EX
    SystemTimeZoneInformation, // q; s: RTL_TIME_ZONE_INFORMATION (requires SeTimeZonePrivilege)
    SystemImageFileExecutionOptionsInformation, // s: SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION (requires SeTcbPrivilege)
    SystemCoverageInformation, // q: COVERAGE_MODULES s: COVERAGE_MODULE_REQUEST // ExpCovQueryInformation (requires SeDebugPrivilege)
    SystemPrefetchPatchInformation, // SYSTEM_PREFETCH_PATCH_INFORMATION
    SystemVerifierFaultsInformation, // s: SYSTEM_VERIFIER_FAULTS_INFORMATION (requires SeDebugPrivilege)
    SystemSystemPartitionInformation, // q: SYSTEM_SYSTEM_PARTITION_INFORMATION
    SystemSystemDiskInformation, // q: SYSTEM_SYSTEM_DISK_INFORMATION
    SystemProcessorPerformanceDistribution, // q: SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION (EX in: USHORT ProcessorGroup) // 100
    SystemNumaProximityNodeInformation, // q; s: SYSTEM_NUMA_PROXIMITY_MAP
    SystemDynamicTimeZoneInformation, // q; s: RTL_DYNAMIC_TIME_ZONE_INFORMATION (requires SeTimeZonePrivilege)
    SystemCodeIntegrityInformation, // q: SYSTEM_CODEINTEGRITY_INFORMATION // SeCodeIntegrityQueryInformation
    SystemProcessorMicrocodeUpdateInformation, // s: SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION
    SystemProcessorBrandString, // q: CHAR[] // HaliQuerySystemInformation -> HalpGetProcessorBrandString, info class 23
    SystemVirtualAddressInformation, // q: SYSTEM_VA_LIST_INFORMATION[]; s: SYSTEM_VA_LIST_INFORMATION[] (requires SeIncreaseQuotaPrivilege) // MmQuerySystemVaInformation
    SystemLogicalProcessorAndGroupInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX (EX in: LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType) // since WIN7 // KeQueryLogicalProcessorRelationship
    SystemProcessorCycleTimeInformation, // q: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION[] (EX in: USHORT ProcessorGroup)
    SystemStoreInformation, // q; s: SYSTEM_STORE_INFORMATION (requires SeProfileSingleProcessPrivilege) // SmQueryStoreInformation
    SystemRegistryAppendString, // s: SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS // 110
    SystemAitSamplingValue, // s: ULONG (requires SeProfileSingleProcessPrivilege)
    SystemVhdBootInformation, // q: SYSTEM_VHD_BOOT_INFORMATION
    SystemCpuQuotaInformation, // q; s: PS_CPU_QUOTA_QUERY_INFORMATION
    SystemNativeBasicInformation, // q: SYSTEM_BASIC_INFORMATION
    SystemErrorPortTimeouts, // SYSTEM_ERROR_PORT_TIMEOUTS
    SystemLowPriorityIoInformation, // q: SYSTEM_LOW_PRIORITY_IO_INFORMATION
    SystemTpmBootEntropyInformation, // q: TPM_BOOT_ENTROPY_NT_RESULT // ExQueryTpmBootEntropyInformation
    SystemVerifierCountersInformation, // q: SYSTEM_VERIFIER_COUNTERS_INFORMATION
    SystemPagedPoolInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypePagedPool)
    SystemSystemPtesInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemPtes) // 120
    SystemNodeDistanceInformation, // q: USHORT[4*NumaNodes] // (EX in: USHORT NodeNumber)
    SystemAcpiAuditInformation, // q: SYSTEM_ACPI_AUDIT_INFORMATION // HaliQuerySystemInformation -> HalpAuditQueryResults, info class 26
    SystemBasicPerformanceInformation, // q: SYSTEM_BASIC_PERFORMANCE_INFORMATION // name:wow64:whNtQuerySystemInformation_SystemBasicPerformanceInformation
    SystemQueryPerformanceCounterInformation, // q: SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION // since WIN7 SP1
    SystemSessionBigPoolInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION // since WIN8
    SystemBootGraphicsInformation, // q; s: SYSTEM_BOOT_GRAPHICS_INFORMATION (kernel-mode only)
    SystemScrubPhysicalMemoryInformation, // q; s: MEMORY_SCRUB_INFORMATION
    SystemBadPageInformation,
    SystemProcessorProfileControlArea, // q; s: SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA
    SystemCombinePhysicalMemoryInformation, // s: MEMORY_COMBINE_INFORMATION, MEMORY_COMBINE_INFORMATION_EX, MEMORY_COMBINE_INFORMATION_EX2 // 130
    SystemEntropyInterruptTimingInformation, // q; s: SYSTEM_ENTROPY_TIMING_INFORMATION
    SystemConsoleInformation, // q; s: SYSTEM_CONSOLE_INFORMATION
    SystemPlatformBinaryInformation, // q: SYSTEM_PLATFORM_BINARY_INFORMATION (requires SeTcbPrivilege)
    SystemPolicyInformation, // q: SYSTEM_POLICY_INFORMATION (Warbird/Encrypt/Decrypt/Execute)
    SystemHypervisorProcessorCountInformation, // q: SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION
    SystemDeviceDataInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemDeviceDataEnumerationInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemMemoryTopologyInformation, // q: SYSTEM_MEMORY_TOPOLOGY_INFORMATION
    SystemMemoryChannelInformation, // q: SYSTEM_MEMORY_CHANNEL_INFORMATION
    SystemBootLogoInformation, // q: SYSTEM_BOOT_LOGO_INFORMATION // 140
    SystemProcessorPerformanceInformationEx, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX // (EX in: USHORT ProcessorGroup) // since WINBLUE
    SystemCriticalProcessErrorLogInformation,
    SystemSecureBootPolicyInformation, // q: SYSTEM_SECUREBOOT_POLICY_INFORMATION
    SystemPageFileInformationEx, // q: SYSTEM_PAGEFILE_INFORMATION_EX
    SystemSecureBootInformation, // q: SYSTEM_SECUREBOOT_INFORMATION
    SystemEntropyInterruptTimingRawInformation,
    SystemPortableWorkspaceEfiLauncherInformation, // q: SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION
    SystemFullProcessInformation, // q: SYSTEM_PROCESS_INFORMATION with SYSTEM_PROCESS_INFORMATION_EXTENSION (requires admin)
    SystemKernelDebuggerInformationEx, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
    SystemBootMetadataInformation, // 150
    SystemSoftRebootInformation, // q: ULONG
    SystemElamCertificateInformation, // s: SYSTEM_ELAM_CERTIFICATE_INFORMATION
    SystemOfflineDumpConfigInformation, // q: OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2
    SystemProcessorFeaturesInformation, // q: SYSTEM_PROCESSOR_FEATURES_INFORMATION
    SystemRegistryReconciliationInformation, // s: NULL (requires admin) (flushes registry hives)
    SystemEdidInformation, // q: SYSTEM_EDID_INFORMATION
    SystemManufacturingInformation, // q: SYSTEM_MANUFACTURING_INFORMATION // since THRESHOLD
    SystemEnergyEstimationConfigInformation, // q: SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION
    SystemHypervisorDetailInformation, // q: SYSTEM_HYPERVISOR_DETAIL_INFORMATION
    SystemProcessorCycleStatsInformation, // q: SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION (EX in: USHORT ProcessorGroup) // 160
    SystemVmGenerationCountInformation,
    SystemTrustedPlatformModuleInformation, // q: SYSTEM_TPM_INFORMATION
    SystemKernelDebuggerFlags, // SYSTEM_KERNEL_DEBUGGER_FLAGS
    SystemCodeIntegrityPolicyInformation, // q; s: SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
    SystemIsolatedUserModeInformation, // q: SYSTEM_ISOLATED_USER_MODE_INFORMATION
    SystemHardwareSecurityTestInterfaceResultsInformation,
    SystemSingleModuleInformation, // q: SYSTEM_SINGLE_MODULE_INFORMATION
    SystemAllowedCpuSetsInformation, // s: SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION
    SystemVsmProtectionInformation, // q: SYSTEM_VSM_PROTECTION_INFORMATION (previously SystemDmaProtectionInformation)
    SystemInterruptCpuSetsInformation, // q: SYSTEM_INTERRUPT_CPU_SET_INFORMATION // 170
    SystemSecureBootPolicyFullInformation, // q: SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
    SystemCodeIntegrityPolicyFullInformation,
    SystemAffinitizedInterruptProcessorInformation, // (requires SeIncreaseBasePriorityPrivilege)
    SystemRootSiloInformation, // q: SYSTEM_ROOT_SILO_INFORMATION
    SystemCpuSetInformation, // q: SYSTEM_CPU_SET_INFORMATION // since THRESHOLD2
    SystemCpuSetTagInformation, // q: SYSTEM_CPU_SET_TAG_INFORMATION
    SystemWin32WerStartCallout,
    SystemSecureKernelProfileInformation, // q: SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION
    SystemCodeIntegrityPlatformManifestInformation, // q: SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION // since REDSTONE
    SystemInterruptSteeringInformation, // q: in: SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT, out: SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT // NtQuerySystemInformationEx // 180
    SystemSupportedProcessorArchitectures, // p: in opt: HANDLE, out: SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION[] // NtQuerySystemInformationEx
    SystemMemoryUsageInformation, // q: SYSTEM_MEMORY_USAGE_INFORMATION
    SystemCodeIntegrityCertificateInformation, // q: SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
    SystemPhysicalMemoryInformation, // q: SYSTEM_PHYSICAL_MEMORY_INFORMATION // since REDSTONE2
    SystemControlFlowTransition, // (Warbird/Encrypt/Decrypt/Execute)
    SystemKernelDebuggingAllowed, // s: ULONG
    SystemActivityModerationExeState, // SYSTEM_ACTIVITY_MODERATION_EXE_STATE
    SystemActivityModerationUserSettings, // SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS
    SystemCodeIntegrityPoliciesFullInformation,
    SystemCodeIntegrityUnlockInformation, // SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION // 190
    SystemIntegrityQuotaInformation,
    SystemFlushInformation, // q: SYSTEM_FLUSH_INFORMATION
    SystemProcessorIdleMaskInformation, // q: ULONG_PTR[ActiveGroupCount] // since REDSTONE3
    SystemSecureDumpEncryptionInformation,
    SystemWriteConstraintInformation, // SYSTEM_WRITE_CONSTRAINT_INFORMATION
    SystemKernelVaShadowInformation, // SYSTEM_KERNEL_VA_SHADOW_INFORMATION
    SystemHypervisorSharedPageInformation, // SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION // since REDSTONE4
    SystemFirmwareBootPerformanceInformation,
    SystemCodeIntegrityVerificationInformation, // SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION
    SystemFirmwarePartitionInformation, // SYSTEM_FIRMWARE_PARTITION_INFORMATION // 200
    SystemSpeculationControlInformation, // SYSTEM_SPECULATION_CONTROL_INFORMATION // (CVE-2017-5715) REDSTONE3 and above.
    SystemDmaGuardPolicyInformation, // SYSTEM_DMA_GUARD_POLICY_INFORMATION
    SystemEnclaveLaunchControlInformation, // SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION
    SystemWorkloadAllowedCpuSetsInformation, // SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION // since REDSTONE5
    SystemCodeIntegrityUnlockModeInformation, // SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION
    SystemLeapSecondInformation, // SYSTEM_LEAP_SECOND_INFORMATION
    SystemFlags2Information, // q: SYSTEM_FLAGS_INFORMATION
    SystemSecurityModelInformation, // SYSTEM_SECURITY_MODEL_INFORMATION // since 19H1
    SystemCodeIntegritySyntheticCacheInformation,
    SystemFeatureConfigurationInformation, // SYSTEM_FEATURE_CONFIGURATION_INFORMATION // since 20H1 // 210
    SystemFeatureConfigurationSectionInformation, // SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION
    SystemFeatureUsageSubscriptionInformation, // SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS
    SystemSecureSpeculationControlInformation, // SECURE_SPECULATION_CONTROL_INFORMATION
    SystemSpacesBootInformation, // since 20H2
    SystemFwRamdiskInformation, // SYSTEM_FIRMWARE_RAMDISK_INFORMATION
    SystemWheaIpmiHardwareInformation,
    SystemDifSetRuleClassInformation, // SYSTEM_DIF_VOLATILE_INFORMATION
    SystemDifClearRuleClassInformation,
    SystemDifApplyPluginVerificationOnDriver, // SYSTEM_DIF_PLUGIN_DRIVER_INFORMATION
    SystemDifRemovePluginVerificationOnDriver, // SYSTEM_DIF_PLUGIN_DRIVER_INFORMATION // 220
    SystemShadowStackInformation, // SYSTEM_SHADOW_STACK_INFORMATION
    SystemBuildVersionInformation, // q: in: ULONG (LayerNumber), out: SYSTEM_BUILD_VERSION_INFORMATION // NtQuerySystemInformationEx // 222
    SystemPoolLimitInformation, // SYSTEM_POOL_LIMIT_INFORMATION (requires SeIncreaseQuotaPrivilege)
    SystemCodeIntegrityAddDynamicStore,
    SystemCodeIntegrityClearDynamicStores,
    SystemDifPoolTrackingInformation,
    SystemPoolZeroingInformation, // q: SYSTEM_POOL_ZEROING_INFORMATION
    SystemDpcWatchdogInformation, // q; s: SYSTEM_DPC_WATCHDOG_CONFIGURATION_INFORMATION
    SystemDpcWatchdogInformation2, // q; s: SYSTEM_DPC_WATCHDOG_CONFIGURATION_INFORMATION_V2
    SystemSupportedProcessorArchitectures2, // q: in opt: HANDLE, out: SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION[] // NtQuerySystemInformationEx // 230
    SystemSingleProcessorRelationshipInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX // (EX in: PROCESSOR_NUMBER Processor)
    SystemXfgCheckFailureInformation, // q: SYSTEM_XFG_FAILURE_INFORMATION
    SystemIommuStateInformation, // SYSTEM_IOMMU_STATE_INFORMATION // since 22H1
    SystemHypervisorMinrootInformation, // SYSTEM_HYPERVISOR_MINROOT_INFORMATION
    SystemHypervisorBootPagesInformation, // SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION
    SystemPointerAuthInformation, // SYSTEM_POINTER_AUTH_INFORMATION
    SystemSecureKernelDebuggerInformation,
    SystemOriginalImageFeatureInformation, // q: in: SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT, out: SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT // NtQuerySystemInformationEx
    MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS;

typedef enum _KAPC_ENVIRONMENT {
    OriginalApcEnvironment,
    AttachedApcEnvironment,
    CurrentApcEnvironment,
    InsertApcEnvironment
} KAPC_ENVIRONMENT, *PKAPC_ENVIRONMENT;

typedef VOID(NTAPI *PKNORMAL_ROUTINE)(
    PVOID NormalContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
);

typedef VOID(NTAPI* PKKERNEL_ROUTINE)(
    PRKAPC Apc,
    PKNORMAL_ROUTINE *NormalRoutine,
    PVOID *NormalContext,
    PVOID *SystemArgument1,
    PVOID *SystemArgument2
);

typedef VOID(NTAPI *PKRUNDOWN_ROUTINE)(PRKAPC Apc);

typedef NTSTATUS(*DevCtrlPtr)(PDEVICE_OBJECT, PIRP Irp);

NTSYSCALLAPI NTSTATUS NTAPI ZwQuerySystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
);

NTKERNELAPI NTSTATUS ObReferenceObjectByName(
    __in PUNICODE_STRING ObjectName,
    __in ULONG Attributes,
    __in_opt PACCESS_STATE AccessState,
    __in_opt ACCESS_MASK DesiredAccess,
    __in POBJECT_TYPE ObjectType,
    __in KPROCESSOR_MODE AccessMode,
    __inout_opt PVOID ParseContext,
    __out PVOID* Object
);

NTKERNELAPI PUCHAR NTAPI PsGetProcessImageFileName(
    _In_ PEPROCESS Process
);

NTKERNELAPI PVOID MmGetVirtualForPhysical(
    __in PHYSICAL_ADDRESS PhysicalAddress
);

NTKERNELAPI PVOID NTAPI PsGetThreadTeb(
    IN PETHREAD Thread
);

NTKERNELAPI VOID NTAPI KeInitializeApc( 
    IN PKAPC Apc,
    IN PKTHREAD Thread,
    IN KAPC_ENVIRONMENT ApcStateIndex,
    IN PKKERNEL_ROUTINE KernelRoutine,
    IN PKRUNDOWN_ROUTINE RundownRoutine,
    IN PKNORMAL_ROUTINE NormalRoutine,
    IN KPROCESSOR_MODE ApcMode,
    IN PVOID NormalContext
);

NTKERNELAPI BOOLEAN NTAPI KeInsertQueueApc(
    PKAPC Apc,
    PVOID SystemArgument1,
    PVOID SystemArgument2,
    KPRIORITY Increment
);

NTKERNELAPI BOOLEAN NTAPI KeTestAlertThread(
    IN KPROCESSOR_MODE AlertMode
);

NTKERNELAPI VOID NTAPI KeFlushCurrentTbImmediately();

NTKERNELAPI VOID NTAPI KeFlushEntireTb();

NTKERNELAPI PPEB NTAPI PsGetProcessPeb(
    IN PEPROCESS Process
);

__declspec(dllimport) POBJECT_TYPE *IoDriverObjectType;
```

`src/driver/memory.c`:

```c
#include "memory.h"

uint64_t GetProcessDirectoryTableBase(PEPROCESS pProcess) {
    PUCHAR process = (PUCHAR)pProcess;
    return *(uint64_t*)(process + 0x28); // DirectoryTableBase;
}

PVOID GetVirtualForPhysical(uint64_t PhysicalAddress) {
    PHYSICAL_ADDRESS AddrToRead = {0};
    AddrToRead.QuadPart = PhysicalAddress;
    return MmGetVirtualForPhysical(AddrToRead);
}

BOOL ReadPhysicalUnsafe(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size) {
    PVOID VirtualAddress = GetVirtualForPhysical(TargetAddress);
    if (!VirtualAddress)
        return FALSE;
    RtlCopyMemory(lpBuffer, VirtualAddress, Size);
    return TRUE;
}

BOOL WritePhysicalUnsafe(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size) {
    PVOID VirtualAddress = GetVirtualForPhysical(TargetAddress);
    if (!VirtualAddress)
        return FALSE;
    RtlCopyMemory(VirtualAddress, lpBuffer, Size);
    return TRUE;
}

PAGE_TABLE_INFO QueryPageTableInfo(uint64_t DirectoryTableBase, PVOID Va) {
    PAGE_TABLE_INFO Pi = {0,0,0,0};

    VIRT_ADDR Addr = {(uint64_t)Va};
    PTE_CR3 Cr3 = {DirectoryTableBase};
    SIZE_T read_size = 0;

    {
        uint64_t Plm4eAddr = PFN_TO_PAGE(Cr3.pml4_p) + sizeof(PML4E) * Addr.pml4_index;
        PML4E* Plm4e = (PML4E*)GetVirtualForPhysical(Plm4eAddr);
        if (!Plm4e->present)
            return Pi;
        Pi.Pml4e = Plm4e;
    }

    {
        uint64_t PdpteAddr = PFN_TO_PAGE(Pi.Pml4e->pdpt_p) + sizeof(PDPTE) * Addr.pdpt_index;
        PDPTE* Pdpte = (PDPTE*)GetVirtualForPhysical(PdpteAddr);
        if (!Pdpte->present)
            return Pi;
        Pi.Pdpte = Pdpte;
    }

    {
        uint64_t PdeAddr = PFN_TO_PAGE(Pi.Pdpte->pd_p) + sizeof(PDE) * Addr.pd_index;
        PDE* Pde = (PDE*)GetVirtualForPhysical(PdeAddr);
        if (!Pde->present)
            return Pi;
        Pi.Pde = Pde;
        if (Pi.Pde->page_size)
            return Pi;
    }

    {
        uint64_t PteAddr = PFN_TO_PAGE(Pi.Pde->pt_p) + sizeof(PTE) * Addr.pt_index;
        PTE* Pte = (PTE*)GetVirtualForPhysical(PteAddr);
        if (!Pte->present)
            return Pi;
        Pi.Pte = Pte;
    }

    return Pi;
}

uint64_t VirtToPhys(uint64_t DirectoryTableBase, PVOID Va) {
    PAGE_TABLE_INFO Info = QueryPageTableInfo(DirectoryTableBase, Va);
    SIZE_T read_size = 0;
    uint64_t Pa = 0;

    if (!Info.Pde)
        return 0;

    if (Info.Pde->page_size) {
        Pa = PFN_TO_PAGE(Info.Pde->pt_p);
        Pa += (uint64_t)Va & (0x200000 - 1);
            return Pa;
    }

    if (!Info.Pte)
        return 0;

    Pa = PFN_TO_PAGE(Info.Pte->page_frame);
    Pa += (uint64_t)Va & (0x1000 - 1);
    
    return Pa;
}

BOOL ExposeKernelMemoryToProcess(PEPROCESS pProcess, PVOID Address, SIZE_T Size) {
    if (!pProcess || !Address || !Size)
        return FALSE;

    PUCHAR pProcessName = PsGetProcessImageFileName(pProcess);
    if (!pProcessName)
        return FALSE;
  
    Log("Exposing kernel memory to %s (%d) at 0x%p with size 0x%X", pProcessName, PsGetProcessId(pProcess), Address, Size);

    uint64_t DirectoryTableBase = GetProcessDirectoryTableBase(pProcess);

    PUCHAR It = (PUCHAR)Address;
    PUCHAR End = It + Size;
    BOOL success = TRUE;

    while (It < End) {
        SIZE_T Size = (PUCHAR)(((uint64_t)It + 0x1000) & (~0xFFF)) - It;

        if ((It + Size) > End)
            Size = End - It;

        PAGE_TABLE_INFO Pti = QueryPageTableInfo(DirectoryTableBase, It);
        It += Size;

        if (!Pti.Pde || (Pti.Pte && !Pti.Pte->present)) {
            success = FALSE;
            continue;
        }

        Pti.Pml4e->user = TRUE;
        Pti.Pdpte->user = TRUE;
        Pti.Pde->user = TRUE;
        if (Pti.Pte)
            Pti.Pte->user = TRUE;
    }

    KeFlushEntireTb();
    KeInvalidateAllCaches();

    return success;
}

PVOID FindModule(PEPROCESS pProcess, PUNICODE_STRING ModuleName) {
    if (!pProcess || !ModuleName)
        return NULL;
    
    PPEB pPeb = PsGetProcessPeb(pProcess);
    if (!pPeb)
        return NULL;
    
    PPEB_LDR_DATA pLdr = pPeb->Ldr;
    if (!pLdr)
        return NULL;
    
    for (PLIST_ENTRY pListEntry = pLdr->InLoadOrderModuleList.Flink; pListEntry != &pLdr->InLoadOrderModuleList; pListEntry = pListEntry->Flink) {
        PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        if (RtlCompareUnicodeString(&pEntry->BaseDllName, ModuleName, TRUE) == 0)
            return pEntry->DllBase;
    }

    return NULL;
}
```

`src/driver/memory.h`:

```h
#pragma once
#include "driver.h"

typedef unsigned long long uint64_t;

#define PFN_TO_PAGE(pfn) ( pfn << 12 )

#pragma pack(push, 1)
typedef union CR3_
{
    uint64_t value;
    struct
    {
        uint64_t ignored_1 : 3;
        uint64_t write_through : 1;
        uint64_t cache_disable : 1;
        uint64_t ignored_2 : 7;
        uint64_t pml4_p : 40;
        uint64_t reserved : 12;
    };
} PTE_CR3;

typedef union VIRT_ADDR_
{
    uint64_t value;
    void *pointer;
    struct
    {
        uint64_t offset : 12;
        uint64_t pt_index : 9;
        uint64_t pd_index : 9;
        uint64_t pdpt_index : 9;
        uint64_t pml4_index : 9;
        uint64_t reserved : 16;
    };
} VIRT_ADDR;

typedef union PML4E_
{
    uint64_t value;
    struct
    {
        uint64_t present : 1;
        uint64_t rw : 1;
        uint64_t user : 1;
        uint64_t write_through : 1;
        uint64_t cache_disable : 1;
        uint64_t accessed : 1;
        uint64_t ignored_1 : 1;
        uint64_t reserved_1 : 1;
        uint64_t ignored_2 : 4;
        uint64_t pdpt_p : 40;
        uint64_t ignored_3 : 11;
        uint64_t xd : 1;
    };
} PML4E;

typedef union PDPTE_
{
    uint64_t value;
    struct
    {
        uint64_t present : 1;
        uint64_t rw : 1;
        uint64_t user : 1;
        uint64_t write_through : 1;
        uint64_t cache_disable : 1;
        uint64_t accessed : 1;
        uint64_t dirty : 1;
        uint64_t page_size : 1;
        uint64_t ignored_2 : 4;
        uint64_t pd_p : 40;
        uint64_t ignored_3 : 11;
        uint64_t xd : 1;
    };
} PDPTE;

typedef union PDE_
{
    uint64_t value;
    struct
    {
        uint64_t present : 1;
        uint64_t rw : 1;
        uint64_t user : 1;
        uint64_t write_through : 1;
        uint64_t cache_disable : 1;
        uint64_t accessed : 1;
        uint64_t dirty : 1;
        uint64_t page_size : 1;
        uint64_t ignored_2 : 4;
        uint64_t pt_p : 40;
        uint64_t ignored_3 : 11;
        uint64_t xd : 1;
    };
} PDE;

typedef union PTE_
{
    uint64_t value;
    VIRT_ADDR vaddr;
    struct
    {
        uint64_t present : 1;
        uint64_t rw : 1;
        uint64_t user : 1;
        uint64_t write_through : 1;
        uint64_t cache_disable : 1;
        uint64_t accessed : 1;
        uint64_t dirty : 1;
        uint64_t pat : 1;
        uint64_t global : 1;
        uint64_t ignored_1 : 3;
        uint64_t page_frame : 40;
        uint64_t ignored_3 : 11;
        uint64_t xd : 1;
    };
} PTE;
#pragma pack(pop)

typedef struct PAGE_TABLE_INFO_ {
    PML4E* Pml4e;
    PDPTE* Pdpte;
    PDE* Pde;
    PTE* Pte;
} PAGE_TABLE_INFO, *PPAGE_TABLE_INFO;

uint64_t GetProcessDirectoryTableBase(PEPROCESS pProcess);
PVOID GetVirtualForPhysical(uint64_t PhysicalAddress);
BOOL ReadPhysicalUnsafe(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size);
BOOL WritePhysicalUnsafe(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size);
PAGE_TABLE_INFO QueryPageTableInfo(uint64_t directoryTableBase, PVOID Va);
uint64_t VirtToPhys(uint64_t DirectoryTableBase, PVOID Va);
BOOL ExposeKernelMemoryToProcess(PEPROCESS pProcess, PVOID Address, SIZE_T Size);
PVOID FindModule(PEPROCESS pProcess, PUNICODE_STRING ModuleName);
```

`src/driver/thread.c`:

```c
#include "thread.h"

NTSTATUS EnumProcesses(PVOID *ppProcesses, SYSTEM_INFORMATION_CLASS SystemInformationClass) {
    ULONG bufferSize = 0x1000 * 0x1000;
    PVOID buffer = ExAllocatePool2(POOL_FLAG_NON_PAGED, bufferSize, POOL_TAG);
    if (!buffer)
        return STATUS_INSUFFICIENT_RESOURCES;

    NTSTATUS status;
    while (TRUE) {
        status = ZwQuerySystemInformation(SystemInformationClass, buffer, bufferSize, &bufferSize);
        if (status == STATUS_INFO_LENGTH_MISMATCH || status == STATUS_BUFFER_TOO_SMALL) {
            Log("Buffer too small, reallocating to 0x%X", bufferSize);
            ExFreePoolWithTag(buffer, POOL_TAG);
            buffer = ExAllocatePool2(POOL_FLAG_NON_PAGED, bufferSize, POOL_TAG);
            if (!buffer)
                return STATUS_INSUFFICIENT_RESOURCES;
        } else {
            break;
        }
    }

    if (!NT_SUCCESS(status)) {
        ExFreePoolWithTag(buffer, POOL_TAG);
        return status;
    }

    *ppProcesses = buffer;
    return STATUS_SUCCESS;
}

PSYSTEM_PROCESS_INFORMATION FindProcessInformation(PVOID Processes, HANDLE ProcessId) {
    PSYSTEM_PROCESS_INFORMATION process = (PSYSTEM_PROCESS_INFORMATION)Processes;
    for (;;) {
        if (process->UniqueProcessId == ProcessId) {
            return process;
        } else if (process->NextEntryOffset) {
            process = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)process + process->NextEntryOffset);
        } else {
            break;
        }
    }
    return NULL;
}

NTSTATUS FindProcessThread(PEPROCESS pProcess, PETHREAD* ppThread) {
    PVOID Processes = NULL;
    NTSTATUS status = EnumProcesses(&Processes, SystemProcessInformation);
    if (!NT_SUCCESS(status)) {
        Log("Failed to enumerate processes (0x%08X)", status);
        return status;
    }

    PSYSTEM_PROCESS_INFORMATION process = FindProcessInformation(Processes, PsGetProcessId(pProcess));
    if (!process) {
        Log("Failed to find process information");
        ExFreePoolWithTag(Processes, POOL_TAG);
        return STATUS_NOT_FOUND;
    }

    for (ULONG i = 0; i < process->NumberOfThreads; i++) {
        HANDLE threadId = process->Threads[i].ClientId.UniqueThread;

        // Skip current thread.
        if (threadId == PsGetCurrentThreadId()) {
            continue;
        }

        PETHREAD pThread = NULL;
        status = PsLookupThreadByThreadId(threadId, &pThread);
        if (!NT_SUCCESS(status) || !pThread) {
            Log("Failed to lookup thread by thread id (0x%08X)", status);
            ExFreePoolWithTag(Processes, POOL_TAG);
            return status;
        }

        if (!SkipThread(pThread)) {
            Log("Found thread 0x%p", pThread);
            *ppThread = pThread;
            ExFreePoolWithTag(Processes, POOL_TAG);
            return STATUS_SUCCESS;
        }

        ObDereferenceObject(pThread);
    }

    ExFreePoolWithTag(Processes, POOL_TAG);
    return STATUS_NOT_FOUND;
}

BOOL SkipThread(PETHREAD pThread) {
    PUCHAR pTeb64 = PsGetThreadTeb(pThread);

    // Skip GUI treads.
    if (*(PULONG64)(pTeb64 + 0x78) != 0) { // Win32ThreadInfo
        Log("Skipping GUI thread");
        return TRUE;
    }

    // Skip threads with no ActivationContext
    if (*(PULONG64)(pTeb64 + 0x2C8) == 0) { // ActivationContextStackPointer
        Log("Skipping thread with no ActivationContext");
        return TRUE;
    }

    // Skip threads with no TLS pointer
    if (*(PULONG64)(pTeb64 + 0x58) == 0) { // ThreadLocalStoragePointer
        Log("Skipping thread with no TLS pointer");
        return TRUE;
    }

    return FALSE;
}

VOID KernelApcCallback(PKAPC Apc, PKNORMAL_ROUTINE* NormalRoutine, 
    PVOID* NormalContext, PVOID* SystemArgument1, PVOID* SystemArgument2) {
    UNREFERENCED_PARAMETER(NormalContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    Log("KernelApcCallback called with NormalRoutine 0x%p", *NormalRoutine);

    // Skip execution
    if (PsIsThreadTerminating(PsGetCurrentThread()))
        *NormalRoutine = NULL;

    ExFreePoolWithTag(Apc, POOL_TAG);
}

VOID KernelApcPrepareCallback(PKAPC Apc, PKNORMAL_ROUTINE* NormalRoutine,
    PVOID* NormalContext, PVOID* SystemArgument1, PVOID* SystemArgument2) {
    UNREFERENCED_PARAMETER(NormalRoutine);
    UNREFERENCED_PARAMETER(NormalContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    Log("KernelApcPrepareCallback called");

    // Alert current thread
    KeTestAlertThread(UserMode);

    ExFreePoolWithTag(Apc, POOL_TAG);
}

NTSTATUS QueueUserApc(PETHREAD pThread, PVOID pUserFunc, PVOID Argument) {
    PKAPC apc = ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(KAPC), POOL_TAG);
    if (!apc)
        return STATUS_INSUFFICIENT_RESOURCES;
    
    KeInitializeApc(apc, pThread, OriginalApcEnvironment, &KernelApcCallback, 
        NULL, (PKNORMAL_ROUTINE)(ULONG_PTR)pUserFunc, UserMode, Argument);

    PKAPC apcPrepare = ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(KAPC), POOL_TAG);
    if (!apcPrepare) {
        ExFreePoolWithTag(apc, POOL_TAG);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeApc(apcPrepare, pThread, OriginalApcEnvironment, 
        &KernelApcPrepareCallback, NULL, NULL, KernelMode, NULL);

    if (!KeInsertQueueApc(apc, NULL, NULL, 0)) {
        Log("Failed to insert APC");
        ExFreePoolWithTag(apc, POOL_TAG);
        ExFreePoolWithTag(apcPrepare, POOL_TAG);
        return STATUS_UNSUCCESSFUL;
    }

    if (!KeInsertQueueApc(apcPrepare, NULL, NULL, 0)) {
        Log("Failed to insert prepare APC");
        ExFreePoolWithTag(apc, POOL_TAG);
        ExFreePoolWithTag(apcPrepare, POOL_TAG);
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}
```

`src/driver/thread.h`:

```h
#pragma once
#include "driver.h"

NTSTATUS EnumProcesses(PVOID *ppProcesses, SYSTEM_INFORMATION_CLASS SystemInformationClass);
PSYSTEM_PROCESS_INFORMATION FindProcessInformation(PVOID Processes, HANDLE ProcessId);
NTSTATUS FindProcessThread(PEPROCESS pProcess, PETHREAD* ppThread);
BOOL SkipThread(PETHREAD pThread);
NTSTATUS QueueUserApc(PETHREAD pThread, PVOID pUserFunc, PVOID Argument);
```

`src/driver_interface/CMakeLists.txt`:

```txt
add_library(driver_interface STATIC driver_interface.cpp)
target_include_directories(driver_interface PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../include)
target_include_directories(driver_interface PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
target_compile_features(driver_interface PUBLIC c_std_17 cxx_std_20)
```

`src/driver_interface/driver_interface.cpp`:

```cpp
#include "driver_interface.h"

std::shared_ptr<fumo::DriverInterface> fumo::DriverInterface::Open(LPCWSTR lpFileName) {
    HANDLE hDevice = CreateFileW(lpFileName, GENERIC_WRITE, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE) {
        return nullptr;
    }
    // not using make_shared because the constructor is private
    return std::shared_ptr<fumo::DriverInterface>(new fumo::DriverInterface(hDevice));
}

VOID fumo::DriverInterface::Unload() {
    DeviceIoControl(hDevice, IO_UNLOAD_REQUEST, 
        nullptr, 0, 
        nullptr, 0, 
        nullptr, nullptr);
}

BOOL fumo::DriverInterface::GetVersion(PULONG pVersion) {
    IO_VERSION_RESPONSE_DATA version_response = {0};
    if (!DeviceIoControl(hDevice, IO_VERSION_REQUEST, 
        nullptr, 0, 
        &version_response, sizeof(version_response), 
        nullptr, nullptr)) {
        return FALSE;
    }
    *pVersion = version_response.Version;
    return TRUE;
}

PVOID fumo::DriverInterface::AllocateKernelMemory(ULONG size) {
    IO_ALLOC_REQUEST_DATA alloc_request = {0};
    alloc_request.Size = size;

    IO_ALLOC_RESPONSE_DATA alloc_response = {0};
    if (!DeviceIoControl(hDevice, IO_ALLOC_REQUEST, 
        &alloc_request, sizeof(alloc_request), 
        &alloc_response, sizeof(alloc_response), 
        nullptr, nullptr)) {
        return nullptr;
    }

    return alloc_response.Address;
}

BOOL fumo::DriverInterface::ExposeKernelMemory(ULONG pid, PVOID address, ULONG size) {
    IO_MAP_MEMORY_REQUEST_DATA map_data = {0};
    map_data.Pid = pid;
    map_data.Address = address;
    map_data.Size = size;

    return DeviceIoControl(hDevice, IO_MAP_MEMORY_REQUEST, 
        &map_data, sizeof(map_data), 
        nullptr, 0, 
        nullptr, nullptr);
}

BOOL fumo::DriverInterface::ExecuteCode(ULONG pid, PVOID address, PVOID argument) {
    IO_EXECUTE_REQUEST_DATA execute_request = {0};
    execute_request.Pid = pid;
    execute_request.Address = address;
    execute_request.Argument = argument;

    return DeviceIoControl(hDevice, IO_EXECUTE_REQUEST, 
        &execute_request, sizeof(execute_request), 
        nullptr, 0, 
        nullptr, nullptr);
}

BOOL fumo::DriverInterface::FindModule(ULONG pid, LPCWSTR lpModuleName, PVOID* Address) {
    IO_FIND_MODULE_REQUEST_DATA find_module_request = {0};
    find_module_request.Pid = pid;
    wcscpy_s(find_module_request.ModuleName, lpModuleName);

    IO_FIND_MODULE_RESPONSE_DATA find_module_response = {0};
    if (!DeviceIoControl(hDevice, IO_FIND_MODULE_REQUEST, 
        &find_module_request, sizeof(find_module_request), 
        &find_module_response, sizeof(find_module_response), 
        nullptr, nullptr)) {
        return FALSE;
    }

    *Address = find_module_response.Address;
    return TRUE;
}

fumo::DriverInterface::~DriverInterface() {
    std::cout << "Closing handle" << std::endl;
    if (hDevice != INVALID_HANDLE_VALUE) {
        CloseHandle(hDevice);
    }
}
```

`src/driver_interface/driver_interface.h`:

```h
#pragma once
#include <Windows.h>
#include <optional>
#include <fomo_common.h>
#include <iostream>

namespace fumo {

class DriverInterface {
private:
    HANDLE hDevice = INVALID_HANDLE_VALUE;
    DriverInterface(HANDLE hDevice) : hDevice(hDevice) {}
    // delete copy constructor and assignment operator
    DriverInterface(const DriverInterface&) = delete;
    DriverInterface& operator=(const DriverInterface&) = delete;
public:
    static std::shared_ptr<fumo::DriverInterface> Open(LPCWSTR lpFileName);
    VOID Unload();
    BOOL GetVersion(PULONG pVersion);
    PVOID AllocateKernelMemory(ULONG size);
    BOOL ExposeKernelMemory(ULONG pid, PVOID address, ULONG size);
    BOOL ExecuteCode(ULONG pid, PVOID address, PVOID argument);
    BOOL FindModule(ULONG pid, LPCWSTR lpModuleName, PVOID* Address);
    ~DriverInterface();
};

} // namespace fumo
```

`src/encoder/CMakeLists.txt`:

```txt
add_executable(fumo_encoder fumo_encoder.cpp)
target_compile_features(fumo_encoder PUBLIC c_std_17 cxx_std_20)
target_compile_definitions(fumo_encoder PRIVATE UNICODE _UNICODE)
target_include_directories(fumo_encoder PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../include)
target_link_libraries(fumo_encoder PRIVATE lz4_static)
```

`src/encoder/fumo_encoder.cpp`:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <iomanip>
#include <filesystem>
#include <stdint.h>
#include <ctime>
#include <random>
#include <fumo_data_header.h>
#include <lz4.h>

int main(int argc, char** argv) {
    // usage: [input_file] [process_name] [wait_for_module1,[wait_for_module2,...]] [output_file]

    std::string input_file_name = [argc, argv]() {
        if (argc > 1)
            return std::string(argv[1]);
        std::cout << "Input file (DLL): ";
        std::string input_file_name;
        std::getline(std::cin, input_file_name);
        return input_file_name;
    }();
    std::string process_name = [argc, argv]() {
        if (argc > 2)
            return std::string(argv[2]);
        std::cout << "Target process name: ";
        std::string process_name;
        std::getline(std::cin, process_name);
        return process_name;
    }();
    std::string wait_for_modules = [argc, argv]() {
        if (argc > 3)
            return std::string(argv[3]);
        std::cout << "Wait for modules (comma separated): ";
        std::string wait_for_modules;
        std::getline(std::cin, wait_for_modules);
        return wait_for_modules;
    }();
    std::string output_file_name = [argc, argv, input_file_name]() {
        if (argc > 4)
            return std::string(argv[4]);
        return std::filesystem::path(input_file_name).replace_extension(".fumo").string();
    }();

    if (process_name.length() == 0) {
        std::cerr << "No process name specified" << std::endl;
        return 1;
    }

    if (wait_for_modules.length() == 0) {
        std::cerr << "No wait modules specified, using default: kernel32.dll" << std::endl;
        wait_for_modules = "kernel32.dll";
    }
    
    // read input file
    std::ifstream input_file(input_file_name, std::ios::binary);
    if (!input_file.is_open()) {
        std::cerr << "Failed to open input file:" << input_file_name << std::endl;
        return 1;
    }
    std::vector<char> data;
    data.assign(std::istreambuf_iterator<char>(input_file), std::istreambuf_iterator<char>());

    // compress data
    std::vector<char> compressed_data;
    compressed_data.resize(LZ4_compressBound(data.size()));
    size_t compressed_size = LZ4_compress_default(data.data(), compressed_data.data(), data.size(), compressed_data.size());
    if (compressed_size <= 0) {
        std::cerr << "Failed to compress data" << std::endl;
        return 1;
    }
    compressed_data.resize(compressed_size);

    // generate xor key
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<unsigned long long> dis(
        std::numeric_limits<std::uint64_t>::min(),
        std::numeric_limits<std::uint64_t>::max()
    );
    uint64_t xor_key = dis(gen);

    // pad to 8 bytes
    int padding = 8 - (compressed_data.size() % 8);
    if (padding != 8)
        compressed_data.insert(compressed_data.end(), padding, 0);

    // encrypt compressed_data
    for (int i = 0; i < compressed_data.size(); i += sizeof(xor_key)) {
        uint64_t* ptr = (uint64_t*)&compressed_data[i];
        *ptr ^= xor_key;
    }

    // generate loader settings
    std::stringstream loader_settings;
    loader_settings << process_name << ';' << wait_for_modules;
    std::string loader_settings_str = loader_settings.str();
    std::vector<unsigned char> loader_settings_data;
    // write size
    uint32_t loader_settings_size = loader_settings.str().length();
    loader_settings_data.insert(loader_settings_data.end(), (unsigned char*)&loader_settings_size, (unsigned char*)&loader_settings_size + sizeof(loader_settings_size));
    // write data
    loader_settings_data.insert(loader_settings_data.end(), loader_settings_str.begin(), loader_settings_str.end());
    // pad to 8 bytes
    padding = 8 - (loader_settings_data.size() % 8);
    if (padding != 8)
        loader_settings_data.insert(loader_settings_data.end(), padding, 0);
    // encrypt loader settings
    for (int i = 0; i < loader_settings_data.size(); i += sizeof(xor_key)) {
        uint64_t* ptr = (uint64_t*)&loader_settings_data[i];
        *ptr ^= xor_key;
    }

    // write output file
    std::ofstream output_file(output_file_name, std::ios::binary);
    if (!output_file.is_open()) {
        std::cerr << "Failed to open output file:" << output_file_name << std::endl;
        return 1;
    }

    FUMO_DATA_HEADER header;
    header.Magic = FUMO_MAGIC;
    header.Version = FUMO_DATA_VERSION;
    header.XorKey = xor_key;
    header.SettingsSize = loader_settings_data.size();
    header.DataSize = compressed_data.size();
    header.CompressedDataSize = compressed_size;
    header.DecompressedDataSize = data.size();
    output_file.write((char*)&header, sizeof(header));
    output_file.write((char*)loader_settings_data.data(), loader_settings_data.size());
    output_file.write((char*)compressed_data.data(), compressed_data.size());

    output_file.close();

    std::cerr << "Successfully encoded " << input_file_name << " to " << output_file_name << std::endl;
    return 0;
}

```

`src/fumo_generator/CMakeLists.txt`:

```txt
add_executable(fumo_generator fumo_generator.cpp)
target_compile_features(fumo_generator PUBLIC c_std_17 cxx_std_20)
target_compile_definitions(fumo_generator PRIVATE UNICODE _UNICODE)
target_include_directories(fumo_generator PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../include)
target_link_libraries(fumo_generator PRIVATE linux-pe)
```

`src/fumo_generator/fumo_generator.cpp`:

```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <iomanip>
#include <optional>
#include <random>
#define VAR_LEN 0
#include <linuxpe>
#include <string.h>
#include "bootstrap.h"

std::optional<std::vector<uint8_t>> read_file(std::string path);
template <typename E>
void randomize_section_name(win::section_header_t* section_header, E& engine);
uint32_t get_aligned_size(uint32_t size, uint32_t alignment);
void encrypt_buffer(uint8_t* buffer, uint32_t size, uint64_t xor_key);
std::vector<uint8_t> generate_resource_section(uint32_t virtual_address);

int main(int argc, char** argv) {
    if (argc < 3) {
        std::cerr << "Usage: " << argv[0] << " <output_file> <initial_loader> [module...]" << std::endl;
        return 1;
    }

    std::string output_file_path = argv[1];
    std::string initial_loader_path = argv[2];
    std::vector<std::string> module_paths;
    for (int i = 3; i < argc; i++)
        module_paths.push_back(argv[i]);

    auto initial_loader_buffer = read_file(initial_loader_path);
    if (!initial_loader_buffer.has_value()) {
        std::cerr << "Failed to read initial_loader file" << std::endl;
        return 1;
    }

    std::vector<std::vector<uint8_t>> module_buffers;
    for (auto& module_path : module_paths) {
        auto module_buffer = read_file(module_path);
        if (!module_buffer.has_value()) {
            std::cerr << "Failed to read module file: " << module_path << std::endl;
            return 1;
        }
        module_buffers.push_back(module_buffer.value());
    }

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<unsigned long long> dis(
        std::numeric_limits<std::uint64_t>::min(),
        std::numeric_limits<std::uint64_t>::max()
    );
    uint64_t xor_key = dis(gen);

    uint32_t NumberOfSections = 3 + module_buffers.size();

    // DOS header
    win::dos_header_t dos_header;
    memset(&dos_header, 0, sizeof(dos_header));
    dos_header.e_magic = win::DOS_HDR_MAGIC;
    dos_header.e_cblp = 0x90;
    dos_header.e_cp = 0x3;
    dos_header.e_cparhdr = 0x4;
    dos_header.e_maxalloc = 0xFFFF;
    dos_header.e_sp = 0xB8;
    dos_header.e_lfarlc = 0x40;
    dos_header.e_lfanew = 0x40;

    // NT headers
    win::nt_headers_x64_t nt_headers;
    memset(&nt_headers, 0, sizeof(nt_headers));
    nt_headers.signature = win::NT_HDR_MAGIC;
    nt_headers.file_header.machine = win::machine_id::amd64;
    nt_headers.file_header.num_sections = NumberOfSections;
    nt_headers.file_header.timedate_stamp = 0x0; // FIXME: randomize
    nt_headers.file_header.size_optional_header = sizeof(nt_headers.optional_header);
    nt_headers.file_header.characteristics.relocs_stripped = true;
    nt_headers.file_header.characteristics.executable = true;
    nt_headers.file_header.characteristics.lines_stripped = true;
    nt_headers.file_header.characteristics.local_symbols_stripped = true;
    nt_headers.file_header.characteristics.large_address_aware = true;
    nt_headers.optional_header.magic = win::OPT_HDR64_MAGIC;
    nt_headers.optional_header.linker_version.major = 0x1;
    nt_headers.optional_header.linker_version.minor = 0x0;
    nt_headers.optional_header.size_code = 0; //* needs to be updated
    nt_headers.optional_header.size_init_data = 0; //* needs to be updated
    nt_headers.optional_header.size_uninit_data = 0x0;
    nt_headers.optional_header.entry_point = 0; //* needs to be updated
    nt_headers.optional_header.base_of_code = 0x1000;
    nt_headers.optional_header.image_base = 0x0000000140000000;
    nt_headers.optional_header.section_alignment = 0x1000;
    nt_headers.optional_header.file_alignment = 0x200;
    nt_headers.optional_header.os_version.major = 0x6;
    nt_headers.optional_header.os_version.minor = 0x6;
    nt_headers.optional_header.img_version.major = 0x0;
    nt_headers.optional_header.img_version.minor = 0x0;
    nt_headers.optional_header.subsystem_version.major = 0x6;
    nt_headers.optional_header.subsystem_version.minor = 0x0;
    nt_headers.optional_header.win32_version_value = 0x0;
    nt_headers.optional_header.size_image = 0; //* needs to be updated
    nt_headers.optional_header.size_headers = 0x400; //* needs to be updated
    nt_headers.optional_header.checksum = 0x0;
    nt_headers.optional_header.subsystem = win::subsystem_id::windows_gui;
    nt_headers.optional_header.characteristics.dynamic_base = true;
    nt_headers.optional_header.characteristics.nx_compat = true;
    nt_headers.optional_header.characteristics.terminal_server_aware = true;
    nt_headers.optional_header.size_stack_reserve = 0x100000;
    nt_headers.optional_header.size_stack_commit = 0x1000;
    nt_headers.optional_header.size_heap_reserve = 0x100000;
    nt_headers.optional_header.size_heap_commit = 0x1000;
    nt_headers.optional_header.ldr_flags = 0x0;
    nt_headers.optional_header.num_data_directories = win::NUM_DATA_DIRECTORIES;

    // section headers
    uint32_t size_of_headers = sizeof(dos_header) + sizeof(nt_headers) + NumberOfSections * sizeof(win::section_header_t);
    // round up to nearest FileAlignment
    size_of_headers = get_aligned_size(size_of_headers, nt_headers.optional_header.file_alignment);
    nt_headers.optional_header.size_headers = size_of_headers;

    // round up to nearest SectionAlignment after headers
    uint32_t next_virtual_address = get_aligned_size(size_of_headers, nt_headers.optional_header.section_alignment);
    uint32_t next_pointer_to_raw_data = get_aligned_size(size_of_headers, nt_headers.optional_header.file_alignment);

    // loader section
    win::section_header_t initial_loader_section_header;
    memset(&initial_loader_section_header, 0, sizeof(initial_loader_section_header));
    initial_loader_section_header.name.short_name[0] = 'l'; // loader
    randomize_section_name(&initial_loader_section_header, gen);
    initial_loader_section_header.virtual_size = initial_loader_buffer->size();
    initial_loader_section_header.virtual_address = next_virtual_address;
    initial_loader_section_header.size_raw_data = initial_loader_buffer->size();
    initial_loader_section_header.ptr_raw_data = next_pointer_to_raw_data;
    initial_loader_section_header.characteristics.mem_execute = true;
    initial_loader_section_header.characteristics.mem_read = true;
    initial_loader_section_header.characteristics.mem_write = true;

    // get next free virtual address and pointer to raw data (round up to nearest section_alignment)
    next_virtual_address += get_aligned_size(initial_loader_section_header.virtual_size, nt_headers.optional_header.section_alignment);
    next_pointer_to_raw_data += get_aligned_size(initial_loader_section_header.size_raw_data, nt_headers.optional_header.file_alignment);

    // bootstrap section
    auto bootstrap_shellcode = get_bootstrap_shellcode(xor_key, initial_loader_section_header.virtual_address, initial_loader_section_header.size_raw_data);
    win::section_header_t bootstrap_section_header;
    memset(&bootstrap_section_header, 0, sizeof(bootstrap_section_header));
    bootstrap_section_header.name.short_name[0] = 'b'; // bootstrap
    randomize_section_name(&bootstrap_section_header, gen);
    bootstrap_section_header.virtual_size = bootstrap_shellcode.size();
    bootstrap_section_header.virtual_address = next_virtual_address;
    bootstrap_section_header.size_raw_data = bootstrap_shellcode.size();
    bootstrap_section_header.ptr_raw_data = next_pointer_to_raw_data;
    bootstrap_section_header.characteristics.mem_execute = true;
    bootstrap_section_header.characteristics.mem_read = true;
    bootstrap_section_header.characteristics.mem_write = true;

    // get next free virtual address and pointer to raw data (round up to nearest section_alignment)
    next_virtual_address += get_aligned_size(bootstrap_section_header.virtual_size, nt_headers.optional_header.section_alignment);
    next_pointer_to_raw_data += get_aligned_size(bootstrap_section_header.size_raw_data, nt_headers.optional_header.file_alignment);

    // module sections
    std::vector<win::section_header_t> module_section_headers;
    for (auto& module_buffer : module_buffers) {
        // section header
        win::section_header_t section_header;
        memset(&section_header, 0, sizeof(section_header));
        section_header.name.short_name[0] = 'e'; // encrypted
        randomize_section_name(&section_header, gen);
        section_header.virtual_size = module_buffer.size();
        section_header.virtual_address = next_virtual_address;
        section_header.size_raw_data = module_buffer.size();
        section_header.ptr_raw_data = next_pointer_to_raw_data;
        section_header.characteristics.mem_read = true;
        section_header.characteristics.mem_write = true;

        // get next free virtual address and pointer to raw data (round up to nearest section_alignment)
        next_virtual_address += get_aligned_size(section_header.virtual_size, nt_headers.optional_header.section_alignment);
        next_pointer_to_raw_data += get_aligned_size(section_header.size_raw_data, nt_headers.optional_header.file_alignment);

        module_section_headers.push_back(section_header);
    }

    // resource section
    auto resource_section_data = generate_resource_section(next_virtual_address);
    win::section_header_t resource_section_header;
    memset(&resource_section_header, 0, sizeof(resource_section_header));
    strcpy(resource_section_header.name.short_name, ".rsrc");
    resource_section_header.virtual_size = resource_section_data.size();
    resource_section_header.virtual_address = next_virtual_address;
    resource_section_header.size_raw_data = resource_section_data.size();
    resource_section_header.ptr_raw_data = next_pointer_to_raw_data;
    resource_section_header.characteristics.mem_read = true;

    // get next free virtual address and pointer to raw data (round up to nearest section_alignment)
    next_virtual_address += get_aligned_size(resource_section_header.virtual_size, nt_headers.optional_header.section_alignment);
    next_pointer_to_raw_data += get_aligned_size(resource_section_header.size_raw_data, nt_headers.optional_header.file_alignment);
    
    // update NT headers
    nt_headers.optional_header.size_image = next_virtual_address;
    nt_headers.optional_header.size_code = initial_loader_section_header.size_raw_data + bootstrap_section_header.size_raw_data;
    nt_headers.optional_header.size_init_data = initial_loader_section_header.size_raw_data + bootstrap_section_header.size_raw_data;
    nt_headers.optional_header.entry_point = bootstrap_section_header.virtual_address;
    nt_headers.optional_header.data_directories.resource_directory.rva = resource_section_header.virtual_address;
    nt_headers.optional_header.data_directories.resource_directory.size = resource_section_header.size_raw_data;

    // write the PE file
    std::ofstream pe_file(output_file_path, std::ios::binary);
    if (!pe_file.is_open()) {
        std::cerr << "Failed to open output file" << std::endl;
        return 1;
    }

    // write DOS header
    pe_file.write((char*)&dos_header, sizeof(dos_header));

    // write NT headers
    pe_file.write((char*)&nt_headers, sizeof(nt_headers));

    // write section headers
    pe_file.write((char*)&initial_loader_section_header, sizeof(initial_loader_section_header));
    pe_file.write((char*)&bootstrap_section_header, sizeof(bootstrap_section_header));
    for (auto& module_section_header : module_section_headers)
        pe_file.write((char*)&module_section_header, sizeof(module_section_header));
    pe_file.write((char*)&resource_section_header, sizeof(resource_section_header));

    // write loader section data
    encrypt_buffer(initial_loader_buffer->data(), initial_loader_buffer->size(), xor_key);
    pe_file.seekp(initial_loader_section_header.ptr_raw_data);
    pe_file.write((char*)initial_loader_buffer->data(), initial_loader_buffer->size());

    // write bootstrap section data
    pe_file.seekp(bootstrap_section_header.ptr_raw_data);
    pe_file.write((char*)bootstrap_shellcode.data(), bootstrap_shellcode.size());

    // write module section data
    for (int i = 0; i < module_buffers.size(); i++) {
        encrypt_buffer(module_buffers[i].data(), module_buffers[i].size(), xor_key);
        pe_file.seekp(module_section_headers[i].ptr_raw_data);
        pe_file.write((char*)module_buffers[i].data(), module_buffers[i].size());
    }

    // write resource section data
    pe_file.seekp(resource_section_header.ptr_raw_data);
    pe_file.write((char*)resource_section_data.data(), resource_section_data.size());

    pe_file.close();
    return 0;
}

std::optional<std::vector<uint8_t>> read_file(std::string path) {
    std::ifstream file(path, std::ios::binary);
    if (!file.is_open())
        return std::nullopt;

    std::vector<uint8_t> data;
    data.assign(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>());
    return data;
}

template <typename E>
void randomize_section_name(win::section_header_t* section_header, E& engine) {
    std::uniform_int_distribution<int> dis('a', 'z');

    // start at 1 to skip our "magic" section type indicator
    for (int j = 1; j < 8; j++)
        section_header->name.short_name[j] = (char)dis(engine);
}

uint32_t get_aligned_size(uint32_t size, uint32_t alignment) {
    return (size + alignment - 1) & ~(alignment - 1);
}

void encrypt_buffer(uint8_t* buffer, uint32_t size, uint64_t xor_key) {
    for (int i = 0; i < size; i += sizeof(xor_key)) {
        auto data = (uint64_t*)(buffer + i);
        *data ^= xor_key;
    }
}

std::vector<uint8_t> generate_resource_section(uint32_t virtual_address) {
    std::vector<uint8_t> data;

    // same thing but with a template and automatic size calculation
    auto allocate = [&]<class T>() -> T* {
        auto offset = data.size();
        data.resize(offset + sizeof(T));
        return reinterpret_cast<T*>(&data[offset]);
    };

    static_assert(sizeof(win::rsrc_directory_t) == 0x10);
    static_assert(sizeof(win::rsrc_generic_t) == 0x8);
    static_assert(sizeof(win::rsrc_data_t) == 0x10);

    auto resource_directory1 = allocate.operator()<win::rsrc_directory_t>();
    resource_directory1->characteristics = 0;
    resource_directory1->timedate_stamp = 0;
    resource_directory1->version.major = 0;
    resource_directory1->version.minor = 0;
    resource_directory1->num_named_entries = 0;
    resource_directory1->num_id_entries = 1;

    // manifest resource
    auto resource_directory_entry1 = allocate.operator()<win::rsrc_generic_t>();
    resource_directory_entry1->identifier = (uint16_t)win::resource_id::manifest;
    resource_directory_entry1->is_directory = true;
    resource_directory_entry1->offset = data.size();

    auto resource_directory2 = allocate.operator()<win::rsrc_directory_t>();
    resource_directory2->characteristics = 0;
    resource_directory2->timedate_stamp = 0;
    resource_directory2->version.major = 0;
    resource_directory2->version.minor = 0;
    resource_directory2->num_named_entries = 0;
    resource_directory2->num_id_entries = 1;

    auto resource_directory_entry2 = allocate.operator()<win::rsrc_generic_t>();
    resource_directory_entry2->identifier = 1;
    resource_directory_entry2->is_directory = true;
    resource_directory_entry2->offset = data.size();

    auto resource_directory3 = allocate.operator()<win::rsrc_directory_t>();
    resource_directory3->characteristics = 0;
    resource_directory3->timedate_stamp = 0;
    resource_directory3->version.major = 0;
    resource_directory3->version.minor = 0;
    resource_directory3->num_named_entries = 0;
    resource_directory3->num_id_entries = 1;

    auto resource_directory_entry3 = allocate.operator()<win::rsrc_generic_t>();
    resource_directory_entry3->identifier = 0x409; // english
    resource_directory_entry3->is_directory = false;
    resource_directory_entry3->offset = data.size();

    std::string manifest = R"(<?xml version='1.0' encoding='UTF-8' standalone='yes'?>
<assembly xmlns='urn:schemas-microsoft-com:asm.v1' manifestVersion='1.0'>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level='requireAdministrator' uiAccess='false' />
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>
)";

    auto resource_data_entry = allocate.operator()<win::rsrc_data_t>();
    resource_data_entry->rva_data = virtual_address + data.size();
    resource_data_entry->size_data = manifest.size();
    resource_data_entry->code_page = 0;
    resource_data_entry->reserved = 0;

    data.insert(data.end(), manifest.begin(), manifest.end());

    return data;
}
```

`src/include/bootstrap.h`:

```h
#pragma once
#include <array>
#include <cstdint>

#if defined(_MSC_VER)
#define __forceinline __forceinline
#elif defined(__GNUC__)
#define __forceinline __attribute__((always_inline)) inline
#else
#define __forceinline inline
#endif

__forceinline auto get_bootstrap_shellcode(uintptr_t xor_key, uintptr_t section_virtual_offset, uint32_t section_size) {
    std::array<uint8_t, 67> entrypoint = {
        // constants
        0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rcx, 0h - xor_key
        0x48, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rdx, 0h - section_virtual_offset
        0x49, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov r8, 0h  - section_virtual_offset + section_size (end of section)

        // add image base address to constants (this removes the need for a relocation table)
        0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00,       // mov rax, gs:[60h] ; PEB
        0x48, 0x8B, 0x40, 0x10,                                     // mov rax, [rax+10h] ; PEB.ImageBaseAddress
        0x48, 0x01, 0xC2,                                           // add rdx, rax
        0x49, 0x01, 0xC0,                                           // add r8, rax

        // save section start so we can jump to it later
        0x4C, 0x8B, 0xCA,                                           // mov r9, rdx

        // decrypt section                                          // loop1:
        0x48, 0x31, 0x0A,                                           // xor QWORD PTR [rdx], rcx
        0x48, 0x83, 0xC2, 0x08,                                     // add rdx, 8
        0x49, 0x3B, 0xD0,                                           // cmp rdx, r8
        0x72, 0xF4,                                                 // jb loop1

        // jump to section (rcx still contains the xor key)
        0x41, 0xFF, 0xE1 // jmp r9
    };

    // update constants
    *(uintptr_t*)&entrypoint[2] = xor_key;
    *(uintptr_t*)&entrypoint[12] = section_virtual_offset;
    *(uintptr_t*)&entrypoint[22] = section_virtual_offset + section_size;
    return entrypoint;
}
```

`src/include/fomo_common.h`:

```h
#pragma once
#include "fumo_data_header.h"

// Windows 10 2004/20H1 (19041) or higher
#define MIN_OS_MAJOR_VERSION 10
#define MIN_OS_BUILD_NUMBER 19041

#define FUMO_DRIVER_VERSION 0x00000003
#define FUMO_HOOKED_DRIVER_NAME L"\\Driver\\Null"
#define FUMO_HOOKED_DRIVER_NAME_USER L"\\\\.\\NUL"
#define FUMO_SECOND_STAGE_PROCESS_NAME L"explorer.exe"
#define FUMO_FILE_FORMAT_VERSION 0x00000001

#define IO_VERSION_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_UNLOAD_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8001, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_ALLOC_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8011, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_MAP_MEMORY_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8012, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_EXECUTE_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8013, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_FIND_MODULE_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8014, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _IO_VERSION_RESPONSE_DATA {
    ULONG Version;
} IO_VERSION_RESPONSE_DATA, *PIO_VERSION_RESPONSE_DATA;

typedef struct _IO_ALLOC_REQUEST_DATA {
    ULONG Size;
} IO_ALLOC_REQUEST_DATA, *PIO_ALLOC_REQUEST_DATA;

typedef struct _IO_ALLOC_RESPONSE_DATA {
    PVOID Address;
} IO_ALLOC_RESPONSE_DATA, *PIO_ALLOC_RESPONSE_DATA;

typedef struct _IO_MAP_MEMORY_REQUEST_DATA {
    ULONG Pid;
    PVOID Address;
    ULONG Size;
} IO_MAP_MEMORY_REQUEST_DATA, *PIO_MAP_MEMORY_REQUEST_DATA;

typedef struct _IO_EXECUTE_REQUEST_DATA {
    ULONG Pid;
    PVOID Address;
    PVOID Argument;
} IO_EXECUTE_REQUEST_DATA, *PIO_EXECUTE_REQUEST_DATA;

typedef struct _IO_FIND_MODULE_REQUEST_DATA {
    ULONG Pid;
    WCHAR ModuleName[256];
} IO_FIND_MODULE_REQUEST_DATA, *PIO_FIND_MODULE_REQUEST_DATA;

typedef struct _IO_FIND_MODULE_RESPONSE_DATA {
    PVOID Address;
} IO_FIND_MODULE_RESPONSE_DATA, *PIO_FIND_MODULE_RESPONSE_DATA;

typedef struct _FUMO_EMBEDDED_DATA {
    PVOID Data;
    DWORD Size;
} FUMO_EMBEDDED_DATA, *PFUMO_EMBEDDED_DATA;
```

`src/include/fumo_data_header.h`:

```h
#pragma once
#include <stdint.h>

#define FUMO_MAGIC 0x4F4D5546 // FUMO
#define FUMO_DATA_VERSION 0x00000002

typedef struct _FUMO_DATA_HEADER {
    uint32_t Magic;
    uint32_t Version;
    uint64_t XorKey;
    uint32_t SettingsSize;
    uint32_t DataSize;
    uint32_t CompressedDataSize;
    uint32_t DecompressedDataSize;
} FUMO_DATA_HEADER, *PFUMO_DATA_HEADER;
```

`src/include/util.h`:

```h
#pragma once
#include <Windows.h>
#include <winternl.h>
#include <TlHelp32.h>
#include <string>
#include <format>
#include <sstream>
#include <vector>
#include <array>
#include <locale>
#include <codecvt>

typedef struct _STAGE2_LOADER_DATA {
    ULONG_PTR stage2_base;
    ULONG_PTR fumo_data_base;
    DWORD loader_pid;
} STAGE2_LOADER_DATA, *PSTAGE2_LOADER_DATA;

typedef struct _SYSTEM_KERNEL_VA_SHADOW_INFORMATION {
    union {
        ULONG KvaShadowFlags;
        struct {
            ULONG KvaShadowEnabled : 1;
            ULONG KvaShadowUserGlobal : 1;
            ULONG KvaShadowPcid : 1;
            ULONG KvaShadowInvpcid : 1;
            ULONG KvaShadowRequired : 1; // REDSTONE4
            ULONG KvaShadowRequiredAvailable : 1;
            ULONG InvalidPteBit : 6;
            ULONG L1DataCacheFlushSupported : 1;
            ULONG L1TerminalFaultMitigationPresent : 1;
            ULONG Reserved : 18;
        };
    };
} SYSTEM_KERNEL_VA_SHADOW_INFORMATION, *PSYSTEM_KERNEL_VA_SHADOW_INFORMATION;

constexpr SYSTEM_INFORMATION_CLASS SystemKernelVaShadowInformation = (SYSTEM_INFORMATION_CLASS)196;

extern "C" NTSYSAPI NTSTATUS NTAPI RtlGetVersion(
    _Out_ PRTL_OSVERSIONINFOW lpVersionInformation
);

inline std::vector<std::string> split(std::string text, char delim) {
    std::string line;
    std::vector<std::string> vec;
    std::stringstream ss(text);
    while(std::getline(ss, line, delim))
        vec.push_back(line);
    return vec;
}

inline std::wstring convert_to_wstring(const std::string &str) {
    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>, wchar_t> conv;
    return conv.from_bytes(str);
}

inline std::wstring get_proces_name(HANDLE process) {
    std::wstring process_name;
    process_name.resize(MAX_PATH);
    DWORD size = process_name.size();
    QueryFullProcessImageNameW(process, 0, (LPWSTR)process_name.data(), &size);
    process_name.resize(size);
    return process_name;
}

inline DWORD find_process_by_name(LPCWSTR lpProcessName) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE)
        return 0;

    PROCESSENTRY32W pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32W);
    if (!Process32FirstW(hSnapshot, &pe32)) {
        CloseHandle(hSnapshot);
        return 0;
    }

    DWORD pid = 0;
    do {
        if (wcscmp(pe32.szExeFile, lpProcessName) == 0) {
            pid = pe32.th32ProcessID;
            break;
        }
    } while (Process32NextW(hSnapshot, &pe32));

    CloseHandle(hSnapshot);
    return pid;
}

namespace fumo {
    template <typename... Args> 
    std::wstring error_string(int code, std::wformat_string<Args...> fmt, Args&&... args) {
        std::wstring message;
        auto it = std::back_inserter(message);
        std::format_to(it, fmt, std::forward<Args>(args)...);
        std::format_to(it, L"\n\nFumo loader error: {}", code);
        std::format_to(it, L"\nWin32 error: {}", GetLastError());
        return message;
    }

    template <typename... Args> 
    int error(int code, std::wformat_string<Args...> fmt, Args&&... args) {
        auto message = error_string(code, fmt, std::forward<Args>(args)...);
        MessageBoxW(NULL, message.c_str(), L"FUMO LOADER ERROR", MB_OK | MB_ICONERROR | MB_SYSTEMMODAL);
        return code;
    }
}
```

`src/initial_loader/CMakeLists.txt`:

```txt
add_library(initial_loader_lib STATIC initial_loader.cpp)
target_link_libraries(initial_loader_lib PRIVATE lazy_importer xorstr)
target_compile_definitions(initial_loader_lib PRIVATE UNICODE _UNICODE)
target_compile_features(initial_loader_lib PUBLIC c_std_17 cxx_std_20)
target_compile_options(initial_loader_lib PRIVATE /O1 /GS- /sdl-)
target_include_directories(initial_loader_lib PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../include)

add_custom_command(
    COMMENT "Extracting initial_loader_lib"
    DEPENDS initial_loader_lib
    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/
    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/initial_loader.obj
    COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/extract_lib.bat $<TARGET_LINKER_FILE:initial_loader_lib>
)

add_custom_command(
    COMMENT "Extracting initial_loader"
    DEPENDS shellcode_extractor
    DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/initial_loader.obj
    OUTPUT ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/initial_loader.bin
    COMMAND shellcode_extractor ${CMAKE_CURRENT_BINARY_DIR}/initial_loader.obj initial_loader ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/initial_loader.bin
)

add_custom_target(
    initial_loader
    DEPENDS ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/initial_loader.bin
    COMMENT "Building initial_loader.bin"
)
set_target_properties(initial_loader PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR})
```

`src/initial_loader/extract_lib.bat`:

```bat
@ECHO OFF
SETLOCAL EnableDelayedExpansion

FOR /F %%O IN ('lib "%~1" /LIST /NOLOGO') DO (
    lib "%~1" /EXTRACT:"%%O" /OUT:"%%~nxO" /NOLOGO
)
```

`src/initial_loader/initial_loader.cpp`:

```cpp
#include <Windows.h>
#include <winternl.h>
#include <lazy_importer.hpp>
#include <xorstr.hpp>
#include <bootstrap.h>
#include <fomo_common.h>

NTSYSAPI ULONG RtlRandomEx(PULONG Seed);

#define DEBUG

#ifdef DEBUG
#define EXIT_WITH_ERROR(error, message) {fnMessageBoxA(nullptr, xorstr_(message), xorstr_("Error"), MB_OK | MB_ICONERROR | MB_SYSTEMMODAL); fnExitProcess(error);}
#else
#define EXIT_WITH_ERROR(error, message) {fnExitProcess(error);}
#endif

#define ERR_SUCCESS 0
#define ERR_FAILED_TO_ALLOCATE_MEMORY 1
#define ERR_FAILED_TO_FIND_LOADER_SECTION 2
#define ERR_FAILED_TO_FIND_BOOTSTRAP_SECTION 3
#define ERR_FAILED_TO_OPEN_FILE_FOR_NEW_EXECUTABLE 4
#define ERR_FAILED_TO_SET_DELETE_FILE_INFO 5
#define ERR_FAILED_TO_WRITE_NEW_EXECUTABLE_TO_DISK 6
#define ERR_FAILED_TO_WRITE_ENTIRE_NEW_EXECUTABLE_TO_DISK 7
#define ERR_FAILED_TO_MAP_ENCRYPTED_SECTION 8
#define ERR_FAILED_TO_RELOCATE_IMAGE 9
#define ERR_FAILED_TO_FIND_IMPORTED_MODULE 10
#define ERR_FAILED_TO_FIND_IMPORTED_FUNCTION 11
#define ERR_FAILED_TO_EXECUTE_DLL_ENTRY_POINT 12

// simple memcpy that can be inlined
__forceinline void inline_memcpy(PVOID dest, PVOID src, SIZE_T size) {
    for (SIZE_T i = 0; i < size; i++) {
        ((PBYTE)dest)[i] = ((PBYTE)src)[i];
    }
}

__forceinline int map_encrypted_image(ULONG_PTR base, PFUMO_EMBEDDED_DATA embedded_data) {
    auto fnVirtualAlloc = LI_FN(VirtualAlloc).get();
    auto fnExitProcess = LI_FN(ExitProcess).get();
    auto fnLoadLibraryA = LI_FN(LoadLibraryA).get();
    auto fnGetProcAddress = LI_FN(GetProcAddress).get();
#ifdef DEBUG
    // user32.dll is not loaded by default by windows, so we need to load it manually
    LI_FN(LoadLibraryA)(xorstr_("user32.dll"));
    auto fnMessageBoxA = LI_FN(MessageBoxA).get();
#else
    #define fnMessageBoxA(a, b, c, d)
#endif

    auto nt_headers = (PIMAGE_NT_HEADERS)(base + ((PIMAGE_DOS_HEADER)base)->e_lfanew);

    // allocate memory for section
    auto new_image_base = (ULONG_PTR)fnVirtualAlloc(nullptr, //(LPVOID)nt_headers->OptionalHeader.ImageBase,
        nt_headers->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!new_image_base)
        EXIT_WITH_ERROR(ERR_FAILED_TO_ALLOCATE_MEMORY, "Failed to allocate memory for new executable");

    // map sections
    auto section_header = IMAGE_FIRST_SECTION(nt_headers);
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
        auto section = &section_header[i];
        if (section->SizeOfRawData == 0)
            continue;
        auto section_data = (PVOID)(base + section->PointerToRawData);
        inline_memcpy((PVOID)(new_image_base + section->VirtualAddress), section_data, section->SizeOfRawData);
    }

    // process relocations
    auto delta = (ULONG_PTR)new_image_base - nt_headers->OptionalHeader.ImageBase;
    if (delta != 0) {
        auto base_relocation = (PIMAGE_BASE_RELOCATION)(new_image_base + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
        while (base_relocation->VirtualAddress != 0) {
            auto relocation = (PWORD)((ULONG_PTR)base_relocation + sizeof(IMAGE_BASE_RELOCATION));
            auto number_of_relocations = (base_relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
            for (auto i = 0; i < number_of_relocations; i++) {
                auto type = relocation[i] >> 12;
                if (type == IMAGE_REL_BASED_DIR64) {
                    auto address = (PULONG_PTR)(new_image_base + base_relocation->VirtualAddress + (relocation[i] & 0xFFF));
                    *address += delta;
                } else if (type != IMAGE_REL_BASED_ABSOLUTE)
                    EXIT_WITH_ERROR(ERR_FAILED_TO_RELOCATE_IMAGE, "Failed to relocate image");
            }
            base_relocation = (PIMAGE_BASE_RELOCATION)((ULONG_PTR)base_relocation + base_relocation->SizeOfBlock);
        }
    }

    // resolve imports
    auto import_descriptor = (PIMAGE_IMPORT_DESCRIPTOR)(new_image_base + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
    while (import_descriptor->Name != 0) {
        auto module_name = (PCHAR)(new_image_base + import_descriptor->Name);
        auto module_handle = fnLoadLibraryA(module_name);
        if (!module_handle)
            EXIT_WITH_ERROR(ERR_FAILED_TO_FIND_IMPORTED_MODULE, "Failed to find imported module");

        auto thunk_data = (PIMAGE_THUNK_DATA)(new_image_base + import_descriptor->FirstThunk);
        while (thunk_data->u1.AddressOfData != 0) {
            if (thunk_data->u1.Ordinal & IMAGE_ORDINAL_FLAG64) {
                auto function_name = (PCHAR)(thunk_data->u1.Ordinal & 0xFFFF);
                auto function_address = fnGetProcAddress(module_handle, function_name);
                if (!function_address)
                    EXIT_WITH_ERROR(ERR_FAILED_TO_FIND_IMPORTED_FUNCTION, "Failed to find imported function");

                thunk_data->u1.Function = (ULONGLONG)function_address;
            } else {
                auto import_by_name = (PIMAGE_IMPORT_BY_NAME)(new_image_base + thunk_data->u1.AddressOfData);
                auto function_address = fnGetProcAddress(module_handle, import_by_name->Name);
                if (!function_address)
                    EXIT_WITH_ERROR(ERR_FAILED_TO_FIND_IMPORTED_FUNCTION, "Failed to find imported function");

                thunk_data->u1.Function = (ULONGLONG)function_address;
            }
            thunk_data++;
        }
        import_descriptor++;
    }

    // execute dll entry point
    using DllMain = BOOL(WINAPI*)(HINSTANCE, DWORD, PFUMO_EMBEDDED_DATA);
    auto dll_entry_point = (DllMain)(new_image_base + nt_headers->OptionalHeader.AddressOfEntryPoint);
    auto success = dll_entry_point((HINSTANCE)new_image_base, DLL_PROCESS_ATTACH, embedded_data);
    if (!success)
        return ERR_FAILED_TO_EXECUTE_DLL_ENTRY_POINT;
    
    return ERR_SUCCESS;
}

__forceinline int map_encrypted_sections(ULONG_PTR base) {
    auto fnExitProcess = LI_FN(ExitProcess).get();
#ifdef DEBUG
    // user32.dll is not loaded by default by windows, so we need to load it manually
    LI_FN(LoadLibraryA)(xorstr_("user32.dll"));
    auto fnMessageBoxA = LI_FN(MessageBoxA).get();
#else
    #define fnMessageBoxA(a, b, c, d)
#endif

    // parse the headers
    auto nt_headers = (PIMAGE_NT_HEADERS)(base + ((PIMAGE_DOS_HEADER)base)->e_lfanew);
    auto section_header = IMAGE_FIRST_SECTION(nt_headers);

    FUMO_EMBEDDED_DATA embedded_data;
    embedded_data.Data = nullptr;
    embedded_data.Size = 0;

    // map encrypted sections
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
        auto section = &section_header[i];
        // only map sections that start with 'e' (encrypted)
        if (section->Name[0] != 'e')
            continue;
        if (section->Misc.VirtualSize < 4)
            EXIT_WITH_ERROR(ERR_FAILED_TO_MAP_ENCRYPTED_SECTION, "Failed to map encrypted section (to small)")
        
        ULONG_PTR section_base = base + section->VirtualAddress;

        // check if this is a data section
        if (*(DWORD*)section_base == FUMO_MAGIC) {
            embedded_data.Data = (PVOID)section_base;
            embedded_data.Size = section->Misc.VirtualSize;
            continue;
        }
        
        auto error = map_encrypted_image(section_base, &embedded_data);
        if (error != ERR_SUCCESS) {
            if (error != ERR_FAILED_TO_EXECUTE_DLL_ENTRY_POINT)
                EXIT_WITH_ERROR(ERR_FAILED_TO_MAP_ENCRYPTED_SECTION, "Failed to map encrypted section");
            return error;
        }
    }
    
    return ERR_SUCCESS;
}

extern "C" void initial_loader(ULONG_PTR xorKey) {
    auto fnGetModuleHandleA = LI_FN(GetModuleHandleA).get();
    auto fnVirtualAlloc = LI_FN(VirtualAlloc).get();
    auto fnVirtualFree = LI_FN(VirtualFree).get();
    auto fnGetTickCount64 = LI_FN(GetTickCount64).get();
    auto fnRtlRandomEx = LI_FN(RtlRandomEx).get();
    auto fnCreateFileA = LI_FN(CreateFileA).get();
    auto fnSetFileInformationByHandle = LI_FN(SetFileInformationByHandle).get();
    auto fnWriteFile = LI_FN(WriteFile).get();
    auto fnCloseHandle = LI_FN(CloseHandle).get();
    auto fnExitProcess = LI_FN(ExitProcess).get();
#ifdef DEBUG
    // user32.dll is not loaded by default by windows, so we need to load it manually
    LI_FN(LoadLibraryA)(xorstr_("user32.dll"));
    auto fnMessageBoxA = LI_FN(MessageBoxA).get();
#else
    #define fnMessageBoxA(a, b, c, d)
#endif

    // get module base
    ULONG_PTR base = (ULONG_PTR)fnGetModuleHandleA(nullptr); // to lazy to pull it from the PEB directly

    // parse the headers
    auto nt_headers = (PIMAGE_NT_HEADERS)(base + ((PIMAGE_DOS_HEADER)base)->e_lfanew);
    auto section_header = IMAGE_FIRST_SECTION(nt_headers);

    // decrypt all sections
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
        auto section = &section_header[i];
        // only decrypt sections that start with 'e' (encrypted)
        if (section->Name[0] == 'e') {
            // decrypt section (8 bytes at a time)
            for (int j = 0; j < section->SizeOfRawData; j += sizeof(xorKey)) {
                auto data = (PULONG64)(base + section->VirtualAddress + j);
                *data ^= xorKey;
            }
        }
    }

#ifndef FUMO_DEBUG
    // allocate memory for new executable
    auto new_image_base = (ULONG_PTR)fnVirtualAlloc(nullptr, nt_headers->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!new_image_base)
        EXIT_WITH_ERROR(ERR_FAILED_TO_ALLOCATE_MEMORY, "Failed to allocate memory for new executable");

    // copy headers
    inline_memcpy((PVOID)new_image_base, (PVOID)base, nt_headers->OptionalHeader.SizeOfHeaders);
    nt_headers = (PIMAGE_NT_HEADERS)(new_image_base + ((PIMAGE_DOS_HEADER)new_image_base)->e_lfanew);
    section_header = IMAGE_FIRST_SECTION(nt_headers);

    // update image base in new executable to the current base the executable is loaded at
    nt_headers->OptionalHeader.ImageBase = base;

    // unmap sections
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
        auto section = &section_header[i];
        if (section->SizeOfRawData == 0) {
            continue;
        }
        inline_memcpy((PVOID)(new_image_base + section->PointerToRawData), (PVOID)(base + section->VirtualAddress), section->SizeOfRawData);
    }

    // generate a new random xor key
    ULONG seed = (ULONG)fnGetTickCount64();
    ULONG_PTR new_xor_key = (ULONG_PTR)fnRtlRandomEx(&seed) | ((ULONG_PTR)fnRtlRandomEx(&seed) << 32);

    // re-encrypt all sections in new executable
    section_header = IMAGE_FIRST_SECTION(nt_headers);
    PIMAGE_SECTION_HEADER loader_section = nullptr;
    PIMAGE_SECTION_HEADER bootstrap_section = nullptr;
    DWORD FileSize = 0;
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
        auto section = &section_header[i];
        switch (section->Name[0]) {
        case 'b': // bootstrap
            bootstrap_section = section;
            break;
        case 'l': // loader
            loader_section = section;
            // fallthrough (encrypt loader section too)
        case 'e': // encrypted
            // encrypt section
            for (int j = 0; j < section->SizeOfRawData; j += sizeof(new_xor_key)) {
                auto data = (PULONG64)(new_image_base + section->PointerToRawData + j);
                *data ^= new_xor_key;
            }
            break;
        default:
            // ignore other sections
            break;
        }

        // calculate file size
        FileSize = max(FileSize, section->PointerToRawData + section->SizeOfRawData);
    }

    if (!loader_section)
        EXIT_WITH_ERROR(ERR_FAILED_TO_FIND_LOADER_SECTION, "Failed to find loader section");
    if (!bootstrap_section)
        EXIT_WITH_ERROR(ERR_FAILED_TO_FIND_BOOTSTRAP_SECTION, "Failed to find bootstrap section");

    // fill bootstrap section with random data
    for (int i = 0; i < bootstrap_section->SizeOfRawData; i += sizeof(ULONG)) {
        auto data = (PULONG)(new_image_base + bootstrap_section->PointerToRawData + i);
        *data = fnRtlRandomEx(&seed);
    }

    auto bootstrap_shellcode = get_bootstrap_shellcode(new_xor_key, loader_section->VirtualAddress, loader_section->SizeOfRawData);

    // pick a random offset in the bootstrap section to store the bootstrap shellcode
    ULONG_PTR max_offset = bootstrap_section->SizeOfRawData - bootstrap_shellcode.size();
    ULONG_PTR bootstrap_shellcode_offset = max_offset == 0 ? 0 : (fnRtlRandomEx(&seed) % max_offset);

    // copy bootstrap shellcode to new executable
    inline_memcpy((PVOID)(new_image_base + bootstrap_section->PointerToRawData + bootstrap_shellcode_offset), bootstrap_shellcode.data(), bootstrap_shellcode.size());

    // update entry point to point to bootstrap shellcode
    nt_headers->OptionalHeader.AddressOfEntryPoint = bootstrap_section->VirtualAddress + bootstrap_shellcode_offset;

    // randomize section names
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
        auto section = &section_header[i];

        // ignore sections with well known names
        if (section->Name[0] == '.')
            continue;

        // start at 1 to skip our "magic" section type indicator
        for (int j = 1; j < 8; j++) {
            section->Name[j] = (char)(fnRtlRandomEx(&seed) % 26 + 'a');
        }
    }

    // generate a new random file name
    char file_name[MAX_PATH];
    for (int i = 0; i < 16; i++) {
        file_name[i] = (char)(fnRtlRandomEx(&seed) % 26 + 'a');
    }
    file_name[16] = '.';
    file_name[17] = 'e';
    file_name[18] = 'x';
    file_name[19] = 'e';
    file_name[20] = '\0';

    auto file_handle = fnCreateFileA(file_name, GENERIC_WRITE | DELETE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (file_handle == INVALID_HANDLE_VALUE)
        EXIT_WITH_ERROR(ERR_FAILED_TO_OPEN_FILE_FOR_NEW_EXECUTABLE, "Failed to open file for new executable");
    
    FILE_DISPOSITION_INFO disposition_info;
    disposition_info.DeleteFile = TRUE;
    if (!fnSetFileInformationByHandle(file_handle, FileDispositionInfo, &disposition_info, sizeof(disposition_info))) {
        fnCloseHandle(file_handle);
        EXIT_WITH_ERROR(ERR_FAILED_TO_SET_DELETE_FILE_INFO, "Failed to set delete file info (1)");
    }

    DWORD bytes_written = 0;
    if (!fnWriteFile(file_handle, (PVOID)new_image_base, FileSize, &bytes_written, nullptr)) {
        fnCloseHandle(file_handle);
        EXIT_WITH_ERROR(ERR_FAILED_TO_WRITE_NEW_EXECUTABLE_TO_DISK, "Failed to write new executable to disk");
    }

    if (bytes_written != FileSize) {
        fnCloseHandle(file_handle);
        EXIT_WITH_ERROR(ERR_FAILED_TO_WRITE_ENTIRE_NEW_EXECUTABLE_TO_DISK, "Failed to write entire new executable to disk");
    }

    fnVirtualFree((PVOID)new_image_base, 0, MEM_RELEASE);
#endif

    auto error = map_encrypted_sections(base);
    if (error != ERR_SUCCESS) {
#ifndef FUMO_DEBUG
        fnCloseHandle(file_handle);
#endif
        fnExitProcess(error);
        return;
    }

#ifndef FUMO_DEBUG
    disposition_info.DeleteFileW = FALSE;
    if (!fnSetFileInformationByHandle(file_handle, FileDispositionInfo, &disposition_info, sizeof(disposition_info))) {
        fnCloseHandle(file_handle);
        EXIT_WITH_ERROR(ERR_FAILED_TO_SET_DELETE_FILE_INFO, "Failed to set delete file info (2)");
    }

    fnCloseHandle(file_handle);
#endif
    fnExitProcess(0);
}
```

`src/resource_generator/CMakeLists.txt`:

```txt
add_executable(resource_generator resource_generator.cpp)
target_compile_features(resource_generator PUBLIC c_std_17 cxx_std_20)
target_compile_definitions(resource_generator PRIVATE UNICODE _UNICODE)
set_target_properties(resource_generator PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

```

`src/resource_generator/resource_generator.cpp`:

```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <array>
#include <iomanip>
#include <filesystem>

int main(int argc, char** argv) {
    if (argc != 4) {
        std::cerr << "Usage: " << argv[0] << " <input_file> <symbol_name> <output_path> " << std::endl;
        return 1;
    }

    std::string input_file_name = argv[1];
    std::string target_symbol_name = argv[2];
    std::filesystem::path output_path = argv[3];

    std::ifstream input_file(input_file_name, std::ios::binary);
    if (!input_file.is_open()) {
        std::cerr << "Failed to open file" << std::endl;
        return 1;
    }

    std::vector<unsigned char> input_data;
    input_data.assign(std::istreambuf_iterator<char>(input_file), std::istreambuf_iterator<char>());

    std::filesystem::path output_source_path = output_path / (target_symbol_name + ".cpp");
    std::ofstream output_file(output_source_path, std::ios::binary);
    if (!output_file.is_open()) {
        std::cerr << "Failed to open source file: " << output_source_path << std::endl;
        return 1;
    }

    output_file << "#include \"" << target_symbol_name << ".h\"\n\n";
    output_file << "std::array<unsigned char, " << input_data.size() << "> res::" << target_symbol_name << " = {\n\t";
    for (int i = 0; i < input_data.size(); i++) {
        if (i % 16 == 0 && i != 0) {
            output_file << "\n\t";
        }
        output_file << "0x" << std::setfill('0') << std::setw(2) << std::hex << (int)input_data[i] << ", ";
    }
    output_file << "\n};\n";
    output_file.close();

    std::filesystem::path output_header_path = output_path / (target_symbol_name + ".h");
    std::ofstream output_header(output_header_path, std::ios::binary);
    if (!output_header.is_open()) {
        std::cerr << "Failed to open header file: " << output_header_path << std::endl;
        return 1;
    }

    output_header << "#pragma once\n\n";
    output_header << "#include <array>\n\n";
    output_header << "namespace res {\n";
    output_header << "extern std::array<unsigned char, " << input_data.size() << "> " << target_symbol_name << ";\n";
    output_header << "}\n";
    output_header.close();

    return 0;
}
```

`src/shellcode_extractor/CMakeLists.txt`:

```txt
add_executable(shellcode_extractor shellcode_extractor.cpp)
target_compile_features(shellcode_extractor PUBLIC c_std_17 cxx_std_20)
target_compile_definitions(shellcode_extractor PRIVATE UNICODE _UNICODE)
set_target_properties(shellcode_extractor PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
```

`src/shellcode_extractor/shellcode_extractor.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <iomanip>

// purpose: extract shellcode from object file given symbol name and save to disk
// reason for existence: Why manually copy it every time when you can
//                       overengineer an automatic extractor/encoder?
// references: https://learn.microsoft.com/en-us/windows/win32/debug/pe-format

std::string getSymbolName(PIMAGE_SYMBOL symbol, PBYTE string_table);

int main(int argc, char** argv) {
    if (argc != 4) {
        std::cerr << "Usage: " << argv[0] << " <object_file> <symbol_name> <output_file>" << std::endl;
        return 1;
    }

    std::string object_file_name = argv[1];
    std::string target_symbol_name = argv[2];
    std::string output_file_name = argv[3];

    std::ifstream object_file(argv[1], std::ios::binary);
    if (!object_file.is_open()) {
        std::cerr << "Failed to open file" << std::endl;
        return 1;
    }

    std::vector<unsigned char> object_data;
    object_data.assign(std::istreambuf_iterator<char>(object_file), std::istreambuf_iterator<char>());

    PBYTE object_base = (PBYTE)object_data.data();
    PIMAGE_FILE_HEADER file_header = (PIMAGE_FILE_HEADER)object_base;
    if (file_header->Machine != IMAGE_FILE_MACHINE_AMD64) {
        std::cerr << "Not a 64-bit object file" << std::endl;
        return 1;
    }

    // parse symbol table
    PIMAGE_SYMBOL symbol_table = (PIMAGE_SYMBOL)(object_base + file_header->PointerToSymbolTable);
    PBYTE string_table = (PBYTE)(symbol_table + file_header->NumberOfSymbols);

    SHORT SectionNumber = IMAGE_SYM_UNDEFINED;
    DWORD SectionOffset = 0;
    for (int i = 0; i < file_header->NumberOfSymbols; i++) {
        std::string symbol_name = getSymbolName(&symbol_table[i], string_table);
        if (symbol_name != target_symbol_name) {
            i += symbol_table[i].NumberOfAuxSymbols;
            continue;
        }

        if ((symbol_table[i].Type >> 4) != IMAGE_SYM_DTYPE_FUNCTION || (symbol_table[i].Type & 0x0F) != IMAGE_SYM_TYPE_NULL) {
            std::cerr << "Specified symbol is not a function" << std::endl;
            return 1;
        }

        if (symbol_table[i].StorageClass != IMAGE_SYM_CLASS_EXTERNAL) {
            std::cerr << "Specified symbol is not external" << std::endl;
            return 1;
        }

        if (symbol_table[i].SectionNumber <= IMAGE_SYM_UNDEFINED) {
            std::cerr << "Specified symbol is not defined in any section" << std::endl;
            return 1;
        }

        SectionNumber = symbol_table[i].SectionNumber;
        SectionOffset = symbol_table[i].Value;
        break;
    }

    if (SectionNumber == IMAGE_SYM_UNDEFINED) {
        std::cerr << "Specified symbol not found" << std::endl;
        return 1;
    }

    // find section
    PIMAGE_SECTION_HEADER section_header = (PIMAGE_SECTION_HEADER)(object_base + sizeof(IMAGE_FILE_HEADER) + file_header->SizeOfOptionalHeader);
    PIMAGE_SECTION_HEADER target_section = &section_header[SectionNumber - 1]; // section numbers are 1-based

    // extract function data
    PBYTE section_data = object_base + target_section->PointerToRawData + SectionOffset;
    DWORD section_size = target_section->SizeOfRawData - SectionOffset;

    // write to file
    std::ofstream output_file(output_file_name, std::ios::binary);
    if (!output_file.is_open()) {
        std::cerr << "Failed to open output file" << std::endl;
        return 1;
    }

    output_file.write((char*)section_data, section_size);
    output_file.close();
    return 0;
}

std::string getSymbolName(PIMAGE_SYMBOL symbol, PBYTE string_table) {
    if (symbol->N.Name.Short == 0)
        return std::string((char*)(string_table + symbol->N.Name.Long));

    char short_name[9] = { 0 };
    memcpy(short_name, symbol->N.ShortName, 8);
    return std::string(short_name);
}
```

`src/stage1/CMakeLists.txt`:

```txt
add_custom_command(
    DEPENDS resource_generator fumo_drv
    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Resources/fumo_drv_data.cpp ${CMAKE_CURRENT_BINARY_DIR}/Resources/fumo_drv_data.h
    COMMAND resource_generator $<TARGET_FILE:fumo_drv> fumo_drv_data ${CMAKE_CURRENT_BINARY_DIR}/Resources
)

add_custom_command(
    DEPENDS resource_generator stage2
    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Resources/stage2_data.cpp ${CMAKE_CURRENT_BINARY_DIR}/Resources/stage2_data.h
    COMMAND resource_generator $<TARGET_FILE:stage2> stage2_data ${CMAKE_CURRENT_BINARY_DIR}/Resources
)

set(STAGE1_RESOURCES
    ${CMAKE_CURRENT_BINARY_DIR}/Resources/fumo_drv_data.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/Resources/stage2_data.cpp
)

add_library(stage1 MODULE stage1.cpp anti_idiot.cpp fumo_preloader.cpp ${STAGE1_RESOURCES})
target_include_directories(stage1 PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../include ${CMAKE_CURRENT_BINARY_DIR}/Resources)
target_compile_features(stage1 PUBLIC c_std_17 cxx_std_20)
target_compile_definitions(stage1 PRIVATE UNICODE _UNICODE)
target_compile_options(stage1 PRIVATE /O1 /GS- /sdl- /guard:cf- /Zc:threadSafeInit-)
target_link_libraries(stage1 PUBLIC ntdll libKDU driver_interface lazy_importer)
set_target_properties(stage1 PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})

if (FUMO_DRIVER_DEBUG)
    target_compile_definitions(stage1 PRIVATE -DFUMO_DRIVER_DEBUG)
endif()
```

`src/stage1/anti_idiot.cpp`:

```cpp
#include "fumo_preloader.h"

std::array<std::wstring, 4> spyware_services = {
    L"FACEIT",
    L"ESEADriver2",
    L"vgk",
    L"vgc",
};

template <typename... Args> 
int s_error(int code, std::wformat_string<Args...> fmt, Args&&... args) {
    return fumo::error(
        code, 
        L"Failed to disable problematic anti-cheat services: {}",
        std::format(fmt, std::forward<decltype(args)>(args)...)
    );
};

int disable_service(SC_HANDLE sc_handle, LPWSTR service_name) {
    SC_HANDLE service_handle = OpenServiceW(sc_handle, service_name, SERVICE_STOP | SERVICE_QUERY_STATUS);
    if (!service_handle) {
        return ERR_STAGE1_FAILED_TO_OPEN_SERVICE;
    }
    
    SERVICE_STATUS status;
    if (!ControlService(service_handle, SERVICE_CONTROL_STOP, &status)) {
        CloseServiceHandle(service_handle);
        return ERR_STAGE1_FAILED_TO_STOP_SERVICE_CONTROL;
    }

    ULONGLONG start_time = GetTickCount64();
    while (status.dwCurrentState != SERVICE_STOPPED) {
        if (GetTickCount64() - start_time > 30000) {
            CloseServiceHandle(service_handle);
            return ERR_STAGE1_FAILED_TO_STOP_SERVICE_TIMEOUT;
        }

        Sleep(status.dwWaitHint);
        
        if (!QueryServiceStatus(service_handle, &status)) {
            CloseServiceHandle(service_handle);
            return ERR_STAGE1_FAILED_TO_STOP_SERVICE_QUERY;
        }
    }

    CloseServiceHandle(service_handle);
    return ERR_STAGE1_SUCCESS;
}

int disable_spyware() {
    SC_HANDLE sc_handle = OpenSCManagerW(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
    if (!sc_handle)
        return s_error(ERR_STAGE1_FAILED_TO_OPEN_DRIVER, L"Failed to open SC manager");
    
    DWORD bytes_needed = 0;
    DWORD services_count = 0;
    EnumServicesStatusW(sc_handle, SERVICE_TYPE_ALL, SERVICE_ACTIVE, NULL, 0, &bytes_needed, &services_count, NULL);
    // the ERROR_INSUFFICIENT_BUFFER is a lie, thanks microsoft docs for lying
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER && GetLastError() != ERROR_MORE_DATA) {
        CloseServiceHandle(sc_handle);
        return s_error(ERR_STAGE1_FAILED_TO_ENUMERATE_SERVICE, L"Failed to enumerate services (1)");
    }
    
    std::vector<BYTE> buffer(bytes_needed);
    ENUM_SERVICE_STATUSW* services = (ENUM_SERVICE_STATUSW*)buffer.data();
    
    DWORD resume_handle = 0;
    while (true) {
        if (!EnumServicesStatusW(sc_handle, SERVICE_TYPE_ALL, SERVICE_ACTIVE, services, buffer.size(), &bytes_needed, &services_count, &resume_handle)) {
            if (GetLastError() != ERROR_MORE_DATA) {
                CloseServiceHandle(sc_handle);
                return s_error(ERR_STAGE1_FAILED_TO_ENUMERATE_SERVICE, L"Failed to enumerate services (2)");
            }
        }
        
        for (DWORD i = 0; i < services_count; i++) {
            auto& service = services[i];
            if (std::find(spyware_services.begin(), spyware_services.end(), service.lpServiceName) == spyware_services.end())
                continue;
            
            auto message = std::format(
                L"Found potentially problematic Anti-Cheat service:\n{} ({})\nDisable automatically?",
                service.lpDisplayName, service.lpServiceName
            );
            int response = MessageBoxW(NULL, message.c_str(), L"Invasive Anti-Cheat is running", MB_YESNOCANCEL | MB_ICONWARNING | MB_SYSTEMMODAL);
            if (response == IDNO)
                continue;
            if (response != IDYES) {
                CloseServiceHandle(sc_handle);
                return ERR_STAGE1_USER_CANCELLED;
            }

            // IDYES
            while (true) {
                int status = disable_service(sc_handle, service.lpServiceName);
                if (status == ERR_STAGE1_SUCCESS)
                    break;

                std::wstring message;
                switch (status) {
                    case ERR_STAGE1_FAILED_TO_OPEN_SERVICE:
                        message = fumo::error_string(status, L"Failed to open service: {}", service.lpServiceName);
                        break;
                    case ERR_STAGE1_FAILED_TO_STOP_SERVICE_CONTROL:
                        message = fumo::error_string(status, L"Failed to stop service: {}", service.lpServiceName);
                        break;
                    case ERR_STAGE1_FAILED_TO_STOP_SERVICE_TIMEOUT:
                        message = fumo::error_string(status, L"Timeout while stopping service: {}", service.lpServiceName);
                        break;
                    case ERR_STAGE1_FAILED_TO_STOP_SERVICE_QUERY:
                        message = fumo::error_string(status, L"Failed to query service status: {}", service.lpServiceName);
                        break;
                    default:
                        message = fumo::error_string(status, L"Unknown error: {}", status);
                        break;
                }
                int response = MessageBoxW(NULL, message.c_str(), L"Failed to disable service", MB_ABORTRETRYIGNORE | MB_ICONERROR | MB_SYSTEMMODAL);
                if (response == IDRETRY)
                    continue;
                if (response == IDIGNORE)
                    break;
                
                // IDABORT
                CloseServiceHandle(sc_handle);
                return status;
            }
        }

        if (resume_handle == 0)
            break;
    }

    CloseServiceHandle(sc_handle);
    return ERR_STAGE1_SUCCESS;
}

bool is_hvci_enabled() {
    SYSTEM_CODEINTEGRITY_INFORMATION sci = { 0 };
    sci.Length = sizeof(sci);
    if (NT_SUCCESS(NtQuerySystemInformation(SystemCodeIntegrityInformation, &sci, sizeof(sci), NULL))) {
        return sci.CodeIntegrityOptions & CODEINTEGRITY_OPTION_ENABLED && 
          sci.CodeIntegrityOptions & CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED;
    }
    return false;
}

bool is_kva_shadow_enabled() {
    SYSTEM_KERNEL_VA_SHADOW_INFORMATION kvs = { 0 };
    if (NT_SUCCESS(NtQuerySystemInformation(SystemKernelVaShadowInformation, &kvs, sizeof(kvs), NULL))) {
        return kvs.KvaShadowEnabled && (!kvs.KvaShadowRequiredAvailable || kvs.KvaShadowRequired);
    }
    return false;
}

int disable_hvci() {
    HKEY hKey;
    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\DeviceGuard", 0, KEY_SET_VALUE, &hKey) != ERROR_SUCCESS)
        return fumo::error(ERR_STAGE1_FAILED_TO_OPEN_REGISTRY, L"Failed to open DeviceGuard registry key");
    
    DWORD value = 0;
    if (RegSetValueExW(hKey, L"EnableVirtualizationBasedSecurity", 0, REG_DWORD, (BYTE*)&value, sizeof(value)) != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return fumo::error(ERR_STAGE1_FAILED_TO_SET_REGISTRY_VALUE, L"Failed to set EnableVirtualizationBasedSecurity to 0");
    }

    RegCloseKey(hKey);
    return ERR_STAGE1_SUCCESS;
}

int disable_kva_shadow() {
    HKEY hKey;
    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management", 0, KEY_SET_VALUE, &hKey) != ERROR_SUCCESS)
        return fumo::error(ERR_STAGE1_FAILED_TO_OPEN_REGISTRY, L"Failed to open Memory Management registry key");
    
    DWORD value = 3;
    if (RegSetValueExW(hKey, L"FeatureSettingsOverride", 0, REG_DWORD, (BYTE*)&value, sizeof(value)) != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return fumo::error(ERR_STAGE1_FAILED_TO_SET_REGISTRY_VALUE, L"Failed to set FeatureSettingsOverride to 3");
    }

    if (RegSetValueExW(hKey, L"FeatureSettingsOverrideMask", 0, REG_DWORD, (BYTE*)&value, sizeof(value)) != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return fumo::error(ERR_STAGE1_FAILED_TO_SET_REGISTRY_VALUE, L"Failed to set FeatureSettingsOverrideMask to 3");
    }

    RegCloseKey(hKey);
    return ERR_STAGE1_SUCCESS;
}

int disable_mitigations() {
    bool reboot_required = false;

    if (is_hvci_enabled()) {
        int response = MessageBoxW(NULL, 
            L"Hypervisor Code Integrity (HVCI) is enabled!\n"
            L"Fumo loader is not compatible with HVCI.\n"
            L"Disable HVCI now?",
            L"Incompatible system settings", MB_YESNO | MB_ICONWARNING | MB_SYSTEMMODAL
        );
        if (response != IDYES)
            return fumo::error(ERR_STAGE1_HVCI_ENABLED, L"Hypervisor Code Integrity (HVCI) is enabled, please disable it and try again");

        int status = disable_hvci();
        if (status != ERR_STAGE1_SUCCESS)
            return status;
        reboot_required = true;
    }
    
    if (is_kva_shadow_enabled()) {
        int response = MessageBoxW(NULL, 
            L"Kernel Virtual Address Shadow (KVAS) is enabled!\n"
            L"Fumo loader is not compatible with KVAS.\n"
            L"Disable KVAS now?",
            L"Incompatible system settings", MB_YESNO | MB_ICONWARNING | MB_SYSTEMMODAL
        );
        if (response != IDYES)
            return fumo::error(ERR_STAGE1_KVA_SHADOW_ENABLED, L"Kernel Virtual Address Shadow (KVAS) is enabled, please disable it and try again");

        int status = disable_kva_shadow();
        if (status != ERR_STAGE1_SUCCESS)
            return status;
        reboot_required = true;
    }

    if (reboot_required) {
        int response = MessageBoxW(NULL, 
            L"System settings have been changed.\n"
            L"A reboot is required to apply the changes.\n"
            L"Reboot now?",
            L"Reboot required", MB_YESNO | MB_ICONQUESTION | MB_SYSTEMMODAL
        );
        if (response == IDYES) {
            if (!get_privilege(SE_SHUTDOWN_NAME))
                return fumo::error(ERR_STAGE1_FAILED_TO_GET_SHUTDOWN_PRIVILEGES, L"Failed to get shutdown privileges");

            ExitWindowsEx(EWX_REBOOT, 0);
        }
        return ERR_STAGE1_REBOOT_REQUIRED;
    }

    return ERR_STAGE1_SUCCESS;
}
```

`src/stage1/fumo_preloader.cpp`:

```cpp
#include "fumo_preloader.h"
#include <libKDU.h>
#include <lazy_importer.hpp>
#include <fumo_drv_data.h>
#include <stage2_data.h>

int load_stage2(HANDLE process, std::vector<BYTE>& fumo_data) {
    // save process name in case it dies mid way through
    auto process_name = get_proces_name(process);

    // parse stage2 header
    LPVOID local_stage2_data = res::stage2_data.data();
    auto dos_header = (PIMAGE_DOS_HEADER)local_stage2_data;
    auto nt_headers = (PIMAGE_NT_HEADERS)((ULONG_PTR)local_stage2_data + dos_header->e_lfanew);

    // allocate memory for stage2 in the target process
    ULONG_PTR stage2_base = (ULONG_PTR)VirtualAllocEx(process, NULL, nt_headers->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (stage2_base == NULL)
        return fumo::error(ERR_STAGE1_FAILED_TO_ALLOCATE_MEMORY, L"Failed to allocate memory in {}", process_name);
    
    // allocate local memory for stage2
    ULONG_PTR stage2_local_base = (ULONG_PTR)VirtualAlloc(NULL, nt_headers->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (stage2_local_base == NULL) {
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);
        return fumo::error(ERR_STAGE1_FAILED_TO_ALLOCATE_MEMORY, L"Failed to allocate memory for module in {}", process_name);
    }
    
    // copy headers
    memcpy((PVOID)stage2_local_base, local_stage2_data, nt_headers->OptionalHeader.SizeOfHeaders);
    dos_header = (PIMAGE_DOS_HEADER)stage2_local_base;
    nt_headers = (PIMAGE_NT_HEADERS)(stage2_local_base + dos_header->e_lfanew);

    // map sections
    auto section_header = IMAGE_FIRST_SECTION(nt_headers);
    for (auto i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
        auto section = &section_header[i];
        if (section->SizeOfRawData == 0)
            continue;
        auto section_data = (PVOID)((ULONG_PTR)local_stage2_data + section->PointerToRawData);
        memcpy((PVOID)(stage2_local_base + section->VirtualAddress), section_data, section->SizeOfRawData);
    }

    // relocate the image
    auto delta = (ULONG_PTR)stage2_base - nt_headers->OptionalHeader.ImageBase;
    if (delta != 0) {
        auto base_relocation = (PIMAGE_BASE_RELOCATION)(stage2_local_base + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
        while (base_relocation->VirtualAddress != 0) {
            auto relocation = (PWORD)((ULONG_PTR)base_relocation + sizeof(IMAGE_BASE_RELOCATION));
            auto number_of_relocations = (base_relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
            for (auto i = 0; i < number_of_relocations; i++) {
                auto type = relocation[i] >> 12;
                if (type == IMAGE_REL_BASED_DIR64) {
                    auto address = (PULONG_PTR)(stage2_local_base + base_relocation->VirtualAddress + (relocation[i] & 0xFFF));
                    *address += delta;
                } else if (type != IMAGE_REL_BASED_ABSOLUTE)
                    return fumo::error(ERR_STAGE1_FAILED_TO_RELOCATE_MODULE, L"Failed to relocate module");
            }
            base_relocation = (PIMAGE_BASE_RELOCATION)((ULONG_PTR)base_relocation + base_relocation->SizeOfBlock);
        }
    }

    // write stage2 to target process
    if (!WriteProcessMemory(process, (LPVOID)stage2_base, (LPCVOID)stage2_local_base, nt_headers->OptionalHeader.SizeOfImage, NULL)) {
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);   
        return fumo::error(ERR_STAGE1_FAILED_TO_WRITE_MEMORY, L"Failed to write stage2 to {}", process_name);
    }
    
    // free local memory
    VirtualFree((LPVOID)stage2_local_base, 0, MEM_RELEASE);

    // allocate memory for stage2 loader in the target process
    ULONG_PTR fumo_data_base = (ULONG_PTR)VirtualAllocEx(process, NULL, fumo_data.size(), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (fumo_data_base == NULL) {
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);
        return fumo::error(ERR_STAGE1_FAILED_TO_ALLOCATE_MEMORY, L"Failed to allocate memory for data in {}", process_name);
    }

    // write fumo data to target process
    if (!WriteProcessMemory(process, (LPVOID)fumo_data_base, fumo_data.data(), fumo_data.size(), NULL)) {
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)fumo_data_base, 0, MEM_RELEASE);
        return fumo::error(ERR_STAGE1_FAILED_TO_WRITE_MEMORY, L"Failed to write fumo data to {}", process_name);
    }

    STAGE2_LOADER_DATA loader_data = { 0 };
    loader_data.stage2_base = (ULONG_PTR)stage2_base;
    loader_data.fumo_data_base = (ULONG_PTR)fumo_data_base;
    loader_data.loader_pid = GetCurrentProcessId();

    SIZE_T shellcode_size = (SIZE_T)stage2_loader_shellcode_end - (SIZE_T)stage2_loader_shellcode;
    SIZE_T shellcode_data_size = sizeof(STAGE2_LOADER_DATA);

    // allocate memory for shellcode in the target process
    ULONG_PTR shellcode_base = (ULONG_PTR)VirtualAllocEx(process, NULL, shellcode_size + shellcode_data_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (shellcode_base == NULL) {
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)fumo_data_base, 0, MEM_RELEASE);
        return fumo::error(ERR_STAGE1_FAILED_TO_ALLOCATE_MEMORY, L"Failed to allocate memory for shellcode in {}", process_name);
    }

    // write shellcode to target process
    ULONG_PTR shellcode_data_base = shellcode_base + shellcode_size;
    if (
        !WriteProcessMemory(process, (LPVOID)shellcode_base, (LPCVOID)stage2_loader_shellcode, shellcode_size, NULL) ||
        !WriteProcessMemory(process, (LPVOID)shellcode_data_base, (LPCVOID)&loader_data, sizeof(STAGE2_LOADER_DATA), NULL)
    ) {
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)fumo_data_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)shellcode_base, 0, MEM_RELEASE);
        return fumo::error(ERR_STAGE1_FAILED_TO_WRITE_MEMORY, L"Failed to write shellcode to {}", process_name);
    }

    // execute shellcode
    HANDLE thread = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)shellcode_base, (LPVOID)shellcode_data_base, 0, NULL);
    if (thread == NULL) {
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)fumo_data_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)shellcode_base, 0, MEM_RELEASE);
        return fumo::error(ERR_STAGE1_FAILED_TO_EXECUTE_SHELLCODE, L"Failed to execute shellcode in {}", process_name);
    }

    DWORD wait_result = WaitForSingleObject(thread, INFINITE);
    if (wait_result != WAIT_OBJECT_0) {
        CloseHandle(thread);
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)fumo_data_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)shellcode_base, 0, MEM_RELEASE);
        return fumo::error(ERR_STAGE1_FAILED_TO_EXECUTE_SHELLCODE, L"Failed to execute shellcode in {}", process_name);
    }

    // get shellcode exit code
    DWORD exit_code = 0;
    GetExitCodeThread(thread, &exit_code);
    CloseHandle(thread);

    // free shellcode memory
    VirtualFreeEx(process, (LPVOID)shellcode_base, 0, MEM_RELEASE);

    // check return code
    if (exit_code != 0) {
        return fumo::error(ERR_STAGE1_FAILED_TO_EXECUTE_SHELLCODE, L"Failed to execute shellcode in {}, error code: {}", process_name, exit_code);
    }

    return ERR_STAGE1_SUCCESS;
}

DWORD stage2_loader_shellcode(PSTAGE2_LOADER_DATA loader_data) {
    auto fnLoadLibraryA = LI_FN(LoadLibraryA).get();
    auto fnGetProcAddress = LI_FN(GetProcAddress).get();

    // parse stage2 header
    auto dos_header = (PIMAGE_DOS_HEADER)loader_data->stage2_base;
    auto nt_headers = (PIMAGE_NT_HEADERS)(loader_data->stage2_base + dos_header->e_lfanew);
    auto section_header = IMAGE_FIRST_SECTION(nt_headers);

    // resolve imports
    auto import_descriptor = (PIMAGE_IMPORT_DESCRIPTOR)(loader_data->stage2_base + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
    while (import_descriptor->Name != 0) {
        auto module_name = (LPCSTR)(loader_data->stage2_base + import_descriptor->Name);
        auto module_base = fnLoadLibraryA(module_name);
        if (module_base == NULL)
            return 1;
        auto thunk_data = (PIMAGE_THUNK_DATA)(loader_data->stage2_base + import_descriptor->FirstThunk);
        auto import_address = (PULONG_PTR)(loader_data->stage2_base + import_descriptor->FirstThunk);
        while (thunk_data->u1.AddressOfData != 0) {
            if (thunk_data->u1.Ordinal & IMAGE_ORDINAL_FLAG) {
                *import_address = (ULONG_PTR)fnGetProcAddress(module_base, (LPCSTR)(thunk_data->u1.Ordinal & 0xFFFF));
            }
            else {
                auto import_by_name = (PIMAGE_IMPORT_BY_NAME)(loader_data->stage2_base + thunk_data->u1.AddressOfData);
                *import_address = (ULONG_PTR)fnGetProcAddress(module_base, (LPCSTR)import_by_name->Name);
            }
            if (*import_address == NULL)
                return 2;
            thunk_data++;
            import_address++;
        }
        import_descriptor++;
    }


    // call entry point
    using fnDllMain = BOOL(WINAPI*)(HMODULE, DWORD, LPVOID);
    auto entry_point = (fnDllMain)(loader_data->stage2_base + nt_headers->OptionalHeader.AddressOfEntryPoint);
    BOOL success = entry_point((HMODULE)loader_data->stage2_base, DLL_PROCESS_ATTACH, loader_data);
    return success ? 0 : 1;
}

void stage2_loader_shellcode_end() {}

int init_driver(fumo::DriverInterface* pDriver, DWORD osBuildNumber, bool forceReload) {
    ULONG version;
    BOOL just_loaded = FALSE;
    if (!pDriver->GetVersion(&version)) {
        auto error = load_driver(osBuildNumber);
        if (error != ERR_STAGE1_SUCCESS)
            return error;

        just_loaded = TRUE;
        if (!pDriver->GetVersion(&version))
            return fumo::error(ERR_STAGE1_FAILED_TO_GET_DRIVER_VERSION, L"Failed to get driver version");
    }

    if (version != FUMO_DRIVER_VERSION || forceReload) {
        // if the driver we just loaded reports a wrong version something has gone terribly wrong
        if (just_loaded && !forceReload)
            return fumo::error(ERR_STAGE1_LOADED_DERIVER_VERSION_MISMATCH, L"Driver version mismatch (expected: {}, found: {})", FUMO_DRIVER_VERSION, version);

        // unload the old driver and try again
        pDriver->Unload();
        return init_driver(pDriver, osBuildNumber, false);
    }

    return ERR_STAGE1_SUCCESS;
}

int load_driver(DWORD osBuildNumber) {
    // FIXME: make the provider configurable
    if (!libKDUMapDriver(0, osBuildNumber, 34, 1, res::fumo_drv_data.data(), NULL, NULL))
        return fumo::error(ERR_STAGE1_FAILED_TO_MAP_DRIVER, L"Failed to map driver");

    return ERR_STAGE1_SUCCESS;
}

bool get_privilege(const TCHAR* Name) {
    HANDLE token;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &token))
        return false;

    LUID luid;
    if (!LookupPrivilegeValue(NULL, Name, &luid)) {
        CloseHandle(token);
        return false;
    }

    TOKEN_PRIVILEGES privileges;
    privileges.PrivilegeCount = 1;
    privileges.Privileges[0].Luid = luid;
    privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(token, FALSE, &privileges, sizeof(privileges), NULL, NULL)) {
        CloseHandle(token);
        return false;
    }

    CloseHandle(token);
    return true;
}
```

`src/stage1/fumo_preloader.h`:

```h
#pragma once
#include <util.h>
#include <fomo_common.h>
#include <driver_interface.h>
#include <vector>

#define ERR_STAGE1_SUCCESS 0
#define ERR_STAGE1_INVALID_ARGS 1
#define ERR_STAGE1_FAILED_TO_OPEN_FILE 2
#define ERR_STAGE1_FAILED_TO_GET_DEBUG_PRIVILEGES 3
#define ERR_STAGE1_FAILED_TO_GET_SHUTDOWN_PRIVILEGES 4

#define ERR_STAGE1_UNSUPPORTED_OS 50
#define ERR_STAGE1_HVCI_ENABLED 51
#define ERR_STAGE1_KVA_SHADOW_ENABLED 52
#define ERR_STAGE1_REBOOT_REQUIRED 53

#define ERR_STAGE1_FAILED_TO_OPEN_SC_MANAGER 60
#define ERR_STAGE1_FAILED_TO_ENUMERATE_SERVICE 61
#define ERR_STAGE1_FAILED_TO_OPEN_SERVICE 62
#define ERR_STAGE1_FAILED_TO_STOP_SERVICE_CONTROL 63
#define ERR_STAGE1_FAILED_TO_STOP_SERVICE_TIMEOUT 64
#define ERR_STAGE1_FAILED_TO_STOP_SERVICE_QUERY 65

#define ERR_STAGE1_FAILED_TO_OPEN_REGISTRY 80
#define ERR_STAGE1_FAILED_TO_SET_REGISTRY_VALUE 81

#define ERR_STAGE1_USER_CANCELLED 99

#define ERR_STAGE1_FAILED_TO_MAP_DRIVER 100
#define ERR_STAGE1_FAILED_TO_OPEN_DRIVER 101
#define ERR_STAGE1_FAILED_TO_GET_DRIVER_VERSION 102
#define ERR_STAGE1_LOADED_DERIVER_VERSION_MISMATCH 103

#define ERR_STAGE1_FAILED_TO_FIND_PROCESS 150
#define ERR_STAGE1_FAILED_TO_OPEN_PROCESS 151

#define ERR_STAGE1_FAILED_TO_ALLOCATE_MEMORY 200
#define ERR_STAGE1_FAILED_TO_RELOCATE_MODULE 201
#define ERR_STAGE1_FAILED_TO_WRITE_MEMORY 202
#define ERR_STAGE1_FAILED_TO_EXECUTE_SHELLCODE 203

int disable_spyware();
int disable_mitigations();
int init_driver(fumo::DriverInterface* pDriver, DWORD osBuildNumber, bool forceReload = false);
int load_driver(DWORD osBuildNumber);
std::wstring get_proces_name(HANDLE process);
DWORD find_process_by_name(LPCWSTR lpProcessName);
int load_stage2(HANDLE process, std::vector<BYTE>& fumo_data);
DWORD stage2_loader_shellcode(PSTAGE2_LOADER_DATA loader_data);
void stage2_loader_shellcode_end();
bool get_privilege(const TCHAR* Name);
```

`src/stage1/stage1.cpp`:

```cpp
#include "fumo_preloader.h"
#include <filesystem>
#include <fstream>

#ifdef FUMO_DRIVER_DEBUG
#define FORCE_RELOAD_DRIVER true
#else
#define FORCE_RELOAD_DRIVER false
#endif

int stage1(PFUMO_EMBEDDED_DATA embedded_data) {
    std::vector<BYTE> fumo_data;
    std::wstring fumo_file_path;

    int argc = 0;
    LPWSTR* argv = CommandLineToArgvW(GetCommandLineW(), &argc);

    // use embedded data if present unless a file is specified
    if (argc != 2 && embedded_data && embedded_data->Data && embedded_data->Size > 0) {
        fumo_file_path = L"embedded_data";
        fumo_data.assign((PBYTE)embedded_data->Data, (PBYTE)embedded_data->Data + embedded_data->Size);
    }
    else {
        if (argc != 2) {
            auto exe_name = std::filesystem::path(argv[0]).filename().wstring();
            return fumo::error(ERR_STAGE1_INVALID_ARGS, 
                L"Invalid arguments.\nUsage: {} <fumo_file>\nTip: you can drag the .fumo file on the loader executable",
                exe_name);
        }

        std::filesystem::path fumo_file = argv[1];
        fumo_file_path = fumo_file.wstring();
        std::ifstream fumo_stream(fumo_file, std::ios::binary);
        if (!fumo_stream.is_open())
            return fumo::error(ERR_STAGE1_FAILED_TO_OPEN_FILE, L"Failed to open file: {}", fumo_file_path);
        
        fumo_data.assign(std::istreambuf_iterator<char>(fumo_stream), std::istreambuf_iterator<char>());
        if (fumo_data.size() < sizeof(FUMO_DATA_HEADER) + 0x1000) // header + one page
            return fumo::error(ERR_STAGE1_FAILED_TO_OPEN_FILE, L"File to small: {}", fumo_file_path);
    }

    PFUMO_DATA_HEADER header = (PFUMO_DATA_HEADER)fumo_data.data();

    // check magic
    if (header->Magic != FUMO_MAGIC)
        return fumo::error(ERR_STAGE1_FAILED_TO_OPEN_FILE,
            L"Invalid file format: {}\nTip: use fumo_encoder to generate a .fumo file", fumo_file_path);
    
    // check version
    if (header->Version != FUMO_DATA_VERSION)
        return fumo::error(ERR_STAGE1_FAILED_TO_OPEN_FILE,
            L"Invalid file version (expected: {}, found: {}): {}\nTip: use fumo_encoder to generate a .fumo file",
            fumo_file_path, FUMO_DATA_VERSION, header->Version);

    OSVERSIONINFO osv;
    osv.dwOSVersionInfoSize = sizeof(osv);
    RtlGetVersion((PRTL_OSVERSIONINFOW)&osv);

    if (osv.dwMajorVersion < MIN_OS_MAJOR_VERSION || osv.dwBuildNumber < MIN_OS_BUILD_NUMBER)
        return fumo::error(ERR_STAGE1_UNSUPPORTED_OS, L"Unsupported OS version: {}.{}.{}.\nUpdate windows and try again", osv.dwMajorVersion, osv.dwMinorVersion, osv.dwBuildNumber);
    
    int status = disable_spyware();
    if (status != ERR_STAGE1_SUCCESS)
        return status;
    
    status = disable_mitigations();
    if (status != ERR_STAGE1_SUCCESS)
        return status;

    if(!get_privilege(SE_DEBUG_NAME))
        return fumo::error(ERR_STAGE1_FAILED_TO_GET_DEBUG_PRIVILEGES, L"Failed to get debug privileges");

    auto driver = fumo::DriverInterface::Open(FUMO_HOOKED_DRIVER_NAME_USER);
    if (!driver)
        return fumo::error(ERR_STAGE1_FAILED_TO_OPEN_DRIVER, L"Failed to open driver");

    auto error = init_driver(driver.get(), osv.dwBuildNumber, FORCE_RELOAD_DRIVER);
    if (error != ERR_STAGE1_SUCCESS)
        return error;
    
    auto pid = find_process_by_name(FUMO_SECOND_STAGE_PROCESS_NAME);
    if (pid == 0)
        return fumo::error(ERR_STAGE1_FAILED_TO_FIND_PROCESS, L"Failed to find {}", FUMO_SECOND_STAGE_PROCESS_NAME);
    
    auto process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (process == NULL)
        return fumo::error(ERR_STAGE1_FAILED_TO_OPEN_PROCESS, L"Failed to open {}", FUMO_SECOND_STAGE_PROCESS_NAME);
    
    error = load_stage2(process, fumo_data);
    CloseHandle(process);

    return error;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    if (fdwReason != DLL_PROCESS_ATTACH)
        return 0;

    return stage1((PFUMO_EMBEDDED_DATA)lpvReserved) == ERR_STAGE1_SUCCESS;
}
```

`src/stage2/CMakeLists.txt`:

```txt
add_library(stage2 MODULE stage2.cpp fumo_loader.cpp tray_icon.cpp)
target_include_directories(stage2 PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../include)
target_compile_features(stage2 PUBLIC c_std_17 cxx_std_20)
target_compile_options(stage2 PRIVATE /O1 /GS- /sdl- /guard:cf- /Zc:threadSafeInit-)
target_compile_definitions(stage2 PRIVATE UNICODE _UNICODE)
target_link_libraries(stage2 PRIVATE driver_interface lz4_static)
```

`src/stage2/fumo_loader.cpp`:

```cpp
#include "fumo_loader.h"
#include "stage2.h"
#include <driver_interface.h>

using fnLdrLoadDll = NTSTATUS(NTAPI*)(DWORD64, PULONG Flags, PUNICODE_STRING ModuleFileName, HMODULE* ModuleHandle);
using fnLdrGetProcedureAddress = NTSTATUS(NTAPI*)(HMODULE ModuleHandle, PANSI_STRING FunctionName, WORD Ordinal, PVOID* FunctionAddress);
using fnRtlAnsiStringToUnicodeString = decltype(&RtlAnsiStringToUnicodeString);
using fnDllMain = BOOL(WINAPI*)(HMODULE hModule, DWORD dwReason, LPVOID lpReserved);

typedef struct _MANUAL_MAPPING_DATA {
    PVOID ImageBase;
    PVOID VirtualProtectStub;
    fnLdrLoadDll LdrLoadDll;
    fnLdrGetProcedureAddress LdrGetProcedureAddress;
    fnRtlAnsiStringToUnicodeString RtlAnsiStringToUnicodeString;
} MANUAL_MAPPING_DATA, *PMANUAL_MAPPING_DATA;

MANUAL_MAPPING_DATA GetManualMappingData(PVOID pImageBase, PVOID pVirtualProtectStub) {
    HMODULE hNtdll = GetModuleHandleW(L"ntdll.dll");

    MANUAL_MAPPING_DATA data = {0};
    data.ImageBase = pImageBase;
    data.VirtualProtectStub = pVirtualProtectStub;
    data.LdrLoadDll = (fnLdrLoadDll)GetProcAddress(hNtdll, "LdrLoadDll");
    data.LdrGetProcedureAddress = (fnLdrGetProcedureAddress)GetProcAddress(hNtdll, "LdrGetProcedureAddress");
    data.RtlAnsiStringToUnicodeString = (fnRtlAnsiStringToUnicodeString)GetProcAddress(hNtdll, "RtlAnsiStringToUnicodeString");
    return data;
}

std::array<uint8_t, 34> virtual_protect_stub = {
    // check if lpAddress is above 0x7FFFFFFEFFFF
    0x48, 0x89, 0xC8,                                           // mov rax, rcx
    0x48, 0xC1, 0xE8, 0x10,                                     // shr rax, 0x10
    0x48, 0x3D, 0xFE, 0xFF, 0xFF, 0x7F,                         // cmp rax, 0x7ffffffe
    0x76, 0x06,                                                 // jbe .call_original
    // return STATUS_SUCCESS
    0xB8, 0x01, 0x00, 0x00, 0x00,                               // mov eax, 0x1
    0xC3,                                                       // ret
    // .call_original
    0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // movabs rax, 0x0 - original VirtualProtect
    0x48, 0xFF, 0xE0                                            // rex.W jmp rax
};
constexpr ULONG_PTR virtual_protect_stub_orig_addr_off = 23;

#define tolower(c) ((c >= 'A' && c <= 'Z') ? c + 32 : c)

DWORD Shellcode(PMANUAL_MAPPING_DATA pMmData) {
    // resolve imports
    auto nt_headers = (PIMAGE_NT_HEADERS)((ULONG_PTR)pMmData->ImageBase + ((PIMAGE_DOS_HEADER)pMmData->ImageBase)->e_lfanew);
    auto import_descriptor = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)pMmData->ImageBase + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

    while (import_descriptor->Name != 0) {
        auto module_name = (PCHAR)((ULONG_PTR)pMmData->ImageBase + import_descriptor->Name);

        USHORT module_name_length = 0;
        while (module_name[module_name_length] != 0)
            module_name_length++;

        BOOL is_kernel32 = FALSE;
        CHAR kernel32[] = {'k', 'e', 'r', 'n', 'e', 'l', '3', '2', '.', 'd', 'l', 'l'};
        if (module_name_length == sizeof(kernel32)) {
            is_kernel32 = TRUE;
            for (int i = 0; i < sizeof(kernel32); i++) {
                if (tolower(module_name[i]) != kernel32[i]) {
                    is_kernel32 = FALSE;
                    break;
                }
            }
        }

        ANSI_STRING ansi_module_name = {0};
        ansi_module_name.Buffer = module_name;
        ansi_module_name.Length = module_name_length;
        ansi_module_name.MaximumLength = module_name_length + 1;

        UNICODE_STRING unicode_module_name = {0};
        pMmData->RtlAnsiStringToUnicodeString(&unicode_module_name, &ansi_module_name, TRUE);

        HMODULE module_handle = nullptr;
        ULONG flags = 0;
        pMmData->LdrLoadDll(1, &flags, &unicode_module_name, &module_handle);

        auto original_first_thunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)pMmData->ImageBase + import_descriptor->OriginalFirstThunk);
        auto first_thunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)pMmData->ImageBase + import_descriptor->FirstThunk);

        while (original_first_thunk->u1.AddressOfData != 0) {
            PVOID function_address = nullptr;
            if (IMAGE_SNAP_BY_ORDINAL(original_first_thunk->u1.Ordinal)) {
                auto function_ordinal = IMAGE_ORDINAL(original_first_thunk->u1.Ordinal);
                pMmData->LdrGetProcedureAddress(module_handle, nullptr, function_ordinal, &function_address);
            } else {
                auto import_by_name = (PIMAGE_IMPORT_BY_NAME)((ULONG_PTR)pMmData->ImageBase + original_first_thunk->u1.AddressOfData);
                auto function_name = (PCHAR)import_by_name->Name;

                USHORT function_name_length = 0;
                while (function_name[function_name_length] != 0)
                    function_name_length++;
                
                CHAR virtual_protect[] = {'V', 'i', 'r', 't', 'u', 'a', 'l', 'P', 'r', 'o', 't', 'e', 'c', 't'};
                BOOL is_virtual_protect = FALSE;
                if (is_kernel32 && function_name_length == sizeof(virtual_protect)) {
                    is_virtual_protect = TRUE;
                    for (int i = 0; i < sizeof(virtual_protect); i++) {
                        if (function_name[i] != virtual_protect[i]) {
                            is_virtual_protect = FALSE;
                            break;
                        }
                    }
                }
                
                ANSI_STRING ansi_function_name = {0};
                ansi_function_name.Buffer = function_name;
                ansi_function_name.Length = function_name_length;
                ansi_function_name.MaximumLength = function_name_length + 1;

                pMmData->LdrGetProcedureAddress(module_handle, &ansi_function_name, 0, &function_address);

                if (is_virtual_protect) {
                    auto virtual_protect_stub = (PBYTE)pMmData->VirtualProtectStub;
                    *(PVOID*)(virtual_protect_stub + virtual_protect_stub_orig_addr_off) = function_address;
                    function_address = virtual_protect_stub;
                }
            }

            first_thunk->u1.Function = (ULONG_PTR)function_address;

            original_first_thunk++;
            first_thunk++;
        }

        import_descriptor++;
    }

    // call entry point
    auto entry_point = (fnDllMain)((ULONG_PTR)pMmData->ImageBase + nt_headers->OptionalHeader.AddressOfEntryPoint);
    entry_point((HMODULE)pMmData->ImageBase, DLL_PROCESS_ATTACH, nullptr);

    return 0;
}

VOID Shellcode_End() {}

int MapImage(fumo::DriverInterface* pDriver, ULONG pid, PVOID pImage) {
    // parse the PE header
    auto dos_header = (PIMAGE_DOS_HEADER)pImage;
    if (dos_header->e_magic != IMAGE_DOS_SIGNATURE)
        return fumo::error(ERR_STAGE2_INVALID_PE_HEADER, L"Invalid PE header");

    // parse the NT header
    auto nt_headers = (PIMAGE_NT_HEADERS)((ULONG_PTR)pImage + dos_header->e_lfanew);
    if (nt_headers->Signature != IMAGE_NT_SIGNATURE)
        return fumo::error(ERR_STAGE2_INVALID_PE_HEADER, L"Invalid PE header");

    // make sure the image is 64-bit
    if (nt_headers->FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64)
        return fumo::error(ERR_STAGE2_INVALID_PE_HEADER, L"Invalid PE header");

    ULONG size_of_shellcode = (ULONG)((SIZE_T)Shellcode_End - (SIZE_T)Shellcode);
    ULONG size_of_virtual_protect_stub = virtual_protect_stub.size();
    ULONG size_of_shellcode_data = sizeof(MANUAL_MAPPING_DATA);
    auto size_of_image = nt_headers->OptionalHeader.SizeOfImage;
    auto size_of_mapping = size_of_image + size_of_shellcode + size_of_virtual_protect_stub + size_of_shellcode_data;

    auto kernel_image = pDriver->AllocateKernelMemory(size_of_mapping);
    if (!kernel_image)
        return fumo::error(ERR_STAGE2_FAILED_TO_ALLOCATE_MEMORY, L"Failed to allocate kernel memory");

    // copy headers
    memcpy(kernel_image, pImage, nt_headers->OptionalHeader.SizeOfHeaders);

    // map sections
    auto section_header = IMAGE_FIRST_SECTION(nt_headers);
    for (auto i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
        auto section = &section_header[i];
        if (section->SizeOfRawData == 0)
            continue;
        auto section_data = (PVOID)((ULONG_PTR)pImage + section->PointerToRawData);
        memcpy((PVOID)((ULONG_PTR)kernel_image + section->VirtualAddress), section_data, section->SizeOfRawData);
    }

    // relocate the image
    auto delta = (ULONG_PTR)kernel_image - nt_headers->OptionalHeader.ImageBase;
    if (delta != 0) {
        auto base_relocation = (PIMAGE_BASE_RELOCATION)((ULONG_PTR)kernel_image + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
        while (base_relocation->VirtualAddress != 0) {
            auto relocation = (PWORD)((ULONG_PTR)base_relocation + sizeof(IMAGE_BASE_RELOCATION));
            auto number_of_relocations = (base_relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
            for (auto i = 0; i < number_of_relocations; i++) {
                if (relocation[i] >> 12 == IMAGE_REL_BASED_DIR64) {
                    auto address = (PULONG_PTR)((ULONG_PTR)kernel_image + base_relocation->VirtualAddress + (relocation[i] & 0xFFF));
                    *address += delta;
                } 
                else if (relocation[i] >> 12 == IMAGE_REL_BASED_HIGHLOW) {
                    auto address = (PULONG)((ULONG_PTR)kernel_image + base_relocation->VirtualAddress + (relocation[i] & 0xFFF));
                    *address += (ULONG)delta;
                }
                else if (relocation[i] >> 12 != IMAGE_REL_BASED_ABSOLUTE)
                    return fumo::error(ERR_STAGE2_FAILED_TO_MAP_FILE, L"Failed to map file (unsupported relocation type)");
            }
            base_relocation = (PIMAGE_BASE_RELOCATION)((ULONG_PTR)base_relocation + base_relocation->SizeOfBlock);
        }
    }

    // write the shellcode
    auto shellcode_addr = (PVOID)((ULONG_PTR)kernel_image + size_of_image);
    memcpy(shellcode_addr, Shellcode, size_of_shellcode);

    // write the virtual protect stub
    auto virtual_protect_stub_addr = (PVOID)((ULONG_PTR)shellcode_addr + size_of_shellcode);
    memcpy(virtual_protect_stub_addr, virtual_protect_stub.data(), size_of_virtual_protect_stub);

    // write the manual mapping data
    auto manual_mapping_data = GetManualMappingData(kernel_image, virtual_protect_stub_addr);
    auto manual_mapping_data_addr = (PMANUAL_MAPPING_DATA)((ULONG_PTR)virtual_protect_stub_addr + size_of_virtual_protect_stub);
    memcpy(manual_mapping_data_addr, &manual_mapping_data, size_of_shellcode_data);

    if (!pDriver->ExposeKernelMemory(pid, kernel_image, size_of_mapping))
        return fumo::error(ERR_STAGE2_FAILED_TO_EXPOSE_MEMORY, L"Failed to expose kernel memory");

    if (!pDriver->ExecuteCode(pid, shellcode_addr, manual_mapping_data_addr))
        return fumo::error(ERR_STAGE2_FAILED_TO_EXECUTE, L"Failed to execute code");

    return ERR_STAGE2_SUCCESS;
}

```

`src/stage2/fumo_loader.h`:

```h
#include <util.h>
#include <driver_interface.h>

int MapImage(fumo::DriverInterface* pDriver, ULONG pid, PVOID pImage);
```

`src/stage2/stage2.cpp`:

```cpp
#include "stage2.h"
#include "fumo_loader.h"
#include "tray_icon.h"
#include <fomo_common.h>
#include <driver_interface.h>
#include <util.h>
#include <sstream>
#include <lz4.h>

std::wstring loader_process_name = L"";
STAGE2_LOADER_DATA loader_data;
TrayIcon* tray_icon = NULL;

int main(HANDLE loader_process) {
    // wait for the loader process to exit
    DWORD wait_result = tray_icon->wait_for_object(loader_process, INFINITE, L"Waiting for loader process to exit");
    if (wait_result != WAIT_OBJECT_0)
        return fumo::error(ERR_STAGE2_FAILED_TO_WAIT_FOR_PROCESS, L"Failed to wait for loader process({}): {}", loader_process_name, wait_result);
    CloseHandle(loader_process);
    
#ifndef FUMO_DEBUG
    // delete the loader executable
    if (!DeleteFileW(loader_process_name.c_str()))
        return fumo::error(ERR_STAGE2_FAILED_TO_DELETE_LOADER, L"Failed to delete loader executable: {}", loader_process_name);
#endif
    
    auto driver = fumo::DriverInterface::Open(FUMO_HOOKED_DRIVER_NAME_USER);
    if (!driver)
        return fumo::error(ERR_STAGE2_FAILED_TO_OPEN_DRIVER, L"Failed to open driver");

    ULONG driver_version;
    if (!driver->GetVersion(&driver_version))
        return fumo::error(ERR_STAGE2_FAILED_TO_OPEN_DRIVER, L"Failed to get driver version");

    if (driver_version != FUMO_DRIVER_VERSION)
        return fumo::error(ERR_STAGE2_INVALID_DRIVER_VERSION, L"Invalid driver version (expected: {}, found: {})", FUMO_DRIVER_VERSION, driver_version);
    
    PFUMO_DATA_HEADER header = (PFUMO_DATA_HEADER)loader_data.fumo_data_base;

    // check magic
    if (header->Magic != FUMO_MAGIC)
        return fumo::error(ERR_STAGE2_INVALID_MAGIC, L"Invalid data format", loader_process_name);
    
    // check version
    if (header->Version != FUMO_DATA_VERSION)
        return fumo::error(ERR_STAGE2_INVALID_VERSION, L"Invalid data version", loader_process_name);
    
    // decrypt the settings
    PBYTE settings_data = (PBYTE)header + sizeof(FUMO_DATA_HEADER);
    uint64_t xor_key = header->XorKey;
    for (int i = 0; i < header->SettingsSize; i += sizeof(xor_key)) {
        uint64_t* ptr = (uint64_t*)&settings_data[i];
        *ptr ^= xor_key;
    }

    // parse the settings
    DWORD settings_size = *(DWORD*)settings_data;
    settings_data += sizeof(DWORD);
    std::string settings((char*)settings_data, settings_size);
    std::stringstream settings_stream(settings);
    
    std::string process_name;
    std::string wait_for_modules_string;
    std::getline(settings_stream, process_name, ';');
    std::getline(settings_stream, wait_for_modules_string, ';');
    
    std::vector<std::string> wait_for_modules = split(wait_for_modules_string, ',');

    tray_icon->send_notification(L"Ready");

    std::wstring process_name_w = convert_to_wstring(process_name);
    WAIT_FOR_PROCESS_DATA wait_for_process_data;
    wait_for_process_data.process_id = 0;
    wait_for_process_data.process_name = process_name_w.c_str();
    wait_for_process_data.cancel_event = CreateEventW(NULL, TRUE, FALSE, NULL);

    HANDLE hThread = CreateThread(NULL, 0, [](LPVOID lpParam) -> DWORD {
        WAIT_FOR_PROCESS_DATA* data = (WAIT_FOR_PROCESS_DATA*)lpParam;
        while (true) {
            data->process_id = find_process_by_name(data->process_name);
            if (data->process_id > 0)
                return 0;
            if (WaitForSingleObject(data->cancel_event, 100) == WAIT_TIMEOUT)
                continue;
            return 1;
        };
    }, &wait_for_process_data, 0, NULL);
    if (hThread == NULL)
        return fumo::error(ERR_STAGE2_FAILED_TO_CREATE_THREAD, L"Failed to create thread");

    // wait for the process to start
    std::wstring message = std::wstring(L"Waiting for ") + process_name_w;
    wait_result = tray_icon->wait_for_object(hThread, INFINITE, message.c_str());
    if (wait_result != WAIT_OBJECT_0) {
        SetEvent(wait_for_process_data.cancel_event); // cancel the wait
        WaitForSingleObject(hThread, INFINITE); // wait for the thread to exit
        CloseHandle(hThread);
        CloseHandle(wait_for_process_data.cancel_event);
        return fumo::error(ERR_STAGE2_FAILED_TO_WAIT_FOR_PROCESS, L"Failed to wait for process({}): {}", process_name_w, wait_result);
    }
    CloseHandle(hThread);
    CloseHandle(wait_for_process_data.cancel_event);

    auto process_id = wait_for_process_data.process_id;

    // wait for all modules to be loaded
    for (auto& module : wait_for_modules) {
        std::wstring module_name = convert_to_wstring(module);
        WAIT_FOR_MODULE_DATA wait_for_module_data;
        wait_for_module_data.driver_interface = driver;
        wait_for_module_data.process_id = process_id;
        wait_for_module_data.module_base = 0;
        wait_for_module_data.module_name = module_name.c_str();
        wait_for_module_data.cancel_event = CreateEventW(NULL, TRUE, FALSE, NULL);

        HANDLE hThread = CreateThread(NULL, 0, [](LPVOID lpParam) -> DWORD {
            WAIT_FOR_MODULE_DATA* data = (WAIT_FOR_MODULE_DATA*)lpParam;
            while (true) {
                if (!data->driver_interface->FindModule(data->process_id, data->module_name, &data->module_base))
                    return 2;
                if (data->module_base)
                    return 0;
                if (WaitForSingleObject(data->cancel_event, 100) == WAIT_TIMEOUT)
                    continue;
                return 1;
            };
        }, &wait_for_module_data, 0, NULL);

        if (hThread == NULL)
            return fumo::error(ERR_STAGE2_FAILED_TO_CREATE_THREAD, L"Failed to create thread");
        
        // wait for the module to be loaded
        std::wstring message = std::wstring(L"Waiting for ") + module_name;
        wait_result = tray_icon->wait_for_object(hThread, INFINITE, message.c_str());
        if (wait_result != WAIT_OBJECT_0) {
            SetEvent(wait_for_module_data.cancel_event); // cancel the wait
            WaitForSingleObject(hThread, INFINITE); // wait for the thread to exit
            CloseHandle(hThread);
            CloseHandle(wait_for_module_data.cancel_event);
            return fumo::error(ERR_STAGE2_FAILED_TO_WAIT_FOR_MODULE, L"Failed to wait for module({}): {}", module_name, wait_result);
        }
        DWORD exit_code = 3;
        GetExitCodeThread(hThread, &exit_code);
        CloseHandle(hThread);
        CloseHandle(wait_for_module_data.cancel_event);

        if (exit_code != 0)
            return fumo::error(ERR_STAGE2_FAILED_TO_WAIT_FOR_MODULE, L"Failed to wait for module error ({}): {}", module_name, exit_code);
    }

    // decrypt the data
    PBYTE data = (PBYTE)header + sizeof(FUMO_DATA_HEADER) + header->SettingsSize;
    for (int i = 0; i < header->DataSize; i += sizeof(xor_key)) {
        uint64_t* ptr = (uint64_t*)&data[i];
        *ptr ^= xor_key;
    }

    // decompress the data
    auto decompressed_data = std::make_unique<char[]>(header->DecompressedDataSize);
    auto decompressed_size = LZ4_decompress_safe((char*)data, decompressed_data.get(), header->CompressedDataSize, header->DecompressedDataSize);
    if (decompressed_size <= 0)
        return fumo::error(ERR_STAGE2_FAILED_TO_DECOMPRESS_DATA, L"Failed to decompress data");

    // let the magic happen
    auto error = MapImage(driver.get(), process_id, decompressed_data.get());
    if (error != ERROR_SUCCESS)
        return error;
    
    tray_icon->clear_notification();
    tray_icon->send_notification(L"Injected");

    return ERR_STAGE2_SUCCESS;
}

DWORD stage2(LPVOID lpThreadParameter) {
    tray_icon = new TrayIcon(L"Fumo Loader");
    auto res = main((HANDLE)lpThreadParameter);
    VirtualFree((LPVOID)loader_data.fumo_data_base, 0, MEM_RELEASE);
    delete tray_icon;
    return res;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    if (fdwReason != DLL_PROCESS_ATTACH || lpvReserved == NULL)
        return FALSE;
    
    // copy the loader data since the one we get will be freed by the stage1 loader
    memcpy(&loader_data, lpvReserved, sizeof(STAGE2_LOADER_DATA));

    // open the loader process
    HANDLE loader_process = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION | SYNCHRONIZE, FALSE, loader_data.loader_pid);
    if (loader_process == NULL) {
        fumo::error(ERR_STAGE2_FAILED_TO_OPEN_PROCESS, L"Failed to open loader process: {}", loader_data.loader_pid);
        return FALSE;
    }
    
    // get the loader process name here since it will not be available after the loader process exits
    loader_process_name = get_proces_name(loader_process);

    // main loader thread
    HANDLE hThread = CreateThread(NULL, 0, stage2, (LPVOID)loader_process, 0, NULL);
    if (hThread == NULL)
        return FALSE;
    
    CloseHandle(hThread);
    return TRUE;
}
```

`src/stage2/stage2.h`:

```h
#pragma once
#include <Windows.h>
#include <stdint.h>
#include <driver_interface.h>

#define ERR_STAGE2_SUCCESS 0
#define ERR_STAGE2_FAILED_TO_OPEN_PROCESS 50
#define ERR_STAGE2_FAILED_TO_WAIT_FOR_PROCESS 51
#define ERR_STAGE2_FAILED_TO_DELETE_LOADER 52
#define ERR_STAGE2_FAILED_TO_OPEN_DRIVER 53
#define ERR_STAGE2_INVALID_DRIVER_VERSION 54
#define ERR_STAGE2_INVALID_MAGIC 100
#define ERR_STAGE2_INVALID_VERSION 101
#define ERR_STAGE2_FAILED_TO_CREATE_THREAD 102
#define ERR_STAGE2_FAILED_TO_WAIT_FOR_MODULE 103
#define ERR_STAGE2_FAILED_TO_DECOMPRESS_DATA 104
#define ERR_STAGE2_INVALID_PE_HEADER 200
#define ERR_STAGE2_FAILED_TO_ALLOCATE_MEMORY 201
#define ERR_STAGE2_FAILED_TO_MAP_FILE 202
#define ERR_STAGE2_FAILED_TO_EXPOSE_MEMORY 203
#define ERR_STAGE2_FAILED_TO_EXECUTE 204

typedef struct _WAIT_FOR_PROCESS_DATA {
    LPCWSTR process_name;
    DWORD process_id;
    HANDLE cancel_event;
} WAIT_FOR_PROCESS_DATA, *PWAIT_FOR_PROCESS_DATA;

typedef struct _WAIT_FOR_MODULE_DATA {
    std::shared_ptr<fumo::DriverInterface> driver_interface;
    LPCWSTR module_name;
    DWORD process_id;
    PVOID module_base;
    HANDLE cancel_event;
} WAIT_FOR_MODULE_DATA, *PWAIT_FOR_MODULE_DATA;
```

`src/stage2/tray_icon.cpp`:

```cpp
#include "tray_icon.h"
#include <array>

// forward declaration for the icon data
extern std::array<BYTE, 588> icon_data;

LRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg) {
    case WM_CREATE: {
        // save the tray icon pointer in the window data
        CREATESTRUCTW* create_struct = (CREATESTRUCTW*)lParam;
        SetWindowLongPtrW(hwnd, GWLP_USERDATA, (LONG_PTR)create_struct->lpCreateParams);

        TrayIcon* tray_icon = (TrayIcon*)create_struct->lpCreateParams;
        tray_icon->create_icon(hwnd);
        break;
    }
    case WM_USER + 1: {
        TrayIcon* tray_icon = (TrayIcon*)GetWindowLongPtrW(hwnd, GWLP_USERDATA);
        if (lParam == WM_LBUTTONDOWN)
            tray_icon->cancel_wait();
        break;
    }
    case WM_USER + 2: {
        TrayIcon* tray_icon = (TrayIcon*)GetWindowLongPtrW(hwnd, GWLP_USERDATA);
        tray_icon->set_icon_message((LPCWSTR)lParam);
        break;
    }
    case WM_DESTROY: {
        TrayIcon* tray_icon = (TrayIcon*)GetWindowLongPtrW(hwnd, GWLP_USERDATA);
        tray_icon->destroy_icon();
        PostQuitMessage(0);
        break;
    }
    default:
        return DefWindowProcW(hwnd, msg, wParam, lParam);
    }
    return 0;
}

TrayIcon::TrayIcon(std::wstring name) : name(name) {
    hInstance = GetModuleHandle(NULL);
    // create the cancel event
    hCancelEvent = CreateEventW(NULL, TRUE, FALSE, NULL);

    // randomize the window class name
    srand(GetTickCount64());
    for (int i = 0; i < 16; i++)
        window_class_name += (wchar_t)(L'A' + rand() % 26);
    
    // start the tray icon message loop in a new thread
    hIconThread = CreateThread(NULL, 0, [](LPVOID lpParam) -> DWORD {
        TrayIcon* tray_icon = (TrayIcon*)lpParam;

        // Register the window class
        WNDCLASSEXW wc = {};
        wc.cbSize = sizeof(WNDCLASSEXW);
        wc.lpfnWndProc = WindowProc;
        wc.hInstance = tray_icon->hInstance;
        wc.lpszClassName = tray_icon->window_class_name.c_str();
        RegisterClassExW(&wc);

        // Create the window (it won't be visible)
        tray_icon->hwnd = CreateWindowExW(0, wc.lpszClassName, L"", 0, 0, 0, 0, 0, NULL, NULL, tray_icon->hInstance, lpParam);
        if (tray_icon->hwnd == NULL)
            return 1;

        // signal that the window has been created
        SetEvent(tray_icon->hCancelEvent);

        // Message loop
        MSG msg = {};
        while (GetMessageW(&msg, NULL, 0, 0)) {
            TranslateMessage(&msg);
            DispatchMessageW(&msg);
        }

        // unregister the window class
        UnregisterClassW(tray_icon->window_class_name.c_str(), tray_icon->hInstance);

        return (DWORD)msg.wParam;
    }, this, 0, NULL);

    // wait for the window to be created or for the thread to exit
    HANDLE handles[2] = { hCancelEvent, hIconThread };
    DWORD wait_result = WaitForMultipleObjects(2, handles, FALSE, INFINITE);
    ResetEvent(hCancelEvent);

    if (wait_result != WAIT_OBJECT_0) {
        // the thread exited, so we failed to create the window
        hwnd = NULL;
    }
}

TrayIcon::~TrayIcon() {
    destroy();
    // wait for the thread to exit
    if (hIconThread != NULL) {
        WaitForSingleObject(hIconThread, INFINITE);
        CloseHandle(hIconThread);
    }
}

void TrayIcon::destroy() {
    CloseHandle(hCancelEvent);
    if (hwnd != NULL)
        PostMessageW(hwnd, WM_CLOSE, 0, 0);
}

void TrayIcon::create_icon(HWND hwnd) {
    HICON hIcon = CreateIconFromResourceEx(icon_data.data(), icon_data.size(), TRUE, 0x00030000, 0, 0, LR_DEFAULTCOLOR);
    if (hIcon == NULL)
        return;

    NOTIFYICONDATAW nid = {};
    nid.cbSize = sizeof(NOTIFYICONDATAW);
    nid.hWnd = hwnd;
    nid.uID = uID;
    nid.uFlags = NIF_ICON | NIF_TIP | NIF_MESSAGE;
    nid.uCallbackMessage = WM_USER + 1;
    nid.hIcon = hIcon;
    wcscpy_s(nid.szTip, name.c_str());
    Shell_NotifyIconW(NIM_ADD, &nid);
}

void TrayIcon::destroy_icon() {
    NOTIFYICONDATAW nid = {};
    nid.cbSize = sizeof(NOTIFYICONDATAW);
    nid.hWnd = hwnd;
    nid.uID = uID;
    Shell_NotifyIconW(NIM_DELETE, &nid);
}

void TrayIcon::set_icon_message(LPCWSTR lpMessage) {
    std::wstring tooltip = name;
    if (lpMessage != NULL)
        tooltip += L"\n" + std::wstring(lpMessage);

    NOTIFYICONDATAW nid = {};
    nid.cbSize = sizeof(NOTIFYICONDATAW);
    nid.hWnd = hwnd;
    nid.uID = uID;
    nid.uFlags = NIF_TIP;
    wcscpy_s(nid.szTip, tooltip.c_str());
    Shell_NotifyIconW(NIM_MODIFY, &nid);
}

void TrayIcon::clear_notification() {
    NOTIFYICONDATAW nid = {};
    nid.cbSize = sizeof(NOTIFYICONDATAW);
    nid.hWnd = hwnd;
    nid.uID = uID;
    nid.uFlags = NIF_INFO;
    Shell_NotifyIconW(NIM_MODIFY, &nid);
}

void TrayIcon::send_notification(LPCWSTR lpMessage) {
    NOTIFYICONDATAW nid = {};
    nid.cbSize = sizeof(NOTIFYICONDATAW);
    nid.hWnd = hwnd;
    nid.uID = uID;
    nid.uFlags = NIF_INFO;
    wcscpy_s(nid.szInfo, lpMessage);
    wcscpy_s(nid.szInfoTitle, name.c_str());
    Shell_NotifyIconW(NIM_MODIFY, &nid);
}

void TrayIcon::cancel_wait() {
    // signal the cancel event
    SetEvent(hCancelEvent);
}

// this function waits for an object to be signaled or for the user to click on the tray icon that will cancel the wait using WaitForMultipleObjects
DWORD TrayIcon::wait_for_object(HANDLE hHandle, DWORD dwMilliseconds, LPCWSTR lpMessage) {
    // reset the cancel event
    ResetEvent(hCancelEvent);

    // set tray icon tooltip
    std::wstring message = std::wstring(lpMessage) + L"\nClick to cancel";
    PostMessageW(hwnd, WM_USER + 2, 0, (LPARAM)message.c_str());

    // wait for the object to be signaled or for the cancel event to be signaled
    HANDLE handles[2] = { hHandle, hCancelEvent };
    DWORD wait_result = WaitForMultipleObjects(2, handles, FALSE, dwMilliseconds);

    // reset the tray icon tooltip
    PostMessageW(hwnd, WM_USER + 2, 0, (LPARAM)NULL);

    return wait_result;
}

// credit: https://www.pixiv.net/en/artworks/35678304
std::array<BYTE, 588> icon_data = {
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
    0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10,
    0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0xF3, 0xFF, 0x61, 0x00, 0x00, 0x02,
    0x13, 0x49, 0x44, 0x41, 0x54, 0x38, 0x8D, 0x75, 0x93, 0x4F, 0x48, 0x93,
    0x61, 0x1C, 0xC7, 0x3F, 0x6F, 0x86, 0x90, 0x50, 0xD0, 0x14, 0x1B, 0xEF,
    0xD8, 0x96, 0x10, 0x8B, 0xE1, 0xE5, 0x15, 0xB6, 0xAC, 0x76, 0x58, 0x12,
    0x0C, 0x07, 0x03, 0xC3, 0x18, 0xCE, 0x53, 0x78, 0xC9, 0x6E, 0x21, 0x78,
    0x90, 0xBA, 0xBC, 0x05, 0x75, 0x69, 0x20, 0x81, 0x87, 0xD5, 0xC1, 0xB0,
    0x93, 0x30, 0xC3, 0xA2, 0xE1, 0x20, 0x26, 0xEC, 0x64, 0x5B, 0x1B, 0xEC,
    0x39, 0x28, 0x4E, 0x3B, 0xC4, 0x16, 0x0E, 0x32, 0x6C, 0x0E, 0xC1, 0xC3,
    0x7B, 0x79, 0x3A, 0xD8, 0x5E, 0x7D, 0x5F, 0xF3, 0x0B, 0x0F, 0x3C, 0x7F,
    0x7E, 0xDF, 0xDF, 0xF3, 0x7C, 0xBF, 0xBF, 0xDF, 0xA3, 0x68, 0xC0, 0x9B,
    0xE2, 0x4F, 0xE9, 0x78, 0xF9, 0x98, 0x93, 0xC8, 0x94, 0xCB, 0x2C, 0xEC,
    0xD4, 0x95, 0x07, 0x2E, 0x8F, 0x8C, 0x05, 0x02, 0x96, 0xB3, 0x3F, 0x4F,
    0x5E, 0x33, 0x39, 0xE8, 0x56, 0x00, 0x14, 0x0D, 0xF8, 0x66, 0x18, 0xB2,
    0x16, 0x4F, 0x90, 0x29, 0x97, 0x01, 0xB8, 0x1C, 0xB9, 0x85, 0x1D, 0xCD,
    0x2F, 0x5F, 0x01, 0x88, 0x05, 0x02, 0x78, 0xD3, 0x8B, 0xDC, 0xE8, 0xEC,
    0x54, 0x00, 0x3A, 0x9C, 0xC0, 0xEF, 0x0E, 0xB7, 0x5E, 0xCF, 0x2C, 0x52,
    0xEB, 0xBD, 0x40, 0x5F, 0x28, 0x88, 0x10, 0x02, 0xA7, 0xD3, 0x69, 0x92,
    0x85, 0x10, 0xF4, 0x85, 0x82, 0x6C, 0x1D, 0xEC, 0xB1, 0xFB, 0xBD, 0x4E,
    0xEE, 0xF0, 0x12, 0xD5, 0xFC, 0xE7, 0x67, 0xE6, 0x0B, 0xF8, 0x27, 0x63,
    0x33, 0x35, 0x8D, 0x10, 0x02, 0x4D, 0xD3, 0xB0, 0xA3, 0xBD, 0xEF, 0x7F,
    0x94, 0x34, 0x9F, 0x0F, 0x70, 0xAE, 0x3D, 0x99, 0x1C, 0x74, 0x2B, 0xED,
    0xA0, 0xB0, 0xB7, 0x89, 0x10, 0xC2, 0x24, 0x86, 0xBD, 0x4D, 0x34, 0x4D,
    0x43, 0x08, 0x61, 0x21, 0x5B, 0x12, 0x00, 0x72, 0x3C, 0x95, 0x23, 0xEC,
    0x6D, 0x32, 0xB6, 0xB2, 0xCF, 0xCC, 0xD4, 0x10, 0x42, 0x08, 0x66, 0xA6,
    0x86, 0x18, 0x5B, 0xD9, 0x27, 0xEC, 0x6D, 0x32, 0x9E, 0xCA, 0x01, 0xC8,
    0xB3, 0x12, 0xB0, 0x36, 0x1A, 0xC2, 0x31, 0x9C, 0x00, 0xA0, 0x7B, 0x64,
    0x82, 0x57, 0xF9, 0xF7, 0x74, 0x8F, 0x4C, 0x00, 0xE0, 0x18, 0x4E, 0xB0,
    0x36, 0x1A, 0x3A, 0x25, 0xCD, 0x92, 0x20, 0x16, 0x08, 0xD0, 0xE5, 0xEF,
    0x3F, 0x15, 0x04, 0xD0, 0xE5, 0xEF, 0xC7, 0x5E, 0x4E, 0x38, 0x61, 0x22,
    0x1C, 0x97, 0xF3, 0xE2, 0xFD, 0x5E, 0xF3, 0x66, 0x80, 0xBD, 0x4F, 0xEF,
    0x38, 0xF8, 0xB0, 0x6B, 0x29, 0x9F, 0x09, 0xCD, 0x3A, 0x64, 0xAB, 0x30,
    0x2F, 0x67, 0x5D, 0x1E, 0x69, 0x18, 0x86, 0xFC, 0xA1, 0x47, 0xA4, 0x61,
    0x18, 0x72, 0xD6, 0xE5, 0x91, 0xAD, 0xC2, 0xBC, 0xD4, 0x40, 0xDA, 0xE2,
    0x8F, 0x25, 0x2C, 0xEB, 0x11, 0x59, 0x6A, 0x15, 0x59, 0x4D, 0xEA, 0x00,
    0xD4, 0xE2, 0x09, 0xAE, 0x3E, 0xF4, 0x50, 0x8B, 0x1F, 0x79, 0xB2, 0x9A,
    0xD4, 0x29, 0xB5, 0x8A, 0x2C, 0xEB, 0x11, 0x8B, 0x89, 0xE7, 0xDB, 0x93,
    0xCA, 0x7A, 0x15, 0xC7, 0xE6, 0x06, 0xCF, 0x97, 0xEA, 0x00, 0xF8, 0x54,
    0x95, 0x6B, 0x38, 0xD8, 0x6E, 0x34, 0x58, 0xD8, 0xA9, 0xC3, 0x12, 0xDC,
    0x9D, 0xDE, 0xA0, 0xB2, 0x5E, 0x3D, 0xD3, 0x03, 0xF9, 0x22, 0x78, 0x93,
    0xED, 0x46, 0xE3, 0xBF, 0x66, 0x65, 0xCA, 0x65, 0x7C, 0xAA, 0xCA, 0xD3,
    0x52, 0x01, 0xE0, 0x74, 0x23, 0x01, 0x4A, 0xCF, 0x5C, 0x1A, 0x9F, 0xAA,
    0x9A, 0x7F, 0xC2, 0x4E, 0xEE, 0x99, 0x4B, 0x5B, 0xC8, 0x16, 0x09, 0x70,
    0xD4, 0x8D, 0xF7, 0xF4, 0xB7, 0x32, 0x1A, 0x8D, 0xE2, 0x1D, 0xB8, 0x62,
    0xEE, 0xDF, 0xAE, 0xFC, 0x22, 0x9B, 0xCD, 0xF2, 0xD1, 0xD6, 0x85, 0x76,
    0x09, 0xA6, 0x94, 0x3B, 0x03, 0xD7, 0xC9, 0x57, 0xB6, 0xDA, 0xB7, 0xD9,
    0xD7, 0x16, 0xFC, 0x05, 0xF8, 0xB0, 0xD2, 0x53, 0xA7, 0x42, 0x1B, 0x26,
    0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
};

```

`src/stage2/tray_icon.h`:

```h
#pragma once
#include <Windows.h>
#include <string>

class TrayIcon {
private:
    std::wstring name = L"";
    HINSTANCE hInstance = NULL;
    std::wstring window_class_name = L"";
    HWND hwnd = NULL;
    UINT uID = 1;
    HANDLE hCancelEvent = NULL;
    HANDLE hIconThread = NULL;
public:
    TrayIcon(std::wstring name);
    ~TrayIcon();
    void create_icon(HWND hwnd);
    void destroy_icon();
    void set_icon_message(LPCWSTR lpMessage);
    void clear_notification();
    void send_notification(LPCWSTR lpMessage);
    void cancel_wait();
    void destroy();
    
    DWORD wait_for_object(HANDLE hHandle, DWORD dwMilliseconds, LPCWSTR lpMessage);
};

```