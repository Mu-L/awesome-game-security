Project Path: arc_Unity-Technologies_com.unity.demoteam.hair_22_sti4o

Source Tree:

```txt
arc_Unity-Technologies_com.unity.demoteam.hair_22_sti4o
├── ApiUpdater~
│   └── ValidationWhiteList.txt
├── CHANGELOG.md
├── CHANGELOG.md.meta
├── Documentation~
│   ├── Images
│   │   └── header_crop.png
│   └── index.md
├── Editor
│   ├── HairAssetBuilder.cs
│   ├── HairAssetBuilder.cs.meta
│   ├── HairAssetEditor.cs
│   ├── HairAssetEditor.cs.meta
│   ├── HairBoundaryEditor.cs
│   ├── HairBoundaryEditor.cs.meta
│   ├── HairInstanceEditor.cs
│   ├── HairInstanceEditor.cs.meta
│   ├── HairInstanceEditorRefresh.cs
│   ├── HairInstanceEditorRefresh.cs.meta
│   ├── HairShaderVariantStripper.cs
│   ├── HairShaderVariantStripper.cs.meta
│   ├── HairWindEditor.cs
│   ├── HairWindEditor.cs.meta
│   ├── PropertyDrawers
│   │   ├── ComparePropertyUtility.cs
│   │   ├── ComparePropertyUtility.cs.meta
│   │   ├── EditableIfDrawer.cs
│   │   ├── EditableIfDrawer.cs.meta
│   │   ├── LineHeaderDrawer.cs
│   │   ├── LineHeaderDrawer.cs.meta
│   │   ├── LinearRampDrawer.cs
│   │   ├── LinearRampDrawer.cs.meta
│   │   ├── LinearRampWidgetDrawer.cs
│   │   ├── LinearRampWidgetDrawer.cs.meta
│   │   ├── RenderingLayerMaskDrawer.cs
│   │   ├── RenderingLayerMaskDrawer.cs.meta
│   │   ├── ToggleGroupDrawer.cs
│   │   ├── ToggleGroupDrawer.cs.meta
│   │   ├── ToggleGroupItemDrawer.cs
│   │   ├── ToggleGroupItemDrawer.cs.meta
│   │   ├── VisibleIfDrawer.cs
│   │   └── VisibleIfDrawer.cs.meta
│   ├── PropertyDrawers.meta
│   ├── Unity.DemoTeam.Hair.Editor.asmdef
│   ├── Unity.DemoTeam.Hair.Editor.asmdef.meta
│   ├── Utility
│   │   ├── HairGUI.ColorScope.cs
│   │   ├── HairGUI.ColorScope.cs.meta
│   │   ├── HairGUI.LineHeader.cs
│   │   ├── HairGUI.LineHeader.cs.meta
│   │   ├── HairGUI.LinearRamp.cs
│   │   ├── HairGUI.LinearRamp.cs.meta
│   │   ├── HairGUI.LinearRampWidget.cs
│   │   ├── HairGUI.LinearRampWidget.cs.meta
│   │   ├── HairGUI.RenderingLayerMask.cs
│   │   ├── HairGUI.RenderingLayerMask.cs.meta
│   │   ├── HairGUILayout.GovernedByPrefabScope.cs
│   │   ├── HairGUILayout.GovernedByPrefabScope.cs.meta
│   │   ├── HairGUILayout.PropertyRectScope.cs
│   │   ├── HairGUILayout.PropertyRectScope.cs.meta
│   │   ├── HairGUILayout.ToggleGroup.cs
│   │   ├── HairGUILayout.ToggleGroup.cs.meta
│   │   ├── HairGUILayout.cs
│   │   ├── HairGUILayout.cs.meta
│   │   ├── HairGUIStyles.cs
│   │   └── HairGUIStyles.cs.meta
│   └── Utility.meta
├── Editor.meta
├── Experiments
│   ├── AffineInterpolate.cs
│   ├── AffineInterpolate.cs.meta
│   ├── LocalShape.cs
│   ├── LocalShape.cs.meta
│   ├── ProjectedCircleDensity.cs
│   ├── ProjectedCircleDensity.cs.meta
│   ├── Unity.DemoTeam.Hair.Experiments.asmdef
│   └── Unity.DemoTeam.Hair.Experiments.asmdef.meta
├── Experiments.meta
├── LICENSE.md
├── LICENSE.md.meta
├── Presentations~
│   └── SIGGRAPH 2022 Strand-based Hair System.pdf
├── README.md
├── README.md.meta
├── Runtime
│   ├── HairAsset.Deprecated.cs
│   ├── HairAsset.Deprecated.cs.meta
│   ├── HairAsset.Migration.0.cs
│   ├── HairAsset.Migration.0.cs.meta
│   ├── HairAsset.Migration.1.cs
│   ├── HairAsset.Migration.1.cs.meta
│   ├── HairAsset.Migration.cs
│   ├── HairAsset.Migration.cs.meta
│   ├── HairAsset.Settings.Deprecated.cs
│   ├── HairAsset.Settings.Deprecated.cs.meta
│   ├── HairAsset.Settings.cs
│   ├── HairAsset.Settings.cs.meta
│   ├── HairAsset.cs
│   ├── HairAsset.cs.meta
│   ├── HairAssetCustomData.cs
│   ├── HairAssetCustomData.cs.meta
│   ├── HairAssetCustomPlacement.cs
│   ├── HairAssetCustomPlacement.cs.meta
│   ├── HairBoundary.Gizmos.cs
│   ├── HairBoundary.Gizmos.cs.meta
│   ├── HairBoundary.Settings.cs
│   ├── HairBoundary.Settings.cs.meta
│   ├── HairBoundary.cs
│   ├── HairBoundary.cs.meta
│   ├── HairBoundaryUtility.cs
│   ├── HairBoundaryUtility.cs.meta
│   ├── HairInstance.Gizmos.cs
│   ├── HairInstance.Gizmos.cs.meta
│   ├── HairInstance.Migration.0.cs
│   ├── HairInstance.Migration.0.cs.meta
│   ├── HairInstance.Migration.1.cs
│   ├── HairInstance.Migration.1.cs.meta
│   ├── HairInstance.Migration.cs
│   ├── HairInstance.Migration.cs.meta
│   ├── HairInstance.Settings.Deprecated.cs
│   ├── HairInstance.Settings.Deprecated.cs.meta
│   ├── HairInstance.Settings.cs
│   ├── HairInstance.Settings.cs.meta
│   ├── HairInstance.cs
│   ├── HairInstance.cs.meta
│   ├── HairInstanceBuilder.cs
│   ├── HairInstanceBuilder.cs.meta
│   ├── HairMaterialCommonBuiltin.hlsl
│   ├── HairMaterialCommonBuiltin.hlsl.meta
│   ├── HairMaterialCommonUnlit.hlsl
│   ├── HairMaterialCommonUnlit.hlsl.meta
│   ├── HairMaterialDefaultLitBuiltin.shader
│   ├── HairMaterialDefaultLitBuiltin.shader.meta
│   ├── HairMaterialDefaultLitSRP.shadergraph
│   ├── HairMaterialDefaultLitSRP.shadergraph.meta
│   ├── HairMaterialDefaultUnlit.shader
│   ├── HairMaterialDefaultUnlit.shader.meta
│   ├── HairMaterialReplaceAsync.shader
│   ├── HairMaterialReplaceAsync.shader.meta
│   ├── HairMaterialReplaceError.shader
│   ├── HairMaterialReplaceError.shader.meta
│   ├── HairMaterialUtility.cs
│   ├── HairMaterialUtility.cs.meta
│   ├── HairSim.LOD.cs
│   ├── HairSim.LOD.cs.hlsl
│   ├── HairSim.LOD.cs.hlsl.meta
│   ├── HairSim.LOD.cs.meta
│   ├── HairSim.Settings.cs
│   ├── HairSim.Settings.cs.meta
│   ├── HairSim.cs
│   ├── HairSim.cs.meta
│   ├── HairSimComputeConfig.hlsl
│   ├── HairSimComputeConfig.hlsl.meta
│   ├── HairSimComputeLOD.hlsl
│   ├── HairSimComputeLOD.hlsl.meta
│   ├── HairSimComputeRoots.hlsl
│   ├── HairSimComputeRoots.hlsl.meta
│   ├── HairSimComputeRoots.shader
│   ├── HairSimComputeRoots.shader.meta
│   ├── HairSimComputeSolver.compute
│   ├── HairSimComputeSolver.compute.meta
│   ├── HairSimComputeSolverBoundaries.hlsl
│   ├── HairSimComputeSolverBoundaries.hlsl.meta
│   ├── HairSimComputeSolverConstraints.hlsl
│   ├── HairSimComputeSolverConstraints.hlsl.meta
│   ├── HairSimComputeSolverQuaternion.hlsl
│   ├── HairSimComputeSolverQuaternion.hlsl.meta
│   ├── HairSimComputeVolume.compute
│   ├── HairSimComputeVolume.compute.meta
│   ├── HairSimComputeVolumeProbe.hlsl
│   ├── HairSimComputeVolumeProbe.hlsl.meta
│   ├── HairSimComputeVolumeRaster.shader
│   ├── HairSimComputeVolumeRaster.shader.meta
│   ├── HairSimComputeVolumeTransfer.hlsl
│   ├── HairSimComputeVolumeTransfer.hlsl.meta
│   ├── HairSimComputeVolumeUtility.hlsl
│   ├── HairSimComputeVolumeUtility.hlsl.meta
│   ├── HairSimConf.cs
│   ├── HairSimConf.cs.hlsl
│   ├── HairSimConf.cs.hlsl.meta
│   ├── HairSimConf.cs.meta
│   ├── HairSimData.cs
│   ├── HairSimData.cs.hlsl
│   ├── HairSimData.cs.hlsl.meta
│   ├── HairSimData.cs.meta
│   ├── HairSimData.hlsl
│   ├── HairSimData.hlsl.meta
│   ├── HairSimDebugDraw.cs
│   ├── HairSimDebugDraw.cs.meta
│   ├── HairSimDebugDraw.shader
│   ├── HairSimDebugDraw.shader.meta
│   ├── HairSimDebugDrawColors.hlsl
│   ├── HairSimDebugDrawColors.hlsl.meta
│   ├── HairSimUtility.cs
│   ├── HairSimUtility.cs.meta
│   ├── HairTopologyCache.cs
│   ├── HairTopologyCache.cs.meta
│   ├── HairTopologyPrefetch.cs
│   ├── HairTopologyPrefetch.cs.meta
│   ├── HairVertex.hlsl
│   ├── HairVertex.hlsl.meta
│   ├── HairVertex.shadersubgraph
│   ├── HairVertex.shadersubgraph.meta
│   ├── HairVolume.hlsl
│   ├── HairVolume.hlsl.meta
│   ├── HairVolume.shadersubgraph
│   ├── HairVolume.shadersubgraph.meta
│   ├── HairVolumeUVW.hlsl
│   ├── HairVolumeUVW.hlsl.meta
│   ├── HairVolumeUVW.shadersubgraph
│   ├── HairVolumeUVW.shadersubgraph.meta
│   ├── HairWind.Gizmos.cs
│   ├── HairWind.Gizmos.cs.meta
│   ├── HairWind.Settings.cs
│   ├── HairWind.Settings.cs.meta
│   ├── HairWind.cs
│   ├── HairWind.cs.meta
│   ├── HairWindUtility.cs
│   ├── HairWindUtility.cs.meta
│   ├── Icons
│   │   ├── HairAsset.png
│   │   ├── HairAsset.png.meta
│   │   ├── HairBoundary.png
│   │   ├── HairBoundary.png.meta
│   │   ├── HairInstance.png
│   │   ├── HairInstance.png.meta
│   │   ├── HairWind.png
│   │   └── HairWind.png.meta
│   ├── Icons.meta
│   ├── PropertyAttributes
│   │   ├── ComparePropertyBase.cs
│   │   ├── ComparePropertyBase.cs.meta
│   │   ├── EditableIfAttribute.cs
│   │   ├── EditableIfAttribute.cs.meta
│   │   ├── LineHeaderAttribute.cs
│   │   ├── LineHeaderAttribute.cs.meta
│   │   ├── LinearRampAttribute.cs
│   │   ├── LinearRampAttribute.cs.meta
│   │   ├── LinearRampWidgetAttribute.cs
│   │   ├── LinearRampWidgetAttribute.cs.meta
│   │   ├── RenderingLayerMaskAttribute.cs
│   │   ├── RenderingLayerMaskAttribute.cs.meta
│   │   ├── ToggleGroupAttribute.cs
│   │   ├── ToggleGroupAttribute.cs.meta
│   │   ├── ToggleGroupItemAttribute.cs
│   │   ├── ToggleGroupItemAttribute.cs.meta
│   │   ├── VisibleIfAttribute.cs
│   │   └── VisibleIfAttribute.cs.meta
│   ├── PropertyAttributes.meta
│   ├── Resources
│   │   ├── HairSimResources.asset
│   │   ├── HairSimResources.asset.meta
│   │   ├── HairSimResources.cs
│   │   └── HairSimResources.cs.meta
│   ├── Resources.meta
│   ├── Unity.DemoTeam.Hair.Runtime.asmdef
│   ├── Unity.DemoTeam.Hair.Runtime.asmdef.meta
│   ├── Utility
│   │   ├── AffineUtility.cs
│   │   ├── AffineUtility.cs.meta
│   │   ├── DerivedCache.cs
│   │   ├── DerivedCache.cs.meta
│   │   ├── Extensions.cs
│   │   ├── Extensions.cs.meta
│   │   ├── LongOperation.cs
│   │   ├── LongOperation.cs.meta
│   │   ├── PrefabContentsUtility.cs
│   │   ├── PrefabContentsUtility.cs.meta
│   │   ├── PrimarySkinningBone.cs
│   │   ├── PrimarySkinningBone.cs.meta
│   │   ├── SpatialComponentFilter.cs
│   │   ├── SpatialComponentFilter.cs.meta
│   │   ├── Texture2DLabels.cs
│   │   ├── Texture2DLabels.cs.meta
│   │   ├── TriMeshBuffers.cs
│   │   ├── TriMeshBuffers.cs.meta
│   │   ├── TriMeshQueries.cs
│   │   ├── TriMeshQueries.cs.meta
│   │   ├── TriMeshSampler.cs
│   │   ├── TriMeshSampler.cs.meta
│   │   ├── UnsafeAdjacency.cs
│   │   ├── UnsafeAdjacency.cs.meta
│   │   ├── UnsafeBFS.cs
│   │   ├── UnsafeBFS.cs.meta
│   │   ├── UnsafeBVH.cs
│   │   ├── UnsafeBVH.cs.meta
│   │   ├── UnsafeClusterSet.cs
│   │   ├── UnsafeClusterSet.cs.meta
│   │   ├── UnsafeDFS.cs
│   │   ├── UnsafeDFS.cs.meta
│   │   ├── VersionedData.cs
│   │   └── VersionedData.cs.meta
│   └── Utility.meta
├── Runtime.meta
├── Samples~
│   ├── HairSample
│   │   ├── HairSample.asmdef
│   │   ├── HairSample.asmdef.meta
│   │   ├── Materials
│   │   │   ├── Builtin_Ground.mat
│   │   │   ├── Builtin_Ground.mat.meta
│   │   │   ├── Builtin_Primitive.mat
│   │   │   ├── Builtin_Primitive.mat.meta
│   │   │   ├── Builtin_Skybox.mat
│   │   │   ├── Builtin_Skybox.mat.meta
│   │   │   ├── SRP.shadergraph
│   │   │   ├── SRP.shadergraph.meta
│   │   │   ├── SRP_Ground.mat
│   │   │   ├── SRP_Ground.mat.meta
│   │   │   ├── SRP_Primitive.mat
│   │   │   └── SRP_Primitive.mat.meta
│   │   ├── Materials.meta
│   │   ├── Prefabs
│   │   │   ├── Boundaries.prefab
│   │   │   ├── Boundaries.prefab.meta
│   │   │   ├── Boundaries_SRP.prefab
│   │   │   ├── Boundaries_SRP.prefab.meta
│   │   │   ├── Camera.prefab
│   │   │   ├── Camera.prefab.meta
│   │   │   ├── Camera_HDRP.prefab
│   │   │   ├── Camera_HDRP.prefab.meta
│   │   │   ├── Camera_URP.prefab
│   │   │   ├── Camera_URP.prefab.meta
│   │   │   ├── Hair.prefab
│   │   │   ├── Hair.prefab.meta
│   │   │   ├── Lights.prefab
│   │   │   ├── Lights.prefab.meta
│   │   │   ├── Lights_HDRP.prefab
│   │   │   ├── Lights_HDRP.prefab.meta
│   │   │   ├── Lights_URP.prefab
│   │   │   └── Lights_URP.prefab.meta
│   │   ├── Prefabs.meta
│   │   ├── Profiles
│   │   │   ├── VolumeProfile_HDRP.asset
│   │   │   ├── VolumeProfile_HDRP.asset.meta
│   │   │   ├── VolumeProfile_URP.asset
│   │   │   └── VolumeProfile_URP.asset.meta
│   │   ├── Profiles.meta
│   │   ├── Providers
│   │   │   ├── SineWave1D.asset
│   │   │   ├── SineWave1D.asset.meta
│   │   │   ├── SineWave1D.cs
│   │   │   └── SineWave1D.cs.meta
│   │   ├── Providers.meta
│   │   ├── Scenes
│   │   │   ├── HairSample_Builtin.unity
│   │   │   ├── HairSample_Builtin.unity.meta
│   │   │   ├── HairSample_HDRP.unity
│   │   │   ├── HairSample_HDRP.unity.meta
│   │   │   ├── HairSample_URP.unity
│   │   │   └── HairSample_URP.unity.meta
│   │   ├── Scenes.meta
│   │   ├── Scripts
│   │   │   ├── Orbit.cs
│   │   │   ├── Orbit.cs.meta
│   │   │   ├── SetSky.cs
│   │   │   ├── SetSky.cs.meta
│   │   │   ├── Slide.cs
│   │   │   └── Slide.cs.meta
│   │   ├── Scripts.meta
│   │   ├── Styles
│   │   │   ├── CurlyCurtain.asset
│   │   │   └── CurlyCurtain.asset.meta
│   │   └── Styles.meta
│   └── HairSample.meta
├── Tests
│   ├── Editor
│   │   ├── HairTestsEditor.cs
│   │   ├── HairTestsEditor.cs.meta
│   │   ├── Unity.DemoTeam.Hair.Tests.Editor.asmdef
│   │   └── Unity.DemoTeam.Hair.Tests.Editor.asmdef.meta
│   ├── Editor.meta
│   ├── Runtime
│   │   ├── HairTests.cs
│   │   ├── HairTests.cs.meta
│   │   ├── Unity.DemoTeam.Hair.Tests.Runtime.asmdef
│   │   └── Unity.DemoTeam.Hair.Tests.Runtime.asmdef.meta
│   └── Runtime.meta
├── Tests.meta
├── package.json
└── package.json.meta

```

`ApiUpdater~/ValidationWhiteList.txt`:

```txt
ConfigurationValidation:
AutoGenerated:
T|[*] Unity.DemoTeam.Hair.HairAssetProvider|clean API updater usage fails on nested type and workaround is incompatible with configuration validation
T|[*] Unity.DemoTeam.Hair.HairAssetProvider/GeneratedRoots|...
T|[*] Unity.DemoTeam.Hair.HairAssetProvider/GeneratedRoots/StrandParameters|..

```

`CHANGELOG.md`:

```md
# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).


## [0.19.0-preview.1] - 2025-02-10

### Added

- Added tests and related scaffolding required for CI and submission to package registry.

### Fixed

- Fixed CI validation errors.


## [0.18.3-exp.1] - 2024-11-13

### Changed

- Reduced number of shader variants produced by HairVertex. (Reduces shader compilation time for all hair materials.)

### Fixed

- Added workaround for crash in builds (disable use of `markNoLongerReadable:true` in non-editor calls to `Mesh.UploadMeshData`).
- Fixed a keyword issue causing indirect instanced rendering to not work correctly on versions prior to 2021.1.
- Fixed warnings when building shaders for XR targets.
- Fixed a number of issues affecting certain build targets (avoid use of logical vector ops in volume trace, guard against volume transfer functions being declared for non-writable targets, guard against XR module missing when querying state of single pass instanced stereo).
- Fixed a division by zero that would sometimes cause angular damping to consume small strands.


## [0.18.2-exp.1] - 2024-10-21

### Fixed

- Removed potentially missing script from sample prefab.


## [0.18.1-exp.1] - 2024-09-27

### Fixed

- Fixed missing default initialization of new flags.


## [0.18.0-exp.1] - 2024-09-27

### Added

- Implemented dynamic LOD-based upper bound on render geometry. (Reduces the amount of work submitted to the interpolation and staging stages post-physics, and also allows for early out in the vertex stage for reduced overhead.)
- Added support for indirect instanced rendering via two new options in rendering settings: 'Allow indirect' and 'Allow instanced'. These are both enabled by default. (When effective, they reduce the amount of work submitted to the vertex stage, and reduce the memory footprint of topology meshes via instancing, respectively.)
- Added support for single-pass instanced stereo (automatically enabled when needed.)

### Changed

- Tweaked the LOD scale sliders in settings for physics and rendering to range between 0 and 4 (previously the upper bound was 2). In general, LOD transitions occur when coverage drops below 1/(lod scale).

### Fixed

- Fixed an issue with the underlying type of buffer used for indirect dispatch.
- Fixed an issue with incorrect/missing substitute shadow bounds on versions prior to 2021.1.
- Fixed an issue with the preview in the HairAsset inspector not showing any strands (due to incorrect bounds.)
- Fixed a few NaN issues that would sometimes consume very short strands at far away distances.
- Fixed a few issues with strands not getting correctly added or promoted to interpolation stage or simulation stage when transitioning directly from non-visible state.


## [0.17.0-exp.1] - 2024-08-19

### Added

- Added new options in HairInstance to allow runtime adjustments to tapering per group instance. (Same pattern as runtime adjustments to strand length, diameter.)
- Added new fields in HairAsset to declare expected unit scale of ingested alembic curve positions and diameters. (Only relevant for hair assets set up to ingest curves from an alembic container.)

### Changed

- Bumped internal data version to support a few internal data layout changes. Existing data will be migrated.

### Fixed

- Fixed an issue with mesh based root UV resolve not always producing correct texture coordinates. (Caused by incorrect measure in closest triangle BVH lookup - thanks @Kleptine for investigating this in #98.)
- Fixed an issue with inconsistent shading when using strips for rendering in combination with builtin RP.
- Fixed a regression in HairVolumeUVW.
- Fixed a constant buffer padding issue.


## [0.16.0-exp.1] - 2024-07-04

### Added

- Added "step-then-pause" button to simulation controls section in HairInstance inspector. (Next to play, pause, etc.)
- Added support for overriding shadow renderer and shadow layers via rendering settings.

### Fixed

- Fixed an issue with minimum (simulation) step count not being respected.


## [0.15.0-exp.1] - 2024-06-17

### Added

- Added support for non-uniform scaling of discrete SDF boundaries specified via texture. (Also attempts to handle scaling of sampled distances.)
- Added support for volumetric drag as part of the volumetric wind feature. Volumetric drag is automatically enabled when wind propagation is enabled.

### Fixed

- Fixed a regression that prevented passing discrete SDF via RenderTexture.
- Fixed an issue with volumetric wind impulse relying on potentially undefined solver constant.

### Changed

- Removed redundant volume data updates for improved performance: Primary volume data (density, velocity, pressure, wind) is now updated only after stepping simulation, while auxiliary volume data (scattering) is updated only once per frame. (Previously, all volume data was updated both after stepping simulation, and at minimum once per frame.)


## [0.14.2-exp.1] - 2024-06-06

### Fixed

- Added missing guard to prevent crash in HairVertex for curious cases where constant buffer was not bound (the guard existed earlier, and its disappearance was a regression in 0.14.0-exp.1.)

### Changed

- Delayed unloading of meshes in topology cache a bit.


## [0.14.1-exp.1] - 2024-06-03

### Fixed

- Fixed regression in fragment stage after limiting variants to vertex stage.


## [0.14.0-exp.1] - 2024-06-03

### Added

- Added runtime topology cache to enable automatic creation and sharing of topology data between multiple hair instances (reduces runtime memory footprint.)
- Added initial support for subframe interpolation of per-frame collision boundaries.
- Added initial support for subframe interpolation of per-frame wind emitters.
- Added icons for assets and components.

### Fixed

- Fixed a determinism issue caused by wind emitter clock not matching simulation time.
- Fixed a few compatibility issues with Metal.

### Changed

- Changed default diameter scale when ingesting alembic curve widths from 1.0 to 0.01 (since alembic curve widths are often specified in cm.)
- Changed root mesh construction to output 16 bit indices when possible.

### Removed

- Removed asset level topology data entirely in favour of shared runtime data, reducing per-particle storage requirements considerably (per-particle reduction of 6.5x - 12.1x, from 79-146 (min-max) to 12 bytes per particle), effectively resulting in smaller hair assets.


## [0.13.0-exp.1] - 2024-04-16

### Added

- Added support for seamless, automatic render LOD with coverage-preserving decimation based on hierarchical clustering.
- Added support for GPU based LOD selection, including GPU root bounds, GPU frustum culling.
- Added support for data/settings migration from older versions of the package.
- Added asset-level support for per-strand diameter and tapering.
- Added asset-level support for per-vertex attributes (uv, width) for shader graph.
- Added more optional fields to HairAssetProvisional.CurveSet for custom curve data: curveDataTexCoord, curveDataDiameter, curveDataTapering.
- Added LOD slider to HairAsset group preview.
- Added LOD indicator to HairInstance gizmos.
- Added simulation state to HairInstance inspector.
- Added per-material lod scale and bias to HairVertex node.

### Changed

- Moved all LOD dependent GPU workloads (most of them) to indirect dispatch.
- Substantially improved performance of constraint solver for primary strands (1.5x-2.5x on Turing.)
- Substantially improved performance of interpolation pass for non-primary strands.
- Refactored settings blocks in HairAsset.
- Refactored settings blocks in HairInstance.
- Refactored HairVertex graph outputs. (NOTE: Not yet final!)
- Updated the SRP default material to include default connections for motion vector and width.
- Updated the draw strand roots debug option to also include tangents and bitangents.
- Improved prefab handling.

### Fixed

- Fixed an issue with bad cast causing Texture3D to be ignored when supplied as static SDF.
- Fixed an issue with first frame initialization on 2021.2+.
- Fixed various regressions after restructuring.
- Fixed a memory leak in TriMeshBuffers.

### Removed

- Removed C# double definitions of most named GPU resources.
- Removed shader keyword for defining PSIZE (now always defined).
- Removed some old code.


## [0.12.0-exp.1] - 2024-04-15

### Added

- Added support for tube rendering.
- Added support for noise-based timing jitter in wind emitters (HairWind) to reduce uniformity of pulses.
- Added support for automatic LOD selection based on size of bounds in viewport.

### Changed

- Reduced size of topology meshes used for rendering. This is the result of a data format change, and affects meshes built at runtime (e.g. when changing subdivision setting), as well as meshes built within hair assets stored on disk. Existing hair assets in existing projects are still usable as-is, but they will need to be rebuilt if one wants to benefit from the reduction in size.
- Improved shader compilation time for all hair materials (removed use of multi_compile in HairVertex.hlsl).
- Improved tooltips in the HairWind component.
- Renamed various fields.

### Fixed

- Fixed a bug in triangle BVH lookup that was causing incorrect and slow root UV resolve on more elaborate meshes. 
- Fixed a precision issue that potentially could cause degenerate segments and skipped vertices when rendering very large groups of strands.
- Fixed an issue with the HairAsset inspector capturing mouse when clicking outside inspector after long progress bar (was triggering rebuild with the 'auto' option enabled).


## [0.11.0-exp.1] - 2023-05-26

### Added

- Added new option to account for solid occluders in wind propagation.
- Added new option to account for solid occluders in strand count probe construction.
- Added new component 'HairWind' for authoring wind emitters that can affect hair. The HairWind component represents a single emitter, and can be configured either as a standalone emitter (preferred), or as a proxy for an existing WindZone (more limited).
- Added support for volumetric wind propagation. Wind propagation is enabled per HairInstance (under volume settings). When enabled, wind will propagate through the volume of hair, and act on strands accordingly, taking into account the physical density of hair in the volume.

### Fixed

- Fixed an issue with root updates not taking the correct path on some platforms.
- Fixed missing 'noinstancing' option in the default builtin lit material.
- Fixed missing clamps on parameters used to control resampling.


## [0.10.0-exp.1] - 2023-03-22

### Added

- Added improved root frame resolve which also includes proper twist under deformation (instead of approximation via root bone of skinning target) when used in combination with com.unity.demoteam.digital-human >= 0.2.1-preview.
- Added support for custom scheduling (enabled per HairInstance via the update mode setting under system settings -- once enabled, the application is responsible for invoking 'DispatchUpdate' on the HairInstance).
- Reduced memory footprint of renderers by sharing topology meshes between similar renderers when possible (requires Unity 2021.2+ for direct renderer bounds + staging subdivision disabled).
- Reduced memory footprint of simulation by shrinking unused buffers according to memory requirements of dynamic and static configuration.
- Added system aware replacement shaders that are automatically swapped in during async compilation and as error fallback.

### Changed

- Renderer bounds are now updated directly instead of via instanced mesh when possible (requires Unity 2021.2+).
- Moved static shader configuration to C# struct with [GenerateHLSL] to be able to inspect static configuration from C# side.
- Separated common unlit/builtin shader setup into separate includes (see HairMaterialCommonUnlit.hlsl and HairMaterialCommonBuiltin.hlsl) to facilitate easier reuse in custom unlit/builtin shaders and materials.
- Increased verbosity of warning displayed if/when a custom data provider supplies incomplete vertex data for one or more of its declared vertex features.

### Fixed

- Fixed an issue with the boundary collision constraint not handling non-uniformly scaled box colliders (caused by incorrect distance computation due to not separating scale from transform).
- Fixed a synchronization issue with buffer uploads (from initialization) not always finishing before first read when using custom scheduling and async dispatch.
- Fixed a warning that was appearing for topology meshes (due to their non-standard vertex layout) with raytracing enabled.
- Fixed an issue that prevented use of material variants.
- Fixed an issue with the content upgrade handling incorrectly causing some of the default settings to be erased on a newly created HairAsset.
- Fixed an issue with runtime generated topology meshes being incomplete on some platforms due to the submesh declaration missing an explicit vertex count.
- Fixed an issue with root UV not being resolved properly from alembic curve data when using the 'Resolve From Curve UV' option.
- Fixed an issue with the graphics-based root update implicitly binding an unspecified render target (might be undefined, so it now explicitly binds a temporary 1x1 target despite not drawing anything).
- Fixed an issue with prerequisite state (for when depending on attachments resolving on GPU) not being reset after disabling/enabling a HairInstance.
- Fixed two related issues within rest pose initialization and root frame resolve that caused strands to sometimes have incorrect rest pose, and to sometimes respond incorrectly to external deformation of the root mesh (initialization now guarantees correct root frame relative rest poses that do not rely on the initial state of the possibly already deformed root mesh, and the root frame resolve now derives directly from the current state of the root mesh, and no longer depends on perturbing an initial root frame).
- Fixed an issue caused by the property drawer for RenderingLayerMask not gracefully handling missing layer mask names (supplied by the active render pipeline).
- Fixed an issue with manually assigned boundaries not taking priority over boundaries automatically collected via overlap (as promised in UI).
- Fixed local vertex descriptor/attribute inconsistencies that caused pipeline validation errors with builtin and Metal.
- Fixed incorrect guard that prevented builtin shaders from actually sampling the hair data on some platforms.
- Fixed out-of-bounds error in HairAssetBuilder that was caused by curve resampling ignoring provisional curve data feature flags.
- Fixed an issue (conditionally) with alembic curve assets not showing up in the object picker (requires Unity 2021.2+).
- Fixed compatibility with Unity.Collections >= 2.0.0.
- Fixed regression in HairAssetBuilder (since refactor) that caused false rejection of alembic curve sets without explicit curve width and UV.


## [0.9.1-exp.1] - 2022-12-15

### Added

- Added option to resolve root UV from input curves, if input curves provide that data.
- Added support for building HairAsset silently and/or without internal linking via scripting and HairAssetBuilder.BuildFlags.
- Added support for building HairAsset from custom curve data (adds type 'Custom' that requires assigning an implementation of HairAssetCustomData).
- Added base class HairAssetCustomPlacement to support user defined providers of custom root placement (replaces HairAssetProvider).
- Added base class HairAssetCustomData to support user defined providers of fully custom curve data.
- Added utility scope LongOperationOutput for controlling the output of the LongOperation utility.
- Enabled support for HDRP High Quality Line Rendering when used in combination HDRP >= 15.0.2.

### Changed

- Removed base type HairAssetProvider and added script upgrader for automatic conversion to HairAssetCustomPlacement.
- Refactored parts of HairAssetBuilder to support custom curve data in existing processing pipeline.

### Fixed

- Fixed a UI issue that sometimes caused a block to also list properties from the next block.
- Suppress compilation warning caused by intentional sqrt(-1) when compiling the debug draw shader.
- Fixed sporadic NaN output from vertex tangent resolve that sometimes caused black screen.
- Fixed duplicate definitions in shader setup that broke compatibility with URP >= 12.0.0.
- Fixed an issue with assemblies not being visible in the default namespace.
- Fixed compatibility with Unity.Collections >= 1.3.0.


## [0.9.0-exp.1] - 2022-08-10

### Added

- Initial public release.


<!--- LINKS --->
[unreleased]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.19.0-preview.1...HEAD
[0.19.0-preview.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.18.3-exp.1...0.19.0-preview.1
[0.18.3-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.18.2-exp.1...0.18.3-exp.1
[0.18.2-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.18.1-exp.1...0.18.2-exp.1
[0.18.1-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.18.0-exp.1...0.18.1-exp.1
[0.18.0-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.17.0-exp.1...0.18.0-exp.1
[0.17.0-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.16.0-exp.1...0.17.0-exp.1
[0.16.0-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.15.0-exp.1...0.16.0-exp.1
[0.15.0-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.14.2-exp.1...0.15.0-exp.1
[0.14.2-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.14.1-exp.1...0.14.2-exp.1
[0.14.1-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.14.0-exp.1...0.14.1-exp.1
[0.14.0-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.13.0-exp.1...0.14.0-exp.1
[0.13.0-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.12.0-exp.1...0.13.0-exp.1
[0.12.0-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.11.0-exp.1...0.12.0-exp.1
[0.11.0-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.10.0-exp.1...0.11.0-exp.1
[0.10.0-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.9.1-exp.1...0.10.0-exp.1
[0.9.1-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/compare/0.9.0-exp.1...0.9.1-exp.1
[0.9.0-exp.1]: https://github.com/Unity-Technologies/com.unity.demoteam.hair/releases/tag/0.9.0-exp.1

```

`CHANGELOG.md.meta`:

```meta
fileFormatVersion: 2
guid: a0a24285eee8eb6438eaeb60473ca74d
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Documentation~/index.md`:

```md
TODO documentation

- introduction
	- principles
	- features

- quick start
	- 

- concepts
	- strands
	- volumetrics
	- level of detail
	- interpolation

- components
	- HairAsset
	- HairInstance
	- HairBoundary
	- HairWind
	
- building shaders
	-

```

`Editor.meta`:

```meta
fileFormatVersion: 2
guid: 3a85a92811175ac47ac4adad23ccd744
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/HairAssetBuilder.cs`:

```cs
//#define VISIBLE_SUBASSETS
#define CLEAR_ALL_SUBASSETS

#define LOD_INDEX_INCREASING
#define USE_DERIVED_CACHE

using System;
using UnityEngine;
using UnityEditor;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Burst;
using Unity.Jobs;

#if HAS_PACKAGE_UNITY_COLLECTIONS_1_0_0_PRE_3
using Unity.Collections.NotBurstCompatible;
#endif

#if HAS_PACKAGE_UNITY_ALEMBIC
using UnityEngine.Formats.Alembic.Importer;
#endif

namespace Unity.DemoTeam.Hair
{
	public static class HairAssetBuilder
	{
		[Flags]
		public enum BuildFlags
		{
			None = 0,
			DisableLinking = 1 << 0,
			DisableProgress = 1 << 1,
		}

		public static void ClearHairAsset(HairAsset hairAsset)
		{
			// do nothing if already clean
			if (hairAsset.strandGroups == null)
				return;

			// unlink and destroy any sub-assets
#if CLEAR_ALL_SUBASSETS
			var subAssetsPath = AssetDatabase.GetAssetPath(hairAsset);
			var subAssets = AssetDatabase.LoadAllAssetsAtPath(subAssetsPath);
			{
				foreach (var subAsset in subAssets)
				{
					if (subAsset != hairAsset)
					{
						AssetDatabase.RemoveObjectFromAsset(subAsset);
						UnityEngine.Object.DestroyImmediate(subAsset);
					}
				}
			}
#else
			foreach (var strandGroup in hairAsset.strandGroups)
			{
				if (strandGroup.meshAssetRoots != null)
				{
					AssetDatabase.RemoveObjectFromAsset(strandGroup.meshAssetRoots);
					Mesh.DestroyImmediate(strandGroup.meshAssetRoots);
				}

				if (strandGroup.meshAssetLines != null)
				{
					AssetDatabase.RemoveObjectFromAsset(strandGroup.meshAssetLines);
					Mesh.DestroyImmediate(strandGroup.meshAssetLines);
				}

				if (strandGroup.meshAssetStrips != null)
				{
					AssetDatabase.RemoveObjectFromAsset(strandGroup.meshAssetStrips);
					Mesh.DestroyImmediate(strandGroup.meshAssetStrips);
				}
			}
#endif

			// clear
			hairAsset.strandGroups = null;
		}

		public static void BuildHairAsset(HairAsset hairAsset, BuildFlags buildFlags = BuildFlags.None)
		{
			// clean up
			ClearHairAsset(hairAsset);

			// build the data
			using (new LongOperationOutput(enable: buildFlags.HasFlag(BuildFlags.DisableProgress) == false))
			{
				switch (hairAsset.settingsBasic.type)
				{
					case HairAsset.Type.Procedural:
						BuildHairAssetProcedural(hairAsset);
						break;

					case HairAsset.Type.Alembic:
						BuildHairAssetAlembic(hairAsset);
						break;

					case HairAsset.Type.Custom:
						BuildHairAssetCustom(hairAsset);
						break;
				}
			}

			// filter the data
			if (hairAsset.strandGroups != null)
			{
				ref var strandGroups = ref hairAsset.strandGroups;

				int validCount = 0;

				for (int i = 0; i != strandGroups.Length; i++)
				{
					if (strandGroups[i].strandCount > 0)
						strandGroups[validCount++] = strandGroups[i];
				}

				if (strandGroups.Length > validCount)
					Array.Resize(ref strandGroups, validCount);

				if (strandGroups.Length == 0)
					strandGroups = null;
			}

			// hash the data
			if (hairAsset.strandGroups != null)
			{
				var hash = new Hash128();

				for (int i = 0; i != hairAsset.strandGroups.Length; i++)
				{
					hash.Append(hairAsset.strandGroups[i].meshAssetRoots.GetInstanceID());
					hash.Append(hairAsset.strandGroups[i].particlePosition);
				}

				hairAsset.checksum = hash.ToString();
			}
			else
			{
				hairAsset.checksum = string.Empty;
			}

			// link sub-assets
			if (hairAsset.strandGroups != null)
			{
				for (int i = 0; i != hairAsset.strandGroups.Length; i++)
				{
					if (buildFlags.HasFlag(BuildFlags.DisableLinking) == false)
					{
						AssetDatabase.AddObjectToAsset(hairAsset.strandGroups[i].meshAssetRoots, hairAsset);
					}

					hairAsset.strandGroups[i].meshAssetRoots.name += (":" + i);
				}
			}

			// dirty the asset
			EditorUtility.SetDirty(hairAsset);

#if VISIBLE_SUBASSETS
			// save and re-import to force hierearchy update
			AssetDatabase.SaveAssets();
			AssetDatabase.ImportAsset(AssetDatabase.GetAssetPath(hairAsset), ImportAssetOptions.ForceUpdate);
#endif
		}

		public static void BuildHairAssetProcedural(HairAsset hairAsset)
		{
			// prep strand groups
			hairAsset.strandGroups = new HairAsset.StrandGroup[1];

			// build strand groups
			for (int i = 0; i != hairAsset.strandGroups.Length; i++)
			{
				BuildStrandGroupProcedural(ref hairAsset.strandGroups[i], hairAsset);
			}
		}

		public static void BuildHairAssetAlembic(HairAsset hairAsset)
		{
#if HAS_PACKAGE_UNITY_ALEMBIC
			// check stream present
			var alembic = hairAsset.settingsAlembic.alembicAsset;
			if (alembic == null)
				return;

			// instantiate to load the data
			var alembicInstantiate = EditorUtility.IsPersistent(hairAsset.settingsAlembic.alembicAsset);
			if (alembicInstantiate)
			{
				alembic = GameObject.Instantiate(alembic);
				alembic.gameObject.hideFlags |= HideFlags.DontSave;
			}

			// fetch all alembic curve sets 
			var alembicCurveSets = alembic.gameObject.GetComponentsInChildren<AlembicCurves>(includeInactive: true);
			if (alembicCurveSets.Length > 0)
			{
				// prep strand groups
				hairAsset.strandGroups = new HairAsset.StrandGroup[alembicCurveSets.Length];

				// build strand groups
				for (int i = 0, alembicCurveSetIndex = 0; alembicCurveSetIndex < alembicCurveSets.Length; i++)
				{
					BuildStrandGroupAlembic(ref hairAsset.strandGroups[i], hairAsset, alembicCurveSets, ref alembicCurveSetIndex);
				}
			}

			// destroy container
			if (alembicInstantiate)
			{
				GameObject.DestroyImmediate(alembic.gameObject);
			}
#endif
		}

		public static void BuildHairAssetCustom(HairAsset hairAsset)
		{
			// check provider present
			var dataProvider = hairAsset.settingsCustom.dataProvider;
			if (dataProvider == null)
				return;

			if (dataProvider.AcquireCurves(out var curveSet, Allocator.Temp))
			{
				using (curveSet)
				{
					// prep strand groups
					hairAsset.strandGroups = new HairAsset.StrandGroup[1];

					// build strand groups
					for (int i = 0; i != hairAsset.strandGroups.Length; i++)
					{
						BuildStrandGroupResolved(ref hairAsset.strandGroups[0], hairAsset, hairAsset.settingsCustom.settingsResolve, curveSet);
					}
				}
			}
		}

		public static void BuildStrandGroupProcedural(ref HairAsset.StrandGroup strandGroup, HairAsset hairAsset)
		{
			ref readonly var settings = ref hairAsset.settingsProcedural;

			// get target counts
			var generatedStrandCount = settings.strandCount;
			var generatedStrandParticleCount = settings.strandParticleCount;

			// prep temporaries
			using (var generatedRoots = new HairAssetProvisional.ProceduralRoots(generatedStrandCount))
			using (var generatedStrands = new HairAssetProvisional.ProceduralStrands(generatedStrandCount, generatedStrandParticleCount))
			{
				// build temporaries
				if (GenerateRoots(generatedRoots, settings))
				{
					GenerateStrands(generatedStrands, generatedRoots, settings, hairAsset.settingsBasic.memoryLayout);
				}
				else
				{
					return;
				}

				// set strand count
				strandGroup.strandCount = generatedStrandCount;
				strandGroup.strandParticleCount = generatedStrandParticleCount;

				// set memory layout
				strandGroup.particleMemoryLayout = hairAsset.settingsBasic.memoryLayout;

				// prep strand buffers
				strandGroup.rootUV = new Vector2[generatedStrandCount];
				strandGroup.rootScale = new Vector4[generatedStrandCount];// completed in FinalizeStrandGroup(..)
				strandGroup.particleFeatures = HairAsset.StrandGroup.ParticleFeatures.Position;
				strandGroup.particlePosition = new Vector3[generatedStrandCount * generatedStrandParticleCount];
				strandGroup.particleTexCoord = null;
				strandGroup.particleDiameter = null;

				// populate strand buffers
				if (generatedStrandCount * generatedStrandParticleCount > 0)
				{
					generatedRoots.rootUV.CopyTo(strandGroup.rootUV);
					generatedStrands.rootScale.CopyTo(strandGroup.rootScale);
					generatedStrands.particlePosition.CopyTo(strandGroup.particlePosition);
				}
			}

			// calc derivative fields, create mesh assets
			FinalizeStrandGroup(ref strandGroup, hairAsset);
		}

		// resolve root scale
		public static unsafe void BuildStrandGroupResolved(ref HairAsset.StrandGroup strandGroup, in HairAsset hairAsset, in HairAsset.SettingsResolve settingsResolve, in HairAssetProvisional.CurveSet curveSet)
		{
			ref readonly var settings = ref settingsResolve;

			// validate input curve set
			if (curveSet.curveCount > curveSet.curveVertexCount.Length)
			{
				Debug.LogWarning("Discarding provided curve set due to incomplete (out of bounds) curve data.");
				return;
			}

			var curveSetInfo = new HairAssetProvisional.CurveSetInfo(curveSet);
			{
				var curveSetIncompleteRoot = (HairAssetProvisional.CurveSet.CurveFeatures)0;
				{
					if (curveSet.curveCount > curveSet.curveDataTexCoord.Length && curveSet.curveFeatures.HasFlag(HairAssetProvisional.CurveSet.CurveFeatures.TexCoord))
						curveSetIncompleteRoot |= HairAssetProvisional.CurveSet.CurveFeatures.TexCoord;
					if (curveSet.curveCount > curveSet.curveDataDiameter.Length && curveSet.curveFeatures.HasFlag(HairAssetProvisional.CurveSet.CurveFeatures.Diameter))
						curveSetIncompleteRoot |= HairAssetProvisional.CurveSet.CurveFeatures.Diameter;
					if (curveSet.curveCount > curveSet.curveDataTapering.Length && curveSet.curveFeatures.HasFlag(HairAssetProvisional.CurveSet.CurveFeatures.Tapering))
						curveSetIncompleteRoot |= HairAssetProvisional.CurveSet.CurveFeatures.Tapering;
				}

				if (curveSetIncompleteRoot != 0)
				{
					Debug.LogWarningFormat("Discarding provided curve set due to incomplete (out of bounds) curve data. ({0})", curveSetIncompleteRoot.ToString());
					return;
				}

				var curveSetIncompleteVertex = (HairAssetProvisional.CurveSet.VertexFeatures)0;
				{
					if (curveSetInfo.sumVertexCount > curveSet.vertexDataPosition.Length)
						curveSetIncompleteVertex |= HairAssetProvisional.CurveSet.VertexFeatures.Position;
					if (curveSetInfo.sumVertexCount > curveSet.vertexDataTexCoord.Length && curveSet.vertexFeatures.HasFlag(HairAssetProvisional.CurveSet.VertexFeatures.TexCoord))
						curveSetIncompleteVertex |= HairAssetProvisional.CurveSet.VertexFeatures.TexCoord;
					if (curveSetInfo.sumVertexCount > curveSet.vertexDataDiameter.Length && curveSet.vertexFeatures.HasFlag(HairAssetProvisional.CurveSet.VertexFeatures.Diameter))
						curveSetIncompleteVertex |= HairAssetProvisional.CurveSet.VertexFeatures.Diameter;
				}

				if (curveSetIncompleteVertex != 0)
				{
					Debug.LogWarningFormat("Discarding provided curve set due to incomplete (out of bounds) vertex data. ({0})", curveSetIncompleteVertex.ToString());
					return;
				}

				if (curveSetInfo.minVertexCount < 2)
				{
					Debug.LogWarning("Discarding provided curve set due to degenerate curves with less than two vertices.");
					return;
				}
			}

			// sanitize input curve data to guarantee uniform vertex count
			var uniformCurveSet = curveSet;
			var uniformVertexCount = curveSetInfo.maxVertexCount;
			var uniformVertexAlloc = false;
			{
				// resample enabled if requested by user
				var resample = settings.resampleCurves;
				var resampleIterations = Mathf.Clamp(settings.resampleQuality, HairAsset.SettingsResolve.MIN_RESAMPLE_QUALITY, HairAsset.SettingsResolve.MAX_RESAMPLE_QUALITY);
				var resampleVertexCount = Mathf.Clamp(settings.resampleResolution, HairAsset.SettingsResolve.MIN_RESAMPLE_RESOLUTION, HairAsset.SettingsResolve.MAX_RESAMPLE_RESOLUTION);

				// resample required if there are curves with varying vertex count
				var resampleRequired = !resample && (curveSetInfo.minVertexCount != curveSetInfo.maxVertexCount);
				if (resampleRequired)
				{
					Debug.LogWarning("Resampling curve set (to maximum vertex count within set) due to curves with varying vertex count.");

					resample = true;
					resampleVertexCount = curveSetInfo.maxVertexCount;
					resampleIterations = 1;
				}

				// resample the data if requested by user or required due to curves with varying vertex count
				if (resample)
				{
					// allocate buffers for resampled data
					uniformCurveSet.vertexDataPosition = new UnsafeList<Vector3>(curveSet.curveCount * resampleVertexCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
					uniformCurveSet.vertexDataTexCoord = new UnsafeList<Vector2>(curveSet.curveCount * resampleVertexCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
					uniformCurveSet.vertexDataDiameter = new UnsafeList<float>(curveSet.curveCount * resampleVertexCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
					uniformVertexCount = resampleVertexCount;
					uniformVertexAlloc = true;

					using (var longOperation = new LongOperationScope("Resampling curves"))
					using (var resampleResolve = new UnsafeList<ResampleBlend>(curveSet.curveCount * resampleVertexCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
					{
						var dstVertexCount = uniformVertexCount;
						var dstDataPositionPtr = uniformCurveSet.vertexDataPosition.Ptr;
						var dstDataTexCoordPtr = uniformCurveSet.vertexDataTexCoord.Ptr;
						var dstDataDiameterPtr = uniformCurveSet.vertexDataDiameter.Ptr;
						var dstVertexOffset = 0;

						var srcVertexCountPtr = curveSet.curveVertexCount.Ptr;
						var srcDataPositionPtr = curveSet.vertexDataPosition.Ptr;
						var srcDataTexCoordPtr = curveSet.vertexDataTexCoord.Ptr;
						var srcDataDiameterPtr = curveSet.vertexDataDiameter.Ptr;
						var srcVertexOffset = 0;

						var resampleResolvePtr = resampleResolve.Ptr;

						// resample position stream
						for (int i = 0; i != curveSet.curveCount; i++)
						{
							longOperation.UpdateStatus("Resampling", i, curveSet.curveCount);

							var srcVertexCount = srcVertexCountPtr[i];
							{
								Resample(
									srcDataPositionPtr + srcVertexOffset, srcVertexCount,
									dstDataPositionPtr + dstVertexOffset, dstVertexCount,
									resampleResolvePtr + dstVertexOffset, resampleIterations);

								srcVertexOffset += srcVertexCount;
								dstVertexOffset += dstVertexCount;
							}
						}

						// resample additional streams
						if (uniformCurveSet.vertexFeatures > HairAssetProvisional.CurveSet.VertexFeatures.Position)
						{
							var resampleTexCoord = uniformCurveSet.vertexFeatures.HasFlag(HairAssetProvisional.CurveSet.VertexFeatures.TexCoord);
							var resampleDiameter = uniformCurveSet.vertexFeatures.HasFlag(HairAssetProvisional.CurveSet.VertexFeatures.Diameter);

							dstVertexOffset = 0;
							srcVertexOffset = 0;

							for (int i = 0; i != curveSet.curveCount; i++)
							{
								for (int j = 0; j != dstVertexCount; j++)
								{
									var dstVertexIndex = dstVertexOffset + j;

									ref readonly var dstVertexResolve = ref resampleResolvePtr[dstVertexIndex];

									var srcVertexIndex0 = srcVertexOffset + dstVertexResolve.srcIndex0;
									var srcVertexIndex1 = srcVertexOffset + dstVertexResolve.srcIndex1;

									//Debug.Log("curve " + i + " dstVertex " + j + " <- lerp("+ dstVertexResolve.srcIndex0 + ", "+ dstVertexResolve.srcIndex1 + ", "+ dstVertexResolve.srcBlendFrac + ")");

									if (resampleTexCoord)
									{
										dstDataTexCoordPtr[dstVertexIndex] = Vector2.Lerp(
											srcDataTexCoordPtr[srcVertexIndex0],
											srcDataTexCoordPtr[srcVertexIndex1],
											dstVertexResolve.srcBlendFrac);
									}

									if (resampleDiameter)
									{
										dstDataDiameterPtr[dstVertexIndex] = Mathf.Lerp(
											srcDataDiameterPtr[srcVertexIndex0],
											srcDataDiameterPtr[srcVertexIndex1],
											dstVertexResolve.srcBlendFrac);
									}
								}

								srcVertexOffset += srcVertexCountPtr[i];
								dstVertexOffset += dstVertexCount;
							}
						}
					}
				}
			}

			// set strand count
			strandGroup.strandCount = uniformCurveSet.curveCount;
			strandGroup.strandParticleCount = uniformVertexCount;

			// set memory layout
			strandGroup.particleMemoryLayout = hairAsset.settingsBasic.memoryLayout;

			// set strand features
			static HairAsset.StrandGroup.ParticleFeatures GetParticleFeature(HairAsset.SettingsResolve.AdditionalData flag)
			{
				switch (flag)
				{
					case HairAsset.SettingsResolve.AdditionalData.PerVertexUV: return HairAsset.StrandGroup.ParticleFeatures.TexCoord;
					case HairAsset.SettingsResolve.AdditionalData.PerVertexWidth: return HairAsset.StrandGroup.ParticleFeatures.Diameter;
					default: return 0;
				}
			}

			strandGroup.particleFeatures = HairAsset.StrandGroup.ParticleFeatures.Position;
			if (settings.additionalData)
			{
				if (uniformCurveSet.vertexFeatures.HasFlag(HairAssetProvisional.CurveSet.VertexFeatures.TexCoord))
					strandGroup.particleFeatures |= GetParticleFeature(settings.additionalDataMask & HairAsset.SettingsResolve.AdditionalData.PerVertexUV);
				if (uniformCurveSet.vertexFeatures.HasFlag(HairAssetProvisional.CurveSet.VertexFeatures.Diameter))
					strandGroup.particleFeatures |= GetParticleFeature(settings.additionalDataMask & HairAsset.SettingsResolve.AdditionalData.PerVertexWidth);
			}

			// prep strand buffers
			strandGroup.rootUV = new Vector2[uniformCurveSet.curveCount];
			strandGroup.rootScale = new Vector4[uniformCurveSet.curveCount];// completed in FinalizeStrandGroup(..)

			static void PrepareParticleBufferConditional<T>(in HairAsset.StrandGroup dstGroup, ref T[] dstBuffer, bool enabled = true) where T : unmanaged
			{
				dstBuffer = enabled ? (new T[dstGroup.strandCount * dstGroup.strandParticleCount]) : null;
			};

			PrepareParticleBufferConditional(strandGroup, ref strandGroup.particlePosition);
			PrepareParticleBufferConditional(strandGroup, ref strandGroup.particleTexCoord, strandGroup.particleFeatures.HasFlag(HairAsset.StrandGroup.ParticleFeatures.TexCoord));
			PrepareParticleBufferConditional(strandGroup, ref strandGroup.particleDiameter, strandGroup.particleFeatures.HasFlag(HairAsset.StrandGroup.ParticleFeatures.Diameter));

			// build strand buffers
			{
				var uniformCurveDataTexCoordPtr = uniformCurveSet.curveDataTexCoord.Ptr;
				var uniformCurveDataDiameterPtr = uniformCurveSet.curveDataDiameter.Ptr;
				var uniformCurveDataTaperingPtr = uniformCurveSet.curveDataTapering.Ptr;

				var uniformVertexDataPositionPtr = uniformCurveSet.vertexDataPosition.Ptr;
				var uniformVertexDataTexCoordPtr = uniformCurveSet.vertexDataTexCoord.Ptr;
				var uniformVertexDataDiameterPtr = uniformCurveSet.vertexDataDiameter.Ptr;

				// resolve root uv
				switch (settings.rootUV)
				{
					case HairAsset.SettingsResolve.RootUV.ResolveFromMesh:
						{
							if (settings.rootUVMesh != null)
							{
								using (var longOperation = new LongOperationScope("Resolving root UVs"))
								{
									longOperation.UpdateStatus("Building mesh BVH", 0.0f);
#if USE_DERIVED_CACHE
									var meshQueries = DerivedCache.GetOrCreate((Mesh)settings.rootUVMesh,
										meshArg =>
										{
											using (var meshData = Mesh.AcquireReadOnlyMeshData(meshArg))
											{
												return new TriMeshQueries(meshData[0], Allocator.Persistent);
											}
										});
#else
									using (var meshData = Mesh.AcquireReadOnlyMeshData(settings.rootUVMesh))
									using (var meshQueries = new TriMeshQueries(meshData[0], Allocator.Temp))
#endif

									for (int i = 0; i != uniformCurveSet.curveCount; i++)
									{
										longOperation.UpdateStatus("Resolving", i, uniformCurveSet.curveCount);
										{
											ref readonly var rootPos = ref uniformVertexDataPositionPtr[i * uniformVertexCount];
											strandGroup.rootUV[i] = meshQueries.FindClosestTriangleUV(rootPos);
										}
									}
								}
							}
							else
							{
								Debug.LogWarning("Unable to resolve root UVs from mesh, since no mesh was assigned. Using provided uniform fallback.");
								goto case HairAsset.SettingsResolve.RootUV.UseFallback;
							}
						}
						break;

					case HairAsset.SettingsResolve.RootUV.ResolveFromCurves:
						{
							// first try per-curve texcoord
							if (uniformCurveSet.curveFeatures.HasFlag(HairAssetProvisional.CurveSet.CurveFeatures.TexCoord))
							{
								for (int i = 0; i != uniformCurveSet.curveCount; i++)
								{
									strandGroup.rootUV[i] = uniformCurveDataTexCoordPtr[i];
								}
							}
							// else try per-vertex texcoord
							else if (uniformCurveSet.vertexFeatures.HasFlag(HairAssetProvisional.CurveSet.VertexFeatures.TexCoord))
							{
								for (int i = 0; i != uniformCurveSet.curveCount; i++)
								{
									strandGroup.rootUV[i] = uniformVertexDataTexCoordPtr[i * uniformVertexCount];
								}
							}
							// else use fallback
							else
							{
								Debug.LogWarning("Unable to resolve root UVs from curves, since no curve UVs were provided in curve set. Using provided uniform fallback.");
								goto case HairAsset.SettingsResolve.RootUV.UseFallback;
							}
						}
						break;

					case HairAsset.SettingsResolve.RootUV.UseFallback:
						{
							for (int i = 0; i != uniformCurveSet.curveCount; i++)
							{
								strandGroup.rootUV[i] = settings.rootUVFallback;
							}
						}
						break;
				}

				// resolve diameter and tapering
				{
					var tryResolveDiameter = (settings.strandDiameter == HairAsset.SettingsResolve.StrandDiameter.ResolveFromCurves);
					var tryResolveTapering = (settings.tipScale == HairAsset.SettingsResolve.TipScale.ResolveFromCurves);

					// write result per vertex
					var perVertexResult = (tryResolveDiameter || tryResolveTapering) && uniformCurveSet.vertexFeatures.HasFlag(HairAssetProvisional.CurveSet.VertexFeatures.Diameter);
					if (perVertexResult)
					{
						for (int i = 0; i != uniformCurveSet.curveCount; i++)
						{
							var maxDiameter = uniformVertexDataDiameterPtr[i * uniformVertexCount];
							var maxDiameterVertexIndex = 0;
							var maxDiameterVertexIndexTaper = 0;

							for (int j = 1; j != uniformVertexCount; j++)
							{
								var vertexDiameter = uniformVertexDataDiameterPtr[i * uniformVertexCount + j];
								if (vertexDiameter >= maxDiameter)
								{
									maxDiameter = vertexDiameter;
									maxDiameterVertexIndex = j;
								}
								else
								{
									if (maxDiameterVertexIndex == j - 1)
									{
										maxDiameterVertexIndexTaper = j - 1;
									}
								}
							}

							var tipDiameter = uniformVertexDataDiameterPtr[(i + 1) * uniformVertexCount - 1];
							var tipScale = Mathf.Min(tipDiameter, maxDiameter) / maxDiameter;
							var tipScaleOffset = maxDiameterVertexIndexTaper / (float)(uniformVertexCount - 1);

							strandGroup.rootScale[i].y = maxDiameter * uniformCurveSet.unitScaleDiameter;
							strandGroup.rootScale[i].z = tipScaleOffset;
							strandGroup.rootScale[i].w = tipScale;
						}
					}

					// resolve strand diameter
					switch (settings.strandDiameter)
					{
						case HairAsset.SettingsResolve.StrandDiameter.ResolveFromCurves:
							{
								// first try per-vertex diameter (result written already)
								if (perVertexResult)
								{
								}
								// else try per-curve diameter
								else if (uniformCurveSet.curveFeatures.HasFlag(HairAssetProvisional.CurveSet.CurveFeatures.Diameter))
								{
									for (int i = 0; i != uniformCurveSet.curveCount; i++)
									{
										strandGroup.rootScale[i].y = uniformCurveDataDiameterPtr[i] * uniformCurveSet.unitScaleDiameter;
									}
								}
								// else use fallback
								else
								{
									Debug.LogWarning("Unable to resolve strand diameters from curves, since no curve diameters were provided in curve set. Using provided uniform fallback.");
									goto case HairAsset.SettingsResolve.StrandDiameter.UseFallback;
								}
							}
							break;

						case HairAsset.SettingsResolve.StrandDiameter.UseFallback:
							{
								for (int i = 0; i != uniformCurveSet.curveCount; i++)
								{
									strandGroup.rootScale[i].y = settings.strandDiameterFallback * 0.001f;
								}
							}
							break;
					}

					// resolve tapering
					switch (settings.tipScale)
					{
						case HairAsset.SettingsResolve.TipScale.ResolveFromCurves:
							{
								// first try per-vertex tapering (result written already)
								if (perVertexResult)
								{
								}
								// else try per-curve tapering
								else if (uniformCurveSet.curveFeatures.HasFlag(HairAssetProvisional.CurveSet.CurveFeatures.Tapering))
								{
									for (int i = 0; i != uniformCurveSet.curveCount; i++)
									{
										ref readonly var curveTapering = ref uniformCurveDataTaperingPtr[i];
										strandGroup.rootScale[i].z = curveTapering.tipScaleOffset;
										strandGroup.rootScale[i].w = curveTapering.tipScale;
									}
								}
								// else use fallback
								else
								{
									Debug.LogWarning("Unable to resolve tapering from curves, since no curve diameters were provided in curve set. Using provided uniform fallback.");
									goto case HairAsset.SettingsResolve.TipScale.UseFallback;
								}
							}
							break;

						case HairAsset.SettingsResolve.TipScale.UseFallback:
							{
								for (int i = 0; i != uniformCurveSet.curveCount; i++)
								{
									strandGroup.rootScale[i].z = settings.tipScaleFallbackOffset;
									strandGroup.rootScale[i].w = settings.tipScaleFallback;
								}
							}
							break;
					}
				}

				// write particle data
				static void WriteParticleData<T>(in HairAsset.StrandGroup dstGroup, T[] dstBuffer, UnsafeList<T> srcBuffer) where T : unmanaged
				{
					if (dstBuffer == null)
						return;

					switch (dstGroup.particleMemoryLayout)
					{
						case HairAsset.MemoryLayout.Sequential:
							{
								var srcPtr = srcBuffer.Ptr;
								var srcSize = dstGroup.strandCount * dstGroup.strandParticleCount * sizeof(T);

								fixed (T* dstPtr = dstBuffer)
								{
									UnsafeUtility.MemCpy(dstPtr, srcPtr, srcSize);
								}
							}
							break;

						case HairAsset.MemoryLayout.Interleaved:
							{
								var srcBufferPtr = srcBuffer.Ptr;
								var srcStride = sizeof(T);
								var dstStride = sizeof(T) * dstGroup.strandCount;

								fixed (T* dstBufferPtr = dstBuffer)
								{
									for (int i = 0; i != dstGroup.strandCount; i++)
									{
										var srcPtr = srcBufferPtr + i * dstGroup.strandParticleCount;
										var dstPtr = dstBufferPtr + i;

										UnsafeUtility.MemCpyStride(dstPtr, dstStride, srcPtr, srcStride, srcStride, dstGroup.strandParticleCount);
									}
								}
							}
							break;
					}
				}

				WriteParticleData(strandGroup, strandGroup.particlePosition, uniformCurveSet.vertexDataPosition);
				if (strandGroup.particleFeatures.HasFlag(HairAsset.StrandGroup.ParticleFeatures.TexCoord))
					WriteParticleData(strandGroup, strandGroup.particleTexCoord, uniformCurveSet.vertexDataTexCoord);
				if (strandGroup.particleFeatures.HasFlag(HairAsset.StrandGroup.ParticleFeatures.Diameter))
					WriteParticleData(strandGroup, strandGroup.particleDiameter, uniformCurveSet.vertexDataDiameter);

				// scale particle data
				//TODO
				//if (uniformCurveSet.unitScalePosition != 1.0f)
				//	;
				//if (uniformCurveSet.unitScaleDiameter != 0.001f)
				//	;
			}

			// free allocated buffers
			if (uniformVertexAlloc)
			{
				uniformCurveSet.vertexDataPosition.Dispose();
				uniformCurveSet.vertexDataTexCoord.Dispose();
				uniformCurveSet.vertexDataDiameter.Dispose();
			}

			// calc derivative fields, create mesh assets
			FinalizeStrandGroup(ref strandGroup, hairAsset);
		}

#if HAS_PACKAGE_UNITY_ALEMBIC
		static unsafe NativeArray<int> IntervalLengthsFromOffsetsAndTotalLength(int* intervalOffsetPtr, int intervalCount, int totalLength, Allocator allocator)
		{
			var intervalLength = new NativeArray<int>(intervalCount, allocator, NativeArrayOptions.UninitializedMemory);
			var intervalLengthPtr = (int*)intervalLength.GetUnsafePtr();
			{
				for (int i = 1; i != intervalCount; i++)
				{
					intervalLengthPtr[i - 1] = intervalOffsetPtr[i] - intervalOffsetPtr[i - 1];
				}

				intervalLengthPtr[intervalCount - 1] = totalLength - intervalOffsetPtr[intervalCount - 1];
			}

			return intervalLength;
		}

		static unsafe NativeArray<int> IntervalLengthsFromOffsetsAndTotalLength(int[] intervalOffset, int totalLength, Allocator allocator)
		{
			fixed (int* intervalOffsetPtr = intervalOffset)
			{
				return IntervalLengthsFromOffsetsAndTotalLength(intervalOffsetPtr, intervalOffset.Length, totalLength, allocator);
			}
		}

		struct AlembicCurvesInfo
		{
			public int curveCount;
			public int[] curveVertexOffset;
			public int curveVertexCountMin;
			public int curveVertexCountMax;
			public Vector3[] vertexDataPosition;
			public Vector2[] vertexDataTexCoord;
			public float[] vertexDataDiameter;
			public HairAssetProvisional.CurveSet.VertexFeatures vertexFeatures;
		}

		static unsafe AlembicCurvesInfo PrepareAlembicCurvesInfo(AlembicCurves curveSet)
		{
			// prepare struct
			var info = new AlembicCurvesInfo
			{
				curveCount = curveSet.CurveOffsets.Length,
				curveVertexOffset = curveSet.CurveOffsets,
				curveVertexCountMin = 0,
				curveVertexCountMax = 0,
				vertexDataPosition = curveSet.Positions,
				vertexDataTexCoord = curveSet.UVs,
				vertexDataDiameter = curveSet.Widths,
				vertexFeatures = HairAssetProvisional.CurveSet.VertexFeatures.Position,
			};

			// find vertex features
			if (info.vertexDataTexCoord != null && info.vertexDataTexCoord.Length > 0)
				info.vertexFeatures |= HairAssetProvisional.CurveSet.VertexFeatures.TexCoord;
			if (info.vertexDataDiameter != null && info.vertexDataDiameter.Length > 0)
				info.vertexFeatures |= HairAssetProvisional.CurveSet.VertexFeatures.Diameter;

			// find min-max vertex count
			if (info.curveCount > 0)
			{
				using (var curveVertexCount = IntervalLengthsFromOffsetsAndTotalLength(info.curveVertexOffset, info.vertexDataPosition.Length, Allocator.Temp))
				{
					var curveVertexCountPtr = (int*)curveVertexCount.GetUnsafePtr();

					info.curveVertexCountMin = curveVertexCountPtr[0];
					info.curveVertexCountMax = curveVertexCountPtr[0];

					for (int i = 1; i != info.curveCount; i++)
					{
						Mathf.Min(info.curveVertexCountMin, curveVertexCountPtr[i]);
						Mathf.Max(info.curveVertexCountMax, curveVertexCountPtr[i]);
					}
				}
			}

			// sanitize vertex features
			if (info.vertexFeatures.HasFlag(HairAssetProvisional.CurveSet.VertexFeatures.Diameter))
			{
				var invalidRootDiameter = 0;
				{
					for (int i = 0; i != info.curveCount; i++)
					{
						var j = info.curveVertexOffset[i];
						if (j < info.vertexDataDiameter.Length && info.vertexDataDiameter[j] <= 0.0f)
						{
							invalidRootDiameter++;
						}
					}
				}

				if (invalidRootDiameter > 0)
				{
					Debug.LogWarningFormat("Discarding alembic curve set diameters due to {0} (out of {1}) curves having degenerate root diameter.", invalidRootDiameter, info.curveCount);
					info.vertexFeatures ^= HairAssetProvisional.CurveSet.VertexFeatures.Diameter;
				}
			}

			// done
			return info;
		}

		public static unsafe void BuildStrandGroupAlembic(ref HairAsset.StrandGroup strandGroup, in HairAsset hairAsset, AlembicCurves[] alembicCurveSets, ref int alembicCurveSetIndex)
		{
			ref readonly var settings = ref hairAsset.settingsAlembic;

			var combinedCurveSet = new HairAssetProvisional.CurveSet(Allocator.Temp);

			using (var longOperation = new LongOperationScope("Gathering curves"))
			{
				var combinedCurveVertexCountMin = 0;
				var combinedCurveVertexCountMax = 0;
				var combinedCurveVertexFeatures = HairAssetProvisional.CurveSet.VertexFeatures.Position;

				while (alembicCurveSetIndex < alembicCurveSets.Length)
				{
					// validate alembic curve set
					var alembicCurveSetInfo = PrepareAlembicCurvesInfo(alembicCurveSets[alembicCurveSetIndex++]);
					if (alembicCurveSetInfo.curveVertexCountMin >= 2)
					{
						// first valid set decides feature flags and maximum vertex count and feature mask
						if (combinedCurveSet.curveCount == 0)
						{
							combinedCurveVertexCountMin = alembicCurveSetInfo.curveVertexCountMin;
							combinedCurveVertexCountMax = alembicCurveSetInfo.curveVertexCountMax;
							combinedCurveVertexFeatures = alembicCurveSetInfo.vertexFeatures;
						}

						// secondary valid set (etc.) must conform to maximum vertex count and feature mask
						if (combinedCurveVertexCountMax != alembicCurveSetInfo.curveVertexCountMax ||
							combinedCurveVertexFeatures != alembicCurveSetInfo.vertexFeatures)
						{
							alembicCurveSetIndex--;// decrementing to revisit when building next strand group
							break;
						}

						// append data to combined set
						fixed (Vector3* alembicVertexDataPositionPtr = alembicCurveSetInfo.vertexDataPosition)
						fixed (Vector2* alembicVertexDataTexCoordPtr = alembicCurveSetInfo.vertexDataTexCoord)
						fixed (float* alembicVertexDataDiameterPtr = alembicCurveSetInfo.vertexDataDiameter)
						{
							using (var alembicCurveVertexCount = IntervalLengthsFromOffsetsAndTotalLength(alembicCurveSetInfo.curveVertexOffset, alembicCurveSetInfo.vertexDataPosition.Length, Allocator.Temp))
							{
								combinedCurveSet.curveCount += alembicCurveSetInfo.curveCount;
								combinedCurveSet.curveVertexCount.AddRange(alembicCurveVertexCount.GetUnsafePtr(), alembicCurveVertexCount.Length);
								combinedCurveSet.vertexDataPosition.AddRange(alembicVertexDataPositionPtr, alembicCurveSetInfo.vertexDataPosition.Length);
								combinedCurveSet.vertexDataTexCoord.AddRange(alembicVertexDataTexCoordPtr, alembicCurveSetInfo.vertexDataTexCoord.Length);
								combinedCurveSet.vertexDataDiameter.AddRange(alembicVertexDataDiameterPtr, alembicCurveSetInfo.vertexDataDiameter.Length);
							}
						}

						// finished if not combining
						if (settings.alembicAssetGroups != HairAsset.SettingsAlembic.Groups.Combine)
						{
							break;
						}
					}
					else
					{
						Debug.LogWarningFormat("Skipping alembic curve set (index {0}) due to degenerate curves with less than two vertices.", alembicCurveSetIndex);
					}
				}

				static float SourceUnitToUnitScale(HairAsset.SettingsAlembic.SourceUnit sourceUnit)
				{
					switch (sourceUnit)
					{
						default:
						case HairAsset.SettingsAlembic.SourceUnit.DataInMeters: return 1.0f;
						case HairAsset.SettingsAlembic.SourceUnit.DataInCentimeters: return 0.01f;
						case HairAsset.SettingsAlembic.SourceUnit.DataInMillimeters: return 0.001f;
					}
				}

				combinedCurveSet.vertexFeatures = combinedCurveVertexFeatures;
				combinedCurveSet.unitScalePosition = SourceUnitToUnitScale(settings.alembicScalePositions);
				combinedCurveSet.unitScaleDiameter = SourceUnitToUnitScale(settings.alembicScaleDiameters);
			}

			using (combinedCurveSet)
			{
				BuildStrandGroupResolved(ref strandGroup, hairAsset, settings.settingsResolve, combinedCurveSet);
			}
		}
#endif

		static void FinalizeStrandGroup(ref HairAsset.StrandGroup strandGroup, HairAsset hairAsset)
		{
			var strandCount = strandGroup.strandCount;
			if (strandCount == 0)
				return;

			var strandParticleCount = strandGroup.strandParticleCount;
			if (strandParticleCount == 0)
				return;

			// finalize strand properties
			using (var longOperation = new LongOperationScope("Finalizing strands"))
			{
				// calc strand lengths
				for (int i = 0; i != strandCount; i++)
				{
					longOperation.UpdateStatus("Measuring", i, strandCount);

					HairAssetUtility.DeclareStrandIterator(strandGroup, i, out int strandParticleBegin, out int strandParticleStride, out int strandParticleEnd);

					ref var strandParams = ref strandGroup.rootScale[i];
					{
						for (int j = strandParticleBegin + strandParticleStride; j != strandParticleEnd; j += strandParticleStride)
						{
							ref var p0 = ref strandGroup.particlePosition[j - strandParticleStride];
							ref var p1 = ref strandGroup.particlePosition[j];

							strandParams.x += Vector3.Distance(p0, p1);
						}
					}
				}

				// ensure non-zero strand parameters
				{
					var strandParamsEps = 1e-10f * Vector4.one;
					{
						for (int i = 0; i != strandCount; i++)
						{
							strandGroup.rootScale[i] = Vector4.Max(strandGroup.rootScale[i], strandParamsEps);
						}
					}
				}

				// calc maximum/average strand parameters within group (x: strand length, y: strand diameter, z: tip scale offset, w: tip scale)
				strandGroup.strandLengthTotal = 0.0f;
				strandGroup.strandParamsMax = Vector4.zero;
				strandGroup.strandParamsAvg = Vector4.zero;
				{
					for (int i = 0; i != strandCount; i++)
					{
						ref readonly var strandParams = ref strandGroup.rootScale[i];
						{
							strandGroup.strandLengthTotal += strandParams.x;
							strandGroup.strandParamsMax = Vector4.Max(strandGroup.strandParamsMax, strandParams);
							strandGroup.strandParamsAvg += strandParams.x * strandParams;
						}
					}

					strandGroup.strandParamsAvg /= strandGroup.strandLengthTotal;
				}

				// calc normalized strand parameters wrt. group maximum (x: strand length, y: strand diameter, z: tip scale offset, w: tip scale)
				for (int i = 0; i != strandCount; i++)
				{
					strandGroup.rootScale[i].Scale(strandGroup.strandParamsMax.Rcp());
				}

				// calc bounds
				if (strandGroup.particlePosition.Length > 0)
				{
					var boundsMin = strandGroup.particlePosition[0];
					var boundsMax = boundsMin;
					var boundsPad = strandGroup.strandParamsMax.y * Vector3.one;

					for (int i = 1, n = strandGroup.particlePosition.Length; i != n; i++)
					{
						longOperation.UpdateStatus("Computing bounds", i, n);

						boundsMin = Vector3.Min(boundsMin, strandGroup.particlePosition[i]);
						boundsMax = Vector3.Max(boundsMax, strandGroup.particlePosition[i]);
					}

					strandGroup.bounds = new Bounds(0.5f * (boundsMin + boundsMax), boundsMax - boundsMin + boundsPad);
				}
				else
				{
					strandGroup.bounds = new Bounds(Vector3.zero, Vector3.zero);
				}
			}

			// build lod clusters
			BuildLODClusters(ref strandGroup, hairAsset);

			// build mesh assets
			using (var longOperation = new LongOperationScope("Preparing mesh assets"))
			{
				unsafe
				{
#if VISIBLE_SUBASSETS
					var hideFlags = HideFlags.None;
#else
					var hideFlags = HideFlags.HideInHierarchy;
#endif

					strandGroup.meshAssetRoots = HairInstanceBuilder.CreateMeshRoots(
						hideFlags,
						strandGroup.particleMemoryLayout,
						strandGroup.strandCount,
						strandGroup.strandParticleCount,
						strandGroup.particlePosition);
				}
			}
		}

		// STRATEGY 1: solve base lod first, and then split towards high lod <--- EQ. divisive aproach
		//	PROS:
		//		- fully informed base lod 
		//		- also splits can be locally refined
		//	CONS:
		//		- costly to refine every split
		//		- splitting might be complicated
		//	SPLIT:
		//		a. sort clusters by number of strands descending
		//		b. split largest cluster in two
		//		c. refine the split
		//
		// ------ ------
		//
		// STRATEGY 2: merge towards base lod
		//	PROS:
		//		- only high lod needs to be refined
		//	CONS: 
		//		- only high lod can be refined
		//		- base lod not fully informed
		//	MERGE:
		//		a. sort clusters by number of strands ascending
		//		b. merge smallest cluster to one with nD closest mean
		//		c. recompute closest mean
		//
		// ------ ------
		//
		// INITIALIZE (3D):
		//	1. guess N root cluster centers
		//		a. sample volume
		//		b. sample mesh
		//		c. mis?
		//	2. build initial clusters by root distance
		//
		// REFINE (nD):
		//	3. k-means iteration in higher dimensional space
		//		a. translate cluster set into nD
		//		b. then cluster by kmeans in nD
		//
		// SPLIT (3D):
		//	4. sort clusters by number of strands
		//	5. split largest cluster
		//		a. longest axis / pca?
		//		b. 
		//
		static void BuildLODClusters(ref HairAsset.StrandGroup strandGroup, HairAsset hairAsset)
		{
			var strandCount = strandGroup.strandCount;
			var strandParticleCount = strandGroup.strandParticleCount;

			// prepare lod chain
			var lodCapacity = 0;
			var lodChain = new LODChain(lodCapacity, strandGroup, hairAsset.settingsBasic.kLODClustersClustering, hairAsset.settingsLODClusters.clusterVoid, Allocator.Temp);

			// build lod chain
			using (StrandClusterUtility.BindStrandData(ref lodChain.clusterSet, strandGroup, Allocator.Temp))
			{
				if (hairAsset.settingsBasic.kLODClusters)
				{
					switch (hairAsset.settingsLODClusters.baseLOD.baseLOD)
					{
						case HairAsset.SettingsLODClusters.BaseLODMode.Generated:
							BuildBaseLODGenerated(ref lodChain, strandGroup, hairAsset);
							break;

						case HairAsset.SettingsLODClusters.BaseLODMode.UVMapped:
							BuildBaseLODUVMapped(ref lodChain, strandGroup, hairAsset);
							break;
					}

					if (hairAsset.settingsLODClusters.highLOD.highLOD)
					{
						switch (hairAsset.settingsLODClusters.highLOD.highLODMode)
						{
							case HairAsset.SettingsLODClusters.HighLODMode.Automatic:
								BuildHighLODAutomatic(ref lodChain, strandGroup, hairAsset);
								break;

							case HairAsset.SettingsLODClusters.HighLODMode.Manual:
								BuildHighLODManual(ref lodChain, strandGroup, hairAsset);
								break;
						}
					}
				}

				if (lodChain.lodCount == 0 || lodChain.lodGuideCount[lodChain.lodCount - 1] < strandCount)
				{
					BuildHighLODAllStrands(ref lodChain, strandGroup, hairAsset);
				}
			}

			// export lod clusters
			strandGroup.lodCount = lodChain.lodCount;
#if LOD_INDEX_INCREASING
#if HAS_PACKAGE_UNITY_COLLECTIONS_1_0_0_PRE_3
			strandGroup.lodGuideCount = lodChain.lodGuideCount.ToArrayNBC();
			strandGroup.lodGuideIndex = lodChain.lodGuideIndex.ToArrayNBC();
			strandGroup.lodGuideCarry = lodChain.lodGuideCarry.ToArrayNBC();
			strandGroup.lodGuideReach = lodChain.lodGuideReach.ToArrayNBC();
#else
			strandGroup.lodGuideCount = lodChain.lodGuideCount.ToArray();
			strandGroup.lodGuideIndex = lodChain.lodGuideIndex.ToArray();
			strandGroup.lodGuideCarry = lodChain.lodGuideCarry.ToArray();
			strandGroup.lodGuideReach = lodChain.lodGuideReach.ToArray();
#endif
#else
			strandGroup.lodGuideCount = new int[lodChain.lodGuideCount.Length];
			strandGroup.lodGuideIndex = new int[lodChain.lodGuideIndex.Length];
			strandGroup.lodGuideCarry = new float[lodChain.lodGuideCarry.Length];
			strandGroup.lodGuideReach = new float[lodChain.lodGuideReach.Length];

			unsafe
			{
				// write highest granularity to LOD 0, next-to-highest granularity to LOD 1, etc.
				fixed (int* lodGuideCountDstBase = strandGroup.lodGuideCount)
				fixed (int* lodGuideIndexDstBase = strandGroup.lodGuideIndex)
				fixed (float* lodGuideCarryDstBase = strandGroup.lodGuideCarry)
				fixed (float* lodGuideReachDstBase = strandGroup.lodGuideReach)
				{
					var lodGuideCountCopyDst = lodGuideCountDstBase;
					var lodGuideIndexCopyDst = lodGuideIndexDstBase;
					var lodGuideCarryCopyDst = lodGuideCarryDstBase;
					var lodGuideReachCopyDst = lodGuideReachDstBase;

					var lodGuideCountCopySrc = (int*)lodChain.lodGuideCount.GetUnsafePtr() + (strandGroup.lodCount);
					var lodGuideIndexCopySrc = (int*)lodChain.lodGuideIndex.GetUnsafePtr() + (strandGroup.lodCount * strandCount);
					var lodGuideCarryCopySrc = (float*)lodChain.lodGuideCarry.GetUnsafePtr() + (strandGroup.lodCount * strandCount);
					var lodGuideReachCopySrc = (float*)lodChain.lodGuideReach.GetUnsafePtr() + (strandGroup.lodCount * strandCount);

					for (int i = 0; i != strandGroup.lodCount; i++)
					{
						lodGuideCountCopySrc -= 1;
						lodGuideIndexCopySrc -= strandCount;
						lodGuideCarryCopySrc -= strandCount;
						lodGuideReachCopySrc -= strandCount;

						UnsafeUtility.MemCpy(lodGuideCountCopyDst, lodGuideCountCopySrc, sizeof(int));
						UnsafeUtility.MemCpy(lodGuideIndexCopyDst, lodGuideIndexCopySrc, sizeof(int) * strandCount);
						UnsafeUtility.MemCpy(lodGuideCarryCopyDst, lodGuideCarryCopySrc, sizeof(float) * strandCount);
						UnsafeUtility.MemCpy(lodGuideReachCopyDst, lodGuideReachCopySrc, sizeof(float) * strandCount);

						lodGuideCountCopyDst += 1;
						lodGuideIndexCopyDst += strandCount;
						lodGuideCarryCopyDst += strandCount;
						lodGuideReachCopyDst += strandCount;
					}
				}
			}
#endif

			// export lod thresholds
			strandGroup.lodThreshold = new float[strandGroup.lodCount];
			{
				for (int i = 0; i != strandGroup.lodCount; i++)
				{
					strandGroup.lodThreshold[i] = strandGroup.lodGuideCount[i] / (float)strandGroup.strandCount;
				}
			}

			// build remapping tables from final cluster set
			var remappingRequired = (lodChain.lodCount > 1 || lodChain.clusterSet.dataDesc.clusterCount < strandCount);
			if (remappingRequired)
			{
				using (var remapping = new StrandClusterRemapping(lodChain.clusterSet, Allocator.Temp))
				{
					// apply to strands
					remapping.ApplyShuffle(strandGroup.rootUV, 0, 1, strandCount);
					remapping.ApplyShuffle(strandGroup.rootScale, 0, 1, strandCount);

					HairAssetUtility.DeclareParticleStride(strandGroup, out var strandParticleOffset, out var strandParticleStride);
					//	.Sequential
					//		strandParticleOffset = strandParticleCount;
					//		strandParticleStride = 1;
					//	.Interleaved
					//		strandParticleOffset = 1;
					//		strandParticleStride = strandCount;

					for (int i = 0; i != strandParticleCount; i++)
					{
						remapping.ApplyShuffle(strandGroup.particlePosition,
							attrOffset: strandParticleStride * i,
							attrStride: strandParticleOffset,
							attrCount: strandCount);
					}

					if (strandGroup.particleFeatures.HasFlag(HairAsset.StrandGroup.ParticleFeatures.TexCoord))
					{
						for (int i = 0; i != strandParticleCount; i++)
						{
							remapping.ApplyShuffle(strandGroup.particleTexCoord,
								attrOffset: strandParticleStride * i,
								attrStride: strandParticleOffset,
								attrCount: strandCount);
						}
					}

					if (strandGroup.particleFeatures.HasFlag(HairAsset.StrandGroup.ParticleFeatures.Diameter))
					{
						for (int i = 0; i != strandParticleCount; i++)
						{
							remapping.ApplyShuffle(strandGroup.particleDiameter,
								attrOffset: strandParticleStride * i,
								attrStride: strandParticleOffset,
								attrCount: strandCount);
						}
					}

					/* old particle shuffle, for reference
					switch (strandGroup.particleMemoryLayout)
					{
						case HairAsset.MemoryLayout.Sequential:
							for (int i = 0; i != strandParticleCount; i++)
							{
								remapping.ApplyShuffle(strandGroup.particlePosition,
									attrOffset: i,
									attrStride: strandParticleCount,
									attrCount: strandCount);
							}
							break;

						case HairAsset.MemoryLayout.Interleaved:
							for (int i = 0; i != strandParticleCount; i++)
							{
								remapping.ApplyShuffle(strandGroup.particlePosition,
									attrOffset: i * strandCount,
									attrStride: 1,
									attrCount: strandCount);
							}
							break;
					}
					*/

					for (int i = 0; i != strandGroup.lodCount; i++)
					{
						remapping.ApplyShuffle(strandGroup.lodGuideIndex, i * strandCount, 1, strandCount);
						remapping.ApplyShuffle(strandGroup.lodGuideCarry, i * strandCount, 1, strandCount);
						remapping.ApplyShuffle(strandGroup.lodGuideReach, i * strandCount, 1, strandCount);
					}

					// apply to indices (since strands have now moved)
					remapping.ApplyRemapping(strandGroup.lodGuideIndex);
				}
			}

			// dispose lod chain
			lodChain.Dispose();
		}

		static unsafe void BuildBaseLODGenerated(ref LODChain lodChain, in HairAsset.StrandGroup strandGroup, HairAsset hairAsset)
		{
			ref readonly var settingsClusters = ref hairAsset.settingsLODClusters;
			ref readonly var settings = ref settingsClusters.baseLODParamsGenerated;

			var clusterCount = Mathf.RoundToInt(strandGroup.strandCount * settings.baseLODClusterQuantity);
			if (clusterCount > strandGroup.strandCount)
				clusterCount = strandGroup.strandCount;
			if (clusterCount < 1)
				clusterCount = 1;

			if (lodChain.clusterSet.ExpandProcedural(clusterCount, settingsClusters.clusterAllocation, settingsClusters.clusterAllocationOrder, settingsClusters.clusterRefinement ? settingsClusters.clusterRefinementIterations : 0))
			{
				lodChain.clusterSet.Commit();
				lodChain.Increment();
			}
		}

		static unsafe void BuildBaseLODUVMapped(ref LODChain lodChain, in HairAsset.StrandGroup strandGroup, HairAsset hairAsset)
		{
			ref readonly var settingsClusters = ref hairAsset.settingsLODClusters;
			ref readonly var settings = ref hairAsset.settingsLODClusters.baseLODParamsUVMapped;

			var strandCount = strandGroup.strandCount;

			// early out if no readable cluster maps
			var clusterMaps = settings.baseLODClusterMaps;
			var clusterMapsReadable = 0;
			{
				if (clusterMaps != null)
				{
					foreach (var clusterMap in clusterMaps)
					{
						if (clusterMap != null && clusterMap.isReadable)
							clusterMapsReadable++;
					}
				}

				if (clusterMapsReadable == 0)
					return;
			}

			// add levels from cluster maps
#if HAS_PACKAGE_UNITY_COLLECTIONS_1_3_0
			using (var clusterLookupColor = new UnsafeParallelHashMap<Color, int>(strandCount, Allocator.Temp))
			using (var clusterLookupLabel = new UnsafeParallelHashMap<uint, int>(strandCount, Allocator.Temp))
#else
			using (var clusterLookupColor = new UnsafeHashMap<Color, int>(strandCount, Allocator.Temp))
			using (var clusterLookupLabel = new UnsafeHashMap<uint, int>(strandCount, Allocator.Temp))
#endif
			using (var strandCluster = new UnsafeList<int>(strandCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
			{
				var strandClusterPtr = strandCluster.Ptr;

				foreach (var clusterMap in clusterMaps)
				{
					if (clusterMap == null || clusterMap.isReadable == false)
						continue;

					// build strand->cluster
					var clusterCount = 0;

					switch (settings.baseLODClusterFormat)
					{
						case HairAsset.SettingsLODClusters.BaseLODClusterMapFormat.OneClusterPerColor:
							{
								clusterLookupColor.Clear();

								for (int i = 0; i != strandCount; i++)
								{
									var x = Mathf.RoundToInt(strandGroup.rootUV[i].x * (clusterMap.width - 1));
									var y = Mathf.RoundToInt(strandGroup.rootUV[i].y * (clusterMap.height - 1));

									var clusterColor = clusterMap.GetPixel(x, y, 0);
									if (clusterLookupColor.TryGetValue(clusterColor, out var cluster) == false)
									{
										cluster = clusterCount++;
										clusterLookupColor.Add(clusterColor, cluster);
									}

									strandClusterPtr[i] = cluster;
								}
							}
							break;

						case HairAsset.SettingsLODClusters.BaseLODClusterMapFormat.OneClusterPerVisualCluster:
							{
								clusterLookupLabel.Clear();

#if USE_DERIVED_CACHE
								var clusterMapLabels = DerivedCache.GetOrCreate(clusterMap,
									clusterMapArg =>
									{
										return new Texture2DLabels(clusterMapArg, clusterMapArg.wrapMode, Allocator.Persistent);
									}
								);
#else
								using (var clusterMapLabels = new Texture2DLabels(clusterMap, clusterMap.wrapMode, Allocator.Temp))
#endif
								{
									for (int i = 0; i != strandCount; i++)
									{
										var x = Mathf.RoundToInt(strandGroup.rootUV[i].x * (clusterMap.width - 1));
										var y = Mathf.RoundToInt(strandGroup.rootUV[i].y * (clusterMap.height - 1));

										var clusterLabel = clusterMapLabels.GetLabel(x, y);
										if (clusterLookupLabel.TryGetValue(clusterLabel, out var cluster) == false)
										{
											cluster = clusterCount++;
											clusterLookupLabel.Add(clusterLabel, cluster);
										}

										strandClusterPtr[i] = cluster;
									}
								}
							}
							break;
					}

					// expand existing set
					if (lodChain.clusterSet.ExpandPreassigned(clusterCount, strandCluster))
					{
						if (settingsClusters.clusterRefinement)
						{
							lodChain.clusterSet.Refine(settingsClusters.clusterRefinementIterations);
						}

						lodChain.clusterSet.Commit();
						lodChain.Increment();
					}
				}
			}
		}

		static unsafe void BuildHighLODAutomatic(ref LODChain lodChain, in HairAsset.StrandGroup strandGroup, HairAsset hairAsset)
		{
			ref readonly var settingsClusters = ref hairAsset.settingsLODClusters;
			ref readonly var settings = ref hairAsset.settingsLODClusters.highLODParamsAutomatic;

			var clusterCountMin = lodChain.clusterSet.dataDesc.clusterCount;
			if (clusterCountMin == 0)
				return;

			var clusterCountMax = Mathf.RoundToInt(settings.highLODClusterQuantity * strandGroup.strandCount);
			if (clusterCountMax > strandGroup.strandCount)
				clusterCountMax = strandGroup.strandCount;
			if (clusterCountMax < 1)
				clusterCountMax = 1;

			var logS = Mathf.Log(settings.highLODClusterExpansion);
			var logR = Mathf.Log((float)clusterCountMax / (float)clusterCountMin);
			var step = logR / logS;

			var incrementCount = Mathf.CeilToInt(step);
			if (incrementCount > 0)
			{
				for (int i = 0; i != incrementCount; i++)
				{
					//     .---steps---.
					// 0---A---B---C---1
					// min           max

					var t = (i + 1) / (float)incrementCount;
					var s = clusterCountMin * Mathf.Pow(settings.highLODClusterExpansion, t * step);
					
					var clusterCount = Mathf.RoundToInt(s);
					if (clusterCount < lodChain.strandCount)
					{
						if (lodChain.clusterSet.ExpandProcedural(clusterCount, settingsClusters.clusterAllocation, settingsClusters.clusterAllocationOrder, settingsClusters.clusterRefinement ? settingsClusters.clusterRefinementIterations : 0))
						{
							lodChain.clusterSet.Commit();
							lodChain.Increment();
						}
					}
					else
					{
						BuildHighLODAllStrands(ref lodChain, strandGroup, hairAsset);
						break;
					}
				}
			}
		}

		static unsafe void BuildHighLODManual(ref LODChain lodChain, in HairAsset.StrandGroup strandGroup, HairAsset hairAsset)
		{
			ref readonly var settingsClusters = ref hairAsset.settingsLODClusters;
			ref readonly var settings = ref settingsClusters.highLODParamsManual;

			for (int i = 0; i != settings.highLODClusterQuantities.Length; i++)
			{
				var clusterCount = Mathf.RoundToInt(strandGroup.strandCount * settings.highLODClusterQuantities[i]);
				if (clusterCount > strandGroup.strandCount)
					clusterCount = strandGroup.strandCount;
				if (clusterCount < 1)
					clusterCount = 1;

				if (clusterCount < lodChain.strandCount)
				{
					if (lodChain.clusterSet.ExpandProcedural(clusterCount, settingsClusters.clusterAllocation, settingsClusters.clusterAllocationOrder, settingsClusters.clusterRefinement ? settingsClusters.clusterRefinementIterations : 0))
					{
						lodChain.clusterSet.Commit();
						lodChain.Increment();
					}
				}
				else
				{
					BuildHighLODAllStrands(ref lodChain, strandGroup, hairAsset);
					break;
				}
			}
		}

		static unsafe void BuildHighLODAllStrands(ref LODChain lodChain, in HairAsset.StrandGroup strandGroup, HairAsset hairAsset)
		{
			using (var strandIndices = StrandClusterContext.AllocateRange(0, strandGroup.strandCount, Allocator.Temp))
			{
				if (lodChain.clusterSet.ExpandPreassigned(strandGroup.strandCount, strandIndices))
				{
					lodChain.clusterSet.Commit();
					lodChain.Increment();
				}
			}
		}

		static unsafe bool GenerateRoots(in HairAssetProvisional.ProceduralRoots roots, in HairAsset.SettingsProcedural settings)
		{
			switch (settings.placement)
			{
				case HairAsset.SettingsProcedural.PlacementMode.Primitive:
					return GenerateRootsPrimitive(roots, settings);

				case HairAsset.SettingsProcedural.PlacementMode.Custom:
					return (settings.placementProvider)?.GenerateRoots(roots) ?? false;

				case HairAsset.SettingsProcedural.PlacementMode.Mesh:
					return GenerateRootsMesh(roots, settings);

				default:
					return false;
			}
		}

		static unsafe bool GenerateRootsPrimitive(in HairAssetProvisional.ProceduralRoots roots, in HairAsset.SettingsProcedural settings)
		{
			roots.GetUnsafePtrs(out var rootPos, out var rootDir, out var rootUV0, out var rootVar);

			var randSeq = new Unity.Mathematics.Random(257);

			switch (settings.placementPrimitive)
			{
				case HairAsset.SettingsProcedural.PrimitiveType.Curtain:
					{
						var step = 1.0f / (settings.strandCount - 1);

						var localDim = new Vector3(1.0f, 0.0f, 0.0f);
						var localDir = Vector3.down;

						for (int i = 0; i != settings.strandCount; i++)
						{
							var uv = new Vector2(i * step, 0.5f);

							rootPos[i] = new Vector3(localDim.x * (uv.x - 0.5f), 0.0f, 0.0f);
							rootDir[i] = localDir;
							rootUV0[i] = uv;
						}
					}
					break;

				case HairAsset.SettingsProcedural.PrimitiveType.StratifiedCurtain:
					{
						var step = 1.0f / settings.strandCount;

						var localDim = new Vector3(1.0f, 0.0f, step);
						var localDir = Vector3.down;

						for (int i = 0; i != settings.strandCount; i++)
						{
							var uvCell = randSeq.NextFloat2(0.0f, 1.0f);
							var uv = new Vector2((i + uvCell.x) * step, uvCell.y);

							rootPos[i] = new Vector3(localDim.x * (uv.x - 0.5f), 0.0f, localDim.z * (uv.y - 0.5f));
							rootDir[i] = localDir;
							rootUV0[i] = uv;
						}
					}
					break;

				case HairAsset.SettingsProcedural.PrimitiveType.Brush:
					{
						var localDim = new Vector3(1.0f, 0.0f, 1.0f);
						var localDir = Vector3.down;

						for (int i = 0; i != settings.strandCount; i++)
						{
							var uv = randSeq.NextFloat2(0.0f, 1.0f);

							rootPos[i] = new Vector3(localDim.x * (uv.x - 0.5f), 0.0f, localDim.z * (uv.y - 0.5f));
							rootDir[i] = localDir;
							rootUV0[i] = uv;
						}
					}
					break;

				case HairAsset.SettingsProcedural.PrimitiveType.Cap:
					{
						for (int i = 0; i != settings.strandCount; i++)
						{
							var localDir = randSeq.NextFloat3Direction();
							if (localDir.y < 0.0f)
								localDir.y = -localDir.y;

							rootPos[i] = new Vector3(localDir.x * 0.5f, localDir.y * 0.5f, localDir.z * 0.5f);
							rootDir[i] = localDir;
							rootUV0[i] = new Vector2(localDir.x * 0.5f + 0.5f, localDir.z * 0.5f + 0.5f);
						}
					}
					break;
			}

			for (int i = 0; i != settings.strandCount; i++)
			{
				rootVar[i] = HairAssetProvisional.ProceduralRoots.RootParameters.defaults;
			}

			return true;// success
		}

		static unsafe bool GenerateRootsMesh(in HairAssetProvisional.ProceduralRoots roots, in HairAsset.SettingsProcedural settings)
		{
			var placementMesh = settings.placementMesh;
			if (placementMesh == null)
				return false;

			roots.GetUnsafePtrs(out var rootPos, out var rootDir, out var rootUV0, out var rootVar);

			using (var meshData = Mesh.AcquireReadOnlyMeshData(settings.placementMesh))
			using (var meshSampler = new TriMeshSampler(meshData[0], 0, Allocator.Temp, (uint)settings.placementMeshGroups))
			{
				bool IsTextureReadable(Texture2D texture)
				{
					return (texture != null && texture.isReadable);
				}

				if (IsTextureReadable(settings.mappedDensity))
				{
					var density = settings.mappedDensity;
					var densityThreshold = new Unity.Mathematics.Random(257);

					for (int i = 0; i != settings.strandCount; i++)
					{
						var sample = meshSampler.Next();
						var sampleDensity = density.GetPixelBilinear(sample.uv0.x, sample.uv0.y, mipLevel: 0);
						var sampleIteration = 0;// safety

						while (sampleDensity.r < densityThreshold.NextFloat() && sampleIteration++ < 200)
						{
							sample = meshSampler.Next();
							sampleDensity = density.GetPixelBilinear(sample.uv0.x, sample.uv0.y, mipLevel: 0);
						}

						rootPos[i] = sample.position;
						rootDir[i] = sample.normal;
						rootUV0[i] = sample.uv0;
					}
				}
				else
				{
					for (int i = 0; i != settings.strandCount; i++)
					{
						var sample = meshSampler.Next();
						rootPos[i] = sample.position;
						rootDir[i] = sample.normal;
						rootUV0[i] = sample.uv0;
					}
				}

				// apply painted direction
				if (IsTextureReadable(settings.mappedDirection))
				{
					switch (settings.mappedDirection.format)
					{
						case TextureFormat.DXT5:
							{
								for (int i = 0; i != settings.strandCount; i++)
								{
									Vector4 dxt5nm = settings.mappedDirection.GetPixelBilinear(rootUV0[i].x, rootUV0[i].y, mipLevel: 0);
									{
										dxt5nm.x *= dxt5nm.w;
									}
									Vector3 n;
									{
										n.x = dxt5nm.x * 2.0f - 1.0f;
										n.y = dxt5nm.y * 2.0f - 1.0f;
										n.z = Mathf.Sqrt(1.0f - Mathf.Clamp01(n.x * n.x + n.y * n.y));
									}
									rootDir[i] = Vector3.Normalize(n);
								}
							}
							break;

						default:
							{
								for (int i = 0; i != settings.strandCount; i++)
								{
									Vector4 xyz = settings.mappedDirection.GetPixelBilinear(rootUV0[i].x, rootUV0[i].y, mipLevel: 0);
									Vector3 n;
									{
										n.x = 2.0f * xyz.x - 1.0f;
										n.y = 2.0f * xyz.y - 1.0f;
										n.z = 2.0f * xyz.z - 1.0f;
									}
									rootDir[i] = Vector3.Normalize(n);
								}
							}
							break;
					}
				}
				else
				{
					for (int i = 0; i != settings.strandCount; i++)
					{
						rootDir[i] = Vector3.Normalize(rootDir[i]);
					}
				}

				// apply painted parameters
				if (IsTextureReadable(settings.mappedParameters))
				{
					var rootVarSampled = (Vector4*)rootVar;

					for (int i = 0; i != settings.strandCount; i++)
					{
						rootVarSampled[i] = (Vector4)settings.mappedParameters.GetPixelBilinear(rootUV0[i].x, rootUV0[i].y, mipLevel: 0);
					}
				}
				else
				{
					for (int i = 0; i != settings.strandCount; i++)
					{
						rootVar[i] = HairAssetProvisional.ProceduralRoots.RootParameters.defaults;
					}
				}
			}

			return true;// success
		}

		static unsafe bool GenerateStrands(in HairAssetProvisional.ProceduralStrands strands, in HairAssetProvisional.ProceduralRoots roots, in HairAsset.SettingsProcedural settings, HairAsset.MemoryLayout memoryLayout)
		{
			var particleInterval = settings.strandLength / (settings.strandParticleCount - 1);
			var particleIntervalVariation = settings.strandLengthVariation ? settings.strandLengthVariationAmount : 0.0f;
			var particleIntervalRandSeq = new Unity.Mathematics.Random(257);
			var particleDiameter = settings.strandDiameter * 0.001f;
			var particleDiameterVariation = settings.strandDiameterVariation ? settings.strandDiameterVariationAmount : 0.0f;
			var particleDiameterRandSeq = new Unity.Mathematics.Random(3432);

			var tipScaleVariation = settings.tipScaleVariation ? settings.tipScaleVariationAmount : 0.0f;
			var tipScaleRandSeq = new Unity.Mathematics.Random(7546);
			var tipScaleOffsetVariation = settings.tipScaleOffsetVariation ? settings.tipScaleOffsetVariationAmount : 0.0f;
			var tipScaleOffsetRandSeq = new Unity.Mathematics.Random(9277);

			var curlRadiusVariation = settings.curlVariation ? settings.curlVariationRadius : 0.0f;
			var curlRadiusRandSeq = new Unity.Mathematics.Random(709);
			var curlSlopeVariation = settings.curlVariation ? settings.curlVariationSlope : 0.0f;
			var curlSlopeRandSeq = new Unity.Mathematics.Random(1171);
			var curlPlaneRandSeq = new Unity.Mathematics.Random(457);

			static float NextScale(ref Unity.Mathematics.Random randSeq, float variation)
			{
				if (variation > 0.0f)
					return Mathf.Lerp(1.0f, randSeq.NextFloat(), variation);
				else
					return 1.0f;
			}

			static Vector3 NextVectorInPlane(ref Mathematics.Random randSeq, in Vector3 n)
			{
				Vector3 r;
				{
					do r = Vector3.ProjectOnPlane(randSeq.NextFloat3Direction(), n);
					while (Vector3.SqrMagnitude(r) < 1e-5f);
				}
				return r;
			};

			using (var longOperation = new LongOperationScope("Generating strands"))
			{
				roots.GetUnsafePtrs(out var rootPos, out var rootDir, out var rootUV0, out var rootVar);
				strands.GetUnsafePtrs(out var rootScalePtr, out var particlePositionPtr);

				for (int i = 0; i != settings.strandCount; i++)
				{
					longOperation.UpdateStatus("Strand", i, settings.strandCount);

					// resolve root diameter and tapering
					rootScalePtr[i].x = 0.0f;// completed in FinalizeStrandGroup(..)
					rootScalePtr[i].y = rootVar[i].normalizedStrandDiameter * particleDiameter * NextScale(ref particleDiameterRandSeq, particleDiameterVariation);
					rootScalePtr[i].z = settings.tipScaleOffset * NextScale(ref tipScaleOffsetRandSeq, tipScaleOffsetVariation);
					rootScalePtr[i].w = settings.tipScale * NextScale(ref tipScaleRandSeq, tipScaleVariation);

					// resolve particle positions
					var step = rootVar[i].normalizedStrandLength * particleInterval * NextScale(ref particleIntervalRandSeq, particleIntervalVariation);
					var curPos = rootPos[i];
					var curDir = rootDir[i];

					HairAssetUtility.DeclareStrandIterator(memoryLayout, settings.strandCount, settings.strandParticleCount, i, out var strandParticleBegin, out var strandParticleStride, out var strandParticleEnd);

					if (settings.curl)
					{
						var curPlaneU = Vector3.Normalize(NextVectorInPlane(ref curlPlaneRandSeq, curDir));
						var curPlaneV = Vector3.Cross(curPlaneU, curDir);

						var targetRadius = rootVar[i].normalizedCurlRadius * settings.curlRadius * 0.01f * NextScale(ref curlRadiusRandSeq, curlRadiusVariation);
						var targetSlope = rootVar[i].normalizedCurlSlope * settings.curlSlope * NextScale(ref curlSlopeRandSeq, curlSlopeVariation);

						var stepPlane = step * Mathf.Cos(0.5f * Mathf.PI * targetSlope);
						if (stepPlane > 1.0f * targetRadius)
							stepPlane = 1.0f * targetRadius;

						var stepSlope = 0.0f;
						{
							switch (settings.curlSamplingStrategy)
							{
								// maintain slope
								case HairAsset.SettingsProcedural.CurlSamplingStrategy.RelaxStrandLength:
									stepSlope = step * Mathf.Sin(0.5f * Mathf.PI * targetSlope);
									break;

								// maintain strand length
								case HairAsset.SettingsProcedural.CurlSamplingStrategy.RelaxCurlSlope:
									stepSlope = Mathf.Sqrt(step * step - stepPlane * stepPlane);
									break;
							}
						}

						var a = (stepPlane > 0.0f) ? 2.0f * Mathf.Asin(stepPlane / (2.0f * targetRadius)) : 0.0f;
						var t = 0;

						curPos -= curPlaneU * targetRadius;

						for (int j = strandParticleBegin; j != strandParticleEnd; j += strandParticleStride)
						{
							var du = targetRadius * Mathf.Cos(t * a);
							var dv = targetRadius * Mathf.Sin(t * a);
							var dn = stepSlope * t;

							particlePositionPtr[j] =
								curPos +
								du * curPlaneU +
								dv * curPlaneV +
								dn * curDir;

							t++;
						}
					}
					else
					{
						for (int j = strandParticleBegin; j != strandParticleEnd; j += strandParticleStride)
						{
							particlePositionPtr[j] = curPos;
							curPos += step * curDir;
						}
					}
				}
			}

			return true;// success
		}

		struct ResampleBlend
		{
			public int srcIndex0;
			public int srcIndex1;
			public float srcBlendFrac;
		}

		static unsafe void Resample(Vector3* srcPos, int srcCount, Vector3* dstPos, int dstCount, ResampleBlend* dstResolve, int iterations)
		{
			var length = 0.0f;
			{
				for (int i = 1; i != srcCount; i++)
				{
					length += Vector3.Distance(srcPos[i], srcPos[i - 1]);
				}
			}

			var dstLength = length;
			var dstSpacing = dstLength / (dstCount - 1);

			ResampleWithHint(srcPos, srcCount, out var srcIndex, dstPos, dstCount, out var dstIndex, dstSpacing, dstResolve);

			// run a couple of iterations
			for (int i = 0; i != iterations; i++)
			{
				if (dstIndex < dstCount || srcIndex < srcCount)
				{
					var remainder = Vector3.Distance(srcPos[srcCount - 1], dstPos[dstIndex - 1]);

					dstLength = (dstIndex - 1) * dstSpacing + remainder;
					dstSpacing = dstLength / (dstCount - 1);

					ResampleWithHint(srcPos, srcCount, out srcIndex, dstPos, dstCount, out dstIndex, dstSpacing, dstResolve);
				}
				else
				{
					break;
				}
			}

			// extrapolate tail for vertices that remain to be placed
			if (dstIndex < dstCount)
			{
				var dstPosPrev = dstPos[dstIndex - 1];
				var dstDirTail = Vector3.Normalize(srcPos[srcCount - 1] - dstPosPrev);

				while (dstIndex < dstCount)
				{
					// extrapolated blend weights are a continuation of the last source vertex
					dstResolve[dstIndex].srcIndex0 = srcCount - 1;
					dstResolve[dstIndex].srcIndex1 = srcCount - 1;
					dstResolve[dstIndex].srcBlendFrac = 0.0f;

					dstPos[dstIndex] = dstPosPrev + dstDirTail * dstSpacing;
					dstPosPrev = dstPos[dstIndex++];
				}
			}
		}

		static unsafe void ResampleWithHint(Vector3* srcPos, int srcCount, out int srcIndex, Vector3* dstPos, int dstCount, out int dstIndex, float dstSpacing, ResampleBlend* dstResolve)
		{
			dstPos[0] = srcPos[0];

			dstResolve[0].srcIndex0 = 0;
			dstResolve[0].srcIndex1 = 0;
			dstResolve[0].srcBlendFrac = 0.0f;

			dstIndex = 1;
			srcIndex = 1;

			var dstPosPrev = dstPos[0];
			var dstSpacingSq = dstSpacing * dstSpacing;

			while (srcIndex < srcCount && dstIndex < dstCount)
			{
				var r = srcPos[srcIndex] - dstPosPrev;
				var rNormSq = Vector3.SqrMagnitude(r);
				if (rNormSq >= dstSpacingSq)
				{
					// find point on line between [srcIndex] and [srcIndex-1]
					var n = Vector3.Normalize(srcPos[srcIndex] - srcPos[srcIndex - 1]);
					var p = srcPos[srcIndex] - n * Vector3.Dot(n, r);

					// b = sqrt(cc - aa) 
					var aa = Vector3.SqrMagnitude(dstPosPrev - p);
					var bb = dstSpacingSq - aa;

					if (bb > float.Epsilon)
						dstPos[dstIndex] = p + n * Mathf.Sqrt(bb);
					else
						dstPos[dstIndex] = p;

					dstResolve[dstIndex].srcIndex0 = srcIndex - 1;
					dstResolve[dstIndex].srcIndex1 = srcIndex;
					dstResolve[dstIndex].srcBlendFrac = Vector3.Dot(n, dstPos[dstIndex] - srcPos[srcIndex - 1]);

					dstPosPrev = dstPos[dstIndex++];
				}
				else
				{
					srcIndex++;
				}
			}
		}

		unsafe struct LODChain : IDisposable
		{
			public LongOperationScope longOperation;

			public UnsafeClusterSet clusterSet;

			public int lodCount;
			public NativeList<int> lodGuideCount;
			public NativeList<int> lodGuideIndex;
			public NativeList<float> lodGuideCarry;
			public NativeList<float> lodGuideReach;

			public int strandCount;
			public UnsafeList<int> strandGuide;
			public UnsafeList<float> strandCarry;
			public UnsafeList<float> strandReach;

			public LODChain(int lodCapacity, in HairAsset.StrandGroup strandGroup, HairAsset.StrandClusterMode strandClusterMode, ClusterVoid clusterVoid, Allocator allocator)
			{
				this.longOperation = new LongOperationScope("Building clusters");
				this.longOperation.UpdateStatus("Level 1 / ?", 0.0f);

				this.clusterSet = StrandClusterUtility.CreateEmptySet(0, clusterVoid, strandGroup, strandClusterMode, Allocator.Temp);
					
				this.lodCount = 0;
				this.lodGuideCount = new NativeList<int>(lodCapacity, allocator);
				this.lodGuideIndex = new NativeList<int>(lodCapacity * strandGroup.strandCount, allocator);
				this.lodGuideCarry = new NativeList<float>(lodCapacity * strandGroup.strandCount, allocator);
				this.lodGuideReach = new NativeList<float>(lodCapacity * strandGroup.strandCount, allocator);

				this.strandCount = strandGroup.strandCount;
				this.strandGuide = new UnsafeList<int>(strandGroup.strandCount, allocator, NativeArrayOptions.UninitializedMemory);
				this.strandCarry = new UnsafeList<float>(strandGroup.strandCount, allocator, NativeArrayOptions.UninitializedMemory);
				this.strandReach = new UnsafeList<float>(strandGroup.strandCount, allocator, NativeArrayOptions.UninitializedMemory);
			}

			public void Dispose()
			{
				longOperation.Dispose();

				clusterSet.Dispose();

				lodGuideCount.Dispose();
				lodGuideIndex.Dispose();
				lodGuideCarry.Dispose();
				lodGuideReach.Dispose();

				strandGuide.Dispose();
				strandCarry.Dispose();
				strandReach.Dispose();
			}

			public bool Increment()
			{
				var clusterCountPrev = (lodCount == 0) ? 0 : lodGuideCount[lodGuideCount.Length - 1];
				if (clusterCountPrev < clusterSet.dataDesc.clusterCount)
				{
					var strandGuidePtr = strandGuide.Ptr;
					var strandCarryPtr = strandCarry.Ptr;
					var strandReachPtr = strandReach.Ptr;

					for (int i = 0; i != strandCount; i++)
					{
						int k = clusterSet.dataDesc.sampleClusterPtr[i];
						{
							strandGuidePtr[i] = clusterSet.dataDesc.clusterGuidePtr[k];
							strandCarryPtr[i] = clusterSet.dataDesc.clusterCarryPtr[k];
							strandReachPtr[i] = clusterSet.dataDesc.clusterReachPtr[k];

							// non-primary strands carry nothing
							if (strandGuidePtr[i] != i)
							{
								strandCarryPtr[i] = 0.0f;
							}
						}
					}

					lodCount++;
					lodGuideCount.Add(clusterSet.dataDesc.clusterCount);
					lodGuideIndex.AddRange(strandGuidePtr, strandCount);
					lodGuideCarry.AddRange(strandCarryPtr, strandCount);
					lodGuideReach.AddRange(strandReachPtr, strandCount);

					longOperation.UpdateStatus("Level " + lodCount + " / ?", 0.0f);
					return true;
				}
				else
				{
					return false;
				}
			}

			/* old preassigned method, kept for reference
			public bool TryAppend(ClusterSet nextClusters)
			{
				if (nextClusters.dataDesc.clusterCount > clusterSet.dataDesc.clusterCount)
				{
					// inject guides from previous set in chain
					if (nextClusters.InjectGuidesFrom(clusterSet))
					{
						// replace current set
						clusterSet.Dispose();
						clusterSet = nextClusters;

						// update lod guide index
						for (int i = 0; i != strandCount; i++)
						{
							int k = clusterSet.dataDesc.sampleClusterPtr[i];
							{
								strandGuidePtr[i] = clusterSet.dataDesc.clusterGuidePtr[k];
								strandCarryPtr[i] = clusterSet.dataDesc.clusterCarryPtr[k];
							}
						}

						lodCount++;
						lodGuideCount.Add(clusterSet.dataDesc.clusterCount);
						lodGuideIndex.AddRange(strandGuidePtr, strandCount);
						lodGuideCarry.AddRange(strandCarryPtr, strandCount);

						// succcess
						return true;
					}
					else// injection will fail if e.g. 3 guides in lower level all point to 1 cluster in current
					{
						Debug.LogWarningFormat("Failed to append to LOD chain at depth {0}. At least one cluster in specified set overlaps more than one guide from previous set in chain.", lodCount);
					}
				}
				else
				{
					Debug.LogWarningFormat("Failed to append to LOD chain at depth {0}. Number of clusters in specified set does not exceed that of previous set in chain.", lodCount);
				}

				// failed to append
				return false;
			}
			*/
		}

		public unsafe struct StrandClusterUtility
		{
			public static UnsafeClusterSet CreateEmptySet(int clusterCapacity, ClusterVoid clusterEmpty, in HairAsset.StrandGroup strandGroup, HairAsset.StrandClusterMode strandClusterMode, Allocator allocator)
			{
				HairAssetUtility.DeclareParticleStride(strandGroup, out var strandParticleOffset, out var strandParticleStride);

				var sampleCount = strandGroup.strandCount;
				var samplePositionOffset = strandParticleOffset;
				var samplePositionStride = strandParticleStride;
				var samplePositionCount = strandGroup.strandParticleCount;
				{
					switch (strandClusterMode)
					{
						case HairAsset.StrandClusterMode.Roots: samplePositionCount = 1; break;
						case HairAsset.StrandClusterMode.Strands: break;
						case HairAsset.StrandClusterMode.Strands3pt: samplePositionStride *= (samplePositionCount / 2); samplePositionCount = 3; break;
					}
				}

				return new UnsafeClusterSet(clusterCapacity, clusterEmpty, sampleCount, samplePositionOffset, samplePositionStride, samplePositionCount, allocator);
			}

			public static StrandClusterContext BindStrandData(ref UnsafeClusterSet clusterSet, in HairAsset.StrandGroup strandGroup, Allocator allocator)
			{
				return new StrandClusterContext(ref clusterSet, strandGroup, allocator);
			}
		}

		public unsafe struct StrandClusterContext : IDisposable
		{
			ulong gchSamplePosition;
			UnsafeList<int> sampleIndices;
			UnsafeList<float> sampleWeights;

			public StrandClusterContext(ref UnsafeClusterSet clusterSet, in HairAsset.StrandGroup strandGroup, Allocator allocator)
			{
				this.sampleIndices = AllocateRange(0, strandGroup.strandCount, Allocator.Temp);
				this.sampleWeights = new UnsafeList<float>(strandGroup.strandCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
				{
					fixed (Vector4* rootScalePtr = strandGroup.rootScale)
					{
						var sampleWeightsPtr = sampleWeights.Ptr;
						for (int i = 0; i != strandGroup.strandCount; i++)
						{
							ref readonly var L = ref rootScalePtr[i].x;// normalized length
							ref readonly var H = ref rootScalePtr[i].y;// normalized diameter
							sampleWeightsPtr[i] = L * H * H;// weigh strands by volume
						}
					}
				}

				clusterSet.dataDesc.samplePositionPtr = (Vector3*)UnsafeUtility.PinGCArrayAndGetDataAddress(strandGroup.particlePosition, out this.gchSamplePosition);
				clusterSet.dataDesc.sampleResolvePtr = sampleIndices.Ptr;
				clusterSet.dataDesc.sampleWeightPtr = sampleWeights.Ptr;
			}

			public void Dispose()
			{
				UnsafeUtility.ReleaseGCObject(gchSamplePosition);
				sampleIndices.Dispose();
				sampleWeights.Dispose();
			}

			public static UnsafeList<int> AllocateRange(int offset, int length, Allocator allocator)
			{
				var range = new UnsafeList<int>(length, allocator, NativeArrayOptions.UninitializedMemory);
				var rangePtr = range.Ptr;
				{
					for (int i = 0; i != length; i++)
					{
						rangePtr[i] = i + offset;
					}
				}
				return range;
			}
		}

		unsafe struct StrandClusterRemapping : IDisposable
		{
			public UnsafeList<int> strandRemapSrc;// maps final strand index -> old strand index
			public UnsafeList<int> strandRemapDst;// maps old strand index -> final strand index

			public int* strandRemapSrcPtr;
			public int* strandRemapDstPtr;

			public StrandClusterRemapping(in UnsafeClusterSet clusterSet, Allocator allocator)
			{
				strandRemapSrc = new UnsafeList<int>(clusterSet.dataDesc.sampleCount, allocator, NativeArrayOptions.UninitializedMemory);
				strandRemapDst = new UnsafeList<int>(clusterSet.dataDesc.sampleCount, allocator, NativeArrayOptions.UninitializedMemory);

				strandRemapSrcPtr = strandRemapSrc.Ptr;
				strandRemapDstPtr = strandRemapDst.Ptr;

				// sort clusters by depth first and guide second
				using (var sortedClusters = new UnsafeList<ulong>(clusterSet.dataDesc.clusterCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
				{
					var sortedClustersPtr = sortedClusters.Ptr;

					for (int k = 0; k != clusterSet.dataDesc.clusterCount; k++)
					{
						var sortDepth = (ulong)clusterSet.dataDesc.clusterDepthPtr[k] << 32;
						var sortGuide = (ulong)clusterSet.dataDesc.clusterGuidePtr[k];
						{
							sortedClustersPtr[k] = sortDepth | sortGuide;
						}
					}

					NativeSortExtension.Sort(sortedClustersPtr, clusterSet.dataDesc.clusterCount);

					// write remapping table for guides from sorted clusters
					for (int k = 0; k != clusterSet.dataDesc.clusterCount; k++)
					{
						var guide = (int)(sortedClustersPtr[k] & 0xffffffffuL);
						{
							strandRemapSrcPtr[k] = guide;
							strandRemapDstPtr[guide] = k;
						}
					}
				}

				var remainingCount = clusterSet.dataDesc.sampleCount - clusterSet.dataDesc.clusterCount;
				if (remainingCount > 0)
				{
					// sort remaining (non-guide) strands by remapped guide first and index second
					using (var sortedRemaining = new UnsafeList<ulong>(remainingCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
					{
						var sortedRemainingPtr = sortedRemaining.Ptr;

						for (int i = 0, j = 0; i != clusterSet.dataDesc.sampleCount; i++)
						{
							var guide = clusterSet.dataDesc.clusterGuidePtr[clusterSet.dataDesc.sampleClusterPtr[i]];
							if (guide != i)
							{
								var sortGuide = (ulong)strandRemapDstPtr[guide] << 32;
								var sortIndex = (ulong)i;
								{
									sortedRemainingPtr[j++] = sortGuide | sortIndex;
								}
							}
						}

						//TODO maybe make it configurable whether/how to sort this data?
						NativeSortExtension.Sort(sortedRemainingPtr, remainingCount);

						// write remapping table for remaining (non-guide) strands
						for (int i = 0, j = clusterSet.dataDesc.clusterCount; i != remainingCount; i++, j++)
						{
							var index = (int)(sortedRemainingPtr[i] & 0xffffffffuL);
							{
								strandRemapSrcPtr[j] = index;
								strandRemapDstPtr[index] = j;
							}
						}
					}
				}
			}

			public void Dispose()
			{
				strandRemapSrc.Dispose();
				strandRemapDst.Dispose();
			}

			public void ApplyRemapping(int* indexPtr, int indexCount)
			{
				for (int i = 0; i != indexCount; i++)
				{
					indexPtr[i] = strandRemapDstPtr[indexPtr[i]];
				}
			}

			public void ApplyRemapping(in NativeArray<int> indexBuffer)
			{
				ApplyRemapping((int*)indexBuffer.GetUnsafePtr(), indexBuffer.Length);
			}

			public void ApplyRemapping(int[] indexBuffer)
			{
				fixed (int* indexPtr = indexBuffer)
				{
					ApplyRemapping(indexPtr, indexBuffer.Length);
				}
			}

			public void ApplyShuffleUntyped(byte* attrPtr, int attrSize, int attrStride, int attrCount)
			{
				using (var buffer = new NativeArray<byte>(attrCount * attrSize, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
				{
					var bufferPtr = (byte*)buffer.GetUnsafePtr();

					// shuffle into temporary buffer
					for (int i = 0; i != attrCount; i++)
					{
						var copyDstPtr = bufferPtr + attrSize * i;
						var copySrcPtr = attrPtr + attrStride * strandRemapSrcPtr[i];

						UnsafeUtility.MemCpy(copyDstPtr, copySrcPtr, attrSize);
					}

					// copy back the shuffled data
					UnsafeUtility.MemCpyStride(
						attrPtr,        // dst
						attrStride,     // dst stride
						bufferPtr,      // src
						attrSize,       // src stride
						attrSize,       // size
						attrCount);     // count

					// copy back reference
					//
					//	for (int i = 0; i != attrCount; i++)
					//	{
					//		var attrDstPtr = attrPtr + attrStride * i;
					//		var attrSrcPtr = bufferPtr + attrSize * i;
					//		UnsafeUtility.MemCpy(attrDstPtr, attrSrcPtr, attrSize);
					//	}
				}
			}

			public void ApplyShuffle<T>(NativeArray<T> attrBuffer, int attrOffset, int attrStride, int attrCount) where T : struct
			{
				var attrPtr = (byte*)attrBuffer.GetUnsafePtr();
				var attrSize = UnsafeUtility.SizeOf<T>();

				ApplyShuffleUntyped(attrPtr + attrOffset * attrSize, attrSize, attrStride * attrSize, attrCount);
			}

			public void ApplyShuffle<T>(T[] attrBuffer, int attrOffset, int attrStride, int attrCount) where T : struct
			{
				var attrPtr = (byte*)UnsafeUtility.PinGCArrayAndGetDataAddress(attrBuffer, out ulong gcHandle);
				var attrSize = UnsafeUtility.SizeOf<T>();

				ApplyShuffleUntyped(attrPtr + attrOffset * attrSize, attrSize, attrStride * attrSize, attrCount);

				UnsafeUtility.ReleaseGCObject(gcHandle);
			}
		}
	}
}

```

`Editor/HairAssetBuilder.cs.meta`:

```meta
fileFormatVersion: 2
guid: 9eb2f7d61773d8e48a5887f880315474
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/HairAssetEditor.cs`:

```cs
using UnityEngine;
using UnityEngine.Rendering;
using UnityEditor;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

#if HAS_PACKAGE_UNITY_ALEMBIC
using UnityEngine.Formats.Alembic.Importer;
#endif

namespace Unity.DemoTeam.Hair
{
	using static HairGUILayout;

	[CustomEditor(typeof(HairAsset))]
	public class HairAssetEditor : Editor
	{
		Editor editorCustomData;
		Editor editorCustomPlacement;

		SerializedProperty _settingsBasic;
		SerializedProperty _settingsCustom;
		SerializedProperty _settingsCustom_settingsResolve;
		SerializedProperty _settingsAlembic;
		SerializedProperty _settingsAlembic_settingsResolve;
		SerializedProperty _settingsProcedural;
		SerializedProperty _settingsLODClusters;
		SerializedProperty _settingsLODClusters_baseLOD;
		SerializedProperty _settingsLODClusters_baseLODParamsGenerated;
		SerializedProperty _settingsLODClusters_baseLODParamsUVMapped;
		SerializedProperty _settingsLODClusters_highLOD;
		SerializedProperty _settingsLODClusters_highLODParamsAutomatic;
		SerializedProperty _settingsLODClusters_highLODParamsManual;

		SerializedProperty _strandGroups;
		SerializedProperty _strandGroupsAutoBuild;

		PreviewRenderUtility previewRenderer;
		Material previewMaterial;
		Vector2 previewAngle;
		float previewZoom;

		HairTopologyDesc[] previewMeshes;
		HairSim.VolumeData previewDataShared;
		HairSim.SolverData[] previewData;
		string previewDataChecksum;
		int[] previewLOD;

		void OnEnable()
		{
			_settingsBasic = serializedObject.FindProperty(nameof(HairAsset.settingsBasic));
			_settingsCustom = serializedObject.FindProperty(nameof(HairAsset.settingsCustom));
			_settingsCustom_settingsResolve = _settingsCustom.FindPropertyRelative(nameof(HairAsset.SettingsCustom.settingsResolve));
			_settingsAlembic = serializedObject.FindProperty(nameof(HairAsset.settingsAlembic));
			_settingsAlembic_settingsResolve = _settingsAlembic.FindPropertyRelative(nameof(HairAsset.SettingsAlembic.settingsResolve));
			_settingsProcedural = serializedObject.FindProperty(nameof(HairAsset.settingsProcedural));
			_settingsLODClusters = serializedObject.FindProperty(nameof(HairAsset.settingsLODClusters));
			_settingsLODClusters_baseLOD = _settingsLODClusters.FindPropertyRelative(nameof(HairAsset.SettingsLODClusters.baseLOD));
			_settingsLODClusters_baseLODParamsGenerated = _settingsLODClusters.FindPropertyRelative(nameof(HairAsset.SettingsLODClusters.baseLODParamsGenerated));
			_settingsLODClusters_baseLODParamsUVMapped = _settingsLODClusters.FindPropertyRelative(nameof(HairAsset.SettingsLODClusters.baseLODParamsUVMapped));
			_settingsLODClusters_highLOD = _settingsLODClusters.FindPropertyRelative(nameof(HairAsset.SettingsLODClusters.highLOD));
			_settingsLODClusters_highLODParamsAutomatic = _settingsLODClusters.FindPropertyRelative(nameof(HairAsset.SettingsLODClusters.highLODParamsAutomatic));
			_settingsLODClusters_highLODParamsManual = _settingsLODClusters.FindPropertyRelative(nameof(HairAsset.SettingsLODClusters.highLODParamsManual));

			_strandGroups = serializedObject.FindProperty(nameof(HairAsset.strandGroups));
			_strandGroupsAutoBuild = serializedObject.FindProperty(nameof(HairAsset.strandGroupsAutoBuild));

			previewMaterial = new Material(HairMaterialUtility.GetCurrentPipelineDefault());
			previewAngle = Vector2.zero;
			previewZoom = 0.0f;

			previewRenderer = new PreviewRenderUtility();
			previewRenderer.camera.clearFlags = CameraClearFlags.SolidColor;
			previewRenderer.camera.backgroundColor = Color.black;
			previewRenderer.camera.nearClipPlane = 0.001f;
			previewRenderer.camera.farClipPlane = 50.0f;
			previewRenderer.camera.fieldOfView = 50.0f;
			previewRenderer.camera.transform.position = Vector3.zero;
			previewRenderer.camera.transform.LookAt(Vector3.forward, Vector3.up);

			previewRenderer.lights[0].transform.SetParent(previewRenderer.camera.transform, worldPositionStays: false);
			previewRenderer.lights[0].transform.localPosition = Vector3.up;
			previewRenderer.lights[0].intensity = 1.0f;

			for (int i = 1; i != previewRenderer.lights.Length; i++)
			{
				previewRenderer.lights[i].enabled = false;
			}
		}

		void OnDisable()
		{
			if (editorCustomData)
			{
				DestroyImmediate(editorCustomData);
			}

			if (editorCustomPlacement)
			{
				DestroyImmediate(editorCustomPlacement);
			}

			ReleasePreviewData();

			if (previewRenderer != null)
			{
				previewRenderer.Cleanup();
				previewRenderer = null;
			}

			if (previewMaterial != null)
			{
				Material.DestroyImmediate(previewMaterial);
				previewMaterial = null;
			}
		}

		public override bool UseDefaultMargins()
		{
			return false;
		}

		public override void OnInspectorGUI()
		{
			var hairAsset = target as HairAsset;
			if (hairAsset == null)
				return;

			EditorGUILayout.BeginVertical(EditorStyles.inspectorFullWidthMargins);
			{
				EditorGUILayout.LabelField("Strand Declaration", EditorStyles.centeredGreyMiniLabel);
				EditorGUILayout.BeginVertical(HairGUIStyles.settingsBox);
				{
					DrawStrandDataDeclGUI();
				}
				EditorGUILayout.EndVertical();

				EditorGUILayout.Space();
				EditorGUILayout.LabelField("Strand Data", EditorStyles.centeredGreyMiniLabel);
				EditorGUILayout.BeginVertical(HairGUIStyles.settingsBox);
				{
					DrawStrandDataGUI();
				}
				EditorGUILayout.EndVertical();

				EditorGUILayout.Space();
				EditorGUILayout.LabelField(hairAsset.checksum, EditorStyles.centeredGreyMiniLabel);
			}
			EditorGUILayout.EndVertical();
		}

		static string LabelName(string variableName)
		{
			return ObjectNames.NicifyVariableName(variableName);
		}

		static void WarnIfNotAssigned(Object asset, string label)
		{
			if (asset == null)
			{
				EditorGUILayout.HelpBox(string.Format("Configuration error: '{0}' is required and not assigned.", label), MessageType.Error, wide: true);
			}
		}

		static void WarnIfNotReadable(Texture2D texture, string label)
		{
			if (texture != null && texture.isReadable == false)
			{
				EditorGUILayout.HelpBox(string.Format("Configuration warning: '{0}' will be ignored since the assigned texture asset is not marked 'Read/Write'.", label), MessageType.Warning, wide: true);
			}
		}

		static StructValidation ValidationGUIProcedural(object userData)
		{
			var hairAsset = userData as HairAsset;
			if (hairAsset != null)
			{
				if (hairAsset.settingsProcedural.placement == HairAsset.SettingsProcedural.PlacementMode.Mesh)
				{
					WarnIfNotAssigned(hairAsset.settingsProcedural.placementMesh, LabelName(nameof(HairAsset.SettingsProcedural.placementMesh)));
					WarnIfNotReadable(hairAsset.settingsProcedural.mappedDensity, LabelName(nameof(HairAsset.SettingsProcedural.mappedDensity)));
					WarnIfNotReadable(hairAsset.settingsProcedural.mappedDirection, LabelName(nameof(HairAsset.SettingsProcedural.mappedDirection)));
					WarnIfNotReadable(hairAsset.settingsProcedural.mappedParameters, LabelName(nameof(HairAsset.SettingsProcedural.mappedParameters)));
				}

				if (hairAsset.settingsProcedural.placement == HairAsset.SettingsProcedural.PlacementMode.Custom)
				{
					WarnIfNotAssigned(hairAsset.settingsProcedural.placementProvider, LabelName(nameof(HairAsset.SettingsProcedural.placementProvider)));
				}
			}
			return StructValidation.Pass;
		}

		static StructValidation ValidationGUIAlembic(object userData)
		{
#if HAS_PACKAGE_UNITY_ALEMBIC
			var hairAsset = userData as HairAsset;
			if (hairAsset != null)
			{
				var alembicAsset = hairAsset.settingsAlembic.alembicAsset;
				if (alembicAsset != null && alembicAsset.GetComponentInChildren<AlembicCurves>(includeInactive: true) == null)
				{
					EditorGUILayout.HelpBox("Configuration warning: Unable to locate curves in the assigned alembic asset.", MessageType.Warning, wide: true);
				}
				else
				{
					WarnIfNotAssigned(alembicAsset, LabelName(nameof(HairAsset.SettingsAlembic.alembicAsset)));
				}

				if (hairAsset.settingsAlembic.settingsResolve.rootUV == HairAsset.SettingsResolve.RootUV.ResolveFromMesh)
				{
					WarnIfNotAssigned(hairAsset.settingsAlembic.settingsResolve.rootUVMesh, LabelName(nameof(HairAsset.SettingsResolve.rootUVMesh)));
				}
			}
			return StructValidation.Pass;
#else
			EditorGUILayout.HelpBox("Alembic settings require package 'com.unity.formats.alembic' >= 2.2.2", MessageType.Warning, wide: true);
			return StructValidation.Inaccessible;
#endif
		}

		static StructValidation ValidationGUICustom(object userData)
		{
			var hairAsset = userData as HairAsset;
			if (hairAsset != null)
			{
				WarnIfNotAssigned(hairAsset.settingsCustom.dataProvider, LabelName(nameof(HairAsset.SettingsCustom.dataProvider)));

				if (hairAsset.settingsCustom.settingsResolve.rootUV == HairAsset.SettingsResolve.RootUV.ResolveFromMesh)
				{
					WarnIfNotAssigned(hairAsset.settingsCustom.settingsResolve.rootUVMesh, LabelName(nameof(HairAsset.SettingsResolve.rootUVMesh)));
				}
			}
			return StructValidation.Pass;
		}

		static StructValidation ValidationGUILODClusters(object userData)
		{
			var hairAsset = userData as HairAsset;
			if (hairAsset.settingsBasic.kLODClusters)
			{
				switch (hairAsset.settingsLODClusters.baseLOD.baseLOD)
				{
					case HairAsset.SettingsLODClusters.BaseLODMode.Generated:
						break;

					case HairAsset.SettingsLODClusters.BaseLODMode.UVMapped:
						{
							var clusterMaps = hairAsset.settingsLODClusters.baseLODParamsUVMapped.baseLODClusterMaps;
							if (clusterMaps != null)
							{
								for (int i = 0; i != clusterMaps.Length; i++)
								{
									WarnIfNotReadable(clusterMaps[i], string.Format("{0}[{1}]", LabelName(nameof(HairAsset.SettingsLODClusters.BaseLODParamsUVMapped.baseLODClusterMaps)), i));
								}
							}
						}
						break;
				}
			}
			return StructValidation.Pass;
		}

		public void DrawStrandDataDeclGUI()
		{
			var hairAsset = target as HairAsset;
			if (hairAsset == null)
				return;

			var currentEv = Event.current.type;
			if (currentEv == EventType.MouseDown)
			{
				// prevent accidental changes due to hotControl not being reset if mouse was released during long progress bar
				if (EditorGUIUtility.hotControl != 0)
				{
					EditorGUIUtility.hotControl = 0;
					GUIUtility.keyboardControl = 0;
				}
			}

			EditorGUI.BeginChangeCheck();
			{
				StructPropertyFieldsWithHeader(_settingsBasic);

				EditorGUILayout.Space();

				switch (hairAsset.settingsBasic.type)
				{
					case HairAsset.Type.Procedural:
						{
							StructPropertyFieldsWithHeader(_settingsProcedural, ValidationGUIProcedural, hairAsset);

							var placementType = hairAsset.settingsProcedural.placement;
							if (placementType == HairAsset.SettingsProcedural.PlacementMode.Custom)
							{
								var placementProvider = hairAsset.settingsProcedural.placementProvider;
								if (placementProvider != null)
								{
									EditorGUILayout.Space();
									if (StructHeader("Settings Procedural Placement"))
									{
										using (new EditorGUI.IndentLevelScope())
										{
											CreateCachedEditor(placementProvider, editorType: null, ref editorCustomPlacement);
											editorCustomPlacement.OnInspectorGUI();
										}
									}
								}
							}
						}
						break;

					case HairAsset.Type.Alembic:
						{
							var alembicExpanded = StructPropertyFieldsWithHeader(_settingsAlembic, ValidationGUIAlembic, hairAsset);
							if (alembicExpanded)
							{
								using (new EditorGUI.IndentLevelScope())
								{
									StructPropertyFields(_settingsAlembic_settingsResolve);
								}
							}
						}
						break;

					case HairAsset.Type.Custom:
						{
							var customExpanded = StructPropertyFieldsWithHeader(_settingsCustom, ValidationGUICustom, hairAsset);
							if (customExpanded)
							{
								using (new EditorGUI.IndentLevelScope())
								{
									StructPropertyFields(_settingsCustom_settingsResolve);
								}
							}

							var dataProvider = hairAsset.settingsCustom.dataProvider;
							if (dataProvider != null)
							{
								EditorGUILayout.Space();
								if (StructHeader("Settings Custom Data"))
								{
									using (new EditorGUI.IndentLevelScope())
									{
										CreateCachedEditor(dataProvider, editorType: null, ref editorCustomData);
										editorCustomData.OnInspectorGUI();
									}
								}
							}
						}
						break;
				}

				if (hairAsset.settingsBasic.kLODClusters)
				{
					EditorGUILayout.Space();

					var lodClustersExpanded = StructPropertyFieldsWithHeader(_settingsLODClusters, ValidationGUILODClusters, hairAsset);
					if (lodClustersExpanded)
					{
						using (new EditorGUI.IndentLevelScope())
						{
							StructPropertyFields(_settingsLODClusters_baseLOD);

							switch (hairAsset.settingsLODClusters.baseLOD.baseLOD)
							{
								case HairAsset.SettingsLODClusters.BaseLODMode.Generated:
									StructPropertyFields(_settingsLODClusters_baseLODParamsGenerated);
									break;

								case HairAsset.SettingsLODClusters.BaseLODMode.UVMapped:
									StructPropertyFields(_settingsLODClusters_baseLODParamsUVMapped);
									break;
							}

							StructPropertyFields(_settingsLODClusters_highLOD);

							using (new EditorGUI.DisabledScope(hairAsset.settingsLODClusters.highLOD.highLOD == false))
							{
								switch (hairAsset.settingsLODClusters.highLOD.highLODMode)
								{
									case HairAsset.SettingsLODClusters.HighLODMode.Automatic:
										StructPropertyFields(_settingsLODClusters_highLODParamsAutomatic);
										break;

									case HairAsset.SettingsLODClusters.HighLODMode.Manual:
										StructPropertyFields(_settingsLODClusters_highLODParamsManual);
										break;
								}
							}
						}
					}
				}
			}

			EditorGUILayout.Space();
			EditorGUILayout.BeginHorizontal();
			{
				EditorGUIUtility.labelWidth = GUI.skin.label.CalcSize(new GUIContent("Auto")).x;

				var buildNow = GUILayout.Button("Build strand groups"); GUILayout.Space(2.0f);
				var buildAuto = EditorGUILayout.ToggleLeft("Auto", _strandGroupsAutoBuild.boolValue, GUILayout.ExpandHeight(true), GUILayout.Width(EditorGUIUtility.labelWidth + 16.0f));

				EditorGUIUtility.labelWidth = 0;

				if (_strandGroupsAutoBuild.boolValue != buildAuto)
					_strandGroupsAutoBuild.boolValue = buildAuto;

				var settingsChanged = EditorGUI.EndChangeCheck();
				if (settingsChanged)
				{
					serializedObject.ApplyModifiedPropertiesWithoutUndo();
				}

				var buildNowAuto = buildAuto && settingsChanged;
				if (buildNowAuto || buildNow)
				{
					HairAssetBuilder.BuildHairAsset(hairAsset);
					serializedObject.Update();
				}
			}
			EditorGUILayout.EndHorizontal();
		}

		public void DrawStrandDataGUI()
		{
			var hairAsset = target as HairAsset;
			if (hairAsset == null)
				return;

			if (hairAsset.strandGroups == null || hairAsset.strandGroups.Length == 0)
			{
				EditorGUILayout.LabelField("None");
			}
			else
			{
				int numStrands = 0;
				int numParticles = 0;

				for (int i = 0; i != hairAsset.strandGroups.Length; i++)
				{
					numStrands += hairAsset.strandGroups[i].strandCount;
					numParticles += hairAsset.strandGroups[i].strandCount * hairAsset.strandGroups[i].strandParticleCount;
				}

				if (previewDataChecksum != hairAsset.checksum)
				{
					InitializePreviewData(hairAsset);
				}

				if (StructHeader("Summary"))
				{
					using (new EditorGUI.IndentLevelScope())
					using (new EditorGUI.DisabledScope(true))
					{
						EditorGUILayout.IntField("Number of groups", hairAsset.strandGroups.Length);
						EditorGUILayout.IntField("Number of strands (total)", numStrands);
						EditorGUILayout.IntField("Number of particles (total)", numParticles);
					}
				}

				for (int i = 0; i != hairAsset.strandGroups.Length; i++)
				{
					EditorGUILayout.Space();

					if (StructHeader("Group:" + i))
					{
						using (new EditorGUI.IndentLevelScope())
						{
							EditorGUILayout.Space(1.0f);
							EditorGUILayout.BeginVertical();
							{
								var rect = GUILayoutUtility.GetAspectRect(16.0f / 9.0f, EditorStyles.helpBox, GUILayout.MaxHeight(400.0f));
								if (rect.width >= 20.0f)
								{
									rect = EditorGUI.IndentedRect(rect);

									GUI.Box(rect, Texture2D.blackTexture, EditorStyles.textField);
									{
										var h = 0.5f * EditorGUIUtility.singleLineHeight;
										rect.xMin += h;
										rect.yMin += h;
										rect.xMax -= h;
										rect.yMax -= h;
									}

									// apply zoom
									var e = Event.current;
									if (e.alt && e.type == EventType.ScrollWheel && rect.Contains(e.mousePosition))
									{
										previewZoom -= 0.05f * e.delta.y;
										previewZoom = Mathf.Clamp01(previewZoom);
										e.Use();
									}

									// apply rotation
									var drag = Vector2.zero;
									if (Drag2D(ref drag, rect))
									{
										drag *= Vector2.one;
									}

									// draw preview
									var boundsCenter = hairAsset.strandGroups[i].bounds.center;
									var boundsRadius = hairAsset.strandGroups[i].bounds.extents.magnitude;
									var boundsRadiusMag = boundsRadius * Mathf.Lerp(1.0f, 0.5f, previewZoom);

									var cameraDistanceFitted = boundsRadiusMag / Mathf.Sin(0.5f * Mathf.Deg2Rad * previewRenderer.cameraFieldOfView);
									var cameraTransform = previewRenderer.camera.transform;
									{
										cameraTransform.Rotate(drag.y, drag.x, 0.0f, Space.Self);
										cameraTransform.position = boundsCenter - cameraDistanceFitted * cameraTransform.forward;

										previewRenderer.camera.nearClipPlane = Mathf.Max(1e-7f, cameraDistanceFitted - boundsRadius);
										previewRenderer.camera.farClipPlane = Mathf.Max(1e-7f, cameraDistanceFitted + boundsRadius);
									}

									var sourceMaterial = HairMaterialUtility.GetCurrentPipelineDefault();
									if (sourceMaterial != null)
									{
										if (previewMaterial.shader != sourceMaterial.shader)
											previewMaterial.shader = sourceMaterial.shader;

										previewMaterial.CopyPropertiesFromMaterial(sourceMaterial);
										previewMaterial.EnableKeyword("HAIR_VERTEX_LIVE");
									}

									ref var previewBuffersShared = ref previewDataShared.buffers;
									{
										ref readonly var bufferIDs = ref HairSim.VolumeData.s_bufferIDs;
										previewMaterial.SetBuffer(bufferIDs._BoundsPrev, previewBuffersShared._Bounds);
										previewMaterial.SetBuffer(bufferIDs._Bounds, previewBuffersShared._Bounds);
									}

									ref var previewBuffers = ref previewData[i].buffers;
									unsafe
									{
										ref readonly var bufferIDs = ref HairSim.SolverData.s_bufferIDs;
										previewMaterial.SetConstantBuffer(bufferIDs.SolverCBuffer, previewBuffers.SolverCBuffer, 0, sizeof(HairSim.SolverCBuffer));
										previewMaterial.SetBuffer(bufferIDs._RootUV, previewBuffers._RootUV);
										previewMaterial.SetBuffer(bufferIDs._RootScale, previewBuffers._RootScale);
										previewMaterial.SetBuffer(bufferIDs._LODGuideCount, previewBuffers._LODGuideCount);
										previewMaterial.SetBuffer(bufferIDs._LODGuideIndex, previewBuffers._LODGuideIndex);
										previewMaterial.SetBuffer(bufferIDs._LODGuideCarry, previewBuffers._LODGuideCarry);
										previewMaterial.SetBuffer(bufferIDs._LODGuideReach, previewBuffers._LODGuideReach);
										previewMaterial.SetBuffer(bufferIDs._StagingVertex, previewBuffers._StagingVertex);
										previewMaterial.SetBuffer(bufferIDs._StagingVertexPrev, previewBuffers._StagingVertex);
										previewMaterial.SetBuffer(bufferIDs._SolverLODStage, previewBuffers._SolverLODStage);
										previewMaterial.SetBuffer(bufferIDs._SolverLODRange, previewBuffers._SolverLODRange);
									}

									previewMaterial.SetInt("_DecodeVertexCount", 1);
									previewMaterial.SetInt("_DecodeVertexWidth", 0);

									var mesh = HairTopologyCache.GetSharedMesh(previewMeshes[i]);
									{
										switch (mesh.GetVertexAttributeFormat(VertexAttribute.TexCoord0))
										{
											case VertexAttributeFormat.UNorm16:
												previewMaterial.SetInt("_DecodeVertexComponentValue", ushort.MaxValue);
												previewMaterial.SetInt("_DecodeVertexComponentWidth", 16);
												break;

											case VertexAttributeFormat.UNorm8:
												previewMaterial.SetInt("_DecodeVertexComponentValue", byte.MaxValue);
												previewMaterial.SetInt("_DecodeVertexComponentWidth", 8);
												break;
										}
									}

									previewRenderer.BeginPreview(rect, GUIStyle.none);
									{
										Graphics.DrawMeshInstancedIndirect(
											mesh,
											submeshIndex: 0,
											previewMaterial,
											hairAsset.strandGroups[i].bounds,
											previewBuffers._SolverLODTopology,
											argsOffset: (int)HairSim.GetSolverLODTopologyOffset(HairSim.SolverLODTopology.IndexedInstancedLines),
											properties: null,
											ShadowCastingMode.Off,
											receiveShadows: false,
											layer: 0,
											previewRenderer.camera,
											LightProbeUsage.Off);
									}
									previewRenderer.Render(true, true);
									previewRenderer.EndAndDrawPreview(rect);
								}
							}
							EditorGUILayout.EndVertical();

							using (new EditorGUI.DisabledScope(hairAsset.strandGroups[i].lodCount < 2))
							{
								var selectedLOD = EditorGUILayout.IntSlider("Preview LOD", previewLOD[i], 0, hairAsset.strandGroups[i].lodCount - 1);
								if (selectedLOD != previewLOD[i])
								{
									InitializePreviewLOD(i, selectedLOD, hairAsset.strandGroups[i].lodGuideCount);
								}
							}

							using (new EditorGUI.DisabledScope(true))
							{
								StructPropertyFields(_strandGroups.GetArrayElementAtIndex(i));
							}
						}
					}
				}

				EditorGUILayout.Space();
				using (new EditorGUI.DisabledScope(true))
				{
					if (GUILayout.Button("Save changes"))
					{
						//TODO remove this?
					}
				}
			}
		}

		void ReleasePreviewData()
		{
			HairSim.ReleaseVolumeData(ref previewDataShared);

			if (previewData != null)
			{
				for (int i = 0; i != previewData.Length; i++)
				{
					HairSim.ReleaseSolverData(ref previewData[i]);
				}
			}

			previewData = null;
			previewDataChecksum = string.Empty;
			previewMeshes = null;
			previewLOD = null;

			EditorApplication.update -= PingPreviewMeshes;
		}

		void InitializePreviewData(HairAsset hairAsset)
		{
			ReleasePreviewData();

			if (hairAsset == null)
				return;

			var strandGroups = hairAsset.strandGroups;
			if (strandGroups == null)
				return;

			previewMeshes = new HairTopologyDesc[strandGroups.Length];
			previewData = new HairSim.SolverData[strandGroups.Length];
			previewLOD = new int[strandGroups.Length];

			using (var cmd = HairSimUtility.ScopedCommandBuffer.Get())
			{
				using (var dummyBounds = new NativeArray<HairSim.LODBounds>(1, Allocator.Temp))
				{
					CreateBufferWithNativeData(ref previewDataShared.buffers._Bounds, dummyBounds);
				}

				for (int i = 0; i != previewData.Length; i++)
				{
					ref var strandGroup = ref strandGroups[i];

					ref var previewMesh = ref previewMeshes[i];
					{
						previewMesh = new HairTopologyDesc
						{
							type = HairTopologyType.Lines,
							strandCount = Mathf.Min(hairAsset.strandGroups[i].strandCount, HairSim.Conf.INSTANCING_BATCH_SIZE),
							strandParticleCount = hairAsset.strandGroups[i].strandParticleCount,
							memoryLayout = hairAsset.strandGroups[i].particleMemoryLayout,
						};
					}

					ref var previewBuffers = ref previewData[i].buffers;
					ref var previewConstants = ref previewData[i].constants;
					{
						HairAssetUtility.DeclareParticleStride(strandGroup, out var strandParticleOffset, out var strandParticleStride);

						previewConstants._StrandCount = (uint)strandGroup.strandCount;
						previewConstants._StrandParticleCount = (uint)strandGroup.strandParticleCount;
						previewConstants._StrandParticleOffset = (uint)strandParticleOffset;
						previewConstants._StrandParticleStride = (uint)strandParticleStride;
						previewConstants._LODCount = (uint)strandGroup.lodCount;

						previewConstants._GroupScale = 1.0f;
						previewConstants._GroupMaxParticleInterval = strandGroup.strandParamsMax.x / (previewConstants._StrandParticleCount - 1);
						previewConstants._GroupMaxParticleDiameter = strandGroup.strandParamsMax.y;
						previewConstants._GroupBoundsIndex = 0;

						previewConstants._StagingSubdivision = 0;
						previewConstants._StagingVertexFormat = (uint)HairSim.StagingVertexFormat.Uncompressed;
						previewConstants._StagingVertexStride = sizeof(float) * 3;

						previewConstants._StagingStrandVertexCount = previewConstants._StrandParticleCount;
						previewConstants._StagingStrandVertexOffset = previewConstants._StrandParticleOffset;

						previewConstants._RenderLODMethod = (uint)HairSim.RenderLODSelection.Manual;
						previewConstants._RenderLODScale = 1.0f;
						previewConstants._RenderLODBias = 0.0f;
						previewConstants._RenderLODClipThreshold = 0.0f;

						previewConstants._RenderFeatures = (uint)HairSim.RenderFeatures.Instancing;
					}

					unsafe
					{
						HairSimUtility.CreateBuffer(ref previewBuffers.SolverCBuffer, string.Empty, 1, sizeof(HairSim.SolverCBuffer), ComputeBufferType.Constant);
						HairSimUtility.PushConstantBufferData(cmd, previewBuffers.SolverCBuffer, previewConstants);
					}

					CreateBufferWithData(ref previewBuffers._RootUV, strandGroup.rootUV);
					CreateBufferWithData(ref previewBuffers._RootScale, strandGroup.rootScale);
					CreateBufferWithData(ref previewBuffers._LODGuideCount, strandGroup.lodGuideCount);
					CreateBufferWithData(ref previewBuffers._LODGuideIndex, strandGroup.lodGuideIndex);
					CreateBufferWithData(ref previewBuffers._LODGuideCarry, strandGroup.lodGuideCarry);
					CreateBufferWithData(ref previewBuffers._LODGuideReach, strandGroup.lodGuideReach);
					CreateBufferWithData(ref previewBuffers._StagingVertex, strandGroup.particlePosition, ComputeBufferType.Raw);

					InitializePreviewLOD(i, strandGroup.lodCount - 1, strandGroup.lodGuideCount);
				}

				Graphics.ExecuteCommandBuffer(cmd);
			}

			previewDataChecksum = hairAsset.checksum;

			EditorApplication.update += PingPreviewMeshes;
		}

		void InitializePreviewLOD(int i, int lodIndex, int[] lodGuideCount)
		{
			using (var lodDescs = new NativeArray<HairSim.LODIndices>((int)HairSim.SolverLODStage.__COUNT, Allocator.Temp))
			using (var lodRange = new NativeArray<Vector2Int>((int)HairSim.SolverLODRange.__COUNT, Allocator.Temp))
			using (var lodTopology = new NativeArray<uint>((int)HairSim.SolverLODTopology.__COUNT * 5, Allocator.Temp))
			{
				unsafe
				{
					static HairSim.LODIndices MakeLODDesc(int lodIndex) => new HairSim.LODIndices
					{
						lodIndexLo = (uint)lodIndex,
						lodIndexHi = (uint)lodIndex,
						lodBlendFrac = 0.0f,
					};

					var lodDescsPtr = (HairSim.LODIndices*)lodDescs.GetUnsafePtr();
					var lodRangePtr = (Vector2Int*)lodRange.GetUnsafePtr();
					var lodTopologyPtr = (uint*)lodTopology.GetUnsafePtr();

					var lodIndexCeil = Mathf.Max(0, (int)previewData[i].constants._LODCount - 1);
					var lodIndexDesc = MakeLODDesc(Mathf.Clamp(lodIndex, 0, lodIndexCeil));
					var lodTopologyIndex = (int)HairSim.SolverLODTopology.IndexedInstancedLines;

					lodDescsPtr[(int)HairSim.SolverLODStage.Physics] = lodIndexDesc;
					lodDescsPtr[(int)HairSim.SolverLODStage.Rendering] = lodIndexDesc;
					lodRangePtr[(int)HairSim.SolverLODRange.Render] = new Vector2Int(0, lodGuideCount[lodIndex]);

					lodTopologyPtr[lodTopologyIndex * 5 + 0] = HairTopologyCache.GetSharedMesh(previewMeshes[i]).GetIndexCount(0);
					lodTopologyPtr[lodTopologyIndex * 5 + 1] = ((uint)lodGuideCount[lodIndex] + HairSim.Conf.INSTANCING_BATCH_SIZE - 1) / HairSim.Conf.INSTANCING_BATCH_SIZE;
					lodTopologyPtr[lodTopologyIndex * 5 + 2] = 0;
					lodTopologyPtr[lodTopologyIndex * 5 + 3] = 0;
					lodTopologyPtr[lodTopologyIndex * 5 + 4] = 0;

					CreateBufferWithNativeData(ref previewData[i].buffers._SolverLODStage, lodDescs);
					CreateBufferWithNativeData(ref previewData[i].buffers._SolverLODRange, lodRange);
					CreateBufferWithNativeData(ref previewData[i].buffers._SolverLODTopology, lodTopology, ComputeBufferType.IndirectArguments);
				}
			}

			previewLOD[i] = lodIndex;
		}

		void PingPreviewMeshes()
		{
			foreach (var meshDesc in previewMeshes)
			{
				HairTopologyCache.GetSharedMesh(meshDesc);
			}
		}

		static void CreateBufferWithData<T>(ref ComputeBuffer buffer, T[] data, ComputeBufferType type = ComputeBufferType.Default) where T : unmanaged
		{
			unsafe
			{
				var elementCount = data.Length;
				var elementStride = UnsafeUtility.SizeOf<T>();

				HairSimUtility.CreateBuffer(ref buffer, string.Empty, elementCount, elementStride, type);

				buffer.SetData(data);
			}
		}

		static void CreateBufferWithData<T>(ref GraphicsBuffer buffer, T[] data, ComputeBufferType type = ComputeBufferType.Default) where T : unmanaged
		{
			unsafe
			{
				var elementCount = data.Length;
				var elementStride = UnsafeUtility.SizeOf<T>();

				HairSimUtility.CreateBuffer(ref buffer, string.Empty, elementCount, elementStride, type);

				buffer.SetData(data);
			}
		}

		static void CreateBufferWithNativeData<T>(ref ComputeBuffer buffer, NativeArray<T> data, ComputeBufferType type = ComputeBufferType.Default) where T : unmanaged
		{
			unsafe
			{
				var elementCount = data.Length;
				var elementStride = sizeof(T);

				HairSimUtility.CreateBuffer(ref buffer, string.Empty, elementCount, elementStride, type);

				buffer.SetData(data);
			}
		}

		static void CreateBufferWithNativeData<T>(ref GraphicsBuffer buffer, NativeArray<T> data, ComputeBufferType type = ComputeBufferType.Default) where T : unmanaged
		{
			unsafe
			{
				var elementCount = data.Length;
				var elementStride = sizeof(T);

				HairSimUtility.CreateBuffer(ref buffer, string.Empty, elementCount, elementStride, type);

				buffer.SetData(data);
			}
		}

		static bool Drag2D(ref Vector2 delta, Rect rect)
		{
			int i = GUIUtility.GetControlID("HairAssetEditor.Drag2D".GetHashCode(), FocusType.Passive);
			var e = Event.current;

			switch (e.GetTypeForControl(i))
			{
				case EventType.MouseDrag:
					if (GUIUtility.hotControl == i)
					{
						delta += e.delta;
						e.Use();
						return true;// dragging
					}
					break;

				case EventType.MouseDown:
					if (rect.Contains(e.mousePosition))
					{
						if (GUIUtility.hotControl == 0)
							GUIUtility.hotControl = i;

						if (GUIUtility.hotControl == i)
						{
							e.Use();
							EditorGUIUtility.SetWantsMouseJumping(1);
							return true;// dragging
						}
					}
					break;

				case EventType.MouseUp:
					if (GUIUtility.hotControl == i)
						GUIUtility.hotControl = 0;

					EditorGUIUtility.SetWantsMouseJumping(0);
					break;
			}

			return false;// not dragging
		}
	}
}

```

`Editor/HairAssetEditor.cs.meta`:

```meta
fileFormatVersion: 2
guid: bfe67ac5258b3914ba3b73cf4ec79040
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/HairBoundaryEditor.cs`:

```cs
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	using static HairGUILayout;
	using static HairGUI;

	[CustomEditor(typeof(HairBoundary)), CanEditMultipleObjects]
	public class HairBoundaryEditor : Editor
	{
		SerializedProperty _settings;
		SerializedProperty _settings_mode;
		SerializedProperty _settings_type;

		SerializedProperty _settingsCapsule;
		SerializedProperty _settingsSphere;
		SerializedProperty _settingsTorus;
		SerializedProperty _settingsCube;
		SerializedProperty _settingsSDF;

		void OnEnable()
		{
			_settings = serializedObject.FindProperty(nameof(HairBoundary.settings));
			_settings_mode = _settings.FindPropertyRelative(nameof(HairBoundary.settings.mode));
			_settings_type = _settings.FindPropertyRelative(nameof(HairBoundary.settings.type));

			_settingsCapsule = serializedObject.FindProperty(nameof(HairBoundary.settingsCapsule));
			_settingsSphere = serializedObject.FindProperty(nameof(HairBoundary.settingsSphere));
			_settingsTorus = serializedObject.FindProperty(nameof(HairBoundary.settingsTorus));
			_settingsCube = serializedObject.FindProperty(nameof(HairBoundary.settingsCube));
			_settingsSDF = serializedObject.FindProperty(nameof(HairBoundary.settingsSDF));
		}

		public override bool UseDefaultMargins()
		{
			return false;
		}

		public override void OnInspectorGUI()
		{
			var hairBoundary = target as HairBoundary;
			if (hairBoundary == null)
				return;

			EditorGUILayout.BeginVertical(EditorStyles.inspectorFullWidthMargins);
			{
				EditorGUILayout.LabelField("Boundary Settings", EditorStyles.centeredGreyMiniLabel);
				EditorGUILayout.BeginVertical(HairGUIStyles.settingsBox);
				{
					DrawBoundaryGUI();
				}
				EditorGUILayout.EndVertical();
			}
			EditorGUILayout.EndVertical();
		}

		public void DrawBoundaryGUI()
		{
			var hairBoundary = target as HairBoundary;
			if (hairBoundary == null)
				return;

			EditorGUI.BeginChangeCheck();

			StructPropertyFieldsWithHeader(_settings, "Settings Shape");

			var selectedMode = (HairBoundary.Settings.Mode)_settings_mode.intValue;
			var selectedType = (HairBoundary.Settings.Type)_settings_type.intValue;

			//TODO move to ValidationGUI
			if (selectedMode == HairBoundary.Settings.Mode.BindToComponent && selectedType == HairBoundary.Settings.Type.DiscreteSDF)
			{
#if !HAS_PACKAGE_DEMOTEAM_MESHTOSDF
				using (new EditorGUI.IndentLevelScope())
				{
					EditorGUILayout.HelpBox("Binding to SDF component requires package: 'com.unity.demoteam.mesh-to-sdf >= 1.0.0'.", MessageType.None, wide: true);
				}
#endif
			}

			if (selectedMode == HairBoundary.Settings.Mode.BindToComponent)
			{
				using (new EditorGUI.IndentLevelScope())
				{
					if (HairBoundary.TryGetMatchingComponent(hairBoundary, out var component))
					{
						using (new ColorScope(Color.white))
						using (new ColorScope(Color.green, ColorType.BackgroundColor))
						{
							GUILayout.Label("Bound to component: " + component.GetType().Name, HairGUIStyles.statusBox, GUILayout.ExpandWidth(true));
							//TODO change to EditorGUILayout.LabelField to preserve indent level?
						}
					}
					else
					{
						EditorGUILayout.HelpBox("No matching components for the selected type.", MessageType.Warning, wide: true);
					}
				}
			}
			else
			{
				if (selectedType == HairBoundary.Settings.Type.Any)
				{
					using (new EditorGUI.IndentLevelScope())
					{
						EditorGUILayout.HelpBox("Type '" + HairBoundary.Settings.Type.Any + "' requires mode '" + ObjectNames.NicifyVariableName(HairBoundary.Settings.Mode.BindToComponent.ToString()) + "'.", MessageType.Warning, wide: true);
					}
				}
				else
				{ 
					EditorGUILayout.Space();

					switch (selectedType)
					{
						case HairBoundary.Settings.Type.DiscreteSDF:
							StructPropertyFieldsWithHeader(_settingsSDF);
							break;
						case HairBoundary.Settings.Type.Capsule:
							StructPropertyFieldsWithHeader(_settingsCapsule);
							break;
						case HairBoundary.Settings.Type.Sphere:
							StructPropertyFieldsWithHeader(_settingsSphere);
							break;
						case HairBoundary.Settings.Type.Torus:
							StructPropertyFieldsWithHeader(_settingsTorus);
							break;
						case HairBoundary.Settings.Type.Cube:
							StructPropertyFieldsWithHeader(_settingsCube);
							break;
					}
				}
			}

			if (EditorGUI.EndChangeCheck())
			{
				serializedObject.ApplyModifiedProperties();
			}
		}
	}
}

```

`Editor/HairBoundaryEditor.cs.meta`:

```meta
fileFormatVersion: 2
guid: 3ed5b599d38659246bcb0091318c3330
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/HairInstanceEditor.cs`:

```cs
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	using static HairGUILayout;
	using static HairGUI;

	[CustomEditor(typeof(HairInstance)), CanEditMultipleObjects]
	public class HairInstanceEditor : Editor
	{
		static bool s_indicator;

		Dictionary<HairAsset, Editor> hairAssetEditorMap = new Dictionary<HairAsset, Editor>(1);

		SerializedProperty _settingsExecutive;
		SerializedProperty _settingsDebugging;

		SerializedProperty _strandGroupProviders;
		SerializedProperty _strandGroupSettings;
		SerializedProperty _strandGroupDefaults;

		SerializedProperty _settingsVolumetrics;
		SerializedProperty _settingsEnvironment;

		void OnEnable()
		{
			_settingsExecutive = serializedObject.FindProperty(nameof(HairInstance.settingsExecutive));
			_settingsDebugging = serializedObject.FindProperty(nameof(HairInstance.settingsDebugging));

			_strandGroupProviders = serializedObject.FindProperty(nameof(HairInstance.strandGroupProviders));
			_strandGroupSettings = serializedObject.FindProperty(nameof(HairInstance.strandGroupSettings));
			_strandGroupDefaults = serializedObject.FindProperty(nameof(HairInstance.strandGroupDefaults));

			_settingsVolumetrics = serializedObject.FindProperty(nameof(HairInstance.settingsVolumetrics));
			_settingsEnvironment = serializedObject.FindProperty(nameof(HairInstance.settingsEnvironment));
		}

		void OnDisable()
		{
			foreach (var hairAssetEditor in hairAssetEditorMap.Values)
			{
				if (hairAssetEditor != null)
				{
					DestroyImmediate(hairAssetEditor);
				}
			}

			hairAssetEditorMap.Clear();
		}

		public bool HasFrameBounds()
		{
			var hairInstance = target as HairInstance;
			if (hairInstance == null || hairInstance.strandGroupInstances == null)
				return false;
			else
				return true;
		}

		public Bounds OnGetFrameBounds()
		{
			var hairInstance = target as HairInstance;
			if (hairInstance == null)
				return new Bounds();
			else
				return HairSim.GetVolumeBounds(hairInstance.volumeData).WithScale(0.5f);
		}

		public override bool UseDefaultMargins()
		{
			return false;
		}

		public override void OnInspectorGUI()
		{
			var hairInstance = target as HairInstance;
			if (hairInstance == null)
				return;

			EditorGUILayout.BeginVertical(EditorStyles.inspectorFullWidthMargins);
			{
				//TODO maybe re-label and re-group like so?
				// Hair Assets
				// Hair Runtime
				// Hair Settings

				EditorGUILayout.LabelField("System Contents", EditorStyles.centeredGreyMiniLabel);
				EditorGUILayout.BeginVertical(HairGUIStyles.settingsBox);
				{
					DrawSystemContentsGUI(hairInstance);
				}
				EditorGUILayout.EndVertical();

				EditorGUILayout.Space();
				EditorGUILayout.LabelField("System Settings", EditorStyles.centeredGreyMiniLabel);
				EditorGUILayout.BeginVertical(HairGUIStyles.settingsBox);
				{
					DrawSystemControlsGUI(hairInstance);
					DrawSystemSettingsGUI(hairInstance);
				}
				EditorGUILayout.EndVertical();

				EditorGUILayout.Space();
				EditorGUILayout.LabelField("Strand Settings", EditorStyles.centeredGreyMiniLabel);
				EditorGUILayout.BeginVertical(HairGUIStyles.settingsBox);
				{
					DrawStrandSettingsGUI(hairInstance);
				}
				EditorGUILayout.EndVertical();

				EditorGUILayout.Space();
				EditorGUILayout.LabelField("Volume Settings", EditorStyles.centeredGreyMiniLabel);
				EditorGUILayout.BeginVertical(HairGUIStyles.settingsBox);
				{
					DrawVolumeSettingsGUI(hairInstance);
				}
				EditorGUILayout.EndVertical();

				//EditorGUILayout.Space();
				//EditorGUILayout.LabelField(hairInstance.strandGroupChecksums, EditorStyles.centeredGreyMiniLabel);
			}
			EditorGUILayout.EndVertical();
		}

		void DrawSystemContentsGUI(HairInstance hairInstance)
		{
			const float widthSymbol = 30.0f;
			const float widthUnlock = 70.0f;

			using (new GovernedByPrefabScope(hairInstance))
			{
				EditorGUI.BeginChangeCheck();
				{
					var multipleAssets = _strandGroupProviders.arraySize > 1;
					for (int i = 0; i != _strandGroupProviders.arraySize; i++)
					{
						var property = _strandGroupProviders.GetArrayElementAtIndex(i);
						var property_hairAsset = property.FindPropertyRelative(nameof(HairInstance.GroupProvider.hairAsset));
						var property_hairAssetQuickEdit = property.FindPropertyRelative(nameof(HairInstance.GroupProvider.hairAssetQuickEdit));
						var property_delete = false;

						EditorGUILayout.BeginHorizontal();
						{
							using (new EditorGUI.DisabledScope(property_hairAsset.objectReferenceValue == null))
							{
								property_hairAssetQuickEdit.boolValue = GUILayout.Toggle(property_hairAssetQuickEdit.boolValue, HairGUIStyles.miniButtonIconEdit, EditorStyles.miniButton, GUILayout.Width(widthSymbol));
							}

							EditorGUILayout.ObjectField(property_hairAsset, GUIContent.none);

							if (multipleAssets)//TODO considering: using (new EditorGUI.DisabledScope(multipleAssets == false))
							{
								property_delete = GUILayout.Button(HairGUIStyles.miniButtonIconSub, EditorStyles.miniButton, GUILayout.Width(widthSymbol));
							}
						}
						EditorGUILayout.EndHorizontal();

						if (property_delete)
						{
							_strandGroupProviders.DeleteArrayElementAtIndex(i--);
							break;
						}

						if (property_hairAssetQuickEdit.boolValue)
						{
							var hairAsset = property_hairAsset.objectReferenceValue as HairAsset;
							if (hairAsset != null)
							{
								if (hairAssetEditorMap.TryGetValue(hairAsset, out var hairAssetEditor) == false)
								{
									CreateCachedEditor(hairAsset, typeof(HairAssetEditor), ref hairAssetEditor);
									hairAssetEditorMap.Add(hairAsset, hairAssetEditor);
								}
								EditorGUILayout.BeginVertical(HairGUIStyles.settingsBox);
								{
									(hairAssetEditor as HairAssetEditor).DrawStrandDataDeclGUI();
								}
								EditorGUILayout.EndVertical();
							}
						}
					}
				}

				if (EditorGUI.EndChangeCheck())
				{
					serializedObject.ApplyModifiedProperties();
				}

				EditorGUILayout.BeginHorizontal();
				{
					if (GUILayout.Button(HairGUIStyles.miniButtonIconAdd, GUILayout.Width(widthSymbol)))
					{
						var countPrev = _strandGroupProviders.arraySize;
						var countNext = countPrev + 1;

						_strandGroupProviders.arraySize = countNext;
						serializedObject.ApplyModifiedProperties();

						if (countNext == hairInstance.strandGroupProviders.Length)
						{
							// write zero element to get rid of default duplicate of previous element
							hairInstance.strandGroupProviders[countNext - 1] = new HairInstance.GroupProvider();
						}
					}

					if (GUILayout.Button("Reload"))
					{
						hairInstance.strandGroupChecksums = null;
					}

					if (GUILayout.Button("Unlock", GUILayout.Width(widthUnlock)))
					{
						var strandGroupInstances = hairInstance.strandGroupInstances;
						if (strandGroupInstances != null)
						{
							for (int i = 0; i != strandGroupInstances.Length; i++)
							{
								ref var strandGroupInstance = ref strandGroupInstances[i];

								strandGroupInstance.sceneObjects.groupContainer.hideFlags &= ~HideFlags.NotEditable;
								strandGroupInstance.sceneObjects.rootMeshFilter.gameObject.hideFlags &= ~HideFlags.NotEditable;
								strandGroupInstance.sceneObjects.strandMeshFilter.gameObject.hideFlags &= ~HideFlags.NotEditable;
							}
						}
					}
				}
				EditorGUILayout.EndHorizontal();
			}

			// loaded status
			{
				var countGroups = (hairInstance.solverData != null) ? hairInstance.solverData.Length : 0;
				var countStrands = 0u;
				var countParticles = 0u;

				for (int i = 0; i != countGroups; i++)
				{
					ref readonly var constants = ref hairInstance.solverData[i].constants;
					{
						countStrands += constants._StrandCount;
						countParticles += constants._StrandCount * constants._StrandParticleCount;
					}
				}

				var countTxt = string.Format("Loaded: {0} group(s), {1} strands, {2} particles.", countGroups, countStrands, countParticles);

				EditorGUILayout.LabelField(countTxt, HairGUIStyles.statusBox, GUILayout.ExpandWidth(true));
			}
		}

		void DrawSystemControlsGUI(HairInstance hairInstance)
		{
			EditorGUI.BeginChangeCheck();
			{
				ref var simAllowed = ref hairInstance.settingsExecutive.updateSimulationInEditor;
				ref var simActive = ref hairInstance.settingsExecutive.updateSimulation;

				var simState = (simAllowed && simActive) ? "Running" : (simAllowed ? "Paused" : "Stopped");
				var simTime = hairInstance.execState.elapsedTime;
				var simTxt = string.Format(System.Globalization.CultureInfo.InvariantCulture, "Simulation state: {0}\nElapsed time: {1:F3}s", simState, simTime);

				using (new ColorScope(simActive ? Color.green : Color.yellow, simAllowed ? ColorType.BackgroundColor : ColorType.None))
				{
					EditorGUILayout.LabelField(simTxt, HairGUIStyles.statusBox, GUILayout.ExpandWidth(true));
				}

				EditorGUILayout.BeginHorizontal();
				{
					using (new ColorScope(Color.cyan, Application.isPlaying ? ColorType.ContentColor : ColorType.None))
					{
						simAllowed = GUILayout.Toggle(Application.isPlaying || simAllowed, HairGUIStyles.miniButtonIconPlay, EditorStyles.miniButton);
					}

					simActive = (GUILayout.Toggle(simActive == false, HairGUIStyles.miniButtonIconPause, EditorStyles.miniButton) == false);

					if (GUILayout.Button(HairGUIStyles.miniButtonIconStep, EditorStyles.miniButton))
					{
						simAllowed = true;
						simActive = true;

						hairInstance.PauseSimulationPostStep();
					}

					if (GUILayout.Button(HairGUIStyles.miniButtonIconRewind, EditorStyles.miniButton))
					{
						hairInstance.ResetSimulationState();
					}
				}
				EditorGUILayout.EndHorizontal();
			}

			if (EditorGUI.EndChangeCheck())
			{
				serializedObject.ApplyModifiedProperties();
			}
		}

		void DrawSystemSettingsGUI(HairInstance hairInstance)
		{
			EditorGUI.BeginChangeCheck();
			{
				if (StructPropertyFieldsWithHeader(_settingsExecutive, ValidationGUIExecutive, hairInstance))
				{
					using (new EditorGUI.IndentLevelScope())
					{
						var rect = GUILayoutUtility.GetRect(0.0f, EditorGUIUtility.singleLineHeight, GUILayout.ExpandWidth(true));
						{
							rect = EditorGUI.PrefixLabel(rect, new GUIContent("Update Steps Status"));
						}

						if (rect.Contains(Event.current.mousePosition) && Event.current.type == EventType.MouseDown)
						{
							s_indicator = !s_indicator;
						}

						if (s_indicator)
						{
							var stepsMin = hairInstance.settingsExecutive.updateStepsMin ? hairInstance.settingsExecutive.updateStepsMinValue : 0;
							var stepsMax = hairInstance.settingsExecutive.updateStepsMax ? hairInstance.settingsExecutive.updateStepsMaxValue : (int)Mathf.Ceil(hairInstance.execState.lastStepCountSmooth);
							if (stepsMax == 0)
								stepsMax = 1;

							var stepDT = hairInstance.GetSimulationTimeStep();
							var stepCount = hairInstance.execState.lastStepCountSmooth;

							var rectWidth = rect.width;
							var rectWidthStep = rectWidth / stepsMax;
							var rectWidthCount = Mathf.Min(rectWidth, rectWidthStep * stepCount);

							rect.width = rectWidthCount;
							{
								using (new ColorScope(hairInstance.execState.lastStepCountRaw > hairInstance.execState.lastStepCount ? Color.red : Color.green, ColorType.Color))
								{
									EditorGUI.HelpBox(rect, string.Empty, MessageType.None);
								}
							}

							rect.width = rectWidthStep;
							{
								var text = stepDT.ToString();
								for (int i = 0; i != stepsMax; i++)
								{
									EditorGUI.HelpBox(rect, text, MessageType.None);
									rect.x += rectWidthStep;
								}
							}

							EditorUtility.SetDirty(hairInstance);
						}
						else
						{
							EditorGUI.HelpBox(rect, "Click to toggle indicator.", MessageType.None);
						}
					}
				}

				EditorGUILayout.Space();
				if (StructPropertyFieldsWithHeader(_settingsDebugging, ValidationGUIDebugging, hairInstance))
				{
					using (new EditorGUI.IndentLevelScope())
					{
						var divider = hairInstance.settingsDebugging.drawSliceDivider;
						var dividerBase = Mathf.Floor(divider);
						var dividerFrac = divider - Mathf.Floor(divider);

						var rect = GUILayoutUtility.GetRect(0.0f, EditorGUIUtility.singleLineHeight, GUILayout.ExpandWidth(true));

						rect = EditorGUI.IndentedRect(rect);

						var rect0 = new Rect(rect);
						var rect1 = new Rect(rect);

						rect0.width = (rect.width) * (1.0f - dividerFrac);
						rect1.width = (rect.width) * dividerFrac;
						rect1.x += rect0.width;

						string DividerLabel(int index)
						{
							switch (index)
							{
								case 0: return "density";
								case 1: return "rest-density";
								case 2: return "velocity";
								case 3: return "divergence";
								case 4: return "pressure";
								case 5: return "grad(pressure)";
								case 6: return "probes(scattering)";
								case 7: return "impulse(wind+external)";
							}
							return "unknown";
						}

						EditorGUILayout.BeginHorizontal();
						{
							GUI.Box(rect0, DividerLabel((int)dividerBase + 0), EditorStyles.helpBox);
							GUI.Box(rect1, DividerLabel((int)dividerBase + 1), EditorStyles.helpBox);
						}
						EditorGUILayout.EndHorizontal();
					}
				}
			}

			if (EditorGUI.EndChangeCheck())
			{
				serializedObject.ApplyModifiedProperties();
			}
		}

		void DrawStrandSettingsGUI(HairInstance hairInstance)
		{
			const float widthSymbol = 30.0f;

			EditorGUI.BeginChangeCheck();
			{
				// settings default
				{
					var property = _strandGroupDefaults;
					var property_settingsSkinning = property.FindPropertyRelative(nameof(HairInstance.GroupSettings.settingsSkinning));
					var property_settingsGeometry = property.FindPropertyRelative(nameof(HairInstance.GroupSettings.settingsGeometry));
					var property_settingsRendering = property.FindPropertyRelative(nameof(HairInstance.GroupSettings.settingsRendering));
					var property_settingsPhysics = property.FindPropertyRelative(nameof(HairInstance.GroupSettings.settingsPhysics));

					EditorGUILayout.BeginHorizontal();
					{
						var expanded = GUILayout.Toggle(property.isExpanded, HairGUIStyles.miniButtonIconEdit, EditorStyles.miniButton, GUILayout.Width(widthSymbol));
						if (expanded != property.isExpanded)
							property.isExpanded = expanded;

						using (var scope = new HairGUILayout.PropertyRectScope(property, "Defaults (All Groups)"))
						{
							EditorGUI.LabelField(scope.position, scope.label, EditorStyles.textArea);
						}
					}
					EditorGUILayout.EndHorizontal();

					if (property.isExpanded)
					{
						EditorGUILayout.BeginVertical(HairGUIStyles.settingsBox);
						{
							using (new GovernedByPrefabScope(hairInstance))
							{
								StructPropertyFieldsWithHeader(property_settingsSkinning, ValidationGUISkinning, hairInstance);
							}
							EditorGUILayout.Space();
							StructPropertyFieldsWithHeader(property_settingsGeometry, ValidationGUIGeometry, hairInstance);
							EditorGUILayout.Space();
							StructPropertyFieldsWithHeader(property_settingsRendering, ValidationGUIRendering, hairInstance);
							EditorGUILayout.Space();
							StructPropertyFieldsWithHeader(property_settingsPhysics, ValidationGUIPhysics, hairInstance);
						}
						EditorGUILayout.EndVertical();
					}
				}

				// settings override
				for (int i = 0; i != _strandGroupSettings.arraySize; i++)
				{
					var property = _strandGroupSettings.GetArrayElementAtIndex(i);
					var property_groupAssetReferences = property.FindPropertyRelative(nameof(HairInstance.GroupSettings.groupAssetReferences));
					var property_settingsSkinning = property.FindPropertyRelative(nameof(HairInstance.GroupSettings.settingsSkinning));
					var property_settingsGeometry = property.FindPropertyRelative(nameof(HairInstance.GroupSettings.settingsGeometry));
					var property_settingsRendering = property.FindPropertyRelative(nameof(HairInstance.GroupSettings.settingsRendering));
					var property_settingsPhysics = property.FindPropertyRelative(nameof(HairInstance.GroupSettings.settingsPhysics));
					var property_settingsSkinningToggle = property.FindPropertyRelative(nameof(HairInstance.GroupSettings.settingsSkinningToggle));
					var property_settingsGeometryToggle = property.FindPropertyRelative(nameof(HairInstance.GroupSettings.settingsGeometryToggle));
					var property_settingsRenderingToggle = property.FindPropertyRelative(nameof(HairInstance.GroupSettings.settingsRenderingToggle));
					var property_settingsPhysicsToggle = property.FindPropertyRelative(nameof(HairInstance.GroupSettings.settingsPhysicsToggle));
					var property_delete = false;

					EditorGUILayout.BeginHorizontal();
					{
						var expanded = GUILayout.Toggle(property.isExpanded, HairGUIStyles.miniButtonIconEdit, EditorStyles.miniButton, GUILayout.Width(widthSymbol));
						if (expanded != property.isExpanded)
							property.isExpanded = expanded;

						var blockCount = property_groupAssetReferences.arraySize;
						var blockLabel = "Overrides (" + blockCount + (blockCount == 1 ? " Group Asset)" : " Group Assets)");
						{
							using (var scope = new HairGUILayout.PropertyRectScope(property, blockLabel))
							{
								EditorGUI.LabelField(scope.position, scope.label, EditorStyles.textArea);
							}
						}

						var strandGroupInstances = hairInstance.strandGroupInstances;
						if (strandGroupInstances != null && strandGroupInstances.Length > 0)
						{
							for (int j = 0; j != strandGroupInstances.Length; j++)
							{
								var groupLabel = "Gr." + j;
								var groupAssigned = (strandGroupInstances[j].settingsIndex == i);
								if (groupAssigned)
								{
									using (new ColorScope(Color.green, ColorType.BackgroundColor))
									{
										if (GUILayout.Toggle(true, groupLabel, EditorStyles.miniButton, GUILayout.ExpandWidth(false)) == false)
										{
											hairInstance.AssignStrandGroupSettings(-1, j);
										}
									}
								}
								else
								{
									using (new ColorScope(Color.Lerp(Color.white, Color.grey, 0.5f), ColorType.ContentColor))
									{
										if (GUILayout.Toggle(false, groupLabel, EditorStyles.miniButton, GUILayout.ExpandWidth(false)))
										{
											hairInstance.AssignStrandGroupSettings(i, j);
										}
									}
								}
							}
						}

						if (true)
						{
							property_delete = GUILayout.Button(HairGUIStyles.miniButtonIconSub, EditorStyles.miniButton, GUILayout.Width(widthSymbol));
						}
					}
					EditorGUILayout.EndHorizontal();

					if (property_delete)
					{
						_strandGroupSettings.DeleteArrayElementAtIndex(i--);
						break;
					}

					if (property.isExpanded)
					{
						EditorGUILayout.BeginVertical(HairGUIStyles.settingsBox);
						{
							using (new GovernedByPrefabScope(hairInstance))
							{
								StructPropertyFieldsWithHeader(property_settingsSkinning, property_settingsSkinningToggle, ValidationGUISkinning, hairInstance);
							}
							EditorGUILayout.Space();
							StructPropertyFieldsWithHeader(property_settingsGeometry, property_settingsGeometryToggle, ValidationGUIGeometry, hairInstance);
							EditorGUILayout.Space();
							StructPropertyFieldsWithHeader(property_settingsRendering, property_settingsRenderingToggle, ValidationGUIRendering, hairInstance);
							EditorGUILayout.Space();
							StructPropertyFieldsWithHeader(property_settingsPhysics, property_settingsPhysicsToggle, ValidationGUIPhysics, hairInstance);
						}
						EditorGUILayout.EndVertical();
					}
				}

				if (GUILayout.Button("Add override block ..."))
				{
					var countPrev = _strandGroupSettings.arraySize;
					var countNext = countPrev + 1;

					_strandGroupSettings.arraySize = countNext;
					serializedObject.ApplyModifiedProperties();

					if (countNext == hairInstance.strandGroupSettings.Length)
					{
						hairInstance.strandGroupSettings[countNext - 1] = HairInstance.GroupSettings.defaults;
					}
				}
			}

			if (EditorGUI.EndChangeCheck())
			{
				serializedObject.ApplyModifiedProperties();
			}
		}

		void DrawVolumeSettingsGUI(HairInstance hairInstance)
		{
			EditorGUI.BeginChangeCheck();
			{
				if (StructPropertyFieldsWithHeader(_settingsVolumetrics, ValidationGUIVolumetrics, hairInstance))
				{
					// ...
				}

				EditorGUILayout.Space();
				if (StructPropertyFieldsWithHeader(_settingsEnvironment, ValidationGUIEnvironment, hairInstance))
				{
					using (new EditorGUI.IndentLevelScope())
					{
						ref readonly var delimDiscrete = ref hairInstance.volumeData.constantsEnvironment._BoundaryDelimDiscrete;
						ref readonly var delimCapsule = ref hairInstance.volumeData.constantsEnvironment._BoundaryDelimCapsule;
						ref readonly var delimSphere = ref hairInstance.volumeData.constantsEnvironment._BoundaryDelimSphere;
						ref readonly var delimTorus = ref hairInstance.volumeData.constantsEnvironment._BoundaryDelimTorus;
						ref readonly var delimCube = ref hairInstance.volumeData.constantsEnvironment._BoundaryDelimCube;

						var countDiscrete = delimDiscrete;
						var countCapsule = delimCapsule - delimDiscrete;
						var countSphere = delimSphere - delimCapsule;
						var countTorus = delimTorus - delimSphere;
						var countCube = delimCube - delimTorus;

						var countAll = countDiscrete + countCapsule + countSphere + countTorus + countCube;
						var countTxt = string.Format("{0} boundaries ({1} discrete, {2} capsule, {3} sphere, {4} torus, {5} cube)", countAll, countDiscrete, countCapsule, countSphere, countTorus, countCube);

						EditorGUILayout.LabelField(countTxt, HairGUIStyles.statusBox, GUILayout.ExpandWidth(true));

						var countDiscarded = hairInstance.volumeData.boundaryCountDiscard;
						if (countDiscarded > 0)
						{
							using (new ColorScope(Color.Lerp(Color.red, Color.yellow, 0.5f)))
							{
								EditorGUILayout.LabelField(string.Format("{0} discarded (due to limit of {1})", countDiscarded, HairSim.Conf.MAX_BOUNDARIES), HairGUIStyles.statusBox, GUILayout.ExpandWidth(true));
							}
						}
					}
				}
			}

			if (EditorGUI.EndChangeCheck())
			{
				serializedObject.ApplyModifiedProperties();
			}
		}

		//TODO update validation callbacks for updated settings & data

		static StructValidation ValidationGUIExecutive(object userData) => StructValidation.Pass;
		static StructValidation ValidationGUIDebugging(object userData) => StructValidation.Pass;

		static StructValidation ValidationGUISkinning(object userData)
		{
#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN
			return StructValidation.Pass;
#else
			EditorGUILayout.HelpBox("Root attachments require package: 'com.unity.demoteam.digital-human >= 0.1.1-preview'.", MessageType.None, wide: true);
			return StructValidation.Inaccessible;
#endif
		}

		static StructValidation ValidationGUIGeometry(object userData) => StructValidation.Pass;
		static StructValidation ValidationGUIRendering(object userData)
		{
			var hairInstance = userData as HairInstance;
			{
				//if (hairInstance.settingsSystem.strandRenderer == HairInstance.SettingsSystem.StrandRenderer.HDRPHighQualityLines)
				/*TODO
				if (false)
				{
#if HAS_PACKAGE_UNITY_HDRP_15_0_2
					var strandGroupInstances = hairInstance.strandGroupInstances;
					if (strandGroupInstances != null)
					{
						//TODO warn when at least one assigned material is not a valid hair material
						//see HairRenderer.IsHairMaterial(...)
					}
#else
					EditorGUILayout.HelpBox(string.Format("Configuration warning: '{0}' requires package: 'com.unity.render-pipelines.high-definition >= 15.0.2'. Using '{1}' as fallback.", HairSim.RenderSettings.Renderer.HDRPHighQualityLines, HairSim.RenderSettings.Renderer.BuiltinLines), MessageType.Warning, wide: true);
#endif
				}
				*/
			}

			return StructValidation.Pass;
		}

		static StructValidation ValidationGUIPhysics(object userData)
		{
			//TODO make aware of multiple settings groups
			//
			//var hairInstance = userData as HairInstance;
			//if (hairInstance.solverData != null && hairInstance.solverData.Length > 0)
			//{
			//	var strandSolver = hairInstance.strandGroupDefaults.settingsSolver.method;
			//	var strandMemoryLayout = hairInstance.solverData[0].memoryLayout;
			//	var strandParticleCount = hairInstance.solverData[0].cbuffer._StrandParticleCount;

			//	switch (strandSolver)
			//	{
			//		case HairSim.SolverSettings.Method.GaussSeidelReference:
			//			EditorGUILayout.HelpBox("Performance warning: Using slow reference solver.", MessageType.Warning, wide: true);
			//			break;

			//		case HairSim.SolverSettings.Method.GaussSeidel:
			//			if (strandMemoryLayout != HairAsset.MemoryLayout.Interleaved)
			//			{
			//				EditorGUILayout.HelpBox("Performance warning: Gauss-Seidel solver performs better with memory layout 'Interleaved'. This can be solved by changing memory layout in the asset.", MessageType.Warning, wide: true);
			//			}
			//			break;

			//		case HairSim.SolverSettings.Method.Jacobi:
			//			if (strandParticleCount != 16 &&
			//				strandParticleCount != 32 &&
			//				strandParticleCount != 64 &&
			//				strandParticleCount != 128)
			//			{
			//				EditorGUILayout.HelpBox("Configuration error: Jacobi solver requires strand particle count of 16, 32, 64, 128. Using slow reference solver as fallback. This can be solved by resampling curves in the asset.", MessageType.Error, wide: true);
			//			}
			//			else if (strandMemoryLayout != HairAsset.MemoryLayout.Sequential)
			//			{
			//				EditorGUILayout.HelpBox("Performance warning: Jacobi solver performs better with memory layout 'Sequential'. This can be solved by changing memory layout in the asset.", MessageType.Warning, wide: true);
			//			}
			//			break;
			//	}
			//}

			return StructValidation.Pass;
		}

		static StructValidation ValidationGUIEnvironment(object userData) => StructValidation.Pass;
		static StructValidation ValidationGUIVolumetrics(object userData) => StructValidation.Pass;
	}
}

```

`Editor/HairInstanceEditor.cs.meta`:

```meta
fileFormatVersion: 2
guid: 358a284fa765db340879dc0d05b40958
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/HairInstanceEditorRefresh.cs`:

```cs
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static class HairInstanceEditorRefresh
	{
		static bool s_initialized = false;

		[InitializeOnLoadMethod]
		static void StaticInitialize()
		{
			if (s_initialized == false)
			{
				EditorApplication.update += ConditionalPlayerLoop;

				s_initialized = true;
			}
		}

		static void ConditionalPlayerLoop()
		{
			if (Application.isPlaying)
				return;

			var alwaysRefresh = AnySceneViewAlwaysRefresh();
			if (alwaysRefresh == false)
				return;

			foreach (var hairInstance in HairInstance.s_instances)
			{
				if (hairInstance != null &&
					hairInstance.isActiveAndEnabled &&
					hairInstance.GetSimulationActive())
				{
					EditorApplication.QueuePlayerLoopUpdate();
					break;
				}
			}
		}

		static bool AnySceneViewAlwaysRefresh()
		{
			var sceneViews = SceneView.sceneViews;
			var sceneViewsActive = 0;

			for (int i = 0; i != sceneViews.Count; i++)
			{
				var sceneView = sceneViews[i] as SceneView;
				if (sceneView != null && sceneView.sceneViewState.alwaysRefreshEnabled)
				{
					sceneViewsActive++;
				}
			}

			return (sceneViewsActive > 0);
		}
	}
}

```

`Editor/HairInstanceEditorRefresh.cs.meta`:

```meta
fileFormatVersion: 2
guid: 0284dfbbb46dbf44486b12e7ac4e6849
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/HairShaderVariantStripper.cs`:

```cs
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEditor.Build;
using UnityEditor.Rendering;

namespace Unity.DemoTeam.Hair
{
	public class HairShaderVariantStripper : IPreprocessShaders
	{
		ShaderKeyword HAIR_VERTEX_LIVE;
		ShaderKeyword HAIR_VERTEX_STATIC;
		ShaderKeyword PROCEDURAL_INSTANCING_ON;

		public HairShaderVariantStripper()
		{
			HAIR_VERTEX_LIVE = new ShaderKeyword(nameof(HAIR_VERTEX_LIVE));
			HAIR_VERTEX_STATIC = new ShaderKeyword(nameof(HAIR_VERTEX_STATIC));
			PROCEDURAL_INSTANCING_ON = new ShaderKeyword(nameof(PROCEDURAL_INSTANCING_ON));
		}

		public int callbackOrder { get; }

		public void OnProcessShader(Shader shader, ShaderSnippetData snippet, IList<ShaderCompilerData> data)
		{
			for (int i = data.Count - 1; i >= 0; i--)
			{
				var keys = data[i].shaderKeywordSet;
				if (keys.IsEnabled(HAIR_VERTEX_STATIC))
				{
					data.RemoveAt(i);
					continue;
				}
#if false
				if (keys.IsEnabled(HAIR_VERTEX_LIVE))
				{
					if (keys.IsEnabled(PROCEDURAL_INSTANCING_ON) == false)
					{
						data.RemoveAt(i);
						continue;
					}
				}
#endif
			}
		}
	}
}

```

`Editor/HairShaderVariantStripper.cs.meta`:

```meta
fileFormatVersion: 2
guid: 4e937113e8684df3900b523cbb613360
timeCreated: 1698266256
```

`Editor/HairWindEditor.cs`:

```cs
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	using static HairGUILayout;
	using static HairGUI;

	[CustomEditor(typeof(HairWind)), CanEditMultipleObjects]
	public class HairWindEditor : Editor
	{
		SerializedProperty _settingsEmitter;
		SerializedProperty _settingsDirectional;
		SerializedProperty _settingsSpherical;
		SerializedProperty _settingsTurbine;
		SerializedProperty _settingsFlow;

		void OnEnable()
		{
			_settingsEmitter = serializedObject.FindProperty(nameof(HairWind.settingsEmitter));
			_settingsDirectional = serializedObject.FindProperty(nameof(HairWind.settingsDirectional));
			_settingsSpherical = serializedObject.FindProperty(nameof(HairWind.settingsSpherical));
			_settingsTurbine = serializedObject.FindProperty(nameof(HairWind.settingsTurbine));
			_settingsFlow = serializedObject.FindProperty(nameof(HairWind.settingsFlow));
		}

		public override bool UseDefaultMargins()
		{
			return false;
		}

		public override void OnInspectorGUI()
		{
			var hairWind = target as HairWind;
			if (hairWind == null)
				return;

			EditorGUILayout.BeginVertical(EditorStyles.inspectorFullWidthMargins);
			{
				EditorGUILayout.LabelField("Wind Settings", EditorStyles.centeredGreyMiniLabel);
				EditorGUILayout.BeginVertical(HairGUIStyles.settingsBox);
				{
					DrawWindGUI();
				}
				EditorGUILayout.EndVertical();
			}
			EditorGUILayout.EndVertical();
		}

		public void DrawWindGUI()
		{
			var hairWind = target as HairWind;
			if (hairWind == null)
				return;

			EditorGUI.BeginChangeCheck();
			{
				StructPropertyFieldsWithHeader(_settingsEmitter);

				if (hairWind.settingsEmitter.mode == HairWind.SettingsEmitter.Mode.BindToComponent)
				{
					using (new EditorGUI.IndentLevelScope())
					{
						if (HairWind.TryGetMatchingComponent(hairWind, out var component))
						{
							using (new ColorScope(Color.white))
							using (new ColorScope(Color.green, ColorType.BackgroundColor))
							{
								GUILayout.Label("Bound to component: " + component.GetType().Name, HairGUIStyles.statusBox, GUILayout.ExpandWidth(true));
								//TODO change to EditorGUILayout.LabelField to preserve indent level?
							}
						}
						else
						{
							EditorGUILayout.HelpBox("No matching components for the selected type.", MessageType.Warning, wide: true);
						}
					}
				}
				else
				{
					if (hairWind.settingsEmitter.type == HairWind.SettingsEmitter.Type.Any)
					{
						using (new EditorGUI.IndentLevelScope())
						{
							EditorGUILayout.HelpBox("Type '" + HairWind.SettingsEmitter.Type.Any + "' requires mode '" + ObjectNames.NicifyVariableName(HairWind.SettingsEmitter.Mode.BindToComponent.ToString()) + "'.", MessageType.Warning, wide: true);
						}
					}
					else
					{
						EditorGUILayout.Space();

						var expanded = false;

						switch (hairWind.settingsEmitter.type)
						{
							case HairWind.SettingsEmitter.Type.Directional:
								expanded = StructPropertyFieldsWithHeader(_settingsDirectional);
								break;
							case HairWind.SettingsEmitter.Type.Spherical:
								expanded = StructPropertyFieldsWithHeader(_settingsSpherical);
								break;
							case HairWind.SettingsEmitter.Type.Turbine:
								expanded = StructPropertyFieldsWithHeader(_settingsTurbine);
								break;
						}

						if (expanded)
						{
							using (new EditorGUI.IndentLevelScope())
							{
								StructPropertyFields(_settingsFlow);
							}
						}
					}
				}
			}

			if (EditorGUI.EndChangeCheck())
			{
				serializedObject.ApplyModifiedProperties();
			}
		}
	}
}

```

`Editor/HairWindEditor.cs.meta`:

```meta
fileFormatVersion: 2
guid: e895bdc847a01f24fad1d481077de424
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/PropertyDrawers.meta`:

```meta
fileFormatVersion: 2
guid: 3cbc18336244ddf429300bb99e946824
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/PropertyDrawers/ComparePropertyUtility.cs`:

```cs
using System;
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static class ComparePropertyUtility
	{
		public static bool Evaluate(ComparePropertyBase attribute, SerializedProperty property)
		{
			var result = false;
			var attrib = attribute;
			if (attrib.fieldName.Length > 0)
			{
				SerializedProperty searchProperty;

				var searchPath = property.propertyPath;
				int searchPathDelim = searchPath.LastIndexOf('.');
				if (searchPathDelim == -1)
				{
					searchProperty = property.serializedObject.FindProperty(attrib.fieldName);
				}
				else
				{
					searchProperty = property.serializedObject.FindProperty(searchPath.Substring(0, searchPathDelim)).FindPropertyRelative(attrib.fieldName);
				}

				if (searchProperty != null)
				{
					switch (attrib.cmpType)
					{
						case TypeCode.Boolean:
							if (searchProperty.propertyType == SerializedPropertyType.ObjectReference)
								result = Compare(attrib.cmpOp, searchProperty.objectReferenceValue != null, (bool)attrib.cmpValue);
							else
								result = Compare(attrib.cmpOp, searchProperty.boolValue, (bool)attrib.cmpValue);
							break;

						case TypeCode.Byte:
						case TypeCode.UInt16:
						case TypeCode.UInt32:
							result = Compare(attrib.cmpOp, searchProperty.intValue, (int)((uint)attrib.cmpValue));
							break;

						case TypeCode.UInt64:
							result = Compare(attrib.cmpOp, searchProperty.longValue, (long)((ulong)attrib.cmpValue));
							break;

						case TypeCode.SByte:
						case TypeCode.Int16:
						case TypeCode.Int32:
							result = Compare(attrib.cmpOp, searchProperty.intValue, (int)attrib.cmpValue);
							break;

						case TypeCode.Int64:
							result = Compare(attrib.cmpOp, searchProperty.longValue, (long)attrib.cmpValue);
							break;

						case TypeCode.Single:
							result = Compare(attrib.cmpOp, searchProperty.floatValue, (float)attrib.cmpValue);
							break;

						case TypeCode.Double:
							result = Compare(attrib.cmpOp, searchProperty.doubleValue, (double)attrib.cmpValue);
							break;

						case TypeCode.Empty:
							result = Compare(attrib.cmpOp, searchProperty.objectReferenceValue != null, true);
							break;

						default:
							//TODO add the remaining
							break;
					}
				}
			}
			else if (attrib.cmpType == TypeCode.Boolean)
			{
				result = (bool)attrib.cmpValue;
			}
			return result;
		}

		static bool Compare<T>(CompareOp op, T a, T b) where T : IComparable<T>
		{
			switch (op)
			{
				case CompareOp.Eq: return a.CompareTo(b) == 0;
				case CompareOp.Geq: return a.CompareTo(b) >= 0;
				case CompareOp.Gt: return a.CompareTo(b) > 0;
				case CompareOp.Leq: return a.CompareTo(b) <= 0;
				case CompareOp.Lt: return a.CompareTo(b) < 0;
				case CompareOp.Neq: return a.CompareTo(b) != 0;
				default: return false;
			}
		}
	}
}

```

`Editor/PropertyDrawers/ComparePropertyUtility.cs.meta`:

```meta
fileFormatVersion: 2
guid: 99272c9ac3c84b94b8435f11b331df3f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/PropertyDrawers/EditableIfDrawer.cs`:

```cs
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static partial class PropertyDrawers
	{
		[CustomPropertyDrawer(typeof(EditableIfAttribute))]
		public class EditableIfDrawer : PropertyDrawer
		{
			public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
			{
				var editable = base.attribute as EditableIfAttribute;
				using (new EditorGUI.DisabledScope(ComparePropertyUtility.Evaluate(editable, property) == false))
				{
					EditorGUI.PropertyField(position, property, label, includeChildren: true);
				}
			}
		}
	}
}

```

`Editor/PropertyDrawers/EditableIfDrawer.cs.meta`:

```meta
fileFormatVersion: 2
guid: 5e16c1300ca67174c94894badde3e459
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/PropertyDrawers/LineHeaderDrawer.cs`:

```cs
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static partial class PropertyDrawers
	{
		[CustomPropertyDrawer(typeof(LineHeaderAttribute))]
		public class LineHeaderDrawer : DecoratorDrawer
		{
			public override float GetHeight() => HairGUI.lineHeaderHeight;
			public override void OnGUI(Rect position)
			{
				var header = attribute as LineHeaderAttribute;
				{
					HairGUI.LineHeader(position, header.label);
				}
			}
		}
	}
}

```

`Editor/PropertyDrawers/LineHeaderDrawer.cs.meta`:

```meta
fileFormatVersion: 2
guid: a6b8ee477ba83cb4282d19d57a5345b8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/PropertyDrawers/LinearRampDrawer.cs`:

```cs
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static partial class PropertyDrawers
	{
		[CustomPropertyDrawer(typeof(LinearRampAttribute))]
		public class LinearRampDrawer : PropertyDrawer
		{
			public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
			{
				var ramp = base.attribute as LinearRampAttribute;
				{
					HairGUI.LinearRamp(position, label, property, ramp.ranges);
				}
			}
		}
	}
}

```

`Editor/PropertyDrawers/LinearRampDrawer.cs.meta`:

```meta
fileFormatVersion: 2
guid: 2230d09fffeb6bc4d9ca8c2b908b69a3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/PropertyDrawers/LinearRampWidgetDrawer.cs`:

```cs
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static partial class PropertyDrawers
	{
		[CustomPropertyDrawer(typeof(LinearRampWidgetAttribute))]
		public class LinearRampWidgetDrawer : PropertyDrawer
		{
			public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
			{
				if (property.propertyType == SerializedPropertyType.Vector2)
				{
					var ramp = base.attribute as LinearRampWidgetAttribute;

					EditorGUI.BeginProperty(position, label, property);
					position = EditorGUI.PrefixLabel(position, label);

					//NOTE: EditorGUIUtility.fieldWidth
					property.vector2Value = HairGUI.LinearRampWidget(position, property.vector2Value, new Vector2(ramp.min, ramp.max), ramp.style);

					EditorGUI.EndProperty();
				}
				else
				{
					base.OnGUI(position, property, label);
				}
			}
		}
	}
}

```

`Editor/PropertyDrawers/LinearRampWidgetDrawer.cs.meta`:

```meta
fileFormatVersion: 2
guid: 1d4d4594bfdc82a438c639a635fc629b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/PropertyDrawers/RenderingLayerMaskDrawer.cs`:

```cs
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static partial class PropertyDrawers
	{
		[CustomPropertyDrawer(typeof(RenderingLayerMaskAttribute))]
		public class RenderingLayerMaskDrawer : PropertyDrawer
		{
			public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) => HairGUI.RenderingLayerMask(position, label, property);
		}
	}
}

```

`Editor/PropertyDrawers/RenderingLayerMaskDrawer.cs.meta`:

```meta
fileFormatVersion: 2
guid: b715e747663c9f84290a6ce84fb109c4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/PropertyDrawers/ToggleGroupDrawer.cs`:

```cs
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static partial class PropertyDrawers
	{
		[CustomPropertyDrawer(typeof(ToggleGroupAttribute))]
		public class ToggleGroupDrawer : PropertyDrawer
		{
			public override float GetPropertyHeight(SerializedProperty property, GUIContent label) => -EditorGUIUtility.standardVerticalSpacing;
			public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) => HairGUILayout.ToggleGroup(fieldInfo, property, label);
		}
	}
}

```

`Editor/PropertyDrawers/ToggleGroupDrawer.cs.meta`:

```meta
fileFormatVersion: 2
guid: a34cb6db827f32c4eb5c0e033671aa95
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/PropertyDrawers/ToggleGroupItemDrawer.cs`:

```cs
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static partial class PropertyDrawers
	{
		[CustomPropertyDrawer(typeof(ToggleGroupItemAttribute))]
		public class ToggleGroupItemDrawer : PropertyDrawer
		{
			public override float GetPropertyHeight(SerializedProperty property, GUIContent label) => -EditorGUIUtility.standardVerticalSpacing;
			public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) { }
		}
	}
}

```

`Editor/PropertyDrawers/ToggleGroupItemDrawer.cs.meta`:

```meta
fileFormatVersion: 2
guid: 79896b02cff9fad4c8b08fb38accbee1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/PropertyDrawers/VisibleIfDrawer.cs`:

```cs
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static partial class PropertyDrawers
	{
		[CustomPropertyDrawer(typeof(VisibleIfAttribute))]
		public class VisibleIfDrawer : PropertyDrawer
		{
			public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
			{
				var visible = base.attribute as VisibleIfAttribute;
				if (ComparePropertyUtility.Evaluate(visible, property))
				{
					return EditorGUI.GetPropertyHeight(property, label, includeChildren: true);
				}
				else
				{
					return -EditorGUIUtility.standardVerticalSpacing;
				}
			}

			public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
			{
				if (position.height > 0.0f)
				{
					var visible = base.attribute as VisibleIfAttribute;
					if (ComparePropertyUtility.Evaluate(visible, property))
					{
						EditorGUI.PropertyField(position, property, label, includeChildren: true);
					}
				}
			}
		}
	}
}

```

`Editor/PropertyDrawers/VisibleIfDrawer.cs.meta`:

```meta
fileFormatVersion: 2
guid: 8390ba33ce4139c42abed1ee3a256d2f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Unity.DemoTeam.Hair.Editor.asmdef`:

```asmdef
{
    "name": "Unity.DemoTeam.Hair.Editor",
    "rootNamespace": "",
    "references": [
        "GUID:f9dedde5eec30c2468e14d8a7b14626e",
        "GUID:2665a8d13d1b3f18800f46e256720795",
        "GUID:e0cd26848372d4e5c891c569017e11f1",
        "GUID:d8b63aba1907145bea998dd612889d6b",
        "GUID:df380645f10b7bc4b97d4f5eb6303d95",
        "GUID:78bd2ddd6e276394a9615c203e574844",
        "GUID:c579267770062bf448e75eb160330b7f",
        "GUID:22f31b74491fb45d5b598e0b935deb31"
    ],
    "includePlatforms": [
        "Editor"
    ],
    "excludePlatforms": [],
    "allowUnsafeCode": true,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [
        {
            "name": "com.unity.render-pipelines.high-definition",
            "expression": "10.2.2",
            "define": "HAS_PACKAGE_UNITY_HDRP"
        },
        {
            "name": "com.unity.render-pipelines.high-definition",
            "expression": "15.0.2",
            "define": "HAS_PACKAGE_UNITY_HDRP_15_0_2"
        },
        {
            "name": "com.unity.render-pipelines.universal",
            "expression": "10.2.2",
            "define": "HAS_PACKAGE_UNITY_URP"
        },
        {
            "name": "com.unity.formats.alembic",
            "expression": "2.2.2",
            "define": "HAS_PACKAGE_UNITY_ALEMBIC"
        },
        {
            "name": "com.unity.demoteam.digital-human",
            "expression": "0.1.1-preview",
            "define": "HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN"
        },
        {
            "name": "com.unity.demoteam.digital-human",
            "expression": "0.2.0-preview",
            "define": "HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN_0_2_0_PREVIEW"
        },
        {
            "name": "com.unity.demoteam.digital-human",
            "expression": "0.2.1-preview",
            "define": "HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN_0_2_1_PREVIEW"
        },
        {
            "name": "com.unity.demoteam.mesh-to-sdf",
            "expression": "1.0.0",
            "define": "HAS_PACKAGE_DEMOTEAM_MESHTOSDF"
        },
        {
            "name": "com.unity.collections",
            "expression": "1.0.0-pre.3",
            "define": "HAS_PACKAGE_UNITY_COLLECTIONS_1_0_0_PRE_3"
        },
        {
            "name": "com.unity.collections",
            "expression": "1.0.0-pre.5",
            "define": "HAS_PACKAGE_UNITY_COLLECTIONS_1_0_0_PRE_5"
        },
        {
            "name": "com.unity.collections",
            "expression": "1.3.0",
            "define": "HAS_PACKAGE_UNITY_COLLECTIONS_1_3_0"
        },
        {
            "name": "com.unity.collections",
            "expression": "[2.0.0,2.1.0-exp.4)",
            "define": "HAS_PACKAGE_UNITY_COLLECTIONS_2_0_0_UNTIL_2_1_0_EXP_4"
        }
    ],
    "noEngineReferences": false
}
```

`Editor/Unity.DemoTeam.Hair.Editor.asmdef.meta`:

```meta
fileFormatVersion: 2
guid: 8f7035be1433e7b42bb810f12982480e
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utility.meta`:

```meta
fileFormatVersion: 2
guid: 8a2ea694d25355e47a14ca4f4caf1fb0
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utility/HairGUI.ColorScope.cs`:

```cs
using System;
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public static partial class HairGUI
	{
		public enum ColorType
		{
			Color,
			ContentColor,
			BackgroundColor,
			None,
		}

		static Color GetColor(ColorType colorType)
		{
			switch (colorType)
			{
				default:
				case ColorType.Color: return GUI.color;
				case ColorType.ContentColor: return GUI.contentColor;
				case ColorType.BackgroundColor: return GUI.backgroundColor;
			}
		}

		static void SetColor(ColorType colorType, in Color color)
		{
			switch (colorType)
			{
				default:
				case ColorType.Color: GUI.color = color; break;
				case ColorType.ContentColor: GUI.contentColor = color; break;
				case ColorType.BackgroundColor: GUI.backgroundColor = color; break;
				case ColorType.None: break;
			}
		}

		public struct ColorScope : IDisposable
		{
			public Color restoreColor;
			public ColorType restoreColorType;

			public ColorScope(Color color, ColorType colorType = ColorType.Color)
			{
				this.restoreColor = GetColor(colorType);
				this.restoreColorType = colorType;
				SetColor(colorType, color);
			}

			public void Dispose()
			{
				SetColor(restoreColorType, restoreColor);
			}
		}
	}
}

```

`Editor/Utility/HairGUI.ColorScope.cs.meta`:

```meta
fileFormatVersion: 2
guid: f21ea2a9d8725924ebfc624bb0814429
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utility/HairGUI.LineHeader.cs`:

```cs
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static partial class HairGUILayout
	{
		public static void LineHeader(GUIContent label = null)
		{
			HairGUI.LineHeader(EditorGUILayout.GetControlRect(), label);
		}
	}

	public static partial class HairGUI
	{
		public const float lineHeaderHeight = lineHeight + lineMarginTop + lineMarginBottom;

		const float lineHeight = 2.0f;
		const float lineMarginTop = 11.0f;
		const float lineMarginBottom = 4.0f;

		const float labelAlign = 0.05f;
		const float labelMargin = 3.0f;

		public static void LineHeader(Rect position, GUIContent label = null)
		{
			if (label == null)
			{
				position = EditorGUI.IndentedRect(position);
				position.y += lineMarginTop;
				position.height = lineHeight;

				var color = GUI.color;
				GUI.color = Color.white;
				GUI.Box(position, "");
				GUI.color = color;
			}
			else
			{
				position = EditorGUI.IndentedRect(position);
				position.y += lineMarginTop;
				position.height = lineHeight;

				var labelSize = EditorStyles.miniLabel.CalcSize(label);
				var labelWidth = labelSize.x + 2.0f * labelMargin;
				var spacerWidth = position.width - labelWidth;

				var delimL = position.xMin + labelAlign * spacerWidth;
				var delimR = position.xMax - (1.0f - labelAlign) * spacerWidth;

				var posL = position;
				var posC = position;
				var posR = position;

				posL.xMax = delimL;
				posC.xMin = delimL + labelMargin;
				posC.xMax = delimR - labelMargin;
				posC.y -= 0.6f * labelSize.y;
				posC.height = labelSize.y;
				posR.xMin = delimR;

				var color = GUI.color;
				GUI.color = Color.white;
				GUI.Box(posL, "");
				GUI.color = Color.Lerp(Color.white, Color.black, 0.45f);
				GUI.Box(posC, label, EditorStyles.miniLabel);
				GUI.color = Color.white;
				GUI.Box(posR, "");
				GUI.color = color;
			}
		}
	}
}

```

`Editor/Utility/HairGUI.LineHeader.cs.meta`:

```meta
fileFormatVersion: 2
guid: 2e004f24706af734daacbe07f7e5b994
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utility/HairGUI.LinearRamp.cs`:

```cs
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Unity.DemoTeam.Hair
{
	public static partial class HairGUILayout
	{
		public static void LinearRamp(GUIContent label, SerializedProperty property, Rect ranges, params GUILayoutOption[] options)
		{
			HairGUI.LinearRamp(EditorGUILayout.GetControlRect(options), label, property, ranges);
		}

		public static AnimationCurve LinearRamp(GUIContent label, AnimationCurve curve, Rect ranges, params GUILayoutOption[] options)
		{
			return HairGUI.LinearRamp(EditorGUILayout.GetControlRect(options), label, curve, ranges);
		}
	}

	public static partial class HairGUI
	{
		public static void LinearRamp(Rect position, GUIContent label, SerializedProperty property, Rect ranges)
		{
			label = EditorGUI.BeginProperty(position, label, property);
			{
				EditorGUI.BeginChangeCheck();

				var curve = property.animationCurveValue;
				{
					curve = LinearRamp(position, label, curve, ranges);
				}

				if (EditorGUI.EndChangeCheck())
				{
					property.animationCurveValue = curve;
				}
			}
			EditorGUI.EndProperty();
		}

		public static AnimationCurve LinearRamp(Rect position, GUIContent label, AnimationCurve curve, Rect ranges)
		{
			EditorGUI.BeginChangeCheck();

			curve = EditorGUI.CurveField(position, label, curve, Color.white, ranges);

			if (EditorGUI.EndChangeCheck())
			{
				curve = ClampCurve(curve, ranges);
				curve.preWrapMode = curve.postWrapMode = WrapMode.Clamp;

				AnimationUtility.SetKeyLeftTangentMode(curve, 0, AnimationUtility.TangentMode.Linear);
				AnimationUtility.SetKeyLeftTangentMode(curve, 1, AnimationUtility.TangentMode.Linear);
				AnimationUtility.SetKeyRightTangentMode(curve, 0, AnimationUtility.TangentMode.Linear);
				AnimationUtility.SetKeyRightTangentMode(curve, 1, AnimationUtility.TangentMode.Linear);
			}

			return curve;
		}

		static AnimationCurve ClampCurve(AnimationCurve curve, Rect ranges)
		{
			var xm = ranges.xMin + 0.5f + ranges.width;
			var ym = ranges.yMin + 0.5f * ranges.height;

			switch (curve.length)
			{
				case 0:
					curve.AddKey(ranges.xMin, ym);
					curve.AddKey(ranges.yMin, ym);
					break;

				case 1:
					var q = ClampKey(curve[0], ranges);
					{
						curve.AddKey(q.time > xm ? ranges.xMin : ranges.xMax, q.value);
					}
					break;

				default:
					while (curve.length > 2)
					{
						curve.RemoveKey(1);// throw away interior keys
					}

					curve.MoveKey(0, ClampKey(curve[0], ranges));
					curve.MoveKey(1, ClampKey(curve[1], ranges));
					break;
			}

			return curve;
		}

		static Keyframe ClampKey(in Keyframe key, Rect ranges)
		{
			return new Keyframe(
				Mathf.Clamp(key.time, ranges.xMin, ranges.xMax),
				Mathf.Clamp(key.value, ranges.yMin, ranges.yMax)
			);
		}
	}
}

```

`Editor/Utility/HairGUI.LinearRamp.cs.meta`:

```meta
fileFormatVersion: 2
guid: fe56c81a0158f924b9f07c3a79564508
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utility/HairGUI.LinearRampWidget.cs`:

```cs
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static partial class HairGUI
	{
		static readonly int s_idHintRampMin = "RampMin".GetHashCode();
		static readonly int s_idHintRampMax = "RampMax".GetHashCode();

		static Vector3[] s_pointsLinear = new Vector3[4];
		static Vector3[] s_pointsSmooth = new Vector3[16];

		public static Vector2 LinearRampWidget(Rect position, Vector2 value, Vector2 limit, LinearRampStyle style = LinearRampStyle.LinearDecreasing)
		{
			GUI.Box(position, GUIContent.none);

			position.xMin += 1.0f;
			position.xMax -= 1.0f;
			position.yMin += 1.0f;
			position.yMax -= 1.0f;

			// sanitize
			if (value.x > value.y)
			{
				value.x = 0.5f * (value.x + value.y);
				value.y = value.x;
			}

			// draw sliders
			var tmin = Mathf.Clamp01((value.x - limit.x) / (limit.y - limit.x));
			var tmax = Mathf.Clamp01((value.y - limit.x) / (limit.y - limit.x));
			{
				var idHot = GUIUtility.hotControl;
				var idMin = GUIUtility.GetControlID(s_idHintRampMin, FocusType.Passive);
				var idMax = GUIUtility.GetControlID(s_idHintRampMax, FocusType.Passive);

				var id = (idHot == idMin || idHot == idMax) ? idHot : 0;

				if (Event.current.type == EventType.MouseDown)
				{
					var xmin = position.xMin + position.width * tmin;
					var xmax = position.xMin + position.width * tmax;

					if (Event.current.mousePosition.x < 0.5f * (xmin + xmax))
						id = idMin;
					else
						id = idMax;
				}

				if (id == idMin)
				{
					value.x = GUI.Slider(position, (float)value.x, 0.0f, limit.x, limit.y, GUIStyle.none, GUIStyle.none, horiz: true, idMin);
					value.y = Mathf.Max((float)value.x, (float)value.y);
				}

				if (id == idMax)
				{
					value.y = GUI.Slider(position, (float)value.y, 0.0f, limit.x, limit.y, GUIStyle.none, GUIStyle.none, horiz: true, idMax);
					value.x = Mathf.Min((float)value.x, (float)value.y);
				}

				tmin = Mathf.Clamp01((value.x - limit.x) / (limit.y - limit.x));
				tmax = Mathf.Clamp01((value.y - limit.x) / (limit.y - limit.x));
			}

			// draw ramp
			using (new Handles.DrawingScope(Color.green))
			{
				var x0 = position.xMin;
				var x1 = position.xMax;
				var y0 = position.yMax;
				var y1 = position.yMin;

				var styleIncreasing = (style == LinearRampStyle.LinearIncreasing || style == LinearRampStyle.SmoothIncreasing);
				if (styleIncreasing)
				{
					y0 = position.yMin;
					y1 = position.yMax;
				}

				s_pointsLinear[0] = new Vector3(x0, y1);
				s_pointsLinear[1] = new Vector3(x0 + tmin * (x1 - x0), y1);
				s_pointsLinear[2] = new Vector3(x0 + tmax * (x1 - x0), y0);
				s_pointsLinear[3] = new Vector3(x1, y0);

				var styleSmooth = (style == LinearRampStyle.SmoothDecreasing || style == LinearRampStyle.SmoothIncreasing);
				if (styleSmooth)
				{
					s_pointsSmooth[0] = s_pointsLinear[0];
					s_pointsSmooth[1] = s_pointsLinear[1];

					var p0 = s_pointsLinear[1];
					var p1 = s_pointsLinear[2];

					var dx = p1.x - p0.x;
					var dy = p1.y - p0.y;
					var dt = 1.0f / (s_pointsSmooth.Length - 3);

					for (int i = 2; i != s_pointsSmooth.Length - 2; i++)
					{
						var t = (i - 1) * dt;
						var s = Mathf.SmoothStep(0.0f, 1.0f, t);

						s_pointsSmooth[i] = new Vector3(p0.x + dx * t, p0.y + dy * s);
					}

					s_pointsSmooth[s_pointsSmooth.Length - 2] = s_pointsLinear[2];
					s_pointsSmooth[s_pointsSmooth.Length - 1] = s_pointsLinear[3];
				}

				Handles.DrawPolyLine(styleSmooth ? s_pointsSmooth : s_pointsLinear);
			}

			// draw markers
			{
				var markerCenter = Matrix4x4.Translate(new Vector3(-11.0f, 0.0f, 0.0f));
				var markerRotate = s_pointsLinear[0].y < s_pointsLinear[3].y ? 90.0f : -90.0f;

				var matrix = GUI.matrix;
				GUI.matrix = Matrix4x4.TRS(s_pointsLinear[1], Quaternion.Euler(0.0f, 0.0f, -markerRotate), 0.8f * Vector3.one) * markerCenter;
				GUI.Label(Rect.zero, GUIContent.none, EditorStyles.foldout);
				GUI.matrix = Matrix4x4.TRS(s_pointsLinear[2], Quaternion.Euler(0.0f, 0.0f, markerRotate), 0.8f * Vector3.one) * markerCenter;
				GUI.Label(Rect.zero, GUIContent.none, EditorStyles.foldout);
				GUI.matrix = matrix;
			}

			// done
			return value;
		}
	}
}

```

`Editor/Utility/HairGUI.LinearRampWidget.cs.meta`:

```meta
fileFormatVersion: 2
guid: f0e7909f27b0c0846bfce3420040820c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utility/HairGUI.RenderingLayerMask.cs`:

```cs
using UnityEngine;
using UnityEngine.Rendering;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static partial class HairGUILayout
	{
		public static void RenderingLayerMask(Rect position, GUIContent label, SerializedProperty property, params GUILayoutOption[] options)
		{
			RenderingLayerMask(EditorGUILayout.GetControlRect(options), label, property);
		}

		public static int RenderingLayerMask(Rect position, GUIContent label, int mask, params GUILayoutOption[] options)
		{
			return RenderingLayerMask(EditorGUILayout.GetControlRect(options), label, mask);
		}
	}

	public static partial class HairGUI
	{
		static string[] s_renderingLayerMaskNames = new string[32];
		static string[] s_renderingLayerMaskNamesDefault = new string[]
		{
			"Default",
			"Unused Layer 1",
			"Unused Layer 2",
			"Unused Layer 3",
			"Unused Layer 4",
			"Unused Layer 5",
			"Unused Layer 6",
			"Unused Layer 7",
			"Unused Layer 8",
			"Unused Layer 9",
			"Unused Layer 10",
			"Unused Layer 11",
			"Unused Layer 12",
			"Unused Layer 13",
			"Unused Layer 14",
			"Unused Layer 15",
			"Unused Layer 16",
			"Unused Layer 17",
			"Unused Layer 18",
			"Unused Layer 19",
			"Unused Layer 20",
			"Unused Layer 21",
			"Unused Layer 22",
			"Unused Layer 23",
			"Unused Layer 24",
			"Unused Layer 25",
			"Unused Layer 26",
			"Unused Layer 27",
			"Unused Layer 28",
			"Unused Layer 29",
			"Unused Layer 30",
			"Unused Layer 31",
			"Unused Layer 32",
		};

		public static void RenderingLayerMask(Rect position, GUIContent label, SerializedProperty property)
		{
			label = EditorGUI.BeginProperty(position, label, property);
			{
				EditorGUI.BeginChangeCheck();

				var mask = property.intValue;
				{
					mask = RenderingLayerMask(position, label, mask);
				}

				if (EditorGUI.EndChangeCheck())
				{
					property.intValue = mask;
				}
			}
			EditorGUI.EndProperty();
		}

		public static int RenderingLayerMask(Rect position, GUIContent label, int mask)
		{
			var currentPipelineAsset = GraphicsSettings.currentRenderPipeline;
			if (currentPipelineAsset != null)
			{
				var renderingLayerMaskNames = currentPipelineAsset.renderingLayerMaskNames;
				if (renderingLayerMaskNames != null)
				{
					int n = s_renderingLayerMaskNames.Length;
					int j = Mathf.Min(n, renderingLayerMaskNames.Length);

					for (int i = 0; i != j; i++)
					{
						s_renderingLayerMaskNames[i] = renderingLayerMaskNames[i];
					}

					for (int i = j; i != n; i++)
					{
						s_renderingLayerMaskNames[i] = s_renderingLayerMaskNamesDefault[i];
					}

					return EditorGUI.MaskField(position, label, mask, s_renderingLayerMaskNames);
				}
			}

			using (new EditorGUI.DisabledScope(true))
			{
				return EditorGUI.IntField(position, label, mask);
			}
		}
	}
}

```

`Editor/Utility/HairGUI.RenderingLayerMask.cs.meta`:

```meta
fileFormatVersion: 2
guid: 0c470bce3cfc6d0458fa58a5113bafb0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utility/HairGUILayout.GovernedByPrefabScope.cs`:

```cs
using System;
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static partial class HairGUILayout
	{
		public struct GovernedByPrefabScope : IDisposable
		{
			public bool isPrefabInstance;
			public EditorGUI.DisabledScope disableScope;

			public GovernedByPrefabScope(UnityEngine.Object componentOrGameObject) : this(PrefabUtility.IsPartOfPrefabInstance(componentOrGameObject)) { }
			public GovernedByPrefabScope(bool isPrefabInstance)
			{
				this.isPrefabInstance = isPrefabInstance;
				if (isPrefabInstance)
				{
					EditorGUILayout.BeginHorizontal();
					EditorGUILayout.BeginVertical();
				}

				disableScope = new EditorGUI.DisabledScope(isPrefabInstance);
			}

			public void Dispose()
			{
				disableScope.Dispose();

				if (isPrefabInstance)
				{
					EditorGUILayout.EndVertical();
					using (new HairGUI.ColorScope(Color.Lerp(Color.red, Color.white, 0.75f), HairGUI.ColorType.BackgroundColor))
					{
						GUILayout.Label("prefab", HairGUIStyles.statusBoxVertical, GUILayout.Width(20.0f), GUILayout.ExpandHeight(true));
					}
					EditorGUILayout.EndHorizontal();
				}
			}
		}
	}
}

```

`Editor/Utility/HairGUILayout.GovernedByPrefabScope.cs.meta`:

```meta
fileFormatVersion: 2
guid: 12f422b11f4740c4ca8930a257500af8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utility/HairGUILayout.PropertyRectScope.cs`:

```cs
using System;
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static partial class HairGUILayout
	{
		public struct PropertyRectScope : IDisposable
		{
			public readonly Rect position;
			public readonly GUIContent label;

			public PropertyRectScope(SerializedProperty property, params GUILayoutOption[] options) : this(property, GUIContent.none, options) { }
			public PropertyRectScope(SerializedProperty property, string label, params GUILayoutOption[] options) : this(property, new GUIContent(label), options) { }
			public PropertyRectScope(SerializedProperty property, GUIContent label, params GUILayoutOption[] options)
			{
				this.position = EditorGUILayout.GetControlRect(label != null && label != GUIContent.none, options);
				this.label = EditorGUI.BeginProperty(position, label, property);
			}

			public PropertyRectScope(GUIContent label, SerializedProperty property, float fixedWidth, GUIStyle style)
			{
				this.position = GUILayoutUtility.GetRect(fixedWidth, EditorGUIUtility.singleLineHeight, style, GUILayout.Width(fixedWidth));
				this.label = EditorGUI.BeginProperty(position, label, property);
			}

			public PropertyRectScope(GUIContent label, SerializedProperty property, float minWidth, float maxWidth, GUIStyle style)
			{
				this.position = GUILayoutUtility.GetRect(minWidth, maxWidth, EditorGUIUtility.singleLineHeight, EditorGUIUtility.singleLineHeight, style);
				this.label = EditorGUI.BeginProperty(position, label, property);
			}

			public void Dispose()
			{
				EditorGUI.EndProperty();
			}
		}
	}
}

```

`Editor/Utility/HairGUILayout.PropertyRectScope.cs.meta`:

```meta
fileFormatVersion: 2
guid: 92bddc90d4a996b479ca7e7dc5e8d191
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utility/HairGUILayout.ToggleGroup.cs`:

```cs
using System;
using System.Collections;
using System.Reflection;
using UnityEngine;
using UnityEditor;
using UnityEditorInternal;

namespace Unity.DemoTeam.Hair
{
	public static partial class HairGUILayout
	{
		const float widthSlider = 100.0f;
		const float widthSpacing = 5.0f;
		const float widthToggle = 14.0f;

		public static void ToggleGroup(FieldInfo fieldInfo, SerializedProperty property, GUIContent label)
		{
			var ev = Event.current;
			var evClick = (ev.type == EventType.MouseDown) || (ev.type == EventType.MouseUp);
			var evClickRight = evClick && (ev.button == 1);

			var groupVisible = fieldInfo.GetCustomAttribute<VisibleIfAttribute>();
			if (groupVisible != null)
			{
				if (ComparePropertyUtility.Evaluate(groupVisible, property) == false)
				{
					return;
				}
			}

			EditorGUILayout.BeginHorizontal();

			var groupLabelPrefix = label.text + " ";
			{
				if (TryGetTooltipAttribute(fieldInfo, out var tooltip))
				{
					label.tooltip = tooltip;
				}
			}

			using (var groupScope = new PropertyRectScope(label, property, EditorGUIUtility.labelWidth + widthToggle + 3.0f, EditorStyles.toggle))
			{
				var toggle = EditorGUI.Toggle(groupScope.position, groupScope.label, property.boolValue);
				if (toggle != property.boolValue)
					property.boolValue = toggle;
			}

			using (new EditorGUI.DisabledScope(property.boolValue == false))
			{
				var storedIndentLevel = EditorGUI.indentLevel;
				EditorGUI.indentLevel = 0;

				while (property.Next(enterChildren: false))
				{
					var target = property.serializedObject.targetObject;
					if (target == null)
						continue;

					var field = GetFieldByPropertyPath(target.GetType(), property.propertyPath);
					if (field == null)
						continue;

					var groupItem = field.GetCustomAttribute<ToggleGroupItemAttribute>();
					if (groupItem == null)
						break;

					var groupItem_withTooltip = TryGetTooltipAttribute(field, out var groupItemTooltip);
					if (groupItem.withLabel)
					{
						var groupItemLabel = property.displayName;
						if (groupItemLabel.StartsWith(groupLabelPrefix))
							groupItemLabel = groupItemLabel.Substring(groupLabelPrefix.Length);

						label = new GUIContent(groupItemLabel, groupItemTooltip);
					}
					else
					{
						label = GUIContent.none;
					}

					EditorGUIUtility.labelWidth = GUI.skin.label.CalcSize(label).x;

					var reserveFixed = false;
					var reserveStyle = EditorStyles.layerMaskField;

					var reserveLabel = widthSpacing + EditorGUIUtility.labelWidth;
					var reserveField = widthSpacing + EditorGUIUtility.fieldWidth;
					var reserveExtra = 0.0f;

					var fieldHasRange = false;
					var fieldHasRangeMin = 0.0f;
					var fieldHasRangeMax = 0.0f;
					var fieldHasRenderingLayerMask = false;

					switch (property.propertyType)
					{
						case SerializedPropertyType.Boolean:
							reserveFixed = true;
							reserveField = widthSpacing + widthToggle + (groupItem.withLabel ? -3.0f : 0.0f);
							break;

						case SerializedPropertyType.Integer:
						case SerializedPropertyType.Float:
							if (TryGetRangeAttribute(field, out fieldHasRangeMin, out fieldHasRangeMax))
							{
								fieldHasRange = true;
								reserveExtra = widthSpacing + widthSlider;
							}
							else if (TryGetRenderingLayerMaskAttribute(field))
							{
								fieldHasRenderingLayerMask = true;
							}
							break;
					}

					PropertyRectScope propertyScope;
					{
						var reserveMin = reserveField + (groupItem.withLabel ? reserveLabel : 0.0f);
						var reserveMax = reserveField + reserveLabel + reserveExtra;

						if (reserveFixed)
							propertyScope = new PropertyRectScope(label, property, reserveMin, reserveStyle);
						else
							propertyScope = new PropertyRectScope(label, property, reserveMin, reserveMax, reserveStyle);
					}

					using (propertyScope)
					{
						var position = propertyScope.position.ClipLeft(widthSpacing);
						label = propertyScope.label;

						switch (property.propertyType)
						{
							case SerializedPropertyType.Enum:
								{
									EditorGUI.BeginChangeCheck();

									var enumValueArray = Enum.GetValues(field.FieldType);
									var enumValueIndex = property.enumValueIndex;
									if (enumValueIndex == -1 || enumValueIndex >= enumValueArray.Length)
										enumValueIndex = 0;

									var enumValue = (Enum)enumValueArray.GetValue(enumValueIndex);
									{
										enumValue = EditorGUI.EnumPopup(position, label, enumValue, EditorStyles.popup);
									}

									if (EditorGUI.EndChangeCheck())
									{
										property.enumValueIndex = Array.IndexOf(enumValueArray, enumValue);
									}
								}
								break;

							case SerializedPropertyType.AnimationCurve:
								{
									EditorGUI.BeginChangeCheck();

									var curve = property.animationCurveValue;
									{
										using (new EditorGUI.DisabledScope(evClickRight))
										{
											if (TryGetLinearRampAttribute(field, out var ranges))
												curve = HairGUI.LinearRamp(position, label, curve, ranges);
											else
												curve = EditorGUI.CurveField(position, label, curve);
										}
									}

									if (EditorGUI.EndChangeCheck())
									{
										property.animationCurveValue = curve;
									}
								}
								break;

							case SerializedPropertyType.Float:
								{
									EditorGUI.BeginChangeCheck();

									var value = property.floatValue;
									{
										using (new EditorGUI.DisabledScope(evClickRight))
										{
											if (fieldHasRange)
												value = EditorGUI.Slider(position, label, value, fieldHasRangeMin, fieldHasRangeMax);
											else
												value = EditorGUI.FloatField(position, label, value);
										}
									}

									if (EditorGUI.EndChangeCheck())
									{
										property.floatValue = value;
									}
								}
								break;

							case SerializedPropertyType.Integer:
								{
									EditorGUI.BeginChangeCheck();

									var value = property.intValue;
									{
										using (new EditorGUI.DisabledScope(evClickRight))
										{
											if (fieldHasRange)
												value = EditorGUI.IntSlider(position, label, value, (int)fieldHasRangeMin, (int)fieldHasRangeMax);
											else if (fieldHasRenderingLayerMask)
												value = HairGUI.RenderingLayerMask(position, label, value);
											else
												value = EditorGUI.IntField(position, label, value);
										}
									}

									if (EditorGUI.EndChangeCheck())
									{
										property.intValue = value;
									}
								}
								break;

							case SerializedPropertyType.Boolean:
								{
									EditorGUI.BeginChangeCheck();

									var toggle = property.boolValue;
									{
										toggle = EditorGUI.Toggle(position, label, toggle);
									}

									if (EditorGUI.EndChangeCheck())
									{
										property.boolValue = toggle;
									}
								}
								break;

							case SerializedPropertyType.Vector2:
								{
									EditorGUI.BeginChangeCheck();

									var value = property.vector2Value;
									{
										using (new EditorGUI.DisabledScope(evClickRight))
										{
											value = EditorGUI.Vector2Field(position, label, value);
										}
									}

									if (EditorGUI.EndChangeCheck())
									{
										property.vector2Value = value;
									}
								}
								break;

							case SerializedPropertyType.Vector3:
								{
									EditorGUI.BeginChangeCheck();

									var value = property.vector3Value;
									{
										using (new EditorGUI.DisabledScope(evClickRight))
										{
											value = EditorGUI.Vector3Field(position, label, value);
										}
									}

									if (EditorGUI.EndChangeCheck())
									{
										property.vector3Value = value;
									}
								}
								break;

							case SerializedPropertyType.ObjectReference:
								{
									EditorGUI.BeginChangeCheck();

									var objectReference = property.objectReferenceValue;
									{
										objectReference = EditorGUI.ObjectField(position, label, objectReference, field.FieldType, allowSceneObjects: groupItem.allowSceneObjects);
									}

									if (EditorGUI.EndChangeCheck())
									{
										property.objectReferenceValue = objectReference;
									}
								}
								break;

							case SerializedPropertyType.LayerMask:
								{
									EditorGUI.BeginChangeCheck();

									var concatName = InternalEditorUtility.layers;
									var concatMask = (property.intValue == -1) ? -1 : InternalEditorUtility.LayerMaskToConcatenatedLayersMask(property.intValue);
									{
										concatMask = EditorGUI.MaskField(position, label, concatMask, concatName);
									}

									if (EditorGUI.EndChangeCheck())
									{
										if (concatMask == -1)
											property.intValue = -1;
										else
											property.intValue = InternalEditorUtility.ConcatenatedLayersMaskToLayerMask(concatMask);
									}
								}
								break;

							default:
								Debug.Log("ToggleGroupItem: unsupported property type " + property.propertyType.ToString() + " (at " + property.propertyPath + ")");
								break;
						}

						if (groupItem.withLabel == false && groupItem_withTooltip)
						{
							GUI.Label(position, new GUIContent(string.Empty, groupItemTooltip));
						}
					}

					if (groupItem.withSuffix != null)
					{
						var suffix = new GUIContent(groupItem.withSuffix);
						var suffixWidth = GUI.skin.label.CalcSize(suffix).x;
						var suffixPosition = GUILayoutUtility.GetRect(suffixWidth, EditorGUIUtility.singleLineHeight, reserveStyle, GUILayout.Width(suffixWidth));
						GUI.Label(suffixPosition, suffix);
					}
				}

				EditorGUIUtility.labelWidth = 0;// reset to default
				EditorGUI.indentLevel = storedIndentLevel;
			}

			EditorGUILayout.EndHorizontal();
		}

		static FieldInfo GetFieldByPropertyPath(Type type, string path)
		{
			var start = 0;
			var delim = path.IndexOf('.', start);

			while (delim != -1)
			{
				var field = type.GetField(path.Substring(start, delim - start));
				if (field != null)
				{
					if (field.FieldType.IsArray)
					{
						type = field.FieldType.GetElementType();
						// skip the array section of the property path
						// e.g. foo.Array.data[0].bar
						//         '--- skip ---> ###
						for (int i = 0; i != 3; i++)
						{
							start = delim + 1;
							delim = path.IndexOf('.', start);
						}
					}
					else
					{
						type = field.FieldType;
						start = delim + 1;
						delim = path.IndexOf('.', start);
					}
				}
				else
				{
					return null;
				}
			}

			return type.GetField(path.Substring(start));
		}

		static bool TryGetAttribute<T>(FieldInfo field, out T attribute) where T : PropertyAttribute
		{
			var a = field.GetCustomAttribute<T>();
			if (a != null)
			{
				attribute = a;
				return true;
			}
			else
			{
				attribute = null;
				return false;
			}
		}

		static bool TryGetMinAttribute(FieldInfo field, out float min)
		{
			if (TryGetAttribute<MinAttribute>(field, out var a))
			{
				min = a.min;
				return true;
			}
			else
			{
				min = 0.0f;
				return false;
			}
		}

		static bool TryGetRangeAttribute(FieldInfo field, out float min, out float max)
		{
			if (TryGetAttribute<RangeAttribute>(field, out var a))
			{
				min = a.min;
				max = a.max;
				return true;
			}
			else
			{
				min = 0.0f;
				max = 0.0f;
				return false;
			}
		}

		static bool TryGetTooltipAttribute(FieldInfo field, out string tooltip)
		{
			if (TryGetAttribute<TooltipAttribute>(field, out var a))
			{
				tooltip = a.tooltip;
				return true;
			}
			else
			{
				tooltip = string.Empty;
				return false;
			}
		}

		static bool TryGetLinearRampAttribute(FieldInfo field, out Rect ranges)
		{
			if (TryGetAttribute<LinearRampAttribute>(field, out var a))
			{
				ranges = a.ranges;
				return true;
			}
			else
			{
				ranges = Rect.zero;
				return false;
			}
		}

		static bool TryGetRenderingLayerMaskAttribute(FieldInfo field)
		{
			return TryGetAttribute<RenderingLayerMaskAttribute>(field, out var a);
		}
	}
}

```

`Editor/Utility/HairGUILayout.ToggleGroup.cs.meta`:

```meta
fileFormatVersion: 2
guid: a814ca87741d47e40be034f92e26ea73
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utility/HairGUILayout.cs`:

```cs
using System;
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static partial class HairGUILayout
	{
		public enum StructValidation
		{
			Pass,
			Inaccessible,
		}

		public delegate StructValidation StructValidationGUI(object userData);

		public static void StructPropertyFields(SerializedProperty property)
		{
			var propertyIt = property.Copy();
			var propertyEnd = property.Copy();

			propertyEnd.NextVisible(enterChildren: false);

			for (int i = 0; propertyIt.NextVisible(enterChildren: i == 0); i++)
			{
				if (SerializedProperty.EqualContents(propertyIt, propertyEnd))
					break;

				EditorGUILayout.PropertyField(propertyIt, includeChildren: true);
			}
		}

		public static void StructPropertyFields(SerializedProperty property, StructValidationGUI validationGUI = null, object validationUserData = null)
		{
			var validationResult = validationGUI?.Invoke(validationUserData) ?? StructValidation.Pass;
			{
				using (new EditorGUI.DisabledScope(validationResult == StructValidation.Inaccessible))
				{
					StructPropertyFields(property);
				}
			}
		}

		[Flags]
		public enum StructHeaderFlags
		{
			DefaultParts = Expand,
			DefaultState = Expand | Toggle,
			Expand = 1 << 0,
			Toggle = 1 << 1,
		}

		public static StructHeaderFlags StructHeader(StructHeaderFlags parts, StructHeaderFlags state, string label, string labelToggle = null)
		{
			EditorGUILayout.BeginHorizontal(HairGUIStyles.settingsHeader);

			if (parts.HasFlag(StructHeaderFlags.Expand))
			{
				if (EditorGUILayout.Foldout(state.HasFlag(StructHeaderFlags.Expand), label, toggleOnLabelClick: true, HairGUIStyles.settingsFoldout))
					state |= StructHeaderFlags.Expand;
				else
					state &= ~StructHeaderFlags.Expand;
			}
			else
			{
				EditorGUILayout.LabelField(label, EditorStyles.miniBoldLabel);
				state |= StructHeaderFlags.Expand;
			}

			if (parts.HasFlag(StructHeaderFlags.Toggle))
			{
				GUILayout.Label(labelToggle ?? "Enabled", EditorStyles.miniLabel, GUILayout.ExpandHeight(true), GUILayout.ExpandWidth(false));

				if (GUILayout.Toggle(state.HasFlag(StructHeaderFlags.Toggle), GUIContent.none, GUILayout.Width(16.0f), GUILayout.ExpandHeight(true)))
					state |= StructHeaderFlags.Toggle;
				else
					state &= ~StructHeaderFlags.Toggle;
			}
			else
			{
				state |= StructHeaderFlags.Toggle;
			}

			EditorGUILayout.EndHorizontal();

			return state;
		}

		public static bool StructHeader(string label)
		{
			var state = StructHeader(
				parts: StructHeaderFlags.DefaultParts,
				state: StructHeaderFlags.DefaultState,
				label: label);

			return state.HasFlag(StructHeaderFlags.Expand);
		}

		public static StructHeaderFlags StructPropertyFieldsWithHeader(SerializedProperty property, StructHeaderFlags parts, StructHeaderFlags state, string label = null, string labelToggle = null, StructValidationGUI validationGUI = null, object validationUserData = null)
		{
			if (property.isExpanded)
				state |= StructHeaderFlags.Expand;
			else
				state &= ~StructHeaderFlags.Expand;

			state = StructHeader(parts, state, label ?? property.displayName, labelToggle);

			var expand = state.HasFlag(StructHeaderFlags.Expand);
			if (expand != property.isExpanded)
			{
				property.isExpanded = expand;
			}

			EditorGUI.BeginProperty(GUILayoutUtility.GetLastRect(), null, property);
			EditorGUI.EndProperty();// add context menu for copy/paste/revert/etc.

			if (expand)
			{
				using (new EditorGUI.DisabledScope(state.HasFlag(StructHeaderFlags.Toggle) == false))
				using (new EditorGUI.IndentLevelScope())
				{
					StructPropertyFields(property, validationGUI, validationUserData);
				}
			}

			return state;
		}

		public static bool StructPropertyFieldsWithHeader(SerializedProperty property, StructValidationGUI validationGUI = null, object validationUserData = null) => StructPropertyFieldsWithHeader(property, null as string, validationGUI, validationUserData);
		public static bool StructPropertyFieldsWithHeader(SerializedProperty property, string label, StructValidationGUI validationGUI = null, object validationUserData = null)
		{
			var state = StructPropertyFieldsWithHeader(property,
				parts: StructHeaderFlags.DefaultParts,
				state: StructHeaderFlags.DefaultState,
				label: label,
				validationGUI: validationGUI,
				validationUserData: validationUserData);

			return state.HasFlag(StructHeaderFlags.Expand);
		}


		public static bool StructPropertyFieldsWithHeader(SerializedProperty property, ref bool toggle, StructValidationGUI validationGUI = null, object validationUserData = null) => StructPropertyFieldsWithHeader(property, null, ref toggle, validationGUI, validationUserData);
		public static bool StructPropertyFieldsWithHeader(SerializedProperty property, string label, ref bool toggle, StructValidationGUI validationGUI = null, object validationUserData = null)
		{
			var state = StructPropertyFieldsWithHeader(property,
				parts: StructHeaderFlags.DefaultParts | StructHeaderFlags.Toggle,
				state: (StructHeaderFlags.DefaultParts & ~StructHeaderFlags.Toggle) | (toggle ? StructHeaderFlags.Toggle : 0),
				label: label,
				validationGUI: validationGUI,
				validationUserData: validationUserData);

			toggle = state.HasFlag(StructHeaderFlags.Toggle);
			return state.HasFlag(StructHeaderFlags.Expand);
		}

		public static bool StructPropertyFieldsWithHeader(SerializedProperty property, SerializedProperty toggleProperty, StructValidationGUI validationGUI = null, object validationUserData = null) => StructPropertyFieldsWithHeader(property, null, toggleProperty, validationGUI, validationUserData);
		public static bool StructPropertyFieldsWithHeader(SerializedProperty property, string label, SerializedProperty toggleProperty, StructValidationGUI validationGUI = null, object validationUserData = null)
		{
			var toggle = toggleProperty.boolValue;
			var expand = StructPropertyFieldsWithHeader(property, label, ref toggle, validationGUI, validationUserData);

			if (toggleProperty.boolValue != toggle)
				toggleProperty.boolValue = toggle;

			return expand;
		}
	}
}

```

`Editor/Utility/HairGUILayout.cs.meta`:

```meta
fileFormatVersion: 2
guid: 144f6ac218cac7d4cbc5036639b6fbbb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utility/HairGUIStyles.cs`:

```cs
using UnityEngine;
using UnityEditor;

namespace Unity.DemoTeam.Hair
{
	public static partial class HairGUIStyles
	{
		public static readonly GUIStyle settingsBox;
		public static readonly GUIStyle settingsHeader;
		public static readonly GUIStyle settingsFoldout;

		public static readonly GUIStyle statusBox;
		public static readonly GUIStyle statusBoxVertical;

		public static readonly GUIContent miniButtonIconEdit;
		public static readonly GUIContent miniButtonIconAdd;
		public static readonly GUIContent miniButtonIconSub;

		public static readonly GUIContent miniButtonIconPlay;
		public static readonly GUIContent miniButtonIconPause;
		public static readonly GUIContent miniButtonIconStep;
		public static readonly GUIContent miniButtonIconRewind;

		static HairGUIStyles()
		{
			settingsBox = new GUIStyle(EditorStyles.helpBox);

			settingsHeader = new GUIStyle(EditorStyles.toolbar);
			//settingsHeader.normal.background = Texture2D.redTexture;

			settingsFoldout = new GUIStyle(EditorStyles.foldout);
			settingsFoldout.padding.left += 1;
			settingsFoldout.margin.left += 9;
			settingsFoldout.margin.top += 1;
			settingsFoldout.font = EditorStyles.miniBoldLabel.font;
			settingsFoldout.fontSize = EditorStyles.miniBoldLabel.fontSize;
			settingsFoldout.fontStyle = EditorStyles.miniBoldLabel.fontStyle;

			statusBox = new GUIStyle(GUI.skin.box);
			statusBox.normal.textColor = statusBox.hover.textColor;

			statusBoxVertical = new GUIStyle(EditorStyles.textField);
			statusBoxVertical.font = EditorStyles.miniFont;
			statusBoxVertical.fontSize = 8;
			statusBoxVertical.wordWrap = true;

			miniButtonIconEdit = EditorGUIUtility.IconContent("editicon.sml");
			miniButtonIconAdd = new GUIContent("+");// EditorGUIUtility.IconContent("Toolbar Plus");
			miniButtonIconSub = new GUIContent("-");// EditorGUIUtility.IconContent("Toolbar Minus");

			miniButtonIconPlay = EditorGUIUtility.IconContent("Animation.Play");
			miniButtonIconPause = EditorGUIUtility.IconContent("PauseButton");
			miniButtonIconStep = EditorGUIUtility.IconContent("Animation.NextKey");
			miniButtonIconRewind = EditorGUIUtility.IconContent("Animation.FirstKey");
		}
	}
}

```

`Editor/Utility/HairGUIStyles.cs.meta`:

```meta
fileFormatVersion: 2
guid: 23a4aad0c68c6814093815d19a43c5de
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Experiments.meta`:

```meta
fileFormatVersion: 2
guid: 06ddb4df7fea6b6439fd7095894097bc
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Experiments/AffineInterpolate.cs`:

```cs
using System.Runtime.CompilerServices;
using UnityEngine;
using Unity.Mathematics;
using static Unity.DemoTeam.Hair.AffineUtility;

#if true
public class AffineInterpolate : MonoBehaviour
{
	public Transform transformA;
	public Transform transformB;

	[Range(3, 100)]
	public int samples = 3;

	public Transform contact;

	private void OnDrawGizmos()
	{
		if (transformA == null || transformB == null)
			return;

		// Ma * M = Mb
		// M = Ma^-1 Mb
		var Ma = (float4x4)transformA.localToWorldMatrix;// curr
		var Mb = (float4x4)transformB.localToWorldMatrix;// prev

		var M = math.mul(AffineInverse4x4(Ma), Mb);
		var q = svd.svdRotation((float3x3)M);

		for (int i = 0; i != samples; i++)
		{
			var t = (float)i / (samples - 1);
			var t_prev = (float)(i - 1) / (samples - 1);

			var M_t = AffineInterpolate4x4(M, q.value, t);
			var M_t_prev = AffineInterpolate4x4(M, q.value, t_prev);

			var Mb_t = AffineMul4x4(Ma, M_t);
			var Mb_t_prev = AffineMul4x4(Ma, M_t_prev);

			Gizmos.color = Color.Lerp(Color.Lerp(Color.clear, Color.red, 0.75f), Color.Lerp(Color.clear, Color.green, 0.75f), t);
			Gizmos.matrix = Mb_t;
			Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
			Gizmos.color = Color.red;
			Gizmos.DrawRay(-0.6f * Vector3.one, 0.25f * Vector3.right);
			Gizmos.color = Color.green;
			Gizmos.DrawRay(-0.6f * Vector3.one, 0.25f * Vector3.up);
			Gizmos.color = Color.blue;
			Gizmos.DrawRay(-0.6f * Vector3.one, 0.25f * Vector3.forward);
		}

		if (contact == null)
			return;

		// x = Ma^-1 * xa
		// x(t) = M(t) * Ma^-1 * xa
		var x = math.transform(AffineInverse4x4(Ma), contact.position);

		for (int i = 1; i != samples; i++)
		{
			var t = (float)i / (samples - 1);
			var t_prev = (float)(i - 1) / (samples - 1);

			var M_t = AffineInterpolate4x4(M, q.value, t);
			var M_t_prev = AffineInterpolate4x4(M, q.value, t_prev);

			var Mb_t = AffineMul4x4(Ma, M_t);
			var Mb_t_prev = AffineMul4x4(Ma, M_t_prev);

			var Mb_t_inv = AffineInverse4x4(Mb_t);
			var Mb_t_inv_step = AffineMul4x4(Mb_t_prev, Mb_t_inv);

			var x_t = math.transform(Mb_t, x);
			var x_t_prev = math.transform(Mb_t_inv_step, x_t);

			Gizmos.matrix = Matrix4x4.identity;
			Gizmos.color = Color.Lerp(Color.magenta, Color.yellow, t);
			Gizmos.DrawLine(x_t, x_t_prev);
		}
	}
}
#endif

```

`Experiments/AffineInterpolate.cs.meta`:

```meta
fileFormatVersion: 2
guid: 349667af1d4189b489e3cd7d89ef2ff4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Experiments/LocalShape.cs`:

```cs
#define DEBUG_BEND
//#define DEBUG_BEND_RMF

using UnityEngine;
using Unity.Mathematics;
using static Unity.Mathematics.math;
using static Quat;
using static Constraints;

public class LocalShape : MonoBehaviour
{
	public bool load;

	[Range(0.001f, 1.0f)]
	public float stepLength;

	[Range(0.0f, 90.0f)]
	public float degreesTwist;
	[Range(0.0f, 90.0f)]
	public float degreesBend;

	[Min(1)]
	public int iterationCount = 1;

	public enum IterationMode
	{
		SingleForward,
		BlendedSplit,
		BlendedBefore,
		BlendedAfter,
		ForwardSplit,
		ForwardBefore,
		ForwardAfter,
		ReverseSplit,
		ReverseBefore,
		ReverseAfter,
	}

	public IterationMode iterationMode;
	[Range(-1, 23)]
	public int iterationStopAt = -1;

	public bool plainMul = false;
	public float2 plainScale = 0;
	public bool lerpW = false;

	[Range(0.0f, 1.0f)]
	public float stiffness = 1.0f;
	public StiffnessMode stiffnessMode;
	public enum StiffnessMode
	{
		Constant,
		IterationCount,
		Iteration,
	};

	public AnimationCurve stiffnessCurve = AnimationCurve.Constant(0.0f, 1.0f, 1.0f);

	public Mode mode;
	public enum Mode
	{
		GlobalRotation,
		LocalRotation,
		LocalBendTwist,
		ReferenceBendTwist,
	};

	public bool flatten = false;
	public float flattenDegrees = 45.0f;

	const int _StrandParticleCount = 24;

	float4[] _ParticlePosition = new float4[_StrandParticleCount];
	float4[] _ParticlePositionCheck = new float4[_StrandParticleCount];

	float4[] _InitialRootFrame = new float4[1];
	float4[] _InitialParticleOffset = new float4[_StrandParticleCount];
	float4[] _InitialParticleFrameDelta = new float4[_StrandParticleCount];

	const int strandIndex = 0;
	const int strandParticleBegin = 0;
	const int strandParticleStride = 1;
	const int strandParticleEnd = _StrandParticleCount - 1;

	float visualizationOffset => 5.0f * stepLength;

	private void InitParticles()
	{
		// make a curly thing
		{
			var bendTwist =
				QMul(
					MakeQuaternionFromAxisAngle(Vector3.up, Mathf.Deg2Rad * degreesTwist),
					MakeQuaternionFromAxisAngle(Vector3.right, Mathf.Deg2Rad * degreesBend)
				);

			var bendTwistCheck =
				Quaternion.AngleAxis(degreesTwist, Vector3.up) *
				Quaternion.AngleAxis(degreesBend, Vector3.right);

			var accuBendTwist = MakeQuaternionIdentity();
			var accuBendTwistCheck = Quaternion.identity;

			if (flatten)
			{
				accuBendTwist = QMul(accuBendTwist, MakeQuaternionFromAxisAngle(Vector3.forward, flattenDegrees * Mathf.Deg2Rad));
				accuBendTwistCheck = accuBendTwistCheck * Quaternion.AngleAxis(flattenDegrees, Vector3.forward);
			}

			var accuPos = float3(0,0,0);// (float3)transform.position;
			var accuPosCheck = Vector3.zero;//(Vector3)transform.position;

			for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
			{
				_ParticlePosition[i].xyz = accuPos;
				_ParticlePositionCheck[i].xyz = accuPosCheck;

				accuPos += stepLength * QMul(accuBendTwist, Vector3.up);
				accuPosCheck += stepLength * (accuBendTwistCheck * Vector3.up);

				accuBendTwist = QMul(accuBendTwist, bendTwist);
				accuBendTwistCheck = accuBendTwistCheck * bendTwistCheck;
			}
		}

		// load a curly thing....
		if (load)
		{
			stepLength = 0.006518265f;

			var x = new float[] { -0.0539647266f, 1.66329408f, 0.0420717821f, -0.05892205f, 1.663796f, 0.0462742671f, -0.065399535f, 1.66450787f, 0.0464253053f, -0.06908573f, 1.66530728f, 0.04110922f, -0.068440184f, 1.66279137f, 0.0351307876f, -0.06692716f, 1.66022718f, 0.02933222f, -0.07266835f, 1.657283f, 0.0302585065f, -0.07648469f, 1.65256929f, 0.03264698f, -0.07852129f, 1.64724529f, 0.029485492f, -0.0799734f, 1.64489079f, 0.0235833619f, -0.08198029f, 1.6421032f, 0.0180435f, -0.08148313f, 1.64316154f, 0.0244560242f, -0.07879324f, 1.6388979f, 0.028588051f, -0.07937992f, 1.6362195f, 0.02267451f, -0.08365847f, 1.633886f, 0.0183459837f, -0.08308538f, 1.63372445f, 0.01185498f, -0.08264584f, 1.63011241f, 0.00644685933f, -0.08222081f, 1.62916529f, 1.17910095E-05f, -0.08783199f, 1.62645793f, -0.00190465129f, -0.08868069f, 1.6237092f, -0.00775377825f, -0.0832980648f, 1.62057388f, -0.009673343f, -0.08594932f, 1.62508285f, -0.0135627184f, -0.0869903862f, 1.62739885f, -0.0195660777f, -0.0857876f, 1.62626815f, -0.0258718319f };
			var n = x.Length / 3;

			x = new float[] { -0.5f, 0f, 0f, -0.5103446f, 0f, 0.00374020683f, -0.512277842f, 0f, 0.0145690013f, -0.503866434f, 0f, 0.021657588f, -0.4935218f, 0f, 0.01791738f, -0.4915886f, 0f, 0.00708858855f, -0.5f, 0f, -3.38009426E-10f, -0.5103446f, 0f, 0.00374021f, -0.512277842f, 0f, 0.0145690031f, -0.503866434f, 0f, 0.021657588f, -0.4935218f, 0f, 0.0179173835f, -0.4915886f, 0f, 0.007088582f, -0.5f, 0f, -6.76018852E-10f, -0.5103446f, 0f, 0.00374020776f, -0.512277842f, 0f, 0.01456901f, -0.503866434f, 0f, 0.02165759f, -0.4935218f, 0f, 0.017917376f, -0.4915886f, 0f, 0.00708858436f, -0.5f, 0f, -9.221217E-11f, -0.5103446f, 0f, 0.00374020543f, -0.512277842f, 0f, 0.0145689966f, -0.503866434f, 0f, 0.02165759f, -0.4935218f, 0f, 0.0179173723f, -0.4915886f, 0f, 0.00708857831f };
			stepLength = 0.0110000074f;

			var o = new Vector3(x[0], x[1], x[2]);

			for (int i = 0; i != n; i++)
			{
				_ParticlePosition[i].x = x[3 * i];
				_ParticlePosition[i].y = x[3 * i + 1];
				_ParticlePosition[i].z = x[3 * i + 2];

				_ParticlePositionCheck[i] = _ParticlePosition[i];
			}

			//Debug.Log(n);

		}

		// calc initial particle offsets (from root)
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_InitialParticleOffset[i].xyz = _ParticlePosition[i].xyz - _ParticlePosition[strandParticleBegin].xyz;
		}

		// calc initial strand root material frame
		{
			float3 rootDir0 = normalize(_InitialParticleOffset[strandParticleBegin + strandParticleStride].xyz);
			float3 rootDirMaterialFrame = float3(0, 1, 0);

			_InitialRootFrame[strandIndex] = MakeQuaternionFromTo(rootDirMaterialFrame, rootDir0);
		}

		// calc initial particle material frame deltas
		{
			float4 rootFrame = _InitialRootFrame[strandIndex];
			float4 rootFrameInv = QInverse(rootFrame);

			// root
			_InitialParticleFrameDelta[strandParticleBegin] = MakeQuaternionIdentity();

			// root+1
			float3 r0 = -float3(0, 1, 0);
			float3 r1 = 0;
			float3 r2 = QMul(rootFrameInv, _InitialParticleOffset[strandParticleBegin + strandParticleStride].xyz);
			{
#if DEBUG_BEND
				_InitialParticleFrameDelta[strandParticleBegin + strandParticleStride] = NextQuaternionFromBend(r0, r1, r2, MakeQuaternionIdentity());
#else
				_InitialParticleFrameDelta[strandParticleBegin + strandParticleStride] = MakeQuaternionFromBend(r0, r1, r2);
#endif
			}

			// root+2..
			for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
			{
				r0 = r1;
				r1 = r2;
				r2 = QMul(rootFrameInv, _InitialParticleOffset[i].xyz);

#if DEBUG_BEND
				_InitialParticleFrameDelta[i] = NextQuaternionFromBend(r0, r1, r2, _InitialParticleFrameDelta[i - strandParticleStride]);
#else
				_InitialParticleFrameDelta[i] = normalize(QMul(MakeQuaternionFromBend(r0, r1, r2), _InitialParticleFrameDelta[i - strandParticleStride]));
#endif
			}

			// reverse to finalize
			{
				for (uint i = strandParticleEnd - strandParticleStride; i != strandParticleBegin; i -= strandParticleStride)
				{
					float4 q0 = _InitialParticleFrameDelta[i - strandParticleStride];
					float4 q1 = _InitialParticleFrameDelta[i];

					float4 delta = QMul(QInverse(q0), q1);
					float4 delta_add = delta + MakeQuaternionIdentity();
					float4 delta_sub = delta - MakeQuaternionIdentity();

					if (dot(delta_sub, delta_sub) > dot(delta_add, delta_add))
					{
						delta *= -1.0f;
					}

					_InitialParticleFrameDelta[i] = delta;// normalize(QMul(QConjugate(q0), q1));
				}
			}
		}
	}

	float GetParticleInterval(int strandIndex)
	{
		return stepLength;
	}

	private void OnDrawGizmos()
	{
		Gizmos.matrix = transform.localToWorldMatrix;

		// test
		/*
		{
			// x = -y
			// y = x
			// z = -w
			// w = z
			//float4 q_e_3_bar = float4(-q.y, q.x, -q.w, q.z);//compute q*e_3.conjugate (cheaper than quaternion product)

			float4 q = float4(11, 22, 33, 44);
			float4 e3_bar = QConjugate(float4(0, 1, 0, 0));
			float4 e3_bar_ref = QConjugate(float4(0, 0, 1, 0));

			float4 q_e3_bar = QMul(q, e3_bar);
			float4 q_e3_bar_ref = QMul(q, e3_bar_ref);

			Debug.Log("----");
			Debug.Log("q = " + q);
			Debug.Log("q_e3_bar = " + q_e3_bar);
			Debug.Log("q_e3_bar_ref = " + q_e3_bar_ref);
			Debug.Log("TARGET_ref = " + float4(-22,11,-44,33));
		}
		*/

		InitParticles();

		float4 rootTransform = MakeQuaternion(transform.rotation);
		float4 rootFrame = normalize(QMul(rootTransform, _InitialRootFrame[0]));

		float3 rootPos = _ParticlePosition[strandParticleBegin].xyz;
		float3 rootDir = QMul(rootFrame, float3(0, 1, 0));

		// draw
		{
			var offsetCheck = float3(visualizationOffset * 2, 0, 0);

			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				Gizmos.color = Color.Lerp(Color.white, Color.clear, 0.5f);
				Gizmos.DrawLine(_ParticlePositionCheck[i].xyz + offsetCheck, _ParticlePositionCheck[i - strandParticleStride].xyz + offsetCheck);
				Gizmos.color = Color.green;
				Gizmos.DrawLine(_ParticlePosition[i].xyz, _ParticlePosition[i - strandParticleStride].xyz);
			}
		}

		// modify
		{
			if (load)
			{
				var dt = 1.0f / 60.0f;
				var dv = dt * dt * (float3)Physics.gravity;

				/*if (false)
				{
					for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
					{
						_ParticlePosition[i].xyz += dv;

						Gizmos.color = Color.Lerp(Color.yellow, Color.clear, 0.5f);
						Gizmos.DrawLine(_ParticlePosition[i - strandParticleStride].xyz, _ParticlePosition[i].xyz);
					}
				}*/
			}
			else
			{
				for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
				{
					uint step = i / strandParticleStride;
					float3 dn = float3(0, step * stepLength, 0);

					_ParticlePosition[i].xyz = rootPos + QMul(rootTransform, dn);

					Gizmos.color = Color.Lerp(Color.yellow, Color.clear, 0.5f);
					Gizmos.DrawLine(_ParticlePosition[i - strandParticleStride].xyz, _ParticlePosition[i].xyz);
				}
			}
		}

		// show deltas
		{
			var offset = float3(visualizationOffset, 0, 0);
			var origin = _ParticlePosition[strandParticleBegin].xyz;

			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				Gizmos.color = Color.Lerp(Color.cyan, Color.clear, 0.5f);
				Gizmos.DrawRay(_ParticlePosition[i - strandParticleStride].xyz - offset, stepLength * QMul(_InitialParticleFrameDelta[i], Vector3.up));
			}

			// reconstruction
			float4 q0 = QMul(rootFrame, _InitialParticleFrameDelta[strandParticleBegin]);
			float3 p0 = 0;
			float3 p1 = origin;

			float3 tangent = stepLength * float3(0, 1, 0);

			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				q0 = QMul(q0, _InitialParticleFrameDelta[i]);

				p0 = p1;
				p1 = p0 + QMul(q0, tangent);

				Gizmos.color = Color.Lerp(Color.magenta, Color.clear, 0.2f);
				Gizmos.DrawLine(p0 + offset, p1 + offset);
			}
		}

		// apply deltas
		UnityEngine.Profiling.Profiler.BeginSample("solve");

		//Debug.Log("---- solve frame ----");

		for (int k = 0; k != iterationCount; k++)
		{
			float kS;
			switch (stiffnessMode)
			{
				default:
				case StiffnessMode.Constant:
					kS = stiffness;
					break;
				case StiffnessMode.Iteration:
					kS = 1.0f - pow(saturate(1.0f - stiffness), 1.0f / (1 + k));
					break;
				case StiffnessMode.IterationCount:
					kS = 1.0f - pow(saturate(1.0f - stiffness), 1.0f / iterationCount);
					break;
			}

			// root
			float3 p0 = rootPos - rootDir * GetParticleInterval(strandIndex) * 3.0f;
			float3 p1 = rootPos - rootDir * GetParticleInterval(strandIndex) * 2.0f;
			float3 p2 = rootPos - rootDir * GetParticleInterval(strandIndex);
			float3 p3 = rootPos;

			float4 accuFrame = normalize(QMul(rootFrame, _InitialParticleFrameDelta[strandParticleBegin]));
			float3 accuTangent = GetParticleInterval(strandIndex) * float3(0, 1, 0);

			float4 q0 = QMul(accuFrame, MakeQuaternionTwistIdentity());
			float4 q1 = accuFrame;//MakeQuaternionIdentity();
			float4 q2 = QMul(accuFrame, MakeQuaternionTwistIdentity());
			float4 q3 = accuFrame;

			float w0 = 0.0f;
			float w1 = 0.0f;
			float w2 = 0.0f;
			float w3 = 0.0f;

			float kS_orig = kS;

			// root+1..
			uint i;
			for (i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				float n = (i - strandParticleBegin) / strandParticleStride;
				float t = n / (_StrandParticleCount - 1);
				float c = stiffnessCurve.Evaluate(t);
				//kS = kS_orig * ;

				p0 = p1;
				p1 = p2;
				p2 = p3;
				p3 = _ParticlePosition[i].xyz;

				w0 = w1;
				w1 = w2;
				w2 = w3;
				w3 = 1.0f;

				//ApplyDistanceConstraint(GetParticleInterval(strandIndex), kS, w2, w3, ref p2, ref p3);

				q0 = q1;
				q1 = q2;
				q2 = q3;
#if DEBUG_BEND
				q3 = NextQuaternionFromBend(p1, p2, p3, q2);
#else
				q3 = QMul(MakeQuaternionFromBend(p1, p2, p3), q2);
#endif

				// solve i
				{
					float wq2 = w2;
					float wq3 = w3;
					if (lerpW)
					{
						wq2 = lerp(w1, w2, 1e-6f);
						wq3 = lerp(w2, w3, 1e-6f);
					}
					wq2 = 1.0f;
					wq3 = 1.0f;

					switch (iterationMode)
					{
						case IterationMode.SingleForward:
							{
								ApplyReferenceBendTwist(_InitialParticleFrameDelta[i], kS, wq2, wq3, ref q2, ref q3);
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), kS, w2, w3, wq3, ref p2, ref p3, ref q3, plainMul, plainScale);
							}
							break;
						
						//---- BL
						case IterationMode.BlendedSplit:
							{
								float scale_w = 2.0f;
								float scale_k = 1.0f;
								float3 pX = p2;
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, w1, scale_w * w2, wq2, ref p1, ref pX, ref q2, plainMul, plainScale);
								ApplyReferenceBendTwist(_InitialParticleFrameDelta[i - 0 * strandParticleStride], kS, wq2, wq3, ref q2, ref q3);
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, scale_w * w2, w3, wq3, ref p2, ref p3, ref q3, plainMul, plainScale);
								p2 = lerp(pX, p2, 0.5f);
							}
							break;
						case IterationMode.BlendedBefore:
							{
								float scale_w = 2.0f;
								float scale_k = 1.0f;
								float3 pX = p2;
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, w1, scale_w * w2, wq2, ref p1, ref pX, ref q2, plainMul, plainScale);
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, scale_w * w2, w3, wq3, ref p2, ref p3, ref q3, plainMul, plainScale);
								ApplyReferenceBendTwist(_InitialParticleFrameDelta[i - 0 * strandParticleStride], kS, wq2, wq3, ref q2, ref q3);
								if (i == strandParticleEnd - strandParticleStride)
								{
									ApplyEdgeVectorConstraint(QMul(q3, float3(0, 1, 0)) * GetParticleInterval(strandIndex), scale_k * kS, w2, w3, ref p2, ref p3);
								}
								p2 = lerp(pX, p2, 0.5f);
							}
							break;
						case IterationMode.BlendedAfter:
							{
								float scale_w = 2.0f;
								float scale_k = 0.5f;
								float3 pX = p2;
								ApplyReferenceBendTwist(_InitialParticleFrameDelta[i - 0 * strandParticleStride], kS, wq2, wq3, ref q2, ref q3);
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, w1, scale_w * w2, wq2, ref p1, ref pX, ref q2, plainMul, plainScale);
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, scale_w * w2, w3, wq3, ref p2, ref p3, ref q3, plainMul, plainScale);
								p2 = lerp(pX, p2, 0.5f);
							}
							break;

						//---- FWD
						case IterationMode.ForwardSplit:
							{
								float scale_w = 1.0f;
								float scale_k = 1.0f;
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, w1, scale_w * w2, wq2, ref p1, ref p2, ref q2, plainMul, plainScale);
								ApplyReferenceBendTwist(_InitialParticleFrameDelta[i - 0 * strandParticleStride], kS, wq2, wq3, ref q2, ref q3);
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, scale_w * w2, w3, wq3, ref p2, ref p3, ref q3, plainMul, plainScale);
							}
							break;
						case IterationMode.ForwardBefore:
							{
								float scale_w = 1.0f;
								float scale_k = 1.0f;
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, w1, scale_w * w2, wq2, ref p1, ref p2, ref q2, plainMul, plainScale);
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, scale_w * w2, w3, wq3, ref p2, ref p3, ref q3, plainMul, plainScale);
								ApplyReferenceBendTwist(_InitialParticleFrameDelta[i - 0 * strandParticleStride], kS, 0.5f * wq2, wq3, ref q2, ref q3);
								if (i == strandParticleEnd - strandParticleStride)
								{
									//ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, w2, w3, wq3, ref p2, ref p3, ref q3, plainMul);
									ApplyEdgeVectorConstraint(QMul(q3, float3(0, 1, 0)) * GetParticleInterval(strandIndex), scale_k * kS, w2, w3, ref p2, ref p3);
									//p3 = p2 + QMul(q3, float3(0, 1, 0)) * GetParticleInterval(strandIndex);
								}
							}
							break;
						case IterationMode.ForwardAfter:
							{
								float scale_w = 1.0f;
								float scale_k = 0.5f;
								ApplyReferenceBendTwist(_InitialParticleFrameDelta[i - 0 * strandParticleStride], kS, wq2, wq3, ref q2, ref q3);
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, w1, scale_w * w2, wq2, ref p1, ref p2, ref q2, plainMul, plainScale);
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, scale_w * w2, w3, wq3, ref p2, ref p3, ref q3, plainMul, plainScale);
							}
							break;

						//---- RWD
						case IterationMode.ReverseSplit:
							{
								float scale_w = 1.0f;
								float scale_k = 1.0f;
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, scale_w * w2, w3, wq3, ref p2, ref p3, ref q3, plainMul, plainScale);
								ApplyReferenceBendTwist(_InitialParticleFrameDelta[i - 0 * strandParticleStride], kS, wq2, wq3, ref q2, ref q3);
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, w1, scale_w * w2, wq2, ref p1, ref p2, ref q2, plainMul, plainScale);
							}
							break;
						case IterationMode.ReverseBefore:
							{
								bool debug = false;// ((i + 5) >= strandParticleEnd - strandParticleStride) && (k == iterationCount - 1);
								float scale_w = 1.0f;
								float scale_k = 1.0f;// 0.75f * 0.666f;
								//wq2 = 1.0f;
								//wq3 = 1.0f;
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, scale_w * w2, w3, wq3, ref p2, ref p3, ref q3, plainMul, plainScale);
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, w1, scale_w * w2, wq2, ref p1, ref p2, ref q2, plainMul, plainScale);
								//ApplyReferenceBendTwist(_InitialParticleFrameDelta[i - 0 * strandParticleStride], kS, 0.6666667f * wq2, wq3, ref q2, ref q3, debug : debug);
								ApplyReferenceBendTwist(_InitialParticleFrameDelta[i - 0 * strandParticleStride], kS, 0.5f * wq2, wq3, ref q2, ref q3, debug: debug);
								if (i == strandParticleEnd - strandParticleStride)
								{
									//ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, w2, w3, wq3, ref p2, ref p3, ref q3, plainMul);
									ApplyEdgeVectorConstraint(QMul(q3, float3(0, 1, 0)) * GetParticleInterval(strandIndex), scale_k * kS, w2, w3, ref p2, ref p3);
									//p3 = p2 + QMul(q3, float3(0, 1, 0)) * GetParticleInterval(strandIndex);
								}
							}
							break;
						case IterationMode.ReverseAfter:
							{
								float scale_w = 1.0f;
								float scale_k = 0.5f;
								ApplyReferenceBendTwist(_InitialParticleFrameDelta[i - 0 * strandParticleStride], kS, wq2, wq3, ref q2, ref q3);
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, scale_w * w2, w3, wq3, ref p2, ref p3, ref q3, plainMul, plainScale);
								ApplyReferenceStretchShear(GetParticleInterval(strandIndex), scale_k * kS, w1, scale_w * w2, wq2, ref p1, ref p2, ref q2, plainMul, plainScale);
							}
							break;
					}


				}

				if (k == iterationCount - 1)
				{
					Gizmos.color = Color.magenta;
					Gizmos.DrawRay(0.5f * (p0 + p1), (0.2f * stepLength) * QMul(q1, float3(1, 0, 0)));
					Gizmos.color = Color.cyan;
					Gizmos.DrawRay(0.5f * (p0 + p1), (0.2f * stepLength) * QMul(q1, float3(0, 0, 1)));
				}

				if (i > strandParticleBegin + 2 * strandParticleStride)
				{
					_ParticlePosition[i - strandParticleStride * 2].xyz = p1;
				}

				if (k == iterationCount - 1 && iterationStopAt != -1)
				{
					var j = (i - strandParticleBegin) / strandParticleStride;
					if (j >= iterationStopAt)
					{
						i += strandParticleStride;
						break;
					}
				}
			}

			if (k == iterationCount - 1)
			{
				Gizmos.color = Color.magenta;
				Gizmos.DrawRay(0.5f * (p1 + p2), (0.2f * stepLength) * QMul(q2, float3(1, 0, 0)));
				Gizmos.color = Color.cyan;
				Gizmos.DrawRay(0.5f * (p1 + p2), (0.2f * stepLength) * QMul(q2, float3(0, 0, 1)));

				Gizmos.color = Color.magenta;
				Gizmos.DrawRay(0.5f * (p2 + p3), (0.25f * stepLength) * QMul(q3, float3(1, 0, 0)));
				Gizmos.color = Color.cyan;
				Gizmos.DrawRay(0.5f * (p2 + p3), (0.25f * stepLength) * QMul(q3, float3(0, 0, 1)));
			}

			if (i > strandParticleBegin + strandParticleStride * 2)
				_ParticlePosition[i - strandParticleStride * 2].xyz = p2;
			if (i > strandParticleBegin + strandParticleStride)
				_ParticlePosition[i - strandParticleStride].xyz = p3;
		}

		UnityEngine.Profiling.Profiler.EndSample();

		// draw again
		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			Gizmos.color = Color.Lerp(Color.red, Color.clear, 0.25f);
			Gizmos.DrawLine(_ParticlePosition[i].xyz, _ParticlePosition[i - strandParticleStride].xyz);
			Gizmos.DrawWireSphere(_ParticlePosition[i].xyz, stepLength * 0.02f);
		}
	}
}

public static class Constraints
{
	const float w_EPSILON = 1e-7f;

	// ---- paper ----

	public static void SolveReferenceBendTwist(
		float4 darboux0, in float stiffness,
		in float w0, in float w1,
		in float4 q0, in float4 q1,
		ref float4 d0, ref float4 d1, bool debug)
	{
		// see: "Position and Orientation Based Cosserat Rods" by T. Kugelstadt and E. Schömer
		// https://www.cg.informatik.uni-mainz.de/files/2016/06/Position-and-Orientation-Based-Cosserat-Rods.pdf

		float4 darboux = QMul(QConjugate(q0), q1);

		// apply eq. 32 + 33 to pick closest delta
		float4 delta_add = (darboux + darboux0);
		float4 delta_sub = (darboux - darboux0);
		float4 delta = (dot(delta_add, delta_add) < dot(delta_sub, delta_sub)) ? delta_add : delta_sub;

		if (dot(delta, delta) < 1e-7)
			return;

		//delta *= 0.5f;
		if (debug)
			Debug.Log("||delta|| = " + length(delta));

		// apply eq. 40 to calc corrections
		float W_inv = stiffness / (w0 + w1 + w_EPSILON);

		delta.w = 0.0f;// zero scalar part
		d0 += (w0 * W_inv) * QMul(q1, delta);
		d1 -= (w1 * W_inv) * QMul(q0, delta);
	}

	public static void SolveReferenceStretchShear(
		float distance0, in float stiffness,
		in float w0, in float w1, in float wq,
		in float3 p0, in float3 p1, in float4 q,
		ref float3 d0, ref float3 d1, ref float4 dq, bool plainMul, float2 plainScale)
	{
		// see: "Position and Orientation Based Cosserat Rods" by T. Kugelstadt and E. Schömer
		// https://www.cg.informatik.uni-mainz.de/files/2016/06/Position-and-Orientation-Based-Cosserat-Rods.pdf

		float3 e3 = float3(0, 1, 0);

		// apply eq. 31 to obtain change vector
		float3 r = (p1 - p0) / distance0 - QMul(q, e3);

		// apply eq. 37 to calc corrections
		float W_inv = stiffness / (w0 + w1 + 4.0f * wq * distance0 * distance0 + w_EPSILON);

		d0 += (w0 * W_inv * distance0) * r;
		d1 -= (w1 * W_inv * distance0) * r;
		dq += (wq * W_inv * distance0 * distance0 * 2.0f) * QMul(float4(r, 0), QMul(q, QInverse(float4(e3, 0))));
	}

	public static void ApplyReferenceBendTwist(
		in float4 darboux0, in float stiffness,
		in float w0, in float w1,
		ref float4 q0, ref float4 q1, bool debug = false)
	{
		float4 d0 = 0;
		float4 d1 = 0;
		SolveReferenceBendTwist(darboux0, stiffness, w0, w1, q0, q1, ref d0, ref d1, debug);
		q0 = normalize(q0 + d0);
		q1 = normalize(q1 + d1);
	}

	public static void ApplyReferenceStretchShear(
		in float distance0, in float stiffness,
		in float w0, in float w1, in float wq,
		ref float3 p0, ref float3 p1, ref float4 q, bool plainMul, float2 plainScale)
	{
		float3 d0 = 0;
		float3 d1 = 0;
		float4 dq = 0;
		SolveReferenceStretchShear(distance0, stiffness, w0, w1, wq, p0, p1, q, ref d0, ref d1, ref dq, plainMul, plainScale);
		p0 += d0;
		p1 += d1;
		q = normalize(q + dq);
	}

	public static void SolveEdgeVectorConstraint(
		in float3 v0, in float stiffness,
		in float w0, in float w1,
		in float3 p0, in float3 p1,
		ref float3 d0, ref float3 d1)
	{
		float3 r = (p0 + v0) - p1;

		float W_inv = stiffness / (w0 + w1 + w_EPSILON);

		d0 -= (w0* W_inv) * r;
		d1 += (w1* W_inv) * r;
	}

	public static void ApplyEdgeVectorConstraint(
		in float3 v0, in float stiffness,
		in float w0, in float w1,
		ref float3 p0, ref float3 p1)
	{
		float3 d0 = 0.0f;
		float3 d1 = 0.0f;
		SolveEdgeVectorConstraint(v0, stiffness, w0, w1, p0, p1, ref d0, ref d1);
		p0 += d0;
		p1 += d1;
	}

	public static void SolveDualEdgeVectorConstraint(
		in float3 v0, in float3 v1, in float stiffness,
		in float w0, in float w1, in float w2,
		in float3 p0, in float3 p1, in float3 p2,
		ref float3 d0, ref float3 d1, ref float3 d2)
	{
		float3 r = (p0 - 2.0f * p1 + p2 + v0 - v1);

		float W_inv = (1.0f * stiffness) / (w0 + 4.0f * w1 + w2 + w_EPSILON);

		d0 -= (w0* W_inv) * r;
		d1 += (w1* W_inv * 2.0f) * r;
		d2 -= (w2* W_inv) * r;
	}

	public static void ApplyDualEdgeVectorConstraint(
		in float3 v0, in float3 v1, in float stiffness,
		in float w0, in float w1, in float w2,
		ref float3 p0, ref float3 p1, ref float3 p2)
	{
		float3 d0 = 0.0f;
		float3 d1 = 0.0f;
		float3 d2 = 0.0f;
		SolveDualEdgeVectorConstraint(v0, v1, stiffness, w0, w1, w2, p0, p1, p2, ref d0, ref d1, ref d2);
		p0 += d0;
		p1 += d1;
		p2 += d2;
	}

	public static void SolveDistanceConstraint(
		in float distance0, in float stiffness,
		in float w0, in float w1,
		in float3 p0, in float3 p1,
		ref float3 d0, ref float3 d1)
	{
		//      d0                      d1
		//    .----.                  .----.
		// p0 ------><--------------><------ p1
		//           \______________/
		//               distance0

		float3 r = p1 - p0;
		float rd_inv = max(0.0f, rsqrt(dot(r, r)));

		float delta = 1.0f - (distance0 * rd_inv);
		float W_inv = (delta * stiffness) / (w0 + w1 + w_EPSILON);

		d0 += (w0* W_inv) * r;
		d1 -= (w1* W_inv) * r;
	}

	public static void ApplyDistanceConstraint(in float distance0, in float stiffness, in float w0, in float w1, ref float3 p0, ref float3 p1)
	{
		float3 d0 = 0.0f;
		float3 d1 = 0.0f;
		SolveDistanceConstraint(distance0, stiffness, w0, w1, p0, p1, ref d0, ref d1);
		p0 += d0;
		p1 += d1;
	}
}

public static class Quat
{
	public static float4 QConjugate(float4 q)
	{
		return q * float4(-1.0f, -1.0f, -1.0f, 1.0f);
	}

	public static float4 QInverse(float4 q)
	{
		return QConjugate(q) * rcp(dot(q, q));
	}

	public static float4 QMul(float4 a, float4 b)
	{
		float4 q = float4(0,0,0,0);
		q.xyz = a.w * b.xyz + b.w * a.xyz + cross(a.xyz, b.xyz);
		q.w = a.w * b.w - dot(a.xyz, b.xyz);
		return q;
	}

	public static float3 QMul(float4 q, float3 v)
	{
		float3 t = 2.0f * cross(q.xyz, v);
		return v + q.w * t + cross(q.xyz, t);
	}

	public static float4 MakeQuaternion(Quaternion q)
	{
		return float4(q.x, q.y, q.z, q.w);
	}

	public static float4 QNlerp(float4 a, float4 b, float t)
	{
		float d = dot(a, b);
		if (d < 0.0)
		{
			b = -b;
		}

		return normalize(lerp(a, b, t));
	}

	public static float4 QSlerp(float4 a, float4 b, float t)
	{
		float d = dot(a, b);
		if (d < 0.0)
		{
			d = -d;
			b = -b;
		}

		if (d < (1.0 - 1e-5))
		{
			float2 w = sin(acos(d) * float2(1.0f - t, t)) * rsqrt(1.0f - d * d);
			return a * w.x + b * w.y;
		}
		else
		{
			return normalize(lerp(a, b, t));
		}
	}

	public static float4 MakeQuaternionIdentity()
	{
		return float4(0.0f, 0.0f, 0.0f, 1.0f);
	}

	public static float4 MakeQuaternionTwistIdentity()
	{
		//return MakeQuaternionIdentity();
		return float4(0.0f, 1.0f, 0.0f, 0.0f);
	}

	public static float4 MakeQuaternionFromAxisAngle(float3 axis, float angle)
	{
		float sina = sin(0.5f * angle);
		float cosa = cos(0.5f * angle);
		return float4(axis * sina, cosa);
	}

	public static float4 MakeQuaternionFromTo(float3 u, float3 v)
	{
		float4 q = 0;
		float s = 1.0f + dot(u, v);
		if (s < 1e-7)// if 'u' and 'v' are parallel opposing
		{
			q.xyz = abs(u.x) > abs(u.z) ? float3(-u.y, u.x, 0.0f) : float3(0.0f, -u.z, u.y);
			q.w = 0.0f;
		}
		else
		{
			q.xyz = cross(u, v);
			q.w = s;
		}
		return normalize(q);
	}

	public static float4 MakeQuaternionFromToWithFallback(float3 u, float3 v, float3 w)
	{
		float4 q = 0;
		float s = 1.0f + dot(u, v);
		if (s < 1e-7)// if 'u' and 'v' are parallel opposing
		{
			q.xyz = w;
			q.w = 0.0f;
		}
		else
		{
			q.xyz = cross(u, v);
			q.w = s;
		}
		return normalize(q);
	}

	public static float4 MakeQuaternionFromBend(float3 p0, float3 p1, float3 p2)
	{
		float3 u = normalize(p1 - p0);
		float3 v = normalize(p2 - p1);
		return MakeQuaternionFromTo(u, v);
	}

	public static float4 NextQuaternionFromBend(float3 p0, float3 p1, float3 p2, float4 q1)
	{
#if DEBUG_BEND_RMF
		return NextQuaternionFromBendRMF(p0, p1, p2, q1);
#else
		return NextQuaternionFromBendSA(p0, p1, p2, q1);
#endif
	}

	public static float4 NextQuaternionFromBendSA(float3 p0, float3 p1, float3 p2, float4 q1)
	{
		float3 u = QMul(q1, float3(0, 1, 0));
		float3 v = normalize(p2 - p1);
		//u = normalize(p1 - p0);

		float4 rotTangent = MakeQuaternionFromToWithFallback(u, v, QMul(q1, float3(1, 0, 0)));
		float4 rotTwist = MakeQuaternionTwistIdentity();
		//rotTwist = MakeQuaternionIdentity();

		return normalize(QMul(rotTangent, QMul(q1, rotTwist)));

		//return QMul(MakeQuaternionFromToWithFallback(u, v, QMul(q1, float3(1, 0, 0))), q1);
	}

	public static float4 NextQuaternionFromBendRMF(float3 p0, float3 p1, float3 p2, float4 q1)
	{
		// see: "Computation of Rotation Minimizing Frames" by W. Wang, B. Jüttler, D. Zheng and Y. Liu
		// https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/Computation-of-rotation-minimizing-frames.pdf

		float3 localNormal = float3(0, 0, 1);
		float3 localTangent = float3(0, 1, 0);
		float3 localBitangent = float3(1, 0, 0);

		float3 v1 = normalize(p2 - p1);
		float3 ri = QMul(q1, localBitangent);
		float3 ti = QMul(q1, localTangent);// normalize(p1 - p0);

		float3 rLi = reflect(ri, v1);
		float3 tLi = reflect(ti, v1);

		float3 t2 = v1;
		float3 v2 = normalize(t2 - tLi);
		float3 r2 = reflect(rLi, v2);
		float3 s2 = cross(r2, t2);

#if true
		// build frame
		float4 rotTangent = MakeQuaternionFromToWithFallback(localTangent, t2, ri);
		float4 rotTangentTwist = MakeQuaternionFromToWithFallback(QMul(rotTangent, localNormal), -s2, t2);
		return QMul(rotTangentTwist, rotTangent);
#else
		// rotate existing frame
		float4 rotTangent = MakeQuaternionFromToWithFallback(ti, t2, ri);
		q1 = QMul(rotTangent, q1);
		float4 rotTangentTwist = MakeQuaternionFromToWithFallback(QMul(q1, localBitangent), r2, t2);
		q1 = QMul(rotTangentTwist, q1);
		return q1;
#endif
	}

	public static float4 MakeQuaternionLookAt(float3 forward, float3 up)
	{
		float3 localForward = float3(0.0f, 0.0f, 1.0f);
		float3 localUp = float3(0.0f, 1.0f, 0.0f);

		float4 rotForward = MakeQuaternionFromTo(localForward, forward);
		float4 rotForwardTwist = MakeQuaternionFromToWithFallback(QMul(rotForward, localUp), up, forward);

		return QMul(rotForwardTwist, rotForward);
	}
}

```

`Experiments/LocalShape.cs.meta`:

```meta
fileFormatVersion: 2
guid: db9ede3c93bfefb419fd8b92decfadc6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Experiments/ProjectedCircleDensity.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

public class ProjectedCircleDensity : MonoBehaviour
{
	public enum Mode
	{
		Random,
		Sunflower,
	}

	[Range(0.0f, 1.0f)]
	public float circleRadius = 1.0f;
	[Range(0.0f, 1.0f)]
	public float circleDensity = 1.0f;
	[Range(0.0f, 1.0f)]
	public float circlePadding = 1.0f;
	
	public Mode sampleDistribution = Mode.Random;
	[Range(0.0f, 1.0f)]
	public float sampleRadius = 0.1f;
	public bool sampleRadiusLocked = false;
	[Min(1)]
	public int sampleCount = 10;
	public int sampleSeed = 0;
	Vector2[] samplePoint;

	public bool experimentGraph = false;
	[Range(2, 1000)]
	public int experimentSteps = 1000;
	public bool experimentLog = false;
	public bool experimentRadius = true;

	static float FitSampleRadius(int n, float r, float d)
	{
		var A = Mathf.PI * r * r;
		var a = d * (A / n);
		return Mathf.Sqrt(a / Mathf.PI);
	}

	static Vector2[] MakeRandom(int n, float rb, int seed)
	{
		var point = new Vector2[n];
		{
			UnityEngine.Random.InitState(seed);

			for (int i = 0; i != n; i++)
			{
				point[i] = UnityEngine.Random.insideUnitCircle * rb;
			}
		}
		return point;
	}

	// https://stackoverflow.com/questions/28567166/uniformly-distribute-x-points-inside-a-circle
	static Vector2[] MakeSunflower(int n, float rb, float alpha = 0)
	{
		var point = new Vector2[n];
		{
			var b = Mathf.RoundToInt(alpha * Mathf.Sqrt(n));// number of boundary points
			var phi = (Mathf.Sqrt(5.0f) + 1.0f) / 2.0f;// golden ratio

			static float radius(int k, int n, int b)
			{
				return (k > n - b) ? 1 : Mathf.Sqrt(k - 0.5f) / Mathf.Sqrt(n - (b + 1.0f) / 2.0f);
			}

			for (int k = 1; k <= n; k++)
			{
				var r = radius(k, n, b) * rb;
				var theta = (2.0f * Mathf.PI * k) / (phi * phi);
				point[k - 1] = new Vector2(r * Mathf.Cos(theta), r * Mathf.Sin(theta));
			}
		}
		return point;
	}

	float IntegrateProjectedCoverage(float sampleRadiusScale)
	{
		var d = 0.0f;
		{
			var r = sampleRadius * sampleRadiusScale;
			var x = samplePoint[0].x - r;

			for (int i = 0; i != samplePoint.Length; i++)
			{
				var x0 = samplePoint[i].x - r;
				var x1 = samplePoint[i].x + r;

				if (x < x1)
				{
					if (x > x0)
						d += (x1 - x);
					else
						d += (x1 - x0);

					x = x1;
				}
			}
		}
		return d / (2.0f * circleRadius);
	}

	float ComputeApproximateProjectedCoverage(float sampleRadiusScale)
	{
		return (1.0f - Mathf.Exp(-sampleRadius * sampleCount * sampleRadiusScale / circleRadius));
	}

	void OnValidate()
	{
		if (sampleRadiusLocked == false)
		{
			sampleRadius = FitSampleRadius(sampleCount, circleRadius, circleDensity);
		}

		switch (sampleDistribution)
		{
			case Mode.Random:
				samplePoint = MakeRandom(sampleCount, circleRadius - circlePadding * sampleRadius, sampleSeed);
				break;
			case Mode.Sunflower:
				samplePoint = MakeSunflower(sampleCount, circleRadius - circlePadding * sampleRadius);
				break;
		}

		Array.Sort<Vector2>(samplePoint, (a, b) => a.x.CompareTo(b.x));
	}

	static void GizmoBox(Vector2 p, Vector2 e)
	{
		Gizmos.DrawLine(new Vector3(p.x - e.x, p.y - e.y, 0.0f), new Vector3(p.x + e.x, p.y - e.y, 0.0f));
		Gizmos.DrawLine(new Vector3(p.x + e.x, p.y - e.y, 0.0f), new Vector3(p.x + e.x, p.y + e.y, 0.0f));
		Gizmos.DrawLine(new Vector3(p.x + e.x, p.y + e.y, 0.0f), new Vector3(p.x - e.x, p.y + e.y, 0.0f));
		Gizmos.DrawLine(new Vector3(p.x - e.x, p.y + e.y, 0.0f), new Vector3(p.x - e.x, p.y - e.y, 0.0f));
	}

	static void GizmoBoxFill(Vector2 p, Vector2 e)
	{
		Gizmos.DrawCube(p, 2.0f * e);
	}

	static void GizmoCircle(Vector2 p, float r)
	{
		var n = 32;
		var k = (Mathf.PI * 2.0f) / 32;

		var c_ = Mathf.Cos(k * (n - 1));
		var s_ = Mathf.Sin(k * (n - 1));

		for (int i = 0; i != n; i++)
		{
			var ci = Mathf.Cos(k * i);
			var si = Mathf.Sin(k * i);

			Gizmos.DrawLine(new Vector3(p.x + r * c_, p.y + r * s_, 0.0f), new Vector3(p.x + r * ci, p.y + r * si, 0.0f));

			c_ = ci;
			s_ = si;
		}
	}

	static void GizmoPlot(Vector2 p0, Vector2 p1, float t0, float t1, int n, Func<float, float> f, bool debug = false)
	{
		var e = p1 - p0;
		var k = 1.0f / (n - 1);

		var t_ = k * 0;
		var d_ = f(t_);

		if (debug)
		{
			Debug.Log(t_.ToString("G", CultureInfo.InvariantCulture) + " " + d_.ToString("G", CultureInfo.InvariantCulture));
		}

		for (int i = 1; i != n; i++)
		{
			var ti = k * i;
			var di = f(ti);

			Gizmos.DrawLine(p0 + e * new Vector2(t_, d_), p0 + e * new Vector2(ti, di));

			t_ = ti;
			d_ = di;

			if (debug)
			{
				Debug.Log(t_.ToString("G", CultureInfo.InvariantCulture) + " " + d_.ToString("G", CultureInfo.InvariantCulture));
			}
		}
	}

	struct GizmoScope : IDisposable
	{
		Matrix4x4 m;
		Color c;

		public GizmoScope(Color c) : this(Gizmos.matrix, c) { }
		public GizmoScope(Matrix4x4 m) : this(m, Gizmos.color) { }
		public GizmoScope(Matrix4x4 m, Color c)
		{
			this.m = Gizmos.matrix;
			this.c = Gizmos.color;
			Gizmos.matrix = m;
			Gizmos.color = c;
		}

		public void Dispose()
		{
			Gizmos.matrix = m;
			Gizmos.color = c;
		}
	}

	void OnDrawGizmos()
	{
		var m = this.transform.localToWorldMatrix;
		var c = Color.white;

		using (new GizmoScope(m, c))
		{
			var projectionHeight = circleRadius * 0.2f;
			var projectionOffset = circleRadius + projectionHeight;

			var experimentHeight = circleRadius * 2.0f;
			var experimentOffset = circleRadius * 3.0f + projectionHeight;

			// draw circle
			GizmoCircle(Vector2.zero, circleRadius);

			// draw circle projection
			GizmoBox(new Vector2(0.0f, -projectionOffset), new Vector2(circleRadius, 0.5f * projectionHeight));

			if (samplePoint != null)
			{
				using (new GizmoScope(m, Color.green))
				{
					// draw samples
					for (int i = 0; i != samplePoint.Length; i++)
					{
						GizmoCircle(samplePoint[i], sampleRadius);
					}

					// draw samples projection
					for (int i = 0; i != samplePoint.Length; i++)
					{
						GizmoBoxFill(new Vector2(samplePoint[i].x, -projectionOffset), new Vector2(sampleRadius, 0.4f * projectionHeight));
					}
				}
			}

			// draw integrated coverage
			using (new GizmoScope(Color.green))
			{
				if (samplePoint != null)
				{
					GizmoBoxFill(new Vector2(0.0f, -projectionOffset - projectionHeight), new Vector2(circleRadius * IntegrateProjectedCoverage(1.0f), 0.1f * projectionHeight));
				}
			}

			// draw approximated coverage
			using (new GizmoScope(Color.cyan))
			{
				GizmoBoxFill(new Vector2(0.0f, -projectionOffset - projectionHeight * 1.3f), new Vector2(circleRadius * ComputeApproximateProjectedCoverage(1.0f), 0.1f * projectionHeight));
			}

			// draw experiment
			if (samplePoint != null && experimentGraph)
			{
				var p = new Vector2(experimentOffset, 0.0f);
				var e = new Vector2(experimentHeight, 0.5f * experimentHeight);

				using (new GizmoScope(m, Color.black))
				{
					GizmoBoxFill(p, e + Vector2.one * (experimentHeight * 0.01f));
				}

				using (new GizmoScope(m, Color.grey))
				{
					GizmoBox(p, e);
				}

				// plot lower bound
				using (new GizmoScope(m, Color.red))
				{
					if (experimentRadius)
						GizmoPlot(p - e, p + e, 0.0f, 1.0f, experimentSteps, (t) => (sampleRadius / circleRadius) * (t));
					else
						GizmoPlot(p - e, p + e, 0.0f, 1.0f, experimentSteps, (t) => (sampleRadius / circleRadius) * Mathf.Sqrt(t));
				}

				// plot upper bound
				using (new GizmoScope(m, Color.yellow))
				{
					if (experimentRadius)
						GizmoPlot(p - e, p + e, 0.0f, 1.0f, experimentSteps, (t) => (sampleRadius / circleRadius) * (t * sampleCount));
					else
						GizmoPlot(p - e, p + e, 0.0f, 1.0f, experimentSteps, (t) => (sampleRadius / circleRadius) * (Mathf.Sqrt(t) * sampleCount));
				}

				// plot pow(t, 1 / n)
				using (new GizmoScope(m, Color.cyan))
				{
					//var r = Mathf.Sqrt(circleDensity);
					var sr = sampleRadius / circleRadius;
					var sd = circleDensity / sampleCount;
					var fillFraction = (sampleRadius * sampleRadius * sampleCount) / (circleRadius * circleRadius);
					//GizmoPlot(p - e, p + e, 0.0f, 1.0f, experimentSteps, (t) => Mathf.Pow(circleRadius * t, sr / 2.0f));
					//GizmoPlot(p - e, p + e, 0.0f, 1.0f, experimentSteps, (t) => Mathf.Lerp(sampleRadius * t * sampleCount, sampleRadius * t, Mathf.Sqrt(t)));
					//GizmoPlot(p - e, p + e, 0.0f, 1.0f, experimentSteps, (t) => sampleRadius * t * Mathf.Lerp(sampleCount, 1.0f, t));

					//GizmoPlot(p - e, p + e, 0.0f, 1.0f, experimentSteps, (t) => 0.9240695f - 0.9165581f * Mathf.Exp(-10.58568f * t));
					//*** GizmoPlot(p - e, p + e, 0.0f, 1.0f, experimentSteps, (t) => (1.0f - 1.0f * Mathf.Exp(-1f * circleDensity * t / sr)));
					//GizmoPlot(p - e, p + e, 0.0f, 1.0f, experimentSteps, (t) => (1.0f - Mathf.Exp(-circleDensity * t / sr)));

					if (experimentRadius)
						GizmoPlot(p - e, p + e, 0.0f, 1.0f, experimentSteps, ComputeApproximateProjectedCoverage, experimentLog);
					else
						GizmoPlot(p - e, p + e, 0.0f, 1.0f, experimentSteps, (t) => ComputeApproximateProjectedCoverage(Mathf.Sqrt(t)), experimentLog);
				}
				//using (new GizmoScope(m, Color.Lerp(Color.cyan, Color.magenta, 0.5f)))
				//{
				//	//var r = Mathf.Sqrt(circleDensity);
				//	var sampleArea = sampleRadius * sampleRadius;
				//	var circleArea = circleRadius * circleRadius;
				//	Debug.Log("sampleArea = " + sampleArea + ", circleArea = " + circleArea);

				//	GizmoPlot(p - e, p + e, 0.0f, 1.0f, experimentSteps, (t) => (1.0f - Mathf.Exp(-sampleArea * t / circleArea)));
				//}

				// plot sampled ground truth
				using (new GizmoScope(m, Color.green))
				{
					if (experimentRadius)
						GizmoPlot(p - e, p + e, 0.0f, 1.0f, experimentSteps, IntegrateProjectedCoverage, experimentLog);
					else
						GizmoPlot(p - e, p + e, 0.0f, 1.0f, experimentSteps, (t) => IntegrateProjectedCoverage(Mathf.Sqrt(t)), experimentLog);
				}
			}

			experimentLog = false;
		}
	}
}

```

`Experiments/ProjectedCircleDensity.cs.meta`:

```meta
fileFormatVersion: 2
guid: 8c5f62a9eac86e3428b692013cefee2e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Experiments/Unity.DemoTeam.Hair.Experiments.asmdef`:

```asmdef
{
    "name": "Unity.DemoTeam.Hair.Experiments",
    "rootNamespace": "",
    "references": [
        "GUID:d8b63aba1907145bea998dd612889d6b",
        "GUID:f9dedde5eec30c2468e14d8a7b14626e"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": true,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}
```

`Experiments/Unity.DemoTeam.Hair.Experiments.asmdef.meta`:

```meta
fileFormatVersion: 2
guid: a83bc647f03a4f745b2d6cf5aa416efb
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`LICENSE.md`:

```md
com.unity.demoteam.hair copyright © 2020 Unity Technologies ApS

Licensed under the Unity Companion License for Unity-dependent projects--see [Unity Companion License](http://www.unity3d.com/legal/licenses/Unity_Companion_License). 

Unless expressly provided otherwise, the Software under this license is made available strictly on an “AS IS” BASIS WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED. Please review the license for details on these and other terms and conditions.

```

`LICENSE.md.meta`:

```meta
fileFormatVersion: 2
guid: c2e6e7ce14b90384ca5c94f9bdd5b906
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`README.md`:

```md
# Package: com.unity.demoteam.hair

![Header](Documentation~/Images/header_crop.png)

<div align="justify">An integrated solution for authoring / importing / simulating / rendering strand-based hair in Unity. Built from the ground up with Unity users in mind, and evolved and hardened during the production of 'Enemies', the hair system is applicable not only to realistic digital humans, but also to more stylized content and games. It allows users to easily create 'Hair Assets', either from grooms from external DCC tools (through the alembic file format for curve data), or through simple built-in procedural generation tools (e.g. scatter x amount of hairs on a mesh or other primitive, or using a custom generator). Using a fast and flexible GPU-based solver that works on both strand- and volume-information, the system enables users to interactively set up ‘Hair Instances’ within scenes, and then see and interact with those instances as they are simulated and rendered in real time.</div>


## Requirements

- Unity 2020.2.0f1 +
- Compute shader enabled platform


## Features

* Authoring
	+ Import grooms from external DCC tools through the alembic file format (.abc)
	[ *depends on **com.unity.formats.alembic >= 2.2.2*** ]
	+ Make procedural grooms in just a few clicks
		- Scatter strands on built-in primitives, or on user specified meshes
		- Shape strands using simple parameters like length and curl
		- Plug in your own generators for custom placement
	+ Hierarchical clustering / Level of detail
		- Build clusters and LOD chain automatically from spatial relationships
		- Can also assign artist-provided clump maps + optionally refine them
		- Supports root-, strand-, and simplified strand-level clusters
	+ Need to inject curves from a different system?
		- Plug in your own providers for custom curve data
		- Custom data also benefits from built-in processing pipeline
		
* Skinning
	+ Easily attach strand roots to skinned geometry in a scene
	[ *depends on **com.unity.demoteam.digital-human >= 0.1.1-preview*** ]

* Simulation
	+ Strand-based solver supporting tens of thousands of individual strands
	+ Solver also adds volume-based quantities such as density and pressure
		- Uses physical strand diameter, physical strand margin
		- Applies pressure to preserve the volume of a groom
			- Allows targeting uniform density
			- Allows targeting initial pose density
		- Applies pressure to soften strand-strand collisions
		- Exposes scattering probe to HDRP physical shading model
	+ Fully configurable set of constraints
		- Boundary collision w/ friction
		- Particle-particle distance (soft, hard)
		- Particle-root distance
		- Local bend limiter (<, >, =)
		- Local shape
		- Global position
		- Global rotation
	+ Seamless level of detail

* Rendering
	+ Supports all current rendering pipelines
		- Built-in RP
		- HDRP
		- URP
	+ Easily build your own hair materials
		- Add the ‘HairVertex’ node to any Shader Graph to read the simulation data
		- Add the 'HairVolume' node to access simulation volume data like density
		- (**Planned**) Optionally, assign generic materials as the cost of serializing strands to generic mesh
		[ *will depend on **Unity >= 2021.2** for vertex buffer access* ]
	+ Multiple modes of rendering
		- Render strands as simple line primitives
		- Render strands as view facing triangle strips w/ tangent space normals
		- Render strands as (view facing, for now) tube geometry w/ object space normals
		- Render high quality strands using the upcoming compute-based HDRP line renderer
		[ *depends on **Unity >= 2023.1.0a21*** ]
	+ Seamless level of detail

* Level of detail
	+ Seamless level of detail for both simulation and rendering
	+ Automatic level of detail selection based on viewport coverage
		- Reduce runtime workload by processing only visible set of strands
		- Preserve global coverage as strands individually transition to subpixel
		- LOD scale/bias supported both per-group and per-material
	+ Volume-accurate reduction enabled by hierarchical clustering
		- Reduced set of strands geometry retains volume of full geometry
		- Volume-based effects remain intact for reduced set of strands

## Installation

Use [*Add package from git URL*](https://docs.unity3d.com/Manual/upm-ui-giturl.html) (in the Package Manager): 

```https://github.com/Unity-Technologies/com.unity.demoteam.hair.git```

... or declare the package as a git dependency in `Packages/manifest.json`:

```
"dependencies": {
    "com.unity.demoteam.hair": "https://github.com/Unity-Technologies/com.unity.demoteam.hair.git",
    ...
}
```


## Related links

- Video: [Enemies – real-time cinematic teaser | Unity](https://www.youtube.com/watch?v=eXYUNrgqWUU)
- Video: [Lion: A glimpse of the future with Unity Art Tools | Unity](https://www.youtube.com/watch?v=KpPx_lvthBQ)
- Video: [Time Ghost | Unity 6](https://www.youtube.com/watch?v=o1JIK5W3DRU)


## References

- [Bender et al. 2015] Position-Based Simulation Methods in Computer Graphics
- [Bridson and Müller-Fischer 2007] Fluid Simulation SIGGRAPH 2007 Course Notes
- [Gibou et al. 2002] A Second Order Accurate Symmetric Discretization of the Poisson Equation on Irregular Domains	
- [Harris 2004] Fast Fluid Dynamics Simulation on the GPU
- [Kelager et al. 2010] A Triangle Bending Constraint Model for Position-Based Dynamics
- [Kim et al. 2012] Long Range Attachments - A Method to Simulate Inextensible Clothing in Computer Games
- [Kugelstadt and Schömer 2016] Position and Orientation Based Cosserat Rods
- [Losasso et al. 2008] Two-Way Coupled SPH and Particle Level Set Fluid Simulation
- [Macklin et al. 2014] Unified particle physics for real-time application
- [Macklin et al. 2019] Small Steps in Physics Simulation
- [McAdams et al. 2009] Detail Preserving Continuum Simulation of Straight Hair
- [Müller et al. 2006] Position Based Dynamics
- [Müller et al. 2012] Fast Simulation of Inextensible Hair and Fur
- [Petrovic et al. 2005] Volumetric Methods for Simulation and Rendering of Hair
- [Zhu and Bridson 2005] Animating Sand as a Fluid


## See also

https://github.com/Unity-Technologies/com.unity.demoteam.digital-human

```

`README.md.meta`:

```meta
fileFormatVersion: 2
guid: 2b71975faadd3564481210a2e84d73eb
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime.meta`:

```meta
fileFormatVersion: 2
guid: 5756ece0e0ebb764c9728ff2d41b4fb8
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairAsset.Deprecated.cs`:

```cs
#pragma warning disable 0282 // ignore undefined ordering

using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public partial class HairAsset
	{
		//TODO explicit layout
		public partial struct StrandGroup
		{
			[EditorBrowsable(EditorBrowsableState.Never), HideInInspector]
			[Obsolete("Removed serialized topology (all topologies are now built at runtime)", false)]
			public Mesh meshAssetLines { get => meshAssetRoots; }

			[EditorBrowsable(EditorBrowsableState.Never), HideInInspector]
			[Obsolete("Removed serialized topology (all topologies are now built at runtime)", false)]
			public Mesh meshAssetStrips { get => meshAssetRoots; }

			[EditorBrowsable(EditorBrowsableState.Never), HideInInspector]
			[Obsolete("Removed serialized topology (all topologies are now built at runtime)", false)]
			public Mesh meshAssetTubes { get => meshAssetRoots; }
		}
	}
}

```

`Runtime/HairAsset.Deprecated.cs.meta`:

```meta
fileFormatVersion: 2
guid: ed89835d46472264fa5404c2752fd4b4
```

`Runtime/HairAsset.Migration.0.cs`:

```cs
using System;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.Rendering;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

#if HAS_PACKAGE_UNITY_ALEMBIC && UNITY_EDITOR
using UnityEngine.Formats.Alembic.Importer;
#endif

namespace Unity.DemoTeam.Hair
{
	// data migration impl. checklist:
	//
	//	- block renamed: capture and migrate all fields
	//	- field(s) renamed: capture and migrate renamed fields
	//	- field(s) changed: capture and migrate changed fields
	//	- field(s) removed: no action
	//
	// data migration is then a simple two-step process:
	//
	//	1. capture old data into trimmed copies of old structures (via FormerlySerializedAs)
	//	2. migrate old data from trimmed copies
	//
	// (old structures are unfortunately also re-serialized)

	using __IMPL__SettingsProcedural = HairAsset.SettingsProcedural;
	using __IMPL__SettingsAlembic = HairAsset.SettingsAlembic;
	using __IMPL__SettingsCustom = HairAsset.SettingsCustom;
	using __IMPL__SettingsResolve = HairAsset.SettingsResolve;

	using __IMPL__StrandGroup = HairAsset.StrandGroup;

	public partial class HairAsset
	{
		[SerializeField, FormerlySerializedAs("settingsProcedural")]
		__0__SettingsProcedural data_0_settingsProcedural = __0__SettingsProcedural.defaults;

		[SerializeField, FormerlySerializedAs("settingsAlembic")]
		__0__SettingsAlembic data_0_settingsAlembic = __0__SettingsAlembic.defaults;

		[SerializeField, FormerlySerializedAs("settingsCustom")]
		__0__SettingsCustom data_0_settingsCustom = __0__SettingsCustom.defaults;

		[SerializeField, FormerlySerializedAs("strandGroups")]
		__0__StrandGroup[] data_0_strandGroups;

		void PerformMigration_0()
		{
			ref var data_IMPL_settingsProcedural = ref this.settingsProcedural;
			ref var data_IMPL_settingsAlembic = ref this.settingsAlembic;
			ref var data_IMPL_settingsCustom = ref this.settingsCustom;

			ref var data_IMPL_strandGroups = ref this.strandGroups;

			// prepare data_IMPL_settingsProcedural
			{
				static void PrepareSettingsProcedural(ref __IMPL__SettingsProcedural out_IMPL)
				{
					out_IMPL.strandDiameter = HairAsset.SharedDefaults.defaultStrandDiameter;
					out_IMPL.strandDiameterVariation = false;
					out_IMPL.strandDiameterVariationAmount = 0.2f;

					out_IMPL.tipScale = 1.0f;
					out_IMPL.tipScaleVariation = false;
					out_IMPL.tipScaleVariationAmount = 0.2f;
					out_IMPL.tipScaleOffset = HairAsset.SharedDefaults.defaultTipScaleOffset;
					out_IMPL.tipScaleOffsetVariation = false;
					out_IMPL.tipScaleOffsetVariationAmount = 0.2f;
				}

				PrepareSettingsProcedural(ref data_IMPL_settingsProcedural);
			}

			// prepare data_IMPL_settingsAlembic
			{
				static void PrepareSettingsAlembic(ref __IMPL__SettingsAlembic out_IMPL)
				{
					out_IMPL.alembicScalePositions = __IMPL__SettingsAlembic.SourceUnit.DataInMeters;
					out_IMPL.alembicScaleDiameters = __IMPL__SettingsAlembic.SourceUnit.DataInCentimeters;
				}

				PrepareSettingsAlembic(ref data_IMPL_settingsAlembic);
			}

			// prepare data_IMPL_settings*.settingsResolve
			{
				static void PrepareSettingsResolve(ref __IMPL__SettingsResolve out_IMPL)
				{
					out_IMPL.strandDiameter = __IMPL__SettingsResolve.StrandDiameter.UseFallback;
					out_IMPL.strandDiameterFallback = 1.0f;

					out_IMPL.tipScale = __IMPL__SettingsResolve.TipScale.UseFallback;
					out_IMPL.tipScaleFallback = 1.0f;
					out_IMPL.tipScaleFallbackOffset = HairAsset.SharedDefaults.defaultTipScaleOffset;

					out_IMPL.additionalData = false;
					out_IMPL.additionalDataMask = __IMPL__SettingsResolve.AdditionalData.All;
				}

				PrepareSettingsResolve(ref data_IMPL_settingsAlembic.settingsResolve);
				PrepareSettingsResolve(ref data_IMPL_settingsCustom.settingsResolve);
			}

			// migrate data_0_settingsProcedural
			{
				ref readonly var in_0 = ref data_0_settingsProcedural;

				// => data_IMPL_settingsProcedural
				{
					static void TransferSettingsProcedural(in __0__SettingsProcedural in_0, ref __IMPL__SettingsProcedural out_IMPL)
					{
						static __IMPL__SettingsProcedural.SubmeshMask TranslateSubmeshMask(__0__SettingsProcedural.SubmeshMask x) => (__IMPL__SettingsProcedural.SubmeshMask)x;

						out_IMPL.placementProvider = in_0.placementProvider;
						out_IMPL.placementMeshGroups = TranslateSubmeshMask(in_0.placementMeshGroups);
						out_IMPL.mappedDensity = in_0.mappedDensity;
						out_IMPL.mappedDirection = in_0.mappedDirection;
						out_IMPL.mappedParameters = in_0.mappedParameters;
					}

					TransferSettingsProcedural(in_0, ref data_IMPL_settingsProcedural);
				}
			}

			// migrate data_0_settings*.settingsResolve
			{
				// => data_IMPL_settings*.settingsResolve
				{
					static void TransferSettingsResolve(in __0__SettingsResolve in_0, ref __IMPL__SettingsResolve out_IMPL)
					{
						static __IMPL__SettingsResolve.RootUV TranslateRootUV(__0__SettingsResolve.RootUV x)
						{
							switch (x)
							{
								case __0__SettingsResolve.RootUV.ResolveFromMesh: return __IMPL__SettingsResolve.RootUV.ResolveFromMesh;
								case __0__SettingsResolve.RootUV.ResolveFromCurveUV: return __IMPL__SettingsResolve.RootUV.ResolveFromCurves;
								default:
								case __0__SettingsResolve.RootUV.Uniform: return __IMPL__SettingsResolve.RootUV.UseFallback;
							}
						}

						out_IMPL.resampleResolution = in_0.resampleParticleCount;

						out_IMPL.rootUV = TranslateRootUV(in_0.rootUV);
						out_IMPL.rootUVFallback = in_0.rootUVConstant;
					}

					TransferSettingsResolve(data_0_settingsAlembic.settingsResolve, ref data_IMPL_settingsAlembic.settingsResolve);
					TransferSettingsResolve(data_0_settingsCustom.settingsResolve, ref data_IMPL_settingsCustom.settingsResolve);
				}
			}

			// migrate data_0_settingsAlembic
			{
				ref readonly var in_0 = ref data_0_settingsAlembic;

				// => data_IMPL_settingsAlembic.settingsResolve
				{
					static void TransferSettingsAlembic(in __0__SettingsAlembic in_0, ref __IMPL__SettingsResolve out_IMPL)
					{
						static __IMPL__SettingsResolve.RootUV TranslateRootUV(__0__SettingsResolve.RootUV x)
						{
							switch (x)
							{
								case __0__SettingsResolve.RootUV.ResolveFromMesh: return __IMPL__SettingsResolve.RootUV.ResolveFromMesh;
								case __0__SettingsResolve.RootUV.ResolveFromCurveUV: return __IMPL__SettingsResolve.RootUV.ResolveFromCurves;
								default:
								case __0__SettingsResolve.RootUV.Uniform: return __IMPL__SettingsResolve.RootUV.UseFallback;
							}
						}

						if (in_0.OLD__transferred == false)
						{
							out_IMPL.rootUV = TranslateRootUV(in_0.OLD__rootUV);
							out_IMPL.rootUVFallback = in_0.OLD__rootUVConstant;
							out_IMPL.rootUVMesh = in_0.OLD__rootUVMesh;

							out_IMPL.resampleCurves = in_0.OLD__resampleCurves;
							out_IMPL.resampleResolution = in_0.OLD__resampleParticleCount;
							out_IMPL.resampleQuality = in_0.OLD__resampleQuality;
						}
					}

					TransferSettingsAlembic(in_0, ref data_IMPL_settingsAlembic.settingsResolve);
				}
			}

			// migrate data_0_strandGroups[]
			{
				// => data_IMPL_strandGroups[]
				{
					static void TransferStrandGroup(in __0__StrandGroup in_0, ref __IMPL__StrandGroup out_IMPL, HairAsset hairAsset)
					{
						out_IMPL.strandLengthTotal = in_0.totalLength;
						out_IMPL.strandParamsMax = new Vector4(in_0.maxStrandLength, 1.0f * 0.001f, 1.0f, 1.0f);
						out_IMPL.strandParamsAvg = new Vector4(in_0.maxStrandLength, 1.0f * 0.001f, 1.0f, 1.0f);

						out_IMPL.rootScale = new Vector4[in_0.rootScale.Length];
						{
							var sumRootScale = 0.0f;

							for (int i = 0; i != out_IMPL.rootScale.Length; i++)
							{
								out_IMPL.rootScale[i].x = in_0.rootScale[i];
								out_IMPL.rootScale[i].y = 1.0f;
								out_IMPL.rootScale[i].z = HairAsset.SharedDefaults.defaultTipScaleOffset;
								out_IMPL.rootScale[i].w = 1.0f;

								sumRootScale += in_0.rootScale[i];
							}

							out_IMPL.strandParamsAvg.x = out_IMPL.strandParamsMax.x * (sumRootScale / out_IMPL.rootScale.Length);
						}

						out_IMPL.particleTexCoord = null;
						out_IMPL.particleDiameter = null;
						out_IMPL.particleFeatures = __IMPL__StrandGroup.ParticleFeatures.Position;

						// ensure valid lod data (note: only meant as placeholder until asset is rebuilt)
						{
							if (out_IMPL.lodCount == 0)
							{
								out_IMPL.lodCount = 1;
								out_IMPL.lodGuideCount = new int[1] { out_IMPL.strandCount };
								out_IMPL.lodGuideIndex = new int[out_IMPL.strandCount];
								out_IMPL.lodThreshold = new float[1] { 1.0f };
								for (int i = 0; i != out_IMPL.lodGuideIndex.Length; i++)
								{
									out_IMPL.lodGuideIndex[i] = i;
								}
							}

							//TODO impl
							if ((out_IMPL.lodGuideCarry?.Length ?? 0) == 0)
							{
								out_IMPL.lodGuideCarry = new float[out_IMPL.lodGuideIndex.Length];
								for (int i = 0; i != out_IMPL.lodGuideCarry.Length; i++)
								{
									out_IMPL.lodGuideCarry[i] = 1.0f;
								}
							}

							//TODO impl
							if ((out_IMPL.lodGuideReach?.Length ?? 0) == 0)
							{
								out_IMPL.lodGuideReach = new float[out_IMPL.lodGuideCarry.Length];
								for (int i = 0; i != out_IMPL.lodGuideReach.Length; i++)
								{
									out_IMPL.lodGuideReach[i] = 0.0f;
								}
							}
						}

						// ensure valid mesh assets
						/*REMOVED
						{
							static void ValidateRenderMesh(__IMPL__StrandGroup out_IMPL, HairAsset hairAsset, ref Mesh meshAsset, HairInstanceBuilder.FnCreateRenderMesh fnCreateRenderMesh)
							{
								var prevName = (meshAsset != null) ? meshAsset.name : null;
								var prevHideFlags = (meshAsset != null ? meshAsset.hideFlags : HideFlags.HideInHierarchy);

								var meshAssetObsolete = (meshAsset != null && (meshAsset.GetVertexAttributeFormat(VertexAttribute.TexCoord0) == VertexAttributeFormat.Float32));
								if (meshAssetObsolete)
								{
#if UNITY_EDITOR
									UnityEditor.AssetDatabase.RemoveObjectFromAsset(meshAsset);
									UnityEngine.Object.DestroyImmediate(meshAsset);
#endif
									meshAsset = null;
								}

								if (meshAsset == null)
								{
									meshAsset = fnCreateRenderMesh(prevHideFlags, out_IMPL.particleMemoryLayout, out_IMPL.strandCount, out_IMPL.strandParticleCount, out_IMPL.bounds);
									meshAsset.name = prevName ?? meshAsset.name;
#if UNITY_EDITOR
									UnityEditor.AssetDatabase.AddObjectToAsset(meshAsset, hairAsset);
#endif
								}
							}

							ValidateRenderMesh(out_IMPL, hairAsset, ref out_IMPL.meshAssetLines, HairInstanceBuilder.CreateRenderMeshLines);
							ValidateRenderMesh(out_IMPL, hairAsset, ref out_IMPL.meshAssetStrips, HairInstanceBuilder.CreateRenderMeshStrips);
							ValidateRenderMesh(out_IMPL, hairAsset, ref out_IMPL.meshAssetTubes, HairInstanceBuilder.CreateRenderMeshTubes);
						}
						*/
					}

					for (int i = 0; i != (data_IMPL_strandGroups?.Length ?? 0); i++)
					{
						TransferStrandGroup(data_0_strandGroups[i], ref data_IMPL_strandGroups[i], this);
					}
				}
			}
		}

		[Serializable]
		// captured @ 46a8b132
		struct __0__SettingsProcedural
		{
			//public enum PlacementType
			//{
			//	Primitive,
			//	Custom,
			//	Mesh,
			//}

			//public enum PrimitiveType
			//{
			//	Curtain,
			//	Brush,
			//	Cap,
			//	StratifiedCurtain,
			//}

			[Flags]
			public enum SubmeshMask
			{
				Submesh0 = 1 << 0,
				Submesh1 = 1 << 1,
				Submesh2 = 1 << 2,
				Submesh3 = 1 << 3,
				Submesh4 = 1 << 4,
				Submesh5 = 1 << 5,
				Submesh6 = 1 << 6,
				Submesh7 = 1 << 7,
			}

			//public enum CurlSamplingStrategy
			//{
			//	RelaxStrandLength,
			//	RelaxCurlSlope,
			//}

			//public PlacementType placement;
			//public PrimitiveType placementPrimitive;
			[FormerlySerializedAs("placementGenerator")]
			public HairAssetCustomPlacement placementProvider;
			//public Mesh placementMesh;
			[FormerlySerializedAs("placementMeshInclude")]
			public SubmeshMask placementMeshGroups;
			[FormerlySerializedAs("placementDensity")]
			public Texture2D mappedDensity;
			[FormerlySerializedAs("paintedDirection")]
			public Texture2D mappedDirection;
			[FormerlySerializedAs("paintedParameters")]
			public Texture2D mappedParameters;

			//public int strandCount;
			//public int strandParticleCount;
			//public float strandLength;
			//public bool strandLengthVariation;
			//public float strandLengthVariationAmount;

			//public bool curl;
			//public float curlRadius;
			//public float curlSlope;
			//public bool curlVariation;
			//public float curlVariationRadius;
			//public float curlVariationSlope;
			//public CurlSamplingStrategy curlSamplingStrategy;

			public static readonly __0__SettingsProcedural defaults = new __0__SettingsProcedural()
			{
				//placement = PlacementType.Primitive,
				//placementPrimitive = PrimitiveType.Curtain,
				placementProvider = null,
				//placementMesh = null,
				placementMeshGroups = (SubmeshMask)(-1),
				mappedDensity = null,
				mappedDirection = null,
				mappedParameters = null,

				//strandCount = 64,
				//strandParticleCount = 32,

				//strandLength = 0.25f,
				//strandLengthVariation = false,
				//strandLengthVariationAmount = 0.2f,

				//curl = false,
				//curlRadius = 1.0f,
				//curlSlope = 0.3f,
				//curlVariation = false,
				//curlVariationRadius = 0.1f,
				//curlVariationSlope = 0.3f,
				//curlSamplingStrategy = CurlSamplingStrategy.RelaxStrandLength,
			};
		}

		[Serializable]
		// captured @ 46a8b132
		struct __0__SettingsAlembic
		{
			//public enum Groups
			//{
			//	Combine,
			//	Preserve,
			//}

#if HAS_PACKAGE_UNITY_ALEMBIC && UNITY_EDITOR
			//public AlembicStreamPlayer alembicAsset;
#endif
			//public Groups alembicAssetGroups;

			public __0__SettingsResolve settingsResolve;

			public static readonly __0__SettingsAlembic defaults = new __0__SettingsAlembic()
			{
#if HAS_PACKAGE_UNITY_ALEMBIC && UNITY_EDITOR
				//alembicAsset = null,
#endif
				//alembicAssetGroups = Groups.Combine,

				settingsResolve = __0__SettingsResolve.defaults,
			};

			[FormerlySerializedAs("rootUV")] public __0__SettingsResolve.RootUV OLD__rootUV;
			[FormerlySerializedAs("rootUVConstant")] public Vector2 OLD__rootUVConstant;
			[FormerlySerializedAs("rootUVMesh")] public Mesh OLD__rootUVMesh;
			[FormerlySerializedAs("resampleCurves")] public bool OLD__resampleCurves;
			[FormerlySerializedAs("resampleParticleCount")] public int OLD__resampleParticleCount;
			[FormerlySerializedAs("resampleQuality")] public int OLD__resampleQuality;
			public bool OLD__transferred;
		}

		[Serializable]
		// captured @ 46a8b132
		struct __0__SettingsCustom
		{
			//public HairAssetCustomData dataProvider;

			public __0__SettingsResolve settingsResolve;

			public static readonly __0__SettingsCustom defaults = new __0__SettingsCustom()
			{
				//dataProvider = null,

				settingsResolve = __0__SettingsResolve.defaults,
			};
		}

		[Serializable]
		// captured @ 46a8b132
		struct __0__SettingsResolve
		{
			public enum RootUV
			{
				Uniform,
				ResolveFromMesh,
				ResolveFromCurveUV,
			}

			public RootUV rootUV;
			public Vector2 rootUVConstant;
			//public Mesh rootUVMesh;

			//public bool resampleCurves;
			public int resampleParticleCount;
			//public int resampleQuality;

			public static readonly __0__SettingsResolve defaults = new __0__SettingsResolve()
			{
				rootUV = RootUV.Uniform,
				rootUVConstant = Vector2.zero,
				//rootUVMesh = null,

				//resampleCurves = true,
				resampleParticleCount = 16,
				//resampleQuality = 1,
			};
		}

		[Serializable]
		// captured @ 46a8b132
		struct __0__StrandGroup
		{
			//public int strandCount;
			//public int strandParticleCount;

			public float maxStrandLength;
			//public float maxParticleInterval;

			public float totalLength;

			//public Bounds bounds;

			//public Vector2[] rootUV;
			public float[] rootScale;
			//public Vector3[] rootPosition;
			//public Vector3[] rootDirection;

			//public Vector3[] particlePosition;
			//public MemoryLayout particleMemoryLayout;

			//public int lodCount;
			//public int[] lodGuideCount;
			//public int[] lodGuideIndex;
			//public float[] lodGuideCarry;
			//public float[] lodThreshold;

			//public Mesh meshAssetRoots;
			//public Mesh meshAssetLines;
			//public Mesh meshAssetStrips;
			//public Mesh meshAssetTubes;

			//public int version;
		}
	}
}

```

`Runtime/HairAsset.Migration.0.cs.meta`:

```meta
fileFormatVersion: 2
guid: 0c9017354b0f2f24ab6184d15cb2bc25
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairAsset.Migration.1.cs`:

```cs
using System;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.Rendering;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

#if HAS_PACKAGE_UNITY_ALEMBIC && UNITY_EDITOR
using UnityEngine.Formats.Alembic.Importer;
#endif

namespace Unity.DemoTeam.Hair
{
	// data migration impl. checklist:
	//
	//	- block renamed: capture and migrate all fields
	//	- field(s) renamed: capture and migrate renamed fields
	//	- field(s) changed: capture and migrate changed fields
	//	- field(s) removed: no action
	//
	// data migration is then a simple two-step process:
	//
	//	1. capture old data into trimmed copies of old structures (via FormerlySerializedAs)
	//	2. migrate old data from trimmed copies
	//
	// (old structures are unfortunately also re-serialized)

	using __IMPL__SettingsProcedural = HairAsset.SettingsProcedural;
	using __IMPL__SettingsAlembic = HairAsset.SettingsAlembic;
	using __IMPL__SettingsCustom = HairAsset.SettingsCustom;
	using __IMPL__SettingsResolve = HairAsset.SettingsResolve;

	using __IMPL__StrandGroup = HairAsset.StrandGroup;

	public partial class HairAsset
	{
		[SerializeField, FormerlySerializedAs("settingsAlembic")]
		__1__SettingsAlembic data_1_settingsAlembic = __1__SettingsAlembic.defaults;

		[SerializeField, FormerlySerializedAs("settingsCustom")]
		__1__SettingsCustom data_1_settingsCustom = __1__SettingsCustom.defaults;

		[SerializeField, FormerlySerializedAs("strandGroups")]
		__1__StrandGroup[] data_1_strandGroups;

		void PerformMigration_1()
		{
			ref var data_IMPL_settingsProcedural = ref this.settingsProcedural;
			ref var data_IMPL_settingsAlembic = ref this.settingsAlembic;
			ref var data_IMPL_settingsCustom = ref this.settingsCustom;

			ref var data_IMPL_strandGroups = ref this.strandGroups;

			// prepare data_IMPL_settingsProcedural
			{
				static void PrepareSettingsProcedural(ref __IMPL__SettingsProcedural out_IMPL)
				{
					out_IMPL.tipScaleVariation = false;
					out_IMPL.tipScaleVariationAmount = 0.2f;
					out_IMPL.tipScaleOffsetVariation = false;
					out_IMPL.tipScaleOffsetVariationAmount = 0.2f;
				}

				PrepareSettingsProcedural(ref data_IMPL_settingsProcedural);
			}

			// prepare data_IMPL_settingsAlembic
			{
				static void PrepareSettingsAlembic(ref __IMPL__SettingsAlembic out_IMPL)
				{
					out_IMPL.alembicScalePositions = __IMPL__SettingsAlembic.SourceUnit.DataInMeters;
					out_IMPL.alembicScaleDiameters = __IMPL__SettingsAlembic.SourceUnit.DataInCentimeters;
				}

				PrepareSettingsAlembic(ref data_IMPL_settingsAlembic);
			}

			// prepare data_IMPL_settings*.settingsResolve
			{
				static void PrepareSettingsResolve(ref __IMPL__SettingsResolve out_IMPL)
				{
					out_IMPL.tipScale = __IMPL__SettingsResolve.TipScale.ResolveFromCurves;
				}

				PrepareSettingsResolve(ref data_IMPL_settingsAlembic.settingsResolve);
				PrepareSettingsResolve(ref data_IMPL_settingsCustom.settingsResolve);
			}

			// migrate data_1_settings*.settingsResolve
			{
				// => data_IMPL_settings*.settingsResolve
				{
					static void TransferSettingsResolve(in __1__SettingsResolve in_1, ref __IMPL__SettingsResolve out_IMPL)
					{
						static __IMPL__SettingsResolve.AdditionalData TranslateTransferAttributes(__1__SettingsResolve.TransferAttributes x) => (__IMPL__SettingsResolve.AdditionalData)x;

						out_IMPL.additionalData = in_1.exportAttributes;
						out_IMPL.additionalDataMask = TranslateTransferAttributes(in_1.exportAttributesMask);
					}

					TransferSettingsResolve(data_1_settingsAlembic.settingsResolve, ref data_IMPL_settingsAlembic.settingsResolve);
					TransferSettingsResolve(data_1_settingsCustom.settingsResolve, ref data_IMPL_settingsCustom.settingsResolve);
				}
			}

			// migrate data_1_strandGroups[]
			{
				// => data_IMPL_strandGroups[]
				{
					static void TransferStrandGroup(in __1__StrandGroup in_1, ref __IMPL__StrandGroup out_IMPL, HairAsset hairAsset)
					{
						out_IMPL.strandLengthTotal = in_1.sumStrandLength;
						out_IMPL.strandParamsMax = new Vector4(in_1.maxStrandLength, in_1.maxStrandDiameter, 0.0f, 0.0f);
						out_IMPL.strandParamsAvg = Vector4.zero;
						{
							var maxTipScale = 0.0f;
							var maxTipScaleOffset = 0.0f;

							var sumRootScale = Vector4.zero;
							var sumRootScaleW = 0.0f;

							for (int i = 0; i != out_IMPL.rootScale.Length; i++)
							{
								var tipScale = out_IMPL.rootScale[i].w;
								var tipScaleOffset = out_IMPL.rootScale[i].z;

								maxTipScale = Mathf.Max(maxTipScale, tipScale);
								maxTipScaleOffset = Mathf.Max(maxTipScaleOffset, tipScaleOffset);

								out_IMPL.rootScale[i].z = tipScaleOffset;
								out_IMPL.rootScale[i].w = tipScale;

								sumRootScale += out_IMPL.rootScale[i].x * out_IMPL.rootScale[i];
								sumRootScaleW += out_IMPL.rootScale[i].x;
							}

							out_IMPL.strandParamsMax.z = maxTipScaleOffset;
							out_IMPL.strandParamsMax.w = maxTipScale;

							out_IMPL.strandParamsAvg = out_IMPL.strandParamsMax;
							out_IMPL.strandParamsAvg.Scale(sumRootScale / sumRootScaleW);
							out_IMPL.strandParamsAvg.y = in_1.avgStrandDiameter;
						}
					}

					for (int i = 0; i != (data_IMPL_strandGroups?.Length ?? 0); i++)
					{
						TransferStrandGroup(data_1_strandGroups[i], ref data_IMPL_strandGroups[i], this);
					}
				}
			}
		}

		[Serializable]
		// captured @ a4dedfe5
		public struct __1__SettingsProcedural
		{
			//public enum PlacementMode
			//{
			//	Primitive = 0,
			//	Custom = 1,
			//	Mesh = 2,
			//}

			//public enum PrimitiveType
			//{
			//	Curtain = 0,
			//	Brush = 1,
			//	Cap = 2,
			//	StratifiedCurtain = 3,
			//}

			//[Flags]
			//public enum SubmeshMask
			//{
			//	Submesh0 = 1 << 0,
			//	Submesh1 = 1 << 1,
			//	Submesh2 = 1 << 2,
			//	Submesh3 = 1 << 3,
			//	Submesh4 = 1 << 4,
			//	Submesh5 = 1 << 5,
			//	Submesh6 = 1 << 6,
			//	Submesh7 = 1 << 7,
			//}

			//public enum CurlSamplingStrategy
			//{
			//	RelaxStrandLength = 0,
			//	RelaxCurlSlope = 1,
			//}

			//public PlacementMode placement;
			//public PrimitiveType placementPrimitive;
			//public HairAssetCustomPlacement placementProvider;
			//public Mesh placementMesh;
			//public SubmeshMask placementMeshGroups;
			//public Texture2D mappedDensity;
			//public Texture2D mappedDirection;
			//public Texture2D mappedParameters;

			//public int strandCount;
			//public int strandParticleCount;

			//public float strandLength;
			//public bool strandLengthVariation;
			//public float strandLengthVariationAmount;
			//public float strandDiameter;
			//public bool strandDiameterVariation;
			//public float strandDiameterVariationAmount;
			//public float tipScale;
			//public float tipScaleOffset;

			//public bool curl;
			//public float curlRadius;
			//public float curlSlope;
			//public bool curlVariation;
			//public float curlVariationRadius;
			//public float curlVariationSlope;
			//public CurlSamplingStrategy curlSamplingStrategy;

			public static readonly __1__SettingsProcedural defaults = new __1__SettingsProcedural()
			{
				//placement = PlacementMode.Primitive,
				//placementPrimitive = PrimitiveType.Curtain,
				//placementProvider = null,
				//placementMesh = null,
				//placementMeshGroups = (SubmeshMask)(-1),
				//mappedDensity = null,
				//mappedDirection = null,
				//mappedParameters = null,

				//strandCount = 64,
				//strandParticleCount = 32,

				//strandLength = 0.25f,
				//strandLengthVariation = false,
				//strandLengthVariationAmount = 0.2f,
				//strandDiameter = SharedDefaults.defaultStrandDiameter,
				//strandDiameterVariation = false,
				//strandDiameterVariationAmount = 0.2f,
				//tipScale = SharedDefaults.defaultTipScale,
				//tipScaleOffset = SharedDefaults.defaultTipScaleOffset,

				//curl = false,
				//curlRadius = 1.0f,
				//curlSlope = 0.3f,
				//curlVariation = false,
				//curlVariationRadius = 0.1f,
				//curlVariationSlope = 0.3f,
				//curlSamplingStrategy = CurlSamplingStrategy.RelaxStrandLength,
			};
		}

		[Serializable]
		// captured @ a4dedfe5
		struct __1__SettingsAlembic
		{
			//public enum Groups
			//{
			//	Combine = 0,
			//	Preserve = 1,
			//}

#if HAS_PACKAGE_UNITY_ALEMBIC && UNITY_EDITOR
			//public AlembicStreamPlayer alembicAsset;
#endif
			//public Groups alembicAssetGroups;

			public __1__SettingsResolve settingsResolve;

			public static readonly __1__SettingsAlembic defaults = new __1__SettingsAlembic()
			{
#if HAS_PACKAGE_UNITY_ALEMBIC && UNITY_EDITOR
				//alembicAsset = null,
#endif
				//alembicAssetGroups = Groups.Combine,

				settingsResolve = __1__SettingsResolve.defaults,
			};
		}

		[Serializable]
		// captured @ a4dedfe5
		struct __1__SettingsCustom
		{
			//public HairAssetCustomData dataProvider;

			public __1__SettingsResolve settingsResolve;

			public static readonly __1__SettingsCustom defaults = new __1__SettingsCustom()
			{
				//dataProvider = null,

				settingsResolve = __1__SettingsResolve.defaults,
			};
		}

		[Serializable]
		// captured @ a4dedfe5
		struct __1__SettingsResolve
		{
			//public enum StrandDiameter
			//{
			//	ResolveFromCurves = 0,
			//	UseFallback = 1,
			//}

			//public enum RootUV
			//{
			//	ResolveFromMesh = 0,
			//	ResolveFromCurves = 1,
			//	UseFallback = 2,
			//}

			[Flags]
			public enum TransferAttributes
			{
				None = 0,
				PerVertexUV = 1 << 1,
				PerVertexWidth = 1 << 0,
				All = PerVertexUV | PerVertexWidth,
			}

			//public bool resampleCurves;
			//public int resampleResolution;
			//public int resampleQuality;

			//public RootUV rootUV;
			//public Mesh rootUVMesh;
			//public Vector2 rootUVFallback;

			//public StrandDiameter strandDiameter;
			//public float strandDiameterScale;
			//public float strandDiameterFallback;
			//public float tipScaleFallback;
			//public float tipScaleFallbackOffset;

			public bool exportAttributes;
			public TransferAttributes exportAttributesMask;

			public static readonly __1__SettingsResolve defaults = new __1__SettingsResolve()
			{
				//resampleCurves = true,
				//resampleResolution = 16,
				//resampleQuality = 3,

				//rootUV = RootUV.UseFallback,
				//rootUVMesh = null,
				//rootUVFallback = Vector2.zero,

				//strandDiameter = StrandDiameter.ResolveFromCurves,
				//strandDiameterScale = 0.01f,
				//strandDiameterFallback = SharedDefaults.defaultStrandDiameter,
				//tipScaleFallback = SharedDefaults.defaultTipScale,
				//tipScaleFallbackOffset = SharedDefaults.defaultTipScaleOffset,

				exportAttributes = false,
				exportAttributesMask = TransferAttributes.All,
			};
		}

		[Serializable]
		// captured @ a4dedfe5
		struct __1__StrandGroup
		{
			//[Flags]
			//public enum ParticleFeatures
			//{
			//	Position = 1 << 0,
			//	TexCoord = 1 << 1,
			//	Diameter = 1 << 2,
			//}

			//public int strandCount;
			//public int strandParticleCount;

			public float sumStrandLength;
			public float maxStrandLength;
			public float maxStrandDiameter;
			public float avgStrandDiameter;

			//public Bounds bounds;

			//public Vector2[] rootUV;
			//public Vector4[] rootScale;

			//public ParticleFeatures particleFeatures;
			//public MemoryLayout particleMemoryLayout;

			//public Vector3[] particlePosition;
			//public Vector2[] particleTexCoord;
			//public float[] particleDiameter;

			//public int lodCount;

			//public int[] lodGuideCount;
			//public int[] lodGuideIndex;
			//public float[] lodGuideCarry;
			//public float[] lodGuideReach;
			//public float[] lodThreshold;

			//public Mesh meshAssetRoots;
		}
	}
}

```

`Runtime/HairAsset.Migration.1.cs.meta`:

```meta
fileFormatVersion: 2
guid: 88d106675429ef54695e89195741a96e
```

`Runtime/HairAsset.Migration.cs`:

```cs
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public partial class HairAsset : IVersionedDataContext
	{
		const int VERSION_IMPL = 2;

		[field: SerializeField]
		public int version { get; private set; } = -1;
		public int VERSION => VERSION_IMPL;

		public void PerformMigrationStep()
		{
			switch (version)
			{
				case 0:
					PerformMigration_0();
					version = VERSION_IMPL;
					break;

				case 1:
					PerformMigration_1();
					version = VERSION_IMPL;
					break;

				case VERSION_IMPL:
					// at latest version
					break;
			}
		}
	}
}

```

`Runtime/HairAsset.Migration.cs.meta`:

```meta
fileFormatVersion: 2
guid: 60bf9b1b04eb68a418740ee9714ace19
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairAsset.Settings.Deprecated.cs`:

```cs
#pragma warning disable 0282 // ignore undefined ordering

using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public partial class HairAsset
	{
		//TODO explicit layout
		public partial struct SettingsResolve
		{
			[EditorBrowsable(EditorBrowsableState.Never), HideInInspector]
			[Obsolete("Renamed SettingsResolve.rootUVConstant (UnityUpgradable) -> rootUVFallback", true)]
			public Vector2 rootUVConstant;

			[EditorBrowsable(EditorBrowsableState.Never), HideInInspector]
			[Obsolete("Renamed SettingsResolve.resampleParticleCount (UnityUpgradable) -> resampleResolution", true)]
			public int resampleParticleCount;
		}
	}
}

```

`Runtime/HairAsset.Settings.Deprecated.cs.meta`:

```meta
fileFormatVersion: 2
guid: 0b8e418a674e5de49945a8cf8e8f7cac
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairAsset.Settings.cs`:

```cs
using System;
using UnityEngine;
using UnityEngine.Serialization;
#if UNITY_2021_2_OR_NEWER
using UnityEngine.Search;
#endif

#if HAS_PACKAGE_UNITY_ALEMBIC && UNITY_EDITOR
using UnityEngine.Formats.Alembic.Importer;
#endif

namespace Unity.DemoTeam.Hair
{
	public partial class HairAsset
	{
		public enum Type
		{
			Procedural	= 0,
			Alembic		= 1,
			Custom		= 2,
		}

		public enum MemoryLayout
		{
			Interleaved	= 0,
			Sequential	= 1,
		}

		public enum StrandClusterMode
		{
			Roots		= 0,
			Strands		= 1,
			Strands3pt	= 2,
		}

		[Serializable]
		public struct SettingsBasic
		{
			[Tooltip("Type of generator")]
			public Type type;
			[Tooltip("Memory layout for the generated strands")]
			public MemoryLayout memoryLayout;
			[ToggleGroup, Tooltip("Build hierarchical LOD clusters for the generated strands (allows reducing cost of simulation and rendering)")]
			public bool kLODClusters;
			[ToggleGroupItem(withLabel = true), Tooltip("Choose how the generated strands are clustered (where Roots == by 3-D root positions, Strands == by n-D strand positions, Strands 3pt == by 9-D quantized strand positions)")]
			public StrandClusterMode kLODClustersClustering;

			public static readonly SettingsBasic defaults = new SettingsBasic()
			{
				type = Type.Procedural,
				memoryLayout = MemoryLayout.Interleaved,
				kLODClusters = true,
				kLODClustersClustering = StrandClusterMode.Strands,
			};
		}

		[Serializable]
		public struct SettingsProcedural
		{
			public enum PlacementMode
			{
				Primitive	= 0,
				Custom		= 1,
				Mesh		= 2,
			}

			public enum PrimitiveType
			{
				Curtain				= 0,
				Brush				= 1,
				Cap					= 2,
				StratifiedCurtain	= 3,
			}

			[Flags]
			public enum SubmeshMask
			{
				Submesh0 = 1 << 0,
				Submesh1 = 1 << 1,
				Submesh2 = 1 << 2,
				Submesh3 = 1 << 3,
				Submesh4 = 1 << 4,
				Submesh5 = 1 << 5,
				Submesh6 = 1 << 6,
				Submesh7 = 1 << 7,
			}

			public enum CurlSamplingStrategy
			{
				RelaxStrandLength	= 0,
				RelaxCurlSlope		= 1,
			}

			[LineHeader("Roots")]

			[Tooltip("Strand placement method")]
			public PlacementMode placement;
			[VisibleIf(nameof(placement), PlacementMode.Primitive), Tooltip("Place strands using builtin primitive generator")]
			public PrimitiveType placementPrimitive;
			[VisibleIf(nameof(placement), PlacementMode.Custom), Tooltip("Place strands using specified custom generator")]
			public HairAssetCustomPlacement placementProvider;
			[VisibleIf(nameof(placement), PlacementMode.Mesh), Tooltip("Place strands on specified triangle mesh")]
			public Mesh placementMesh;
			[VisibleIf(nameof(placement), PlacementMode.Mesh), Tooltip("Included submesh indices")]
			public SubmeshMask placementMeshGroups;
			[VisibleIf(nameof(placement), PlacementMode.Mesh), Tooltip("Place strands on mesh according to specified density map (where 0 == Empty region, 1 == Fully populated region)")]
			public Texture2D mappedDensity;
			[VisibleIf(nameof(placement), PlacementMode.Mesh), Tooltip("Obtain strand direction from specified object-space direction map")]
			public Texture2D mappedDirection;
			[VisibleIf(nameof(placement), PlacementMode.Mesh), Tooltip("Obtain normalized strand parameters from specified 4-channel mask map (where R,G,B,A == Strand length, Strand diameter, Curl radius, Curl slope)")]
			public Texture2D mappedParameters;

			//[ToggleGroup, Tooltip("Initial seed")]
			//public bool seed;
			//[ToggleGroupItem, Min(1)]
			//public uint seedValue;

			[LineHeader("Quantity")]

			[Range(HairSim.MIN_STRAND_COUNT, HairSim.MAX_STRAND_COUNT), Tooltip("Number of strands")]
			public int strandCount;
			[Range(HairSim.MIN_STRAND_PARTICLE_COUNT, HairSim.MAX_STRAND_PARTICLE_COUNT), Tooltip("Number of equidistant particles along each strand")]
			public int strandParticleCount;

			[LineHeader("Proportions")]

			[Range(0.001f, 5.0f), Tooltip("Strand length (in meters)")]
			public float strandLength;
			[ToggleGroup, Tooltip("Enable this to vary the strand lengths")]
			public bool strandLengthVariation;
			[ToggleGroupItem, Range(0.0f, 1.0f), Tooltip("Amount of variation as fraction of strand length")]
			public float strandLengthVariationAmount;
			[Range(0.01f, 100.0f), Tooltip("Strand diameter (in millimeters)")]
			public float strandDiameter;
			[ToggleGroup, Tooltip("Enable this to vary the strand diameters")]
			public bool strandDiameterVariation;
			[ToggleGroupItem, Range(0.0f, 1.0f), Tooltip("Amount of variation as fraction of strand diameter")]
			public float strandDiameterVariationAmount;

			[LineHeader("Tapering")]

			[Range(0.0f, 1.0f)]
			public float tipScale;
			[ToggleGroup]
			public bool tipScaleVariation;
			[ToggleGroupItem, Range(0.0f, 1.0f)]
			public float tipScaleVariationAmount;
			[Range(0.0f, 1.0f)]
			public float tipScaleOffset;
			[ToggleGroup]
			public bool tipScaleOffsetVariation;
			[ToggleGroupItem, Range(0.0f, 1.0f)]
			public float tipScaleOffsetVariationAmount;

			[LineHeader("Curls")]

			[ToggleGroup, Tooltip("Enable this to curl the strands")]
			public bool curl;
			[ToggleGroupItem(withLabel = true), Range(0.0f, 10.0f), Tooltip("Curl radius (in centimeters)")]
			public float curlRadius;
			[ToggleGroupItem(withLabel = true), Range(0.0f, 1.0f), Tooltip("Curl slope")]
			public float curlSlope;
			[ToggleGroup, Tooltip("Enable this to vary the curls")]
			public bool curlVariation;
			[ToggleGroupItem(withLabel = true), Range(0.0f, 1.0f), Tooltip("Amount of variation as fraction of curl radius")]
			public float curlVariationRadius;
			[ToggleGroupItem(withLabel = true), Range(0.0f, 1.0f), Tooltip("Amount of variation as fraction of curl slope")]
			public float curlVariationSlope;
			[Tooltip("Choose which parameter to relax if the curls become undersampled (due to a combination of particle count, strand length, curl radius and slope)")]
			public CurlSamplingStrategy curlSamplingStrategy;

			public static readonly SettingsProcedural defaults = new SettingsProcedural()
			{
				placement = PlacementMode.Primitive,
				placementPrimitive = PrimitiveType.Curtain,
				placementProvider = null,
				placementMesh = null,
				placementMeshGroups = (SubmeshMask)(-1),
				mappedDensity = null,
				mappedDirection = null,
				mappedParameters = null,
				//seed = false,
				//seedValue = 1,

				strandCount = 64,
				strandParticleCount = 32,

				strandLength = SharedDefaults.defaultStrandLength,
				strandLengthVariation = false,
				strandLengthVariationAmount = 0.2f,
				strandDiameter = SharedDefaults.defaultStrandDiameter,
				strandDiameterVariation = false,
				strandDiameterVariationAmount = 0.2f,

				tipScale = SharedDefaults.defaultTipScale,
				tipScaleVariation = false,
				tipScaleVariationAmount = 0.2f,
				tipScaleOffset = SharedDefaults.defaultTipScaleOffset,
				tipScaleOffsetVariation = false,
				tipScaleOffsetVariationAmount = 0.2f,

				curl = false,
				curlRadius = 1.0f,
				curlSlope = 0.3f,
				curlVariation = false,
				curlVariationRadius = 0.1f,
				curlVariationSlope = 0.3f,
				curlSamplingStrategy = CurlSamplingStrategy.RelaxStrandLength,
			};
		}

		[Serializable]
		public struct SettingsAlembic
		{
			public enum Groups
			{
				Combine		= 0,
				Preserve	= 1,
			}

			public enum SourceUnit
			{
				DataInMeters		= 0,
				DataInCentimeters	= 1,
				DataInMillimeters	= 2,
			}

			[LineHeader("Curves")]

#if HAS_PACKAGE_UNITY_ALEMBIC && UNITY_EDITOR
			[Tooltip("Alembic asset containing at least one set of curves")]
#if UNITY_2021_2_OR_NEWER
			[SearchContext("p: ext:abc t:AlembicStreamPlayer", "asset",
				SearchViewFlags.CompactView |
				SearchViewFlags.HideSearchBar |
				SearchViewFlags.DisableInspectorPreview |
				SearchViewFlags.DisableSavedSearchQuery)]
#endif
			public AlembicStreamPlayer alembicAsset;
#endif
			[Tooltip("Whether to combine or preserve subsequent sets of curves with same vertex count")]
			public Groups alembicAssetGroups;

			[LineHeader("Conversion")]

			[Tooltip("Declare unit scale of position data in assigned alembic asset")]
			public SourceUnit alembicScalePositions;
			[Tooltip("Declare unit scale of diameter data in assigned alembic asset")]
			public SourceUnit alembicScaleDiameters;

			[VisibleIf(false)] public SettingsResolve settingsResolve;

			public static readonly SettingsAlembic defaults = new SettingsAlembic()
			{
#if HAS_PACKAGE_UNITY_ALEMBIC && UNITY_EDITOR
				alembicAsset = null,
#endif
				alembicAssetGroups = Groups.Combine,

				alembicScalePositions = SourceUnit.DataInMeters,
				alembicScaleDiameters = SourceUnit.DataInCentimeters,

				settingsResolve = SettingsResolve.defaults,
			};
		}

		[Serializable]
		public struct SettingsCustom
		{
			[LineHeader("Curves")]

			public HairAssetCustomData dataProvider;

			[VisibleIf(false)] public SettingsResolve settingsResolve;

			public static readonly SettingsCustom defaults = new SettingsCustom()
			{
				dataProvider = null,

				settingsResolve = SettingsResolve.defaults,
			};
		}

		[Serializable]
		public partial struct SettingsResolve
		{
			public const int MIN_RESAMPLE_RESOLUTION = HairSim.MIN_STRAND_PARTICLE_COUNT;
			public const int MAX_RESAMPLE_RESOLUTION = HairSim.MAX_STRAND_PARTICLE_COUNT;
			public const int MIN_RESAMPLE_QUALITY = 1;
			public const int MAX_RESAMPLE_QUALITY = 5;

			public enum RootUV
			{
				ResolveFromMesh		= 0,
				ResolveFromCurves	= 1,
				UseFallback			= 2,
			}

			public enum StrandDiameter
			{
				ResolveFromCurves	= 0,
				UseFallback			= 1,
			}

			public enum TipScale
			{
				ResolveFromCurves	= 0,
				UseFallback			= 1,
			}

			[Flags]
			public enum AdditionalData
			{
				None			= 0,
				PerVertexUV		= 1 << 1,
				PerVertexWidth	= 1 << 0,
				All				= PerVertexUV | PerVertexWidth,
			}

			[LineHeader("Processing")]

			[Tooltip("Resample curves to ensure a specific number of equidistant particles along each strand")]
			public bool resampleCurves;
			[Range(MIN_RESAMPLE_RESOLUTION, MAX_RESAMPLE_RESOLUTION), Tooltip("Number of equidistant particles along each strand")]
			public int resampleResolution;
			[Range(MIN_RESAMPLE_QUALITY, MAX_RESAMPLE_QUALITY), Tooltip("Number of resampling iterations")]
			public int resampleQuality;

			[LineHeader("UV Resolve")]

			public RootUV rootUV;
			[VisibleIf(nameof(rootUV), RootUV.ResolveFromMesh)]
			public Mesh rootUVMesh;
			public Vector2 rootUVFallback;

			[LineHeader("Proportions")]

			public StrandDiameter strandDiameter;
			[Range(0.01f, 100.0f), Tooltip("Strand diameter (in millimeters)")]
			public float strandDiameterFallback;

			[LineHeader("Tapering")]

			public TipScale tipScale;
			[Range(0.0f, 1.0f)]
			public float tipScaleFallback;
			[Range(0.0f, 1.0f)]
			public float tipScaleFallbackOffset;

			[LineHeader("Material")]

			[ToggleGroup]
			public bool additionalData;
			[ToggleGroupItem]
			public AdditionalData additionalDataMask;

			public static readonly SettingsResolve defaults = new SettingsResolve()
			{
				resampleCurves = true,
				resampleResolution = 16,
				resampleQuality = 3,

				rootUV = RootUV.UseFallback,
				rootUVMesh = null,
				rootUVFallback = Vector2.zero,

				strandDiameter = StrandDiameter.ResolveFromCurves,
				strandDiameterFallback = SharedDefaults.defaultStrandDiameter,

				tipScale = TipScale.ResolveFromCurves,
				tipScaleFallback = SharedDefaults.defaultTipScale,
				tipScaleFallbackOffset = SharedDefaults.defaultTipScaleOffset,

				additionalData = false,
				additionalDataMask = AdditionalData.All,
			};
		}

		[Serializable]
		public struct SettingsLODClusters
		{
			[LineHeader("Clustering")]

			//[Min(1), Tooltip("Initial seed (evolved with set)")]
			//public int initialSeed;
			[Tooltip("Cluster policy to apply to empty clusters")]
			public ClusterVoid clusterVoid;
			[Tooltip("Cluster allocation policy (where Global == Allocate and iterate within full set, Split Global == Allocate within select cluster but iterate within full set, Split Branching == Allocate and iterate solely within split cluster)")]
			public ClusterAllocationPolicy clusterAllocation;
			[VisibleIf(nameof(clusterAllocation), CompareOp.Neq, ClusterAllocationPolicy.Global), Tooltip("Cluster allocation order for split-type policies (decides the order in which existing clusters are selected to be split into smaller clusters)")]
			public ClusterAllocationOrder clusterAllocationOrder;
			[ToggleGroup, Tooltip("Enable cluster refinement by k-means iteration")]
			public bool clusterRefinement;
			[ToggleGroupItem, Range(1, 200), Tooltip("Number of k-means iterations (upper bound, may finish earlier)")]
			public int clusterRefinementIterations;

			public enum BaseLODMode
			{
				Generated	= 0,
				UVMapped	= 1,
			}

			public enum BaseLODClusterMapFormat
			{
				OneClusterPerColor			= 0,
				OneClusterPerVisualCluster	= 1,
			}

			[Serializable]
			public struct BaseLOD
			{
				[LineHeader("Base LOD")]

				[Tooltip("Choose build path for the lower level clusters (where Generated == Intialize witk k-means++, UV Mapped == Import from cluster maps")]
				public BaseLODMode baseLOD;
			}

			[Serializable]
			public struct BaseLODParamsGenerated
			{
				[Range(0.0f, 1.0f), Tooltip("Number of clusters as fraction of all strands")]
				public float baseLODClusterQuantity;
			}

			[Serializable]
			public struct BaseLODParamsUVMapped
			{
				[Tooltip("Cluster map format (controls how specified cluster maps are interpreted)")]
				public BaseLODClusterMapFormat baseLODClusterFormat;
				[NonReorderable, Tooltip("Cluster map chain (higher indices must provide increasing level of detail)")]
				public Texture2D[] baseLODClusterMaps;
			}

			public enum HighLODMode
			{
				Automatic	= 0,
				Manual		= 1,
			}

			[Serializable]
			public struct HighLOD
			{
				[LineHeader("High LOD")]

				[ToggleGroup, Tooltip("Enable upper level clusters (will be built using lower level clusters as basis)")]
				public bool highLOD;
				[ToggleGroupItem, Tooltip("Choose build path for the upper level clusters")]
				public HighLODMode highLODMode;
			}

			[Serializable]
			public struct HighLODParamsAutomatic
			{
				[Range(0.0f, 1.0f), Tooltip("Number of clusters as fraction of all strands")]
				public float highLODClusterQuantity;
				[Range(1.2f, 8.0f), Tooltip("Upper bound on multiplier for number of clusters per level incremenent")]
				public float highLODClusterExpansion;
			}

			[Serializable]
			public struct HighLODParamsManual
			{
				[Range(0.0f, 1.0f), NonReorderable, Tooltip("Numbers of clusters as fractions of all strands")]
				public float[] highLODClusterQuantities;
			}

			[VisibleIf(false)] public BaseLOD baseLOD;
			[VisibleIf(false)] public BaseLODParamsGenerated baseLODParamsGenerated;
			[VisibleIf(false)] public BaseLODParamsUVMapped baseLODParamsUVMapped;

			[VisibleIf(false)] public HighLOD highLOD;
			[VisibleIf(false)] public HighLODParamsAutomatic highLODParamsAutomatic;
			[VisibleIf(false)] public HighLODParamsManual highLODParamsManual;

			public static readonly SettingsLODClusters defaults = new SettingsLODClusters()
			{
				//initialSeed = 7,
				clusterVoid = ClusterVoid.Preserve,
				clusterAllocation = ClusterAllocationPolicy.SplitBranching,
				clusterAllocationOrder = ClusterAllocationOrder.ByHighestError,
				clusterRefinement = true,
				clusterRefinementIterations = 100,

				baseLOD = new BaseLOD
				{
					baseLOD = BaseLODMode.Generated,
				},
				baseLODParamsGenerated = new BaseLODParamsGenerated
				{
					baseLODClusterQuantity = 0.001f,
				},
				baseLODParamsUVMapped = new BaseLODParamsUVMapped
				{
					baseLODClusterFormat = BaseLODClusterMapFormat.OneClusterPerColor,
				},

				highLOD = new HighLOD
				{
					highLOD = true,
				},
				highLODParamsAutomatic = new HighLODParamsAutomatic
				{
					highLODClusterQuantity = 1.0f,
					highLODClusterExpansion = 2.0f,
				},
				highLODParamsManual = new HighLODParamsManual
				{
					highLODClusterQuantities = new float[]
					{
						0.25f,
						0.5f,
						0.75f,
						1.0f,
					},
				},
			};
		}

		public static class SharedDefaults
		{
			public static readonly float defaultStrandLength = 0.25f;
			public static readonly float defaultStrandDiameter = 1.0f;
			public static readonly float defaultTipScale = 0.15f;
			public static readonly float defaultTipScaleOffset = 0.75f;
		}
	}
}

```

`Runtime/HairAsset.Settings.cs.meta`:

```meta
fileFormatVersion: 2
guid: fd808a4c840613f44b0fa4be63da6c0a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairAsset.cs`:

```cs
using System;
using UnityEngine;
using UnityEngine.Serialization;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

#if HAS_PACKAGE_UNITY_ALEMBIC && UNITY_EDITOR
using UnityEngine.Formats.Alembic.Importer;
#endif

namespace Unity.DemoTeam.Hair
{
	[CreateAssetMenu(menuName = "Hair/Hair Asset", order = 350), PreferBinarySerialization]
	public partial class HairAsset : ScriptableObject
	{
		[Serializable]
		public partial struct StrandGroup
		{
			[Flags]
			public enum ParticleFeatures
			{
				Position = 1 << 0,
				TexCoord = 1 << 1,
				Diameter = 1 << 2,
			}

			public int strandCount;							// strand count
			public int strandParticleCount;					// strand particle count (uniform resolution within group)

			public float strandLengthTotal;					// strand length group total
			public Vector4 strandParamsMax;					// strand params group maximum (x: strand length, y: strand diameter, z: tip scale offset, w: tip scale)
			public Vector4 strandParamsAvg;					// strand params group average (x: strand length, y: strand diameter, z: tip scale offset, w: tip scale)

			[HideInInspector] public Vector2[] rootUV;		// root uv
			[HideInInspector] public Vector4[] rootScale;	// root scale wrt. group maximum (x: strand length, y: strand diameter, z: tip scale offset, w: tip scale)

			[HideInInspector] public ParticleFeatures particleFeatures;
			[HideInInspector] public MemoryLayout particleMemoryLayout;

			[HideInInspector] public Vector3[] particlePosition;
			[HideInInspector] public Vector2[] particleTexCoord;
			[HideInInspector] public float[] particleDiameter;

			[HideInInspector] public Bounds bounds;

			public int lodCount;

			[NonReorderable] public int[] lodGuideCount;	// n: lod index -> num. guides
			[HideInInspector] public int[] lodGuideIndex;	// i: lod index * strand count + strand index -> guide index
			[HideInInspector] public float[] lodGuideCarry;	// f: lod index * strand count + strand index -> guide carry
			[HideInInspector] public float[] lodGuideReach;	// f: lod index * strand count + strand index -> guide reach (approximate cluster extent)
			[HideInInspector] public float[] lodThreshold;	// f: lod index -> relative guide count [0..1]

			[HideInInspector] public Mesh meshAssetRoots;
		}

		public SettingsBasic settingsBasic = SettingsBasic.defaults;
		public SettingsCustom settingsCustom = SettingsCustom.defaults;
		public SettingsAlembic settingsAlembic = SettingsAlembic.defaults;
		public SettingsProcedural settingsProcedural = SettingsProcedural.defaults;
		public SettingsLODClusters settingsLODClusters = SettingsLODClusters.defaults;

		public StrandGroup[] strandGroups;
		public bool strandGroupsAutoBuild;

		public string checksum;

		void Reset()
		{
			version = VERSION;
		}

		void OnValidate()
		{
			if (version < 0)
				version = 0;

			VersionedDataUtility.HandleVersionChangeOnValidate(this);
		}

		void OnEnable()
		{
			VersionedDataUtility.HandleVersionChange(this);
		}
	}

	public static class HairAssetProvisional
	{
		public struct ProceduralRoots : IDisposable
		{
			public struct RootParameters
			{
				public float normalizedStrandLength;
				public float normalizedStrandDiameter;
				public float normalizedCurlRadius;
				public float normalizedCurlSlope;

				public static readonly RootParameters defaults = new RootParameters()
				{
					normalizedStrandLength = 1.0f,
					normalizedStrandDiameter = 1.0f,
					normalizedCurlRadius = 1.0f,
					normalizedCurlSlope = 1.0f,
				};
			}

			public int strandCount;
			public NativeArray<Vector2> rootUV;
			public NativeArray<Vector3> rootPosition;
			public NativeArray<Vector3> rootDirection;
			public NativeArray<RootParameters> rootParameters;// R,G,B,A == Strand length, Strand diameter, Curl radius, Curl slope

			public ProceduralRoots(int strandCount, Allocator allocator = Allocator.Temp)
			{
				this.strandCount = strandCount;
				this.rootUV = new NativeArray<Vector2>(strandCount, allocator, NativeArrayOptions.UninitializedMemory);
				this.rootPosition = new NativeArray<Vector3>(strandCount, allocator, NativeArrayOptions.UninitializedMemory);
				this.rootDirection = new NativeArray<Vector3>(strandCount, allocator, NativeArrayOptions.UninitializedMemory);
				this.rootParameters = new NativeArray<RootParameters>(strandCount, allocator, NativeArrayOptions.UninitializedMemory);
			}

			public unsafe void GetUnsafePtrs(out Vector3* rootPositionPtr, out Vector3* rootDirectionPtr, out Vector2* rootUVPtr, out RootParameters* rootParametersPtr)
			{
				rootUVPtr = (Vector2*)rootUV.GetUnsafePtr();
				rootPositionPtr = (Vector3*)rootPosition.GetUnsafePtr();
				rootDirectionPtr = (Vector3*)rootDirection.GetUnsafePtr();
				rootParametersPtr = (RootParameters*)rootParameters.GetUnsafePtr();
			}

			public void Dispose()
			{
				rootUV.Dispose();
				rootPosition.Dispose();
				rootDirection.Dispose();
				rootParameters.Dispose();
			}
		}

		public struct ProceduralStrands : IDisposable
		{
			public int strandCount;
			public int strandParticleCount;
			public NativeArray<Vector4> rootScale;
			public NativeArray<Vector3> particlePosition;

			public ProceduralStrands(int strandCount, int strandParticleCount, Allocator allocator = Allocator.Temp)
			{
				this.strandCount = strandCount;
				this.strandParticleCount = strandParticleCount;
				this.rootScale = new NativeArray<Vector4>(strandCount, allocator, NativeArrayOptions.UninitializedMemory);
				this.particlePosition = new NativeArray<Vector3>(strandCount * strandParticleCount, allocator, NativeArrayOptions.UninitializedMemory);
			}

			public unsafe void GetUnsafePtrs(out Vector4* rootScalePtr, out Vector3* particlePositionPtr)
			{
				rootScalePtr = (Vector4*)rootScale.GetUnsafePtr();
				particlePositionPtr = (Vector3*)particlePosition.GetUnsafePtr();
			}

			public void Dispose()
			{
				rootScale.Dispose();
				particlePosition.Dispose();
			}
		}

		public struct CurveSet : IDisposable
		{
			[Flags]
			public enum CurveFeatures
			{
				TexCoord = 1 << 0,
				Diameter = 1 << 1,
				Tapering = 1 << 2,
			}

			[Flags]
			public enum VertexFeatures
			{
				Position = 1 << 0,
				TexCoord = 1 << 1,
				Diameter = 1 << 2,
			}

			public struct Tip
			{
				public float tipScale;			// tip scale
				public float tipScaleOffset;	// tip scale offset (offset along curve where tapering begins)
			}

			public int curveCount;							// number of curves in set
			public UnsafeList<int> curveVertexCount;		// i: curve index -> number of vertices in curve
			public UnsafeList<Vector2> curveDataTexCoord;	// i: curve index -> curve root texcoord
			public UnsafeList<float> curveDataDiameter;		// i: curve index -> curve root diameter
			public UnsafeList<Tip> curveDataTapering;		// i: curve index -> curve tapering
			public CurveFeatures curveFeatures;				// m: curve feature flags
			public UnsafeList<Vector3> vertexDataPosition;	// j: vertex index -> curve vertex position
			public UnsafeList<Vector2> vertexDataTexCoord;	// j: vertex index -> curve vertex texcoord
			public UnsafeList<float> vertexDataDiameter;	// j: vertex index -> curve vertex diameter
			public VertexFeatures vertexFeatures;			// m: vertex feature flags
			public float unitScalePosition;					// scale of position data in meters
			public float unitScaleDiameter;					// scale of diameter data in meters

			// vertex data must be laid out sequentially, e.g. for two curves a and b with 4 and 2 vertices respectively:
			//		curveVertexCount	[ 4 2 ]
			//		vertexData*			[ a a a a b b ]
			//
			// vertex data offset for the i'th curve is then given by:
			//		j <- sum( curveVertexCount, 0..i-1 )
			//
			// vertex feature flags are used during processing:
			//		- vertex position is expected (stream required, flag not tested)
			//		- vertex texcoord is optional and is used to export material attribute and/or resolve root uv
			//		- vertex diameter is optional and is used to export material attribute and/or resolve strand diameter and tapering
			//
			// curve feature flags are also used during processing:
			//		- curve texcoord is optional and is used to resolve root uv (takes precedence over vertex texcoord)
			//		- curve diameter is optional and is used to resolve strand diameter (unless vertex diameter is present)
			//		- curve tapering is optional and is used to resolve strand tapering (unless vertex diameter is present)

			public CurveSet(Allocator allocator) : this(0, 0, allocator) { }
			public CurveSet(int initialCurveCapacity, int initialVertexCapacity, Allocator allocator)
			{
				this.curveCount = 0;
				this.curveVertexCount = new UnsafeList<int>(initialCurveCapacity, allocator, NativeArrayOptions.UninitializedMemory);
				this.curveDataTexCoord = new UnsafeList<Vector2>(initialCurveCapacity, allocator, NativeArrayOptions.UninitializedMemory);
				this.curveDataDiameter = new UnsafeList<float>(initialCurveCapacity, allocator, NativeArrayOptions.UninitializedMemory);
				this.curveDataTapering = new UnsafeList<Tip>(initialCurveCapacity, allocator, NativeArrayOptions.UninitializedMemory);
				this.curveFeatures = (CurveFeatures)0;
				this.vertexDataPosition = new UnsafeList<Vector3>(initialVertexCapacity, allocator, NativeArrayOptions.UninitializedMemory);
				this.vertexDataTexCoord = new UnsafeList<Vector2>(initialVertexCapacity, allocator, NativeArrayOptions.UninitializedMemory);
				this.vertexDataDiameter = new UnsafeList<float>(initialVertexCapacity, allocator, NativeArrayOptions.UninitializedMemory);
				this.vertexFeatures = VertexFeatures.Position;
				this.unitScalePosition = 1.0f;
				this.unitScaleDiameter = 1.0f;
			}

			public void Dispose()
			{
				curveVertexCount.Dispose();
				curveDataTexCoord.Dispose();
				curveDataDiameter.Dispose();
				curveDataTapering.Dispose();
				vertexDataPosition.Dispose();
				vertexDataTexCoord.Dispose();
				vertexDataDiameter.Dispose();
			}
		}

		public struct CurveSetInfo
		{
			public int minVertexCount;
			public int maxVertexCount;
			public int sumVertexCount;

			public CurveSetInfo(in CurveSet curveSet)
			{
				if (curveSet.curveCount > 0)
				{
					unsafe
					{
						var curveVertexCountPtr = (int*)curveSet.curveVertexCount.Ptr;

						minVertexCount = curveVertexCountPtr[0];
						maxVertexCount = curveVertexCountPtr[0];
						sumVertexCount = curveVertexCountPtr[0];

						for (int i = 1; i != curveSet.curveCount; i++)
						{
							minVertexCount = Mathf.Min(minVertexCount, curveVertexCountPtr[i]);
							maxVertexCount = Mathf.Max(maxVertexCount, curveVertexCountPtr[i]);
							sumVertexCount += curveVertexCountPtr[i];
						}
					}
				}
				else
				{
					minVertexCount = 0;
					maxVertexCount = 0;
					sumVertexCount = 0;
				}
			}
		}
	}

	public static class HairAssetUtility
	{
		public static void DeclareStrandIterator(HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount, int strandIndex,
			out int strandParticleBegin,
			out int strandParticleStride,
			out int strandParticleEnd)
		{
			switch (memoryLayout)
			{
				default:
				case HairAsset.MemoryLayout.Sequential:
					strandParticleBegin = strandIndex * strandParticleCount;
					strandParticleStride = 1;
					break;

				case HairAsset.MemoryLayout.Interleaved:
					strandParticleBegin = strandIndex;
					strandParticleStride = strandCount;
					break;
			}

			strandParticleEnd = strandParticleBegin + strandParticleStride * strandParticleCount;
		}

		public static void DeclareStrandIterator(in HairAsset.StrandGroup strandGroup, int strandIndex,
			out int strandParticleBegin,
			out int strandParticleStride,
			out int strandParticleEnd)
		{
			DeclareStrandIterator(strandGroup.particleMemoryLayout, strandGroup.strandCount, strandGroup.strandParticleCount, strandIndex,
				out strandParticleBegin,
				out strandParticleStride,
				out strandParticleEnd);
		}

		public static void DeclareParticleStride(HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount,
			out int strandParticleOffset,
			out int strandParticleStride)
		{
			switch (memoryLayout)
			{
				default:
				case HairAsset.MemoryLayout.Sequential:
					strandParticleOffset = strandParticleCount;
					strandParticleStride = 1;
					break;

				case HairAsset.MemoryLayout.Interleaved:
					strandParticleOffset = 1;
					strandParticleStride = strandCount;
					break;
			}
		}

		public static void DeclareParticleStride(in HairAsset.StrandGroup strandGroup, out int strandParticleOffset, out int strandParticleStride)
		{
			DeclareParticleStride(strandGroup.particleMemoryLayout, strandGroup.strandCount, strandGroup.strandParticleCount,
				out strandParticleOffset,
				out strandParticleStride);
		}
	}
}

```

`Runtime/HairAsset.cs.meta`:

```meta
fileFormatVersion: 2
guid: df302c2b7a2b66240b40412f9a662a10
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {fileID: 2800000, guid: e23706d7155887b49bd53435ba6aabb5, type: 3}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairAssetCustomData.cs`:

```cs
using UnityEngine;
using Unity.Collections;

namespace Unity.DemoTeam.Hair
{
	public abstract class HairAssetCustomData : ScriptableObject
	{
		public abstract bool AcquireCurves(out HairAssetProvisional.CurveSet curveSet, Allocator allocator);
	}
}

```

`Runtime/HairAssetCustomData.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6e9e13b72a3b6d34eb7f611e91da6549
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairAssetCustomPlacement.cs`:

```cs
using System;
using System.ComponentModel;
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public abstract class HairAssetCustomPlacement : ScriptableObject
	{
		public abstract bool GenerateRoots(in HairAssetProvisional.ProceduralRoots roots);
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[Obsolete("Renamed HairAssetProvider (UnityUpgradable) -> HairAssetCustomPlacement", true)]
	public abstract class HairAssetProvider
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Renamed HairAssetProvider/GeneratedRoots (UnityUpgradable) -> HairAssetProvisional/ProceduralRoots", true)]
		public struct GeneratedRoots
		{
			[EditorBrowsable(EditorBrowsableState.Never)]
			[Obsolete("Renamed HairAssetProvider/GeneratedRoots/StrandParameters (UnityUpgradable) -> GeneratedRoots.RootParameters", true)]
			public struct StrandParameters { };
		};
	}
}

```

`Runtime/HairAssetCustomPlacement.cs.meta`:

```meta
fileFormatVersion: 2
guid: 17b887ffebb61c64ab973fa39878999b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairBoundary.Gizmos.cs`:

```cs
using System;
using UnityEngine;
using UnityEngine.Serialization;

namespace Unity.DemoTeam.Hair
{
	public partial class HairBoundary
	{
		void OnDrawGizmosSelected()
		{
			var data = new RuntimeData();
			{
				if (TryGetData(this, ref data))
				{
					DrawGizmosRuntimeData(data);
				}
			}
		}

		static void DrawGizmosRuntimeData(in RuntimeData data)
		{
			switch (data.type)
			{
				case RuntimeData.Type.Shape: DrawGizmosRuntimeShape(data); break;
				case RuntimeData.Type.SDF: DrawGizmosRuntimeSDF(data); break;
			}
		}

		static void DrawGizmosRuntimeShape(in RuntimeData data)
		{
			Gizmos.color = Color.red;
			Gizmos.matrix = data.xform.matrix;
			Gizmos.DrawWireCube(Vector3.zero, Vector3.one);

			Gizmos.color = Color.yellow;
			Gizmos.matrix = Matrix4x4.identity;

			switch (data.shape.type)
			{
				case RuntimeShape.Type.Capsule:
					{
						var worldCenterA = data.shape.data.pA;
						var worldCenterB = data.shape.data.pB;
						var worldRadius = data.shape.data.tA;
						{
							Gizmos.DrawWireSphere(worldCenterA, worldRadius);
							Gizmos.DrawWireSphere(worldCenterB, worldRadius);
							Gizmos.DrawLine(worldCenterA, worldCenterB);
						}
					}
					break;
				case RuntimeShape.Type.Sphere:
					{
						var worldCenter = data.shape.data.pA;
						var worldRadius = data.shape.data.tA;
						{
							Gizmos.DrawWireSphere(worldCenter, worldRadius);
						}
					}
					break;
				case RuntimeShape.Type.Torus:
					{
						var worldCenter = data.shape.data.pA;
						var worldAxis = data.shape.data.pB;
						var worldRadiusAxis = data.shape.data.tA;
						var worldRadiusRing = data.shape.data.tB;
						{
							var basisX = (Mathf.Abs(worldAxis.y) > 1.0f - 1e-4f) ? Vector3.right : Vector3.Normalize(Vector3.Cross(worldAxis, Vector3.up));
							var basisY = worldAxis;
							var basisZ = Vector3.Cross(basisX, worldAxis);

							var axisSteps = 11;
							var axisStep = Quaternion.AngleAxis(360.0f / axisSteps, basisY);
							var axisVec = worldRadiusAxis * basisX;

							var ringSteps = 5;
							var ringStep = Quaternion.AngleAxis(360.0f / ringSteps, basisZ);
							var ringVec = worldRadiusRing * basisX;

							var axisRot = Quaternion.identity;
							var axisPos = axisRot * axisVec + worldCenter;

							unsafe
							{
								var ring_0 = stackalloc Vector3[ringSteps];
								var ring_i = stackalloc Vector3[ringSteps];

								for (int i = 0; i != axisSteps; i++)
								{
									var ringRot = axisRot;
									var ringPos = axisPos + ringRot * ringVec;

									for (int j = 0; j != ringSteps; j++)
									{
										var ringPosPrev = ringPos;

										ringRot = ringRot * ringStep;
										ringPos = axisPos + ringRot * ringVec;

										Gizmos.DrawLine(ringPosPrev, ringPos);

										if (i == 0)
										{
											ring_0[j] = ringPos;
											ring_i[j] = ringPos;
										}
										else
										{
											Gizmos.DrawLine(ring_i[j], ringPos);
											ring_i[j] = ringPos;
										}
									}

									axisRot = axisRot * axisStep;
									axisPos = axisRot * axisVec + worldCenter;
								}

								for (int j = 0; j != ringSteps; j++)
								{
									Gizmos.DrawLine(ring_0[j], ring_i[j]);
								}
							}
						}
					}
					break;
				case RuntimeShape.Type.Cube:
					{
						var localCenter = Vector3.zero;
						var localExtent = Vector3.one;
						{
							Gizmos.matrix = data.xform.matrix;
							Gizmos.DrawWireCube(localCenter, localExtent);
						}
					}
					break;
			}
		}

		static void DrawGizmosRuntimeSDF(in RuntimeData data)
		{
			var localCenter = 0.5f * Vector3.one;
			var localExtent = Vector3.one;
			{
				Gizmos.color = Color.red;
				Gizmos.matrix = data.xform.matrix;
				Gizmos.DrawWireCube(localCenter, localExtent);
			}
		}
	}
}

```

`Runtime/HairBoundary.Gizmos.cs.meta`:

```meta
fileFormatVersion: 2
guid: 2108bffc5c056a64f8c4ec9ce37a478e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairBoundary.Settings.cs`:

```cs
using System;
using UnityEngine;
using UnityEngine.Serialization;

namespace Unity.DemoTeam.Hair
{
	public partial class HairBoundary
	{
		public enum Axis
		{
			XAxis = 0,
			YAxis = 1,
			ZAxis = 2,
		};

		[Serializable]
		public struct Settings
		{
			public enum Mode
			{
				BindToComponent,
				Standalone,
			}

			public enum Type
			{
				DiscreteSDF,// can bind to component -> SDFTexture (requires Unity.DemoTeam.MeshToSDF)
				Capsule,    // can bind to component -> CapsuleCollider
				Sphere,     // can bind to component -> SphereCollider
				Torus,
				Cube,       // can bind to component -> BoxCollider
				Any,
			}

			public Mode mode;
			public Type type;

			public static readonly Settings defaults = new Settings
			{
				mode = Mode.BindToComponent,
				type = Type.Any,
			};
		}

		[Serializable]
		public struct SettingsCapsule
		{
			public Axis direction;
			public float radius;
			public float height;

			public static readonly SettingsCapsule defaults = new SettingsCapsule
			{
				direction = Axis.YAxis,
				radius = 0.5f,
				height = 2.0f,
			};
		}

		[Serializable]
		public struct SettingsSphere
		{
			public float radius;

			public static readonly SettingsSphere defaults = new SettingsSphere
			{
				radius = 0.5f,
			};
		}

		[Serializable]
		public struct SettingsTorus
		{
			public Axis axis;
			public float radiusAxis;
			public float radiusRing;

			public static readonly SettingsTorus defaults = new SettingsTorus
			{
				axis = Axis.YAxis,
				radiusAxis = 0.5f,
				radiusRing = 0.125f,
			};
		}

		[Serializable]
		public struct SettingsCube
		{
			public Vector3 size;

			public static readonly SettingsCube defaults = new SettingsCube
			{
				size = Vector3.one,
			};
		}

		[Serializable]
		public struct SettingsSDF
		{
			[FormerlySerializedAs("kSDF")]
			public Texture kSDFTexture;
			public Vector3 kSDFWorldSize;

			public static readonly SettingsSDF defaults = new SettingsSDF
			{
				kSDFTexture = null,
				kSDFWorldSize = Vector3.one,
			};
		}
	}
}

```

`Runtime/HairBoundary.Settings.cs.meta`:

```meta
fileFormatVersion: 2
guid: 412290411171b054f9fa9a1ffa3ae922
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairBoundary.cs`:

```cs
using System;
using UnityEngine;
using UnityEngine.Serialization;
using Unity.Mathematics;

namespace Unity.DemoTeam.Hair
{
	public partial class HairBoundary : MonoBehaviour
	{
		static readonly Vector3[] s_normal =
		{
			new Vector3(1.0f, 0.0f, 0.0f),
			new Vector3(0.0f, 1.0f, 0.0f),
			new Vector3(0.0f, 0.0f, 1.0f),
		};

		static readonly Vector3[] s_planar =
		{
			new Vector3(0.0f, 1.0f, 1.0f),
			new Vector3(1.0f, 0.0f, 1.0f),
			new Vector3(1.0f, 1.0f, 0.0f),
		};

		public Settings settings = Settings.defaults;
		public SettingsCapsule settingsCapsule = SettingsCapsule.defaults;
		public SettingsSphere settingsSphere = SettingsSphere.defaults;
		public SettingsTorus settingsTorus = SettingsTorus.defaults;
		public SettingsCube settingsCube = SettingsCube.defaults;
		public SettingsSDF settingsSDF = SettingsSDF.defaults;

		//--------------
		// runtime data

		public struct RuntimeData
		{
			public enum Type
			{
				Shape,
				SDF,
			};

			public Type type;
			public RuntimeTransform xform;
			public RuntimeShape shape;
			public RuntimeSDF sdf;
		}

		public struct RuntimeTransform
		{
			public int handle;
			public Matrix4x4 matrix;
		}

		public struct RuntimeShape
		{
			public enum Type
			{
				Discrete,
				Capsule,
				Sphere,
				Torus,
				Cube,
			};

			public struct Data
			{
				// shape    |  float3     float      float3     float
				// -------------------------------------------------------
				// discrete |  __pad      scale      __pad      __pad
				// capsule  |  centerA    radius     centerB    __pad
				// sphere   |  center     radius     __pad      __pad
				// torus    |  center     radiusA    axis       radiusB
				// cube     |  center     rotf16x    extent     rotf16y

				public Vector3 pA; public float tA;
				public Vector3 pB; public float tB;
			}

			public Type type;
			public Data data;
		}

		public struct RuntimeSDF
		{
			public Texture sdfTexture;
			public float sdfCellSize;
		}

		//--------------------
		// runtime conversion

		public static RuntimeData GetRuntimeCapsule(CapsuleCollider collider) => GetRuntimeCapsule(collider.GetInstanceID(), collider.transform, collider.center, collider.direction, collider.height, collider.radius);
		public static RuntimeData GetRuntimeCapsule(Transform transform, in SettingsCapsule settings) => GetRuntimeCapsule(transform.GetInstanceID(), transform, Vector3.zero, (int)settings.direction, settings.height, settings.radius);
		public static RuntimeData GetRuntimeCapsule(int handle, Transform transform, in Vector3 center, int axis, float height, float radius)
		{
			var lossyScaleAbs = transform.lossyScale.Abs();
			var lossyScaleAbsPlanar = Vector3.Scale(lossyScaleAbs, s_planar[axis]);

			var worldCenter = transform.TransformPoint(center);
			var worldRadius = radius * lossyScaleAbsPlanar.CMax();
			var worldHeight = Mathf.Max(height * lossyScaleAbs[axis], 2.0f * worldRadius);
			var worldExtent = transform.rotation * (s_normal[axis] * (0.5f * worldHeight - worldRadius));

			return new RuntimeData
			{
				type = RuntimeData.Type.Shape,
				xform = new RuntimeTransform
				{
					handle = handle,
					matrix = Matrix4x4.TRS(worldCenter, transform.rotation, s_normal[axis] * worldHeight + s_planar[axis] * (2.0f * worldRadius)),
				},
				shape = new RuntimeShape
				{
					type = RuntimeShape.Type.Capsule,
					data = new RuntimeShape.Data
					{
						pA = worldCenter - worldExtent,
						pB = worldCenter + worldExtent,
						tA = worldRadius,
					},
				},
			};
		}

		public static RuntimeData GetRuntimeSphere(SphereCollider collider) => GetRuntimeSphere(collider.GetInstanceID(), collider.transform, collider.center, collider.radius);
		public static RuntimeData GetRuntimeSphere(Transform transform, in SettingsSphere settings) => GetRuntimeSphere(transform.GetInstanceID(), transform, Vector3.zero, settings.radius);
		public static RuntimeData GetRuntimeSphere(int handle, Transform transform, in Vector3 center, float radius)
		{
			var lossyScaleAbs = transform.lossyScale.Abs();
			var lossyScaleAbsMax = lossyScaleAbs.CMax();

			var worldCenter = transform.TransformPoint(center);
			var worldRadius = radius * lossyScaleAbsMax;

			return new RuntimeData
			{
				type = RuntimeData.Type.Shape,
				xform = new RuntimeTransform
				{
					handle = handle,
					matrix = Matrix4x4.TRS(worldCenter, transform.rotation, Vector3.one * (2.0f * worldRadius)),
				},
				shape = new RuntimeShape
				{
					type = RuntimeShape.Type.Sphere,
					data = new RuntimeShape.Data
					{
						pA = worldCenter,
						tA = worldRadius,
					},
				},
			};
		}

		public static RuntimeData GetRuntimeTorus(Transform transform, in SettingsTorus settings) => GetRuntimeTorus(transform.GetInstanceID(), transform, Vector3.zero, (int)settings.axis, settings.radiusAxis, settings.radiusRing);
		public static RuntimeData GetRuntimeTorus(int handle, Transform transform, in Vector3 center, int axis, float radiusAxis, float radiusRing)
		{
			var lossyScaleAbs = transform.lossyScale.Abs();
			var lossyScaleAbsMax = lossyScaleAbs.CMax();

			var worldCenter = transform.TransformPoint(center);
			var worldAxis = transform.rotation * s_normal[axis];
			var worldRadiusAxis = radiusAxis * lossyScaleAbsMax;
			var worldRadiusRing = radiusRing * lossyScaleAbsMax;

			return new RuntimeData
			{
				type = RuntimeData.Type.Shape,
				xform = new RuntimeTransform
				{
					handle = handle,
					matrix = Matrix4x4.TRS(worldCenter, transform.rotation, s_planar[axis] * (2.0f * (worldRadiusAxis + worldRadiusRing)) + s_normal[axis] * (2.0f * worldRadiusRing)),
				},
				shape = new RuntimeShape
				{
					type = RuntimeShape.Type.Torus,
					data = new RuntimeShape.Data
					{
						pA = worldCenter,
						pB = worldAxis,
						tA = worldRadiusAxis,
						tB = worldRadiusRing,
					},
				},
			};
		}

		public static RuntimeData GetRuntimeCube(BoxCollider collider) => GetRuntimeCube(collider.GetInstanceID(), collider.transform, collider.center, collider.size);
		public static RuntimeData GetRuntimeCube(Transform transform, in SettingsCube settings) => GetRuntimeCube(transform.GetInstanceID(), transform, Vector3.zero, settings.size);
		public static RuntimeData GetRuntimeCube(int handle, Transform transform, in Vector3 center, in Vector3 size)
		{
			var lossyScaleAbs = transform.lossyScale.Abs();

			var worldCenter = transform.TransformPoint(center);
			var worldSize = Vector3.Scale(size, lossyScaleAbs);
			var worldRot = transform.rotation;

			var rotf16 = math.f32tof16(Quaternion.Inverse(worldRot).ToVector4());
			var rotf16x = rotf16.x | (rotf16.z << 16);
			var rotf16y = rotf16.y | (rotf16.w << 16);

			return new RuntimeData
			{
				type = RuntimeData.Type.Shape,
				xform = new RuntimeTransform
				{
					handle = handle,
					matrix = Matrix4x4.TRS(worldCenter, transform.rotation, worldSize),
				},
				shape = new RuntimeShape
				{
					type = RuntimeShape.Type.Cube,
					data = new RuntimeShape.Data
					{
						pA = worldCenter,
						pB = worldSize * 0.5f,
						tA = Unity.Mathematics.math.asfloat(rotf16x),
						tB = Unity.Mathematics.math.asfloat(rotf16y),
					},
				},
			};
		}

#if HAS_PACKAGE_DEMOTEAM_MESHTOSDF
		public static RuntimeData GetRuntimeSDF(SDFTexture sdfComponent) => GetRuntimeSDF(sdfComponent.transform.GetInstanceID(), sdfComponent.transform, sdfComponent.sdf, sdfComponent.voxelBounds.size);
#endif
		public static RuntimeData GetRuntimeSDF(Transform transform, in SettingsSDF settings) => GetRuntimeSDF(transform.GetInstanceID(), transform, settings.kSDFTexture, settings.kSDFWorldSize);
		public static RuntimeData GetRuntimeSDF(int handle, Transform transform, Texture sdfTexture, in Vector3 sdfWorldSize)
		{
			var sdfTextureResolution = Vector3.one;
			{	
				if (sdfTexture is Texture3D)
				{
					var sdfTexture3D = (Texture3D)sdfTexture;
					{
						sdfTextureResolution.x = sdfTexture3D.width;
						sdfTextureResolution.y = sdfTexture3D.height;
						sdfTextureResolution.z = sdfTexture3D.depth;
					}
				}
				else if (sdfTexture is RenderTexture)
				{
					var sdfTexture3D = (RenderTexture)sdfTexture;
					{
						sdfTextureResolution.x = sdfTexture3D.width;
						sdfTextureResolution.y = sdfTexture3D.height;
						sdfTextureResolution.z = Mathf.Max(1, sdfTexture3D.volumeDepth);
					}
				}
			}

			// compute scale factor for euclidean distances within non-uniformly scaled aabb,
			// given aabb initial dimensions (Lx, Ly, Lz) and aabb scale factors (Sx, Sy, Sz):
			// d' = d * cbrt((Lx*Lx*Sx*Sx + Ly*Ly*Sy*Sy + Lz*Lz*Sz*Sz) / (Lx*Lx + Ly*Ly + Lz*Lz))
			var sdfWorldScale = transform.lossyScale.Abs();
			var sdfValueScale = 1.0f;//sdfWorldScale.CMin();
			{
				static float cbrt(float value) => Mathf.Pow(value, 1.0f / 3.0f);

				var LL = sdfWorldSize.CMul(sdfWorldSize);
				var LLsum = LL.CSum();
				if (LLsum > 0.0f)
				{
					var SS = sdfWorldScale.CMul(sdfWorldScale);
					var SSLLsum = SS.CMul(LL).CSum();

					sdfValueScale = cbrt(SSLLsum / LLsum);
				}
			}

			return new RuntimeData
			{
				type = RuntimeData.Type.SDF,
				xform = new RuntimeTransform
				{
					handle = transform.GetInstanceID(),
					matrix = Matrix4x4.TRS(transform.position, transform.rotation, sdfWorldSize.CMul(sdfWorldScale)) * Matrix4x4.Translate(-0.5f * Vector3.one),
				},
				shape = new RuntimeShape
				{
					type = RuntimeShape.Type.Discrete,
					data = new RuntimeShape.Data
					{
						tA = sdfValueScale,
					},
				},
				sdf = new RuntimeSDF()
				{
					sdfTexture = sdfTexture,
					sdfCellSize = sdfWorldSize.CMul(sdfTextureResolution.Rcp()).CMax(),
				},
			};
		}

		//-----------
		// accessors

		public static bool TryGetData(HairBoundary boundary, ref RuntimeData data)
		{
			if (boundary.settings.mode == Settings.Mode.BindToComponent)
			{
				if (TryGetMatchingComponent(boundary, out var component))
				{
					return TryGetComponentData(component, ref data);
				}
			}
			else
			{
				return TryGetStandaloneData(boundary, ref data);
			}
			return false;
		}

		public static bool TryGetMatchingComponent(HairBoundary boundary, Settings.Type type, out Component component)
		{
			static Component FilterSolid(Collider collider) => (collider != null && collider.isTrigger == false) ? collider : null;

			switch (type)
			{
#if HAS_PACKAGE_DEMOTEAM_MESHTOSDF
				case Settings.Type.DiscreteSDF:
					component = boundary.GetComponent<SDFTexture>(); break;
#endif
				case Settings.Type.Capsule:
					component = FilterSolid(boundary.GetComponent<CapsuleCollider>()); break;
				case Settings.Type.Sphere:
					component = FilterSolid(boundary.GetComponent<SphereCollider>()); break;
				case Settings.Type.Cube:
					component = FilterSolid(boundary.GetComponent<BoxCollider>()); break;
				default:
					component = null; break;
			}
			return (component != null);
		}

		public static bool TryGetMatchingComponent(HairBoundary boundary, out Component component)
		{
			if (boundary.settings.type == Settings.Type.Any)
			{
				return
					TryGetMatchingComponent(boundary, Settings.Type.DiscreteSDF, out component) ||
					TryGetMatchingComponent(boundary, Settings.Type.Capsule, out component) ||
					TryGetMatchingComponent(boundary, Settings.Type.Sphere, out component) ||
					TryGetMatchingComponent(boundary, Settings.Type.Torus, out component) ||
					TryGetMatchingComponent(boundary, Settings.Type.Cube, out component);
			}
			else
			{
				return TryGetMatchingComponent(boundary, boundary.settings.type, out component);
			}
		}

		public static bool TryGetComponentData(Component component, ref RuntimeData data)
		{
			var collider = component as Collider;
			if (collider != null)
			{
				if (collider.isTrigger == false)
				{
					if (component is CapsuleCollider)
					{
						data = GetRuntimeCapsule(component as CapsuleCollider); return true;
					}
					else if (component is SphereCollider)
					{
						data = GetRuntimeSphere(component as SphereCollider); return true;
					}
					else if (component is BoxCollider)
					{
						data = GetRuntimeCube(component as BoxCollider); return true;
					}
				}
			}
#if HAS_PACKAGE_DEMOTEAM_MESHTOSDF
			else if (component is SDFTexture)
			{
				data = GetRuntimeSDF(component as SDFTexture); return (data.sdf.sdfTexture != null);
			}
#endif
			return false;
		}

		public static bool TryGetStandaloneData(HairBoundary boundary, ref RuntimeData data)
		{
			switch (boundary.settings.type)
			{
				case Settings.Type.DiscreteSDF:
					data = GetRuntimeSDF(boundary.transform, boundary.settingsSDF); return (data.sdf.sdfTexture != null);
				case Settings.Type.Capsule:
					data = GetRuntimeCapsule(boundary.transform, boundary.settingsCapsule); return true;
				case Settings.Type.Sphere:
					data = GetRuntimeSphere(boundary.transform, boundary.settingsSphere); return true;
				case Settings.Type.Torus:
					data = GetRuntimeTorus(boundary.transform, boundary.settingsTorus); return true;
				case Settings.Type.Cube:
					data = GetRuntimeCube(boundary.transform, boundary.settingsCube); return true;
				default:
					return false;
			}
		}
	}
}

```

`Runtime/HairBoundary.cs.meta`:

```meta
fileFormatVersion: 2
guid: cd6dc43f8cdf841428bf772881f46201
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {fileID: 2800000, guid: 4fbe4c10ffe8d6e4c823c425851d8cac, type: 3}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairBoundaryUtility.cs`:

```cs
using UnityEngine;
using Unity.Mathematics;

using static Unity.Mathematics.math;

namespace Unity.DemoTeam.Hair
{
	public struct HairBoundaryProxy : ISpatialComponentProxy<HairBoundary, HairBoundary.RuntimeData>
	{
		public bool TryGetData(HairBoundary component, ref HairBoundary.RuntimeData data)
			=> HairBoundary.TryGetData(component, ref data);
		public bool TryGetComponentData(Component component, ref HairBoundary.RuntimeData data)
			=> HairBoundary.TryGetComponentData(component, ref data);

		public int ResolveDataHandle(in HairBoundary.RuntimeData data)
			=> data.xform.handle;
		public float ResolveDataDistance(in HairBoundary.RuntimeData data, in Vector3 p)
			=> HairBoundaryUtility.SdBoundary(p, data);
	}

	public static class HairBoundaryUtility
	{
		//-----------------
		// signed distance

		public static float SdBoundary(in Vector3 p, in HairBoundary.RuntimeData data)
		{
			switch (data.type)
			{
				case HairBoundary.RuntimeData.Type.SDF:
					return SdDiscrete(p, data);

				case HairBoundary.RuntimeData.Type.Shape:
					{
						switch (data.shape.type)
						{
							case HairBoundary.RuntimeShape.Type.Capsule: return SdCapsule(p, data.shape.data);
							case HairBoundary.RuntimeShape.Type.Sphere: return SdSphere(p, data.shape.data);
							case HairBoundary.RuntimeShape.Type.Torus: return SdTorus(p, data.shape.data);
							case HairBoundary.RuntimeShape.Type.Cube: return SdCube(p, data.shape.data, Matrix4x4.Inverse(data.xform.matrix));
						}
					}
					break;
			}
			return 1e+7f;
		}

		public static float SdDiscrete(in Vector3 p, in HairBoundary.RuntimeData data) => SdDiscrete(p, data.shape.data.tA, Matrix4x4.Inverse(data.xform.matrix), data.sdf.sdfTexture as Texture3D);
		public static float SdDiscrete(in Vector3 p, in float scale, in Matrix4x4 invM, Texture3D sdf)
		{
			float3 uvw = mul(invM, float4(p, 1.0f)).xyz;
			return scale * sdf.GetPixelBilinear(uvw.x, uvw.y, uvw.z).r;
		}

		public static float SdCapsule(in float3 p, in HairBoundary.RuntimeShape.Data capsule) => SdCapsule(p, capsule.pA, capsule.pB, capsule.tA);
		public static float SdCapsule(in float3 p, in float3 centerA, in float3 centerB, float radius)
		{
			// see: "distance functions" by Inigo Quilez
			// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm

			float3 pa = p - centerA;
			float3 ba = centerB - centerA;

			float h = saturate(dot(pa, ba) / dot(ba, ba));
			float r = radius;

			return (length(pa - ba * h) - r);
		}

		public static float SdSphere(in float3 p, in HairBoundary.RuntimeShape.Data sphere) => SdSphere(p, sphere.pA, sphere.tA);
		public static float SdSphere(in float3 p, in float3 center, float radius)
		{
			// see: "distance functions" by Inigo Quilez
			// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm

			return (length(p - center) - radius);
		}

		public static float SdTorus(in float3 p, in HairBoundary.RuntimeShape.Data torus) => SdTorus(p, torus.pA, torus.pB, torus.tA, torus.tB);
		public static float SdTorus(float3 p, in float3 center, in float3 axis, float radiusA, float radiusB)
		{
			float3 basisX = (abs(axis.y) > 1.0f - 1e-4f) ? float3(1.0f, 0.0f, 0.0f) : normalize(cross(axis, float3(0.0f, 1.0f, 0.0f)));
			float3 basisY = axis;
			float3 basisZ = cross(basisX, axis);
			float3x3 invM = float3x3(basisX, basisY, basisZ);

			p = mul(invM, p - center);

			// see: "distance functions" by Inigo Quilez
			// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm

			float2 t = float2(radiusA, radiusB);
			float2 q = float2(length(p.xz) - t.x, p.y);

			return length(q) - t.y;
		}

		public static float SdCube(in float3 p, in HairBoundary.RuntimeShape.Data cube, in float4x4 invM) => SdCube(p, cube.pB, invM);
		public static float SdCube(float3 p, in float3 extent, in float4x4 invM)
		{
			p = mul(invM, float4(p, 1.0f)).xyz;
			// assuming TRS, can apply scale post-transform to preserve primitive scale
			// T R S x_local = x_world
			//       x_local = S^-1 R^-1 T^-1 x_world
			//     S x_local = S S^-1 R^-1 T^-1 world
			p *= 2.0f * extent;

			// see: "distance functions" by Inigo Quilez
			// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm

			float3 b = extent;
			float3 q = abs(p) - b;

			return length(max(q, 0.0f)) + min(max(q.x, max(q.y, q.z)), 0.0f);
		}
	}
}

```

`Runtime/HairBoundaryUtility.cs.meta`:

```meta
fileFormatVersion: 2
guid: 4cacc8f8387d20e4e992a99ceddb8aca
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairInstance.Gizmos.cs`:

```cs
using UnityEngine;
using Unity.Collections;

namespace Unity.DemoTeam.Hair
{
	public partial class HairInstance
	{
		void OnDrawGizmos()
		{
			if (solverData == null)
				return;

			// show volume bounds
			{
				Gizmos.color = Color.Lerp(Color.clear, Color.white, 0.5f);
				Gizmos.matrix = Matrix4x4.identity;

				var volumeBounds = HairSim.GetVolumeBounds(volumeData);
				{
					Gizmos.DrawWireCube(volumeBounds.center, volumeBounds.size);
				}
			}
		}

		void OnDrawGizmosSelected()
		{
			if (solverData == null)
				return;

			// show root bounds
			{
				Gizmos.color = Color.Lerp(Color.clear, Color.blue, 0.5f);
				Gizmos.matrix = Matrix4x4.identity;

				for (int i = 0; i != strandGroupInstances.Length; i++)
				{
					var rootMeshFilter = strandGroupInstances[i].sceneObjects.rootMeshFilter;
					if (rootMeshFilter != null)
					{
						var rootMesh = rootMeshFilter.sharedMesh;
						if (rootMesh != null)
						{
							var rootBounds = rootMesh.bounds;
							{
								Gizmos.matrix = rootMeshFilter.transform.localToWorldMatrix;
								Gizmos.DrawWireCube(rootBounds.center, rootBounds.size);
								Gizmos.matrix = Matrix4x4.identity;
							}
						}
					}
				}
			}

			// show solver gravity
			{
				Gizmos.color = Color.Lerp(Color.clear, Color.cyan, 0.5f);
				Gizmos.matrix = Matrix4x4.identity;

				for (int i = 0; i != solverData.Length; i++)
				{
					var solverBounds = HairSim.GetSolverBounds(solverData[i], volumeData);
					var solverGravity = volumeData.constantsEnvironment._WorldGravity * solverData[i].constants._GravityScale;
					{
						Gizmos.DrawRay(solverBounds.center, solverGravity * 0.1f);
					}
				}
			}

			// show solver bounds
#if false
			{
				Gizmos.color = Color.Lerp(Color.clear, Color.green, 0.5f);
				Gizmos.matrix = Matrix4x4.identity;

				for (int i = 0; i != solverData.Length; i++)
				{
					var solverBounds = HairSim.GetSolverBounds(solverData[i], volumeData);
					{
						Gizmos.DrawWireCube(solverBounds.center, solverBounds.size);
					}
				}
			}
#endif

			// show solver lod indicators
			{
				var camera = Camera.current;
				var cameraPosition = camera.transform.position;
				var cameraRotation = camera.transform.rotation;
				var cameraForward = cameraRotation * Vector3.forward;
				var cameraOrtho = camera.orthographic;

				for (int i = 0; i != solverData.Length; i++)
				{
					var solverBounds = HairSim.GetSolverBounds(solverData[i], volumeData);
					var solverLODPhysics = HairSim.GetSolverLODSelection(solverData[i], HairSim.SolverLODStage.Physics);
					var solverLODRendering = HairSim.GetSolverLODSelection(solverData[i], HairSim.SolverLODStage.Rendering);
					{
						var planarBoundsCenter = solverBounds.center;
						var planarBoundsExtent = solverBounds.extents.CMax();
						var planarBoundsDepth = cameraOrtho ? 1.0f : Mathf.Max(Vector3.Dot(cameraForward, planarBoundsCenter - cameraPosition), camera.nearClipPlane);

						var viewportExtentUnitDepth = cameraOrtho ? camera.orthographicSize : Mathf.Tan(0.5f * Mathf.Deg2Rad * camera.GetGateFittedFieldOfView());
						var viewportExtent = planarBoundsDepth * viewportExtentUnitDepth;
						var viewportScale = viewportExtent / planarBoundsExtent;

						/* TODO minify indicator up close?
						//var planarBoundsP00 = planarBoundsCenter - cameraRotation * (new Vector3(-planarBoundsExtent, -planarBoundsExtent, 0.0f));
						//var planarBoundsP10 = planarBoundsCenter - cameraRotation * (new Vector3( planarBoundsExtent, -planarBoundsExtent, 0.0f));
						//var planarBoundsP01 = planarBoundsCenter - cameraRotation * (new Vector3(-planarBoundsExtent,  planarBoundsExtent, 0.0f));
						//var planarBoundsP11 = planarBoundsCenter - cameraRotation * (new Vector3( planarBoundsExtent,  planarBoundsExtent, 0.0f));
						//var viewDistanceRef = new Vector2(0.5f, 0.5f);
						//var viewDistanceP00 = ((Vector2)camera.WorldToViewportPoint(planarBoundsP00) - viewDistanceRef).Abs().CMax() * 2.0f;
						//var viewDistanceP10 = ((Vector2)camera.WorldToViewportPoint(planarBoundsP10) - viewDistanceRef).Abs().CMax() * 2.0f;
						//var viewDistanceP01 = ((Vector2)camera.WorldToViewportPoint(planarBoundsP01) - viewDistanceRef).Abs().CMax() * 2.0f;
						//var viewDistanceP11 = ((Vector2)camera.WorldToViewportPoint(planarBoundsP11) - viewDistanceRef).Abs().CMax() * 2.0f;
						//var viewDistanceMax = Mathf.Max(viewDistanceP00, Mathf.Max(viewDistanceP10, Mathf.Max(viewDistanceP01, viewDistanceP11)));
						//var minify = Mathf.InverseLerp(0.75f, 1.0f, viewDistanceMax);
						//if (minify > 0.0f)
						//{
						//}
						*/

						Gizmos.matrix = Matrix4x4.TRS(planarBoundsCenter, cameraRotation, new Vector3(2.0f * planarBoundsExtent, 2.0f * planarBoundsExtent, 0.0f));

						//using (new UnityEditor.Handles.DrawingScope(Gizmos.matrix))
						//{
						//	UnityEditor.Handles.Label(0.5f * (Vector3.left + Vector3.up), string.Format("{0}[{1}]", strandGroupInstances[i].groupAssetReference.hairAsset.name, strandGroupInstances[i].groupAssetReference.hairAssetGroupIndex));
						//}

						static void GizmosDrawLODIndicator(in HairSim.LODIndices lodDesc, in NativeArray<float> lodThreshold, in Vector2 p0, in Vector2 rx, in Vector2 ry, in Color color)
						{
							// draw sections
							var t0 = 0.0f;
							{
								for (int j = 0; j != lodThreshold.Length; j++)
								{
									var t = lodThreshold[j];
									var m = (t + t0) * 0.5f;
									var w = (t - t0);

									Gizmos.color = Color.Lerp(Color.clear, Color.Lerp(Color.black, color, t), 0.5f);
									Gizmos.DrawCube(p0 + rx * m + ry * 0.5f, rx * w + ry);

									t0 = t;
								}
							}

							// draw cursor
							Gizmos.color = Color.cyan;
							Gizmos.DrawRay(p0 + rx * lodDesc.lodValue, ry);

							// draw frame
							//Gizmos.color = Color.Lerp(Color.clear, color, 0.5f);
							//Gizmos.DrawWireCube(p0 + (rx + ry) * 0.5f, rx + ry);
						}

						float indicatorHeight = 0.005f * viewportScale;
						float indicatorOffset = 0.5f + indicatorHeight;

						GizmosDrawLODIndicator(solverLODRendering, solverData[i].lodThreshold, Vector2.down * 0.5f + Vector2.right * indicatorOffset, Vector2.up, Vector2.left * indicatorHeight, Color.green);
						GizmosDrawLODIndicator(solverLODPhysics, solverData[i].lodThreshold, Vector2.left * 0.5f + Vector2.down * indicatorOffset, Vector2.right, Vector2.up * indicatorHeight, Color.magenta);

						Gizmos.color = Color.Lerp(Color.clear, Color.green, 0.5f);
						Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
					}
				}
			}

#if false
#if UNITY_EDITOR
			// show participating solid boundaries
			{
				var volumeBounds = HairSim.GetVolumeBounds(volumeData);
				var volumeBoundaries = SpatialComponentFilter<HairBoundary, HairBoundary.RuntimeData, HairBoundaryProxy>.Gather(settingsEnvironment.boundaryResident, settingsEnvironment.boundaryCapture, volumeBounds, settingsEnvironment.boundaryCaptureLayer, volumeSort: false, settingsEnvironment.boundaryCaptureMode == HairSim.SettingsEnvironment.BoundaryCaptureMode.IncludeColliders);

				for (int i = 0; i != volumeBoundaries.Count; i++)
				{
					var boundaryData = volumeBoundaries[i];
					var boundaryOrigin = boundaryData.xform.matrix.MultiplyPoint3x4(Vector3.zero);
					var boundaryDistance = HairBoundaryUtility.SdBoundary(volumeBounds.center, boundaryData);
					var boundaryColor = (i < HairSim.Conf.MAX_BOUNDARIES) ? Color.Lerp(Color.white, Color.clear, 0.5f) : Color.red;

					UnityEditor.Handles.color = boundaryColor;
					UnityEditor.Handles.DrawLine(volumeBounds.center, boundaryOrigin);
					UnityEditor.Handles.Label(boundaryOrigin, string.Format("d[{0}]: {1}", 0, boundaryDistance));
				}
			}
#endif
#endif

			// show participating wind emitters
			if (settingsVolumetrics.windPropagation)
			{
				var volumeBounds = HairSim.GetVolumeBounds(volumeData);
				var volumeEmitters = SpatialComponentFilter<HairWind, HairWind.RuntimeData, HairWindProxy>.Gather(settingsEnvironment.emitterResident, settingsEnvironment.emitterCapture, volumeBounds, settingsEnvironment.emitterCaptureLayer, volumeSort: false, settingsEnvironment.emitterCaptureMode == HairSim.SettingsEnvironment.EmitterCaptureMode.IncludeWindZones);

				for (int i = 0; i != Mathf.Min(volumeEmitters.Count, HairSim.Conf.MAX_EMITTERS); i++)
				{
					HairWind.DrawGizmosRuntimeData(volumeEmitters[i], volumeData.constantsEnvironment._WindEmitterClock, volumeData.constants._VolumeDT, active: true, selected: true);
				}
			}
		}
	}
}

```

`Runtime/HairInstance.Gizmos.cs.meta`:

```meta
fileFormatVersion: 2
guid: 5fb88144aa690fc4ea7c06d0077b7200
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairInstance.Migration.0.cs`:

```cs
using System;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.Rendering;

#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN
using Unity.DemoTeam.DigitalHuman;
#endif

namespace Unity.DemoTeam.Hair
{
	// data migration impl. checklist:
	//
	//	- block renamed: capture and migrate all fields
	//	- field(s) renamed: capture and migrate renamed fields
	//	- field(s) changed: capture and migrate changed fields
	//	- field(s) removed: no action
	//
	// data migration is then a simple two-step process:
	//
	//	1. capture old data into trimmed copies of old structures (via FormerlySerializedAs)
	//	2. migrate old data from trimmed copies
	//
	// (old structures are unfortunately also re-serialized)

	using __IMPL__SettingsExecutive = HairInstance.SettingsExecutive;
	using __IMPL__SettingsEnvironment = HairSim.SettingsEnvironment;
	using __IMPL__SettingsVolumetrics = HairSim.SettingsVolume;

	using __IMPL__SettingsGeometry = HairSim.SettingsGeometry;
	using __IMPL__SettingsRendering = HairSim.SettingsRendering;
	using __IMPL__SettingsPhysics = HairSim.SettingsPhysics;

	using __IMPL__SolverLODSelection = HairSim.SolverLODSelection;

	public partial class HairInstance
	{
		[SerializeField, FormerlySerializedAs("settingsSystem")]
		__0__SettingsSystem data_0_settingsSystem = __0__SettingsSystem.defaults;

		[SerializeField, FormerlySerializedAs("settingsVolume"), FormerlySerializedAs("volumeSettings")]
		__0__VolumeSettings data_0_settingsVolume = __0__VolumeSettings.defaults;

		[SerializeField, FormerlySerializedAs("strandGroupDefaults")]
		__0__GroupSettings data_0_strandGroupDefaults = __0__GroupSettings.defaults;

		[SerializeField, FormerlySerializedAs("strandGroupSettings")]
		__0__GroupSettings[] data_0_strandGroupSettings;

		void PerformMigration_0()
		{
			ref var data_IMPL_settingsExecutive = ref this.settingsExecutive;
			ref var data_IMPL_settingsEnvironment = ref this.settingsEnvironment;
			ref var data_IMPL_settingsVolumetrics = ref this.settingsVolumetrics;

			ref var data_IMPL_strandGroupDefaults = ref this.strandGroupDefaults;
			ref var data_IMPL_strandGroupSettings = ref this.strandGroupSettings;

			// migrate data_0_settingsSystem
			{
				ref readonly var in_0 = ref data_0_settingsSystem;

				// => data_IMPL_settingsExecutive
				{
					static void TransferSettingsSystem(in __0__SettingsSystem in_0, ref __IMPL__SettingsExecutive out_IMPL)
					{
						static __IMPL__SettingsExecutive.UpdateMode TranslateUpdateMode(__0__SettingsSystem.UpdateMode x) => (__IMPL__SettingsExecutive.UpdateMode)x;
						static __IMPL__SettingsExecutive.UpdateRate TranslateSimulationRate(__0__SettingsSystem.SimulationRate x)
						{
							switch (x)
							{
								default:
								case __0__SettingsSystem.SimulationRate.Fixed30Hz: return __IMPL__SettingsExecutive.UpdateRate.Fixed30Hz;
								case __0__SettingsSystem.SimulationRate.Fixed60Hz: return __IMPL__SettingsExecutive.UpdateRate.Fixed60Hz;
								case __0__SettingsSystem.SimulationRate.Fixed120Hz: return __IMPL__SettingsExecutive.UpdateRate.Fixed120Hz;
								case __0__SettingsSystem.SimulationRate.CustomTimeStep: return __IMPL__SettingsExecutive.UpdateRate.CustomTimeStep;
							}
						}

						out_IMPL.updateMode = TranslateUpdateMode(in_0.updateMode);
						out_IMPL.updateSimulation = in_0.simulation;
						out_IMPL.updateSimulationRate = TranslateSimulationRate(in_0.simulationRate);
						out_IMPL.updateSimulationInEditor = in_0.simulationInEditor;
						out_IMPL.updateTimeStep = in_0.simulationTimeStep;
						out_IMPL.updateStepsMin = in_0.stepsMin;
						out_IMPL.updateStepsMinValue = in_0.stepsMinValue;
						out_IMPL.updateStepsMax = in_0.stepsMax;
						out_IMPL.updateStepsMaxValue = in_0.stepsMaxValue;
					}

					TransferSettingsSystem(in_0, ref data_IMPL_settingsExecutive);
				}

				// => data_IMPL_strandGroupDefaults.settingsGeometry
				// => data_IMPL_strandGroupSettings[].settingsGeometry
				{
					static void TransferSettingsSystem(in __0__SettingsSystem in_0, ref __IMPL__SettingsGeometry out_IMPL)
					{
						static __IMPL__SettingsGeometry.BoundsMode TranslateBoundsMode(__0__SettingsSystem.BoundsMode x) => (__IMPL__SettingsGeometry.BoundsMode)x;

						out_IMPL.boundsMode = TranslateBoundsMode(in_0.boundsMode);
						out_IMPL.boundsCenter = in_0.boundsCenter;
						out_IMPL.boundsExtent = in_0.boundsExtent;
						out_IMPL.boundsScale = in_0.boundsScale;
						out_IMPL.boundsScaleValue = in_0.boundsScaleValue;
					}

					TransferSettingsSystem(in_0, ref data_IMPL_strandGroupDefaults.settingsGeometry);
					
					for (int i = 0; i != (data_IMPL_strandGroupSettings?.Length ?? 0); i++)
					{
						TransferSettingsSystem(in_0, ref data_IMPL_strandGroupSettings[i].settingsGeometry);
					}
				}

				// => data_IMPL_strandGroupDefaults.settingsPhysics
				// => data_IMPL_strandGroupSettings[].settingsPhysics
				{
					static void TransferSettingsSystem(in __0__SettingsSystem in_0, ref __IMPL__SettingsPhysics out_IMPL)
					{
						static __IMPL__SolverLODSelection TranslateLODSelection(__0__SettingsSystem.LODSelection x)
						{
							switch (x)
							{
								default:
								case __0__SettingsSystem.LODSelection.Automatic: return __IMPL__SolverLODSelection.AutomaticPerGroup;
								case __0__SettingsSystem.LODSelection.Fixed: return __IMPL__SolverLODSelection.Manual;
							}
						};

						out_IMPL.kLODSelection = TranslateLODSelection(in_0.kLODSearch);
						out_IMPL.kLODSelectionValue = in_0.kLODSearchValue;
					}

					TransferSettingsSystem(in_0, ref data_IMPL_strandGroupDefaults.settingsPhysics);
					
					for (int i = 0; i != (data_IMPL_strandGroupSettings?.Length ?? 0); i++)
					{
						TransferSettingsSystem(in_0, ref data_IMPL_strandGroupSettings[i].settingsPhysics);
					}
				}

				// => data_IMPL_strandGroupDefaults.settingsRendering
				// => data_IMPL_strandGroupSettings[].settingsRendering
				{
					static void TransferSettingsSystem(in __0__SettingsSystem in_0, ref __IMPL__SettingsRendering out_IMPL)
					{
						static __IMPL__SettingsRendering.Renderer TranslateStrandRenderer(__0__SettingsSystem.StrandRenderer x)
						{
							switch (x)
							{
								case __0__SettingsSystem.StrandRenderer.Disabled: return __IMPL__SettingsRendering.Renderer.Disabled;
								default:
								case __0__SettingsSystem.StrandRenderer.BuiltinLines: return __IMPL__SettingsRendering.Renderer.BuiltinLines;
								case __0__SettingsSystem.StrandRenderer.BuiltinStrips: return __IMPL__SettingsRendering.Renderer.BuiltinStrips;
								case __0__SettingsSystem.StrandRenderer.BuiltinTubes: return __IMPL__SettingsRendering.Renderer.BuiltinTubes;
								case __0__SettingsSystem.StrandRenderer.HDRPHighQualityLines: return __IMPL__SettingsRendering.Renderer.HDRPHighQualityLines;
							}
						};

						out_IMPL.renderer = TranslateStrandRenderer(in_0.strandRenderer);
#if HAS_PACKAGE_UNITY_HDRP_15_0_2
						out_IMPL.rendererGroup = in_0.strandRendererGroup;
#endif
						out_IMPL.rendererLayers = in_0.strandLayers;
						out_IMPL.rendererShadows = in_0.strandShadows;
						out_IMPL.motionVectors = in_0.motionVectors;
					}

					TransferSettingsSystem(in_0, ref data_IMPL_strandGroupDefaults.settingsRendering);

					for (int i = 0; i != (data_IMPL_strandGroupSettings?.Length ?? 0); i++)
					{
						TransferSettingsSystem(in_0, ref data_IMPL_strandGroupSettings[i].settingsRendering);
					}
				}
			}

			// migrate data_0_settingsVolume
			{
				ref readonly var in_0 = ref data_0_settingsVolume;

				// => data_IMPL_settingsEnvironment
				{
					static void TransferSettingsVolume(in __0__VolumeSettings in_0, ref __IMPL__SettingsEnvironment out_IMPL)
					{
						static __IMPL__SettingsEnvironment.BoundaryCaptureMode TranslateCollectMode(__0__VolumeSettings.CollectMode x) => (__IMPL__SettingsEnvironment.BoundaryCaptureMode)x;

						out_IMPL.boundaryCapture = in_0.boundariesCollect;
						out_IMPL.boundaryCaptureMode = TranslateCollectMode(in_0.boundariesCollectMode);
						out_IMPL.boundaryCaptureLayer = in_0.boundariesCollectLayer;
						out_IMPL.boundaryResident = in_0.boundariesPriority;
						out_IMPL.defaultSolidMargin = in_0.collisionMargin;
						out_IMPL.defaultSolidDensity = in_0.probeOcclusionSolidDensity;
					}

					TransferSettingsVolume(in_0, ref data_IMPL_settingsEnvironment);
				}

				// => data_IMPL_settingsVolumetrics
				{
					static void TransferSettingsVolume(in __0__VolumeSettings in_0, ref __IMPL__SettingsVolumetrics out_IMPL)
					{
						static __IMPL__SettingsVolumetrics.GridPrecision TranslateGridPrecision(__0__VolumeSettings.GridPrecision x) => (__IMPL__SettingsVolumetrics.GridPrecision)x;
						static __IMPL__SettingsVolumetrics.SplatMethod TranslateSplatMethod(__0__VolumeSettings.SplatMethod x) => (__IMPL__SettingsVolumetrics.SplatMethod)x;
						static __IMPL__SettingsVolumetrics.PressureSolution TranslatePressureSolution(__0__VolumeSettings.PressureSolution x) => (__IMPL__SettingsVolumetrics.PressureSolution)x;
						static __IMPL__SettingsVolumetrics.RestDensity TranslateTargetDensity(__0__VolumeSettings.TargetDensity x) => (__IMPL__SettingsVolumetrics.RestDensity)x;
						static __IMPL__SettingsVolumetrics.OcclusionMode TranslateOcclusionMode(__0__VolumeSettings.OcclusionMode x) => (__IMPL__SettingsVolumetrics.OcclusionMode)x;

						out_IMPL.gridPrecision = TranslateGridPrecision(in_0.gridPrecision);
						out_IMPL.gridResolution = (uint)in_0.gridResolution;

						out_IMPL.splatMethod = TranslateSplatMethod(in_0.splatMethod);
						out_IMPL.splatClusters = in_0.splatClusters;

						out_IMPL.pressureIterations = (uint)in_0.pressureIterations;
						out_IMPL.pressureSolution = TranslatePressureSolution(in_0.pressureSolution);
						out_IMPL.restDensity = TranslateTargetDensity(in_0.targetDensity);
						out_IMPL.restDensityInfluence = in_0.targetDensityInfluence;

						out_IMPL.scatteringProbe = in_0.scatteringProbe;
						out_IMPL.scatteringProbeCellSubsteps = in_0.scatteringProbeCellSubsteps;
						out_IMPL.scatteringProbeBias = in_0.scatteringProbeBias;
						out_IMPL.probeSamplesTheta = in_0.probeSamplesTheta;
						out_IMPL.probeSamplesPhi = in_0.probeSamplesPhi;
						out_IMPL.probeOcclusion = in_0.probeOcclusion;
						out_IMPL.probeOcclusionMode = TranslateOcclusionMode(in_0.probeOcclusionMode);
						out_IMPL.probeOcclusionSolidDensity = in_0.probeOcclusionSolidDensity;

						out_IMPL.windPropagation = in_0.windPropagation;
						out_IMPL.windPropagationCellSubsteps = in_0.windPropagationCellSubsteps;
						out_IMPL.windOcclusion = in_0.windOcclusion;
						out_IMPL.windOcclusionMode = TranslateOcclusionMode(in_0.windOcclusionMode);
						out_IMPL.windDepth = in_0.windExtinction;
					}

					TransferSettingsVolume(in_0, ref data_IMPL_settingsVolumetrics);
				}
			}

			// migrate data_0_strandGroupDefaults
			// migrate data_0_strandGroupSettings[]
			{
				// *.settingsStrands
				{
					// => data_IMPL_strandGroupDefaults.settingsRendering
					// => data_IMPL_strandGroupSettings[].settingsRendering
					{
						static void TransferSettingsStrands(in __0__SettingsStrands in_0, ref __IMPL__SettingsRendering out_IMPL)
						{
							out_IMPL.material = in_0.material;
							out_IMPL.materialAsset = in_0.materialValue;
						}

						TransferSettingsStrands(data_0_strandGroupDefaults.settingsStrands, ref data_IMPL_strandGroupDefaults.settingsRendering);

						for (int i = 0; i != (data_IMPL_strandGroupSettings?.Length ?? 0); i++)
						{
							TransferSettingsStrands(data_0_strandGroupSettings[i].settingsStrands, ref data_IMPL_strandGroupSettings[i].settingsRendering);
							data_IMPL_strandGroupSettings[i].settingsRenderingToggle = data_0_strandGroupSettings[i].settingsStrandsToggle;
						}
					}

					// => data_IMPL_strandGroupDefaults.settingsGeometry
					// => data_IMPL_strandGroupSettings[].settingsGeometry
					{
						static void TransferSettingsStrands(in __0__SettingsStrands in_0, ref __IMPL__SettingsGeometry out_IMPL)
						{
							static __IMPL__SettingsGeometry.StrandScale TranslateStrandScale(__0__SettingsStrands.StrandScale x) => (__IMPL__SettingsGeometry.StrandScale)x;
							static __IMPL__SettingsGeometry.StagingPrecision TranslateStagingPrecision(__0__SettingsStrands.StagingPrecision x) => (__IMPL__SettingsGeometry.StagingPrecision)x;

							out_IMPL.strandScale = TranslateStrandScale(in_0.strandScale);
							out_IMPL.strandDiameter = true;
							out_IMPL.strandDiameterValue = in_0.strandDiameter;
							out_IMPL.strandSeparation = in_0.strandMargin;

							out_IMPL.stagingPrecision = TranslateStagingPrecision(in_0.stagingPrecision);
							out_IMPL.stagingSubdivision = (in_0.stagingSubdivision > 0);
							out_IMPL.stagingSubdivisionCount = (in_0.stagingSubdivision > 0) ? in_0.stagingSubdivision : 1;
						}

						TransferSettingsStrands(data_0_strandGroupDefaults.settingsStrands, ref data_IMPL_strandGroupDefaults.settingsGeometry);

						for (int i = 0; i != (data_IMPL_strandGroupSettings?.Length ?? 0); i++)
						{
							TransferSettingsStrands(data_0_strandGroupSettings[i].settingsStrands, ref data_IMPL_strandGroupSettings[i].settingsGeometry);
							data_IMPL_strandGroupSettings[i].settingsGeometryToggle = data_0_strandGroupSettings[i].settingsStrandsToggle;
						}
					}
				}

				// *.settingsSolver
				{
					// => data_IMPL_strandGroupDefaults.settingsPhysics
					// => data_IMPL_strandGroupSettings[].settingsPhysics
					{
						static void TransferSettingsSolver(in __0__SolverSettings in_0, ref __IMPL__SettingsPhysics out_IMPL)
						{
							static __IMPL__SettingsPhysics.Solver TranslateMethod(__0__SolverSettings.Method x) => (__IMPL__SettingsPhysics.Solver)x;
							static __IMPL__SettingsPhysics.TimeInterval TranslateTimeInterval(__0__SolverSettings.TimeInterval x) => (__IMPL__SettingsPhysics.TimeInterval)x;
							static __IMPL__SettingsPhysics.LocalCurvatureMode TranslateLocalCurvatureMode(__0__SolverSettings.LocalCurvatureMode x) => (__IMPL__SettingsPhysics.LocalCurvatureMode)x;
							static __IMPL__SettingsPhysics.LocalShapeMode TranslateLocalShapeMode(__0__SolverSettings.LocalShapeMode x) => (__IMPL__SettingsPhysics.LocalShapeMode)x;

							out_IMPL.solver = TranslateMethod(in_0.method);
							out_IMPL.solverSubsteps = (uint)in_0.substeps;
							out_IMPL.constraintIterations = (uint)in_0.iterations;
							out_IMPL.constraintStiffness = in_0.stiffness;
							out_IMPL.constraintSOR = in_0.kSOR;

							out_IMPL.dampingLinear = in_0.damping;
							out_IMPL.dampingLinearFactor = in_0.dampingFactor;
							out_IMPL.dampingLinearInterval = TranslateTimeInterval(in_0.dampingInterval);
							out_IMPL.dampingAngular = in_0.angularDamping;
							out_IMPL.dampingAngularFactor = in_0.angularDampingFactor;
							out_IMPL.dampingAngularInterval = TranslateTimeInterval(in_0.angularDampingInterval);
							out_IMPL.cellPressure = in_0.cellPressure;
							out_IMPL.cellVelocity = in_0.cellVelocity;
							out_IMPL.cellExternal = in_0.cellForces;
							out_IMPL.gravity = 1.0f;// global scale and rotation moves to data_IMPL_settingsEnvironment

							out_IMPL.boundaryCollision = in_0.boundaryCollision;
							out_IMPL.boundaryCollisionFriction = in_0.boundaryCollisionFriction;
							out_IMPL.distance = in_0.distance;
							out_IMPL.distanceLRA = in_0.distanceLRA;
							out_IMPL.distanceFTL = in_0.distanceFTL;
							out_IMPL.distanceFTLCorrection = in_0.distanceFTLCorrection;
							out_IMPL.localCurvature = in_0.localCurvature;
							out_IMPL.localCurvatureMode = TranslateLocalCurvatureMode(in_0.localCurvatureMode);
							out_IMPL.localCurvatureValue = in_0.localCurvatureValue;
							out_IMPL.localShape = in_0.localShape;
							out_IMPL.localShapeMode = TranslateLocalShapeMode(in_0.localShapeMode);
							out_IMPL.localShapeInfluence = in_0.localShapeInfluence;
							out_IMPL.localShapeBias = in_0.localShapeBias;
							out_IMPL.localShapeBiasValue = in_0.localShapeBiasValue;

							out_IMPL.globalPosition = in_0.globalPosition;
							out_IMPL.globalPositionInfluence = in_0.globalPositionInfluence;
							out_IMPL.globalPositionInterval = TranslateTimeInterval(in_0.globalPositionInterval);
							out_IMPL.globalRotation = in_0.globalRotation;
							out_IMPL.globalRotationInfluence = in_0.globalRotationInfluence;
							out_IMPL.globalFade = in_0.globalFade;
							out_IMPL.globalFadeOffset = in_0.globalFadeOffset;
							out_IMPL.globalFadeExtent = in_0.globalFadeExtent;
						}

						TransferSettingsSolver(data_0_strandGroupDefaults.settingsSolver, ref data_IMPL_strandGroupDefaults.settingsPhysics);

						for (int i = 0; i != (data_IMPL_strandGroupSettings?.Length ?? 0); i++)
						{
							TransferSettingsSolver(data_0_strandGroupSettings[i].settingsSolver, ref data_IMPL_strandGroupSettings[i].settingsPhysics);
							data_IMPL_strandGroupSettings[i].settingsPhysicsToggle = data_0_strandGroupSettings[i].settingsSolverToggle;
						}
					}

					// => data_IMPL_settingsEnvironment
					{
						static void TransferSettingsSolver(in __0__SolverSettings in_0, ref __IMPL__SettingsEnvironment out_IMPL)
						{
							out_IMPL.gravityScale = in_0.gravity;
							out_IMPL.gravityRotation = Quaternion.Euler(in_0.gravityRotation);
						}

						TransferSettingsSolver(data_0_strandGroupDefaults.settingsSolver, ref data_IMPL_settingsEnvironment);
					}
				}
			}
		}

		[Serializable]
		// captured @ 46a8b132
		struct __0__SettingsSystem
		{
			public enum BoundsMode
			{
				Automatic,
				Fixed,
			}

			public enum LODSelection
			{
				Automatic,
				Fixed,
			}

			public enum StrandRenderer
			{
				Disabled = 0,
				BuiltinLines = 1,
				BuiltinStrips = 2,
				BuiltinTubes = 4,
				HDRPHighQualityLines = 3,
			}

			public enum UpdateMode
			{
				BuiltinEvent,
				External,
			}

			public enum SimulationRate
			{
				Fixed30Hz,
				Fixed60Hz,
				Fixed120Hz,
				CustomTimeStep,
			}

			public BoundsMode boundsMode;
			public Vector3 boundsCenter;
			public Vector3 boundsExtent;
			public bool boundsScale;
			public float boundsScaleValue;

			public LODSelection kLODSearch;
			public CameraType kLODSearchViews;
			public AnimationCurve kLODSearchCurve;
			public float kLODSearchValue;
			public bool kLODBlending;

			public StrandRenderer strandRenderer;
#if HAS_PACKAGE_UNITY_HDRP_15_0_2
			[FormerlySerializedAs("strandRendererGroupingValue")]
			public LineRendering.RendererGroup strandRendererGroup;
#endif
			public ShadowCastingMode strandShadows;
			public int strandLayers;
			public MotionVectorGenerationMode motionVectors;

			public UpdateMode updateMode;

			public bool simulation;
			public SimulationRate simulationRate;
			public bool simulationInEditor;
			public float simulationTimeStep;
			public bool stepsMin;
			public int stepsMinValue;
			public bool stepsMax;
			public int stepsMaxValue;

			public static readonly __0__SettingsSystem defaults = new __0__SettingsSystem()
			{
				boundsMode = BoundsMode.Automatic,
				boundsCenter = new Vector3(0.0f, 0.0f, 0.0f),
				boundsExtent = new Vector3(1.0f, 1.0f, 1.0f),
				boundsScale = false,
				boundsScaleValue = 1.25f,

				kLODSearch = LODSelection.Fixed,
				kLODSearchViews = ~CameraType.SceneView,
				kLODSearchCurve = AnimationCurve.Linear(0.0f, 0.0f, 1.0f, 1.0f),
				kLODSearchValue = 1.0f,
				kLODBlending = false,

				strandRenderer = StrandRenderer.BuiltinLines,
#if HAS_PACKAGE_UNITY_HDRP_15_0_2
				strandRendererGroup = LineRendering.RendererGroup.None,
#endif
				strandShadows = ShadowCastingMode.On,
				strandLayers = 0x0101,//TODO this is the HDRP default -- should decide based on active pipeline asset
				motionVectors = MotionVectorGenerationMode.Object,

				updateMode = UpdateMode.BuiltinEvent,

				simulation = true,
				simulationRate = SimulationRate.Fixed30Hz,
				simulationInEditor = true,
				simulationTimeStep = 1.0f / 100.0f,
				stepsMin = false,
				stepsMinValue = 1,
				stepsMax = true,
				stepsMaxValue = 1,
			};
		}

		[Serializable]
		// captured @ 46a8b132
		struct __0__VolumeSettings
		{
			public enum GridPrecision
			{
				Full,
				Half,
			}

			public enum SplatMethod
			{
				None,
				Compute,
				ComputeSplit,
				Rasterization,
				RasterizationNoGS,
			}

			public enum PressureSolution
			{
				DensityEquals,
				DensityLessThan,
			}

			public enum TargetDensity
			{
				Uniform,
				InitialPose,
				InitialPoseInParticles,
			}

			public enum OcclusionMode
			{
				Discrete,
				Exact,
			}

			public enum CollectMode
			{
				JustTagged,
				IncludeColliders,
			}

			public GridPrecision gridPrecision;
			[FormerlySerializedAs("volumeGridResolution")]
			public int gridResolution;

			[FormerlySerializedAs("volumeSplatMethod")]
			public SplatMethod splatMethod;
			public bool splatClusters;

			public int pressureIterations;
			public PressureSolution pressureSolution;
			public TargetDensity targetDensity;
			public float targetDensityInfluence;

			[FormerlySerializedAs("strandCountProbe")]
			public bool scatteringProbe;
			[FormerlySerializedAs("strandCountProbeCellSubsteps")]
			public uint scatteringProbeCellSubsteps;
			[FormerlySerializedAs("strandCountBias")]
			public float scatteringProbeBias;
			[FormerlySerializedAs("probeStepsTheta")]
			public uint probeSamplesTheta;
			[FormerlySerializedAs("probeStepsPhi")]
			public uint probeSamplesPhi;
			public bool probeOcclusion;
			public OcclusionMode probeOcclusionMode;
			public float probeOcclusionSolidDensity;

			public bool windPropagation;
			public uint windPropagationCellSubsteps;
			public bool windOcclusion;
			public OcclusionMode windOcclusionMode;
			public float windExtinction;

			public float collisionMargin;
			public bool boundariesCollect;
			public CollectMode boundariesCollectMode;
			public LayerMask boundariesCollectLayer;
			public HairBoundary[] boundariesPriority;

			public static readonly __0__VolumeSettings defaults = new __0__VolumeSettings()
			{
				splatMethod = SplatMethod.Compute,
				splatClusters = true,

				gridResolution = 32,
				gridPrecision = GridPrecision.Full,

				pressureIterations = 3,
				pressureSolution = PressureSolution.DensityLessThan,
				targetDensity = TargetDensity.Uniform,
				targetDensityInfluence = 1.0f,

				scatteringProbe = false,
				scatteringProbeCellSubsteps = 1,
				scatteringProbeBias = 1.0f,
				probeSamplesTheta = 5,
				probeSamplesPhi = 10,
				probeOcclusion = true,
				probeOcclusionMode = OcclusionMode.Discrete,
				probeOcclusionSolidDensity = 5.0f,

				windPropagation = true,
				windPropagationCellSubsteps = 1,
				windOcclusion = true,
				windOcclusionMode = OcclusionMode.Exact,
				windExtinction = 1.0f,

				collisionMargin = 0.25f,
				boundariesCollect = true,
				boundariesCollectMode = CollectMode.IncludeColliders,
				boundariesCollectLayer = Physics.AllLayers,
				boundariesPriority = new HairBoundary[0],
			};
		}

		[Serializable]
		// captured @ 46a8b132
		struct __0__GroupSettings
		{
			//public List<GroupAssetReference> groupAssetReferences;

			//public __0__SettingsSkinning settingsSkinning;
			//public bool settingsSkinningToggle;

			public __0__SettingsStrands settingsStrands;
			public bool settingsStrandsToggle;

			public __0__SolverSettings settingsSolver;
			public bool settingsSolverToggle;

			public static __0__GroupSettings defaults => new __0__GroupSettings()
			{
				//groupAssetReferences = new List<GroupAssetReference>(1),

				//settingsSkinning = SettingsSkinning.defaults,
				//settingsSkinningToggle = false,

				settingsStrands = __0__SettingsStrands.defaults,
				settingsStrandsToggle = false,

				settingsSolver = __0__SolverSettings.defaults,
				settingsSolverToggle = false,
			};
		}

		[Serializable]
		// captured @ 46a8b132
		struct __0__SettingsStrands
		{
			public enum StrandScale
			{
				Fixed,
				UniformWorldMin,
				UniformWorldMax,
			}

			public enum StagingPrecision
			{
				Full,
				Half,
			}

			[FormerlySerializedAs("strandMaterial")]
			public bool material;
			[FormerlySerializedAs("strandMaterialValue")]
			public Material materialValue;

			public StrandScale strandScale;
			public float strandDiameter;
			public float strandMargin;

			public StagingPrecision stagingPrecision;
			public uint stagingSubdivision;

			public static readonly __0__SettingsStrands defaults = new __0__SettingsStrands()
			{
				material = false,
				materialValue = null,

				strandScale = StrandScale.Fixed,
				strandDiameter = 1.0f,
				strandMargin = 0.0f,

				stagingSubdivision = 0,
				stagingPrecision = StagingPrecision.Half,
			};
		}

		[Serializable]
		// captured @ 46a8b132
		struct __0__SolverSettings
		{
			public enum Method
			{
				GaussSeidelReference = 0,
				GaussSeidel = 1,
				Jacobi = 2,
			}

			public enum TimeInterval
			{
				PerSecond,
				Per100ms,
				Per10ms,
				Per1ms,
			}

			public enum LocalCurvatureMode
			{
				Equals,
				LessThan,
				GreaterThan,
			}

			public enum LocalShapeMode
			{
				Forward,
				Stitched,
			}

			public Method method;
			public int iterations;
			public int substeps;
			public float stiffness;
			public float kSOR;

			public bool damping;
			public float dampingFactor;
			public TimeInterval dampingInterval;
			public bool angularDamping;
			public float angularDampingFactor;
			public TimeInterval angularDampingInterval;
			public float cellPressure;
			public float cellVelocity;
			public float cellForces;
			public float gravity;
			public Vector3 gravityRotation;

			public bool boundaryCollision;
			public float boundaryCollisionFriction;
			public bool distance;
			public bool distanceLRA;
			public bool distanceFTL;
			[FormerlySerializedAs("distanceFTLDamping")]
			public float distanceFTLCorrection;
			public bool localCurvature;
			public LocalCurvatureMode localCurvatureMode;
			public float localCurvatureValue;
			public bool localShape;
			public LocalShapeMode localShapeMode;
			public float localShapeInfluence;
			public bool localShapeBias;
			public float localShapeBiasValue;

			public bool globalPosition;
			public float globalPositionInfluence;
			public TimeInterval globalPositionInterval;
			public bool globalRotation;
			public float globalRotationInfluence;
			public bool globalFade;
			public float globalFadeOffset;
			public float globalFadeExtent;

			public static readonly __0__SolverSettings defaults = new __0__SolverSettings()
			{
				method = Method.GaussSeidel,
				substeps = 1,
				iterations = 3,
				stiffness = 1.0f,
				kSOR = 1.0f,

				damping = false,
				dampingFactor = 0.5f,
				dampingInterval = TimeInterval.PerSecond,
				angularDamping = false,
				angularDampingFactor = 0.5f,
				angularDampingInterval = TimeInterval.PerSecond,
				cellPressure = 1.0f,
				cellVelocity = 0.05f,
				cellForces = 1.0f,
				gravity = 1.0f,

				boundaryCollision = true,
				boundaryCollisionFriction = 0.5f,
				distance = true,
				distanceLRA = true,
				distanceFTL = false,
				distanceFTLCorrection = 0.8f,
				localCurvature = false,
				localCurvatureMode = LocalCurvatureMode.LessThan,
				localCurvatureValue = 0.1f,
				localShape = true,
				localShapeMode = LocalShapeMode.Stitched,
				localShapeInfluence = 1.0f,
				localShapeBias = true,
				localShapeBiasValue = 0.5f,

				globalPosition = false,
				globalPositionInfluence = 1.0f,
				globalPositionInterval = TimeInterval.PerSecond,
				globalRotation = false,
				globalRotationInfluence = 1.0f,
				globalFade = false,
				globalFadeOffset = 0.1f,
				globalFadeExtent = 0.2f,
			};
		}
	}
}

```

`Runtime/HairInstance.Migration.0.cs.meta`:

```meta
fileFormatVersion: 2
guid: 8fd523592c2e2ab4bb278ce5afb86086
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairInstance.Migration.1.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.Rendering;

#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN
using Unity.DemoTeam.DigitalHuman;
#endif

namespace Unity.DemoTeam.Hair
{
	// data migration impl. checklist:
	//
	//	- block renamed: capture and migrate all fields
	//	- field(s) renamed: capture and migrate renamed fields
	//	- field(s) changed: capture and migrate changed fields
	//	- field(s) removed: no action
	//
	// data migration is then a simple two-step process:
	//
	//	1. capture old data into trimmed copies of old structures (via FormerlySerializedAs)
	//	2. migrate old data from trimmed copies
	//
	// (old structures are unfortunately also re-serialized)

	using __IMPL__SettingsGeometry = HairSim.SettingsGeometry;

	public partial class HairInstance
	{
		void PerformMigration_1()
		{
			ref var data_IMPL_strandGroupDefaults = ref this.strandGroupDefaults;
			ref var data_IMPL_strandGroupSettings = ref this.strandGroupSettings;

			// prepare data_IMPL_strandGroup*.settingsGeometry
			{
				static void PrepareSettingsGeometry(ref __IMPL__SettingsGeometry out_IMPL)
				{
					out_IMPL.tipScale = false;
					out_IMPL.tipScaleValue = HairAsset.SharedDefaults.defaultTipScale;

					out_IMPL.tipScaleOffset = false;
					out_IMPL.tipScaleOffsetValue = HairAsset.SharedDefaults.defaultTipScaleOffset;
				}

				PrepareSettingsGeometry(ref data_IMPL_strandGroupDefaults.settingsGeometry);

				for (int i = 0; i != (data_IMPL_strandGroupSettings?.Length ?? 0); i++)
				{
					PrepareSettingsGeometry(ref data_IMPL_strandGroupSettings[i].settingsGeometry);
				}
			}
		}
	}

	[Serializable]
	// captured @ a4dedfe5
	struct __1__GroupSettings
	{
		//public List<GroupAssetReference> groupAssetReferences;

		//public SettingsSkinning settingsSkinning;
		//public bool settingsSkinningToggle;

		//public __1__SettingsGeometry settingsGeometry;
		//public bool settingsGeometryToggle;

		//public HairSim.SettingsRendering settingsRendering;
		//public bool settingsRenderingToggle;

		//public HairSim.SettingsPhysics settingsPhysics;
		//public bool settingsPhysicsToggle;

		public static __1__GroupSettings defaults => new __1__GroupSettings()
		{
			//groupAssetReferences = new List<GroupAssetReference>(1),

			//settingsSkinning = SettingsSkinning.defaults,
			//settingsSkinningToggle = false,

			//settingsGeometry = __1__SettingsGeometry.defaults,
			//settingsGeometryToggle = false,

			//settingsRendering = HairSim.SettingsRendering.defaults,
			//settingsRenderingToggle = false,

			//settingsPhysics = HairSim.SettingsPhysics.defaults,
			//settingsPhysicsToggle = false,
		};
	}

	[Serializable]
	// captured @ a4dedfe5
	struct __1__SettingsGeometry
	{
		//public enum StrandScale
		//{
		//	Fixed = 0,
		//	UniformWorldMin = 1,
		//	UniformWorldMax = 2,
		//}

		//public enum BoundsMode
		//{
		//	Automatic = 0,
		//	Manual = 1,
		//}

		//public enum StagingPrecision
		//{
		//	Full = 0,
		//	Half = 1,
		//}

		//public StrandScale strandScale;
		//public bool strandLength;
		//public float strandLengthValue;
		//public bool strandDiameter;
		//public float strandDiameterValue;
		//public float strandSeparation;

		//public BoundsMode boundsMode;
		//public Vector3 boundsCenter;
		//public Vector3 boundsExtent;
		//public bool boundsScale;
		//public float boundsScaleValue;

		//public StagingPrecision stagingPrecision;
		//public bool stagingSubdivision;
		//public uint stagingSubdivisionCount;

		public static readonly __1__SettingsGeometry defaults = new __1__SettingsGeometry()
		{
			//strandScale = StrandScale.Fixed,
			//strandDiameter = false,
			//strandDiameterValue = 1.0f,
			//strandLength = false,
			//strandLengthValue = 1.0f,
			//strandSeparation = 0.0f,

			//boundsMode = BoundsMode.Automatic,
			//boundsCenter = Vector3.zero,
			//boundsExtent = Vector3.one,
			//boundsScale = false,
			//boundsScaleValue = 1.25f,

			//stagingPrecision = StagingPrecision.Half,
			//stagingSubdivision = false,
			//stagingSubdivisionCount = 1,
		};
	}
}

```

`Runtime/HairInstance.Migration.1.cs.meta`:

```meta
fileFormatVersion: 2
guid: aa5d95f0b6ff1064aa4b311a747be560
```

`Runtime/HairInstance.Migration.cs`:

```cs
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public partial class HairInstance : IVersionedDataContext
	{
		const int VERSION_IMPL = 2;

		[field: SerializeField]
		public int version { get; private set; } = -1;
		public int VERSION => VERSION_IMPL;

		public void PerformMigrationStep()
		{
			switch (version)
			{
				case 0:
					PerformMigration_0();
					version = VERSION_IMPL;
					break;

				case 1:
					PerformMigration_1();
					version = VERSION_IMPL;
					break;

				case VERSION_IMPL:
					// at latest version
					break;
			}
		}
	}
}

```

`Runtime/HairInstance.Migration.cs.meta`:

```meta
fileFormatVersion: 2
guid: f08be115315a0284fa872a14ced89262
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairInstance.Settings.Deprecated.cs`:

```cs
using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public partial class HairInstance
	{
		[EditorBrowsable(EditorBrowsableState.Never), HideInInspector]
		[Obsolete("Renamed HairInstance.settingsSystem (UnityUpgradable) -> settingsExecutive", true)]
		public SettingsSystem settingsSystem;

		[StructLayout(LayoutKind.Explicit)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Renamed HairInstance/SettingsSystem (UnityUpgradable) -> HairInstance/SettingsExecutive", true)]
		public struct SettingsSystem
		{
			[FieldOffset(0)]
			[EditorBrowsable(EditorBrowsableState.Never), HideInInspector]
			[Obsolete("Renamed SettingsSystem.simulation (UnityUpgradable) -> updateSimulation", true)]
			public bool simulation;

			[FieldOffset(0)]
			[EditorBrowsable(EditorBrowsableState.Never), HideInInspector]
			[Obsolete("Renamed SettingsSystem.simulationRate (UnityUpgradable) -> updateSimulationRate", true)]
			public SettingsExecutive.UpdateRate simulationRate;

			[FieldOffset(0)]
			[EditorBrowsable(EditorBrowsableState.Never), HideInInspector]
			[Obsolete("Renamed SettingsSystem.simulationInEditor (UnityUpgradable) -> updateSimulationInEditor", true)]
			public bool simulationInEditor;

			[FieldOffset(0)]
			[EditorBrowsable(EditorBrowsableState.Never), HideInInspector]
			[Obsolete("Renamed SettingsSystem.simulationTimeStep (UnityUpgradable) -> updateTimeStep", true)]
			public float simulationTimeStep;

			[FieldOffset(0)]
			[EditorBrowsable(EditorBrowsableState.Never), HideInInspector]
			[Obsolete("Renamed SettingsSystem.stepsMin (UnityUpgradable) -> updateStepsMin", true)]
			public bool stepsMin;

			[FieldOffset(0)]
			[EditorBrowsable(EditorBrowsableState.Never), HideInInspector]
			[Obsolete("Renamed SettingsSystem.stepsMinValue (UnityUpgradable) -> updateStepsMinValue", true)]
			public int stepsMinValue;

			[FieldOffset(0)]
			[EditorBrowsable(EditorBrowsableState.Never), HideInInspector]
			[Obsolete("Renamed SettingsSystem.stepsMax (UnityUpgradable) -> updateStepsMax", true)]
			public bool stepsMax;

			[FieldOffset(0)]
			[EditorBrowsable(EditorBrowsableState.Never), HideInInspector]
			[Obsolete("Renamed SettingsSystem.stepsMaxValue (UnityUpgradable) -> updateStepsMaxValue", true)]
			public int stepsMaxValue;
		}
	}
}

```

`Runtime/HairInstance.Settings.Deprecated.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6224df3a958b8c54bac353635e0655e1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairInstance.Settings.cs`:

```cs
using System;
using UnityEngine;

#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN
using Unity.DemoTeam.DigitalHuman;
#endif

namespace Unity.DemoTeam.Hair
{
	public partial class HairInstance
	{
		[Serializable]
		public struct SettingsExecutive
		{
			public enum UpdateMode
			{
				BuiltinEvent	= 0,
				ExternalCall	= 1,
			}

			public enum UpdateRate
			{
				Fixed30Hz		= 0,
				Fixed60Hz		= 1,
				Fixed90Hz		= 2,
				Fixed120Hz		= 3,
				CustomTimeStep	= 4,
			}

			[LineHeader("Scheduling")]

			[Tooltip("Specifies whether updates are scheduled and dispatched via builtin event, or scheduled via external call (with caller being responsible for subsequent dispatch)")]
			public UpdateMode updateMode;

			[LineHeader("Simulation")]

			[ToggleGroup, Tooltip("Enable simulation")]
			public bool updateSimulation;
			[ToggleGroupItem, Tooltip("Simulation update rate")]
			public UpdateRate updateSimulationRate;
			[ToggleGroupItem(withLabel = true), Tooltip("Enable simulation in Edit Mode")]
			public bool updateSimulationInEditor;
			[VisibleIf(nameof(updateSimulationRate), UpdateRate.CustomTimeStep), Tooltip("Simulation time step (in seconds)")]
			public float updateTimeStep;
			[ToggleGroup, Tooltip("Enable minimum number of simulation steps per rendered frame")]
			public bool updateStepsMin;
			[ToggleGroupItem, Tooltip("Minimum number of simulation steps per rendered frame")]
			public int updateStepsMinValue;
			[ToggleGroup, Tooltip("Enable maximum number of simulation steps per rendered frame")]
			public bool updateStepsMax;
			[ToggleGroupItem, Tooltip("Maximum number of simulation steps per rendered frame")]
			public int updateStepsMaxValue;

			public static readonly SettingsExecutive defaults = new SettingsExecutive()
			{
				updateMode = UpdateMode.BuiltinEvent,

				updateSimulation = true,
				updateSimulationRate = UpdateRate.Fixed30Hz,
				updateSimulationInEditor = true,
				updateTimeStep = 1.0f / 100.0f,
				updateStepsMin = false,
				updateStepsMinValue = 1,
				updateStepsMax = true,
				updateStepsMaxValue = 4,
			};
		}

		[Serializable]
		public struct SettingsSkinning
		{
#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN
			[LineHeader("Skinning")]

			[ToggleGroup]
			public bool rootsAttach;
			[ToggleGroupItem]
			public SkinAttachmentTarget rootsAttachTarget;
			[HideInInspector]
			public PrimarySkinningBone rootsAttachTargetBone;
#endif

			public static readonly SettingsSkinning defaults = new SettingsSkinning()
			{
#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN
				rootsAttach = false,
				rootsAttachTarget = null,
#endif
			};
		}
	}
}

```

`Runtime/HairInstance.Settings.cs.meta`:

```meta
fileFormatVersion: 2
guid: c0a96f835fbdaf740bc93a06dd31420c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairInstance.cs`:

```cs
#pragma warning disable 0414 // some fields are unused in case of disabled optional features

using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.Rendering;
using UnityEngine.XR;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

#if HAS_PACKAGE_UNITY_HDRP
using UnityEngine.Rendering.HighDefinition;
#endif

#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN
using Unity.DemoTeam.DigitalHuman;
#endif

namespace Unity.DemoTeam.Hair
{
	[ExecuteAlways, SelectionBase]
	public partial class HairInstance : MonoBehaviour
	{
		public static HashSet<HairInstance> s_instances = new HashSet<HairInstance>();

		[Serializable]
		public struct GroupProvider
		{
			public HairAsset hairAsset;
			public bool hairAssetQuickEdit;
		}

		[Serializable]
		public struct GroupAssetReference : IEquatable<GroupAssetReference>
		{
			public HairAsset hairAsset;
			public int hairAssetGroupIndex;

			public ulong GetSortKey()
			{
				var a = (ulong)hairAsset.GetInstanceID();
				var b = (ulong)hairAssetGroupIndex;
				return (a << 32) | b;
			}

			public ulong GetSortKey48()
			{
				var a = (ulong)hairAsset.GetInstanceID();
				var b = (ulong)hairAssetGroupIndex & 0xffffuL;
				return (a << 16) | b;
			}

			public ref readonly HairAsset.StrandGroup Resolve()
			{
				return ref hairAsset.strandGroups[hairAssetGroupIndex];
			}

			bool IEquatable<GroupAssetReference>.Equals(GroupAssetReference other)
			{
				return (GetSortKey() == other.GetSortKey());
			}
		}

		[Serializable]
		public struct GroupInstance
		{
			[Serializable]
			public struct SceneObjects
			{
				public GameObject groupContainer;

				public GameObject rootMeshContainer;
				public MeshFilter rootMeshFilter;
#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN
				public SkinAttachment rootMeshAttachment;
#endif

				public GameObject strandMeshContainer;
				public MeshFilter strandMeshFilter;
				public MeshRenderer strandMeshRenderer;
#if HAS_PACKAGE_UNITY_HDRP_15_0_2
				public HDAdditionalMeshRendererSettings strandMeshRendererHDRP;
#endif

				[NonSerialized] public Material materialInstance;
				[NonSerialized] public Material materialInstanceShadows;

#if !UNITY_2021_2_OR_NEWER
				[NonSerialized] public Mesh meshInstance;
				[NonSerialized] public Mesh meshInstanceShadows;

				[NonSerialized] public ulong meshInstanceKey;
				[NonSerialized] public ulong meshInstanceKeyShadows;
#endif
			}

			public GroupAssetReference groupAssetReference;
			public SceneObjects sceneObjects;
			public int settingsIndex;
		}

		[Serializable]
		public struct GroupSettings
		{
			public List<GroupAssetReference> groupAssetReferences;

			public SettingsSkinning settingsSkinning;
			public bool settingsSkinningToggle;

			public HairSim.SettingsGeometry settingsGeometry;
			public bool settingsGeometryToggle;

			public HairSim.SettingsRendering settingsRendering;
			public bool settingsRenderingToggle;

			public HairSim.SettingsPhysics settingsPhysics;
			public bool settingsPhysicsToggle;

			public static GroupSettings defaults => new GroupSettings()
			{
				groupAssetReferences = new List<GroupAssetReference>(1),

				settingsSkinning = SettingsSkinning.defaults,
				settingsSkinningToggle = false,

				settingsGeometry = HairSim.SettingsGeometry.defaults,
				settingsGeometryToggle = false,

				settingsRendering = HairSim.SettingsRendering.defaults,
				settingsRenderingToggle = false,

				settingsPhysics = HairSim.SettingsPhysics.defaults,
				settingsPhysicsToggle = false,
			};
		}

		public struct ExecutiveStep
		{
			public int countRaw;
			public int count;
			public float dt;
			public float hi;

			public static readonly ExecutiveStep defaults = new ExecutiveStep()
			{
				countRaw = 0,
				count = 0,
				dt = 0.0f,
				hi = 1.0f,
			};
		}

		public struct ExecutiveState
		{
			public float accumulatedTime;

			public double elapsedTimeRaw;
			public double elapsedTime;

			//public NativeQueue<TimeStepDesc> stepHistory;

			public int lastStepCount;
			public int lastStepCountRaw;
			public float lastStepCountSmooth;

			public bool pausePostStep;

			public static readonly ExecutiveState defaults = new ExecutiveState()
			{
				accumulatedTime = 0.0f,

				elapsedTime = 0.0f,
				elapsedTimeRaw = 0.0f,

				lastStepCount = 0,
				lastStepCountRaw = 0,
				lastStepCountSmooth = 0,

				pausePostStep = false,
			};
		}

		public string[] strandGroupChecksums;// checksums of active providers for instantiated groups

		public GroupProvider[] strandGroupProviders = new GroupProvider[1];
		public GroupInstance[] strandGroupInstances;
		public GroupSettings[] strandGroupSettings;
		public GroupSettings strandGroupDefaults = GroupSettings.defaults;

		[NonSerialized] public HairSim.SolverData[] solverData;
		[NonSerialized] public HairSim.VolumeData volumeData;
		[NonSerialized] public ExecutiveState execState = ExecutiveState.defaults;

		public SettingsExecutive settingsExecutive = SettingsExecutive.defaults;
		public HairSim.SettingsDebugging settingsDebugging = HairSim.SettingsDebugging.defaults;
		public HairSim.SettingsEnvironment settingsEnvironment = HairSim.SettingsEnvironment.defaults;
		public HairSim.SettingsVolume settingsVolumetrics = HairSim.SettingsVolume.defaults;

		public event Action<CommandBuffer> onSimulationStateChanged;
		public event Action<CommandBuffer> onRenderingStateChanged;

		void Reset()
		{
			version = VERSION;
		}

		void OnValidate()
		{
			if (version < 0)
				version = 0;

			VersionedDataUtility.HandleVersionChangeOnValidate(this);

			settingsVolumetrics.gridResolution = (uint)(Mathf.Max(8, (int)settingsVolumetrics.gridResolution) / 8) * 8;
		}

		void OnEnable()
		{
			VersionedDataUtility.HandleVersionChange(this);

			UpdateStrandGroupInstances();
			UpdateStrandGroupHideFlags();
			UpdateStrandGroupSettings();

			s_instances.Add(this);
		}

		void OnDisable()
		{
			ReleaseRuntimeData();
			ReleasePrerequisite();

			s_instances.Remove(this);
		}

		void Update()
		{
			UpdateStrandGroupInstances();
			UpdateStrandGroupSettings();
			UpdateAttachedState();
			UpdatePrerequisite();
		}

		void LateUpdate()
		{
			if (settingsExecutive.updateMode == SettingsExecutive.UpdateMode.BuiltinEvent)
			{
				HandlePrerequisite();
			}
		}

		#region Update Group Instances
		enum StrandGroupInstancesStatus
		{
			RequireRebuild,
			RequireRelease,
			Valid,
		}

		StrandGroupInstancesStatus CheckStrandGroupInstances()
		{
			var strandGroupChecksumCount = strandGroupChecksums?.Length ?? 0;
			var strandGroupProviderPass = 0;
			var strandGroupProviderFail = 0;

			for (int i = 0, readIndexChecksum = 0; i != strandGroupProviders.Length; i++)
			{
				var hairAsset = strandGroupProviders[i].hairAsset;
				if (hairAsset == null || hairAsset.checksum == "")
					continue;

				if (readIndexChecksum < strandGroupChecksumCount)
				{
					if (strandGroupChecksums[readIndexChecksum++] == hairAsset.checksum)
						strandGroupProviderPass++;
					else
						strandGroupProviderFail++;
				}
				else
				{
					strandGroupProviderFail++;
				}
			}

			var validChecksums = (strandGroupProviderPass == strandGroupChecksumCount);
			var validProviders = (strandGroupProviderFail == 0);
			if (validProviders && validChecksums)
			{
				return StrandGroupInstancesStatus.Valid;
			}
			else
			{
				var strandGroupProviderCount = strandGroupProviderPass + strandGroupProviderFail;
				if (strandGroupProviderCount > 0)
					return StrandGroupInstancesStatus.RequireRebuild;
				else
					return StrandGroupInstancesStatus.RequireRelease;
			}
		}

		void UpdateStrandGroupInstances()
		{
			var status = CheckStrandGroupInstances();
			if (status == StrandGroupInstancesStatus.Valid)
				return;

#if UNITY_EDITOR
			// if this is part of a prefab instance, then we need to handle content changes in underlying prefab
			var isPrefabInstance = UnityEditor.PrefabUtility.IsPartOfPrefabInstance(this);
			if (isPrefabInstance)
			{
				// ensure that all content-related properties are inherited from underlying prefab (these are also marked "prefab" and not-editable in UI)
				{
					var serializedObject = new UnityEditor.SerializedObject(this);

					var property_strandGroupProviders = serializedObject.FindProperty(nameof(strandGroupChecksums));
					var property_strandGroupChecksums = serializedObject.FindProperty(nameof(strandGroupProviders));
					var property_strandGroupDefaults = serializedObject.FindProperty(nameof(strandGroupDefaults));
					var property_strandGroupSettings = serializedObject.FindProperty(nameof(strandGroupSettings));

					UnityEditor.PrefabUtility.RevertPropertyOverride(property_strandGroupProviders, UnityEditor.InteractionMode.AutomatedAction);
					UnityEditor.PrefabUtility.RevertPropertyOverride(property_strandGroupChecksums, UnityEditor.InteractionMode.AutomatedAction);
					UnityEditor.PrefabUtility.RevertPropertyOverride(property_strandGroupDefaults.FindPropertyRelative(nameof(GroupSettings.settingsSkinning)), UnityEditor.InteractionMode.AutomatedAction);

					for (int i = 0; i != property_strandGroupSettings.arraySize; i++)
					{
						UnityEditor.PrefabUtility.RevertPropertyOverride(property_strandGroupSettings.GetArrayElementAtIndex(i).FindPropertyRelative(nameof(GroupSettings.settingsSkinning)), UnityEditor.InteractionMode.AutomatedAction);
					}
				}

				// handle content changes in underlying prefab
				Debug.Log(string.Format("{0} ({1}): rebuilding governing prefab...", this.GetType().Name, this.name), this);

				PrefabContentsUtility.UpdateUnderlyingPrefabContents(this, verbose: false, (GameObject prefabContentsRoot) =>
				{
					foreach (var prefabHairInstance in prefabContentsRoot.GetComponentsInChildren<HairInstance>(includeInactive: true))
					{
						prefabHairInstance.UpdateStrandGroupInstances();
					}
				});
			}
			else
#endif
			{
				// handle content changes
				switch (status)
				{
					case StrandGroupInstancesStatus.RequireRebuild:
						HairInstanceBuilder.BuildHairInstance(this, strandGroupProviders, HideFlags.NotEditable);
						break;

					case StrandGroupInstancesStatus.RequireRelease:
						HairInstanceBuilder.ClearHairInstance(this);
						break;
				}
			}

			// release runtime data
			ReleaseRuntimeData();
		}

		void UpdateStrandGroupHideFlags(HideFlags hideFlags = HideFlags.NotEditable)
		{
			if (strandGroupInstances == null)
				return;

			for (int i = 0; i != strandGroupInstances.Length; i++)
			{
				ref readonly var strandGroupInstance = ref strandGroupInstances[i];

				strandGroupInstance.sceneObjects.groupContainer.hideFlags = hideFlags;
				strandGroupInstance.sceneObjects.rootMeshContainer.hideFlags = hideFlags;
				strandGroupInstance.sceneObjects.strandMeshContainer.hideFlags = hideFlags;
			}
		}
		#endregion

		#region Update Group Settings
		void UpdateStrandGroupSettings()
		{
			if (strandGroupInstances == null)
				return;

			for (int i = 0; i != strandGroupInstances.Length; i++)
			{
				strandGroupInstances[i].settingsIndex = -1;
			}

			if (strandGroupSettings == null)
				return;

			// remove duplicate references (meaning only one settings block can affect instances of a particular group asset)
			{
				var groupAssetKeyCapacity = 0;
				{
					for (int i = 0; i != strandGroupSettings.Length; i++)
					{
						groupAssetKeyCapacity += strandGroupSettings[i].groupAssetReferences.Count;
					}
				}

#if HAS_PACKAGE_UNITY_COLLECTIONS_1_3_0
				using (var groupAssetKeys = new UnsafeParallelHashSet<ulong>(groupAssetKeyCapacity, Allocator.Temp))
#else
				using (var groupAssetKeys = new UnsafeHashSet<ulong>(groupAssetKeyCapacity, Allocator.Temp))
#endif
				{
					for (int i = 0; i != strandGroupSettings.Length; i++)
					{
						var groupAssetReferences = strandGroupSettings[i].groupAssetReferences;

						for (int j = groupAssetReferences.Count - 1; j >= 0; j--)
						{
							var groupAssetKey = groupAssetReferences[j].GetSortKey();
							if (groupAssetKeys.Contains(groupAssetKey) == false)
							{
								groupAssetKeys.Add(groupAssetKey);
							}
							else
							{
								groupAssetReferences.RemoveAtSwapBack(j);
							}
						}
					}
				}
			}

			// map settings to group instances
#if true
#if HAS_PACKAGE_UNITY_COLLECTIONS_1_3_0 && !HAS_PACKAGE_UNITY_COLLECTIONS_2_0_0_UNTIL_2_1_0_EXP_4
			using (var groupAssetInstancesMap = new UnsafeParallelMultiHashMap<ulong, int>(strandGroupInstances.Length, Allocator.Temp))
#else
			using (var groupAssetInstancesMap = new UnsafeMultiHashMap<ulong, int>(strandGroupInstances.Length, Allocator.Temp))
#endif
			{
				for (int i = 0; i != strandGroupInstances.Length; i++)
				{
					groupAssetInstancesMap.Add(strandGroupInstances[i].groupAssetReference.GetSortKey(), i);
				}

				for (int i = 0; i != strandGroupSettings.Length; i++)
				{
					foreach (var groupAssetReference in strandGroupSettings[i].groupAssetReferences)
					{
						var groupAssetKey = groupAssetReference.GetSortKey();
						if (groupAssetInstancesMap.TryGetFirstValue(groupAssetKey, out var j, out var iterator))
						{
							do { strandGroupInstances[j].settingsIndex = i; }
							while (groupAssetInstancesMap.TryGetNextValue(out j, ref iterator));
						}
					}
				}
			}
#else// alt. path without multihashmap
			unsafe
			{
				using (var sortedGroupInstances = new NativeArray<ulong>(strandGroupInstances.Length, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
				{
					var sortedGroupInstancesPtr = (ulong*)sortedGroupInstances.GetUnsafePtr();

					for (int i = 0; i != strandGroupInstances.Length; i++)
					{
						var groupAssetKey = (strandGroupInstances[i].groupAssetReference.GetSortKey48() << 16);
						{
							sortedGroupInstancesPtr[i] = groupAssetKey | ((ulong)i & 0xffffuL);
						}
					}

					sortedGroupInstances.Sort();

					for (int i = 0; i != strandGroupSettings.Length; i++)
					{
						foreach (var groupAssetReference in strandGroupSettings[i].groupAssetReferences)
						{
							var groupAssetKey = groupAssetReference.GetSortKey48() << 16;
							var groupAssetMask = (~0uL) << 16;

							var j = sortedGroupInstances.BinarySearch(groupAssetKey);
							if (j < 0)
								j = ~j;

							while (j < sortedGroupInstances.Length)
							{
								if ((sortedGroupInstancesPtr[j] & groupAssetMask) != groupAssetKey)
									break;

								strandGroupInstances[sortedGroupInstancesPtr[j++] & 0xffffuL].settingsIndex = i;
							}
						}
					}
				}
			}
#endif
		}

		public void AssignStrandGroupSettings(int settingsIndex, int instanceIndex)
		{
			if (strandGroupSettings == null || strandGroupSettings.Length <= settingsIndex)
				return;
			if (strandGroupInstances == null || strandGroupInstances.Length <= instanceIndex)
				return;

			ref var groupInstance = ref strandGroupInstances[instanceIndex];
			ref var groupAssetReference = ref groupInstance.groupAssetReference;

			var prevSettingsIndex = groupInstance.settingsIndex;
			if (prevSettingsIndex >= 0 && prevSettingsIndex < strandGroupSettings.Length)
			{
				strandGroupSettings[prevSettingsIndex].groupAssetReferences.Remove(groupAssetReference);
			}

			groupInstance.settingsIndex = -1;

			if (settingsIndex >= 0)
			{
				strandGroupSettings[settingsIndex].groupAssetReferences.Add(groupAssetReference);
				groupInstance.settingsIndex = settingsIndex;
			}

			UpdateStrandGroupSettings();
		}
		#endregion

		#region Update Attached State
		void UpdateAttachedState()
		{
			if (strandGroupInstances == null)
				return;

#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN
#if UNITY_EDITOR
			var isPrefabInstance = UnityEditor.PrefabUtility.IsPartOfPrefabInstance(this);
			if (isPrefabInstance)
				return;
#endif

			using (var attachmentsChangedMask = new UnsafeBitArray(1 + (strandGroupSettings?.Length ?? 0), Allocator.Temp, NativeArrayOptions.ClearMemory))
			{
				for (int i = 0; i != strandGroupInstances.Length; i++)
				{
					ref readonly var strandGroupInstance = ref strandGroupInstances[i];
					ref readonly var settingsSkinning = ref GetSettingsSkinning(strandGroupInstance);

					var attachment = strandGroupInstance.sceneObjects.rootMeshAttachment;
					if (attachment == null)
					{
						var container = strandGroupInstance.sceneObjects.rootMeshContainer;
						if (container != null && container.TryGetComponent(out attachment) == false)
						{
							attachment = strandGroupInstances[i].sceneObjects.rootMeshAttachment = HairInstanceBuilder.CreateComponent<SkinAttachment>(container, container.hideFlags);
							attachment.attachmentType = SkinAttachment.AttachmentType.Mesh;
							attachment.forceRecalculateBounds = true;
						}
					}

					if (attachment != null && (attachment.target != settingsSkinning.rootsAttachTarget || attachment.attached != settingsSkinning.rootsAttach))
					{
						attachment.target = settingsSkinning.rootsAttachTarget;

						if (attachment.target != null && settingsSkinning.rootsAttach)
						{
							attachment.Attach(storePositionRotation: false);
						}
						else
						{
							attachment.Detach(revertPositionRotation: false);
							attachment.checksum0 = 0;
							attachment.checksum1 = 0;
						}

						// default settings (settingsIndex -1) sets bit 0, and so forth
						attachmentsChangedMask.Set(strandGroupInstance.settingsIndex + 1, true);
					}
				}

				static void CommitAttachments(ref SettingsSkinning settingsSkinning)
				{
					if (settingsSkinning.rootsAttachTarget != null)
					{
						settingsSkinning.rootsAttachTarget.CommitSubjectsIfRequired();
						settingsSkinning.rootsAttachTargetBone = new PrimarySkinningBone(settingsSkinning.rootsAttachTarget.transform);
#if UNITY_EDITOR
						UnityEditor.EditorUtility.SetDirty(settingsSkinning.rootsAttachTarget);
#endif
					}
				}

				for (int i = 0; i != attachmentsChangedMask.Length; i++)
				{
					if (attachmentsChangedMask.IsSet(i))
					{
						if (i == 0)
							CommitAttachments(ref strandGroupDefaults.settingsSkinning);
						else
							CommitAttachments(ref strandGroupSettings[i - 1].settingsSkinning);
					}
				}
			}
#endif
		}
		#endregion

		#region Update Prerequisite
#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN_0_2_0_PREVIEW
		private HashSet<SkinAttachmentTarget> preqGPUAttachmentTargets = new HashSet<SkinAttachmentTarget>();
		private Hash128 preqGPUAttachmentTargetsHash = new Hash128();
#endif
		private int preqCountdown = 1;

		void UpdatePrerequisite()
		{
#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN_0_2_0_PREVIEW
			var hash = new Hash128();
			{
				if (strandGroupInstances != null)
				{
					for (int i = 0; i != strandGroupInstances.Length; i++)
					{
						ref readonly var settingsSkinning = ref GetSettingsSkinning(strandGroupInstances[i]);
						if (settingsSkinning.rootsAttach)
						{
							var attachmentTarget = settingsSkinning.rootsAttachTarget;
							if (attachmentTarget != null && attachmentTarget.isActiveAndEnabled && attachmentTarget.executeOnGPU)
							{
								hash.Append(attachmentTarget.GetInstanceID());
							}
						}
					}
				}
			}

			if (hash != preqGPUAttachmentTargetsHash)
			{
				ReleasePrerequisite();

				if (strandGroupInstances != null)
				{
					for (int i = 0; i != strandGroupInstances.Length; i++)
					{
						ref readonly var settingsSkinning = ref GetSettingsSkinning(strandGroupInstances[i]);
						if (settingsSkinning.rootsAttach)
						{
							var attachmentTarget = settingsSkinning.rootsAttachTarget;
							if (attachmentTarget != null && attachmentTarget.isActiveAndEnabled && attachmentTarget.executeOnGPU)
							{
								preqGPUAttachmentTargets.Add(attachmentTarget);
							}
						}
					}
				}

				foreach (var preq in preqGPUAttachmentTargets)
				{
					preq.afterGPUAttachmentWorkCommitted += HandlePrerequisite;
				}

				preqGPUAttachmentTargetsHash = hash;
			}

			preqCountdown = 1 + preqGPUAttachmentTargets.Count;
#else
			preqCountdown = 1;
#endif
		}

		void ReleasePrerequisite()
		{
#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN_0_2_0_PREVIEW
			foreach (var preq in preqGPUAttachmentTargets)
			{
				preq.afterGPUAttachmentWorkCommitted -= HandlePrerequisite;
			}

			preqGPUAttachmentTargets.Clear();
			preqGPUAttachmentTargetsHash = new Hash128();
#endif
		}

		void HandlePrerequisite()
		{
			if (--preqCountdown == 0)
			{
				DispatchUpdate();
			}
		}
		#endregion

		public ExecutiveStep UpdateExecutiveState(float dt)
		{
			var stepDesc = new ExecutiveStep();
			{
				stepDesc.countRaw = 0;
				stepDesc.count = 0;
				stepDesc.dt = 0.0f;
				stepDesc.hi = 1.0f;
			}

			if (GetSimulationActive())
			{
				var simulationTimeStep = GetSimulationTimeStep();
				if (simulationTimeStep > 0.0f)
				{
					execState.accumulatedTime += dt;

					var accumulatedStepCount = Mathf.FloorToInt(execState.accumulatedTime / simulationTimeStep);
					{
						var minStepCount = settingsExecutive.updateStepsMin ? settingsExecutive.updateStepsMinValue : accumulatedStepCount;
						var maxStepCount = settingsExecutive.updateStepsMax ? settingsExecutive.updateStepsMaxValue : accumulatedStepCount;

						stepDesc.countRaw = accumulatedStepCount;
						stepDesc.count = Mathf.Clamp(accumulatedStepCount, minStepCount, maxStepCount);
						stepDesc.dt = simulationTimeStep;

						// method A: align per-frame data with simulation time steps
						//
						//           accu + accu = a
						//      .---------.--------------.
						//      :         :              :
						// F----X---------F--------------F - - -
						//      :
						//      : dt   dt   dt
						//      O----S----S----X---------|
						//      :              :         :
						//      '--------------'---------'
						//          (dt * n)   :    b
						//                     :
						//                     '- blend fraction
						{
							//TODO put this to use pending changes to root interpolation and staging resolve
							stepDesc.hi = (simulationTimeStep * accumulatedStepCount) / execState.accumulatedTime;
						}
					}

					execState.accumulatedTime -= simulationTimeStep * accumulatedStepCount;
				}

				execState.elapsedTimeRaw += dt;
				execState.elapsedTime += stepDesc.dt * stepDesc.count;

				if (execState.pausePostStep && stepDesc.count > 0)
				{
					execState.pausePostStep = false;

					//TODO separate editor player state from settings?
					settingsExecutive.updateSimulation = false;
				}
			}
			else
			{
				if (execState.pausePostStep)
				{
					execState.pausePostStep = false;
				}
			}

			//timeState.stepHistory.Enqueue(stepDesc);

			execState.lastStepCount = stepDesc.count;
			execState.lastStepCountRaw = stepDesc.countRaw;
			execState.lastStepCountSmooth = Mathf.Lerp(execState.lastStepCountSmooth, stepDesc.count, 1.0f - Mathf.Pow(0.01f, dt / 0.2f));

			return stepDesc;
		}

		void UpdateSystemState(CommandBuffer cmd, CommandBufferExecutionFlags cmdFlags, in ExecutiveStep stepDesc)
		{
			for (int i = 0; i != solverData.Length; i++)
			{
				var rootMesh = strandGroupInstances[i].sceneObjects.rootMeshFilter.sharedMesh;
				var rootMeshMatrix = strandGroupInstances[i].sceneObjects.rootMeshFilter.transform.localToWorldMatrix;
				var rootMeshSkinningRotation = GetRootMeshSkinningRotation(strandGroupInstances[i], GetSettingsSkinning(strandGroupInstances[i]));

				HairSim.PushSolverRoots(cmd, cmdFlags, ref solverData[i], rootMesh, rootMeshMatrix, rootMeshSkinningRotation, stepDesc.count);
			}

			for (int i = 0; i != solverData.Length; i++)
			{
				HairSim.PushSolverGeometry(cmd, ref solverData[i], GetSettingsGeometry(strandGroupInstances[i]), this.transform.localToWorldMatrix);
			}

			HairSim.PushVolumeObservers(cmd, ref volumeData, CameraType.Game | CameraType.SceneView);
			HairSim.PushVolumeGeometry(cmd, ref volumeData, solverData);
			HairSim.PushVolumeBounds(cmd, ref volumeData, solverData);

			for (int i = 0; i != solverData.Length; i++)
			{
				HairSim.PushSolverLOD(cmd, ref solverData[i], GetSettingsPhysics(strandGroupInstances[i]), GetSettingsRendering(strandGroupInstances[i]), volumeData, stepDesc.count);
			}

			HairSim.PushVolumeLOD(cmd, ref volumeData, settingsVolumetrics);
			HairSim.PushVolumeEnvironment(cmd, ref volumeData, settingsEnvironment, stepDesc.count, 1.0f);//stepDesc.hi);
			HairSim.PushVolumeStepBegin(cmd, ref volumeData, settingsVolumetrics, stepDesc.dt);
			{
				//var frameTimeLo = execState.elapsedTime - stepDesc.count * stepDesc.dt;
				//var frameTimeHi = execState.elapsedTime;

				if (stepDesc.count >= 1)
				{
					var stepVolumePre = HairSim.PrepareVolumeData(ref volumeData, settingsVolumetrics, solverData.Length + 1);
					if (stepVolumePre)
					{
						var stepFracLo = 0.0f;
						var stepFracHi = 1.0f / (float)stepDesc.count;
						var stepTimeHi = execState.elapsedTime - stepDesc.dt * (stepDesc.count - 1);

						HairSim.PushVolumeStep(cmd, cmdFlags, ref volumeData, settingsVolumetrics, solverData, stepFracLo, stepFracHi, stepTimeHi);
					}

					for (int i = 0; i != solverData.Length; i++)
					{
						HairSim.PushSolverStepBegin(cmd, ref solverData[i], GetSettingsPhysics(strandGroupInstances[i]), stepDesc.dt);
					}

					for (int k = 0; k != stepDesc.count; k++)
					{
						var stepFracLo = (k + 0) / (float)stepDesc.count;
						var stepFracHi = (k + 1) / (float)stepDesc.count;
						var stepTimeHi = execState.elapsedTime - stepDesc.dt * (stepDesc.count - 1 - k);

						for (int i = 0; i != solverData.Length; i++)
						{
							HairSim.PushSolverStep(cmd, ref solverData[i], GetSettingsPhysics(strandGroupInstances[i]), volumeData, stepFracLo, stepFracHi, stepFinal: k == stepDesc.count - 1);
						}

						HairSim.PushVolumeStep(cmd, cmdFlags, ref volumeData, settingsVolumetrics, solverData, stepFracLo, stepFracHi, stepTimeHi);

						if (onSimulationStateChanged != null)
							onSimulationStateChanged(cmd);
					}

					for (int i = 0; i != solverData.Length; i++)
					{
						HairSim.PushSolverStepEnd(cmd, solverData[i], volumeData);
					}
				}
			}
			HairSim.PushVolumeStepEnd(cmd, volumeData, settingsVolumetrics);

			for (int i = 0; i != solverData.Length; i++)
			{
				HairSim.PushSolverStaging(cmd, ref solverData[i], GetSettingsGeometry(strandGroupInstances[i]), GetSettingsRendering(strandGroupInstances[i]), volumeData);
			}

			if (onRenderingStateChanged != null)
				onRenderingStateChanged(cmd);
		}

		void UpdateSceneState(CommandBuffer cmd)
		{
			for (int i = 0; i != strandGroupInstances.Length; i++)
			{
				UpdateRendererState(cmd, ref strandGroupInstances[i], solverData[i]);
			}
		}

		void UpdateRendererState(CommandBuffer cmd, ref GroupInstance strandGroupInstance, in HairSim.SolverData solverData)
		{
			ref readonly var settingsRendering = ref GetSettingsRendering(strandGroupInstance);

			#region GetRenderTopologyType(..)
			static HairTopologyType GetRenderTopologyType(HairSim.SettingsRendering.Renderer renderer)
			{
				switch (renderer)
				{
					default:
						return HairTopologyType.Lines;
					case HairSim.SettingsRendering.Renderer.BuiltinStrips:
						return HairTopologyType.Strips;
					case HairSim.SettingsRendering.Renderer.BuiltinTubes:
						return HairTopologyType.Tubes;
				}
			}
			#endregion

			#region GetShadowTopologyType(..)
			static HairTopologyType GetShadowTopologyType(HairSim.SettingsRendering.ShadowSubstitute shadowSubstitute)
			{
				switch (shadowSubstitute)
				{
					default:
						return HairTopologyType.Lines;
					case HairSim.SettingsRendering.ShadowSubstitute.BuiltinStrips:
						return HairTopologyType.Strips;
					case HairSim.SettingsRendering.ShadowSubstitute.BuiltinTubes:
						return HairTopologyType.Tubes;
				}
			}
			#endregion

			#region GetTopologyMesh(..)
#if !UNITY_2021_2_OR_NEWER
			static Mesh GetTopologyMesh(in HairSim.SolverData solverData, HairTopologyType meshType, bool gpuInstancing, ref Mesh meshInstance, ref ulong meshInstanceKey)
#else
			static Mesh GetTopologyMesh(in HairSim.SolverData solverData, HairTopologyType meshType, bool gpuInstancing)
#endif
			{
				var meshDesc = new HairTopologyDesc
				{
					type = meshType,
					strandCount = Mathf.Min((int)solverData.constants._StrandCount, gpuInstancing ? HairSim.Conf.INSTANCING_BATCH_SIZE : (int)solverData.constants._StrandCount),
					strandParticleCount = (int)solverData.constants._StagingStrandVertexCount,
					memoryLayout = solverData.memoryLayout,
				};

#if !UNITY_2021_2_OR_NEWER
				// if possible, keep current instance and do not touch topology cache (allow shared mesh to deallocate)
				var meshKey = HairTopologyCache.GetSortKey(meshDesc);
				if (meshKey != meshInstanceKey || meshInstance == null)
				{
					CoreUtils.Destroy(meshInstance);
						
					meshInstance = HairInstanceBuilder.CreateMeshInstance(HairTopologyCache.GetSharedMesh(meshDesc), HideFlags.HideAndDontSave);
					meshInstanceKey = meshKey;
				}

				return meshInstance;
#else
				return HairTopologyCache.GetSharedMesh(meshDesc);
#endif
			}
			#endregion

			#region GetTopologyMaterial(..)
			static Material GetTopologyMaterial(in HairSim.SolverData solverData, in HairSim.VolumeData volumeData, Mesh mesh, HairTopologyType meshType, bool gpuInstancing, Material materialAsset, ref Material materialInstance)
			{
				if (materialAsset != null && materialAsset.shader != null)
				{
					if (materialInstance == null)
					{
						materialInstance = new Material(materialAsset.shader);
						materialInstance.hideFlags = HideFlags.HideAndDontSave;
						materialInstance.name = materialAsset.name + "(Instance)";
					}
					else
					{
						if (materialInstance.shader != materialAsset.shader)
						{
							materialInstance.shader = materialAsset.shader;
							materialInstance.name = materialAsset.name + "(Instance)";
						}
					}

					materialInstance.CopyPropertiesFromMaterial(materialAsset);
					materialInstance.EnableKeyword("HAIR_VERTEX_LIVE");
				}

				if (materialInstance != null)
				{
					UpdateMaterialState(materialInstance, solverData, volumeData, mesh, meshType);

#if UNITY_EDITOR
					var materialInstancePendingPasses = HairMaterialUtility.TryCompileCountPassesPending(materialInstance);
					if (materialInstancePendingPasses > 0)
					{
						materialInstance.shader = HairMaterialUtility.GetReplacementShader(HairMaterialUtility.ReplacementType.Async);
						UpdateMaterialState(materialInstance, solverData, volumeData, mesh, meshType);
					}
#endif
				}

				return materialInstance;
			}
			#endregion

			// prepare settings
			var layerMask = settingsRendering.rendererLayers;
			var layerMaskShadows = settingsRendering.shadowLayers ? settingsRendering.shadowLayersValue : layerMask;

			var meshType = GetRenderTopologyType(settingsRendering.renderer);
			var meshTypeShadows = settingsRendering.shadowSubstitute ? GetShadowTopologyType(settingsRendering.shadowSubstituteValue) : meshType;

			// prepare conditionals
			var needRenderer = false;
			var needRendererShadows = false;

			var needResources = false;
			var needResourcesShadows = false;
			{
				if (settingsRendering.renderer != HairSim.SettingsRendering.Renderer.Disabled)
				{
					var sameShadowLayer = (layerMask == layerMaskShadows);
					var sameShadowMesh = (meshType == meshTypeShadows);
					var sameShadow = sameShadowLayer && sameShadowMesh;

					if (sameShadow == true || settingsRendering.rendererShadows != ShadowCastingMode.ShadowsOnly)
					{
						needRenderer = true;
						needResources = true;
					}

					if (sameShadow == false && settingsRendering.rendererShadows != ShadowCastingMode.Off)
					{
						needRendererShadows = true;
						needResourcesShadows = (sameShadowMesh == false) || (needResources == false);
					}
				}
			}

			// prepare instancing
			var supportIndirect = false;
			{
#pragma warning disable CS0219
#if UNITY_EDITOR
				const bool false_if_UNITY_EDITOR = false;
#else
				const bool false_if_UNITY_EDITOR = true;
#endif
#pragma warning restore CS0219

				// indirect feature table
				//
				//	N = NO
				//	y = yes, partially (no picking)
				//	Y = YES
				//
				//			BRP/20	BRP/22	BRP/23	SRP/20	SRP/22	SRP/23
				//	-1		y		y		Y		y		y		Y
				//	mask	y		y		Y		N		y		Y

#if UNITY_2023_2_OR_NEWER
				// supports indirect w/ layer mask + picking
				supportIndirect = true;
#elif UNITY_2021_2_OR_NEWER
				// supports indirect w/ layer mask
				supportIndirect = false_if_UNITY_EDITOR;
#else
				// supports indirect
				supportIndirect = false_if_UNITY_EDITOR && ((RenderPipelineManager.currentPipeline == null) || (layerMask == GraphicsSettings.defaultRenderingLayerMask));
#endif
			}

			var enableIndirect = settingsRendering.allowIndirect && supportIndirect && (settingsRendering.renderer != HairSim.SettingsRendering.Renderer.HDRPHighQualityLines);
			var enableIndirectShadows = settingsRendering.allowIndirect && supportIndirect;
			var enableInstancing = settingsRendering.allowInstancing && enableIndirect;
			var enableInstancingShadows = settingsRendering.allowInstancing && enableIndirectShadows;
#if ENABLE_VR && ENABLE_VR_MODULE
			var enableStereoInstancing = (XRSettings.stereoRenderingMode == XRSettings.StereoRenderingMode.SinglePassInstanced);
#else
			var enableStereoInstancing = false;
#endif

			var topologyIndex = (int)meshType + (enableInstancing ? 3 : 0) + (enableStereoInstancing ? 6 : 0);
			var topologyIndexShadows = (int)meshTypeShadows + (enableInstancingShadows ? 3 : 0);

			// prepare resources
			var mesh = null as Mesh;
			var meshShadows = null as Mesh;

			var materialAsset = GetMaterial(strandGroupInstance);
			var materialInstance = null as Material;
			var materialInstanceShadows = null as Material;
			{
				if (needResources)
				{
#if !UNITY_2021_2_OR_NEWER
					mesh = GetTopologyMesh(solverData, meshType, enableInstancing,
						ref strandGroupInstance.sceneObjects.meshInstance,
						ref strandGroupInstance.sceneObjects.meshInstanceKey);
#else
					mesh = GetTopologyMesh(solverData, meshType, enableInstancing);
#endif
					materialInstance = GetTopologyMaterial(solverData, volumeData, mesh, meshType, enableInstancing, materialAsset, ref strandGroupInstance.sceneObjects.materialInstance);
				}

				if (needResourcesShadows)
				{
#if !UNITY_2021_2_OR_NEWER
					meshShadows = GetTopologyMesh(solverData, meshTypeShadows, enableInstancingShadows,
						ref strandGroupInstance.sceneObjects.meshInstanceShadows,
						ref strandGroupInstance.sceneObjects.meshInstanceKeyShadows);
#else
					meshShadows = GetTopologyMesh(solverData, meshTypeShadows, enableInstancingShadows);
#endif
					materialInstanceShadows = GetTopologyMaterial(solverData, volumeData, meshShadows, meshTypeShadows, enableInstancingShadows, materialAsset, ref strandGroupInstance.sceneObjects.materialInstanceShadows);
				}
				else
				{
					meshShadows = mesh;
					materialInstanceShadows = materialInstance;
				}
			}

			// update mesh filter
			ref var meshFilter = ref strandGroupInstance.sceneObjects.strandMeshFilter;
			{
				if (meshFilter.sharedMesh != mesh)
					meshFilter.sharedMesh = mesh;
			}

			// update mesh renderer
			ref var meshRenderer = ref strandGroupInstance.sceneObjects.strandMeshRenderer;
			{
				meshRenderer.enabled = needRenderer;
				meshRenderer.sharedMaterial = materialInstance;
				meshRenderer.shadowCastingMode = needRendererShadows ? ShadowCastingMode.Off : settingsRendering.rendererShadows;
				meshRenderer.renderingLayerMask = (uint)layerMask;
				meshRenderer.motionVectorGenerationMode = settingsRendering.motionVectors;

				if (meshRenderer.rayTracingMode != UnityEngine.Experimental.Rendering.RayTracingMode.Off && SystemInfo.supportsRayTracing)
					meshRenderer.rayTracingMode = UnityEngine.Experimental.Rendering.RayTracingMode.Off;
			}

#if HAS_PACKAGE_UNITY_HDRP_15_0_2
			ref var meshRendererHDRP = ref strandGroupInstance.sceneObjects.strandMeshRendererHDRP;
			{
				if (meshRendererHDRP == null)
				{
					var container = strandGroupInstance.sceneObjects.strandMeshContainer;
					if (container != null && container.TryGetComponent(out meshRendererHDRP) == false)
					{
						meshRendererHDRP = strandGroupInstance.sceneObjects.strandMeshRendererHDRP = HairInstanceBuilder.CreateComponent<HDAdditionalMeshRendererSettings>(container, container.hideFlags);
					}
				}

				meshRendererHDRP.enabled = needRenderer && (settingsRendering.rendererShadows != ShadowCastingMode.ShadowsOnly);
				meshRendererHDRP.rendererGroup = settingsRendering.rendererGroup;
				meshRendererHDRP.enableHighQualityLineRendering = (settingsRendering.renderer == HairSim.SettingsRendering.Renderer.HDRPHighQualityLines);
			}
#endif

			// update mesh bounds
			{
#if !UNITY_2021_2_OR_NEWER
				// prior to 2021.2 it was only possible to set renderer bounds indirectly via mesh bounds
				if (mesh != null)
					mesh.bounds = HairSim.GetSolverBounds(solverData, volumeData).WithTransform(meshFilter.transform.worldToLocalMatrix);
#else
				// starting with 2021.2 we can override renderer bounds directly
				meshRenderer.localBounds = HairSim.GetSolverBounds(solverData, volumeData).WithTransform(meshFilter.transform.worldToLocalMatrix);

				//TODO the world space bounds override is failing in some cases -- figure out why?
				//meshRenderer.bounds = HairSim.GetSolverBounds(solverData, volumeData);
#endif
			}

			// render (optional depending on configuration)
			if (needRenderer)
			{
				if (enableIndirect)
				{
					meshRenderer.enabled = false;

#if HAS_PACKAGE_UNITY_HDRP_15_0_2
					if (meshRendererHDRP != null)
						meshRendererHDRP.enabled = false;
#endif

#if !UNITY_2021_2_OR_NEWER
					Graphics.DrawMeshInstancedIndirect(
						mesh,
						submeshIndex: 0,
						materialInstance,
						HairSim.GetSolverBounds(solverData, volumeData),
						solverData.buffers._SolverLODTopology,
						argsOffset: (int)HairSim.GetSolverLODTopologyOffset((HairSim.SolverLODTopology)topologyIndex),
						properties: null,
						meshRenderer.shadowCastingMode);
#else
					var rparams = new RenderParams(materialInstance);
					{
						/* defaults since 2023.2:

						rparams.layer = 0;
						rparams.renderingLayerMask = GraphicsSettings.defaultRenderingLayerMask;
						rparams.rendererPriority = 0;
						rparams.worldBounds = new Bounds(Vector3.zero, Vector3.zero);
						rparams.camera = null;
						rparams.motionVectorMode = MotionVectorGenerationMode.Camera;
						rparams.reflectionProbeUsage = ReflectionProbeUsage.Off;
						rparams.material = mat;
						rparams.matProps = null;
						rparams.shadowCastingMode = ShadowCastingMode.Off;
						rparams.receiveShadows = false;
						rparams.lightProbeUsage = LightProbeUsage.Off;
						rparams.lightProbeProxyVolume = null;
						rparams.overrideSceneCullingMask = false;
						rparams.sceneCullingMask = 0uL;
						rparams.instanceID = 0;

						*/

						rparams.renderingLayerMask = (uint)meshRenderer.renderingLayerMask;
						rparams.worldBounds = HairSim.GetSolverBounds(solverData, volumeData);
						rparams.motionVectorMode = meshRenderer.motionVectorGenerationMode;
						rparams.shadowCastingMode = meshRenderer.shadowCastingMode;
						rparams.receiveShadows = true;
#if UNITY_2023_2_OR_NEWER
						rparams.instanceID = this.GetInstanceID();
#endif
					}

					Graphics.RenderMeshIndirect(rparams, mesh, solverData.buffers._SolverLODTopology, 1, topologyIndex);
#endif
				}
			}

			// render separate shadows (optional depending on configuration)
			if (needRendererShadows)
			{
#if !UNITY_2021_2_OR_NEWER
				if (enableIndirectShadows)
				{
					Graphics.DrawMeshInstancedIndirect(
						meshShadows,
						submeshIndex: 0,
						materialInstanceShadows,
						HairSim.GetSolverBounds(solverData, volumeData),
						solverData.buffers._SolverLODTopology,
						argsOffset: (int)HairSim.GetSolverLODTopologyOffset((HairSim.SolverLODTopology)topologyIndexShadows),
						properties: null,
						ShadowCastingMode.ShadowsOnly);
				}
				else
				{
					if (meshShadows != null)
						meshShadows.bounds = HairSim.GetSolverBounds(solverData, volumeData).WithTransform(meshFilter.transform.worldToLocalMatrix);

					Graphics.DrawMesh(meshShadows, Matrix4x4.identity, materialInstanceShadows, 0, null, 0, null, ShadowCastingMode.ShadowsOnly);
				}
#else
				var rparams = new RenderParams(materialInstanceShadows);
				{
					/* defaults since 2023.2:

					rparams.layer = 0;
					rparams.renderingLayerMask = GraphicsSettings.defaultRenderingLayerMask;
					rparams.rendererPriority = 0;
					rparams.worldBounds = new Bounds(Vector3.zero, Vector3.zero);
					rparams.camera = null;
					rparams.motionVectorMode = MotionVectorGenerationMode.Camera;
					rparams.reflectionProbeUsage = ReflectionProbeUsage.Off;
					rparams.material = mat;
					rparams.matProps = null;
					rparams.shadowCastingMode = ShadowCastingMode.Off;
					rparams.receiveShadows = false;
					rparams.lightProbeUsage = LightProbeUsage.Off;
					rparams.lightProbeProxyVolume = null;
					rparams.overrideSceneCullingMask = false;
					rparams.sceneCullingMask = 0uL;
					rparams.instanceID = 0;

					*/

					rparams.renderingLayerMask = (uint)layerMaskShadows;
					rparams.worldBounds = HairSim.GetSolverBounds(solverData, volumeData);
					rparams.shadowCastingMode = ShadowCastingMode.ShadowsOnly;
				}

				if (enableIndirectShadows)
				{
					Graphics.RenderMeshIndirect(rparams, meshShadows, solverData.buffers._SolverLODTopology, 1, topologyIndexShadows);
				}
				else
				{
					Graphics.RenderMesh(rparams, meshShadows, 0, Matrix4x4.identity);
				}
#endif
			}
		}

		static void UpdateMaterialState(Material materialInstance, in HairSim.SolverData solverData, in HairSim.VolumeData volumeData, Mesh mesh, HairTopologyType meshType)
		{
			HairSim.BindSolverData(materialInstance, solverData);
			HairSim.BindVolumeData(materialInstance, volumeData);

			switch (meshType)
			{
				case HairTopologyType.Lines:
					materialInstance.SetInt("_DecodeVertexCount", 1);
					materialInstance.SetInt("_DecodeVertexWidth", 0);
					break;

				case HairTopologyType.Strips:
					materialInstance.SetInt("_DecodeVertexCount", 2);
					materialInstance.SetInt("_DecodeVertexWidth", 1);
					break;

				case HairTopologyType.Tubes:
					materialInstance.SetInt("_DecodeVertexCount", 4);
					materialInstance.SetInt("_DecodeVertexWidth", 2);
					break;
			}

			if (mesh != null)
			{
				switch (mesh.GetVertexAttributeFormat(VertexAttribute.TexCoord0))
				{
					case VertexAttributeFormat.UNorm16:
						materialInstance.SetInt("_DecodeVertexComponentValue", ushort.MaxValue);
						materialInstance.SetInt("_DecodeVertexComponentWidth", 16);
						break;

					case VertexAttributeFormat.UNorm8:
						materialInstance.SetInt("_DecodeVertexComponentValue", byte.MaxValue);
						materialInstance.SetInt("_DecodeVertexComponentWidth", 8);
						break;
				}
			}

			materialInstance.SetTexture("_UntypedVolumeDensity", volumeData.textures._VolumeDensity);
			materialInstance.SetTexture("_UntypedVolumeVelocity", volumeData.textures._VolumeVelocity);
			materialInstance.SetTexture("_UntypedVolumeScattering", volumeData.textures._VolumeScattering);
		}

		public bool GetSimulationActive()
		{
			return settingsExecutive.updateSimulation && (settingsExecutive.updateSimulationInEditor || Application.isPlaying);
		}

		public float GetSimulationTimeStep()
		{
			switch (settingsExecutive.updateSimulationRate)
			{
				case SettingsExecutive.UpdateRate.Fixed30Hz: return 1.0f / 30.0f;
				case SettingsExecutive.UpdateRate.Fixed60Hz: return 1.0f / 60.0f;
				case SettingsExecutive.UpdateRate.Fixed90Hz: return 1.0f / 90.0f;
				case SettingsExecutive.UpdateRate.Fixed120Hz: return 1.0f / 120.0f;
				case SettingsExecutive.UpdateRate.CustomTimeStep: return Mathf.Max(0.0f, settingsExecutive.updateTimeStep);
				default: return 0.0f;
			}
		}

		public static Bounds GetRootMeshBounds(in GroupInstance strandGroupInstance)
		{
			var rootLocalBounds = strandGroupInstance.sceneObjects.rootMeshFilter.sharedMesh.bounds;
			var rootLocalToWorld = strandGroupInstance.sceneObjects.rootMeshFilter.transform.localToWorldMatrix;
			{
				return rootLocalBounds.WithTransform(rootLocalToWorld);
			}
		}

		public static Quaternion GetRootMeshSkinningRotation(in GroupInstance strandGroupInstance, in SettingsSkinning settingsSkinning)
		{
#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN
			if (settingsSkinning.rootsAttach && settingsSkinning.rootsAttachTarget != null)
			{
				return settingsSkinning.rootsAttachTargetBone.skinningBone.rotation;
			}
#endif
			return strandGroupInstance.sceneObjects.rootMeshFilter.transform.rotation;
		}

		public ref readonly SettingsSkinning GetSettingsSkinning(in GroupInstance strandGroupInstance)
		{
			var i = strandGroupInstance.settingsIndex;
			if (i != -1 && strandGroupSettings[i].settingsSkinningToggle)
				return ref strandGroupSettings[i].settingsSkinning;
			else
				return ref strandGroupDefaults.settingsSkinning;
		}

		public ref readonly HairSim.SettingsGeometry GetSettingsGeometry(in GroupInstance strandGroupInstance)
		{
			var i = strandGroupInstance.settingsIndex;
			if (i != -1 && strandGroupSettings[i].settingsGeometryToggle)
				return ref strandGroupSettings[i].settingsGeometry;
			else
				return ref strandGroupDefaults.settingsGeometry;
		}

		public ref readonly HairSim.SettingsRendering GetSettingsRendering(in GroupInstance strandGroupInstance)
		{
			var i = strandGroupInstance.settingsIndex;
			if (i != -1 && strandGroupSettings[i].settingsRenderingToggle)
				return ref strandGroupSettings[i].settingsRendering;
			else
				return ref strandGroupDefaults.settingsRendering;
		}

		public ref readonly HairSim.SettingsPhysics GetSettingsPhysics(in GroupInstance strandGroupInstance)
		{
			var i = strandGroupInstance.settingsIndex;
			if (i != -1 && strandGroupSettings[i].settingsPhysicsToggle)
				return ref strandGroupSettings[i].settingsPhysics;
			else
				return ref strandGroupDefaults.settingsPhysics;
		}

		public Material GetMaterial(in GroupInstance strandGroupInstance)
		{
			ref readonly var settingsRendering = ref GetSettingsRendering(strandGroupInstance);

			var mat = null as Material;

			if (mat == null && settingsRendering.material)
				mat = settingsRendering.materialAsset;

			if (mat == null)
				mat = HairMaterialUtility.GetCurrentPipelineDefault();

			return mat;
		}

		public void DispatchUpdate()
		{
			using (var cmd = HairSimUtility.ScopedCommandBuffer.Get())
			{
				if (DispatchUpdate(cmd, CommandBufferExecutionFlags.None, Time.deltaTime))
				{
					Graphics.ExecuteCommandBuffer(cmd);
				}
			}
		}

		public bool DispatchUpdate(CommandBuffer cmd, CommandBufferExecutionFlags cmdFlags, float dt)
		{
			if (InitializeRuntimeData())
			{
				var stepDesc = UpdateExecutiveState(dt);
				{
					UpdateSystemState(cmd, cmdFlags, stepDesc);
					UpdateSceneState(cmd);
				}

				return true;
			}
			else
			{
				return false;
			}
		}

		public void DispatchDraw(CommandBuffer cmd, CommandBufferExecutionFlags cmdFlags)
		{
			if (InitializeRuntimeData())
			{
				// draw solver data
				for (int i = 0; i != solverData.Length; i++)
				{
					HairSim.DrawSolverData(cmd, solverData[i], settingsDebugging);
				}

				// draw volume data
				HairSim.DrawVolumeData(cmd, volumeData, settingsDebugging);
			}
		}

		bool InitializeRuntimeData()
		{
			var groupStatus = CheckStrandGroupInstances();
			if (groupStatus != StrandGroupInstancesStatus.Valid)
				return false;

			var groupCount = strandGroupInstances?.Length ?? 0;
			if (groupCount == 0)
				return false;

			if (solverData?.Length == groupCount)
				return true;

			// record and dispatch initialization
			using (var cmd = HairSimUtility.ScopedCommandBuffer.Get())
			{
				InitializeRuntimeDataUnchecked(cmd, CommandBufferExecutionFlags.None);
				Graphics.ExecuteCommandBuffer(cmd);
			}

			// ensure that readback buffers are ready first frame
			AsyncGPUReadback.WaitAllRequests();

			// ready
			return true;
		}

		void InitializeRuntimeDataUnchecked(CommandBuffer cmd, CommandBufferExecutionFlags cmdFlags)
		{
			var groupCount = strandGroupInstances.Length;

			// prepare solver data
			solverData = new HairSim.SolverData[groupCount];
			{
				for (int i = 0; i != groupCount; i++)
				{
					ref readonly var groupAsset = ref strandGroupInstances[i].groupAssetReference.Resolve();

					HairSim.PrepareSolverData(ref solverData[i], groupAsset.strandCount, groupAsset.strandParticleCount, groupAsset.lodCount);
					{
						HairAssetUtility.DeclareParticleStride(groupAsset, out var strandParticleOffset, out var strandParticleStride);

						ref var solverConstants = ref solverData[i].constants;
						{
							solverConstants._StrandCount = (uint)groupAsset.strandCount;
							solverConstants._StrandParticleCount = (uint)groupAsset.strandParticleCount;
							solverConstants._StrandParticleOffset = (uint)strandParticleOffset;
							solverConstants._StrandParticleStride = (uint)strandParticleStride;
							solverConstants._LODCount = (uint)groupAsset.lodCount;
							//solverConstants._GroupScale
							//solverConstants._GroupMaxParticleVolume
							//solverConstants._GroupMaxParticleInterval
							//solverConstants._GroupMaxParticleDiameter
							//solverConstants._GroupAvgParticleDiameter
							//solverConstants._GroupAvgParticleMargin
							solverConstants._GroupBoundsIndex = (uint)i;
							//solverConstants._GroupBoundsPadding

							HairSimUtility.PushConstantBufferData(cmd, solverData[i].buffers.SolverCBuffer, solverConstants);
						}

						solverData[i].memoryLayout = groupAsset.particleMemoryLayout;

						solverData[i].initialStrandLengthTotal = groupAsset.strandLengthTotal;
						solverData[i].initialStrandParamsMax = groupAsset.strandParamsMax;
						solverData[i].initialStrandParamsAvg = groupAsset.strandParamsAvg;

						solverData[i].lodThreshold = new NativeArray<float>(groupAsset.lodThreshold, Allocator.Persistent);
					}

					using (var uploadCtx = new HairSimUtility.BufferUploadContext(cmd, cmdFlags))
					{
						ref readonly var solverBuffers = ref solverData[i].buffers;

						uploadCtx.SetData(solverBuffers._RootUV, groupAsset.rootUV);
						uploadCtx.SetData(solverBuffers._RootScale, groupAsset.rootScale);
						uploadCtx.SetData(solverBuffers._ParticlePosition, groupAsset.particlePosition);

						unsafe
						{
							// optional particle features
							//TODO defer allocation and upload to staging (let render settings decide if material should be able to access)
							{
								var particleCount = (groupAsset.strandCount * groupAsset.strandParticleCount);
								var particleTexCoordAvailable = groupAsset.particleFeatures.HasFlag(HairAsset.StrandGroup.ParticleFeatures.TexCoord);
								var particleDiameterAvailable = groupAsset.particleFeatures.HasFlag(HairAsset.StrandGroup.ParticleFeatures.Diameter);

								HairSimUtility.CreateBuffer(ref solverData[i].buffers._ParticleOptTexCoord, "ParticleOptTexCoord", particleTexCoordAvailable ? particleCount : 1, sizeof(Vector2));
								HairSimUtility.CreateBuffer(ref solverData[i].buffers._ParticleOptDiameter, "ParticleOptDiameter", particleDiameterAvailable ? particleCount : 1, sizeof(Vector2));

								if (particleTexCoordAvailable) uploadCtx.SetData(solverBuffers._ParticleOptTexCoord, groupAsset.particleTexCoord);
								if (particleDiameterAvailable) uploadCtx.SetData(solverBuffers._ParticleOptDiameter, groupAsset.particleDiameter);
							}
						}

						uploadCtx.SetData(solverBuffers._LODGuideCount, groupAsset.lodGuideCount);
						uploadCtx.SetData(solverBuffers._LODGuideIndex, groupAsset.lodGuideIndex);
						uploadCtx.SetData(solverBuffers._LODGuideCarry, groupAsset.lodGuideCarry);
						uploadCtx.SetData(solverBuffers._LODGuideReach, groupAsset.lodGuideReach);
					}
				}
			}

			// prepare volume data
			volumeData = new HairSim.VolumeData();
			{
				HairSim.PrepareVolumeData(ref volumeData, settingsVolumetrics, solverData.Length + 1);
				{
					volumeData.constants._CombinedBoundsIndex = (uint)solverData.Length;
				}
			}

			// perform initialization
			{
				for (int i = 0; i != solverData.Length; i++)
				{
					var rootMesh = strandGroupInstances[i].sceneObjects.rootMeshFilter.sharedMesh;
					var rootMeshMatrix = strandGroupInstances[i].sceneObjects.rootMeshFilter.transform.localToWorldMatrix;
					var rootMeshSkinningRotation = GetRootMeshSkinningRotation(strandGroupInstances[i], GetSettingsSkinning(strandGroupInstances[i]));

					HairSim.PushSolverRoots(cmd, cmdFlags, ref solverData[i], rootMesh, rootMeshMatrix, rootMeshSkinningRotation, stepCount: 1);
					HairSim.PushSolverRootsHistory(cmd, solverData[i]);
				}

				for (int i = 0; i != solverData.Length; i++)
				{
					HairSim.PushSolverGeometry(cmd, ref solverData[i], GetSettingsGeometry(strandGroupInstances[i]), this.transform.localToWorldMatrix);
				}

				for (int i = 0; i != solverData.Length; i++)
				{
					HairSim.InitSolverData(cmd, solverData[i]);
				}

				HairSim.PushVolumeObservers(cmd, ref volumeData, CameraType.Game | CameraType.SceneView);
				HairSim.PushVolumeGeometry(cmd, ref volumeData, solverData);
				HairSim.PushVolumeBounds(cmd, ref volumeData, solverData);
				HairSim.PushVolumeBoundsHistory(cmd, volumeData);

				for (int i = 0; i != solverData.Length; i++)
				{
					HairSim.PushSolverLODInit(cmd, solverData[i]);
					HairSim.PushSolverLOD(cmd, ref solverData[i], GetSettingsPhysics(strandGroupInstances[i]), GetSettingsRendering(strandGroupInstances[i]), volumeData, stepCount: 1);
				}

				HairSim.PushVolumeLOD(cmd, ref volumeData, settingsVolumetrics);
				HairSim.PushVolumeStepBegin(cmd, ref volumeData, settingsVolumetrics, 0.0f);
				HairSim.PushVolumeStep(cmd, cmdFlags, ref volumeData, settingsVolumetrics, solverData, stepFracLo: 0.0f, stepFracHi: 0.0f, stepTimeHi: 0.0);
				HairSim.PushVolumeStepEnd(cmd, volumeData, settingsVolumetrics);

				for (int i = 0; i != solverData.Length; i++)
				{
					HairSim.InitSolverDataPostVolume(cmd, solverData[i], volumeData);
				}
			}
		}

		void ReleaseRuntimeData()
		{
			if (strandGroupInstances != null)
			{
				for (int i = 0; i != strandGroupInstances.Length; i++)
				{	
					ref var strandGroupInstance = ref strandGroupInstances[i];

					CoreUtils.Destroy(strandGroupInstance.sceneObjects.materialInstance);
					CoreUtils.Destroy(strandGroupInstance.sceneObjects.materialInstanceShadows);

#if !UNITY_2021_2_OR_NEWER
					CoreUtils.Destroy(strandGroupInstance.sceneObjects.meshInstance);
					CoreUtils.Destroy(strandGroupInstance.sceneObjects.meshInstanceShadows);

					strandGroupInstance.sceneObjects.meshInstanceKey = 0uL;
					strandGroupInstance.sceneObjects.meshInstanceKeyShadows = 0uL;
#endif
				}
			}

			AsyncGPUReadback.WaitAllRequests();

			if (solverData != null)
			{
				for (int i = 0; i != solverData.Length; i++)
				{
					HairSim.ReleaseSolverData(ref solverData[i]);
				}

				solverData = null;
			}

			HairSim.ReleaseVolumeData(ref volumeData);

			execState = ExecutiveState.defaults;
		}

		public void PauseSimulationPostStep()
		{
			execState.pausePostStep = true;
		}

		public void ResetSimulationState()
		{
			ReleaseRuntimeData();
		}
	}
}

```

`Runtime/HairInstance.cs.meta`:

```meta
fileFormatVersion: 2
guid: 5e3c4c7574c547e4685bfb8817fbe6f3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {fileID: 2800000, guid: b10206d371a26e5428e4abde9978d769, type: 3}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairInstanceBuilder.cs`:

```cs
using System;
using UnityEngine;
using UnityEngine.Rendering;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Mathematics;

#if HAS_PACKAGE_UNITY_HDRP
using UnityEngine.Rendering.HighDefinition;
#endif

#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN
using Unity.DemoTeam.DigitalHuman;
#endif

namespace Unity.DemoTeam.Hair
{
	public static class HairInstanceBuilder
	{
		public static void ClearHairInstance(HairInstance hairInstance)
		{
			var strandGroupInstances = hairInstance.strandGroupInstances;
			if (strandGroupInstances != null)
			{
				for (int i = 0; i != strandGroupInstances.Length; i++)
				{
					ref readonly var strandGroupInstance = ref strandGroupInstances[i];

#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN
					if (strandGroupInstance.sceneObjects.rootMeshAttachment != null)
						strandGroupInstance.sceneObjects.rootMeshAttachment.Detach(false);
#endif

					CoreUtils.Destroy(strandGroupInstance.sceneObjects.groupContainer);
					CoreUtils.Destroy(strandGroupInstance.sceneObjects.materialInstance);
#if !UNITY_2021_2_OR_NEWER
					CoreUtils.Destroy(strandGroupInstance.sceneObjects.meshInstance);
#endif
				}
			}

			hairInstance.strandGroupInstances = null;
			hairInstance.strandGroupChecksums = null;

#if UNITY_EDITOR
			UnityEditor.EditorUtility.SetDirty(hairInstance);
#endif
		}

		public static void BuildHairInstance(HairInstance hairInstance, HairInstance.GroupProvider[] strandGroupProviders, HideFlags hideFlags = HideFlags.NotEditable)
		{
			ClearHairInstance(hairInstance);

			// prep strand group instances
			var strandGroupInstanceCount = 0;
			var strandGroupChecksumCount = 0;

			if (strandGroupProviders != null)
			{
				for (int i = 0; i != strandGroupProviders.Length; i++)
				{
					var hairAsset = strandGroupProviders[i].hairAsset;
					if (hairAsset == null || hairAsset.checksum == "")
						continue;

					var strandGroups = hairAsset.strandGroups;
					if (strandGroups == null)
						continue;

					strandGroupInstanceCount += hairAsset.strandGroups.Length;
					strandGroupChecksumCount++;
				}
			}

			if (strandGroupInstanceCount == 0)
				return;

			hairInstance.strandGroupInstances = new HairInstance.GroupInstance[strandGroupInstanceCount];
			hairInstance.strandGroupChecksums = new string[strandGroupChecksumCount];

			// build strand group instances
			for (int i = 0, writeIndexInstance = 0, writeIndexChecksum = 0; i != strandGroupProviders.Length; i++)
			{
				var hairAsset = strandGroupProviders[i].hairAsset;
				if (hairAsset == null || hairAsset.checksum == "")
					continue;

				var strandGroups = hairAsset.strandGroups;
				if (strandGroups == null)
					continue;

				for (int j = 0; j != strandGroups.Length; j++)
				{
					ref var strandGroupInstance = ref hairInstance.strandGroupInstances[writeIndexInstance++];

					strandGroupInstance.groupAssetReference.hairAsset = hairAsset;
					strandGroupInstance.groupAssetReference.hairAssetGroupIndex = j;
					strandGroupInstance.settingsIndex = -1;

					var flatIndex = writeIndexInstance - 1;

					// create scene object for group
					strandGroupInstance.sceneObjects.groupContainer = CreateContainer("Group:" + flatIndex, hairInstance.gameObject, hideFlags);

					// create scene objects for root mesh
					strandGroupInstance.sceneObjects.rootMeshContainer = CreateContainer("Roots:" + flatIndex, strandGroupInstance.sceneObjects.groupContainer, hideFlags);
					{
						strandGroupInstance.sceneObjects.rootMeshFilter = CreateComponent<MeshFilter>(strandGroupInstance.sceneObjects.rootMeshContainer, hideFlags);
						strandGroupInstance.sceneObjects.rootMeshFilter.sharedMesh = strandGroups[j].meshAssetRoots;

#if HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN
						strandGroupInstance.sceneObjects.rootMeshAttachment = CreateComponent<SkinAttachment>(strandGroupInstance.sceneObjects.rootMeshContainer, hideFlags);
						strandGroupInstance.sceneObjects.rootMeshAttachment.attachmentType = SkinAttachment.AttachmentType.Mesh;
						strandGroupInstance.sceneObjects.rootMeshAttachment.forceRecalculateBounds = true;
#endif
					}

					// create scene objects for strand mesh
					strandGroupInstance.sceneObjects.strandMeshContainer = CreateContainer("Strands:" + flatIndex, strandGroupInstance.sceneObjects.groupContainer, hideFlags);
					{
						strandGroupInstance.sceneObjects.strandMeshFilter = CreateComponent<MeshFilter>(strandGroupInstance.sceneObjects.strandMeshContainer, hideFlags);
						strandGroupInstance.sceneObjects.strandMeshRenderer = CreateComponent<MeshRenderer>(strandGroupInstance.sceneObjects.strandMeshContainer, hideFlags);

#if HAS_PACKAGE_UNITY_HDRP_15_0_2
						strandGroupInstance.sceneObjects.strandMeshRendererHDRP = CreateComponent<HDAdditionalMeshRendererSettings>(strandGroupInstance.sceneObjects.strandMeshContainer, hideFlags);
#endif
					}
				}

				hairInstance.strandGroupChecksums[writeIndexChecksum++] = hairAsset.checksum;
			}

#if UNITY_EDITOR
			UnityEditor.EditorUtility.SetDirty(hairInstance);
#endif
		}

		//--------
		// meshes

		public const MeshUpdateFlags MESH_UPDATE_UNCHECKED = MeshUpdateFlags.DontValidateIndices | MeshUpdateFlags.DontResetBoneBounds | MeshUpdateFlags.DontNotifyMeshUsers | MeshUpdateFlags.DontRecalculateBounds;

		public static unsafe void BuildMeshRoots(Mesh meshRoots, HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount, Vector3[] particlePosition)
		{
			var indexFormat = IndexFormat.UInt32;
			var indexStride = sizeof(uint);
			var indexCount = strandCount;

			using (var rootMeshPosition = new NativeArray<Vector3>(strandCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
			using (var rootMeshTangent = new NativeArray<Vector4>(strandCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
			using (var rootMeshNormal = new NativeArray<Vector3>(strandCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
			using (var indices = new NativeArray<byte>(indexCount * indexStride, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
			{
				var rootMeshPositionPtr = (Vector3*)rootMeshPosition.GetUnsafePtr();
				var rootMeshTangentPtr = (Vector4*)rootMeshTangent.GetUnsafePtr();
				var rootMeshNormalPtr = (Vector3*)rootMeshNormal.GetUnsafePtr();
				var indicesPtr = (uint*)indices.GetUnsafePtr();

				// write attributes
				for (int i = 0; i != strandCount; i++)
				{
					HairAssetUtility.DeclareStrandIterator(memoryLayout, strandCount, strandParticleCount, i,
						out var strandParticleBegin,
						out var strandParticleStride,
						out var strandParticleEnd);

					ref readonly var p0 = ref particlePosition[strandParticleBegin + strandParticleStride * 0];
					ref readonly var p1 = ref particlePosition[strandParticleBegin + strandParticleStride * 1];

					var localRootDir = Vector3.Normalize(p1 - p0);
					var localRootFrame = Quaternion.FromToRotation(Vector3.up, localRootDir);
					var localRootPerp = localRootFrame * Vector3.right;

					*(rootMeshPositionPtr++) = p0;
					*(rootMeshTangentPtr++) = new Vector4(localRootPerp.x, localRootPerp.y, localRootPerp.z, 1.0f);
					*(rootMeshNormalPtr++) = localRootDir;
				}

				// write indices
				for (uint i = 0; i != strandCount; i++)
				{
					*(indicesPtr++) = i;
				}

				if (strandCount <= UInt16.MaxValue)
				{
					var indicesPtrRead = (uint*)indices.GetUnsafePtr();
					var indicesPtrWrite = (ushort*)indices.GetUnsafePtr();

					for (uint i = 0; i != strandCount; i++)
					{
						*(indicesPtrWrite++) = (ushort)(*(indicesPtrRead++));
					}

					indexFormat = IndexFormat.UInt16;
					indexStride = sizeof(ushort);
				}

				// apply to mesh
				var meshVertexCount = strandCount;
				var meshUpdateFlags = MESH_UPDATE_UNCHECKED;
				{
					meshRoots.SetVertexBufferParams(meshVertexCount,
						new VertexAttributeDescriptor(VertexAttribute.Position, VertexAttributeFormat.Float32, dimension: 3, stream: 0),
						new VertexAttributeDescriptor(VertexAttribute.Normal, VertexAttributeFormat.Float32, dimension: 3, stream: 1),
						new VertexAttributeDescriptor(VertexAttribute.Tangent, VertexAttributeFormat.Float32, dimension: 4, stream: 2));
					{
						meshRoots.SetVertexBufferData(rootMeshPosition, dataStart: 0, meshBufferStart: 0, meshVertexCount, stream: 0, meshUpdateFlags);
						meshRoots.SetVertexBufferData(rootMeshNormal, dataStart: 0, meshBufferStart: 0, meshVertexCount, stream: 1, meshUpdateFlags);
						meshRoots.SetVertexBufferData(rootMeshTangent, dataStart: 0, meshBufferStart: 0, meshVertexCount, stream: 2, meshUpdateFlags);
					}

					meshRoots.SetIndexBufferParams(indexCount, indexFormat);
					{
						switch (indexFormat)
						{
							case IndexFormat.UInt16: meshRoots.SetIndexBufferData(indices.Reinterpret<byte, ushort>(), dataStart: 0, meshBufferStart: 0, indexCount, meshUpdateFlags); break;
							case IndexFormat.UInt32: meshRoots.SetIndexBufferData(indices.Reinterpret<byte, uint>(), dataStart: 0, meshBufferStart: 0, indexCount, meshUpdateFlags); break;
						}
					}

					meshRoots.subMeshCount = 1;
					meshRoots.SetSubMesh(0, new SubMeshDescriptor(0, indexCount, MeshTopology.Points) { vertexCount = meshVertexCount }, meshUpdateFlags);
					meshRoots.RecalculateBounds();
				}
			}
		}

		struct RenderMeshData : IDisposable
		{
			public NativeArray<byte> vertices;
			public NativeArray<byte> indices;

			public VertexAttributeFormat vertexFormat;
			public int vertexStride;
			public int vertexCount;

			public IndexFormat indexFormat;
			public int indexStride;
			public int indexCount;

			public void Dispose()
			{
				vertices.Dispose();
				indices.Dispose();
			}
		}

		static unsafe RenderMeshData CreateRenderMeshData(int strandCount, int strandParticleCount, int strandParticleVertexCount, int indexCount, Allocator allocator)
		{
			if (strandParticleCount > ushort.MaxValue)
			{
				strandParticleCount = ushort.MaxValue;
				Debug.LogWarning("Creating renderer data with truncated number of particles per strand (input exceeds maximum of 65535 particles per strand).");
			}

			RenderMeshData data;
			{
				var reqBitsStrandIndex = 32 - math.lzcnt(strandCount);
				var reqBitsVertexIndex = 32 - math.lzcnt(strandParticleCount);
				var reqBitsVertexFacet = 32 - math.lzcnt(strandParticleVertexCount - 1);

				data.vertexCount = strandCount * strandParticleCount * strandParticleVertexCount;
				data.vertexFormat = VertexAttributeFormat.UNorm16;
				data.vertexStride = 4 * sizeof(ushort);
				{
					if (reqBitsStrandIndex + reqBitsVertexFacet <= 24 && reqBitsVertexIndex <= 8)
					{
						data.vertexFormat = VertexAttributeFormat.UNorm8;
						data.vertexStride = 4 * sizeof(byte);
					}
				}

				data.indexCount = indexCount;
				data.indexFormat = IndexFormat.UInt32;
				data.indexStride = sizeof(uint);

				data.vertices = new NativeArray<byte>(data.vertexCount * data.vertexStride, allocator, NativeArrayOptions.UninitializedMemory);
				{
					switch (data.vertexFormat)
					{
						case VertexAttributeFormat.UNorm8:
							//	24-n bit strand index (i)
							//	0..8 bit vertex facet (k)
							//	   8 bit vertex index (j)
							//
							//	[ iiii iiii | iiii iiii | iiii kkkk | jjjj jjjj ]
							//	  ----w----   ----z----   ----y----   ----x----
							{
								var lshStrandIndex = 8 + reqBitsVertexFacet;
								var lshVertexFacet = 8;

								var verticesPtr = (uint*)data.vertices.GetUnsafePtr();

								for (uint i = 0; i != strandCount; i++)
								{
									for (uint j = 0; j != strandParticleCount; j++)
									{
										for (uint k = 0; k != strandParticleVertexCount; k++)
										{
											*(verticesPtr++) =
												(i << lshStrandIndex) |
												(k << lshVertexFacet) |
												(j);
										}
									}
								}
							}
							break;

						case VertexAttributeFormat.UNorm16:
							//	 48-n bit strand index (i)
							//	0..16 bit vertex facet (k)
							//	   16 bit vertex index (j)
							//
							//	[ iiii iiii iiii iiii | iiii iiii iiii iiii | iiii iiii kkkk kkkk | jjjj jjjj jjjj jjjj ]
							//	  ---------w---------   ---------z---------   ---------y---------   ---------x---------
							{
								var lshStrandIndex = 16 + reqBitsVertexFacet;
								var lshVertexFacet = 16;

								var verticesPtr = (ulong*)data.vertices.GetUnsafePtr();

								for (uint i = 0; i != strandCount; i++)
								{
									for (uint j = 0; j != strandParticleCount; j++)
									{
										for (uint k = 0; k != strandParticleVertexCount; k++)
										{
											*(verticesPtr++) =
												((ulong)i << lshStrandIndex) |
												((ulong)k << lshVertexFacet) |
												((ulong)j);
										}
									}
								}
							}
							break;
					}
				}

				data.indices = new NativeArray<byte>(data.indexCount * data.indexStride, allocator, NativeArrayOptions.UninitializedMemory);
				{
					// note: indices are written by caller
				}
			}

			return data;
		}

		static unsafe void ApplyRenderMeshData(Mesh mesh, MeshTopology topology, RenderMeshData data, in Bounds bounds)
		{
			/*
			if (topology == MeshTopology.Triangles)
			{
				var _DecodeStrandIndex = 1u;
				var _DecodeVertexComponentValue = (1 << 16) - 1;
				var _DecodeVertexComponentWidth = 32 - math.lzcnt(_DecodeVertexComponentValue);
				var _DecodeVertexCount = 3;
				var _DecodeVertexWidth = _DecodeVertexCount > 0 ? 32 - math.lzcnt(_DecodeVertexCount - 1) : 0;
				var _DecodeVertexValue = math.ceilpow2(_DecodeVertexCount);

				Debug.Log("BEGIN strandIndex " + _DecodeStrandIndex + " vertexCount " + _DecodeVertexCount + " vertexWidth " + _DecodeVertexWidth);
				for (uint k = 0; k != _DecodeVertexCount; k++)
				{
					uint pack = (_DecodeStrandIndex << _DecodeVertexWidth) | k;
					//Debug.Log(Convert.ToString(enc, 2).PadLeft(8, '0'));

					float4 packedID = 0;
					packedID.y = (float)pack / _DecodeVertexComponentValue;

					uint4 unpack = (uint4)math.round(packedID * _DecodeVertexComponentValue);
					var decodedStrandIndex = unpack.y >> _DecodeVertexWidth;
					var decodedVertexFacet = unpack.y & ((1 << _DecodeVertexWidth) - 1);
					var decodedTubularU = math.frac(packedID.y * ((float)_DecodeVertexComponentValue / (1 << _DecodeVertexWidth))) * ((1 << _DecodeVertexWidth) / (float)_DecodeVertexCount);
					Debug.Log("k " + k + " ... decodedStrandIndex " + decodedStrandIndex + " decodedVertexFacet " + decodedVertexFacet + " decodedTubularU " + decodedTubularU);
				}
			}
			*/

			if (data.vertexCount <= UInt16.MaxValue)
			{
				var indicesPtrRead = (uint*)data.indices.GetUnsafePtr();
				var indicesPtrWrite = (ushort*)data.indices.GetUnsafePtr();

				for (uint i = 0; i != data.indexCount; i++)
				{
					*(indicesPtrWrite++) = (ushort)(*(indicesPtrRead++));
				}

				data.indexFormat = IndexFormat.UInt16;
				data.indexStride = sizeof(ushort);
			}

			var meshUpdateFlags = MESH_UPDATE_UNCHECKED;
			{
				mesh.SetVertexBufferParams(data.vertexCount, new VertexAttributeDescriptor(VertexAttribute.TexCoord0, data.vertexFormat, dimension: 4, stream: 0));
				{
					switch (data.vertexFormat)
					{
						case VertexAttributeFormat.UNorm8: mesh.SetVertexBufferData(data.vertices.Reinterpret<byte, uint>(), dataStart: 0, meshBufferStart: 0, data.vertexCount, stream: 0, meshUpdateFlags); break;
						case VertexAttributeFormat.UNorm16: mesh.SetVertexBufferData(data.vertices.Reinterpret<byte, ulong>(), dataStart: 0, meshBufferStart: 0, data.vertexCount, stream: 0, meshUpdateFlags); break;
					}
				}

				mesh.SetIndexBufferParams(data.indexCount, data.indexFormat);
				{
					switch (data.indexFormat)
					{
						case IndexFormat.UInt16: mesh.SetIndexBufferData(data.indices.Reinterpret<byte, ushort>(), dataStart: 0, meshBufferStart: 0, data.indexCount, meshUpdateFlags); break;
						case IndexFormat.UInt32: mesh.SetIndexBufferData(data.indices.Reinterpret<byte, uint>(), dataStart: 0, meshBufferStart: 0, data.indexCount, meshUpdateFlags); break;
					}
				}

				mesh.subMeshCount = 1;
				mesh.SetSubMesh(0, new SubMeshDescriptor(0, data.indexCount, topology) { vertexCount = data.vertexCount, bounds = bounds }, meshUpdateFlags);
				mesh.bounds = bounds;
			}
		}

		public static unsafe void BuildRenderMeshLines(Mesh meshLines, HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount, in Bounds bounds)
		{
			var perLineVertices = strandParticleCount;
			var perLineSegments = perLineVertices - 1;
			var perLineIndices = perLineSegments * 2;

			using (var data = CreateRenderMeshData(strandCount, strandParticleCount, strandParticleVertexCount: 1, indexCount: strandCount * perLineIndices, Allocator.Temp))
			{
				// write indices
				{
					var indicesPtr = (uint*)data.indices.GetUnsafePtr();

					for (uint i = 0, segmentBase = 0; i != strandCount; i++, segmentBase++)
					{
						for (uint j = 0; j != perLineSegments; j++, segmentBase++)
						{
							*(indicesPtr++) = segmentBase;
							*(indicesPtr++) = segmentBase + 1;
						}
					}
				}

				// apply to mesh
				ApplyRenderMeshData(meshLines, MeshTopology.Lines, data, bounds);
			}
		}

		public static unsafe void BuildRenderMeshStrips(Mesh meshStrips, HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount, in Bounds bounds)
		{
			var perStripVertices = strandParticleCount * 2;
			var perStripSegments = strandParticleCount - 1;
			var perStripTriangles = perStripSegments * 2;
			var perStripIndices = perStripTriangles * 3;

			using (var data = CreateRenderMeshData(strandCount, strandParticleCount, strandParticleVertexCount : 2, indexCount: strandCount * perStripIndices, Allocator.Temp))
			{
				// write indices
				{
					var indicesPtr = (uint*)data.indices.GetUnsafePtr();

					for (uint i = 0, segmentBase = 0; i != strandCount; i++, segmentBase += 2)
					{
						for (uint j = 0; j != perStripSegments; j++, segmentBase += 2)
						{
							//  :  .   :
							//  |,     |
							//  4------5
							//  |    ,´|
							//  |  ,´  |      etc.
							//  |,´    |
							//  2------3    12----13
							//  |    ,´|    |    ,´|
							//  |  ,´  |    |  ,´  |
							//  |,´    |    |,´    |
							//  0------1    10----11
							//  .
							//  |
							//  '--- segmentBase

							// indices for first triangle
							*(indicesPtr++) = segmentBase + 0;
							*(indicesPtr++) = segmentBase + 3;
							*(indicesPtr++) = segmentBase + 1;

							// indices for second triangle
							*(indicesPtr++) = segmentBase + 0;
							*(indicesPtr++) = segmentBase + 2;
							*(indicesPtr++) = segmentBase + 3;
						}
					}
				}

				// apply to mesh
				ApplyRenderMeshData(meshStrips, MeshTopology.Triangles, data, bounds);
			}
		}

		public static unsafe void BuildRenderMeshTubes(Mesh meshTubes, HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount, in Bounds bounds)
		{
			const int numSides = 4;
			
			var perTubeVertices = strandParticleCount * numSides;
			var perTubeSegments = strandParticleCount - 1;
			var perTubeTriangles = (perTubeSegments * numSides * 2) + 4;
			var perTubeIndices = perTubeTriangles * 3;
			
			using (var data = CreateRenderMeshData(strandCount, strandParticleCount, strandParticleVertexCount: numSides, indexCount: strandCount * perTubeIndices, Allocator.Temp))
			{
				void CreateTriangle(ref uint* indicesPtr, uint offset, uint i0, uint i1, uint i2)
				{
					*(indicesPtr++) = offset + i0;
					*(indicesPtr++) = offset + i1;
					*(indicesPtr++) = offset + i2;
				}

				// write indices
				{
					var indicesPtr = (uint*)data.indices.GetUnsafePtr();

					for (uint i = 0, segmentBase = 0; i != strandCount; i++, segmentBase += 4)
					{
						// end cap a
						{
							CreateTriangle(ref indicesPtr, segmentBase, 0, 2, 3);
							CreateTriangle(ref indicesPtr, segmentBase, 0, 1, 2);
						}

						for (uint j = 0; j != perTubeSegments; j++, segmentBase += 4)
						{
							//     :      :
							//     7------6
							//   ,´:    ,´|        4------5------6------7------4
							//  4------5  |        |    ,´|    ,´|    ,´|    ,´|
							//  |  :   |  |   =>   |  ,´  |  ,´  |  ,´  |  ,´  |
							//  |  3 - |- 2        |,´    |,´    |,´    |,´    |
							//  |,´    |,´         0------1------2------3------0
							//  0------1
							//  .
							//  |
							//  '--- segmentBase

							// side a
							{
								CreateTriangle(ref indicesPtr, segmentBase, 0, 5, 1);
								CreateTriangle(ref indicesPtr, segmentBase, 0, 4, 5);
							}

							// side b
							{
								CreateTriangle(ref indicesPtr, segmentBase, 1, 6, 2);
								CreateTriangle(ref indicesPtr, segmentBase, 1, 5, 6);
							}

							// side c
							{
								CreateTriangle(ref indicesPtr, segmentBase, 2, 7, 3);
								CreateTriangle(ref indicesPtr, segmentBase, 2, 6, 7);
							}

							// side d
							{
								CreateTriangle(ref indicesPtr, segmentBase, 3, 4, 0);
								CreateTriangle(ref indicesPtr, segmentBase, 3, 7, 4);
							}
						}

						// end cap b
						{
							CreateTriangle(ref indicesPtr, segmentBase, 0, 2, 1);
							CreateTriangle(ref indicesPtr, segmentBase, 0, 3, 2);
						}
					}
				}

				// apply to mesh
				ApplyRenderMeshData(meshTubes, MeshTopology.Triangles, data, bounds);
			}
		}

		public static Mesh CreateMeshRoots(HideFlags hideFlags, HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount, Vector3[] particlePosition)
		{
			var meshRoots = new Mesh();
			{
				meshRoots.hideFlags = hideFlags;
				meshRoots.name = "Roots";
				BuildMeshRoots(meshRoots, memoryLayout, strandCount, strandParticleCount, particlePosition);
			}
			return meshRoots;
		}

		public static Mesh CreateMeshRootsIfNull(ref Mesh meshRoots, HideFlags hideFlags, HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount, Vector3[] particlePosition)
		{
			if (meshRoots == null)
				meshRoots = CreateMeshRoots(hideFlags, memoryLayout, strandCount, strandParticleCount, particlePosition);

			return meshRoots;
		}

		public delegate Mesh FnCreateRenderMesh(HideFlags hideFlags, HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount, in Bounds bounds);
		public delegate void FnCreateRenderMeshIfNull(ref Mesh mesh, HideFlags hideFlags, HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount, in Bounds bounds);

		public static Mesh CreateRenderMeshLines(HideFlags hideFlags, HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount, in Bounds bounds)
		{
			var meshLines = new Mesh();
			{
				meshLines.hideFlags = hideFlags;
				meshLines.name = "X-Lines";
				BuildRenderMeshLines(meshLines, memoryLayout, strandCount, strandParticleCount, bounds);
			}
			return meshLines;
		}

		public static Mesh CreateRenderMeshLinesIfNull(ref Mesh meshLines, HideFlags hideFlags, HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount, in Bounds bounds)
		{
			if (meshLines == null)
				meshLines = CreateRenderMeshLines(hideFlags, memoryLayout, strandCount, strandParticleCount, bounds);

			return meshLines;
		}

		public static Mesh CreateRenderMeshStrips(HideFlags hideFlags, HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount, in Bounds bounds)
		{
			var meshStrips = new Mesh();
			{
				meshStrips.hideFlags = hideFlags;
				meshStrips.name = "X-Strips";
				BuildRenderMeshStrips(meshStrips, memoryLayout, strandCount, strandParticleCount, bounds);
			}
			return meshStrips;
		}

		public static Mesh CreateRenderMeshStripsIfNull(ref Mesh meshStrips, HideFlags hideFlags, HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount, in Bounds bounds)
		{
			if (meshStrips == null)
				meshStrips = CreateRenderMeshStrips(hideFlags, memoryLayout, strandCount, strandParticleCount, bounds);

			return meshStrips;
		}
		
		public static Mesh CreateRenderMeshTubes(HideFlags hideFlags, HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount, in Bounds bounds)
		{
			var meshTubes = new Mesh();
			{
				meshTubes.hideFlags = hideFlags;
				meshTubes.name = "X-Tubes";
				BuildRenderMeshTubes(meshTubes, memoryLayout, strandCount, strandParticleCount, bounds);
			}
			return meshTubes;
		}

		public static Mesh CreateRenderMeshTubesIfNull(ref Mesh meshTubes, HideFlags hideFlags, HairAsset.MemoryLayout memoryLayout, int strandCount, int strandParticleCount, in Bounds bounds)
		{
			if (meshTubes == null)
				meshTubes = CreateRenderMeshTubes(hideFlags, memoryLayout, strandCount, strandParticleCount, bounds);

			return meshTubes;
		}

		public static Mesh CreateMeshInstance(Mesh original, HideFlags hideFlags)
		{
			var instance = Mesh.Instantiate(original);
			{
				instance.name = original.name + "(Instance)";
				instance.hideFlags = hideFlags;
			}
			return instance;
		}

		public static Mesh CreateMeshInstanceIfNull(ref Mesh instance, Mesh original, HideFlags hideFlags)
		{
			if (instance == null)
				instance = CreateMeshInstance(original, hideFlags);

			return instance;
		}

		//------------
		// containers

		public static GameObject CreateContainer(string name, GameObject parentContainer, HideFlags hideFlags)
		{
			var container = new GameObject(name);
			{
				container.transform.SetParent(parentContainer.transform, worldPositionStays: false);
				container.hideFlags = hideFlags;
			}
			return container;
		}

		public static T CreateComponent<T>(GameObject container, HideFlags hideFlags) where T : Component
		{
			var component = container.AddComponent<T>();
			{
				component.hideFlags = hideFlags;
			}
			return component;
		}

		public static void CreateComponentIfNull<T>(ref T component, GameObject container, HideFlags hideFlags) where T : Component
		{
			if (component == null)
				component = CreateComponent<T>(container, hideFlags);
		}
	}
}

```

`Runtime/HairInstanceBuilder.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6b852ec12d4d7c94490cb2f2d73ae4f1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairMaterialCommonBuiltin.hlsl`:

```hlsl
#ifndef __HAIRMATERIALCOMMONBUILTIN_HLSL__
#define __HAIRMATERIALCOMMONBUILTIN_HLSL__

//----------
// includes

#define UNITY_COMMON_INCLUDED

#ifndef real
#define real float
#endif
#ifndef real3
#define real3 float3
#endif
#ifndef real3x3
#define real3x3 float3x3
#endif
#ifndef SafeNormalize
#define SafeNormalize(v) (normalize(v))
#endif

#include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderConfig.cs.hlsl"
#ifdef SHADEROPTIONS_CAMERA_RELATIVE_RENDERING
#undef SHADEROPTIONS_CAMERA_RELATIVE_RENDERING
#define SHADEROPTIONS_CAMERA_RELATIVE_RENDERING (0)
#endif

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariables.hlsl"
#ifndef UNITY_MATRIX_M
#define UNITY_MATRIX_M unity_ObjectToWorld
#endif
#ifndef UNITY_MATRIX_I_M
#define UNITY_MATRIX_I_M unity_WorldToObject
#endif
#ifndef UNITY_PREV_MATRIX_M
#define UNITY_PREV_MATRIX_M UNITY_MATRIX_M
#endif
#ifndef UNITY_PREV_MATRIX_I_M
#define UNITY_PREV_MATRIX_I_M UNITY_MATRIX_I_M
#endif
#include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"

#if !SHADER_TARGET_SURFACE_ANALYSIS
#include "HairVertex.hlsl"
#endif

//------------
// structures

struct appdata_hair
{
	float4 packedID : TEXCOORD0;
#if HAIR_VERTEX_LIVE
	float4 vertex : COLOR;
#else
	float4 vertex : POSITION;
#endif
	float3 normal : NORMAL;
	float4 tangent : TANGENT;
	UNITY_VERTEX_INPUT_INSTANCE_ID
};

struct Input
{
	float3 strandColor;
	float2 strandUV;
};

//----------
// programs

void BuiltinVert(inout appdata_hair a, out Input o)
{
	UNITY_SETUP_INSTANCE_ID(a);
#if !SHADER_TARGET_SURFACE_ANALYSIS
	HairVertexData v = GetHairVertex(a.packedID, a.vertex.xyz, a.normal.xyz, (a.tangent.xyz * a.tangent.w));
	{
		a.vertex = float4(v.surfacePosition, 1.0);
		a.normal = v.surfaceNormal;
		a.tangent = float4(v.surfaceTangent, 1.0);

		UNITY_INITIALIZE_OUTPUT(Input, o);
		o.strandColor = v.strandIndexColor;
		o.strandUV = v.surfaceUV;
	}
#else
	o.strandColor = float3(0.5, 0.5, 0.5);
	o.strandUV = float2(0.5, 0.0);
#endif
}

void BuiltinSurf(Input IN, inout SurfaceOutput o)
{
#if !SHADER_TARGET_SURFACE_ANALYSIS
	float3 normalTS = GetSurfaceNormalTS(IN.strandUV * 0.5);
#else
	float3 normalTS = float3(0.0, 0.0, 1.0);
#endif

	o.Albedo = IN.strandColor;
	o.Normal = normalTS;
}

#endif//__HAIRMATERIALCOMMONBUILTIN_HLSL__

```

`Runtime/HairMaterialCommonBuiltin.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: 2d666bfa23792cf4eaf9be17f3f8dcb9
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  preprocessorOverride: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairMaterialCommonUnlit.hlsl`:

```hlsl
#ifndef __HAIRMATERIALCOMMONUNLIT_HLSL__
#define __HAIRMATERIALCOMMONUNLIT_HLSL__

//----------
// includes

#include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderConfig.cs.hlsl"
#ifdef SHADEROPTIONS_CAMERA_RELATIVE_RENDERING
#undef SHADEROPTIONS_CAMERA_RELATIVE_RENDERING
#define SHADEROPTIONS_CAMERA_RELATIVE_RENDERING (0)
#endif

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariables.hlsl"
#ifndef UNITY_MATRIX_M
#define UNITY_MATRIX_M unity_ObjectToWorld
#endif
#ifndef UNITY_MATRIX_I_M
#define UNITY_MATRIX_I_M unity_WorldToObject
#endif
#ifndef UNITY_PREV_MATRIX_M
#define UNITY_PREV_MATRIX_M UNITY_MATRIX_M
#endif
#ifndef UNITY_PREV_MATRIX_I_M
#define UNITY_PREV_MATRIX_I_M UNITY_MATRIX_I_M
#endif
#include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"

#include "HairVertex.hlsl"

//------------
// structures

struct UnlitAttribs
{
	float4 packedID : TEXCOORD0;
	float3 staticPositionOS : POSITION;
	float3 staticTangentOS : TANGENT;
	float3 staticNormalOS : NORMAL;
	UNITY_VERTEX_INPUT_INSTANCE_ID
};

struct UnlitVaryings
{
	float4 positionCS : SV_POSITION;
	float3 strandColor : COLOR;
	float2 strandUV : TEXCOORD0;
};

//----------
// programs

UnlitVaryings UnlitVert(UnlitAttribs IN)
{
	UNITY_SETUP_INSTANCE_ID(IN);
	HairVertexData v = GetHairVertex(IN.packedID, IN.staticPositionOS, IN.staticNormalOS, IN.staticTangentOS);
	{
		UnlitVaryings OUT;
		OUT.positionCS = TransformObjectToHClip(v.surfacePosition);
		OUT.strandColor = v.strandIndexColor;
		OUT.strandUV = v.surfaceUV;
		return OUT;
	}
}

float4 UnlitFrag(UnlitVaryings IN) : SV_Target
{
	return float4(IN.strandColor, 1.0);
}

#endif//__HAIRMATERIALCOMMONUNLIT_HLSL__

```

`Runtime/HairMaterialCommonUnlit.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: 7301e907b204a6a479bbf119a5ce2f32
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  preprocessorOverride: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairMaterialDefaultLitBuiltin.shader`:

```shader
Shader "Hair/Default/HairMaterialDefaultLitBuiltin"
{
	CGINCLUDE

	#pragma target 5.0

	#pragma multi_compile_local_vertex HAIR_VERTEX_STATIC HAIR_VERTEX_LIVE
	#pragma multi_compile_vertex PROCEDURAL_INSTANCING_ON

	#pragma instancing_options assumeuniformscaling nomatrices nolodfade nolightprobe nolightmap procedural:HairVertexInstancingSetup

	#include "HairMaterialCommonBuiltin.hlsl"

	ENDCG

	SubShader
	{
		Tags { "RenderType" = "Opaque" "DisableBatching" = "True" "Queue" = "Geometry" }
		ZTest LEqual
		ZWrite On

		CGPROGRAM

		#pragma surface BuiltinSurf Lambert vertex:BuiltinVert addshadow fullforwardshadows noinstancing nolightmap nodynlightmap nometa
		#pragma enable_cbuffer// required on some targets to include custom constant buffers in surface shaders (e.g. metal)

		ENDCG
	}

	Fallback "Hair/Default/HairMaterialDefaultUnlit"
}

```

`Runtime/HairMaterialDefaultLitBuiltin.shader.meta`:

```meta
fileFormatVersion: 2
guid: 00130ba255f6d9246b65ea8e49cd73c7
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  preprocessorOverride: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairMaterialDefaultLitSRP.shadergraph`:

```shadergraph
{
    "m_SGVersion": 3,
    "m_Type": "UnityEditor.ShaderGraph.GraphData",
    "m_ObjectId": "72f98e211c5d47b9b4fca984ffc882a6",
    "m_Properties": [],
    "m_Keywords": [],
    "m_Dropdowns": [],
    "m_CategoryData": [
        {
            "m_Id": "fd0161ee075440139d2cda2cbdfee0c9"
        }
    ],
    "m_Nodes": [
        {
            "m_Id": "0f4935af65214d9db47b84dd4594d3ae"
        },
        {
            "m_Id": "4d315f3bc22d41a3980b68daa845bdc8"
        },
        {
            "m_Id": "592152ec4eb7404c832cd308ddf49fbf"
        },
        {
            "m_Id": "7ab2f0c9b7fc411180b63181354e4736"
        },
        {
            "m_Id": "61a4ae95775446f9af98c17e7e5243d0"
        },
        {
            "m_Id": "80c3b697376e4e019f66f6bf2dbb76ac"
        },
        {
            "m_Id": "2cd034ffa8fe49708760da90ba83ff31"
        },
        {
            "m_Id": "d4375eec47ea4bdeafd15b8053a91801"
        },
        {
            "m_Id": "59a517df7e394269aa4a9edc6189893b"
        },
        {
            "m_Id": "51744e63cdb34ca2b853be52071dae14"
        },
        {
            "m_Id": "6f5fa02a414042b9af991451e1088877"
        },
        {
            "m_Id": "7087d7b22c3c4adca9ddcd4929bb5815"
        },
        {
            "m_Id": "166ecf14bf8d4ce59f4eb2dda42c3cda"
        },
        {
            "m_Id": "e44ca09d258444878b101fc100486da3"
        },
        {
            "m_Id": "e82139cc5fb2432181e72a0dd8992522"
        }
    ],
    "m_GroupDatas": [],
    "m_StickyNoteDatas": [],
    "m_Edges": [
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "7ab2f0c9b7fc411180b63181354e4736"
                },
                "m_SlotId": 1
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "592152ec4eb7404c832cd308ddf49fbf"
                },
                "m_SlotId": 0
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "7ab2f0c9b7fc411180b63181354e4736"
                },
                "m_SlotId": 2
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "0f4935af65214d9db47b84dd4594d3ae"
                },
                "m_SlotId": 0
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "7ab2f0c9b7fc411180b63181354e4736"
                },
                "m_SlotId": 3
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "4d315f3bc22d41a3980b68daa845bdc8"
                },
                "m_SlotId": 0
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "7ab2f0c9b7fc411180b63181354e4736"
                },
                "m_SlotId": 6
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "6f5fa02a414042b9af991451e1088877"
                },
                "m_SlotId": 0
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "7ab2f0c9b7fc411180b63181354e4736"
                },
                "m_SlotId": 7
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "61a4ae95775446f9af98c17e7e5243d0"
                },
                "m_SlotId": 0
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "7ab2f0c9b7fc411180b63181354e4736"
                },
                "m_SlotId": 10
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "e44ca09d258444878b101fc100486da3"
                },
                "m_SlotId": 0
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "7ab2f0c9b7fc411180b63181354e4736"
                },
                "m_SlotId": 10
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "e82139cc5fb2432181e72a0dd8992522"
                },
                "m_SlotId": 0
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "7ab2f0c9b7fc411180b63181354e4736"
                },
                "m_SlotId": 14
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "166ecf14bf8d4ce59f4eb2dda42c3cda"
                },
                "m_SlotId": 0
            }
        }
    ],
    "m_VertexContext": {
        "m_Position": {
            "x": -148.00003051757813,
            "y": -172.0
        },
        "m_Blocks": [
            {
                "m_Id": "592152ec4eb7404c832cd308ddf49fbf"
            },
            {
                "m_Id": "0f4935af65214d9db47b84dd4594d3ae"
            },
            {
                "m_Id": "4d315f3bc22d41a3980b68daa845bdc8"
            },
            {
                "m_Id": "e82139cc5fb2432181e72a0dd8992522"
            },
            {
                "m_Id": "166ecf14bf8d4ce59f4eb2dda42c3cda"
            },
            {
                "m_Id": "e44ca09d258444878b101fc100486da3"
            }
        ]
    },
    "m_FragmentContext": {
        "m_Position": {
            "x": -147.0,
            "y": 173.0
        },
        "m_Blocks": [
            {
                "m_Id": "61a4ae95775446f9af98c17e7e5243d0"
            },
            {
                "m_Id": "80c3b697376e4e019f66f6bf2dbb76ac"
            },
            {
                "m_Id": "2cd034ffa8fe49708760da90ba83ff31"
            },
            {
                "m_Id": "d4375eec47ea4bdeafd15b8053a91801"
            },
            {
                "m_Id": "59a517df7e394269aa4a9edc6189893b"
            },
            {
                "m_Id": "51744e63cdb34ca2b853be52071dae14"
            },
            {
                "m_Id": "6f5fa02a414042b9af991451e1088877"
            },
            {
                "m_Id": "7087d7b22c3c4adca9ddcd4929bb5815"
            }
        ]
    },
    "m_PreviewData": {
        "serializedMesh": {
            "m_SerializedMesh": "{\"mesh\":{\"instanceID\":0}}",
            "m_Guid": ""
        },
        "preventRotation": false
    },
    "m_Path": "Hair/Default",
    "m_GraphPrecision": 0,
    "m_PreviewMode": 2,
    "m_OutputNode": {
        "m_Id": ""
    },
    "m_ActiveTargets": [
        {
            "m_Id": "e48891f036134c71b3a448c665e97338"
        },
        {
            "m_Id": "47822eabdb95401ea680b5c3b7cc9bb9"
        }
    ]
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "0e1e9b2de7a24a56a827f08a61fe661f",
    "m_Id": 0,
    "m_DisplayName": "Width",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Width",
    "m_StageCapability": 1,
    "m_Value": 0.07999999821186066,
    "m_DefaultValue": 0.07999999821186066,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "0f4935af65214d9db47b84dd4594d3ae",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "VertexDescription.Normal",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "407225fc1ff54f45bd3d243d81197743"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "VertexDescription.Normal"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.Rendering.HighDefinition.ShaderGraph.SystemData",
    "m_ObjectId": "101a1806c8934935942aa3f879d0aeab",
    "m_MaterialNeedsUpdateHash": 529,
    "m_SurfaceType": 0,
    "m_RenderingPass": 1,
    "m_BlendMode": 0,
    "m_ZTest": 4,
    "m_ZWrite": false,
    "m_TransparentCullMode": 2,
    "m_OpaqueCullMode": 2,
    "m_SortPriority": 0,
    "m_AlphaTest": false,
    "m_ExcludeFromTUAndAA": false,
    "m_TransparentDepthPrepass": false,
    "m_TransparentDepthPostpass": false,
    "m_SupportLodCrossFade": false,
    "m_DoubleSidedMode": 0,
    "m_DOTSInstancing": false,
    "m_CustomVelocity": true,
    "m_Tessellation": false,
    "m_TessellationMode": 0,
    "m_TessellationFactorMinDistance": 20.0,
    "m_TessellationFactorMaxDistance": 50.0,
    "m_TessellationFactorTriangleSize": 100.0,
    "m_TessellationShapeFactor": 0.75,
    "m_TessellationBackFaceCullEpsilon": -0.25,
    "m_TessellationMaxDisplacement": 0.009999999776482582,
    "m_DebugSymbols": false,
    "m_Version": 2,
    "inspectorFoldoutMask": 9
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BooleanMaterialSlot",
    "m_ObjectId": "12cd0cccb7de43c98f1d1c9c51e20cfa",
    "m_Id": -461852878,
    "m_DisplayName": "widthSet",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Boolean_cd8e0004d0024c258e2b86e3e06cfede",
    "m_StageCapability": 3,
    "m_Value": false,
    "m_DefaultValue": false
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "166ecf14bf8d4ce59f4eb2dda42c3cda",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "VertexDescription.Width",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "0e1e9b2de7a24a56a827f08a61fe661f"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "VertexDescription.Width"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "2298f47ee75a497cbe799c8d1223d1a0",
    "m_Id": 14,
    "m_DisplayName": "lodOutputWidth",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "lodOutputWidth",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "25ff02c3af674b61bbc925a3d470a418",
    "m_Id": 147058159,
    "m_DisplayName": "widthMod",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Vector1_9a07d2ec24634364bfe703b24288abac",
    "m_StageCapability": 3,
    "m_Value": 1.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "2cd034ffa8fe49708760da90ba83ff31",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.Alpha",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "fabaf5ad2fb34f109a0fc2366886add4"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.Alpha"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "2d0647fa135e4b568a1d129701946065",
    "m_Id": 3,
    "m_DisplayName": "surfaceTangentOS",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceTangentOS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector2MaterialSlot",
    "m_ObjectId": "2f2eaa22e930421d9e49e09c151b31ee",
    "m_Id": 5,
    "m_DisplayName": "rootUV",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "rootUV",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.ColorRGBMaterialSlot",
    "m_ObjectId": "391ee3fa3f9f470199cc6fe0932379e7",
    "m_Id": 0,
    "m_DisplayName": "Emission",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Emission",
    "m_StageCapability": 2,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": [],
    "m_ColorMode": 1,
    "m_DefaultColor": {
        "r": 0.0,
        "g": 0.0,
        "b": 0.0,
        "a": 1.0
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.PositionMaterialSlot",
    "m_ObjectId": "401615b730b84131b1c3dc0f4d0ee217",
    "m_Id": 0,
    "m_DisplayName": "Position",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Position",
    "m_StageCapability": 1,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": [
        "X",
        "Y",
        "Z"
    ],
    "m_Space": 0
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.NormalMaterialSlot",
    "m_ObjectId": "407225fc1ff54f45bd3d243d81197743",
    "m_Id": 0,
    "m_DisplayName": "Normal",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Normal",
    "m_StageCapability": 1,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": [
        "X",
        "Y",
        "Z"
    ],
    "m_Space": 0
}

{
    "m_SGVersion": 1,
    "m_Type": "UnityEditor.Rendering.Universal.ShaderGraph.UniversalTarget",
    "m_ObjectId": "47822eabdb95401ea680b5c3b7cc9bb9",
    "m_Datas": [],
    "m_ActiveSubTarget": {
        "m_Id": "65188460385f4790a6ad7e907a57c673"
    },
    "m_AllowMaterialOverride": false,
    "m_SurfaceType": 0,
    "m_ZTestMode": 4,
    "m_ZWriteControl": 0,
    "m_AlphaMode": 0,
    "m_RenderFace": 2,
    "m_AlphaClip": false,
    "m_CastShadows": true,
    "m_ReceiveShadows": true,
    "m_AdditionalMotionVectorMode": 2,
    "m_AlembicMotionVectors": false,
    "m_SupportsLODCrossFade": false,
    "m_CustomEditorGUI": "",
    "m_SupportVFX": false
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "4b5286e5ffe84f3fae0928b489b4270f",
    "m_Id": -1108646570,
    "m_DisplayName": "lodBias",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Vector1_d3c05afc9b6a491e82ac2f9a438408ba",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "4d315f3bc22d41a3980b68daa845bdc8",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "VertexDescription.Tangent",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 22.4000244140625,
            "y": -56.80000305175781,
            "width": 200.0,
            "height": 40.79999923706055
        }
    },
    "m_Slots": [
        {
            "m_Id": "b5aa1ab6936e4ef4a2341b8cceae588a"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "VertexDescription.Tangent"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "4f46a4fd955f4e61abd7f27f359ec9aa",
    "m_Id": 9,
    "m_DisplayName": "strandIndex",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "strandIndex",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "51744e63cdb34ca2b853be52071dae14",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.Occlusion",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "9d9a6fbef26649798dff94516bd338ed"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.Occlusion"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "54a4c844bec24919b12c20f5aeb92bb1",
    "m_Id": 10,
    "m_DisplayName": "surfaceVelocityOS",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceVelocityOS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "592152ec4eb7404c832cd308ddf49fbf",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "VertexDescription.Position",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 28.799936294555665,
            "y": -121.60000610351563,
            "width": 200.0,
            "height": 41.599998474121097
        }
    },
    "m_Slots": [
        {
            "m_Id": "401615b730b84131b1c3dc0f4d0ee217"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "VertexDescription.Position"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "59a517df7e394269aa4a9edc6189893b",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.Smoothness",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "76ba3985f30e49498f1bd4f8ee2a922c"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.Smoothness"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "61a4ae95775446f9af98c17e7e5243d0",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.BaseColor",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "73ceeabac4d943a1828433fc97da8ea6"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.BaseColor"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.Rendering.HighDefinition.ShaderGraph.HDLitSubTarget",
    "m_ObjectId": "63a95309930c4dff9998140a47a11d44"
}

{
    "m_SGVersion": 2,
    "m_Type": "UnityEditor.Rendering.Universal.ShaderGraph.UniversalLitSubTarget",
    "m_ObjectId": "65188460385f4790a6ad7e907a57c673",
    "m_WorkflowMode": 1,
    "m_NormalDropOffSpace": 0,
    "m_ClearCoat": false,
    "m_BlendModePreserveSpecular": false
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector2MaterialSlot",
    "m_ObjectId": "67771e805a064ab7b720526e57bb6ff2",
    "m_Id": 11,
    "m_DisplayName": "surfaceUV",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceUV",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "6f5fa02a414042b9af991451e1088877",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.NormalTS",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "736fccafda1d417da03ac6d472b761a4"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.NormalTS"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "7087d7b22c3c4adca9ddcd4929bb5815",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.Metallic",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "9bc215378add450ea0a5641ce19abd65"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.Metallic"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.NormalMaterialSlot",
    "m_ObjectId": "736fccafda1d417da03ac6d472b761a4",
    "m_Id": 0,
    "m_DisplayName": "Normal (Tangent Space)",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "NormalTS",
    "m_StageCapability": 2,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": [],
    "m_Space": 3
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.ColorRGBMaterialSlot",
    "m_ObjectId": "73ceeabac4d943a1828433fc97da8ea6",
    "m_Id": 0,
    "m_DisplayName": "Base Color",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "BaseColor",
    "m_StageCapability": 2,
    "m_Value": {
        "x": 0.5,
        "y": 0.5,
        "z": 0.5
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": [],
    "m_ColorMode": 0,
    "m_DefaultColor": {
        "r": 0.5,
        "g": 0.5,
        "b": 0.5,
        "a": 1.0
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "76ba3985f30e49498f1bd4f8ee2a922c",
    "m_Id": 0,
    "m_DisplayName": "Smoothness",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Smoothness",
    "m_StageCapability": 2,
    "m_Value": 0.5,
    "m_DefaultValue": 0.5,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.SubGraphNode",
    "m_ObjectId": "7ab2f0c9b7fc411180b63181354e4736",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "HairVertex",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -973.9999389648438,
            "y": -171.99998474121095,
            "width": 208.0,
            "height": 446.0000305175781
        }
    },
    "m_Slots": [
        {
            "m_Id": "85d90147dce4442197af3c7003a8a35d"
        },
        {
            "m_Id": "4b5286e5ffe84f3fae0928b489b4270f"
        },
        {
            "m_Id": "25ff02c3af674b61bbc925a3d470a418"
        },
        {
            "m_Id": "12cd0cccb7de43c98f1d1c9c51e20cfa"
        },
        {
            "m_Id": "bb5502e0bc4d4dc383d0671f8ada2b0c"
        },
        {
            "m_Id": "9533a6ef78c74bb1b2db47936490f35d"
        },
        {
            "m_Id": "2d0647fa135e4b568a1d129701946065"
        },
        {
            "m_Id": "54a4c844bec24919b12c20f5aeb92bb1"
        },
        {
            "m_Id": "a819da355aa34f1a8e77d7ec9d7350d2"
        },
        {
            "m_Id": "67771e805a064ab7b720526e57bb6ff2"
        },
        {
            "m_Id": "f741b7126eb649339d4fb6f4f3e1b523"
        },
        {
            "m_Id": "f4b19e5622214c47bdd5febc06b07d38"
        },
        {
            "m_Id": "2298f47ee75a497cbe799c8d1223d1a0"
        },
        {
            "m_Id": "2f2eaa22e930421d9e49e09c151b31ee"
        },
        {
            "m_Id": "be9c2b0794fc4717951015ef3f1b74ac"
        },
        {
            "m_Id": "4f46a4fd955f4e61abd7f27f359ec9aa"
        },
        {
            "m_Id": "e4ebd0e8a36f4b0280e0fec77482b074"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": false,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedSubGraph": "{\n    \"subGraph\": {\n        \"fileID\": -5475051401550479605,\n        \"guid\": \"002d81e8bea19124fa7923b24cb10d46\",\n        \"type\": 3\n    }\n}",
    "m_PropertyGuids": [
        "e935c862-ea39-43ee-b8a2-fce6cf0c0c57",
        "ef8f2b92-1164-4e4a-8a59-43e03cb67e8e",
        "25d0a9b2-ee13-44c2-b1a5-c30e0760039f",
        "30a1e851-b1d9-47ea-a659-654208c32b89"
    ],
    "m_PropertyIds": [
        -15954981,
        -1108646570,
        147058159,
        -461852878
    ],
    "m_Dropdowns": [],
    "m_DropdownSelectedEntries": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "80c3b697376e4e019f66f6bf2dbb76ac",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.Emission",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "391ee3fa3f9f470199cc6fe0932379e7"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.Emission"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "85d90147dce4442197af3c7003a8a35d",
    "m_Id": -15954981,
    "m_DisplayName": "lodScale",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Vector1_1a64895764df486687bfa37d0a17be88",
    "m_StageCapability": 3,
    "m_Value": 1.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.NormalMaterialSlot",
    "m_ObjectId": "896cd5eed74c4f929ed289a77b65a5e8",
    "m_Id": 0,
    "m_DisplayName": "Bent Normal",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "BentNormal",
    "m_StageCapability": 2,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": [],
    "m_Space": 3
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "8f3c18b55ce64dedb33a0df26508cd99",
    "m_Id": 0,
    "m_DisplayName": "Motion Vector",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "MotionVector",
    "m_StageCapability": 1,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "9533a6ef78c74bb1b2db47936490f35d",
    "m_Id": 2,
    "m_DisplayName": "surfaceNormalOS",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceNormalOS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "9bc215378add450ea0a5641ce19abd65",
    "m_Id": 0,
    "m_DisplayName": "Metallic",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Metallic",
    "m_StageCapability": 2,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "9d9a6fbef26649798dff94516bd338ed",
    "m_Id": 0,
    "m_DisplayName": "Ambient Occlusion",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Occlusion",
    "m_StageCapability": 2,
    "m_Value": 1.0,
    "m_DefaultValue": 1.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.Rendering.HighDefinition.ShaderGraph.HDLitData",
    "m_ObjectId": "a65a91b0a3464c22bdfbe06bc87c17a8",
    "m_RayTracing": false,
    "m_MaterialType": 0,
    "m_MaterialTypeMask": 2,
    "m_RefractionModel": 0,
    "m_SSSTransmission": true,
    "m_EnergyConservingSpecular": true,
    "m_ClearCoat": false
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "a692ec27b98841bd825a697063a57428",
    "m_Id": 0,
    "m_DisplayName": "Velocity",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "CustomVelocity",
    "m_StageCapability": 1,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "a819da355aa34f1a8e77d7ec9d7350d2",
    "m_Id": 6,
    "m_DisplayName": "surfaceNormalTS",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceNormalTS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.TangentMaterialSlot",
    "m_ObjectId": "b5aa1ab6936e4ef4a2341b8cceae588a",
    "m_Id": 0,
    "m_DisplayName": "Tangent",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Tangent",
    "m_StageCapability": 1,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": [
        "X",
        "Y",
        "Z"
    ],
    "m_Space": 0
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.Rendering.HighDefinition.ShaderGraph.BuiltinData",
    "m_ObjectId": "bab95a9e7cc1436eaa8f39290bfecbb9",
    "m_Distortion": false,
    "m_DistortionMode": 0,
    "m_DistortionDepthTest": true,
    "m_AddPrecomputedVelocity": false,
    "m_TransparentWritesMotionVec": false,
    "m_DepthOffset": false,
    "m_ConservativeDepthOffset": false,
    "m_TransparencyFog": true,
    "m_AlphaTestShadow": false,
    "m_BackThenFrontRendering": false,
    "m_TransparentDepthPrepass": false,
    "m_TransparentDepthPostpass": false,
    "m_TransparentPerPixelSorting": false,
    "m_SupportLodCrossFade": false
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "bb5502e0bc4d4dc383d0671f8ada2b0c",
    "m_Id": 1,
    "m_DisplayName": "surfacePositionOS",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfacePositionOS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector4MaterialSlot",
    "m_ObjectId": "be9c2b0794fc4717951015ef3f1b74ac",
    "m_Id": 12,
    "m_DisplayName": "rootScale",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "rootScale",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "d4375eec47ea4bdeafd15b8053a91801",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.BentNormal",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "896cd5eed74c4f929ed289a77b65a5e8"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.BentNormal"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.Rendering.HighDefinition.ShaderGraph.LightingData",
    "m_ObjectId": "d8000c07c9a744e487b14092429b4c9f",
    "m_NormalDropOffSpace": 0,
    "m_BlendPreserveSpecular": true,
    "m_ReceiveDecals": false,
    "m_ReceiveSSR": false,
    "m_ReceiveSSRTransparent": false,
    "m_SpecularAA": false,
    "m_SpecularOcclusionMode": 0,
    "m_OverrideBakedGI": false
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "e44ca09d258444878b101fc100486da3",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "VertexDescription.MotionVector",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -138.0,
            "y": -17.0,
            "width": 200.0,
            "height": 41.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "8f3c18b55ce64dedb33a0df26508cd99"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "VertexDescription.MotionVector"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.Rendering.HighDefinition.ShaderGraph.HDTarget",
    "m_ObjectId": "e48891f036134c71b3a448c665e97338",
    "m_ActiveSubTarget": {
        "m_Id": "63a95309930c4dff9998140a47a11d44"
    },
    "m_Datas": [
        {
            "m_Id": "bab95a9e7cc1436eaa8f39290bfecbb9"
        },
        {
            "m_Id": "101a1806c8934935942aa3f879d0aeab"
        },
        {
            "m_Id": "d8000c07c9a744e487b14092429b4c9f"
        },
        {
            "m_Id": "a65a91b0a3464c22bdfbe06bc87c17a8"
        }
    ],
    "m_CustomEditorGUI": "",
    "m_SupportVFX": false,
    "m_SupportLineRendering": true
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "e4ebd0e8a36f4b0280e0fec77482b074",
    "m_Id": 7,
    "m_DisplayName": "strandIndexColor",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "strandIndexColor",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "e82139cc5fb2432181e72a0dd8992522",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "VertexDescription.CustomVelocity",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -132.0,
            "y": -12.0,
            "width": 200.0,
            "height": 41.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "a692ec27b98841bd825a697063a57428"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "VertexDescription.CustomVelocity"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "f4b19e5622214c47bdd5febc06b07d38",
    "m_Id": 13,
    "m_DisplayName": "lodOutputOpacity",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "lodOutputOpacity",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector2MaterialSlot",
    "m_ObjectId": "f741b7126eb649339d4fb6f4f3e1b523",
    "m_Id": 8,
    "m_DisplayName": "surfaceUVClip",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceUVClip",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "fabaf5ad2fb34f109a0fc2366886add4",
    "m_Id": 0,
    "m_DisplayName": "Alpha",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Alpha",
    "m_StageCapability": 2,
    "m_Value": 1.0,
    "m_DefaultValue": 1.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.CategoryData",
    "m_ObjectId": "fd0161ee075440139d2cda2cbdfee0c9",
    "m_Name": "",
    "m_ChildObjectList": []
}


```

`Runtime/HairMaterialDefaultLitSRP.shadergraph.meta`:

```meta
fileFormatVersion: 2
guid: e28e8d02189f3d549a2682c06f7ab03d
ScriptedImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 2
  userData: 
  assetBundleName: 
  assetBundleVariant: 
  script: {fileID: 11500000, guid: 625f186215c104763be7675aa2d941aa, type: 3}

```

`Runtime/HairMaterialDefaultUnlit.shader`:

```shader
Shader "Hair/Default/HairMaterialDefaultUnlit"
{
	HLSLINCLUDE

	#pragma target 5.0

	#pragma multi_compile_local_vertex HAIR_VERTEX_STATIC HAIR_VERTEX_LIVE
	#pragma multi_compile_vertex PROCEDURAL_INSTANCING_ON

	#pragma instancing_options assumeuniformscaling nomatrices nolodfade nolightprobe nolightmap procedural:HairVertexInstancingSetup

	#include "HairMaterialCommonUnlit.hlsl"

	ENDHLSL

	SubShader
	{
		Tags { "RenderType" = "Opaque" "DisableBatching" = "True" "Queue" = "Transparent-1" }
		ZTest LEqual
		ZWrite On

		Pass
		{
			HLSLPROGRAM

			#pragma vertex UnlitVert
			#pragma fragment UnlitFrag

			ENDHLSL
		}
	}

	Fallback Off
}

```

`Runtime/HairMaterialDefaultUnlit.shader.meta`:

```meta
fileFormatVersion: 2
guid: aa19c1d1ecbc28f43be51dc33a2ffa95
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  preprocessorOverride: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairMaterialReplaceAsync.shader`:

```shader
Shader "Hair/Hidden/HairMaterialReplaceAsync"
{
	HLSLINCLUDE

	#pragma target 5.0
	#pragma editor_sync_compilation

	#pragma multi_compile_local_vertex HAIR_VERTEX_STATIC HAIR_VERTEX_LIVE
	#pragma multi_compile_vertex PROCEDURAL_INSTANCING_ON

	#pragma instancing_options assumeuniformscaling nomatrices nolodfade nolightprobe nolightmap procedural:HairVertexInstancingSetup

	#include "HairMaterialCommonUnlit.hlsl"

	ENDHLSL

	SubShader
	{
		Tags { "RenderType" = "Opaque" "DisableBatching" = "True" "Queue" = "Transparent-1" }
		ZTest LEqual
		ZWrite On

		Pass
		{
			HLSLPROGRAM

			#pragma vertex UnlitVert
			#pragma fragment UnlitFragAsync

			float4 UnlitFragAsync(UnlitVaryings IN) : SV_Target
			{
				float3 asyncColor = float3(0.0, 1.0, 1.0);
				return float4(lerp(IN.strandColor, asyncColor, 0.9), 1.0);
			}

			ENDHLSL
		}
	}

	Fallback Off
}

```

`Runtime/HairMaterialReplaceAsync.shader.meta`:

```meta
fileFormatVersion: 2
guid: 924d5e6be0d55294e89ae9a03b93ef99
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  preprocessorOverride: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairMaterialReplaceError.shader`:

```shader
Shader "Hair/Hidden/HairMaterialReplaceError"
{
	HLSLINCLUDE

	#pragma target 5.0
	#pragma editor_sync_compilation

	#pragma multi_compile_local_vertex HAIR_VERTEX_STATIC HAIR_VERTEX_LIVE
	#pragma multi_compile_vertex PROCEDURAL_INSTANCING_ON

	#pragma instancing_options assumeuniformscaling nomatrices nolodfade nolightprobe nolightmap procedural:HairVertexInstancingSetup

	#include "HairMaterialCommonUnlit.hlsl"

	ENDHLSL

	SubShader
	{
		Tags { "RenderType" = "Opaque" "DisableBatching" = "True" "Queue" = "Transparent-1" }
		ZTest LEqual
		ZWrite On

		Pass
		{
			HLSLPROGRAM

			#pragma vertex UnlitVert
			#pragma fragment UnlitFragError

			float4 UnlitFragError(UnlitVaryings IN) : SV_Target
			{
				float3 errorColor = float3(1.0, 0.0, 1.0);
				return float4(lerp(IN.strandColor, errorColor, 0.9), 1.0);
			}

			ENDHLSL
		}
	}

	Fallback Off
}

```

`Runtime/HairMaterialReplaceError.shader.meta`:

```meta
fileFormatVersion: 2
guid: ce4b10c704251b44aa714a9480bf938a
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  preprocessorOverride: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairMaterialUtility.cs`:

```cs
using System;
#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine;
using UnityEngine.Rendering;

#if HAS_PACKAGE_UNITY_HDRP
using UnityEngine.Rendering.HighDefinition;
#endif
#if HAS_PACKAGE_UNITY_URP
using UnityEngine.Rendering.Universal;
#endif

namespace Unity.DemoTeam.Hair
{
	public static class HairMaterialUtility
	{
		static Material[] s_defaultMaterial = new Material[Enum.GetNames(typeof(PipelineLabel)).Length];

		public enum PipelineLabel
		{
			Builtin,
			Custom,
			HDRP,
			URP,
		}

		public static PipelineLabel GetPipelineLabel(RenderPipeline pipeline)
		{
			if (pipeline != null)
			{
#if HAS_PACKAGE_UNITY_HDRP
				if (pipeline is HDRenderPipeline)
					return PipelineLabel.HDRP;
#endif
#if HAS_PACKAGE_UNITY_URP
				if (pipeline is UniversalRenderPipeline)
					return PipelineLabel.URP;
#endif

				return PipelineLabel.Custom;
			}

			return PipelineLabel.Builtin;
		}

		public static Shader GetPipelineDefaultShader(RenderPipeline pipeline) => GetPipelineDefaultShader(GetPipelineLabel(pipeline));
		public static Shader GetPipelineDefaultShader(PipelineLabel pipelineLabel)
		{
			switch (pipelineLabel)
			{
				case PipelineLabel.Builtin: return HairSimResources.Load().defaultBuiltin;
				case PipelineLabel.Custom: return HairSimResources.Load().defaultCustom;
				case PipelineLabel.HDRP: return HairSimResources.Load().defaultHDRP;
				case PipelineLabel.URP: return HairSimResources.Load().defaultURP;
			}

			return HairSimResources.Load().defaultCustom;
		}

		public static Material GetPipelineDefaultMaterial(RenderPipeline pipeline) => GetPipelineDefaultMaterial(GetPipelineLabel(pipeline));
		public static Material GetPipelineDefaultMaterial(PipelineLabel pipelineLabel)
		{
			var mat = s_defaultMaterial[(int)pipelineLabel];
			if (mat == null)
			{
				var sh = GetPipelineDefaultShader(pipelineLabel);
				if (sh != null)
				{
					mat = s_defaultMaterial[(int)pipelineLabel] = CoreUtils.CreateEngineMaterial(sh);
				}
			}

			return mat;
		}

		public static Material GetCurrentPipelineDefault()
		{
			return GetPipelineDefaultMaterial(RenderPipelineManager.currentPipeline);
		}

		public static bool AnyPassPendingCompilation(Material material)
		{
#if UNITY_EDITOR
			for (int i = 0, n = material.shader.passCount; i != n; i++)
			{
				if (ShaderUtil.IsPassCompiled(material, i) == false)
				{
					return true;
				}
			}
#endif
			return false;
		}

		public static int TryCompileCountPassesPending(Material material)
		{
			var pendingCompilation = 0;
#if UNITY_EDITOR
			for (int i = 0; i != material.passCount; i++)
			{
				if (ShaderUtil.IsPassCompiled(material, i) == false)
				{
					ShaderUtil.CompilePass(material, i);
					pendingCompilation++;
				}
			}
#endif
			return pendingCompilation;
		}

		public enum ReplacementType
		{
			Async,
			Error,
		}

		public static Shader GetReplacementShader(ReplacementType type)
		{
			switch (type)
			{
				case ReplacementType.Async: return HairSimResources.Load().replaceAsync;
				case ReplacementType.Error: return HairSimResources.Load().replaceError;
			}

			return null;
		}
	}
}

```

`Runtime/HairMaterialUtility.cs.meta`:

```meta
fileFormatVersion: 2
guid: 50d1c7e9356c9b548bca9d3e57990cb9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSim.LOD.cs`:

```cs
using UnityEngine;
using UnityEngine.Rendering;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.DemoTeam.Hair
{
	public static partial class HairSim
	{
		private static Camera[] s_managedCameras = new Camera[128];
		private static Plane[] s_managedFrustum = new Plane[6];
			
		[GenerateHLSL(needAccessors = false)]
		public struct LODFrustum
		{
			public Vector3 cameraPosition;
			public Vector3 cameraForward;
			public float cameraNear;
			public float unitSpanSubpixelDepth;

			public Vector4 plane0;
			public Vector4 plane1;
			public Vector4 plane2;
			public Vector4 plane3;
			public Vector4 plane4;
			public Vector4 plane5;
		};

		[GenerateHLSL(needAccessors = false)]
		public struct LODBounds
		{
			public Vector3 center;
			public Vector3 extent;
			public float radius;
			public float reach;
		}

		[GenerateHLSL(needAccessors = false)]
		public struct LODGeometry
		{
			public float maxParticleDiameter;
			public float maxParticleInterval;
		}

		[GenerateHLSL(needAccessors = false)]
		public struct LODIndices
		{
			public uint lodIndexLo;
			public uint lodIndexHi;
			public float lodBlendFrac;
			public float lodValue;
		};

		public static NativeList<LODFrustum> AcquireLODFrustums(CameraType cameraType, Allocator allocator)
		{
			var lodFrustums = new NativeList<LODFrustum>(Conf.MAX_FRUSTUMS, allocator);
			{
				MakeLODFrustums(cameraType, ref lodFrustums);
			}

			if (lodFrustums.Length > Conf.MAX_FRUSTUMS)
			{
				lodFrustums.Resize(Conf.MAX_FRUSTUMS, NativeArrayOptions.UninitializedMemory);
			}

			return lodFrustums;
		}

		public static int MakeLODFrustums(CameraType cameraType, ref NativeList<LODFrustum> lodFrustums)
		{
			lodFrustums.Clear();

			// enumerate non-scene view cameras
			if ((cameraType & ~CameraType.SceneView) != 0)
			{
				var n = Camera.GetAllCameras(s_managedCameras);
				for (int i = 0; i != n; i++)
				{
					var camera = s_managedCameras[i];
					if (camera != null && camera.isActiveAndEnabled && cameraType.HasFlag(camera.cameraType))
					{
						lodFrustums.Add(MakeLODFrustum(camera));
					}

					s_managedCameras[i] = null;
				}
			}

			// enumerate scene view cameras
			if (cameraType.HasFlag(CameraType.SceneView))
			{
#if UNITY_EDITOR
				var sceneViews = UnityEditor.SceneView.sceneViews;
				for (int i = 0; i != sceneViews.Count; i++)
				{
					var sceneView = sceneViews[i] as UnityEditor.SceneView;
					if (sceneView != null)
					{
						var camera = sceneView.camera;
						if (camera != null)
						{
							lodFrustums.Add(MakeLODFrustum(camera));
						}
					}
				}
#endif
			}

			return lodFrustums.Length;
		}

		public static LODFrustum MakeLODFrustum(Camera camera)
		{
			var cameraPosition = camera.transform.position;
			var cameraForward = camera.transform.forward;
			var cameraOrtho = camera.orthographic;
			var cameraNear = camera.nearClipPlane;
			var cameraFar = camera.farClipPlane;

			GeometryUtility.CalculateFrustumPlanes(camera, s_managedFrustum);
			{
				var forwardDistance = Vector3.Dot(cameraForward, cameraPosition);

				// guard NaN near
				if (s_managedFrustum[4].IsNaN())
					s_managedFrustum[4] = cameraForward.ToPlane(-(forwardDistance + cameraNear));

				// guard NaN far
				if (s_managedFrustum[5].IsNaN())
					s_managedFrustum[5] = (-cameraForward).ToPlane(forwardDistance + cameraFar);
			}

			var unitDepthScreenSpan = 2.0f * (cameraOrtho ? camera.orthographicSize : Mathf.Tan(0.5f * Mathf.Deg2Rad * camera.GetGateFittedFieldOfView()));
			var unitDepthPixelCount = camera.scaledPixelHeight;
			var unitSpanSubpixelDepth = unitDepthPixelCount / unitDepthScreenSpan;

			// NOTE: we use these values in LODFrustumCoverage to compute pixel coverage for a given sample as follows:
			//
			//		float sampleDepth = max(dot(cameraForward, samplePosition - cameraPosition), cameraNear);
			//		float sampleSpanSubpixelDepth = sampleSpan * unitSpanSubpixelDepth;
			//		float sampleCoverage = sampleSpanSubpixelDepth / sampleDepth;
			//
			// also: for orthographic cameras we need to take depth out of the equation, so in that case we force:
			//
			//		float cameraForward	= 0;
			//		float cameraNear = 1;
			//	=>	float sampleDepth = 1;

			return new LODFrustum
			{
				cameraPosition = cameraPosition,
				cameraForward = cameraOrtho ? Vector3.zero : cameraForward,
				cameraNear = cameraOrtho ? 1.0f : cameraNear,
				unitSpanSubpixelDepth = unitSpanSubpixelDepth,

				plane0 = s_managedFrustum[0].ToVector4(),
				plane1 = s_managedFrustum[1].ToVector4(),
				plane2 = s_managedFrustum[2].ToVector4(),
				plane3 = s_managedFrustum[3].ToVector4(),
				plane4 = s_managedFrustum[4].ToVector4(),
				plane5 = s_managedFrustum[5].ToVector4(),
			};
		}

		public static bool LODFrustumContains(in LODFrustum lodFrustum, in LODBounds lodBounds)
		{
			// see: https://fgiesen.wordpress.com/2010/10/17/view-frustum-culling/
			return (
				Vector3.Dot(lodBounds.center + lodBounds.extent.CMul(lodFrustum.plane0.Sign()), lodFrustum.plane0) > -lodFrustum.plane0.w &&
				Vector3.Dot(lodBounds.center + lodBounds.extent.CMul(lodFrustum.plane1.Sign()), lodFrustum.plane1) > -lodFrustum.plane1.w &&
				Vector3.Dot(lodBounds.center + lodBounds.extent.CMul(lodFrustum.plane2.Sign()), lodFrustum.plane2) > -lodFrustum.plane2.w &&
				Vector3.Dot(lodBounds.center + lodBounds.extent.CMul(lodFrustum.plane3.Sign()), lodFrustum.plane3) > -lodFrustum.plane3.w &&
				Vector3.Dot(lodBounds.center + lodBounds.extent.CMul(lodFrustum.plane4.Sign()), lodFrustum.plane4) > -lodFrustum.plane4.w &&
				Vector3.Dot(lodBounds.center + lodBounds.extent.CMul(lodFrustum.plane5.Sign()), lodFrustum.plane5) > -lodFrustum.plane5.w
			);
		}

		public static float LODFrustumCoverage(in LODFrustum lodFrustum, float sampleDepth, float sampleSpan)
		{
			var sampleSpanSubpixelDepth = sampleSpan * lodFrustum.unitSpanSubpixelDepth;
			var sampleCoverage = sampleSpanSubpixelDepth / Mathf.Max(sampleDepth, lodFrustum.cameraNear);
			{
				return sampleCoverage;
			}
		}

		public static float LODFrustumCoverage(in LODFrustum lodFrustum, in Vector3 samplePosition, float sampleSpan)
		{
			var sampleDepth = Vector3.Dot(lodFrustum.cameraForward, samplePosition - lodFrustum.cameraPosition);
			{
				return LODFrustumCoverage(lodFrustum, sampleDepth, sampleSpan);
			}
		}

		public static Vector2 LODFrustumCoverageCeiling(in LODFrustum lodFrustum, in LODBounds lodBounds, in LODGeometry lodGeometry)
		{
			if (LODFrustumContains(lodFrustum, lodBounds))
			{
				var cameraVector = lodFrustum.cameraPosition - lodBounds.center;
				var cameraDistance = cameraVector.magnitude;

				var nearestSamplePosition = lodBounds.center + cameraVector * (Mathf.Min(cameraDistance, lodBounds.radius) / cameraDistance);
				var nearestSampleCoverage = new Vector2(
					LODFrustumCoverage(lodFrustum, nearestSamplePosition, lodGeometry.maxParticleDiameter),
					LODFrustumCoverage(lodFrustum, nearestSamplePosition, lodGeometry.maxParticleInterval)
				);

				//Debug.Log("checking cam: " + camera.ToString() + " => vis, coverage " + nearestSampleCoverage);
				return nearestSampleCoverage;
			}
			else
			{
				//Debug.Log("checking cam: " + camera.ToString() + " => hidden");
				return Vector2.zero;
			}
		}

		public static Vector2 LODFrustumCoverageCeilingSequential(CameraType cameraType, in LODBounds lodBounds, in LODGeometry lodGeometry)
		{
			var maxCoverage = Vector2.zero;
			{
				using (var lodFrustums = AcquireLODFrustums(cameraType, Allocator.Temp))
				{
					for (int i = 0; i != lodFrustums.Length; i++)
					{
						maxCoverage = Vector2.Max(maxCoverage, LODFrustumCoverageCeiling(lodFrustums[i], lodBounds, lodGeometry));
					}
				}
			}

			return maxCoverage;
		}

		public static float ResolveLODQuantity(float sampleCoverage, float lodCeiling, float lodScale, float lodBias)
		{
			float lodValue = Mathf.Clamp01(Mathf.Clamp01(sampleCoverage * lodScale) + lodBias);
			{
				return Mathf.Min(lodValue, lodCeiling);
			}
		}

		public static LODIndices ResolveLODIndices(float lodValue, NativeArray<float> lodThresholds, bool lodBlending)
		{
			var lodCount = lodThresholds.Length;
			var lodSearch = lodThresholds.BinarySearch(lodValue);
			var lodDesc = new LODIndices
			{
				lodIndexLo = 0,
				lodIndexHi = 0,
				lodBlendFrac = 0.0f,
				lodValue = lodValue,
			};
				
			if (lodSearch < 0)
			{
				lodSearch = ~lodSearch;
				lodDesc.lodIndexLo = (uint)Mathf.Max(0, lodSearch - 1);
				lodDesc.lodIndexHi = (uint)Mathf.Min(lodSearch, lodCount - 1);

				var lodValueLo = lodThresholds[(int)lodDesc.lodIndexLo];
				var lodValueHi = lodThresholds[(int)lodDesc.lodIndexHi];
				{
					lodDesc.lodBlendFrac = (lodValueLo != lodValueHi) ? Mathf.Clamp01((lodValue - lodValueLo) / (lodValueHi - lodValueLo)) : 0.0f;
				}
			}

			if (lodBlending)
			{
				//Debug.Log("LOD: " + lodSelection.lodIndexLo + " -> " + lodSelection.lodIndexHi + " (" + lodSelection.lodBlendFrac + ")");
			}
			else
			{
				lodDesc.lodIndexLo = (lodDesc.lodBlendFrac > 0.5f) ? lodDesc.lodIndexHi : lodDesc.lodIndexLo;
				lodDesc.lodIndexHi = lodDesc.lodIndexLo;
				lodDesc.lodBlendFrac = 0.0f;
				//Debug.Log("LOD: " + lodSelection.lodIndexLo + " (no blend)");
			}

			return lodDesc;
		}
	}
}
```

`Runtime/HairSim.LOD.cs.hlsl`:

```hlsl
//
// This file was automatically generated. Please don't edit by hand. Execute Editor command [ Edit > Rendering > Generate Shader Includes ] instead
//

#ifndef HAIRSIM_LOD_CS_HLSL
#define HAIRSIM_LOD_CS_HLSL
// Generated from Unity.DemoTeam.Hair.HairSim+LODBounds
// PackingRules = Exact
struct LODBounds
{
    float3 center;
    float3 extent;
    float radius;
    float reach;
};

// Generated from Unity.DemoTeam.Hair.HairSim+LODFrustum
// PackingRules = Exact
struct LODFrustum
{
    float3 cameraPosition;
    float3 cameraForward;
    float cameraNear;
    float unitSpanSubpixelDepth;
    float4 plane0;
    float4 plane1;
    float4 plane2;
    float4 plane3;
    float4 plane4;
    float4 plane5;
};

// Generated from Unity.DemoTeam.Hair.HairSim+LODGeometry
// PackingRules = Exact
struct LODGeometry
{
    float maxParticleDiameter;
    float maxParticleInterval;
};

// Generated from Unity.DemoTeam.Hair.HairSim+LODIndices
// PackingRules = Exact
struct LODIndices
{
    uint lodIndexLo;
    uint lodIndexHi;
    float lodBlendFrac;
    float lodValue;
};


#endif

```

`Runtime/HairSim.LOD.cs.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: 7a260ddcde39b424898f8b4015103927
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  preprocessorOverride: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSim.LOD.cs.meta`:

```meta
fileFormatVersion: 2
guid: 476b75f46467f184eb40cf0bbf7cdc1b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSim.Settings.cs`:

```cs
using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Serialization;

namespace Unity.DemoTeam.Hair
{
	public static partial class HairSim
	{
		[Serializable]
		public struct SettingsGeometry
		{
			public enum StrandScale
			{
				Fixed			= 0,
				UniformWorldMin	= 1,
				UniformWorldMax	= 2,
			}

			public enum BoundsMode
			{
				Automatic	= 0,
				Manual		= 1,
			}

			public enum StagingPrecision
			{
				Full	= 0,
				Half	= 1,
			}

			[LineHeader("Proportions")]

			public StrandScale strandScale;
			[ToggleGroup, Tooltip("Override strand length (otherwise supplied by group asset)")]
			public bool strandLength;
			[ToggleGroupItem, Range(0.001f, 5.0f), Tooltip("Strand length (in meters)")]
			public float strandLengthValue;
			[ToggleGroup, Tooltip("Override strand diameter (otherwise supplied by group asset)")]
			public bool strandDiameter;
			[ToggleGroupItem, Range(0.01f, 100.0f), Tooltip("Strand diameter (in millimeters)")]
			public float strandDiameterValue;
			[Range(0.0f, 100.0f), Tooltip("Strand separation margin (in millimeters)")]
			public float strandSeparation;

			[LineHeader("Tapering")]

			[ToggleGroup]
			public bool tipScale;
			[ToggleGroupItem, Range(0.0f, 1.0f)]
			public float tipScaleValue;
			[ToggleGroup]
			public bool tipScaleOffset;
			[ToggleGroupItem, Range(0.0f, 1.0f)]
			public float tipScaleOffsetValue;

			[LineHeader("Bounds")]

			public BoundsMode boundsMode;
			[VisibleIf(nameof(boundsMode), BoundsMode.Manual)]
			public Vector3 boundsCenter;
			[VisibleIf(nameof(boundsMode), BoundsMode.Manual)]
			public Vector3 boundsExtent;
			[ToggleGroup]
			public bool boundsScale;
			[ToggleGroupItem, Range(0.0f, 2.0f)]
			public float boundsScaleValue;

			[LineHeader("Staging")]

			public StagingPrecision stagingPrecision;
			[ToggleGroup]
			public bool stagingSubdivision;
			[ToggleGroupItem, Range(1, 10)]
			public uint stagingSubdivisionCount;

			public static readonly SettingsGeometry defaults = new SettingsGeometry()
			{
				strandScale = StrandScale.Fixed,
				strandDiameter = false,
				strandDiameterValue = HairAsset.SharedDefaults.defaultStrandDiameter,
				strandLength = false,
				strandLengthValue = HairAsset.SharedDefaults.defaultStrandLength,
				strandSeparation = 0.0f,

				tipScale = false,
				tipScaleValue = HairAsset.SharedDefaults.defaultTipScale,
				tipScaleOffset = false,
				tipScaleOffsetValue = HairAsset.SharedDefaults.defaultTipScaleOffset,

				boundsMode = BoundsMode.Automatic,
				boundsCenter = Vector3.zero,
				boundsExtent = Vector3.one,
				boundsScale = false,
				boundsScaleValue = 1.25f,

				stagingPrecision = StagingPrecision.Half,
				stagingSubdivision = false,
				stagingSubdivisionCount = 1,
			};
		}

		[Serializable]
		public struct SettingsPhysics
		{
			public enum Solver
			{
				GaussSeidelReference	= 0,
				GaussSeidel				= 1,
				Jacobi					= 2,
			}

			public enum TimeInterval
			{
				PerSecond	= 0,
				Per100ms	= 1,
				Per10ms		= 2,
				Per1ms		= 3,
			}

			public enum LocalCurvatureMode
			{
				Equals		= 0,
				LessThan	= 1,
				GreaterThan	= 2,
			}

			public enum LocalShapeMode
			{
				Forward		= 0,
				Stitched	= 1,
			}

			[LineHeader("Solver")]

			[Tooltip("Constraint solver")]
			public Solver solver;
			[Range(1, 12), Tooltip("Constraint solver substeps (number of invocations per time step)")]
			public uint solverSubsteps;
			[Range(1, 100), Tooltip("Constraint iterations")]
			public uint constraintIterations;
			[Range(0.0f, 1.0f), Tooltip("Constraint stiffness")]
			public float constraintStiffness;
			[Range(1.0f, 2.0f), Tooltip("Successive over-relaxation factor")]
			public float constraintSOR;

			[LineHeader("Forces")]

			[ToggleGroup, Tooltip("Enable linear damping")]
			public bool dampingLinear;
			[ToggleGroupItem, Range(0.0f, 1.0f), Tooltip("Linear damping factor (fraction of linear velocity to subtract per interval of time)")]
			public float dampingLinearFactor;
			[ToggleGroupItem, Tooltip("Interval of time over which to subtract fraction of linear velocity")]
			public TimeInterval dampingLinearInterval;

			[ToggleGroup, Tooltip("Enable angular damping")]
			public bool dampingAngular;
			[ToggleGroupItem, Range(0.0f, 1.0f), Tooltip("Angular damping factor (fraction of angular velocity to subtract per interval of time)")]
			public float dampingAngularFactor;
			[ToggleGroupItem, Tooltip("Interval of time over which to subtract fraction of angular velocity")]
			public TimeInterval dampingAngularInterval;

			[Range(0.0f, 1.0f), Tooltip("Scale factor for volume pressure impulse")]
			public float cellPressure;
			[Range(0.0f, 1.0f), Tooltip("Scale factor for volume velocity impulse (where 0 == FLIP, 1 == PIC)")]
			public float cellVelocity;
			[Range(0.0f, 1.0f), Tooltip("Scale factor for volume-accumulated external impulses (e.g. wind and drag)")]
			public float cellExternal;
			[Range(0.0f, 1.0f), Tooltip("Scale factor for volume gravity")]
			public float gravity;

			[LineHeader("Constraints")]

			[ToggleGroup, Tooltip("Enable boundary collision constraint")]
			public bool boundaryCollision;
			[ToggleGroupItem(withLabel = true), Range(0.0f, 1.0f), Tooltip("Boundary collision friction")]
			public float boundaryCollisionFriction;

			[Tooltip("Enable particle-particle distance constraint")]
			public bool distance;
			[Tooltip("Enable 'long range attachment' distance constraint (root-particle maximum distance)")]
			public bool distanceLRA;
			[ToggleGroup, Tooltip("Enable 'follow the leader' distance constraint (hard particle-particle distance, non-physical)")]
			public bool distanceFTL;
			[ToggleGroupItem(withLabel = true), Range(0.0f, 1.0f), Tooltip("FTL correction factor")]
			public float distanceFTLCorrection;

			[ToggleGroup, Tooltip("Enable bending curvature constraint")]
			public bool localCurvature;
			[ToggleGroupItem, Tooltip("Bending curvature constraint mode (=, <, >)")]
			public LocalCurvatureMode localCurvatureMode;
			[ToggleGroupItem, Range(0.0f, 1.0f), Tooltip("Scales to a bend of [0 .. 90] degrees")]
			public float localCurvatureValue;

			[ToggleGroup, Tooltip("Enable local shape constraint")]
			public bool localShape;
			[ToggleGroupItem, Tooltip("Local shape constraint application mode")]
			public LocalShapeMode localShapeMode;
			[ToggleGroupItem, Range(0.0f, 1.0f), Tooltip("Local shape constraint influence")]
			public float localShapeInfluence;
			[ToggleGroup, Tooltip("Enable local shape bias")]
			public bool localShapeBias;
			[ToggleGroupItem, Range(0.0f, 1.0f), Tooltip("Local shape bias (skews local solution towards global reference)")]
			public float localShapeBiasValue;

			[LineHeader("Reference")]

			[ToggleGroup, Tooltip("Enable global position constraint")]
			public bool globalPosition;
			[ToggleGroupItem, Range(0.0f, 1.0f), Tooltip("Fraction of global position to apply per interval of time")]
			public float globalPositionInfluence;
			[ToggleGroupItem, Tooltip("Interval of time over which to apply fraction of global position")]
			public TimeInterval globalPositionInterval;
			[ToggleGroup, Tooltip("Enable global rotation constraint")]
			public bool globalRotation;
			[ToggleGroupItem, Range(0.0f, 1.0f), Tooltip("Global rotation influence")]
			public float globalRotationInfluence;
			[ToggleGroup, Tooltip("Fade influence of global constraints from root to tip")]
			public bool globalFade;
			[ToggleGroupItem(withLabel = true), Range(0.0f, 1.0f), Tooltip("Normalized fade offset (normalized distance from root)")]
			public float globalFadeOffset;
			[ToggleGroupItem(withLabel = true), Range(0.0f, 1.0f), Tooltip("Normalized fade extent (normalized distance from specified offset)")]
			public float globalFadeExtent;

			[LineHeader("Solver LOD")]

			public SolverLODSelection kLODSelection;
			[VisibleIf(nameof(kLODSelection), SolverLODSelection.Manual), Range(0.0f, 1.0f)]
			public float kLODSelectionValue;
			[Range(0.0f, 1.0f)]
			public float kLODCeiling;
			[Range(0.0f, 4.0f)]
			public float kLODScale;
			[Range(-1.0f, 1.0f)]
			public float kLODBias;

			public static readonly SettingsPhysics defaults = new SettingsPhysics()
			{
				solver = Solver.GaussSeidel,
				solverSubsteps = 2,
				constraintIterations = 4,
				constraintStiffness = 0.8f,
				constraintSOR = 1.0f,

				dampingLinear = false,
				dampingLinearFactor = 0.5f,
				dampingLinearInterval = TimeInterval.PerSecond,
				dampingAngular = true,
				dampingAngularFactor = 0.5f,
				dampingAngularInterval = TimeInterval.PerSecond,
				cellPressure = 1.0f,
				cellVelocity = 0.05f,
				cellExternal = 1.0f,
				gravity = 1.0f,

				boundaryCollision = true,
				boundaryCollisionFriction = 0.5f,
				distance = true,
				distanceLRA = true,
				distanceFTL = false,
				distanceFTLCorrection = 0.8f,
				localCurvature = false,
				localCurvatureMode = LocalCurvatureMode.LessThan,
				localCurvatureValue = 0.1f,
				localShape = true,
				localShapeMode = LocalShapeMode.Stitched,
				localShapeInfluence = 1.0f,
				localShapeBias = true,
				localShapeBiasValue = 0.5f,

				globalPosition = false,
				globalPositionInfluence = 1.0f,
				globalPositionInterval = TimeInterval.PerSecond,
				globalRotation = false,
				globalRotationInfluence = 1.0f,
				globalFade = false,
				globalFadeOffset = 0.1f,
				globalFadeExtent = 0.2f,

				kLODSelection = SolverLODSelection.AutomaticPerGroup,
				kLODSelectionValue = 1.0f,
				kLODCeiling = 1.0f,
				kLODScale = 1.0f,
				kLODBias = 0.0f,
			};
		}

		[Serializable]
		public struct SettingsRendering
		{
			public enum Renderer
			{
				Disabled				= 0,
				BuiltinLines			= 1,
				BuiltinStrips			= 2,
				BuiltinTubes			= 3,
				HDRPHighQualityLines	= 4,
			}

			public enum ShadowSubstitute
			{
				BuiltinLines			= 0,
				BuiltinStrips			= 1,
				BuiltinTubes			= 2,
				//VolumeIsosurface		= 3,
				//VolumeTransmittance	= 4,
			}

			//[Flags]
			//public enum MaterialPermissions
			//{
			//	FreeLOD					= 1 << 1,
			//	FreeDiameter			= 1 << 0,
			//	UploadPerVertexUV		= 1 << 2,
			//	UploadPerVertexDiameter	= 1 << 3,
			//}

			//public enum PerVertexData
			//{
			//	Disregard		= 0,
			//	Upload			= 1,
			//	UploadAndApply	= 2,
			//}

			[LineHeader("Material")]

			[ToggleGroup]
			public bool material;
			[ToggleGroupItem]
			public Material materialAsset;

			//TODO maybe something like this, but an enum with just the optional streams + flags to specify if material intends to dilate?
			//public MaterialPermissions materialPermissions;

			//public PerVertexData perVertexUV;
			//public PerVertexData perVertexDiameter;

			[LineHeader("Renderer")]

			public Renderer renderer;
#if HAS_PACKAGE_UNITY_HDRP_15_0_2
			[VisibleIf(nameof(renderer), Renderer.HDRPHighQualityLines)]
			public LineRendering.RendererGroup rendererGroup;
#endif
			[RenderingLayerMask]
			public int rendererLayers;
			public ShadowCastingMode rendererShadows;
			[ToggleGroup]
			public bool shadowLayers;
			[ToggleGroupItem, RenderingLayerMask]
			public int shadowLayersValue;
			[ToggleGroup]
			public bool shadowSubstitute;
			[ToggleGroupItem]
			public ShadowSubstitute shadowSubstituteValue;
			public MotionVectorGenerationMode motionVectors;

			[LineHeader("Renderer Flags")]

			[Tooltip("Allow rendering via indirect draw (improves performance by shrinking work submitted to vertex stage according to LOD based upper bound)")]
			public bool allowIndirect;
			[EditableIf(nameof(allowIndirect), true), Tooltip("Allow rendering via indirect instanced draw (reduces memory footprint of topology data by instancing single warp-aware batch of strands)")]
			public bool allowInstancing;

			[LineHeader("Renderer LOD")]

			public RenderLODSelection kLODSelection;
			[VisibleIf(nameof(kLODSelection), (int)RenderLODSelection.Manual), Range(0.0f, 1.0f)]
			public float kLODSelectionValue;
			[Range(0.0f, 1.0f)]
			public float kLODCeiling;
			[Range(0.0f, 4.0f)]
			public float kLODScale;
			[Range(-1.0f, 1.0f)]
			public float kLODBias;
			[Range(0.0f, 1.0f)]
			public float clipThreshold;

			public static readonly SettingsRendering defaults = new SettingsRendering()
			{
				material = false,
				materialAsset = null,

				renderer = Renderer.BuiltinStrips,
#if HAS_PACKAGE_UNITY_HDRP_15_0_2
				rendererGroup = LineRendering.RendererGroup.None,
#endif
				rendererLayers = 0x0101,//TODO this is the HDRP default -- should decide based on active pipeline asset
				rendererShadows = ShadowCastingMode.On,
				shadowLayers = false,
				shadowLayersValue = 0x0101,//TODO this is the HDRP default -- should decide based on active pipeline asset
				shadowSubstitute = false,
				shadowSubstituteValue = ShadowSubstitute.BuiltinLines,
				motionVectors = MotionVectorGenerationMode.Object,

				allowIndirect = true,
				allowInstancing = true,

				kLODSelection = RenderLODSelection.AutomaticPerSegment,
				kLODSelectionValue = 1.0f,
				kLODCeiling = 1.0f,
				kLODScale = 1.0f,
				kLODBias = 0.0f,
				clipThreshold = 0.05f,
			};
		}

		[Serializable]
		public struct SettingsEnvironment
		{
			public enum EmitterCaptureMode
			{
				JustTagged			= 0,
				IncludeWindZones	= 1,
			}

			public enum BoundaryCaptureMode
			{
				JustTagged			= 0,
				IncludeColliders	= 1,
			}

			[LineHeader("Gravity")]

			[Range(-1.0f, 1.0f), Tooltip("Scale factor to apply to scene gravity (Physics.gravity)")]
			public float gravityScale;
			[Tooltip("Rotation to apply to scaled scene gravity")]
			public Quaternion gravityRotation;

			[LineHeader("Wind")]

			[ToggleGroup, Tooltip("Collect and transfer wind emitters (via physics overlap)")]
			public bool emitterCapture;
			[ToggleGroupItem, Tooltip("Collect just tagged emitters, or also include untagged wind zones")]
			public EmitterCaptureMode emitterCaptureMode;
			[ToggleGroupItem(withLabel = true)]
			public LayerMask emitterCaptureLayer;
			[NonReorderable, Tooltip("Always-included emitters (these take priority over emitters collected from scene)")]
			public HairWind[] emitterResident;

			[LineHeader("Solids")]

			[ToggleGroup, Tooltip("Collect and transfer solid boundaries (via physics overlap)")]
			public bool boundaryCapture;
			[ToggleGroupItem, Tooltip("Collect just tagged boundaries, or also include untagged colliders")]
			public BoundaryCaptureMode boundaryCaptureMode;
			[ToggleGroupItem(withLabel = true)]
			public LayerMask boundaryCaptureLayer;
			[NonReorderable, Tooltip("Always-included boundaries (these take priority over boundaries collected from physics)")]
			public HairBoundary[] boundaryResident;

			[Range(0.0f, 10.0f), Tooltip("Default solid margin (in centimeters)")]
			public float defaultSolidMargin;
			[Range(0.0f, 10.0f)]
			public float defaultSolidDensity;
			//[Range(0.0f, 1.0f), Tooltip("Default solid friction")]
			//public float defaultSolidFriction;

			//TODO => boundaryDefaults { collisionMargin, occlusionDensity, occlusionMargin }

			public static readonly SettingsEnvironment defaults = new SettingsEnvironment()
			{
				gravityScale = 1.0f,
				gravityRotation = Quaternion.identity,

				emitterCapture = true,
				emitterCaptureMode = EmitterCaptureMode.JustTagged,
				emitterCaptureLayer = Physics.AllLayers,
				emitterResident = new HairWind[0],

				boundaryCapture = true,
				boundaryCaptureMode = BoundaryCaptureMode.IncludeColliders,
				boundaryCaptureLayer = Physics.AllLayers,
				boundaryResident = new HairBoundary[0],

				defaultSolidMargin = 0.25f,
				defaultSolidDensity = 5.0f,
			};
		}

		[Serializable]
		public struct SettingsVolume
		{
			public enum GridPrecision
			{
				Full	= 0,
				Half	= 1,
			}

			public enum SplatMethod
			{
				None				= 0,
				Compute				= 1,
				ComputeSplit		= 2,
				Rasterization		= 3,
				RasterizationNoGS	= 4,
			}

			public enum PressureSolution
			{
				DensityEquals	= 0,
				DensityLessThan	= 1,
			}

			public enum RestDensity
			{
				Uniform					= 0,
				InitialPose				= 1,
				InitialPoseInParticles	= 2,
			}

			public enum OcclusionMode
			{
				Discrete	= 0,
				Exact		= 1,
			}

			[LineHeader("Transfer")]

			public GridPrecision gridPrecision;
			[Range(8, 160)]
			public uint gridResolution;
			[HideInInspector, Tooltip("Increases precision of derivative quantities at the cost of volume splatting performance")]
			public bool gridStaggered;
			public SplatMethod splatMethod;
			public bool splatClusters;

			[LineHeader("Pressure")]

			[Range(0, 100), Tooltip("Number of pressure solve iterations (where 0 == Initialization by EOS, [1 .. n] == Jacobi iteration)")]
			public uint pressureIterations;
			[Tooltip("Pressure solve can either target an exact density (causing both compression and decompression), or a maximum density (causing just decompression)")]
			public PressureSolution pressureSolution;
			[Tooltip("Target density can be uniform (based on physical strand diameter), based on the initial pose, or based on initial pose carried in particles (a runtime average)")]
			public RestDensity restDensity;
			[Min(0.01f)]
			public float restDensityScale;
			[Range(0.0f, 1.0f), Tooltip("Influence of rest density vs. an always-present incompressibility term")]
			public float restDensityInfluence;

			[LineHeader("Scattering")]

			[ToggleGroup]
			public bool scatteringProbe;
			[ToggleGroupItem(withLabel = true), Range(1, 10)]
			public uint scatteringProbeCellSubsteps;
			[Range(0.0f, 2.0f)]
			public float scatteringProbeBias;
			[Range(0, 20)]
			public uint probeSamplesTheta;
			[Range(0, 20)]
			public uint probeSamplesPhi;
			[ToggleGroup]
			public bool probeOcclusion;
			[ToggleGroupItem]
			public OcclusionMode probeOcclusionMode;
			[ToggleGroupItem(withLabel = true), Range(0.0f, 10.0f)]
			public float probeOcclusionSolidDensity;

			[LineHeader("Wind & Drag")]

			[ToggleGroup]
			public bool windPropagation;
			[ToggleGroupItem(withLabel = true), Range(1, 10)]
			public uint windPropagationCellSubsteps;
			[ToggleGroup]
			public bool windOcclusion;
			[ToggleGroupItem]
			public OcclusionMode windOcclusionMode;
			[Range(0.0f, 10.0f), Tooltip("Extinction distance in fully occupied volume (in centimeters)")]
			public float windDepth;

			public static readonly SettingsVolume defaults = new SettingsVolume()
			{
				gridResolution = 32,
				gridPrecision = GridPrecision.Full,
				gridStaggered = false,

				splatMethod = SplatMethod.Compute,
				splatClusters = true,

				pressureIterations = 5,
				pressureSolution = PressureSolution.DensityLessThan,
				restDensity = RestDensity.Uniform,
				restDensityScale = 1.0f,
				restDensityInfluence = 1.0f,

				scatteringProbe = false,
				scatteringProbeCellSubsteps = 1,
				scatteringProbeBias = 1.0f,
				probeSamplesTheta = 5,
				probeSamplesPhi = 10,
				probeOcclusion = true,
				probeOcclusionMode = OcclusionMode.Discrete,
				probeOcclusionSolidDensity = 5.0f,

				windPropagation = true,
				windPropagationCellSubsteps = 1,
				windOcclusion = true,
				windOcclusionMode = OcclusionMode.Exact,
				windDepth = 1.0f,
			};
		}

		[Serializable]
		public struct SettingsDebugging
		{
			[LineHeader("Strand Data")]

			public bool drawStrandRoots;
			public bool drawStrandParticles;
			public bool drawStrandVelocities;
			public bool drawStrandClusters;
			public int specificCluster;

			[LineHeader("Volume Cells")]

			public bool drawCellDensity;
			public bool drawCellGradient;
			[ToggleGroup]
			public bool drawIsosurface;
			[ToggleGroupItem(withLabel = true), Range(0.0f, 1.0f), Tooltip("Trace threshold")]
			public float drawIsosurfaceDensity;
			[ToggleGroupItem(withLabel = true), Range(1, 10), Tooltip("Substeps within each cell")]
			public uint drawIsosurfaceSubsteps;

			[LineHeader("Volume Slices")]

			[ToggleGroup]
			public bool drawSliceX;
			[ToggleGroupItem, Range(0.0f, 1.0f), Tooltip("Position of slice along X")]
			public float drawSliceXOffset;
			[ToggleGroup]
			public bool drawSliceY;
			[ToggleGroupItem, Range(0.0f, 1.0f), Tooltip("Position of slice along Y")]
			public float drawSliceYOffset;
			[ToggleGroup]
			public bool drawSliceZ;
			[ToggleGroupItem, Range(0.0f, 1.0f), Tooltip("Position of slice along Z")]
			public float drawSliceZOffset;
			[Range(0.0f, 7.0f), Tooltip("Scrubs between different layers")]
			public float drawSliceDivider;

			public static readonly SettingsDebugging defaults = new SettingsDebugging()
			{
				drawStrandRoots = false,
				drawStrandParticles = false,
				drawStrandVelocities = false,
				drawStrandClusters = false,
				specificCluster = -1,

				drawCellDensity = false,
				drawCellGradient = false,
				drawIsosurface = false,
				drawIsosurfaceDensity = 0.5f,
				drawIsosurfaceSubsteps = 4,

				drawSliceX = false,
				drawSliceXOffset = 0.5f,
				drawSliceY = false,
				drawSliceYOffset = 0.5f,
				drawSliceZ = false,
				drawSliceZOffset = 0.5f,
				drawSliceDivider = 0.0f,
			};
		}
	}
}
```

`Runtime/HairSim.Settings.cs.meta`:

```meta
fileFormatVersion: 2
guid: dbad34aaae33c9743a40630545d6baf5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSim.cs`:

```cs
#pragma warning disable 0162 // some parts will be unreachable due to branching on configuration constants
#pragma warning disable 0649 // some fields are assigned via reflection

//#define DEBUG_LOD_SELECTION
//#define DEBUG_LOD_SELECTION_POST

using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Serialization;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Profiling;
using Unity.Mathematics;

namespace Unity.DemoTeam.Hair
{
	using static HairSimUtility;

	public static partial class HairSim
	{
		static bool s_initialized = false;

		static ComputeShader s_solverCS;
		static Material s_solverRootsMat;

		static ComputeShader s_volumeCS;
		static Material s_volumeRasterMat;

		static Mesh s_debugDrawCube;
		static Material s_debugDrawMat;
		static MaterialPropertyBlock s_debugDrawPb;

		static RuntimeFlags s_runtimeFlags;

		[Flags]
		enum RuntimeFlags
		{
			None = 0,
			SupportsGeometryStage = 1 << 0,
			SupportsTextureAtomics = 1 << 1,// NOTE: needs to be in sync with HairSimData.hlsl (PLATFORM_SUPPORTS_TEXTURE_ATOMICS)
			SupportsVertexUAVWrites = 1 << 2,
		}

		static class MarkersCPU
		{
			public static ProfilerMarker Dummy;
		}

		static class MarkersGPU
		{
			public static ProfilingSampler Roots;
			public static ProfilingSampler Solver;
			public static ProfilingSampler Solver_SubstepScene;
			public static ProfilingSampler Solver_SolveConstraints;
			public static ProfilingSampler Solver_Interpolate;
			public static ProfilingSampler Solver_Staging;
			public static ProfilingSampler Volume;
			public static ProfilingSampler Volume_0_Clear;
			public static ProfilingSampler Volume_1_Splat;
			public static ProfilingSampler Volume_1_Splat_Density;
			public static ProfilingSampler Volume_1_Splat_VelocityXYZ;
			public static ProfilingSampler Volume_1_Splat_Rasterization;
			public static ProfilingSampler Volume_1_Splat_RasterizationNoGS;
			public static ProfilingSampler Volume_2_Resolve;
			public static ProfilingSampler Volume_2_ResolveRaster;
			public static ProfilingSampler Volume_3_Divergence;
			public static ProfilingSampler Volume_4_PressureEOS;
			public static ProfilingSampler Volume_5_PressureSolve;
			public static ProfilingSampler Volume_6_PressureGradient;
			public static ProfilingSampler Volume_7_Scattering;
			public static ProfilingSampler Volume_8_Wind;
			public static ProfilingSampler DrawSolverData;
			public static ProfilingSampler DrawVolumeData;
		}

		static class UniformIDs
		{
			// solver
			//TODO move into per-step cbuffer?
			public static int _SubstepFractionLo;
			public static int _SubstepFractionHi;

			// debug
			public static int _DebugCluster;
			public static int _DebugSliceAxis;
			public static int _DebugSliceOffset;
			public static int _DebugSliceDivider;
			public static int _DebugSliceOpacity;
			public static int _DebugIsosurfaceDensity;
			public static int _DebugIsosurfaceSubsteps;
		}

		static class SolverKernels
		{
			public static int KRoots;
			public static int KRootsHistory;
			public static int KRootsHistoryAdd;
			public static int KRootsSubstep;
			public static int KInitialize;
			public static int KInitializePostVolume;
			public static int KLODSelectionInit;
			public static int KLODSelection;
			public static int KLODSelectionPost;
			public static int KSolveConstraints_GaussSeidelReference;
			public static int KSolveConstraints_GaussSeidel;
			public static int KSolveConstraints_Jacobi_16;
			public static int KSolveConstraints_Jacobi_32;
			public static int KSolveConstraints_Jacobi_64;
			public static int KSolveConstraints_Jacobi_128;
			public static int KInterpolate;
			public static int KInterpolateAdd;
			public static int KInterpolatePromote;
			public static int KStaging;
			public static int KStagingSubdivision;
			public static int KStagingHistory;
			public static int KStagingHistoryAdd;
		}

		static class VolumeKernels
		{
			// bounds
			public static int KBoundsClear;
			public static int KBoundsGather;
			public static int KBoundsResolve;
			public static int KBoundsResolveCombined;
			public static int KBoundsHistory;
			public static int KBoundsCoverage;
			public static int KLODSelection;

			// grid
			public static int KVolumeClear;
			public static int KVolumeSplat;
			public static int KVolumeSplatDensity;
			public static int KVolumeSplatVelocityX;
			public static int KVolumeSplatVelocityY;
			public static int KVolumeSplatVelocityZ;
			public static int KVolumeResolve;
			public static int KVolumeResolveRaster;
			public static int KVolumeDivergence;
			public static int KVolumePressureEOS;
			public static int KVolumePressureSolve;
			public static int KVolumePressureGradient;
			public static int KVolumeScatteringPrep;
			public static int KVolumeScattering;
			public static int KVolumeWindPrep;
			public static int KVolumeWind;

			// scene
			public static int KBoundariesAdvance;
			public static int KBoundariesSubstep;
			public static int KEmittersAdvance;
			public static int KEmittersSubstep;
		}

		//TODO move to conf
		public const int THREAD_GROUP_SIZE = 64;

		//TODO move to conf
		public const int MIN_STRAND_COUNT = 64;
		public const int MAX_STRAND_COUNT = 64000;
		public const int MIN_STRAND_PARTICLE_COUNT = 3;
		public const int MAX_STRAND_PARTICLE_COUNT = 128;

		static HairSim()
		{
			if (s_initialized == false)
			{
				s_runtimeFlags = RuntimeFlags.None;
				{
					switch (SystemInfo.graphicsDeviceType)
					{
						case GraphicsDeviceType.Direct3D11:
						case GraphicsDeviceType.Direct3D12:
						case GraphicsDeviceType.Vulkan:
							s_runtimeFlags |= RuntimeFlags.SupportsGeometryStage;
							s_runtimeFlags |= RuntimeFlags.SupportsTextureAtomics;
							s_runtimeFlags |= RuntimeFlags.SupportsVertexUAVWrites;
							break;

						case GraphicsDeviceType.Metal:
							break;

						default:
							s_runtimeFlags |= RuntimeFlags.SupportsGeometryStage;
							s_runtimeFlags |= RuntimeFlags.SupportsTextureAtomics;
							break;
					}
				}

				var resources = HairSimResources.Load();
				{
					s_solverCS = resources.computeSolver;
					s_solverRootsMat = CoreUtils.CreateEngineMaterial(resources.computeRoots);

					s_volumeCS = resources.computeVolume;
					s_volumeRasterMat = CoreUtils.CreateEngineMaterial(resources.computeVolumeRaster);

					s_debugDrawCube = resources.debugDrawCube;
					s_debugDrawMat = CoreUtils.CreateEngineMaterial(resources.debugDraw);
					s_debugDrawPb = new MaterialPropertyBlock();
				}

				InitializeStructFields(ref SolverData.s_bufferIDs, (string s) => Shader.PropertyToID(s));
				InitializeStructFields(ref SolverData.s_textureIDs, (string s) => Shader.PropertyToID(s));
				InitializeStructFields(ref SolverData.s_externalIDs, (string s) => Shader.PropertyToID(s));

				InitializeStructFields(ref VolumeData.s_bufferIDs, (string s) => Shader.PropertyToID(s));
				InitializeStructFields(ref VolumeData.s_textureIDs, (string s) => Shader.PropertyToID(s));

				InitializeStaticFields(typeof(MarkersCPU), (string s) => new ProfilerMarker("HairSim." + s.Replace('_', '.')));
				InitializeStaticFields(typeof(MarkersGPU), (string s) => new ProfilingSampler("HairSim." + s.Replace('_', '.')));
				InitializeStaticFields(typeof(UniformIDs), (string s) => Shader.PropertyToID(s));

				InitializeStaticFields(typeof(SolverKernels), (string s) => s_solverCS.FindKernel(s));
				InitializeStaticFields(typeof(VolumeKernels), (string s) => s_volumeCS.FindKernel(s));

#if UNITY_EDITOR
				UnityEditor.AssemblyReloadEvents.beforeAssemblyReload += () =>
				{
					Material.DestroyImmediate(HairSim.s_solverRootsMat);
					Material.DestroyImmediate(HairSim.s_volumeRasterMat);
					Material.DestroyImmediate(HairSim.s_debugDrawMat);
				};
#endif

				s_initialized = true;
			}
		}

		public static bool PrepareSolverData(ref SolverData solverData, int strandCount, int strandParticleCount, int lodCount)
		{
			ref var solverBuffers = ref solverData.buffers;

			unsafe
			{
				bool changed = false;

				int particleCount = strandCount * strandParticleCount;
				int particleStrideIndex = sizeof(uint);
				int particleStrideScalar = sizeof(float);
				int particleStrideVector2 = sizeof(Vector2);
				int particleStrideVector3 = sizeof(Vector3);
				int particleStrideVector4 = sizeof(Vector4);

				changed |= CreateBuffer(ref solverBuffers.SolverCBufferRoots, "SolverCBufferRoots", 1, sizeof(SolverCBufferRoots), ComputeBufferType.Constant);
				changed |= CreateBuffer(ref solverBuffers.SolverCBuffer, "SolverCBuffer", 1, sizeof(SolverCBuffer), ComputeBufferType.Constant);

				changed |= CreateBuffer(ref solverBuffers._RootUV, "RootUV", strandCount, particleStrideVector2);
				changed |= CreateBuffer(ref solverBuffers._RootScale, "RootScale", strandCount, particleStrideVector4);

				changed |= CreateBuffer(ref solverBuffers._RootPositionNext, "RootPosition_0", strandCount, particleStrideVector4);
				changed |= CreateBuffer(ref solverBuffers._RootPositionPrev, "RootPosition_1", strandCount, particleStrideVector4);
				changed |= CreateBuffer(ref solverBuffers._RootPosition, "RootPosition_2", strandCount, particleStrideVector4);
				changed |= CreateBuffer(ref solverBuffers._RootFrameNext, "RootFrame_0", strandCount, particleStrideVector4);
				changed |= CreateBuffer(ref solverBuffers._RootFramePrev, "RootFrame_1", strandCount, particleStrideVector4);
				changed |= CreateBuffer(ref solverBuffers._RootFrame, "RootFrame_2", strandCount, particleStrideVector4);

				changed |= CreateBuffer(ref solverBuffers._SolverLODStage, "SolverLODStage", (int)SolverLODStage.__COUNT, sizeof(LODIndices));
				changed |= CreateBuffer(ref solverBuffers._SolverLODRange, "SolverLODRange", (int)SolverLODRange.__COUNT, particleStrideVector2);
				changed |= CreateBuffer(ref solverBuffers._SolverLODDispatch, "SolverLODDispatch", (int)SolverLODDispatch.__COUNT * 4, sizeof(uint), ComputeBufferType.IndirectArguments);
				changed |= CreateBuffer(ref solverBuffers._SolverLODTopology, "SolverLODTopology", (int)SolverLODTopology.__COUNT * 5, sizeof(uint), ComputeBufferType.IndirectArguments);

				changed |= CreateBuffer(ref solverBuffers._InitialParticleOffset, "InitialParticleOffset", particleCount, particleStrideVector4);
				changed |= CreateBuffer(ref solverBuffers._InitialParticleFrameDelta, "InitialParticleFrameDelta", particleCount, particleStrideVector4);
				changed |= CreateBuffer(ref solverBuffers._InitialParticleFrameDelta16, "InitialParticleFrameDelta16", particleCount, particleStrideVector2);

				changed |= CreateBuffer(ref solverBuffers._ParticlePosition, "ParticlePosition_0", particleCount, particleStrideVector3);
				changed |= CreateBuffer(ref solverBuffers._ParticlePositionPrev, "ParticlePosition_1", particleCount, particleStrideVector3);
				changed |= CreateBuffer(ref solverBuffers._ParticlePositionPrevPrev, "ParticlePosition_2", (Conf.SECOND_ORDER_UPDATE != 0) ? particleCount : 1, particleStrideVector3);
				changed |= CreateBuffer(ref solverBuffers._ParticleVelocity, "ParticleVelocity_0", particleCount, particleStrideVector3);
				changed |= CreateBuffer(ref solverBuffers._ParticleVelocityPrev, "ParticleVelocity_1", (Conf.SECOND_ORDER_UPDATE != 0) ? particleCount : 1, particleStrideVector3);

				changed |= CreateBuffer(ref solverBuffers._LODGuideCount, "LODGuideCount", Mathf.Max(1, lodCount), particleStrideIndex);
				changed |= CreateBuffer(ref solverBuffers._LODGuideIndex, "LODGuideIndex", Mathf.Max(1, lodCount) * strandCount, particleStrideIndex);
				changed |= CreateBuffer(ref solverBuffers._LODGuideCarry, "LODGuideCarry", Mathf.Max(1, lodCount) * strandCount, particleStrideScalar);
				changed |= CreateBuffer(ref solverBuffers._LODGuideReach, "LODGuideReach", Mathf.Max(1, lodCount) * strandCount, particleStrideScalar);

				CreateReadbackBuffer(ref solverData.buffersReadback._SolverLODStage, solverBuffers._SolverLODStage);
#if DEBUG_LOD_SELECTION
				CreateReadbackBuffer(ref solverData.buffersReadback._SolverLODRange, solverBuffers._SolverLODRange);
				CreateReadbackBuffer(ref solverData.buffersReadback._SolverLODDispatch, solverBuffers._SolverLODDispatch);
				CreateReadbackBuffer(ref solverData.buffersReadback._SolverLODTopology, solverBuffers._SolverLODTopology);
#endif

				return changed;
			}
		}

		public static bool PrepareVolumeData(ref VolumeData volumeData, in SettingsVolume settingsVolume, int boundsCount)
		{
			ref var volumeBuffers = ref volumeData.buffers;
			ref var volumeTextures = ref volumeData.textures;

			unsafe
			{
				bool changed = false;

				int particleStrideVector2 = sizeof(Vector2);
				int particleStrideVector3 = sizeof(Vector3);

				var cellCount = (int)settingsVolume.gridResolution;
				var cellPrecision = settingsVolume.gridPrecision;
				var cellFormatScalar = (cellPrecision == SettingsVolume.GridPrecision.Half) ? RenderTextureFormat.RHalf : RenderTextureFormat.RFloat;
				var cellFormatVector = (cellPrecision == SettingsVolume.GridPrecision.Half) ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.ARGBFloat;
				var cellAccuFormat = GraphicsFormat.R32_SInt;//TODO switch to R16_SInt ?
				var cellAccuStride = 4;// num. bytes

				changed |= CreateBuffer(ref volumeBuffers.VolumeCBufferEnvironment, "VolumeCBufferEnvironment", 1, sizeof(VolumeCBufferEnvironment), ComputeBufferType.Constant);
				changed |= CreateBuffer(ref volumeBuffers.VolumeCBuffer, "VolumeCBuffer", 1, sizeof(VolumeCBuffer), ComputeBufferType.Constant);

				changed |= CreateBuffer(ref volumeBuffers._LODFrustum, "LODFrustum", Conf.MAX_FRUSTUMS, sizeof(LODFrustum));

				changed |= CreateBuffer(ref volumeBuffers._BoundaryMatrixNext, "BoundaryMatrixNext", Conf.MAX_BOUNDARIES, sizeof(Matrix4x4));
				changed |= CreateBuffer(ref volumeBuffers._BoundaryMatrixPrevA, "BoundaryMatrixPrevA", Conf.MAX_BOUNDARIES, sizeof(Matrix4x4));
				changed |= CreateBuffer(ref volumeBuffers._BoundaryMatrixPrevQ, "BoundaryMatrixPrevQ", Conf.MAX_BOUNDARIES, sizeof(Quaternion));
				changed |= CreateBuffer(ref volumeBuffers._BoundaryMatrix, "BoundaryMatrix", Conf.MAX_BOUNDARIES, sizeof(Matrix4x4));
				changed |= CreateBuffer(ref volumeBuffers._BoundaryMatrixInv, "BoundaryMatrixInv", Conf.MAX_BOUNDARIES, sizeof(Matrix4x4));
				changed |= CreateBuffer(ref volumeBuffers._BoundaryMatrixInvStep, "BoundaryMatrixInvStep", Conf.MAX_BOUNDARIES, sizeof(Matrix4x4));
				changed |= CreateBuffer(ref volumeBuffers._BoundaryShapeNext, "BoundaryShapeNext", Conf.MAX_BOUNDARIES, sizeof(HairBoundary.RuntimeShape.Data));
				changed |= CreateBuffer(ref volumeBuffers._BoundaryShapePrevLUT, "BoundaryShapePrevLUT", Conf.MAX_BOUNDARIES, sizeof(int));
				changed |= CreateBuffer(ref volumeBuffers._BoundaryShapePrev, "BoundaryShapePrev", Conf.MAX_BOUNDARIES, sizeof(HairBoundary.RuntimeShape.Data));
				changed |= CreateBuffer(ref volumeBuffers._BoundaryShape, "BoundaryShape", Conf.MAX_BOUNDARIES, sizeof(HairBoundary.RuntimeShape.Data));

				changed |= CreateBuffer(ref volumeBuffers._WindEmitterNext, "WindEmitterNext", Conf.MAX_EMITTERS, sizeof(HairWind.RuntimeEmitter));
				changed |= CreateBuffer(ref volumeBuffers._WindEmitterPrevLUT, "WindEmitterPrevLUT", Conf.MAX_EMITTERS, sizeof(int));
				changed |= CreateBuffer(ref volumeBuffers._WindEmitterPrev, "WindEmitterPrev", Conf.MAX_EMITTERS, sizeof(HairWind.RuntimeEmitter));
				changed |= CreateBuffer(ref volumeBuffers._WindEmitter, "WindEmitter", Conf.MAX_EMITTERS, sizeof(HairWind.RuntimeEmitter));

				changed |= CreateBuffer(ref volumeBuffers._BoundsMinMaxU, "BoundsMinMaxU", boundsCount * 2, particleStrideVector3);
				changed |= CreateBuffer(ref volumeBuffers._BoundsPrev, "BoundsPrev", boundsCount, sizeof(LODBounds));
				changed |= CreateBuffer(ref volumeBuffers._Bounds, "Bounds", boundsCount, sizeof(LODBounds));

				changed |= CreateBuffer(ref volumeBuffers._BoundsGeometry, "BoundsGeometry", boundsCount, sizeof(LODGeometry));
				changed |= CreateBuffer(ref volumeBuffers._BoundsCoverage, "BoundsCoverage", boundsCount, particleStrideVector2);

				changed |= CreateBuffer(ref volumeBuffers._VolumeLODStage, "VolumeLODStage", (int)VolumeLODStage.__COUNT, sizeof(VolumeLODGrid));
				changed |= CreateBuffer(ref volumeBuffers._VolumeLODDispatch, "VolumeLODDispatch", (int)VolumeLODDispatch.__COUNT * 4, sizeof(uint), ComputeBufferType.IndirectArguments);

				if (s_runtimeFlags.HasFlag(RuntimeFlags.SupportsTextureAtomics))
				{
					changed |= CreateVolume(ref volumeTextures._AccuWeight, "AccuWeight", cellCount, cellAccuFormat);
					changed |= CreateVolume(ref volumeTextures._AccuWeight0, "AccuWeight0", cellCount, cellAccuFormat);
					changed |= CreateVolume(ref volumeTextures._AccuVelocityX, "AccuVelocityX", cellCount, cellAccuFormat);
					changed |= CreateVolume(ref volumeTextures._AccuVelocityY, "AccuVelocityY", cellCount, cellAccuFormat);
					changed |= CreateVolume(ref volumeTextures._AccuVelocityZ, "AccuVelocityZ", cellCount, cellAccuFormat);
				}
				else
				{
					int cellCountTotal = cellCount * cellCount * cellCount;

					changed |= CreateBuffer(ref volumeBuffers._AccuWeightBuffer, "AccuWeight", cellCountTotal, cellAccuStride);
					changed |= CreateBuffer(ref volumeBuffers._AccuWeight0Buffer, "AccuWeight0", cellCountTotal, cellAccuStride);
					changed |= CreateBuffer(ref volumeBuffers._AccuVelocityXBuffer, "AccuVelocityX", cellCountTotal, cellAccuStride);
					changed |= CreateBuffer(ref volumeBuffers._AccuVelocityYBuffer, "AccuVelocityY", cellCountTotal, cellAccuStride);
					changed |= CreateBuffer(ref volumeBuffers._AccuVelocityZBuffer, "AccuVelocityZ", cellCountTotal, cellAccuStride);
				}

				changed |= CreateVolume(ref volumeTextures._VolumeDensity, "VolumeDensity", cellCount, cellFormatScalar);
				changed |= CreateVolume(ref volumeTextures._VolumeDensity0, "VolumeDensity0", cellCount, cellFormatScalar);
				changed |= CreateVolume(ref volumeTextures._VolumeVelocity, "VolumeVelocity", cellCount, cellFormatVector);

				changed |= CreateVolume(ref volumeTextures._VolumeDivergence, "VolumeDivergence", cellCount, cellFormatScalar);
				changed |= CreateVolume(ref volumeTextures._VolumePressure, "VolumePressure_0", cellCount, cellFormatScalar);
				changed |= CreateVolume(ref volumeTextures._VolumePressureNext, "VolumePressure_1", cellCount, cellFormatScalar);
				changed |= CreateVolume(ref volumeTextures._VolumePressureGrad, "VolumePressureGrad", cellCount, cellFormatVector);

				changed |= CreateVolume(ref volumeTextures._VolumeScattering, "VolumeScattering", cellCount, cellFormatVector);
				changed |= CreateVolume(ref volumeTextures._VolumeImpulse, "VolumeImpulse", cellCount, cellFormatVector);

				changed |= CreateVolume(ref volumeTextures._BoundarySDF_undefined, "BoundarySDF_undefined", 1, RenderTextureFormat.RHalf);

				CreateReadbackBuffer(ref volumeData.buffersReadback._Bounds, volumeBuffers._Bounds);
				CreateReadbackBuffer(ref volumeData.buffersReadback._BoundsCoverage, volumeBuffers._BoundsCoverage);
				CreateReadbackBuffer(ref volumeData.buffersReadback._VolumeLODStage, volumeBuffers._VolumeLODStage);
				//CreateReadbackBuffer(ref volumeData.buffersReadback._WindEmitter, volumeBuffers._WindEmitter);

				return changed;
			}
		}

		public static void ReleaseSolverData(ref SolverData solverData)
		{
			ref var solverBuffers = ref solverData.buffers;

			ReleaseBuffer(ref solverBuffers.SolverCBuffer);
			ReleaseBuffer(ref solverBuffers.SolverCBufferRoots);

			ReleaseBuffer(ref solverBuffers._RootUV);
			ReleaseBuffer(ref solverBuffers._RootScale);

			ReleaseBuffer(ref solverBuffers._RootPositionNext);
			ReleaseBuffer(ref solverBuffers._RootPositionPrev);
			ReleaseBuffer(ref solverBuffers._RootPosition);
			ReleaseBuffer(ref solverBuffers._RootFrameNext);
			ReleaseBuffer(ref solverBuffers._RootFramePrev);
			ReleaseBuffer(ref solverBuffers._RootFrame);

			ReleaseBuffer(ref solverBuffers._SolverLODStage);
			ReleaseBuffer(ref solverBuffers._SolverLODRange);
			ReleaseBuffer(ref solverBuffers._SolverLODDispatch);
			ReleaseBuffer(ref solverBuffers._SolverLODTopology);

			ReleaseBuffer(ref solverBuffers._InitialParticleOffset);
			ReleaseBuffer(ref solverBuffers._InitialParticleFrameDelta);
			ReleaseBuffer(ref solverBuffers._InitialParticleFrameDelta16);

			ReleaseBuffer(ref solverBuffers._ParticlePosition);
			ReleaseBuffer(ref solverBuffers._ParticlePositionPrev);
			ReleaseBuffer(ref solverBuffers._ParticlePositionPrevPrev);
			ReleaseBuffer(ref solverBuffers._ParticleVelocity);
			ReleaseBuffer(ref solverBuffers._ParticleVelocityPrev);
			ReleaseBuffer(ref solverBuffers._ParticleCorrection);

			ReleaseBuffer(ref solverBuffers._ParticleOptTexCoord);
			ReleaseBuffer(ref solverBuffers._ParticleOptDiameter);

			ReleaseBuffer(ref solverBuffers._LODGuideCount);
			ReleaseBuffer(ref solverBuffers._LODGuideIndex);
			ReleaseBuffer(ref solverBuffers._LODGuideCarry);
			ReleaseBuffer(ref solverBuffers._LODGuideReach);

			ReleaseBuffer(ref solverBuffers._StagingVertex);
			ReleaseBuffer(ref solverBuffers._StagingVertexPrev);

			ReleaseReadbackBuffer(ref solverData.buffersReadback._SolverLODStage);
#if DEBUG_LOD_SELECTION
			ReleaseReadbackBuffer(ref solverData.buffersReadback._SolverLODRange);
			ReleaseReadbackBuffer(ref solverData.buffersReadback._SolverLODDispatch);
			ReleaseReadbackBuffer(ref solverData.buffersReadback._SolverLODTopology);
#endif

			if (solverData.lodThreshold.IsCreated)
				solverData.lodThreshold.Dispose();

			solverData = new SolverData();
		}

		public static void ReleaseVolumeData(ref VolumeData volumeData)
		{
			ref var volumeBuffers = ref volumeData.buffers;
			ref var volumeTextures = ref volumeData.textures;

			ReleaseBuffer(ref volumeBuffers.VolumeCBuffer);
			ReleaseBuffer(ref volumeBuffers.VolumeCBufferEnvironment);

			ReleaseBuffer(ref volumeBuffers._LODFrustum);

			ReleaseBuffer(ref volumeBuffers._BoundaryMatrixNext);
			ReleaseBuffer(ref volumeBuffers._BoundaryMatrixPrevA);
			ReleaseBuffer(ref volumeBuffers._BoundaryMatrixPrevQ);
			ReleaseBuffer(ref volumeBuffers._BoundaryMatrix);
			ReleaseBuffer(ref volumeBuffers._BoundaryMatrixInv);
			ReleaseBuffer(ref volumeBuffers._BoundaryMatrixInvStep);
			ReleaseBuffer(ref volumeBuffers._BoundaryShapeNext);
			ReleaseBuffer(ref volumeBuffers._BoundaryShapePrevLUT);
			ReleaseBuffer(ref volumeBuffers._BoundaryShapePrev);
			ReleaseBuffer(ref volumeBuffers._BoundaryShape);

			ReleaseBuffer(ref volumeBuffers._WindEmitterNext);
			ReleaseBuffer(ref volumeBuffers._WindEmitterPrevLUT);
			ReleaseBuffer(ref volumeBuffers._WindEmitterPrev);
			ReleaseBuffer(ref volumeBuffers._WindEmitter);

			ReleaseBuffer(ref volumeBuffers._BoundsMinMaxU);
			ReleaseBuffer(ref volumeBuffers._BoundsPrev);
			ReleaseBuffer(ref volumeBuffers._Bounds);
			ReleaseBuffer(ref volumeBuffers._BoundsGeometry);
			ReleaseBuffer(ref volumeBuffers._BoundsCoverage);

			ReleaseBuffer(ref volumeBuffers._VolumeLODStage);
			ReleaseBuffer(ref volumeBuffers._VolumeLODDispatch);

			ReleaseBuffer(ref volumeBuffers._AccuWeightBuffer);
			ReleaseBuffer(ref volumeBuffers._AccuWeight0Buffer);
			ReleaseBuffer(ref volumeBuffers._AccuVelocityXBuffer);
			ReleaseBuffer(ref volumeBuffers._AccuVelocityYBuffer);
			ReleaseBuffer(ref volumeBuffers._AccuVelocityZBuffer);

			ReleaseVolume(ref volumeTextures._AccuWeight);
			ReleaseVolume(ref volumeTextures._AccuWeight0);
			ReleaseVolume(ref volumeTextures._AccuVelocityX);
			ReleaseVolume(ref volumeTextures._AccuVelocityY);
			ReleaseVolume(ref volumeTextures._AccuVelocityZ);

			ReleaseVolume(ref volumeTextures._VolumeDensity);
			ReleaseVolume(ref volumeTextures._VolumeDensity0);
			ReleaseVolume(ref volumeTextures._VolumeVelocity);

			ReleaseVolume(ref volumeTextures._VolumeDivergence);
			ReleaseVolume(ref volumeTextures._VolumePressure);
			ReleaseVolume(ref volumeTextures._VolumePressureNext);
			ReleaseVolume(ref volumeTextures._VolumePressureGrad);

			ReleaseVolume(ref volumeTextures._VolumeScattering);
			ReleaseVolume(ref volumeTextures._VolumeImpulse);

			ReleaseVolume(ref volumeTextures._BoundarySDF_undefined);

			ReleaseReadbackBuffer(ref volumeData.buffersReadback._Bounds);
			ReleaseReadbackBuffer(ref volumeData.buffersReadback._BoundsCoverage);
			ReleaseReadbackBuffer(ref volumeData.buffersReadback._VolumeLODStage);
			//ReleaseReadbackBuffer(ref volumeData.buffersReadback._WindEmitter);

			ReleaseCPUBuffer(ref volumeData.boundaryPrevHandle);
			ReleaseCPUBuffer(ref volumeData.boundaryPrevMatrix);
			ReleaseCPUBuffer(ref volumeData.emitterPrevHandle);

			volumeData = new VolumeData();
		}

		public static void BindSolverData(Material mat, in SolverData solverData) => BindSolverData(new BindTargetMaterial(mat), solverData);
		public static void BindSolverData(CommandBuffer cmd, in SolverData solverData) => BindSolverData(new BindTargetGlobalCmd(cmd), solverData);
		public static void BindSolverData(CommandBuffer cmd, ComputeShader cs, int kernel, in SolverData solverData) => BindSolverData(new BindTargetComputeCmd(cmd, cs, kernel), solverData);
		public static void BindSolverData<T>(T target, in SolverData solverData) where T : IBindTarget
		{
			ref readonly var solverBuffers = ref solverData.buffers;
			ref readonly var solverKeywords = ref solverData.keywords;

			target.BindConstantBuffer(SolverData.s_bufferIDs.SolverCBufferRoots, solverBuffers.SolverCBufferRoots);
			target.BindConstantBuffer(SolverData.s_bufferIDs.SolverCBuffer, solverBuffers.SolverCBuffer);

			target.BindComputeBuffer(SolverData.s_bufferIDs._RootUV, solverBuffers._RootUV);
			target.BindComputeBuffer(SolverData.s_bufferIDs._RootScale, solverBuffers._RootScale);

			target.BindComputeBuffer(SolverData.s_bufferIDs._RootPositionNext, solverBuffers._RootPositionNext);
			target.BindComputeBuffer(SolverData.s_bufferIDs._RootPositionPrev, solverBuffers._RootPositionPrev);
			target.BindComputeBuffer(SolverData.s_bufferIDs._RootPosition, solverBuffers._RootPosition);
			target.BindComputeBuffer(SolverData.s_bufferIDs._RootFrameNext, solverBuffers._RootFrameNext);
			target.BindComputeBuffer(SolverData.s_bufferIDs._RootFramePrev, solverBuffers._RootFramePrev);
			target.BindComputeBuffer(SolverData.s_bufferIDs._RootFrame, solverBuffers._RootFrame);

			target.BindComputeBuffer(SolverData.s_bufferIDs._InitialParticleOffset, solverBuffers._InitialParticleOffset);
			target.BindComputeBuffer(SolverData.s_bufferIDs._InitialParticleFrameDelta, solverBuffers._InitialParticleFrameDelta);
			target.BindComputeBuffer(SolverData.s_bufferIDs._InitialParticleFrameDelta16, solverBuffers._InitialParticleFrameDelta16);

			target.BindComputeBuffer(SolverData.s_bufferIDs._SolverLODStage, solverBuffers._SolverLODStage);
			target.BindComputeBuffer(SolverData.s_bufferIDs._SolverLODRange, solverBuffers._SolverLODRange);
			target.BindComputeBuffer(SolverData.s_bufferIDs._SolverLODDispatch, solverBuffers._SolverLODDispatch);
			target.BindComputeBuffer(SolverData.s_bufferIDs._SolverLODTopology, solverBuffers._SolverLODTopology);

			target.BindComputeBuffer(SolverData.s_bufferIDs._ParticlePosition, solverBuffers._ParticlePosition);
			target.BindComputeBuffer(SolverData.s_bufferIDs._ParticlePositionPrev, solverBuffers._ParticlePositionPrev);
			target.BindComputeBuffer(SolverData.s_bufferIDs._ParticlePositionPrevPrev, solverBuffers._ParticlePositionPrevPrev);
			target.BindComputeBuffer(SolverData.s_bufferIDs._ParticleVelocity, solverBuffers._ParticleVelocity);
			target.BindComputeBuffer(SolverData.s_bufferIDs._ParticleVelocityPrev, solverBuffers._ParticleVelocityPrev);
			target.BindComputeBuffer(SolverData.s_bufferIDs._ParticleCorrection, solverBuffers._ParticleCorrection);

			target.BindComputeBuffer(SolverData.s_bufferIDs._ParticleOptTexCoord, solverBuffers._ParticleOptTexCoord);
			target.BindComputeBuffer(SolverData.s_bufferIDs._ParticleOptDiameter, solverBuffers._ParticleOptDiameter);

			target.BindComputeBuffer(SolverData.s_bufferIDs._LODGuideCount, solverBuffers._LODGuideCount);
			target.BindComputeBuffer(SolverData.s_bufferIDs._LODGuideIndex, solverBuffers._LODGuideIndex);
			target.BindComputeBuffer(SolverData.s_bufferIDs._LODGuideCarry, solverBuffers._LODGuideCarry);
			target.BindComputeBuffer(SolverData.s_bufferIDs._LODGuideReach, solverBuffers._LODGuideReach);

			target.BindComputeBuffer(SolverData.s_bufferIDs._StagingVertex, solverBuffers._StagingVertex);
			target.BindComputeBuffer(SolverData.s_bufferIDs._StagingVertexPrev, solverBuffers._StagingVertexPrev);

			target.BindKeyword("LAYOUT_INTERLEAVED", solverKeywords.LAYOUT_INTERLEAVED);
			target.BindKeyword("LIVE_POSITIONS_3", solverKeywords.LIVE_POSITIONS_3);
			target.BindKeyword("LIVE_POSITIONS_2", solverKeywords.LIVE_POSITIONS_2);
			target.BindKeyword("LIVE_POSITIONS_1", solverKeywords.LIVE_POSITIONS_1);
			target.BindKeyword("LIVE_ROTATIONS_2", solverKeywords.LIVE_ROTATIONS_2);
		}

		public static void BindVolumeData(Material mat, in VolumeData volumeData) => BindVolumeData(new BindTargetMaterial(mat), volumeData);
		public static void BindVolumeData(CommandBuffer cmd, VolumeData volumeData) => BindVolumeData(new BindTargetGlobalCmd(cmd), volumeData);
		public static void BindVolumeData(CommandBuffer cmd, ComputeShader cs, int kernel, in VolumeData volumeData) => BindVolumeData(new BindTargetComputeCmd(cmd, cs, kernel), volumeData);
		public static void BindVolumeData<T>(T target, in VolumeData volumeData) where T : IBindTarget
		{
			ref readonly var volumeBuffers = ref volumeData.buffers;
			ref readonly var volumeTextures = ref volumeData.textures;
			ref readonly var volumeKeywords = ref volumeData.keywords;

			ref readonly var volumeBufferIDs = ref VolumeData.s_bufferIDs;
			ref readonly var volumeTextureIDs = ref VolumeData.s_textureIDs;

			target.BindConstantBuffer(volumeBufferIDs.VolumeCBuffer, volumeBuffers.VolumeCBuffer);
			target.BindConstantBuffer(volumeBufferIDs.VolumeCBufferEnvironment, volumeBuffers.VolumeCBufferEnvironment);

			target.BindComputeBuffer(volumeBufferIDs._LODFrustum, volumeBuffers._LODFrustum);

			target.BindComputeBuffer(volumeBufferIDs._BoundaryMatrixNext, volumeBuffers._BoundaryMatrixNext);
			target.BindComputeBuffer(volumeBufferIDs._BoundaryMatrixPrevA, volumeBuffers._BoundaryMatrixPrevA);
			target.BindComputeBuffer(volumeBufferIDs._BoundaryMatrixPrevQ, volumeBuffers._BoundaryMatrixPrevQ);
			target.BindComputeBuffer(volumeBufferIDs._BoundaryMatrix, volumeBuffers._BoundaryMatrix);
			target.BindComputeBuffer(volumeBufferIDs._BoundaryMatrixInv, volumeBuffers._BoundaryMatrixInv);
			target.BindComputeBuffer(volumeBufferIDs._BoundaryMatrixInvStep, volumeBuffers._BoundaryMatrixInvStep);
			target.BindComputeBuffer(volumeBufferIDs._BoundaryShapeNext, volumeBuffers._BoundaryShapeNext);
			target.BindComputeBuffer(volumeBufferIDs._BoundaryShapePrevLUT, volumeBuffers._BoundaryShapePrevLUT);
			target.BindComputeBuffer(volumeBufferIDs._BoundaryShapePrev, volumeBuffers._BoundaryShapePrev);
			target.BindComputeBuffer(volumeBufferIDs._BoundaryShape, volumeBuffers._BoundaryShape);

			target.BindComputeBuffer(volumeBufferIDs._WindEmitterNext, volumeBuffers._WindEmitterNext);
			target.BindComputeBuffer(volumeBufferIDs._WindEmitterPrevLUT, volumeBuffers._WindEmitterPrevLUT);
			target.BindComputeBuffer(volumeBufferIDs._WindEmitterPrev, volumeBuffers._WindEmitterPrev);
			target.BindComputeBuffer(volumeBufferIDs._WindEmitter, volumeBuffers._WindEmitter);

			target.BindComputeBuffer(volumeBufferIDs._BoundsMinMaxU, volumeBuffers._BoundsMinMaxU);
			target.BindComputeBuffer(volumeBufferIDs._BoundsPrev, volumeBuffers._BoundsPrev);
			target.BindComputeBuffer(volumeBufferIDs._Bounds, volumeBuffers._Bounds);
			target.BindComputeBuffer(volumeBufferIDs._BoundsGeometry, volumeBuffers._BoundsGeometry);
			target.BindComputeBuffer(volumeBufferIDs._BoundsCoverage, volumeBuffers._BoundsCoverage);

			target.BindComputeBuffer(volumeBufferIDs._VolumeLODStage, volumeBuffers._VolumeLODStage);
			target.BindComputeBuffer(volumeBufferIDs._VolumeLODDispatch, volumeBuffers._VolumeLODDispatch);

			if (s_runtimeFlags.HasFlag(RuntimeFlags.SupportsTextureAtomics))
			{
				target.BindComputeTexture(volumeTextureIDs._AccuWeight, volumeTextures._AccuWeight);
				target.BindComputeTexture(volumeTextureIDs._AccuWeight0, volumeTextures._AccuWeight0);
				target.BindComputeTexture(volumeTextureIDs._AccuVelocityX, volumeTextures._AccuVelocityX);
				target.BindComputeTexture(volumeTextureIDs._AccuVelocityY, volumeTextures._AccuVelocityY);
				target.BindComputeTexture(volumeTextureIDs._AccuVelocityZ, volumeTextures._AccuVelocityZ);
			}
			else
			{
				target.BindComputeBuffer(volumeTextureIDs._AccuWeight, volumeBuffers._AccuWeightBuffer);
				target.BindComputeBuffer(volumeTextureIDs._AccuWeight0, volumeBuffers._AccuWeight0Buffer);
				target.BindComputeBuffer(volumeTextureIDs._AccuVelocityX, volumeBuffers._AccuVelocityXBuffer);
				target.BindComputeBuffer(volumeTextureIDs._AccuVelocityY, volumeBuffers._AccuVelocityYBuffer);
				target.BindComputeBuffer(volumeTextureIDs._AccuVelocityZ, volumeBuffers._AccuVelocityZBuffer);
			}

			target.BindComputeTexture(volumeTextureIDs._VolumeDensity, volumeTextures._VolumeDensity);
			target.BindComputeTexture(volumeTextureIDs._VolumeDensity0, volumeTextures._VolumeDensity0);
			target.BindComputeTexture(volumeTextureIDs._VolumeVelocity, volumeTextures._VolumeVelocity);
			target.BindComputeTexture(volumeTextureIDs._VolumeDivergence, volumeTextures._VolumeDivergence);

			target.BindComputeTexture(volumeTextureIDs._VolumePressure, volumeTextures._VolumePressure);
			target.BindComputeTexture(volumeTextureIDs._VolumePressureNext, volumeTextures._VolumePressureNext);
			target.BindComputeTexture(volumeTextureIDs._VolumePressureGrad, volumeTextures._VolumePressureGrad);

			target.BindComputeTexture(volumeTextureIDs._VolumeScattering, volumeTextures._VolumeScattering);
			target.BindComputeTexture(volumeTextureIDs._VolumeImpulse, volumeTextures._VolumeImpulse);

			target.BindComputeTexture(volumeTextureIDs._BoundarySDF, (volumeTextures._BoundarySDF != null) ? volumeTextures._BoundarySDF : volumeTextures._BoundarySDF_undefined);

			target.BindKeyword("VOLUME_SPLAT_CLUSTERS", volumeKeywords.VOLUME_SPLAT_CLUSTERS);
			target.BindKeyword("VOLUME_SUPPORT_CONTRACTION", volumeKeywords.VOLUME_SUPPORT_CONTRACTION);
			target.BindKeyword("VOLUME_TARGET_INITIAL_POSE", volumeKeywords.VOLUME_TARGET_INITIAL_POSE);
			target.BindKeyword("VOLUME_TARGET_INITIAL_POSE_IN_PARTICLES", volumeKeywords.VOLUME_TARGET_INITIAL_POSE_IN_PARTICLES);
		}

		public static void InitSolverData(CommandBuffer cmd, in SolverData solverData)
		{
			int numX = ((int)solverData.constants._StrandCount + THREAD_GROUP_SIZE - 1) / THREAD_GROUP_SIZE;
			int numY = 1;
			int numZ = 1;

			BindSolverData(cmd, s_solverCS, SolverKernels.KInitialize, solverData);
			cmd.DispatchCompute(s_solverCS, SolverKernels.KInitialize, numX, numY, numZ);
		}

		public static void InitSolverDataPostVolume(CommandBuffer cmd, in SolverData solverData, in VolumeData volumeData)
		{
			int numX = ((int)solverData.constants._StrandCount + THREAD_GROUP_SIZE - 1) / THREAD_GROUP_SIZE;
			int numY = 1;
			int numZ = 1;

			BindVolumeData(cmd, s_solverCS, SolverKernels.KInitializePostVolume, volumeData);
			BindSolverData(cmd, s_solverCS, SolverKernels.KInitializePostVolume, solverData);
			cmd.DispatchCompute(s_solverCS, SolverKernels.KInitializePostVolume, numX, numY, numZ);
		}

		public static void PushSolverRoots(CommandBuffer cmd, CommandBufferExecutionFlags cmdFlags, ref SolverData solverData, Mesh rootMesh, in Matrix4x4 rootMeshMatrix, in Quaternion rootMeshSkinningRotation, int stepCount)
		{
			ref var solverBuffers = ref solverData.buffers;
			ref var solverConstantsRoots = ref solverData.constantsRoots;

			// derive constants
			var rootMeshRotation = rootMeshMatrix.rotation;
			var rootMeshRotationInv = Quaternion.Inverse(rootMeshRotation);

			solverConstantsRoots._RootMeshMatrix = rootMeshMatrix;
			solverConstantsRoots._RootMeshRotation = rootMeshRotation.ToVector4();
			solverConstantsRoots._RootMeshRotationInv = rootMeshRotationInv.ToVector4();
			solverConstantsRoots._RootMeshSkinningRotation = rootMeshSkinningRotation.ToVector4();

#if UNITY_2021_2_OR_NEWER
			if (rootMesh.vertexBufferTarget.HasFlag(GraphicsBuffer.Target.Raw) == false)
				rootMesh.vertexBufferTarget |= GraphicsBuffer.Target.Raw;

			var vertexPositionStream = rootMesh.GetVertexAttributeStream(VertexAttribute.Position);
			var vertexPositionOffset = rootMesh.GetVertexAttributeOffset(VertexAttribute.Position);
			var vertexPositionStride = rootMesh.GetVertexBufferStride(vertexPositionStream);

			var vertexTangentStream = rootMesh.GetVertexAttributeStream(VertexAttribute.Tangent);
			var vertexTangentOffset = rootMesh.GetVertexAttributeOffset(VertexAttribute.Tangent);
			var vertexTangentStride = rootMesh.GetVertexBufferStride(vertexTangentStream);

			var normalStream = rootMesh.GetVertexAttributeStream(VertexAttribute.Normal);
			var normalOffset = rootMesh.GetVertexAttributeOffset(VertexAttribute.Normal);
			var normalStride = rootMesh.GetVertexBufferStride(normalStream);

			solverConstantsRoots._RootMeshPositionOffset = (uint)vertexPositionOffset;
			solverConstantsRoots._RootMeshPositionStride = (uint)vertexPositionStride;
			solverConstantsRoots._RootMeshTangentOffset = (uint)vertexTangentOffset;
			solverConstantsRoots._RootMeshTangentStride = (uint)vertexTangentStride;
			solverConstantsRoots._RootMeshNormalOffset = (uint)normalOffset;
			solverConstantsRoots._RootMeshNormalStride = (uint)normalStride;
#else
			solverConstantsRoots._RootMeshTangentStride = rootMesh.HasVertexAttribute(VertexAttribute.Tangent) ? 1u : 0u;
#endif

#if !HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN_0_2_1_PREVIEW
			solverConstantsRoots._RootMeshTangentStride = 0;//TODO remove this? (and therein assume that root mesh having tangents == root mesh having tangent frame)
#endif

			// update cbuffer
			PushConstantBufferData(cmd, solverData.buffers.SolverCBufferRoots, solverConstantsRoots);

			// conditionally advance roots
			if (stepCount > 0)
			{
				CoreUtils.Swap(ref solverBuffers._RootPositionPrev, ref solverBuffers._RootPosition);
				CoreUtils.Swap(ref solverBuffers._RootFramePrev, ref solverBuffers._RootFrame);
			}

			using (new ProfilingScope(cmd, MarkersGPU.Roots))
			{
#if UNITY_2021_2_OR_NEWER
				if (rootMesh.vertexBufferTarget.HasFlag(GraphicsBuffer.Target.Raw) == false)
					rootMesh.vertexBufferTarget |= GraphicsBuffer.Target.Raw;
				
				using (GraphicsBuffer vertexPosition = rootMesh.GetVertexBuffer(vertexPositionStream))
				using (GraphicsBuffer vertexTangent = (vertexTangentStride != 0) ? rootMesh.GetVertexBuffer(vertexTangentStream) : null)
				using (GraphicsBuffer vertexNormal = rootMesh.GetVertexBuffer(normalStream))
				{
					int numX = ((int)solverData.constants._StrandCount + THREAD_GROUP_SIZE - 1) / THREAD_GROUP_SIZE;
					int numY = 1;
					int numZ = 1;

					cmd.SetComputeBufferParam(s_solverCS, SolverKernels.KRoots, SolverData.s_externalIDs._RootMeshPosition, vertexPosition);
					cmd.SetComputeBufferParam(s_solverCS, SolverKernels.KRoots, SolverData.s_externalIDs._RootMeshTangent, vertexTangent ?? vertexNormal);
					cmd.SetComputeBufferParam(s_solverCS, SolverKernels.KRoots, SolverData.s_externalIDs._RootMeshNormal, vertexNormal);

					BindSolverData(cmd, s_solverCS, SolverKernels.KRoots, solverData);
					cmd.DispatchCompute(s_solverCS, SolverKernels.KRoots, numX, numY, numZ);
				}
#else
				if (s_runtimeFlags.HasFlag(RuntimeFlags.SupportsVertexUAVWrites) && cmdFlags.HasFlag(CommandBufferExecutionFlags.AsyncCompute) == false)
				{
					// this path uses UAV writes from the vertex stage to funnel out data from the root mesh.
					// despite not actually rendering anything (all fragments clipped), we need to also bind
					// a dummy render target to avoid an unspecified target being bound for the draw.
					{
						cmd.GetTemporaryRT(SolverData.s_externalIDs._RootResolveDummyRT, 1, 1);
						cmd.SetRenderTarget(SolverData.s_externalIDs._RootResolveDummyRT);
					}

					BindSolverData(cmd, solverData);

					cmd.SetRandomWriteTarget(1, solverData.buffers._RootPositionNext);
					cmd.SetRandomWriteTarget(2, solverData.buffers._RootFrameNext);
					cmd.DrawMesh(rootMesh, Matrix4x4.identity, s_solverRootsMat);
					cmd.ClearRandomWriteTargets();
				}
				else
				{
					// some platforms (Metal, for example) do not support unconditional vertex stage UAV writes.
					// we use the (default) compute path to support those platforms, but since that path requires
					// vertex buffer access from C# it is available only with Unity 2021.2+. (this limitation is
					// also what prevents async scheduling on versions prior.)
					Debug.LogError("Unable to resolve roots (vertex UAV writes not supported and compute path requires 2021.2+)");
				}
#endif
			}
		}

		public static void PushSolverRootsHistory(CommandBuffer cmd, in SolverData solverData)
		{
			int numX = ((int)solverData.constants._StrandCount + THREAD_GROUP_SIZE - 1) / THREAD_GROUP_SIZE;
			int numY = 1;
			int numZ = 1;

			BindSolverData(cmd, s_solverCS, SolverKernels.KRootsHistory, solverData);
			cmd.DispatchCompute(s_solverCS, SolverKernels.KRootsHistory, numX, numY, numZ);
		}

		public static void PushSolverGeometry(CommandBuffer cmd, ref SolverData solverData, in SettingsGeometry settingsGeometry, Matrix4x4 localToWorld)
		{
			ref var solverConstants = ref solverData.constants;

			// derive constants
			var localToWorldScale = 1.0f;
			{
				switch (settingsGeometry.strandScale)
				{
					case SettingsGeometry.StrandScale.Fixed:
						break;

					case SettingsGeometry.StrandScale.UniformWorldMin:
						localToWorldScale = localToWorld.lossyScale.Abs().CMin();
						break;

					case SettingsGeometry.StrandScale.UniformWorldMax:
						localToWorldScale = localToWorld.lossyScale.Abs().CMax();
						break;
				}
			}

			var localToWorldScaleLength = localToWorldScale;
			{
				if (settingsGeometry.strandLength)
				{
					localToWorldScaleLength *= settingsGeometry.strandLengthValue / solverData.initialStrandParamsMax.x;
				}
			}

			var localToWorldScaleDiameter = localToWorldScale;
			{
				if (settingsGeometry.strandDiameter)
				{
					localToWorldScaleDiameter *= (settingsGeometry.strandDiameterValue * 0.001f) / solverData.initialStrandParamsMax.y;
				}
			}

			var worldMaxParticleInterval = localToWorldScaleLength * (solverData.initialStrandParamsMax.x / (solverConstants._StrandParticleCount - 1));
			var worldMaxParticleDiameter = localToWorldScaleDiameter * solverData.initialStrandParamsMax.y;
			var worldAvgParticleDiameter = localToWorldScaleDiameter * solverData.initialStrandParamsAvg.y;

			solverConstants._GroupScale = localToWorldScaleLength;
			solverConstants._GroupMaxParticleVolume = worldMaxParticleInterval * (0.25f * Mathf.PI * worldMaxParticleDiameter * worldMaxParticleDiameter);
			solverConstants._GroupMaxParticleInterval = worldMaxParticleInterval;
			solverConstants._GroupMaxParticleDiameter = worldMaxParticleDiameter;
			solverConstants._GroupAvgParticleDiameter = worldAvgParticleDiameter;
			solverConstants._GroupAvgParticleMargin = localToWorldScale * settingsGeometry.strandSeparation * 0.001f;

			solverConstants._GroupMaxTipScale = settingsGeometry.tipScale ? settingsGeometry.tipScaleValue : solverData.initialStrandParamsMax.w;
			solverConstants._GroupMaxTipScaleOffset = settingsGeometry.tipScaleOffset ? settingsGeometry.tipScaleOffsetValue : solverData.initialStrandParamsMax.z;

			solverConstants._GroupBoundsPadding = settingsGeometry.boundsScale ? settingsGeometry.boundsScaleValue : 1.25f;

			// update cbuffer
			PushConstantBufferData(cmd, solverData.buffers.SolverCBuffer, solverConstants);

			// update manual bounds
			solverData.manualBounds = (settingsGeometry.boundsMode == SettingsGeometry.BoundsMode.Manual);
			solverData.manualBoundsMin = settingsGeometry.boundsCenter - settingsGeometry.boundsExtent;
			solverData.manualBoundsMax = settingsGeometry.boundsCenter + settingsGeometry.boundsExtent;
		}

		public static void PushSolverLODInit(CommandBuffer cmd, in SolverData solverData)
		{
			BindSolverData(cmd, s_solverCS, SolverKernels.KLODSelectionInit, solverData);
			cmd.DispatchCompute(s_solverCS, SolverKernels.KLODSelectionInit, 1, 1, 1);
		}

		public static void PushSolverLOD(CommandBuffer cmd, ref SolverData solverData, in SettingsPhysics settingsPhysics, in SettingsRendering settingsRendering, in VolumeData volumeData, int stepCount)
		{
			ref var solverConstants = ref solverData.constants;

			// derive constants
			solverConstants._SolverLODMethod = ((uint)settingsPhysics.kLODSelection & 0xffffu) | (stepCount > 0 ? 0x10000u : 0x00000u);
			solverConstants._SolverLODCeiling = settingsPhysics.kLODCeiling;
			solverConstants._SolverLODScale = settingsPhysics.kLODScale;
			solverConstants._SolverLODBias = (settingsPhysics.kLODSelection == SolverLODSelection.Manual) ? settingsPhysics.kLODSelectionValue : settingsPhysics.kLODBias;

			solverConstants._RenderLODMethod = (uint)settingsRendering.kLODSelection;
			solverConstants._RenderLODCeiling = settingsRendering.kLODCeiling;
			solverConstants._RenderLODScale = settingsRendering.kLODScale;
			solverConstants._RenderLODBias = (settingsRendering.kLODSelection == RenderLODSelection.Manual) ? settingsRendering.kLODSelectionValue : settingsRendering.kLODBias;
			solverConstants._RenderLODClipThreshold = settingsRendering.clipThreshold;

			// update cbuffer
			PushConstantBufferData(cmd, solverData.buffers.SolverCBuffer, solverConstants);

			// lod selection
			BindVolumeData(cmd, s_solverCS, SolverKernels.KLODSelection, volumeData);
			BindSolverData(cmd, s_solverCS, SolverKernels.KLODSelection, solverData);
			cmd.DispatchCompute(s_solverCS, SolverKernels.KLODSelection, 1, 1, 1);

			// schedule readback
			solverData.buffersReadback._SolverLODStage.ScheduleCopy(cmd, solverData.buffers._SolverLODStage);
#if DEBUG_LOD_SELECTION
			solverData.buffersReadback._SolverLODRange.ScheduleCopy(cmd, solverData.buffers._SolverLODRange);
			solverData.buffersReadback._SolverLODDispatch.ScheduleCopy(cmd, solverData.buffers._SolverLODDispatch);
			{
				var dataRange = solverData.buffersReadback._SolverLODRange.GetData<uint2>(true);
				var dataStage = solverData.buffersReadback._SolverLODStage.GetData<LODIndices>(true);
				var dataDispatch = solverData.buffersReadback._SolverLODDispatch.GetData<uint4>(true);

				var rangeAdd = dataRange[(int)HairSim.SolverLODRange.InterpolateAdd];
				var rangePromote = dataRange[(int)HairSim.SolverLODRange.InterpolatePromote];

				var countAdd = rangeAdd.y - rangeAdd.x;
				var countPromote = rangePromote.y - rangePromote.x;

				if (countAdd > 0 || countPromote > 0)
				{
					Debug.Log("---- ADD OR PROMOTE -----");
					for (int i = 0; i != (int)HairSim.SolverLODRange.__COUNT; i++)
					{
						Debug.LogFormat("range {0} = {1}", (HairSim.SolverLODRange)i, dataRange[i]);
					}

					Debug.Log(" ... ");
					for (int i = 0; i != (int)HairSim.SolverLODStage.__COUNT; i++)
					{
						Debug.LogFormat("stage {0} = {1}", (HairSim.SolverLODStage)i, dataStage[i].lodIndexHi);
					}

					Debug.Log(" ... ");
					for (int i = 0; i != (int)HairSim.SolverLODDispatch.__COUNT; i++)
					{
						Debug.LogFormat("dispatch {0} = [{1}, {2}, {3}] {4}", (HairSim.SolverLODDispatch)i, dataDispatch[i].x, dataDispatch[i].y, dataDispatch[i].z, dataDispatch[i].w);
					}
				}
			}
#endif

			// add reentrant -> interpolated
			static SolverData WithCurrentRoots(in SolverData solverData)
			{
				var ret = solverData;
				{
					CoreUtils.Swap(ref ret.buffers._RootFrame, ref ret.buffers._RootFrameNext);
					CoreUtils.Swap(ref ret.buffers._RootPosition, ref ret.buffers._RootPositionNext);
				}
				return ret;
			}

			BindSolverData(cmd, s_solverCS, SolverKernels.KInterpolateAdd, WithCurrentRoots(solverData));
			cmd.DispatchCompute(s_solverCS, SolverKernels.KInterpolateAdd, solverData.buffers._SolverLODDispatch, GetSolverLODDispatchOffset(SolverLODDispatch.InterpolateAdd));
		}

		public static void PushSolverStepBegin(CommandBuffer cmd, ref SolverData solverData, in SettingsPhysics settingsPhysics, float deltaTime)
		{
			ref var solverConstants = ref solverData.constants;
			ref var solverKeywords = ref solverData.keywords;

			// derive constants
			static float IntervalToSeconds(SettingsPhysics.TimeInterval interval)
			{
				switch (interval)
				{
					default:
					case SettingsPhysics.TimeInterval.PerSecond: return 1.0f;
					case SettingsPhysics.TimeInterval.Per100ms: return 0.1f;
					case SettingsPhysics.TimeInterval.Per10ms: return 0.01f;
					case SettingsPhysics.TimeInterval.Per1ms: return 0.001f;
				}
			}

			solverConstants._DT = deltaTime / Mathf.Max(1, settingsPhysics.solverSubsteps);
			solverConstants._Substeps = (uint)Mathf.Max(1, settingsPhysics.solverSubsteps);
			solverConstants._Iterations = (uint)settingsPhysics.constraintIterations;
			solverConstants._Stiffness = settingsPhysics.constraintStiffness;
			solverConstants._SOR = (settingsPhysics.constraintIterations > 1) ? settingsPhysics.constraintSOR : 1.0f;

			solverConstants._LinearDamping = settingsPhysics.dampingLinear ? settingsPhysics.dampingLinearFactor : 0.0f;
			solverConstants._LinearDampingInterval = IntervalToSeconds(settingsPhysics.dampingLinearInterval);
			solverConstants._AngularDamping = settingsPhysics.dampingAngular ? settingsPhysics.dampingAngularFactor : 0.0f;
			solverConstants._AngularDampingInterval = IntervalToSeconds(settingsPhysics.dampingAngularInterval);
			solverConstants._CellPressure = settingsPhysics.cellPressure;
			solverConstants._CellVelocity = settingsPhysics.cellVelocity;
			solverConstants._CellExternal = settingsPhysics.cellExternal;
			solverConstants._GravityScale = settingsPhysics.gravity;

			solverConstants._BoundaryFriction = settingsPhysics.boundaryCollisionFriction;
			solverConstants._FTLCorrection = settingsPhysics.distanceFTLCorrection;
			solverConstants._LocalCurvature = settingsPhysics.localCurvatureValue * 0.5f;
			solverConstants._LocalShape = settingsPhysics.localShapeInfluence;
			solverConstants._LocalShapeBias = settingsPhysics.localShapeBias ? settingsPhysics.localShapeBiasValue : 0.0f;

			solverConstants._GlobalPosition = settingsPhysics.globalPositionInfluence;
			solverConstants._GlobalPositionInterval = IntervalToSeconds(settingsPhysics.globalPositionInterval);
			solverConstants._GlobalRotation = settingsPhysics.globalRotationInfluence;
			solverConstants._GlobalFadeOffset = settingsPhysics.globalFade ? settingsPhysics.globalFadeOffset : 1e9f;
			solverConstants._GlobalFadeExtent = settingsPhysics.globalFade ? settingsPhysics.globalFadeExtent : 1e9f;

			// derive features
			SolverFeatures features = 0;
			{
				features |= (settingsPhysics.boundaryCollision && settingsPhysics.boundaryCollisionFriction == 0.0f) ? SolverFeatures.Boundary : 0;
				features |= (settingsPhysics.boundaryCollision && settingsPhysics.boundaryCollisionFriction > 0.0f) ? SolverFeatures.BoundaryFriction : 0;
				features |= (settingsPhysics.distance) ? SolverFeatures.Distance : 0;
				features |= (settingsPhysics.distanceLRA) ? SolverFeatures.DistanceLRA : 0;
				features |= (settingsPhysics.distanceFTL) ? SolverFeatures.DistanceFTL : 0;
				features |= (settingsPhysics.localCurvature && settingsPhysics.localCurvatureMode == SettingsPhysics.LocalCurvatureMode.Equals) ? SolverFeatures.CurvatureEQ : 0;
				features |= (settingsPhysics.localCurvature && settingsPhysics.localCurvatureMode == SettingsPhysics.LocalCurvatureMode.GreaterThan) ? SolverFeatures.CurvatureGEQ : 0;
				features |= (settingsPhysics.localCurvature && settingsPhysics.localCurvatureMode == SettingsPhysics.LocalCurvatureMode.LessThan) ? SolverFeatures.CurvatureLEQ : 0;
				features |= (settingsPhysics.localShape && settingsPhysics.localShapeInfluence > 0.0f && settingsPhysics.localShapeMode == SettingsPhysics.LocalShapeMode.Forward) ? SolverFeatures.PoseLocalShape : 0;
				features |= (settingsPhysics.localShape && settingsPhysics.localShapeInfluence > 0.0f && settingsPhysics.localShapeMode == SettingsPhysics.LocalShapeMode.Stitched) ? SolverFeatures.PoseLocalShapeRWD : 0;
				features |= (settingsPhysics.globalPosition && settingsPhysics.globalPositionInfluence > 0.0f) ? SolverFeatures.PoseGlobalPosition : 0;
				features |= (settingsPhysics.globalRotation && settingsPhysics.globalRotationInfluence > 0.0f) ? SolverFeatures.PoseGlobalRotation : 0;

				if (features.HasFlag(SolverFeatures.PoseLocalShapeRWD) && settingsPhysics.solver != SettingsPhysics.Solver.GaussSeidel)
				{
					features &= ~SolverFeatures.PoseLocalShapeRWD;
					features |= SolverFeatures.PoseLocalShape;
				}
			}
			solverConstants._SolverFeatures = (uint)features;

			// derive feature-dependent buffers
			unsafe
			{
				var enableParticlePositionCorr = true;
				{
					enableParticlePositionCorr = enableParticlePositionCorr && features.HasFlag(SolverFeatures.DistanceFTL);
					enableParticlePositionCorr = enableParticlePositionCorr && (settingsPhysics.solver != SettingsPhysics.Solver.Jacobi);
				}

				var particleCount = (int)solverData.constants._StrandCount * (int)solverData.constants._StrandParticleCount;
				var particleStrideVector3 = sizeof(Vector3);

				CreateBuffer(ref solverData.buffers._ParticleCorrection, "ParticleCorrection", enableParticlePositionCorr ? particleCount : 1, particleStrideVector3);
			}

			// derive keywords
			solverKeywords.LAYOUT_INTERLEAVED = (solverData.memoryLayout == HairAsset.MemoryLayout.Interleaved);
			solverKeywords.LIVE_POSITIONS_3 = ((features & (SolverFeatures.CurvatureEQ | SolverFeatures.CurvatureGEQ | SolverFeatures.CurvatureLEQ | SolverFeatures.PoseLocalShapeRWD)) != 0);
			solverKeywords.LIVE_POSITIONS_2 = !solverKeywords.LIVE_POSITIONS_3 && ((features & (SolverFeatures.Distance | SolverFeatures.PoseLocalShape | SolverFeatures.PoseGlobalRotation)) != 0);
			solverKeywords.LIVE_POSITIONS_1 = !solverKeywords.LIVE_POSITIONS_3 && !solverKeywords.LIVE_POSITIONS_2 && ((features & ~SolverFeatures.PoseGlobalPosition) != 0);
			solverKeywords.LIVE_ROTATIONS_2 = ((features & (SolverFeatures.PoseLocalShape | SolverFeatures.PoseLocalShapeRWD | SolverFeatures.PoseGlobalRotation)) != 0);

			// update cbuffer
			PushConstantBufferData(cmd, solverData.buffers.SolverCBuffer, solverConstants);

			// promote interpolated -> simulated
			BindSolverData(cmd, s_solverCS, SolverKernels.KRootsHistoryAdd, solverData);
			cmd.DispatchCompute(s_solverCS, SolverKernels.KRootsHistoryAdd, solverData.buffers._SolverLODDispatch, GetSolverLODDispatchOffset(SolverLODDispatch.InterpolatePromote));

			BindSolverData(cmd, s_solverCS, SolverKernels.KInterpolatePromote, solverData);
			cmd.DispatchCompute(s_solverCS, SolverKernels.KInterpolatePromote, solverData.buffers._SolverLODDispatch, GetSolverLODDispatchOffset(SolverLODDispatch.InterpolatePromote));
		}

		public static void PushSolverStep(CommandBuffer cmd, ref SolverData solverData, in SettingsPhysics settingsPhysics, in VolumeData volumeData, float stepFracLo, float stepFracHi, bool stepFinal)
		{
			var solveKernel = SolverKernels.KSolveConstraints_GaussSeidelReference;
			var solveDispatch = SolverLODDispatch.Solve;

			switch (settingsPhysics.solver)
			{
				case SettingsPhysics.Solver.GaussSeidelReference:
					solveKernel = SolverKernels.KSolveConstraints_GaussSeidelReference;
					solveDispatch = SolverLODDispatch.Solve;
					break;

				case SettingsPhysics.Solver.GaussSeidel:
					solveKernel = SolverKernels.KSolveConstraints_GaussSeidel;
					solveDispatch = SolverLODDispatch.Solve;
					break;

				case SettingsPhysics.Solver.Jacobi:
					switch (solverData.constants._StrandParticleCount)
					{
						case 16:
							solveKernel = SolverKernels.KSolveConstraints_Jacobi_16;
							break;

						case 32:
							solveKernel = SolverKernels.KSolveConstraints_Jacobi_32;
							break;

						case 64:
							solveKernel = SolverKernels.KSolveConstraints_Jacobi_64;
							break;

						case 128:
							solveKernel = SolverKernels.KSolveConstraints_Jacobi_128;
							break;
					}
					solveDispatch = SolverLODDispatch.SolveGroupParticles;
					break;
			}

			using (new ProfilingScope(cmd, MarkersGPU.Solver))
			{
				var substepConstantsBackup = solverData.constants;
				var substepCount = solverData.constants._Substeps;

				for (int i = 0; i != substepCount; i++)
				{
					// substep per-frame scene data
					using (new ProfilingScope(cmd, MarkersGPU.Solver_SubstepScene))
					{
						var substepFracLo = Mathf.Lerp(stepFracLo, stepFracHi, (i + 0) / (float)substepCount);
						var substepFracHi = Mathf.Lerp(stepFracLo, stepFracHi, (i + 1) / (float)substepCount);

						// substep roots
						//TODO skip substepping if range stepFracLo, stepFracHi is [0, 1]
						{
							cmd.SetComputeFloatParam(s_solverCS, UniformIDs._SubstepFractionLo, substepFracLo);
							cmd.SetComputeFloatParam(s_solverCS, UniformIDs._SubstepFractionHi, substepFracHi);

							var resolveRootsInterpolated = stepFinal || (volumeData.keywords.VOLUME_SPLAT_CLUSTERS == false && i == substepCount - 1);
							var resolveRootsDispatch = resolveRootsInterpolated ?
								SolverLODDispatch.Roots :
								SolverLODDispatch.Solve;

							BindSolverData(cmd, s_solverCS, SolverKernels.KRootsSubstep, solverData);
							cmd.DispatchCompute(s_solverCS, SolverKernels.KRootsSubstep, solverData.buffers._SolverLODDispatch, GetSolverLODDispatchOffset(resolveRootsDispatch));
						}

						// substep boundaries
						{
							cmd.SetComputeFloatParam(s_volumeCS, UniformIDs._SubstepFractionLo, substepFracLo);
							cmd.SetComputeFloatParam(s_volumeCS, UniformIDs._SubstepFractionHi, substepFracHi);

							int numX = (Conf.MAX_BOUNDARIES + THREAD_GROUP_SIZE - 1) / THREAD_GROUP_SIZE;
							int numY = 1;
							int numZ = 1;

							BindVolumeData(cmd, s_volumeCS, VolumeKernels.KBoundariesSubstep, volumeData);
							cmd.DispatchCompute(s_volumeCS, VolumeKernels.KBoundariesSubstep, numX, numY, numZ);
						}
					}

					//Debug.Log("substep " + i + ": " + (substepFrac < (1.0f - float.Epsilon)) + " (lo " + stepFracLo + " hi " + stepFracHi + ")");
					using (new ProfilingScope(cmd, MarkersGPU.Solver_SolveConstraints))
					{
						if (Conf.SECOND_ORDER_UPDATE != 0)
						{
							CoreUtils.Swap(ref solverData.buffers._ParticlePosition, ref solverData.buffers._ParticlePositionPrev);     // A B C -> b a c
							CoreUtils.Swap(ref solverData.buffers._ParticlePosition, ref solverData.buffers._ParticlePositionPrevPrev); // b a c -> C A B
							CoreUtils.Swap(ref solverData.buffers._ParticleVelocity, ref solverData.buffers._ParticleVelocityPrev);
						}
						else
						{
							CoreUtils.Swap(ref solverData.buffers._ParticlePosition, ref solverData.buffers._ParticlePositionPrev);     // A B -> B A
						}

						BindVolumeData(cmd, s_solverCS, solveKernel, volumeData);
						BindSolverData(cmd, s_solverCS, solveKernel, solverData);
						cmd.DispatchCompute(s_solverCS, solveKernel, solverData.buffers._SolverLODDispatch, GetSolverLODDispatchOffset(solveDispatch));
					}

					// volume impulse is only applied for first substep
					if (substepCount > 1)
					{
						solverData.constants._CellPressure = 0.0f;
						solverData.constants._CellVelocity = 0.0f;
						solverData.constants._CellExternal = 0.0f;
						PushConstantBufferData(cmd, solverData.buffers.SolverCBuffer, solverData.constants);
					}
				}

				if (substepCount > 1)
				{
					solverData.constants = substepConstantsBackup;
					PushConstantBufferData(cmd, solverData.buffers.SolverCBuffer, solverData.constants);
				}
			}

			if (volumeData.keywords.VOLUME_SPLAT_CLUSTERS == false)
			{
				using (new ProfilingScope(cmd, MarkersGPU.Solver_Interpolate))
				{
					BindSolverData(cmd, s_solverCS, SolverKernels.KInterpolate, solverData);
					cmd.DispatchCompute(s_solverCS, SolverKernels.KInterpolate, solverData.buffers._SolverLODDispatch, GetSolverLODDispatchOffset(SolverLODDispatch.Interpolate));
				}
			}
		}

		public static void PushSolverStepEnd(CommandBuffer cmd, in SolverData solverData, in VolumeData volumeData)
		{
			if (volumeData.keywords.VOLUME_SPLAT_CLUSTERS)
			{
				using (new ProfilingScope(cmd, MarkersGPU.Solver_Interpolate))
				{
					BindSolverData(cmd, s_solverCS, SolverKernels.KInterpolate, solverData);
					cmd.DispatchCompute(s_solverCS, SolverKernels.KInterpolate, solverData.buffers._SolverLODDispatch, GetSolverLODDispatchOffset(SolverLODDispatch.Interpolate));
				}
			}
		}

		public static void PushSolverStaging(CommandBuffer cmd, ref SolverData solverData, in SettingsGeometry settingsGeometry, in SettingsRendering settingsRendering, in VolumeData volumeData)
		{
			ref var solverBuffers = ref solverData.buffers;
			ref var solverConstants = ref solverData.constants;

			// derive constants
			var subdivisionCount = (settingsGeometry.stagingSubdivision ? settingsGeometry.stagingSubdivisionCount : 0);
			var subdivisionCountChanged = (subdivisionCount != solverConstants._StagingSubdivision);
			var subdivisionSegmentCount = (subdivisionCount + 1) * (solverConstants._StrandParticleCount - 1);

			var stagingVertexFormat = (StagingVertexFormat)0;
			var stagingVertexStride = 0;

			unsafe
			{
				switch (settingsGeometry.stagingPrecision)
				{
					default:
					case SettingsGeometry.StagingPrecision.Full:
						stagingVertexFormat = StagingVertexFormat.Uncompressed;
						stagingVertexStride = sizeof(Vector3);
						break;

					case SettingsGeometry.StagingPrecision.Half:
						stagingVertexFormat = StagingVertexFormat.Compressed;
						stagingVertexStride = sizeof(Vector2);
						break;
				}
			}

			solverConstants._StagingSubdivision = subdivisionCount;
			solverConstants._StagingVertexFormat = (uint)stagingVertexFormat;
			solverConstants._StagingVertexStride = (uint)stagingVertexStride;

			solverConstants._StagingStrandVertexCount = subdivisionSegmentCount + 1;
			solverConstants._StagingStrandVertexOffset = solverConstants._StrandParticleOffset;

			// derive constant-dependent buffers
			var stagingBufferVertexCount = (int)(solverConstants._StrandCount * (subdivisionSegmentCount + 1));
			var stagingBufferHistoryReset = false;
			{
				stagingBufferHistoryReset |= subdivisionCountChanged;
				stagingBufferHistoryReset |= CreateBuffer(ref solverBuffers._StagingVertex, "StagingVertex_0", stagingBufferVertexCount, stagingVertexStride, ComputeBufferType.Raw);
				stagingBufferHistoryReset |= CreateBuffer(ref solverBuffers._StagingVertexPrev, "StagingVertex_1", stagingBufferVertexCount, stagingVertexStride, ComputeBufferType.Raw);
			}

			// derive features
			RenderFeatures features = 0;
			{
				//features |= (settingsRendering.allowIndirect && settingsRendering.allowInstancing) ? RenderFeatures.Instancing : 0;
				//features |= RenderFeatures.PerVertexTexCoord;
				//features |= RenderFeatures.PerVertexDiameter;
			}
			solverConstants._RenderFeatures = (uint)features;

			// update cbuffer
			PushConstantBufferData(cmd, solverData.buffers.SolverCBuffer, solverConstants);

			// update staging
			int stagingKernel = (solverConstants._StagingSubdivision == 0)
				? SolverKernels.KStaging
				: SolverKernels.KStagingSubdivision;

			using (new ProfilingScope(cmd, MarkersGPU.Solver_Staging))
			{
				CoreUtils.Swap(ref solverData.buffers._StagingVertex, ref solverData.buffers._StagingVertexPrev);

				BindVolumeData(cmd, s_solverCS, stagingKernel, volumeData);
				BindSolverData(cmd, s_solverCS, stagingKernel, solverData);
				cmd.DispatchCompute(s_solverCS, stagingKernel, solverData.buffers._SolverLODDispatch, GetSolverLODDispatchOffset(SolverLODDispatch.Staging));

				if (stagingBufferHistoryReset)
				{
					BindSolverData(cmd, s_solverCS, SolverKernels.KStagingHistory, solverData);
					cmd.DispatchCompute(s_solverCS, SolverKernels.KStagingHistory, solverData.buffers._SolverLODDispatch, GetSolverLODDispatchOffset(SolverLODDispatch.Staging));
				}
				else
				{
					BindSolverData(cmd, s_solverCS, SolverKernels.KStagingHistoryAdd, solverData);
					cmd.DispatchCompute(s_solverCS, SolverKernels.KStagingHistoryAdd, solverData.buffers._SolverLODDispatch, GetSolverLODDispatchOffset(SolverLODDispatch.StagingAdd));
				}
			}

			// post-staging lod selection (topology)
			//TODO push staging params earlier to fold this under earlier lod selection
			BindSolverData(cmd, s_solverCS, SolverKernels.KLODSelectionPost, solverData);
			cmd.DispatchCompute(s_solverCS, SolverKernels.KLODSelectionPost, 1, 1, 1);

			// schedule readback
#if DEBUG_LOD_SELECTION && DEBUG_LOD_SELECTION_POST
			solverData.buffersReadback._SolverLODTopology.ScheduleCopy(cmd, solverData.buffers._SolverLODTopology);
			{
				var data = solverData.buffersReadback._SolverLODTopology.GetData<uint>(true);
				Debug.Log("---indirect draw args---");
				for (int i = 0; i != 3; i++)
				{
					Debug.LogFormat((SolverLODTopology)i + ": args = {0}, {1}, {2}, {3}, {4}",
						data[i * 5 + 0],
						data[i * 5 + 1],
						data[i * 5 + 2],
						data[i * 5 + 3],
						data[i * 5 + 4]);
				}
			}
#endif
		}

		public static void PushVolumeGeometry(CommandBuffer cmd, ref VolumeData volumeData, SolverData[] solverData)
		{
			ref var volumeConstants = ref volumeData.constants;

			// derive constants
			var allGroupsMaxParticleVolume = 0.0f;
			var allGroupsMaxParticleInterval = 0.0f;
			var allGroupsMaxParticleDiameter = 0.0f;
			var allGroupsAvgParticleDiameterAccu = Vector2.zero;
			var allGroupsAvgParticleMarginAccu = Vector2.zero;

			for (int i = 0; i != solverData.Length; i++)
			{
				ref readonly var solverConstants = ref solverData[i].constants;
				ref readonly var solverWeight = ref solverData[i].initialStrandLengthTotal;

				allGroupsMaxParticleVolume = Mathf.Max(allGroupsMaxParticleVolume, solverConstants._GroupMaxParticleVolume);
				allGroupsMaxParticleInterval = Mathf.Max(allGroupsMaxParticleInterval, solverConstants._GroupMaxParticleInterval);
				allGroupsMaxParticleDiameter = Mathf.Max(allGroupsMaxParticleDiameter, solverConstants._GroupMaxParticleDiameter);
				allGroupsAvgParticleDiameterAccu.x += solverWeight * solverConstants._GroupAvgParticleDiameter;
				allGroupsAvgParticleDiameterAccu.y += solverWeight;
				allGroupsAvgParticleMarginAccu.x += solverWeight * solverConstants._GroupAvgParticleMargin;
				allGroupsAvgParticleMarginAccu.y += solverWeight;
			}

			if (allGroupsAvgParticleDiameterAccu.y > 0.0f)
				allGroupsAvgParticleDiameterAccu.x /= allGroupsAvgParticleDiameterAccu.y;
			if (allGroupsAvgParticleMarginAccu.y > 0.0f)
				allGroupsAvgParticleMarginAccu.x /= allGroupsAvgParticleMarginAccu.y;

			volumeConstants._AllGroupsMaxParticleVolume = allGroupsMaxParticleVolume;
			volumeConstants._AllGroupsMaxParticleInterval = allGroupsMaxParticleInterval;
			volumeConstants._AllGroupsMaxParticleDiameter = allGroupsMaxParticleDiameter;
			volumeConstants._AllGroupsAvgParticleDiameter = allGroupsAvgParticleDiameterAccu.x;
			volumeConstants._AllGroupsAvgParticleMargin = allGroupsAvgParticleMarginAccu.x;

			// update cbuffer
			PushConstantBufferData(cmd, volumeData.buffers.VolumeCBuffer, volumeConstants);
		}

		public static void PushVolumeBounds(CommandBuffer cmd, ref VolumeData volumeData, in SolverData[] solverData)
		{
			var boundsCount = solverData.Length + 1;
			int boundsNumX = ((int)boundsCount + THREAD_GROUP_SIZE - 1) / THREAD_GROUP_SIZE;
			int boundsNumY = 1;
			int boundsNumZ = 1;

			// update bounds
			{
				CoreUtils.Swap(ref volumeData.buffers._Bounds, ref volumeData.buffers._BoundsPrev);

				// clear
				using (var minMaxUBuffer = new NativeArray<uint>(6 * boundsCount, Allocator.Temp))
				{
					var manualBounds = false;

					unsafe
					{
						const uint clearMinU = 0xFFFFFFFFu;
						const uint clearMaxU = 0x00000000u;

						var minMaxUPtr = (uint*)minMaxUBuffer.GetUnsafePtr();

						static unsafe uint FloatToUnsignedSortable(uint x)
						{
							// see: http://stereopsis.com/radix.html
							// see: https://lemire.me/blog/2020/12/14/converting-floating-point-numbers-to-integers-while-preserving-order/
							uint mask = math.asuint(math.asint(x) >> 31) | 0x80000000u;
							return x ^ mask;
						}

						for (int i = 0; i != solverData.Length; i++)
						{
							if (solverData[i].manualBounds)
							{
								*(minMaxUPtr++) = FloatToUnsignedSortable(math.asuint(solverData[i].manualBoundsMin.x));
								*(minMaxUPtr++) = FloatToUnsignedSortable(math.asuint(solverData[i].manualBoundsMin.y));
								*(minMaxUPtr++) = FloatToUnsignedSortable(math.asuint(solverData[i].manualBoundsMin.z));
								*(minMaxUPtr++) = FloatToUnsignedSortable(math.asuint(solverData[i].manualBoundsMax.x));
								*(minMaxUPtr++) = FloatToUnsignedSortable(math.asuint(solverData[i].manualBoundsMax.y));
								*(minMaxUPtr++) = FloatToUnsignedSortable(math.asuint(solverData[i].manualBoundsMax.z));

								manualBounds = true;
							}
							else
							{
								*(minMaxUPtr++) = clearMinU;
								*(minMaxUPtr++) = clearMinU;
								*(minMaxUPtr++) = clearMinU;
								*(minMaxUPtr++) = clearMaxU;
								*(minMaxUPtr++) = clearMaxU;
								*(minMaxUPtr++) = clearMaxU;
							}
						}

						*(minMaxUPtr++) = clearMinU;
						*(minMaxUPtr++) = clearMinU;
						*(minMaxUPtr++) = clearMinU;
						*(minMaxUPtr++) = clearMaxU;
						*(minMaxUPtr++) = clearMaxU;
						*(minMaxUPtr++) = clearMaxU;
					}

					if (manualBounds)
					{
						PushComputeBufferData(cmd, volumeData.buffers._BoundsMinMaxU, minMaxUBuffer);
					}
					else
					{
						BindVolumeData(cmd, s_volumeCS, VolumeKernels.KBoundsClear, volumeData);
						cmd.DispatchCompute(s_volumeCS, VolumeKernels.KBoundsClear, boundsNumX, boundsNumY, boundsNumZ);
					}
				}

				// gather
				for (int i = 0; i != solverData.Length; i++)
				{
					if (solverData[i].manualBounds == false)
					{
						int rootsNumX = ((int)solverData[i].constants._StrandCount + THREAD_GROUP_SIZE - 1) / THREAD_GROUP_SIZE;
						int rootsNumY = 1;
						int rootsNumZ = 1;

						BindVolumeData(cmd, s_volumeCS, VolumeKernels.KBoundsGather, volumeData);
						BindSolverData(cmd, s_volumeCS, VolumeKernels.KBoundsGather, solverData[i]);
						cmd.DispatchCompute(s_volumeCS, VolumeKernels.KBoundsGather, rootsNumX, rootsNumY, rootsNumZ);
					}
				}

				// resolve
				BindVolumeData(cmd, s_volumeCS, VolumeKernels.KBoundsResolve, volumeData);
				cmd.DispatchCompute(s_volumeCS, VolumeKernels.KBoundsResolve, boundsNumX, boundsNumY, boundsNumZ);

				// resolve combined
				BindVolumeData(cmd, s_volumeCS, VolumeKernels.KBoundsResolveCombined, volumeData);
				cmd.DispatchCompute(s_volumeCS, VolumeKernels.KBoundsResolveCombined, 1, 1, 1);
			}

			// update bounds coverage
			{
				using (var lodGeometryBuffer = new NativeArray<LODGeometry>(boundsCount, Allocator.Temp))
				{
					unsafe
					{
						var lodGeometryPtr = (LODGeometry*)lodGeometryBuffer.GetUnsafePtr();

						for (int i = 0; i != solverData.Length; i++)
						{
							lodGeometryPtr[solverData[i].constants._GroupBoundsIndex] = new LODGeometry
							{
								maxParticleDiameter = solverData[i].constants._GroupMaxParticleDiameter,
								maxParticleInterval = solverData[i].constants._GroupMaxParticleInterval,
							};
						}

						lodGeometryPtr[volumeData.constants._CombinedBoundsIndex] = new LODGeometry
						{
							maxParticleDiameter = volumeData.constants._AllGroupsMaxParticleDiameter,
							maxParticleInterval = volumeData.constants._AllGroupsMaxParticleInterval,
						};
					}

					PushComputeBufferData(cmd, volumeData.buffers._BoundsGeometry, lodGeometryBuffer);
				}

				BindVolumeData(cmd, s_volumeCS, VolumeKernels.KBoundsCoverage, volumeData);
				cmd.DispatchCompute(s_volumeCS, VolumeKernels.KBoundsCoverage, boundsNumX, boundsNumY, boundsNumZ);
			}

			// schedule readback
			{
				volumeData.buffersReadback._Bounds.ScheduleCopy(cmd, volumeData.buffers._Bounds);
				volumeData.buffersReadback._BoundsCoverage.ScheduleCopy(cmd, volumeData.buffers._BoundsCoverage);
			}
		}

		public static void PushVolumeBoundsHistory(CommandBuffer cmd, in VolumeData volumeData)
		{
			var boundsCount = volumeData.constants._CombinedBoundsIndex + 1;
			int boundsNumX = ((int)boundsCount + THREAD_GROUP_SIZE - 1) / THREAD_GROUP_SIZE;
			int boundsNumY = 1;
			int boundsNumZ = 1;

			BindVolumeData(cmd, s_volumeCS, VolumeKernels.KBoundsHistory, volumeData);
			cmd.DispatchCompute(s_volumeCS, VolumeKernels.KBoundsHistory, boundsNumX, boundsNumY, boundsNumZ);
		}

		public static void PushVolumeObservers(CommandBuffer cmd, ref VolumeData volumeData, CameraType cameraType)
		{
			ref var volumeConstantsEnvironment = ref volumeData.constantsEnvironment;

			// update frustums
			using (var frustums = AcquireLODFrustums(CameraType.Game | CameraType.SceneView, Allocator.Temp))
			{
				//int i = 0;
				//foreach (var frustum in frustums)
				//{
				//	Debug.Log("--- FRUSTUM " + (i++) + " ---");
				//	Debug.Log("frustum.cameraPosition = " + frustum.cameraPosition);
				//	Debug.Log("frustum.cameraForward = " + frustum.cameraForward);
				//	Debug.Log("frustum.cameraNearClipPlane = " + frustum.cameraNearClipPlane);
				//	Debug.Log("frustum.cameraUnitSpanSubpixelDepth = " + frustum.cameraUnitSpanSubpixelDepth);
				//	Debug.Log("frustum.plane0 = " + frustum.plane0);
				//	Debug.Log("frustum.plane1 = " + frustum.plane1);
				//	Debug.Log("frustum.plane2 = " + frustum.plane2);
				//	Debug.Log("frustum.plane3 = " + frustum.plane3);
				//	Debug.Log("frustum.plane4 = " + frustum.plane4);
				//	Debug.Log("frustum.plane5 = " + frustum.plane5);
				//}

				// write constants
				volumeConstantsEnvironment._LODFrustumCount = (uint)frustums.Length;

				// update buffers
				PushComputeBufferData(cmd, volumeData.buffers._LODFrustum, frustums.AsArray());
			}

			// update cbuffer
			PushConstantBufferData(cmd, volumeData.buffers.VolumeCBufferEnvironment, volumeConstantsEnvironment);
		}

		public static void PushVolumeEnvironment(CommandBuffer cmd, ref VolumeData volumeData, in SettingsEnvironment settingsEnvironment, int stepCount, float frameFracHi)
		{
			ref var volumeConstantsScene = ref volumeData.constantsEnvironment;
			ref var volumeTextures = ref volumeData.textures;

			// update gravity
			volumeConstantsScene._WorldGravity = settingsEnvironment.gravityRotation * (Physics.gravity * settingsEnvironment.gravityScale);

			// update boundaries
			using (var bufRemap = new NativeArray<int>(Conf.MAX_BOUNDARIES, Allocator.Temp, NativeArrayOptions.ClearMemory))
			using (var bufHandle = new NativeArray<int>(Conf.MAX_BOUNDARIES, Allocator.Temp, NativeArrayOptions.ClearMemory))
			using (var bufMatrix = new NativeArray<Matrix4x4>(Conf.MAX_BOUNDARIES, Allocator.Temp, NativeArrayOptions.ClearMemory))
			using (var bufMatrixA = new NativeArray<Matrix4x4>(Conf.MAX_BOUNDARIES, Allocator.Temp, NativeArrayOptions.ClearMemory))
			using (var bufMatrixQ = new NativeArray<Quaternion>(Conf.MAX_BOUNDARIES, Allocator.Temp, NativeArrayOptions.ClearMemory))
			using (var bufShape = new NativeArray<HairBoundary.RuntimeShape.Data>(Conf.MAX_BOUNDARIES, Allocator.Temp, NativeArrayOptions.ClearMemory))
			{
				CreateCPUBuffer(ref volumeData.boundaryPrevHandle, Conf.MAX_BOUNDARIES, Allocator.Persistent, NativeArrayOptions.ClearMemory);
				CreateCPUBuffer(ref volumeData.boundaryPrevMatrix, Conf.MAX_BOUNDARIES, Allocator.Persistent, NativeArrayOptions.ClearMemory);

				unsafe
				{
					var ptrRemap = (int*)bufRemap.GetUnsafePtr();
					var ptrHandle = (int*)bufHandle.GetUnsafePtr();
					var ptrMatrix = (Matrix4x4*)bufMatrix.GetUnsafePtr();
					var ptrMatrixA = (Matrix4x4*)bufMatrixA.GetUnsafePtr();
					var ptrMatrixQ = (Quaternion*)bufMatrixQ.GetUnsafePtr();
					var ptrShape = (HairBoundary.RuntimeShape.Data*)bufShape.GetUnsafePtr();

					// gather boundaries
					//TODO expose or always enable the volumeSort option which sorts active boundaries by distance
					var boundaryList = SpatialComponentFilter<HairBoundary, HairBoundary.RuntimeData, HairBoundaryProxy>.Gather(settingsEnvironment.boundaryResident, settingsEnvironment.boundaryCapture, GetVolumeBounds(volumeData), settingsEnvironment.boundaryCaptureLayer, volumeSort: false, (settingsEnvironment.boundaryCaptureMode == SettingsEnvironment.BoundaryCaptureMode.IncludeColliders));
					var boundaryCountDiscrete = 0;
					var boundaryCountCapsule = 0;
					var boundaryCountSphere = 0;
					var boundaryCountTorus = 0;
					var boundaryCountCube = 0;
					var boundaryCount = 0;

					var boundarySDFIndex = -1;
					var boundarySDFCellSize = 0.0f;
					 
					foreach (var data in boundaryList)
					{
						if (data.type == HairBoundary.RuntimeData.Type.Shape)
						{
							switch (data.shape.type)
							{
								case HairBoundary.RuntimeShape.Type.Capsule: boundaryCountCapsule++; break;
								case HairBoundary.RuntimeShape.Type.Sphere: boundaryCountSphere++; break;
								case HairBoundary.RuntimeShape.Type.Torus: boundaryCountTorus++; break;
								case HairBoundary.RuntimeShape.Type.Cube: boundaryCountCube++; break;
							}

							boundaryCount++;
						}
						else
						{
							if (boundarySDFIndex == -1)// only include first discrete
							{
								boundarySDFIndex = boundaryCount;
								boundarySDFCellSize = Mathf.Max(boundarySDFCellSize, data.sdf.sdfCellSize);

								boundaryCountDiscrete++;
								boundaryCount++;
							}
						}

						if (boundaryCount == Conf.MAX_BOUNDARIES)
							break;
					}

					// prepare delimiters
					var firstIndexDiscrete = 0;
					var firstIndexCapsule = firstIndexDiscrete + boundaryCountDiscrete;
					var firstIndexSphere = firstIndexCapsule + boundaryCountCapsule;
					var firstIndexTorus = firstIndexSphere + boundaryCountSphere;
					var firstIndexCube = firstIndexTorus + boundaryCountTorus;
					var firstIndexEnd = firstIndexCube + boundaryCountCube;

					// write constants
					volumeConstantsScene._BoundaryDelimDiscrete = (uint)firstIndexCapsule;
					volumeConstantsScene._BoundaryDelimCapsule = (uint)firstIndexSphere;
					volumeConstantsScene._BoundaryDelimSphere = (uint)firstIndexTorus;
					volumeConstantsScene._BoundaryDelimTorus = (uint)firstIndexCube;
					volumeConstantsScene._BoundaryDelimCube = (uint)firstIndexEnd;

					volumeConstantsScene._BoundaryWorldEpsilon = (boundarySDFIndex != -1) ? boundarySDFCellSize * 0.2f : 1e-4f;
					volumeConstantsScene._BoundaryWorldMargin = settingsEnvironment.defaultSolidMargin * 0.01f;

					// write textures
					volumeTextures._BoundarySDF = (boundarySDFIndex != -1) ? boundaryList[boundarySDFIndex].sdf.sdfTexture : null;

					// write attributes
					{
						var writeIndexDiscrete = firstIndexDiscrete;
						var writeIndexCapsule = firstIndexCapsule;
						var writeIndexSphere = firstIndexSphere;
						var writeIndexTorus = firstIndexTorus;
						var writeIndexCube = firstIndexCube;
						var writeCount = 0;

						foreach (var data in boundaryList)
						{
							var writeIndex = -1;

							if (data.type == HairBoundary.RuntimeData.Type.Shape)
							{
								switch (data.shape.type)
								{
									case HairBoundary.RuntimeShape.Type.Capsule: writeIndex = writeIndexCapsule++; break;
									case HairBoundary.RuntimeShape.Type.Sphere: writeIndex = writeIndexSphere++; break;
									case HairBoundary.RuntimeShape.Type.Torus: writeIndex = writeIndexTorus++; break;
									case HairBoundary.RuntimeShape.Type.Cube: writeIndex = writeIndexCube++; break;
								}
							}
							else
							{
								if (writeIndexDiscrete == 0)// only include first discrete
								{
									writeIndex = writeIndexDiscrete++;
								}
							}

							if (writeIndex != -1)
							{
								ptrHandle[writeIndex] = data.xform.handle;
								ptrMatrix[writeIndex] = data.xform.matrix;
								ptrShape[writeIndex] = data.shape.data;

								writeCount++;
							}

							if (writeCount == Conf.MAX_BOUNDARIES)
								break;
						}
					}

					// write remapping (current -> previous)
					{
						for (int i = 0; i != boundaryCount; i++)
						{
							ptrRemap[i] = NativeArrayExtensions.IndexOf<int, int>(volumeData.boundaryPrevHandle, ptrHandle[i]);
						}

						for (int i = boundaryCount; i != Conf.MAX_BOUNDARIES; i++)
						{
							ptrRemap[i] = -1;
						}
					}

					// write blend params
					{
						for (int i = 0; i != boundaryCount; i++)
						{
							var j = ptrRemap[i];
							if (j != -1)
							{
								// Ma * M = Mb
								// M = Ma^-1 * Mb
								// ..
								// Mb_t = Ma * M(t)
								//
								// where Ma is the transform of the current frame
								//   and Mb is the transform of the last substep of the previous frame

								var Ma = ptrMatrix[i];
								var Mb = volumeData.boundaryPrevMatrix[j];

								var M = Matrix4x4.Inverse(Ma) * Mb;
								var q = (Quaternion)svd.svdRotation((float3x3)((float4x4)M));

								ptrMatrixA[i] = M;
								ptrMatrixQ[i] = q;
							}
							else
							{
								ptrMatrixA[i] = Matrix4x4.identity;
								ptrMatrixQ[i] = Quaternion.identity;
							}
						}
					}

					// update buffers
					PushComputeBufferData(cmd, volumeData.buffers._BoundaryMatrixNext, bufMatrix);
					PushComputeBufferData(cmd, volumeData.buffers._BoundaryMatrixPrevA, bufMatrixA);
					PushComputeBufferData(cmd, volumeData.buffers._BoundaryMatrixPrevQ, bufMatrixQ);
					PushComputeBufferData(cmd, volumeData.buffers._BoundaryShapeNext, bufShape);
					PushComputeBufferData(cmd, volumeData.buffers._BoundaryShapePrevLUT, bufRemap);

					// update previous frame info
					if (stepCount > 0)
					{
						volumeData.boundaryPrevHandle.CopyFrom(bufHandle);
#if false
						volumeData.boundaryPrevMatrix.CopyFrom(bufMatrix);
#else
						// resolve boundaryPrevMatrix to match contents of _BoundaryMatrix after final substep in frame
						{
							var ptrMatrixPrev = (Matrix4x4*)volumeData.boundaryPrevMatrix.GetUnsafePtr();

							for (int i = 0; i != boundaryCount; i++)
							{
								ref var Ma = ref ptrMatrix[i];
								ref var M = ref ptrMatrixA[i];
								ref var q = ref ptrMatrixQ[i];

								var M_t = AffineUtility.AffineInterpolate4x4(M, ((quaternion)q).value, 1.0f - frameFracHi);
								var Mb_t = AffineUtility.AffineMul4x4(Ma, M_t);

								ptrMatrixPrev[i] = Mb_t;
							}
						}
#endif
					}

					volumeData.boundaryCount = boundaryCount;
					volumeData.boundaryCountDiscard = boundaryList.Count - boundaryCount;

					/* TODO remove
					fixed (void* outShape = volumeConstantsScene._CB_BoundaryShape)
					fixed (void* outMatrix = volumeConstantsScene._CB_BoundaryMatrix)
					fixed (void* outMatrixInv = volumeConstantsScene._CB_BoundaryMatrixInv)
					fixed (void* outMatrixW2PrevW = volumeConstantsScene._CB_BoundaryMatrixW2PrevW)
					{
						UnsafeUtility.MemCpy(outShape, ptrShape, boundaryCount * sizeof(HairBoundary.RuntimeShape.Data));

						static void CopyTransformRows3x4(Vector4* dst, Matrix4x4* src, int count)
						{
							for (int i = 0; i != count; i++)
							{
								ref readonly var A = ref src[i];
								dst[i * 3 + 0] = new Vector4(A.m00, A.m01, A.m02, A.m03);
								dst[i * 3 + 1] = new Vector4(A.m10, A.m11, A.m12, A.m13);
								dst[i * 3 + 2] = new Vector4(A.m20, A.m21, A.m22, A.m23);
							}
						}

						CopyTransformRows3x4((Vector4*)outMatrix, ptrMatrix, boundaryCount);
						CopyTransformRows3x4((Vector4*)outMatrixInv, ptrMatrixInv, boundaryCount);
						CopyTransformRows3x4((Vector4*)outMatrixW2PrevW, ptrMatrixW2PrevW, boundaryCount);
					}
					*/
				}
			}

			// update emitters
			using (var bufRemap = new NativeArray<int>(Conf.MAX_EMITTERS, Allocator.Temp, NativeArrayOptions.ClearMemory))
			using (var bufHandle = new NativeArray<int>(Conf.MAX_EMITTERS, Allocator.Temp, NativeArrayOptions.ClearMemory))
			using (var bufEmitter = new NativeArray<HairWind.RuntimeEmitter>(Conf.MAX_EMITTERS, Allocator.Temp, NativeArrayOptions.ClearMemory))
			{
				CreateCPUBuffer(ref volumeData.emitterPrevHandle, Conf.MAX_EMITTERS, Allocator.Persistent, NativeArrayOptions.ClearMemory);

				unsafe
				{
					var ptrRemap = (int*)bufRemap.GetUnsafePtr();
					var ptrHandle = (int*)bufHandle.GetUnsafePtr();
					var ptrEmitter = (HairWind.RuntimeEmitter*)bufEmitter.GetUnsafePtr();

					// gather emitters
					var emitterList = SpatialComponentFilter<HairWind, HairWind.RuntimeData, HairWindProxy>.Gather(settingsEnvironment.emitterResident, settingsEnvironment.emitterCapture, GetVolumeBounds(volumeData), settingsEnvironment.emitterCaptureLayer, volumeSort: false, (settingsEnvironment.emitterCaptureMode == SettingsEnvironment.EmitterCaptureMode.IncludeWindZones));
					var emitterCount = Mathf.Min(emitterList.Count, Conf.MAX_EMITTERS);

					// write constants
					volumeConstantsScene._WindEmitterCount = (uint)emitterCount;

					// write attributes
					{
						for (int i = 0; i != emitterCount; i++)
						{
							ptrHandle[i] = emitterList[i].xform.handle;
							ptrEmitter[i] = emitterList[i].emitter;
						}
					}

					// write remapping (current -> previous)
					{
						for (int i = 0; i != emitterCount; i++)
						{
							ptrRemap[i] = NativeArrayExtensions.IndexOf<int, int>(volumeData.emitterPrevHandle, ptrHandle[i]);
						}

						for (int i = emitterCount; i != Conf.MAX_EMITTERS; i++)
						{
							ptrRemap[i] = -1;
						}
					}

					// update buffers
					PushComputeBufferData(cmd, volumeData.buffers._WindEmitterNext, bufEmitter);
					PushComputeBufferData(cmd, volumeData.buffers._WindEmitterPrevLUT, bufRemap);

					// update previous frame info
					if (stepCount > 0)
					{
						volumeData.emitterPrevHandle.CopyFrom(bufHandle);
					}

					volumeData.emitterCount = emitterCount;
					volumeData.emitterCountDiscard = emitterList.Count - emitterCount;
				}
			}

			// update cbuffer
			PushConstantBufferData(cmd, volumeData.buffers.VolumeCBufferEnvironment, volumeConstantsScene);

			// conditionally advance boundaries
			if (stepCount > 0)
			{
				int numX = (Conf.MAX_BOUNDARIES + THREAD_GROUP_SIZE - 1) / THREAD_GROUP_SIZE;
				int numY = 1;
				int numZ = 1;

				BindVolumeData(cmd, s_volumeCS, VolumeKernels.KBoundariesAdvance, volumeData);
				cmd.DispatchCompute(s_volumeCS, VolumeKernels.KBoundariesAdvance, numX, numY, numZ);
			}

			// conditionally advance emitters
			if (stepCount > 0)
			{
				int numX = (Conf.MAX_EMITTERS + THREAD_GROUP_SIZE - 1) / THREAD_GROUP_SIZE;
				int numY = 1;
				int numZ = 1;

				BindVolumeData(cmd, s_volumeCS, VolumeKernels.KEmittersAdvance, volumeData);
				cmd.DispatchCompute(s_volumeCS, VolumeKernels.KEmittersAdvance, numX, numY, numZ);
			}
		}

		public static void PushVolumeLOD(CommandBuffer cmd, ref VolumeData volumeData, in SettingsVolume settingsVolume)
		{
			ref var volumeConstants = ref volumeData.constants;

			// derive constants
			volumeConstants._GridResolution = settingsVolume.gridResolution;

			// update cbuffer
			PushConstantBufferData(cmd, volumeData.buffers.VolumeCBuffer, volumeConstants);

			// lod selection
			BindVolumeData(cmd, s_volumeCS, VolumeKernels.KLODSelection, volumeData);
			cmd.DispatchCompute(s_volumeCS, VolumeKernels.KLODSelection, 1, 1, 1);

			// schedule readback
			volumeData.buffersReadback._VolumeLODStage.ScheduleCopy(cmd, volumeData.buffers._VolumeLODStage);
		}

		public static void PushVolumeStepBegin(CommandBuffer cmd, ref VolumeData volumeData, in SettingsVolume settingsVolume, float deltaTime)
		{
			ref var volumeConstants = ref volumeData.constants;
			ref var volumeKeywords = ref volumeData.keywords;

			// derive constants
			var allGroupsAvgRestSpan = volumeConstants._AllGroupsAvgParticleDiameter + volumeConstants._AllGroupsAvgParticleMargin;
			var allGroupsAvgRestDensity = (volumeConstants._AllGroupsAvgParticleDiameter * volumeConstants._AllGroupsAvgParticleDiameter) / (allGroupsAvgRestSpan * allGroupsAvgRestSpan);

			volumeConstants._VolumeDT = deltaTime;

			volumeConstants._TargetDensityScale = Mathf.Max(1e-7f, settingsVolume.restDensityScale * allGroupsAvgRestDensity);
			volumeConstants._TargetDensityInfluence = settingsVolume.restDensityInfluence;

			volumeConstants._ScatteringProbeUnitWidth = volumeConstants._AllGroupsAvgParticleDiameter * (1.0f / Mathf.Max(1e-7f, settingsVolume.scatteringProbeBias));
			volumeConstants._ScatteringProbeSubsteps = settingsVolume.scatteringProbeCellSubsteps;
			volumeConstants._ScatteringProbeSamplesTheta = settingsVolume.probeSamplesTheta;
			volumeConstants._ScatteringProbeSamplesPhi = settingsVolume.probeSamplesPhi;
			volumeConstants._ScatteringProbeOccluderDensity = (settingsVolume.probeOcclusion ? settingsVolume.probeOcclusionSolidDensity : 0.0f);
			volumeConstants._ScatteringProbeOccluderMargin = 1.0f;// multiplier for cell radius //TODO expose more control if necessary

			volumeConstants._WindPropagationSubsteps = settingsVolume.windPropagationCellSubsteps;
			volumeConstants._WindPropagationExtinction = 1.0f / Mathf.Max(1e-7f, settingsVolume.windDepth * 0.01f);
			volumeConstants._WindPropagationOccluderDensity = (settingsVolume.windOcclusion ? float.PositiveInfinity : 0.0f);
			volumeConstants._WindPropagationOccluderMargin = (settingsVolume.windOcclusionMode == SettingsVolume.OcclusionMode.Discrete) ? 1.0f : 0.0f;// multiplier for cell radius //TODO expose more control if necessary

			// derive features
			VolumeFeatures features = 0;
			{
				features |= (settingsVolume.scatteringProbe) ? VolumeFeatures.Scattering : 0;
				features |= (settingsVolume.scatteringProbe && (volumeConstants._ScatteringProbeOccluderDensity == 0.0f || settingsVolume.probeOcclusionMode == SettingsVolume.OcclusionMode.Discrete)) ? VolumeFeatures.ScatteringFastpath : 0;
				features |= (settingsVolume.windPropagation) ? VolumeFeatures.Wind : 0;
				features |= (settingsVolume.windPropagation && (volumeConstants._WindPropagationOccluderDensity == 0.0f || settingsVolume.windOcclusionMode == SettingsVolume.OcclusionMode.Discrete)) ? VolumeFeatures.WindFastpath : 0;
			}
			volumeConstants._VolumeFeatures = (uint)features;

			// derive keywords
			volumeKeywords.VOLUME_SPLAT_CLUSTERS = (settingsVolume.splatClusters);
			volumeKeywords.VOLUME_TARGET_INITIAL_POSE = (settingsVolume.restDensity == SettingsVolume.RestDensity.InitialPose);
			volumeKeywords.VOLUME_TARGET_INITIAL_POSE_IN_PARTICLES = (settingsVolume.restDensity == SettingsVolume.RestDensity.InitialPoseInParticles);
			volumeKeywords.VOLUME_SUPPORT_CONTRACTION = (settingsVolume.pressureSolution == SettingsVolume.PressureSolution.DensityEquals);

			// update cbuffer
			PushConstantBufferData(cmd, volumeData.buffers.VolumeCBuffer, volumeConstants);
		}

		public static void PushVolumeStep(CommandBuffer cmd, CommandBufferExecutionFlags cmdFlags, ref VolumeData volumeData, in SettingsVolume settingsVolume, SolverData[] solverData, float stepFracLo, float stepFracHi, double stepTimeHi)
		{
			using (new ProfilingScope(cmd, MarkersGPU.Volume))
			{
				// update clock
				{
					volumeData.constantsEnvironment._WindEmitterClock = (float)stepTimeHi;
					PushConstantBufferData(cmd, volumeData.buffers.VolumeCBufferEnvironment, volumeData.constantsEnvironment);
				}

				// substep per-frame scene data
				if (stepFracHi > 0.0f)
				{
					//TODO skip substepping if range stepFracLo, stepFracHi is [0, 1]

					cmd.SetComputeFloatParam(s_volumeCS, UniformIDs._SubstepFractionLo, stepFracLo);
					cmd.SetComputeFloatParam(s_volumeCS, UniformIDs._SubstepFractionHi, stepFracHi);

					// substep boundaries
					{
						int numX = (Conf.MAX_BOUNDARIES + THREAD_GROUP_SIZE - 1) / THREAD_GROUP_SIZE;
						int numY = 1;
						int numZ = 1;

						BindVolumeData(cmd, s_volumeCS, VolumeKernels.KBoundariesSubstep, volumeData);
						cmd.DispatchCompute(s_volumeCS, VolumeKernels.KBoundariesSubstep, numX, numY, numZ);
					}

					// substep emitters
					{
						int numX = (Conf.MAX_EMITTERS + THREAD_GROUP_SIZE - 1) / THREAD_GROUP_SIZE;
						int numY = 1;
						int numZ = 1;

						BindVolumeData(cmd, s_volumeCS, VolumeKernels.KEmittersSubstep, volumeData);
						cmd.DispatchCompute(s_volumeCS, VolumeKernels.KEmittersSubstep, numX, numY, numZ);

						/*
						volumeData.buffersReadback._WindEmitter.ScheduleCopy(cmd, volumeData.buffers._WindEmitter);
						{
							var data = volumeData.buffersReadback._WindEmitter.GetData<HairWind.RuntimeEmitter>(true);
							Debug.Log("---emitters---");
							for (int i = 0; i != volumeData.constantsEnvironment._WindEmitterCount; i++)
							{
								var e = data[i];
								Debug.LogFormat(
									"p {0}\tn {1}\tt0 {2}\th0 {3}\tm {4}\t" +
									"v {5}\tA {6}\tf {7}\t" +
									"jd {8}\tjw {9}\tjp {10}",
									e.p, e.n, e.t0, e.h0, e.m,
									e.v, e.A, e.f,
									e.jd, e.jw, e.jp);
							}
						}
						*/
					}
				}

				// build the volume
				{
					HairSim.PushVolumeClear(cmd, ref volumeData, settingsVolume);

					for (int i = 0; i != solverData.Length; i++)
					{
						HairSim.PushVolumeTransfer(cmd, cmdFlags, ref volumeData, settingsVolume, solverData[i]);
					}

					HairSim.PushVolumeResolve(cmd, ref volumeData, settingsVolume);
				}
			}
		}

		public static void PushVolumeStepEnd(CommandBuffer cmd, in VolumeData volumeData, in SettingsVolume settingsVolume)
		{
			// build the per-frame volume data
			{
				PushVolumeScattering(cmd, volumeData, settingsVolume);
			}
		}

		static void PushVolumeClear(CommandBuffer cmd, ref VolumeData volumeData, in SettingsVolume settingsVolume)
		{
			using (new ProfilingScope(cmd, MarkersGPU.Volume_0_Clear))
			{
				BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumeClear, volumeData);
				cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumeClear, volumeData.buffers._VolumeLODDispatch, GetVolumeLODDispatchOffset(VolumeLODDispatch.Resolve));
			}
		}

		static void PushVolumeTransfer(CommandBuffer cmd, CommandBufferExecutionFlags cmdFlags, ref VolumeData volumeData, in SettingsVolume settingsVolume, in SolverData solverData)
		{
			var transferDispatch = volumeData.keywords.VOLUME_SPLAT_CLUSTERS ?
				SolverLODDispatch.Transfer :
				SolverLODDispatch.TransferAll;

			using (new ProfilingScope(cmd, MarkersGPU.Volume_1_Splat))
			{
				switch (settingsVolume.splatMethod)
				{
					case SettingsVolume.SplatMethod.Compute:
						{
							BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumeSplat, volumeData);
							BindSolverData(cmd, s_volumeCS, VolumeKernels.KVolumeSplat, solverData);
							cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumeSplat, solverData.buffers._SolverLODDispatch, GetSolverLODDispatchOffset(transferDispatch));
						}
						break;

					case SettingsVolume.SplatMethod.ComputeSplit:
						{
							using (new ProfilingScope(cmd, MarkersGPU.Volume_1_Splat_Density))
							{
								BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumeSplatDensity, volumeData);
								BindSolverData(cmd, s_volumeCS, VolumeKernels.KVolumeSplatDensity, solverData);
								cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumeSplatDensity, solverData.buffers._SolverLODDispatch, GetSolverLODDispatchOffset(transferDispatch));
							}

							using (new ProfilingScope(cmd, MarkersGPU.Volume_1_Splat_VelocityXYZ))
							{
								BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumeSplatVelocityX, volumeData);
								BindSolverData(cmd, s_volumeCS, VolumeKernels.KVolumeSplatVelocityX, solverData);
								cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumeSplatVelocityX, solverData.buffers._SolverLODDispatch, GetSolverLODDispatchOffset(transferDispatch));

								BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumeSplatVelocityY, volumeData);
								BindSolverData(cmd, s_volumeCS, VolumeKernels.KVolumeSplatVelocityY, solverData);
								cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumeSplatVelocityY, solverData.buffers._SolverLODDispatch, GetSolverLODDispatchOffset(transferDispatch));

								BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumeSplatVelocityZ, volumeData);
								BindSolverData(cmd, s_volumeCS, VolumeKernels.KVolumeSplatVelocityZ, solverData);
								cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumeSplatVelocityZ, solverData.buffers._SolverLODDispatch, GetSolverLODDispatchOffset(transferDispatch));
							}
						}
						break;

					case SettingsVolume.SplatMethod.Rasterization:
						{
							if (cmdFlags.HasFlag(CommandBufferExecutionFlags.AsyncCompute))
							{
								goto case SettingsVolume.SplatMethod.Compute;
							}
							else if (s_runtimeFlags.HasFlag(RuntimeFlags.SupportsGeometryStage))
							{
								var rasterDispatchPoints = volumeData.keywords.VOLUME_SPLAT_CLUSTERS ?
									SolverLODDispatch.RasterPoints :
									SolverLODDispatch.RasterPointsAll;

								using (new ProfilingScope(cmd, MarkersGPU.Volume_1_Splat_Rasterization))
								{
									CoreUtils.SetRenderTarget(cmd, volumeData.textures._VolumeVelocity, ClearFlag.Color);

									BindVolumeData(cmd, volumeData);
									BindSolverData(cmd, solverData);
									cmd.DrawProceduralIndirect(Matrix4x4.identity, s_volumeRasterMat, 0, MeshTopology.Points, solverData.buffers._SolverLODDispatch, (int)GetSolverLODDispatchOffset(rasterDispatchPoints));
								}
							}
							else
							{
								goto case SettingsVolume.SplatMethod.RasterizationNoGS;
							}
						}
						break;

					case SettingsVolume.SplatMethod.RasterizationNoGS:
						{
							if (cmdFlags.HasFlag(CommandBufferExecutionFlags.AsyncCompute))
							{
								goto case SettingsVolume.SplatMethod.Compute;
							}
							else
							{
								var rasterDispatchQuads = volumeData.keywords.VOLUME_SPLAT_CLUSTERS ?
									SolverLODDispatch.RasterQuads :
									SolverLODDispatch.RasterQuadsAll;

								using (new ProfilingScope(cmd, MarkersGPU.Volume_1_Splat_RasterizationNoGS))
								{
									CoreUtils.SetRenderTarget(cmd, volumeData.textures._VolumeVelocity, ClearFlag.Color);

									BindVolumeData(cmd, volumeData);
									BindSolverData(cmd, solverData);
									cmd.DrawProceduralIndirect(Matrix4x4.identity, s_volumeRasterMat, 1, MeshTopology.Quads, solverData.buffers._SolverLODDispatch, (int)GetSolverLODDispatchOffset(rasterDispatchQuads));
								}
							}
						}
						break;
				}
			}
		}

		static void PushVolumeResolve(CommandBuffer cmd, ref VolumeData volumeData, in SettingsVolume settingsVolume)
		{
			// resolve density, velocity
			switch (settingsVolume.splatMethod)
			{
				case SettingsVolume.SplatMethod.Compute:
				case SettingsVolume.SplatMethod.ComputeSplit:
					{
						using (new ProfilingScope(cmd, MarkersGPU.Volume_2_Resolve))
						{
							BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumeResolve, volumeData);
							cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumeResolve, volumeData.buffers._VolumeLODDispatch, GetVolumeLODDispatchOffset(VolumeLODDispatch.Resolve));
						}
					}
					break;

				case SettingsVolume.SplatMethod.Rasterization:
				case SettingsVolume.SplatMethod.RasterizationNoGS:
					{
						using (new ProfilingScope(cmd, MarkersGPU.Volume_2_ResolveRaster))
						{
							BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumeResolveRaster, volumeData);
							cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumeResolveRaster, volumeData.buffers._VolumeLODDispatch, GetVolumeLODDispatchOffset(VolumeLODDispatch.Resolve));
						}
					}
					break;
			}

			// compute divergence
			using (new ProfilingScope(cmd, MarkersGPU.Volume_3_Divergence))
			{
				BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumeDivergence, volumeData);
				cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumeDivergence, volumeData.buffers._VolumeLODDispatch, GetVolumeLODDispatchOffset(VolumeLODDispatch.Resolve));
			}

			// pressure eos (initial guess)
			using (new ProfilingScope(cmd, MarkersGPU.Volume_4_PressureEOS))
			{
				BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumePressureEOS, volumeData);
				cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumePressureEOS, volumeData.buffers._VolumeLODDispatch, GetVolumeLODDispatchOffset(VolumeLODDispatch.Resolve));
			}

			// pressure solve (jacobi)
			using (new ProfilingScope(cmd, MarkersGPU.Volume_5_PressureSolve))
			{
				BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumePressureSolve, volumeData);

				for (int i = 0; i != settingsVolume.pressureIterations; i++)
				{
					cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumePressureSolve, volumeData.buffers._VolumeLODDispatch, GetVolumeLODDispatchOffset(VolumeLODDispatch.Resolve));

					CoreUtils.Swap(ref volumeData.textures._VolumePressure, ref volumeData.textures._VolumePressureNext);
					cmd.SetComputeTextureParam(s_volumeCS, VolumeKernels.KVolumePressureSolve, VolumeData.s_textureIDs._VolumePressure, volumeData.textures._VolumePressure);
					cmd.SetComputeTextureParam(s_volumeCS, VolumeKernels.KVolumePressureSolve, VolumeData.s_textureIDs._VolumePressureNext, volumeData.textures._VolumePressureNext);
				}
			}

			// pressure gradient
			using (new ProfilingScope(cmd, MarkersGPU.Volume_6_PressureGradient))
			{
				BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumePressureGradient, volumeData);
				cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumePressureGradient, volumeData.buffers._VolumeLODDispatch, GetVolumeLODDispatchOffset(VolumeLODDispatch.Resolve));
			}

			// wind propagation
			if (settingsVolume.windPropagation)
			{
				using (new ProfilingScope(cmd, MarkersGPU.Volume_8_Wind))
				{
					switch (settingsVolume.windOcclusionMode)
					{
						case SettingsVolume.OcclusionMode.Discrete:
							{
								if (volumeData.constants._WindPropagationOccluderDensity == 0.0f)
								{
									goto case SettingsVolume.OcclusionMode.Exact;
								}

								cmd.GetTemporaryRT(VolumeData.s_textureIDs._VolumeDensityComp, MakeVolumeDesc((int)settingsVolume.gridResolution, RenderTextureFormat.RHalf));

								BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumeWindPrep, volumeData);
								cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumeWindPrep, volumeData.buffers._VolumeLODDispatch, GetVolumeLODDispatchOffset(VolumeLODDispatch.Resolve));

								BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumeWind, volumeData);
								cmd.SetComputeTextureParam(s_volumeCS, VolumeKernels.KVolumeWind, VolumeData.s_textureIDs._VolumeDensity, VolumeData.s_textureIDs._VolumeDensityComp);
								cmd.SetComputeTextureParam(s_volumeCS, VolumeKernels.KVolumeWind, VolumeData.s_textureIDs._VolumeDensityPreComp, volumeData.textures._VolumeDensity);
								cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumeWind, volumeData.buffers._VolumeLODDispatch, GetVolumeLODDispatchOffset(VolumeLODDispatch.Resolve));

								cmd.ReleaseTemporaryRT(VolumeData.s_textureIDs._VolumeDensityComp);
							}
							break;

						case SettingsVolume.OcclusionMode.Exact:
							{
								BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumeWind, volumeData);
								cmd.SetComputeTextureParam(s_volumeCS, VolumeKernels.KVolumeWind, VolumeData.s_textureIDs._VolumeDensityPreComp, volumeData.textures._VolumeDensity);
								cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumeWind, volumeData.buffers._VolumeLODDispatch, GetVolumeLODDispatchOffset(VolumeLODDispatch.Resolve));
							}
							break;
					}
				}
			}
		}

		public static void PushVolumeScattering(CommandBuffer cmd, in VolumeData volumeData, in SettingsVolume settingsVolume)
		{
			// scattering probe
			if (settingsVolume.scatteringProbe)
			{
				using (new ProfilingScope(cmd, MarkersGPU.Volume_7_Scattering))
				{
					switch (settingsVolume.probeOcclusionMode)
					{
						case SettingsVolume.OcclusionMode.Discrete:
							{
								if (volumeData.constants._ScatteringProbeOccluderDensity > 0.0f)
								{
									goto case SettingsVolume.OcclusionMode.Exact;
								}

								cmd.GetTemporaryRT(VolumeData.s_textureIDs._VolumeDensityComp, MakeVolumeDesc((int)settingsVolume.gridResolution, RenderTextureFormat.RHalf));

								BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumeScatteringPrep, volumeData);
								cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumeScatteringPrep, volumeData.buffers._VolumeLODDispatch, GetVolumeLODDispatchOffset(VolumeLODDispatch.Resolve));

								BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumeScattering, volumeData);
								cmd.SetComputeTextureParam(s_volumeCS, VolumeKernels.KVolumeScattering, VolumeData.s_textureIDs._VolumeDensity, VolumeData.s_textureIDs._VolumeDensityComp);
								cmd.SetComputeTextureParam(s_volumeCS, VolumeKernels.KVolumeScattering, VolumeData.s_textureIDs._VolumeDensityPreComp, volumeData.textures._VolumeDensity);
								cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumeScattering, volumeData.buffers._VolumeLODDispatch, GetVolumeLODDispatchOffset(VolumeLODDispatch.Resolve));

								cmd.ReleaseTemporaryRT(VolumeData.s_textureIDs._VolumeDensityComp);
							}
							break;

						case SettingsVolume.OcclusionMode.Exact:
							{
								BindVolumeData(cmd, s_volumeCS, VolumeKernels.KVolumeScattering, volumeData);
								cmd.SetComputeTextureParam(s_volumeCS, VolumeKernels.KVolumeScattering, VolumeData.s_textureIDs._VolumeDensityPreComp, volumeData.textures._VolumeDensity);
								cmd.DispatchCompute(s_volumeCS, VolumeKernels.KVolumeScattering, volumeData.buffers._VolumeLODDispatch, GetVolumeLODDispatchOffset(VolumeLODDispatch.Resolve));
							}
							break;
					}
				}
			}
		}

		enum DebugDrawPass
		{
			StrandRootFrame			= 0,
			StrandParticlePosition	= 1,
			StrandParticleVelocity	= 2,
			StrandParticleClusters	= 3,
			VolumeCellDensity		= 4,
			VolumeCellGradient		= 5,
			VolumeSliceAbove		= 6,
			VolumeSliceBelow		= 7,
			VolumeIsosurface		= 8,
		};

		public static void DrawSolverData(CommandBuffer cmd, in SolverData solverData, in SettingsDebugging settingsDebugging)
		{
			using (new ProfilingScope(cmd, MarkersGPU.DrawSolverData))
			{
				if (!settingsDebugging.drawStrandRoots &&
					!settingsDebugging.drawStrandParticles &&
					!settingsDebugging.drawStrandVelocities &&
					!settingsDebugging.drawStrandClusters)
					return;

				BindSolverData(cmd, solverData);

				s_debugDrawPb.SetInt(UniformIDs._DebugCluster, settingsDebugging.specificCluster);

				// strand roots
				if (settingsDebugging.drawStrandRoots)
				{
					cmd.DrawProcedural(Matrix4x4.identity, s_debugDrawMat, (int)DebugDrawPass.StrandRootFrame, MeshTopology.Lines, vertexCount: 6, (int)solverData.constants._StrandCount, s_debugDrawPb);
				}

				// strand particles
				if (settingsDebugging.drawStrandParticles)
				{
					cmd.DrawProcedural(Matrix4x4.identity, s_debugDrawMat, (int)DebugDrawPass.StrandParticlePosition, MeshTopology.Points, vertexCount: (int)solverData.constants._StrandParticleCount, (int)solverData.constants._StrandCount, s_debugDrawPb);
				}

				// strand velocities
				if (settingsDebugging.drawStrandVelocities)
				{
					if (Conf.SECOND_ORDER_UPDATE != 0)
						cmd.DrawProcedural(Matrix4x4.identity, s_debugDrawMat, (int)DebugDrawPass.StrandParticleVelocity, MeshTopology.Lines, vertexCount: 4 * (int)solverData.constants._StrandParticleCount, (int)solverData.constants._StrandCount, s_debugDrawPb);
					else
						cmd.DrawProcedural(Matrix4x4.identity, s_debugDrawMat, (int)DebugDrawPass.StrandParticleVelocity, MeshTopology.Lines, vertexCount: 2 * (int)solverData.constants._StrandParticleCount, (int)solverData.constants._StrandCount, s_debugDrawPb);
				}

				// strand clusters
				if (settingsDebugging.drawStrandClusters)
				{
					cmd.DrawProcedural(Matrix4x4.identity, s_debugDrawMat, (int)DebugDrawPass.StrandParticleClusters, MeshTopology.Lines, vertexCount: 2, (int)solverData.constants._StrandCount, s_debugDrawPb);
				}
			}
		}

		public static void DrawVolumeData(CommandBuffer cmd, in VolumeData volumeData, in SettingsDebugging settingsDebugging)
		{
			using (new ProfilingScope(cmd, MarkersGPU.DrawVolumeData))
			{
				if (!settingsDebugging.drawCellDensity &&
					!settingsDebugging.drawCellGradient &&
					!settingsDebugging.drawSliceX &&
					!settingsDebugging.drawSliceY &&
					!settingsDebugging.drawSliceZ &&
					!settingsDebugging.drawIsosurface)
					return;

				BindVolumeData(cmd, volumeData);

				// cell density
				if (settingsDebugging.drawCellDensity)
				{
					cmd.DrawProceduralIndirect(Matrix4x4.identity, s_debugDrawMat, (int)DebugDrawPass.VolumeCellDensity, MeshTopology.Points, volumeData.buffers._VolumeLODDispatch, (int)GetVolumeLODDispatchOffset(VolumeLODDispatch.RasterPoints));
					//cmd.DrawProcedural(Matrix4x4.identity, s_debugDrawMat, DEBUG_PASS_VOLUME_CELL_DENSITY, MeshTopology.Points, GetVolumeCellCount(volumeData), 1);
				}

				// cell gradient
				if (settingsDebugging.drawCellGradient)
				{
					cmd.DrawProceduralIndirect(Matrix4x4.identity, s_debugDrawMat, (int)DebugDrawPass.VolumeCellGradient, MeshTopology.Lines, volumeData.buffers._VolumeLODDispatch, (int)GetVolumeLODDispatchOffset(VolumeLODDispatch.RasterVectors));
					//cmd.DrawProcedural(Matrix4x4.identity, s_debugDrawMat, DEBUG_PASS_VOLUME_CELL_GRADIENT, MeshTopology.Lines, 2 * GetVolumeCellCount(volumeData), 1);
				}

				// volume slices
				if (settingsDebugging.drawSliceX || settingsDebugging.drawSliceY || settingsDebugging.drawSliceZ)
				{
					s_debugDrawPb.SetFloat(UniformIDs._DebugSliceDivider, settingsDebugging.drawSliceDivider);

					if (settingsDebugging.drawSliceX)
					{
						s_debugDrawPb.SetInt(UniformIDs._DebugSliceAxis, 0);
						s_debugDrawPb.SetFloat(UniformIDs._DebugSliceOffset, settingsDebugging.drawSliceXOffset);

						s_debugDrawPb.SetFloat(UniformIDs._DebugSliceOpacity, 0.8f);
						cmd.DrawProcedural(Matrix4x4.identity, s_debugDrawMat, (int)DebugDrawPass.VolumeSliceAbove, MeshTopology.Quads, 4, 1, s_debugDrawPb);
						s_debugDrawPb.SetFloat(UniformIDs._DebugSliceOpacity, 0.2f);
						cmd.DrawProcedural(Matrix4x4.identity, s_debugDrawMat, (int)DebugDrawPass.VolumeSliceBelow, MeshTopology.Quads, 4, 1, s_debugDrawPb);
					}
					if (settingsDebugging.drawSliceY)
					{
						s_debugDrawPb.SetInt(UniformIDs._DebugSliceAxis, 1);
						s_debugDrawPb.SetFloat(UniformIDs._DebugSliceOffset, settingsDebugging.drawSliceYOffset);

						s_debugDrawPb.SetFloat(UniformIDs._DebugSliceOpacity, 0.8f);
						cmd.DrawProcedural(Matrix4x4.identity, s_debugDrawMat, (int)DebugDrawPass.VolumeSliceAbove, MeshTopology.Quads, 4, 1, s_debugDrawPb);
						s_debugDrawPb.SetFloat(UniformIDs._DebugSliceOpacity, 0.2f);
						cmd.DrawProcedural(Matrix4x4.identity, s_debugDrawMat, (int)DebugDrawPass.VolumeSliceBelow, MeshTopology.Quads, 4, 1, s_debugDrawPb);
					}
					if (settingsDebugging.drawSliceZ)
					{
						s_debugDrawPb.SetInt(UniformIDs._DebugSliceAxis, 2);
						s_debugDrawPb.SetFloat(UniformIDs._DebugSliceOffset, settingsDebugging.drawSliceZOffset);

						s_debugDrawPb.SetFloat(UniformIDs._DebugSliceOpacity, 0.8f);
						cmd.DrawProcedural(Matrix4x4.identity, s_debugDrawMat, (int)DebugDrawPass.VolumeSliceAbove, MeshTopology.Quads, 4, 1, s_debugDrawPb);
						s_debugDrawPb.SetFloat(UniformIDs._DebugSliceOpacity, 0.2f);
						cmd.DrawProcedural(Matrix4x4.identity, s_debugDrawMat, (int)DebugDrawPass.VolumeSliceBelow, MeshTopology.Quads, 4, 1, s_debugDrawPb);
					}
				}

				// volume isosurface
				if (settingsDebugging.drawIsosurface)
				{
					var volumeBounds = GetVolumeBounds(volumeData);

					s_debugDrawPb.SetFloat(UniformIDs._DebugIsosurfaceDensity, settingsDebugging.drawIsosurfaceDensity);
					s_debugDrawPb.SetInt(UniformIDs._DebugIsosurfaceSubsteps, (int)settingsDebugging.drawIsosurfaceSubsteps);

					cmd.DrawMesh(s_debugDrawCube, Matrix4x4.TRS(volumeBounds.center, Quaternion.identity, 2.0f * volumeBounds.extents), s_debugDrawMat, 0, (int)DebugDrawPass.VolumeIsosurface, s_debugDrawPb);
				}
			}
		}

		//TODO move elsewhere
		//maybe 'HairSimDataUtility' ?
		public static Bounds GetSolverBounds(in SolverData solverData, in VolumeData volumeData)
		{
			var boundsBuffer = volumeData.buffersReadback._Bounds.GetData<LODBounds>();
			if (boundsBuffer.IsCreated)
			{
				var bounds = boundsBuffer[(int)solverData.constants._GroupBoundsIndex];
				return new Bounds(bounds.center, 2.0f * bounds.extent);
			}
			else
			{
				return new Bounds();
			}
		}

		public static Bounds GetVolumeBounds(in VolumeData volumeData)
		{
			var boundsBuffer = volumeData.buffersReadback._Bounds.GetData<LODBounds>();
			if (boundsBuffer.IsCreated)
			{
				var bounds = boundsBuffer[(int)volumeData.constants._CombinedBoundsIndex];
				return new Bounds(bounds.center, 2.0f * bounds.extent).ToSquare();
			}
			else
			{
				return new Bounds();
			}
		}

		public static LODIndices GetSolverLODSelection(in SolverData solverData, SolverLODStage solverLODStage)
		{
			var lodDescBuffer = solverData.buffersReadback._SolverLODStage.GetData<LODIndices>();
			if (lodDescBuffer.IsCreated)
			{
				return lodDescBuffer[(int)solverLODStage];
			}
			else
			{
				return new LODIndices();
			}
		}

		public static VolumeLODGrid GetVolumeLODSelection(in VolumeData volumeData, VolumeLODStage volumeLODStage)
		{
			var lodGridBuffer = volumeData.buffersReadback._VolumeLODStage.GetData<VolumeLODGrid>();
			if (lodGridBuffer.IsCreated)
			{
				return lodGridBuffer[(int)volumeLODStage];
			}
			else
			{
				return new VolumeLODGrid();
			}
		}

		public static uint GetSolverLODDispatchOffset(SolverLODDispatch index)
		{
			return (uint)index * 4 * sizeof(uint);
		}

		public static uint GetVolumeLODDispatchOffset(VolumeLODDispatch index)
		{
			return (uint)index * 4 * sizeof(uint);
		}

		public static uint GetSolverLODTopologyOffset(SolverLODTopology index)
		{
			return (uint)index * 5 * sizeof(uint);
		}
	}
}
```

`Runtime/HairSim.cs.meta`:

```meta
fileFormatVersion: 2
guid: e2b6d23d090c06245aca3124e153206f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimComputeConfig.hlsl`:

```hlsl
#ifndef __HAIRSIMCOMPUTECONFIG_HLSL__
#define __HAIRSIMCOMPUTECONFIG_HLSL__

#include "HairSimConf.cs.hlsl"

#endif//__HAIRSIMCOMPUTECONFIG_HLSL__

```

`Runtime/HairSimComputeConfig.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: 3e095a7ae4b7c8c4b9687fba61d3d6b5
ComputeShaderImporter:
  externalObjects: {}
  currentAPIMask: 4
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimComputeLOD.hlsl`:

```hlsl
#ifndef __HAIRSIMCOMPUTELOD_HLSL__
#define __HAIRSIMCOMPUTELOD_HLSL__

#include "HairSimData.hlsl"
#include "HairSim.LOD.cs.hlsl"

#ifdef __HAIRVERTEX_HLSL__
LODFrustum MakeLODFrustumForCurrentCamera()
{
	//float unitDepthScreenSpan = abs(1.0 / UNITY_MATRIX_P._m11);
	//float unitDepthPixelCount = 0.5 * _ScreenParams.y;
	//float unitDepthPixelSpan = unitDepthScreenSpan / unitDepthPixelCount;
	//float unitSpanSubpixelDepth = 1.0 / unitDepthPixelSpan;
	//                            = 1.0 / (unitDepthScreenSpan / unitDepthPixelCount);
	//                            = unitDepthPixelCount / unitDepthScreenSpan;
	//                            = unitDepthPixelCount / (1.0 / UNITY_MATRIX_P._m11);
	//                            = unitDepthPixelCount * UNITY_MATRIX_P._m11;
	//                            = 0.5 * _ScreenParams.y * UNITY_MATRIX_P._m11;
	//float unitSpanClippingDepth = unitSpanSubpixelDepth / lodClipThreshold;

	float unitDepthInvScreenSpan = UNITY_MATRIX_P._m11;
	float unitSpanSubpixelDepth = abs(0.5 * _ScreenParams.y * unitDepthInvScreenSpan);// lerp(unitDepthInvScreenSpan, 0.5 / unity_OrthoParams.y, unity_OrthoParams.w));

	bool cameraOrtho = (UNITY_MATRIX_P._m33 != 0.0);

	LODFrustum lodFrustum;
	{
		lodFrustum.cameraPosition = HAIR_VERTEX_IMPL_WS_POS_TO_RWS(_WorldSpaceCameraPos);
		lodFrustum.cameraForward = cameraOrtho ? float3(0.0, 0.0, 0.0) : -UNITY_MATRIX_V[2].xyz;
		lodFrustum.cameraNear = cameraOrtho ? 1.0 : _ProjectionParams.y;// cameraOrtho ? 1.0 : 0.001;// lerp(_ProjectionParams.y, 1.0, unity_OrthoParams.w);
		lodFrustum.unitSpanSubpixelDepth = unitSpanSubpixelDepth;
	}

	return lodFrustum;
}
#endif

bool LODFrustumContains(const LODFrustum lodFrustum, const LODBounds lodBounds)
{
	// see: https://fgiesen.wordpress.com/2010/10/17/view-frustum-culling/
	return (
		dot(lodBounds.center + lodBounds.extent * sign(lodFrustum.plane0.xyz), lodFrustum.plane0.xyz) > -lodFrustum.plane0.w &&
		dot(lodBounds.center + lodBounds.extent * sign(lodFrustum.plane1.xyz), lodFrustum.plane1.xyz) > -lodFrustum.plane1.w &&
		dot(lodBounds.center + lodBounds.extent * sign(lodFrustum.plane2.xyz), lodFrustum.plane2.xyz) > -lodFrustum.plane2.w &&
		dot(lodBounds.center + lodBounds.extent * sign(lodFrustum.plane3.xyz), lodFrustum.plane3.xyz) > -lodFrustum.plane3.w &&
		dot(lodBounds.center + lodBounds.extent * sign(lodFrustum.plane4.xyz), lodFrustum.plane4.xyz) > -lodFrustum.plane4.w &&
		dot(lodBounds.center + lodBounds.extent * sign(lodFrustum.plane5.xyz), lodFrustum.plane5.xyz) > -lodFrustum.plane5.w
	);
}

float LODFrustumCoverage(const LODFrustum lodFrustum, const float sampleDepth, const float sampleSpan)
{
	float sampleSpanSubpixelDepth = sampleSpan * lodFrustum.unitSpanSubpixelDepth;
	float sampleCoverage = sampleSpanSubpixelDepth / max(sampleDepth, lodFrustum.cameraNear);
	{
		return sampleCoverage;
	}
}

float LODFrustumCoverage(const LODFrustum lodFrustum, const float3 samplePosition, const float sampleSpan)
{
	float sampleDepth = dot(lodFrustum.cameraForward, samplePosition - lodFrustum.cameraPosition);
	{
		return LODFrustumCoverage(lodFrustum, sampleDepth, sampleSpan);
	}
}

float2 LODFrustumCoverageCeiling(const LODFrustum lodFrustum, const LODBounds lodBounds, const LODGeometry lodGeometry)
{
	if (LODFrustumContains(lodFrustum, lodBounds))
	{
		float3 cameraVector = lodFrustum.cameraPosition - lodBounds.center;
		float cameraDistance = length(cameraVector);

		//TODO revisit this
		float3 nearestSamplePosition = lodBounds.center + cameraVector * (min(cameraDistance, lodBounds.radius) / cameraDistance);
		float2 nearestSampleCoverage = float2(
			LODFrustumCoverage(lodFrustum, nearestSamplePosition, lodGeometry.maxParticleDiameter),
			LODFrustumCoverage(lodFrustum, nearestSamplePosition, lodGeometry.maxParticleInterval)
		);

		return nearestSampleCoverage;
	}
	else
	{
		return 0.0;
	}
}

float2 LODFrustumCoverageCeilingSequential(const LODBounds lodBounds, const LODGeometry lodGeometry)
{
	float2 maxCoverage = 0.0;
	{
		for (uint i = 0; i != _LODFrustumCount; i++)
		{
			maxCoverage = max(maxCoverage, LODFrustumCoverageCeiling(_LODFrustum[i], lodBounds, lodGeometry));
		}
	}

	return maxCoverage;
}

float ResolveLODQuantity(const float sampleCoverage, const float lodCeiling, const float lodScale, const float lodBias)
{
	//TODO: more friendly hybrid?
	//
	// if (bias < 0.0)
	//		scale	= 1 + min(0.0, bias)
	//		bias	= 0
	// else
	//		scale	= 1
	//		bias	= max(0.0, bias)
	//
	// float curveLod = saturate(curveCoverage) * (1.0 + min(0.0, lodBias)) + max(0.0, lodBias));   // lod in [0..1]

	float lodValue = saturate(saturate(sampleCoverage * lodScale) + lodBias);
	{
		return min(lodValue, lodCeiling);
	}
}

LODIndices ResolveLODIndices(const float lodValue)
{
	//TODO optimize
	//TODO e.g. could replace with lut, floor(sample(_LODIndicesByLODValue, lodValue))

	LODIndices lodDesc;
	{
		lodDesc.lodIndexLo = 0;
		lodDesc.lodIndexHi = _LODCount - 1;
		{
			while (lodDesc.lodIndexHi > 0)
			{
				if (lodValue > _LODGuideCount[lodDesc.lodIndexHi - 1] / (float)_StrandCount)
				{
					break;
				}
				else
				{
					lodDesc.lodIndexHi--;
				}
			}
		}
		
		if (lodDesc.lodIndexLo != lodDesc.lodIndexHi)
		{
			lodDesc.lodIndexLo = lodDesc.lodIndexHi - 1;
			{
				float lodValueLo = _LODGuideCount[lodDesc.lodIndexLo] / (float)_StrandCount;
				float lodValueHi = _LODGuideCount[lodDesc.lodIndexHi] / (float)_StrandCount;
			
				lodDesc.lodBlendFrac = saturate((lodValue - lodValueLo) / (lodValueHi - lodValueLo));
			}
		}
		else
		{
			lodDesc.lodBlendFrac = 0.0f;
		}
		
		lodDesc.lodValue = lodValue;
	}

	return lodDesc;
}

#endif//__HAIRSIMCOMPUTELOD_HLSL__
```

`Runtime/HairSimComputeLOD.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: 12485560b7773ce44ae09f54b59031a6
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  preprocessorOverride: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimComputeRoots.hlsl`:

```hlsl
#ifndef __HAIRSIMCOMPUTEROOTS_HLSL__
#define __HAIRSIMCOMPUTEROOTS_HLSL__

#include "HairSimData.cs.hlsl"
#include "HairSimComputeSolverQuaternion.hlsl"

void RootResolve(out float3 rootPosition, out float4 rootFrame, const float3 rootMeshPositionOS, const float4 rootMeshTangentOS, const float3 rootMeshNormalOS)
{
	// resolve root position
	rootPosition = mul(_RootMeshMatrix, float4(rootMeshPositionOS, 1.0)).xyz;

	// resolve root frame
	if (_RootMeshTangentStride != 0)
	{
		// reconstruct from tangent frame
		float3 localRootDir = rootMeshNormalOS;
		float3 localRootPerp = rootMeshTangentOS.xyz * rootMeshTangentOS.w;
		float4 localRootFrame = MakeQuaternionLookAtBasis(float3(0.0, 1.0, 0.0), localRootDir, float3(1.0, 0.0, 0.0), localRootPerp);

		// output world frame
		rootFrame = normalize(QMul(_RootMeshRotation, localRootFrame));
	}
	else
	{
		// reconstruct partially from direction
		float3 localRootDir = rootMeshNormalOS;
		float4 localRootFrame = MakeQuaternionFromTo(float3(0.0, 1.0, 0.0), localRootDir);

		// approximate twist from skinning bone delta
		float4 skinningBoneLocalDelta = QMul(_RootMeshRotationInv, _RootMeshSkinningRotation);
		float4 skinningBoneLocalTwist = QDecomposeTwist(skinningBoneLocalDelta, localRootDir);
		{
			localRootFrame = QMul(skinningBoneLocalTwist, localRootFrame);
		}

		// output world frame
		rootFrame = normalize(QMul(_RootMeshRotation, localRootFrame));
	}
}

#endif//__HAIRSIMCOMPUTEROOTS_HLSL__
```

`Runtime/HairSimComputeRoots.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: f562f19c863e5f24d974622714714d9d
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  preprocessorOverride: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimComputeRoots.shader`:

```shader
Shader "Hidden/HairSimComputeRoots"
{
	HLSLINCLUDE

	#pragma target 5.0

	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"

	#include "HairSimComputeRoots.hlsl"

	RWStructuredBuffer<float4> _UpdatedRootPosition : register(u1);
	RWStructuredBuffer<float4> _UpdatedRootFrame : register(u2);

	struct RootAttribs
	{
		float3 positionOS : POSITION;
		float4 tangentOS : TANGENT;
		float3 normalOS : NORMAL;
	};

	struct RootVaryings
	{
		float4 positionCS : SV_POSITION;
		float pointSize : PSIZE;
	};

	RootVaryings RootVert(RootAttribs attribs, uint strandIndex : SV_VertexID)
	{
		RootResolve(
			_UpdatedRootPosition[strandIndex].xyz,
			_UpdatedRootFrame[strandIndex],
			attribs.positionOS,
			attribs.tangentOS,
			attribs.normalOS
		);

		// clip
		RootVaryings v;
		v.positionCS = float4(0.0, 0.0, 1.0, 0.0);
		v.pointSize = 1.0;
		return v;
	}

	void RootFragDiscard()
	{
		discard;
	}

	ENDHLSL

	SubShader
	{
		Tags { "RenderType" = "Opaque" }

		Cull Off
		ZTest Always
		ZWrite Off

		Pass
		{
			HLSLPROGRAM

			#pragma vertex RootVert
			#pragma fragment RootFragDiscard

			ENDHLSL
		}
	}

	Fallback Off
}

```

`Runtime/HairSimComputeRoots.shader.meta`:

```meta
fileFormatVersion: 2
guid: 6e058d123672f674799fd1072e73d6d1
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimComputeSolver.compute`:

```compute
//#pragma use_dxc
//#pragma enable_d3d11_debug_symbols

#pragma kernel KRoots									THREAD_GROUP_SIZE=64	F_INPUT
#pragma kernel KRootsHistory							THREAD_GROUP_SIZE=64	F_INPUT
#pragma kernel KRootsHistoryAdd							THREAD_GROUP_SIZE=64	F_INPUT
#pragma kernel KRootsSubstep							THREAD_GROUP_SIZE=64	F_INPUT

#pragma kernel KLODSelectionInit						THREAD_GROUP_SIZE=1		F_LOD
#pragma kernel KLODSelection							THREAD_GROUP_SIZE=1		F_LOD
#pragma kernel KLODSelectionPost						THREAD_GROUP_SIZE=1		F_LOD

#pragma kernel KInitialize								THREAD_GROUP_SIZE=64	F_INIT
#pragma kernel KInitializePostVolume					THREAD_GROUP_SIZE=64	F_INIT
#pragma kernel KSolveConstraints_GaussSeidelReference	THREAD_GROUP_SIZE=64	F_SOLVE
#pragma kernel KSolveConstraints_GaussSeidel			THREAD_GROUP_SIZE=64	F_SOLVE		ALLOW_GROUPSHARED_STRAND_PROPERTIES=0 ALLOW_GROUPSHARED_BOUNDARY_DATA=1
#pragma kernel KSolveConstraints_Jacobi_16				THREAD_GROUP_SIZE=16	F_SOLVE		KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_16
#pragma kernel KSolveConstraints_Jacobi_32				THREAD_GROUP_SIZE=32	F_SOLVE		KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_32
#pragma kernel KSolveConstraints_Jacobi_64				THREAD_GROUP_SIZE=64	F_SOLVE		KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_64
#pragma kernel KSolveConstraints_Jacobi_128				THREAD_GROUP_SIZE=128	F_SOLVE		KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_128
#pragma kernel KInterpolate								THREAD_GROUP_SIZE=64	F_INTERPOLATE
#pragma kernel KInterpolateAdd							THREAD_GROUP_SIZE=64	F_INTERPOLATE
#pragma kernel KInterpolatePromote						THREAD_GROUP_SIZE=64	F_INTERPOLATE
#pragma kernel KStaging									THREAD_GROUP_SIZE=64	F_STAGING
#pragma kernel KStagingSubdivision						THREAD_GROUP_SIZE=64	F_STAGING
#pragma kernel KStagingHistory							THREAD_GROUP_SIZE=64	F_STAGING
#pragma kernel KStagingHistoryAdd						THREAD_GROUP_SIZE=64	F_STAGING

//----------
// includes

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"

#define HAIRSIM_WRITEABLE_SOLVERINPUT (F_INPUT)
#define HAIRSIM_WRITEABLE_SOLVERLOD (F_LOD)
#define HAIRSIM_WRITEABLE_SOLVERINIT (F_INIT)
#define HAIRSIM_WRITEABLE_SOLVERDATA (F_INIT || F_SOLVE || F_INTERPOLATE || F_STAGING)

#include "HairSimData.hlsl"
#include "HairSimComputeConfig.hlsl"
#include "HairSimComputeSolverBoundaries.hlsl"
#include "HairSimComputeSolverConstraints.hlsl"
#include "HairSimComputeSolverQuaternion.hlsl"
#include "HairSimComputeVolumeUtility.hlsl"
#include "HairSimComputeLOD.hlsl"

//----------
// features

#pragma multi_compile __ LIVE_POSITIONS_3 LIVE_POSITIONS_2 LIVE_POSITIONS_1
// 0 == no live positions
// N == num. live positions denoted by suffix

#pragma multi_compile __ LIVE_ROTATIONS_2
// 0 == no live rotations
// N == num. live rotations denoted by suffix

//------------------
// features derived

#if LIVE_POSITIONS_3
#define LIVE_POSITIONS 3
#elif LIVE_POSITIONS_2
#define LIVE_POSITIONS 2
#else
#define LIVE_POSITIONS 1
#endif

#if LIVE_ROTATIONS_2
#define LIVE_ROTATIONS 2
#else
#define LIVE_ROTATIONS 1
#endif

#define ENABLE(flag)					((_SolverFeatures & (flag)) != 0)
#define ENABLE_BOUNDARY					(LIVE_POSITIONS >= 1 && ENABLE(SOLVERFEATURES_BOUNDARY))
#define ENABLE_BOUNDARY_FRICTION		(LIVE_POSITIONS >= 1 && ENABLE(SOLVERFEATURES_BOUNDARY_FRICTION))
#define ENABLE_DISTANCE					(LIVE_POSITIONS >= 2 && ENABLE(SOLVERFEATURES_DISTANCE))
#define ENABLE_DISTANCE_LRA				(LIVE_POSITIONS >= 1 && ENABLE(SOLVERFEATURES_DISTANCE_LRA))
#define ENABLE_DISTANCE_FTL				(LIVE_POSITIONS >= 1 && ENABLE(SOLVERFEATURES_DISTANCE_FTL))
#define ENABLE_CURVATURE_EQ				(LIVE_POSITIONS >= 3 && ENABLE(SOLVERFEATURES_CURVATURE_EQ))
#define ENABLE_CURVATURE_GEQ			(LIVE_POSITIONS >= 3 && ENABLE(SOLVERFEATURES_CURVATURE_GEQ))
#define ENABLE_CURVATURE_LEQ			(LIVE_POSITIONS >= 3 && ENABLE(SOLVERFEATURES_CURVATURE_LEQ))
#define ENABLE_POSE_LOCAL_SHAPE			(LIVE_POSITIONS >= 2 && LIVE_ROTATIONS >= 2 && ENABLE(SOLVERFEATURES_POSE_LOCAL_SHAPE))
#define ENABLE_POSE_LOCAL_SHAPE_RWD		(LIVE_POSITIONS >= 2 && LIVE_ROTATIONS >= 2 && ENABLE(SOLVERFEATURES_POSE_LOCAL_SHAPE_RWD))
#define ENABLE_POSE_GLOBAL_ROTATION		(LIVE_POSITIONS >= 2 && LIVE_ROTATIONS >= 2 && ENABLE(SOLVERFEATURES_POSE_GLOBAL_ROTATION))
#define ENABLE_POSE_GLOBAL_POSITION		(ENABLE(SOLVERFEATURES_POSE_GLOBAL_POSITION))

#if SECOND_ORDER_UPDATE
#define SECOND_ORDER_POSITION 1
#define SECOND_ORDER_VELOCITY 0
#else
#define SECOND_ORDER_POSITION 0
#define SECOND_ORDER_VELOCITY 0
#endif

//---------------
// strand macros

#define CHECK_POW_2(n)					((n & (n - 1)) == 0)
#define CHECK_STRAND(x)					(x < _StrandCount)
#define CHECK_STRAND_WITHIN(i, range)	(i + range.x < range.y)

#define DECLARE_STRAND_UNCHECKED(x)											\
	const uint strandIndex = x;												\
	const uint strandParticleBegin = strandIndex * _StrandParticleOffset;	\
	const uint strandParticleStride = _StrandParticleStride;				\
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;

#define DECLARE_STRAND(x)						\
	if (!CHECK_STRAND(x)) return;				\
	DECLARE_STRAND_UNCHECKED(x);

#define DECLARE_STRAND_WITHIN(i, range)			\
	if (!CHECK_STRAND_WITHIN(i, range)) return;	\
	DECLARE_STRAND_UNCHECKED(i + range.x);

//-------------------
// strand properties

uint GetParticleIndex(const uint strandIndex, const uint strandParticleNumber)
{
	return strandIndex * _StrandParticleOffset + _StrandParticleStride * strandParticleNumber;
}

float3 GetRootPosition(uint strandIndex)
{
	return _RootPosition[strandIndex].xyz;
}

float4 GetRootFrame(uint strandIndex)
{
	return _RootFrame[strandIndex];
}

float GetParticleInterval(uint strandIndex)
{
	return _GroupMaxParticleInterval * _RootScale[strandIndex].x;
}

float GetParticleDiameter(uint strandIndex)
{
	return _GroupMaxParticleDiameter * _RootScale[strandIndex].y;
}

float GetBendingRadius(uint strandIndex)
{
	return _LocalCurvature * GetParticleInterval(strandIndex);
}

#if ALLOW_GROUPSHARED_STRAND_PROPERTIES && CHECK_POW_2(THREAD_GROUP_SIZE)

groupshared float3 gs_rootPosition[THREAD_GROUP_SIZE];
groupshared float4 gs_rootFrame[THREAD_GROUP_SIZE];
groupshared float gs_segmentLength[THREAD_GROUP_SIZE];
groupshared float gs_segmentDiameter[THREAD_GROUP_SIZE];
groupshared float gs_bendingRadius[THREAD_GROUP_SIZE];

#define STRAND_INDEX_TO_THREAD(strandIndex) ((strandIndex) & (THREAD_GROUP_SIZE - 1))

void PrepareStrandProperties(uint strandIndex)
{
	gs_rootPosition[STRAND_INDEX_TO_THREAD(strandIndex)] = GetRootPosition(strandIndex);
	gs_rootFrame[STRAND_INDEX_TO_THREAD(strandIndex)] = GetRootFrame(strandIndex);
	gs_segmentLength[STRAND_INDEX_TO_THREAD(strandIndex)] = GetParticleInterval(strandIndex);
	gs_segmentDiameter[STRAND_INDEX_TO_THREAD(strandIndex)] = GetParticleDiameter(strandIndex);
	gs_bendingRadius[STRAND_INDEX_TO_THREAD(strandIndex)] = GetBendingRadius(strandIndex);
}

#define GetRootPosition(strandIndex) gs_rootPosition[STRAND_INDEX_TO_THREAD(strandIndex)]
#define GetRootFrame(strandIndex) gs_rootFrame[STRAND_INDEX_TO_THREAD(strandIndex)]
#define GetParticleInterval(strandIndex) gs_segmentLength[STRAND_INDEX_TO_THREAD(strandIndex)]
#define GetParticleDiameter(strandIndex) gs_segmentDiameter[STRAND_INDEX_TO_THREAD(strandIndex)]
#define GetBendingRadius(strandIndex) gs_bendingRadius[STRAND_INDEX_TO_THREAD(strandIndex)]

#else

void PrepareStrandProperties(uint strandIndex) { }

#endif

//---------
// utility

float GetIterationStiffness(uint iteration)
{
	//return 1.0 - pow(abs(1.0 - _Stiffness), 1.0 / _Iterations);
	return 1.0 - pow(saturate(1.0 - _Stiffness), 1.0 / (iteration + 1));
}

float3 GetVolumeGravity(float3 x0)
{
	return (_WorldGravity.xyz * _GravityScale);
}

float3 GetVolumeImpulse(float3 x0, float3 v0)
{
	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	float3 volumeUVW = VolumeWorldToUVW(lodGrid, x0);
	float3 volumeImpulse = 0.0;

	// add cell pressure
	if (_CellPressure > 0.0)
	{
		volumeImpulse += _CellPressure * -VolumeSampleVector(_VolumePressureGrad, volumeUVW);
	}

	// add cell velocity
	if (_CellVelocity > 0.0)
	{
#if SPLAT_TRILINEAR
		volumeImpulse += _CellVelocity * (VolumeSampleVector(_VolumeVelocity, volumeUVW, _Volume_trilinear_clamp) - v0);
#else
		volumeImpulse += _CellVelocity * (VolumeSampleVector(_VolumeVelocity, volumeUVW, _Volume_point_clamp) - v0);
#endif
	}

	// add cell external
	if (_CellExternal > 0.0)
	{
		volumeImpulse += _CellExternal * VolumeSampleVector(_VolumeImpulse, volumeUVW);
	}

	return volumeImpulse;
}

//-------------
// integration

float3 IntegratePosition(float3 x0, float3 v0, float3 a0)
{
	return x0 + _DT * (v0 + _DT * a0);
}

float3 IntegratePosition_SecondOrder(float3 x0, float3 x0_minus1, float3 v0, float3 v0_minus1, float3 a0)
{
	// second order prediction
	// http://www.cs.ubc.ca/~rbridson/docs/english-siggraph08-cloth.pdf

	return (
		(4.0 / 3.0) * x0 -
		(1.0 / 3.0) * x0_minus1 +
		(8.0 / 9.0) * _DT * v0 -
		(2.0 / 9.0) * _DT * v0_minus1 +
		(4.0 / 9.0) * _DT * _DT * a0
	);
}

float3 DeriveVelocity(float3 x1, float3 x0)
{
	return (x1 - x0) / _DT;
	//TODO clamp?
}

float3 DeriveVelocity_SecondOrder(float3 x1, float3 x0, float3 x0_minus1)
{
	// second order velocity update
	// http://www.cs.ubc.ca/~rbridson/docs/english-siggraph08-cloth.pdf
	
	return (
		(3.0 / 2.0) * x1 -
		(2.0 / 1.0) * x0 +
		(1.0 / 2.0) * x0_minus1
	) / _DT;
}

void DeriveParticleVelocity(uint particleIndex, out float3 x1, out float3 v1)
{
	x1 = _ParticlePosition[particleIndex].xyz;
#if SECOND_ORDER_VELOCITY
	v1 = DeriveVelocity_SecondOrder(x1, _ParticlePositionPrev[particleIndex].xyz, _ParticlePositionPrevPrev[particleIndex].xyz);
#else
	v1 = DeriveVelocity(x1, _ParticlePositionPrev[particleIndex].xyz);
#endif
}

float3 DeriveParticleVelocity(uint particleIndex, float3 x1)
{
#if SECOND_ORDER_VELOCITY
	return DeriveVelocity_SecondOrder(x1, _ParticlePositionPrev[particleIndex].xyz, _ParticlePositionPrevPrev[particleIndex].xyz);
#else
	return DeriveVelocity(x1, _ParticlePositionPrev[particleIndex].xyz);
#endif
}

//-------
// decay

float GetDecayMultiplier(float fraction, float interval)
{
	return pow(max(1e-5, 1.0 - fraction), _DT / interval);
}

#define DEFINE_DECAY_FUNCTIONS(T)										\
	T Decay(T a, float fraction, float interval)						\
	{																	\
		return a * GetDecayMultiplier(fraction, interval);				\
	}																	\
	T DecayTowards(T a, T b, float fraction, float interval)			\
	{																	\
		return lerp(a, b, 1.0 - GetDecayMultiplier(fraction, interval));\
	}

DEFINE_DECAY_FUNCTIONS(float);
DEFINE_DECAY_FUNCTIONS(float2);
DEFINE_DECAY_FUNCTIONS(float3);
DEFINE_DECAY_FUNCTIONS(float4);

//---------
// damping

float3 LinearToAngular(float3 r, float3 v)
{
	float3 w = cross(r, v) / max(1e-37, dot(r, r));
	return w;
}

float3 LinearToAngularPoint(float3 pF, float3 vF, float3 p, float3 v)
{
	float3 w = LinearToAngular(p - pF, v - vF);
	return w;
}

float3 AngularToLinear(float3 r, float3 w)
{
	float3 v = cross(w, r);
	return v;
}

float3 AngularToLinearPoint(float3 pF, float3 vF, float3 p, float3 w)
{
	float3 v = vF + AngularToLinear(p - pF, w);
	return v;
}

void ApplyFTLCorrection(inout float3 v, float3 d)
{
	v -= (_FTLCorrection / _DT) * d;
}

void ApplyDampingLinear(inout float3 v)
{
	v *= GetDecayMultiplier(_LinearDamping, _LinearDampingInterval);
}

void ApplyDampingAngular(float3 p0, float3 p1, inout float3 v0, inout float3 v1, inout float3 d0, inout float3 d1)
{
#if 1
	float3 r = 0.5 * (p1 - p0);
	float3 v = 0.5 * (v1 - v0);

	float3 w = LinearToAngular(r, v);
	float3 w_damp = Decay(w, _AngularDamping, _AngularDampingInterval);

	float3 dv = AngularToLinear(r, w_damp - w);

	d0 -= dv;
	d1 += dv;
#else
	float3 r = 0.5 * (p1 - p0);
	float3 v = 0.5 * (v1 - v0);

	float3 v_tan = AngularToLinear(r, LinearToAngular(r, v));
	float3 v_tan_damp = Decay(v_tan, _AngularDamping, _AngularDampingInterval);

	float3 dv = v_tan_damp - v_tan;

	d0 -= dv;
	d1 += dv;
#endif
}

void ApplyDampingAngular(float3 p0, float3 p1, inout float3 v0, inout float3 v1)
{
	if (_AngularDamping > 0.0)
	{
		float3 d0 = 0;
		float3 d1 = 0;
		ApplyDampingAngular(p0, p1, v0, v1, d0, d1);
		v0 += d0;
		v1 += d1;
	}
}

void ApplyDampingDistance(float3 p0, float3 p1, inout float3 v0, inout float3 v1, inout float3 d0, inout float3 d1)
{
	//TODO separate damping coeff or group with linear/point?
	return;// disabled until then

	float3 n = normalize(p1 - p0);
	float3 v = v1 - v0;

	v0 += 0.5 * n * dot(n, v);
	v1 -= 0.5 * n * dot(n, v);
}

void ApplyDampingDistance(float3 p0, float3 p1, inout float3 v0, inout float3 v1)
{
	float3 d0 = 0;
	float3 d1 = 0;
	ApplyDampingDistance(p0, p1, v0, v1, d0, d1);
	p0 += d0;
	p1 += d1;
}

//-------------
// attenuation

float LinearRamp(float x, float4 ramp)
{
	// ramp.x = x min
	// ramp.y = x ext
	// ramp.z = y min
	// ramp.w = y ext
	return ramp.z + ramp.w * saturate((x - ramp.x) / ramp.y);
}

float4 LinearRampUnpack(uint rampPack)
{
	return saturate(
		float4(
			rampPack >> 24,
			rampPack >> 16,
			rampPack >> 8,
			rampPack
			) / 255.0
	);
}

float LinearRamp(float x, uint rampPack)
{
	return LinearRamp(x, LinearRampUnpack(rampPack));
}

float GetGlobalParamAttenuation(uint strandIndex, uint strandParticleNumber)
{
	float x = _RootScale[strandIndex].x * (strandParticleNumber / (float)(_StrandParticleCount - 1));
	return LinearRamp(x, float4(_GlobalFadeOffset, _GlobalFadeExtent, 1.0, -1.0));
}

float GetGlobalPositionInfluence(uint strandIndex, uint strandParticleNumber)
{
	float k = _GlobalPosition * GetGlobalParamAttenuation(strandIndex, strandParticleNumber);
	return 1.0 - GetDecayMultiplier(k, _GlobalPositionInterval);// fits into lerp(a, b, t), where b is the global position
}

float GetGlobalRotationInfluence(uint strandIndex, uint strandParticleNumber)
{
	float k = _GlobalRotation * GetGlobalParamAttenuation(strandIndex, strandParticleNumber);
	return k;
}

//--------------
// kernels init

#if F_INIT

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KInitialize(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);

	// calc initial local root frame
	float3 localRootPos = _ParticlePosition[strandParticleBegin].xyz;
	float3 localRootDir = normalize(_ParticlePosition[strandParticleBegin + strandParticleStride].xyz - localRootPos);
	float4 localRootFrame = MakeQuaternionFromTo(float3(0.0, 1.0, 0.0), localRootDir);// transforms 0,1,0 to initial local dir
	float4 localRootFrameInv = QInverse(localRootFrame);

	// calc initial particle offsets from strand root + set up initial world pose
	float4 worldRootFrame = GetRootFrame(strandIndex);
	float3 worldRootPos = GetRootPosition(strandIndex);

	for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
	{
		float3 localParticleOffset = QMul(localRootFrameInv, _ParticlePosition[i].xyz - localRootPos);
		{
			_InitialParticleOffset[i].xyz = localParticleOffset;
		}

		float3 worldParticleOffset = QMul(worldRootFrame, localParticleOffset * _GroupScale);
		{
			_ParticlePosition[i].xyz = (worldRootPos + worldParticleOffset);
			_ParticlePositionPrev[i].xyz = (worldRootPos + worldParticleOffset);
#if SECOND_ORDER_UPDATE
			_ParticlePositionPrevPrev[i].xyz = (worldRootPos + worldParticleOffset);
#endif

			_ParticleVelocity[i] = float3(0.0, 0.0, 0.0);
#if SECOND_ORDER_UPDATE
			_ParticleVelocityPrev[i] = float3(0.0, 0.0, 0.0);
#endif
		}
	}

	// calc initial particle material frame deltas
	{
		// root
		_InitialParticleFrameDelta[strandParticleBegin] = MakeQuaternionIdentity();
	
		// root+1
		float3 r0 = -float3(0.0, 1.0, 0.0);
		float3 r1 = 0.0;
		float3 r2 = _InitialParticleOffset[strandParticleBegin + strandParticleStride].xyz;
		{
			_InitialParticleFrameDelta[strandParticleBegin + strandParticleStride] = NextQuaternionFromBend(r0, r1, r2, MakeQuaternionIdentity());
		}
		
		// root+2..
		for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
		{
			r0 = r1;
			r1 = r2;
			r2 = _InitialParticleOffset[i].xyz;

			_InitialParticleFrameDelta[i] = NextQuaternionFromBend(r0, r1, r2, _InitialParticleFrameDelta[i - strandParticleStride]);
		}

		// reverse to finalize
		{
			for (uint i = strandParticleEnd - strandParticleStride; i != strandParticleBegin; i -= strandParticleStride)
			{
				float4 q0 = _InitialParticleFrameDelta[i - strandParticleStride];
				float4 q1 = _InitialParticleFrameDelta[i];
				float4 q = QMul(QInverse(q0), q1);

				_InitialParticleFrameDelta[i] = q;
				_InitialParticleFrameDelta16[i] = QEncode16(q);
			}
		}
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KInitializePostVolume(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);

	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
	{
		float3 uvw = VolumeWorldToUVW(lodGrid, _ParticlePosition[i].xyz);
		float accu_w = _VolumeVelocity.SampleLevel(_Volume_trilinear_clamp, uvw, 0).w;

		// estimate pre-insertion value given trilinear sample and trilinear weights
		{
			accu_w *= VolumeWorldToCellTrilinearInverseMultiplier(lodGrid, _ParticlePosition[i].xyz);
		}

		_InitialParticleOffset[i].w = accu_w;
	}
}

#endif//F_INIT

//---------------
// kernels input

#if F_INPUT

#include "HairSimComputeRoots.hlsl"

ByteAddressBuffer _RootMeshPosition;
ByteAddressBuffer _RootMeshTangent;
ByteAddressBuffer _RootMeshNormal;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KRoots(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);

	float3 rootMeshPositionOS = asfloat(_RootMeshPosition.Load3(strandIndex * _RootMeshPositionStride + _RootMeshPositionOffset));
	float4 rootMeshTangentOS = asfloat(_RootMeshTangent.Load4(strandIndex * _RootMeshTangentStride + _RootMeshTangentOffset));
	float3 rootMeshNormalOS = asfloat(_RootMeshNormal.Load3(strandIndex * _RootMeshNormalStride + _RootMeshNormalOffset));

	RootResolve(
		_RootPositionNext[strandIndex].xyz,
		_RootFrameNext[strandIndex],
		rootMeshPositionOS,
		rootMeshTangentOS,
		rootMeshNormalOS
	);
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KRootsHistory(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x)

	_RootPositionPrev[strandIndex] = _RootPositionNext[strandIndex];
	_RootPosition[strandIndex] = _RootPositionNext[strandIndex];

	_RootFramePrev[strandIndex] = _RootFrameNext[strandIndex];
	_RootFrame[strandIndex] = _RootFrameNext[strandIndex];
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KRootsHistoryAdd(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND_WITHIN(worldIdx.x, _SolverLODRange[SOLVERLODRANGE_INTERPOLATE_PROMOTE]);

	_RootPositionPrev[strandIndex] = _RootPositionNext[strandIndex];
	_RootPosition[strandIndex] = _RootPositionNext[strandIndex];

	_RootFramePrev[strandIndex] = _RootFrameNext[strandIndex];
	_RootFrame[strandIndex] = _RootFrameNext[strandIndex];
}

float3 BlendPosition(float3 p0, float3 p1, float t)
{
	return lerp(p0, p1, t);
}

float3 BlendDirection(float3 v0, float3 v1, float t)
{
	float4 q0 = MakeQuaternionIdentity();
	float4 q1 = MakeQuaternionFromTo(v0, v1);
	float4 qt = QSlerp(q0, q1, t);
	return QMul(qt, v0);
}

float4 BlendQuaternion(float4 q0, float4 q1, float t)
{
	return QSlerp(q0, q1, t);
}

float _SubstepFractionLo;
float _SubstepFractionHi;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KRootsSubstep(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);

	float t = _SubstepFractionHi;

	_RootPosition[strandIndex].xyz = BlendPosition(
		_RootPositionPrev[strandIndex].xyz,
		_RootPositionNext[strandIndex].xyz,
		t);

	_RootFrame[strandIndex] = BlendQuaternion(
		_RootFramePrev[strandIndex],
		_RootFrameNext[strandIndex],
		t);
}

#endif//F_INPUT

//-------------
// kernels lod

#if F_LOD

#define DISPATCH_THREAD_GROUP_SIZE 64

uint4 ResolveDispatchParallelStrands(uint strandCount)
{
	// returns data necessary for indirect dispatch + associated strand count
	// (thread groups x, thread groups y, thread groups z, associated strand count)
	uint numX = (strandCount + DISPATCH_THREAD_GROUP_SIZE - 1) / DISPATCH_THREAD_GROUP_SIZE;
	uint numY = 1;
	uint numZ = 1;
	return uint4(numX, numY, numZ, strandCount);
}

uint4 ResolveDispatchParallelParticles(uint strandCount)
{
	// returns data necessary for indirect dispatch + associated strand count
	// (thread groups x, thread groups y, thread groups z, associated strand count)
	uint numX = ((strandCount * _StrandParticleCount) + DISPATCH_THREAD_GROUP_SIZE - 1) / DISPATCH_THREAD_GROUP_SIZE;
	uint numY = 1;
	uint numZ = 1;
	return uint4(numX, numY, numZ, strandCount);
}

uint4 ResolveDispatchParallelParticlesEachStrand(uint strandCount)
{
	// returns data necessary for indirect dispatch + associated strand count
	// (thread groups x, thread groups y, thread groups z, associated strand count)
	uint numX = strandCount;
	uint numY = 1;
	uint numZ = 1;
	return uint4(numX, numY, numZ, strandCount);
}

uint4 ResolveDrawParallelParticles(uint strandCount, uint particleVertexCount)
{
	// returns data necessary for indirect draw
	// (vertex count per instance, instance count, start vertex location, and start instance location)
	return uint4((strandCount * _StrandParticleCount) * particleVertexCount, 1, 0, 0);
}

uint2 CheckedRange(uint i, uint j)
{
	if (i <= j)
		return uint2(i, j);
	else
		return uint2(j, j);
}

uint CheckedCount(uint2 range)
{
	if (range.x < range.y)
		return (range.y - range.x);
	else
		return 0;
}

void WriteIndirectDispatch(uint index, uint4 args)
{
	_SolverLODDispatch[index * 4 + 0] = args.x;
	_SolverLODDispatch[index * 4 + 1] = args.y;
	_SolverLODDispatch[index * 4 + 2] = args.z;
	_SolverLODDispatch[index * 4 + 3] = args.w;
}

[numthreads(1, 1, 1)]
void KLODSelectionInit(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	uint2 rangeSolve		= CheckedRange(0, _StrandCount);
	uint2 rangeInterpolate	= CheckedRange(_StrandCount, _StrandCount);
	uint2 rangeRender		= CheckedRange(0, _StrandCount);

	_SolverLODRange[SOLVERLODRANGE_SOLVE]				= rangeSolve;
	_SolverLODRange[SOLVERLODRANGE_INTERPOLATE]			= rangeInterpolate;
	_SolverLODRange[SOLVERLODRANGE_INTERPOLATE_ADD]		= rangeInterpolate;
	_SolverLODRange[SOLVERLODRANGE_INTERPOLATE_PROMOTE]	= rangeInterpolate;
	_SolverLODRange[SOLVERLODRANGE_RENDER]				= rangeRender;
	_SolverLODRange[SOLVERLODRANGE_RENDER_ADD]			= rangeRender;
}

[numthreads(1, 1, 1)]
void KLODSelection(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	// select solver lod
	float solverLODQuantity = 1.0;
	{
		switch (_SolverLODMethod & 0xffff)
		{
			case SOLVERLODSELECTION_AUTOMATIC_PER_GROUP:
				solverLODQuantity = ResolveLODQuantity(_BoundsCoverage[_GroupBoundsIndex].x, _SolverLODCeiling, _SolverLODScale, _SolverLODBias);
				break;

			case SOLVERLODSELECTION_AUTOMATIC_PER_VOLUME:
				solverLODQuantity = ResolveLODQuantity(_BoundsCoverage[_CombinedBoundsIndex].x, _SolverLODCeiling, _SolverLODScale, _SolverLODBias);
				break;

			case SOLVERLODSELECTION_MANUAL:
				solverLODQuantity = ResolveLODQuantity(0.0, 1.0, 1.0, _SolverLODBias);
				break;
		}
	}

	LODIndices solverLODDesc = ResolveLODIndices(solverLODQuantity);
	{
		if (_SolverLODMethod & 0x10000)
		{
			_SolverLODStage[SOLVERLODSTAGE_PHYSICS_PREV] = _SolverLODStage[SOLVERLODSTAGE_PHYSICS];
			_SolverLODStage[SOLVERLODSTAGE_PHYSICS] = solverLODDesc;
		}
	}

	// select render lod (may depend on solver lod)
	float renderLODQuantity = 1.0;
	{
		switch (_RenderLODMethod)
		{
			case RENDERLODSELECTION_AUTOMATIC_PER_SEGMENT:
			case RENDERLODSELECTION_AUTOMATIC_PER_GROUP:
				renderLODQuantity = ResolveLODQuantity(_BoundsCoverage[_GroupBoundsIndex].x, _RenderLODCeiling, _RenderLODScale, _RenderLODBias);
				break;

			case RENDERLODSELECTION_AUTOMATIC_PER_VOLUME:
				renderLODQuantity = ResolveLODQuantity(_BoundsCoverage[_CombinedBoundsIndex].x, _RenderLODCeiling, _RenderLODScale, _RenderLODBias);
				break;

			case RENDERLODSELECTION_MATCH_PHYSICS:
				renderLODQuantity = solverLODQuantity;
				break;

			case RENDERLODSELECTION_MANUAL:
				renderLODQuantity = ResolveLODQuantity(0.0, 1.0, 1.0, _RenderLODBias);
				break;
		}
	}

	LODIndices renderLODDesc = ResolveLODIndices(renderLODQuantity);
	{
		_SolverLODStage[SOLVERLODSTAGE_RENDERING] = renderLODDesc;
	}
	
	// update delimiters / ranges
	uint solverStrandCount = _LODGuideCount[solverLODDesc.lodIndexHi];
	uint renderStrandCount = _LODGuideCount[renderLODDesc.lodIndexHi];

	uint i0 = _SolverLODRange[SOLVERLODRANGE_SOLVE].y;
	uint j0 = _SolverLODRange[SOLVERLODRANGE_INTERPOLATE].y;
	uint k0 = _SolverLODRange[SOLVERLODRANGE_RENDER].y;
	uint i1;
	uint j1;
	uint k1;
	{
		/* delimiters

		|------sim------|------pos------|-------------OFF---------|
		                i0              j0

		                |------pos---------------|
		                                :        j1
		                                `--------´
		                                  append


		|------sim------|------pos------:--------|----OFF---------|
		                i0             (j0)      j1 

		|------sim--------------------------|
		                :                   i1
		                `-------------------´
		                       promote

		*/

		if (_SolverLODMethod & 0x10000)
		{
			i1 = solverStrandCount;							// promote	[i0, i1]	(pos -> sim)
			j1 = max(solverStrandCount, renderStrandCount);	// append	[j0, j1]	(OFF -> pos)
			k1 = renderStrandCount;
		}
		else
		{
			i1 = i0;										// promote	deferred
			j1 = max(j0, renderStrandCount);				// append	[j0, j1]	(OFF -> pos)
			k1 = renderStrandCount;
		}
	}

	uint2 rangeSolve				= CheckedRange(0, i1);
	uint2 rangeInterpolate			= CheckedRange(i1, j1);
	uint2 rangeInterpolateAdd		= CheckedRange(j0, j1);
	uint2 rangeInterpolatePromote	= CheckedRange(i0, i1);
	uint2 rangeRender				= CheckedRange(0, k1);
	uint2 rangeRenderAdd			= CheckedRange(k0, k1);

	_SolverLODRange[SOLVERLODRANGE_SOLVE]				= rangeSolve;
	_SolverLODRange[SOLVERLODRANGE_INTERPOLATE]			= rangeInterpolate;
	_SolverLODRange[SOLVERLODRANGE_INTERPOLATE_ADD]		= rangeInterpolateAdd;
	_SolverLODRange[SOLVERLODRANGE_INTERPOLATE_PROMOTE]	= rangeInterpolatePromote;
	_SolverLODRange[SOLVERLODRANGE_RENDER]				= rangeRender;
	_SolverLODRange[SOLVERLODRANGE_RENDER_ADD]			= rangeRenderAdd;

	// update dispatch
	uint countSolve					= CheckedCount(rangeSolve);
	uint countInterpolate			= CheckedCount(rangeInterpolate);
	uint countInterpolateAdd		= CheckedCount(rangeInterpolateAdd);
	uint countInterpolatePromote	= CheckedCount(rangeInterpolatePromote);
	uint countRender				= CheckedCount(rangeRender);
	uint countRenderAdd				= CheckedCount(rangeRenderAdd);

	WriteIndirectDispatch(SOLVERLODDISPATCH_SOLVE,					ResolveDispatchParallelStrands(countSolve));
	WriteIndirectDispatch(SOLVERLODDISPATCH_SOLVE_GROUP_PARTICLES,	ResolveDispatchParallelParticlesEachStrand(countSolve));
	WriteIndirectDispatch(SOLVERLODDISPATCH_INTERPOLATE,			ResolveDispatchParallelStrands(countInterpolate));
	WriteIndirectDispatch(SOLVERLODDISPATCH_INTERPOLATE_ADD,		ResolveDispatchParallelStrands(countInterpolateAdd));
	WriteIndirectDispatch(SOLVERLODDISPATCH_INTERPOLATE_PROMOTE,	ResolveDispatchParallelStrands(countInterpolatePromote));
	WriteIndirectDispatch(SOLVERLODDISPATCH_STAGING,				ResolveDispatchParallelStrands(countRender));
	WriteIndirectDispatch(SOLVERLODDISPATCH_STAGING_ADD,			ResolveDispatchParallelStrands(countRenderAdd));
	WriteIndirectDispatch(SOLVERLODDISPATCH_ROOTS,					ResolveDispatchParallelStrands(countSolve + countInterpolate));
	WriteIndirectDispatch(SOLVERLODDISPATCH_TRANSFER,				ResolveDispatchParallelParticles(countSolve));
	WriteIndirectDispatch(SOLVERLODDISPATCH_TRANSFER_ALL,			ResolveDispatchParallelParticles(countSolve + countInterpolate));
	WriteIndirectDispatch(SOLVERLODDISPATCH_RASTER_POINTS,			ResolveDrawParallelParticles(countSolve, 1));
	WriteIndirectDispatch(SOLVERLODDISPATCH_RASTER_POINTS_ALL,		ResolveDrawParallelParticles(countSolve + countInterpolate, 1));
	WriteIndirectDispatch(SOLVERLODDISPATCH_RASTER_QUADS,			ResolveDrawParallelParticles(countSolve, 8));
	WriteIndirectDispatch(SOLVERLODDISPATCH_RASTER_QUADS_ALL,		ResolveDrawParallelParticles(countSolve + countInterpolate, 8));
}

uint2 ResolveDrawIndexedLine()
{
	uint perLineSegments = _StagingStrandVertexCount - 1;
	uint perLineIndices = perLineSegments * 2;
	return uint2(perLineIndices, 1);
}

uint2 ResolveDrawIndexedStrip()
{
	uint perStripSegments = _StagingStrandVertexCount - 1;
	uint perStripTriangles = perStripSegments * 2;
	uint perStripIndices = perStripTriangles * 3;
	return uint2(perStripIndices, 1);
}

uint2 ResolveDrawIndexedTube()
{
	const uint numSides = 4;

	uint perTubeSegments = _StagingStrandVertexCount - 1;
	uint perTubeTriangles = (perTubeSegments * numSides * 2) + 4;
	uint perTubeIndices = perTubeTriangles * 3;
	return uint2(perTubeIndices, 1);
}

void WriteIndirectTopology(uint index, uint2 args)
{
	_SolverLODTopology[index * 5 + 0] = args.x;	// == indexCountPerInstance
	_SolverLODTopology[index * 5 + 1] = args.y;	// == instanceCount
	_SolverLODTopology[index * 5 + 2] = 0;		// == startIndex
	_SolverLODTopology[index * 5 + 3] = 0;		// == baseVertexIndex
	_SolverLODTopology[index * 5 + 4] = 0;		// == startInstance
}

[numthreads(1, 1, 1)]
void KLODSelectionPost(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	uint countRender = _SolverLODRange[SOLVERLODRANGE_RENDER].y;
	uint countRenderBatchSize = min(countRender, INSTANCING_BATCH_SIZE);
	uint countRenderBatchCount = (countRender + INSTANCING_BATCH_SIZE - 1) / INSTANCING_BATCH_SIZE;

	WriteIndirectTopology(SOLVERLODTOPOLOGY_INDEXED_LINES,				uint2(countRender, 1) * ResolveDrawIndexedLine());
	WriteIndirectTopology(SOLVERLODTOPOLOGY_INDEXED_STRIPS,				uint2(countRender, 1) * ResolveDrawIndexedStrip());
	WriteIndirectTopology(SOLVERLODTOPOLOGY_INDEXED_TUBES,				uint2(countRender, 1) * ResolveDrawIndexedTube());

	WriteIndirectTopology(SOLVERLODTOPOLOGY_INDEXED_INSTANCED_LINES,	uint2(countRenderBatchSize, countRenderBatchCount) * ResolveDrawIndexedLine());
	WriteIndirectTopology(SOLVERLODTOPOLOGY_INDEXED_INSTANCED_STRIPS,	uint2(countRenderBatchSize, countRenderBatchCount) * ResolveDrawIndexedStrip());
	WriteIndirectTopology(SOLVERLODTOPOLOGY_INDEXED_INSTANCED_TUBES,	uint2(countRenderBatchSize, countRenderBatchCount) * ResolveDrawIndexedTube());

	WriteIndirectTopology(SOLVERLODTOPOLOGY_XR_INDEXED_LINES,			uint2(countRender, 2) * ResolveDrawIndexedLine());
	WriteIndirectTopology(SOLVERLODTOPOLOGY_XR_INDEXED_STRIPS,			uint2(countRender, 2) * ResolveDrawIndexedStrip());
	WriteIndirectTopology(SOLVERLODTOPOLOGY_XR_INDEXED_TUBES,			uint2(countRender, 2) * ResolveDrawIndexedTube());

	WriteIndirectTopology(SOLVERLODTOPOLOGY_XR_INDEXED_INSTANCED_LINES,	uint2(countRenderBatchSize, 2 * countRenderBatchCount) * ResolveDrawIndexedLine());
	WriteIndirectTopology(SOLVERLODTOPOLOGY_XR_INDEXED_INSTANCED_STRIPS,uint2(countRenderBatchSize, 2 * countRenderBatchCount) * ResolveDrawIndexedStrip());
	WriteIndirectTopology(SOLVERLODTOPOLOGY_XR_INDEXED_INSTANCED_TUBES,	uint2(countRenderBatchSize, 2 * countRenderBatchCount) * ResolveDrawIndexedTube());
}

#endif//F_LOD

//---------------
// kernels solve

#if F_SOLVE

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidelReference(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND_WITHIN(worldIdx.x, _SolverLODRange[SOLVERLODRANGE_SOLVE]);

	// clear corrections
	if (ENABLE_DISTANCE_FTL)
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticleCorrection[i].xyz = 0;
		}
	}

	// predict positions
	{
		_ParticlePosition[strandParticleBegin].xyz = GetRootPosition(strandIndex).xyz;

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			const float3 x0 = _ParticlePositionPrev[i].xyz;
#if SECOND_ORDER_UPDATE
			const float3 v0 = _ParticleVelocityPrev[i].xyz + GetVolumeImpulse(x0, _ParticleVelocityPrev[i].xyz);
#else
			const float3 v0 = _ParticleVelocity[i].xyz + GetVolumeImpulse(x0, _ParticleVelocity[i].xyz);
#endif
			const float3 a0 = GetVolumeGravity(x0);
			{
#if SECOND_ORDER_POSITION
				const float3 x0_minus1 = _ParticlePositionPrevPrev[i].xyz;
				const float3 v0_minus1 = _ParticleVelocity[i].xyz;
				_ParticlePosition[i].xyz = IntegratePosition_SecondOrder(x0, x0_minus1, v0, v0_minus1, a0);
#else
				_ParticlePosition[i].xyz = IntegratePosition(x0, v0, a0);
#endif
			}
		}
	}

	// apply global position constraints
	if (ENABLE_POSE_GLOBAL_POSITION)
	{
		float4 rootFrame = GetRootFrame(strandIndex);

		float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

		for (uint i = strandParticleBegin + strandParticleStride, k = 1; i != strandParticleEnd; i += strandParticleStride, k++)
		{
			float3 r0 = _ParticlePosition[i].xyz - p0;
			float3 r1 = QMul(rootFrame, _InitialParticleOffset[i].xyz * _GroupScale);

			_ParticlePosition[i].xyz = p0 + lerp(r0, r1, GetGlobalPositionInfluence(strandIndex, k));
		}
	}

	// prepare collision margin
	const float rootMargin = (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION) ?
		(0.5 * _GroupMaxParticleDiameter * _RootScale[strandIndex].y) :
		(0.5 * _GroupAvgParticleDiameter);

	// solve constraints by Gauss-Seidel iteration
	for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
	{
		const float stiffness = GetIterationStiffness(__iteration);

		// solve boundary collision constraints
		if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
		{
			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				if (ENABLE_BOUNDARY_FRICTION)
					ApplyCollisionFrictionConstraint(rootMargin, _BoundaryFriction, _ParticlePositionPrev[i].xyz, _ParticlePosition[i].xyz);
				else
					ApplyCollisionConstraint(rootMargin, _ParticlePosition[i].xyz);
			}
		}

		// solve 'long range attachment' distance constraints
		if (ENABLE_DISTANCE_LRA)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

			// root+1..
			for (uint i = strandParticleBegin + strandParticleStride, k = 1; i != strandParticleEnd; i += strandParticleStride, k++)
			{
				float3 p1 = _ParticlePosition[i].xyz;

				ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex) * k, p0, p1);

				_ParticlePosition[i].xyz = p1;
			}
		}

		// solve particle-particle distance constraints
		if (ENABLE_DISTANCE)
		{
			// root+1
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;

			ApplyDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.0, 1.0, p0, p1);

			// root+2..
			for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = _ParticlePosition[i].xyz;

				ApplyDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.5, 0.5, p0, p1);

				_ParticlePosition[i - strandParticleStride].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p1;
		}

		// solve triangle bending constraints
		if (ENABLE_CURVATURE_EQ || ENABLE_CURVATURE_GEQ || ENABLE_CURVATURE_LEQ)
		{
			float4 rootFrame = GetRootFrame(strandIndex);
			float3 rootVec = GetParticleInterval(strandIndex) * QMul(rootFrame, float3(0, 1, 0));

			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
			float3 p2 = _ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz;
			float3 r0 = p0 - rootVec;

			//      p1 <-- solve
			//     /
			//--- p0 <-- fixed (root)
			//    |
			//    r0 <-- fixed (root-1)
			if (ENABLE_CURVATURE_EQ)	ApplyTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, 0.0, 0.0, 1.0, r0, p0, p1);
			if (ENABLE_CURVATURE_GEQ)	ApplyTriangleBendingMinConstraint(GetBendingRadius(strandIndex), stiffness, 0.0, 0.0, 1.0, r0, p0, p1);
			if (ENABLE_CURVATURE_LEQ)	ApplyTriangleBendingMaxConstraint(GetBendingRadius(strandIndex), stiffness, 0.0, 0.0, 1.0, r0, p0, p1);

			//      p2 <-- solve
			//     /
			//    p1 <-- solve
			//    |
			//--- p0 <-- fixed (root)
			//    |
			//    ##
			if (ENABLE_CURVATURE_EQ)	ApplyTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, 0.0, 1.0, 1.0, p0, p1, p2);
			if (ENABLE_CURVATURE_GEQ)	ApplyTriangleBendingMinConstraint(GetBendingRadius(strandIndex), stiffness, 0.0, 1.0, 1.0, p0, p1, p2);
			if (ENABLE_CURVATURE_LEQ)	ApplyTriangleBendingMaxConstraint(GetBendingRadius(strandIndex), stiffness, 0.0, 1.0, 1.0, p0, p1, p2);

			for (uint i = strandParticleBegin + strandParticleStride * 3; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = p2;
				p2 = _ParticlePosition[i].xyz;

				//      p2 <-- solve
				//     /
				//    p1 <-- solve
				//    |
				//    p0 <-- solve
				//    |
				//--- ##
				if (ENABLE_CURVATURE_EQ)	ApplyTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, 1.0, 1.0, 1.0, p0, p1, p2);
				if (ENABLE_CURVATURE_GEQ)	ApplyTriangleBendingMinConstraint(GetBendingRadius(strandIndex), stiffness, 1.0, 1.0, 1.0, p0, p1, p2);
				if (ENABLE_CURVATURE_LEQ)	ApplyTriangleBendingMaxConstraint(GetBendingRadius(strandIndex), stiffness, 1.0, 1.0, 1.0, p0, p1, p2);

				_ParticlePosition[i - strandParticleStride * 2].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p1;
			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p2;
		}

		// solve global rotation constraints
		if (ENABLE_POSE_GLOBAL_ROTATION)
		{
			float4 rootFrame = GetRootFrame(strandIndex);
			float3 rootPos = GetRootPosition(strandIndex);
			float3 rootVec = GetParticleInterval(strandIndex) * QMul(rootFrame, float3(0, 1, 0));

			// root
			float3 p0 = rootPos - rootVec;
			float3 p1 = rootPos;

			float4 accuFrame = QMul(rootFrame, _InitialParticleFrameDelta[strandParticleBegin]);

			// root+1
			{
				const uint i = strandParticleBegin + strandParticleStride;

				p0 = rootPos;
				p1 = _ParticlePosition[i].xyz;

				accuFrame = QMul(accuFrame, _InitialParticleFrameDelta[i]);

				ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, 1), 0.0, 1.0, 0.0, p0, p1, accuFrame);
			}

			// root+2..
			for (uint i = strandParticleBegin + strandParticleStride * 2, k = 2; i != strandParticleEnd; i += strandParticleStride, k++)
			{
				p0 = p1;
				p1 = _ParticlePosition[i].xyz;

				accuFrame = QMul(accuFrame, _InitialParticleFrameDelta[i]);

				ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, k), 1.0, 1.0, 0.0, p0, p1, accuFrame);

				_ParticlePosition[i - strandParticleStride].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p1;
		}

		// solve local shape constraints
		if (ENABLE_POSE_LOCAL_SHAPE)
		{
			float4 rootFrame = GetRootFrame(strandIndex);
			float3 rootPos = GetRootPosition(strandIndex);
			float3 rootDir = QMul(rootFrame, float3(0.0, 1.0, 0.0));

			// root
			float3 p0 = rootPos - rootDir * GetParticleInterval(strandIndex) * 3.0;
			float3 p1 = rootPos - rootDir * GetParticleInterval(strandIndex) * 2.0;
			float3 p2 = rootPos - rootDir * GetParticleInterval(strandIndex);
			float3 p3 = rootPos;

			float4 q2 = MakeQuaternionIdentity();
			float4 q3 = QMul(rootFrame, _InitialParticleFrameDelta[strandParticleBegin]);

			float4 accuFrame = QMul(rootFrame, _InitialParticleFrameDelta[strandParticleBegin]);

			// root+1
			{
				const uint i = strandParticleBegin + strandParticleStride;

				p0 = p1;// root-2
				p1 = p2;// root-1
				p2 = p3;// root
				p3 = _ParticlePosition[i].xyz;

				q2 = q3;// root frame
				q3 = NextQuaternionFromBend(p1, p2, p3, q2);

				ApplyMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i], _LocalShape, 0.0, 1.0, q2, q3);
				ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, 0.0, 1.0, 1.0, p2, p3, q3);
			}

			// root+2..
			for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = p2;
				p2 = p3;
				p3 = _ParticlePosition[i].xyz;

				q2 = q3;
				q3 = NextQuaternionFromBend(p1, p2, p3, q2);

				ApplyMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i], _LocalShape, 1.0 - _LocalShapeBias, 1.0, q2, q3);
				ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, 1.0, 1.0, 1.0, p2, p3, q3);

				_ParticlePosition[i - strandParticleStride].xyz = p2;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p3;
		}

		// solve 'follow the leader' distance constraints
		if (ENABLE_DISTANCE_FTL)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				float3 p1 = _ParticlePosition[i].xyz;
				float3 d1 = 0;

				ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p0, p1, d1);
				
				_ParticlePosition[i].xyz = p1;
				_ParticleCorrection[i - strandParticleStride].xyz += d1;// correction to particle above current particle

				p0 = p1;
			}
		}
	}

	// update velocities
	{
		// root
		float3 p0;
		float3 v0;
		DeriveParticleVelocity(strandParticleBegin, p0, v0);

		// root+1..
		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			float3 p1;
			float3 v1;
			DeriveParticleVelocity(i, p1, v1);

			if (ENABLE_DISTANCE_FTL)
			{
				ApplyFTLCorrection(v1, _ParticleCorrection[i].xyz);
			}

			ApplyDampingLinear(v1);
			ApplyDampingAngular(p0, p1, v0, v1);
			ApplyDampingDistance(p0, p1, v0, v1);

			_ParticleVelocity[i - strandParticleStride].xyz = v0;

			p0 = p1;
			v0 = v1;
		}

		// ..n-1
		_ParticleVelocity[strandParticleEnd - strandParticleStride].xyz = v0;
	}
}

float3 PredictParticlePosition(const uint strandIndex, const uint k)
{
	const uint i = GetParticleIndex(strandIndex, k);

	const float3 x0 = _ParticlePositionPrev[i].xyz;
#if SECOND_ORDER_UPDATE
	const float3 v0 = _ParticleVelocityPrev[i].xyz + GetVolumeImpulse(x0, _ParticleVelocityPrev[i].xyz);
#else
	const float3 v0 = _ParticleVelocity[i].xyz + GetVolumeImpulse(x0, _ParticleVelocity[i].xyz);
#endif
	const float3 a0 = GetVolumeGravity(x0);

#if SECOND_ORDER_POSITION
	const float3 x0_minus1 = _ParticlePositionPrevPrev[i].xyz;
	const float3 v0_minus1 = _ParticleVelocity[i].xyz;
	float3 x1_pre = IntegratePosition_SecondOrder(x0, x0_minus1, v0, v0_minus1, a0);
#else
	float3 x1_pre = IntegratePosition(x0, v0, a0);
#endif

	// apply reference position
	if (ENABLE_POSE_GLOBAL_POSITION)
	{
		const float3 rootPosition = GetRootPosition(strandIndex);
		const float4 rootFrame = GetRootFrame(strandIndex);

		const float3 x1_ref = rootPosition + QMul(rootFrame, _InitialParticleOffset[i].xyz) * _GroupScale;

		x1_pre = lerp(x1_pre, x1_ref, GetGlobalPositionInfluence(strandIndex, k));
	}

	return x1_pre;
}

struct PartialStrandPos
{
	float3 minus[4];// ..
};

struct PartialStrandRot
{
	float4 minus[2];
};

void PartialStrand_SolveNext(
	inout PartialStrandPos p, inout PartialStrandRot q,
	const uint strandIndex, const uint k,
	const float stiffness,
	const float w_minus[3],
	const bool enablePrediction,
	const bool enablePrefetch)
{
	// LIVE_POSITIONS == 3
	//                                                 load
	//                           (q1)          (q0)     |
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//                       `--------- solve ---------´
	//
	// LIVE_POSITIONS == 2
	//                                                 load
	//                           (q1)          (q0)     |
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//                                     `-- solve --´
	//
	// LIVE_POSITIONS == 1
	//                                                 load
	//                           (q1)          (q0)     |
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//                                                   `-- solve

	uint2 prefetch_particleFrameDelta16 = _InitialParticleFrameDelta16[GetParticleIndex(strandIndex, k)];

	p.minus[3] = p.minus[2];
	p.minus[2] = p.minus[1];
	p.minus[1] = p.minus[0];
	
#define SOLVER_INLINE_PREDICTION 1

#if SOLVER_INLINE_PREDICTION
	if (enablePrediction)
		p.minus[0] = PredictParticlePosition(strandIndex, k);
	else
		p.minus[0] = _ParticlePosition[GetParticleIndex(strandIndex, k)].xyz;
#else
	p.minus[0] = _ParticlePosition[GetParticleIndex(strandIndex, k)].xyz;
#endif

#define MACRO_particlePositionPrev _ParticlePositionPrev[GetParticleIndex(strandIndex, k)].xyz
#define MACRO_particleFrameDelta QDecode16(prefetch_particleFrameDelta16)

	if (ENABLE_BOUNDARY)			ApplyCollisionConstraint(0.5 * GetParticleDiameter(strandIndex), p.minus[0]);
	if (ENABLE_BOUNDARY_FRICTION)	ApplyCollisionFrictionConstraint(0.5 * GetParticleDiameter(strandIndex), _BoundaryFriction, MACRO_particlePositionPrev, p.minus[0]);
	if (ENABLE_DISTANCE_LRA)		ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex) * k, GetRootPosition(strandIndex), p.minus[0]);
	if (ENABLE_DISTANCE)			ApplyDistanceConstraint(GetParticleInterval(strandIndex), 1.0, w_minus[1], w_minus[0], p.minus[1], p.minus[0]);
	if (ENABLE_CURVATURE_EQ)		ApplyTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, w_minus[2], w_minus[1], w_minus[0], p.minus[2], p.minus[1], p.minus[0]);
	if (ENABLE_CURVATURE_GEQ)		ApplyTriangleBendingMinConstraint(GetBendingRadius(strandIndex), stiffness, w_minus[2], w_minus[1], w_minus[0], p.minus[2], p.minus[1], p.minus[0]);
	if (ENABLE_CURVATURE_LEQ)		ApplyTriangleBendingMaxConstraint(GetBendingRadius(strandIndex), stiffness, w_minus[2], w_minus[1], w_minus[0], p.minus[2], p.minus[1], p.minus[0]);

	q.minus[1] = q.minus[0];
	q.minus[0] = NextQuaternionFromBend(p.minus[2], p.minus[1], p.minus[0], q.minus[1]);

	if (ENABLE_POSE_GLOBAL_ROTATION)
	{
		const float wq_minus1 = 0.0;
		const float wq_minus0 = lerp(w_minus[1], w_minus[0], 1e-6);// 0.5);

		ApplyMaterialFrameBendTwistConstraint(MACRO_particleFrameDelta, 1.0, wq_minus1, wq_minus0, q.minus[1], q.minus[0]);
		ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, k), w_minus[1], w_minus[0], wq_minus0, p.minus[1], p.minus[0], q.minus[0]);
	}

	if (ENABLE_POSE_LOCAL_SHAPE || ENABLE_POSE_LOCAL_SHAPE_RWD)
	{
		const float wq_minus1 = lerp(w_minus[2], w_minus[1], 1e-6);// 0.5);
		const float wq_minus0 = lerp(w_minus[1], w_minus[0], 1e-6);// 0.5);

		if (ENABLE_POSE_LOCAL_SHAPE_RWD)
		{
			ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, w_minus[1], w_minus[0], wq_minus0, p.minus[1], p.minus[0], q.minus[0]);
			ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, w_minus[2], w_minus[1], wq_minus1, p.minus[2], p.minus[1], q.minus[1]);
			ApplyMaterialFrameBendTwistConstraint(MACRO_particleFrameDelta, _LocalShape, (1.0 - _LocalShapeBias) * wq_minus1, wq_minus0, q.minus[1], q.minus[0]);
		}
		else
		{
			ApplyMaterialFrameBendTwistConstraint(MACRO_particleFrameDelta, _LocalShape, (1.0 - _LocalShapeBias) * wq_minus1, wq_minus0, q.minus[1], q.minus[0]);
			ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, w_minus[1], w_minus[0], wq_minus0, p.minus[1], p.minus[0], q.minus[0]);
		}
	}

	// LIVE_POSITIONS == 3
	//
	//                           (q1)          (q0)
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//    (anchor)          |`-- done      `-- active ---´
	//                      |
	//                     write
	//
	// LIVE_POSITIONS == 2
	//
	//                           (q1)          (q0)
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//                  (anchor)          |`-- done      `-- active
	//                                    |
	//                                   write
	//
	// LIVE_POSITIONS == 1
	//
	//                           (q1)          (q0)
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//                                (anchor)          |`-- done
	//                                                  |
	//                                                 write

	GroupMemoryBarrierWithGroupSync();

	if (ENABLE_DISTANCE_FTL)
	{
		// if ((LIVE_POSITIONS == 3) && (w_minus[2] != 0.0)) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus[3], p.minus[2], _ParticleCorrection[i - strandParticleStride * 3].xyz);
		// if ((LIVE_POSITIONS == 2) && (w_minus[1] != 0.0)) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus[2], p.minus[1], _ParticleCorrection[i - strandParticleStride * 2].xyz);
		// if ((LIVE_POSITIONS == 1) && (w_minus[0] != 0.0)) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus[1], p.minus[0], _ParticleCorrection[i - strandParticleStride * 1].xyz);
		if (w_minus[LIVE_POSITIONS - 1] != 0.0) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus[LIVE_POSITIONS], p.minus[LIVE_POSITIONS - 1], _ParticleCorrection[GetParticleIndex(strandIndex, k - LIVE_POSITIONS)].xyz);
	}

	// if ((LIVE_POSITIONS == 3) && (w_minus[2] != 0.0)) _ParticlePosition[i - strandParticleStride * 2].xyz = p.minus[2];
	// if ((LIVE_POSITIONS == 2) && (w_minus[1] != 0.0)) _ParticlePosition[i - strandParticleStride * 1].xyz = p.minus[1];
	// if ((LIVE_POSITIONS == 1) && (w_minus[0] != 0.0)) _ParticlePosition[i - strandParticleStride * 0].xyz = p.minus[0];
	if (w_minus[LIVE_POSITIONS - 1] != 0.0) _ParticlePosition[GetParticleIndex(strandIndex, k - (LIVE_POSITIONS - 1))].xyz = p.minus[LIVE_POSITIONS - 1];
}

void PartialStrand_SolveTail(inout PartialStrandPos p, inout PartialStrandRot q, const uint strandIndex, const float stiffness)
{
	if (ENABLE_POSE_LOCAL_SHAPE_RWD)
	{
#if 1
		ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, 1.0, 1.0, 1.0, p.minus[1], p.minus[0], q.minus[0]);
#else
		ApplyEdgeVectorConstraint(QMul(q.minus0, float3(0, 1, 0)) * GetParticleInterval(strandIndex), stiffness * _LocalShape, 1.0, 1.0, p.minus[1], p.minus[0]);
#endif
	}

	if (ENABLE_DISTANCE_FTL)
	{
		if (LIVE_POSITIONS >= 3) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus[2], p.minus[1], _ParticleCorrection[GetParticleIndex(strandIndex, _StrandParticleCount - 3)].xyz);
		if (LIVE_POSITIONS >= 2) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus[1], p.minus[0], _ParticleCorrection[GetParticleIndex(strandIndex, _StrandParticleCount - 2)].xyz);
	}

	if (LIVE_POSITIONS >= 3) _ParticlePosition[GetParticleIndex(strandIndex, _StrandParticleCount - 2)].xyz = p.minus[1];
	if (LIVE_POSITIONS >= 2) _ParticlePosition[GetParticleIndex(strandIndex, _StrandParticleCount - 1)].xyz = p.minus[0];
}

void PartialStrand_SolveStrand(const uint strandIndex, const uint iteration, const bool enablePrediction)
{
	const float stiffness = GetIterationStiffness(iteration);

	const float3 rootPosition = GetRootPosition(strandIndex);
	const float4 rootFrame = GetRootFrame(strandIndex);
	const float3 rootVec = GetParticleInterval(strandIndex) * QMul(rootFrame, float3(0.0, 1.0, 0.0));

	PartialStrandPos p;
	p.minus[3] = rootPosition - rootVec * 3.0;
	p.minus[2] = rootPosition - rootVec * 2.0;
	p.minus[1] = rootPosition - rootVec * 1.0;
	p.minus[0] = rootPosition;

	PartialStrandRot q;
	q.minus[1] = QMul(rootFrame, MakeQuaternionTwistIdentity());
	q.minus[0] = rootFrame;

	// root+1
	{
		const float w_minus[3] = { 1.0, 0.0, 0.0 };
		PartialStrand_SolveNext(p, q, strandIndex, 1, stiffness, w_minus, enablePrediction, true);
	}

	// root+2
	{
		const float w_minus[3] = { 1.0, 1.0, 0.0 };
		PartialStrand_SolveNext(p, q, strandIndex, 2, stiffness, w_minus, enablePrediction, true);
	}

	// root+3..
	for (uint k = 3; k != _StrandParticleCount; k++)
	{
		const float w_minus[3] = { 1.0, 1.0, 1.0 };
		PartialStrand_SolveNext(p, q, strandIndex, k, stiffness, w_minus, enablePrediction, k < _StrandParticleCount - 1);
	}

	// ..n-2, n-1
	PartialStrand_SolveTail(p, q, strandIndex, stiffness);
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidel(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND_WITHIN(worldIdx.x, _SolverLODRange[SOLVERLODRANGE_SOLVE]);

	PrepareStrandProperties(strandIndex);

	// clear corrections
	if (ENABLE_DISTANCE_FTL)
	{
		for (uint k = 0; k != _StrandParticleCount; k++)
		{
			_ParticleCorrection[GetParticleIndex(strandIndex, k)] = 0;
		}
	}

	// predict positions
	{
		// root
		_ParticlePosition[GetParticleIndex(strandIndex, 0)].xyz = GetRootPosition(strandIndex);

		// root+1..
#if !SOLVER_INLINE_PREDICTION
		for (uint k = 1; k != _StrandParticleCount; k++)
		{
			_ParticlePosition[GetParticleIndex(strandIndex, k)].xyz = PredictParticlePosition(strandIndex, k);
		}
#endif
	}

	// solve constraints by Gauss-Seidel iteration
	{
#if SOLVER_INLINE_PREDICTION
		for (uint __iteration0 = 0; __iteration0 != min(1, _Iterations); __iteration0++)
		{
			PartialStrand_SolveStrand(strandIndex, __iteration0, true);
		}

		for (uint __iterationX = 1; __iterationX != _Iterations; __iterationX++)
		{
			PartialStrand_SolveStrand(strandIndex, __iterationX, false);
		}
#else
		for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
		{
			PartialStrand_SolveStrand(strandIndex, __iteration, false);
		}
#endif
	}

	// derive velocities
	{
		GroupMemoryBarrierWithGroupSync();

		// root
		float3 p0;
		float3 v0;
		DeriveParticleVelocity(GetParticleIndex(strandIndex, 0), p0, v0);

		// root+1..
		for (uint k = 1; k != _StrandParticleCount; k++)
		{
			const uint i = GetParticleIndex(strandIndex, k);

			float3 p1;
			float3 v1;
			DeriveParticleVelocity(i, p1, v1);

			if (ENABLE_DISTANCE_FTL)
			{
				ApplyFTLCorrection(v1, _ParticleCorrection[i].xyz);
			}

			ApplyDampingLinear(v1);
			ApplyDampingAngular(p0, p1, v0, v1);
			ApplyDampingDistance(p0, p1, v0, v1);

			_ParticleVelocity[i - _StrandParticleStride].xyz = v0;

			p0 = p1;
			v0 = v1;
		}

		// ..n-1
		_ParticleVelocity[GetParticleIndex(strandIndex, _StrandParticleCount - 1)].xyz = v0;
	}
}

// pad head so that index 0 == root-1
groupshared float4 gs_x[1 + THREAD_GROUP_SIZE];// xyz: position, w: weight
groupshared float4 gs_q[1 + THREAD_GROUP_SIZE];// quat(xyz,w): material frame
groupshared float3 gs_d[1 + THREAD_GROUP_SIZE];// xyz: ftl correction

// one thread group per strand
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_Jacobi(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	//DECLARE_STRAND_WITHIN(groupIdx.x, _SolverLODRange[SOLVERLODRANGE_SOLVE]);
	DECLARE_STRAND(groupIdx.x);//TODO

	const uint i = strandParticleBegin + strandParticleStride * threadIdx;
	const uint j = threadIdx + 1;// for data in group shared memory (gs_*)

	// clear corrections
	if (ENABLE_DISTANCE_FTL)
	{
		// [threads: root]
		if (threadIdx == 0)
		{
			gs_d[0] = 0;
			gs_d[1] = 0;
		}
		// [threads: root+1..]
		else
		{
			gs_d[j] = 0;
		}
	}

	// predict positions
	const float3 x0 = _ParticlePositionPrev[i].xyz;
	{
		const float4 rootFrame = GetRootFrame(strandIndex);
		const float3 rootPos = GetRootPosition(strandIndex);

		// [threads: root]
		if (threadIdx == 0)
		{
			const float3 rootVec = GetParticleInterval(strandIndex) * QMul(rootFrame, float3(0, 1, 0));
			{
				gs_x[0] = float4(rootPos - rootVec, 0.0);
				gs_x[1] = float4(rootPos, 0.0);
			}
		}
		// [threads: root+1..]
		else
		{
#if SECOND_ORDER_UPDATE
			const float3 v0 = _ParticleVelocityPrev[i].xyz + GetVolumeImpulse(x0, _ParticleVelocityPrev[i].xyz);
#else
			const float3 v0 = _ParticleVelocity[i].xyz + GetVolumeImpulse(x0, _ParticleVelocity[i].xyz);
#endif
			const float3 a0 = GetVolumeGravity(x0);
			{
#if SECOND_ORDER_POSITION
				const float3 x0_minus1 = _ParticlePositionPrevPrev[i].xyz;
				const float3 v0_minus1 = _ParticleVelocity[i].xyz;
				float3 x1_pre = IntegratePosition_SecondOrder(x0, x0_minus1, v0, v0_minus1, a0);
#else
				float3 x1_pre = IntegratePosition(x0, v0, a0);
#endif

				// solve global position constraints
				if (ENABLE_POSE_GLOBAL_POSITION)
				{
					const float3 r0 = x1_pre - rootPos;
					const float3 r1 = QMul(rootFrame, _InitialParticleOffset[i].xyz * _GroupScale);

					x1_pre = rootPos + lerp(r0, r1, GetGlobalPositionInfluence(strandIndex, threadIdx));
				}

				gs_x[j] = float4(x1_pre, 1.0);
			}
		}

		// build material frames
		{
			GroupMemoryBarrierWithGroupSync();

			// [threads: root]
			if (threadIdx == 0)
			{
				gs_q[0] = QMul(rootFrame, MakeQuaternionTwistIdentity());
				gs_q[1] = rootFrame;

				for (uint m = 2; m <= THREAD_GROUP_SIZE; m++)
				{
					gs_q[m] = NextQuaternionFromBend(gs_x[m - 2].xyz, gs_x[m - 1].xyz, gs_x[m].xyz, gs_q[m - 1]);
				}
			}
		}
	}

	// count tailing particles
	const uint num_tailing = (THREAD_GROUP_SIZE - 1) - threadIdx;

	// count acting constraints
	const uint num_acting_x = max(1,
		(ENABLE_BOUNDARY				? 1							: 0) +
		(ENABLE_BOUNDARY_FRICTION		? 1							: 0) +
		(ENABLE_DISTANCE				? min(2, 1 + num_tailing)	: 0) +
		(ENABLE_DISTANCE_LRA			? 1							: 0) +
		(ENABLE_DISTANCE_FTL			? 1							: 0) +
		(ENABLE_CURVATURE_EQ			? min(3, 1 + num_tailing)	: 0) +
		(ENABLE_CURVATURE_GEQ			? min(3, 1 + num_tailing)	: 0) +
		(ENABLE_CURVATURE_LEQ			? min(3, 1 + num_tailing)	: 0) +
		(ENABLE_POSE_LOCAL_SHAPE		? min(2, 1 + num_tailing)	: 0) +
		(ENABLE_POSE_GLOBAL_ROTATION	? min(2, 1 + num_tailing)	: 0) +
		0);

	const uint num_acting_q = max(1,
		(ENABLE_POSE_LOCAL_SHAPE		? min(3, 2 + num_tailing)	: 0) +
		(ENABLE_POSE_GLOBAL_ROTATION	? min(3, 2 + num_tailing)	: 0) +
		0);

	// prepare collision margin
	const float rootMargin = (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION) ?
		(0.5 * _GroupMaxParticleDiameter * _RootScale[strandIndex].y) :
		(0.5 * _GroupAvgParticleDiameter);

	// solve constraints by Jacobi iteration
	for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
	{
		GroupMemoryBarrierWithGroupSync();
			
		const float stiffness = GetIterationStiffness(__iteration);

		// [threads: root+1..]
		if (threadIdx > 0)
		{
			float3 corr_x = 0;
			float4 corr_q = 0;

			// solve boundary collision constraints
			if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
			{
				if (ENABLE_BOUNDARY_FRICTION)
					SolveCollisionFrictionConstraint(rootMargin, _BoundaryFriction, x0, gs_x[j], corr_x);
				else
					SolveCollisionConstraint(rootMargin, gs_x[j], corr_x);
			}

			// solve 'long range attachment' distance constraints
			if (ENABLE_DISTANCE_LRA)
			{
				SolveDistanceLRAConstraint(GetParticleInterval(strandIndex) * threadIdx, gs_x[1].xyz, gs_x[j].xyz, corr_x);
			}

			// solve particle-particle distance constraints
			if (ENABLE_DISTANCE)
			{
				float3 NOP;
				
				SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, gs_x[j - 1], gs_x[j], NOP, corr_x);

				// [threads: ..end-1]
				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, gs_x[j], gs_x[j + 1], corr_x, NOP);
				}
			}

			// solve triangle bending constraints
			if (ENABLE_CURVATURE_EQ || ENABLE_CURVATURE_GEQ || ENABLE_CURVATURE_LEQ)
			{
				float3 NOP;

				if (ENABLE_CURVATURE_EQ)	SolveTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, gs_x[j - 2], gs_x[j - 1], gs_x[j], NOP, NOP, corr_x);
				if (ENABLE_CURVATURE_GEQ)	SolveTriangleBendingMinConstraint(GetBendingRadius(strandIndex), stiffness, gs_x[j - 2], gs_x[j - 1], gs_x[j], NOP, NOP, corr_x);
				if (ENABLE_CURVATURE_LEQ)	SolveTriangleBendingMaxConstraint(GetBendingRadius(strandIndex), stiffness, gs_x[j - 2], gs_x[j - 1], gs_x[j], NOP, NOP, corr_x);

				// [threads: ..end-1]
				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					if (ENABLE_CURVATURE_EQ)	SolveTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, gs_x[j - 1], gs_x[j], gs_x[j + 1], NOP, corr_x, NOP);
					if (ENABLE_CURVATURE_GEQ)	SolveTriangleBendingMinConstraint(GetBendingRadius(strandIndex), stiffness, gs_x[j - 1], gs_x[j], gs_x[j + 1], NOP, corr_x, NOP);
					if (ENABLE_CURVATURE_LEQ)	SolveTriangleBendingMaxConstraint(GetBendingRadius(strandIndex), stiffness, gs_x[j - 1], gs_x[j], gs_x[j + 1], NOP, corr_x, NOP);

					// [threads: ..end-2]
					if (threadIdx < THREAD_GROUP_SIZE - 2)
					{
						if (ENABLE_CURVATURE_EQ)	SolveTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, gs_x[j], gs_x[j + 1], gs_x[j + 2], corr_x, NOP, NOP);
						if (ENABLE_CURVATURE_GEQ)	SolveTriangleBendingMinConstraint(GetBendingRadius(strandIndex), stiffness, gs_x[j], gs_x[j + 1], gs_x[j + 2], corr_x, NOP, NOP);
						if (ENABLE_CURVATURE_LEQ)	SolveTriangleBendingMaxConstraint(GetBendingRadius(strandIndex), stiffness, gs_x[j], gs_x[j + 1], gs_x[j + 2], corr_x, NOP, NOP);
					}
				}
			}

			/* TODO
			// solve global rotation constraints
			if (ENABLE_POSE_GLOBAL_ROTATION)
			{
				float4 NOP;

				const float wq_minus1 = 0.0;
				const float wq_minus0 = lerp(gs_x[j - 1].w, gs_x[j - 0].w, 1e-6);// 0.5);

				SolveMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i], 1.0, wq_minus1, wq_minus0, gs_q[j - 1], gs_q[j], NOP, corr_q);
				SolveMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, threadIdx), gs_x[j - 1].w, gs_x[j].w, wq_minus0, gs_x[j - 1].xyz, gs_x[j].xyz, gs_q[j], NOP.xyz, corr_x, corr_q);

				// [threads: ..end-1]
				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					const float wq_plus1 = lerp(gs_x[j - 0].w, gs_x[j + 1].w, 1e-6);// 0.5);

					SolveMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i + strandParticleStride], 1.0, wq_minus0, wq_plus1, gs_q[j], gs_q[j + 1], corr_q, NOP);
					SolveMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, threadIdx), gs_x[j].w, gs_x[j + 1].w, wq_plus1, gs_x[j].xyz, gs_x[j + 1].xyz, gs_q[j + 1], corr_x, NOP.xyz, NOP);
				}
			}
			*/

			// solve local shape constraints
			if (ENABLE_POSE_LOCAL_SHAPE)
			{
				float4 NOP;

				const float wq_minus1 = lerp(gs_x[j - 2].w, gs_x[j - 1].w, 1e-6);// 0.5);
				const float wq_minus0 = lerp(gs_x[j - 1].w, gs_x[j - 0].w, 1e-6);// 0.5);

				SolveMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i], stiffness * _LocalShape, (1.0 - _LocalShapeBias) * wq_minus1, wq_minus0, gs_q[j - 1], gs_q[j], NOP, corr_q);
				SolveMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, gs_x[j - 1].w, gs_x[j].w, wq_minus0, gs_x[j - 1].xyz, gs_x[j].xyz, gs_q[j], NOP.xyz, corr_x, corr_q);

				// [threads: ..end-1]
				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					const float wq_plus1 = lerp(gs_x[j - 0].w, gs_x[j + 1].w, 1e-6);// 0.5);

					SolveMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i + strandParticleStride], stiffness * _LocalShape, (1.0 - _LocalShapeBias) * wq_minus0, wq_plus1, gs_q[j], gs_q[j + 1], corr_q, NOP);
					SolveMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, gs_x[j].w, gs_x[j + 1].w, wq_plus1, gs_x[j].xyz, gs_x[j + 1].xyz, gs_q[j + 1], corr_x, NOP.xyz, NOP);
				}
			}

			// apply SOR and averaging
			corr_x *= _SOR / num_acting_x;
			corr_q *= _SOR / num_acting_q;

			// solve 'follow the leader' distance constraints
			if (ENABLE_DISTANCE_FTL)
			{
				float3 corr_x_ftl = 0;

				SolveDistanceFTLConstraint(GetParticleInterval(strandIndex), gs_x[j - 1].xyz, gs_x[j].xyz, corr_x_ftl);

				corr_x_ftl *= 0.5 / num_acting_x;
				corr_x += corr_x_ftl;

				gs_d[j - 1] += corr_x_ftl;// correction to particle above current particle
			}

			// move to next iteration
			gs_x[j].xyz += corr_x;
			gs_q[j] = normalize(gs_q[j] + corr_q);
		}
	}

	GroupMemoryBarrierWithGroupSync();

	// store positions
	{
		_ParticlePosition[i].xyz = gs_x[j].xyz;
	}

	// update velocities
	{
#if SECOND_ORDER_VELOCITY
		float3 v = DeriveVelocity_SecondOrder(gs_x[j].xyz, x0, _ParticlePositionPrevPrev[i].xyz);
#else
		float3 v = DeriveVelocity(gs_x[j].xyz, x0);
#endif

		if (ENABLE_DISTANCE_FTL)
		{
			ApplyFTLCorrection(v, gs_d[j]);
		}

		ApplyDampingLinear(v);

		gs_d[j] = v;

		GroupMemoryBarrierWithGroupSync();

		// [threads: root+1..]
		if (threadIdx > 0)
		{
			float3 NOP;
			float3 dv = 0;

			ApplyDampingAngular(gs_x[j - 1].xyz, gs_x[j].xyz, gs_d[j - 1], gs_d[j], NOP, v);
			ApplyDampingDistance(gs_x[j - 1].xyz, gs_x[j].xyz, gs_d[j - 1], gs_d[j], NOP, v);

			// [threads: ..end-1]
			if (threadIdx < THREAD_GROUP_SIZE - 1)
			{
				ApplyDampingAngular(gs_x[j].xyz, gs_x[j + 1].xyz, gs_d[j], gs_d[j + 1], v, NOP);
				ApplyDampingDistance(gs_x[j].xyz, gs_x[j + 1].xyz, gs_d[j], gs_d[j + 1], v, NOP);
			}
		}

		_ParticleVelocity[i].xyz = v;
	}
}

#endif//F_SOLVE

//---------------------
// kernels interpolate

#if F_INTERPOLATE

void StoreInterpolatedPosition(int particleIndex, float3 position)
{
	_ParticlePosition[particleIndex].xyz = position;
#if SECOND_ORDER_UPDATE
	_ParticlePositionPrev[particleIndex].xyz = position;
#endif
}

void StoreInterpolatedVelocity(int particleIndex, float3 velocity)
{
	_ParticleVelocity[particleIndex] = velocity;
#if SECOND_ORDER_UPDATE
	_ParticleVelocityPrev[particleIndex] = 0;
#endif
}

void InterpolateStrandPosition(const uint index, const uint2 range, const LODIndices lodDesc)
{
	DECLARE_STRAND_WITHIN(index, range);

	const uint strandIndexLo = _LODGuideIndex[(lodDesc.lodIndexLo * _StrandCount) + strandIndex];
	const uint strandIndexHi = _LODGuideIndex[(lodDesc.lodIndexHi * _StrandCount) + strandIndex];

	const uint strandParticleBeginLo = strandIndexLo * _StrandParticleOffset;
	const uint strandParticleBeginHi = strandIndexHi * _StrandParticleOffset;

	const float strandContribLo = _RootScale[strandIndex].x / _RootScale[strandIndexLo].x;
	const float strandContribHi = _RootScale[strandIndex].x / _RootScale[strandIndexHi].x;

	const float4 rootFrame = _RootFrame[strandIndex];
	const float4 rootFrameLo = _RootFrame[strandIndexLo];
	const float4 rootFrameHi = _RootFrame[strandIndexHi];

	const float3 rootPosition = _RootPosition[strandIndex].xyz;
	const float3 rootPositionLo = _RootPosition[strandIndexLo].xyz;
	const float3 rootPositionHi = _RootPosition[strandIndexHi].xyz;

#if 0// experimental
	float4 frame = rootFrame;
	float4 frameLo = rootFrameLo;
	float4 frameHi = rootFrameHi;

	float3 initialPosition = rootPosition;
	float3 initialPositionLo = rootPositionLo;
	float3 initialPositionHi = rootPositionHi;

	float step = GetParticleInterval(strandIndex);
	float stepLo = GetParticleInterval(strandIndexLo);
	float stepHi = GetParticleInterval(strandIndexHi);

	if (lodDesc.lodBlendFrac == 0.0)
	{
		for (uint i = strandParticleBegin + strandParticleStride, iLo = strandParticleBeginLo + strandParticleStride; i != strandParticleEnd; i += strandParticleStride, iLo += strandParticleStride)
		{
			frame = QMul(frame, QDecode16(_InitialParticleFrameDelta16[i]));
			frameLo = QMul(frameLo, QDecode16(_InitialParticleFrameDelta16[iLo]));

			initialPosition += QMul(frame, float3(0.0, 1.0, 0.0)) * step;
			initialPositionLo += QMul(frameLo, float3(0.0, 1.0, 0.0)) * stepLo;

			float3 positionDeltaLo = strandContribLo * (_ParticlePosition[iLo].xyz - initialPositionLo);
			float3 position = initialPosition + positionDeltaLo;

			//TODO transition strand to interpolated to avoid pops
			StoreInterpolatedPosition(i, position);
		}
	}
	else
	{
		for (uint i = strandParticleBegin + strandParticleStride, iLo = strandParticleBeginLo + strandParticleStride, iHi = strandParticleBeginHi + strandParticleStride; i != strandParticleEnd; i += strandParticleStride, iLo += strandParticleStride, iHi += strandParticleStride)
		{
			frame = QMul(frame, QDecode16(_InitialParticleFrameDelta16[i]));
			frameLo = QMul(frameLo, QDecode16(_InitialParticleFrameDelta16[iLo]));
			frameHi = QMul(frameHi, QDecode16(_InitialParticleFrameDelta16[iHi]));

			initialPosition += QMul(frame, float3(0.0, 1.0, 0.0)) * step;
			initialPositionLo += QMul(frameLo, float3(0.0, 1.0, 0.0)) * stepLo;
			initialPositionHi += QMul(frameHi, float3(0.0, 1.0, 0.0)) * stepHi;

			float3 positionDeltaLo = strandContribLo * (_ParticlePosition[iLo].xyz - initialPositionLo);
			float3 positionDeltaHi = strandContribHi * (_ParticlePosition[iHi].xyz - initialPositionHi);
			float3 position = initialPosition + lerp(positionDeltaLo, positionDeltaHi, lodDesc.lodBlendFrac);

			//TODO transition strand to interpolated to avoid pops
			StoreInterpolatedPosition(i, position);
		}
	}
#else
	StoreInterpolatedPosition(strandParticleBegin, rootPosition);

	if (lodDesc.lodBlendFrac == 0.0)
	{
		for (uint i = strandParticleBegin + strandParticleStride, iLo = strandParticleBeginLo + strandParticleStride; i != strandParticleEnd; i += strandParticleStride, iLo += strandParticleStride)
		{
			float3 initialOffset = QMul(rootFrame, _InitialParticleOffset[i].xyz) * _GroupScale;
			float3 initialOffsetLo = QMul(rootFrameLo, _InitialParticleOffset[iLo].xyz) * _GroupScale;

			float3 currentOffsetLo = _ParticlePosition[iLo].xyz - rootPositionLo;

			float3 positionDeltaLo = strandContribLo * (currentOffsetLo - initialOffsetLo);
			float3 position = rootPosition + initialOffset + positionDeltaLo;

			//TODO transition strand to interpolated to avoid pops
			StoreInterpolatedPosition(i, position);
		}
	}
	else
	{
		for (uint i = strandParticleBegin + strandParticleStride, iLo = strandParticleBeginLo + strandParticleStride, iHi = strandParticleBeginHi + strandParticleStride; i != strandParticleEnd; i += strandParticleStride, iLo += strandParticleStride, iHi += strandParticleStride)
		{
			float3 initialOffset = QMul(rootFrame, _InitialParticleOffset[i].xyz) * _GroupScale;
			float3 initialOffsetLo = QMul(rootFrameLo, _InitialParticleOffset[iLo].xyz) * _GroupScale;
			float3 initialOffsetHi = QMul(rootFrameHi, _InitialParticleOffset[iHi].xyz) * _GroupScale;

			float3 currentOffsetLo = _ParticlePosition[iLo].xyz - rootPositionLo;
			float3 currentOffsetHi = _ParticlePosition[iHi].xyz - rootPositionHi;

			float3 positionDeltaLo = strandContribLo * (currentOffsetLo - initialOffsetLo);
			float3 positionDeltaHi = strandContribHi * (currentOffsetHi - initialOffsetHi);
			float3 position = rootPosition + initialOffset + lerp(positionDeltaLo, positionDeltaHi, lodDesc.lodBlendFrac);

			//TODO transition strand to interpolated to avoid pops
			StoreInterpolatedPosition(i, position);
		}
	}
#endif
}

void InterpolateStrandVelocity(const uint index, const uint2 range, const LODIndices lodDesc)
{
	DECLARE_STRAND_WITHIN(index, range);

	const uint strandIndexLo = _LODGuideIndex[(lodDesc.lodIndexLo * _StrandCount) + strandIndex];
	const uint strandIndexHi = _LODGuideIndex[(lodDesc.lodIndexHi * _StrandCount) + strandIndex];

	const uint strandParticleBeginLo = strandIndexLo * _StrandParticleOffset;
	const uint strandParticleBeginHi = strandIndexHi * _StrandParticleOffset;

	const float strandContribLo = _RootScale[strandIndex].x / _RootScale[strandIndexLo].x;
	const float strandContribHi = _RootScale[strandIndex].x / _RootScale[strandIndexHi].x;

	if (lodDesc.lodBlendFrac == 0.0)
	{
		for (uint i = strandParticleBegin, iLo = strandParticleBeginLo; i != strandParticleEnd; i += strandParticleStride, iLo += strandParticleStride)
		{
			float3 velocityLo = strandContribLo * _ParticleVelocity[iLo];
			float3 velocity = velocityLo;

			StoreInterpolatedVelocity(i, velocity);
		}
	}
	else
	{
		for (uint i = strandParticleBegin, iLo = strandParticleBeginLo, iHi = strandParticleBeginHi; i != strandParticleEnd; i += strandParticleStride, iLo += strandParticleStride, iHi += strandParticleStride)
		{
			float3 velocityLo = strandContribLo * _ParticleVelocity[iLo];
			float3 velocityHi = strandContribHi * _ParticleVelocity[iHi];
			float3 velocity = lerp(velocityLo, velocityHi, lodDesc.lodBlendFrac);

			StoreInterpolatedVelocity(i, velocity);
		}
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KInterpolate(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterpolateStrandPosition(worldIdx.x, _SolverLODRange[SOLVERLODRANGE_INTERPOLATE], _SolverLODStage[SOLVERLODSTAGE_PHYSICS]);
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KInterpolateAdd(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterpolateStrandPosition(worldIdx.x, _SolverLODRange[SOLVERLODRANGE_INTERPOLATE_ADD], _SolverLODStage[SOLVERLODSTAGE_PHYSICS_PREV]);
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KInterpolatePromote(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterpolateStrandVelocity(worldIdx.x, _SolverLODRange[SOLVERLODRANGE_INTERPOLATE_PROMOTE], _SolverLODStage[SOLVERLODSTAGE_PHYSICS_PREV]);
}

#endif//F_INTERPOLATE

//-----------------
// kernels staging

#if F_STAGING

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KStaging(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND_WITHIN(worldIdx.x, _SolverLODRange[SOLVERLODRANGE_RENDER]);

	const LODBounds lodBounds = _Bounds[_GroupBoundsIndex];

	float4 rootFrame = GetRootFrame(strandIndex);
	float3 rootDir = QMul(rootFrame, float3(0, 1, 0));

	float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
	float3 r0 = rootDir;

	for (uint i = strandParticleBegin; i != strandParticleEnd - strandParticleStride; i += strandParticleStride)
	{
		float3 p1 = _ParticlePosition[i + strandParticleStride].xyz;
		float3 r1 = normalize(p1 - p0);

		StoreStagingPosition(i, p0, lodBounds);

		p0 = p1;
		r0 = r1;
	}

	StoreStagingPosition(strandParticleEnd - strandParticleStride, p0, lodBounds);
}

struct CatmullRomParticle
{
	float3 xt;
	float3 vt;
};

CatmullRomParticle CatmullRom(float3 p0, float3 m0, float3 p1, float3 m1, float t)
{
	CatmullRomParticle pt;
	{
		float tt = t * t;
		float ttt = t * tt;

		pt.xt =
			p0 * (2 * ttt - 3 * tt + 1) +
			m0 * (ttt - 2 * tt + t) +
			p1 * (-2 * ttt + 3 * tt) +
			m1 * (ttt - tt);

		pt.vt =
			p0 * (6 * tt - 6 * t) +
			m0 * (3 * tt - 4 * t + 1) +
			p1 * (-6 * tt + 6 * t) +
			m1 * (3 * tt - 2 * t);
	}
	return pt;
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KStagingSubdivision(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND_WITHIN(worldIdx.x, _SolverLODRange[SOLVERLODRANGE_RENDER]);

	const LODBounds lodBounds = _Bounds[_GroupBoundsIndex];

	float4 rootFrame = GetRootFrame(strandIndex);
	float3 rootVec = GetParticleInterval(strandIndex) * QMul(rootFrame, float3(0, 1, 0));

	float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
	float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
	float3 m0 = lerp(rootVec, p1 - p0, 0.75);

	const uint segmentStepCount = _StagingSubdivision + 1;
	const float segmentStep = 1.0 / segmentStepCount;

	uint writeIndex = strandIndex * _StagingStrandVertexOffset;
	uint writeStride = strandParticleStride;

	// segment 1..N-1
	for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd - strandParticleStride; i += strandParticleStride)
	{
		float3 p2 = _ParticlePosition[i + strandParticleStride].xyz;
		float3 m1 = 0.5 * (p2 - p0);

		for (uint k = 0; k != segmentStepCount; k++, writeIndex += writeStride)
		{
			StoreStagingPosition(writeIndex, CatmullRom(p0, m0, p1, m1, segmentStep * k).xt, lodBounds);
		}

		p0 = p1;
		p1 = p2;
		m0 = m1;
	}

	// segment N
	{
		float3 m1 = lerp(m0, p1 - p0, 2.0);

		for (uint k = 0; k != segmentStepCount; k++, writeIndex += writeStride)
		{
			StoreStagingPosition(writeIndex, CatmullRom(p0, m0, p1, m1, segmentStep * k).xt, lodBounds);
		}

		p0 = p1;
		m0 = m1;
	}

	// cap
	StoreStagingPosition(writeIndex, p0, lodBounds);
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KStagingHistory(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND_WITHIN(worldIdx.x, _SolverLODRange[SOLVERLODRANGE_RENDER]);

	for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
	{
		ResetStagingPositionPrev(i);
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KStagingHistoryAdd(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND_WITHIN(worldIdx.x, _SolverLODRange[SOLVERLODRANGE_RENDER_ADD]);

	for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
	{
		ResetStagingPositionPrev(i);
	}
}

#endif//F_STAGING

```

`Runtime/HairSimComputeSolver.compute.meta`:

```meta
fileFormatVersion: 2
guid: b6088415b07a2b44ab1624cac72a2252
ComputeShaderImporter:
  externalObjects: {}
  currentAPIMask: 4
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimComputeSolverBoundaries.hlsl`:

```hlsl
#ifndef __HAIRSIMCOMPUTEBOUNDARIES_HLSL__
#define __HAIRSIMCOMPUTEBOUNDARIES_HLSL__

#include "HairSimData.hlsl"
#include "HairSimComputeSolverQuaternion.hlsl"

#define BOUNDARIES_OPT_HINT_LOOP 1
#define BOUNDARIES_OPT_PACK_CUBE 0
#if ALLOW_GROUPSHARED_BOUNDARY_DATA
#define BOUNDARIES_OPT_GROUP_MEM 0// requires call to PrepareBoundaryData(threadIndex, threadCount)
#endif

//-----------------
// boundary shapes

float SdDiscrete(const float3 p, const float scale, const float3x4 invM, Texture3D<float> sdf)
{
	float3 uvw = mul(invM, float4(p, 1.0));
	return scale * sdf.SampleLevel(_Volume_trilinear_clamp, uvw, 0);
}

float SdCapsule(const float3 p, const float3 centerA, const float3 centerB, const float radius)
{
	// see: "distance functions" by Inigo Quilez
	// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm

	const float3 pa = p - centerA;
	const float3 ba = centerB - centerA;

	const float h = saturate(dot(pa, ba) / dot(ba, ba));
	const float r = radius;

	return (length(pa - ba * h) - r);
}

float4 SdgCapsule(const float3 p, const float3 centerA, const float3 centerB, const float radius)
{
	// SdCapsule extended to include gradient in .yzw

	const float3 pa = p - centerA;
	const float3 ba = centerB - centerA;

	const float h = saturate(dot(pa, ba) / dot(ba, ba));
	const float r = radius;

	const float3 v = pa - ba * h;
	const float mv = length(v);

	return float4(mv - r, v / mv);
}

float SdSphere(const float3 p, const float3 center, const float radius)
{
	// see: "distance functions" by Inigo Quilez
	// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm

	return (length(p - center) - radius);
}

float4 SdgSphere(const float3 p, const float3 center, const float radius)
{
	// SdSphere extended to include gradient in .yzw

	const float3 v = p - center;
	const float mv = length(v);

	return float4(mv - radius, v / mv);
}

float SdTorus(float3 p, const float3 center, const float3 axis, const float radiusA, const float radiusB)
{
	const float3 basisX = (abs(axis.y) > 1.0 - 1e-4) ? float3(1.0, 0.0, 0.0) : normalize(cross(axis, float3(0.0, 1.0, 0.0)));
	const float3 basisY = axis;
	const float3 basisZ = cross(basisX, axis);
	const float3x3 invM = float3x3(basisX, basisY, basisZ);

	p = mul(invM, p - center);

	// see: "distance functions" by Inigo Quilez
	// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm

	const float2 t = float2(radiusA, radiusB);
	const float2 q = float2(length(p.xz) - t.x, p.y);

	return length(q) - t.y;
}

float4 SdgTorus(float3 p, const float3 center, const float3 axis, const float radiusA, const float radiusB)
{
	// SdTorus extended to include gradient in .yzw

	const float3 basisX = (abs(axis.y) > 1.0 - 1e-4) ? float3(1.0, 0.0, 0.0) : normalize(cross(axis, float3(0.0, 1.0, 0.0)));
	const float3 basisY = axis;
	const float3 basisZ = cross(basisX, axis);
	const float3x3 invM = float3x3(basisX, basisY, basisZ);

	p = mul(invM, p - center);

	const float2 t = float2(radiusA, radiusB);
	const float da = length(p.xz);
	const float2 q = float2(da - t.x, p.y);
	const float mq = length(q);

	float2 na = p.xz / da;
	float3 nq = float3(q.x * na.x, q.y, q.x * na.y) / mq;

	return float4(mq - t.y, nq);
}

#if BOUNDARIES_OPT_PACK_CUBE
float SdCube(float3 p, const float3 center, const float3 extent, const uint2 rotf16)
#else
float SdCube(float3 p, const float3 extent, const float3x4 invM)
#endif
{
#if BOUNDARIES_OPT_PACK_CUBE
	p = QMul(QDecode16(rotf16), p - center);
#else
	p = mul(invM, float4(p, 1.0));
	// assuming TRS, can apply scale post-transform to preserve primitive scale
	// T R S x_local = x_world
	//       x_local = S^-1 R^-1 T^-1 x_world
	//     S x_local = S S^-1 R^-1 T^-1 world
	p *= 2.0 * extent;
#endif

	// see: "distance functions" by Inigo Quilez
	// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm

	const float3 b = extent;
	const float3 q = abs(p) - b;

	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

#if BOUNDARIES_OPT_PACK_CUBE
float4 SdgCube(float3 p, const float3 center, const float3 extent, const uint2 rotf16)
#else
float4 SdgCube(float3 p, const float3 extent, const float3x4 invM)
#endif
{
	// SdCube extended to include gradient in .yzw

#if BOUNDARIES_OPT_PACK_CUBE
	p = QMul(QDecode16(rotf16), p - center);
#else
	p = mul(invM, float4(p, 1.0));
	// assuming TRS, can apply scale post-transform to preserve primitive scale
	// T R S x_local = x_world
	//       x_local = S^-1 R^-1 T^-1 x_world
	//     S x_local = S S^-1 R^-1 T^-1 world
	p *= 2.0 * extent;
#endif

	const float3 b = extent;
	const float3 q = abs(p) - b;
	const float3 s = sign(p);

	float3 v = max(q, 0.0);
	float kv = dot(v, v);
	if (kv > 0.0)
	{
		float mv = sqrt(kv);
		return float4(mv, s * v / mv);
	}
	else
	{
		if (q.x > q.y && q.x > q.z)
			return float4(q.x, s.x, 0.0, 0.0);
		else if (q.y > q.z)
			return float4(q.y, 0.0, s.y, 0.0);
		else
			return float4(q.z, 0.0, 0.0, s.z);
	}
}

float SdDiscrete(const float3 p, const BoundaryShape discrete, const float3x4 invM, Texture3D<float> sdf)
{
	return SdDiscrete(p, discrete.tA, invM, sdf);
}

float SdCapsule(const float3 p, const BoundaryShape capsule)
{
	return SdCapsule(p, capsule.pA, capsule.pB, capsule.tA);
}

float4 SdgCapsule(const float3 p, const BoundaryShape capsule)
{
	return SdgCapsule(p, capsule.pA, capsule.pB, capsule.tA);
}

float SdSphere(const float3 p, const BoundaryShape sphere)
{
	return SdSphere(p, sphere.pA, sphere.tA);
}

float4 SdgSphere(const float3 p, const BoundaryShape sphere)
{
	return SdgSphere(p, sphere.pA, sphere.tA);
}

float SdTorus(const float3 p, const BoundaryShape torus)
{
	return SdTorus(p, torus.pA, torus.pB, torus.tA, torus.tB);
}

float4 SdgTorus(const float3 p, const BoundaryShape torus)
{
	return SdgTorus(p, torus.pA, torus.pB, torus.tA, torus.tB);
}

#if BOUNDARIES_OPT_PACK_CUBE
float SdCube(const float3 p, const BoundaryShape cube)
{
	return SdCube(p, cube.pA, cube.pB, asuint(float2(cube.tA, cube.tB)));
}
#else
float SdCube(const float3 p, const BoundaryShape cube, const float3x4 invM)
{
	return SdCube(p, cube.pB, invM);
}
#endif

#if BOUNDARIES_OPT_PACK_CUBE
float4 SdgCube(const float3 p, const BoundaryShape cube)
{
	return SdgCube(p, cube.pA, cube.pB, asuint(float2(cube.tA, cube.tB)));
}
#else
float4 SdgCube(const float3 p, const BoundaryShape cube, const float3x4 invM)
{
	return SdgCube(p, cube.pB, invM);
}
#endif

//--------------------
// boundary accessors

#define __GetBoundaryShape(i) _BoundaryShape[i]
#define __GetBoundaryMatrix(i) (float3x4)_BoundaryMatrix[i]
#define __GetBoundaryMatrixInv(i) (float3x4)_BoundaryMatrixInv[i]
#define __GetBoundaryMatrixInvStep(i) (float3x4)_BoundaryMatrixInvStep[i]

#if BOUNDARIES_OPT_GROUP_MEM

groupshared BoundaryShape gs_boundaryShape[MAX_BOUNDARIES];
groupshared float3x4 gs_boundaryMatrix[MAX_BOUNDARIES];
groupshared float3x4 gs_boundaryMatrixInv[MAX_BOUNDARIES];
groupshared float3x4 gs_boundaryMatrixW2PrevW[MAX_BOUNDARIES];

#define GetBoundaryShape(i) gs_boundaryShape[i]
#define GetBoundaryMatrix(i) gs_boundaryMatrix[i]
#define GetBoundaryMatrixInv(i) gs_boundaryMatrixInv[i]
#define GetBoundaryMatrixInvStep(i) gs_boundaryMatrixInvStep[i]

void PrepareBoundaryData(const uint threadIndex, const uint threadCount)
{
	if (threadIndex == 0)
	{
		for (int i = 0; i != MAX_BOUNDARIES; i++)
		{
			gs_boundaryShape[i] = __GetBoundaryShape(i);
			gs_boundaryMatrix[i] = __GetBoundaryMatrix(i);
			gs_boundaryMatrixInv[i] = __GetBoundaryMatrixInv(i);
			gs_boundaryMatrixInvStep[i] = __GetBoundaryMatrixInvStep(i);
		}
	}

	GroupMemoryBarrierWithGroupSync();
}

#else

#define GetBoundaryShape(i) __GetBoundaryShape(i)
#define GetBoundaryMatrix(i) __GetBoundaryMatrix(i)
#define GetBoundaryMatrixInv(i) __GetBoundaryMatrixInv(i)
#define GetBoundaryMatrixInvStep(i) __GetBoundaryMatrixInvStep(i)

void PrepareBoundaryData(const uint threadIndex, const uint threadCount) { }

#endif

//------------------
// boundary queries

#if BOUNDARIES_OPT_HINT_LOOP
#define BOUNDARIES_LOOP [loop]
#else
#define BOUNDARIES_LOOP
#endif

#if 1
#define BOUNDARIES_FOR_VARS(i, val) uint i = val;
#define BOUNDARIES_FOR(i, n) BOUNDARIES_LOOP for (; i != n; i++)
#else
#define BOUNDARIES_FOR_VARS(i, val) uint i = val; uint j = val;
#define BOUNDARIES_FOR(i, n) BOUNDARIES_LOOP for (j += n; i != j; i++)
#endif

float BoundaryDistance(const float3 p)
{
	float d = 1e+7;

	BOUNDARIES_FOR_VARS(i, 0)
	BOUNDARIES_FOR(i, _BoundaryDelimDiscrete)
	{
		d = min(d, SdDiscrete(p, GetBoundaryShape(i), GetBoundaryMatrixInv(i), _BoundarySDF));
	}
	BOUNDARIES_FOR(i, _BoundaryDelimCapsule)
	{
		d = min(d, SdCapsule(p, GetBoundaryShape(i)));
	}
	BOUNDARIES_FOR(i, _BoundaryDelimSphere)
	{
		d = min(d, SdSphere(p, GetBoundaryShape(i)));
	}
	BOUNDARIES_FOR(i, _BoundaryDelimTorus)
	{
		d = min(d, SdTorus(p, GetBoundaryShape(i)));
	}
	BOUNDARIES_FOR(i, _BoundaryDelimCube)
	{
#if BOUNDARIES_OPT_PACK_CUBE
		d = min(d, SdCube(p, GetBoundaryShape(i)));
#else
		d = min(d, SdCube(p, GetBoundaryShape(i), GetBoundaryMatrixInv(i)));
#endif
	}

	return d;
}

float3 BoundaryDistanceDiscrete(const float3 p)
{
	float d = 1e+7;

	BOUNDARIES_FOR_VARS(i, 0)
	BOUNDARIES_FOR(i, _BoundaryDelimDiscrete)
	{
		d = min(d, SdDiscrete(p, GetBoundaryShape(i), GetBoundaryMatrixInv(i), _BoundarySDF));
	}

	return d;
}

uint BoundarySelect(const float3 p, const float d)
{
	uint k = 0;

	BOUNDARIES_FOR_VARS(i, 0)
	BOUNDARIES_FOR(i, _BoundaryDelimDiscrete)
	{
		if (d == SdDiscrete(p, GetBoundaryShape(i), GetBoundaryMatrixInv(i), _BoundarySDF))
			k = i;
	}
	BOUNDARIES_FOR(i, _BoundaryDelimCapsule)
	{
		if (d == SdCapsule(p, GetBoundaryShape(i)))
			k = i;
	}
	BOUNDARIES_FOR(i, _BoundaryDelimSphere)
	{
		if (d == SdSphere(p, GetBoundaryShape(i)))
			k = i;
	}
	BOUNDARIES_FOR(i, _BoundaryDelimTorus)
	{
		if (d == SdTorus(p, GetBoundaryShape(i)))
			k = i;
	}
	BOUNDARIES_FOR(i, _BoundaryDelimCube)
	{
#if BOUNDARIES_OPT_PACK_CUBE
		if (d == SdCube(p, GetBoundaryShape(i)))
			k = i;
#else
		if (d == SdCube(p, GetBoundaryShape(i), GetBoundaryMatrixInv(i)))
			k = i;
#endif
	}

	return k;
}

float4 BoundaryNormalAnalyticMin(const float4 sdgA, const float4 sdgB)
{
	if (sdgA.x < sdgB.x)
		return sdgA;
	else
		return sdgB;
}

float3 BoundaryNormalAnalytic(const float3 p)
{
	float4 sdg = float4(1e+7, 0.0, 0.0, 0.0);

	BOUNDARIES_FOR_VARS(i, _BoundaryDelimDiscrete)
	BOUNDARIES_FOR(i, _BoundaryDelimCapsule)
	{
		sdg = BoundaryNormalAnalyticMin(sdg, SdgCapsule(p, GetBoundaryShape(i)));
	}
	BOUNDARIES_FOR(i, _BoundaryDelimSphere)
	{
		sdg = BoundaryNormalAnalyticMin(sdg, SdSphere(p, GetBoundaryShape(i)));
	}
	BOUNDARIES_FOR(i, _BoundaryDelimTorus)
	{
		sdg = BoundaryNormalAnalyticMin(sdg, SdTorus(p, GetBoundaryShape(i)));
	}
	BOUNDARIES_FOR(i, _BoundaryDelimCube)
	{
#if BOUNDARIES_OPT_PACK_CUBE
		sdg = BoundaryNormalAnalyticMin(sdg, SdCube(p, GetBoundaryShape(i)));
#else
		sdg = BoundaryNormalAnalyticMin(sdg, SdCube(p, GetBoundaryShape(i), GetBoundaryMatrixInv(i)));
#endif
	}

	return sdg.yzw;
}

float3 BoundaryNormal(const float3 p, const float d)
{
#if 0

	return BoundaryNormalAnalytic(p);

#else

	const float2 h = float2(_BoundaryWorldEpsilon, 0.0);
#if 1
	float3 diff = float3(
		BoundaryDistance(p - h.xyy) - d,
		BoundaryDistance(p - h.yxy) - d,
		BoundaryDistance(p - h.yyx) - d);
	return diff * rsqrt(dot(diff, diff) + 1e-7);
#else
	return normalize(float3(
		BoundaryDistance(p - h.xyy) - d,
		BoundaryDistance(p - h.yxy) - d,
		BoundaryDistance(p - h.yyx) - d
		));
#endif

#endif
}

#endif//__HAIRSIMCOMPUTEBOUNDARIES_HLSL__

```

`Runtime/HairSimComputeSolverBoundaries.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: 5540215c379d5064a9dec39f7ef17164
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimComputeSolverConstraints.hlsl`:

```hlsl
#ifndef __HAIRSIMCOMPUTECONSTRAINTS_HLSL__
#define __HAIRSIMCOMPUTECONSTRAINTS_HLSL__

#include "HairSimComputeSolverBoundaries.hlsl"
#include "HairSimComputeSolverQuaternion.hlsl"

#define MIN_MAX_HANDLES_NAN 0

//--------
// macros

#ifndef w_EPSILON
#define w_EPSILON 1e-7
#endif

#ifndef rsqrt_safe// used where NaN would otherwise damage the data
#if MIN_MAX_HANDLES_NAN
#define rsqrt_safe(x) max(0.0, rsqrt(x))
#else
#define rsqrt_safe(x) rsqrt(max(1e-37, x))
#endif
#endif

#ifndef rsqrt_unsafe// used where NaN is already handled by later operation
#if MIN_MAX_HANDLES_NAN
#define rsqrt_unsafe(x) rsqrt(x)
#else
#define rsqrt_unsafe(x) rsqrt_safe(x)
#endif
#endif

//----------------------
// constraint functions

void SolveCollisionConstraint(
	const float margin,
	const float w,
	const float3 p,
	inout float3 d)
{
	//         .
	//           `.
	//          d  \
	//        .---. .
	//       p----->|
	//              `
	//             /
	//           .`
	//         ´

	if (w > 0.0)
	{
		float depth = BoundaryDistance(p);
		if (depth < (_BoundaryWorldMargin + margin))
		{
			float3 normal = BoundaryNormal(p, depth);

			d += normal * (depth - (_BoundaryWorldMargin + margin));
		}
	}
}

void SolveCollisionFrictionConstraint(
	const float margin,
	const float friction,
	const float3 x0,
	const float w,
	const float3 p,
	inout float3 d)
{
	// see: "Unified Particle Physics for Real-Time Applications"
	// https://mmacklin.com/uppfrta_preprint.pdf
	//
	//                          x0
	//                         '
	//                d_tan   '
	//               .-----. '
	// - -- ------- x* ---> x ----- -- -
	//            .`|      /
	//            | |     /
	//            | |    /
	//      d_nrm | |   / d
	//            | |  /
	//            | | /
	//            '.|/
	//              p

	if (w > 0.0)
	{
		float depth = BoundaryDistance(p);
		if (depth < (_BoundaryWorldMargin + margin))
		{
			uint index = BoundarySelect(p, depth);
			float3 normal = BoundaryNormal(p, depth);

			depth -= (_BoundaryWorldMargin + margin);

			//... float4x4 M_inv_step = mul(_BoundaryMatrixPrev[index], _BoundaryMatrixInv[index]);
			const float3x4 M_inv_step = GetBoundaryMatrixInvStep(index);

			const float3 x_star = p + normal * depth;
			//... float3 x_delta = (x_star - x0) - (x_star - mul(M_inv_step, float4(x_star, 1.0)));
			const float3 x_delta = mul(M_inv_step, float4(x_star, 1.0)) - x0;
			const float3 x_delta_tan = x_delta - dot(x_delta, normal) * normal;

			d += normal * depth;

#define BOUNDARY_FRICTION_AS_CONSTANT_FRACTION 0
#if BOUNDARY_FRICTION_AS_CONSTANT_FRACTION
			d -= x_delta_tan * friction;// always subtract specified fraction of tangential delta, regardless of ratio between depth and tangential delta
#else
			const float norm2_delta_tan = dot(x_delta_tan, x_delta_tan);

			const float muS = friction * 1.7;// for now just using a constant multiplier to ensure that static friction is higher than kinetic friction
			const float muK = friction * 1.0;// ...

			if (norm2_delta_tan < muS * muS * depth * depth)
				d -= x_delta_tan;
			else
				d -= x_delta_tan * min(-muK * depth * rsqrt_unsafe(norm2_delta_tan), 1.0);
#endif
		}
	}
}

void SolveDistanceConstraint(
	const float distance0, const float stiffness,
	const float w0, const float w1,
	const float3 p0, const float3 p1,
	inout float3 d0, inout float3 d1)
{
	//      d0                      d1
	//    .----.                  .----.
	// p0 ------><--------------><------ p1
	//           \______________/
	//               distance0

	float3 r = p1 - p0;
	float rd_inv = rsqrt_safe(dot(r, r));

	float delta = 1.0 - (distance0 * rd_inv);
	float W_inv = (delta * stiffness) / (w0 + w1 + w_EPSILON);

	d0 += (w0 * W_inv) * r;
	d1 -= (w1 * W_inv) * r;
}

void SolveDistanceMinConstraint(
	const float distanceMin, const float stiffness,
	const float w0, const float w1,
	const float3 p0, const float3 p1,
	inout float3 d0, inout float3 d1)
{
	// variation of SolveDistanceConstraint(...),
	// ensures distance p0 - p1 >= distanceMin

	float3 r = p1 - p0;
	float rd_inv = rsqrt_unsafe(dot(r, r));

	float delta = 1.0 - max(1.0, distanceMin * rd_inv);// === if (rd < distanceMin) { delta = 1.0 - distanceMin / rd; }
	float W_inv = (delta * stiffness) / (w0 + w1 + w_EPSILON);

	d0 += (w0 * W_inv) * r;
	d1 -= (w1 * W_inv) * r;
}

void SolveDistanceMaxConstraint(
	const float distanceMax, const float stiffness,
	const float w0, const float w1,
	const float3 p0, const float3 p1,
	inout float3 d0, inout float3 d1)
{
	// variation of SolveDistanceConstraint(...),
	// ensures distance p0 - p1 <= distanceMax

	float3 r = p1 - p0;
	float rd_inv = rsqrt_unsafe(dot(r, r));

	float delta = 1.0 - min(1.0, distanceMax * rd_inv);// === if (rd > distanceMax) { delta = 1.0 - distanceMax / rd; }
	float W_inv = (delta * stiffness) / (w0 + w1 + w_EPSILON);

	d0 += (w0 * W_inv) * r;
	d1 -= (w1 * W_inv) * r;
}

void SolveDistanceLRAConstraint(
	const float distanceMax,
	const float3 p0, const float3 p1,
	inout float3 d1)
{
	// see: "Long Range Attachments - A Method to Simulate Inextensible Clothing in Computer Games"
	// https://matthias-research.github.io/pages/publications/sca2012cloth.pdf
	//
	//                        d1
	//                      .----.
	// p0 #----------------<------ p1
	//    \_______________/
	//       distanceMax

	float3 r = p1 - p0;
	float rd_inv = rsqrt_unsafe(dot(r, r));

	r *= 1.0 - min(1.0, distanceMax * rd_inv);

	d1 -= r;
}

void SolveDistanceFTLConstraint(
	const float distance0,
	const float3 p0, const float3 p1,
	inout float3 d1)
{
	// see: "Fast Simulation of Inextensible Hair and Fur"
	// https://matthias-research.github.io/pages/publications/FTLHairFur.pdf
	//
	//                       d1
	//                     .----.
	// p0 #--------------><------ p1
	//    \______________/
	//        distance0

	float3 r = p1 - p0;
	float rd_inv = rsqrt_safe(dot(r, r));

	r *= 1.0 - (distance0 * rd_inv);

	d1 -= r;
}

void SolveTriangleBendingConstraint(
	const float radius0, const float stiffness,
	const float w0, const float w1, const float w2,
	const float3 p0, const float3 p1, const float3 p2,
	inout float3 d0, inout float3 d1, inout float3 d2)
{
	// see: "A Triangle Bending Constraint Model for Position-Based Dynamics"
	// http://image.diku.dk/kenny/download/kelager.niebe.ea10.pdf
	//
	//                 p1
	//                  o
	//                ,´|`.
	//              ,´  |  `.
	//            ,´    | r  `.
	//    .     ,´      |      `.     .
	//    |   ,´        o C      `.   | r/2
	//    | ,´                     `. |
	// p0 o´-------------------------`o p2

	float3 c = (p0 + p1 + p2) / 3.0;
	float3 r = p1 - c;
	float rd_inv = rsqrt_safe(dot(r, r));

	float delta = 1.0 - radius0 * rd_inv;
	float W_inv = (2.0 * delta * stiffness) / (w0 + 2.0 * w1 + w2 + w_EPSILON);

	d0 += (w0 * W_inv) * r;
	d1 -= (w1 * W_inv * 2.0) * r;
	d2 += (w2 * W_inv) * r;
}

void SolveTriangleBendingMinConstraint(
	const float radiusMin, const float stiffness,
	const float w0, const float w1, const float w2,
	const float3 p0, const float3 p1, const float3 p2,
	inout float3 d0, inout float3 d1, inout float3 d2)
{
	// variation of SolveTriangleBendingConstraint(...),
	// ensures triangle bend radius >= radiusMin

	float3 c = (p0 + p1 + p2) / 3.0;
	float3 r = p1 - c;
	float rd_inv = rsqrt_unsafe(dot(r, r));

	float delta = 1.0 - max(1.0, radiusMin * rd_inv);// === if (rd < radiusMin) { delta = 1.0 - radiusMin / rd; }
	float W_inv = (2.0 * delta * stiffness) / (w0 + 2.0 * w1 + w2 + w_EPSILON);

	d0 += (w0 * W_inv) * r;
	d1 -= (w1 * W_inv * 2.0) * r;
	d2 += (w2 * W_inv) * r;
}

void SolveTriangleBendingMaxConstraint(
	const float radiusMax, const float stiffness,
	const float w0, const float w1, const float w2,
	const float3 p0, const float3 p1, const float3 p2,
	inout float3 d0, inout float3 d1, inout float3 d2)
{
	// variation of SolveTriangleBendingConstraint(...),
	// ensures triangle bend radius <= radiusMax

	float3 c = (p0 + p1 + p2) / 3.0;
	float3 r = p1 - c;
	float rd_inv = rsqrt_unsafe(dot(r, r));

	float delta = 1.0 - min(1.0, radiusMax * rd_inv);// === if (rd > radiusMax) { delta = 1.0 - radiusMax / rd; }
	float W_inv = (2.0 * delta * stiffness) / (w0 + 2.0 * w1 + w2 + w_EPSILON);

	d0 += (w0 * W_inv) * r;
	d1 -= (w1 * W_inv * 2.0) * r;
	d2 += (w2 * W_inv) * r;
}

void SolveEdgeVectorConstraint(
	const float3 v0, const float stiffness,
	const float w0, const float w1,
	const float3 p0, const float3 p1,
	inout float3 d0, inout float3 d1)
{
	float3 r = (p0 + v0) - p1;

	float W_inv = stiffness / (w0 + w1 + w_EPSILON);

	d0 -= (w0 * W_inv) * r;
	d1 += (w1 * W_inv) * r;
}

void SolveDualEdgeVectorConstraint(
	const float3 v0, const float3 v1, const float stiffness,
	const float w0, const float w1, const float w2,
	const float3 p0, const float3 p1, const float3 p2,
	inout float3 d0, inout float3 d1, inout float3 d2)
{
	float3 r = (p0 - 2.0 * p1 + p2 + v0 - v1);

	float W_inv = (1.0 * stiffness) / (w0 + 4.0 * w1 + w2 + w_EPSILON);

	d0 -= (w0 * W_inv) * r;
	d1 += (w1 * W_inv * 2.0) * r;
	d2 -= (w2 * W_inv) * r;
}

void SolveMaterialFrameBendTwistConstraint(
	const float4 darboux0, const float stiffness,
	const float w0, const float w1,
	const float4 q0, const float4 q1,
	inout float4 d0, inout float4 d1)
{
	// see: "Position and Orientation Based Cosserat Rods" by T. Kugelstadt and E. Schömer
	// https://www.cg.informatik.uni-mainz.de/files/2016/06/Position-and-Orientation-Based-Cosserat-Rods.pdf

	float4 darboux = QMul(QInverse(q0), q1);

	// apply eq. 32 + 33 to pick closest delta
#if 1
	float sqnorm_add = dot(darboux + darboux0, darboux + darboux0);
	float sqnorm_sub = dot(darboux - darboux0, darboux - darboux0);
	float4 delta = darboux + (sqnorm_add < sqnorm_sub ? 1.0 : -1.0) * darboux0;
#else
	float4 delta_add = (darboux + darboux0);
	float4 delta_sub = (darboux - darboux0);
	float4 delta = (dot(delta_add, delta_add) < dot(delta_sub, delta_sub)) ? delta_add : delta_sub;
#endif

	//TODO consider this?
	//if (dot(delta.xyz, delta.xyz) < 1e-7)
	//	return;

	// apply eq. 40 to calc corrections
	float W_inv = stiffness / (w0 + w1 + w_EPSILON);

	delta.w = 0.0;// zero scalar part
	d0 += (w0 * W_inv) * QMul(q1, delta);
	d1 -= (w1 * W_inv) * QMul(q0, delta);
}

void SolveMaterialFrameStretchShearConstraint(
	const float distance0, const float stiffness,
	const float w0, const float w1, const float wq,
	const float3 p0, const float3 p1, const float4 q,
	inout float3 d0, inout float3 d1, inout float4 dq)
{
	// see: "Position and Orientation Based Cosserat Rods" by T. Kugelstadt and E. Schömer
	// https://www.cg.informatik.uni-mainz.de/files/2016/06/Position-and-Orientation-Based-Cosserat-Rods.pdf

	const float3 e3 = float3(0, 1, 0);

#if 0
	// apply eq. 31 to obtain change vector
	float3 r = (p1 - p0) - distance0 * QMul(q, e3);

	// apply eq. 37 to calc corrections
	float W_inv = stiffness / (w0 + w1 + 4.0 * wq * distance0 * distance0 + w_EPSILON);

	 //TODO
	d0 += (w0 * W_inv) * r;
	d1 -= (w1 * W_inv) * r;
	dq += (wq * W_inv * distance0) * QMul(float4(r, 0), QMul(q, QConjugate(float4(e3, 0))));
#else
	// apply eq. 31 to obtain change vector
	float3 r = (p1 - p0) / distance0 - QMul(q, e3);

	// apply eq. 37 to calc corrections
	float W_inv = stiffness / (w0 + w1 + 4.0 * wq * distance0 * distance0 + w_EPSILON);

	d0 += (w0 * W_inv * distance0) * r;
	d1 -= (w1 * W_inv * distance0) * r;
	dq += (wq * W_inv * distance0 * distance0) * QMul(float4(r, 0), QMul(q, QConjugate(float4(e3, 0))));
#endif
}

//--------------------------------------------------
// constraint shortcuts: weight in fourth component

void SolveCollisionConstraint(
	const float margin,
	const float4 p,
	inout float3 d)
{
	SolveCollisionConstraint(margin, p.w, p.xyz, d);
}

void SolveCollisionFrictionConstraint(
	const float margin,
	const float friction,
	const float3 x0,
	const float4 p,
	inout float3 d)
{
	SolveCollisionFrictionConstraint(margin, friction, x0, p.w, p.xyz, d);
}

void SolveDistanceConstraint(
	const float distance0, const float stiffness,
	const float4 p0, const float4 p1,
	inout float3 d0, inout float3 d1)
{
	SolveDistanceConstraint(distance0, stiffness, p0.w, p1.w, p0.xyz, p1.xyz, d0, d1);
}

void SolveDistanceMinConstraint(
	const float distanceMin, const float stiffness,
	const float4 p0, const float4 p1,
	inout float3 d0, inout float3 d1)
{
	SolveDistanceMinConstraint(distanceMin, stiffness, p0.w, p1.w, p0.xyz, p1.xyz, d0, d1);
}

void SolveDistanceMaxConstraint(
	const float distanceMax, const float stiffness,
	const float4 p0, const float4 p1,
	inout float3 d0, inout float3 d1)
{
	SolveDistanceMaxConstraint(distanceMax, stiffness, p0.w, p1.w, p0.xyz, p1.xyz, d0, d1);
}

void SolveTriangleBendingConstraint(
	const float radius0, const float stiffness,
	const float4 p0, const float4 p1, const float4 p2,
	inout float3 d0, inout float3 d1, inout float3 d2)
{
	SolveTriangleBendingConstraint(radius0, stiffness, p0.w, p1.w, p2.w, p0.xyz, p1.xyz, p2.xyz, d0, d1, d2);
}

void SolveTriangleBendingMinConstraint(
	const float radiusMin, const float stiffness,
	const float4 p0, const float4 p1, const float4 p2,
	inout float3 d0, inout float3 d1, inout float3 d2)
{
	SolveTriangleBendingMinConstraint(radiusMin, stiffness, p0.w, p1.w, p2.w, p0.xyz, p1.xyz, p2.xyz, d0, d1, d2);
}

void SolveTriangleBendingMaxConstraint(
	const float radiusMax, const float stiffness,
	const float4 p0, const float4 p1, const float4 p2,
	inout float3 d0, inout float3 d1, inout float3 d2)
{
	SolveTriangleBendingMaxConstraint(radiusMax, stiffness, p0.w, p1.w, p2.w, p0.xyz, p1.xyz, p2.xyz, d0, d1, d2);
}

void SolveEdgeVectorConstraint(
	const float3 v0, const float stiffness,
	const float4 p0, const float4 p1,
	inout float3 d0, inout float3 d1)
{
	SolveEdgeVectorConstraint(v0, stiffness, p0.w, p1.w, p0.xyz, p1.xyz, d0, d1);
}

void SolveDualEdgeVectorConstraint(
	const float3 v0, const float3 v1, const float stiffness,
	const float4 p0, const float4 p1, const float4 p2,
	inout float3 d0, inout float3 d1, inout float3 d2)
{
	SolveDualEdgeVectorConstraint(v0, v1, stiffness, p0.w, p1.w, p2.w, p0.xyz, p1.xyz, p2.xyz, d0, d1, d2);
}

//------------------------------------------------------------
// constraint shortcuts: apply directly to position variables

void ApplyCollisionConstraint(const float margin, inout float3 p)
{
	float3 d = 0.0;
	SolveCollisionConstraint(margin, 1.0, p, d);
	p += d;
}

void ApplyCollisionFrictionConstraint(const float margin, const float friction, const float3 x0, inout float3 p)
{
	float3 d = 0.0;
	SolveCollisionFrictionConstraint(margin, friction, x0, 1.0, p, d);
	p += d;
}

void ApplyDistanceConstraint(const float distance0, const float stiffness, const float w0, const float w1, inout float3 p0, inout float3 p1)
{
	float3 d0 = 0.0;
	float3 d1 = 0.0;
	SolveDistanceConstraint(distance0, stiffness, w0, w1, p0, p1, d0, d1);
	p0 += d0;
	p1 += d1;
}

void ApplyDistanceMinConstraint(const float distanceMin, const float stiffness, const float w0, const float w1, inout float3 p0, inout float3 p1)
{
	float3 d0 = 0.0;
	float3 d1 = 0.0;
	SolveDistanceMinConstraint(distanceMin, stiffness, w0, w1, p0, p1, d0, d1);
	p0 += d0;
	p1 += d1;
}

void ApplyDistanceMaxConstraint(const float distanceMax, const float stiffness, const float w0, const float w1, inout float3 p0, inout float3 p1)
{
	float3 d0 = 0.0;
	float3 d1 = 0.0;
	SolveDistanceMaxConstraint(distanceMax, stiffness, w0, w1, p0, p1, d0, d1);
	p0 += d0;
	p1 += d1;
}

void ApplyDistanceLRAConstraint(const float distanceMax, const float3 p0, inout float3 p1)
{
	float3 d1 = 0.0;
	SolveDistanceLRAConstraint(distanceMax, p0, p1, d1);
	p1 += d1;
}

void ApplyDistanceFTLConstraint(const float distance0, const float3 p0, inout float3 p1, inout float3 d1)
{
	float3 d1_tmp = 0.0;
	SolveDistanceFTLConstraint(distance0, p0, p1, d1_tmp);
	p1 += d1_tmp;
	d1 += d1_tmp;
}

void ApplyTriangleBendingConstraint(
	const float radius0, const float stiffness,
	const float w0, const float w1, const float w2,
	inout float3 p0, inout float3 p1, inout float3 p2)
{
	float3 d0 = 0.0;
	float3 d1 = 0.0;
	float3 d2 = 0.0;
	SolveTriangleBendingConstraint(radius0, stiffness, w0, w1, w2, p0, p1, p2, d0, d1, d2);
	p0 += d0;
	p1 += d1;
	p2 += d2;
}

void ApplyTriangleBendingMinConstraint(
	const float radiusMin, const float stiffness,
	const float w0, const float w1, const float w2,
	inout float3 p0, inout float3 p1, inout float3 p2)
{
	float3 d0 = 0.0;
	float3 d1 = 0.0;
	float3 d2 = 0.0;
	SolveTriangleBendingMinConstraint(radiusMin, stiffness, w0, w1, w2, p0, p1, p2, d0, d1, d2);
	p0 += d0;
	p1 += d1;
	p2 += d2;
}

void ApplyTriangleBendingMaxConstraint(
	const float radiusMax, const float stiffness,
	const float w0, const float w1, const float w2,
	inout float3 p0, inout float3 p1, inout float3 p2)
{
	float3 d0 = 0.0;
	float3 d1 = 0.0;
	float3 d2 = 0.0;
	SolveTriangleBendingMaxConstraint(radiusMax, stiffness, w0, w1, w2, p0, p1, p2, d0, d1, d2);
	p0 += d0;
	p1 += d1;
	p2 += d2;
}

void ApplyEdgeVectorConstraint(
	const float3 v0, const float stiffness,
	const float w0, const float w1,
	inout float3 p0, inout float3 p1)
{
	float3 d0 = 0.0;
	float3 d1 = 0.0;
	SolveEdgeVectorConstraint(v0, stiffness, w0, w1, p0, p1, d0, d1);
	p0 += d0;
	p1 += d1;
}

void ApplyDualEdgeVectorConstraint(
	const float3 v0, const float3 v1, const float stiffness,
	const float w0, const float w1, const float w2,
	inout float3 p0, inout float3 p1, inout float3 p2)
{
	float3 d0 = 0.0;
	float3 d1 = 0.0;
	float3 d2 = 0.0;
	SolveDualEdgeVectorConstraint(v0, v1, stiffness, w0, w1, w2, p0, p1, p2, d0, d1, d2);
	p0 += d0;
	p1 += d1;
	p2 += d2;
}

void ApplyMaterialFrameBendTwistConstraint(
	const float4 darboux0, const float stiffness,
	const float w0, const float w1,
	inout float4 q0, inout float4 q1)
{
	float4 d0 = 0.0;
	float4 d1 = 0.0;
	SolveMaterialFrameBendTwistConstraint(darboux0, stiffness, w0, w1, q0, q1, d0, d1);
	q0 = normalize(q0 + d0);
	q1 = normalize(q1 + d1);
}

void ApplyMaterialFrameStretchShearConstraint(
	const float distance0, const float stiffness,
	const float w0, const float w1, const float wq,
	inout float3 p0, inout float3 p1, inout float4 q)
{
	float3 d0 = 0.0;
	float3 d1 = 0.0;
	float4 dq = 0.0;
	SolveMaterialFrameStretchShearConstraint(distance0, stiffness, w0, w1, wq, p0, p1, q, d0, d1, dq);
	p0 += d0;
	p1 += d1;
	q = normalize(q + dq);
}

#endif//__HAIRSIMCOMPUTECONSTRAINTS_HLSL__

```

`Runtime/HairSimComputeSolverConstraints.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: be6436be6b98ea84c9dd7dd3fca3df19
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimComputeSolverQuaternion.hlsl`:

```hlsl
#ifndef __HAIRSIMCOMPUTEQUATERNION_HLSL__
#define __HAIRSIMCOMPUTEQUATERNION_HLSL__

#ifndef normalize_safe
#define normalize_safe(x) ((x) * rsqrt(max(1e-37, dot(x, x))))
#endif

//----------------------
// quaternion functions

float4 QConjugate(float4 q)
{
	return q * float4(-1.0, -1.0, -1.0, 1.0);
}

float4 QInverse(float4 q)
{
	return QConjugate(q) * rcp(dot(q, q));
}

float4 QMul(float4 a, float4 b)
{
	float4 q;
	q.xyz = a.w * b.xyz + b.w * a.xyz + cross(a.xyz, b.xyz);
	q.w = a.w * b.w - dot(a.xyz, b.xyz);
	return q;
}

float3 QMul(float4 q, float3 v)
{
	float3 t = 2.0 * cross(q.xyz, v);
	return v + q.w * t + cross(q.xyz, t);
}

float4 QNlerp(float4 a, float4 b, float t)
{
	float d = dot(a, b);
	if (d < 0.0)
	{
		b = -b;
	}

	return normalize(lerp(a, b, t));
}

float4 QSlerp(float4 a, float4 b, float t)
{
	float d = dot(a, b);
	if (d < 0.0)
	{
		d = -d;
		b = -b;
	}

	if (d < (1.0 - 1e-5))
	{
		float2 w = sin(acos(d) * float2(1.0 - t, t)) * rsqrt(1.0 - d * d);
		return a * w.x + b * w.y;
	}
	else
	{
		return normalize(lerp(a, b, t));
	}
}

float3x3 QMat3x3(float4 q)
{
	float3 c0 = QMul(q, float3(1.0, 0.0, 0.0));
	float3 c1 = QMul(q, float3(0.0, 1.0, 0.0));
	float3 c2 = QMul(q, float3(0.0, 0.0, 1.0));

	return float3x3(
		c0.x, c1.x, c2.x,
		c0.y, c1.y, c2.y,
		c0.z, c1.z, c2.z);
}

float4 QDecomposeTwist(float4 q, float3 axis)
{
	// see: "Component of a quaternion rotation around an axis"
	// https://stackoverflow.com/a/22401169

	float3 v = float3(q.x, q.y, q.z);
	float dn = dot(v, axis);
	float3 p = dn * axis;
	float4 r = float4(p.x, p.y, p.z, q.w);

	if (dot(r, r) < 1e-5)
	{
		r = float4(0.0, 0.0, 0.0, 1.0);
	}
	else
	{
		if (dn < 0.0)
			r = normalize(-r);
		else
			r = normalize(r);
	}

	return r;
}

//-------------------------
// quaternion constructors

float4 MakeQuaternionIdentity()
{
	return float4(0.0, 0.0, 0.0, 1.0);
}

float4 MakeQuaternionTwistIdentity()
{
	return float4(0.0, 1.0, 0.0, 0.0);
}

float4 MakeQuaternionFromAxisAngle(float3 axis, float angle)
{
	float sina = sin(0.5 * angle);
	float cosa = cos(0.5 * angle);
	return float4(axis * sina, cosa);
}

float4 MakeQuaternionFromTo(float3 u, float3 v)
{
	float4 q;
	float s = 1.0 + dot(u, v);
	if (s < 1e-6)// if 'u' and 'v' are directly opposing
	{
		q.xyz = abs(u.x) > abs(u.z) ? float3(-u.y, u.x, 0.0) : float3(0.0, -u.z, u.y);
		q.w = 0.0;
	}
	else
	{
		q.xyz = cross(u, v);
		q.w = s;
	}
	return normalize(q);
}

float4 MakeQuaternionFromToWithFallback(float3 u, float3 v, float3 w)
{
	float4 q;
	float s = 1.0 + dot(u, v);
	if (s < 1e-6)// if 'u' and 'v' are directly opposing
	{
		q.xyz = w;
		q.w = 0.0;
	}
	else
	{
		q.xyz = cross(u, v);
		q.w = s;
	}
	return normalize(q);
}

float4 MakeQuaternionLookAtBasis(float3 forwardRef, float3 forward, float3 upRef, float3 up)
{
	float4 rotForward = MakeQuaternionFromTo(forwardRef, forward);
	float4 rotForwardTwist = MakeQuaternionFromToWithFallback(QMul(rotForward, upRef), up, forward);
	return QMul(rotForwardTwist, rotForward);
}

float4 MakeQuaternionLookAt(float3 forward, float3 up)
{
	float3 unityForward = float3(0, 0, 1);
	float3 unityUp = float3(0, 1, 0);
	return MakeQuaternionLookAtBasis(unityForward, forward, unityUp, up);
}

float4 MakeQuaternionFromBend(float3 p0, float3 p1, float3 p2)
{
#if 1
	// gracefully handle zero segment length
	float3 u = normalize_safe(p1 - p0);
	float3 v = normalize_safe(p2 - p1);
	return MakeQuaternionFromTo(u, v);
#else
	// assume non-zero segment length
	float3 u = normalize(p1 - p0);
	float3 v = normalize(p2 - p1);
	return MakeQuaternionFromTo(u, v);
#endif
}

float4 NextQuaternionFromBend(float3 p0, float3 p1, float3 p2, float4 q1)
{
#if 1
	// gracefully handle zero segment length
	float3 u = QMul(q1, float3(0, 1, 0));
	float3 v = normalize_safe(p2 - p1);

	float4 rotTangent = MakeQuaternionFromToWithFallback(u, v, QMul(q1, float3(1, 0, 0)));
	float4 rotTwist = MakeQuaternionTwistIdentity();

	return QMul(rotTangent, QMul(q1, rotTwist));
#else
	// assume non-zero segment length
	float3 u = QMul(q1, float3(0, 1, 0));
	float3 v = normalize(p2 - p1);

	float4 rotTangent = MakeQuaternionFromToWithFallback(u, v, QMul(q1, float3(1, 0, 0)));
	float4 rotTwist = MakeQuaternionTwistIdentity();

	return QMul(rotTangent, QMul(q1, rotTwist));
#endif
}

float4 NextQuaternionFromBendRMF(float3 p0, float3 p1, float3 p2, float4 q1)
{
	// see: "Computation of Rotation Minimizing Frames" by W. Wang, B. Jüttler, D. Zheng and Y. Liu
	// https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/Computation-of-rotation-minimizing-frames.pdf

	float3 localNormal = float3(0, 0, 1);
	float3 localTangent = float3(0, 1, 0);
	float3 localBitangent = float3(1, 0, 0);

	float3 v1 = normalize(p2 - p1);
	float3 ri = QMul(q1, localBitangent);
	float3 ti = QMul(q1, localTangent);

	float3 rLi = reflect(ri, v1);
	float3 tLi = reflect(ti, v1);

	float3 t2 = v1;
	float3 v2 = normalize(t2 - tLi);
	float3 r2 = reflect(rLi, v2);
	float3 s2 = cross(r2, t2);

#if 1
	// build new frame
	float4 rotTangent = MakeQuaternionFromToWithFallback(localTangent, t2, ri);
	float4 rotTangentTwist = MakeQuaternionFromToWithFallback(QMul(rotTangent, localNormal), -s2, t2);
	return QMul(rotTangentTwist, rotTangent);
#else
	// rotate existing frame
	float4 rotTangent = MakeQuaternionFromToWithFallback(ti, t2, ri);
	q1 = QMul(rotTangent, q1);
	float4 rotTangentTwist = MakeQuaternionFromToWithFallback(QMul(q1, localBitangent), r2, t2);
	q1 = QMul(rotTangentTwist, q1);
	return q1;
#endif
}

//--------------------------------
// quaternion storage/compression

float4 QDecode16(uint2 q16)
{
	return float4(f16tof32(q16), f16tof32(q16 >> 16));
}

uint2 QEncode16(float4 q)
{
	return f32tof16(q.xy) | (f32tof16(q.zw) << 16);
}

#endif//__HAIRSIMCOMPUTEQUATERNION_HLSL__

```

`Runtime/HairSimComputeSolverQuaternion.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: f31266d43f1da32498f0f67bf367b05a
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  preprocessorOverride: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimComputeVolume.compute`:

```compute
//#pragma use_dxc
//#pragma enable_d3d11_debug_symbols

#pragma kernel KBoundsClear						THREAD_GROUP_SIZE=64	F_BOUNDS
#pragma kernel KBoundsGather					THREAD_GROUP_SIZE=64	F_BOUNDS
#pragma kernel KBoundsResolve					THREAD_GROUP_SIZE=64	F_BOUNDS
#pragma kernel KBoundsResolveCombined			THREAD_GROUP_SIZE=1		F_BOUNDS
#pragma kernel KBoundsHistory					THREAD_GROUP_SIZE=64	F_BOUNDS
#pragma kernel KBoundsCoverage					THREAD_GROUP_SIZE=64	F_BOUNDS

#pragma kernel KLODSelection					THREAD_GROUP_SIZE=1		F_LOD

#pragma kernel KVolumeSplat						THREAD_GROUP_SIZE=64	F_SPLAT
#pragma kernel KVolumeSplatDensity				THREAD_GROUP_SIZE=64	F_SPLAT
#pragma kernel KVolumeSplatVelocityX			THREAD_GROUP_SIZE=64	F_SPLAT
#pragma kernel KVolumeSplatVelocityY			THREAD_GROUP_SIZE=64	F_SPLAT
#pragma kernel KVolumeSplatVelocityZ			THREAD_GROUP_SIZE=64	F_SPLAT

#pragma kernel KVolumeClear						THREAD_GROUP_SIZE_XY=8	F_CLEAR
#pragma kernel KVolumeResolve					THREAD_GROUP_SIZE_XY=8	F_RESOLVE
#pragma kernel KVolumeResolveRaster				THREAD_GROUP_SIZE_XY=8	F_RESOLVE
#pragma kernel KVolumeDivergence				THREAD_GROUP_SIZE_XY=8	F_DIVERGENCE
#pragma kernel KVolumePressureEOS				THREAD_GROUP_SIZE_XY=8	F_PRESSURE
#pragma kernel KVolumePressureSolve				THREAD_GROUP_SIZE_XY=8	F_PRESSURE
#pragma kernel KVolumePressureGradient			THREAD_GROUP_SIZE_XY=8	F_PRESSURE
#pragma kernel KVolumeScatteringPrep			THREAD_GROUP_SIZE_XY=8	F_SCATTERING
#pragma kernel KVolumeScattering				THREAD_GROUP_SIZE_XY=8	F_SCATTERING
#pragma kernel KVolumeWindPrep					THREAD_GROUP_SIZE_XY=8	F_WIND
#pragma kernel KVolumeWind						THREAD_GROUP_SIZE_XY=8	F_WIND

#pragma kernel KBoundariesAdvance				THREAD_GROUP_SIZE=64	F_BOUNDARIES
#pragma kernel KBoundariesSubstep				THREAD_GROUP_SIZE=64	F_BOUNDARIES
#pragma kernel KEmittersAdvance					THREAD_GROUP_SIZE=64	F_EMITTERS
#pragma kernel KEmittersSubstep					THREAD_GROUP_SIZE=64	F_EMITTERS

//----------
// features

#pragma multi_compile __ LAYOUT_INTERLEAVED
// 0 == particles grouped by strand, i.e. root, root+1, root, root+1
// 1 == particles grouped by index, i.e. root, root, root+1, root+1

#pragma multi_compile __ VOLUME_SPLAT_CLUSTERS
// 0 == splat weight of single particle
// 1 == splat weight of cluster of particles

#pragma multi_compile __ VOLUME_SUPPORT_CONTRACTION
// 0 == pressure is always positive
// 1 == negative pressure causes contraction

#pragma multi_compile __ VOLUME_TARGET_INITIAL_POSE VOLUME_TARGET_INITIAL_POSE_IN_PARTICLES
// 0 == uniform target density
// 1 == non uniform target density

//------------------
// features derived

#if VOLUME_SUPPORT_CONTRACTION
	#define VOLUME_REST_AT_ZERO					0
	#define VOLUME_AIR_CELL_ZERO_PRESSURE		0
	#define VOLUME_AIR_CELL_ZERO_PRESSURE_GRAD	0
	#define VOLUME_AIR_CELL_ZERO_DIVERGENCE		1
	#define VOLUME_AIR_CELL_ZERO_SINK			1
	#define VOLUME_GHOST_PRESSURE				1
	#define VOLUME_GHOST_PRESSURE_GRAD			1
	#define VOLUME_VOF							0
#elif 1// no contraction
	#define VOLUME_REST_AT_ZERO					1
	#define VOLUME_AIR_CELL_ZERO_PRESSURE		0
	#define VOLUME_AIR_CELL_ZERO_PRESSURE_GRAD	0
	#define VOLUME_AIR_CELL_ZERO_DIVERGENCE		1
	#define VOLUME_AIR_CELL_ZERO_SINK			1
	#define VOLUME_GHOST_PRESSURE				0
	#define VOLUME_GHOST_PRESSURE_GRAD			0
	#define VOLUME_VOF							0
#else// old (incorrect)
	#define VOLUME_REST_AT_ZERO					0
	#define VOLUME_AIR_CELL_ZERO_PRESSURE		0
	#define VOLUME_AIR_CELL_ZERO_PRESSURE_GRAD	0
	#define VOLUME_AIR_CELL_ZERO_DIVERGENCE		1
	#define VOLUME_AIR_CELL_ZERO_SINK			0
	#define VOLUME_GHOST_PRESSURE				0
	#define VOLUME_GHOST_PRESSURE_GRAD			0
	#define VOLUME_VOF							0
#endif

//----------
// includes

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Random.hlsl"

#define HAIRSIM_WRITEABLE_VOLUMEBOUNDS (F_BOUNDS)
#define HAIRSIM_WRITEABLE_VOLUMELOD (F_LOD)
#define HAIRSIM_WRITEABLE_VOLUMEACCU (F_CLEAR || F_SPLAT)
#define HAIRSIM_WRITEABLE_VOLUMEDATA (F_RESOLVE || F_DIVERGENCE || F_PRESSURE)
#define HAIRSIM_WRITEABLE_VOLUMEOPTS (F_CLEAR || F_SCATTERING || F_WIND)
#define HAIRSIM_WRITEABLE_VOLUMESUBSTEP (F_BOUNDARIES || F_EMITTERS)

#include "HairSimData.hlsl"
#include "HairSimComputeConfig.hlsl"
#include "HairSimComputeVolumeUtility.hlsl"
#include "HairSimComputeSolverBoundaries.hlsl"
#include "HairSimComputeSolverQuaternion.hlsl"
#include "HairSimComputeLOD.hlsl"

#if F_CLEAR || F_SPLAT || F_RESOLVE
#include "HairSimComputeVolumeTransfer.hlsl"
#endif
#if F_SCATTERING
#include "HairSimComputeVolumeProbe.hlsl"
#endif

//--------
// macros

#if VOLUME_SPLAT_CLUSTERS
  #define CHECK_SPLAT(x)	\
	if (x >= _SolverLODRange[SOLVERLODRANGE_SOLVE].y * _StrandParticleCount) return;
#else
  #define CHECK_SPLAT(x)	\
	if (x >= _StrandCount * _StrandParticleCount) return;
#endif

#if VOLUME_SPLAT_CLUSTERS && LAYOUT_INTERLEAVED
  #define DECLARE_SPLAT_PARTICLE_UNCHECKED(x)	\
	const uint particleIndex = _StrandCount * (x / _SolverLODRange[SOLVERLODRANGE_SOLVE].y) + (x % _SolverLODRange[SOLVERLODRANGE_SOLVE].y);
#else
  #define DECLARE_SPLAT_PARTICLE_UNCHECKED(x)	\
	const uint particleIndex = x;
#endif

#define DECLARE_SPLAT_PARTICLE(x)	\
	CHECK_SPLAT(x);					\
	DECLARE_SPLAT_PARTICLE_UNCHECKED(x);

#define CHECK_STRAND(x)			(x < _StrandCount)
#define CHECK_STRAND_SOLVER(x)	(x < _SolverLODRange[SOLVERLODRANGE_SOLVE].y)

#define DECLARE_STRAND_UNCHECKED(x)											\
	const uint strandIndex = x;												\
	const uint strandParticleBegin = strandIndex * _StrandParticleOffset;	\
	const uint strandParticleStride = _StrandParticleStride;				\
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;

#define DECLARE_STRAND(x)			\
	if (!CHECK_STRAND(x)) return;	\
	DECLARE_STRAND_UNCHECKED(x);

#define DECLARE_STRAND_SOLVER(x)			\
	if (!CHECK_STRAND_SOLVER(x)) return;	\
	DECLARE_STRAND_UNCHECKED(x);

#define CHECK_BOUNDS(x)			(x <= _CombinedBoundsIndex)
#define CHECK_BOUNDS_GROUP(x)	(x < _CombinedBoundsIndex)

#define DECLARE_BOUNDS_UNCHECKED(x)	\
	const uint boundsIndex = x;

#define DECLARE_BOUNDS(x)			\
	if (!CHECK_BOUNDS(x)) return;	\
	DECLARE_BOUNDS_UNCHECKED(x);

#define DECLARE_BOUNDS_GROUP(x)			\
	if (!CHECK_BOUNDS_GROUP(x)) return;	\
	DECLARE_BOUNDS_UNCHECKED(x);

//---------------
// kernels splat

#if F_SPLAT

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KVolumeSplat(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_SPLAT_PARTICLE(worldIdx.x);

	const float3 p = _ParticlePosition[particleIndex].xyz;
	const float3 v = _ParticleVelocity[particleIndex].xyz;
	const float w = GetParticleVolumeWeight(particleIndex);

	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	// splat density
	InterlockedAddParticleContribution(lodGrid, p, (w), _AccuWeight);

	// splat target density
	{
#if VOLUME_TARGET_INITIAL_POSE
		const uint strandIndex = GetParticleStrandIndex(particleIndex);
		const float3 p0 = _RootPosition[strandIndex].xyz;
		const float3 r0 = QMul(_RootFrame[strandIndex], _InitialParticleOffset[particleIndex].xyz * _GroupScale);
		InterlockedAddParticleContribution(lodGrid, p0 + r0, (w), _AccuWeight0);
#elif VOLUME_TARGET_INITIAL_POSE_IN_PARTICLES
		InterlockedMaxParticleContribution(lodGrid, p, (w * _InitialParticleOffset[particleIndex].w), _AccuWeight0);
#endif
	}

	//TODO remap and pack according to max velocity within volume?
	// splat velocity
#if VOLUME_STAGGERED_GRID
	InterlockedAddParticleContributionPackW(lodGrid, p, (w * v.x), _AccuVelocityX, float3(0.0, 0.5, 0.5));
	InterlockedAddParticleContributionPackW(lodGrid, p, (w * v.y), _AccuVelocityY, float3(0.5, 0.0, 0.5));
	InterlockedAddParticleContributionPackW(lodGrid, p, (w * v.z), _AccuVelocityZ, float3(0.5, 0.5, 0.0));
#else
	InterlockedAddParticleContribution(lodGrid, p, (w * v.x), _AccuVelocityX);
	InterlockedAddParticleContribution(lodGrid, p, (w * v.y), _AccuVelocityY);
	InterlockedAddParticleContribution(lodGrid, p, (w * v.z), _AccuVelocityZ);
#endif
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KVolumeSplatDensity(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_SPLAT_PARTICLE(worldIdx.x);

	const float3 p = _ParticlePosition[particleIndex].xyz;
	const float3 v = _ParticleVelocity[particleIndex].xyz;
	const float w = GetParticleVolumeWeight(particleIndex);

	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	// splat density
	InterlockedAddParticleContribution(lodGrid, p, (w), _AccuWeight);

	// splat target density
	{
#if VOLUME_TARGET_INITIAL_POSE
		const uint strandIndex = GetParticleStrandIndex(particleIndex);
		const float3 p0 = _RootPosition[strandIndex].xyz;
		const float3 r0 = QMul(_RootFrame[strandIndex], _InitialParticleOffset[particleIndex].xyz * _GroupScale);
		InterlockedAddParticleContribution(lodGrid, p0 + r0, (w), _AccuWeight0);
#elif VOLUME_TARGET_INITIAL_POSE_IN_PARTICLES
		InterlockedMaxParticleContribution(lodGrid, p, (w * _InitialParticleOffset[particleIndex].w), _AccuWeight0);
#endif
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KVolumeSplatVelocityX(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_SPLAT_PARTICLE(worldIdx.x);

	const float3 p = _ParticlePosition[particleIndex].xyz;
	const float3 v = _ParticleVelocity[particleIndex].xyz;
	const float w = GetParticleVolumeWeight(particleIndex);

	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	// splat velocity-x
#if VOLUME_STAGGERED_GRID
	InterlockedAddParticleContributionPackW(lodGrid, p, (w * v.x), _AccuVelocityX, float3(0.0, 0.5, 0.5));
#else
	InterlockedAddParticleContribution(lodGrid, p, (w * v.x), _AccuVelocityX);
#endif
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KVolumeSplatVelocityY(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_SPLAT_PARTICLE(worldIdx.x);

	const float3 p = _ParticlePosition[particleIndex].xyz;
	const float3 v = _ParticleVelocity[particleIndex].xyz;
	const float w = GetParticleVolumeWeight(particleIndex);

	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	// splat velocity-y
#if VOLUME_STAGGERED_GRID
	InterlockedAddParticleContributionPackW(lodGrid, p, (w * v.y), _AccuVelocityY, float3(0.5, 0.0, 0.5));
#else
	InterlockedAddParticleContribution(lodGrid, p, (w * v.y), _AccuVelocityY);
#endif
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KVolumeSplatVelocityZ(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_SPLAT_PARTICLE(worldIdx.x);

	const float3 p = _ParticlePosition[particleIndex].xyz;
	const float3 v = _ParticleVelocity[particleIndex].xyz;
	const float w = GetParticleVolumeWeight(particleIndex);

	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	// splat velocity-z
#if VOLUME_STAGGERED_GRID
	InterlockedAddParticleContributionPackW(lodGrid, p, (w * v.z), _AccuVelocityZ, float3(0.5, 0.5, 0.0));
#else
	InterlockedAddParticleContribution(lodGrid, p, (w * v.z), _AccuVelocityZ);
#endif
}

#endif//F_SPLAT

//---------------
// kernels clear

#if F_CLEAR

[numthreads(THREAD_GROUP_SIZE_XY, THREAD_GROUP_SIZE_XY, 1)]
void KVolumeClear(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	ACCUIDX accuIdx = WORLDIDX_TO_ACCUIDX(worldIdx);

	_AccuWeight[accuIdx] = 0;

#if VOLUME_TARGET_INITIAL_POSE || VOLUME_TARGET_INITIAL_POSE_IN_PARTICLES
	_AccuWeight0[accuIdx] = 0;
#endif

	_AccuVelocityX[accuIdx] = 0;
	_AccuVelocityY[accuIdx] = 0;
	_AccuVelocityZ[accuIdx] = 0;

	_VolumeScattering[worldIdx] = 0;

	_VolumeImpulse[worldIdx] = 0;
}

#endif//F_CLEAR

//-----------------
// kernels resolve

#if F_RESOLVE

[numthreads(THREAD_GROUP_SIZE_XY, THREAD_GROUP_SIZE_XY, 1)]
void KVolumeResolve(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	ACCUIDX accuIdx = WORLDIDX_TO_ACCUIDX(worldIdx);

	const int accu_n = _AccuWeight[accuIdx];
	const float accu_w = accu_n / (float)(1 << SPLAT_FRACTIONAL_BITS);

	const float rho_particle = _AllGroupsMaxParticleVolume / VolumeWorldCellVolume(lodGrid);

	_VolumeDensity[worldIdx] = rho_particle * accu_w;

#if VOLUME_TARGET_INITIAL_POSE
	_VolumeDensity0[worldIdx] = rho_particle * (_AccuWeight0[accuIdx] / (float)(1 << SPLAT_FRACTIONAL_BITS));
#elif VOLUME_TARGET_INITIAL_POSE_IN_PARTICLES
	_VolumeDensity0[worldIdx] = rho_particle * (_AccuWeight0[accuIdx] / (float)(1 << SPLAT_FRACTIONAL_BITS));
#endif

	_VolumeVelocity[worldIdx] = float4(
		(float3(
#if VOLUME_STAGGERED_GRID
			_AccuVelocityX[accuIdx] >> WEIGHT_BITS,
			_AccuVelocityY[accuIdx] >> WEIGHT_BITS,
			_AccuVelocityZ[accuIdx] >> WEIGHT_BITS) /
			float3(
				max(1, _AccuVelocityX[accuIdx] & WEIGHT_MASK),
				max(1, _AccuVelocityY[accuIdx] & WEIGHT_MASK),
				max(1, _AccuVelocityZ[accuIdx] & WEIGHT_MASK)
			)
#else
			_AccuVelocityX[accuIdx],
			_AccuVelocityY[accuIdx],
			_AccuVelocityZ[accuIdx]) / (float)max(1, accu_n)
#endif
		),
		accu_w);
}

[numthreads(THREAD_GROUP_SIZE_XY, THREAD_GROUP_SIZE_XY, 1)]
void KVolumeResolveRaster(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	const float4 splat = _VolumeVelocity[worldIdx];
	{
		const float rho_particle = _AllGroupsMaxParticleVolume / VolumeWorldCellVolume(lodGrid);

		_VolumeDensity[worldIdx] = rho_particle * splat.w;

		if (splat.w > 0.0)
			_VolumeVelocity[worldIdx] = float4(splat.xyz / splat.w, splat.w);
		else
			_VolumeVelocity[worldIdx] = 0.0;
	}
}

#endif//F_RESOLVE

//--------------------
// kernels divergence

#if F_DIVERGENCE

[numthreads(THREAD_GROUP_SIZE_XY, THREAD_GROUP_SIZE_XY, 1)]
void KVolumeDivergence(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	const bool3 isBoundaryLower = (worldIdx == 0);
	const bool3 isBoundaryUpper = (worldIdx == (uint3)lodGrid.volumeCellCount.xyz - 1);

	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

	const float4 v_in = _VolumeVelocity[worldIdx];

#if VOLUME_VOF
	const float min_contrib = 0.1;
	const float max_contrib = 2.0;
	
	const float w_xm = clamp(_VolumeDensity[worldIdx - worldIdxStrideX], min_contrib, max_contrib);
	const float w_ym = clamp(_VolumeDensity[worldIdx - worldIdxStrideY], min_contrib, max_contrib);
	const float w_zm = clamp(_VolumeDensity[worldIdx - worldIdxStrideZ], min_contrib, max_contrib);

	const float w_xp = clamp(_VolumeDensity[worldIdx + worldIdxStrideX], min_contrib, max_contrib);
	const float w_yp = clamp(_VolumeDensity[worldIdx + worldIdxStrideY], min_contrib, max_contrib);
	const float w_zp = clamp(_VolumeDensity[worldIdx + worldIdxStrideZ], min_contrib, max_contrib);
	
	const float vx_xm = isBoundaryLower.x ? v_in.x : _VolumeVelocity[worldIdx - worldIdxStrideX].x * w_xm;
	const float vy_ym = isBoundaryLower.y ? v_in.y : _VolumeVelocity[worldIdx - worldIdxStrideY].y * w_ym;
	const float vz_zm = isBoundaryLower.z ? v_in.z : _VolumeVelocity[worldIdx - worldIdxStrideZ].z * w_zm;

	const float vx_xp = isBoundaryUpper.x ? v_in.x : _VolumeVelocity[worldIdx + worldIdxStrideX].x * w_xp;
	const float vy_yp = isBoundaryUpper.y ? v_in.y : _VolumeVelocity[worldIdx + worldIdxStrideY].y * w_yp;
	const float vz_zp = isBoundaryUpper.z ? v_in.z : _VolumeVelocity[worldIdx + worldIdxStrideZ].z * w_zp;
#else
  #if VOLUME_STAGGERED_GRID
	const float vx_xm = v_in.x;
	const float vy_ym = v_in.y;
	const float vz_zm = v_in.z;
  #else
	const float vx_xm = isBoundaryLower.x ? v_in.x : _VolumeVelocity[worldIdx - worldIdxStrideX].x;
	const float vy_ym = isBoundaryLower.y ? v_in.y : _VolumeVelocity[worldIdx - worldIdxStrideY].y;
	const float vz_zm = isBoundaryLower.z ? v_in.z : _VolumeVelocity[worldIdx - worldIdxStrideZ].z;
  #endif

	const float vx_xp = isBoundaryUpper.x ? v_in.x : _VolumeVelocity[worldIdx + worldIdxStrideX].x;
	const float vy_yp = isBoundaryUpper.y ? v_in.y : _VolumeVelocity[worldIdx + worldIdxStrideY].y;
	const float vz_zp = isBoundaryUpper.z ? v_in.z : _VolumeVelocity[worldIdx + worldIdxStrideZ].z;
#endif

#if VOLUME_SQUARE_CELLS
  #if VOLUME_STAGGERED_GRID
	const float h = 1.0 * VolumeWorldCellSize(lodGrid).x;
  #else
	const float h = 2.0 * VolumeWorldCellSize(lodGrid).x;
  #endif
	const float div = float(
		(vx_xp - vx_xm) +
		(vy_yp - vy_ym) +
		(vz_zp - vz_zm)) / h;
#else
	const float3 h = 2.0 * VolumeWorldCellSize(lodGrid).xyz;
	const float div = float(
		(vx_xp - vx_xm) / h.x +
		(vy_yp - vy_ym) / h.y +
		(vz_zp - vz_zm) / h.z);
#endif

	const float rho = _VolumeDensity[worldIdx];
#if VOLUME_TARGET_INITIAL_POSE || VOLUME_TARGET_INITIAL_POSE_IN_PARTICLES
	const float rho0 = _VolumeDensity0[worldIdx];
#else
	const float rho0 = 1.0;
#endif

#if VOLUME_AIR_CELL_ZERO_DIVERGENCE || VOLUME_AIR_CELL_ZERO_SINK
	if (rho == 0.0)
	{
	#if VOLUME_AIR_CELL_ZERO_DIVERGENCE && VOLUME_AIR_CELL_ZERO_SINK
		_VolumeDivergence[worldIdx] = 0.0;
	#elif VOLUME_AIR_CELL_ZERO_DIVERGENCE
	  #if VOLUME_REST_AT_ZERO
		_VolumeDivergence[worldIdx] = 0.0 - max(0.0, rho / _TargetDensityScale - rho0) * (_TargetDensityInfluence);
	  #else
		_VolumeDivergence[worldIdx] = 0.0 - (rho / _TargetDensityScale - rho0) * (_TargetDensityInfluence);
	  #endif
	#else
		_VolumeDivergence[worldIdx] = div;
	#endif
	}
	else
#endif
	{
	  #if VOLUME_REST_AT_ZERO
		_VolumeDivergence[worldIdx] = min(0.0, div - (rho / _TargetDensityScale - rho0) * (_TargetDensityInfluence));
	  #else
		_VolumeDivergence[worldIdx] = div - (rho / _TargetDensityScale - rho0) * (_TargetDensityInfluence);
	  #endif
	}
}

#endif//F_DIVERGENCE

//------------------
// kernels pressure

#if F_PRESSURE

[numthreads(THREAD_GROUP_SIZE_XY, THREAD_GROUP_SIZE_XY, 1)]
void KVolumePressureEOS(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	const float rho = _VolumeDensity[worldIdx];
#if VOLUME_TARGET_INITIAL_POSE || VOLUME_TARGET_INITIAL_POSE_IN_PARTICLES
	const float rho0 = _VolumeDensity0[worldIdx];
#else
	const float rho0 = 1.0;
#endif

#if VOLUME_AIR_CELL_ZERO_PRESSURE || VOLUME_AIR_CELL_ZERO_SINK
	if (rho == 0.0)
	{
		_VolumePressure[worldIdx] = 0.0;
	}
	else
#endif
	{
	  #if VOLUME_REST_AT_ZERO
		_VolumePressure[worldIdx] = max(0.0, rho / _TargetDensityScale - rho0) * (_TargetDensityInfluence * VolumeWorldCellSize(lodGrid).x * VolumeWorldCellSize(lodGrid).x);
	  #else
		_VolumePressure[worldIdx] = (rho / _TargetDensityScale - rho0) * (_TargetDensityInfluence * VolumeWorldCellSize(lodGrid).x * VolumeWorldCellSize(lodGrid).x);
	  #endif
	}
}

float GhostPressureStep(const VolumeLODGrid lodGrid, int3 index, int3 step)
{
	uint3 other = clamp(index + step, int3(0, 0, 0), (int3)lodGrid.volumeCellCount.xyz - 1);
	
	float rho_0 = _VolumeDensity[index];
	float rho_1 = _VolumeDensity[other];
	
#if VOLUME_GHOST_PRESSURE
	if (rho_1 == 0.0 && rho_0 > 0.0)
	{
		// step from volume -> air
		float vol_0 = abs(rho_0);
		float vol_0_r = pow((3.0 * vol_0) / (4.0 * 3.14159), 1.0 / 3.0);
			
		float sd_0 = -vol_0_r;
		float sd_1 = 1.0 - vol_0_r;
			
		return _VolumePressure[index] * (sd_0 / sd_1);
	}
	else
#endif
	{
		return _VolumePressure[other];
	}
}

bool GhostPressureCell(uint3 worldIdx)
{
	if (_VolumeDensity[worldIdx] == 0.0)
		return true;
	else
		return false;
}

float GhostPressure(const VolumeLODGrid lodGrid, float rho, float pressure, uint3 worldIdx)
{
	worldIdx = clamp(worldIdx, uint3(0, 0, 0), (uint3)lodGrid.volumeCellCount.xyz - 1);
	
	if (rho > 0.0 && GhostPressureCell(worldIdx))
	{
		float vol_0 = abs(rho);
		float vol_0_r = pow((3.0 * vol_0) / (4.0 * 3.14159), 1.0 / 3.0);
		
		float theta = saturate(vol_0_r);
		
		return -pressure * saturate((1.0 - theta) / theta);
	}
	else
	{
		return _VolumePressure[worldIdx];
	}
}

[numthreads(THREAD_GROUP_SIZE_XY, THREAD_GROUP_SIZE_XY, 1)]
void KVolumePressureSolve(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	const float rho = _VolumeDensity[worldIdx];

#if VOLUME_AIR_CELL_ZERO_PRESSURE
	if (rho == 0.0)
	{
		_VolumePressureNext[worldIdx] = 0.0;
		return;
	}
#endif
	
	// solve poisson equation for pressure using central differences
	// https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch38.html

	const bool3 isBoundaryLower = (worldIdx == 0);
	const bool3 isBoundaryUpper = (worldIdx == (uint3)lodGrid.volumeCellCount.xyz - 1);
	
	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

	const float p_in = _VolumePressure[worldIdx];
	
#if VOLUME_GHOST_PRESSURE
	const float p_xm = GhostPressure(lodGrid, rho, p_in, worldIdx - worldIdxStrideX);
	const float p_ym = GhostPressure(lodGrid, rho, p_in, worldIdx - worldIdxStrideY);
	const float p_zm = GhostPressure(lodGrid, rho, p_in, worldIdx - worldIdxStrideZ);

	const float p_xp = GhostPressure(lodGrid, rho, p_in, worldIdx + worldIdxStrideX);
	const float p_yp = GhostPressure(lodGrid, rho, p_in, worldIdx + worldIdxStrideY);
	const float p_zp = GhostPressure(lodGrid, rho, p_in, worldIdx + worldIdxStrideZ);
#else
	const float p_xm = isBoundaryLower.x ? p_in : _VolumePressure[worldIdx - worldIdxStrideX];
	const float p_ym = isBoundaryLower.y ? p_in : _VolumePressure[worldIdx - worldIdxStrideY];
	const float p_zm = isBoundaryLower.z ? p_in : _VolumePressure[worldIdx - worldIdxStrideZ];

	const float p_xp = isBoundaryUpper.x ? p_in : _VolumePressure[worldIdx + worldIdxStrideX];
	const float p_yp = isBoundaryUpper.y ? p_in : _VolumePressure[worldIdx + worldIdxStrideY];
	const float p_zp = isBoundaryUpper.z ? p_in : _VolumePressure[worldIdx + worldIdxStrideZ];
#endif

	const float b = _VolumeDivergence[worldIdx];
	const float w = 1.0;// SOR factor [1..2]

#if VOLUME_SQUARE_CELLS
	const float h = VolumeWorldCellSize(lodGrid).x;
	const float a = -(h * h);

	const float pressure =
		(1.0 - w) * p_in +
		(w / 6.0) * float(
			p_xm + p_xp +
			p_ym + p_yp +
			p_zm + p_zp +
			a * b);
#else
	const float3 h = VolumeWorldCellSize(lodGrid).xyz;
	const float3 a = -(h * h) / 3.0;

	const float pressure =
		(1.0 - w) * p_in +
		(w / 6.0) * float(
			(p_xm + p_xp + a.x * b) + 
			(p_ym + p_yp + a.y * b) +
			(p_zm + p_zp + a.z * b));
#endif

	_VolumePressureNext[worldIdx] = pressure;
}

[numthreads(THREAD_GROUP_SIZE_XY, THREAD_GROUP_SIZE_XY, 1)]
void KVolumePressureGradient(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	const float rho = _VolumeDensity[worldIdx];
	
#if VOLUME_AIR_CELL_ZERO_PRESSURE_GRAD
	if (rho == 0.0)
	{
		_VolumePressureGrad[worldIdx] = 0.0;
		return;
	}
#endif

	const bool3 isBoundaryLower = (worldIdx == 0);
	const bool3 isBoundaryUpper = (worldIdx == (uint3)lodGrid.volumeCellCount.xyz - 1);

	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

	const float p_in = _VolumePressure[worldIdx];

#if VOLUME_GHOST_PRESSURE_GRAD
	const float p_xm = GhostPressure(lodGrid, rho, p_in, worldIdx - worldIdxStrideX);
	const float p_ym = GhostPressure(lodGrid, rho, p_in, worldIdx - worldIdxStrideY);
	const float p_zm = GhostPressure(lodGrid, rho, p_in, worldIdx - worldIdxStrideZ);

  #if VOLUME_STAGGERED_GRID
	const float p_xp = p_in;
	const float p_yp = p_in;
	const float p_zp = p_in;
  #else
	const float p_xp = GhostPressure(lodGrid, rho, p_in, worldIdx + worldIdxStrideX);
	const float p_yp = GhostPressure(lodGrid, rho, p_in, worldIdx + worldIdxStrideY);
	const float p_zp = GhostPressure(lodGrid, rho, p_in, worldIdx + worldIdxStrideZ);
  #endif
#else
	const float p_xm = isBoundaryLower.x ? p_in : _VolumePressure[worldIdx - worldIdxStrideX];
	const float p_ym = isBoundaryLower.y ? p_in : _VolumePressure[worldIdx - worldIdxStrideY];
	const float p_zm = isBoundaryLower.z ? p_in : _VolumePressure[worldIdx - worldIdxStrideZ];

  #if VOLUME_STAGGERED_GRID
	const float p_xp = p_in;
	const float p_yp = p_in;
	const float p_zp = p_in;
  #else
	const float p_xp = isBoundaryUpper.x ? p_in : _VolumePressure[worldIdx + worldIdxStrideX];
	const float p_yp = isBoundaryUpper.y ? p_in : _VolumePressure[worldIdx + worldIdxStrideY];
	const float p_zp = isBoundaryUpper.z ? p_in : _VolumePressure[worldIdx + worldIdxStrideZ];
  #endif
#endif
	
#if VOLUME_SQUARE_CELLS
  #if VOLUME_STAGGERED_GRID
	const float h = 1.0 * VolumeWorldCellSize(lodGrid).x;
  #else
	const float h = 2.0 * VolumeWorldCellSize(lodGrid).x;
  #endif
#else
	const float3 h = 2.0 * VolumeWorldCellSize(lodGrid).xyz;
#endif

	const float3 diff = float3(
		p_xp - p_xm,
		p_yp - p_ym,
		p_zp - p_zm) / h;

	_VolumePressureGrad[worldIdx] = diff;
}

#endif//F_PRESSURE

//--------------------
// kernels scattering

#if F_SCATTERING

RWTexture3D<float> _VolumeDensityComp;
Texture3D<float> _VolumeDensityPreComp;

[numthreads(THREAD_GROUP_SIZE_XY, THREAD_GROUP_SIZE_XY, 1)]
void KVolumeScatteringPrep(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	if (BoundaryDistance(VolumeIndexToWorld(lodGrid, worldIdx)) < _ScatteringProbeOccluderMargin * lodGrid.volumeCellRadius)
	{
		_VolumeDensityComp[worldIdx] = _VolumeDensity[worldIdx] + _ScatteringProbeOccluderDensity;
	}
	else
	{
		_VolumeDensityComp[worldIdx] = _VolumeDensity[worldIdx];
	}
}

[numthreads(THREAD_GROUP_SIZE_XY, THREAD_GROUP_SIZE_XY, 1)]
void KVolumeScattering(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	const float rho = _VolumeDensityPreComp[worldIdx];

	// early out in empty cells
	if (rho == 0.0)
	{
		return;
	}

#if 1
	_VolumeScattering[worldIdx] = ProjectStrandCountSH_L0L1(lodGrid, VolumeIndexToWorld(lodGrid, worldIdx));
#else
	float coefficients[4];
	ProjectStrandCountSH(lodGrid, worldIdx, coefficients);
	_VolumeScattering[worldIdx] = float4(
		coefficients[0],
		coefficients[1],
		coefficients[2],
		coefficients[3]);
#endif
}

#endif//F_SCATTERING

//--------------
// kernels wind

#if F_WIND

RWTexture3D<float> _VolumeDensityComp;
Texture3D<float> _VolumeDensityPreComp;

[numthreads(THREAD_GROUP_SIZE_XY, THREAD_GROUP_SIZE_XY, 1)]
void KVolumeWindPrep(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	if (BoundaryDistance(VolumeIndexToWorld(lodGrid, worldIdx)) < _WindPropagationOccluderMargin * lodGrid.volumeCellRadius)
	{
		_VolumeDensityComp[worldIdx] = _VolumeDensity[worldIdx] + _WindPropagationOccluderDensity;
	}
	else
	{
		_VolumeDensityComp[worldIdx] = _VolumeDensity[worldIdx];
	}
}

float SphericalCellCrossSectionRadiusCubed(float V)
{
	float rrr = (3.0 * abs(V)) / (4.0 * 3.14159);
	return rrr;
}

float SphericalCellCrossSectionRadius(float V)
{
	float rrr = SphericalCellCrossSectionRadiusCubed(V);
	float r = pow(rrr, 1.0 / 3.0);
	return r;
}

float SphericalCellCrossSection(float V)
{
	float rrr = SphericalCellCrossSectionRadiusCubed(V);
	float rr = pow(rrr, 2.0 / 3.0);
	float A = PI * rr;
	return A;
}

float ValueNoise(const float2 x)
{
	float2 i = floor(x);
	float2 f = frac(x);

	f = f * f * (3.0 - 2.0 * f);

	uint2 j = uint2(int2(i));
	float a00 = JenkinsHash(j + uint2(0, 0));
	float a10 = JenkinsHash(j + uint2(1, 0));
	float a01 = JenkinsHash(j + uint2(0, 1));
	float a11 = JenkinsHash(j + uint2(1, 1));
	float b0 = lerp(a00, a10, f.x);
	float b1 = lerp(a01, a11, f.x);

	return lerp(b0, b1, f.y) / (float)UINT_MAX;
}

float ValueNoise(const float3 x)
{
	float3 i = floor(x);
	float3 f = frac(x);

	f = f * f * (3.0 - 2.0 * f);

	uint3 j = uint3(int3(i));
	float a000 = JenkinsHash(j + uint3(0, 0, 0));
	float a100 = JenkinsHash(j + uint3(1, 0, 0));
	float a010 = JenkinsHash(j + uint3(0, 1, 0));
	float a110 = JenkinsHash(j + uint3(1, 1, 0));
	float a001 = JenkinsHash(j + uint3(0, 0, 1));
	float a101 = JenkinsHash(j + uint3(1, 0, 1));
	float a011 = JenkinsHash(j + uint3(0, 1, 1));
	float a111 = JenkinsHash(j + uint3(1, 1, 1));
	float b00 = lerp(a000, a100, f.x);
	float b10 = lerp(a010, a110, f.x);
	float b01 = lerp(a001, a101, f.x);
	float b11 = lerp(a011, a111, f.x);
	float c0 = lerp(b00, b10, f.y);
	float c1 = lerp(b01, b11, f.y);

	return lerp(c0, c1, f.z) / (float)UINT_MAX;
}

float ValueNoiseFractal(float2 x, const uint octaves = 3, const float persistence = 0.5)
{
	float v = 0.0;
	float s = 0.0;
	float a = 1.0;

	for (uint k = 0; k != octaves; k++)
	{
		v += a * ValueNoise(x);
		s += a;

		x *= 2.0;
		a *= persistence;
	}

	return v / max(1.0, s);
}

float ValueNoiseFractal(float3 x, const uint octaves = 3, const float persistence = 0.5)
{
	float v = 0.0;
	float s = 0.0;
	float a = 1.0;

	for (uint k = 0; k != octaves; k++)
	{
		v += a * ValueNoise(x);
		s += a;

		x *= 2.0;
		a *= persistence;
	}

	return v / max(1.0, s);
}

//#define ABSORB(x) SphericalCellCrossSection(x)
#define ABSORB(x) pow(abs(x), 2.0 / 3.0)

float WindTransmittanceSegment(const VolumeLODGrid lodGrid, const float3 p, const float3 n, const float nd)
{
	float T = 1.0;
	///*
	{
		VolumeTraceState trace = VolumeTraceBegin(lodGrid, p, n, 1.0, _WindPropagationSubsteps);

		float S = length(VolumeWorldCellStep(lodGrid, n)) / _WindPropagationSubsteps;
		float R = nd - (S * _WindPropagationSubsteps);// == remaining trace distance to emitter
		float k = _WindPropagationExtinction * S;

		if ((_VolumeFeatures & VOLUMEFEATURES_WIND_FASTPATH) != 0)
		{
			while (T > 1e-5 && R >= 0.0 && VolumeTraceStep(trace))
			{
				T *= exp(-ABSORB(VolumeSampleScalar(_VolumeDensity, trace.uvw)) * k);
				R -= S;
			}
		}
		else
		{
			while (T > 1e-5 && R >= 0.0 && VolumeTraceStep(trace))
			{
				if (BoundaryDistance(VolumeUVWToWorld(lodGrid, trace.uvw)) < _WindPropagationOccluderMargin * lodGrid.volumeCellRadius)
				{
					T = 0.0;
				}
				else
				{
					T *= exp(-ABSORB(VolumeSampleScalar(_VolumeDensity, trace.uvw)) * k);
					R -= S;
				}
			}
		}

		//TODO handle boundaries outside the discrete volume?
		//if (R > 0.0 && VolumeTraceEnded(trace))
		//{
		//	// need to compute distance to closest solid along emitter ray
		//	//	- march sdf within conservative total bounds?
		//	//	- add ray-primitive intersection?
		//	if (BoundaryIntersection(VolumeUVWToWorld(trace.uvw, -n))
		//	{
		//		T = 0.0;
		//	}
		//}
	}
	//*/
	return T;
}

float WindTransmittanceBackground(const VolumeLODGrid lodGrid, const float3 p, const float3 n)
{
	float T = 1.0;
	///*
	{
		VolumeTraceState trace = VolumeTraceBegin(lodGrid, p, n, 1.0, _WindPropagationSubsteps);

		float S = length(VolumeWorldCellStep(lodGrid, n)) / _WindPropagationSubsteps;
		float A = 1.0;
		float k = _WindPropagationExtinction * S;
		
		if ((_VolumeFeatures & VOLUMEFEATURES_WIND_FASTPATH) != 0)
		{
			while (T > 1e-5 && A > 0.0 && VolumeTraceStep(trace))
			{
				A = ABSORB(VolumeSampleScalar(_VolumeDensity, trace.uvw));
				T *= exp(-A * k);
			}
		}
		else
		{
			while (T > 1e-5 && A > 0.0 && VolumeTraceStep(trace))
			{
				if (BoundaryDistance(VolumeUVWToWorld(lodGrid, trace.uvw)) < _WindPropagationOccluderMargin * lodGrid.volumeCellRadius)
				{
					T = 0.0;
				}
				else
				{
					A = ABSORB(VolumeSampleScalar(_VolumeDensity, trace.uvw));
					T *= exp(-A * k);
				}
			}
		}
	}
	//*/
	return T;
}

float3 WindDragImpulse(const float3 v, const float3 v0, const float k)
{
	float3 u = v - v0;
	float ud = length(u);
	
	// note: drag force
	// Fd = 0.5 rho |u|^2 Cd A
	//    = 0.5 rho u |u| Cd A

	return 0.5 * (u * ud) * k;
}

[numthreads(THREAD_GROUP_SIZE_XY, THREAD_GROUP_SIZE_XY, 1)]
void KVolumeWind(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

	const float rho = _VolumeDensityPreComp[worldIdx];

	// early out in empty cells
	if (rho == 0.0)
	{
		return;
	}

	// compute absorption factor (surface area) of current cell
	float A = ABSORB(saturate(0.1 + rho));

	// compute position of current cell
	float3 p = VolumeIndexToWorld(lodGrid, worldIdx);

	// load velocity in current cell
	float3 v0 = _VolumeVelocity[worldIdx].xyz;

	// since we don't have an active flow field for the wind, we accumulate
	// and average a drag impulse based on the transmitted relative flow of
	// all active emitters, as well as the transmitted relative flow of a
	// zero-flow background ahead of the current cell.
	float4 Lsum = float4(0.0, 0.0, 0.0, 0.0);
	{
		// add impulses from active emitters
		for (uint i = 0; i != _WindEmitterCount; i++)
		{
			const WindEmitter wind = _WindEmitter[i];

			float3 r = p - wind.p;

			float t = dot(wind.n, r);
			float h = wind.m * (t - wind.t0) + wind.h0;

			float3 a = r - wind.n * t;
			float bb = dot(a, a);

			// consider emitter if cell center is inside emitter volume
			//TODO handle partial overlap?
			if (isinf(wind.h0) || (t >= wind.t0 && bb <= h * h))
			{
				// compute trace direction and distance from emitter base
				float3 n = (wind.m == 0.0) ? wind.n : normalize(r) * (t < 0.0 ? -1.0 : 1.0);
				float nd = dot(n, r) * (1.0 - wind.t0 / (t + 1e-5));

				// compute transmittance from current cell to emitter base
				float T = WindTransmittanceSegment(lodGrid, p, -n, nd);

				// compute unobstructed attenuated flow
				float3 v;
				{
					// note: various approaches to attenuation
					//
					//	Ka: inf at x=0
					//		Ka(x,t) => 1 / x^2
					//
					//	Kb: inf at x=0, one at x=-t, x=t
					//		Kb(x,t) => 1 / (x/t)^2
					//		Kb(x,t) => t^2 / x^2
					//
					//	Kc: h at x=0, one at x=-t, x=t
					//		Kc(x,t,h) => (t^2 + (t^2 + e) / (h - 1 + e)) / (x^2 + (t^2 + e) / (h - 1 + e))
					//
					//	Kd: |t|+1 at x=0, one at x=-t, x=t
					//		Kd(x,t) => (t^2 + (t^2 + e) / (|t| + e)) / (x^2 + (t^2 + e) / (|t| + e))
					//		Kd(x,t) => (t^2 * (|t| + e) + t^2 + e) / (x^2 * (|t| + e) + t^2 + e)
					//
					//	Ke: |t|^2+1 at x=0, one at x=-t, x=t
					//		Ke(x,t) => (t^2 * (|t| + e) + |t| + e) / (x^2 * (|t| + e) + |t| + e)
					//		Ke(x,t) => (t^2 + 1) / (x^2 + 1)
					//
					//	Kf: [1..h] at x=0, one at x=-t, x=t
					//		Kf(x,t,h) => (t^2 + (t^2 + 1) / (h - 1 + e)) / (x^2 + (t^2 + 1) / (h - 1 + e))
					//		Kf(x,t,h) => (e * t^2 + t^2 * h + 1) / (x^2 * (h - 1 + e) + t^2 + 1)
					//		Kf(x,t,h) => (t^2 * h + 1) / (x^2 * (h - 1) + t^2 + 1)
					//
					//	Kg: TODO half at x=-s, x=s, one at x=-1, x=t
	
					float va = (wind.m == 0.0) ? 1.0 : (wind.t0 * wind.t0 * 2.0f + 1.0f) / (nd * nd * (2.0f - 1.0f) + wind.t0 * wind.t0 + 1.0f);// (using Kf)
					float vd = isinf(wind.h0) ? dot(r, n) : nd;
					float vt = vd / (wind.v + wind.A);
					float vc = wind.f * (vt - _WindEmitterClock);

					if (wind.jd > 0.0)
					{
						if (isinf(wind.m))// spherical emitter
							vc += wind.jd * (ValueNoiseFractal(wind.jw * (p - wind.jp * n * (vd - 0.5))) * 2.0 - 1.0);
						else
							vc += wind.jd * (ValueNoiseFractal(wind.jw * (p - wind.jp * n * vd)) * 2.0 - 1.0);
					}

					float vf = wind.v + wind.A * (0.5 * cos(2.0 * PI * vc) + 0.5);
					
					v = (va * vf) * n;
				}

				// compute drag impulse
				float3 L = WindDragImpulse(v, v0, saturate(T / A));
				float Lw = length(L);
				if (Lw > 0.0)
				{
					Lsum.xyz += Lw * L;
					Lsum.w += Lw;
				}
			}
		}

		// add impulse from zero-flow background
		{
			// consider background if cell velocity is non-zero
			float v0dd = dot(v0, v0);
			if (v0dd > 0.0)
			{
				// compute transmittance from current cell to background
				float T = WindTransmittanceBackground(lodGrid, p, v0 * rsqrt(v0dd));
			
				// compute drag impulse
				float3 L = WindDragImpulse(0.0, v0, saturate(T / A));
				float Lw = length(L);
				if (Lw > 0.0)
				{
					Lsum.xyz += Lw * L;
					Lsum.w += Lw;
				}
			}
		}
	}
	
	// apply weighted average
	if (Lsum.w > 0.0)
	{
		_VolumeImpulse[worldIdx].xyz = (Lsum.xyz / Lsum.w) * (_VolumeDT);
	}
	else
	{
		_VolumeImpulse[worldIdx].xyz = 0.0;
	}
}

#endif//F_WIND

//----------------
// kernels bounds

#if F_BOUNDS

uint FloatToUnsignedSortable(uint x)
{
	// see: http://stereopsis.com/radix.html
	// see: https://lemire.me/blog/2020/12/14/converting-floating-point-numbers-to-integers-while-preserving-order/
	uint mask = asuint(asint(x) >> 31) | 0x80000000u;
	return x ^ mask;
}

uint3 FloatToUnsignedSortable(uint3 x)
{
	return uint3(
		FloatToUnsignedSortable(x.x),
		FloatToUnsignedSortable(x.y),
		FloatToUnsignedSortable(x.z));
}

uint UnsignedSortableToFloat(uint x)
{
	// see: http://stereopsis.com/radix.html
	// see: https://lemire.me/blog/2020/12/14/converting-floating-point-numbers-to-integers-while-preserving-order/
	uint mask = ((x >> 31) - 1) | 0x80000000u;
	return x ^ mask;
}

uint3 UnsignedSortableToFloat(uint3 x)
{
	return uint3(
		UnsignedSortableToFloat(x.x),
		UnsignedSortableToFloat(x.y),
		UnsignedSortableToFloat(x.z));
}

groupshared uint3 gs_minMaxU[2];

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KBoundsClear(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_BOUNDS(worldIdx.x);

	_BoundsMinMaxU[2 * boundsIndex + 0] = 0xFFFFFFFFu;
	_BoundsMinMaxU[2 * boundsIndex + 1] = 0x00000000u;
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KBoundsGather(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND_UNCHECKED(worldIdx.x);

	if (threadIdx == 0)
	{
		gs_minMaxU[0] = 0xFFFFFFFFu;
		gs_minMaxU[1] = 0x00000000u;
	}

	uint3 rootMinU;
	uint3 rootMaxU;

	if (CHECK_STRAND(strandIndex))
	{
		float3 rootPos = _RootPositionNext[strandIndex].xyz;
		float3 rootExt = _GroupBoundsPadding * max(
			_GroupMaxParticleInterval * (_StrandParticleCount - 1),
			_GroupMaxParticleDiameter * 0.5
		);

		rootMinU = FloatToUnsignedSortable(asuint(rootPos - rootExt));
		rootMaxU = FloatToUnsignedSortable(asuint(rootPos + rootExt));
	}
	else
	{
		rootMinU = 0xFFFFFFFFu;
		rootMaxU = 0x00000000u;
	}

	GroupMemoryBarrierWithGroupSync();

	InterlockedMin(gs_minMaxU[0].x, rootMinU.x);
	InterlockedMin(gs_minMaxU[0].y, rootMinU.y);
	InterlockedMin(gs_minMaxU[0].z, rootMinU.z);
	InterlockedMax(gs_minMaxU[1].x, rootMaxU.x);
	InterlockedMax(gs_minMaxU[1].y, rootMaxU.y);
	InterlockedMax(gs_minMaxU[1].z, rootMaxU.z);
	
	GroupMemoryBarrierWithGroupSync();

	if (threadIdx == 0)
	{
		InterlockedMin(_BoundsMinMaxU[2 * _GroupBoundsIndex + 0].x, gs_minMaxU[0].x);
		InterlockedMin(_BoundsMinMaxU[2 * _GroupBoundsIndex + 0].y, gs_minMaxU[0].y);
		InterlockedMin(_BoundsMinMaxU[2 * _GroupBoundsIndex + 0].z, gs_minMaxU[0].z);

		InterlockedMax(_BoundsMinMaxU[2 * _GroupBoundsIndex + 1].x, gs_minMaxU[1].x);
		InterlockedMax(_BoundsMinMaxU[2 * _GroupBoundsIndex + 1].y, gs_minMaxU[1].y);
		InterlockedMax(_BoundsMinMaxU[2 * _GroupBoundsIndex + 1].z, gs_minMaxU[1].z);
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KBoundsResolve(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_BOUNDS_GROUP(worldIdx.x);

	uint3 boundsMinU = _BoundsMinMaxU[2 * boundsIndex + 0];
	uint3 boundsMaxU = _BoundsMinMaxU[2 * boundsIndex + 1];

	InterlockedMin(_BoundsMinMaxU[2 * _CombinedBoundsIndex + 0].x, boundsMinU.x);
	InterlockedMin(_BoundsMinMaxU[2 * _CombinedBoundsIndex + 0].y, boundsMinU.y);
	InterlockedMin(_BoundsMinMaxU[2 * _CombinedBoundsIndex + 0].z, boundsMinU.z);

	InterlockedMax(_BoundsMinMaxU[2 * _CombinedBoundsIndex + 1].x, boundsMaxU.x);
	InterlockedMax(_BoundsMinMaxU[2 * _CombinedBoundsIndex + 1].y, boundsMaxU.y);
	InterlockedMax(_BoundsMinMaxU[2 * _CombinedBoundsIndex + 1].z, boundsMaxU.z);

	float3 boundsMin = asfloat(UnsignedSortableToFloat(boundsMinU));
	float3 boundsMax = asfloat(UnsignedSortableToFloat(boundsMaxU));

	LODBounds lodBounds;
	{
		lodBounds.center = 0.5 * (boundsMax + boundsMin);
		lodBounds.extent = 0.5 * (boundsMax - boundsMin);
		lodBounds.radius = length(lodBounds.extent);
		lodBounds.reach = min(lodBounds.extent.x, min(lodBounds.extent.y, lodBounds.extent.z));
	}

	_Bounds[boundsIndex] = lodBounds;
}

[numthreads(1, 1, 1)]
void KBoundsResolveCombined(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_BOUNDS(_CombinedBoundsIndex);

	uint3 combinedBoundsMinU = _BoundsMinMaxU[2 * boundsIndex + 0];
	uint3 combinedBoundsMaxU = _BoundsMinMaxU[2 * boundsIndex + 1];

	float3 combinedBoundsMin = asfloat(UnsignedSortableToFloat(combinedBoundsMinU));
	float3 combinedBoundsMax = asfloat(UnsignedSortableToFloat(combinedBoundsMaxU));

	LODBounds lodBounds;
	{
		lodBounds.center = 0.5 * (combinedBoundsMax + combinedBoundsMin);
		lodBounds.extent = 0.5 * (combinedBoundsMax - combinedBoundsMin);
		lodBounds.radius = length(lodBounds.extent);
		lodBounds.reach = min(lodBounds.extent.x, min(lodBounds.extent.y, lodBounds.extent.z));
	}

	_Bounds[boundsIndex] = lodBounds;
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KBoundsHistory(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_BOUNDS(worldIdx.x);

	_BoundsPrev[boundsIndex] = _Bounds[boundsIndex];
}

//TODO use y-dim for frustums..
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KBoundsCoverage(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_BOUNDS(worldIdx.x);

	//TODO use y-dim for frustums..
	_BoundsCoverage[boundsIndex] = LODFrustumCoverageCeilingSequential(_Bounds[boundsIndex], _BoundsGeometry[boundsIndex]);
}

#endif//F_BOUNDS

//-------------
// kernels lod

#if F_LOD

#define DISPATCH_THREAD_GROUP_SIZE_X 8
#define DISPATCH_THREAD_GROUP_SIZE_Y 8
#define DISPATCH_THREAD_GROUP_SIZE_Z 1

uint4 ResolveDispatchParallelCells(uint3 cellCount)
{
	// returns data necessary for indirect dispatch + associated cell count
	// (thread groups x, thread groups y, thread groups z, associated cell count)
	uint numX = (cellCount.x + DISPATCH_THREAD_GROUP_SIZE_X - 1) / DISPATCH_THREAD_GROUP_SIZE_X;
	uint numY = (cellCount.y + DISPATCH_THREAD_GROUP_SIZE_Y - 1) / DISPATCH_THREAD_GROUP_SIZE_Y;
	uint numZ = (cellCount.z + DISPATCH_THREAD_GROUP_SIZE_Z - 1) / DISPATCH_THREAD_GROUP_SIZE_Z;
	return uint4(numX, numY, numZ, cellCount.x * cellCount.y * cellCount.z);
}

uint4 ResolveDrawParallelCells(uint3 cellCount, uint cellVertexCount)
{
	// returns data necessary for indirect draw
	// (vertex count per instance, instance count, start vertex location, and start instance location)
	return uint4(cellCount.x * cellCount.y * cellCount.z * cellVertexCount, 1, 0, 0);
}

void WriteIndirectDispatch(uint index, uint4 args)
{
	_VolumeLODDispatch[index * 4 + 0] = args.x;
	_VolumeLODDispatch[index * 4 + 1] = args.y;
	_VolumeLODDispatch[index * 4 + 2] = args.z;
	_VolumeLODDispatch[index * 4 + 3] = args.w;
}

[numthreads(1, 1, 1)]
void KLODSelection(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	// update lod grid
	LODBounds bounds = _Bounds[_CombinedBoundsIndex];

	float gridExtent = max(bounds.extent.x, max(bounds.extent.y, bounds.extent.z));
	float3 gridMin = bounds.center - gridExtent;
	float3 gridMax = bounds.center + gridExtent;

	VolumeLODGrid lodGrid;
	{
		lodGrid.volumeWorldMin = gridMin;
		lodGrid.volumeWorldMax = gridMax;
		lodGrid.volumeCellCount = _GridResolution.xxx;
		lodGrid.volumeCellRadius = length(gridExtent) / _GridResolution;
	}

	_VolumeLODStage[VOLUMELODSTAGE_RESOLVE] = lodGrid;

	// update lod dispatch
	WriteIndirectDispatch(VOLUMELODDISPATCH_RESOLVE,		ResolveDispatchParallelCells(lodGrid.volumeCellCount));
	WriteIndirectDispatch(VOLUMELODDISPATCH_RASTER_POINTS,	ResolveDrawParallelCells(lodGrid.volumeCellCount, 1));
	WriteIndirectDispatch(VOLUMELODDISPATCH_RASTER_VECTORS,	ResolveDrawParallelCells(lodGrid.volumeCellCount, 2));
}

#endif//F_LOD

//--------------------
// kernels boundaries

#if F_BOUNDARIES

float3x3 AffineInterpolateUpper3x3(float3x3 A, float4 q, float t)
{
	// A = QR
	// Q^-1 A = R

	float3x3 Q_inv = QMat3x3(QConjugate(q));
	float3x3 R = mul(Q_inv, A);
	float3x3 I = float3x3(
		1.0, 0.0, 0.0,
		0.0, 1.0, 0.0,
		0.0, 0.0, 1.0);

	float3x3 Q_t = QMat3x3(QSlerp(MakeQuaternionIdentity(), q, t));
	float3x3 R_t = lerp(I, R, t);
	float3x3 A_t = mul(Q_t, R_t);

	return A_t;
}

float3x4 AffineInterpolate3x4(float3x4 M, float4 q, float t)
{
	// M = | A T |

	float3x3 A_t = AffineInterpolateUpper3x3((float3x3)M, q, t);
	float3 T_t = M._m03_m13_m23 * t;

	return float3x4(
		A_t._m00, A_t._m01, A_t._m02, T_t.x,
		A_t._m10, A_t._m11, A_t._m12, T_t.y,
		A_t._m20, A_t._m21, A_t._m22, T_t.z);
}

float4x4 AffineInterpolate4x4(float4x4 M, float4 q, float t)
{
	// M = | A T |
	//     | 0 1 |
	
	float3x3 A_t = AffineInterpolateUpper3x3((float3x3)M, q, t);
	float3 T_t = M._m03_m13_m23 * t;

	return float4x4(
		A_t._m00, A_t._m01, A_t._m02, T_t.x,
		A_t._m10, A_t._m11, A_t._m12, T_t.y,
		A_t._m20, A_t._m21, A_t._m22, T_t.z,
		0.0, 0.0, 0.0, 1.0);
}

float3x3 AffineInverseUpper3x3(float3x3 A)
{
	float3 c0 = A._m00_m10_m20;
	float3 c1 = A._m01_m11_m21;
	float3 c2 = A._m02_m12_m22;
	
	float3 cp0x1 = cross(c0, c1);
	float3 cp1x2 = cross(c1, c2);
	float3 cp2x0 = cross(c2, c0);

	return float3x3(cp1x2, cp2x0, cp0x1) / dot(c0, cp1x2);
}

float4x4 AffineInverse4x4(float4x4 M)
{
	// | A T |
	// | 0 1 |

	float3x3 A_inv = AffineInverseUpper3x3((float3x3)M);
	float3 T_inv = -mul(A_inv, M._m03_m13_m23);

	return float4x4(
		A_inv._m00, A_inv._m01, A_inv._m02, T_inv.x,
		A_inv._m10, A_inv._m11, A_inv._m12, T_inv.y,
		A_inv._m20, A_inv._m21, A_inv._m22, T_inv.z,
		0.0, 0.0, 0.0, 1.0);
}

float3x4 AffineMul3x4(float3x4 Ma, float3x4 Mb)
{
	// Ma x Mb  =  | A Ta |  x  | B Tb |
	//             | 0 1  |     | 0 1  |
	//
	//          =  | mul(A,B)  mul(A,Tb)+Ta |
	//             | 0         1            |

	float3x3 A = (float3x3)Ma;
	float3x3 B = (float3x3)Mb;

	float3x3 AB = mul(A, B);
	float3 ATb = mul(A, Mb._m03_m13_m23);
	float3 Ta = Ma._m03_m13_m23;

	return float3x4(
		AB._m00, AB._m01, AB._m02, ATb.x + Ta.x,
		AB._m10, AB._m11, AB._m12, ATb.y + Ta.y,
		AB._m20, AB._m21, AB._m22, ATb.z + Ta.z);
}

float4x4 AffineMul4x4(float4x4 Ma, float4x4 Mb)
{
	return mul(Ma, Mb);
}

float _SubstepFractionLo;
float _SubstepFractionHi;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KBoundariesAdvance(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	uint i = worldIdx.x;
	if (i >= MAX_BOUNDARIES)
		return;

	int j = _BoundaryShapePrevLUT[i];
	if (j == -1)
		_BoundaryShapePrev[i] = _BoundaryShapeNext[i];
	else
		_BoundaryShapePrev[i] = _BoundaryShape[j];
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KBoundariesSubstep(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	uint i = worldIdx.x;
	if (i >= MAX_BOUNDARIES)
		return;

	// compute substep boundary transform
	{
		// Ma * M = Mb
		// M = Ma^-1 * Mb
		// ..
		// Mb_t = Ma * M(t)
		//
		// where Ma is the transform of the current frame
		//   and Mb is the transform of the last substep of the previous frame

		float4x4 Ma = _BoundaryMatrixNext[i];
		float4x4 M = _BoundaryMatrixPrevA[i];
		float4 q = _BoundaryMatrixPrevQ[i];

		float4x4 M_t = AffineInterpolate4x4(M, q, 1.0 - _SubstepFractionHi);
		float4x4 M_t_prev = AffineInterpolate4x4(M, q, 1.0 - _SubstepFractionLo);

		float4x4 Mb_t = AffineMul4x4(Ma, M_t);
		float4x4 Mb_t_prev = AffineMul4x4(Ma, M_t_prev);

		float4x4 Mb_t_inv = AffineInverse4x4(Mb_t);
		float4x4 Mb_t_inv_step = AffineMul4x4(Mb_t_prev, Mb_t_inv);

		_BoundaryMatrix[i] = Mb_t;
		_BoundaryMatrixInv[i] = Mb_t_inv;
		_BoundaryMatrixInvStep[i] = Mb_t_inv_step;
	}

	// compute substep boundary shape
	{
		float t = _SubstepFractionHi;

		BoundaryShape g0 = _BoundaryShapePrev[i];
		BoundaryShape g1 = _BoundaryShapeNext[i];
		BoundaryShape gt = g1;

		// shapes blend differently depending on type
		{
			// shape    |  float3     float      float3     float
			// -------------------------------------------------------
			// discrete |  __pad      __pad      __pad      __pad
			// capsule  |  centerA    radius     centerB    __pad
			// sphere   |  center     radius     __pad      __pad
			// torus    |  center     radiusA    axis       radiusB
			// cube     |  center     rotf16x    extent     rotf16y
		}
		if (i < _BoundaryDelimDiscrete)
		{
			//          :
			// discrete |  __pad      __pad      __pad      __pad
		}
		else if (i < _BoundaryDelimSphere)
		{
			//          :
			// capsule  |  centerA    radius     centerB    __pad
			// sphere   |  center     radius     __pad      __pad
			gt.pA = lerp(g0.pA, g1.pA, t);
			gt.tA = lerp(g0.tA, g1.tA, t);
			gt.pB = lerp(g0.pB, g1.pB, t);
		}
		else if (i < _BoundaryDelimTorus)
		{
			//          :
			// torus    |  center     radiusA    axis       radiusB
			gt.pA = lerp(g0.pA, g1.pA, t);
			gt.tA = lerp(g0.tA, g1.tA, t);
			gt.pB = QMul(QSlerp(MakeQuaternionIdentity(), MakeQuaternionFromTo(g0.pB, g1.pB), t), g0.pB);
			gt.tB = lerp(g0.tB, g1.tB, t);
		}
		else if (i < _BoundaryDelimCube)
		{
			//          :
			// cube     |  center     rotf16x    extent     rotf16y
#if BOUNDARIES_OPT_PACK_CUBE
			float4 q0 = QDecode16(asuint(float2(g0.tA, g0.tB)));
			float4 q1 = QDecode16(asuint(float2(g1.tA, g1.tB)));
			uint2 qt16 = QEncode16(QSlerp(q0, q1, t));
			gt.pA = lerp(g0.pA, g1.pA, t);
			gt.tA = asfloat(qt16.x);
			gt.pB = lerp(g0.pB, g1.pB, t);
			gt.tB = asfloat(qt16.y);
#else
			gt.pA = lerp(g0.pA, g1.pA, t);
			gt.pB = lerp(g0.pB, g1.pB, t);
#endif
		}

		_BoundaryShape[i] = gt;
	}
}

#endif//F_BOUNDARIES

//------------------
// kernels emitters

#if F_EMITTERS

float _SubstepFractionLo;
float _SubstepFractionHi;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KEmittersAdvance(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	uint i = worldIdx.x;
	if (i >= MAX_EMITTERS)
		return;

	int j = _WindEmitterPrevLUT[i];
	if (j == -1)
		_WindEmitterPrev[i] = _WindEmitterNext[i];
	else
		_WindEmitterPrev[i] = _WindEmitter[j];
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KEmittersSubstep(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	uint i = worldIdx.x;
	if (i >= MAX_EMITTERS)
		return;

	// compute substep wind emitter
	{
		float t = _SubstepFractionHi;

		WindEmitter g0 = _WindEmitterPrev[i];
		WindEmitter g1 = _WindEmitterNext[i];
		WindEmitter gt = g1;

#if 0
		#define slerp(n0, n1, t) QMul(QSlerp(MakeQuaternionIdentity(), MakeQuaternionFromTo(n0, n1), t), n0)
		#define DECLARE_BLEND(ATTR, FN) gt.ATTR = FN(g0.ATTR, g1.ATTR, t);
		{
			DECLARE_BLEND(p, lerp)
			DECLARE_BLEND(n, slerp)
		
			DECLARE_BLEND(t0, lerp)
			DECLARE_BLEND(h0, lerp)
			DECLARE_BLEND(m, lerp)
			
			DECLARE_BLEND(v, lerp)
			DECLARE_BLEND(A, lerp)
			DECLARE_BLEND(f, lerp)

			DECLARE_BLEND(jd, lerp)
			DECLARE_BLEND(jw, lerp)
			DECLARE_BLEND(jp, lerp)
		}
#else
		gt.p = lerp(g0.p, g1.p, t);
		gt.n = QMul(QSlerp(MakeQuaternionIdentity(), MakeQuaternionFromTo(g0.n, g1.n), t), g0.n);
		
		gt.t0 = lerp(g0.t0, g1.t0, t);
		gt.h0 = lerp(g0.h0, g1.h0, t);
		gt.m = lerp(g0.m, g1.m, t);

		gt.v = lerp(g0.v, g1.v, t);
		gt.A = lerp(g0.A, g1.A, t);
		gt.f = lerp(g0.f, g1.f, t);
		
		gt.jd = lerp(g0.jd, g1.jd, t);
		gt.jw = lerp(g0.jw, g1.jw, t);
		gt.jp = lerp(g0.jp, g1.jp, t);
#endif

		if (isnan(gt.h0) || isinf(gt.h0)) gt.h0 = g1.h0;
		if (isnan(gt.m) || isinf(gt.m)) gt.m = g1.m;
		
		_WindEmitter[i] = gt;
	}
}

#endif//F_EMITTERS

```

`Runtime/HairSimComputeVolume.compute.meta`:

```meta
fileFormatVersion: 2
guid: 6936d281b1638924b97a8733f5ce8974
ComputeShaderImporter:
  externalObjects: {}
  currentAPIMask: 4
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimComputeVolumeProbe.hlsl`:

```hlsl
#ifndef __HAIRSIMCOMPUTEVOLUMEPROBE_HLSL__
#define __HAIRSIMCOMPUTEVOLUMEPROBE_HLSL__

#define HALF_SQRT_INV_PI    0.5 * 0.56418958354775628694 
#define HALF_SQRT_3_DIV_PI  0.5 * 0.97720502380583984317

// Transforms the unit vector from the spherical to the Cartesian (right-handed, Z up) coordinate.
real3 SphericalToCartesian(real cosPhi, real sinPhi, real cosTheta)
{
	real sinTheta = SinFromCos(cosTheta);

	return real3(real2(cosPhi, sinPhi) * sinTheta, cosTheta);
}

real3 SphericalToCartesian(real phi, real cosTheta)
{
	real sinPhi, cosPhi;
	sincos(phi, sinPhi, cosPhi);

	return SphericalToCartesian(cosPhi, sinPhi, cosTheta);
}

float EstimateStrandCount(const VolumeLODGrid lodGrid, float3 P, float3 L)
{
	float rho_sum = 0;

	VolumeTraceState trace = VolumeTraceBegin(lodGrid, P, L, 0, _ScatteringProbeSubsteps);

	if ((_VolumeFeatures & VOLUMEFEATURES_SCATTERING_FASTPATH) != 0)
	{
		while (VolumeTraceStep(trace))
		{
			rho_sum += VolumeSampleScalar(_VolumeDensity, trace.uvw);
		}
	}
	else
	{
		while (VolumeTraceStep(trace))
		{
			if (BoundaryDistance(VolumeUVWToWorld(lodGrid, trace.uvw)) < _ScatteringProbeOccluderMargin * lodGrid.volumeCellRadius)
			{
				rho_sum += VolumeSampleScalar(_VolumeDensity, trace.uvw) + _ScatteringProbeOccluderDensity;
			}
			else
			{
				rho_sum += VolumeSampleScalar(_VolumeDensity, trace.uvw);
			}
		}
	}
		
	const float stepLength = length(VolumeWorldSize(lodGrid) * trace.uvwStep);
	const float stepCapacity = max(0.0, stepLength / _ScatteringProbeUnitWidth);

	return (rho_sum * stepCapacity);
}

float EstimateSH(int l, int m, float3 L)
{
	const float x = L.x;
	const float y = L.y;
	const float z = L.z;

	// Evaluate the SH basis function given l and m
	if (l == 0 && m ==  0) return HALF_SQRT_INV_PI;
	if (l == 1 && m == -1) return HALF_SQRT_3_DIV_PI * y;
	if (l == 1 && m ==  0) return HALF_SQRT_3_DIV_PI * z;
	if (l == 1 && m == +1) return HALF_SQRT_3_DIV_PI * x;

	return -1;
}

float EncodeSHCoefficient(const VolumeLODGrid lodGrid, float3 P, int l, int m)
{
	const int SAMPLES_PHI = _ScatteringProbeSamplesPhi;
	const int SAMPLES_THETA = _ScatteringProbeSamplesTheta;

	const float dPhi = TWO_PI / SAMPLES_PHI;// step yaw
	const float dTheta = PI / SAMPLES_THETA;// step pitch

	float C = 0;

	for (int i = 0; i < SAMPLES_PHI; i++)
	{
		float phi = i * dPhi;

		for (int j = 0; j < SAMPLES_THETA; j++)
		{
			float theta = (0.5 + j) * dTheta;

			float sinTheta, cosTheta;
			sincos(theta, sinTheta, cosTheta);

			float3 L = SphericalToCartesian(phi, cosTheta);

			float value   = EstimateStrandCount(lodGrid, P, L);
			float valueSH = EstimateSH(l, m, L); 

			C += value * valueSH * sinTheta * dPhi * dTheta;
		}
	}

	return C;
}

// Projects the neighboring density field of the cell into an L1 spherical harmonic.
void ProjectStrandCountSH(const VolumeLODGrid lodGrid, uint3 index, inout float coefficients[4])
{
	float3 P = VolumeIndexToWorld(lodGrid, index);

	// L0
	coefficients[0] = EncodeSHCoefficient(lodGrid, P, 0,  0);

	// L1
	coefficients[1] = EncodeSHCoefficient(lodGrid, P, 1, -1);
	coefficients[2] = EncodeSHCoefficient(lodGrid, P, 1,  0);
	coefficients[3] = EncodeSHCoefficient(lodGrid, P, 1, +1);
}

// Projects the neighboring density field of the cell into an L1 spherical harmonic.
float4 ProjectStrandCountSH_L0L1(const VolumeLODGrid lodGrid, float3 P)
{
	const int SAMPLES_PHI = _ScatteringProbeSamplesPhi;
	const int SAMPLES_THETA = _ScatteringProbeSamplesTheta;

	const float dPhi = TWO_PI / SAMPLES_PHI;// step yaw
	const float dTheta = PI / SAMPLES_THETA;// step pitch

	float4 probe = 0.0;

	for (int i = 0; i < SAMPLES_PHI; i++)
	{
		float sinPhi, cosPhi;
		sincos(i * dPhi, sinPhi, cosPhi);

		for (int j = 0; j < SAMPLES_THETA; j++)
		{
			float sinTheta, cosTheta;
			sincos((0.5 + j) * dTheta, sinTheta, cosTheta);

			float3 L = float3(
				sinTheta * cosPhi,
				sinTheta * sinPhi,
				cosTheta);

			float strandCountApprox = EstimateStrandCount(lodGrid, P, L);
			float strandCountTerm = strandCountApprox * sinTheta * dPhi * dTheta;

			// L0
			probe.x += strandCountTerm * EstimateSH(0,  0, L);

			// L1
			probe.y += strandCountTerm * EstimateSH(1, -1, L);
			probe.z += strandCountTerm * EstimateSH(1,  0, L);
			probe.w += strandCountTerm * EstimateSH(1, +1, L);
		}
	}

	return probe;
}

// Returns the approximate strand count in direction L from an L1 band spherical harmonic.
float DecodeStrandCount(float3 L, float4 probe)
{
	float4 Ylm = float4(
		HALF_SQRT_INV_PI,
		HALF_SQRT_3_DIV_PI * L.y,
		HALF_SQRT_3_DIV_PI * L.z,
		HALF_SQRT_3_DIV_PI * L.x
		);

	return abs(dot(probe, Ylm));
}

#endif//__HAIRSIMCOMPUTEVOLUMEPROBE_HLSL__

```

`Runtime/HairSimComputeVolumeProbe.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: 926f6ef7e8c1c9e4090d3713cef0b5de
ShaderIncludeImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimComputeVolumeRaster.shader`:

```shader
Shader "Hidden/HairSimComputeVolumeRaster"
{
	HLSLINCLUDE

	#pragma target 5.0

	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"

	#include "HairSimData.hlsl"
	#include "HairSimComputeConfig.hlsl"
	#include "HairSimComputeVolumeUtility.hlsl"
	#include "HairSimComputeVolumeTransfer.hlsl"

	struct SliceVaryings
	{
		float4 volumePos : SV_POSITION;
		uint volumeSlice : SV_RenderTargetArrayIndex;
		nointerpolation float2 valuePos : TEXCOORD0;
		nointerpolation float4 value : TEXCOORD1;// xyz = velocity, w = density
		float pointSize : PSIZE;
	};

	SliceVaryings MakeVertex(float2 pos, float4 value, float2 valuePos, uint slice)
	{
		SliceVaryings output;
		output.volumePos = float4(pos, 0.0, 1.0);
		output.volumeSlice = slice;
		output.valuePos = valuePos;
		output.value = value;
		output.pointSize = 1.0;
		return output;
	}

#if !SHADER_API_METAL
	uint SliceVert(uint vertexID : SV_VertexID) : TEXCOORD0
	{
		return vertexID;
	}

	[maxvertexcount(8)]
	void SliceGeom(point uint vertexID[1] : TEXCOORD0, inout TriangleStream<SliceVaryings> outStream)
	{
		// generates 2 quads per particle
		//
		//   3---------+---------4
		//   | `.      :         |
		//   |    C    :    C    |
		//   |      `. :         |
		//   + - - - - + - - - - +
		//   |       x : `.      |
		//   |    C    :    C    |
		//   |         :      `. |
		//   1---------+---------2
		//
		// where
		//
		//   # = triangle vertices
		//   C = cell centers
		//   x = particle

		const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

		const float3 localPos = VolumeWorldToLocal(lodGrid, _ParticlePosition[vertexID[0]].xyz) - 0.5;// subtract offset to cell center
		const float3 localPosFloor = floor(localPos);

		const float2 uvCellSize = 1.0 / lodGrid.volumeCellCount.xy;
		const float2 uv0 = uvCellSize * localPosFloor.xy;
		const float2 uvH = uvCellSize * 2.0;

		const float2 ndc0 = 2.0 * float2(uv0.x, 1.0 - uv0.y) - 1.0;
		const float3 ndcH = 2.0 * float3(uvH.x, -uvH.y, 0.0);

		const uint slice0 = localPosFloor.z;
		const uint slice1 = slice0 + 1;

		const float w1 = localPos.z - localPosFloor.z;
		const float w0 = 1.0 - w1;

		const float4 v = float4(_ParticleVelocity[vertexID[0]], GetParticleVolumeWeight(vertexID[0]));
		const float4 value = float4((v.xyz * v.w), v.w);

		outStream.Append(MakeVertex(ndc0 + ndcH.zz, value * w0, localPos.xy, slice0));
		outStream.Append(MakeVertex(ndc0 + ndcH.xz, value * w0, localPos.xy, slice0));
		outStream.Append(MakeVertex(ndc0 + ndcH.zy, value * w0, localPos.xy, slice0));
		outStream.Append(MakeVertex(ndc0 + ndcH.xy, value * w0, localPos.xy, slice0));
		outStream.RestartStrip();

		outStream.Append(MakeVertex(ndc0 + ndcH.zz, value * w1, localPos.xy, slice1));
		outStream.Append(MakeVertex(ndc0 + ndcH.xz, value * w1, localPos.xy, slice1));
		outStream.Append(MakeVertex(ndc0 + ndcH.zy, value * w1, localPos.xy, slice1));
		outStream.Append(MakeVertex(ndc0 + ndcH.xy, value * w1, localPos.xy, slice1));
		outStream.RestartStrip();
	}
#endif

	SliceVaryings SliceVertNoGS(uint vertexID : SV_VertexID)
	{
		// generates 2 quads per particle
		// 
		//            <----- particle 0 ----->    <----- particle 1 ----->
		// vertexID   0  1  2  3    4  5  6  7    8  9 10 11   12 13 14 15
		// i          0  0  0  0    0  0  0  0    1  1  1  1    1  1  1  1    (vertexID >> 3)
		// j          0  0  0  0    1  1  1  1    0  0  0  0    1  1  1  1    (vertexID >> 2) & 1
		// uvID       0  1  2  3    0  1  2  3    0  1  2  3    0  1  2  3    (vertexID & 3)

		const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

		const uint i = (vertexID >> 3);
		const uint j = (vertexID >> 2) & 1;

		const uint uvID = (vertexID & 3);
		const float2 uv = float2(((uvID >> 1) ^ uvID) & 1, uvID >> 1);

		const float3 localPos = VolumeWorldToLocal(lodGrid, _ParticlePosition[i].xyz) - 0.5;// subtract offset to cell center
		const float3 localPosFloor = floor(localPos);

		const float2 uvCellSize = 1.0 / lodGrid.volumeCellCount.xy;
		const float2 uv0 = uvCellSize * localPosFloor.xy;
		const float2 uvH = uvCellSize * 2.0;

		const float2 ndc0 = 2.0 * float2(uv0.x, 1.0 - uv0.y) - 1.0;
		const float2 ndcH = 2.0 * float2(uvH.x, -uvH.y);

		const float w1 = localPos.z - localPosFloor.z;
		const float w0 = 1.0 - w1;

		const float4 v = float4(_ParticleVelocity[i], GetParticleVolumeWeight(i));

		SliceVaryings output;
		output.volumePos = float4(ndc0 + ndcH * uv, 0.0, 1.0);
		output.volumeSlice = localPosFloor.z + j;
		output.valuePos = localPos.xy;
		output.value = float4((v.xyz * v.w), v.w) * lerp(w0, w1, j);
		output.pointSize = 1.0;
		return output;
	}

	float4 SliceFrag(SliceVaryings input) : SV_Target
	{
		float2 d = 1.0 - saturate(abs(input.valuePos - input.volumePos.xy + 0.5));
		return d.x * d.y * input.value;
	}

	ENDHLSL

	SubShader
	{
		Tags { "RenderType" = "Opaque" }

		Cull Off
		ZTest Always
		ZWrite Off
		Blend One One

		Pass
		{
			HLSLPROGRAM

#if !SHADER_API_METAL
			#pragma vertex SliceVert
			#pragma geometry SliceGeom
			#pragma fragment SliceFrag
#endif

			ENDHLSL
		}

		Pass
		{
			HLSLPROGRAM

			#pragma vertex SliceVertNoGS
			#pragma fragment SliceFrag

			ENDHLSL
		}
	}

	Fallback Off
}

```

`Runtime/HairSimComputeVolumeRaster.shader.meta`:

```meta
fileFormatVersion: 2
guid: 7e9119a1fe374fd45b70c831f4cc3131
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimComputeVolumeTransfer.hlsl`:

```hlsl
#ifndef __HAIRSIMCOMPUTEVOLUMETRANSFER_HLSL__
#define __HAIRSIMCOMPUTEVOLUMETRANSFER_HLSL__

#include "HairSimData.hlsl"

uint GetParticleStrandIndex(uint particleIndex)
{
#if LAYOUT_INTERLEAVED
	return particleIndex % _StrandCount;
#else
	return particleIndex / _StrandParticleCount;
#endif
}

float GetParticleLODCarry(uint particleIndex)
{
#if VOLUME_SPLAT_CLUSTERS
	LODIndices lodDesc = _SolverLODStage[SOLVERLODSTAGE_PHYSICS];

	//TODO check if it's worth doing this in practice
	//uint strandIndex = GetParticleStrandIndex(particleIndex);
	//float strandCarryLo = _LODGuideCarry[(lodDesc.lodIndexLo * _StrandCount) + strandIndex];
	//float strandCarryHi = _LODGuideCarry[(lodDesc.lodIndexHi * _StrandCount) + strandIndex];
	//return lerp(strandCarryLo, strandCarryHi, lodDesc.lodBlendFrac);

	return _LODGuideCarry[(lodDesc.lodIndexHi * _StrandCount) + GetParticleStrandIndex(particleIndex)];
#else
	return 1.0;
#endif
}

float GetParticleVolumeWeight(uint particleIndex)
{
	float2 S = _RootScale[GetParticleStrandIndex(particleIndex)].xy;
	float V = (_GroupMaxParticleVolume) * (S.x * S.y * S.y);
	return (V * GetParticleLODCarry(particleIndex)) / _AllGroupsMaxParticleVolume;
}

#define WEIGHT_BITS 16
#define WEIGHT_MASK 0xFFFF

#if PLATFORM_SUPPORTS_TEXTURE_ATOMICS
#define ACCUIDX uint3
#define WORLDIDX_TO_ACCUIDX(idx) (idx)
#else
#define ACCUIDX uint
#define WORLDIDX_TO_ACCUIDX(idx) VolumeIndexToFlatIndex(idx)
#endif

#if HAIRSIM_WRITEABLE_VOLUMEACCU

void InterlockedAddTrilinear(HAIRSIM_VOLUMEACCU<int> volume, float value, uint3 idx0, float3 w0, float3 w1)
{
	const uint2 h = uint2(1, 0);
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.yyy)], (int)round(value * w0.x * w0.y * w0.z));
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.xyy)], (int)round(value * w1.x * w0.y * w0.z));
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.yxy)], (int)round(value * w0.x * w1.y * w0.z));
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.xxy)], (int)round(value * w1.x * w1.y * w0.z));
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.yyx)], (int)round(value * w0.x * w0.y * w1.z));
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.xyx)], (int)round(value * w1.x * w0.y * w1.z));
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.yxx)], (int)round(value * w0.x * w1.y * w1.z));
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.xxx)], (int)round(value * w1.x * w1.y * w1.z));
}

void InterlockedAddTrilinearPackW(HAIRSIM_VOLUMEACCU<int> volume, float value, uint3 idx0, float3 w0, float3 w1)
{
	const uint2 h = uint2(1, 0);
	const float r = (1 << SPLAT_FRACTIONAL_BITS);
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.yyy)], ((int)round(value * w0.x * w0.y * w0.z) << WEIGHT_BITS) | ((uint)round(r * w0.x * w0.y * w0.z) & WEIGHT_MASK));
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.xyy)], ((int)round(value * w1.x * w0.y * w0.z) << WEIGHT_BITS) | ((uint)round(r * w1.x * w0.y * w0.z) & WEIGHT_MASK));
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.yxy)], ((int)round(value * w0.x * w1.y * w0.z) << WEIGHT_BITS) | ((uint)round(r * w0.x * w1.y * w0.z) & WEIGHT_MASK));
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.xxy)], ((int)round(value * w1.x * w1.y * w0.z) << WEIGHT_BITS) | ((uint)round(r * w1.x * w1.y * w0.z) & WEIGHT_MASK));
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.yyx)], ((int)round(value * w0.x * w0.y * w1.z) << WEIGHT_BITS) | ((uint)round(r * w0.x * w0.y * w1.z) & WEIGHT_MASK));
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.xyx)], ((int)round(value * w1.x * w0.y * w1.z) << WEIGHT_BITS) | ((uint)round(r * w1.x * w0.y * w1.z) & WEIGHT_MASK));
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.yxx)], ((int)round(value * w0.x * w1.y * w1.z) << WEIGHT_BITS) | ((uint)round(r * w0.x * w1.y * w1.z) & WEIGHT_MASK));
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.xxx)], ((int)round(value * w1.x * w1.y * w1.z) << WEIGHT_BITS) | ((uint)round(r * w1.x * w1.y * w1.z) & WEIGHT_MASK));
}

void InterlockedMaxTrilinear(HAIRSIM_VOLUMEACCU<int> volume, float value, uint3 idx0, float3 w0, float3 w1)
{
	const uint2 h = uint2(1, 0);
	InterlockedMax(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.yyy)], (int)round(value * w0.x * w0.y * w0.z));
	InterlockedMax(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.xyy)], (int)round(value * w1.x * w0.y * w0.z));
	InterlockedMax(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.yxy)], (int)round(value * w0.x * w1.y * w0.z));
	InterlockedMax(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.xxy)], (int)round(value * w1.x * w1.y * w0.z));
	InterlockedMax(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.yyx)], (int)round(value * w0.x * w0.y * w1.z));
	InterlockedMax(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.xyx)], (int)round(value * w1.x * w0.y * w1.z));
	InterlockedMax(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.yxx)], (int)round(value * w0.x * w1.y * w1.z));
	InterlockedMax(volume[WORLDIDX_TO_ACCUIDX(idx0 + h.xxx)], (int)round(value * w1.x * w1.y * w1.z));
}

void InterlockedAddParticleContribution(const VolumeLODGrid lodGrid, float3 worldPos, float value, HAIRSIM_VOLUMEACCU<int> volume, float3 offset = 0.5)
{
#if SPLAT_TRILINEAR
	TrilinearWeights tri = VolumeWorldToCellTrilinear(lodGrid, worldPos, offset);
	InterlockedAddTrilinear(volume, value * (1 << SPLAT_FRACTIONAL_BITS), tri.idx0, tri.w0, tri.w1);
#else
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(VolumeWorldToIndex(lodGrid, worldPos))], (int) round(value * (1 << SPLAT_FRACTIONAL_BITS)));
#endif
}

void InterlockedAddParticleContributionPackW(const VolumeLODGrid lodGrid, float3 worldPos, float value, HAIRSIM_VOLUMEACCU<int> volume, float3 offset = 0.5)
{
#if SPLAT_TRILINEAR
	TrilinearWeights tri = VolumeWorldToCellTrilinear(lodGrid, worldPos, offset);
	InterlockedAddTrilinearPackW(volume, value * (1 << SPLAT_FRACTIONAL_BITS), tri.idx0, tri.w0, tri.w1);
#else
	InterlockedAdd(volume[WORLDIDX_TO_ACCUIDX(VolumeWorldToIndex(lodGrid, worldPos))], (int) round(value * (1 << SPLAT_FRACTIONAL_BITS)));
#endif
}

void InterlockedMaxParticleContribution(const VolumeLODGrid lodGrid, float3 worldPos, float value, HAIRSIM_VOLUMEACCU<int> volume, float3 offset = 0.5)
{
#if SPLAT_TRILINEAR
	TrilinearWeights tri = VolumeWorldToCellTrilinear(lodGrid, worldPos, offset);
	InterlockedMaxTrilinear(volume, value * (1 << SPLAT_FRACTIONAL_BITS), tri.idx0, tri.w0, tri.w1);
#else
	InterlockedMax(volume[WORLDIDX_TO_ACCUIDX(VolumeWorldToIndex(lodGrid, worldPos))], (int) round(value * (1 << SPLAT_FRACTIONAL_BITS)));
#endif
}

#else// !HAIRSIM_WRITEABLE_VOLUMEACCU

//void InterlockedAddParticleContribution(const VolumeLODGrid lodGrid, float3 worldPos, float value, HAIRSIM_VOLUMEACCU<int> volume, float3 offset = 0.5) { }
//void InterlockedAddParticleContributionPackW(const VolumeLODGrid lodGrid, float3 worldPos, float value, HAIRSIM_VOLUMEACCU<int> volume, float3 offset = 0.5) { }
//void InterlockedMaxParticleContribution(const VolumeLODGrid lodGrid, float3 worldPos, float value, HAIRSIM_VOLUMEACCU<int> volume, float3 offset = 0.5) { }

#endif

#endif//__HAIRSIMCOMPUTEVOLUMETRANSFER_HLSL__

```

`Runtime/HairSimComputeVolumeTransfer.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: 52073b8857789a3409b664383324b794
ShaderIncludeImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimComputeVolumeUtility.hlsl`:

```hlsl
#ifndef __HAIRSIMCOMPUTEVOLUMEUTILITY_HLSL__
#define __HAIRSIMCOMPUTEVOLUMEUTILITY_HLSL__

#include "HairSimData.hlsl"
#include "HairSimComputeConfig.hlsl"
/*
	_VolumeCells = (3, 3, 3)

			  +---+---+-- Q
		 +---+---+---+  o :
	+---+---+---+  o | ---+
	| o | o | o | ---+  o |
	+---+---+---+  o | ---+
	| o | o | o | ---+  o |
	+---+---+---+  o | ---+
	: o | o | o | ---+
	P --+---+---+

	_VolumeWorldMin = P
	_VolumeWorldMax = Q

	https://asawicki.info/news_1516_half-pixel_offset_in_directx_11.html

	worldToUVW(P) = (0, 0, 0)
	worldToUVW(Q) = (1, 1, 1)

	worldToLocal(P) = (0, 0, 0)
	worldToLocal(Q) = (3, 3, 3)
*/

float3 VolumeWorldSize(const VolumeLODGrid lodGrid)
{
	return lodGrid.volumeWorldMax.xyz - lodGrid.volumeWorldMin.xyz;
}

float3 VolumeWorldCellSize(const VolumeLODGrid lodGrid)
{
	return VolumeWorldSize(lodGrid) / _GridResolution.xxx;
}

float VolumeWorldCellVolume(const VolumeLODGrid lodGrid)
{
	float3 worldCellSize = VolumeWorldCellSize(lodGrid);
	return worldCellSize.x * worldCellSize.y * worldCellSize.z;
}

//-------------
// conversions

float3 VolumeWorldToUVW(const VolumeLODGrid lodGrid, float3 worldPos)
{
	//TODO sanitize out of bounds?
	float3 uvw = (worldPos - lodGrid.volumeWorldMin.xyz) / (lodGrid.volumeWorldMax.xyz - lodGrid.volumeWorldMin.xyz);
	return uvw;
}

float3 VolumeWorldToLocal(const VolumeLODGrid lodGrid, float3 worldPos)
{
	float3 localPos = _GridResolution.xxx * VolumeWorldToUVW(lodGrid, worldPos);
	return localPos;
}

uint3 VolumeWorldToIndex(const VolumeLODGrid lodGrid, float3 worldPos)
{
	float3 localPos = VolumeWorldToLocal(lodGrid, worldPos);
	float3 localPosFloor = floor(localPos);
	return localPosFloor;
}

float3 VolumeUVWToWorld(const VolumeLODGrid lodGrid, float3 uvw)
{
	return lerp(lodGrid.volumeWorldMin.xyz, lodGrid.volumeWorldMax.xyz, uvw);
}

float3 VolumeUVWToLocal(const VolumeLODGrid lodGrid, float3 uvw)
{
	float3 localPos = uvw * _GridResolution.xxx;
	return localPos;
}

float3 VolumeLocalToUVW(const VolumeLODGrid lodGrid, float3 localPos)
{
	float3 uvw = localPos / _GridResolution.xxx;
	return uvw;
}

float3 VolumeIndexToUVW(const VolumeLODGrid lodGrid, uint3 index)
{
	float3 uvw = (index + 0.5) / _GridResolution.xxx;
	return uvw;
}

float3 VolumeIndexToLocal(const VolumeLODGrid lodGrid, uint3 index)
{
	float3 localPos = index + 0.5;
	return localPos;
}

float3 VolumeIndexToWorld(const VolumeLODGrid lodGrid, uint3 index)
{
	float3 worldPos = lodGrid.volumeWorldMin.xyz + (index + 0.5) * VolumeWorldCellSize(lodGrid);
	return worldPos;
}

uint VolumeIndexToFlatIndex(uint3 index)
{
	uint3 gridResolution = _GridResolution.xxx;
	uint3 clampedIndex = min(index, gridResolution - 1);
	uint flatIndex = (
		clampedIndex.z * (gridResolution.x * gridResolution.y) +
		clampedIndex.y * gridResolution.x +
		clampedIndex.x
	);
	return flatIndex;
}

uint3 VolumeFlatIndexToIndex(uint flatIndex)
{
	uint3 gridResolution = _GridResolution.xxx;
	uint x = (flatIndex % gridResolution.x);
	uint y = (flatIndex / gridResolution.x) % gridResolution.y;
	uint z = (flatIndex / (gridResolution.x * gridResolution.y));
	return uint3(x, y, z);
}

//---------------
// sample scalar

float VolumeSampleScalar(Texture3D<float> volume, float3 uvw, SamplerState state)
{
	return volume.SampleLevel(state, uvw, 0);
}

float VolumeSampleScalar(Texture3D<float> volume, float3 uvw)
{
	return VolumeSampleScalar(volume, uvw, _Volume_trilinear_clamp);
}

float3 VolumeSampleScalarGradient(Texture3D<float> volume, float3 uvw)
{
	const float2 h = float2(1.0 / _GridResolution, 0.0);
	
	float s_xm = VolumeSampleScalar(volume, uvw - h.xyy, _Volume_trilinear_clamp);
	float s_ym = VolumeSampleScalar(volume, uvw - h.yxy, _Volume_trilinear_clamp);
	float s_zm = VolumeSampleScalar(volume, uvw - h.yyx, _Volume_trilinear_clamp);

	float s_xp = VolumeSampleScalar(volume, uvw + h.xyy, _Volume_trilinear_clamp);
	float s_yp = VolumeSampleScalar(volume, uvw + h.yxy, _Volume_trilinear_clamp);
	float s_zp = VolumeSampleScalar(volume, uvw + h.yyx, _Volume_trilinear_clamp);

	const float3 diff = float3(
		s_xp - s_xm,
		s_yp - s_ym,
		s_zp - s_zm);

	return diff / (2.0 * h.x);
}

//---------------
// sample vector

float3 VolumeStaggededOffsetUVW()
{
	return 0.5 / _GridResolution.xxx;
}

float3 VolumeStaggeredSample(Texture3D<float3> volume, float3 uvw, SamplerState state)
{
	return float3(
		volume.SampleLevel(state, uvw + float3(VolumeStaggededOffsetUVW().x, 0.0, 0.0), 0).x,
		volume.SampleLevel(state, uvw + float3(0.0, VolumeStaggededOffsetUVW().y, 0.0), 0).y,
		volume.SampleLevel(state, uvw + float3(0.0, 0.0, VolumeStaggededOffsetUVW().z), 0).z);
}

float3 VolumeStaggeredSample(Texture3D<float4> volume, float3 uvw, SamplerState state)
{
	return float3(
		volume.SampleLevel(state, uvw + float3(VolumeStaggededOffsetUVW().x, 0.0, 0.0), 0).x,
		volume.SampleLevel(state, uvw + float3(0.0, VolumeStaggededOffsetUVW().y, 0.0), 0).y,
		volume.SampleLevel(state, uvw + float3(0.0, 0.0, VolumeStaggededOffsetUVW().z), 0).z);
}

float3 VolumeSampleVector(Texture3D<float3> volume, float3 uvw, SamplerState state)
{
#if VOLUME_STAGGERED_GRID
	return VolumeStaggeredSample(volume, uvw, state);
#else
	return volume.SampleLevel(state, uvw, 0).xyz;
#endif
}

float3 VolumeSampleVector(Texture3D<float4> volume, float3 uvw, SamplerState state)
{
#if VOLUME_STAGGERED_GRID
	return VolumeStaggeredSample(volume, uvw, state);
#else
	return volume.SampleLevel(state, uvw, 0).xyz;
#endif
}

float3 VolumeSampleVector(Texture3D<float3> volume, float3 uvw)
{
	return VolumeSampleVector(volume, uvw, _Volume_trilinear_clamp);
}

float3 VolumeSampleVector(Texture3D<float4> volume, float3 uvw)
{
	return VolumeSampleVector(volume, uvw, _Volume_trilinear_clamp);
}

//---------
// weights

struct TrilinearWeights
{
	uint3 idx0;
	float3 w0;
	float3 w1;
};

TrilinearWeights VolumeWorldToCellTrilinear(const VolumeLODGrid lodGrid, float3 worldPos, float3 offset = 0.5)
{
	float3 localPos = VolumeWorldToLocal(lodGrid, worldPos) - offset;// subtracting offset to cell center
	float3 localPosFloor = floor(localPos);

	uint3 cellIdx0 = localPosFloor;
	float3 cellPos = localPos - localPosFloor;

	TrilinearWeights tri;
	tri.idx0 = cellIdx0;
	tri.w0 = 1.0 - cellPos;
	tri.w1 = cellPos;
	return tri;
}

float VolumeWorldToCellTrilinearInverseMultiplier(const VolumeLODGrid lodGrid, float3 worldPos, float3 offset = 0.5)
{
	//TODO comment/illustrate

	TrilinearWeights tri = VolumeWorldToCellTrilinear(lodGrid, worldPos);

	const float3 sqw0 = tri.w0 * tri.w0;
	const float3 sqw1 = tri.w1 * tri.w1;

	const float d = (
		sqw0.x * sqw0.y * sqw0.z +
		sqw1.x * sqw0.y * sqw0.z +
		sqw0.x * sqw1.y * sqw0.z +
		sqw1.x * sqw1.y * sqw0.z +
		sqw0.x * sqw0.y * sqw1.z +
		sqw1.x * sqw0.y * sqw1.z +
		sqw0.x * sqw1.y * sqw1.z +
		sqw1.x * sqw1.y * sqw1.z
		);

	return 1.0 / d;
}

//-------
// trace

float3 VolumeWorldCellStep(const VolumeLODGrid lodGrid, float3 worldDir)
{
#if VOLUME_SQUARE_CELLS
	float3 dirAbs = abs(worldDir);
	float3 dirMax = max(dirAbs.x, max(dirAbs.y, dirAbs.z));
	float3 step = worldDir * (VolumeWorldCellSize(lodGrid).x / dirMax);
	return step;
#else
	//TODO or otherwise always force VOLUME_SQUARE_CELLS ?
#endif
}

struct VolumeTraceState
{
	float3 uvw;
	float3 uvwStep;
};

VolumeTraceState VolumeTraceBegin(const VolumeLODGrid lodGrid, float3 worldPos, float3 worldDir, float cellOffset, int cellSubsteps)
{
	float3 uvwStep = VolumeWorldCellStep(lodGrid, worldDir) / (lodGrid.volumeWorldMax.xyz - lodGrid.volumeWorldMin.xyz);
	float3 uvw = VolumeWorldToUVW(lodGrid, worldPos) + cellOffset * uvwStep;

	uvwStep /= cellSubsteps;
	uvw -= uvwStep;

	VolumeTraceState trace;
	{
		trace.uvwStep = uvwStep;
		trace.uvw = uvw;
	}

	return trace;
}

bool VolumeTraceEnded(in VolumeTraceState trace)
{
	// trace has ended if for any axis the trace is outside the volume and not reentering
#if 0
	if (any(and(trace.uvw < 0, trace.uvwStep <= 0)) || any(and(trace.uvw > 1, trace.uvwStep >= 0)))
#else
	if (any((trace.uvw < 0) & (trace.uvwStep <= 0)) || any((trace.uvw > 1) & (trace.uvwStep >= 0)))
#endif
		return true;
	else
		return false;
}

bool VolumeTraceStep(inout VolumeTraceState trace)
{
	trace.uvw += trace.uvwStep;

	// signal no further steps required if the trace has exited the volume
	if (VolumeTraceEnded(trace))
		return false;
	else
		return true;
}

#endif//__HAIRSIMCOMPUTEVOLUMEUTILITY_HLSL__

```

`Runtime/HairSimComputeVolumeUtility.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: a9295d3d311e0ff4a9c4f997d12a6c5d
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimConf.cs`:

```cs
using UnityEngine.Rendering;

namespace Unity.DemoTeam.Hair
{
	public static partial class HairSim
	{
		[GenerateHLSL]
		public struct Conf
		{
			public const int MAX_FRUSTUMS = 32;
			// N == max number of lod cameras

			public const int MAX_BOUNDARIES = 8;
			// N == max number of solid boundaries

			public const int MAX_EMITTERS = 8;
			// N == max number of wind emitters

			public const int SECOND_ORDER_UPDATE = 0;
			// 0 == off (smaller memory footprint)
			// 1 == on (experimental)

			public const int SPLAT_FRACTIONAL_BITS = 12;// => 1 / (1 << 14) = 0.00006103515625
			// N == controls smallest fraction stored on grid

			public const int SPLAT_TRILINEAR = 1;
			// 0 == splat only to nearest cell
			// 1 == trilinear weights

			public const int VOLUME_SQUARE_CELLS = 1;
			// 0 == support non-square cells
			// 1 == only square cells

			public const int VOLUME_STAGGERED_GRID = 0;
			// 0 == store everything at cell centers
			// 1 == store velocity and pressure gradient at cell faces

			public const int INSTANCING_BATCH_SIZE = 64;
			// N == number of strands per render instance
		}
	}
}

```

`Runtime/HairSimConf.cs.hlsl`:

```hlsl
//
// This file was automatically generated. Please don't edit by hand. Execute Editor command [ Edit > Rendering > Generate Shader Includes ] instead
//

#ifndef HAIRSIMCONF_CS_HLSL
#define HAIRSIMCONF_CS_HLSL
//
// Unity.DemoTeam.Hair.HairSim+Conf:  static fields
//
#define MAX_FRUSTUMS (32)
#define MAX_BOUNDARIES (8)
#define MAX_EMITTERS (8)
#define SECOND_ORDER_UPDATE (0)
#define SPLAT_FRACTIONAL_BITS (12)
#define SPLAT_TRILINEAR (1)
#define VOLUME_SQUARE_CELLS (1)
#define VOLUME_STAGGERED_GRID (0)
#define INSTANCING_BATCH_SIZE (64)


#endif

```

`Runtime/HairSimConf.cs.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: 08e5ee43a95c16548a6f177962fa1a86
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  preprocessorOverride: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimConf.cs.meta`:

```meta
fileFormatVersion: 2
guid: dbb3c2e2b7a46744681dc46dd57483c8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimData.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnityEngine;
using UnityEngine.Rendering;
using Unity.Collections;

namespace Unity.DemoTeam.Hair
{
	public static partial class HairSim
	{
		public struct SolverData
		{
			public static SolverExternals<int> s_externalIDs;
			public struct SolverExternals<T>
			{
				public T _RootMeshPosition;				// root mesh vertex buffer w/ positions
				public T _RootMeshTangent;				// root mesh vertex buffer w/ tangents
				public T _RootMeshNormal;				// root mesh vertex buffer w/ normals

				public T _RootResolveDummyRT;			// render target when resolving via vertex stage
			};

			public static SolverBuffers<int> s_bufferIDs;
			public struct SolverBuffers<T>
			{
				public T SolverCBufferRoots;			// constant buffer for root resolve
				public T SolverCBuffer;					// constant buffer

				public T _RootUV;						// xy: root uv
				public T _RootScale;					// xy: root scale (length, diameter normalized to maximum within group), z: tip scale offset, w: tip scale

				public T _RootPositionNext;				// xyz: strand root position, w: -
				public T _RootPositionPrev;				// xyz: ...
				public T _RootPosition;					// xyz: ...
				public T _RootFrameNext;				// quat(xyz,w): strand root material frame where (0,1,0) is tangent to curve
				public T _RootFramePrev;				// quat(xyz,w): ...
				public T _RootFrame;					// quat(xyz,w): ...

				public T _SolverLODStage;				// x: lod index lo, y: lod index hi, z: lod blend fraction, w: lod value/quantity
				public T _SolverLODRange;				// xy: dispatch strand range [begin, end)
				public T _SolverLODDispatch;			// xyz: dispatch args compute, w: dispatch strand count || xyzw: dispatch args draw
				public T _SolverLODTopology;			// x[5]: dispatch args draw indexed

				public T _InitialParticleOffset;		// xyz: initial particle offset from strand root, w: initial local accumulated weight (gather)
				public T _InitialParticleFrameDelta;	// quat(xyz,w): initial particle material frame delta
				public T _InitialParticleFrameDelta16;	// xy: compressed initial particle material frame delta

				public T _ParticlePosition;				// xyz: position
				public T _ParticlePositionPrev;			// xyz: ...
				public T _ParticlePositionPrevPrev;		// xyz: ...
				public T _ParticleVelocity;				// xyz: velocity
				public T _ParticleVelocityPrev;			// xyz: ...
				public T _ParticleCorrection;			// xyz: ftl distance correction

				public T _ParticleOptTexCoord;			// xy: optional particle uv
				public T _ParticleOptDiameter;			// x: optional particle diameter

				public T _LODGuideCount;				// x: lod index -> num. guides
				public T _LODGuideIndex;				// x: lod index * strand count + strand index -> guide index
				public T _LODGuideCarry;				// x: lod index * strand count + strand index -> guide carry
				public T _LODGuideReach;				// x: lod index * strand count + strand index -> guide reach (approximate cluster extent)

				public T _StagingVertex;				// xyz: position (uncompressed) || xy: position (compressed)
				public T _StagingVertexPrev;			// xyz: ...
			}

			public static SolverTextures<int> s_textureIDs;
			public struct SolverTextures<T>
			{
				//public T _LODIndexLUT;				// TODO
			}

			public struct SolverKeywords
			{
				public bool LAYOUT_INTERLEAVED;
				public bool LIVE_POSITIONS_3;
				public bool LIVE_POSITIONS_2;
				public bool LIVE_POSITIONS_1;
				public bool LIVE_ROTATIONS_2;
			}

			// data accessible by GPU
#if UNITY_2021_1_OR_NEWER
			public SolverBuffers<GraphicsBuffer> buffers;
#else
			public SolverBuffers<ComputeBuffer> buffers;
#endif
			public SolverTextures<Texture> textures;

			// data accessible by GPU + CPU
			public SolverCBufferRoots constantsRoots;
			public SolverCBuffer constants;
			public SolverKeywords keywords;

			// data accessible by CPU, updated via async readback
			public SolverBuffers<HairSimUtility.AsyncReadbackBuffer> buffersReadback;

			// data accessible by CPU
			public HairAsset.MemoryLayout memoryLayout;

			public float initialStrandLengthTotal;
			public Vector4 initialStrandParamsMax;
			public Vector4 initialStrandParamsAvg;

			public bool manualBounds;
			public Vector3 manualBoundsMin;
			public Vector3 manualBoundsMax;

			public NativeArray<float> lodThreshold;		// lod index -> relative guide count [0..1]
		}

		[GenerateHLSL(needAccessors = false, generateCBuffer = true), StructLayout(LayoutKind.Sequential, Pack = 16)]
		public struct SolverCBufferRoots
		{
			// NOTE: explicit end padding to 16 byte boundary required on some platforms, please update counts if modifying

			// 0
			#region Strand Roots (34 floats, 136 bytes)
			public Matrix4x4 _RootMeshMatrix;			// float4x4: root mesh local to world

			// +16
			public Vector4 _RootMeshRotation;			// quat(xyz,w): root mesh rotation
			public Vector4 _RootMeshRotationInv;		// quat(xyz,w): root mesh rotation inverse
			public Vector4 _RootMeshSkinningRotation;	// quat(xyz,w): root mesh skinning rotation

			// +28
			public uint _RootMeshPositionOffset;		// x: position stream offset
			public uint _RootMeshPositionStride;		// x: position stream stride
			public uint _RootMeshTangentOffset;			// x: tangent ...
			public uint _RootMeshTangentStride;			// x: tangent ...
			public uint _RootMeshNormalOffset;			// x: normal ...
			public uint _RootMeshNormalStride;			// x: normal ...

			// +34
			#endregion

			// 34 --> 36 (pad to 16 byte boundary)
			public float _rcbpad1;
			public float _rcbpad2;
			//public float _rcbpad3;
		}

		[GenerateHLSL(needAccessors = false, generateCBuffer = true), StructLayout(LayoutKind.Sequential, Pack = 16)]
		public struct SolverCBuffer
		{
			// NOTE: explicit end padding to 16 byte boundary required on some platforms, please update counts if modifying

			// 0
			#region Strand Geometry (15 floats, 60 bytes)
			public uint _StrandCount;					// number of strands
			public uint _StrandParticleCount;			// number of particles in strand
			public uint _StrandParticleOffset;			// stride in particles between strands
			public uint _StrandParticleStride;			// stride in particles between particles in strand
			public uint _LODCount;						// group lod count

			// +5
			public float _GroupScale;					// group scale
			public float _GroupMaxParticleVolume;		// (already scaled) max particle volume
			public float _GroupMaxParticleInterval;		// (already scaled) max particle interval
			public float _GroupMaxParticleDiameter;		// (already scaled) max particle diameter
			public float _GroupAvgParticleDiameter;		// (already scaled) avg particle diameter
			public float _GroupAvgParticleMargin;		// (already scaled) avg particle margin
			public float _GroupMaxTipScale;				// max tip scale
			public float _GroupMaxTipScaleOffset;		// max tip scale offset

			// +13
			public uint _GroupBoundsIndex;				// group bounds index
			public float _GroupBoundsPadding;			// group bounds padding

			// +15
			#endregion

			// 15
			#region Strand Solver (28 floats, 112 bytes)
			public uint _SolverLODMethod;				// solver lod method (for lod selection)
			public float _SolverLODCeiling;				// solver lod ceiling
			public float _SolverLODScale;				// solver lod scale
			public float _SolverLODBias;				// solver lod bias

			// +4
			public uint _SolverFeatures;				// solver feature flags

			// +5
			public float _DT;							// solver time step
			public uint _Substeps;						// solver substeps
			public uint _Iterations;					// constraint iterations
			public float _Stiffness;					// constraint stiffness
			public float _SOR;							// constraint sor factor

			// +10
			public float _LinearDamping;				// linear damping factor (fraction to subtract per interval)
			public float _LinearDampingInterval;		// linear damping interval
			public float _AngularDamping;				// angular damping factor (fraction to subtract per interval)
			public float _AngularDampingInterval;		// angular damping interval
			public float _CellPressure;					// scale factor for cell-sampled pressure impulse [0..1]
			public float _CellVelocity;					// scale factor for cell-sampled velocity impulse [0..1]
			public float _CellExternal;					// scale factor for cell-sampled external impulse [0..1]
			public float _GravityScale;					// scale factor for system gravity [0..1]

			// +18
			public float _BoundaryFriction;				// boundary collision constraint friction
			public float _FTLCorrection;				// follow-the-leader constraint correction
			public float _LocalCurvature;				// local curvature
			public float _LocalShape;					// local shape constraint influence
			public float _LocalShapeBias;				// local shape constraint bias

			// +23
			public float _GlobalPosition;
			public float _GlobalPositionInterval;
			public float _GlobalRotation;
			public float _GlobalFadeOffset;
			public float _GlobalFadeExtent;

			// +28
			#endregion

			// 43
			#region Strand Staging (11 floats, 44 bytes)
			public uint _StagingSubdivision;			// staging subdivision count
			public uint _StagingVertexFormat;			// staging buffer vertex format
			public uint _StagingVertexStride;			// staging buffer vertex stride

			public uint _StagingStrandVertexCount;		// staging strand vertex count
			public uint _StagingStrandVertexOffset;		// staging strand vertex offset

			// +5
			public uint _RenderLODMethod;				// render lod method (for lod selection)
			public float _RenderLODCeiling;				// render lod ceiling
			public float _RenderLODScale;				// render lod scale
			public float _RenderLODBias;				// render lod bias
			public float _RenderLODClipThreshold;		// reclip threshold (min pixel coverage)

			public uint _RenderFeatures;				// render feature falgs

			// +11
			#endregion

			// 54 --> 56 (pad to 16 byte boundary)
			public float _scbpad1;
			public float _scbpad2;
			//public float _scbpad3;
		}

		[GenerateHLSL, Flags]
		public enum SolverFeatures
		{
			Boundary			= 1 << 0,
			BoundaryFriction	= 1 << 1,
			Distance			= 1 << 2,
			DistanceLRA			= 1 << 3,
			DistanceFTL			= 1 << 4,
			CurvatureEQ			= 1 << 5,
			CurvatureGEQ		= 1 << 6,
			CurvatureLEQ		= 1 << 7,
			PoseLocalShape		= 1 << 8,
			PoseLocalShapeRWD	= 1 << 9,
			PoseGlobalPosition	= 1 << 10,
			PoseGlobalRotation	= 1 << 11,
		}

		[GenerateHLSL]
		public enum SolverLODStage
		{
			Physics		= 0,
			PhysicsPrev	= 1,
			Rendering	= 2,
			__COUNT
		}

		[GenerateHLSL]
		public enum SolverLODRange
		{
			Solve					= 0,
			Interpolate				= 1,
			InterpolateAdd			= 2,
			InterpolatePromote		= 3,
			Render					= 4,
			RenderAdd				= 5,
			__COUNT
		}

		[GenerateHLSL]
		public enum SolverLODDispatch
		{
			Solve					= 0,	// thread group is 64 strands
			SolveGroupParticles		= 1,	// thread group is 16|32|64|128 particles (one group = one strand)
			Interpolate				= 2,	// thread group is 64 strands
			InterpolateAdd			= 3,	// thread group is 64 strands
			InterpolatePromote		= 4,	// thread group is 64 strands
			Staging					= 5,	// thread group is 64 strands
			StagingAdd				= 6,	// thread group is 64 strands
			Roots					= 7,	// thread group is 64 strands
			Transfer				= 8,	// thread group is 64 particles
			TransferAll				= 9,	// thread group is 64 particles
			RasterPoints			= 10,	// -
			RasterPointsAll			= 11,	// -
			RasterQuads				= 12,	// -
			RasterQuadsAll			= 13,	// -
			__COUNT
		}

		[GenerateHLSL]
		public enum SolverLODTopology
		{
			IndexedLines				= 0,
			IndexedStrips				= 1,
			IndexedTubes				= 2,
			IndexedInstancedLines		= 3,
			IndexedInstancedStrips		= 4,
			IndexedInstancedTubes		= 5,
			XrIndexedLines				= 6,
			XrIndexedStrips				= 7,
			XrIndexedTubes				= 8,
			XrIndexedInstancedLines		= 9,
			XrIndexedInstancedStrips	= 10,
			XrIndexedInstancedTubes		= 11,
			__COUNT
		}

		[GenerateHLSL]
		public enum SolverLODSelection
		{
			AutomaticPerGroup	= 0,
			AutomaticPerVolume	= 1,
			Manual				= 2,
		}

		[GenerateHLSL, Flags]
		public enum RenderFeatures
		{
			Instancing			= 1 << 0,
			PerVertexTexCoord	= 1 << 1,
			PerVertexDiameter	= 1 << 2,
		}

		[GenerateHLSL]
		public enum RenderLODSelection
		{
			AutomaticPerSegment	= 0,
			AutomaticPerGroup	= 1,
			AutomaticPerVolume	= 2,
			MatchPhysics		= 3,
			Manual				= 4,
		}

		[GenerateHLSL]
		public enum StagingVertexFormat
		{
			Compressed		= 0,
			Uncompressed	= 1,
		}

		public struct VolumeData
		{
			public static VolumeBuffers<int> s_bufferIDs;
			public struct VolumeBuffers<T>
			{
				public T VolumeCBufferEnvironment;	// constant buffer for environment capture
				public T VolumeCBuffer;				// constant buffer

				public T _LODFrustum;				// array(LODFrustum): observer properties (camera properties and frustum planes)

				public T _BoundaryMatrixNext;		// push per frame, array(float4x4)
				public T _BoundaryMatrixPrevA;		// push per frame, array(float4x4)
				public T _BoundaryMatrixPrevQ;		// push per frame, array(float4)
				public T _BoundaryMatrix;			// compute per step (volume or group), array(float4x4): local to world
				public T _BoundaryMatrixInv;		// compute per step (volume or group), array(float4x4): world to local
				public T _BoundaryMatrixInvStep;	// compute per step (volume or group), array(float4x4): world to previous world
				public T _BoundaryShapeNext;		// push per frame, array(HairBoundary.RuntimeShape.Data)
				public T _BoundaryShapePrevLUT;		// push per frame, array(int)
				public T _BoundaryShapePrev;		// compute per frame, array(HairBoundary.RuntimeShape.Data)
				public T _BoundaryShape;			// compute per step (volume or group), array(HairBoundary.RuntimeShape.Data)

				public T _WindEmitterNext;			// push per frame, array(HairWind.RuntimeEmitter)
				public T _WindEmitterPrevLUT;		// push per frame, array(int)
				public T _WindEmitterPrev;			// compute per frame, array(HairWind.RuntimeEmitter)
				public T _WindEmitter;				// compute per step (volume), array(HairWind.RuntimeEmitter)

				public T _BoundsMinMaxU;			// xyz: bounds min/max (unsigned sortable)
				public T _BoundsPrev;				// array(LODBounds): bounds (center, extent, radius, reach)
				public T _Bounds;					// array(LODBounds): bounds (center, extent, radius, reach)
				public T _BoundsGeometry;			// array(LODGeometry): bounds geometry description (dimensions for coverage)
				public T _BoundsCoverage;			// xy: bounds coverage (unbiased ceiling)

				public T _VolumeLODStage;			// array(VolumeLODGrid): grid properties
				public T _VolumeLODDispatch;		// xyz: num groups, w: num grid cells in one dimension

				public T _AccuWeightBuffer;			// x: fp accumulated weight
				public T _AccuWeight0Buffer;		// x: fp accumulated target weight
				public T _AccuVelocityXBuffer;		// x: fp accumulated x-velocity
				public T _AccuVelocityYBuffer;		// x: ... ... ... .. y-velocity
				public T _AccuVelocityZBuffer;		// x: .. ... ... ... z-velocity
			}

			public static VolumeTextures<int> s_textureIDs;
			public struct VolumeTextures<T>
			{
				public T _AccuWeight;				// x: fp accumulated weight
				public T _AccuWeight0;				// x: fp accumulated target weight
				public T _AccuVelocityX;			// x: fp accumulated x-velocity
				public T _AccuVelocityY;			// x: ... ... ... .. y-velocity
				public T _AccuVelocityZ;			// x: .. ... ... ... z-velocity

				public T _VolumeDensity;			// x: density (cell fraction occupied)
				public T _VolumeDensity0;			// x: density target
				public T _VolumeDensityComp;		// (temp)
				public T _VolumeDensityPreComp;		// (temp)

				public T _VolumeVelocity;			// xyz: velocity, w: accumulated weight
				public T _VolumeDivergence;			// x: velocity divergence + source term
				public T _VolumePressure;			// x: pressure
				public T _VolumePressureNext;		// x: pressure (output of iteration)
				public T _VolumePressureGrad;		// xyz: pressure gradient, w: -

				public T _VolumeScattering;			// xyzw: L1 spherical harmonic
				public T _VolumeImpulse;			// xyz: accumulated external forces, w: -

				public T _BoundarySDF;				// x: signed distance to arbitrary solid
				public T _BoundarySDF_undefined;	// .. (placeholder for when inactive)
			};

			public struct VolumeKeywords
			{
				public bool VOLUME_SPLAT_CLUSTERS;
				public bool VOLUME_SUPPORT_CONTRACTION;
				public bool VOLUME_TARGET_INITIAL_POSE;
				public bool VOLUME_TARGET_INITIAL_POSE_IN_PARTICLES;
			}

			// data accessible by GPU
			public VolumeBuffers<ComputeBuffer> buffers;
			public VolumeTextures<Texture> textures;

			// data accessible by GPU + CPU
			public VolumeCBufferEnvironment constantsEnvironment;
			public VolumeCBuffer constants;
			public VolumeKeywords keywords;

			// data accessible by CPU, updated via async readback
			public VolumeBuffers<HairSimUtility.AsyncReadbackBuffer> buffersReadback;

			// data accessible by CPU
			public NativeArray<int> boundaryPrevHandle;
			public NativeArray<Matrix4x4> boundaryPrevMatrix;
			public int boundaryCount;
			public int boundaryCountDiscard;

			public NativeArray<int> emitterPrevHandle;
			public int emitterCount;
			public int emitterCountDiscard;
		}

		[GenerateHLSL(needAccessors = false, generateCBuffer = true), StructLayout(LayoutKind.Sequential, Pack = 16)]
		public unsafe struct VolumeCBufferEnvironment
		{
			// NOTE: explicit end padding to 16 byte boundary required on some platforms, please update counts if modifying

			// 0
			#region Volume Environment (14 floats, 56 bytes)
			public Vector4 _WorldGravity;

			// +4
			public uint _LODFrustumCount;

			// +5
			public uint _BoundaryDelimDiscrete;
			public uint _BoundaryDelimCapsule;
			public uint _BoundaryDelimSphere;
			public uint _BoundaryDelimTorus;
			public uint _BoundaryDelimCube;
			public float _BoundaryWorldEpsilon;
			public float _BoundaryWorldMargin;

			// +12
			public float _WindEmitterClock;
			public uint _WindEmitterCount;

			// +14
			#endregion

			// 14 --> 16 (pad to 16 byte boundary)
			public float _ecbpad1;
			public float _ecbpad2;
			//public float _ecbpad3;
		}

		[GenerateHLSL(needAccessors = false, generateCBuffer = true), StructLayout(LayoutKind.Sequential, Pack = 16)]
		public struct VolumeCBuffer
		{
			// NOTE: explicit end padding to 16 byte boundary required on some platforms, please update counts if modifying
	
			// 0
			#region Volume Geometry (6 floats, 24 bytes)
			public uint _GridResolution;

			// +1
			public float _AllGroupsMaxParticleVolume;
			public float _AllGroupsMaxParticleInterval;
			public float _AllGroupsMaxParticleDiameter;
			public float _AllGroupsAvgParticleDiameter;
			public float _AllGroupsAvgParticleMargin;

			// +5
			public uint _CombinedBoundsIndex;

			// +6
			#endregion

			// 6
			#region Volume Resolve (14 floats, 56 bytes)
			public uint _VolumeFeatures;
			public float _VolumeDT;

			// +2
			public float _TargetDensityScale;
			public float _TargetDensityInfluence;

			// +4
			public float _ScatteringProbeUnitWidth;
			public uint _ScatteringProbeSubsteps;
			public uint _ScatteringProbeSamplesTheta;
			public uint _ScatteringProbeSamplesPhi;
			public float _ScatteringProbeOccluderDensity;
			public float _ScatteringProbeOccluderMargin;

			// +10
			public uint _WindPropagationSubsteps;
			public float _WindPropagationExtinction;
			public float _WindPropagationOccluderDensity;
			public float _WindPropagationOccluderMargin;

			// +14
			#endregion

			// 20 --> 20 (pad to 16 byte boundary)
			//public float _vcbpad1;
			//public float _vcbpad2;
			//public float _vcbpad3;
		}

		[GenerateHLSL, Flags]
		public enum VolumeFeatures
		{
			Scattering			= 1 << 0,
			ScatteringFastpath	= 1 << 1,
			Wind				= 1 << 2,
			WindFastpath		= 1 << 3,
		}

		[GenerateHLSL]
		public enum VolumeLODStage
		{
			Resolve			= 0,
			__COUNT
		}

		[GenerateHLSL]
		public enum VolumeLODDispatch
		{
			Resolve			= 0,
			RasterPoints	= 1,
			RasterVectors	= 2,
			__COUNT
		}

		[GenerateHLSL(needAccessors = false)]
		public struct VolumeLODGrid
		{
			public Vector3 volumeWorldMin;
			public Vector3 volumeWorldMax;
			public Vector3 volumeCellCount;
			public float volumeCellRadius;
		}
	}
}

```

`Runtime/HairSimData.cs.hlsl`:

```hlsl
//
// This file was automatically generated. Please don't edit by hand. Execute Editor command [ Edit > Rendering > Generate Shader Includes ] instead
//

#ifndef HAIRSIMDATA_CS_HLSL
#define HAIRSIMDATA_CS_HLSL
//
// Unity.DemoTeam.Hair.HairSim+VolumeLODDispatch:  static fields
//
#define VOLUMELODDISPATCH_RESOLVE (0)
#define VOLUMELODDISPATCH_RASTER_POINTS (1)
#define VOLUMELODDISPATCH_RASTER_VECTORS (2)
#define VOLUMELODDISPATCH___COUNT (3)

//
// Unity.DemoTeam.Hair.HairSim+StagingVertexFormat:  static fields
//
#define STAGINGVERTEXFORMAT_COMPRESSED (0)
#define STAGINGVERTEXFORMAT_UNCOMPRESSED (1)

//
// Unity.DemoTeam.Hair.HairSim+VolumeLODStage:  static fields
//
#define VOLUMELODSTAGE_RESOLVE (0)
#define VOLUMELODSTAGE___COUNT (1)

//
// Unity.DemoTeam.Hair.HairSim+SolverLODTopology:  static fields
//
#define SOLVERLODTOPOLOGY_INDEXED_LINES (0)
#define SOLVERLODTOPOLOGY_INDEXED_STRIPS (1)
#define SOLVERLODTOPOLOGY_INDEXED_TUBES (2)
#define SOLVERLODTOPOLOGY_INDEXED_INSTANCED_LINES (3)
#define SOLVERLODTOPOLOGY_INDEXED_INSTANCED_STRIPS (4)
#define SOLVERLODTOPOLOGY_INDEXED_INSTANCED_TUBES (5)
#define SOLVERLODTOPOLOGY_XR_INDEXED_LINES (6)
#define SOLVERLODTOPOLOGY_XR_INDEXED_STRIPS (7)
#define SOLVERLODTOPOLOGY_XR_INDEXED_TUBES (8)
#define SOLVERLODTOPOLOGY_XR_INDEXED_INSTANCED_LINES (9)
#define SOLVERLODTOPOLOGY_XR_INDEXED_INSTANCED_STRIPS (10)
#define SOLVERLODTOPOLOGY_XR_INDEXED_INSTANCED_TUBES (11)
#define SOLVERLODTOPOLOGY___COUNT (12)

//
// Unity.DemoTeam.Hair.HairSim+RenderFeatures:  static fields
//
#define RENDERFEATURES_INSTANCING (1)
#define RENDERFEATURES_PER_VERTEX_TEX_COORD (2)
#define RENDERFEATURES_PER_VERTEX_DIAMETER (4)

//
// Unity.DemoTeam.Hair.HairSim+SolverLODSelection:  static fields
//
#define SOLVERLODSELECTION_AUTOMATIC_PER_GROUP (0)
#define SOLVERLODSELECTION_AUTOMATIC_PER_VOLUME (1)
#define SOLVERLODSELECTION_MANUAL (2)

//
// Unity.DemoTeam.Hair.HairSim+SolverLODRange:  static fields
//
#define SOLVERLODRANGE_SOLVE (0)
#define SOLVERLODRANGE_INTERPOLATE (1)
#define SOLVERLODRANGE_INTERPOLATE_ADD (2)
#define SOLVERLODRANGE_INTERPOLATE_PROMOTE (3)
#define SOLVERLODRANGE_RENDER (4)
#define SOLVERLODRANGE_RENDER_ADD (5)
#define SOLVERLODRANGE___COUNT (6)

//
// Unity.DemoTeam.Hair.HairSim+SolverLODStage:  static fields
//
#define SOLVERLODSTAGE_PHYSICS (0)
#define SOLVERLODSTAGE_PHYSICS_PREV (1)
#define SOLVERLODSTAGE_RENDERING (2)
#define SOLVERLODSTAGE___COUNT (3)

//
// Unity.DemoTeam.Hair.HairSim+SolverLODDispatch:  static fields
//
#define SOLVERLODDISPATCH_SOLVE (0)
#define SOLVERLODDISPATCH_SOLVE_GROUP_PARTICLES (1)
#define SOLVERLODDISPATCH_INTERPOLATE (2)
#define SOLVERLODDISPATCH_INTERPOLATE_ADD (3)
#define SOLVERLODDISPATCH_INTERPOLATE_PROMOTE (4)
#define SOLVERLODDISPATCH_STAGING (5)
#define SOLVERLODDISPATCH_STAGING_ADD (6)
#define SOLVERLODDISPATCH_ROOTS (7)
#define SOLVERLODDISPATCH_TRANSFER (8)
#define SOLVERLODDISPATCH_TRANSFER_ALL (9)
#define SOLVERLODDISPATCH_RASTER_POINTS (10)
#define SOLVERLODDISPATCH_RASTER_POINTS_ALL (11)
#define SOLVERLODDISPATCH_RASTER_QUADS (12)
#define SOLVERLODDISPATCH_RASTER_QUADS_ALL (13)
#define SOLVERLODDISPATCH___COUNT (14)

//
// Unity.DemoTeam.Hair.HairSim+VolumeFeatures:  static fields
//
#define VOLUMEFEATURES_SCATTERING (1)
#define VOLUMEFEATURES_SCATTERING_FASTPATH (2)
#define VOLUMEFEATURES_WIND (4)
#define VOLUMEFEATURES_WIND_FASTPATH (8)

//
// Unity.DemoTeam.Hair.HairSim+RenderLODSelection:  static fields
//
#define RENDERLODSELECTION_AUTOMATIC_PER_SEGMENT (0)
#define RENDERLODSELECTION_AUTOMATIC_PER_GROUP (1)
#define RENDERLODSELECTION_AUTOMATIC_PER_VOLUME (2)
#define RENDERLODSELECTION_MATCH_PHYSICS (3)
#define RENDERLODSELECTION_MANUAL (4)

//
// Unity.DemoTeam.Hair.HairSim+SolverFeatures:  static fields
//
#define SOLVERFEATURES_BOUNDARY (1)
#define SOLVERFEATURES_BOUNDARY_FRICTION (2)
#define SOLVERFEATURES_DISTANCE (4)
#define SOLVERFEATURES_DISTANCE_LRA (8)
#define SOLVERFEATURES_DISTANCE_FTL (16)
#define SOLVERFEATURES_CURVATURE_EQ (32)
#define SOLVERFEATURES_CURVATURE_GEQ (64)
#define SOLVERFEATURES_CURVATURE_LEQ (128)
#define SOLVERFEATURES_POSE_LOCAL_SHAPE (256)
#define SOLVERFEATURES_POSE_LOCAL_SHAPE_RWD (512)
#define SOLVERFEATURES_POSE_GLOBAL_POSITION (1024)
#define SOLVERFEATURES_POSE_GLOBAL_ROTATION (2048)

// Generated from Unity.DemoTeam.Hair.HairSim+VolumeCBufferEnvironment
// PackingRules = Exact
CBUFFER_START(VolumeCBufferEnvironment)
    float4 _WorldGravity;
    uint _LODFrustumCount;
    uint _BoundaryDelimDiscrete;
    uint _BoundaryDelimCapsule;
    uint _BoundaryDelimSphere;
    uint _BoundaryDelimTorus;
    uint _BoundaryDelimCube;
    float _BoundaryWorldEpsilon;
    float _BoundaryWorldMargin;
    float _WindEmitterClock;
    uint _WindEmitterCount;
    float _ecbpad1;
    float _ecbpad2;
CBUFFER_END

// Generated from Unity.DemoTeam.Hair.HairSim+VolumeCBuffer
// PackingRules = Exact
CBUFFER_START(VolumeCBuffer)
    uint _GridResolution;
    float _AllGroupsMaxParticleVolume;
    float _AllGroupsMaxParticleInterval;
    float _AllGroupsMaxParticleDiameter;
    float _AllGroupsAvgParticleDiameter;
    float _AllGroupsAvgParticleMargin;
    uint _CombinedBoundsIndex;
    uint _VolumeFeatures;
    float _VolumeDT;
    float _TargetDensityScale;
    float _TargetDensityInfluence;
    float _ScatteringProbeUnitWidth;
    uint _ScatteringProbeSubsteps;
    uint _ScatteringProbeSamplesTheta;
    uint _ScatteringProbeSamplesPhi;
    float _ScatteringProbeOccluderDensity;
    float _ScatteringProbeOccluderMargin;
    uint _WindPropagationSubsteps;
    float _WindPropagationExtinction;
    float _WindPropagationOccluderDensity;
    float _WindPropagationOccluderMargin;
CBUFFER_END

// Generated from Unity.DemoTeam.Hair.HairSim+SolverCBuffer
// PackingRules = Exact
CBUFFER_START(SolverCBuffer)
    uint _StrandCount;
    uint _StrandParticleCount;
    uint _StrandParticleOffset;
    uint _StrandParticleStride;
    uint _LODCount;
    float _GroupScale;
    float _GroupMaxParticleVolume;
    float _GroupMaxParticleInterval;
    float _GroupMaxParticleDiameter;
    float _GroupAvgParticleDiameter;
    float _GroupAvgParticleMargin;
    float _GroupMaxTipScale;
    float _GroupMaxTipScaleOffset;
    uint _GroupBoundsIndex;
    float _GroupBoundsPadding;
    uint _SolverLODMethod;
    float _SolverLODCeiling;
    float _SolverLODScale;
    float _SolverLODBias;
    uint _SolverFeatures;
    float _DT;
    uint _Substeps;
    uint _Iterations;
    float _Stiffness;
    float _SOR;
    float _LinearDamping;
    float _LinearDampingInterval;
    float _AngularDamping;
    float _AngularDampingInterval;
    float _CellPressure;
    float _CellVelocity;
    float _CellExternal;
    float _GravityScale;
    float _BoundaryFriction;
    float _FTLCorrection;
    float _LocalCurvature;
    float _LocalShape;
    float _LocalShapeBias;
    float _GlobalPosition;
    float _GlobalPositionInterval;
    float _GlobalRotation;
    float _GlobalFadeOffset;
    float _GlobalFadeExtent;
    uint _StagingSubdivision;
    uint _StagingVertexFormat;
    uint _StagingVertexStride;
    uint _StagingStrandVertexCount;
    uint _StagingStrandVertexOffset;
    uint _RenderLODMethod;
    float _RenderLODCeiling;
    float _RenderLODScale;
    float _RenderLODBias;
    float _RenderLODClipThreshold;
    uint _RenderFeatures;
    float _scbpad1;
    float _scbpad2;
CBUFFER_END

// Generated from Unity.DemoTeam.Hair.HairSim+SolverCBufferRoots
// PackingRules = Exact
CBUFFER_START(SolverCBufferRoots)
    float4x4 _RootMeshMatrix;
    float4 _RootMeshRotation;
    float4 _RootMeshRotationInv;
    float4 _RootMeshSkinningRotation;
    uint _RootMeshPositionOffset;
    uint _RootMeshPositionStride;
    uint _RootMeshTangentOffset;
    uint _RootMeshTangentStride;
    uint _RootMeshNormalOffset;
    uint _RootMeshNormalStride;
    float _rcbpad1;
    float _rcbpad2;
CBUFFER_END

// Generated from Unity.DemoTeam.Hair.HairSim+VolumeLODGrid
// PackingRules = Exact
struct VolumeLODGrid
{
    float3 volumeWorldMin;
    float3 volumeWorldMax;
    float3 volumeCellCount;
    float volumeCellRadius;
};


#endif

```

`Runtime/HairSimData.cs.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: 9a1e4d8bf55975b49953726f198fb0dd
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimData.cs.meta`:

```meta
fileFormatVersion: 2
guid: 4eff1e005c0dad947923c4bc03996758
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimData.hlsl`:

```hlsl
#ifndef __HAIRSIMDATA_HLSL__
#define __HAIRSIMDATA_HLSL__

#include "HairSimData.cs.hlsl"
#include "HairSim.LOD.cs.hlsl"
	
//-------------
// solver data

#if HAIRSIM_WRITEABLE_SOLVERINPUT
#define HAIRSIM_SOLVERINPUT RWStructuredBuffer
#else
#define HAIRSIM_SOLVERINPUT StructuredBuffer
#endif

#if HAIRSIM_WRITEABLE_SOLVERINIT
#define HAIRSIM_SOLVERINIT RWStructuredBuffer
#else
#define HAIRSIM_SOLVERINIT StructuredBuffer
#endif

#if HAIRSIM_WRITEABLE_SOLVERDATA
#define HAIRSIM_SOLVERDATA RWStructuredBuffer
#else
#define HAIRSIM_SOLVERDATA StructuredBuffer
#endif

#if HAIRSIM_WRITEABLE_SOLVERLOD
#define HAIRSIM_SOLVERLOD RWStructuredBuffer
#define HAIRSIM_SOLVERLODX RWBuffer
#else
#define HAIRSIM_SOLVERLOD StructuredBuffer
#define HAIRSIM_SOLVERLODX Buffer
#endif

#if HAIRSIM_WRITEABLE_SOLVERDATA
#define HAIRSIM_RENDERDATA RWByteAddressBuffer
#else
#define HAIRSIM_RENDERDATA ByteAddressBuffer
#endif

StructuredBuffer<float2> _RootUV;						// xy: root uv
StructuredBuffer<float4> _RootScale;					// xy: root scale (length, diameter normalized to maximum within group), z: tip scale offset, w: tip scale

HAIRSIM_SOLVERINPUT<float4> _RootPositionNext;			// xyz: strand root position, w: -
HAIRSIM_SOLVERINPUT<float4> _RootPositionPrev;			// xyz: ...
HAIRSIM_SOLVERINPUT<float4> _RootPosition;				// xyz: ...
HAIRSIM_SOLVERINPUT<float4> _RootFrameNext;				// quat(xyz,w): strand root material frame where (0,1,0) is tangent to curve
HAIRSIM_SOLVERINPUT<float4> _RootFramePrev;				// quat(xyz,w): ...
HAIRSIM_SOLVERINPUT<float4> _RootFrame;					// quat(xyz,w): ...

HAIRSIM_SOLVERLOD<LODIndices> _SolverLODStage;			// x: lod index lo, y: lod index hi, z: lod blend fraction, w: lod value/quantity
HAIRSIM_SOLVERLOD<uint2> _SolverLODRange;				// xy: dispatch strand range [begin, end)
HAIRSIM_SOLVERLODX<uint> _SolverLODDispatch;			// xyz: dispatch args compute, w: dispatch strand count || xyzw: dispatch args draw
HAIRSIM_SOLVERLODX<uint> _SolverLODTopology;			// x[5]: dispatch args draw indexed

HAIRSIM_SOLVERINIT<float4> _InitialParticleOffset;		// xyz: initial particle offset from strand root, w: initial local accumulated weight (gather)
HAIRSIM_SOLVERINIT<float4> _InitialParticleFrameDelta;	// quat(xyz,w): initial particle material frame delta
HAIRSIM_SOLVERINIT<uint2> _InitialParticleFrameDelta16;	// xy: compressed initial particle material frame delta

HAIRSIM_SOLVERDATA<float3> _ParticlePosition;			// xyz: position
HAIRSIM_SOLVERINIT<float3> _ParticlePositionPrev;		// xyz: ...
HAIRSIM_SOLVERINIT<float3> _ParticlePositionPrevPrev;	// xyz: ...
HAIRSIM_SOLVERDATA<float3> _ParticleVelocity;			// xyz: velocity
HAIRSIM_SOLVERINIT<float3> _ParticleVelocityPrev;		// xyz: ...
HAIRSIM_SOLVERDATA<float3> _ParticleCorrection;			// xyz: ftl distance correction

StructuredBuffer<float2> _ParticleOptTexCoord;			// xy: optional particle uv
StructuredBuffer<float> _ParticleOptDiameter;			// x: optional particle diameter

StructuredBuffer<uint> _LODGuideCount;					// x: lod index -> num. guides
StructuredBuffer<uint> _LODGuideIndex;					// x: lod index * strand count + strand index -> guide index
StructuredBuffer<float> _LODGuideCarry;					// x: lod index * strand count + strand index -> guide carry
StructuredBuffer<float> _LODGuideReach;					// x: lod index * strand count + strand index -> guide reach (approximate cluster extent)

HAIRSIM_RENDERDATA _StagingVertex;						// xyz: position (uncompressed) || xy: position (compressed)
HAIRSIM_RENDERDATA _StagingVertexPrev;					// xyz: ...

//-------------
// volume data

#if HAIRSIM_WRITEABLE_VOLUMESUBSTEP
#define HAIRSIM_VOLUMESUBSTEP RWStructuredBuffer
#else
#define HAIRSIM_VOLUMESUBSTEP StructuredBuffer
#endif

#if HAIRSIM_WRITEABLE_VOLUMEBOUNDS
#define HAIRSIM_VOLUMEBOUNDS RWStructuredBuffer
#else
#define HAIRSIM_VOLUMEBOUNDS StructuredBuffer
#endif

#if HAIRSIM_WRITEABLE_VOLUMELOD
#define HAIRSIM_VOLUMELOD RWStructuredBuffer
#define HAIRSIM_VOLUMELODX RWBuffer
#else
#define HAIRSIM_VOLUMELOD StructuredBuffer
#define HAIRSIM_VOLUMELODX Buffer
#endif

#if SHADER_API_METAL
#define PLATFORM_SUPPORTS_TEXTURE_ATOMICS 0
#else
#define PLATFORM_SUPPORTS_TEXTURE_ATOMICS 1
#endif

#if PLATFORM_SUPPORTS_TEXTURE_ATOMICS
#if HAIRSIM_WRITEABLE_VOLUMEACCU
#define HAIRSIM_VOLUMEACCU RWTexture3D
#else
#define HAIRSIM_VOLUMEACCU Texture3D
#endif
#else
#if HAIRSIM_WRITEABLE_VOLUMEACCU
#define HAIRSIM_VOLUMEACCU RWStructuredBuffer
#else
#define HAIRSIM_VOLUMEACCU StructuredBuffer
#endif
#endif

#if HAIRSIM_WRITEABLE_VOLUMEDATA
#define HAIRSIM_VOLUMEDATA RWTexture3D
#else
#define HAIRSIM_VOLUMEDATA Texture3D
#endif

#if HAIRSIM_WRITEABLE_VOLUMEOPTS
#define HAIRSIM_VOLUMEOPTS RWTexture3D
#else
#define HAIRSIM_VOLUMEOPTS Texture3D
#endif

StructuredBuffer<LODFrustum> _LODFrustum;

HAIRSIM_VOLUMEBOUNDS<uint3> _BoundsMinMaxU;			// xyz: bounds min/max (unsigned sortable)
HAIRSIM_VOLUMEBOUNDS<LODBounds> _Bounds;			// array(LODBounds): bounds (center, extent, radius, reach)
HAIRSIM_VOLUMEBOUNDS<LODBounds> _BoundsPrev;		// array(LODBounds): bounds (center, extent, radius, reach)
HAIRSIM_VOLUMEBOUNDS<LODGeometry> _BoundsGeometry;	// array(LODGeometry): bounds geometry description (dimensions for coverage)
HAIRSIM_VOLUMEBOUNDS<float2> _BoundsCoverage;		// xy: bounds coverage (unbiased ceiling)

HAIRSIM_VOLUMELOD<VolumeLODGrid> _VolumeLODStage;// array(VolumeLODGrid): grid properties
HAIRSIM_VOLUMELODX<uint> _VolumeLODDispatch;		// xyz: num groups, w: num grid cells in one dimension

HAIRSIM_VOLUMEACCU<int> _AccuWeight;				// x: fp accumulated weight
HAIRSIM_VOLUMEACCU<int> _AccuWeight0;				// x: fp accumulated target weight
HAIRSIM_VOLUMEACCU<int> _AccuVelocityX;				// x: fp accumulated x-velocity
HAIRSIM_VOLUMEACCU<int> _AccuVelocityY;				// x: ... ... ... .. y-velocity
HAIRSIM_VOLUMEACCU<int> _AccuVelocityZ;				// x: .. ... ... ... z-velocity

HAIRSIM_VOLUMEDATA<float> _VolumeDensity;			// x: density (cell fraction occupied)
HAIRSIM_VOLUMEDATA<float> _VolumeDensity0;			// x: density target
HAIRSIM_VOLUMEDATA<float4> _VolumeVelocity;			// xyz: velocity, w: accumulated weight

HAIRSIM_VOLUMEDATA<float> _VolumeDivergence;		// x: velocity divergence + source term
HAIRSIM_VOLUMEDATA<float> _VolumePressure;			// x: pressure
HAIRSIM_VOLUMEDATA<float> _VolumePressureNext;		// x: pressure (output of iteration)
HAIRSIM_VOLUMEDATA<float3> _VolumePressureGrad;		// xyz: pressure gradient, w: -

HAIRSIM_VOLUMEOPTS<float4> _VolumeScattering;		// xyzw: L1 spherical harmonic
HAIRSIM_VOLUMEOPTS<float3> _VolumeImpulse;			// xyz: accumulated external forces, w: -

SamplerState _Volume_point_clamp;
SamplerState _Volume_trilinear_clamp;

//-------------------
// volume boundaries

struct BoundaryShape
{
	// shape    |  float3     float      float3     float
	// -------------------------------------------------------
	// discrete |  __pad      __pad      __pad      __pad
	// capsule  |  centerA    radius     centerB    __pad
	// sphere   |  center     radius     __pad      __pad
	// torus    |  center     radiusA    axis       radiusB
	// cube     |  center     rotf16x    extent     rotf16y

	float3 pA; float tA;
	float3 pB; float tB;
};

StructuredBuffer<float4x4> _BoundaryMatrixNext;
StructuredBuffer<float4x4> _BoundaryMatrixPrevA;
StructuredBuffer<float4> _BoundaryMatrixPrevQ;
HAIRSIM_VOLUMESUBSTEP<float4x4> _BoundaryMatrix;
HAIRSIM_VOLUMESUBSTEP<float4x4> _BoundaryMatrixInv;
HAIRSIM_VOLUMESUBSTEP<float4x4> _BoundaryMatrixInvStep;

StructuredBuffer<BoundaryShape>	_BoundaryShapeNext;
StructuredBuffer<int> _BoundaryShapePrevLUT;
HAIRSIM_VOLUMESUBSTEP<BoundaryShape> _BoundaryShapePrev;
HAIRSIM_VOLUMESUBSTEP<BoundaryShape> _BoundaryShape;

Texture3D<float> _BoundarySDF;

//-------------
// volume wind

struct WindEmitter
{
	float3 p;	// emitter origin
	float3 n;	// emitter forward
	float t0;	// emitter base offset
	float h0;	// emitter base radius
	float m;	// emitter slope

	float v;	// flow speed
	float A;	// flow pulse amplitude
	float f;	// flow pulse frequency

	float jd;	// jitter displacement
	float jw;	// jitter resolution
	float jp;	// jitter planar
};

StructuredBuffer<WindEmitter> _WindEmitterNext;
StructuredBuffer<int> _WindEmitterPrevLUT;
HAIRSIM_VOLUMESUBSTEP<WindEmitter> _WindEmitterPrev;
HAIRSIM_VOLUMESUBSTEP<WindEmitter> _WindEmitter;

//---------
// utility

#define UNORM_ENCODING 0
#define UNORM_10_10_10 0

#if UNORM_ENCODING
uint2 EncodePosition(float3 p, float4 pivot)
{
	float3 p_snorm = (p - pivot.xyz) / pivot.w;
	float3 p_unorm = saturate(0.5 * p_snorm + 0.5);
	
	uint3 p_u10 = (p_unorm * 0x003ff);	//             11 1111 1111 = 0x003ff
	uint3 p_u20 = (p_unorm * 0xfffff);	// 1111 1111 1111 1111 1111 = 0xfffff
	uint2 p_enc;
	{
#if UNORM_10_10_10
		// ----------------- u32 -----------------
		// 1111 1111 1111 1111 1111 1111 1111 1111
		//   '---0x3ff--' '---0x3ff--''---0x3ff--'
		
		p_enc.x = (p_u10.x & 0x003ff) | ((p_u10.y & 0x003ff) << 10) | ((p_u10.z & 0x003ff) << 20);
		p_enc.y = 0;
#else
		// ----------------- u32 ----------------- ----------------- u32 -----------------
		// 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111
		//      '--0xff-' '-------0xfffff--------' '----0xfff---' '-------0xfffff--------'

		p_enc.x = (p_u20.x & 0xfffff) | ((p_u20.z & 0x00fff) << 20);
		p_enc.y = (p_u20.y & 0xfffff) | ((p_u20.z & 0xff000) << 8);
#endif
	}
	
	return p_enc;
}

float3 DecodePosition(uint2 p_enc, float4 pivot)
{
#if UNORM_10_10_10
	uint3 p_u10;
	{
		p_u10.x = (p_enc.x & 0x000003ff);
		p_u10.y = (p_enc.x & 0x000ffc00) >> 10;
		p_u10.z = (p_enc.x & 0x3ff00000) >> 20;
	}
#else
	uint3 p_u20;
	{
		p_u20.x = (p_enc.x & 0x000fffff);
		p_u20.y = (p_enc.y & 0x000fffff);
		p_u20.z = ((p_enc.x & 0xfff00000) >> 20) | ((p_enc.y & 0x0ff00000) >> 8);
	}
#endif

#if UNORM_10_10_10
	float3 p_unorm = p_u10 / (float)0x003ff;
#else
	float3 p_unorm = p_u20 / (float)0xfffff;
#endif
	float3 p_snorm = p_unorm * 2.0 - 1.0;
	return p_snorm * pivot.w + pivot.xyz;
}
#else
uint2 EncodePosition(float3 p, float4 pivot)
{
	uint3 p_f16 = f32tof16((p - pivot.xyz) / pivot.w);
	uint2 p_enc = p_f16.xy | (p_f16.z << 16);
	return p_enc;
}

float3 DecodePosition(uint2 p_enc, float4 pivot)
{
	uint3 p_f16 = uint3(p_enc, p_enc.x >> 16);
	float3 p = f16tof32(p_f16) * pivot.w + pivot.xyz;
	return p;
}
#endif

float3 LoadStagingPosition(const uint i, const LODBounds lodBounds)
{
#if UNORM_ENCODING
	const float4 stagingPivot = float4(lodBounds.center, lodBounds.radius);
#else
	const float4 stagingPivot = float4(lodBounds.center, lodBounds.reach);
#endif

	switch (_StagingVertexFormat)
	{
		case STAGINGVERTEXFORMAT_COMPRESSED:
			return DecodePosition(asuint(_StagingVertex.Load2(i * _StagingVertexStride)), stagingPivot);

		case STAGINGVERTEXFORMAT_UNCOMPRESSED:
			return asfloat(_StagingVertex.Load3(i * _StagingVertexStride));

		default:
			return 0;
	}
}

float3 LoadStagingPositionPrev(const uint i, const LODBounds lodBoundsPrev)
{
#if UNORM_ENCODING
	const float4 stagingPivotPrev = float4(lodBoundsPrev.center, lodBoundsPrev.radius);
#else
	const float4 stagingPivotPrev = float4(lodBoundsPrev.center, lodBoundsPrev.reach);
#endif

	switch (_StagingVertexFormat)
	{
		case STAGINGVERTEXFORMAT_COMPRESSED:
			return DecodePosition(asuint(_StagingVertexPrev.Load2(i * _StagingVertexStride)), stagingPivotPrev);

		case STAGINGVERTEXFORMAT_UNCOMPRESSED:
			return asfloat(_StagingVertexPrev.Load3(i * _StagingVertexStride));

		default:
			return 0;
	}
}

void StoreStagingPosition(const uint i, float3 p, const LODBounds lodBounds)
{
#if HAIRSIM_WRITEABLE_SOLVERDATA
#if UNORM_ENCODING
	const float4 stagingPivot = float4(lodBounds.center, lodBounds.radius);
#else
	const float4 stagingPivot = float4(lodBounds.center, lodBounds.reach);
#endif

	switch (_StagingVertexFormat)
	{
		case STAGINGVERTEXFORMAT_COMPRESSED:
			_StagingVertex.Store2(i * _StagingVertexStride, EncodePosition(p, stagingPivot));
			break;

		case STAGINGVERTEXFORMAT_UNCOMPRESSED:
			_StagingVertex.Store3(i * _StagingVertexStride, asuint(p));
			break;
	}
#endif
}

void ResetStagingPositionPrev(const uint i)
{
#if HAIRSIM_WRITEABLE_SOLVERDATA
	switch (_StagingVertexFormat)
	{
		case STAGINGVERTEXFORMAT_COMPRESSED:
			_StagingVertexPrev.Store2(i * _StagingVertexStride, _StagingVertex.Load2(i * _StagingVertexStride));
			break;

		case STAGINGVERTEXFORMAT_UNCOMPRESSED:
			_StagingVertexPrev.Store3(i * _StagingVertexStride, _StagingVertex.Load3(i * _StagingVertexStride));
			break;
	}
#endif
}

#endif//__HAIRSIMDATA_HLSL__

```

`Runtime/HairSimData.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: 586a06104fcd200419a5066fdf042462
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimDebugDraw.cs`:

```cs
#define PREFER_HDRP_CUSTOMPASS

using System;
using UnityEngine;
using UnityEngine.Rendering;

#if HAS_PACKAGE_UNITY_HDRP 
using UnityEngine.Rendering.HighDefinition;
#endif

namespace Unity.DemoTeam.Hair
{
	public static class HairSimDebugDraw
	{
		static bool s_initialized = false;

		static GameObject s_container = null;

#if UNITY_EDITOR
		[UnityEditor.InitializeOnLoadMethod]
#else
		[RuntimeInitializeOnLoadMethod]
#endif
		static void StaticInitialize()
		{
			if (s_initialized == false)
			{
				Camera.onPreRender += HandlePreRender;
				Camera.onPostRender += HandlePostRender;

				RenderPipelineManager.beginCameraRendering += HandleBeginCameraRendering;
				RenderPipelineManager.endCameraRendering += HandleEndCameraRendering;

				s_container = new GameObject(nameof(HairSimDebugDraw));
				s_container.hideFlags = HideFlags.HideAndDontSave;

#if UNITY_EDITOR
				UnityEditor.AssemblyReloadEvents.beforeAssemblyReload += () => CoreUtils.Destroy(s_container);
#endif

#if HAS_PACKAGE_UNITY_HDRP && PREFER_HDRP_CUSTOMPASS
				var customPassVolume = s_container.AddComponent<CustomPassVolume>();
				{
					customPassVolume.AddPassOfType<HairSimDebugDrawCustomPass>();
					customPassVolume.injectionPoint = CustomPassInjectionPoint.AfterPostProcess;
					customPassVolume.isGlobal = true;
				}
#endif

				s_initialized = true;
			}
		}

		struct DebugFrame : IDisposable
		{
			public CommandBuffer cmd;

			public DebugFrame(Camera camera)
			{
				cmd = CommandBufferPool.Get();
				WriteDebugDrawCommands(cmd);
			}

			public void Dispose()
			{
				CommandBufferPool.Release(cmd);
			}

			public static void WriteDebugDrawCommands(CommandBuffer cmd)
			{
				foreach (var hairInstance in HairInstance.s_instances)
				{
					if (hairInstance != null && hairInstance.isActiveAndEnabled)
						hairInstance.DispatchDraw(cmd, CommandBufferExecutionFlags.None);
				}
			}
		}

		static bool SupportedCamera(Camera camera)
		{
			switch (camera.cameraType)
			{
				case CameraType.Game:
				case CameraType.SceneView:
					return true;

				default:
					return false;
			}
		}

		static void HandlePreRender(Camera camera) { }
		static void HandlePostRender(Camera camera)
		{
			if (SupportedCamera(camera))
			{
				using (var debugFrame = new DebugFrame(camera))
				{
					Graphics.ExecuteCommandBuffer(debugFrame.cmd);
				}
			}
		}

		static void HandleBeginCameraRendering(ScriptableRenderContext context, Camera camera) { }
		static void HandleEndCameraRendering(ScriptableRenderContext context, Camera camera)
		{
			if (SupportedCamera(camera))
			{
#if HAS_PACKAGE_UNITY_HDRP && PREFER_HDRP_CUSTOMPASS
				var hdPipeline = RenderPipelineManager.currentPipeline as HDRenderPipeline;
				if (hdPipeline != null)
				{
					return;// prefer HDRP CustomPass, since HDRP doesn't bind depth before calling EndCameraRendering
				}
#endif

				using (var debugFrame = new DebugFrame(camera))
				{
					context.ExecuteCommandBuffer(debugFrame.cmd);
					context.Submit();// submit immediately, since e.g. URP doesn't submit after calling EndCameraRendering
				}
			}
		}

#if HAS_PACKAGE_UNITY_HDRP && PREFER_HDRP_CUSTOMPASS
		public class HairSimDebugDrawCustomPass : CustomPass
		{
			protected override void Setup(ScriptableRenderContext renderContext, CommandBuffer cmd)
			{
				base.name = "HairSimDebugDrawCustomPass";
			}

			protected override void Execute(CustomPassContext context)
			{
				DebugFrame.WriteDebugDrawCommands(context.cmd);
			}
		}
#endif
	}
}

```

`Runtime/HairSimDebugDraw.cs.meta`:

```meta
fileFormatVersion: 2
guid: b438bcc9cdd447f4da0b8151eb0113fa
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimDebugDraw.shader`:

```shader
Shader "Hidden/HairSimDebugDraw"
{
	HLSLINCLUDE

	#pragma target 5.0

	#pragma multi_compile __ VOLUME_TARGET_INITIAL_POSE VOLUME_TARGET_INITIAL_POSE_IN_PARTICLES
	// 0 == uniform target density
	// 1 == non uniform target density

	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
	#include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariables.hlsl"
	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl"

	#include "HairSimData.hlsl"
	#include "HairSimComputeConfig.hlsl"
	#include "HairSimComputeSolverBoundaries.hlsl"
	#include "HairSimComputeSolverQuaternion.hlsl"
	#include "HairSimComputeVolumeUtility.hlsl"
	#include "HairSimComputeVolumeProbe.hlsl"
	#include "HairSimDebugDrawColors.hlsl"

	int _DebugCluster;
	uint _DebugSliceAxis;
	float _DebugSliceOffset;
	float _DebugSliceDivider;
	float _DebugSliceOpacity;
	float _DebugIsosurfaceDensity;
	uint _DebugIsosurfaceSubsteps;

	struct DebugVaryings
	{
		float4 positionCS : SV_POSITION;
		float pointSize : PSIZE;
		float4 color : TEXCOORD0;
	};

	float4 WorldToClip(float3 worldPos)
	{
		return TransformWorldToHClip(worldPos);
	}

	float4 FilterClusters(float4 worldPos, uint strandIndex, in LODIndices lodDesc)
	{
		if (_DebugCluster >= 0)
		{
			int guideIndexLo = _LODGuideIndex[(lodDesc.lodIndexLo * _StrandCount) + strandIndex];
			int guideIndexHi = _LODGuideIndex[(lodDesc.lodIndexHi * _StrandCount) + strandIndex];

			if (guideIndexLo != _DebugCluster && guideIndexHi != _DebugCluster)
			{
				return asfloat(0x7FC00000u);// => NaN
			}
		}

		return worldPos;
	}

	DebugVaryings DebugVert_StrandRootFrame(uint instanceID : SV_InstanceID, uint vertexID : SV_VertexID)
	{
		const LODIndices lodDesc = _SolverLODStage[SOLVERLODSTAGE_PHYSICS];

		const uint strandIndex = instanceID;
		const uint strandParticleBegin = strandIndex * _StrandParticleOffset;
		const uint strandParticleStride = _StrandParticleStride;

		float3 worldPos = _RootPositionNext[strandIndex].xyz;

		float4 rootFrame = _RootFrame[strandIndex];
		float3 rootFrameAxis = float3(
			(vertexID < 2) ? 1.0 : 0.0,
			(vertexID & 2) ? 1.0 : 0.0,
			(vertexID & 4) ? 1.0 : 0.0);

		if (vertexID & 1)
		{
			worldPos += (0.25 * _GroupMaxParticleInterval * _RootScale[strandIndex].x) * QMul(rootFrame, rootFrameAxis);
		}

		DebugVaryings output;
		{
			output.positionCS = FilterClusters(WorldToClip(worldPos), strandIndex, lodDesc);
			output.pointSize = 1.0;
			output.color = float4(rootFrameAxis, 1.0);
		}

		return output;
	}

	DebugVaryings DebugVert_StrandParticlePosition(uint instanceID : SV_InstanceID, uint vertexID : SV_VertexID)
	{
		const LODIndices lodDesc = _SolverLODStage[SOLVERLODSTAGE_PHYSICS];

		const uint strandIndex = instanceID;
		const uint strandParticleBegin = strandIndex * _StrandParticleOffset;
		const uint strandParticleStride = _StrandParticleStride;

		uint i = strandParticleBegin + strandParticleStride * vertexID;
		float3 worldPos = _ParticlePosition[i].xyz;

		DebugVaryings output;
		{
			output.positionCS = FilterClusters(WorldToClip(worldPos), strandIndex, lodDesc);
			output.pointSize = 1.0;
			output.color = float4(ColorCycle(strandIndex, _StrandCount), 1.0);
		}

		return output;
	}

	DebugVaryings DebugVert_StrandParticleVelocity(uint instanceID : SV_InstanceID, uint vertexID : SV_VertexID)
	{
		const LODIndices lodDesc = _SolverLODStage[SOLVERLODSTAGE_PHYSICS];

		const uint strandIndex = instanceID;
		const uint strandParticleBegin = instanceID * _StrandParticleOffset;
		const uint strandParticleStride = _StrandParticleStride;

#if SECOND_ORDER_UPDATE
		uint i = strandParticleBegin + strandParticleStride * (vertexID >> 2);
#else
		uint i = strandParticleBegin + strandParticleStride * (vertexID >> 1);
#endif
		float3 worldPos = _ParticlePosition[i].xyz;

#if SECOND_ORDER_UPDATE
		if (vertexID & 2)
		{
			if (!(vertexID & 1))
			{
				worldPos -= _DT * _ParticleVelocityPrev[i].xyz;
			}
		}
		else
#endif
		{
			if (vertexID & 1)
			{
				worldPos += _DT * _ParticleVelocity[i].xyz;
			}
		}

		DebugVaryings output;
		output.positionCS = FilterClusters(WorldToClip(worldPos), strandIndex, lodDesc);
		output.pointSize = 1.0;
		output.color = float4(0.0, vertexID & 1, vertexID & 2, 1.0);
		return output;

	}

	DebugVaryings DebugVert_StrandParticleClusters(uint instanceID : SV_InstanceID, uint vertexID : SV_VertexID)
	{
		const LODIndices lodDesc = _SolverLODStage[SOLVERLODSTAGE_PHYSICS];

		const uint strandIndex = instanceID;
		const uint strandParticleBegin = strandIndex * _StrandParticleOffset;
		const uint strandParticleStride = _StrandParticleStride;

		uint i = strandParticleBegin + strandParticleStride * (vertexID >> 1);

		uint strandIndexLo = _LODGuideIndex[(lodDesc.lodIndexLo * _StrandCount) + strandIndex];
		uint strandIndexHi = _LODGuideIndex[(lodDesc.lodIndexHi * _StrandCount) + strandIndex];

		const uint strandParticleBeginLo = strandIndexLo * _StrandParticleOffset;
		const uint strandParticleBeginHi = strandIndexHi * _StrandParticleOffset;

		float3 worldPosLo = _ParticlePosition[strandParticleBeginLo + strandParticleStride * (vertexID >> 1)].xyz;
		float3 worldPosHi = _ParticlePosition[strandParticleBeginHi + strandParticleStride * (vertexID >> 1)].xyz;
		float3 worldPos = lerp(worldPosLo, worldPosHi, lodDesc.lodBlendFrac);

		float3 colorLo = ColorCycle(strandIndexLo, _LODGuideCount[_LODCount - 1]);
		float3 colorHi = ColorCycle(strandIndexHi, _LODGuideCount[_LODCount - 1]);
		float3 color = lerp(colorLo, colorHi, lodDesc.lodBlendFrac);

		if (vertexID & 1)
		{
			worldPos = _ParticlePosition[i].xyz;
		}

		DebugVaryings output;
		output.positionCS = FilterClusters(WorldToClip(worldPos), strandIndex, lodDesc);
		output.pointSize = 1.0;
		output.color = float4(color, 1.0);
		return output;
	}

	DebugVaryings DebugVert_VolumeCellDensity(uint vertexID : SV_VertexID)
	{
		const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

		uint3 volumeIdx = VolumeFlatIndexToIndex(vertexID);
		float volumeDensity = _VolumeDensity[volumeIdx];
		float3 worldPos = (volumeDensity == 0.0) ? 1e+7 : VolumeIndexToWorld(lodGrid, volumeIdx);

		DebugVaryings output;
		output.positionCS = WorldToClip(worldPos);
		output.pointSize = 1.0;
		output.color = float4(ColorDensity(volumeDensity), 1.0);
		return output;
	}

	DebugVaryings DebugVert_VolumeCellGradient(uint vertexID : SV_VertexID)
	{
		const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

		uint3 volumeIdx = VolumeFlatIndexToIndex(vertexID >> 1);
		float3 volumeGradient = _VolumePressureGrad[volumeIdx];
		float3 worldPos = VolumeIndexToWorld(lodGrid, volumeIdx);

		if (vertexID & 1)
		{
			worldPos -= volumeGradient;
		}

		DebugVaryings output;
		output.positionCS = WorldToClip(worldPos);
		output.pointSize = 1.0;
		output.color = float4(ColorGradient(volumeGradient), 1.0);
		return output;
	}

	DebugVaryings DebugVert_VolumeSlice(uint vertexID : SV_VertexID)
	{
		const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

		float3 uvw = float3(((vertexID >> 1) ^ vertexID) & 1, vertexID >> 1, _DebugSliceOffset);
		float3 uvwWorld = (_DebugSliceAxis == 0) ? uvw.zxy : (_DebugSliceAxis == 1 ? uvw.xzy : uvw.xyz);
		float3 worldPos = VolumeUVWToWorld(lodGrid, uvwWorld);

		uvw = uvwWorld;

		DebugVaryings output;
		output.positionCS = WorldToClip(worldPos);
		output.pointSize = 1.0;
		output.color = float4(uvw, 1);
		return output;
	}
	
	DebugVaryings DebugVert_VolumeIsosurface(float3 position : POSITION)
	{
		float3 worldPos = TransformObjectToWorld(position);

		DebugVaryings output;
		output.positionCS = WorldToClip(worldPos);
		output.pointSize = 1.0;
		output.color = float4(worldPos, 1);
		return output;
	}

	float4 DebugFrag(DebugVaryings input) : SV_Target
	{
		return input.color;
	}

	float4 DebugFrag_VolumeSlice(DebugVaryings input) : SV_Target
	{
		const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

		float3 uvw = input.color.xyz;

		float3 localPos = VolumeUVWToLocal(lodGrid, uvw);
		float3 localPosFloor = round(localPos + 0.5);

		float3 gridNormal = float3(_DebugSliceAxis == 0, _DebugSliceAxis == 1, _DebugSliceAxis == 2);
		float3 gridAxis = float3(_DebugSliceAxis != 0, _DebugSliceAxis != 1, _DebugSliceAxis != 2);
		float3 gridDist = gridAxis * abs(localPos - localPosFloor);
		float3 gridWidth = gridAxis * fwidth(localPos);

		if (any(gridDist < gridWidth))
		{
			uint i = ((uint)localPosFloor[_DebugSliceAxis]) % 3;
			return float4(0.2 * float3(i == 0, i == 1, i == 2), _DebugSliceOpacity);
		}

		float volumeDensity = VolumeSampleScalar(_VolumeDensity, uvw);
#if VOLUME_TARGET_INITIAL_POSE || VOLUME_TARGET_INITIAL_POSE_IN_PARTICLES
		float volumeDensity0 = VolumeSampleScalar(_VolumeDensity0, uvw);
#else
		float volumeDensity0 = 1.0;
#endif
		float3 volumeVelocity = VolumeSampleVector(_VolumeVelocity, uvw);
		float volumeDivergence = VolumeSampleScalar(_VolumeDivergence, uvw);
		float volumePressure = VolumeSampleScalar(_VolumePressure, uvw);
		float3 volumePressureGrad = VolumeSampleVector(_VolumePressureGrad, uvw);
		float4 volumeThicknessSH = _VolumeScattering.SampleLevel(_Volume_trilinear_clamp, uvw, 0);
		float volumeThickness = DecodeStrandCount(/*gridNormal*/float3(1,0,0), volumeThicknessSH);
		float3 volumeImpulse = VolumeSampleVector(_VolumeImpulse, uvw);

#if 0
		float3 worldPos = VolumeUVWToWorld(lodGrid, uvw);
		float sd = BoundaryDistance(worldPos);
		if (abs(sd) < 0.1)
		{
			float3 sdNormal = 0.5 + 0.5 * BoundaryNormal(worldPos, sd);
			return float4(sdNormal, _DebugSliceOpacity);
		}
		else
		{
			sd *= 10.0;
			if (sd < 0.0)
			{
				return float4(frac(-sd), 0, frac(-sd), _DebugSliceOpacity);
			}
			else
			{
				return float4(0, frac(sd), frac(sd), _DebugSliceOpacity);
			}
		}
#endif

		// test fake level-set
		/*
		if (_DebugSliceDivider == 2.0)
		{
			float3 step = VolumeLocalToUVW(lodGrid, 1.0);
			float d_min = 1e+4;
			float r_max = 0.0;

			for (int i = -1; i <= 1; i++)
			{
				for (int j = -1; j <= 1; j++)
				{
					float3 uvw_xz = float3(
						uvw.x + i * step.x,
						uvw.y,
						uvw.z + j * step.z);

					float vol = abs(VolumeSampleScalar(lodGrid, _VolumeDensity, uvw_xz));
					if (vol > 0.0)
					{
						float vol_d = length(float2(i, j));
						float vol_r = pow((3.0 * vol) / (4.0 * 3.14159), 1.0 / 3.0);

						d_min = min(d_min, vol_d - vol_r);
						r_max = max(r_max, vol_r);
					}
				}
			}

			float4 color_air = float4(0.0, 0.0, 0.0, 1.0);
			float4 color_int = float4(1.0, 0.0, 0.0, 1.0);
			float4 color_ext = float4(1.0, 1.0, 0.0, 1.0);

			return float4(r_max.xxx, 1.0);

			if (d_min == 1e+4)
				return color_air;
			else if (d_min < -0.5)
				return color_int * float4(-d_min.xxx, 1.0);
			else
				return color_ext * float4(1.0 - d_min.xxx, 1.0);
		}
		*/

		float x = uvw.x + _DebugSliceDivider;
		if (x < 1.0)
			return float4(ColorDensity(volumeDensity), _DebugSliceOpacity);
		else if (x < 2.0)
			return float4(float3(1.0, 1.0, 0.0) * ColorDensity(volumeDensity0), _DebugSliceOpacity);
		else if (x < 3.0)
			return float4(ColorVelocity(volumeVelocity), _DebugSliceOpacity);
		else if (x < 4.0)
			return float4(ColorDivergence(volumeDivergence), _DebugSliceOpacity);
		else if (x < 5.0)
			return float4(ColorPressure(volumePressure), _DebugSliceOpacity);
		else if (x < 6.0)
			return float4(ColorGradient(volumePressureGrad), _DebugSliceOpacity);
		else if (x < 7.0)
			return float4(ColorDensity(0.1 * volumeThickness), _DebugSliceOpacity);
		else
			return float4(ColorVelocity(volumeImpulse), _DebugSliceOpacity);
	}

	float4 DebugFrag_VolumeIsosurface(DebugVaryings input) : SV_Target
	{
		const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];

		const float3 worldPos = input.color.xyz;
		const float3 worldPosCamera = -GetCameraRelativePositionWS(float3(0, 0, 0));
		const float3 worldDir = normalize(worldPos - worldPosCamera);

		const int numStepsWithinCell = _DebugIsosurfaceSubsteps;
		const int numSteps = lodGrid.volumeCellCount.x * numStepsWithinCell;

		VolumeTraceState trace = VolumeTraceBegin(lodGrid, worldPos, worldDir, 0.5, numStepsWithinCell);

		float3 accuDensity = 0;

		for (int i = 0; i != numSteps; i++)
		{
			if (VolumeTraceStep(trace))
			{
				float rho = VolumeSampleScalar(_VolumeDensity, trace.uvw);
				if (rho > _DebugIsosurfaceDensity)
				{
					float3 gradDensity = normalize(VolumeSampleScalarGradient(_VolumeDensity, trace.uvw));
					return float4(0.5 * gradDensity + 0.5, 1.0);
				}

				accuDensity.r += rho;
			}
			else
			{
				accuDensity.g = 1.0 - (i + 1.0) / numSteps;
				break;
			}
		}

		return float4(saturate(accuDensity), 0.5);
	}

	ENDHLSL

	SubShader
	{
		Cull Off
		ZTest LEqual
		ZWrite On

		Pass// 0 == STRAND ROOT FRAME
		{
			HLSLPROGRAM

			#pragma vertex DebugVert_StrandRootFrame
			#pragma fragment DebugFrag

			ENDHLSL
		}

		Pass// 1 == STRAND PARTICLE POSITION
		{
			HLSLPROGRAM

			#pragma vertex DebugVert_StrandParticlePosition
			#pragma fragment DebugFrag

			ENDHLSL
		}

		Pass// 1 == STRAND PARTICLE VELOCITY
		{
			HLSLPROGRAM

			#pragma vertex DebugVert_StrandParticleVelocity
			#pragma fragment DebugFrag

			ENDHLSL
		}

		Pass// 7 == STRAND PARTICLE CLUSTERS
		{
			HLSLPROGRAM

			#pragma vertex DebugVert_StrandParticleClusters
			#pragma fragment DebugFrag

			ENDHLSL
		}

		Pass// 2 == VOLUME CELL DENSITY
		{
			HLSLPROGRAM

			#pragma vertex DebugVert_VolumeCellDensity
			#pragma fragment DebugFrag

			ENDHLSL
		}

		Pass// 3 == VOLUME CELL GRADIENT
		{
			HLSLPROGRAM

			#pragma vertex DebugVert_VolumeCellGradient
			#pragma fragment DebugFrag

			ENDHLSL
		}

		Pass// 4 == VOLUME SLICE (ABOVE)
		{
			Blend SrcAlpha OneMinusSrcAlpha

			HLSLPROGRAM

			#pragma vertex DebugVert_VolumeSlice
			#pragma fragment DebugFrag_VolumeSlice

			ENDHLSL
		}

		Pass// 5 == VOLUME SLICE (BELOW)
		{
			Blend SrcAlpha OneMinusSrcAlpha
			ZTest Greater
			ZWrite Off

			HLSLPROGRAM

			#pragma vertex DebugVert_VolumeSlice
			#pragma fragment DebugFrag_VolumeSlice

			ENDHLSL
		}

		Pass// 6 == VOLUME ISOSURFACE
		{
			Blend SrcAlpha OneMinusSrcAlpha
			Cull Back
			ZTest Always
			ZWrite Off

			HLSLPROGRAM

			#pragma vertex DebugVert_VolumeIsosurface
			#pragma fragment DebugFrag_VolumeIsosurface

			ENDHLSL
		}
	}
}

```

`Runtime/HairSimDebugDraw.shader.meta`:

```meta
fileFormatVersion: 2
guid: f84628556e79514499da79fa2a82f427
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimDebugDrawColors.hlsl`:

```hlsl
#ifndef __HAIRSIMDEBUGDRAWCOLORS_HLSL__
#define __HAIRSIMDEBUGDRAWCOLORS_HLSL__

//----------------
// colors generic

float3 ColorCycle(uint index, uint count)
{
	float t = frac(index / (float)count);

	// source: https://www.shadertoy.com/view/4ttfRn
	float3 c = 3.0 * float3(abs(t - 0.5), t.xx) - float3(1.5, 1.0, 2.0);
	return 1.0 - c * c;
}

float3 ColorRamp(uint index, uint count)
{
	float t = 1.0 - frac(index / (float)count);

	// source: https://www.shadertoy.com/view/4ttfRn
	float3 c = 2.0 * t - float3(0.0, 1.0, 2.0);
	return 1.0 - c * c;
}

//-------------------
// colors quantities

float3 ColorDensity(float rho)
{
	float above = saturate(rho - 1.0);
	return float3(saturate(rho), saturate(rho) - above, saturate(rho) - above);
}

float3 ColorDivergence(float div)
{
	if (div < 0.0)// inward flux increases pressure
		return saturate(abs(float3(div, div, 0.0)));
	else
		return saturate(abs(float3(0.0, div, div)));
}

float3 ColorPressure(float p)
{
	p *= 15.0;
	if (p > 0.0)
		return saturate(float3(frac(p), 0.0, 0.0));
	else
		return saturate(float3(0.0, 0.0, frac(-p)));
}

float3 ColorGradient(float3 n)
{
	//return abs(n.zzz);

	float d = dot(n, n);
	if (d > 1e-11)
		return 0.5 + 0.5 * (n * rsqrt(d));
	else
		return 0.0;

	//return (0.5 + 0.5 * normalize(n.xzy));
}

float3 ColorVelocity(float3 v)
{
	return saturate(abs(float3(v.x, 0.0, -v.z)));
}

float3 ColorProbe(float3 s)
{
	return s;
}

#endif//__HAIRSIMDEBUGDRAWCOLORS_HLSL__

```

`Runtime/HairSimDebugDrawColors.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: 05fa9cd3998dca44f8e4746bb2093f0f
ShaderImporter:
  externalObjects: {}
  defaultTextures: []
  nonModifiableTextures: []
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairSimUtility.cs`:

```cs
using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Experimental.Rendering;
using Unity.Collections;

namespace Unity.DemoTeam.Hair
{
	public static class HairSimUtility
	{
		//---------------
		// cpu resources

		public static bool CreateCPUBuffer<T>(ref NativeArray<T> buffer, int count, Allocator allocator, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory) where T : unmanaged
		{
			if (buffer.IsCreated && buffer.Length == count)
				return false;

			if (buffer.IsCreated)
				buffer.Dispose();

			buffer = new NativeArray<T>(count, allocator, options);
			return true;
		}

		public static void ReleaseCPUBuffer<T>(ref NativeArray<T> buffer) where T : unmanaged
		{
			if (buffer.IsCreated)
				buffer.Dispose();
		}

		//---------------
		// gpu resources

		static GraphicsBuffer.Target TranslateComputeBufferType(ComputeBufferType type)
		{
			if (type == ComputeBufferType.Default)
			{
				return GraphicsBuffer.Target.Structured;
			}
			else
			{
				var mask = (GraphicsBuffer.Target)0;
				{
					if (type.HasFlag(ComputeBufferType.Raw))
						mask |= GraphicsBuffer.Target.Raw;
					if (type.HasFlag(ComputeBufferType.Append))
						mask |= GraphicsBuffer.Target.Append;
					if (type.HasFlag(ComputeBufferType.Counter))
						mask |= GraphicsBuffer.Target.Counter;
					if (type.HasFlag(ComputeBufferType.Constant))
						mask |= GraphicsBuffer.Target.Constant;
					if (type.HasFlag(ComputeBufferType.Structured))
						mask |= GraphicsBuffer.Target.Structured;
					if (type.HasFlag(ComputeBufferType.IndirectArguments))
						mask |= GraphicsBuffer.Target.IndirectArguments;
				}
				return mask;
			}
		}

		public static bool CreateBuffer<T>(ref ComputeBuffer buffer, string name, int count, ComputeBufferType type = ComputeBufferType.Default) where T : unmanaged
		{
			unsafe
			{
				return CreateBuffer(ref buffer, name, count, sizeof(T), type);
			}
		}

		public static bool CreateBuffer<T>(ref GraphicsBuffer buffer, string name, int count, ComputeBufferType type = ComputeBufferType.Default) where T : unmanaged
		{
			unsafe
			{
				return CreateBuffer(ref buffer, name, count, sizeof(T), type);
			}
		}

		public static bool CreateBuffer(ref ComputeBuffer buffer, string name, int count, int stride, ComputeBufferType type = ComputeBufferType.Default)
		{
			if (buffer != null && buffer.count == count && buffer.stride == stride && buffer.IsValid())
				return false;

			if (buffer != null)
				buffer.Release();

			buffer = new ComputeBuffer(count > 0 ? count : 1, stride, type);
			buffer.name = name;
			return true;
		}

		public static bool CreateBuffer(ref GraphicsBuffer buffer, string name, int count, int stride, ComputeBufferType type = ComputeBufferType.Default)
		{
			if (buffer != null && buffer.count == count && buffer.stride == stride && buffer.IsValid())
				return false;

			if (buffer != null)
				buffer.Release();

			buffer = new GraphicsBuffer(TranslateComputeBufferType(type), count > 0 ? count : 1, stride);
#if UNITY_2021_2_OR_NEWER
			buffer.name = name;
#endif
			return true;
		}

		public static void ReleaseBuffer(ref ComputeBuffer buffer)
		{
			if (buffer != null)
			{
				buffer.Release();
				buffer = null;
			}
		}

		public static void ReleaseBuffer(ref GraphicsBuffer buffer)
		{
			if (buffer != null)
			{
				buffer.Release();
				buffer = null;
			}
		}

		public static bool CreateReadbackBuffer(ref AsyncReadbackBuffer bufferReadback, in ComputeBuffer buffer)
		{
			var ret = CreateCPUBuffer(ref bufferReadback.buffer, buffer.count * buffer.stride, Allocator.Persistent);
			if (ret)
			{
				//Debug.Log("created readback buffer w/ length " + (buffer.count * buffer.stride) + " for buffer " + buffer.ToString());
			}
			return ret;
		}

		public static bool CreateReadbackBuffer(ref AsyncReadbackBuffer bufferReadback, in GraphicsBuffer buffer)
		{
			var ret = CreateCPUBuffer(ref bufferReadback.buffer, buffer.count * buffer.stride, Allocator.Persistent);
			if (ret)
			{
				//Debug.Log("created readback buffer w/ length " + (buffer.count * buffer.stride) + " for buffer " + buffer.ToString());
			}
			return ret;
		}

		public static void ReleaseReadbackBuffer(ref AsyncReadbackBuffer bufferReadback)
		{
			ReleaseCPUBuffer(ref bufferReadback.buffer);
		}

		public static RenderTextureDescriptor MakeVolumeDesc(int cellCount, RenderTextureFormat cellFormat)
		{
			return new RenderTextureDescriptor()
			{
				dimension = TextureDimension.Tex3D,
				width = cellCount,
				height = cellCount,
				volumeDepth = cellCount,
				colorFormat = cellFormat,
				enableRandomWrite = true,
				msaaSamples = 1,
			};
		}

		public static RenderTextureDescriptor MakeVolumeDesc(int cellCount, GraphicsFormat cellFormat)
		{
			return new RenderTextureDescriptor()
			{
				dimension = TextureDimension.Tex3D,
				width = cellCount,
				height = cellCount,
				volumeDepth = cellCount,
				graphicsFormat = cellFormat,
				enableRandomWrite = true,
				msaaSamples = 1,
			};
		}

		public static bool CreateVolume(ref Texture volume, string name, int cellCount, RenderTextureFormat cellFormat)
		{
			var volumeRT = volume as RenderTexture;
			if (volumeRT != null && volumeRT.width == cellCount && volumeRT.format == cellFormat)
				return false;

			if (volumeRT != null)
				volumeRT.Release();

			//Debug.Log("creating volume " + name);
			volumeRT = new RenderTexture(MakeVolumeDesc(cellCount, cellFormat));
			volumeRT.wrapMode = TextureWrapMode.Clamp;
			volumeRT.hideFlags = HideFlags.HideAndDontSave;
			volumeRT.name = name;
			volumeRT.Create();
			volume = volumeRT;
			return true;
		}

		public static bool CreateVolume(ref Texture volume, string name, int cellCount, GraphicsFormat cellFormat)
		{
			var volumeRT = volume as RenderTexture;
			if (volumeRT != null && volumeRT.width == cellCount && volumeRT.graphicsFormat == cellFormat)
				return false;

			if (volumeRT != null)
				volumeRT.Release();

			//Debug.Log("creating volume " + name);
			volumeRT = new RenderTexture(MakeVolumeDesc(cellCount, cellFormat));
			volumeRT.wrapMode = TextureWrapMode.Clamp;
			volumeRT.hideFlags = HideFlags.HideAndDontSave;
			volumeRT.name = name;
			volumeRT.Create();
			volume = volumeRT;
			return true;
		}

		public static void ReleaseVolume(ref Texture volume)
		{
			var volumeRT = volume as RenderTexture;
			if (volumeRT != null)
			{
				volumeRT.Release();
				volume = null;
			}
		}

		//----------
		// gpu data

		public static void PushComputeBufferData(CommandBuffer cmd, in ComputeBuffer buffer, in Array bufferData)
		{
#if UNITY_2021_1_OR_NEWER
			cmd.SetBufferData(buffer, bufferData);
#else
			cmd.SetComputeBufferData(buffer, bufferData);
#endif
		}

		public static void PushComputeBufferData(CommandBuffer cmd, in GraphicsBuffer buffer, in Array bufferData)
		{
#if UNITY_2021_1_OR_NEWER
			cmd.SetBufferData(buffer, bufferData);
#else
			Debug.LogError("PushComputeBufferData(cmd, GraphicsBuffer) requres 2021.1+");
#endif
		}

		public static void PushComputeBufferData<T>(CommandBuffer cmd, in ComputeBuffer buffer, in NativeArray<T> bufferData) where T : struct
		{
#if UNITY_2021_1_OR_NEWER
			cmd.SetBufferData(buffer, bufferData);
#else
			cmd.SetComputeBufferData(buffer, bufferData);
#endif
		}

		public static void PushComputeBufferData<T>(CommandBuffer cmd, in GraphicsBuffer buffer, in NativeArray<T> bufferData) where T : struct
		{
#if UNITY_2021_1_OR_NEWER
			cmd.SetBufferData(buffer, bufferData);
#else
			Debug.LogError("PushComputeBufferData(cmd, GraphicsBuffer) requres 2021.1+");
#endif
		}

		public static void PushConstantBufferData<T>(CommandBuffer cmd, in ComputeBuffer cbuffer, in T cbufferData) where T : struct
		{
			var cbufferStaging = new NativeArray<T>(1, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
			{
				cbufferStaging[0] = cbufferData;
#if UNITY_2021_1_OR_NEWER
				cmd.SetBufferData(cbuffer, cbufferStaging);
#else
				cmd.SetComputeBufferData(cbuffer, cbufferStaging);
#endif
				cbufferStaging.Dispose();
			}
		}

		public static void PushConstantBufferData<T>(CommandBuffer cmd, in GraphicsBuffer cbuffer, in T cbufferData) where T : struct
		{
			var cbufferStaging = new NativeArray<T>(1, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
			{
				cbufferStaging[0] = cbufferData;
#if UNITY_2021_1_OR_NEWER
				cmd.SetBufferData(cbuffer, cbufferStaging);
#else
				Debug.LogError("PushComputeBufferData(cmd, GraphicsBuffer) requres 2021.1+");
#endif
				cbufferStaging.Dispose();
			}
		}

		public struct BufferUploadContext : IDisposable
		{
			CommandBuffer cmd;
			GraphicsFence cmdFence;

			bool asyncExecution;
			bool asyncUpload;
			bool asyncWait;

			public BufferUploadContext(CommandBuffer cmd, CommandBufferExecutionFlags cmdFlags)
			{
				this.cmd = cmd;

				asyncExecution = cmdFlags.HasFlag(CommandBufferExecutionFlags.AsyncCompute);
				asyncUpload = asyncExecution && (SystemInfo.supportsGraphicsFence == false);
				asyncWait = asyncExecution && (asyncUpload == false);

				if (asyncWait)
					cmdFence = Graphics.CreateGraphicsFence(GraphicsFenceType.AsyncQueueSynchronisation, SynchronisationStageFlags.AllGPUOperations);
				else
					cmdFence = new GraphicsFence();
			}

			public void SetData(ComputeBuffer buffer, Array data)
			{
				if (asyncUpload)
					PushComputeBufferData(cmd, buffer, data);
				else
					buffer.SetData(data);
			}

			public void SetData(GraphicsBuffer buffer, Array data)
			{
				if (asyncUpload)
					PushComputeBufferData(cmd, buffer, data);
				else
					buffer.SetData(data);
			}

			public void SetData<T>(ComputeBuffer buffer, in NativeArray<T> data) where T : struct
			{
				if (asyncUpload)
					PushComputeBufferData(cmd, buffer, data);
				else
					buffer.SetData(data);
			}

			public void SetData<T>(GraphicsBuffer buffer, in NativeArray<T> data) where T : struct
			{
				if (asyncUpload)
					PushComputeBufferData(cmd, buffer, data);
				else
					buffer.SetData(data);
			}

			public void Dispose()
			{
				if (asyncWait)
					cmd.WaitOnAsyncGraphicsFence(cmdFence);
			}
		}

		//------------------
		// gpu bind targets

		public interface IBindTarget
		{
			void BindConstantBuffer(int nameID, ComputeBuffer cbuffer);
			void BindConstantBuffer(int nameID, GraphicsBuffer cbuffer);
			void BindComputeBuffer(int nameID, ComputeBuffer buffer);
			void BindComputeBuffer(int nameID, GraphicsBuffer buffer);
			void BindComputeTexture(int nameID, Texture texture);
			void BindKeyword(string name, bool value);
		}

		public struct BindTargetCompute : IBindTarget
		{
			public ComputeShader cs;
			public int kernel;

			public BindTargetCompute(ComputeShader cs, int kernel)
			{
				this.cs = cs;
				this.kernel = kernel;
			}

			public void BindConstantBuffer(int nameID, ComputeBuffer cbuffer) => cs.SetConstantBuffer(nameID, cbuffer, 0, cbuffer.stride);
			public void BindConstantBuffer(int nameID, GraphicsBuffer cbuffer) => cs.SetConstantBuffer(nameID, cbuffer, 0, cbuffer.stride);
			public void BindComputeBuffer(int nameID, ComputeBuffer buffer) => cs.SetBuffer(kernel, nameID, buffer);
			public void BindComputeBuffer(int nameID, GraphicsBuffer buffer) => cs.SetBuffer(kernel, nameID, buffer);
			public void BindComputeTexture(int nameID, Texture texture) => cs.SetTexture(kernel, nameID, texture);
			public void BindKeyword(string name, bool value) => CoreUtils.SetKeyword(cs, name, value);
		}

		public struct BindTargetComputeCmd : IBindTarget
		{
			public CommandBuffer cmd;
			public ComputeShader cs;
			public int kernel;

			public BindTargetComputeCmd(CommandBuffer cmd, ComputeShader cs, int kernel)
			{
				this.cmd = cmd;
				this.cs = cs;
				this.kernel = kernel;
			}

			public void BindConstantBuffer(int nameID, ComputeBuffer cbuffer) => cmd.SetComputeConstantBufferParam(cs, nameID, cbuffer, 0, cbuffer.stride);
			public void BindConstantBuffer(int nameID, GraphicsBuffer cbuffer) => cmd.SetComputeConstantBufferParam(cs, nameID, cbuffer, 0, cbuffer.stride);
			public void BindComputeBuffer(int nameID, ComputeBuffer buffer) => cmd.SetComputeBufferParam(cs, kernel, nameID, buffer);
			public void BindComputeBuffer(int nameID, GraphicsBuffer buffer) => cmd.SetComputeBufferParam(cs, kernel, nameID, buffer);
			public void BindComputeTexture(int nameID, Texture texture) => cmd.SetComputeTextureParam(cs, kernel, nameID, texture);
			public void BindKeyword(string name, bool value) => CoreUtils.SetKeyword(cmd, name, value);
		}

		public struct BindTargetGlobal : IBindTarget
		{
			public void BindConstantBuffer(int nameID, ComputeBuffer cbuffer) => Shader.SetGlobalConstantBuffer(nameID, cbuffer, 0, cbuffer.stride);
			public void BindConstantBuffer(int nameID, GraphicsBuffer cbuffer) => Shader.SetGlobalConstantBuffer(nameID, cbuffer, 0, cbuffer.stride);
			public void BindComputeBuffer(int nameID, ComputeBuffer buffer) => Shader.SetGlobalBuffer(nameID, buffer);
			public void BindComputeBuffer(int nameID, GraphicsBuffer buffer) => Shader.SetGlobalBuffer(nameID, buffer);
			public void BindComputeTexture(int nameID, Texture texture) => Shader.SetGlobalTexture(nameID, texture);
			public void BindKeyword(string name, bool value)
			{
				if (value)
					Shader.EnableKeyword(name);
				else
					Shader.DisableKeyword(name);
			}
		}

		public struct BindTargetGlobalCmd : IBindTarget
		{
			public CommandBuffer cmd;

			public BindTargetGlobalCmd(CommandBuffer cmd)
			{
				this.cmd = cmd;
			}

			public void BindConstantBuffer(int nameID, ComputeBuffer cbuffer) => cmd.SetGlobalConstantBuffer(cbuffer, nameID, 0, cbuffer.stride);
			public void BindConstantBuffer(int nameID, GraphicsBuffer cbuffer) => cmd.SetGlobalConstantBuffer(cbuffer, nameID, 0, cbuffer.stride);
			public void BindComputeBuffer(int nameID, ComputeBuffer buffer) => cmd.SetGlobalBuffer(nameID, buffer);
			public void BindComputeBuffer(int nameID, GraphicsBuffer buffer) => cmd.SetGlobalBuffer(nameID, buffer);
			public void BindComputeTexture(int nameID, Texture texture) => cmd.SetGlobalTexture(nameID, texture);
			public void BindKeyword(string name, bool value) => CoreUtils.SetKeyword(cmd, name, value);
		}

		public struct BindTargetMaterial : IBindTarget
		{
			public Material mat;

			public BindTargetMaterial(Material mat)
			{
				this.mat = mat;
			}

			public void BindConstantBuffer(int nameID, ComputeBuffer cbuffer) => mat.SetConstantBuffer(nameID, cbuffer, 0, cbuffer.stride);
			public void BindConstantBuffer(int nameID, GraphicsBuffer cbuffer) => mat.SetConstantBuffer(nameID, cbuffer, 0, cbuffer.stride);
			public void BindComputeBuffer(int nameID, ComputeBuffer buffer) => mat.SetBuffer(nameID, buffer);
			public void BindComputeBuffer(int nameID, GraphicsBuffer buffer) => mat.SetBuffer(nameID, buffer);
			public void BindComputeTexture(int nameID, Texture texture) => mat.SetTexture(nameID, texture);
			public void BindKeyword(string name, bool value) => CoreUtils.SetKeyword(mat, name, value);
		}

		//--------------
		// gpu readback

		public struct AsyncReadbackBuffer
		{
			public NativeArray<byte> buffer;

			private void Callback(AsyncGPUReadbackRequest request)
			{
				//Debug.Log("callback with request.done = " + request.done + ", request.hasError " + request.hasError);
				if (request.done && request.hasError == false)
				{
					var data = request.GetData<byte>();
					if (data.IsCreated && buffer.IsCreated)
					{
						data.CopyTo(buffer);
					}
				}
			}

			public void ScheduleCopy(CommandBuffer cmd, ComputeBuffer buffer)
			{
				cmd.RequestAsyncReadback(buffer, Callback);
			}

			public void ScheduleCopy(CommandBuffer cmd, GraphicsBuffer buffer)
			{
				cmd.RequestAsyncReadback(buffer, Callback);
			}

			public void Sync()
			{
				AsyncGPUReadback.WaitAllRequests();
			}

			public NativeArray<T> GetData<T>(bool forceSync = false) where T : struct
			{
				if (forceSync)
				{
					Sync();
				}

				return buffer.Reinterpret<T>(sizeof(byte));
			}
		}

		//--------------
		// gpu commands

		public struct ScopedCommandBuffer : IDisposable
		{
			public CommandBuffer cmd;
			public void Dispose() => CommandBufferPool.Release(cmd);
			public static ScopedCommandBuffer Get() => new ScopedCommandBuffer { cmd = CommandBufferPool.Get() };
			public static implicit operator CommandBuffer(ScopedCommandBuffer scmd) => scmd.cmd;
		}

		//------------
		// reflection

		public static void InitializeStaticFields<T>(Type type, Func<string, T> construct)
		{
			foreach (var field in type.GetFields())
			{
				field.SetValue(null, construct(field.Name));
			}
		}

		public static void InitializeStructFields<TStruct, T>(ref TStruct data, Func<string, T> construct) where TStruct : struct
		{
			Type type = typeof(TStruct);
			var boxed = (object)data;
			foreach (var field in type.GetFields())
			{
				field.SetValue(boxed, construct(field.Name));
			}
			data = (TStruct)boxed;
		}

		public static void EnumerateFields(Type type, Action<int, System.Reflection.FieldInfo> visit)
		{
			var fields = type.GetFields();
			for (int i = 0; i != fields.Length; i++)
			{
				visit(i, fields[i]);
			}
		}
	}
}

```

`Runtime/HairSimUtility.cs.meta`:

```meta
fileFormatVersion: 2
guid: 349327557b2fe17418a24aa8750ecefd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairTopologyCache.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.DemoTeam.Hair
{
	public enum HairTopologyType
	{
		Lines	= 0,
		Strips	= 1,
		Tubes	= 2,
	}

	[Serializable]
	public struct HairTopologyDesc
	{
		public HairTopologyType type;
		public int strandCount;
		public int strandParticleCount;
		public HairAsset.MemoryLayout memoryLayout;
	}

	public static class HairTopologyCache
	{
		const int DELAY_UNUSED = 10;

		static bool s_initialized = false;

		static Dictionary<ulong, Mesh> s_keyToMesh = null;
		static Dictionary<ulong, int> s_keyToUsage = null;

		static HairTopologyCache()
		{
			if (s_initialized == false)
			{
				s_keyToMesh = new Dictionary<ulong, Mesh>();
				s_keyToUsage = new Dictionary<ulong, int>();

#if UNITY_EDITOR
				UnityEditor.AssemblyReloadEvents.beforeAssemblyReload += () => DestroyAll();
#endif

				s_initialized = true;
			}
		}

		public static ulong GetSortKey(in HairTopologyDesc desc)
		{
			var a = (ulong)desc.strandCount;
			var b = (ulong)desc.strandParticleCount;
			var c = (ulong)desc.memoryLayout;
			var d = (ulong)desc.type;
			{
				// [ dddd cccc | bbbb bbbb | aaaa aaaa | aaaa aaaa ]
				return (d << 56) | (c << 48) | (b << 32) | a;
			}
		}

		public static Mesh GetSharedMesh(in HairTopologyDesc desc)
		{
			var key = GetSortKey(desc);

			if (s_keyToMesh.TryGetValue(key, out var mesh))
			{
				s_keyToUsage[key] = 1;
			}
			else
			{
				//Debug.Log("f " + Time.frameCount + " create mesh (strandCount " + desc.strandCount + ")");
				switch (desc.type)
				{
					case HairTopologyType.Lines:
						mesh = HairInstanceBuilder.CreateRenderMeshLines(HideFlags.HideAndDontSave, desc.memoryLayout, desc.strandCount, desc.strandParticleCount, new Bounds());
						break;

					case HairTopologyType.Strips:
						mesh = HairInstanceBuilder.CreateRenderMeshStrips(HideFlags.HideAndDontSave, desc.memoryLayout, desc.strandCount, desc.strandParticleCount, new Bounds());
						break;

					case HairTopologyType.Tubes:
						mesh = HairInstanceBuilder.CreateRenderMeshTubes(HideFlags.HideAndDontSave, desc.memoryLayout, desc.strandCount, desc.strandParticleCount, new Bounds());
						break;
				}

#if UNITY_EDITOR
				mesh.UploadMeshData(markNoLongerReadable: true);
#else
				mesh.UploadMeshData(markNoLongerReadable: false);//TODO builds should use markNoLongerReadable again when crash has been fixed
#endif

				s_keyToMesh[key] = mesh;
				s_keyToUsage[key] = 1;
			}

			return mesh;
		}

		static void DestroyAll()
		{
			foreach (var pair in s_keyToMesh)
			{
				//Debug.Log("f " + Time.frameCount + " delete mesh (strandCount " + (pair.Key & 0xffffffff) + ") (ALL)");
				CoreUtils.Destroy(pair.Value);
			}

			s_keyToMesh.Clear();
			s_keyToUsage.Clear();
		}

		static void DestroyUnused()
		{
			// decay references
			using (var decayKeys = new UnsafeList<ulong>(s_keyToUsage.Count, Allocator.Temp))
			{
				foreach (var key in s_keyToUsage.Keys)
				{
					decayKeys.Add(key);
				}

				foreach (var key in decayKeys)
				{
					s_keyToUsage[key]--;
				}
			}

			// find and destroy unused
#if HAS_PACKAGE_UNITY_COLLECTIONS_1_3_0
			using (var removeKeys = new UnsafeParallelHashSet<ulong>(s_keyToMesh.Count, Allocator.Temp))
#else
			using (var removeKeys = new UnsafeHashSet<ulong>(s_keyToMesh.Count, Allocator.Temp))
#endif
			{
				foreach (var pair in s_keyToMesh)
				{
					if (pair.Value == null)
					{
						removeKeys.Add(pair.Key);
					}
				}

				foreach (var pair in s_keyToUsage)
				{
					if (pair.Value + DELAY_UNUSED < 0)
					{
						removeKeys.Add(pair.Key);
					}
				}

				foreach (var key in removeKeys)
				{
					if (s_keyToMesh.TryGetValue(key, out var mesh))
					{
						if (mesh != null)
						{
							//Debug.Log("f " + Time.frameCount + " delete mesh (strandCount " + (key & 0xffffffff) + ") (expire)");
							CoreUtils.Destroy(mesh);
						}
					}

					s_keyToMesh.Remove(key);
					s_keyToUsage.Remove(key);
				}
			}
		}

		[ExecuteAlways]
		class DestroyUnusedPerFrame : MonoBehaviour
		{
			static bool s_initialized = false;

			static GameObject s_container = null;

#if UNITY_EDITOR
			[UnityEditor.InitializeOnLoadMethod]
#else
			[RuntimeInitializeOnLoadMethod]
#endif
			static void StaticInitialize()
			{
				if (s_initialized == false)
				{
					s_container = new GameObject(nameof(HairTopologyCache));
					s_container.hideFlags = HideFlags.HideAndDontSave;
					s_container.AddComponent<DestroyUnusedPerFrame>();

#if UNITY_EDITOR
					UnityEditor.AssemblyReloadEvents.beforeAssemblyReload += () => CoreUtils.Destroy(s_container);
#endif

					s_initialized = true;
				}
			}

			void Update()
			{
				HairTopologyCache.DestroyUnused();
			}
		}
	}
}

```

`Runtime/HairTopologyCache.cs.meta`:

```meta
fileFormatVersion: 2
guid: 8f8a181c56f6132438abae87f6024eb9
```

`Runtime/HairTopologyPrefetch.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	//TODO either add something like this or a more automatic build-time approach
	/*
	public class HairTopologyPrefetch : MonoBehaviour
	{
		public bool onAwake = true;
		public bool onUpdate = true;

		public HairTopologyDesc[] descriptions;

		void Fetch(bool cond) { if (cond) Fetch(); }
		void Fetch()
		{
			if (descriptions != null)
				return;

			for (int i = 0; i != descriptions.Length; i++)
			{
				var mesh = HairTopologyCache.GetSharedMesh(descriptions[i]);
			}
		}

		void Awake() => Fetch(onAwake);
		void Update() => Fetch(onUpdate);
	}
	*/
}

```

`Runtime/HairTopologyPrefetch.cs.meta`:

```meta
fileFormatVersion: 2
guid: 8991334d543c4da40a93cfc7c53d81e8
```

`Runtime/HairVertex.hlsl`:

```hlsl
//#pragma use_dxc
//#pragma enable_d3d11_debug_symbols

#ifndef __HAIRVERTEX_HLSL__
#define __HAIRVERTEX_HLSL__

#ifndef HAIR_VERTEX_IMPL_WS_POS_VIEW_DIR
#define HAIR_VERTEX_IMPL_WS_POS_VIEW_DIR(x) GetWorldSpaceNormalizeViewDir(x)
#endif
#ifndef HAIR_VERTEX_IMPL_WS_POS_TO_RWS
#define HAIR_VERTEX_IMPL_WS_POS_TO_RWS(x) GetCameraRelativePositionWS(x)
#endif
#ifndef HAIR_VERTEX_IMPL_WS_VEC_TO_OS
#define HAIR_VERTEX_IMPL_WS_VEC_TO_OS(v) TransformWorldToObjectNormal(v)
#endif

#ifndef normalize_safe
#define normalize_safe(x) ((x) * rsqrt(max(1e-37, dot(x, x))))
#endif

#include "HairSimData.hlsl"
#include "HairSimComputeConfig.hlsl"
#include "HairSimComputeLOD.hlsl"
#include "HairSimDebugDrawColors.hlsl"

#ifndef UNITY_PREV_MATRIX_I_M// not defined by e.g. URP graphs prior to 2021.2.x
#define UNITY_PREV_MATRIX_I_M UNITY_MATRIX_I_M
#endif

#define STRAND_PARTICLE_COUNT	_StagingStrandVertexCount
#define STRAND_PARTICLE_OFFSET	_StagingStrandVertexOffset

#define DECLARE_STRAND(x)													\
	const uint strandIndex = x;												\
	const uint strandParticleBegin = strandIndex * STRAND_PARTICLE_OFFSET;	\
	const uint strandParticleStride = _StrandParticleStride;				\
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * STRAND_PARTICLE_COUNT;

//------------
// instancing

//#pragma instancing_options assumeuniformscaling nomatrices nolodfade nolightprobe nolightmap procedural:HairVertexInstancingSetup

#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED
void HairVertexInstancingMatrices(float4x4 objectToWorld, float4x4 worldToObject)
{
	//TODO add meaningful pivot here

	//const float4x4 I = float4x4(
	//	1.0, 0.0, 0.0, 0.0,
	//	0.0, 1.0, 0.0, 0.0,
	//	0.0, 0.0, 1.0, 0.0,
	//	0.0, 0.0, 0.0, 1.0);

	//objectToWorld = I;
	//worldToObject = I;
}

void HairVertexInstancingSetup()
{
	//#define unity_ObjectToWorld unity_ObjectToWorld
	//#define unity_WorldToObject unity_WorldToObject
	//HairVertexInstancingMatrices(unity_ObjectToWorld, unity_WorldToObject);
}
#endif

//---------
// utility

float3 LoadPosition(const uint i, const LODBounds lodBounds)
{
	return LoadStagingPosition(i, lodBounds);
}

float3 LoadPositionPrev(const uint i, const LODBounds lodBoundsPrev)
{
	return LoadStagingPositionPrev(i, lodBoundsPrev);
}

float GetStrandParticleOffset(const uint strandParticleNumber)
{
	return strandParticleNumber / (float)(STRAND_PARTICLE_COUNT - 1);
}

float GetStrandParticleTaperScale(const uint strandParticleNumber, const float2 strandTaperOffsetScale)
{
	float strandParticleInterval = GetStrandParticleOffset(1);
	float strandParticleOffset = GetStrandParticleOffset(strandParticleNumber);
	float strandTaperOffset = strandTaperOffsetScale.x * _GroupMaxTipScaleOffset;
	float strandTaperT = saturate((strandParticleOffset - strandTaperOffset) / max(strandParticleInterval, 1.0 - strandTaperOffset));// lower bound on taper interval here ensures smooth transition as taper offset approaches 1
	return lerp(1.0, _GroupMaxTipScale * strandTaperOffsetScale.y, strandTaperT);

	//TODO ideally should taper to match desired fill area independent of strand resolution
	//
	//   o--------x-----------o
	//   |        | `         |  
	//   |        |    `      | 1-s
	// 1 |        |       `   |
	//   |        |- - - - - `x  
	//   |        |           | s  
	//   o--------x-----------o
	//        a         b
	//
	// desired area:
	//   a + s*b + (1-s)*b/2
}

float3 GetStrandDebugColor(const uint strandIndex)
{
	LODIndices lodDesc = _SolverLODStage[SOLVERLODSTAGE_PHYSICS];
	uint guideIndexLo = _LODGuideIndex[(lodDesc.lodIndexLo * _StrandCount) + strandIndex];
	uint guideIndexHi = _LODGuideIndex[(lodDesc.lodIndexHi * _StrandCount) + strandIndex];
	float3 guideColorLo = ColorCycle(guideIndexLo, _LODGuideCount[_LODCount - 1]);
	float3 guideColorHi = ColorCycle(guideIndexHi, _LODGuideCount[_LODCount - 1]);
	return lerp(guideColorLo, guideColorHi, lodDesc.lodBlendFrac);
}

//-----------
// accessors

int _DecodeVertexCount;
int _DecodeVertexWidth;
int _DecodeVertexComponentValue;
int _DecodeVertexComponentWidth;

struct HairVertexID
{
	uint strandIndex;
	uint vertexIndex;
	uint vertexFacet;
	float2 tubularUV;
};

static const HairVertexID s_defaultHairVertexID =
{
	/* uint strandIndex; */ 0,
	/* uint vertexIndex; */ 0,
	/* uint vertexFacet; */ 0,
	/* float2 tubularUV; */ float2(0.5, 0.0),
};

struct HairVertexModifiers
{
	float lodScale;
	float lodBias;
	float widthMod;
	bool widthSet;
};

static const HairVertexModifiers s_defaultHairVertexModifiers =
{
	/* float lodScale; */ 1.0,
	/* float lodBias;  */ 0.0,
	/* float widthMod; */ 1.0,
	/* bool widthSet;  */ false,
};

struct HairVertexData
{
	float3 surfacePosition;
	float3 surfaceNormal;
	float3 surfaceTangent;
	float3 surfaceVelocity;
	float3 surfaceNormalTS;
	float2 surfaceUV;
	float2 surfaceUVClip;
	float lodOutputOpacity;
	float lodOutputWidth;
	float2 rootUV;
	float4 rootScale;
	uint strandIndex;
	float3 strandIndexColor;
};

static const HairVertexData s_defaultHairVertexData =
{
	/* float3 surfacePosition;  */ float3(0.0, 0.0, 0.0),
	/* float3 surfaceNormal;    */ float3(0.0, 0.0, 0.0),
	/* float3 surfaceTangent;   */ float3(0.0, 0.0, 0.0),
	/* float3 surfaceVelocity;  */ float3(0.0, 0.0, 0.0),
	/* float3 surfaceNormalTS;  */ float3(0.0, 0.0, 1.0),
	/* float2 surfaceUV;        */ float2(0.5, 0.0),
	/* float2 surfaceUVClip;    */ float2(0.5, 0.0),
	/* float lodOutputOpacity;  */ 1.0,
	/* float lodOutputWidth;    */ 1.0 * 0.1,
	/* float2 rootUV;           */ float2(0.0, 0.0),
	/* float4 rootScale;        */ float4(1.0, 1.0, 1.0, 1.0),
	/* uint strandIndex;        */ 0,
	/* float3 strandIndexColor; */ float3(0.5, 0.5, 0.5),
};

HairVertexID DecodeHairVertexID(float4 packedID)
{
	HairVertexID id;
	{
		uint4 unpack = round(packedID * _DecodeVertexComponentValue);

		id.strandIndex = (
			(unpack.w << ((_DecodeVertexComponentWidth << 1) - _DecodeVertexWidth)) |
			(unpack.z << ((_DecodeVertexComponentWidth << 0) - _DecodeVertexWidth)) |
			(unpack.y >> _DecodeVertexWidth)
		);

#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED
		id.strandIndex += (unity_InstanceID * INSTANCING_BATCH_SIZE);
#endif

		id.vertexIndex = unpack.x;
		id.vertexFacet = unpack.y & ((1 << _DecodeVertexWidth) - 1);

		//TODO evaluate this in comparison
		//	id.strandIndex = floor(dot(packedID.yzw, _DecodeStrandIndex.xyz))
		//	id.vertexFacet = frac(packedID.y * _DecodeStrandFacet.x) * _DecodeStrandFacet.y
		//	id.vertexIndex = packedID.x * _DecodeStrandIndex.w

		if (_DecodeVertexCount == 1)
		{
			id.tubularUV.x = 0.5;
			id.tubularUV.y = (packedID.x * _DecodeVertexComponentValue) / (float) (STRAND_PARTICLE_COUNT - 1);
		}
		else
		{
			id.tubularUV.x = frac(packedID.y * (_DecodeVertexComponentValue / (float)(1 << _DecodeVertexWidth))) * ((1 << _DecodeVertexWidth) / (float)_DecodeVertexCount);
			id.tubularUV.y = (packedID.x * _DecodeVertexComponentValue) / (float) (STRAND_PARTICLE_COUNT - 1);
		}
	}
	return id;
}

float3 GetSurfaceNormalTS(const float2 tubularUV)
{
	float3 surfaceNormalTS;
	{
		if (_DecodeVertexCount == 2)// strips
		{
			surfaceNormalTS.x = 4.0 * saturate(tubularUV.x) - 1.0;
			surfaceNormalTS.y = 0.0;
			surfaceNormalTS.z = sqrt(max(1e-5, 1.0 - surfaceNormalTS.x * surfaceNormalTS.x));
		}
		else// everything else
		{
			surfaceNormalTS = float3(0.0, 0.0, 1.0);
		}
	}
	return surfaceNormalTS;
}

float2 GetSurfaceUV(const float2 tubularUV)
{
	float2 surfaceUV = tubularUV;
	{
		if (_DecodeVertexCount >= 2)// strips, tubes
		{
			surfaceUV.x *= 2.0;
		}
	}
	return surfaceUV;
}

HairVertexData GetHairVertexWS(const HairVertexID id, const HairVertexModifiers m)
{
	DECLARE_STRAND(id.strandIndex);

	const uint i = strandParticleBegin + id.vertexIndex * strandParticleStride;
	const uint i_next = i + strandParticleStride;
	const uint i_prev = i - strandParticleStride;
	const uint i_head = strandParticleBegin;
	const uint i_tail = strandParticleEnd - strandParticleStride;

	const LODBounds lodBounds = _Bounds[_GroupBoundsIndex];
	const LODBounds lodBoundsPrev = _BoundsPrev[_GroupBoundsIndex];

	float3 p = LoadPosition(i, lodBounds);
	float3 r0 = (i == i_head) ? LoadPosition(i_next, lodBounds) - p : p - LoadPosition(i_prev, lodBounds);
	float3 r1 = (i == i_tail) ? r0 /* .......................... */ : LoadPosition(i_next, lodBounds) - p;

	float3 curvePositionRWS = HAIR_VERTEX_IMPL_WS_POS_TO_RWS(p);
	float3 curvePositionRWSPrev = HAIR_VERTEX_IMPL_WS_POS_TO_RWS(LoadPositionPrev(i, lodBoundsPrev));
	float3 curveTangentWS = (r0 + r1); // approx tangent to curve

	// calc world radius
	float radius = (0.5 * _GroupMaxParticleDiameter) * _RootScale[strandIndex].y;
	{
		// apply clustering lod
		{
			LODFrustum lodFrustum = MakeLODFrustumForCurrentCamera();

			float curveSpan = 2.0 * radius;
			float curveDepth = dot(lodFrustum.cameraForward, curvePositionRWS - lodFrustum.cameraPosition);
			float curveCoverage = LODFrustumCoverage(lodFrustum, curveDepth, curveSpan);

			// lod selection
			LODIndices lodDesc;
			{
				switch (_RenderLODMethod)
				{
					case RENDERLODSELECTION_AUTOMATIC_PER_SEGMENT:
#define ANISOTROPIC_LOD_DENSITY 0
#if ANISOTROPIC_LOD_DENSITY
						float3 curveViewWS = HAIR_VERTEX_IMPL_WS_POS_VIEW_DIR(curvePositionRWS);
						float curveParallel = saturate(abs(dot(normalize_safe(curveTangentWS), curveViewWS)));
						float curveCoverageA = lerp(curveCoverage, sqrt(curveCoverage), curveParallel);
						lodDesc = ResolveLODIndices(ResolveLODQuantity(curveCoverageA, _RenderLODCeiling, _RenderLODScale * m.lodScale, _RenderLODBias + m.lodBias));
#else
						lodDesc = ResolveLODIndices(ResolveLODQuantity(curveCoverage, _RenderLODCeiling, _RenderLODScale * m.lodScale, _RenderLODBias + m.lodBias));
#endif
						break;

					default:
						if (m.lodScale == 1.0 && m.lodBias == 0.0)
						{
							lodDesc = _SolverLODStage[SOLVERLODSTAGE_RENDERING];
						}
						else
						{
							lodDesc = ResolveLODIndices(ResolveLODQuantity(_SolverLODStage[SOLVERLODSTAGE_RENDERING].lodValue, _RenderLODCeiling, m.lodScale, m.lodBias));
						}
						break;
				}
			}

			// lod subpixel accumulation -> cluster centroid
			{
				float guideCarryLo = _LODGuideCarry[(lodDesc.lodIndexLo * _StrandCount) + strandIndex];
				float guideCarryHi = _LODGuideCarry[(lodDesc.lodIndexHi * _StrandCount) + strandIndex];
				float guideCarry = lerp(guideCarryLo, guideCarryHi, lodDesc.lodBlendFrac);

				float guideReachLo = _LODGuideReach[(lodDesc.lodIndexLo * _StrandCount) + strandIndex] * _GroupScale;
				float guideReachHi = _LODGuideReach[(lodDesc.lodIndexHi * _StrandCount) + strandIndex] * _GroupScale;
				float guideReach = lerp(guideReachLo, guideReachHi, lodDesc.lodBlendFrac);

				float guideProjectedCoverageLo = 1.0 - exp(-radius * guideCarryLo / guideReachLo);
				float guideProjectedCoverageHi = 1.0 - exp(-radius * guideCarryHi / guideReachHi);
				float guideProjectedCoverage = 1.0 - exp(-radius * guideCarry / guideReach);

#define USE_PASSING_FRACTION 0
#if USE_PASSING_FRACTION
				if (_RenderLODMethod == RENDERLODSELECTION_AUTOMATIC_PER_SEGMENT)
				{
					//float lodThreshClip = lodClipThreshold;
					//                    = unitSpanSubpixelDepth / unitSpanClippingDepth;
					//float lodThreshClipCluster = unitSpanSubpixelDepth / (unitSpanClippingDepth + guideReach * 2);
					//                           = unitSpanSubpixelDepth / ((unitSpanSubpixelDepth / lodClipThreshold) + guideReach * 2);
					//                           = (unitSpanSubpixelDepth * lodClipThreshold) / (unitSpanSubpixelDepth + 2 * guideReach * lodClipThreshold);

					float lodThresh = 1.0;
					float lodThreshClip = max(_RenderLODClipThreshold, 1e-5);
					float lodThreshClipCluster = (lodFrustum.unitSpanSubpixelDepth * lodThreshClip) / (lodFrustum.unitSpanSubpixelDepth + 2.0 * guideReach * lodThreshClip);

					float farDepth = curveDepth + guideReach;
					float farLod = saturate(lodDesc.lodValue * (curveDepth / farDepth));
					float farLodT = saturate((farLod - lodThreshClipCluster) / (lodThresh - lodThreshClipCluster));

#define USE_CIRCULAR_SECTION 1
#if USE_CIRCULAR_SECTION
					// replaces t with normalized area of circular section at height 2rt:
					// A = (acos(1-2*x)-(1-2*x)*2*sqrt(x*(1-x)))/PI
					farLodT = (acos(1.0 - 2.0 * farLodT) - (1.0 - 2.0 * farLodT) * 2 * sqrt(farLodT * (1.0 - farLodT))) / 3.14159;
#endif

					radius = lerp((radius + guideReach) * guideProjectedCoverage, radius, farLodT);
				}
				else
#endif
				{
					radius = lerp((radius + guideReachLo) * guideProjectedCoverageLo, (radius + guideReachHi) * guideProjectedCoverageHi, lodDesc.lodBlendFrac);
				}

				curveSpan = 2.0 * radius;
				curveCoverage = LODFrustumCoverage(lodFrustum, curveDepth, curveSpan);
			}

			// lod subpixel discard
			{
				if (curveCoverage < _RenderLODClipThreshold)
				{
					curvePositionRWS = asfloat(0x7FC00000u); // => NaN
				}
			}
		}

		// apply tapering
		{
			radius *= GetStrandParticleTaperScale(id.vertexIndex, _RootScale[strandIndex].zw);
		}

		// apply scaling
		{
			radius = m.widthMod * (m.widthSet ? 0.5 : radius);
		}
	}

	// calc surface vectors
	float3 surfaceTangentWS = normalize_safe(cross(HAIR_VERTEX_IMPL_WS_POS_VIEW_DIR(curvePositionRWS), curveTangentWS));
	float3 surfaceNormalWS = normalize_safe(cross(curveTangentWS, surfaceTangentWS));
	
	// calc surface offset
	float3 surfaceOffsetWS = 0;
	{
		if (_DecodeVertexCount > 1)
		{
			// calc offset in plane
			float2 surfaceOffset2D;
			{
				sincos((0.5 - id.tubularUV.x) * 6.2831853, surfaceOffset2D.y, surfaceOffset2D.x);
			}

			// calc offset in world space
			if (_DecodeVertexCount == 2)
			{
				surfaceOffsetWS =
					(radius * surfaceOffset2D.x) * surfaceTangentWS +
					(radius * surfaceOffset2D.y) * surfaceNormalWS;
			}
			else
			{
				surfaceNormalWS =
					(surfaceOffset2D.x) * surfaceTangentWS +
					(surfaceOffset2D.y) * surfaceNormalWS;
				
				surfaceOffsetWS =
					(radius) * surfaceNormalWS;
			}
		}
	}

	// assemble output
	HairVertexData v;
	{
		v.surfacePosition = surfaceOffsetWS + curvePositionRWS;
		v.surfaceNormal = surfaceNormalWS;
		v.surfaceTangent = surfaceTangentWS;
		v.surfaceVelocity = curvePositionRWS - curvePositionRWSPrev;
		v.surfaceNormalTS = GetSurfaceNormalTS(id.tubularUV);
		v.surfaceUV = GetSurfaceUV(id.tubularUV);//TODO scroll to handle twist / change in view direction
		v.surfaceUVClip = GetSurfaceUV(id.tubularUV) * float2(1.0, _RootScale[strandIndex].x);//TODO scroll to handle twist / change in view direction
		v.lodOutputOpacity = 1.0;//TODO reserved for later use
		v.lodOutputWidth = (2.0 * radius) * 100.0;// output in cm
		v.rootUV = _RootUV[strandIndex];
		v.rootScale = _RootScale[strandIndex];
		v.strandIndex = strandIndex;
		v.strandIndexColor = GetStrandDebugColor(strandIndex);
	}
	return v;
}

HairVertexData GetHairVertexOS(const HairVertexID id, const HairVertexModifiers m)
{
	HairVertexData v = GetHairVertexWS(id, m);
	{
#define USE_OBJECT_SPACE_DELTA 1
#if USE_OBJECT_SPACE_DELTA
		float3 surfacePositionOS = mul(UNITY_MATRIX_I_M, float4(v.surfacePosition, 1.0)).xyz;
		float3 surfacePositionOSPrev = mul(UNITY_PREV_MATRIX_I_M, float4(v.surfacePosition - v.surfaceVelocity, 1.0)).xyz;
		
		v.surfacePosition = surfacePositionOS;
		v.surfaceNormal = HAIR_VERTEX_IMPL_WS_VEC_TO_OS(v.surfaceNormal);
		v.surfaceTangent = HAIR_VERTEX_IMPL_WS_VEC_TO_OS(v.surfaceTangent);
		v.surfaceVelocity = surfacePositionOS - surfacePositionOSPrev;
#else
		v.surfacePosition = mul(UNITY_MATRIX_I_M, float4(v.surfacePosition, 1.0)).xyz;
		v.surfaceNormal = HAIR_VERTEX_IMPL_WS_VEC_TO_OS(v.surfaceNormal);
		v.surfaceTangent = HAIR_VERTEX_IMPL_WS_VEC_TO_OS(v.surfaceTangent);
		v.surfaceVelocity = mul(UNITY_PREV_MATRIX_I_M, float4(v.surfaceVelocity, 0.0)).xyz;
#endif
	}
	return v;
}

HairVertexData GetHairVertex(
	const float4 packedID,
	const float3 staticPositionOS,
	const float3 staticNormalOS,
	const float3 staticTangentOS,
	const HairVertexModifiers m = s_defaultHairVertexModifiers)
{
	HairVertexData v;
	{
#if HAIR_VERTEX_LIVE || !SHADER_STAGE_VERTEX
		if (_DecodeVertexCount > 0)
		{
			HairVertexID id = DecodeHairVertexID(packedID);

			if (id.strandIndex < _SolverLODRange[SOLVERLODRANGE_RENDER].y)
			{
				v = GetHairVertexOS(id, m);
			}
			else
			{
				v = s_defaultHairVertexData;
				v.surfacePosition = asfloat(0x7FC00000u); // => NaN
			}
		}
		else
#endif
		{
			v = s_defaultHairVertexData;
			v.surfacePosition = staticPositionOS;
			v.surfaceNormal = staticNormalOS;
			v.surfaceTangent = staticTangentOS;
		}
	}
	return v;
}

//-------------
// shadergraph

void HairVertex_float(
	const float4 in_packedID,
	const float3 in_staticPositionOS,
	const float3 in_staticNormalOS,
	const float3 in_staticTangentOS,

	const float in_lodScale,
	const float in_lodBias,
	const float in_widthMod,
	const bool in_widthSet,

	out float3 out_surfacePositionOS,
	out float3 out_surfaceNormalOS,
	out float3 out_surfaceTangentOS,
	out float3 out_surfaceVelocityOS,
	out float3 out_surfaceNormalTS,
	out float2 out_surfaceUV,
	out float2 out_surfaceUVClip,
	out float out_lodOutputOpacity,
	out float out_lodOutputWidth,
	out float2 out_rootUV,
	out float4 out_rootScale,
	out float out_strandIndex,
	out float3 out_strandIndexColor)
{
	HairVertexModifiers m = { in_lodScale, in_lodBias, in_widthMod, in_widthSet };
	HairVertexData v = GetHairVertex(in_packedID, in_staticPositionOS, in_staticNormalOS, in_staticTangentOS, m);
	{
		out_surfacePositionOS = v.surfacePosition;
		out_surfaceNormalOS = v.surfaceNormal;
		out_surfaceTangentOS = v.surfaceTangent;
		out_surfaceVelocityOS = v.surfaceVelocity;
		out_surfaceNormalTS = v.surfaceNormalTS;
		out_surfaceUV = v.surfaceUV;
		out_surfaceUVClip = v.surfaceUVClip;
		out_lodOutputOpacity = v.lodOutputOpacity;
		out_lodOutputWidth = v.lodOutputWidth;
		out_rootUV = v.rootUV;
		out_rootScale = v.rootScale;
		out_strandIndex = v.strandIndex;
		out_strandIndexColor = v.strandIndexColor;
	}
}

#endif//__HAIRVERTEX_HLSL__

```

`Runtime/HairVertex.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: 4f6d24cde688f7343b07b92b71138a5a
ShaderIncludeImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairVertex.shadersubgraph`:

```shadersubgraph
{
    "m_SGVersion": 3,
    "m_Type": "UnityEditor.ShaderGraph.GraphData",
    "m_ObjectId": "d1afb942372c49b6be7e6f382d135a78",
    "m_Properties": [
        {
            "m_Id": "1a64895764df486687bfa37d0a17be88"
        },
        {
            "m_Id": "d3c05afc9b6a491e82ac2f9a438408ba"
        },
        {
            "m_Id": "9a07d2ec24634364bfe703b24288abac"
        },
        {
            "m_Id": "cd8e0004d0024c258e2b86e3e06cfede"
        }
    ],
    "m_Keywords": [
        {
            "m_Id": "be5bfa3abf3c4490bada295f31cb7eb9"
        },
        {
            "m_Id": "d169fcbdea0144808719ef05039948fa"
        }
    ],
    "m_Dropdowns": [],
    "m_CategoryData": [
        {
            "m_Id": "c749f3a57d5d49d8878f87d48ad0e5c0"
        }
    ],
    "m_Nodes": [
        {
            "m_Id": "05907e129e0b4526858a9d2d669f647a"
        },
        {
            "m_Id": "1f91cf420025464eaead59f9d50b1e80"
        },
        {
            "m_Id": "ad9c5f32380c4a40ab45c400f8da8903"
        },
        {
            "m_Id": "79df9a72eec84e95a1a5d1a8cc439db4"
        },
        {
            "m_Id": "ef6dd66ac24042b184978d4a9a325284"
        },
        {
            "m_Id": "bdc041dbf90a475dbab9e324814d496c"
        },
        {
            "m_Id": "5ffbd43b1e87468d807f4e059daefe0a"
        },
        {
            "m_Id": "a31fb9c8b54543a38775de6a3d76fb01"
        },
        {
            "m_Id": "132700e1de19491d9741c4a775a5d78e"
        },
        {
            "m_Id": "9e3e7c19cdf24ac5a1020748dcaf1033"
        },
        {
            "m_Id": "ea544d11db68430789d144b6ff3e41e5"
        }
    ],
    "m_GroupDatas": [],
    "m_StickyNoteDatas": [
        {
            "m_Id": "f84496d497874313b7f614bbcb8c4c5d"
        },
        {
            "m_Id": "8331e992bf384bccbcc056026365ccb9"
        },
        {
            "m_Id": "ec0401e100fe40689801e8c8270ea16a"
        }
    ],
    "m_Edges": [
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "132700e1de19491d9741c4a775a5d78e"
                },
                "m_SlotId": 0
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 20
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 3
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "05907e129e0b4526858a9d2d669f647a"
                },
                "m_SlotId": 1
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 4
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "05907e129e0b4526858a9d2d669f647a"
                },
                "m_SlotId": 2
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 5
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "05907e129e0b4526858a9d2d669f647a"
                },
                "m_SlotId": 3
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 7
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "05907e129e0b4526858a9d2d669f647a"
                },
                "m_SlotId": 5
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 8
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "05907e129e0b4526858a9d2d669f647a"
                },
                "m_SlotId": 6
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 9
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "05907e129e0b4526858a9d2d669f647a"
                },
                "m_SlotId": 7
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 12
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "05907e129e0b4526858a9d2d669f647a"
                },
                "m_SlotId": 8
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 16
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "05907e129e0b4526858a9d2d669f647a"
                },
                "m_SlotId": 9
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 17
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "05907e129e0b4526858a9d2d669f647a"
                },
                "m_SlotId": 10
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 22
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "05907e129e0b4526858a9d2d669f647a"
                },
                "m_SlotId": 11
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 23
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "05907e129e0b4526858a9d2d669f647a"
                },
                "m_SlotId": 12
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 24
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "05907e129e0b4526858a9d2d669f647a"
                },
                "m_SlotId": 14
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 25
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "05907e129e0b4526858a9d2d669f647a"
                },
                "m_SlotId": 13
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "5ffbd43b1e87468d807f4e059daefe0a"
                },
                "m_SlotId": 0
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 18
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "79df9a72eec84e95a1a5d1a8cc439db4"
                },
                "m_SlotId": 0
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 10
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "9e3e7c19cdf24ac5a1020748dcaf1033"
                },
                "m_SlotId": 0
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 21
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "a31fb9c8b54543a38775de6a3d76fb01"
                },
                "m_SlotId": 0
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 19
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "ad9c5f32380c4a40ab45c400f8da8903"
                },
                "m_SlotId": 0
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "ea544d11db68430789d144b6ff3e41e5"
                },
                "m_SlotId": 0
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "bdc041dbf90a475dbab9e324814d496c"
                },
                "m_SlotId": 0
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 15
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "ea544d11db68430789d144b6ff3e41e5"
                },
                "m_SlotId": 1
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 0
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "ef6dd66ac24042b184978d4a9a325284"
                },
                "m_SlotId": 0
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "1f91cf420025464eaead59f9d50b1e80"
                },
                "m_SlotId": 14
            }
        }
    ],
    "m_VertexContext": {
        "m_Position": {
            "x": 0.0,
            "y": 0.0
        },
        "m_Blocks": []
    },
    "m_FragmentContext": {
        "m_Position": {
            "x": 0.0,
            "y": 0.0
        },
        "m_Blocks": []
    },
    "m_PreviewData": {
        "serializedMesh": {
            "m_SerializedMesh": "{\"mesh\":{\"instanceID\":0}}",
            "m_Guid": ""
        },
        "preventRotation": false
    },
    "m_Path": "Hair",
    "m_GraphPrecision": 0,
    "m_PreviewMode": 2,
    "m_OutputNode": {
        "m_Id": "05907e129e0b4526858a9d2d669f647a"
    },
    "m_ActiveTargets": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "008903bf1b334034aceddc7ac31ee91b",
    "m_Id": 24,
    "m_DisplayName": "lodOutputWidth",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "lodOutputWidth",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector2MaterialSlot",
    "m_ObjectId": "011a53bd48004abcb0762362661bf547",
    "m_Id": 8,
    "m_DisplayName": "surfaceUVClip",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceUVClip",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.SubGraphOutputNode",
    "m_ObjectId": "05907e129e0b4526858a9d2d669f647a",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Output",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 450.0,
            "y": -182.0,
            "width": 152.0,
            "height": 365.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "de2852bb66784c618a8fad459141fbcd"
        },
        {
            "m_Id": "0e5622b598df4585b9e4277e3c5dc115"
        },
        {
            "m_Id": "c518720e274e4b44b02c21de95e0fdb2"
        },
        {
            "m_Id": "962a0d7d301d4cad8c4f7e74f6dde02c"
        },
        {
            "m_Id": "181234521dc5453da262da540d05f1f8"
        },
        {
            "m_Id": "4e87720e343c40c9adde358b5d10abec"
        },
        {
            "m_Id": "011a53bd48004abcb0762362661bf547"
        },
        {
            "m_Id": "dc03b823b63a4c02abcd7bb5df84d7a7"
        },
        {
            "m_Id": "1d38dab045a04c5b83befcfd7b953bcf"
        },
        {
            "m_Id": "cfdd09ee92b64c52a444c6dbfbfab079"
        },
        {
            "m_Id": "d07f1adfb56246318209a869d288e959"
        },
        {
            "m_Id": "bc2067cd19b44b3cb2b85b555c719e0a"
        },
        {
            "m_Id": "0e8e08da07034845bc75c5f8d9a241a7"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "IsFirstSlotValid": true
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "093fe5b022bf4cce9f8b5301f0520004",
    "m_Id": 0,
    "m_DisplayName": "lodScale",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "Out",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "0ad7927044d9423d927742156b16c5cc",
    "m_Id": 17,
    "m_DisplayName": "surfaceVelocityOS",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceVelocityOS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "0e5622b598df4585b9e4277e3c5dc115",
    "m_Id": 2,
    "m_DisplayName": "surfaceNormalOS",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceNormalOS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "0e8e08da07034845bc75c5f8d9a241a7",
    "m_Id": 7,
    "m_DisplayName": "strandIndexColor",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "strandIndexColor",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "12bd8ca94938426b9507deb10fd0c56b",
    "m_Id": 18,
    "m_DisplayName": "lodScale",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "lodScale",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.PropertyNode",
    "m_ObjectId": "132700e1de19491d9741c4a775a5d78e",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Property",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -112.0,
            "y": 324.0,
            "width": 130.0,
            "height": 34.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "f508586458f34f3487ad4b012db511b3"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_Property": {
        "m_Id": "9a07d2ec24634364bfe703b24288abac"
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "138295b955a34e2199ee51f3bf097396",
    "m_Id": 15,
    "m_DisplayName": "staticTangent",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "staticTangent",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "181234521dc5453da262da540d05f1f8",
    "m_Id": 6,
    "m_DisplayName": "surfaceNormalTS",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceNormalTS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "18b428b034b547adac0d0177144576b8",
    "m_Id": 14,
    "m_DisplayName": "staticNormal",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "staticNormal",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 1.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "1942cbd6ef8f40d28e8a2e897ad2a545",
    "m_Id": 8,
    "m_DisplayName": "surfaceNormalTS",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceNormalTS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 1,
    "m_Type": "UnityEditor.ShaderGraph.Internal.Vector1ShaderProperty",
    "m_ObjectId": "1a64895764df486687bfa37d0a17be88",
    "m_Guid": {
        "m_GuidSerialized": "e935c862-ea39-43ee-b8a2-fce6cf0c0c57"
    },
    "m_Name": "lodScale",
    "m_DefaultRefNameVersion": 0,
    "m_RefNameGeneratedByDisplayName": "",
    "m_DefaultReferenceName": "Vector1_1a64895764df486687bfa37d0a17be88",
    "m_OverrideReferenceName": "",
    "m_GeneratePropertyBlock": true,
    "m_UseCustomSlotLabel": false,
    "m_CustomSlotLabel": "",
    "m_DismissedVersion": 0,
    "m_Precision": 0,
    "overrideHLSLDeclaration": false,
    "hlslDeclarationOverride": 0,
    "m_Hidden": false,
    "m_Value": 1.0,
    "m_FloatType": 0,
    "m_RangeValues": {
        "x": 0.0,
        "y": 1.0
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "1d38dab045a04c5b83befcfd7b953bcf",
    "m_Id": 14,
    "m_DisplayName": "lodOutputWidth",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "lodOutputWidth",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BooleanMaterialSlot",
    "m_ObjectId": "1d95945c921e4ca0a1049a3f04f097bb",
    "m_Id": 0,
    "m_DisplayName": "widthSet",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "Out",
    "m_StageCapability": 3,
    "m_Value": false,
    "m_DefaultValue": false
}

{
    "m_SGVersion": 1,
    "m_Type": "UnityEditor.ShaderGraph.CustomFunctionNode",
    "m_ObjectId": "1f91cf420025464eaead59f9d50b1e80",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "HairVertex (Custom Function)",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -71.0,
            "y": -182.0,
            "width": 273.0,
            "height": 310.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "e9ad063d8e7a433ab72b40683be6242d"
        },
        {
            "m_Id": "2e20ff62401b4ee1b469c3ae3a2d91ed"
        },
        {
            "m_Id": "18b428b034b547adac0d0177144576b8"
        },
        {
            "m_Id": "138295b955a34e2199ee51f3bf097396"
        },
        {
            "m_Id": "12bd8ca94938426b9507deb10fd0c56b"
        },
        {
            "m_Id": "86532f3315414091886565a0447a7a1e"
        },
        {
            "m_Id": "418d92840e814c548df3632242785456"
        },
        {
            "m_Id": "65b8729c0a7c4a599da23fe56eab4c3f"
        },
        {
            "m_Id": "4963c9469232450581857b5d2717352b"
        },
        {
            "m_Id": "8b275a63fc60431d92917ab2733afbf4"
        },
        {
            "m_Id": "2254e203000942b5b5b5ec044ae77d4e"
        },
        {
            "m_Id": "0ad7927044d9423d927742156b16c5cc"
        },
        {
            "m_Id": "1942cbd6ef8f40d28e8a2e897ad2a545"
        },
        {
            "m_Id": "d9a8f5fb43c8406bae634089442e3f36"
        },
        {
            "m_Id": "368f374e5c9a4a6d90c15bcf1a06b0c1"
        },
        {
            "m_Id": "e01cabb2bf704a3992601d5c2a8597e3"
        },
        {
            "m_Id": "008903bf1b334034aceddc7ac31ee91b"
        },
        {
            "m_Id": "93244208abc6470b85390f17f6b831d5"
        },
        {
            "m_Id": "3ee4dc4a99584c0b912377d9db271029"
        },
        {
            "m_Id": "6ea57a5135494debab79eab2f6bf10b7"
        },
        {
            "m_Id": "cba913fcf6094a09a5ee8678c45aa306"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": false,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SourceType": 0,
    "m_FunctionName": "HairVertex",
    "m_FunctionSource": "4f6d24cde688f7343b07b92b71138a5a",
    "m_FunctionBody": "Enter function body here..."
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "2254e203000942b5b5b5ec044ae77d4e",
    "m_Id": 5,
    "m_DisplayName": "surfaceTangentOS",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceTangentOS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "2dcd26a6b956460bb950c594b7d80a16",
    "m_Id": 0,
    "m_DisplayName": "Out",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "Out",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 1.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "2e20ff62401b4ee1b469c3ae3a2d91ed",
    "m_Id": 10,
    "m_DisplayName": "staticPosition",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "staticPosition",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector4MaterialSlot",
    "m_ObjectId": "3375da14f66044cda79600fc30781365",
    "m_Id": 1,
    "m_DisplayName": "Out",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "Out",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector2MaterialSlot",
    "m_ObjectId": "368f374e5c9a4a6d90c15bcf1a06b0c1",
    "m_Id": 12,
    "m_DisplayName": "surfaceUVClip",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceUVClip",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "39f4f4d12ebb4f0c8b81b8ed9238181e",
    "m_Id": 0,
    "m_DisplayName": "lodBias",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "Out",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector4MaterialSlot",
    "m_ObjectId": "3e5fc992330e4660879599825f6cf1b8",
    "m_Id": 0,
    "m_DisplayName": "Out",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "Out",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector4MaterialSlot",
    "m_ObjectId": "3ee4dc4a99584c0b912377d9db271029",
    "m_Id": 23,
    "m_DisplayName": "rootScale",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "rootScale",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "418d92840e814c548df3632242785456",
    "m_Id": 20,
    "m_DisplayName": "widthMod",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "widthMod",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "4963c9469232450581857b5d2717352b",
    "m_Id": 3,
    "m_DisplayName": "surfacePositionOS",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfacePositionOS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector2MaterialSlot",
    "m_ObjectId": "4e87720e343c40c9adde358b5d10abec",
    "m_Id": 11,
    "m_DisplayName": "surfaceUV",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceUV",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.PropertyNode",
    "m_ObjectId": "5ffbd43b1e87468d807f4e059daefe0a",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Property",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -103.0,
            "y": 256.0,
            "width": 121.0,
            "height": 34.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "093fe5b022bf4cce9f8b5301f0520004"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_Property": {
        "m_Id": "1a64895764df486687bfa37d0a17be88"
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BooleanMaterialSlot",
    "m_ObjectId": "65b8729c0a7c4a599da23fe56eab4c3f",
    "m_Id": 21,
    "m_DisplayName": "widthSet",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "widthSet",
    "m_StageCapability": 3,
    "m_Value": false,
    "m_DefaultValue": false
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "6d15fe48cebe45f690ab036cb09ae41f",
    "m_Id": 0,
    "m_DisplayName": "Out",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "Out",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "6ea57a5135494debab79eab2f6bf10b7",
    "m_Id": 16,
    "m_DisplayName": "strandIndex",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "strandIndex",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "74ab0201ea674934923073b77509e252",
    "m_Id": 0,
    "m_DisplayName": "Out",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "Out",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 1.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 1,
    "m_Type": "UnityEditor.ShaderGraph.PositionNode",
    "m_ObjectId": "79df9a72eec84e95a1a5d1a8cc439db4",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Position",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -391.0000305175781,
            "y": -105.00001525878906,
            "width": 206.0,
            "height": 132.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "6d15fe48cebe45f690ab036cb09ae41f"
        }
    ],
    "synonyms": [],
    "m_Precision": 1,
    "m_PreviewExpanded": false,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 2,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_Space": 0,
    "m_PositionSource": 0
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.StickyNoteData",
    "m_ObjectId": "8331e992bf384bccbcc056026365ccb9",
    "m_Title": "Static fallback",
    "m_Content": "(material preview)",
    "m_TextSize": 0,
    "m_Theme": 0,
    "m_Position": {
        "serializedVersion": "2",
        "x": -571.0,
        "y": -99.0,
        "width": 174.0,
        "height": 386.0
    },
    "m_Group": {
        "m_Id": ""
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "86532f3315414091886565a0447a7a1e",
    "m_Id": 19,
    "m_DisplayName": "lodBias",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "lodBias",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "8b275a63fc60431d92917ab2733afbf4",
    "m_Id": 4,
    "m_DisplayName": "surfaceNormalOS",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceNormalOS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector2MaterialSlot",
    "m_ObjectId": "93244208abc6470b85390f17f6b831d5",
    "m_Id": 7,
    "m_DisplayName": "rootUV",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "rootUV",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "962a0d7d301d4cad8c4f7e74f6dde02c",
    "m_Id": 10,
    "m_DisplayName": "surfaceVelocityOS",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceVelocityOS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 1,
    "m_Type": "UnityEditor.ShaderGraph.Internal.Vector1ShaderProperty",
    "m_ObjectId": "9a07d2ec24634364bfe703b24288abac",
    "m_Guid": {
        "m_GuidSerialized": "25d0a9b2-ee13-44c2-b1a5-c30e0760039f"
    },
    "m_Name": "widthMod",
    "m_DefaultRefNameVersion": 0,
    "m_RefNameGeneratedByDisplayName": "",
    "m_DefaultReferenceName": "Vector1_9a07d2ec24634364bfe703b24288abac",
    "m_OverrideReferenceName": "",
    "m_GeneratePropertyBlock": true,
    "m_UseCustomSlotLabel": false,
    "m_CustomSlotLabel": "",
    "m_DismissedVersion": 0,
    "m_Precision": 0,
    "overrideHLSLDeclaration": false,
    "hlslDeclarationOverride": 0,
    "m_Hidden": false,
    "m_Value": 1.0,
    "m_FloatType": 0,
    "m_RangeValues": {
        "x": 0.0,
        "y": 1.0
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.PropertyNode",
    "m_ObjectId": "9e3e7c19cdf24ac5a1020748dcaf1033",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Property",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -107.0,
            "y": 358.0,
            "width": 125.0,
            "height": 34.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "1d95945c921e4ca0a1049a3f04f097bb"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_Property": {
        "m_Id": "cd8e0004d0024c258e2b86e3e06cfede"
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.PropertyNode",
    "m_ObjectId": "a31fb9c8b54543a38775de6a3d76fb01",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Property",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -97.0,
            "y": 290.0,
            "width": 115.0,
            "height": 34.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "39f4f4d12ebb4f0c8b81b8ed9238181e"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_Property": {
        "m_Id": "d3c05afc9b6a491e82ac2f9a438408ba"
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.UVNode",
    "m_ObjectId": "ad9c5f32380c4a40ab45c400f8da8903",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "UV",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -535.9999389648438,
            "y": -329.0,
            "width": 144.99996948242188,
            "height": 129.00003051757813
        }
    },
    "m_Slots": [
        {
            "m_Id": "3e5fc992330e4660879599825f6cf1b8"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": false,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_OutputChannel": 0
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "bc2067cd19b44b3cb2b85b555c719e0a",
    "m_Id": 9,
    "m_DisplayName": "strandIndex",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "strandIndex",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.TangentVectorNode",
    "m_ObjectId": "bdc041dbf90a475dbab9e324814d496c",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Tangent Vector",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -393.0000305175781,
            "y": 158.99996948242188,
            "width": 206.0,
            "height": 132.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "2dcd26a6b956460bb950c594b7d80a16"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": false,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 2,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_Space": 0
}

{
    "m_SGVersion": 1,
    "m_Type": "UnityEditor.ShaderGraph.ShaderKeyword",
    "m_ObjectId": "be5bfa3abf3c4490bada295f31cb7eb9",
    "m_Guid": {
        "m_GuidSerialized": "ba3f9785-f141-4325-b805-7cc8dbfef86a"
    },
    "m_Name": "HAIR_VERTEX",
    "m_DefaultRefNameVersion": 1,
    "m_RefNameGeneratedByDisplayName": "HAIR_VERTEX",
    "m_DefaultReferenceName": "_HAIR_VERTEX",
    "m_OverrideReferenceName": "HAIR_VERTEX",
    "m_GeneratePropertyBlock": true,
    "m_UseCustomSlotLabel": false,
    "m_CustomSlotLabel": "",
    "m_DismissedVersion": 0,
    "m_KeywordType": 1,
    "m_KeywordDefinition": 1,
    "m_KeywordScope": 0,
    "m_KeywordStages": 1,
    "m_Entries": [
        {
            "id": 3,
            "displayName": "STATIC",
            "referenceName": "STATIC"
        },
        {
            "id": 1,
            "displayName": "LIVE",
            "referenceName": "LIVE"
        }
    ],
    "m_Value": 0,
    "m_IsEditable": true
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector4MaterialSlot",
    "m_ObjectId": "c05861ac10894331be42a8d3031bfabf",
    "m_Id": 0,
    "m_DisplayName": "In",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "In",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "c518720e274e4b44b02c21de95e0fdb2",
    "m_Id": 3,
    "m_DisplayName": "surfaceTangentOS",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceTangentOS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.CategoryData",
    "m_ObjectId": "c749f3a57d5d49d8878f87d48ad0e5c0",
    "m_Name": "",
    "m_ChildObjectList": [
        {
            "m_Id": "1a64895764df486687bfa37d0a17be88"
        },
        {
            "m_Id": "d3c05afc9b6a491e82ac2f9a438408ba"
        },
        {
            "m_Id": "9a07d2ec24634364bfe703b24288abac"
        },
        {
            "m_Id": "cd8e0004d0024c258e2b86e3e06cfede"
        },
        {
            "m_Id": "be5bfa3abf3c4490bada295f31cb7eb9"
        },
        {
            "m_Id": "d169fcbdea0144808719ef05039948fa"
        }
    ]
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "cba913fcf6094a09a5ee8678c45aa306",
    "m_Id": 9,
    "m_DisplayName": "strandIndexColor",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "strandIndexColor",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Internal.BooleanShaderProperty",
    "m_ObjectId": "cd8e0004d0024c258e2b86e3e06cfede",
    "m_Guid": {
        "m_GuidSerialized": "30a1e851-b1d9-47ea-a659-654208c32b89"
    },
    "m_Name": "widthSet",
    "m_DefaultRefNameVersion": 0,
    "m_RefNameGeneratedByDisplayName": "",
    "m_DefaultReferenceName": "Boolean_cd8e0004d0024c258e2b86e3e06cfede",
    "m_OverrideReferenceName": "",
    "m_GeneratePropertyBlock": true,
    "m_UseCustomSlotLabel": false,
    "m_CustomSlotLabel": "",
    "m_DismissedVersion": 0,
    "m_Precision": 0,
    "overrideHLSLDeclaration": false,
    "hlslDeclarationOverride": 0,
    "m_Hidden": false,
    "m_Value": false
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector2MaterialSlot",
    "m_ObjectId": "cfdd09ee92b64c52a444c6dbfbfab079",
    "m_Id": 5,
    "m_DisplayName": "rootUV",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "rootUV",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector4MaterialSlot",
    "m_ObjectId": "d07f1adfb56246318209a869d288e959",
    "m_Id": 12,
    "m_DisplayName": "rootScale",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "rootScale",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 1,
    "m_Type": "UnityEditor.ShaderGraph.ShaderKeyword",
    "m_ObjectId": "d169fcbdea0144808719ef05039948fa",
    "m_Guid": {
        "m_GuidSerialized": "b2ed7e1d-5543-4811-a894-5f6eb3ac2a0c"
    },
    "m_Name": "PROCEDURAL_INSTANCING_ON",
    "m_DefaultRefNameVersion": 1,
    "m_RefNameGeneratedByDisplayName": "PROCEDURAL_INSTANCING_ON",
    "m_DefaultReferenceName": "_PROCEDURAL_INSTANCING_ON",
    "m_OverrideReferenceName": "PROCEDURAL_INSTANCING_ON",
    "m_GeneratePropertyBlock": true,
    "m_UseCustomSlotLabel": false,
    "m_CustomSlotLabel": "",
    "m_DismissedVersion": 0,
    "m_KeywordType": 0,
    "m_KeywordDefinition": 1,
    "m_KeywordScope": 1,
    "m_KeywordStages": 1,
    "m_Entries": [],
    "m_Value": 0,
    "m_IsEditable": true
}

{
    "m_SGVersion": 1,
    "m_Type": "UnityEditor.ShaderGraph.Internal.Vector1ShaderProperty",
    "m_ObjectId": "d3c05afc9b6a491e82ac2f9a438408ba",
    "m_Guid": {
        "m_GuidSerialized": "ef8f2b92-1164-4e4a-8a59-43e03cb67e8e"
    },
    "m_Name": "lodBias",
    "m_DefaultRefNameVersion": 0,
    "m_RefNameGeneratedByDisplayName": "",
    "m_DefaultReferenceName": "Vector1_d3c05afc9b6a491e82ac2f9a438408ba",
    "m_OverrideReferenceName": "",
    "m_GeneratePropertyBlock": true,
    "m_UseCustomSlotLabel": false,
    "m_CustomSlotLabel": "",
    "m_DismissedVersion": 0,
    "m_Precision": 0,
    "overrideHLSLDeclaration": false,
    "hlslDeclarationOverride": 0,
    "m_Hidden": false,
    "m_Value": 0.0,
    "m_FloatType": 0,
    "m_RangeValues": {
        "x": 0.0,
        "y": 1.0
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector2MaterialSlot",
    "m_ObjectId": "d9a8f5fb43c8406bae634089442e3f36",
    "m_Id": 22,
    "m_DisplayName": "surfaceUV",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfaceUV",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "dc03b823b63a4c02abcd7bb5df84d7a7",
    "m_Id": 13,
    "m_DisplayName": "lodOutputOpacity",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "lodOutputOpacity",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "de2852bb66784c618a8fad459141fbcd",
    "m_Id": 1,
    "m_DisplayName": "surfacePositionOS",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "surfacePositionOS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "e01cabb2bf704a3992601d5c2a8597e3",
    "m_Id": 25,
    "m_DisplayName": "lodOutputOpacity",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "lodOutputOpacity",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector4MaterialSlot",
    "m_ObjectId": "e9ad063d8e7a433ab72b40683be6242d",
    "m_Id": 0,
    "m_DisplayName": "packedID",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "packedID",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 1,
    "m_Type": "UnityEditor.ShaderGraph.CustomFunctionNode",
    "m_ObjectId": "ea544d11db68430789d144b6ff3e41e5",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Instancing (Custom Function)",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -315.9999694824219,
            "y": -329.0,
            "width": 204.0,
            "height": 93.99998474121094
        }
    },
    "m_Slots": [
        {
            "m_Id": "c05861ac10894331be42a8d3031bfabf"
        },
        {
            "m_Id": "3375da14f66044cda79600fc30781365"
        }
    ],
    "synonyms": [
        "code",
        "HLSL"
    ],
    "m_Precision": 0,
    "m_PreviewExpanded": false,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SourceType": 1,
    "m_FunctionName": "Instancing",
    "m_FunctionSource": "",
    "m_FunctionBody": "#pragma instancing_options assumeuniformscaling nomatrices nolodfade nolightprobe nolightmap procedural:HairVertexInstancingSetup\r\nOut = In;"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.StickyNoteData",
    "m_ObjectId": "ec0401e100fe40689801e8c8270ea16a",
    "m_Title": "Inline pragmas",
    "m_Content": "#pragma instancing_options ...",
    "m_TextSize": 0,
    "m_Theme": 0,
    "m_Position": {
        "serializedVersion": "2",
        "x": -312.0,
        "y": -434.0,
        "width": 205.0,
        "height": 100.0
    },
    "m_Group": {
        "m_Id": ""
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.NormalVectorNode",
    "m_ObjectId": "ef6dd66ac24042b184978d4a9a325284",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Normal Vector",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -391.0000305175781,
            "y": 26.999977111816408,
            "width": 206.0,
            "height": 132.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "74ab0201ea674934923073b77509e252"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": false,
    "m_DismissedVersion": 0,
    "m_PreviewMode": 2,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_Space": 0
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "f508586458f34f3487ad4b012db511b3",
    "m_Id": 0,
    "m_DisplayName": "widthMod",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "Out",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.StickyNoteData",
    "m_ObjectId": "f84496d497874313b7f614bbcb8c4c5d",
    "m_Title": "Topology mesh",
    "m_Content": "UV0.xyzw = packedID",
    "m_TextSize": 0,
    "m_Theme": 0,
    "m_Position": {
        "serializedVersion": "2",
        "x": -718.0,
        "y": -324.0,
        "width": 177.0,
        "height": 122.0
    },
    "m_Group": {
        "m_Id": ""
    }
}


```

`Runtime/HairVertex.shadersubgraph.meta`:

```meta
fileFormatVersion: 2
guid: 002d81e8bea19124fa7923b24cb10d46
ScriptedImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 2
  userData: 
  assetBundleName: 
  assetBundleVariant: 
  script: {fileID: 11500000, guid: 60072b568d64c40a485e0fc55012dc9f, type: 3}

```

`Runtime/HairVolume.hlsl`:

```hlsl
#ifndef __HAIRVOLUME_HLSL__
#define __HAIRVOLUME_HLSL__

#include "HairSimData.hlsl"
#include "HairSimComputeVolumeUtility.hlsl"

Texture3D _UntypedVolumeDensity;
Texture3D _UntypedVolumeVelocity;
Texture3D _UntypedVolumeScattering;

void HairVolume_float(
	in float3 in_positionWS,
	out float3 out_boundsMinWS,
	out float3 out_boundsMaxWS,
	out float3 out_cellCount,
	out float3 out_cellSizeWS,
	out float3 out_cellSizeUVW,
#if UNITY_VERSION >= 202023
	out UnityTexture3D out_volumeDensity,
	out UnityTexture3D out_volumeVelocity,
	out UnityTexture3D out_volumeScattering,
#else
	out Texture3D out_volumeDensity,
	out Texture3D out_volumeVelocity,
	out Texture3D out_volumeScattering,
#endif
	out float3 out_volumeUVW)
{
	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];
	{
		out_boundsMinWS = lodGrid.volumeWorldMin;
		out_boundsMaxWS = lodGrid.volumeWorldMax;
		out_cellCount = lodGrid.volumeCellCount;
		out_cellSizeWS = VolumeWorldCellSize(lodGrid);
		out_cellSizeUVW = 1.0f / lodGrid.volumeCellCount;
#if UNITY_VERSION >= 202023
		out_volumeDensity.tex = _UntypedVolumeDensity;
		out_volumeDensity.samplerstate = _Volume_trilinear_clamp;
		out_volumeVelocity.tex = _UntypedVolumeVelocity;
		out_volumeVelocity.samplerstate = _Volume_trilinear_clamp;
		out_volumeScattering.tex = _UntypedVolumeScattering;
		out_volumeScattering.samplerstate = _Volume_trilinear_clamp;
#else
		out_volumeDensity = _UntypedVolumeDensity;
		out_volumeVelocity = _UntypedVolumeVelocity;
		out_volumeScattering = _UntypedVolumeScattering;
#endif
		out_volumeUVW = VolumeWorldToUVW(lodGrid, in_positionWS);
	}
}

#endif//__HAIRVOLUME_HLSL__

```

`Runtime/HairVolume.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: a497841658a8d6a4392917d319ef6345
ShaderIncludeImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairVolume.shadersubgraph`:

```shadersubgraph
{
    "m_SGVersion": 2,
    "m_Type": "UnityEditor.ShaderGraph.GraphData",
    "m_ObjectId": "853831542a9a4df8b4a9070e1501856a",
    "m_Properties": [],
    "m_Keywords": [],
    "m_Nodes": [
        {
            "m_Id": "51009a9937724d72b9250896569a7909"
        },
        {
            "m_Id": "44f5e51a52784b51a33d7135c556dd57"
        },
        {
            "m_Id": "7406c6ca8ce74d7785a672de49f82e50"
        }
    ],
    "m_GroupDatas": [],
    "m_StickyNoteDatas": [],
    "m_Edges": [
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "44f5e51a52784b51a33d7135c556dd57"
                },
                "m_SlotId": 0
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "51009a9937724d72b9250896569a7909"
                },
                "m_SlotId": 2
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "44f5e51a52784b51a33d7135c556dd57"
                },
                "m_SlotId": 1
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "51009a9937724d72b9250896569a7909"
                },
                "m_SlotId": 3
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "44f5e51a52784b51a33d7135c556dd57"
                },
                "m_SlotId": 2
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "51009a9937724d72b9250896569a7909"
                },
                "m_SlotId": 1
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "44f5e51a52784b51a33d7135c556dd57"
                },
                "m_SlotId": 3
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "51009a9937724d72b9250896569a7909"
                },
                "m_SlotId": 4
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "44f5e51a52784b51a33d7135c556dd57"
                },
                "m_SlotId": 4
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "51009a9937724d72b9250896569a7909"
                },
                "m_SlotId": 5
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "44f5e51a52784b51a33d7135c556dd57"
                },
                "m_SlotId": 5
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "51009a9937724d72b9250896569a7909"
                },
                "m_SlotId": 6
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "44f5e51a52784b51a33d7135c556dd57"
                },
                "m_SlotId": 6
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "51009a9937724d72b9250896569a7909"
                },
                "m_SlotId": 7
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "44f5e51a52784b51a33d7135c556dd57"
                },
                "m_SlotId": 7
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "51009a9937724d72b9250896569a7909"
                },
                "m_SlotId": 8
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "44f5e51a52784b51a33d7135c556dd57"
                },
                "m_SlotId": 9
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "51009a9937724d72b9250896569a7909"
                },
                "m_SlotId": 9
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "7406c6ca8ce74d7785a672de49f82e50"
                },
                "m_SlotId": 0
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "44f5e51a52784b51a33d7135c556dd57"
                },
                "m_SlotId": 8
            }
        }
    ],
    "m_VertexContext": {
        "m_Position": {
            "x": 0.0,
            "y": 0.0
        },
        "m_Blocks": []
    },
    "m_FragmentContext": {
        "m_Position": {
            "x": 0.0,
            "y": 0.0
        },
        "m_Blocks": []
    },
    "m_PreviewData": {
        "serializedMesh": {
            "m_SerializedMesh": "{\"mesh\":{\"instanceID\":0}}",
            "m_Guid": ""
        }
    },
    "m_Path": "Hair",
    "m_ConcretePrecision": 0,
    "m_PreviewMode": 2,
    "m_OutputNode": {
        "m_Id": "51009a9937724d72b9250896569a7909"
    },
    "m_ActiveTargets": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "10876dfdf32342c38791107e1940072c",
    "m_Id": 5,
    "m_DisplayName": "cellCount",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "cellCount",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "21631d9815a941cd8960d18fd8017080",
    "m_Id": 2,
    "m_DisplayName": "boundsMinWS",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "boundsMinWS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Texture3DInputMaterialSlot",
    "m_ObjectId": "258a4ea550694367a9d0b66746120f9c",
    "m_Id": 4,
    "m_DisplayName": "volumeVelocity",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "volumeVelocity",
    "m_StageCapability": 3,
    "m_BareResource": false,
    "m_Texture": {
        "m_SerializedTexture": "{\"texture\":{\"instanceID\":0}}",
        "m_Guid": ""
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "3e9db22ad6284aff9ebe776b16f90e35",
    "m_Id": 0,
    "m_DisplayName": "boundsMinWS",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "boundsMinWS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 1,
    "m_Type": "UnityEditor.ShaderGraph.CustomFunctionNode",
    "m_ObjectId": "44f5e51a52784b51a33d7135c556dd57",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "HairVolume (Custom Function)",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -227.0,
            "y": -25.0,
            "width": 280.0,
            "height": 286.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "5b9dd4e620cc4093ad9ddf2fb9660e34"
        },
        {
            "m_Id": "3e9db22ad6284aff9ebe776b16f90e35"
        },
        {
            "m_Id": "736c7e965e9b4e098e25622e9a58ef33"
        },
        {
            "m_Id": "ad466168df7b4bbebcf6ef5822d13b0c"
        },
        {
            "m_Id": "c506afa3e0d34cc2953d5f72ae09a214"
        },
        {
            "m_Id": "a7df3f87e1ea4d84952be8096e614534"
        },
        {
            "m_Id": "924495cad2934d0db8d0f0261c132a5b"
        },
        {
            "m_Id": "5192fac8412240058b3299cd22003230"
        },
        {
            "m_Id": "8e9013651980415aa65f5e964c030481"
        },
        {
            "m_Id": "c126fe2487a34d7f8cfc58b828a8390d"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": false,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SourceType": 0,
    "m_FunctionName": "HairVolume",
    "m_FunctionSource": "a497841658a8d6a4392917d319ef6345",
    "m_FunctionBody": "Enter function body here..."
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "457b26deb901498dba8eb700cac872dd",
    "m_Id": 0,
    "m_DisplayName": "Out",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "Out",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "4acde2cb756043fca2203f20d4c6295e",
    "m_Id": 6,
    "m_DisplayName": "cellSizeWS",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "cellSizeWS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.SubGraphOutputNode",
    "m_ObjectId": "51009a9937724d72b9250896569a7909",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Output",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 133.0,
            "y": -25.0,
            "width": 197.0,
            "height": 269.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "21631d9815a941cd8960d18fd8017080"
        },
        {
            "m_Id": "f7f8e77fb5f24c3bbd97211ed2e450fb"
        },
        {
            "m_Id": "10876dfdf32342c38791107e1940072c"
        },
        {
            "m_Id": "4acde2cb756043fca2203f20d4c6295e"
        },
        {
            "m_Id": "b7bc2982c849488391a1dc2b9c3a54fb"
        },
        {
            "m_Id": "9e2dea2dbbb741adb788771f234a5ace"
        },
        {
            "m_Id": "258a4ea550694367a9d0b66746120f9c"
        },
        {
            "m_Id": "bc701a7ba6af4598b012b9c4683c4eb9"
        },
        {
            "m_Id": "80c63f71e91d4ed1bda87d655a1784cf"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_PreviewMode": 0,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "IsFirstSlotValid": true
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Texture3DMaterialSlot",
    "m_ObjectId": "5192fac8412240058b3299cd22003230",
    "m_Id": 3,
    "m_DisplayName": "volumeVelocity",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "volumeVelocity",
    "m_StageCapability": 3,
    "m_BareResource": false
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "5b9dd4e620cc4093ad9ddf2fb9660e34",
    "m_Id": 8,
    "m_DisplayName": "positionWS",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "positionWS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "736c7e965e9b4e098e25622e9a58ef33",
    "m_Id": 1,
    "m_DisplayName": "boundsMaxWS",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "boundsMaxWS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 1,
    "m_Type": "UnityEditor.ShaderGraph.PositionNode",
    "m_ObjectId": "7406c6ca8ce74d7785a672de49f82e50",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Position",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -492.0,
            "y": -25.0,
            "width": 208.0,
            "height": 316.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "457b26deb901498dba8eb700cac872dd"
        }
    ],
    "synonyms": [],
    "m_Precision": 1,
    "m_PreviewExpanded": false,
    "m_PreviewMode": 2,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_Space": 4
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "80c63f71e91d4ed1bda87d655a1784cf",
    "m_Id": 8,
    "m_DisplayName": "volumeUVW",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "volumeUVW",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Texture3DMaterialSlot",
    "m_ObjectId": "8e9013651980415aa65f5e964c030481",
    "m_Id": 9,
    "m_DisplayName": "volumeScattering",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "volumeScattering",
    "m_StageCapability": 3,
    "m_BareResource": false
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Texture3DMaterialSlot",
    "m_ObjectId": "924495cad2934d0db8d0f0261c132a5b",
    "m_Id": 2,
    "m_DisplayName": "volumeDensity",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "volumeDensity",
    "m_StageCapability": 3,
    "m_BareResource": false
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Texture3DInputMaterialSlot",
    "m_ObjectId": "9e2dea2dbbb741adb788771f234a5ace",
    "m_Id": 1,
    "m_DisplayName": "volumeDensity",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "volumeDensity",
    "m_StageCapability": 3,
    "m_BareResource": false,
    "m_Texture": {
        "m_SerializedTexture": "{\"texture\":{\"instanceID\":0}}",
        "m_Guid": ""
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "a7df3f87e1ea4d84952be8096e614534",
    "m_Id": 6,
    "m_DisplayName": "cellSizeUVW",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "cellSizeUVW",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "ad466168df7b4bbebcf6ef5822d13b0c",
    "m_Id": 4,
    "m_DisplayName": "cellCount",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "cellCount",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "b7bc2982c849488391a1dc2b9c3a54fb",
    "m_Id": 7,
    "m_DisplayName": "cellSizeUVW",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "cellSizeUVW",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Texture3DInputMaterialSlot",
    "m_ObjectId": "bc701a7ba6af4598b012b9c4683c4eb9",
    "m_Id": 9,
    "m_DisplayName": "volumeScattering",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "volumeScattering",
    "m_StageCapability": 3,
    "m_BareResource": false,
    "m_Texture": {
        "m_SerializedTexture": "{\"texture\":{\"instanceID\":0}}",
        "m_Guid": ""
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "c126fe2487a34d7f8cfc58b828a8390d",
    "m_Id": 7,
    "m_DisplayName": "volumeUVW",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "volumeUVW",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "c506afa3e0d34cc2953d5f72ae09a214",
    "m_Id": 5,
    "m_DisplayName": "cellSizeWS",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "cellSizeWS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "f7f8e77fb5f24c3bbd97211ed2e450fb",
    "m_Id": 3,
    "m_DisplayName": "boundsMaxWS",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "boundsMaxWS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}


```

`Runtime/HairVolume.shadersubgraph.meta`:

```meta
fileFormatVersion: 2
guid: 34afd29dc7e672f449c09a95f3c42b26
ScriptedImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 2
  userData: 
  assetBundleName: 
  assetBundleVariant: 
  script: {fileID: 11500000, guid: 60072b568d64c40a485e0fc55012dc9f, type: 3}

```

`Runtime/HairVolumeUVW.hlsl`:

```hlsl
#ifndef __HAIRVOLUMEUVW_HLSL__
#define __HAIRVOLUMEUVW_HLSL__

#include "HairSimComputeVolumeUtility.hlsl"

void HairVolumeUVW_float(
	in float3 in_positionWS,
	out float3 out_volumeUVW)
{
	const VolumeLODGrid lodGrid = _VolumeLODStage[VOLUMELODSTAGE_RESOLVE];
	{
		out_volumeUVW = VolumeWorldToUVW(lodGrid, in_positionWS);
	}
}

#endif//__HAIRVOLUMEUVW_HLSL__

```

`Runtime/HairVolumeUVW.hlsl.meta`:

```meta
fileFormatVersion: 2
guid: a3eee4c42d07b5e46b3a7eb8ec397fa8
ShaderIncludeImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairVolumeUVW.shadersubgraph`:

```shadersubgraph
{
    "m_SGVersion": 2,
    "m_Type": "UnityEditor.ShaderGraph.GraphData",
    "m_ObjectId": "c14ec9b44dd64f71a7174984823c30da",
    "m_Properties": [
        {
            "m_Id": "8194fe7fad084511b784c75f4156dafd"
        }
    ],
    "m_Keywords": [],
    "m_Nodes": [
        {
            "m_Id": "8782d03613464f57b38e31ecc9dbae03"
        },
        {
            "m_Id": "14968d617c834a3c8243c6045463a9f6"
        },
        {
            "m_Id": "dcf52c381331461f97217510cf2fba59"
        }
    ],
    "m_GroupDatas": [],
    "m_StickyNoteDatas": [],
    "m_Edges": [
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "14968d617c834a3c8243c6045463a9f6"
                },
                "m_SlotId": 1
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "8782d03613464f57b38e31ecc9dbae03"
                },
                "m_SlotId": 1
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "dcf52c381331461f97217510cf2fba59"
                },
                "m_SlotId": 0
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "14968d617c834a3c8243c6045463a9f6"
                },
                "m_SlotId": 0
            }
        }
    ],
    "m_VertexContext": {
        "m_Position": {
            "x": 0.0,
            "y": 0.0
        },
        "m_Blocks": []
    },
    "m_FragmentContext": {
        "m_Position": {
            "x": 0.0,
            "y": 0.0
        },
        "m_Blocks": []
    },
    "m_PreviewData": {
        "serializedMesh": {
            "m_SerializedMesh": "{\"mesh\":{\"instanceID\":0}}",
            "m_Guid": ""
        }
    },
    "m_Path": "Hair",
    "m_ConcretePrecision": 0,
    "m_OutputNode": {
        "m_Id": "8782d03613464f57b38e31ecc9dbae03"
    },
    "m_ActiveTargets": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "13b6b101c5364582a33f1d24e14beaa5",
    "m_Id": 0,
    "m_DisplayName": "positionWS",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "Out",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.CustomFunctionNode",
    "m_ObjectId": "14968d617c834a3c8243c6045463a9f6",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Custom Function",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -220.0,
            "y": -77.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "99889ec9503d4047a6cf10f1341606c3"
        },
        {
            "m_Id": "9736d29d5ea94ed895e4b67688fc392f"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": false,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SourceType": 0,
    "m_FunctionName": "HairVolumeUVW",
    "m_FunctionSource": "a3eee4c42d07b5e46b3a7eb8ec397fa8",
    "m_FunctionBody": "Enter function body here..."
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "37a1f7253f6949b2a783866bd3b3d115",
    "m_Id": 1,
    "m_DisplayName": "volumeUVW",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "volumeUVW",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 1,
    "m_Type": "UnityEditor.ShaderGraph.Internal.Vector3ShaderProperty",
    "m_ObjectId": "8194fe7fad084511b784c75f4156dafd",
    "m_Guid": {
        "m_GuidSerialized": "8a0965fc-cbc4-4422-bbed-bad5c9cb33b5"
    },
    "m_Name": "positionWS",
    "m_DefaultReferenceName": "Vector3_8194fe7fad084511b784c75f4156dafd",
    "m_OverrideReferenceName": "",
    "m_GeneratePropertyBlock": true,
    "m_Precision": 0,
    "overrideHLSLDeclaration": false,
    "hlslDeclarationOverride": 0,
    "m_Hidden": false,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.SubGraphOutputNode",
    "m_ObjectId": "8782d03613464f57b38e31ecc9dbae03",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Output",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 69.0,
            "y": -77.0,
            "width": 119.0,
            "height": 77.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "37a1f7253f6949b2a783866bd3b3d115"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "IsFirstSlotValid": true
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "9736d29d5ea94ed895e4b67688fc392f",
    "m_Id": 1,
    "m_DisplayName": "volumeUVW",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "volumeUVW",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector3MaterialSlot",
    "m_ObjectId": "99889ec9503d4047a6cf10f1341606c3",
    "m_Id": 0,
    "m_DisplayName": "positionWS",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "positionWS",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.PropertyNode",
    "m_ObjectId": "dcf52c381331461f97217510cf2fba59",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Property",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -404.0,
            "y": -37.0,
            "width": 138.0,
            "height": 34.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "13b6b101c5364582a33f1d24e14beaa5"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_Property": {
        "m_Id": "8194fe7fad084511b784c75f4156dafd"
    }
}


```

`Runtime/HairVolumeUVW.shadersubgraph.meta`:

```meta
fileFormatVersion: 2
guid: 961586fe1d3fc884db8b3228e109861c
ScriptedImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 2
  userData: 
  assetBundleName: 
  assetBundleVariant: 
  script: {fileID: 11500000, guid: 60072b568d64c40a485e0fc55012dc9f, type: 3}

```

`Runtime/HairWind.Gizmos.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using Unity.Mathematics;

namespace Unity.DemoTeam.Hair
{
	public partial class HairWind
	{
		void OnDrawGizmosSelected()
		{
			var data = new RuntimeData();
			{
				if (TryGetData(this, ref data))
				{
					DrawGizmosRuntimeData(data, Time.time, Time.deltaTime, active: isActiveAndEnabled, selected: true);
				}
			}
		}

		public static void DrawGizmosRuntimeData(in RuntimeData data, float t, float dt, bool active, bool selected)
		{
			DrawGizmosRuntimeEmitter(data, selected ? 1.0f : 0.5f);

			if (selected)
			{
				if (active)
				{
					DrawGizmosRuntimeEmitterFlow(data, selected ? 1.0f : 0.5f, 256, t, dt);
				}

				//DrawGizmosRuntimeEmitterGrid(data, 16);
			}
		}

		static void DrawGizmosRuntimeEmitter(in RuntimeData data, float opacity)
		{
			Gizmos.color = Color.Lerp(Color.clear, Color.cyan, opacity);
			Gizmos.matrix = Matrix4x4.identity;

			switch (data.type)
			{
				case RuntimeData.Type.Directional:
					{
						var p = data.emitter.p - data.emitter.n * 0.5f;
						var q = p + data.emitter.n;
						var r = p + data.emitter.n * 0.9f;

						var ux = data.gizmo.rotation * Vector3.right;
						var uy = data.gizmo.rotation * Vector3.up;

						var r00 = r + ux * 0.1f;
						var r01 = r + uy * 0.1f;
						var r10 = r - ux * 0.1f;
						var r11 = r - uy * 0.1f;

						Gizmos.DrawLine(p, q);
						Gizmos.DrawLine(q, r00);
						Gizmos.DrawLine(q, r01);
						Gizmos.DrawLine(q, r10);
						Gizmos.DrawLine(q, r11);
					}
					break;

				case RuntimeData.Type.Spherical:
					{
						Gizmos.matrix = Matrix4x4.TRS(data.emitter.p, data.gizmo.rotation, Vector3.one);
						Gizmos.DrawWireSphere(Vector3.zero, 0.5f);
					}
					break;

				case RuntimeData.Type.Turbine:
					{
						var t0 = data.emitter.t0;
						var t1 = t0 + data.gizmo.turbineNozzleOffset;

						var h0 = data.emitter.h0;
						var h1 = 0.5f * data.gizmo.turbineNozzleWidth;

						var p0 = data.emitter.p + data.emitter.n * t0;
						var p1 = data.emitter.p + data.emitter.n * t1;

						var ux = data.gizmo.rotation * Vector3.right;
						var uy = data.gizmo.rotation * Vector3.up;

						Gizmos.DrawRay(p0 + uy * h0, (data.emitter.n + data.emitter.m * uy) * (t1 - t0));
						Gizmos.DrawRay(p0 - uy * h0, (data.emitter.n - data.emitter.m * uy) * (t1 - t0));
						Gizmos.DrawRay(p0 + ux * h0, (data.emitter.n + data.emitter.m * ux) * (t1 - t0));
						Gizmos.DrawRay(p0 - ux * h0, (data.emitter.n - data.emitter.m * ux) * (t1 - t0));

						Gizmos.matrix = Matrix4x4.TRS(p0, data.gizmo.rotation, Vector3.one);
						DrawGizmosWireCircleZ(Vector3.zero, h0);

						Gizmos.matrix = Matrix4x4.TRS(p1, data.gizmo.rotation, Vector3.one);
						DrawGizmosWireCircleZ(Vector3.zero, h1);
					}
					break;
			}
		}

		static void DrawGizmosRuntimeEmitterFlow(in RuntimeData data, float opacity, uint samples, float t, float dt)
		{
			dt = Mathf.Clamp(dt, 1.0f / 120.0f, 1.0f / 15.0f);

			Gizmos.color = Color.Lerp(Color.clear, Color.cyan, opacity * 0.6f);
			Gizmos.matrix = Matrix4x4.identity;

			var Lv = data.emitter.v + 0.5f * data.emitter.A;//TODO replace average with something that is more meaningful visually
			var Lt = 3.0f;// flow line lifetime
			var Ld = math.abs(Lv * Lt);
			var Nt = math.frac(t / Lt);

			var ux = data.gizmo.rotation * Vector3.right;
			var uy = data.gizmo.rotation * Vector3.up;

			for (uint i = 0; i != samples; i++)
			{
				var j = (uint)(i + samples * Nt) % samples;
				var R = Mathematics.Random.CreateFromIndex(j);

				var p = data.emitter.p;
				{
					switch (data.type)
					{
						case RuntimeData.Type.Directional:
							{
								var h = 3.0f;
								var k = R.NextFloat3();
								p.x += (k.x * 2.0f - 1.0f) * h - (0.5f * Ld) * data.emitter.n.x;
								p.y += (k.y * 2.0f - 1.0f) * h - (0.5f * Ld) * data.emitter.n.y;
								p.z += (k.z * 2.0f - 1.0f) * h - (0.5f * Ld) * data.emitter.n.z;
							}
							break;

						case RuntimeData.Type.Spherical:
							{
								var k = R.NextFloat3Direction();
								p.x += 1e-4f * k.x;
								p.y += 1e-4f * k.y;
								p.z += 1e-4f * k.z;
							}
							break;
								
						case RuntimeData.Type.Turbine:
							{
								var k = R.NextFloat2();
								var h = data.emitter.h0 + 1e-4f * data.emitter.m;
								math.sincos(2.0f * Mathf.PI * k.x, out var sina, out var cosa);
								p.x += (k.y * cosa * h) * ux.x + (k.y * sina * h) * uy.x + (1e-4f + data.emitter.t0) * data.emitter.n.x;
								p.y += (k.y * cosa * h) * ux.y + (k.y * sina * h) * uy.y + (1e-4f + data.emitter.t0) * data.emitter.n.y;
								p.z += (k.y * cosa * h) * ux.z + (k.y * sina * h) * uy.z + (1e-4f + data.emitter.t0) * data.emitter.n.z;
							}
							break;
					}
				}

				var n = (data.emitter.m == 0.0f) ? data.emitter.n : (Vector3.Normalize(p - data.emitter.p));
				var s = math.frac(Nt + (float)j / samples);

				if (Vector3.Dot(n, data.emitter.n) < 0.0f)
				{
					n = -n;
				}

				if (Lv < 0.0f)
				{
					Gizmos.DrawRay(p + n * (Ld - Ld * s), n * -(Lv * dt));
				}
				else
				{
					Gizmos.DrawRay(p + n * Ld * s, n * (Lv * dt));
				}
			}
		}

		static void DrawGizmosRuntimeEmitterGrid(in RuntimeData data, uint samples)
		{
			Gizmos.color = Color.cyan;
			Gizmos.matrix = Matrix4x4.identity;

			var colorPass = Color.green;
			var colorFail = Color.cyan;
			{
				colorFail.a = 0.1f;
			}

			var size = 4.0f;
			var step = size / (samples - 1);

			var pext = (0.5f * size) * Vector3.one;
			var pmin = data.emitter.p - pext;

			if (data.type == RuntimeData.Type.Turbine)
			{
				pmin += data.emitter.n * data.emitter.t0;
			}

			for (uint i = 0; i != samples; i++)
			{
				for (uint j = 0; j != samples; j++)
				{
					for (uint k = 0; k != samples; k++)
					{
						var p = pmin;
						{
							p.x += step * i;
							p.y += step * j;
							p.z += step * k;
						}

						var r = p - data.emitter.p;
						var t = Vector3.Dot(data.emitter.n, r);
						var h = data.emitter.m * (t - data.emitter.t0) + data.emitter.h0;

						var a = r - data.emitter.n * t;
						var b = Vector3.SqrMagnitude(a);

						var bInside = (b <= h * h);
						var bFacing = (t >= data.emitter.t0);

						var n = (0.5f * step) * ((data.emitter.m == 0.0f) ? data.emitter.n : Vector3.Normalize(r) * Mathf.Sign(t));

						Gizmos.color = (bInside && bFacing) ? colorPass : colorFail;
						Gizmos.DrawRay(p - 0.5f * n, n);
					}
				}
			}
		}

		static void DrawGizmosWireCircleZ(in Vector3 center, float radius)
		{
			var stepCount = 16;
			var stepTheta = (2.0f * Mathf.PI) / stepCount;

			math.sincos(-stepTheta, out var sina, out var cosa);
			var pointPrev = new Vector3(center.x + radius * cosa, center.y + radius * sina, center.z);

			for (int i = 0; i != stepCount; i++)
			{
				math.sincos(i * stepTheta, out sina, out cosa);
				var point = new Vector3(center.x + radius * cosa, center.y + radius * sina, center.z);

				Gizmos.DrawLine(point, pointPrev);

				pointPrev = point;
			}
		}
	}
}

```

`Runtime/HairWind.Gizmos.cs.meta`:

```meta
fileFormatVersion: 2
guid: 998a398c03d0a5e42a4df00feaaee4c0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairWind.Settings.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using Unity.Mathematics;

namespace Unity.DemoTeam.Hair
{
	public partial class HairWind
	{
		[Serializable]
		public struct SettingsEmitter
		{
			public enum Mode
			{
				BindToComponent,
				Standalone,
			}

			public enum Type
			{
				Directional,// binds to component -> WindZone (Directional)
				Spherical,  // binds to component -> WindZone (Spherical)
				Turbine,
				Any,
			}

			[LineHeader("Mode")]

			public Mode mode;
			public Type type;

			public static readonly SettingsEmitter defaults = new SettingsEmitter
			{
				mode = Mode.Standalone,
				type = Type.Directional,
			};
		}

		[Serializable]
		public struct SettingsDirectional
		{
			public static readonly SettingsDirectional defaults = new SettingsDirectional { };
		}

		[Serializable]
		public struct SettingsSpherical
		{
			public static readonly SettingsSpherical defaults = new SettingsSpherical { };
		}

		[Serializable]
		public struct SettingsTurbine
		{
			[LineHeader("Geometry")]

			[Tooltip("Turbine base width (in meters)")]
			public float baseWidth;
			[Tooltip("Turbine nozzle width (in meters)")]
			public float nozzleWidth;
			[Tooltip("Turbine nozzle offset (in meters)")]
			public float nozzleOffset;

			public static readonly SettingsTurbine defaults = new SettingsTurbine
			{
				baseWidth = 1.0f,
				nozzleWidth = 1.5f,
				nozzleOffset = 1.0f,
			};
		}

		[Serializable]
		public struct SettingsFlow
		{
			public enum JitterSpace
			{
				Planar,
				Global,
			}

			[LineHeader("Flow")]

			[Tooltip("Base speed (in meters per second)")]
			public float baseSpeed;
			[Tooltip("Pulse amplitude (in meters per second)")]
			public float pulseAmplitude;
			[Tooltip("Pulse frequency (in cycles per second)")]
			public float pulseFrequency;

			[LineHeader("Noise")]

			[ToggleGroup, Tooltip("Enable noise-based timing jitter (to reduce uniformity of pulses)")]
			public bool timingJitter;
			[ToggleGroupItem, Tooltip("Controls whether the timing jitter varies over the emitter surface only (planar) or over the entire volume (global)")]
			public JitterSpace timingJitterSpace;
			[ToggleGroupItem, Range(0.0f, 4.0f), Tooltip("Timing jitter displacement (in pulse cycles)")]
			public float timingJitterDisplacement;
			[EditableIf(nameof(timingJitter), true), Tooltip("Timing jitter resolution (in noise cells per meter)")]
			public float timingJitterResolution;

			public static readonly SettingsFlow defaults = new SettingsFlow
			{
				baseSpeed = 0.25f,
				pulseAmplitude = 1.0f,
				pulseFrequency = 0.25f,

				timingJitter = true,
				timingJitterSpace = JitterSpace.Planar,
				timingJitterDisplacement = 0.25f,
				timingJitterResolution = 1.0f,
			};
		}
	}
}
```

`Runtime/HairWind.Settings.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6610d74f9d2b3404c8c8b14b36b71599
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairWind.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	[ExecuteAlways]
	public partial class HairWind : MonoBehaviour
	{
		public SettingsEmitter settingsEmitter = SettingsEmitter.defaults;
		public SettingsDirectional settingsDirectional = SettingsDirectional.defaults;
		public SettingsSpherical settingsSpherical = SettingsSpherical.defaults;
		public SettingsTurbine settingsTurbine = SettingsTurbine.defaults;
		public SettingsFlow settingsFlow = SettingsFlow.defaults;

		//--------------
		// runtime data

		public struct RuntimeData
		{
			public enum Type
			{
				Directional,
				Spherical,
				Turbine,
				Plane,
			}

			public Type type;
			public RuntimeTransform xform;
			public RuntimeEmitter emitter;
			public RuntimeGizmo gizmo;
		}

		public struct RuntimeTransform
		{
			public int handle;
		}

		public struct RuntimeEmitter
		{
			public Vector3 p;	// emitter origin
			public Vector3 n;	// emitter forward
			public float t0;	// emitter base offset
			public float h0;	// emitter base radius
			public float m;		// emitter slope

			public float v;		// flow speed
			public float A;		// flow pulse amplitude
			public float f;		// flow pulse frequency

			public float jd;	// jitter displacement
			public float jw;	// jitter resolution
			public float jp;	// jitter planar
		}

		public struct RuntimeGizmo
		{
			public Quaternion rotation;
			public float turbineBaseWidth;
			public float turbineNozzleWidth;
			public float turbineNozzleOffset;
		}

		//--------------------
		// runtime conversion

#if HAS_MODULE_WIND
		public static SettingsFlow MakeSettingsFlow(WindZone windZone)
		{
			return new SettingsFlow
			{
				baseSpeed = windZone.windMain,
				pulseAmplitude = windZone.windPulseMagnitude,
				pulseFrequency = windZone.windPulseFrequency,

				timingJitter = false,
				timingJitterDisplacement = 0.0f,
				timingJitterResolution = 0.0f,
			};
		}
#endif

#if HAS_MODULE_WIND
		public static RuntimeData GetRuntimeDirectional(WindZone windZone) => GetRuntimeDirectional(windZone.transform, MakeSettingsFlow(windZone), new SettingsDirectional { });
#endif
		public static RuntimeData GetRuntimeDirectional(Transform transform, in SettingsFlow flow, in SettingsDirectional directional)
		{
			return new RuntimeData
			{
				type = RuntimeData.Type.Directional,
				xform = new RuntimeTransform
				{
					handle = transform.GetInstanceID(),
				},
				emitter = new RuntimeEmitter
				{
					p = transform.position,
					n = transform.forward,

					t0 = float.MinValue,
					h0 = float.PositiveInfinity,
					m = 0.0f,

					v = flow.baseSpeed,
					A = flow.pulseAmplitude,
					f = flow.pulseFrequency,

					jd = flow.timingJitter ? flow.timingJitterDisplacement : 0.0f,
					jw = flow.timingJitterResolution,
					jp = (flow.timingJitterSpace == SettingsFlow.JitterSpace.Planar) ? 1.0f : 0.0f,
				},
				gizmo = new RuntimeGizmo
				{
					rotation = transform.rotation,
				},
			};
		}

#if HAS_MODULE_WIND
		public static RuntimeData GetRuntimeSpherical(WindZone windZone) => GetRuntimeSpherical(windZone.transform, MakeSettingsFlow(windZone), new SettingsSpherical { });
#endif
		public static RuntimeData GetRuntimeSpherical(Transform transform, in SettingsFlow flow, in SettingsSpherical spherical)
		{
			return new RuntimeData
			{
				type = RuntimeData.Type.Spherical,
				xform = new RuntimeTransform
				{
					handle = transform.GetInstanceID(),
				},
				emitter = new RuntimeEmitter
				{
					p = transform.position,
					n = Vector3.zero,

					t0 = 0.0f,
					h0 = float.PositiveInfinity,
					m = float.PositiveInfinity,

					v = flow.baseSpeed,
					A = flow.pulseAmplitude,
					f = flow.pulseFrequency,

					jd = flow.timingJitter ? flow.timingJitterDisplacement : 0.0f,
					jw = flow.timingJitterResolution,
					jp = (flow.timingJitterSpace == SettingsFlow.JitterSpace.Planar) ? 1.0f : 0.0f,
				},
				gizmo = new RuntimeGizmo
				{
					rotation = transform.rotation,
				},
			};
		}

		public static RuntimeData GetRuntimeTurbine(Transform transform, in SettingsFlow flow, SettingsTurbine turbine)
		{
			var lossyScaleAbs = transform.lossyScale.Abs();
			var lossyScaleAbsMax = lossyScaleAbs.CMax();

			var t0 = 0.0f;
			var h0 = 0.5f * turbine.baseWidth;
			var m = 0.0f;
			{
				var dt = turbine.nozzleOffset;
				if (dt != 0.0f)
				{
					var dh = 0.5f * (turbine.nozzleWidth - turbine.baseWidth);
					if (dh != 0.0f)
					{
						// calc slope
						m = dh / dt;

						// calc base offset
						t0 = h0 / m;
					}
				}
			}

			t0 *= lossyScaleAbsMax;
			h0 *= lossyScaleAbsMax;

			return new RuntimeData
			{
				type = RuntimeData.Type.Turbine,
				xform = new RuntimeTransform
				{
					handle = transform.GetInstanceID(),
				},
				emitter = new RuntimeEmitter
				{
					p = transform.position - t0 * transform.forward,
					n = transform.forward,

					t0 = t0,
					h0 = h0,
					m = m,

					v = flow.baseSpeed,
					A = flow.pulseAmplitude,
					f = flow.pulseFrequency,

					jd = flow.timingJitter ? flow.timingJitterDisplacement : 0.0f,
					jw = flow.timingJitterResolution,
					jp = (flow.timingJitterSpace == SettingsFlow.JitterSpace.Planar) ? 1.0f : 0.0f,
				},
				gizmo = new RuntimeGizmo
				{
					rotation = transform.rotation,
					turbineNozzleWidth = turbine.nozzleWidth * lossyScaleAbsMax,
					turbineNozzleOffset = turbine.nozzleOffset * lossyScaleAbsMax,
				},
			};
		}

		//-----------
		// accessors

		public static bool TryGetData(HairWind wind, ref RuntimeData data)
		{
			if (wind.settingsEmitter.mode == SettingsEmitter.Mode.BindToComponent)
			{
				if (TryGetMatchingComponent(wind, out var component))
				{
					return TryGetComponentData(component, ref data);
				}
			}
			else
			{
				return TryGetStandaloneData(wind, ref data);
			}
			return false;
		}

		public static bool TryGetMatchingComponent(HairWind wind, SettingsEmitter.Type type, out Component component)
		{
#if HAS_MODULE_WIND
			var windZone = wind.GetComponent<WindZone>();
			if (windZone == null)
				windZone = null;

			switch (type)
			{
				case SettingsEmitter.Type.Directional:
					component = (windZone?.mode == WindZoneMode.Directional ? windZone : null); break;
				case SettingsEmitter.Type.Spherical:
					component = (windZone?.mode == WindZoneMode.Spherical ? windZone : null); break;
				default:
					component = null; break;
			}
#else
			component = null;
#endif
			return (component != null);
		}

		public static bool TryGetMatchingComponent(HairWind wind, out Component component)
		{
			if (wind.settingsEmitter.type == SettingsEmitter.Type.Any)
			{
				return
					TryGetMatchingComponent(wind, SettingsEmitter.Type.Directional, out component) ||
					TryGetMatchingComponent(wind, SettingsEmitter.Type.Spherical, out component);
			}
			else
			{
				return TryGetMatchingComponent(wind, wind.settingsEmitter.type, out component);
			}
		}

		public static bool TryGetComponentData(Component component, ref RuntimeData data)
		{
#if HAS_MODULE_WIND
			var windZone = component as WindZone;
			if (windZone == null)
				windZone = component.GetComponent<WindZone>();

			if (windZone != null)
			{
				switch (windZone.mode)
				{
					case WindZoneMode.Directional:
						data = GetRuntimeDirectional(windZone); return true;
					case WindZoneMode.Spherical:
						data = GetRuntimeSpherical(windZone); return true;
				}
			}
#endif
			return false;
		}

		public static bool TryGetStandaloneData(HairWind wind, ref RuntimeData data)
		{
			switch (wind.settingsEmitter.type)
			{
				case SettingsEmitter.Type.Directional:
					data = GetRuntimeDirectional(wind.transform, wind.settingsFlow, wind.settingsDirectional); return true;
				case SettingsEmitter.Type.Spherical:
					data = GetRuntimeSpherical(wind.transform, wind.settingsFlow, wind.settingsSpherical); return true;
				case SettingsEmitter.Type.Turbine:
					data = GetRuntimeTurbine(wind.transform, wind.settingsFlow, wind.settingsTurbine); return true;
				default:
					return false;
			}
		}
	}
}
```

`Runtime/HairWind.cs.meta`:

```meta
fileFormatVersion: 2
guid: c2704fd1c0e5e1d499d5c380296977a1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {fileID: 2800000, guid: d74de52c28819254c985180c7e1fe85f, type: 3}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/HairWindUtility.cs`:

```cs
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public struct HairWindProxy : ISpatialComponentProxy<HairWind, HairWind.RuntimeData>
	{
		public bool TryGetData(HairWind component, ref HairWind.RuntimeData data)
			=> HairWind.TryGetData(component, ref data);
		public bool TryGetComponentData(Component component, ref HairWind.RuntimeData data)
			=> HairWind.TryGetComponentData(component, ref data);

		public int ResolveDataHandle(in HairWind.RuntimeData data)
			=> data.xform.handle;
		public float ResolveDataDistance(in HairWind.RuntimeData data, in Vector3 p)
			=> HairWindUtility.SdWind(p, data);
	}

	public static class HairWindUtility
	{
		//-----------------
		// signed distance

		public static float SdWind(in Vector3 p, in HairWind.RuntimeData data)
		{
			switch (data.type)
			{
				case HairWind.RuntimeData.Type.Directional:
					return 0.0f;

				case HairWind.RuntimeData.Type.Spherical:
					return Vector3.Distance(p, data.emitter.p);

				case HairWind.RuntimeData.Type.Turbine:
					return Vector3.Distance(p, data.emitter.p + data.emitter.n * data.emitter.t0);
			}
			return 1e+7f;
		}
	}
}

```

`Runtime/HairWindUtility.cs.meta`:

```meta
fileFormatVersion: 2
guid: e38b344f277912f4dbc8434ffbe7c541
```

`Runtime/Icons.meta`:

```meta
fileFormatVersion: 2
guid: 58c2f82d06bd3c04da428afa1e13d706
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Icons/HairAsset.png.meta`:

```meta
fileFormatVersion: 2
guid: e23706d7155887b49bd53435ba6aabb5
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 13
  mipmaps:
    mipMapMode: 0
    enableMipMap: 1
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
    flipGreenChannel: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  vTOnly: 0
  ignoreMipmapLimit: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: 1
    aniso: 1
    mipBias: 0
    wrapU: 0
    wrapV: 0
    wrapW: 0
  nPOTScale: 1
  lightmap: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 1
  spriteTessellationDetail: -1
  textureType: 0
  textureShape: 1
  singleChannelComponent: 0
  flipbookRows: 1
  flipbookColumns: 1
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  ignorePngGamma: 0
  applyGammaDecoding: 0
  swizzle: 50462976
  cookieLightType: 0
  platformSettings:
  - serializedVersion: 3
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Standalone
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 
    internalID: 0
    vertices: []
    indices: 
    edges: []
    weights: []
    secondaryTextures: []
    nameFileIdTable: {}
  mipmapLimitGroupName: 
  pSDRemoveMatte: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Icons/HairBoundary.png.meta`:

```meta
fileFormatVersion: 2
guid: 4fbe4c10ffe8d6e4c823c425851d8cac
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 13
  mipmaps:
    mipMapMode: 0
    enableMipMap: 1
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
    flipGreenChannel: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  vTOnly: 0
  ignoreMipmapLimit: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: 1
    aniso: 1
    mipBias: 0
    wrapU: 0
    wrapV: 0
    wrapW: 0
  nPOTScale: 1
  lightmap: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 1
  spriteTessellationDetail: -1
  textureType: 0
  textureShape: 1
  singleChannelComponent: 0
  flipbookRows: 1
  flipbookColumns: 1
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  ignorePngGamma: 0
  applyGammaDecoding: 0
  swizzle: 50462976
  cookieLightType: 0
  platformSettings:
  - serializedVersion: 3
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Standalone
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 
    internalID: 0
    vertices: []
    indices: 
    edges: []
    weights: []
    secondaryTextures: []
    nameFileIdTable: {}
  mipmapLimitGroupName: 
  pSDRemoveMatte: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Icons/HairInstance.png.meta`:

```meta
fileFormatVersion: 2
guid: b10206d371a26e5428e4abde9978d769
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 13
  mipmaps:
    mipMapMode: 0
    enableMipMap: 1
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
    flipGreenChannel: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  vTOnly: 0
  ignoreMipmapLimit: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: 1
    aniso: 1
    mipBias: 0
    wrapU: 0
    wrapV: 0
    wrapW: 0
  nPOTScale: 1
  lightmap: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 1
  spriteTessellationDetail: -1
  textureType: 0
  textureShape: 1
  singleChannelComponent: 0
  flipbookRows: 1
  flipbookColumns: 1
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  ignorePngGamma: 0
  applyGammaDecoding: 0
  swizzle: 50462976
  cookieLightType: 0
  platformSettings:
  - serializedVersion: 3
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Standalone
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 
    internalID: 0
    vertices: []
    indices: 
    edges: []
    weights: []
    secondaryTextures: []
    nameFileIdTable: {}
  mipmapLimitGroupName: 
  pSDRemoveMatte: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Icons/HairWind.png.meta`:

```meta
fileFormatVersion: 2
guid: d74de52c28819254c985180c7e1fe85f
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 13
  mipmaps:
    mipMapMode: 0
    enableMipMap: 1
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
    flipGreenChannel: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  vTOnly: 0
  ignoreMipmapLimit: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: 1
    aniso: 1
    mipBias: 0
    wrapU: 0
    wrapV: 0
    wrapW: 0
  nPOTScale: 1
  lightmap: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 1
  spriteTessellationDetail: -1
  textureType: 0
  textureShape: 1
  singleChannelComponent: 0
  flipbookRows: 1
  flipbookColumns: 1
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  ignorePngGamma: 0
  applyGammaDecoding: 0
  swizzle: 50462976
  cookieLightType: 0
  platformSettings:
  - serializedVersion: 3
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Standalone
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 
    internalID: 0
    vertices: []
    indices: 
    edges: []
    weights: []
    secondaryTextures: []
    nameFileIdTable: {}
  mipmapLimitGroupName: 
  pSDRemoveMatte: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/PropertyAttributes.meta`:

```meta
fileFormatVersion: 2
guid: c112a51a934575442999431be613febf
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/PropertyAttributes/ComparePropertyBase.cs`:

```cs
using System;
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public enum CompareOp
	{
		Eq,
		Geq,
		Gt,
		Leq,
		Lt,
		Neq,
	}

	[AttributeUsage(AttributeTargets.Field)]
	public abstract class ComparePropertyBase : PropertyAttribute
	{
		public readonly string fieldName;
		public readonly object cmpValue;
		public readonly TypeCode cmpType;
		public readonly CompareOp cmpOp;

		public ComparePropertyBase(string fieldName, object cmpValue) : this(fieldName, CompareOp.Eq, cmpValue) { }
		public ComparePropertyBase(string fieldName, CompareOp cmpOp, object cmpValue)
		{
			this.fieldName = fieldName;
			this.cmpValue = cmpValue;
			this.cmpType = cmpValue is null ? TypeCode.Empty : Type.GetTypeCode(cmpValue.GetType());
			this.cmpOp = cmpOp;
		}
	}
}

```

`Runtime/PropertyAttributes/ComparePropertyBase.cs.meta`:

```meta
fileFormatVersion: 2
guid: 100e335f004c764469fbf3ad168895c5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/PropertyAttributes/EditableIfAttribute.cs`:

```cs
namespace Unity.DemoTeam.Hair
{
	public class EditableIfAttribute : ComparePropertyBase
	{
		public EditableIfAttribute(bool fieldFlag) : base("", fieldFlag) { }
		public EditableIfAttribute(string fieldName, object cmpValue) : base(fieldName, cmpValue) { }
		public EditableIfAttribute(string fieldName, CompareOp cmpOp, object cmpValue) : base(fieldName, cmpOp, cmpValue) { }
	}
}

```

`Runtime/PropertyAttributes/EditableIfAttribute.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6b75901cd14eef3498de0e66ca041082
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/PropertyAttributes/LineHeaderAttribute.cs`:

```cs
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public class LineHeaderAttribute : PropertyAttribute
	{
		public GUIContent label;
		public LineHeaderAttribute(string label = null)
		{
			if (label != null)
				this.label = new GUIContent(label);
			else
				this.label = null;
		}
	}
}

```

`Runtime/PropertyAttributes/LineHeaderAttribute.cs.meta`:

```meta
fileFormatVersion: 2
guid: 005552245a97db84baf12ba32180974e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/PropertyAttributes/LinearRampAttribute.cs`:

```cs
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public class LinearRampAttribute : PropertyAttribute
	{
		public Rect ranges;
		public LinearRampAttribute(float x0, float y0, float x1, float y1)
		{
			this.ranges = new Rect(x0, y0, x1 - x0, y1 - y0);
		}
	}
}

```

`Runtime/PropertyAttributes/LinearRampAttribute.cs.meta`:

```meta
fileFormatVersion: 2
guid: dca6db28d4259324e8f68561756db727
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/PropertyAttributes/LinearRampWidgetAttribute.cs`:

```cs
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public enum LinearRampStyle
	{
		LinearDecreasing,
		LinearIncreasing,
		SmoothDecreasing,
		SmoothIncreasing,
	}

	public class LinearRampWidgetAttribute : PropertyAttribute
	{
		public float min;
		public float max;
		public LinearRampStyle style;

		public LinearRampWidgetAttribute(float min, float max, LinearRampStyle style = LinearRampStyle.LinearDecreasing)
		{
			this.min = min;
			this.max = max;
			this.style = style;
		}
	}
}

```

`Runtime/PropertyAttributes/LinearRampWidgetAttribute.cs.meta`:

```meta
fileFormatVersion: 2
guid: 098b17a5ce8ad394ca7b13a681f774cb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/PropertyAttributes/RenderingLayerMaskAttribute.cs`:

```cs
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public class RenderingLayerMaskAttribute : PropertyAttribute { }
}

```

`Runtime/PropertyAttributes/RenderingLayerMaskAttribute.cs.meta`:

```meta
fileFormatVersion: 2
guid: 0c8297540eb97b846a1c6d15336c7bae
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/PropertyAttributes/ToggleGroupAttribute.cs`:

```cs
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public class ToggleGroupAttribute : PropertyAttribute { }
}

```

`Runtime/PropertyAttributes/ToggleGroupAttribute.cs.meta`:

```meta
fileFormatVersion: 2
guid: c4ac6d81417a47d46b72a16ecf07c096
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/PropertyAttributes/ToggleGroupItemAttribute.cs`:

```cs
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public class ToggleGroupItemAttribute : PropertyAttribute
	{
		public bool withLabel;
		public string withSuffix;
		public bool allowSceneObjects;

		public ToggleGroupItemAttribute(bool withLabel = false, string withSuffix = null, bool allowSceneObjects = true)
		{
			this.withLabel = withLabel;
			this.withSuffix = withSuffix;
			this.allowSceneObjects = allowSceneObjects;
		}
	}
}

```

`Runtime/PropertyAttributes/ToggleGroupItemAttribute.cs.meta`:

```meta
fileFormatVersion: 2
guid: d1886691d3465fb44aa98f16c88e99e7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/PropertyAttributes/VisibleIfAttribute.cs`:

```cs
namespace Unity.DemoTeam.Hair
{
	public class VisibleIfAttribute : ComparePropertyBase
	{
		public VisibleIfAttribute(bool fieldFlag) : base("", fieldFlag) { }
		public VisibleIfAttribute(string fieldName, object cmpValue) : base(fieldName, cmpValue) { }
		public VisibleIfAttribute(string fieldName, CompareOp cmpOp, object cmpValue) : base(fieldName, cmpOp, cmpValue) { }
	}
}

```

`Runtime/PropertyAttributes/VisibleIfAttribute.cs.meta`:

```meta
fileFormatVersion: 2
guid: df1e2c22fd75b374db442e4382d71feb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Resources.meta`:

```meta
fileFormatVersion: 2
guid: 010c8c348105f08478926f9bf444d4f1
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Resources/HairSimResources.asset`:

```asset
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 90a0f1ea2cd8f2d43ac3752210225e3b, type: 3}
  m_Name: HairSimResources
  m_EditorClassIdentifier: 
  computeRoots: {fileID: 4800000, guid: 6e058d123672f674799fd1072e73d6d1, type: 3}
  computeSolver: {fileID: 7200000, guid: b6088415b07a2b44ab1624cac72a2252, type: 3}
  computeVolume: {fileID: 7200000, guid: 6936d281b1638924b97a8733f5ce8974, type: 3}
  computeVolumeRaster: {fileID: 4800000, guid: 7e9119a1fe374fd45b70c831f4cc3131, type: 3}
  debugDraw: {fileID: 4800000, guid: f84628556e79514499da79fa2a82f427, type: 3}
  debugDrawCube: {fileID: 10202, guid: 0000000000000000e000000000000000, type: 0}
  defaultBuiltin: {fileID: 4800000, guid: 00130ba255f6d9246b65ea8e49cd73c7, type: 3}
  defaultCustom: {fileID: 4800000, guid: aa19c1d1ecbc28f43be51dc33a2ffa95, type: 3}
  defaultHDRP: {fileID: -6465566751694194690, guid: e28e8d02189f3d549a2682c06f7ab03d, type: 3}
  defaultURP: {fileID: -6465566751694194690, guid: e28e8d02189f3d549a2682c06f7ab03d, type: 3}
  replaceAsync: {fileID: 4800000, guid: 924d5e6be0d55294e89ae9a03b93ef99, type: 3}
  replaceError: {fileID: 4800000, guid: ce4b10c704251b44aa714a9480bf938a, type: 3}

```

`Runtime/Resources/HairSimResources.asset.meta`:

```meta
fileFormatVersion: 2
guid: b17eb3e50f3b046418fab7d5eacafaf6
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Resources/HairSimResources.cs`:

```cs
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public class HairSimResources : ScriptableObject
	{
		static HairSimResources s_resources;

		public static HairSimResources Load()
		{
			if (s_resources == null)
				s_resources = Resources.Load<HairSimResources>("HairSimResources");

			return s_resources;
		}

		[LineHeader("Kernels")]

		public Shader computeRoots;
		public ComputeShader computeSolver;

		public ComputeShader computeVolume;
		public Shader computeVolumeRaster;

		[LineHeader("Debugging")]

		public Shader debugDraw;
		public Mesh debugDrawCube;

		[LineHeader("Materials")]

		public Shader defaultBuiltin;
		public Shader defaultCustom;
		public Shader defaultHDRP;
		public Shader defaultURP;
		public Shader replaceAsync;
		public Shader replaceError;
	}
}

```

`Runtime/Resources/HairSimResources.cs.meta`:

```meta
fileFormatVersion: 2
guid: 90a0f1ea2cd8f2d43ac3752210225e3b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences:
  - computeRoots: {instanceID: 0}
  - computeSolver: {instanceID: 0}
  - computeVolume: {instanceID: 0}
  - computeVolumeRaster: {instanceID: 0}
  - debugDraw: {instanceID: 0}
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Unity.DemoTeam.Hair.Runtime.asmdef`:

```asmdef
{
    "name": "Unity.DemoTeam.Hair.Runtime",
    "rootNamespace": "",
    "references": [
        "GUID:2665a8d13d1b3f18800f46e256720795",
        "GUID:e0cd26848372d4e5c891c569017e11f1",
        "GUID:d8b63aba1907145bea998dd612889d6b",
        "GUID:df380645f10b7bc4b97d4f5eb6303d95",
        "GUID:457756d89b35d2941b3e7b37b4ece6f1",
        "GUID:15fc0a57446b3144c949da3e2b9737a9",
        "GUID:22f31b74491fb45d5b598e0b935deb31",
        "GUID:7e9d95a3be8cd654ba8a8d2bb2409223",
        "GUID:b10624d713de0ea499050eed0b22b274"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": true,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [
        {
            "name": "com.unity.render-pipelines.high-definition",
            "expression": "10.2.2",
            "define": "HAS_PACKAGE_UNITY_HDRP"
        },
        {
            "name": "com.unity.render-pipelines.high-definition",
            "expression": "15.0.2",
            "define": "HAS_PACKAGE_UNITY_HDRP_15_0_2"
        },
        {
            "name": "com.unity.render-pipelines.universal",
            "expression": "10.2.2",
            "define": "HAS_PACKAGE_UNITY_URP"
        },
        {
            "name": "com.unity.formats.alembic",
            "expression": "2.2.2",
            "define": "HAS_PACKAGE_UNITY_ALEMBIC"
        },
        {
            "name": "com.unity.demoteam.digital-human",
            "expression": "0.1.1-preview",
            "define": "HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN"
        },
        {
            "name": "com.unity.demoteam.digital-human",
            "expression": "0.2.0-preview",
            "define": "HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN_0_2_0_PREVIEW"
        },
        {
            "name": "com.unity.demoteam.digital-human",
            "expression": "0.2.1-preview",
            "define": "HAS_PACKAGE_DEMOTEAM_DIGITALHUMAN_0_2_1_PREVIEW"
        },
        {
            "name": "com.unity.demoteam.mesh-to-sdf",
            "expression": "1.0.0",
            "define": "HAS_PACKAGE_DEMOTEAM_MESHTOSDF"
        },
        {
            "name": "com.unity.collections",
            "expression": "1.0.0-pre.3",
            "define": "HAS_PACKAGE_UNITY_COLLECTIONS_1_0_0_PRE_3"
        },
        {
            "name": "com.unity.collections",
            "expression": "1.0.0-pre.5",
            "define": "HAS_PACKAGE_UNITY_COLLECTIONS_1_0_0_PRE_5"
        },
        {
            "name": "com.unity.collections",
            "expression": "1.3.0",
            "define": "HAS_PACKAGE_UNITY_COLLECTIONS_1_3_0"
        },
        {
            "name": "com.unity.collections",
            "expression": "[2.0.0,2.1.0-exp.4)",
            "define": "HAS_PACKAGE_UNITY_COLLECTIONS_2_0_0_UNTIL_2_1_0_EXP_4"
        },
        {
            "name": "com.unity.modules.physics",
            "expression": "1.0.0",
            "define": "HAS_MODULE_PHYSICS"
        },
        {
            "name": "com.unity.modules.wind",
            "expression": "1.0.0",
            "define": "HAS_MODULE_WIND"
        }
    ],
    "noEngineReferences": false
}
```

`Runtime/Unity.DemoTeam.Hair.Runtime.asmdef.meta`:

```meta
fileFormatVersion: 2
guid: f9dedde5eec30c2468e14d8a7b14626e
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility.meta`:

```meta
fileFormatVersion: 2
guid: a09916ba7d960974a9444e08479f7188
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility/AffineUtility.cs`:

```cs
using UnityEngine;
using Unity.Mathematics;

namespace Unity.DemoTeam.Hair
{
	public static class AffineUtility
	{
		public static float3x3 AffineInterpolateUpper3x3(float3x3 A, float4 q, float t)
		{
			static float3x3 lerp(float3x3 a, float3x3 b, float t) => math.float3x3(
				math.lerp(a.c0, b.c0, t),
				math.lerp(a.c1, b.c1, t),
				math.lerp(a.c2, b.c2, t));

			// A = QR
			// Q^-1 A = R

			float3x3 Q_inv = math.float3x3(math.conjugate(q));
			float3x3 R = math.mul(Q_inv, A);
			float3x3 I = math.float3x3(
				1.0f, 0.0f, 0.0f,
				0.0f, 1.0f, 0.0f,
				0.0f, 0.0f, 1.0f);

			float3x3 Q_t = math.float3x3(math.slerp(quaternion.identity, q, t));
			float3x3 R_t = lerp(I, R, t);
			float3x3 A_t = math.mul(Q_t, R_t);

			return A_t;
		}

		public static float3x4 AffineInterpolate3x4(float3x4 M, float4 q, float t)
		{
			// M = | A T |

			float3x3 A_t = AffineInterpolateUpper3x3(math.float3x3(M.c0, M.c1, M.c2), q, t);
			float3 T_t = M.c3 * t;

			return math.float3x4(
				A_t.c0.x, A_t.c1.x, A_t.c2.x, T_t.x,
				A_t.c0.y, A_t.c1.y, A_t.c2.y, T_t.y,
				A_t.c0.z, A_t.c1.z, A_t.c2.z, T_t.z);
		}

		public static float4x4 AffineInterpolate4x4(float4x4 M, float4 q, float t)
		{
			// M = | A T |
			//     | 0 1 |

			float3x3 A_t = AffineInterpolateUpper3x3((float3x3)M, q, t);
			float3 T_t = M.c3.xyz * t;

			return math.float4x4(
				A_t.c0.x, A_t.c1.x, A_t.c2.x, T_t.x,
				A_t.c0.y, A_t.c1.y, A_t.c2.y, T_t.y,
				A_t.c0.z, A_t.c1.z, A_t.c2.z, T_t.z,
				0.0f, 0.0f, 0.0f, 1.0f);
		}

		public static float3x3 AffineInverseUpper3x3(float3x3 A)
		{
			float3 c0 = A.c0;
			float3 c1 = A.c1;
			float3 c2 = A.c2;

			float3 cp0x1 = math.cross(c0, c1);
			float3 cp1x2 = math.cross(c1, c2);
			float3 cp2x0 = math.cross(c2, c0);

			return math.float3x3(cp1x2, cp2x0, cp0x1) / math.dot(c0, cp1x2);
		}

		public static float4x4 AffineInverse4x4(float4x4 M)
		{
			// | A T |
			// | 0 1 |

			float3x3 A_inv = AffineInverseUpper3x3((float3x3)M);
			float3 T_inv = -math.mul(A_inv, M.c3.xyz);

			return math.float4x4(
				A_inv.c0.x, A_inv.c1.x, A_inv.c2.x, T_inv.x,
				A_inv.c0.y, A_inv.c1.y, A_inv.c2.y, T_inv.y,
				A_inv.c0.z, A_inv.c1.z, A_inv.c2.z, T_inv.z,
				0.0f, 0.0f, 0.0f, 1.0f);
		}

		public static float3x4 AffineMul3x4(float3x4 Ma, float3x4 Mb)
		{
			// Ma x Mb  =  | A Ta |  x  | B Tb |
			//             | 0 1  |     | 0 1  |
			//
			//          =  | mul(A,B)  mul(A,Tb)+Ta |
			//             | 0         1            |

			float3x3 A = math.float3x3(Ma.c0, Ma.c1, Ma.c2);
			float3x3 B = math.float3x3(Mb.c0, Mb.c1, Mb.c3);

			float3x3 AB = math.mul(A, B);
			float3 ATb = math.mul(A, Mb.c3);
			float3 Ta = Ma.c3;

			return math.float3x4(
				AB.c0.x, AB.c1.x, AB.c2.x, ATb.x + Ta.x,
				AB.c0.y, AB.c1.y, AB.c2.y, ATb.y + Ta.y,
				AB.c0.z, AB.c1.z, AB.c2.z, ATb.z + Ta.z);
		}

		public static float4x4 AffineMul4x4(float4x4 Ma, float4x4 Mb)
		{
			return math.mul(Ma, Mb);
		}
	}
}

```

`Runtime/Utility/AffineUtility.cs.meta`:

```meta
fileFormatVersion: 2
guid: afda711320c0bf7408d53dfbd852f71e
```

`Runtime/Utility/DerivedCache.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public static class DerivedCache<TObject, TDerived> where TObject : UnityEngine.Object where TDerived : struct, IDisposable
	{
		static bool s_initialized = false;

		static Dictionary<TObject, Item> s_items;
		struct Item
		{
			public TDerived data;
			public Hash128 hash;
		}

		static void StaticInitialize()
		{
			if (s_initialized == false)
			{
				s_items = new Dictionary<TObject, Item>();

#if UNITY_EDITOR
				UnityEditor.AssemblyReloadEvents.beforeAssemblyReload += Clear;
#endif

				s_initialized = true;
			}
		}

		public static void Clear()
		{
			StaticInitialize();

			foreach (var item in s_items.Values)
			{
				item.data.Dispose();
			}

			s_items.Clear();
		}

		public static bool TryGet(TObject objectKey, out TDerived derivedData)
		{
			StaticInitialize();

			if (s_items.TryGetValue(objectKey, out var item))
			{
				var hash = DerivedHash.Compute(objectKey);
				if (hash == item.hash)
				{
					derivedData = item.data;
					return true;
				}
			}

			derivedData = new TDerived();
			return false;
		}

		public static void SetOrReplace(TObject objectKey, in TDerived derivedData)
		{
			StaticInitialize();

			if (s_items.TryGetValue(objectKey, out var item))
			{
				item.data.Dispose();
			}

			s_items[objectKey] = new Item
			{
				data = derivedData,
				hash = DerivedHash.Compute(objectKey),
			};
		}

		public static TDerived GetOrCreate(TObject objectKey, Func<TObject, TDerived> derivedDataConstructor)
		{
			if (TryGet(objectKey, out var derivedData) == false)
			{
				derivedData = derivedDataConstructor(objectKey);
				SetOrReplace(objectKey, derivedData);
			}

			return derivedData;
		}
	}

	public static class DerivedCache
	{
		public static bool TryGet<TObject, TDerived>(TObject objectKey, out TDerived derivedData) where TObject : UnityEngine.Object where TDerived : struct, IDisposable
		{
			return DerivedCache<TObject, TDerived>.TryGet(objectKey, out derivedData);
		}

		public static void SetOrReplace<TObject, TDerived>(TObject objectKey, in TDerived derivedData) where TObject : UnityEngine.Object where TDerived : struct, IDisposable
		{
			DerivedCache<TObject, TDerived>.SetOrReplace(objectKey, derivedData);
		}

		public static TDerived GetOrCreate<TObject, TDerived>(TObject objectKey, Func<TObject, TDerived> derivedDataConstructor) where TObject : UnityEngine.Object where TDerived : struct, IDisposable
		{
			return DerivedCache<TObject, TDerived>.GetOrCreate(objectKey, derivedDataConstructor);
		}
	}

	public partial class DerivedHash
	{
		public static Hash128 Compute<TObject>(TObject key) where TObject : UnityEngine.Object
		{
			return new Hash128((uint)key.GetInstanceID(), 0, 0, 0);
		}

		public static Hash128 Compute(Mesh mesh)
		{
			return new Hash128((uint)mesh.GetInstanceID(), 0, 0, 0);//TODO content hash?
		}

		public static Hash128 Compute(Texture2D texture)
		{
#if UNITY_EDITOR
			return texture.imageContentsHash;
#else
			return new Hash128((uint)texture.GetInstanceID(), 0, 0, 0);
#endif
		}
	}
}

```

`Runtime/Utility/DerivedCache.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6fe49e41e64df20478736ac293afe781
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility/Extensions.cs`:

```cs
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public static class Vector2Extensions
	{
		public static Vector2 Abs(this Vector2 value)
		{
			return new Vector2
			{
				x = Mathf.Abs(value.x),
				y = Mathf.Abs(value.y),
			};
		}

		public static Vector2 CMul(this Vector2 value, in Vector2 other)
		{
			return new Vector2
			{
				x = value.x * other.x,
				y = value.y * other.y,
			};
		}

		public static float CMin(this Vector2 value)
		{
			return Mathf.Min(value.x, value.y);
		}

		public static float CMax(this Vector2 value)
		{
			return Mathf.Max(value.x, value.y);
		}
	}

	public static class Vector3Extensions
	{
		public static Vector3 Abs(this Vector3 value)
		{
			return new Vector3
			{
				x = Mathf.Abs(value.x),
				y = Mathf.Abs(value.y),
				z = Mathf.Abs(value.z),
			};
		}

		public static Vector3 CMul(this Vector3 value, in Vector3 other)
		{
			return new Vector3
			{
				x = value.x * other.x,
				y = value.y * other.y,
				z = value.z * other.z,
			};
		}

		public static float CMin(this Vector3 value)
		{
			return Mathf.Min(Mathf.Min(value.x, value.y), value.z);
		}

		public static float CMax(this Vector3 value)
		{
			return Mathf.Max(Mathf.Max(value.x, value.y), value.z);
		}

		public static float CSum(this Vector3 value)
		{
			return value.x + value.y + value.z;
		}

		public static Vector3 Rcp(this Vector3 value)
		{
			return new Vector3
			{
				x = 1.0f / value.x,
				y = 1.0f / value.y,
				z = 1.0f / value.z,
			};
		}

		public static Vector3 Sign(this Vector3 value)
		{
			return new Vector3
			{
				x = Mathf.Sign(value.x),
				y = Mathf.Sign(value.y),
				z = Mathf.Sign(value.z),
			};
		}

		public static Plane ToPlane(this Vector3 value, float distance)
		{
			return new Plane(value, distance);
		}
	}

	public static class Vector4Extensions
	{
		public static Vector4 Rcp(this Vector4 value)
		{
			return new Vector4
			{
				x = 1.0f / value.x,
				y = 1.0f / value.y,
				z = 1.0f / value.z,
				w = 1.0f / value.w,
			};
		}

		public static Vector4 Sign(this Vector4 value)
		{
			return new Vector4
			{
				x = Mathf.Sign(value.x),
				y = Mathf.Sign(value.y),
				z = Mathf.Sign(value.z),
				w = Mathf.Sign(value.w),
			};
		}

		public static Plane ToPlane(this Vector4 value)
		{
			return new Plane(value, value.w);
		}
	}

	public static class QuaternionExtensions
	{
		public static Vector4 ToVector4(this Quaternion value)
		{
			return new Vector4
			{
				x = value.x,
				y = value.y,
				z = value.z,
				w = value.w,
			};
		}
	}

	public static class BoundsExtensions
	{
		public static Bounds WithTransform(this Bounds bounds, Matrix4x4 transform)
		{
			//TODO revisit Unity.Mathematics

			var aPos = bounds.center;
			var aExt = bounds.extents;

			var p000 = new Vector3(aPos.x - aExt.x, aPos.y - aExt.y, aPos.z - aExt.z);
			var p001 = new Vector3(aPos.x + aExt.x, aPos.y - aExt.y, aPos.z - aExt.z);
			var p010 = new Vector3(aPos.x - aExt.x, aPos.y + aExt.y, aPos.z - aExt.z);
			var p011 = new Vector3(aPos.x + aExt.x, aPos.y + aExt.y, aPos.z - aExt.z);
			var p100 = new Vector3(aPos.x - aExt.x, aPos.y - aExt.y, aPos.z + aExt.z);
			var p101 = new Vector3(aPos.x + aExt.x, aPos.y - aExt.y, aPos.z + aExt.z);
			var p110 = new Vector3(aPos.x - aExt.x, aPos.y + aExt.y, aPos.z + aExt.z);
			var p111 = new Vector3(aPos.x + aExt.x, aPos.y + aExt.y, aPos.z + aExt.z);

			var b = new Bounds(transform.MultiplyPoint3x4(p000), Vector3.zero);
			{
				b.Encapsulate(transform.MultiplyPoint3x4(p001));
				b.Encapsulate(transform.MultiplyPoint3x4(p010));
				b.Encapsulate(transform.MultiplyPoint3x4(p011));
				b.Encapsulate(transform.MultiplyPoint3x4(p100));
				b.Encapsulate(transform.MultiplyPoint3x4(p101));
				b.Encapsulate(transform.MultiplyPoint3x4(p110));
				b.Encapsulate(transform.MultiplyPoint3x4(p111));
			}

			return b;
		}

		public static Bounds WithPadding(this Bounds bounds, float padding)
		{
			return new Bounds(bounds.center, bounds.size + new Vector3(2.0f * padding, 2.0f * padding, 2.0f * padding));
		}

		public static Bounds WithScale(this Bounds bounds, float scale)
		{
			return new Bounds(bounds.center, bounds.size * scale);
		}

		public static Bounds ToSquare(this Bounds bounds)
		{
			return new Bounds(bounds.center, bounds.size.Abs().CMax() * Vector3.one);
		}
	}

	public static class PlaneExtensions
	{
		public static bool IsNaN(this Plane value)
		{
			var n = value.normal;
			return (
				float.IsNaN(n.x) ||
				float.IsNaN(n.y) ||
				float.IsNaN(n.z)
			);
		}

		public static Vector4 ToVector4(this Plane value)
		{
			var n = value.normal;
			var d = value.distance;

			return new Vector4
			{
				x = n.x,
				y = n.y,
				z = n.z,
				w = d,
			};
		}
	}

	public static class RectExtensions
	{
		public static Rect ClipLeft(this Rect position, float width)
		{
			return new Rect(position.x + width, position.y, position.width - width, position.height);
		}

		public static Rect ClipLeft(this Rect position, float width, out Rect clipped)
		{
			clipped = new Rect(position.x, position.y, width, position.height);
			return position.ClipLeft(width);
		}
	}
}

```

`Runtime/Utility/Extensions.cs.meta`:

```meta
fileFormatVersion: 2
guid: 40760ea0bde1d0e4c82f373aa7877d0f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility/LongOperation.cs`:

```cs
#define ENABLED

using System;
using UnityEngine;
using UnityEditor;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.DemoTeam.Hair
{
#if !HAS_PACKAGE_UNITY_COLLECTIONS_1_0_0_PRE_5
	using FixedString128Bytes = FixedString128;
	using FixedString4096Bytes = FixedString4096;
#endif

	using Stack = UnsafeList<LongOperationDesc>;

	public struct LongOperationDesc
	{
		public FixedString128Bytes operationTitle;
		public FixedString128Bytes operationStatus;
		public float operationProgress;
		public int operationLastTick;
	}

	public struct LongOperationScope : IDisposable
	{
		public LongOperationDesc desc;

		public LongOperationScope(in FixedString128Bytes operationTitle)
		{
			desc.operationTitle = operationTitle;
			desc.operationStatus = new FixedString128Bytes();
			desc.operationProgress = 0.0f;

			unchecked
			{
				// should be safe unless one waits a long time (~24 days) showing first progress
				// https://docs.microsoft.com/en-us/dotnet/api/system.environment.tickcount?view=net-6.0
				desc.operationLastTick = Environment.TickCount - int.MaxValue;
			}

#if ENABLED
			LongOperationStack.Push(desc);
			LongOperationStack.Show();
#endif
		}

		bool WaitForTime()
		{
			const int WAIT_TICKS = 200;// milliseconds
			unchecked
			{
				var tick = Environment.TickCount;
				var tickDiff = tick - desc.operationLastTick;
				if (tickDiff > WAIT_TICKS)
				{
					desc.operationLastTick = tick;
					return false;
				}
				else
				{
					return true;
				}
			}
		}

		public void UpdateStatus(in FixedString128Bytes operationStatus, float operationProgress)
		{
#if ENABLED
			if (WaitForTime())
				return;

			desc.operationStatus = operationStatus;
			desc.operationProgress = operationProgress;

			LongOperationStack.Edit(desc);
			LongOperationStack.Show();
#endif
		}

		public void UpdateStatus(in FixedString128Bytes operationStatus, int operationProgressIndex, int operationProgressCount)
		{
#if ENABLED
			if (WaitForTime())
				return;

			var operationStatusEx = operationStatus;
			{
				operationStatusEx.Append(' ');
				operationStatusEx.Append(operationProgressIndex);
				operationStatusEx.Append(" / ");
				operationStatusEx.Append(operationProgressCount);
			}

			desc.operationStatus = operationStatusEx;
			desc.operationProgress = (float)operationProgressIndex / operationProgressCount;

			LongOperationStack.Edit(desc);
			LongOperationStack.Show();
#endif
		}

		public void Dispose()
		{
#if ENABLED
			LongOperationStack.Pop();
#endif
		}
	}

	public static class LongOperationStack
	{
		private static Stack s_stack;

		public static void Push(in LongOperationDesc headDesc)
		{
			if (s_stack.IsCreated == false)
				s_stack = new Stack(4, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);

			s_stack.Add(headDesc);
		}

		public static void Edit(in LongOperationDesc headDesc)
		{
			if (s_stack.IsEmpty)
				return;

			s_stack.ElementAt(s_stack.Length - 1) = headDesc;
		}

		public static void Show()
		{
			if (s_stack.IsEmpty || LongOperationOutput.s_enable == false)
				return;

			var concatTitle = new FixedString4096Bytes();
			var concatStatus = new FixedString4096Bytes();
			var concatProgress = 0.0f;
			{
				var concatTitleHead = -1;
				var concatTitleLimit = 3;
				var concatTitleOffset = 0;
				var concatStatusHead = -1;
				var concatStatusLimit = 4;
				var concatStatusOffset = 0;
				var concatStatusDefault = false;

				void ConditionalCopy(bool cond, ref int limit, int input, ref int output) => output = (cond && limit-- > 0) ? input : output;
				void ConditionalAppend(bool cond, in FixedString128Bytes input, ref FixedString4096Bytes concat)
				{
					if (cond && input.Length > 0)
					{
						if (concat.Length > 0)
							concat.Append(" > ");

						concat.Append(input);
					}
				};

				for (int i = s_stack.Length - 1; i >= 0; i--)
				{
					ref var desc = ref s_stack.ElementAt(i);
					{
						ConditionalCopy(desc.operationTitle.Length > 0, ref concatTitleLimit, i, ref concatTitleOffset);
						ConditionalCopy(desc.operationStatus.Length > 0, ref concatStatusLimit, i, ref concatStatusOffset);

						if (concatTitleHead == -1 && desc.operationTitle.Length > 0)
							concatTitleHead = concatTitleOffset;
						if (concatStatusHead == -1 && desc.operationStatus.Length > 0)
							concatStatusHead = concatStatusOffset;
					}
				}

				if (concatStatusHead < concatTitleHead)
				{
					if (concatStatusLimit <= 0)
						concatStatusOffset++;

					concatStatusDefault = true;
				}

				ConditionalAppend(concatTitleLimit < 0, "..", ref concatTitle);
				ConditionalAppend(concatStatusLimit < 0, "..", ref concatStatus);

				for (int i = 0; i != s_stack.Length; i++)
				{
					ref var desc = ref s_stack.ElementAt(i);
					{
						ConditionalAppend(i >= concatTitleOffset, desc.operationTitle, ref concatTitle);
						ConditionalAppend(i >= concatStatusOffset, desc.operationStatus, ref concatStatus);
						concatProgress = concatProgress + (1.0f - concatProgress) * desc.operationProgress;
					}
				}

				/*
				var j = s_stack.Length - 1;
				if (j > 0)
				{
					var progressBase = s_stack.ElementAt(j - 1).operationProgress;
					var progressHead = s_stack.ElementAt(j).operationProgress;
					concatProgress = progressBase + (1.0f - progressBase) * progressHead;
				}
				else
				{
					concatProgress = s_stack.ElementAt(j).operationProgress;
				}
				*/

				ConditionalAppend(concatStatusDefault, "...", ref concatStatus);
			}

			LongOperationOutput.s_output.show(concatTitle.Value, concatStatus.Value, concatProgress);
		}

		public static void Hide()
		{
			if (LongOperationOutput.s_enable == false)
				return;

			LongOperationOutput.s_output.hide();
		}

		public static void Pop()
		{
			if (s_stack.IsEmpty)
				return;

			s_stack.RemoveAt(s_stack.Length - 1);

			if (s_stack.IsEmpty)
				Hide();
			else
				Show();
		}

		public static bool IsEmpty()
		{
			return s_stack.IsEmpty;
		}
	}

	public struct LongOperationOutput : IDisposable
	{
		public struct Impl
		{
			public delegate void FnShow(string title, string status, float progress);
			public delegate void FnHide();

			public FnShow show;
			public FnHide hide;
		}

#if UNITY_EDITOR
		public static readonly Impl defaultImplEditor = new Impl
		{
			show = EditorUtility.DisplayProgressBar,
			hide = EditorUtility.ClearProgressBar,
		};
#endif

		public static readonly Impl defaultImplPlayer = new Impl
		{
			show = (title, status, progress) =>
			{
				var concatProgressSymbols = new FixedString128Bytes();
				var concatProgressSymbolsMax = concatProgressSymbols.Capacity / 4 - 2;
				var concatProgressSymbolsLit = Mathf.RoundToInt(progress * concatProgressSymbolsMax);

				concatProgressSymbols.Append('[');
				{
					for (int i = 0; i != concatProgressSymbolsLit; i++)
						concatProgressSymbols.Append('#');
					for (int i = concatProgressSymbolsLit; i != concatProgressSymbolsMax; i++)
						concatProgressSymbols.Append(' ');
				}
				concatProgressSymbols.Append(']');

				Debug.Log(string.Format("{0} --- {1} --- {2}", title, status, concatProgressSymbols.Value));
			},
			hide = () => { },
		};

		public static bool s_enable = false;
#if UNITY_EDITOR
		public static Impl s_output = defaultImplEditor;
#else
		public static Impl s_output = defaultImplPlayer;
#endif

		private static bool s_enablePrev;
		private static Impl s_outputPrev;

		public LongOperationOutput(bool enable) : this(enable, s_output) { }
		public LongOperationOutput(Impl output) : this(s_enable, output) { }
		public LongOperationOutput(bool enable, Impl output)
		{
			s_enablePrev = s_enable;
			s_outputPrev = s_output;

			s_enable = enable;
			s_output = output;
		}

		public void Dispose()
		{
			s_enable = s_enablePrev;
			s_output = s_outputPrev;
		}
	}
}

```

`Runtime/Utility/LongOperation.cs.meta`:

```meta
fileFormatVersion: 2
guid: d9336e235745ac6498d0547d86b95dd3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility/PrefabContentsUtility.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
#if UNITY_EDITOR
	public static class PrefabContentsUtility
	{
		public delegate void FnUpdatePrefabContents(GameObject prefabContentsRoot);

		struct UpdateUnderlyingPrefabScope : IDisposable
		{
			public UnityEngine.Object prefabInstanceMember;
			public string prefabPath;
			public bool verbose;

			public UpdateUnderlyingPrefabScope(UnityEngine.Object prefabInstanceMember, bool verbose)
			{
				this.prefabInstanceMember = prefabInstanceMember;
				this.prefabPath = UnityEditor.PrefabUtility.GetPrefabAssetPathOfNearestInstanceRoot(prefabInstanceMember);
				this.verbose = verbose;

				if (verbose)
				{
					Debug.Log(string.Format("{0} ({1}): entering prefab '{2}'...", prefabInstanceMember.GetType().Name, prefabInstanceMember.name, prefabPath), prefabInstanceMember);
				}
			}

			public void Dispose()
			{
				if (verbose)
				{
					Debug.Log(string.Format("{0} ({1}): exiting prefab '{2}'...", prefabInstanceMember.GetType().Name, prefabInstanceMember.name, prefabPath), prefabInstanceMember);
				}
			}
		}

		public static void UpdateUnderlyingPrefabContents(UnityEngine.Object prefabInstanceMember, bool verbose, FnUpdatePrefabContents fnUpdatePrefabContents)
		{
			using (var prefabScope = new UpdateUnderlyingPrefabScope(prefabInstanceMember, verbose))
			{
				UpdateUnderlyingPrefabContents(prefabScope.prefabPath, fnUpdatePrefabContents);
			}
		}

		public static void UpdateUnderlyingPrefabContents(string prefabPath, FnUpdatePrefabContents fnUpdatePrefabContents)
		{
#if UNITY_2021_2_OR_NEWER
			var prefabStage = UnityEditor.SceneManagement.PrefabStageUtility.GetCurrentPrefabStage();
#else
			var prefabStage = UnityEditor.Experimental.SceneManagement.PrefabStageUtility.GetCurrentPrefabStage();
#endif
			if (prefabStage != null && prefabStage.assetPath == prefabPath)
			{
				// update contents of prefab in prefab stage
				fnUpdatePrefabContents(prefabStage.prefabContentsRoot);

				// force a save to ensure that prefab instances receive changes
				{
					UnityEditor.PrefabUtility.SaveAsPrefabAsset(prefabStage.prefabContentsRoot, prefabPath);
					prefabStage.ClearDirtiness();
				}
			}
			else
			{
				using (var prefabEditScope = new UnityEditor.PrefabUtility.EditPrefabContentsScope(prefabPath))
				{
					// update contents of prefab on disk
					fnUpdatePrefabContents(prefabEditScope.prefabContentsRoot);
				}
			}
		}
	}
#endif
}

```

`Runtime/Utility/PrefabContentsUtility.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6e4d550f9cf533241857d3c82988a7cd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility/PrimarySkinningBone.cs`:

```cs
using System;
using UnityEngine;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.DemoTeam.Hair
{
	[Serializable]
	public struct PrimarySkinningBone
	{
		public Transform skinningBone;
		public Matrix4x4 skinningBoneBindPose;
		public Matrix4x4 skinningBoneBindPoseInverse;

		public PrimarySkinningBone(Transform transform)
		{
			this.skinningBone = transform;
			this.skinningBoneBindPose = Matrix4x4.identity;
			this.skinningBoneBindPoseInverse = Matrix4x4.identity;

			// search for skinning bone
			var smr = transform.GetComponent<SkinnedMeshRenderer>();
			if (smr != null)
			{
				var skinningBoneIndex = -1;
				var skinningBoneWeight = 0.0f;

				unsafe
				{
					var boneWeights = smr.sharedMesh.GetAllBoneWeights();
					var boneWeightPtr = (BoneWeight1*)boneWeights.GetUnsafeReadOnlyPtr();

					for (int i = 0; i != boneWeights.Length; i++)
					{
						if (skinningBoneWeight < boneWeightPtr[i].weight)
						{
							skinningBoneWeight = boneWeightPtr[i].weight;
							skinningBoneIndex = boneWeightPtr[i].boneIndex;
						}
					}
				}

				if (skinningBoneIndex != -1)
				{
					this.skinningBone = smr.bones[skinningBoneIndex];
					this.skinningBoneBindPose = smr.sharedMesh.bindposes[skinningBoneIndex];
					this.skinningBoneBindPoseInverse = skinningBoneBindPose.inverse;
					//Debug.Log("discovered skinning bone for " + smr.name + " : " + skinningBone.name);
				}
				else if (smr.rootBone != null)
				{
					this.skinningBone = smr.rootBone;
				}
			}
		}

		public Matrix4x4 GetWorldToLocalSkinning()
		{
			return skinningBoneBindPoseInverse * skinningBone.worldToLocalMatrix;
		}

		public Matrix4x4 GetLocalSkinningToWorld()
		{
			return skinningBone.localToWorldMatrix * skinningBoneBindPose;
		}
	}
}

```

`Runtime/Utility/PrimarySkinningBone.cs.meta`:

```meta
fileFormatVersion: 2
guid: 8bc5885bc4160e945a93b2c1923ff6cb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility/SpatialComponentFilter.cs`:

```cs
using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public interface ISpatialComponentProxy<TComponent, TData> where TData : struct
	{
		bool TryGetData(TComponent component, ref TData data);
		bool TryGetComponentData(Component component, ref TData data);

		int ResolveDataHandle(in TData data);
		float ResolveDataDistance(in TData data, in Vector3 p);
	}

	public static class SpatialComponentFilter<TComponent, TData, TFn> where TComponent : MonoBehaviour where TData : struct where TFn : ISpatialComponentProxy<TComponent, TData>
	{
		const int MAX_OVERLAP_COUNT = 64;

		static Collider[] s_managedColliders = new Collider[MAX_OVERLAP_COUNT];
		static List<TComponent> s_managedComponents = new List<TComponent>();

		static HashSet<int> s_gatherMask = new HashSet<int>();
		static List<TData> s_gatherList = new List<TData>();
		static List<TData> s_gatherListVolume = new List<TData>();

		static TFn s_fn;

		static void FilterDirect(TComponent component, HashSet<int> mask, List<TData> list, ref TData data)
		{
			if (component == null || component.isActiveAndEnabled == false)
				return;

			if (s_fn.TryGetData(component, ref data))
			{
				var handle = s_fn.ResolveDataHandle(data);
				{
					if (mask.Contains(handle) == false)
					{
						mask.Add(handle);
						list.Add(data);
					}
				}
			}
		}

		static void FilterDerived(Component component, HashSet<int> mask, List<TData> list, ref TData data)
		{
			if (component == null)
				return;

			if (s_fn.TryGetComponentData(component, ref data))
			{
				var handle = s_fn.ResolveDataHandle(data);
				{
					if (mask.Contains(handle) == false)
					{
						mask.Add(handle);
						list.Add(data);
					}
				}
			}
		}

		public static List<TData> Gather(TComponent[] resident, bool volume, in Bounds volumeBounds, LayerMask volumeLayer, bool volumeSort, bool includeDerived)
		{
			var scratch = new TData();

			s_gatherMask.Clear();
			s_gatherList.Clear();
			s_gatherListVolume.Clear();

			// gather from resident
			if (resident != null)
			{
				foreach (var component in resident)
				{
					FilterDirect(component, s_gatherMask, s_gatherList, ref scratch);
				}
			}

			// gather from volume
			if (volume)
			{
				var colliderBuffer = s_managedColliders;
				var colliderCount = Physics.OverlapBoxNonAlloc(volumeBounds.center, volumeBounds.extents, colliderBuffer, Quaternion.identity, volumeLayer, QueryTriggerInteraction.Collide);

				// filter bound / standalone
				for (int i = 0; i != colliderCount; i++)
				{
					colliderBuffer[i].GetComponents(s_managedComponents);

					foreach (var component in s_managedComponents)
					{
						FilterDirect(component, s_gatherMask, s_gatherListVolume, ref scratch);
					}
				}

				// filter derived (e.g. untagged colliders)
				if (includeDerived)
				{
					for (int i = 0; i != colliderCount; i++)
					{
						FilterDerived(colliderBuffer[i], s_gatherMask, s_gatherListVolume, ref scratch);
					}
				}

				// sort and append
				unsafe
				{
					using (var sortedIndices = new NativeArray<ulong>(s_gatherListVolume.Count, Allocator.Temp))
					{
						var sortedIndicesPtr = (ulong*)sortedIndices.GetUnsafePtr();

						var captureOrigin = volumeBounds.center;
						var captureExtent = volumeBounds.extents.Abs().CMax();

						for (int i = 0; i != s_gatherListVolume.Count; i++)
						{
							var volumeSortValue = 0u;
							if (volumeSort)
							{
								var sdRaw = s_fn.ResolveDataDistance(s_gatherListVolume[i], captureOrigin);
								var sdClippedDoubleExtent = Mathf.Clamp(sdRaw / captureExtent, -1.0f, 1.0f);
								var udClippedDoubleExtent = Mathf.Clamp01(sdClippedDoubleExtent * 0.5f + 0.5f);
								{
									volumeSortValue = (uint)(udClippedDoubleExtent * UInt16.MaxValue);
								}
							}

							var sortDistance = ((ulong)volumeSortValue) << 48;
							var sortHandle = (((ulong)s_fn.ResolveDataHandle(s_gatherListVolume[i])) << 16) & 0xffffffff0000uL;
							var sortIndex = ((ulong)i) & 0xffffuL;
							{
								sortedIndicesPtr[i] = sortDistance | sortHandle | sortIndex;
							}
						}

						sortedIndices.Sort();

						for (int i = 0; i != s_gatherListVolume.Count; i++)
						{
							var index = (int)(sortedIndicesPtr[i] & 0xffffuL);
							{
								s_gatherList.Add(s_gatherListVolume[index]);
							}
						}
					}
				}
			}

			// done
			return s_gatherList;
		}
	}
}

```

`Runtime/Utility/SpatialComponentFilter.cs.meta`:

```meta
fileFormatVersion: 2
guid: ebedaa3c1d4de1948bd2a9895f136901
```

`Runtime/Utility/Texture2DLabels.cs`:

```cs
using System;
using UnityEngine;
using UnityEngine.Profiling;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.DemoTeam.Hair
{
	public unsafe struct Texture2DLabels : IDisposable
	{
		public delegate uint GetLabelDelegate(int x, int y);

		public int dimX;
		public int dimY;

		public NativeArray<uint> texelLabel;
		public uint* texelLabelPtr;

		public uint labelCount;
		public bool labelWrap;

		//TODO optimize me + runs out of memory for clump maps >4k
		public Texture2DLabels(Texture2D texture, TextureWrapMode wrapMode, Allocator allocator)
		{
			dimX = texture.width;
			dimY = texture.height;

			texelLabel = new NativeArray<uint>(dimX * dimY, allocator, NativeArrayOptions.UninitializedMemory);
			texelLabelPtr = (uint*)texelLabel.GetUnsafePtr();

			labelCount = 0;
			labelWrap = (wrapMode == TextureWrapMode.Repeat);

			var texelData = texture.GetRawTextureData<byte>();
			var texelDataPtr = (byte*)texelData.GetUnsafePtr();

			var texelCount = dimX * dimY;
			var texelSize = texelData.Length / texelCount;

			var texelBG = new NativeArray<byte>(texelSize, Allocator.Temp, NativeArrayOptions.ClearMemory);
			var texelBGPtr = (byte*)texelBG.GetUnsafePtr();

			// discover matching neighbours
			Profiler.BeginSample("discover matching neighbours");
			var texelAdjacency = new UnsafeAdjacency(texelCount, 8 * texelCount, Allocator.Temp);
			{
				bool CompareEquals(byte* ptrA, byte* ptrB, int count)
				{
					for (int i = 0; i != count; i++)
					{
						if (ptrA[i] != ptrB[i])
							return false;
					}

					return true;
				};

				void CompareAndConnect(ref UnsafeAdjacency adjacency, byte* valueBasePtr, int valueSize, int indexA, int indexB)
				{
					if (CompareEquals(valueBasePtr + valueSize * indexA, valueBasePtr + valueSize * indexB, valueSize))
					{
						adjacency.Append(indexA, indexB);
						adjacency.Append(indexB, indexA);
					}
				};

				if (wrapMode == TextureWrapMode.Repeat)
				{
					// a b c
					// d e <-- 'e' is sweep index at (x, y)
					for (int y = 0; y != dimY; y++)
					{
						int ym = (y - 1 + dimY) % dimY;
						int yp = (y + 1) % dimY;

						for (int x = 0; x != dimX; x++)
						{
							int xm = (x - 1 + dimX) % dimX;
							int xp = (x + 1) % dimX;

							int i_a = dimX * ym + xm;
							int i_b = dimX * ym + x;
							int i_c = dimX * ym + xp;
							int i_d = dimX * y + xm;
							int i_e = dimX * y + x;

							if (CompareEquals(texelBGPtr, texelDataPtr + texelSize * i_e, texelSize))
								continue;

							// 8-way connected clusters
							{
								CompareAndConnect(ref texelAdjacency, texelDataPtr, texelSize, i_e, i_a);
								CompareAndConnect(ref texelAdjacency, texelDataPtr, texelSize, i_e, i_b);
								CompareAndConnect(ref texelAdjacency, texelDataPtr, texelSize, i_e, i_c);
								CompareAndConnect(ref texelAdjacency, texelDataPtr, texelSize, i_e, i_d);
							}
						}
					}
				}
				else// wrapMode == TextureWrapMode.Clamp
				{
					// a b c
					// d e <-- 'e' is sweep index at (x, y)
					for (int y = 0; y != dimY; y++)
					{
						int ym = Mathf.Max(y - 1);
						int yp = Mathf.Min(y + 1, dimY - 1);

						for (int x = 0; x != dimX; x++)
						{
							int xm = Mathf.Max(x - 1, 0);
							int xp = Mathf.Min(x + 1, dimX - 1);

							int i_a = dimX * ym + xm;
							int i_b = dimX * ym + x;
							int i_c = dimX * ym + xp;
							int i_d = dimX * y + xm;
							int i_e = dimX * y + x;

							if (CompareEquals(texelBGPtr, texelDataPtr + texelSize * i_e, texelSize))
								continue;

							// 8-way connected clusters except at boundary
							if (i_e != i_a) CompareAndConnect(ref texelAdjacency, texelDataPtr, texelSize, i_e, i_a);
							if (i_e != i_b) CompareAndConnect(ref texelAdjacency, texelDataPtr, texelSize, i_e, i_b);
							if (i_e != i_c) CompareAndConnect(ref texelAdjacency, texelDataPtr, texelSize, i_e, i_c);
							if (i_e != i_d) CompareAndConnect(ref texelAdjacency, texelDataPtr, texelSize, i_e, i_d);
						}
					}
				}
			}
			Profiler.EndSample();

			// discover clusters, write label per texel
			Profiler.BeginSample("discover clusters");
			var texelVisitor = new UnsafeBFS(texelCount, Allocator.Temp);
			{
				for (int i = 0; i != texelCount; i++)
				{
					if (texelVisitor.visitedPtr[i])
						continue;

					labelCount++;

					if (texelAdjacency.listsPtr[i].size > 0)
					{
						texelVisitor.Insert(i);

						while (texelVisitor.MoveNext(out int visitedIndex, out int visitedDepth))
						{
							foreach (var adjacentIndex in texelAdjacency[visitedIndex])
							{
								texelVisitor.Insert(adjacentIndex);
							}

							texelLabelPtr[visitedIndex] = labelCount;
						}
					}
					else
					{
						texelVisitor.Ignore(i);
						texelLabelPtr[i] = labelCount;
					}
				}
			}
			Profiler.EndSample();

			// dispose temporary structures
			texelAdjacency.Dispose();
			texelVisitor.Dispose();
			texelBG.Dispose();
		}

		public void Dispose()
		{
			texelLabel.Dispose();
		}

		public uint GetLabelCount()
		{
			return labelCount;
		}

		public uint GetLabel(int x, int y)
		{
			if (labelWrap)
			{
				int Wrap(int a, int n)
				{
					int r = a % n;
					if (r < 0)
						return r + n;
					else
						return r;
				}

				x = Wrap(x, dimX);
				y = Wrap(y, dimY);
			}
			else
			{
				int Clamp(int a, int n)
				{
					return (a < 0) ? 0 : ((a > n - 1) ? (n - 1) : a);
				}

				x = Clamp(x, dimX);
				y = Clamp(y, dimY);
			}

			return texelLabelPtr[x + y * dimX];
		}
	}
}

```

`Runtime/Utility/Texture2DLabels.cs.meta`:

```meta
fileFormatVersion: 2
guid: aeb11fc6db749ec44b4e3f77eea38860
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility/TriMeshBuffers.cs`:

```cs
using System;
using UnityEngine;
using Unity.Collections;

namespace Unity.DemoTeam.Hair
{
	public struct TriMeshBuffers : IDisposable
	{
		[Flags]
		public enum Attribute
		{
			All = Position | Normal | UV0,
			Position = 1 << 0,
			Normal = 1 << 1,
			UV0 = 1 << 2,
		}

		public int vertexCount;
		public Attribute vertexAttributes;

		public NativeArray<Vector3> vertexPosition;
		public NativeArray<Vector3> vertexNormal;
		public NativeArray<Vector2> vertexUV0;

		public int triangleVertexCount;
		public NativeArray<int> triangleVertexIndices;

		public uint submeshMask;

		public TriMeshBuffers(Mesh.MeshData meshData, Attribute meshAttributes = Attribute.All, Allocator allocator = Allocator.Temp, uint submeshMask = ~0u)
		{
			vertexCount = meshData.vertexCount;
			vertexAttributes = meshAttributes;

			vertexPosition = new NativeArray<Vector3>(vertexCount, allocator, NativeArrayOptions.UninitializedMemory);
			vertexNormal = new NativeArray<Vector3>(vertexCount, allocator, NativeArrayOptions.UninitializedMemory);
			vertexUV0 = new NativeArray<Vector2>(vertexCount, allocator, NativeArrayOptions.UninitializedMemory);

			if (vertexAttributes.HasFlag(Attribute.Position))
				meshData.GetVertices(vertexPosition);

			if (vertexAttributes.HasFlag(Attribute.Normal))
				meshData.GetNormals(vertexNormal);

			if (vertexAttributes.HasFlag(Attribute.UV0))
				meshData.GetUVs(0, vertexUV0);

			triangleVertexCount = 0;
			{
				for (int i = 0; i != meshData.subMeshCount; i++)
				{
					if (((1 << i) & submeshMask) == 0)
						continue;

					var submesh = meshData.GetSubMesh(i);
					if (submesh.topology != MeshTopology.Triangles)
						continue;

					triangleVertexCount += submesh.indexCount;
				}
			}

			triangleVertexIndices = new NativeArray<int>(triangleVertexCount, allocator, NativeArrayOptions.UninitializedMemory);
			{
				int writeOffset = 0;

				for (int i = 0; i != meshData.subMeshCount; i++)
				{
					if (((1 << i) & submeshMask) == 0)
						continue;

					var submesh = meshData.GetSubMesh(i);
					if (submesh.topology != MeshTopology.Triangles)
						continue;

					var indexCount = submesh.indexCount;
					if (indexCount == 0)
						continue;

					using (var meshIndices = new NativeArray<int>(indexCount, allocator, NativeArrayOptions.UninitializedMemory))
					{
						meshData.GetIndices(meshIndices, i);
						meshIndices.CopyTo(triangleVertexIndices.GetSubArray(writeOffset, submesh.indexCount));
					}

					writeOffset += indexCount;
				}
			}

			this.submeshMask = submeshMask;
		}

		public void Dispose()
		{
			if (vertexPosition.IsCreated)
				vertexPosition.Dispose();

			if (vertexNormal.IsCreated)
				vertexNormal.Dispose();

			if (vertexUV0.IsCreated)
				vertexUV0.Dispose();

			if (triangleVertexIndices.IsCreated)
				triangleVertexIndices.Dispose();
		}

		public bool HasAttribute(Attribute attribute)
		{
			return vertexAttributes.HasFlag(attribute);
		}
	}
}

```

`Runtime/Utility/TriMeshBuffers.cs.meta`:

```meta
fileFormatVersion: 2
guid: d96ad2ea02b59f04e8e5f8e924cf1387
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility/TriMeshQueries.cs`:

```cs
using System;
using UnityEngine;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Mathematics;

using static Unity.Mathematics.math;

namespace Unity.DemoTeam.Hair
{
	public struct TriMeshQueries : IDisposable
	{
		public unsafe struct TriMeshBVHContext : IUnsafeBVHContext
		{
			public int triangleCount;
			public int* triangleVertexIndicesPtr;
			public float3* vertexPositionPtr;
			public float3* vertexNormalPtr;
			public float2* vertexUV0Ptr;

			public int GetLeafCount()
			{
				return triangleCount;
			}

			public void BuildLeafData(UnsafeBVH.Leaf* leafPtr, int leafCount)
			{
				for (uint i = 0; i != leafCount; i++)
				{
					var j0 = triangleVertexIndicesPtr[i * 3 + 0];
					var j1 = triangleVertexIndicesPtr[i * 3 + 1];
					var j2 = triangleVertexIndicesPtr[i * 3 + 2];

					var p0 = vertexPositionPtr[j0];
					var p1 = vertexPositionPtr[j1];
					var p2 = vertexPositionPtr[j2];

					leafPtr[i].min = min(p0, min(p1, p2));
					leafPtr[i].max = max(p0, max(p1, p2));
					leafPtr[i].index = i;
				}
			}

			public float SqDistanceLeafPoint(uint leafIndex, in float3 p)
			{
				var j0 = triangleVertexIndicesPtr[leafIndex * 3 + 0];
				var j1 = triangleVertexIndicesPtr[leafIndex * 3 + 1];
				var j2 = triangleVertexIndicesPtr[leafIndex * 3 + 2];

				var p0 = vertexPositionPtr[j0];
				var p1 = vertexPositionPtr[j1];
				var p2 = vertexPositionPtr[j2];

				return TriMeshQueriesUtility.SqDistTriangle(p0, p1, p2, p);
			}

			public float SqDistanceLeafTrace(uint leafIndex, in float3 p, in float3 r)
			{
				return float.PositiveInfinity;//TODO
			}
		}

		public TriMeshBuffers triangleMesh;
		public TriMeshBVHContext triangleBVHContext;
		public UnsafeBVH triangleBVH;

		public TriMeshQueries(Mesh.MeshData meshData, Allocator allocator = Allocator.Temp)
		{
			triangleMesh = new TriMeshBuffers(meshData, TriMeshBuffers.Attribute.All, allocator);

			unsafe
			{
				triangleBVHContext = new TriMeshBVHContext
				{
					triangleCount = triangleMesh.triangleVertexCount / 3,
					triangleVertexIndicesPtr = (int*)triangleMesh.triangleVertexIndices.GetUnsafePtr(),
					vertexPositionPtr = (float3*)triangleMesh.vertexPosition.GetUnsafePtr(),
					vertexNormalPtr = (float3*)triangleMesh.vertexNormal.GetUnsafePtr(),
					vertexUV0Ptr = (float2*)triangleMesh.vertexUV0.GetUnsafePtr(),
				};

				triangleBVH = UnsafeBVHBuilder.CreateFromContext(triangleBVHContext, allocator);
			}
		}

		public void Dispose()
		{
			triangleMesh.Dispose();
			triangleBVH.Dispose();
		}

		public uint FindClosestTriangle(in float3 p)
		{
			return UnsafeBVHQueries.FindClosestLeaf(triangleBVHContext, triangleBVH, p);
		}

		public float2 FindClosestTriangleUV(in float3 p)
		{
			var triangleIndex = FindClosestTriangle(p);
			if (triangleIndex != uint.MaxValue)
			{
				unsafe
				{
					var j0 = triangleBVHContext.triangleVertexIndicesPtr[triangleIndex * 3 + 0];
					var j1 = triangleBVHContext.triangleVertexIndicesPtr[triangleIndex * 3 + 1];
					var j2 = triangleBVHContext.triangleVertexIndicesPtr[triangleIndex * 3 + 2];

					var p0 = triangleBVHContext.vertexPositionPtr[j0];
					var p1 = triangleBVHContext.vertexPositionPtr[j1];
					var p2 = triangleBVHContext.vertexPositionPtr[j2];

					var q = TriMeshQueriesUtility.ProjectOntoTriangle(p, p0, p1, p2);
					var u = TriMeshQueriesUtility.MakeBarycentric(q, p0, p1, p2);

					var u0 = triangleBVHContext.vertexUV0Ptr[j0];
					var u1 = triangleBVHContext.vertexUV0Ptr[j1];
					var u2 = triangleBVHContext.vertexUV0Ptr[j2];

					return TriMeshQueriesUtility.BarycentricInterpolate(u, u0, u1, u2);
				}
			}
			else
			{
				return float2(0.0f, 0.0f);
			}
		}
	}

	public static class TriMeshQueriesUtility
	{
		public static float3 MakeBarycentric(in float3 q, in float3 a, in float3 b, in float3 c)
		{
			// compute (u, v, w) for point q in plane spanned by triangle (a, b, c)
			// https://gamedev.stackexchange.com/a/23745

			var v0 = b - a;
			var v1 = c - a;
			var v2 = q - a;

			var d00 = dot(v0, v0);
			var d01 = dot(v0, v1);
			var d11 = dot(v1, v1);
			var d20 = dot(v2, v0);
			var d21 = dot(v2, v1);

			var denom = d00 * d11 - d01 * d01;
			var v = (d11 * d20 - d01 * d21) / denom;
			var w = (d00 * d21 - d01 * d20) / denom;
			var u = 1.0f - v - w;

			return new float3(u, v, w);
		}

		public static float2 BarycentricInterpolate(in float3 uvw, in float2 a, in float2 b, in float2 c)
		{
			return a * uvw.x + b * uvw.y + c * uvw.z;
		}

		public static float3 BarycentricInterpolate(in float3 uvw, in float3 a, in float3 b, in float3 c)
		{
			return a * uvw.x + b * uvw.y + c * uvw.z;
		}

		public static float SqDistTriangle(in float3 v1, in float3 v2, in float3 v3, in float3 p)
		{
			// see: "distance to triangle" by Inigo Quilez
			// https://www.iquilezles.org/www/articles/triangledistance/triangledistance.htm

			float dot2(float3 v) => dot(v, v);

			// prepare data
			float3 v21 = v2 - v1; float3 p1 = p - v1;
			float3 v32 = v3 - v2; float3 p2 = p - v2;
			float3 v13 = v1 - v3; float3 p3 = p - v3;
			float3 nor = cross(v21, v13);

			// inside/outside test
			if (sign(dot(cross(v21, nor), p1)) +
				sign(dot(cross(v32, nor), p2)) +
				sign(dot(cross(v13, nor), p3)) < 2.0f)
			{
				// 3 edges
				return min(min(
					dot2(v21 * clamp(dot(v21, p1) / dot2(v21), 0.0f, 1.0f) - p1),
					dot2(v32 * clamp(dot(v32, p2) / dot2(v32), 0.0f, 1.0f) - p2)),
					dot2(v13 * clamp(dot(v13, p3) / dot2(v13), 0.0f, 1.0f) - p3));
			}
			else
			{
				// 1 face
				return dot(nor, p1) * dot(nor, p1) / dot2(nor);
			}
		}

		public static float3 ProjectOntoLine(in float3 p, in float3 p0, in float3 p1)
		{
			var n = normalize(p1 - p0);
			var q = p0 + n * dot(p - p0, n);

			return q;
		}

		public static float3 ProjectOntoPlane(in float3 p, in float3 p0, in float3 n0)
		{
			return p - n0 * dot(p - p0, n0);
		}

		public static float3 ProjectOntoPlane(in float3 p, in float3 p0, in float3 p1, in float3 p2)
		{
			var v01 = p1 - p0;
			var v12 = p2 - p1;
			var v20 = p0 - p2;

			var n = normalize(cross(v20, v01));// ccw towards viewer
			var q = p - n * dot(p - p0, n);

			return q;
		}

		public static float3 ProjectOntoTriangle(in float3 p, in float3 p0, in float3 p1, in float3 p2)
		{
			var v01 = p1 - p0;
			var v12 = p2 - p1;
			var v20 = p0 - p2;

			var n = normalize(cross(v20, v01));// ccw towards viewer
			var q = p - n * dot(p - p0, n);

			var v0q = q - p0;
			var v1q = q - p1;
			var v2q = q - p2;

			var n01 = cross(v01, n);
			var n12 = cross(v12, n);
			var n20 = cross(v20, n);

			var d01 = dot(v0q, n01);
			var d12 = dot(v1q, n12);
			var d20 = dot(v2q, n20);

			var mask_face_positive =
				(d01 > 0.0f ? 0b001 : 0b000) |
				(d12 > 0.0f ? 0b010 : 0b000) |
				(d20 > 0.0f ? 0b100 : 0b000);

			if (mask_face_positive != 0)
			{
				var t01 = dot(v0q, v01) / lengthsq(v01);
				var t12 = dot(v1q, v12) / lengthsq(v12);
				var t20 = dot(v2q, v20) / lengthsq(v20);

				var mask_face_ortho =
					((t01 > 0.0f && t01 < 1.0f) ? 0b001 : 0b000) |
					((t12 > 0.0f && t12 < 1.0f) ? 0b010 : 0b000) |
					((t20 > 0.0f && t20 < 1.0f) ? 0b100 : 0b000);

				var mask_face_isect =
					((t01 >= 1.0f && t12 <= 0.0f) ? 0b011 : 0b000) |
					((t12 >= 1.0f && t20 <= 0.0f) ? 0b110 : 0b000) |
					((t20 >= 1.0f && t01 <= 0.0f) ? 0b101 : 0b000);

				switch ((mask_face_positive & mask_face_ortho) | mask_face_isect)
				{
					case 0b001: q = ProjectOntoLine(q, p0, p1); break;
					case 0b010: q = ProjectOntoLine(q, p1, p2); break;
					case 0b100: q = ProjectOntoLine(q, p2, p0); break;
					case 0b011: q = p1; break;
					case 0b110: q = p2; break;
					case 0b101: q = p0; break;
				}
			}

			return q;
		}
	}
}

```

`Runtime/Utility/TriMeshQueries.cs.meta`:

```meta
fileFormatVersion: 2
guid: 554dc0678ef95494ab17c60f80a8865b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility/TriMeshSampler.cs`:

```cs
using System;
using UnityEngine;
using Unity.Collections;

namespace Unity.DemoTeam.Hair
{
	public struct TriMeshSampler : IDisposable
	{
		public TriMeshBuffers triangleMesh;

		public int triangleCount;
		public float triangleAreaSum;
		public NativeArray<float> triangleArea;
		public NativeArray<float> triangleAreaAccu;

		public Unity.Mathematics.Random randSeed;
		public Unity.Mathematics.Random rand;

		public TriMeshSampler(Mesh.MeshData meshData, uint seedIndex, Allocator allocator = Allocator.Temp, uint submeshMask = ~0u)
		{
			triangleMesh = new TriMeshBuffers(meshData, TriMeshBuffers.Attribute.All, allocator, submeshMask);

			triangleCount = triangleMesh.triangleVertexCount / 3;
			triangleAreaSum = 0.0f;

			triangleArea = new NativeArray<float>(triangleCount, allocator);
			triangleAreaAccu = new NativeArray<float>(triangleCount, allocator);

			// calc triangle area + total
			for (int i = 0; i != triangleCount; i++)
			{
				var j0 = triangleMesh.triangleVertexIndices[i * 3 + 0];
				var j1 = triangleMesh.triangleVertexIndices[i * 3 + 1];
				var j2 = triangleMesh.triangleVertexIndices[i * 3 + 2];

				var p0 = triangleMesh.vertexPosition[j0];
				var p1 = triangleMesh.vertexPosition[j1];
				var p2 = triangleMesh.vertexPosition[j2];

				var area = 0.5f * Mathf.Abs(Vector3.Magnitude(Vector3.Cross(p2 - p0, p1 - p0)));

				triangleAreaSum += area;
				triangleArea[i] = area;
			}

			// calc triangle area accumulated until current index
			if (triangleCount > 0)
			{
				triangleAreaAccu[0] = triangleArea[0];
				for (int i = 1; i != triangleCount; i++)
				{
					triangleAreaAccu[i] = triangleAreaAccu[i - 1] + triangleArea[i];
				}
			}

			// initial sequence
			rand = randSeed = Unity.Mathematics.Random.CreateFromIndex(seedIndex);
		}

		public void Dispose()
		{
			triangleMesh.Dispose();

			triangleArea.Dispose();
			triangleAreaAccu.Dispose();
		}

		private void ResetSequence()
		{
			rand = randSeed;
		}

		private int NextTriangleIndex()
		{
			if (triangleCount == 0)
			{
				return -1;
			}
			else
			{
				var searchValue = triangleAreaSum * rand.NextFloat();
				var searchIndex = triangleAreaAccu.BinarySearch(searchValue);

				if (searchIndex >= 0)
					return searchIndex;
				else
					return ~searchIndex;
			}
		}

		public Sample Next()
		{
			var i = NextTriangleIndex();
			if (i == -1)
			{
				return new Sample();
			}

			var s = rand.NextFloat();
			var t = rand.NextFloat();
			if (s + t > 1.0f)
			{
				s = 1.0f - s;
				t = 1.0f - t;
			}

			var j0 = triangleMesh.triangleVertexIndices[i * 3 + 0];
			var j1 = triangleMesh.triangleVertexIndices[i * 3 + 1];
			var j2 = triangleMesh.triangleVertexIndices[i * 3 + 2];

			var p0 = triangleMesh.vertexPosition[j0];
			var p1 = triangleMesh.vertexPosition[j1] - p0;
			var p2 = triangleMesh.vertexPosition[j2] - p0;

			var n0 = triangleMesh.vertexNormal[j0];
			var n1 = triangleMesh.vertexNormal[j1] - n0;
			var n2 = triangleMesh.vertexNormal[j2] - n0;

			var u0 = triangleMesh.vertexUV0[j0];
			var u1 = triangleMesh.vertexUV0[j1] - u0;
			var u2 = triangleMesh.vertexUV0[j2] - u0;

			return new Sample()
			{
				position = p0 + (s * p1) + (t * p2),
				normal = n0 + (s * n1) + (t * n2),
				uv0 = u0 + (s * u1) + (t * u2),
			};
		}

		public struct Sample
		{
			public Vector3 position;
			public Vector3 normal;
			public Vector2 uv0;
		}
	}
}

```

`Runtime/Utility/TriMeshSampler.cs.meta`:

```meta
fileFormatVersion: 2
guid: 3dbdb473c7b230b4b99a4fb5c796e90a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility/UnsafeAdjacency.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.DemoTeam.Hair
{
	public unsafe struct UnsafeAdjacency : IDisposable
	{
		public struct LinkedIndexList
		{
			public int head;
			public int size;
		}

		public struct LinkedIndexItem
		{
			public int next;
			public int prev;
			public int data;
		}

		public NativeArray<LinkedIndexList> lists;
		public LinkedIndexList* listsPtr;

		public UnsafeList<LinkedIndexItem> items;
		public LinkedIndexItem* itemsPtr;

		public int listCount;
		public int itemCount;

		public UnsafeAdjacency(int listCapacity, int itemCapacity, Allocator allocator)
		{
			lists = new NativeArray<LinkedIndexList>(listCapacity, allocator, NativeArrayOptions.UninitializedMemory);
			listsPtr = (LinkedIndexList*)lists.GetUnsafePtr();

			items = new UnsafeList<LinkedIndexItem>(itemCapacity, allocator, NativeArrayOptions.UninitializedMemory);
			itemsPtr = (LinkedIndexItem*)items.Ptr;

			listCount = lists.Length;
			itemCount = 0;

			Clear();
		}

		public void Dispose()
		{
			lists.Dispose();
			items.Dispose();
		}

		public void Clear()
		{
			listCount = lists.Length;
			itemCount = 0;

			for (int i = 0; i != listCount; i++)
			{
				listsPtr[i].head = -1;
				listsPtr[i].size = 0;
			}
		}

		public void Append(int listIndex, int value)
		{
			if (itemCount == items.Capacity)
			{
				items.Resize(itemCount * 2, NativeArrayOptions.UninitializedMemory);
				itemsPtr = (LinkedIndexItem*)items.Ptr;
			}

			int headIndex = listsPtr[listIndex].head;
			if (headIndex == -1)
			{
				int itemIndex = itemCount++;

				itemsPtr[itemIndex] = new LinkedIndexItem
				{
					next = itemIndex,
					prev = itemIndex,
					data = value,
				};

				listsPtr[listIndex].head = itemIndex;
				listsPtr[listIndex].size = 1;
			}
			else
			{
				int itemIndex = itemCount++;
				int tailIndex = itemsPtr[headIndex].prev;

				itemsPtr[itemIndex] = new LinkedIndexItem
				{
					next = headIndex,
					prev = tailIndex,
					data = value,
				};

				itemsPtr[tailIndex].next = itemIndex;
				itemsPtr[headIndex].prev = itemIndex;

				listsPtr[listIndex].size++;
			}
		}

		public void AppendMove(int listIndex, int listOther)
		{
			int headOther = listsPtr[listOther].head;
			if (headOther != -1)
			{
				int headIndex = listsPtr[listIndex].head;
				if (headIndex != -1)
				{
					int tailIndex = itemsPtr[headIndex].prev;
					int tailOther = itemsPtr[headOther].prev;

					itemsPtr[headIndex].prev = tailOther;
					itemsPtr[tailIndex].next = headOther;

					itemsPtr[headOther].prev = tailIndex;
					itemsPtr[tailOther].next = headIndex;

					listsPtr[listIndex].size += listsPtr[listOther].size;
				}
				else
				{
					listsPtr[listIndex].head = listsPtr[listOther].head;
					listsPtr[listIndex].size = listsPtr[listOther].size;
				}

				listsPtr[listOther].head = -1;
				listsPtr[listOther].size = 0;
			}
		}

		public int GetCount(int listIndex)
		{
			return listsPtr[listIndex].size;
		}

		public LinkedIndexEnumerable this[int listIndex]
		{
			get
			{
				return new LinkedIndexEnumerable(itemsPtr, listsPtr[listIndex].head);
			}
		}

		public struct LinkedIndexEnumerable : IEnumerable<int>
		{
			public LinkedIndexItem* itemsPtr;
			public int headIndex;

			public LinkedIndexEnumerable(LinkedIndexItem* itemsPtr, int headIndex)
			{
				this.itemsPtr = itemsPtr;
				this.headIndex = headIndex;
			}

			public LinkedIndexEnumerator GetEnumerator()
			{
				return new LinkedIndexEnumerator(itemsPtr, headIndex, -1);
			}

			IEnumerator<int> IEnumerable<int>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public struct LinkedIndexEnumerator : IEnumerator<int>
		{
			public LinkedIndexItem* itemsPtr;
			public int headIndex;
			public int itemIndex;

			public LinkedIndexEnumerator(LinkedIndexItem* itemsPtr, int headIndex, int itemIndex)
			{
				this.itemsPtr = itemsPtr;
				this.headIndex = headIndex;
				this.itemIndex = itemIndex;
			}

			public int Current
			{
				get { return itemsPtr[itemIndex].data; }
			}

			object IEnumerator.Current
			{
				get { return Current; }
			}

			public bool MoveNext()
			{
				if (itemIndex == -1)
				{
					itemIndex = headIndex;
					return (itemIndex != -1);
				}
				else
				{
					itemIndex = itemsPtr[itemIndex].next;
					return (itemIndex != headIndex);// stop if we've come full circle
				}
			}

			public int ReadNext()
			{
				if (MoveNext())
					return Current;
				else
					return -1;
			}

			public void Reset()
			{
				itemIndex = headIndex;
			}

			public void Dispose()
			{
				// foo
			}
		}
	}
}

```

`Runtime/Utility/UnsafeAdjacency.cs.meta`:

```meta
fileFormatVersion: 2
guid: 4e90ccd13f16cbb479c01fb7e7f07f4b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility/UnsafeBFS.cs`:

```cs
using System;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.DemoTeam.Hair
{
	public unsafe struct UnsafeBFS : IDisposable
	{
		public int currentNodeIndex;
		public int currentNodeDepth;

		public NativeArray<ulong> pending;// pending[i] == (nodeDepth << 32) | nodeIndex
		public ulong* pendingPtr;
		public int pendingHead;
		public int pendingTail;

		public NativeArray<bool> visited;
		public bool* visitedPtr;

		public UnsafeBFS(int nodeCount, Allocator allocator)
		{
			currentNodeIndex = -1;
			currentNodeDepth = -1;

			pending = new NativeArray<ulong>(nodeCount, allocator, NativeArrayOptions.UninitializedMemory);
			pendingPtr = (ulong*)pending.GetUnsafePtr();
			pendingHead = 0;
			pendingTail = 0;

			visited = new NativeArray<bool>(nodeCount, allocator, NativeArrayOptions.ClearMemory);
			visitedPtr = (bool*)visited.GetUnsafePtr();
		}

		public void Dispose()
		{
			pending.Dispose();
			visited.Dispose();
		}

		public void Clear()
		{
			currentNodeIndex = -1;
			currentNodeDepth = -1;

			pendingHead = 0;
			pendingTail = 0;

			UnsafeUtility.MemClear(visitedPtr, sizeof(bool) * visited.Length);
		}

		public void Ignore(int nodeIndex)
		{
			visitedPtr[nodeIndex] = true;
		}

		public void Insert(int nodeIndex)
		{
			if (visitedPtr[nodeIndex])
				return;

			ulong packedIndex = (ulong)nodeIndex;
			ulong packedDepth = (ulong)(currentNodeDepth + 1) << 32;

			pendingPtr[pendingTail++] = packedDepth | packedIndex;
			visitedPtr[nodeIndex] = true;
		}

		public bool MoveNext(out int nodeIndex, out int nodeDepth)
		{
			if (pendingHead != pendingTail)
			{
				ulong packed = pendingPtr[pendingHead++];
				nodeIndex = currentNodeIndex = (int)(packed & 0xffffffffuL);
				nodeDepth = currentNodeDepth = (int)(packed >> 32);
				return true;
			}
			else
			{
				nodeIndex = currentNodeIndex = -1;
				nodeDepth = currentNodeDepth = -1;
				return false;
			}
		}
	}
}

```

`Runtime/Utility/UnsafeBFS.cs.meta`:

```meta
fileFormatVersion: 2
guid: 9c3ed87e933ecb045ac632003a9030e1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility/UnsafeBVH.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Mathematics;

using static Unity.Mathematics.math;

namespace Unity.DemoTeam.Hair
{
	using Leaf = UnsafeBVH.Leaf;
	using Node = UnsafeBVH.Node;

	public unsafe interface IUnsafeBVHContext
	{
		int GetLeafCount();
		void BuildLeafData(Leaf* leafPtr, int leafCount);
		float SqDistanceLeafPoint(uint leafIndex, in float3 p);
		float SqDistanceLeafTrace(uint leafIndex, in float3 p, in float3 r);
	}

	public unsafe struct UnsafeBVH : IDisposable
	{
		public struct Leaf
		{
			public float3 min;// aabb min
			public float3 max;// aabb max
			public uint index;// context data index

			public static readonly Leaf empty = new Leaf
			{
				min = Vector3.positiveInfinity,
				max = Vector3.negativeInfinity,
				index = uint.MaxValue,
			};
		}

		public struct Node
		{
			public Leaf data;
			public uint stepL;
			public uint stepR;

			public static readonly Node empty = new Node
			{
				data = Leaf.empty,
				stepL = 0,
				stepR = 0,
			};

			public bool Contains(in float3 p)
			{
				return all((p >= data.min) & (p <= data.max));
			}
		}

		public NativeArray<Node> nodeData;

		public UnsafeBVH(int leafCapacity, Allocator allocator)
		{
			nodeData = new NativeArray<Node>(leafCapacity * 2 - 1, allocator, NativeArrayOptions.UninitializedMemory);
			nodeData[0] = Node.empty;
		}

		public void Dispose()
		{
			nodeData.Dispose();
		}

		public Node* GetUnsafeRootPtr()
		{
			return (Node*)nodeData.GetUnsafePtr();
		}
	}

	public static unsafe class UnsafeBVHBuilder
	{
		struct LeafComparerX : IComparer<Leaf> { public int Compare(Leaf a, Leaf b) => a.min.x.CompareTo(b.min.x); }
		struct LeafComparerY : IComparer<Leaf> { public int Compare(Leaf a, Leaf b) => a.min.y.CompareTo(b.min.y); }
		struct LeafComparerZ : IComparer<Leaf> { public int Compare(Leaf a, Leaf b) => a.min.z.CompareTo(b.min.z); }

		static readonly LeafComparerX leafComparerX = new LeafComparerX();
		static readonly LeafComparerY leafComparerY = new LeafComparerY();
		static readonly LeafComparerZ leafComparerZ = new LeafComparerZ();

		static Leaf MakeUnion(Leaf* leafPtr, int leafCount)
		{
			if (leafCount > 0)
			{
				var result = leafPtr[0];
				for (int i = 0; i != leafCount; i++)
				{
					result.min = min(result.min, leafPtr[i].min);
					result.max = max(result.max, leafPtr[i].max);
					result.index = uint.MaxValue;
				}
				return result;
			}
			else
			{
				return Leaf.empty;
			}
		}

		static void SortWithinNode(Leaf* leafPtr, int leafCount, Node* nodePtr)
		{
			var size = abs(nodePtr->data.max - nodePtr->data.min);
			if (size.x >= size.y && size.x >= size.z)
				NativeSortExtension.Sort(leafPtr, leafCount, leafComparerX);
			else if (size.y >= size.z)
				NativeSortExtension.Sort(leafPtr, leafCount, leafComparerY);
			else
				NativeSortExtension.Sort(leafPtr, leafCount, leafComparerZ);
		}

		static void SplitWithinNode(Leaf* leafPtr, int leafCount, Node* nodePtr, out int leafCountL, out int leafCountR)
		{
			SortWithinNode(leafPtr, leafCount, nodePtr);

			leafCountL = (leafCount + 1) / 2;
			leafCountR = leafCount - leafCountL;

			//TODO sah?
		}

		static Node* BuildNode(ref Node* nodeWritePtr, Leaf* leafPtr, int leafCount)
		{
			var nodePtr = nodeWritePtr++;

			if (leafCount == 1)
			{
				nodePtr->data = *leafPtr;
				nodePtr->stepL = 0;
				nodePtr->stepR = 0;
			}
			else
			{
				nodePtr->data = MakeUnion(leafPtr, leafCount);

				SplitWithinNode(leafPtr, leafCount, nodePtr, out var leafCountL, out var leafCountR);

				nodePtr->stepL = (leafCountL == 0) ? 0 : (uint)(BuildNode(ref nodeWritePtr, leafPtr, leafCountL) - nodePtr);
				nodePtr->stepR = (leafCountR == 0) ? 0 : (uint)(BuildNode(ref nodeWritePtr, leafPtr + leafCountL, leafCountR) - nodePtr);
			}

			return nodePtr;
		}

		public static UnsafeBVH CreateFromContext<T>(in T context, Allocator allocator) where T : IUnsafeBVHContext
		{
			using (var leafData = new NativeArray<Leaf>(context.GetLeafCount(), allocator))
			{
				var leafPtr = (Leaf*)leafData.GetUnsafePtr();
				var leafCount = leafData.Length;
				{
					context.BuildLeafData(leafPtr, leafCount);
				}

				var bvh = new UnsafeBVH(leafCount, allocator);
				var bvhWritePtr = bvh.GetUnsafeRootPtr();
				{
					BuildNode(ref bvhWritePtr, leafPtr, leafCount);
				}

				return bvh;
			}
		}
	}

	public static unsafe class UnsafeBVHQueries
	{
		public static float SqDistanceNodePoint(Node* nodePtr, in float3 p)
		{
			//                .p
			//            .r´
			// +-------+´
			// |     e´|
			// |   q´  |
			// |       |
			// +-------+

			var e = 0.5f * (nodePtr->data.max - nodePtr->data.min);
			var q = 0.5f * (nodePtr->data.max + nodePtr->data.min);
			var r = max(abs(p - q) - e, 0.0f);

			return dot(r, r);
		}

		public static uint FindClosestLeaf<T>(in T context, in UnsafeBVH bvh, in float3 p) where T : IUnsafeBVHContext
		{
			var bestDist = float.PositiveInfinity;
			var bestIndex = uint.MaxValue;

			FindClosestLeaf(context, bvh.GetUnsafeRootPtr(), p, &bestDist, &bestIndex);

			return bestIndex;
		}

		static void FindClosestLeaf<T>(in T context, Node* nodePtr, in float3 p, float* bestDistPtr, uint* bestIndexPtr) where T : IUnsafeBVHContext
		{
			// examine leaf data
			var leafIndex = nodePtr->data.index;
			if (leafIndex != uint.MaxValue)
			{
				var distSq = context.SqDistanceLeafPoint(leafIndex, p);
				if (distSq < *bestDistPtr)
				{
					*bestDistPtr = distSq;
					*bestIndexPtr = leafIndex;
				}
			}

			// examine subtrees (closest first)
			var distL = (nodePtr->stepL != 0) ? SqDistanceNodePoint(nodePtr + nodePtr->stepL, p) : float.PositiveInfinity;
			var distR = (nodePtr->stepR != 0) ? SqDistanceNodePoint(nodePtr + nodePtr->stepR, p) : float.PositiveInfinity;
			if (distR < distL)
			{
				if (distR < *bestDistPtr) FindClosestLeaf(context, nodePtr + nodePtr->stepR, p, bestDistPtr, bestIndexPtr);
				if (distL < *bestDistPtr) FindClosestLeaf(context, nodePtr + nodePtr->stepL, p, bestDistPtr, bestIndexPtr);
			}
			else
			{
				if (distL < *bestDistPtr) FindClosestLeaf(context, nodePtr + nodePtr->stepL, p, bestDistPtr, bestIndexPtr);
				if (distR < *bestDistPtr) FindClosestLeaf(context, nodePtr + nodePtr->stepR, p, bestDistPtr, bestIndexPtr);
			}
		}
	}
}

```

`Runtime/Utility/UnsafeBVH.cs.meta`:

```meta
fileFormatVersion: 2
guid: c1a390e09b00db6439de9430eff905a3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility/UnsafeClusterSet.cs`:

```cs
#define USE_JOBS

using System;
using UnityEngine;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Mathematics;
using Unity.Burst;
using Unity.Jobs;

namespace Unity.DemoTeam.Hair
{
	using static PointSetMath;

	public enum ClusterAllocationPolicy
	{
		Global,
		SplitGlobal,
		SplitBranching,
	}

	public enum ClusterAllocationOrder
	{
		ByHighestError,// approximate
		ByHighestTally,// approximate
		ByHighestTallyBreadthFirst,// approximate
	}

	public enum ClusterVoid
	{
		Remove,
		Preserve,
		Reallocate,
	}

	[BurstCompile]
	public unsafe struct UnsafeClusterSet : IDisposable
	{
		public UnsafeList<Vector3> clusterPosition;
		public UnsafeList<float> clusterWeight;
		public UnsafeList<int> clusterTally;
		public UnsafeList<int> clusterGuide;
		public UnsafeList<int> clusterDepth;
		public UnsafeList<float> clusterCarry;
		public UnsafeList<float> clusterReach;

		public UnsafeList<int> sampleCluster;

		public DataDesc dataDesc;

		public struct DataDesc
		{
			public int clusterCapacity;
			public int clusterCount;
			public int clusterCountCommitted;

			public ClusterVoid clusterVoidPolicy;

			[NativeDisableUnsafePtrRestriction, NoAlias] public Vector3* clusterPositionPtr;// data valid after UpdateCentroids, SelectCentroids
			[NativeDisableUnsafePtrRestriction, NoAlias] public float* clusterWeightPtr;	// data valid after UpdateCentroids, SelectCentroids
			[NativeDisableUnsafePtrRestriction, NoAlias] public int* clusterTallyPtr;		// data valid after AssignSamples, SelectPreassigned
			[NativeDisableUnsafePtrRestriction, NoAlias] public int* clusterGuidePtr;		// data valid after Commit
			[NativeDisableUnsafePtrRestriction, NoAlias] public int* clusterDepthPtr;		// data valid after Commit
			[NativeDisableUnsafePtrRestriction, NoAlias] public float* clusterCarryPtr;		// data valid after Commit
			[NativeDisableUnsafePtrRestriction, NoAlias] public float* clusterReachPtr;		// data valid after Commit

			public int clusterPositionOffset;
			public int clusterPositionStride;
			public int clusterPositionCount;

			public int sampleCount;

			[NativeDisableUnsafePtrRestriction, NoAlias] public Vector3* samplePositionPtr;	// must be assigned prior to each operation
			[NativeDisableUnsafePtrRestriction, NoAlias] public float* sampleWeightPtr;		// must be assigned prior to each operation
			[NativeDisableUnsafePtrRestriction, NoAlias] public int* sampleResolvePtr;		// must be assigned prior to each operation
			[NativeDisableUnsafePtrRestriction, NoAlias] public int* sampleClusterPtr;		// data valid after AssignSamples, SelectPreassigned

			public int samplePositionOffset;
			public int samplePositionStride;
			public int samplePositionCount;

			public Unity.Mathematics.Random randSeq;
		}

		public UnsafeClusterSet(int clusterCapacity, ClusterVoid clusterVoidPolicy, int sampleCount, int samplePositionOffset, int samplePositionStride, int samplePositionCount, Allocator allocator)
		{
			this.clusterPosition = new UnsafeList<Vector3>(clusterCapacity * samplePositionCount, allocator, NativeArrayOptions.UninitializedMemory);
			this.clusterWeight = new UnsafeList<float>(clusterCapacity, allocator, NativeArrayOptions.UninitializedMemory);
			this.clusterTally = new UnsafeList<int>(clusterCapacity, allocator, NativeArrayOptions.UninitializedMemory);
			this.clusterGuide = new UnsafeList<int>(clusterCapacity, allocator, NativeArrayOptions.UninitializedMemory);
			this.clusterDepth = new UnsafeList<int>(clusterCapacity, allocator, NativeArrayOptions.UninitializedMemory);
			this.clusterCarry = new UnsafeList<float>(clusterCapacity, allocator, NativeArrayOptions.UninitializedMemory);
			this.clusterReach = new UnsafeList<float>(clusterCapacity, allocator, NativeArrayOptions.UninitializedMemory);

			this.sampleCluster = new UnsafeList<int>(sampleCount, allocator, NativeArrayOptions.UninitializedMemory);

			//.dataDesc
			{
				this.dataDesc.clusterCapacity = clusterCapacity;
				this.dataDesc.clusterCount = 0;
				this.dataDesc.clusterCountCommitted = 0;

				this.dataDesc.clusterVoidPolicy = clusterVoidPolicy;

				this.dataDesc.clusterPositionPtr = this.clusterPosition.Ptr;
				this.dataDesc.clusterWeightPtr = this.clusterWeight.Ptr;
				this.dataDesc.clusterTallyPtr = this.clusterTally.Ptr;
				this.dataDesc.clusterGuidePtr = this.clusterGuide.Ptr;
				this.dataDesc.clusterDepthPtr = this.clusterDepth.Ptr;
				this.dataDesc.clusterCarryPtr = this.clusterCarry.Ptr;
				this.dataDesc.clusterReachPtr = this.clusterReach.Ptr;

				this.dataDesc.clusterPositionOffset = samplePositionCount;
				this.dataDesc.clusterPositionStride = 1;
				this.dataDesc.clusterPositionCount = samplePositionCount;

				this.dataDesc.sampleCount = sampleCount;

				this.dataDesc.samplePositionPtr = null; // must be assigned prior to each operation
				this.dataDesc.sampleResolvePtr = null;  // must be assigned prior to each operation
				this.dataDesc.sampleWeightPtr = null;   // must be assigned prior to each operation
				this.dataDesc.sampleClusterPtr = this.sampleCluster.Ptr;

				this.dataDesc.samplePositionOffset = samplePositionOffset;
				this.dataDesc.samplePositionStride = samplePositionStride;
				this.dataDesc.samplePositionCount = samplePositionCount;

				this.dataDesc.randSeq = new Unity.Mathematics.Random(137);//TODO seed by param
			}

			for (int k = 0; k != clusterCapacity; k++)
			{
				this.dataDesc.clusterTallyPtr[k] = -1;
				this.dataDesc.clusterGuidePtr[k] = -1;
			}

			for (int i = 0; i != sampleCount; i++)
			{
				this.dataDesc.sampleClusterPtr[i] = -1;
			}
		}

		public void Dispose()
		{
			clusterPosition.Dispose();
			clusterWeight.Dispose();
			clusterTally.Dispose();
			clusterGuide.Dispose();
			clusterCarry.Dispose();
			clusterReach.Dispose();

			sampleCluster.Dispose();
		}

		void EnsureCapacity(int clusterCapacity)
		{
			if (clusterCapacity > dataDesc.clusterCapacity)
			{
				clusterPosition.Resize(clusterCapacity * dataDesc.clusterPositionCount);
				clusterWeight.Resize(clusterCapacity);
				clusterTally.Resize(clusterCapacity);
				clusterGuide.Resize(clusterCapacity);
				clusterDepth.Resize(clusterCapacity);
				clusterCarry.Resize(clusterCapacity);
				clusterReach.Resize(clusterCapacity);

				dataDesc.clusterPositionPtr = clusterPosition.Ptr;
				dataDesc.clusterWeightPtr = clusterWeight.Ptr;
				dataDesc.clusterTallyPtr = clusterTally.Ptr;
				dataDesc.clusterGuidePtr = clusterGuide.Ptr;
				dataDesc.clusterDepthPtr = clusterDepth.Ptr;
				dataDesc.clusterCarryPtr = clusterCarry.Ptr;
				dataDesc.clusterReachPtr = clusterReach.Ptr;

				dataDesc.clusterCapacity = clusterCapacity;

				for (int k = dataDesc.clusterCount; k != dataDesc.clusterCapacity; k++)
				{
					dataDesc.clusterTallyPtr[k] = -1;
					dataDesc.clusterGuidePtr[k] = -1;
				}
			}
		}

		static int CountEmptyClusters(ref DataDesc dataDesc)
		{
			var emptyClusterCount = 0;
			{
				for (int k = 0; k != dataDesc.clusterCount; k++)
				{
					if (dataDesc.clusterTallyPtr[k] == 0)
					{
						emptyClusterCount++;
					}
				}
			}
			return emptyClusterCount;
		}

		static bool FindClosestCluster(ref DataDesc dataDesc, int i, out float minDistSq, out int minDistIndex)
		{
			minDistSq = float.PositiveInfinity;
			minDistIndex = -1;

			for (int k = 0; k != dataDesc.clusterCount; k++)
			{
				var distSq = PsDistanceSq(
					dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * k,
					dataDesc.clusterPositionStride,
					dataDesc.samplePositionPtr + dataDesc.samplePositionOffset * dataDesc.sampleResolvePtr[i],
					dataDesc.samplePositionStride,
					dataDesc.samplePositionCount);

				if (minDistSq > distSq)
				{
					minDistSq = distSq;
					minDistIndex = k;
				}
			}

			return (minDistIndex != -1);
		}

		static bool FindClosestSample(ref DataDesc dataDesc, int k, out float minDistSq, out int minDistIndex)
		{
			minDistSq = float.PositiveInfinity;
			minDistIndex = -1;

			for (int i = 0; i != dataDesc.sampleCount; i++)
			{
				var distSq = PsDistanceSq(
					dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * k,
					dataDesc.clusterPositionStride,
					dataDesc.samplePositionPtr + dataDesc.samplePositionOffset * dataDesc.sampleResolvePtr[i],
					dataDesc.samplePositionStride,
					dataDesc.samplePositionCount);

				if (minDistSq > distSq)
				{
					minDistSq = distSq;
					minDistIndex = k;
				}
			}

			return (minDistIndex != -1);
		}

		static UnsafeList<float> FindAllClustersMaxErrorSq(ref DataDesc dataDesc, Allocator allocator)
		{
			var maxErrorSq = new UnsafeList<float>(dataDesc.clusterCount, allocator, NativeArrayOptions.UninitializedMemory);
			var maxErrorSqPtr = maxErrorSq.Ptr;
			{
				for (int k = 0; k != dataDesc.clusterCount; k++)
				{
					maxErrorSqPtr[k] = float.NegativeInfinity;
				}

				for (int i = 0; i != dataDesc.sampleCount; i++)
				{
					var k = dataDesc.sampleClusterPtr[i];
					if (k != -1)
					{
						var errorSq = PsDistanceSq(
							dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * k,
							dataDesc.clusterPositionStride,
							dataDesc.samplePositionPtr + dataDesc.samplePositionOffset * dataDesc.sampleResolvePtr[i],
							dataDesc.samplePositionStride,
							dataDesc.samplePositionCount);

						if (maxErrorSqPtr[k] < errorSq)
							maxErrorSqPtr[k] = errorSq;
					}
				}
			}
			return maxErrorSq;
		}

		static UnsafeList<uint> FindAllClustersMaxErrorSortKey(ref DataDesc dataDesc, Allocator allocator)
		{
			var maxErrorSortKey = new UnsafeList<uint>(dataDesc.clusterCount, allocator, NativeArrayOptions.UninitializedMemory);
			var maxErrorSortKeyPtr = maxErrorSortKey.Ptr;

			using (var maxError = FindAllClustersMaxErrorSq(ref dataDesc, allocator))
			{
				var maxErrorPtr = maxError.Ptr;
				var maxErrorLimit = 0.0f;
				{
					for (int k = 0; k != dataDesc.clusterCount; k++)
					{
						var maxErrorValue = maxErrorPtr[k];
						if (maxErrorValue > 0.0f)
						{
							maxErrorValue = Mathf.Sqrt(maxErrorValue);
							maxErrorPtr[k] = maxErrorValue;
						}

						if (maxErrorLimit < maxErrorValue)
							maxErrorLimit = maxErrorValue;
					}

					if (maxErrorLimit == 0.0f)
						maxErrorLimit = 1.0f;
				}

				for (int k = 0; k != dataDesc.clusterCount; k++)
				{
					var maxErrorNorm = maxErrorPtr[k] / maxErrorLimit;
					if (maxErrorNorm > 0.0f)
					{
						maxErrorSortKeyPtr[k] = (uint)(uint.MaxValue * (double)maxErrorNorm);
					}
					else
					{
						maxErrorSortKeyPtr[k] = 0;
					}
				}
			}

			return maxErrorSortKey;
		}

		// select n additional cluster centroids from set of samples by k-means++ initialization
		void SelectCentroids(int n)
		{
			// see "k-means++: The Advantages of Careful Seeding"
			// http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf

			using (var longOperation = new LongOperationScope("Picking centroids"))
			using (var state = new SelectCentroidState(dataDesc, Allocator.Temp))
			{
				var nTotal = n;

				// pick first centroid with uniform probability
				if (dataDesc.clusterCount < dataDesc.clusterCapacity && dataDesc.clusterCount == 0 && n-- > 0)
				{
					var i = dataDesc.randSeq.NextInt(0, dataDesc.sampleCount);
					{
						state.exclusionMask.Ptr[i] = true;

						PsCopyA(
							dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * 0,
							dataDesc.clusterPositionStride,
							dataDesc.samplePositionPtr + dataDesc.samplePositionOffset * dataDesc.sampleResolvePtr[i],
							dataDesc.samplePositionStride,
							dataDesc.samplePositionCount);

						dataDesc.clusterCount++;
					}

					longOperation.UpdateStatus("Picked", 1, nTotal);
				}

				// pick remaining centroids with higher probability further from already chosen centroids
				while (dataDesc.clusterCount < dataDesc.clusterCapacity && n-- > 0)
				{
					if (SelectCentroid(dataDesc.clusterCount, state))
					{
						dataDesc.clusterCount++;
					}
					else
					{
						break;// ... there are no more candidates
					}

					longOperation.UpdateStatus("Picked", (nTotal - n), nTotal);
				}
			}
			// using (...)
		}

		struct SelectCentroidState : IDisposable
		{
			public UnsafeList<bool> exclusionMask;
			public UnsafeList<int> candidateSample;
			public UnsafeList<float> candidateWeight;

			public SelectCentroidState(in DataDesc dataDesc, Allocator allocator)
			{
				exclusionMask = new UnsafeList<bool>(dataDesc.sampleCount, allocator, NativeArrayOptions.ClearMemory);
				candidateSample = new UnsafeList<int>(dataDesc.sampleCount, allocator, NativeArrayOptions.UninitializedMemory);
				candidateWeight = new UnsafeList<float>(dataDesc.sampleCount, allocator, NativeArrayOptions.UninitializedMemory);

				// exclude existing guides from selection
				var exclusionMaskPtr = exclusionMask.Ptr;
				{
					for (int k = 0; k != dataDesc.clusterCount; k++)
					{
						var i = dataDesc.clusterGuidePtr[k];
						if (i != -1)
						{
							exclusionMaskPtr[i] = true;
						}
					}
				}
			}

			public void Dispose()
			{
				exclusionMask.Dispose();
				candidateSample.Dispose();
				candidateWeight.Dispose();
			}
		}

		struct SelectCentroidCandidate
		{
			public int sample;
			public float weight;
		}

		// select k-th cluster centroid from set of samples by k-means++ initialization
		bool SelectCentroid(int k, in SelectCentroidState state)
		{
			var exclusionMaskPtr = state.exclusionMask.Ptr;
			var candidateSamplePtr = state.candidateSample.Ptr;
			var candidateWeightPtr = state.candidateWeight.Ptr;
			var candidateCount = 0;

			// gather candidates by squared distance to closest centroid
#if USE_JOBS
			fixed (DataDesc* dataDescPtr = &dataDesc)
			{
				var job = new SelectCentroidCandidatesJob
				{
					dataDescPtr = dataDescPtr,
					exclusionMaskPtr = exclusionMaskPtr,
					candidateCountPtr = &candidateCount,
					candidateSamplePtr = candidateSamplePtr,
					candidateWeightPtr = candidateWeightPtr,
				};

				var jobHandle = job.Schedule(dataDesc.sampleCount, 64);
				{
					JobHandle.ScheduleBatchedJobs();
					jobHandle.Complete();
				}

				//TODO simplify
				// sort candidates by sample index to maintain ordering
				using (var candidateKeys = new UnsafeList<ulong>(candidateCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
				using (var candidateSampleCopy = new UnsafeList<int>(candidateCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
				using (var candidateWeightCopy = new UnsafeList<float>(candidateCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
				{
					var candidateKeysPtr = candidateKeys.Ptr;
					var candidateSampleCopyPtr = candidateSampleCopy.Ptr;
					var candidateWeightCopyPtr = candidateWeightCopy.Ptr;

					for (int i = 0; i != candidateCount; i++)
					{
						var sortSample = (ulong)candidateSamplePtr[i] << 32;
						var sortLookup = (ulong)i;
						{
							candidateKeysPtr[i] = sortSample | sortLookup;
							candidateSampleCopyPtr[i] = candidateSamplePtr[i];
							candidateWeightCopyPtr[i] = candidateWeightPtr[i];
						}
					}

					NativeSortExtension.Sort(candidateKeysPtr, candidateCount);

					for (int i = 0; i != candidateCount; i++)
					{
						var resolve = (int)(candidateKeysPtr[i] & 0xffffffffuL);
						{
							candidateSamplePtr[i] = candidateSampleCopyPtr[resolve];
							candidateWeightPtr[i] = candidateWeightCopyPtr[resolve];
						}
					}
				}
			}
#else
			for (int i = 0; i != dataDesc.sampleCount; i++)
			{
				if (exclusionMaskPtr[i])
					continue;

				if (FindClosestCluster(ref dataDesc, i, out var minDistSq, out var minDistIndex))
				{
					candidateSamplePtr[candidateCount] = i;
					candidateWeightPtr[candidateCount] = minDistSq;
					candidateCount++;
				}
			}
#endif

			// failure if there were no candidates
			if (candidateCount == 0)
				return false;

			// compute accumulated weights until current index
			for (int i = 1; i != candidateCount; i++)
			{
				candidateWeightPtr[i] = candidateWeightPtr[i - 1] + candidateWeightPtr[i];
			}

			// weighted search for k-th centroid
			var candidateWeightSum = candidateWeightPtr[candidateCount - 1];
			{
				var searchValue = candidateWeightSum * dataDesc.randSeq.NextFloat();
				var searchIndex = NativeSortExtension.BinarySearch(candidateWeightPtr, candidateCount, searchValue);
				if (searchIndex < 0)
					searchIndex = ~searchIndex;

				var i = candidateSamplePtr[searchIndex];
				{
					exclusionMaskPtr[i] = true;

					PsCopyA(
						dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * k,
						dataDesc.clusterPositionStride,
						dataDesc.samplePositionPtr + dataDesc.samplePositionOffset * dataDesc.sampleResolvePtr[i],
						dataDesc.samplePositionStride,
						dataDesc.samplePositionCount);
				}
			}

			// success
			return true;
		}

		[BurstCompile]
		struct SelectCentroidCandidatesJob : IJobParallelFor
		{
			[NativeDisableUnsafePtrRestriction, NoAlias] public DataDesc* dataDescPtr;
			[NativeDisableUnsafePtrRestriction, NoAlias] public bool* exclusionMaskPtr;
			[NativeDisableUnsafePtrRestriction, NoAlias] public int* candidateSamplePtr;
			[NativeDisableUnsafePtrRestriction, NoAlias] public float* candidateWeightPtr;
			[NativeDisableUnsafePtrRestriction, NoAlias] public int* candidateCountPtr;

			public void Execute(int i)
			{
				if (exclusionMaskPtr[i])
					return;

				if (FindClosestCluster(ref *dataDescPtr, i, out var minDistSq, out var minDistIndex))
				{
					var j = System.Threading.Interlocked.Increment(ref *candidateCountPtr) - 1;
					{
						candidateSamplePtr[j] = i;
						candidateWeightPtr[j] = minDistSq;
					}
				}
			}
		}

		// assign samples to clusters by closest centroid
		int AssignSamples()
		{
			var reassignedCount = 0;
			{
				UnsafeUtility.MemClear(dataDesc.clusterTallyPtr, sizeof(int) * dataDesc.clusterCount);

#if USE_JOBS
				fixed (DataDesc* dataDescPtr = &dataDesc)
				{
					var job = new AssignSamplesJob
					{
						dataDescPtr = dataDescPtr,
						reassignedCountPtr = &reassignedCount
					};

					var jobHandle = job.Schedule(dataDesc.sampleCount, 64);
					{
						JobHandle.ScheduleBatchedJobs();
						jobHandle.Complete();
					}
				}
#else
				for (int i = 0; i != dataDesc.sampleCount; i++)
				{
					if (AssignSample(ref dataDesc, i, out var k))
					{
						reassignedCount++;
					}

					if (k != -1)
					{
						dataDesc.clusterTallyPtr[k]++;
					}
				}
#endif
			}

			if (reassignedCount > 0)
			{
				UpdateVoid();
			}

			return reassignedCount;
		}

		[BurstCompile]
		struct AssignSamplesJob : IJobParallelFor
		{
			[NativeDisableUnsafePtrRestriction, NoAlias] public DataDesc* dataDescPtr;
			[NativeDisableUnsafePtrRestriction, NoAlias] public int* reassignedCountPtr;

			public void Execute(int i)
			{
				if (AssignSample(ref *dataDescPtr, i, out var k))
				{
					System.Threading.Interlocked.Increment(ref *reassignedCountPtr);
				}

				if (k != -1)
				{
					System.Threading.Interlocked.Increment(ref dataDescPtr->clusterTallyPtr[k]);
				}
			}
		}

		// assign i-th sample to cluster with closest centroid, returns true if reassigned
		static bool AssignSample(ref DataDesc dataDesc, int i, out int k)
		{
			// do not reassign samples that are guides in committed clusters
			var kExisting = dataDesc.sampleClusterPtr[i];
			if (kExisting != -1 && kExisting < dataDesc.clusterCountCommitted)
			{
				if (dataDesc.clusterGuidePtr[kExisting] == i)
				{
					k = kExisting;
					return false;
				}
			}

			// assign sample to closest cluster
			if (FindClosestCluster(ref dataDesc, i, out var minDistSq, out var minDistIndex))
			{
				k = minDistIndex;
				if (dataDesc.sampleClusterPtr[i] != minDistIndex)
				{
					dataDesc.sampleClusterPtr[i] = minDistIndex;
					return true;
				}
			}
			else
			{
				k = -1;
			}

			return false;
		}

		// update empty clusters according to strategy specified on initialization
		void UpdateVoid()
		{
			switch (dataDesc.clusterVoidPolicy)
			{
				// displace empty clusters to effectively remove them from solution
				case ClusterVoid.Remove:
					{
						for (int k = 0; k != dataDesc.clusterCount; k++)
						{
							if (dataDesc.clusterTallyPtr[k] > 0)
								continue;

							PsClearA(
								dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * k,
								dataDesc.clusterPositionStride,
								Vector3.positiveInfinity,
								dataDesc.clusterPositionCount);
						}
					}
					break;

				// preserve empty clusters so they have a chance of reentering
				case ClusterVoid.Preserve:
					break;

				// reallocate empty clusters by k-means++ initialization
				case ClusterVoid.Reallocate:
					{
						using (var state = new SelectCentroidState(dataDesc, Allocator.Temp))
						{
							for (int k = 0; k != dataDesc.clusterCount; k++)
							{
								if (dataDesc.clusterTallyPtr[k] > 0)
									continue;

								if (SelectCentroid(k, state) == false)
								{
									break;// ... there are no more candidates
								}
							}
						}
					}
					break;
			}
		}

		// update cluster centroids from assigned samples
		void UpdateCentroids()
		{
			if (dataDesc.clusterCount == 0)
				return;

			// clear centroids
			for (int k = 0; k != dataDesc.clusterCount; k++)
			{
				if (dataDesc.clusterTallyPtr[k] > 0)
				{
					PsClearA(
						dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * k,
						dataDesc.clusterPositionStride,
						Vector3.zero,
						dataDesc.clusterPositionCount);

					dataDesc.clusterWeightPtr[k] = 0.0f;
				}
			}

			// add samples to weighted sum
			//TODO either list per cluster, or split the work
			for (int i = 0; i != dataDesc.sampleCount; i++)
			{
				var k = dataDesc.sampleClusterPtr[i];
				var w = dataDesc.sampleWeightPtr[dataDesc.sampleResolvePtr[i]];
				{
					PsMulAddA(
						dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * k,
						dataDesc.clusterPositionStride,
						dataDesc.samplePositionPtr + dataDesc.samplePositionOffset * dataDesc.sampleResolvePtr[i],
						dataDesc.samplePositionStride, w,
						dataDesc.samplePositionCount);

					dataDesc.clusterWeightPtr[k] += w;
				}
			}

			// weighted average to obtain centroids
			for (int k = 0; k != dataDesc.clusterCount; k++)
			{
				if (dataDesc.clusterTallyPtr[k] > 0)
				{
					PsMulA(
						dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * k,
						dataDesc.clusterPositionStride,
						1.0f / dataDesc.clusterWeightPtr[k],
						dataDesc.clusterPositionCount);
				}
			}

			// committed centroids cannot stray too far from guides
			//TODO replace hard snap with limit
			//TODO limit to half the distance to closest adj. centroid (to avoid stealing from other committed clusters)
			for (int k = 0; k != dataDesc.clusterCountCommitted; k++)
			{
				var i = dataDesc.clusterGuidePtr[k];
				if (i != -1)
				{
					PsCopyA(
						dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * k,
						dataDesc.clusterPositionStride,
						dataDesc.samplePositionPtr + dataDesc.samplePositionOffset * dataDesc.sampleResolvePtr[i],
						dataDesc.samplePositionStride,
						dataDesc.samplePositionCount);
				}
			}
		}

		public bool ExpandProcedural(int clusterCount, ClusterAllocationPolicy clusterSelectionPolicy, ClusterAllocationOrder clusterSelectionOrder, int clusterIterations)
		{
			var appendCount = clusterCount - dataDesc.clusterCount;
			if (appendCount <= 0)
				return false;

			EnsureCapacity(clusterCount);

			if (clusterSelectionPolicy != ClusterAllocationPolicy.Global)
			{
				// bootstrap empty set before splitting
				if (dataDesc.clusterCount == 0)
				{
					ExpandProcedural(1, ClusterAllocationPolicy.Global, clusterSelectionOrder, 0);
					appendCount--;
				}

				// handle large splits as multiple chunks (prevents some otherwise expensive global searches in first few levels)
				while (appendCount > 0)
				{
					var intermediateClusterCount = dataDesc.clusterCount;
					var intermediateSplitThreshold = 64 * intermediateClusterCount;
					if (intermediateSplitThreshold < appendCount)
					{
						ExpandProcedural(dataDesc.clusterCount + intermediateSplitThreshold, clusterSelectionPolicy, clusterSelectionOrder, clusterIterations);
						appendCount -= (dataDesc.clusterCount - intermediateClusterCount);
					}
					else
					{
						break;
					}
				}
			}

			switch (clusterSelectionPolicy)
			{
				case ClusterAllocationPolicy.Global:
					{
						SelectCentroids(appendCount);
						AssignSamples();
						UpdateCentroids();
						Refine(clusterIterations);
					}
					break;

				case ClusterAllocationPolicy.SplitGlobal:
					{
						SplitClusters(appendCount, clusterSelectionOrder, 0);
						Refine(clusterIterations);
					}
					break;

				case ClusterAllocationPolicy.SplitBranching:
					{
						SplitClusters(appendCount, clusterSelectionOrder, clusterIterations);
					}
					break;
			}

			return true;
		}

		public bool ExpandPreassigned(int clusterCount, in UnsafeList<int> sampleCluster)
		{
			var appendCount = clusterCount - dataDesc.clusterCount;
			if (appendCount <= 0)
				return false;

			EnsureCapacity(clusterCount);

			using (var preassignedClusterSet = new UnsafeClusterSet(clusterCount, ClusterVoid.Preserve, dataDesc.sampleCount, dataDesc.samplePositionOffset, dataDesc.samplePositionStride, dataDesc.samplePositionCount, Allocator.Temp))
			using (var preassignedClusterResolve = new UnsafeList<int>(clusterCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
			{
				// build preassigned set
				var preassignedDataDescPtr = &preassignedClusterSet.dataDesc;
				{
					preassignedDataDescPtr->samplePositionPtr = dataDesc.samplePositionPtr;
					preassignedDataDescPtr->sampleWeightPtr = dataDesc.sampleWeightPtr;
					preassignedDataDescPtr->sampleResolvePtr = dataDesc.sampleResolvePtr;
				}

				var sampleClusterPtr = sampleCluster.Ptr;
				{
					UnsafeUtility.MemClear(preassignedClusterSet.dataDesc.clusterTallyPtr, sizeof(int) * preassignedClusterSet.dataDesc.clusterCapacity);

					for (int i = 0; i != preassignedClusterSet.dataDesc.sampleCount; i++)
					{
						var k = sampleClusterPtr[preassignedClusterSet.dataDesc.sampleResolvePtr[i]];
						if (k < preassignedClusterSet.dataDesc.clusterCapacity)
						{
							preassignedClusterSet.dataDesc.sampleClusterPtr[i] = k;
							preassignedClusterSet.dataDesc.clusterTallyPtr[k]++;
						}
						else
						{
							Debug.LogWarning("Skipping entry from preassigned set: Preassigned cluster index exceeds capacity of allocated cluster set.");
						}
					}

					preassignedDataDescPtr->clusterCount = clusterCount;
				}

				preassignedClusterSet.UpdateVoid();
				preassignedClusterSet.UpdateCentroids();

				var preassignedClusterResolvePtr = preassignedClusterResolve.Ptr;
				{
					for (int k = 0; k != preassignedClusterSet.dataDesc.clusterCount; k++)
					{
						preassignedClusterResolvePtr[k] = -1;
					}
				}

				// map preassigned clusters to existing and append only those that cannot be mapped, so as to not override existing committed structure
				using (var centroidClusterSet = new UnsafeClusterSet(dataDesc.clusterCapacity, ClusterVoid.Preserve, preassignedClusterSet.dataDesc.clusterCount, preassignedClusterSet.dataDesc.clusterPositionOffset, preassignedClusterSet.dataDesc.clusterPositionStride, preassignedClusterSet.dataDesc.clusterPositionCount, Allocator.Temp))
				using (var centroidSampleWeight = new UnsafeList<float>(preassignedClusterSet.dataDesc.clusterCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
				using (var centroidSampleResolve = new UnsafeList<int>(preassignedClusterSet.dataDesc.clusterCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
				{
					// map centroids of preassigned clusters to existing clusters
					var centroidDataDescPtr = &centroidClusterSet.dataDesc;
					var centroidSampleWeightPtr = centroidSampleWeight.Ptr;
					var centroidSampleResolvePtr = centroidSampleResolve.Ptr;
					{
						// copy existing cluster centroids
						UnsafeUtility.MemCpy(centroidClusterSet.dataDesc.clusterPositionPtr, dataDesc.clusterPositionPtr, sizeof(Vector3) * clusterPosition.Length);
						{
							centroidDataDescPtr->clusterCount = dataDesc.clusterCount;
						}

						// bind preassigned centroids as sample data
						centroidDataDescPtr->samplePositionPtr = preassignedClusterSet.dataDesc.clusterPositionPtr;
						centroidDataDescPtr->sampleWeightPtr = centroidSampleWeightPtr;
						centroidDataDescPtr->sampleResolvePtr = centroidSampleResolvePtr;

						for (int ki = 0; ki != preassignedClusterSet.dataDesc.clusterCount; ki++)
						{
							centroidSampleWeightPtr[ki] = 1.0f;
							centroidSampleResolvePtr[ki] = ki;
						}

						// construct the map
						centroidClusterSet.AssignSamples();
					}

					// make space for empty existing clusters (that are not the best fit for any preassigned cluster)
					var emptyCount = CountEmptyClusters(ref *centroidDataDescPtr);
					if (emptyCount > 0)
					{
						EnsureCapacity(dataDesc.clusterCapacity + emptyCount);
					}

					// identify secondary preassigned clusters (that are not the best fit for the closest existing cluster)
					centroidClusterSet.Commit();

					// append secondary preassigned clusters
					for (int ki = 0; ki != centroidClusterSet.dataDesc.sampleCount; ki++)
					{
						var k = centroidClusterSet.dataDesc.sampleClusterPtr[ki];
						if (k == -1 || ki != centroidClusterSet.dataDesc.clusterGuidePtr[k])// not guide => secondary
						{
							var kAppend = dataDesc.clusterCount++;

							// copy centroid
							PsCopyA(
								dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * kAppend,
								dataDesc.clusterPositionStride,
								preassignedClusterSet.dataDesc.clusterPositionPtr + preassignedClusterSet.dataDesc.clusterPositionOffset * ki,
								preassignedClusterSet.dataDesc.clusterPositionStride,
								preassignedClusterSet.dataDesc.clusterPositionCount);

							// initialize tally
							dataDesc.clusterTallyPtr[kAppend] = 0;

							// queue resolve
							preassignedClusterResolvePtr[ki] = kAppend;
						}
					}
				}
				// using (...)

				// resolve sample cluster assignments for appended clusters
				var reassignedCount = 0;
				{
					for (int i = 0; i != dataDesc.sampleCount; i++)
					{
						var kPreassigned = preassignedClusterSet.dataDesc.sampleClusterPtr[i];
						var kResolved = preassignedClusterResolvePtr[kPreassigned];
						if (kResolved != -1)
						{
							// do not reassign samples that are guides in committed clusters
							var kExisting = dataDesc.sampleClusterPtr[i];
							if (kExisting != -1 && kExisting < dataDesc.clusterCountCommitted)
							{
								if (dataDesc.clusterGuidePtr[kExisting] == i)
								{
									continue;
								}
							}

							// reassign to appended cluster
							//TODO update tallies in separate pass instead of inc/dec?
							if (kExisting != -1)
							{
								dataDesc.clusterTallyPtr[kExisting]--;
							}

							dataDesc.sampleClusterPtr[i] = kResolved;
							dataDesc.clusterTallyPtr[kResolved]++;
							reassignedCount++;
						}
					}
				}
				if (reassignedCount > 0)
				{
					UpdateCentroids();

					//Debug.Log("---");
					//for (int k = 0; k != dataDesc.clusterCount; k++)
					//{
					//	Debug.Log("cluster " + k + " -> guide " + dataDesc.clusterGuidePtr[k] + " tally " + dataDesc.clusterTallyPtr[k]);
					//}
				}
			}
			// using (...)

			return true;
		}

		void SplitClusters(int n, ClusterAllocationOrder splitPreference, int splitClusterIterations)
		{
			using (var longOperation = new LongOperationScope("Splitting clusters"))
			using (var splitWorkDesc = new SplitClustersWorkDesc(ref dataDesc, n, splitPreference, Allocator.Temp))
			{
				var splitKeysPtr = splitWorkDesc.splitKeys.Ptr;
				var splitCountPtr = splitWorkDesc.splitCount.Ptr;
				var splitOffsetPtr = splitWorkDesc.splitOffset.Ptr;

				var splitWorkTotal = splitWorkDesc.splitWorkTotal;
				var splitWorkUnits = splitWorkDesc.splitWorkUnits;

				// early out if no splits were ordered
				if (splitWorkUnits == 0)
				{
					return;
				}

				// execute the splits
				//TODO split in parallel?
				for (int j = 0; j != splitWorkUnits; j++)
				{
					longOperation.UpdateStatus("Split", j + 1, splitWorkUnits);

					var k = (int)(splitKeysPtr[j] & 0xffffffffuL);

					var splitClusterCount = 1 + splitCountPtr[j];
					var splitSampleCount = dataDesc.clusterTallyPtr[k];

					using (var splitClusterSet = new UnsafeClusterSet(splitClusterCount, dataDesc.clusterVoidPolicy, splitSampleCount, dataDesc.samplePositionOffset, dataDesc.samplePositionStride, dataDesc.samplePositionCount, Allocator.Temp))
					using (var splitSampleResolve = new UnsafeList<int>(splitSampleCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
					{
						// bind sample indices from parent cluster
						var splitSampleResolvePtr = splitSampleResolve.Ptr;
						var splitSampleResolveCount = 0;
						{
							for (int i = 0; i != dataDesc.sampleCount && splitSampleResolveCount < splitSampleCount; i++)
							{
								if (dataDesc.sampleClusterPtr[i] == k)
								{
									splitSampleResolvePtr[splitSampleResolveCount++] = i;
								}
							}
						}

						var splitDataDescPtr = &splitClusterSet.dataDesc;
						{
							splitDataDescPtr->samplePositionPtr = dataDesc.samplePositionPtr;
							splitDataDescPtr->sampleWeightPtr = dataDesc.sampleWeightPtr;
							splitDataDescPtr->sampleResolvePtr = splitSampleResolvePtr;
						}

						// inject first centroid from parent cluster
						{
							PsCopyA(
								splitDataDescPtr->clusterPositionPtr + splitDataDescPtr->clusterPositionOffset * 0,
								splitDataDescPtr->clusterPositionStride,
								dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * k,
								dataDesc.clusterPositionStride,
								dataDesc.clusterPositionCount);

							splitDataDescPtr->clusterCount++;
						}

						// inject first guide from split cluster as well, if split cluster was a committed cluster
						var parentClusterCommitted = (k < dataDesc.clusterCountCommitted);
						if (parentClusterCommitted)
						{
							splitDataDescPtr->clusterGuidePtr[0] = NativeArrayExtensions.IndexOf<int, int>(splitSampleResolvePtr, splitSampleResolveCount, dataDesc.clusterGuidePtr[k]);
							splitDataDescPtr->clusterDepthPtr[0] = dataDesc.clusterDepthPtr[k];
							splitDataDescPtr->clusterCountCommitted++;
						}

						// select remaining centroids by k-means++ initialization
						splitClusterSet.SelectCentroids(splitClusterCount - 1);
						splitClusterSet.AssignSamples();
						splitClusterSet.UpdateCentroids();
						splitClusterSet.Refine(splitClusterIterations);

						// transfer centroids to parent set
						{
							// first centroid replaces existing entry
							PsCopyA(
								dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * k,
								dataDesc.clusterPositionStride,
								splitDataDescPtr->clusterPositionPtr + splitDataDescPtr->clusterPositionOffset * 0,
								splitDataDescPtr->clusterPositionStride,
								splitDataDescPtr->clusterPositionCount);

							dataDesc.clusterWeightPtr[k] = splitDataDescPtr->clusterWeightPtr[0];
							dataDesc.clusterTallyPtr[k] = splitDataDescPtr->clusterTallyPtr[0];

							// remaining centroids appended at specific offset
							for (int m = 1; m != splitClusterCount; m++)
							{
								var km = splitOffsetPtr[j] + m - 1;

								PsCopyA(
									dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * km,
									dataDesc.clusterPositionStride,
									splitDataDescPtr->clusterPositionPtr + splitDataDescPtr->clusterPositionOffset * m,
									splitDataDescPtr->clusterPositionStride,
									splitDataDescPtr->clusterPositionCount);

								dataDesc.clusterWeightPtr[km] = splitDataDescPtr->clusterWeightPtr[m];
								dataDesc.clusterTallyPtr[km] = splitDataDescPtr->clusterTallyPtr[m];
							}
						}

						// transfer assignments to parent set
						for (int i = 0; i != splitDataDescPtr->sampleCount; i++)
						{
							var m = splitDataDescPtr->sampleClusterPtr[i];
							if (m == 0)
							{
								// samples in first cluster are already assigned
								//dataDesc.sampleClusterPtr[splitSampleResolvePtr[i]] = k;
							}
							else
							{
								// samples in remaining clusters need to be reassigned
								dataDesc.sampleClusterPtr[splitSampleResolvePtr[i]] = splitOffsetPtr[j] + m - 1;
							}
						}
					}
					// using (...)
				}

				// count the added clusters
				dataDesc.clusterCount += splitWorkTotal;
			}
			// using (...)
		}

		struct SplitClustersWorkDesc : IDisposable
		{
			public UnsafeList<ulong> splitKeys;
			public UnsafeList<int> splitCount;
			public UnsafeList<int> splitOffset;

			public int splitWorkTotal;
			public int splitWorkUnits;

			public SplitClustersWorkDesc(ref DataDesc dataDesc, int n, ClusterAllocationOrder splitPreference, Allocator allocator)
			{
				splitKeys = new UnsafeList<ulong>(dataDesc.clusterCount, allocator, NativeArrayOptions.UninitializedMemory);
				splitCount = new UnsafeList<int>(dataDesc.clusterCount, allocator, NativeArrayOptions.ClearMemory);
				splitOffset = new UnsafeList<int>(dataDesc.clusterCount, allocator, NativeArrayOptions.UninitializedMemory);

				splitWorkTotal = 0;
				splitWorkUnits = 0;

				if (dataDesc.clusterCount == 0)
				{
					return;
				}

				var splitKeysPtr = splitKeys.Ptr;
				var splitCountPtr = splitCount.Ptr;
				var splitOffsetPtr = splitOffset.Ptr;

				void BubbleFirstIndex(ulong* valuePtr, int valueCount) => BubbleSingleIndex(valuePtr, valueCount, 0);
				void BubbleSingleIndex(ulong* valuePtr, int valueCount, int i)
				{
					var valueMoving = valuePtr[i++];

					for (; i != valueCount; i++)
					{
						var valueStep = valuePtr[i];
						if (valueStep < valueMoving)
						{
							valuePtr[i - 1] = valueStep;
						}
						else
						{
							valuePtr[i - 1] = valueMoving;
							return;
						}
					}

					if (i == valueCount)
					{
						valuePtr[valueCount - 1] = valueMoving;
					}
				}

				switch (splitPreference)
				{
					case ClusterAllocationOrder.ByHighestError:
						using (var maxErrorSortKey = FindAllClustersMaxErrorSortKey(ref dataDesc, allocator))
						{
							var maxErrorSortKeyPtr = maxErrorSortKey.Ptr;

							// sort clusters by maximum error (descending)
							for (int k = 0; k != dataDesc.clusterCount; k++)
							{
								var sortError = (ulong)(uint.MaxValue - maxErrorSortKeyPtr[k]) << 32;// store error descending
								var sortIndex = (ulong)k;
								{
									splitKeysPtr[k] = sortError | sortIndex;
								}
							}

							NativeSortExtension.Sort(splitKeysPtr, dataDesc.clusterCount);

							// distribute splits ordered by maximum error, shrinking maximum error with each split
							while (n-- > 0)
							{
								var k = (int)(splitKeysPtr[0] & 0xffffffffuL);
								var c = dataDesc.clusterTallyPtr[k] - splitCountPtr[k];
								if (c > 1)// must have at least one free sample available for centroid selection
								{
									var approxError = maxErrorSortKeyPtr[k];
									{
										//TODO intuitively, the reduced error can be expressed as the approximate half-radius of one of the smaller clusters
										//TODO find the approximate radius of the smaller clusters
										approxError /= (2 + (uint)splitCountPtr[k]);
										if (c <= 2)
										{
											approxError = 0;// zero sort key (to effectively push to back) if this is the last free sample
										}
									}

									splitKeysPtr[0] &= 0xffffffffuL;
									splitKeysPtr[0] |= (ulong)(uint.MaxValue - approxError) << 32;// store error descending
									splitCountPtr[k]++;

									BubbleFirstIndex(splitKeysPtr, dataDesc.clusterCount);
								}
								else
								{
									n = 0;// no further splits possible
								}
							}
						}
						break;

					case ClusterAllocationOrder.ByHighestTally:
						{
							// sort clusters by tally (descending)
							for (int k = 0; k != dataDesc.clusterCount; k++)
							{
								var sortTally = (ulong)(uint.MaxValue - (uint)dataDesc.clusterTallyPtr[k]) << 32;// store tally descending
								var sortIndex = (ulong)k;
								{
									splitKeysPtr[k] = sortTally | sortIndex;
								}
							}

							NativeSortExtension.Sort(splitKeysPtr, dataDesc.clusterCount);

							// distribute splits ordered by tally, shrinking tally with each split
							while (n-- > 0)
							{
								var k = (int)(splitKeysPtr[0] & 0xffffffffuL);
								var c = dataDesc.clusterTallyPtr[k] - splitCountPtr[k];
								if (c > 1)// must have at least one free sample available for centroid selection
								{
									var approxTally = (uint)dataDesc.clusterTallyPtr[k];
									{
										approxTally /= (2 + (uint)splitCountPtr[k]);
										if (c <= 2)
										{
											approxTally = 0;// zero sort key (to effectively push to back) if this is the last free sample
										}
									}

									splitKeysPtr[0] &= 0xffffffffuL;
									splitKeysPtr[0] |= (ulong)(uint.MaxValue - approxTally) << 32;// store tally descending
									splitCountPtr[k]++;

									BubbleFirstIndex(splitKeysPtr, dataDesc.clusterCount);
								}
								else
								{
									n = 0;// no further splits possible
								}
							}
						}
						break;

					case ClusterAllocationOrder.ByHighestTallyBreadthFirst:
						{
							// sort clusters by tally (descending)
							for (int k = 0; k != dataDesc.clusterCount; k++)
							{
								var sortTally = (ulong)(int.MaxValue - dataDesc.clusterTallyPtr[k]) << 32;// store tally descending
								var sortIndex = (ulong)k;
								{
									splitKeysPtr[k] = sortTally | sortIndex;
								}
							}

							NativeSortExtension.Sort(splitKeysPtr, dataDesc.clusterCount);

							// distribute splits breadth first, with remainder distributed to clusters with highest tally
							while (n > 0)
							{
								for (int j = 0; j != dataDesc.clusterCount && n > 0; j++, n--)
								{
									var k = (int)(splitKeysPtr[j] & 0xffffffffuL);
									var c = dataDesc.clusterTallyPtr[k] - splitCountPtr[k];
									if (c > 1)// must have at least one free sample available for centroid selection
									{
										splitCountPtr[k]++;
									}
									else
									{
										if (j == 0)
											n = 0;// no further splits possible

										break;
									}
								}
							}

						}
						break;
				}

				// prepare work units (compact)
				for (int k = 0; k != dataDesc.clusterCount; k++)
				{
					var nk = splitCountPtr[k];
					if (nk > 0)
					{
						var j = splitWorkUnits++;
						{
							splitKeysPtr[j] = (ulong)k;
							splitCountPtr[j] = nk;
							splitWorkTotal += nk;
						}
					}
				}

				// compute work unit offsets
				if (splitWorkUnits > 0)
				{
					splitOffsetPtr[0] = dataDesc.clusterCount;

					for (int j = 1; j != splitWorkUnits; j++)
					{
						splitOffsetPtr[j] = splitOffsetPtr[j - 1] + splitCountPtr[j - 1];
					}
				}
			}

			public void Dispose()
			{
				splitKeys.Dispose();
				splitCount.Dispose();
				splitOffset.Dispose();
			}
		}

		// refine clusters by k-means iteration
		public void Refine(int maxIterations)
		{
			if (maxIterations == 0)
				return;

			using (var longOperation = new LongOperationScope("Refining clusters"))
			{
				var t = 0.0f;
				var tt = 0.0f;

				for (int m = 0; m != maxIterations; m++)
				{
					longOperation.UpdateStatus("Iteration " + (m + 1) + " ...", tt);

					var reassignedCount = AssignSamples();
					if (reassignedCount > 0)
					{
						UpdateCentroids();

						t = (dataDesc.sampleCount - reassignedCount) / (float)dataDesc.sampleCount;
						tt = t * t;
					}
					else
					{
						break;
					}
				}
			}
		}

		// commit clusters to guides (also reduces future working set)
		public void Commit()
		{
			// compact and trim so live clusters are consecutive in range [0, clusterCount)
			CompactAndTrim();

			// pick one guide per cluster based on minimum weighted distance to centroid
			using (var minDist = new UnsafeList<float>(dataDesc.clusterCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
			{
				var minDistPtr = minDist.Ptr;
				{
					for (int k = 0; k != dataDesc.clusterCount; k++)
					{
						minDistPtr[k] = float.PositiveInfinity;
					}
				}

				for (int i = 0; i != dataDesc.sampleCount; i++)
				{
					var k = dataDesc.sampleClusterPtr[i];
					if (k < dataDesc.clusterCountCommitted)
					{
						continue;// skip committed clusters (since they have a fixed guide assigned to them)
					}

					var w = dataDesc.sampleWeightPtr[i];
					{
						var dist = PsDistance(
							dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * k,
							dataDesc.clusterPositionStride,
							dataDesc.samplePositionPtr + dataDesc.samplePositionOffset * dataDesc.sampleResolvePtr[i],
							dataDesc.samplePositionStride,
							dataDesc.samplePositionCount) / w;

						if (minDistPtr[k] > dist)
						{
							minDistPtr[k] = dist;
							dataDesc.clusterGuidePtr[k] = i;
							dataDesc.clusterDepthPtr[k] = dataDesc.clusterCount;// this is useful as a sorting key
						}
					}
				}
			}

			// find cluster carry (weight of all samples in cluster relative to weight of cluster guide)
			for (int k = 0; k != dataDesc.clusterCount; k++)
			{
				var i = dataDesc.clusterGuidePtr[k];
				if (i != -1)
				{
					dataDesc.clusterCarryPtr[k] = dataDesc.clusterWeightPtr[k] / dataDesc.sampleWeightPtr[i];
				}
			}

			// snap centroids to guides
			for (int k = 0; k != dataDesc.clusterCount; k++)
			{
				var i = dataDesc.clusterGuidePtr[k];
				if (i != -1)
				{
					PsCopyA(
						dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * k,
						dataDesc.clusterPositionStride,
						dataDesc.samplePositionPtr + dataDesc.samplePositionOffset * dataDesc.sampleResolvePtr[i],
						dataDesc.samplePositionStride,
						dataDesc.samplePositionCount);
				}
			}

			// find cluster reach (maximum sample distance to centroid)
			//TODO recompute & use actual (not snapped) cluster centroids as error origins
			//TODO maybe replace with radius of planar convex hull?
			using (var maxErrorSq = FindAllClustersMaxErrorSq(ref dataDesc, Allocator.Temp))
			{
				var maxErrorSqPtr = maxErrorSq.Ptr;
				{
					for (int k = 0; k != dataDesc.clusterCount; k++)
					{
						dataDesc.clusterReachPtr[k] = (maxErrorSqPtr[k] > 0.0f) ? Mathf.Sqrt(maxErrorSqPtr[k]) : 0.0f;
					}
				}
			}

			// reduce working set
			dataDesc.clusterCountCommitted = dataDesc.clusterCount;
		}

		// compact cluster data by moving empty clusters to tail end of set and shrinking set
		void CompactAndTrim()
		{
			// early out if there are no empty clusters
			var emptyClusterCount = CountEmptyClusters(ref dataDesc);
			if (emptyClusterCount == 0)
				return;

			//Debug.Log("found " + emptyClusterCount + " empty clusters (out of " + dataDesc.clusterCount + ") => compacting set ...");

			// move empty clusters to tail
			using (var remappedClusterIndices = new UnsafeList<int>(dataDesc.clusterCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory))
			{
				var remappedClusterIndicesPtr = remappedClusterIndices.Ptr;

				for (int k = 0; k < dataDesc.clusterCount; k++)
				{
					if (dataDesc.clusterTallyPtr[k] > 0)
					{
						remappedClusterIndicesPtr[k] = k;
						continue;
					}

					// swap empty cluster with live tail (if any)
					var kLive = dataDesc.clusterCount;
					{
						while (--kLive > k)
						{
							if (dataDesc.clusterTallyPtr[kLive] == 0)
								continue;

							PsCopyA(
								dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * k,
								dataDesc.clusterPositionStride,
								dataDesc.clusterPositionPtr + dataDesc.clusterPositionOffset * kLive,
								dataDesc.clusterPositionStride,
								dataDesc.clusterPositionCount);

							dataDesc.clusterWeightPtr[k] = dataDesc.clusterWeightPtr[kLive];
							dataDesc.clusterTallyPtr[k] = dataDesc.clusterTallyPtr[kLive];
							dataDesc.clusterGuidePtr[k] = dataDesc.clusterGuidePtr[kLive];
							dataDesc.clusterDepthPtr[k] = dataDesc.clusterDepthPtr[kLive];
							dataDesc.clusterCarryPtr[k] = dataDesc.clusterCarryPtr[kLive];
							dataDesc.clusterReachPtr[k] = dataDesc.clusterReachPtr[kLive];

							remappedClusterIndicesPtr[kLive] = k;
							break;
						}
					}

					dataDesc.clusterCount = kLive;
				}

				// apply remapped cluster indices
				for (int i = 0; i != dataDesc.sampleCount; i++)
				{
					dataDesc.sampleClusterPtr[i] = remappedClusterIndicesPtr[dataDesc.sampleClusterPtr[i]];
				}
			}
			// using (...)
		}

		/* old preassigned method, kept for reference
		// inject guides from prior committed set
		public bool InjectGuidesFrom(in ClusterSet clusterSet)
		{
			using (var clusterUpdated = new UnsafeList<bool>(dataDesc.clusterCount, Allocator.Temp, NativeArrayOptions.ClearMemory))
			{
				var clusterUpdatedPtr = clusterUpdated.Ptr;
				var clusterUpdatedCount = 0;

				// loop over and inject prior clusters
				for (int k = 0; k != clusterSet.dataDesc.clusterCount; k++)
				{
					// get prior cluster guide and depth
					var priorGuide = clusterSet.dataDesc.clusterGuidePtr[k];
					var priorDepth = clusterSet.dataDesc.clusterDepthPtr[k];

					// get current cluster for prior guide
					var kCurrent = dataDesc.sampleClusterPtr[priorGuide];

					// update current cluster if not already updated
					if (clusterUpdatedPtr[kCurrent] == false)
					{
						// transfer both guide and depth so we can sort clusters by depth first and guide second
						dataDesc.clusterGuidePtr[kCurrent] = priorGuide;
						dataDesc.clusterDepthPtr[kCurrent] = priorDepth;

						// mark as updated
						clusterUpdatedPtr[kCurrent] = true;
						clusterUpdatedCount++;
					}
				}

				// success if all guides were injected
				return (clusterUpdatedCount == clusterSet.dataDesc.clusterCount);
			}
			// using (...)
		}
		*/
	}

	public unsafe struct PointSetMath
	{
		public static void PsClearA(Vector3* pointsA, int strideA, Vector3 value, int count)
		{
			for (int i = 0; i != count; i++)
			{
				pointsA[i * strideA] = value;
			}
		}

		public static void PsCopyA(Vector3* pointsA, int strideA, Vector3* pointsB, int strideB, int count)
		{
			for (int i = 0; i != count; i++)
			{
				pointsA[i * strideA] = pointsB[i * strideB];
			}
		}

		public static void PsAddA(Vector3* pointsA, int strideA, Vector3* pointsB, int strideB, int count)
		{
			for (int i = 0; i != count; i++)
			{
				pointsA[i * strideA] += pointsB[i * strideB];
			}
		}

		public static void PsSubA(Vector3* pointsA, int strideA, Vector3* pointsB, int strideB, int count)
		{
			for (int i = 0; i != count; i++)
			{
				pointsA[i * strideA] -= pointsB[i * strideB];
			}
		}

		public static void PsMulA(Vector3* pointsA, int strideA, float scalarB, int count)
		{
			for (int i = 0; i != count; i++)
			{
				pointsA[i * strideA] *= scalarB;
			}
		}

		public static void PsMulAddA(Vector3* pointsA, int strideA, Vector3* pointsB, int strideB, float scalarC, int count)
		{
			for (int i = 0; i != count; i++)
			{
				pointsA[i * strideA] += pointsB[i * strideB] * scalarC;
			}
		}

		public static float PsDot(Vector3* pointsA, int strideA, Vector3* pointsB, int strideB, int count)
		{
			var sum = 0.0f;
			for (int i = 0; i != count; i++)
			{
				ref readonly var a = ref pointsA[i * strideA];
				ref readonly var b = ref pointsB[i * strideB];
				sum += (a.x * b.x);
				sum += (a.y * b.y);
				sum += (a.z * b.z);
			}
			return sum;
		}

		public static float PsNorm(Vector3* pointsA, int strideA, int count) => Mathf.Sqrt(PsNormSq(pointsA, strideA, count));
		public static float PsNormSq(Vector3* pointsA, int strideA, int count)
		{
			var sum = 0.0f;
			for (int i = 0; i != count; i++)
			{
				ref readonly var a = ref pointsA[i * strideA];
				sum += (a.x * a.x);
				sum += (a.y * a.y);
				sum += (a.z * a.z);
			}
			return sum;
		}

		public static float PsNormL1(Vector3* pointsA, int strideA, int count)
		{
			var sum = 0.0f;
			for (int i = 0; i != count; i++)
			{
				ref readonly var a = ref pointsA[i * strideA];
				sum += Mathf.Abs(a.x);
				sum += Mathf.Abs(a.y);
				sum += Mathf.Abs(a.z);
			}
			return sum;
		}

		public static float PsDistance(Vector3* pointsA, int strideA, Vector3* pointsB, int strideB, int count) => Mathf.Sqrt(PsDistanceSq(pointsA, strideA, pointsB, strideB, count));
		public static float PsDistanceSq(Vector3* pointsA, int strideA, Vector3* pointsB, int strideB, int count)
		{
			var sum = 0.0f;
			for (int i = 0; i != count; i++)
			{
				ref readonly var a = ref pointsA[i * strideA];
				ref readonly var b = ref pointsB[i * strideB];
				var dx = a.x - b.x;
				var dy = a.y - b.y;
				var dz = a.z - b.z;
				sum += (dx * dx);
				sum += (dy * dy);
				sum += (dz * dz);
			}
			return sum;
		}

		public static float PsDistanceL1(Vector3* pointsA, int strideA, Vector3* pointsB, int strideB, int count)
		{
			var sum = 0.0f;
			for (int i = 0; i != count; i++)
			{
				ref readonly var a = ref pointsA[i * strideA];
				ref readonly var b = ref pointsB[i * strideB];
				var dx = a.x - b.x;
				var dy = a.y - b.y;
				var dz = a.z - b.z;
				sum += Mathf.Abs(dx);
				sum += Mathf.Abs(dy);
				sum += Mathf.Abs(dz);
			}
			return sum;
		}

		public static float PsCosineSimilarity(Vector3* pointsA, int strideA, Vector3* pointsB, int strideB, int count)
		{
			var dotAB = PsDot(pointsA, strideA, pointsB, strideB, count);
			var normA = PsNorm(pointsA, strideA, count);
			var normB = PsNorm(pointsB, strideB, count);
			return dotAB / (normA * normB);
		}
	}
}

```

`Runtime/Utility/UnsafeClusterSet.cs.meta`:

```meta
fileFormatVersion: 2
guid: 62f37b3f67e48d44e893ac162b1a072d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility/UnsafeDFS.cs`:

```cs
using System;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.DemoTeam.Hair
{
	public unsafe struct UnsafeDFS : IDisposable
	{
		public int currentNodeIndex;
		public int currentNodeDepth;

		public NativeArray<ulong> pending;// pending[i] == (nodeDepth << 32) | nodeIndex
		public ulong* pendingPtr;
		public int pendingHead;

		public NativeArray<bool> visited;
		public bool* visitedPtr;

		public UnsafeDFS(int nodeCount, Allocator allocator)
		{
			currentNodeIndex = -1;
			currentNodeDepth = -1;

			pending = new NativeArray<ulong>(nodeCount, allocator, NativeArrayOptions.UninitializedMemory);
			pendingPtr = (ulong*)pending.GetUnsafePtr();
			pendingHead = 0;

			visited = new NativeArray<bool>(nodeCount, allocator, NativeArrayOptions.ClearMemory);
			visitedPtr = (bool*)visited.GetUnsafePtr();
		}

		public void Dispose()
		{
			pending.Dispose();
			visited.Dispose();
		}

		public void Clear()
		{
			currentNodeIndex = -1;
			currentNodeDepth = -1;

			pendingHead = 0;

			UnsafeUtility.MemClear(visitedPtr, sizeof(bool) * visited.Length);
		}

		public void Ignore(int nodeIndex)
		{
			visitedPtr[nodeIndex] = true;
		}

		public void Insert(int nodeIndex)
		{
			if (visitedPtr[nodeIndex])
				return;

			ulong packedIndex = (ulong)nodeIndex;
			ulong packedDepth = (ulong)(currentNodeDepth + 1) << 32;

			pendingPtr[pendingHead++] = packedDepth | packedIndex;
			visitedPtr[nodeIndex] = true;
		}

		public bool MoveNext(out int nodeIndex, out int nodeDepth)
		{
			if (pendingHead > 0)
			{
				ulong packed = pendingPtr[--pendingHead];
				nodeIndex = currentNodeIndex = (int)(packed & 0xffffffffuL);
				nodeDepth = currentNodeDepth = (int)(packed >> 32);
				return true;
			}
			else
			{
				nodeIndex = currentNodeIndex = -1;
				nodeDepth = currentNodeDepth = -1;
				return false;
			}
		}
	}
}

```

`Runtime/Utility/UnsafeDFS.cs.meta`:

```meta
fileFormatVersion: 2
guid: c9a28b8f7d11879428ef7bb18c43052c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Utility/VersionedData.cs`:

```cs
using UnityEngine;

namespace Unity.DemoTeam.Hair
{
	public interface IVersionedDataContext
	{
		// should return version of data (should return negative value if version of data is still pending)
		int version { get; }

		// should return version of implementation (constant)
		int VERSION { get; }

		// should increment version of data towards version of implementation
		void PerformMigrationStep();
	}

	public static class VersionedDataUtility
	{
		static readonly string versionPropertyPath = string.Format("<{0}>k__BackingField", nameof(IVersionedDataContext.version));

		public static void HandleVersionChangeOnValidate<T>(T ctx) where T : UnityEngine.Object, IVersionedDataContext
		{
#if UNITY_EDITOR
			UnityEditor.EditorApplication.delayCall += () =>
			{
				if (ctx != null)
				{
					HandleVersionChange(ctx);
				}
			};
#else
			HandleVersionChange(ctx);
#endif
		}

		public static void HandleVersionChange<T>(T ctx) where T : UnityEngine.Object, IVersionedDataContext
		{
			var versionIni = ctx.version;
			if (versionIni == ctx.VERSION || versionIni < 0)
				return;

			var nameType = ctx.GetType().Name;
			var nameObject = ctx.name;

			Debug.Log(string.Format("{0} ({1}): starting migration...", nameType, nameObject), ctx);

#if UNITY_EDITOR
			// if this is part of a prefab instance, then we need to first handle version changes in underlying prefab
			var isPrefabInstance = UnityEditor.PrefabUtility.IsPartOfPrefabInstance(ctx);
			if (isPrefabInstance)
			{
				// handle version changes in underlying prefab
				Debug.Log(string.Format("{0} ({1}): migrating underlying prefab...", nameType, nameObject), ctx);

				PrefabContentsUtility.UpdateUnderlyingPrefabContents(ctx, verbose: true, (GameObject prefabContentsRoot) =>
				{
					foreach (var prefabVersionedDataContext in prefabContentsRoot.GetComponentsInChildren<T>(includeInactive: true))
					{
						HandleVersionChange(prefabVersionedDataContext);
					}
				});

				// ensure that own version is not inherited from prefab
				var serializedObject = new UnityEditor.SerializedObject(ctx);
				{
					serializedObject.FindProperty(versionPropertyPath).intValue = versionIni;
					serializedObject.ApplyModifiedPropertiesWithoutUndo();
				}
			}
#endif

			// handle version changes
			while (ctx.version < ctx.VERSION)
			{
				Debug.Log(string.Format("{0} ({1}): migrating data from version {2}...", nameType, nameObject, ctx.version), ctx);
				var versionPre = ctx.version;
				{
					ctx.PerformMigrationStep();
				}
				if (versionPre == ctx.version)
				{
					Debug.LogError(string.Format("{0} ({1}): failed to migrate data from version {2} -> {3} (remains at version {2})", nameType, nameObject, ctx.version, ctx.VERSION), ctx);
					break;
				}
			}
			
			if (versionIni < ctx.version)
			{
#if UNITY_EDITOR
				UnityEditor.EditorUtility.SetDirty(ctx);
				UnityEditor.PrefabUtility.RecordPrefabInstancePropertyModifications(ctx);
#endif
				if (ctx.version == ctx.VERSION)
				{
					Debug.Log(string.Format("{0} ({1}): completed migration (now at version {2})", nameType, nameObject, ctx.version), ctx);
				}
			}
		}
	}
}

```

`Runtime/Utility/VersionedData.cs.meta`:

```meta
fileFormatVersion: 2
guid: c579a1ecf8107384fb681f638cf87f22
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample.meta`:

```meta
fileFormatVersion: 2
guid: d91dfc102125b614787a462d0464241e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/HairSample.asmdef`:

```asmdef
{
    "name": "HairSim_Demo",
    "rootNamespace": "",
    "references": [
        "GUID:f9dedde5eec30c2468e14d8a7b14626e"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": true,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": false,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}
```

`Samples~/HairSample/HairSample.asmdef.meta`:

```meta
fileFormatVersion: 2
guid: ab711d20616f81447bfddeeaa3bcb198
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Materials.meta`:

```meta
fileFormatVersion: 2
guid: c93f99a8ac923a04cb4fe666226b7ab1
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Materials/Builtin_Ground.mat`:

```mat
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!21 &2100000
Material:
  serializedVersion: 6
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_Name: Builtin_Ground
  m_Shader: {fileID: 46, guid: 0000000000000000f000000000000000, type: 0}
  m_ShaderKeywords: _DISABLE_SSR_TRANSPARENT _NORMALMAP_TANGENT_SPACE
  m_LightmapFlags: 4
  m_EnableInstancingVariants: 0
  m_DoubleSidedGI: 0
  m_CustomRenderQueue: -1
  stringTagMap: {}
  disabledShaderPasses:
  - DistortionVectors
  - MOTIONVECTORS
  - TransparentDepthPrepass
  - TransparentDepthPostpass
  - TransparentBackface
  - RayTracingPrepass
  m_SavedProperties:
    serializedVersion: 3
    m_TexEnvs:
    - _AnisotropyMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _BaseColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _BentNormalMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _BentNormalMapOS:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _BumpMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _CoatMaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DetailAlbedoMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DetailMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DetailMask:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DetailNormalMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DistortionVectorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _EmissionMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _EmissiveColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _HeightMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _IridescenceMaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _IridescenceThicknessMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _MainTex:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _MaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _MetallicGlossMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _NormalMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _NormalMapOS:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _OcclusionMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _ParallaxMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _SpecularColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _SubsurfaceMaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _TangentMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _TangentMapOS:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _ThicknessMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _TransmittanceColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - unity_Lightmaps:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - unity_LightmapsInd:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - unity_ShadowMasks:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    m_Floats:
    - _AORemapMax: 1
    - _AORemapMin: 0
    - _ATDistance: 1
    - _AddPrecomputedVelocity: 0
    - _AlbedoAffectEmissive: 0
    - _AlphaCutoff: 0.5
    - _AlphaCutoffEnable: 0
    - _AlphaCutoffPostpass: 0.5
    - _AlphaCutoffPrepass: 0.5
    - _AlphaCutoffShadow: 0.5
    - _AlphaDstBlend: 0
    - _AlphaSrcBlend: 1
    - _AlphaToMask: 0
    - _AlphaToMaskInspectorValue: 0
    - _Anisotropy: 0
    - _BlendMode: 0
    - _BumpScale: 1
    - _CoatMask: 0
    - _CullMode: 2
    - _CullModeForward: 2
    - _Cutoff: 0.5
    - _DepthOffsetEnable: 0
    - _DetailAlbedoScale: 1
    - _DetailNormalMapScale: 1
    - _DetailNormalScale: 1
    - _DetailSmoothnessScale: 1
    - _DiffusionProfile: 0
    - _DiffusionProfileHash: 0
    - _DisplacementLockObjectScale: 1
    - _DisplacementLockTilingScale: 1
    - _DisplacementMode: 0
    - _DistortionBlendMode: 0
    - _DistortionBlurBlendMode: 0
    - _DistortionBlurDstBlend: 1
    - _DistortionBlurRemapMax: 1
    - _DistortionBlurRemapMin: 0
    - _DistortionBlurScale: 1
    - _DistortionBlurSrcBlend: 1
    - _DistortionDepthTest: 1
    - _DistortionDstBlend: 1
    - _DistortionEnable: 0
    - _DistortionScale: 1
    - _DistortionSrcBlend: 1
    - _DistortionVectorBias: -1
    - _DistortionVectorScale: 2
    - _DoubleSidedEnable: 0
    - _DoubleSidedNormalMode: 1
    - _DstBlend: 0
    - _EmissiveColorMode: 1
    - _EmissiveExposureWeight: 1
    - _EmissiveIntensity: 1
    - _EmissiveIntensityUnit: 0
    - _EnableBlendModePreserveSpecularLighting: 1
    - _EnableFogOnTransparent: 1
    - _EnableGeometricSpecularAA: 0
    - _EnergyConservingSpecularColor: 1
    - _GlossMapScale: 1
    - _Glossiness: 0
    - _GlossyReflections: 1
    - _HeightAmplitude: 0.02
    - _HeightCenter: 0.5
    - _HeightMapParametrization: 0
    - _HeightMax: 1
    - _HeightMin: -1
    - _HeightOffset: 0
    - _HeightPoMAmplitude: 2
    - _HeightTessAmplitude: 2
    - _HeightTessCenter: 0.5
    - _InvTilingScale: 1
    - _Ior: 1.5
    - _IridescenceMask: 1
    - _IridescenceThickness: 1
    - _LinkDetailsWithBase: 1
    - _MaterialID: 1
    - _Metallic: 0
    - _MetallicRemapMax: 0
    - _MetallicRemapMin: 0
    - _Mode: 0
    - _NormalMapSpace: 0
    - _NormalScale: 1
    - _OcclusionStrength: 1
    - _OpaqueCullMode: 2
    - _PPDLodThreshold: 5
    - _PPDMaxSamples: 15
    - _PPDMinSamples: 5
    - _PPDPrimitiveLength: 1
    - _PPDPrimitiveWidth: 1
    - _Parallax: 0.02
    - _RayTracing: 0
    - _ReceivesSSR: 1
    - _ReceivesSSRTransparent: 0
    - _RefractionModel: 0
    - _SSRefractionProjectionModel: 0
    - _Smoothness: 0
    - _SmoothnessRemapMax: 1
    - _SmoothnessRemapMin: 0
    - _SmoothnessTextureChannel: 0
    - _SpecularAAScreenSpaceVariance: 0.1
    - _SpecularAAThreshold: 0.2
    - _SpecularHighlights: 1
    - _SpecularOcclusionMode: 1
    - _SrcBlend: 1
    - _StencilRef: 0
    - _StencilRefDepth: 8
    - _StencilRefDistortionVec: 4
    - _StencilRefGBuffer: 10
    - _StencilRefMV: 40
    - _StencilWriteMask: 6
    - _StencilWriteMaskDepth: 8
    - _StencilWriteMaskDistortionVec: 4
    - _StencilWriteMaskGBuffer: 14
    - _StencilWriteMaskMV: 40
    - _SubsurfaceMask: 1
    - _SupportDecals: 1
    - _SurfaceType: 0
    - _TexWorldScale: 1
    - _TexWorldScaleEmissive: 1
    - _Thickness: 1
    - _TransmissionEnable: 1
    - _TransparentBackfaceEnable: 0
    - _TransparentCullMode: 2
    - _TransparentDepthPostpassEnable: 0
    - _TransparentDepthPrepassEnable: 0
    - _TransparentSortPriority: 0
    - _TransparentWritingMotionVec: 0
    - _TransparentZWrite: 0
    - _UVBase: 0
    - _UVDetail: 0
    - _UVEmissive: 0
    - _UVSec: 0
    - _UseEmissiveIntensity: 0
    - _UseShadowThreshold: 0
    - _ZTestDepthEqualForOpaque: 3
    - _ZTestGBuffer: 4
    - _ZTestModeDistortion: 4
    - _ZTestTransparent: 4
    - _ZWrite: 1
    m_Colors:
    - _BaseColor: {r: 0.30630082, g: 0.398, b: 0.16875201, a: 1}
    - _BaseColorMap_MipInfo: {r: 0, g: 0, b: 0, a: 0}
    - _Color: {r: 0.3063008, g: 0.39799997, b: 0.16875198, a: 1}
    - _DiffusionProfileAsset: {r: 0, g: 0, b: 0, a: 0}
    - _DoubleSidedConstants: {r: 1, g: 1, b: -1, a: 0}
    - _EmissionColor: {r: 1, g: 1, b: 1, a: 1}
    - _EmissiveColor: {r: 0, g: 0, b: 0, a: 1}
    - _EmissiveColorLDR: {r: 0, g: 0, b: 0, a: 1}
    - _InvPrimScale: {r: 1, g: 1, b: 0, a: 0}
    - _IridescenceThicknessRemap: {r: 0, g: 1, b: 0, a: 0}
    - _SpecularColor: {r: 1, g: 1, b: 1, a: 1}
    - _ThicknessRemap: {r: 0, g: 1, b: 0, a: 0}
    - _TransmittanceColor: {r: 1, g: 1, b: 1, a: 1}
    - _UVDetailsMappingMask: {r: 1, g: 0, b: 0, a: 0}
    - _UVMappingMask: {r: 1, g: 0, b: 0, a: 0}
    - _UVMappingMaskEmissive: {r: 1, g: 0, b: 0, a: 0}
  m_BuildTextureStacks: []
--- !u!114 &9130460386438202954
MonoBehaviour:
  m_ObjectHideFlags: 11
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: da692e001514ec24dbc4cca1949ff7e8, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  version: 11

```

`Samples~/HairSample/Materials/Builtin_Ground.mat.meta`:

```meta
fileFormatVersion: 2
guid: 5f10f40e8eb71c245bd03eb8fef69a59
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Materials/Builtin_Primitive.mat`:

```mat
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!21 &2100000
Material:
  serializedVersion: 6
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_Name: Builtin_Primitive
  m_Shader: {fileID: 46, guid: 0000000000000000f000000000000000, type: 0}
  m_ShaderKeywords: _DISABLE_SSR_TRANSPARENT _NORMALMAP_TANGENT_SPACE
  m_LightmapFlags: 4
  m_EnableInstancingVariants: 0
  m_DoubleSidedGI: 0
  m_CustomRenderQueue: -1
  stringTagMap: {}
  disabledShaderPasses:
  - DistortionVectors
  - MOTIONVECTORS
  - TransparentDepthPrepass
  - TransparentDepthPostpass
  - TransparentBackface
  - RayTracingPrepass
  m_SavedProperties:
    serializedVersion: 3
    m_TexEnvs:
    - _AnisotropyMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _BaseColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _BentNormalMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _BentNormalMapOS:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _BumpMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _CoatMaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DetailAlbedoMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DetailMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DetailMask:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DetailNormalMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DistortionVectorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _EmissionMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _EmissiveColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _HeightMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _IridescenceMaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _IridescenceThicknessMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _MainTex:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _MaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _MetallicGlossMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _NormalMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _NormalMapOS:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _OcclusionMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _ParallaxMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _SpecularColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _SubsurfaceMaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _TangentMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _TangentMapOS:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _ThicknessMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _TransmittanceColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - unity_Lightmaps:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - unity_LightmapsInd:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - unity_ShadowMasks:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    m_Floats:
    - _AORemapMax: 1
    - _AORemapMin: 0
    - _ATDistance: 1
    - _AddPrecomputedVelocity: 0
    - _AlbedoAffectEmissive: 0
    - _AlphaCutoff: 0.5
    - _AlphaCutoffEnable: 0
    - _AlphaCutoffPostpass: 0.5
    - _AlphaCutoffPrepass: 0.5
    - _AlphaCutoffShadow: 0.5
    - _AlphaDstBlend: 0
    - _AlphaSrcBlend: 1
    - _AlphaToMask: 0
    - _AlphaToMaskInspectorValue: 0
    - _Anisotropy: 0
    - _BlendMode: 0
    - _BumpScale: 1
    - _CoatMask: 0
    - _CullMode: 2
    - _CullModeForward: 2
    - _Cutoff: 0.5
    - _DepthOffsetEnable: 0
    - _DetailAlbedoScale: 1
    - _DetailNormalMapScale: 1
    - _DetailNormalScale: 1
    - _DetailSmoothnessScale: 1
    - _DiffusionProfile: 0
    - _DiffusionProfileHash: 0
    - _DisplacementLockObjectScale: 1
    - _DisplacementLockTilingScale: 1
    - _DisplacementMode: 0
    - _DistortionBlendMode: 0
    - _DistortionBlurBlendMode: 0
    - _DistortionBlurDstBlend: 1
    - _DistortionBlurRemapMax: 1
    - _DistortionBlurRemapMin: 0
    - _DistortionBlurScale: 1
    - _DistortionBlurSrcBlend: 1
    - _DistortionDepthTest: 1
    - _DistortionDstBlend: 1
    - _DistortionEnable: 0
    - _DistortionScale: 1
    - _DistortionSrcBlend: 1
    - _DistortionVectorBias: -1
    - _DistortionVectorScale: 2
    - _DoubleSidedEnable: 0
    - _DoubleSidedNormalMode: 1
    - _DstBlend: 0
    - _EmissiveColorMode: 1
    - _EmissiveExposureWeight: 1
    - _EmissiveIntensity: 1
    - _EmissiveIntensityUnit: 0
    - _EnableBlendModePreserveSpecularLighting: 1
    - _EnableFogOnTransparent: 1
    - _EnableGeometricSpecularAA: 0
    - _EnergyConservingSpecularColor: 1
    - _GlossMapScale: 1
    - _Glossiness: 0.7
    - _GlossyReflections: 1
    - _HeightAmplitude: 0.02
    - _HeightCenter: 0.5
    - _HeightMapParametrization: 0
    - _HeightMax: 1
    - _HeightMin: -1
    - _HeightOffset: 0
    - _HeightPoMAmplitude: 2
    - _HeightTessAmplitude: 2
    - _HeightTessCenter: 0.5
    - _InvTilingScale: 1
    - _Ior: 1.5
    - _IridescenceMask: 1
    - _IridescenceThickness: 1
    - _LinkDetailsWithBase: 1
    - _MaterialID: 1
    - _Metallic: 0
    - _MetallicRemapMax: 0
    - _MetallicRemapMin: 0
    - _Mode: 0
    - _NormalMapSpace: 0
    - _NormalScale: 1
    - _OcclusionStrength: 1
    - _OpaqueCullMode: 2
    - _PPDLodThreshold: 5
    - _PPDMaxSamples: 15
    - _PPDMinSamples: 5
    - _PPDPrimitiveLength: 1
    - _PPDPrimitiveWidth: 1
    - _Parallax: 0.02
    - _RayTracing: 0
    - _ReceivesSSR: 1
    - _ReceivesSSRTransparent: 0
    - _RefractionModel: 0
    - _SSRefractionProjectionModel: 0
    - _Smoothness: 0.7
    - _SmoothnessRemapMax: 1
    - _SmoothnessRemapMin: 0
    - _SmoothnessTextureChannel: 0
    - _SpecularAAScreenSpaceVariance: 0.1
    - _SpecularAAThreshold: 0.2
    - _SpecularHighlights: 1
    - _SpecularOcclusionMode: 1
    - _SrcBlend: 1
    - _StencilRef: 0
    - _StencilRefDepth: 8
    - _StencilRefDistortionVec: 4
    - _StencilRefGBuffer: 10
    - _StencilRefMV: 40
    - _StencilWriteMask: 6
    - _StencilWriteMaskDepth: 8
    - _StencilWriteMaskDistortionVec: 4
    - _StencilWriteMaskGBuffer: 14
    - _StencilWriteMaskMV: 40
    - _SubsurfaceMask: 1
    - _SupportDecals: 1
    - _SurfaceType: 0
    - _TexWorldScale: 1
    - _TexWorldScaleEmissive: 1
    - _Thickness: 1
    - _TransmissionEnable: 1
    - _TransparentBackfaceEnable: 0
    - _TransparentCullMode: 2
    - _TransparentDepthPostpassEnable: 0
    - _TransparentDepthPrepassEnable: 0
    - _TransparentSortPriority: 0
    - _TransparentWritingMotionVec: 0
    - _TransparentZWrite: 0
    - _UVBase: 0
    - _UVDetail: 0
    - _UVEmissive: 0
    - _UVSec: 0
    - _UseEmissiveIntensity: 0
    - _UseShadowThreshold: 0
    - _ZTestDepthEqualForOpaque: 3
    - _ZTestGBuffer: 4
    - _ZTestModeDistortion: 4
    - _ZTestTransparent: 4
    - _ZWrite: 1
    m_Colors:
    - _BaseColor: {r: 0.7294118, g: 0.7294118, b: 0.7294118, a: 1}
    - _BaseColorMap_MipInfo: {r: 0, g: 0, b: 0, a: 0}
    - _Color: {r: 0.7294118, g: 0.7294118, b: 0.7294118, a: 1}
    - _DiffusionProfileAsset: {r: 0, g: 0, b: 0, a: 0}
    - _DoubleSidedConstants: {r: 1, g: 1, b: -1, a: 0}
    - _EmissionColor: {r: 1, g: 1, b: 1, a: 1}
    - _EmissiveColor: {r: 0, g: 0, b: 0, a: 1}
    - _EmissiveColorLDR: {r: 0, g: 0, b: 0, a: 1}
    - _InvPrimScale: {r: 1, g: 1, b: 0, a: 0}
    - _IridescenceThicknessRemap: {r: 0, g: 1, b: 0, a: 0}
    - _SpecularColor: {r: 1, g: 1, b: 1, a: 1}
    - _ThicknessRemap: {r: 0, g: 1, b: 0, a: 0}
    - _TransmittanceColor: {r: 1, g: 1, b: 1, a: 1}
    - _UVDetailsMappingMask: {r: 1, g: 0, b: 0, a: 0}
    - _UVMappingMask: {r: 1, g: 0, b: 0, a: 0}
    - _UVMappingMaskEmissive: {r: 1, g: 0, b: 0, a: 0}
  m_BuildTextureStacks: []
--- !u!114 &9130460386438202954
MonoBehaviour:
  m_ObjectHideFlags: 11
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: da692e001514ec24dbc4cca1949ff7e8, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  version: 11

```

`Samples~/HairSample/Materials/Builtin_Primitive.mat.meta`:

```meta
fileFormatVersion: 2
guid: a1352989639bd544494540446871c1cb
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Materials/Builtin_Skybox.mat`:

```mat
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!21 &2100000
Material:
  serializedVersion: 6
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_Name: Builtin_Skybox
  m_Shader: {fileID: 106, guid: 0000000000000000f000000000000000, type: 0}
  m_ShaderKeywords: _SUNDISK_HIGH_QUALITY
  m_LightmapFlags: 4
  m_EnableInstancingVariants: 0
  m_DoubleSidedGI: 0
  m_CustomRenderQueue: -1
  stringTagMap: {}
  disabledShaderPasses: []
  m_SavedProperties:
    serializedVersion: 3
    m_TexEnvs:
    - _BumpMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DetailAlbedoMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DetailMask:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DetailNormalMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _EmissionMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _MainTex:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _MetallicGlossMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _OcclusionMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _ParallaxMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    m_Floats:
    - _AtmosphereThickness: 1.5
    - _BumpScale: 1
    - _Cutoff: 0.5
    - _DetailNormalMapScale: 1
    - _DstBlend: 0
    - _Exposure: 1
    - _GlossMapScale: 1
    - _Glossiness: 0.5
    - _GlossyReflections: 1
    - _Metallic: 0
    - _Mode: 0
    - _OcclusionStrength: 1
    - _Parallax: 0.02
    - _SmoothnessTextureChannel: 0
    - _SpecularHighlights: 1
    - _SrcBlend: 1
    - _SunDisk: 2
    - _SunSize: 0.04
    - _SunSizeConvergence: 5
    - _UVSec: 0
    - _ZWrite: 1
    m_Colors:
    - _Color: {r: 1, g: 1, b: 1, a: 1}
    - _EmissionColor: {r: 0, g: 0, b: 0, a: 1}
    - _GroundColor: {r: 0.30588236, g: 0.39607844, b: 0.16862746, a: 1}
    - _SkyTint: {r: 0.5, g: 0.5, b: 0.5, a: 1}
  m_BuildTextureStacks: []

```

`Samples~/HairSample/Materials/Builtin_Skybox.mat.meta`:

```meta
fileFormatVersion: 2
guid: 37565627c08575c4bb329ed5a68bc511
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 2100000
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Materials/SRP.shadergraph`:

```shadergraph
{
    "m_SGVersion": 2,
    "m_Type": "UnityEditor.ShaderGraph.GraphData",
    "m_ObjectId": "5dfdb52a778148bebc3201bf6661322f",
    "m_Properties": [
        {
            "m_Id": "020ef9a5ab8249da91e6a350af13f799"
        },
        {
            "m_Id": "aa16d99ab74643eda4ab5ea1fd910540"
        }
    ],
    "m_Keywords": [],
    "m_Nodes": [
        {
            "m_Id": "0e474581ce6c4fd6aa38575c72bb86d9"
        },
        {
            "m_Id": "eafe93a313204fba8720be9041a065c3"
        },
        {
            "m_Id": "e40beb117bd14646b807caa22c23763f"
        },
        {
            "m_Id": "ed0fbe6fb3954951bb9bd559e8289ca6"
        },
        {
            "m_Id": "f46aed48454644c38f0ba8e4f7915611"
        },
        {
            "m_Id": "36feb72ce02f40ffb73d760fc5622ac2"
        },
        {
            "m_Id": "063b017d135347779bb0ddd969c013cb"
        },
        {
            "m_Id": "153802ea8dae4a1ab36c800c9c71d697"
        },
        {
            "m_Id": "f06f839d6bee4f969fcf3dca70547347"
        },
        {
            "m_Id": "8acef2822002471384218a2baad83cc4"
        },
        {
            "m_Id": "13834940301a4191b944bdf382dc2235"
        },
        {
            "m_Id": "f4321a6a78f04cdb93f6d68bf7e81add"
        },
        {
            "m_Id": "e845b019c60c4ab6a0da523869480305"
        }
    ],
    "m_GroupDatas": [],
    "m_StickyNoteDatas": [],
    "m_Edges": [
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "e845b019c60c4ab6a0da523869480305"
                },
                "m_SlotId": 0
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "f06f839d6bee4f969fcf3dca70547347"
                },
                "m_SlotId": 0
            }
        },
        {
            "m_OutputSlot": {
                "m_Node": {
                    "m_Id": "f4321a6a78f04cdb93f6d68bf7e81add"
                },
                "m_SlotId": 0
            },
            "m_InputSlot": {
                "m_Node": {
                    "m_Id": "ed0fbe6fb3954951bb9bd559e8289ca6"
                },
                "m_SlotId": 0
            }
        }
    ],
    "m_VertexContext": {
        "m_Position": {
            "x": 0.0,
            "y": 0.0
        },
        "m_Blocks": [
            {
                "m_Id": "0e474581ce6c4fd6aa38575c72bb86d9"
            },
            {
                "m_Id": "eafe93a313204fba8720be9041a065c3"
            },
            {
                "m_Id": "e40beb117bd14646b807caa22c23763f"
            }
        ]
    },
    "m_FragmentContext": {
        "m_Position": {
            "x": 0.0,
            "y": 200.0
        },
        "m_Blocks": [
            {
                "m_Id": "ed0fbe6fb3954951bb9bd559e8289ca6"
            },
            {
                "m_Id": "f46aed48454644c38f0ba8e4f7915611"
            },
            {
                "m_Id": "36feb72ce02f40ffb73d760fc5622ac2"
            },
            {
                "m_Id": "063b017d135347779bb0ddd969c013cb"
            },
            {
                "m_Id": "153802ea8dae4a1ab36c800c9c71d697"
            },
            {
                "m_Id": "f06f839d6bee4f969fcf3dca70547347"
            },
            {
                "m_Id": "8acef2822002471384218a2baad83cc4"
            },
            {
                "m_Id": "13834940301a4191b944bdf382dc2235"
            }
        ]
    },
    "m_PreviewData": {
        "serializedMesh": {
            "m_SerializedMesh": "{\"mesh\":{\"instanceID\":0}}",
            "m_Guid": ""
        }
    },
    "m_Path": "Hair/Sample",
    "m_ConcretePrecision": 0,
    "m_OutputNode": {
        "m_Id": ""
    },
    "m_ActiveTargets": [
        {
            "m_Id": "01df2fe314cd49938c6441ece4f38062"
        },
        {
            "m_Id": "a1ce8418f11f4d888429f8b6f73e3bdb"
        }
    ]
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.Rendering.HighDefinition.ShaderGraph.HDTarget",
    "m_ObjectId": "01df2fe314cd49938c6441ece4f38062",
    "m_ActiveSubTarget": {
        "m_Id": "0a30e75e259d452b83ae0b2377281b67"
    },
    "m_Datas": [
        {
            "m_Id": "3a1c0e4d8ca244cb86af998b6593c8b2"
        },
        {
            "m_Id": "d2dc71cc3c5147279dfab071fe904085"
        },
        {
            "m_Id": "c06f61e1ad7e43c4940f8eb74de937e1"
        },
        {
            "m_Id": "43677809aa144bc7b4c1e2400a46ddf0"
        }
    ],
    "m_CustomEditorGUI": ""
}

{
    "m_SGVersion": 3,
    "m_Type": "UnityEditor.ShaderGraph.Internal.ColorShaderProperty",
    "m_ObjectId": "020ef9a5ab8249da91e6a350af13f799",
    "m_Guid": {
        "m_GuidSerialized": "72e72e3f-551e-4a81-b1b1-05b03a2ccd67"
    },
    "m_Name": "Base Color",
    "m_DefaultReferenceName": "Color_020ef9a5ab8249da91e6a350af13f799",
    "m_OverrideReferenceName": "",
    "m_GeneratePropertyBlock": true,
    "m_Precision": 0,
    "overrideHLSLDeclaration": false,
    "hlslDeclarationOverride": 0,
    "m_Hidden": false,
    "m_Value": {
        "r": 0.0,
        "g": 0.0,
        "b": 0.0,
        "a": 0.0
    },
    "m_ColorMode": 0
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "063b017d135347779bb0ddd969c013cb",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.Metallic",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "ed105f8eeada464cafb3f3cf72900d6e"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.Metallic"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.Rendering.HighDefinition.ShaderGraph.HDLitSubTarget",
    "m_ObjectId": "0a30e75e259d452b83ae0b2377281b67"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "0e474581ce6c4fd6aa38575c72bb86d9",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "VertexDescription.Position",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "b0853263598f4850ba3541881598a109"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "VertexDescription.Position"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.NormalMaterialSlot",
    "m_ObjectId": "12be132d54d342028d93ea10be02146c",
    "m_Id": 0,
    "m_DisplayName": "Normal (Tangent Space)",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "NormalTS",
    "m_StageCapability": 2,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": [],
    "m_Space": 3
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "13834940301a4191b944bdf382dc2235",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.Alpha",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "517f2c7f77bf4baf93d25da10f0e2177"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.Alpha"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "153802ea8dae4a1ab36c800c9c71d697",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.Emission",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "1bc6afb244b14afd8d584bd2797b25ab"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.Emission"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.ColorRGBMaterialSlot",
    "m_ObjectId": "1bc6afb244b14afd8d584bd2797b25ab",
    "m_Id": 0,
    "m_DisplayName": "Emission",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Emission",
    "m_StageCapability": 2,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": [],
    "m_ColorMode": 1,
    "m_DefaultColor": {
        "r": 0.0,
        "g": 0.0,
        "b": 0.0,
        "a": 1.0
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "36feb72ce02f40ffb73d760fc5622ac2",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.BentNormal",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "920696ab3475460d86d19e5457f798c4"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.BentNormal"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.Rendering.HighDefinition.ShaderGraph.HDLitData",
    "m_ObjectId": "3a1c0e4d8ca244cb86af998b6593c8b2",
    "m_RayTracing": false,
    "m_MaterialType": 0,
    "m_RefractionModel": 0,
    "m_SSSTransmission": true,
    "m_EnergyConservingSpecular": true,
    "m_ClearCoat": false
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.Rendering.HighDefinition.ShaderGraph.SystemData",
    "m_ObjectId": "43677809aa144bc7b4c1e2400a46ddf0",
    "m_MaterialNeedsUpdateHash": 529,
    "m_SurfaceType": 0,
    "m_RenderingPass": 1,
    "m_BlendMode": 0,
    "m_ZTest": 4,
    "m_ZWrite": false,
    "m_TransparentCullMode": 2,
    "m_OpaqueCullMode": 2,
    "m_SortPriority": 0,
    "m_AlphaTest": false,
    "m_TransparentDepthPrepass": false,
    "m_TransparentDepthPostpass": false,
    "m_SupportLodCrossFade": false,
    "m_DoubleSidedMode": 0,
    "m_DOTSInstancing": false,
    "m_Version": 0,
    "m_FirstTimeMigrationExecuted": true,
    "inspectorFoldoutMask": 0
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "4b33445bdaff470fb696457183f6ba1b",
    "m_Id": 0,
    "m_DisplayName": "Smoothness",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Smoothness",
    "m_StageCapability": 2,
    "m_Value": 0.5,
    "m_DefaultValue": 0.5,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "517f2c7f77bf4baf93d25da10f0e2177",
    "m_Id": 0,
    "m_DisplayName": "Alpha",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Alpha",
    "m_StageCapability": 2,
    "m_Value": 1.0,
    "m_DefaultValue": 1.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.Rendering.Universal.ShaderGraph.UniversalLitSubTarget",
    "m_ObjectId": "614b3d7f13e94a6d96057b3f71c65d25",
    "m_WorkflowMode": 1,
    "m_NormalDropOffSpace": 0,
    "m_ClearCoat": false
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.NormalMaterialSlot",
    "m_ObjectId": "69215a4b78c9431790f8852f44a32b7f",
    "m_Id": 0,
    "m_DisplayName": "Normal",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Normal",
    "m_StageCapability": 1,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": [],
    "m_Space": 0
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.TangentMaterialSlot",
    "m_ObjectId": "6a0b4538d5b84f0aacb3b25031d49100",
    "m_Id": 0,
    "m_DisplayName": "Tangent",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Tangent",
    "m_StageCapability": 1,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": [],
    "m_Space": 0
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "8acef2822002471384218a2baad83cc4",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.Occlusion",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "c9754b02351a4643a32cf9f934f82c2c"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.Occlusion"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector4MaterialSlot",
    "m_ObjectId": "8b5db72ebe4f4c60bbbe901dcd812612",
    "m_Id": 0,
    "m_DisplayName": "Base Color",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "Out",
    "m_StageCapability": 3,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0,
        "w": 0.0
    },
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.NormalMaterialSlot",
    "m_ObjectId": "920696ab3475460d86d19e5457f798c4",
    "m_Id": 0,
    "m_DisplayName": "Bent Normal",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "BentNormal",
    "m_StageCapability": 2,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": [],
    "m_Space": 3
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.Rendering.Universal.ShaderGraph.UniversalTarget",
    "m_ObjectId": "a1ce8418f11f4d888429f8b6f73e3bdb",
    "m_ActiveSubTarget": {
        "m_Id": "614b3d7f13e94a6d96057b3f71c65d25"
    },
    "m_SurfaceType": 0,
    "m_AlphaMode": 0,
    "m_TwoSided": false,
    "m_AlphaClip": false,
    "m_CustomEditorGUI": ""
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.PositionMaterialSlot",
    "m_ObjectId": "b0853263598f4850ba3541881598a109",
    "m_Id": 0,
    "m_DisplayName": "Position",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Position",
    "m_StageCapability": 1,
    "m_Value": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": [],
    "m_Space": 0
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.ColorRGBMaterialSlot",
    "m_ObjectId": "b99b54bd2b664241a66b50507f0d9641",
    "m_Id": 0,
    "m_DisplayName": "Base Color",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "BaseColor",
    "m_StageCapability": 2,
    "m_Value": {
        "x": 0.5,
        "y": 0.5,
        "z": 0.5
    },
    "m_DefaultValue": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
    },
    "m_Labels": [],
    "m_ColorMode": 0,
    "m_DefaultColor": {
        "r": 0.5,
        "g": 0.5,
        "b": 0.5,
        "a": 1.0
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "bd2b3f521cce40308e2c59167fb0ee0c",
    "m_Id": 0,
    "m_DisplayName": "Smoothness",
    "m_SlotType": 1,
    "m_Hidden": false,
    "m_ShaderOutputName": "Out",
    "m_StageCapability": 3,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.Rendering.HighDefinition.ShaderGraph.LightingData",
    "m_ObjectId": "c06f61e1ad7e43c4940f8eb74de937e1",
    "m_NormalDropOffSpace": 0,
    "m_BlendPreserveSpecular": true,
    "m_ReceiveDecals": true,
    "m_ReceiveSSR": true,
    "m_ReceiveSSRTransparent": false,
    "m_SpecularAA": false,
    "m_SpecularOcclusionMode": 0,
    "m_OverrideBakedGI": false
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "c9754b02351a4643a32cf9f934f82c2c",
    "m_Id": 0,
    "m_DisplayName": "Ambient Occlusion",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Occlusion",
    "m_StageCapability": 2,
    "m_Value": 1.0,
    "m_DefaultValue": 1.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.Rendering.HighDefinition.ShaderGraph.BuiltinData",
    "m_ObjectId": "d2dc71cc3c5147279dfab071fe904085",
    "m_Distortion": false,
    "m_DistortionMode": 0,
    "m_DistortionDepthTest": true,
    "m_AddPrecomputedVelocity": false,
    "m_TransparentWritesMotionVec": false,
    "m_AlphaToMask": false,
    "m_DepthOffset": false,
    "m_TransparencyFog": true,
    "m_AlphaTestShadow": false,
    "m_BackThenFrontRendering": false,
    "m_TransparentDepthPrepass": false,
    "m_TransparentDepthPostpass": false,
    "m_SupportLodCrossFade": false
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "e40beb117bd14646b807caa22c23763f",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "VertexDescription.Tangent",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "6a0b4538d5b84f0aacb3b25031d49100"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "VertexDescription.Tangent"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.PropertyNode",
    "m_ObjectId": "e845b019c60c4ab6a0da523869480305",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Property",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -280.0,
            "y": 444.0,
            "width": 142.0,
            "height": 34.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "bd2b3f521cce40308e2c59167fb0ee0c"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_Property": {
        "m_Id": "aa16d99ab74643eda4ab5ea1fd910540"
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "eafe93a313204fba8720be9041a065c3",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "VertexDescription.Normal",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "69215a4b78c9431790f8852f44a32b7f"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "VertexDescription.Normal"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "ed0fbe6fb3954951bb9bd559e8289ca6",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.BaseColor",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "b99b54bd2b664241a66b50507f0d9641"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.BaseColor"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.Vector1MaterialSlot",
    "m_ObjectId": "ed105f8eeada464cafb3f3cf72900d6e",
    "m_Id": 0,
    "m_DisplayName": "Metallic",
    "m_SlotType": 0,
    "m_Hidden": false,
    "m_ShaderOutputName": "Metallic",
    "m_StageCapability": 2,
    "m_Value": 0.0,
    "m_DefaultValue": 0.0,
    "m_Labels": []
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "f06f839d6bee4f969fcf3dca70547347",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.Smoothness",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "4b33445bdaff470fb696457183f6ba1b"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.Smoothness"
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.PropertyNode",
    "m_ObjectId": "f4321a6a78f04cdb93f6d68bf7e81add",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "Property",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": -280.0,
            "y": 239.0,
            "width": 135.0,
            "height": 34.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "8b5db72ebe4f4c60bbbe901dcd812612"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_Property": {
        "m_Id": "020ef9a5ab8249da91e6a350af13f799"
    }
}

{
    "m_SGVersion": 0,
    "m_Type": "UnityEditor.ShaderGraph.BlockNode",
    "m_ObjectId": "f46aed48454644c38f0ba8e4f7915611",
    "m_Group": {
        "m_Id": ""
    },
    "m_Name": "SurfaceDescription.NormalTS",
    "m_DrawState": {
        "m_Expanded": true,
        "m_Position": {
            "serializedVersion": "2",
            "x": 0.0,
            "y": 0.0,
            "width": 0.0,
            "height": 0.0
        }
    },
    "m_Slots": [
        {
            "m_Id": "12be132d54d342028d93ea10be02146c"
        }
    ],
    "synonyms": [],
    "m_Precision": 0,
    "m_PreviewExpanded": true,
    "m_CustomColors": {
        "m_SerializableColors": []
    },
    "m_SerializedDescriptor": "SurfaceDescription.NormalTS"
}

{
    "m_SGVersion": 1,
    "m_Type": "UnityEditor.ShaderGraph.Internal.Vector1ShaderProperty",
    "m_ObjectId": "aa16d99ab74643eda4ab5ea1fd910540",
    "m_Guid": {
        "m_GuidSerialized": "0072637e-5fac-4d4d-bda7-5aa74675c2d3"
    },
    "m_Name": "Smoothness",
    "m_DefaultReferenceName": "Vector1_aa16d99ab74643eda4ab5ea1fd910540",
    "m_OverrideReferenceName": "",
    "m_GeneratePropertyBlock": true,
    "m_Precision": 0,
    "overrideHLSLDeclaration": false,
    "hlslDeclarationOverride": 0,
    "m_Hidden": false,
    "m_Value": 0.0,
    "m_FloatType": 0,
    "m_RangeValues": {
        "x": 0.0,
        "y": 1.0
    }
}


```

`Samples~/HairSample/Materials/SRP.shadergraph.meta`:

```meta
fileFormatVersion: 2
guid: bb6861b6415138943ba63d17865c2455
ScriptedImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 2
  userData: 
  assetBundleName: 
  assetBundleVariant: 
  script: {fileID: 11500000, guid: 625f186215c104763be7675aa2d941aa, type: 3}

```

`Samples~/HairSample/Materials/SRP_Ground.mat`:

```mat
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!21 &2100000
Material:
  serializedVersion: 6
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_Name: SRP_Ground
  m_Shader: {fileID: -6465566751694194690, guid: bb6861b6415138943ba63d17865c2455, type: 3}
  m_ShaderKeywords: _DISABLE_SSR_TRANSPARENT _NORMALMAP_TANGENT_SPACE
  m_LightmapFlags: 4
  m_EnableInstancingVariants: 0
  m_DoubleSidedGI: 0
  m_CustomRenderQueue: -1
  stringTagMap: {}
  disabledShaderPasses:
  - DistortionVectors
  - MOTIONVECTORS
  - TransparentDepthPrepass
  - TransparentDepthPostpass
  - TransparentBackface
  - RayTracingPrepass
  m_SavedProperties:
    serializedVersion: 3
    m_TexEnvs:
    - _AnisotropyMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _BaseColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _BentNormalMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _BentNormalMapOS:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _CoatMaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DetailMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DistortionVectorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _EmissiveColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _HeightMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _IridescenceMaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _IridescenceThicknessMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _MainTex:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _MaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _NormalMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _NormalMapOS:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _SpecularColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _SubsurfaceMaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _TangentMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _TangentMapOS:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _ThicknessMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _TransmittanceColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - unity_Lightmaps:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - unity_LightmapsInd:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - unity_ShadowMasks:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    m_Floats:
    - Vector1_aa16d99ab74643eda4ab5ea1fd910540: 0
    - _AORemapMax: 1
    - _AORemapMin: 0
    - _ATDistance: 1
    - _AddPrecomputedVelocity: 0
    - _AlbedoAffectEmissive: 0
    - _AlphaCutoff: 0.5
    - _AlphaCutoffEnable: 0
    - _AlphaCutoffPostpass: 0.5
    - _AlphaCutoffPrepass: 0.5
    - _AlphaCutoffShadow: 0.5
    - _AlphaDstBlend: 0
    - _AlphaSrcBlend: 1
    - _AlphaToMask: 0
    - _AlphaToMaskInspectorValue: 0
    - _Anisotropy: 0
    - _BlendMode: 0
    - _CoatMask: 0
    - _CullMode: 2
    - _CullModeForward: 2
    - _Cutoff: 0.5
    - _DepthOffsetEnable: 0
    - _DetailAlbedoScale: 1
    - _DetailNormalScale: 1
    - _DetailSmoothnessScale: 1
    - _DiffusionProfile: 0
    - _DiffusionProfileHash: 0
    - _DisplacementLockObjectScale: 1
    - _DisplacementLockTilingScale: 1
    - _DisplacementMode: 0
    - _DistortionBlendMode: 0
    - _DistortionBlurBlendMode: 0
    - _DistortionBlurDstBlend: 1
    - _DistortionBlurRemapMax: 1
    - _DistortionBlurRemapMin: 0
    - _DistortionBlurScale: 1
    - _DistortionBlurSrcBlend: 1
    - _DistortionDepthTest: 1
    - _DistortionDstBlend: 1
    - _DistortionEnable: 0
    - _DistortionScale: 1
    - _DistortionSrcBlend: 1
    - _DistortionVectorBias: -1
    - _DistortionVectorScale: 2
    - _DoubleSidedEnable: 0
    - _DoubleSidedNormalMode: 1
    - _DstBlend: 0
    - _EmissiveColorMode: 1
    - _EmissiveExposureWeight: 1
    - _EmissiveIntensity: 1
    - _EmissiveIntensityUnit: 0
    - _EnableBlendModePreserveSpecularLighting: 1
    - _EnableFogOnTransparent: 1
    - _EnableGeometricSpecularAA: 0
    - _EnergyConservingSpecularColor: 1
    - _HeightAmplitude: 0.02
    - _HeightCenter: 0.5
    - _HeightMapParametrization: 0
    - _HeightMax: 1
    - _HeightMin: -1
    - _HeightOffset: 0
    - _HeightPoMAmplitude: 2
    - _HeightTessAmplitude: 2
    - _HeightTessCenter: 0.5
    - _InvTilingScale: 1
    - _Ior: 1.5
    - _IridescenceMask: 1
    - _IridescenceThickness: 1
    - _LinkDetailsWithBase: 1
    - _MaterialID: 1
    - _Metallic: 0
    - _MetallicRemapMax: 0
    - _MetallicRemapMin: 0
    - _NormalMapSpace: 0
    - _NormalScale: 1
    - _OpaqueCullMode: 2
    - _PPDLodThreshold: 5
    - _PPDMaxSamples: 15
    - _PPDMinSamples: 5
    - _PPDPrimitiveLength: 1
    - _PPDPrimitiveWidth: 1
    - _RayTracing: 0
    - _ReceivesSSR: 1
    - _ReceivesSSRTransparent: 0
    - _RefractionModel: 0
    - _RenderQueueType: 1
    - _RequireSplitLighting: 0
    - _SSRefractionProjectionModel: 0
    - _Smoothness: 0
    - _SmoothnessRemapMax: 1
    - _SmoothnessRemapMin: 0
    - _SpecularAAScreenSpaceVariance: 0.1
    - _SpecularAAThreshold: 0.2
    - _SpecularOcclusionMode: 1
    - _SrcBlend: 1
    - _StencilRef: 0
    - _StencilRefDepth: 8
    - _StencilRefDistortionVec: 4
    - _StencilRefGBuffer: 10
    - _StencilRefMV: 40
    - _StencilWriteMask: 6
    - _StencilWriteMaskDepth: 8
    - _StencilWriteMaskDistortionVec: 4
    - _StencilWriteMaskGBuffer: 14
    - _StencilWriteMaskMV: 40
    - _SubsurfaceMask: 1
    - _SupportDecals: 1
    - _SurfaceType: 0
    - _TexWorldScale: 1
    - _TexWorldScaleEmissive: 1
    - _Thickness: 1
    - _TransmissionEnable: 1
    - _TransparentBackfaceEnable: 0
    - _TransparentCullMode: 2
    - _TransparentDepthPostpassEnable: 0
    - _TransparentDepthPrepassEnable: 0
    - _TransparentSortPriority: 0
    - _TransparentWritingMotionVec: 0
    - _TransparentZWrite: 0
    - _UVBase: 0
    - _UVDetail: 0
    - _UVEmissive: 0
    - _UseEmissiveIntensity: 0
    - _UseShadowThreshold: 0
    - _ZTestDepthEqualForOpaque: 3
    - _ZTestGBuffer: 4
    - _ZTestModeDistortion: 4
    - _ZTestTransparent: 4
    - _ZWrite: 1
    m_Colors:
    - Color_020ef9a5ab8249da91e6a350af13f799: {r: 0.30588236, g: 0.39607844, b: 0.16862746, a: 0}
    - _BaseColor: {r: 0.30630082, g: 0.398, b: 0.16875201, a: 1}
    - _BaseColorMap_MipInfo: {r: 0, g: 0, b: 0, a: 0}
    - _Color: {r: 0.3063008, g: 0.39799997, b: 0.16875198, a: 1}
    - _DiffusionProfileAsset: {r: 0, g: 0, b: 0, a: 0}
    - _DoubleSidedConstants: {r: 1, g: 1, b: -1, a: 0}
    - _EmissionColor: {r: 1, g: 1, b: 1, a: 1}
    - _EmissiveColor: {r: 0, g: 0, b: 0, a: 1}
    - _EmissiveColorLDR: {r: 0, g: 0, b: 0, a: 1}
    - _InvPrimScale: {r: 1, g: 1, b: 0, a: 0}
    - _IridescenceThicknessRemap: {r: 0, g: 1, b: 0, a: 0}
    - _SpecularColor: {r: 1, g: 1, b: 1, a: 1}
    - _ThicknessRemap: {r: 0, g: 1, b: 0, a: 0}
    - _TransmittanceColor: {r: 1, g: 1, b: 1, a: 1}
    - _UVDetailsMappingMask: {r: 1, g: 0, b: 0, a: 0}
    - _UVMappingMask: {r: 1, g: 0, b: 0, a: 0}
    - _UVMappingMaskEmissive: {r: 1, g: 0, b: 0, a: 0}
  m_BuildTextureStacks: []
--- !u!114 &9130460386438202954
MonoBehaviour:
  m_ObjectHideFlags: 11
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: da692e001514ec24dbc4cca1949ff7e8, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  version: 11

```

`Samples~/HairSample/Materials/SRP_Ground.mat.meta`:

```meta
fileFormatVersion: 2
guid: c5bdb101e4dfd2548a15c1a737dc36d7
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Materials/SRP_Primitive.mat`:

```mat
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!21 &2100000
Material:
  serializedVersion: 6
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_Name: SRP_Primitive
  m_Shader: {fileID: -6465566751694194690, guid: bb6861b6415138943ba63d17865c2455, type: 3}
  m_ShaderKeywords: _DISABLE_SSR_TRANSPARENT _NORMALMAP_TANGENT_SPACE
  m_LightmapFlags: 4
  m_EnableInstancingVariants: 0
  m_DoubleSidedGI: 0
  m_CustomRenderQueue: -1
  stringTagMap: {}
  disabledShaderPasses:
  - DistortionVectors
  - MOTIONVECTORS
  - TransparentDepthPrepass
  - TransparentDepthPostpass
  - TransparentBackface
  - RayTracingPrepass
  m_SavedProperties:
    serializedVersion: 3
    m_TexEnvs:
    - _AnisotropyMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _BaseColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _BentNormalMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _BentNormalMapOS:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _CoatMaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DetailMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _DistortionVectorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _EmissiveColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _HeightMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _IridescenceMaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _IridescenceThicknessMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _MainTex:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _MaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _NormalMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _NormalMapOS:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _SpecularColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _SubsurfaceMaskMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _TangentMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _TangentMapOS:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _ThicknessMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _TransmittanceColorMap:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - unity_Lightmaps:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - unity_LightmapsInd:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - unity_ShadowMasks:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    m_Floats:
    - Vector1_aa16d99ab74643eda4ab5ea1fd910540: 0.7
    - _AORemapMax: 1
    - _AORemapMin: 0
    - _ATDistance: 1
    - _AddPrecomputedVelocity: 0
    - _AlbedoAffectEmissive: 0
    - _AlphaCutoff: 0.5
    - _AlphaCutoffEnable: 0
    - _AlphaCutoffPostpass: 0.5
    - _AlphaCutoffPrepass: 0.5
    - _AlphaCutoffShadow: 0.5
    - _AlphaDstBlend: 0
    - _AlphaSrcBlend: 1
    - _AlphaToMask: 0
    - _AlphaToMaskInspectorValue: 0
    - _Anisotropy: 0
    - _BlendMode: 0
    - _CoatMask: 0
    - _CullMode: 2
    - _CullModeForward: 2
    - _Cutoff: 0.5
    - _DepthOffsetEnable: 0
    - _DetailAlbedoScale: 1
    - _DetailNormalScale: 1
    - _DetailSmoothnessScale: 1
    - _DiffusionProfile: 0
    - _DiffusionProfileHash: 0
    - _DisplacementLockObjectScale: 1
    - _DisplacementLockTilingScale: 1
    - _DisplacementMode: 0
    - _DistortionBlendMode: 0
    - _DistortionBlurBlendMode: 0
    - _DistortionBlurDstBlend: 1
    - _DistortionBlurRemapMax: 1
    - _DistortionBlurRemapMin: 0
    - _DistortionBlurScale: 1
    - _DistortionBlurSrcBlend: 1
    - _DistortionDepthTest: 1
    - _DistortionDstBlend: 1
    - _DistortionEnable: 0
    - _DistortionScale: 1
    - _DistortionSrcBlend: 1
    - _DistortionVectorBias: -1
    - _DistortionVectorScale: 2
    - _DoubleSidedEnable: 0
    - _DoubleSidedNormalMode: 1
    - _DstBlend: 0
    - _EmissiveColorMode: 1
    - _EmissiveExposureWeight: 1
    - _EmissiveIntensity: 1
    - _EmissiveIntensityUnit: 0
    - _EnableBlendModePreserveSpecularLighting: 1
    - _EnableFogOnTransparent: 1
    - _EnableGeometricSpecularAA: 0
    - _EnergyConservingSpecularColor: 1
    - _HeightAmplitude: 0.02
    - _HeightCenter: 0.5
    - _HeightMapParametrization: 0
    - _HeightMax: 1
    - _HeightMin: -1
    - _HeightOffset: 0
    - _HeightPoMAmplitude: 2
    - _HeightTessAmplitude: 2
    - _HeightTessCenter: 0.5
    - _InvTilingScale: 1
    - _Ior: 1.5
    - _IridescenceMask: 1
    - _IridescenceThickness: 1
    - _LinkDetailsWithBase: 1
    - _MaterialID: 1
    - _Metallic: 0
    - _MetallicRemapMax: 0
    - _MetallicRemapMin: 0
    - _NormalMapSpace: 0
    - _NormalScale: 1
    - _OpaqueCullMode: 2
    - _PPDLodThreshold: 5
    - _PPDMaxSamples: 15
    - _PPDMinSamples: 5
    - _PPDPrimitiveLength: 1
    - _PPDPrimitiveWidth: 1
    - _RayTracing: 0
    - _ReceivesSSR: 1
    - _ReceivesSSRTransparent: 0
    - _RefractionModel: 0
    - _RenderQueueType: 1
    - _RequireSplitLighting: 0
    - _SSRefractionProjectionModel: 0
    - _Smoothness: 0.7
    - _SmoothnessRemapMax: 1
    - _SmoothnessRemapMin: 0
    - _SpecularAAScreenSpaceVariance: 0.1
    - _SpecularAAThreshold: 0.2
    - _SpecularOcclusionMode: 1
    - _SrcBlend: 1
    - _StencilRef: 0
    - _StencilRefDepth: 8
    - _StencilRefDistortionVec: 4
    - _StencilRefGBuffer: 10
    - _StencilRefMV: 40
    - _StencilWriteMask: 6
    - _StencilWriteMaskDepth: 8
    - _StencilWriteMaskDistortionVec: 4
    - _StencilWriteMaskGBuffer: 14
    - _StencilWriteMaskMV: 40
    - _SubsurfaceMask: 1
    - _SupportDecals: 1
    - _SurfaceType: 0
    - _TexWorldScale: 1
    - _TexWorldScaleEmissive: 1
    - _Thickness: 1
    - _TransmissionEnable: 1
    - _TransparentBackfaceEnable: 0
    - _TransparentCullMode: 2
    - _TransparentDepthPostpassEnable: 0
    - _TransparentDepthPrepassEnable: 0
    - _TransparentSortPriority: 0
    - _TransparentWritingMotionVec: 0
    - _TransparentZWrite: 0
    - _UVBase: 0
    - _UVDetail: 0
    - _UVEmissive: 0
    - _UseEmissiveIntensity: 0
    - _UseShadowThreshold: 0
    - _ZTestDepthEqualForOpaque: 3
    - _ZTestGBuffer: 4
    - _ZTestModeDistortion: 4
    - _ZTestTransparent: 4
    - _ZWrite: 1
    m_Colors:
    - Color_020ef9a5ab8249da91e6a350af13f799: {r: 0.7294118, g: 0.7294118, b: 0.7294118, a: 0}
    - _BaseColor: {r: 0.7294118, g: 0.7294118, b: 0.7294118, a: 1}
    - _BaseColorMap_MipInfo: {r: 0, g: 0, b: 0, a: 0}
    - _Color: {r: 0.7294118, g: 0.7294118, b: 0.7294118, a: 1}
    - _DiffusionProfileAsset: {r: 0, g: 0, b: 0, a: 0}
    - _DoubleSidedConstants: {r: 1, g: 1, b: -1, a: 0}
    - _EmissionColor: {r: 1, g: 1, b: 1, a: 1}
    - _EmissiveColor: {r: 0, g: 0, b: 0, a: 1}
    - _EmissiveColorLDR: {r: 0, g: 0, b: 0, a: 1}
    - _InvPrimScale: {r: 1, g: 1, b: 0, a: 0}
    - _IridescenceThicknessRemap: {r: 0, g: 1, b: 0, a: 0}
    - _SpecularColor: {r: 1, g: 1, b: 1, a: 1}
    - _ThicknessRemap: {r: 0, g: 1, b: 0, a: 0}
    - _TransmittanceColor: {r: 1, g: 1, b: 1, a: 1}
    - _UVDetailsMappingMask: {r: 1, g: 0, b: 0, a: 0}
    - _UVMappingMask: {r: 1, g: 0, b: 0, a: 0}
    - _UVMappingMaskEmissive: {r: 1, g: 0, b: 0, a: 0}
  m_BuildTextureStacks: []
--- !u!114 &9130460386438202954
MonoBehaviour:
  m_ObjectHideFlags: 11
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: da692e001514ec24dbc4cca1949ff7e8, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  version: 11

```

`Samples~/HairSample/Materials/SRP_Primitive.mat.meta`:

```meta
fileFormatVersion: 2
guid: 8caee36f6072297438efb9036299d0f7
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Prefabs.meta`:

```meta
fileFormatVersion: 2
guid: c63929259dfee2b41a8df7b6c7a9ab2e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Prefabs/Boundaries.prefab`:

```prefab
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &7510820715701891250
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 7510820715701891251}
  m_Layer: 0
  m_Name: Boundaries
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &7510820715701891251
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820715701891250}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 7510820715752381236}
  - {fileID: 7510820717226929396}
  - {fileID: 7510820716335053721}
  - {fileID: 7510820715981549980}
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!1 &7510820715752381239
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 7510820715752381236}
  - component: {fileID: 7510820715752381235}
  - component: {fileID: 7510820715752381234}
  - component: {fileID: 7510820715752381237}
  m_Layer: 0
  m_Name: Cube
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &7510820715752381236
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820715752381239}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: -0.5, z: 0}
  m_LocalScale: {x: 10000, y: 1, z: 10000}
  m_Children: []
  m_Father: {fileID: 7510820715701891251}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!33 &7510820715752381235
MeshFilter:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820715752381239}
  m_Mesh: {fileID: 10202, guid: 0000000000000000e000000000000000, type: 0}
--- !u!23 &7510820715752381234
MeshRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820715752381239}
  m_Enabled: 1
  m_CastShadows: 1
  m_ReceiveShadows: 1
  m_DynamicOccludee: 1
  m_MotionVectors: 1
  m_LightProbeUsage: 1
  m_ReflectionProbeUsage: 1
  m_RayTracingMode: 2
  m_RayTraceProcedural: 0
  m_RenderingLayerMask: 257
  m_RendererPriority: 0
  m_Materials:
  - {fileID: 2100000, guid: 5f10f40e8eb71c245bd03eb8fef69a59, type: 2}
  m_StaticBatchInfo:
    firstSubMesh: 0
    subMeshCount: 0
  m_StaticBatchRoot: {fileID: 0}
  m_ProbeAnchor: {fileID: 0}
  m_LightProbeVolumeOverride: {fileID: 0}
  m_ScaleInLightmap: 1
  m_ReceiveGI: 1
  m_PreserveUVs: 0
  m_IgnoreNormalsForChartDetection: 0
  m_ImportantGI: 0
  m_StitchLightmapSeams: 1
  m_SelectedEditorRenderState: 3
  m_MinimumChartSize: 4
  m_AutoUVMaxDistance: 0.5
  m_AutoUVMaxAngle: 89
  m_LightmapParameters: {fileID: 0}
  m_SortingLayerID: 0
  m_SortingLayer: 0
  m_SortingOrder: 0
  m_AdditionalVertexStreams: {fileID: 0}
--- !u!65 &7510820715752381237
BoxCollider:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820715752381239}
  m_Material: {fileID: 0}
  m_IsTrigger: 0
  m_Enabled: 1
  serializedVersion: 2
  m_Size: {x: 1, y: 1, z: 1}
  m_Center: {x: 0, y: 0, z: 0}
--- !u!1 &7510820715981549987
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 7510820715981549980}
  - component: {fileID: 7510820715981549983}
  - component: {fileID: 7510820715981549982}
  - component: {fileID: 7510820715981549985}
  - component: {fileID: 7510820715981549984}
  m_Layer: 0
  m_Name: Capsule
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &7510820715981549980
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820715981549987}
  m_LocalRotation: {x: 0.91893464, y: 0.1726537, z: 0.13751717, w: 0.32686207}
  m_LocalPosition: {x: -1.369, y: 0.547, z: 2.585}
  m_LocalScale: {x: 0.49978, y: 0.49978, z: 0.49978}
  m_Children: []
  m_Father: {fileID: 7510820715701891251}
  m_RootOrder: 3
  m_LocalEulerAnglesHint: {x: 33.59, y: -206.033, z: -209.264}
--- !u!33 &7510820715981549983
MeshFilter:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820715981549987}
  m_Mesh: {fileID: 10208, guid: 0000000000000000e000000000000000, type: 0}
--- !u!23 &7510820715981549982
MeshRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820715981549987}
  m_Enabled: 1
  m_CastShadows: 1
  m_ReceiveShadows: 1
  m_DynamicOccludee: 1
  m_MotionVectors: 1
  m_LightProbeUsage: 1
  m_ReflectionProbeUsage: 1
  m_RayTracingMode: 2
  m_RayTraceProcedural: 0
  m_RenderingLayerMask: 1
  m_RendererPriority: 0
  m_Materials:
  - {fileID: 2100000, guid: a1352989639bd544494540446871c1cb, type: 2}
  m_StaticBatchInfo:
    firstSubMesh: 0
    subMeshCount: 0
  m_StaticBatchRoot: {fileID: 0}
  m_ProbeAnchor: {fileID: 0}
  m_LightProbeVolumeOverride: {fileID: 0}
  m_ScaleInLightmap: 1
  m_ReceiveGI: 1
  m_PreserveUVs: 0
  m_IgnoreNormalsForChartDetection: 0
  m_ImportantGI: 0
  m_StitchLightmapSeams: 1
  m_SelectedEditorRenderState: 3
  m_MinimumChartSize: 4
  m_AutoUVMaxDistance: 0.5
  m_AutoUVMaxAngle: 89
  m_LightmapParameters: {fileID: 0}
  m_SortingLayerID: 0
  m_SortingLayer: 0
  m_SortingOrder: 0
  m_AdditionalVertexStreams: {fileID: 0}
--- !u!136 &7510820715981549985
CapsuleCollider:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820715981549987}
  m_Material: {fileID: 0}
  m_IsTrigger: 0
  m_Enabled: 1
  m_Radius: 0.5
  m_Height: 2
  m_Direction: 1
  m_Center: {x: 0, y: 0, z: 0}
--- !u!114 &7510820715981549984
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820715981549987}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: cd6dc43f8cdf841428bf772881f46201, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  settings:
    mode: 0
    type: 5
  settingsCapsule:
    direction: 1
    radius: 0.5
    height: 2
  settingsSphere:
    radius: 0.5
  settingsTorus:
    axis: 1
    radiusAxis: 0.5
    radiusRing: 0.125
  settingsCube:
    size: {x: 1, y: 1, z: 1}
  settingsSDF:
    source: 0
    kSDF: {fileID: 0}
    kSDFWorldBounds:
      m_Center: {x: 0, y: 0, z: 0}
      m_Extent: {x: 0.5, y: 0.5, z: 0.5}
    kSDFComponent: {fileID: 0}
    kSDFRigidTransform: 0
    kSDFRigidTransformOrigin: {fileID: 0}
--- !u!1 &7510820716335053724
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 7510820716335053721}
  - component: {fileID: 7510820716335053720}
  - component: {fileID: 7510820716335053723}
  - component: {fileID: 7510820716335053722}
  - component: {fileID: 7510820716335053725}
  m_Layer: 0
  m_Name: Sphere (1)
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &7510820716335053721
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820716335053724}
  m_LocalRotation: {x: 0.14614218, y: 0.7276722, z: -0.6699953, w: -0.015552487}
  m_LocalPosition: {x: 2.344, y: 0.73, z: -1.45}
  m_LocalScale: {x: 1.0740404, y: 1.0740405, z: 1.0740403}
  m_Children: []
  m_Father: {fileID: 7510820715701891251}
  m_RootOrder: 2
  m_LocalEulerAnglesHint: {x: 76.055, y: -2274.969, z: 435.706}
--- !u!33 &7510820716335053720
MeshFilter:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820716335053724}
  m_Mesh: {fileID: 10207, guid: 0000000000000000e000000000000000, type: 0}
--- !u!23 &7510820716335053723
MeshRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820716335053724}
  m_Enabled: 1
  m_CastShadows: 1
  m_ReceiveShadows: 1
  m_DynamicOccludee: 1
  m_MotionVectors: 1
  m_LightProbeUsage: 1
  m_ReflectionProbeUsage: 1
  m_RayTracingMode: 2
  m_RayTraceProcedural: 0
  m_RenderingLayerMask: 1
  m_RendererPriority: 0
  m_Materials:
  - {fileID: 2100000, guid: a1352989639bd544494540446871c1cb, type: 2}
  m_StaticBatchInfo:
    firstSubMesh: 0
    subMeshCount: 0
  m_StaticBatchRoot: {fileID: 0}
  m_ProbeAnchor: {fileID: 0}
  m_LightProbeVolumeOverride: {fileID: 0}
  m_ScaleInLightmap: 1
  m_ReceiveGI: 1
  m_PreserveUVs: 0
  m_IgnoreNormalsForChartDetection: 0
  m_ImportantGI: 0
  m_StitchLightmapSeams: 1
  m_SelectedEditorRenderState: 3
  m_MinimumChartSize: 4
  m_AutoUVMaxDistance: 0.5
  m_AutoUVMaxAngle: 89
  m_LightmapParameters: {fileID: 0}
  m_SortingLayerID: 0
  m_SortingLayer: 0
  m_SortingOrder: 0
  m_AdditionalVertexStreams: {fileID: 0}
--- !u!135 &7510820716335053722
SphereCollider:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820716335053724}
  m_Material: {fileID: 0}
  m_IsTrigger: 0
  m_Enabled: 1
  serializedVersion: 2
  m_Radius: 0.5
  m_Center: {x: 0, y: 0, z: 0}
--- !u!114 &7510820716335053725
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820716335053724}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: cd6dc43f8cdf841428bf772881f46201, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  settings:
    mode: 0
    type: 5
  settingsCapsule:
    direction: 1
    radius: 0.5
    height: 2
  settingsSphere:
    radius: 0.5
  settingsTorus:
    axis: 1
    radiusAxis: 0.5
    radiusRing: 0.125
  settingsCube:
    size: {x: 1, y: 1, z: 1}
  settingsSDF:
    source: 0
    kSDF: {fileID: 0}
    kSDFWorldBounds:
      m_Center: {x: 0, y: 0, z: 0}
      m_Extent: {x: 0.5, y: 0.5, z: 0.5}
    kSDFComponent: {fileID: 0}
    kSDFRigidTransform: 0
    kSDFRigidTransformOrigin: {fileID: 0}
--- !u!1 &7510820717226929403
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 7510820717226929396}
  - component: {fileID: 7510820717226929399}
  - component: {fileID: 7510820717226929398}
  - component: {fileID: 7510820717226929401}
  - component: {fileID: 7510820717226929400}
  m_Layer: 0
  m_Name: Sphere
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &7510820717226929396
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820717226929403}
  m_LocalRotation: {x: -0, y: 0.9009906, z: -0, w: -0.43383864}
  m_LocalPosition: {x: 1.032, y: 0.92, z: 2.166}
  m_LocalScale: {x: 0.6756961, y: 0.67569613, z: 0.6756961}
  m_Children: []
  m_Father: {fileID: 7510820715701891251}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 0, y: -488.577, z: 0}
--- !u!33 &7510820717226929399
MeshFilter:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820717226929403}
  m_Mesh: {fileID: 10207, guid: 0000000000000000e000000000000000, type: 0}
--- !u!23 &7510820717226929398
MeshRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820717226929403}
  m_Enabled: 1
  m_CastShadows: 1
  m_ReceiveShadows: 1
  m_DynamicOccludee: 1
  m_MotionVectors: 1
  m_LightProbeUsage: 1
  m_ReflectionProbeUsage: 1
  m_RayTracingMode: 2
  m_RayTraceProcedural: 0
  m_RenderingLayerMask: 1
  m_RendererPriority: 0
  m_Materials:
  - {fileID: 2100000, guid: a1352989639bd544494540446871c1cb, type: 2}
  m_StaticBatchInfo:
    firstSubMesh: 0
    subMeshCount: 0
  m_StaticBatchRoot: {fileID: 0}
  m_ProbeAnchor: {fileID: 0}
  m_LightProbeVolumeOverride: {fileID: 0}
  m_ScaleInLightmap: 1
  m_ReceiveGI: 1
  m_PreserveUVs: 0
  m_IgnoreNormalsForChartDetection: 0
  m_ImportantGI: 0
  m_StitchLightmapSeams: 1
  m_SelectedEditorRenderState: 3
  m_MinimumChartSize: 4
  m_AutoUVMaxDistance: 0.5
  m_AutoUVMaxAngle: 89
  m_LightmapParameters: {fileID: 0}
  m_SortingLayerID: 0
  m_SortingLayer: 0
  m_SortingOrder: 0
  m_AdditionalVertexStreams: {fileID: 0}
--- !u!135 &7510820717226929401
SphereCollider:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820717226929403}
  m_Material: {fileID: 0}
  m_IsTrigger: 0
  m_Enabled: 1
  serializedVersion: 2
  m_Radius: 0.5
  m_Center: {x: 0, y: 0, z: 0}
--- !u!114 &7510820717226929400
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7510820717226929403}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: cd6dc43f8cdf841428bf772881f46201, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  settings:
    mode: 0
    type: 5
  settingsCapsule:
    direction: 1
    radius: 0.5
    height: 2
  settingsSphere:
    radius: 0.5
  settingsTorus:
    axis: 1
    radiusAxis: 0.5
    radiusRing: 0.125
  settingsCube:
    size: {x: 1, y: 1, z: 1}
  settingsSDF:
    source: 0
    kSDF: {fileID: 0}
    kSDFWorldBounds:
      m_Center: {x: 0, y: 0, z: 0}
      m_Extent: {x: 0.5, y: 0.5, z: 0.5}
    kSDFComponent: {fileID: 0}
    kSDFRigidTransform: 0
    kSDFRigidTransformOrigin: {fileID: 0}

```

`Samples~/HairSample/Prefabs/Boundaries.prefab.meta`:

```meta
fileFormatVersion: 2
guid: 82ca5ad9930bff94b8bb66a60ccff66c
PrefabImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Prefabs/Boundaries_SRP.prefab`:

```prefab
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1001 &5291624424076239658
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 7510820715701891250, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_Name
      value: Boundaries_SRP
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_RootOrder
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalPosition.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalRotation.w
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalRotation.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalRotation.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalRotation.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715752381234, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_Materials.Array.data[0]
      value: 
      objectReference: {fileID: 2100000, guid: c5bdb101e4dfd2548a15c1a737dc36d7, type: 2}
    - target: {fileID: 7510820715981549982, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_Materials.Array.data[0]
      value: 
      objectReference: {fileID: 2100000, guid: 8caee36f6072297438efb9036299d0f7, type: 2}
    - target: {fileID: 7510820716335053723, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_Materials.Array.data[0]
      value: 
      objectReference: {fileID: 2100000, guid: 8caee36f6072297438efb9036299d0f7, type: 2}
    - target: {fileID: 7510820717226929398, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_Materials.Array.data[0]
      value: 
      objectReference: {fileID: 2100000, guid: 8caee36f6072297438efb9036299d0f7, type: 2}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}

```

`Samples~/HairSample/Prefabs/Boundaries_SRP.prefab.meta`:

```meta
fileFormatVersion: 2
guid: 72a09331ad1a1224ebf2ec83225bcb0b
PrefabImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Prefabs/Camera.prefab`:

```prefab
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &5127100956968223908
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 5127100956968223963}
  - component: {fileID: 5127100956968223962}
  m_Layer: 0
  m_Name: VolumeURP
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 0
--- !u!4 &5127100956968223963
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 5127100956968223908}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 7494141127162770968}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!114 &5127100956968223962
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 5127100956968223908}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 172515602e62fb746b5d573b38a5fe58, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  isGlobal: 1
  priority: 0
  blendDistance: 0
  weight: 1
  sharedProfile: {fileID: 11400000, guid: 71f811389c245fe48b2dfb7b39ba9cd1, type: 2}
--- !u!1 &5127100957232491901
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 5127100957232491900}
  - component: {fileID: 5127100957232491891}
  m_Layer: 0
  m_Name: VolumeHDRP
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 0
--- !u!4 &5127100957232491900
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 5127100957232491901}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 7494141127162770968}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!114 &5127100957232491891
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 5127100957232491901}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 172515602e62fb746b5d573b38a5fe58, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  isGlobal: 1
  priority: 0
  blendDistance: 0
  weight: 1
  sharedProfile: {fileID: 11400000, guid: a4a8e754c7d994940a91f588a736b4c4, type: 2}
--- !u!1 &7494141127162770975
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 7494141127162770968}
  - component: {fileID: 2901098224332677096}
  - component: {fileID: 2901098224332677097}
  - component: {fileID: 1417649525146712754}
  - component: {fileID: 6453869409246690431}
  - component: {fileID: 5301158165904946644}
  m_Layer: 0
  m_Name: Camera
  m_TagString: MainCamera
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &7494141127162770968
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7494141127162770975}
  m_LocalRotation: {x: 0.13464461, y: 0.39459655, z: -0.05857508, w: 0.9070465}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 5127100957232491900}
  - {fileID: 5127100956968223963}
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 16.887, y: 47.021, z: 0}
--- !u!20 &2901098224332677096
Camera:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7494141127162770975}
  m_Enabled: 1
  serializedVersion: 2
  m_ClearFlags: 1
  m_BackGroundColor: {r: 0.19215687, g: 0.3019608, b: 0.4745098, a: 0}
  m_projectionMatrixMode: 1
  m_GateFitMode: 2
  m_FOVAxisMode: 0
  m_SensorSize: {x: 36, y: 24}
  m_LensShift: {x: 0, y: 0}
  m_FocalLength: 50
  m_NormalizedViewPortRect:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  near clip plane: 0.3
  far clip plane: 1000
  field of view: 50
  orthographic: 0
  orthographic size: 5
  m_Depth: -1
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingPath: -1
  m_TargetTexture: {fileID: 0}
  m_TargetDisplay: 0
  m_TargetEye: 3
  m_HDR: 0
  m_AllowMSAA: 0
  m_AllowDynamicResolution: 0
  m_ForceIntoRT: 0
  m_OcclusionCulling: 1
  m_StereoConvergence: 10
  m_StereoSeparation: 0.022
--- !u!81 &2901098224332677097
AudioListener:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7494141127162770975}
  m_Enabled: 1
--- !u!114 &1417649525146712754
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7494141127162770975}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 23920834ba9472542b1b6bcf69359a2f, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  builtinSkybox: {fileID: 2100000, guid: 37565627c08575c4bb329ed5a68bc511, type: 2}
--- !u!114 &6453869409246690431
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7494141127162770975}
  m_Enabled: 0
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 23c1ce4fb46143f46bc5cb5224c934f6, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Version: 7
  m_ObsoleteRenderingPath: 0
  m_ObsoleteFrameSettings:
    overrides: 0
    enableShadow: 0
    enableContactShadows: 0
    enableShadowMask: 0
    enableSSR: 0
    enableSSAO: 0
    enableSubsurfaceScattering: 0
    enableTransmission: 0
    enableAtmosphericScattering: 0
    enableVolumetrics: 0
    enableReprojectionForVolumetrics: 0
    enableLightLayers: 0
    enableExposureControl: 1
    diffuseGlobalDimmer: 0
    specularGlobalDimmer: 0
    shaderLitMode: 0
    enableDepthPrepassWithDeferredRendering: 0
    enableTransparentPrepass: 0
    enableMotionVectors: 0
    enableObjectMotionVectors: 0
    enableDecals: 0
    enableRoughRefraction: 0
    enableTransparentPostpass: 0
    enableDistortion: 0
    enablePostprocess: 0
    enableOpaqueObjects: 0
    enableTransparentObjects: 0
    enableRealtimePlanarReflection: 0
    enableMSAA: 0
    enableAsyncCompute: 0
    runLightListAsync: 0
    runSSRAsync: 0
    runSSAOAsync: 0
    runContactShadowsAsync: 0
    runVolumeVoxelizationAsync: 0
    lightLoopSettings:
      overrides: 0
      enableDeferredTileAndCluster: 0
      enableComputeLightEvaluation: 0
      enableComputeLightVariants: 0
      enableComputeMaterialVariants: 0
      enableFptlForForwardOpaque: 0
      enableBigTilePrepass: 0
      isFptlEnabled: 0
  clearColorMode: 0
  backgroundColorHDR: {r: 0.025, g: 0.07, b: 0.19, a: 0}
  clearDepth: 1
  volumeLayerMask:
    serializedVersion: 2
    m_Bits: 1
  volumeAnchorOverride: {fileID: 0}
  antialiasing: 0
  SMAAQuality: 2
  dithering: 0
  stopNaNs: 0
  taaSharpenStrength: 0.5
  TAAQuality: 1
  taaHistorySharpening: 0.35
  taaAntiFlicker: 0.5
  taaMotionVectorRejection: 0
  taaAntiHistoryRinging: 0
  physicalParameters:
    m_Iso: 200
    m_ShutterSpeed: 0.005
    m_Aperture: 16
    m_BladeCount: 5
    m_Curvature: {x: 2, y: 11}
    m_BarrelClipping: 0.25
    m_Anamorphism: 0
  flipYMode: 0
  xrRendering: 1
  fullscreenPassthrough: 0
  allowDynamicResolution: 0
  customRenderingSettings: 0
  invertFaceCulling: 0
  probeLayerMask:
    serializedVersion: 2
    m_Bits: 4294967295
  hasPersistentHistory: 0
  exposureTarget: {fileID: 0}
  m_RenderingPathCustomFrameSettings:
    bitDatas:
      data1: 72198262773251917
      data2: 13763000468760363032
    lodBias: 1
    lodBiasMode: 0
    lodBiasQualityLevel: 0
    maximumLODLevel: 0
    maximumLODLevelMode: 0
    maximumLODLevelQualityLevel: 0
    sssQualityMode: 0
    sssQualityLevel: 0
    sssCustomSampleBudget: 20
    materialQuality: 0
  renderingPathCustomFrameSettingsOverrideMask:
    mask:
      data1: 0
      data2: 0
  defaultFrameSettings: 0
--- !u!114 &5301158165904946644
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7494141127162770975}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a79441f348de89743a2939f4d699eac1, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_RenderShadows: 1
  m_RequiresDepthTextureOption: 2
  m_RequiresOpaqueTextureOption: 2
  m_CameraType: 0
  m_Cameras: []
  m_RendererIndex: -1
  m_VolumeLayerMask:
    serializedVersion: 2
    m_Bits: 1
  m_VolumeTrigger: {fileID: 0}
  m_RenderPostProcessing: 0
  m_Antialiasing: 0
  m_AntialiasingQuality: 2
  m_StopNaN: 0
  m_Dithering: 0
  m_ClearDepth: 1
  m_AllowXRRendering: 1
  m_RequiresDepthTexture: 0
  m_RequiresColorTexture: 0
  m_Version: 2

```

`Samples~/HairSample/Prefabs/Camera.prefab.meta`:

```meta
fileFormatVersion: 2
guid: f6205044afc2bf74888d8020858b4c5b
PrefabImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Prefabs/Camera_HDRP.prefab`:

```prefab
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1001 &317035195455400197
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 1417649525146712754, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_Enabled
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 5127100957232491901, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_IsActive
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 6453869409246690431, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_Enabled
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_RootOrder
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalPosition.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalRotation.w
      value: 0.9070465
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalRotation.x
      value: 0.13464461
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalRotation.y
      value: 0.39459655
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalRotation.z
      value: -0.05857508
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 16.887
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 47.021
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770975, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_Name
      value: Camera_HDRP
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}

```

`Samples~/HairSample/Prefabs/Camera_HDRP.prefab.meta`:

```meta
fileFormatVersion: 2
guid: e733d904bfa68ac449bd39236b4c8d72
PrefabImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Prefabs/Camera_URP.prefab`:

```prefab
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1001 &5395932464596670446
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 5127100956968223908, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_IsActive
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_RootOrder
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalPosition.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalRotation.w
      value: 0.9070465
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalRotation.x
      value: 0.13464461
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalRotation.y
      value: 0.39459655
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalRotation.z
      value: -0.05857508
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 16.887
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 47.021
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770975, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_Name
      value: Camera_URP
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}

```

`Samples~/HairSample/Prefabs/Camera_URP.prefab.meta`:

```meta
fileFormatVersion: 2
guid: 852440ec915fcf247a8093430de4542c
PrefabImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Prefabs/Hair.prefab`:

```prefab
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &2034033869895580038
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2034033869895580056}
  - component: {fileID: 2034033869895580039}
  m_Layer: 0
  m_Name: Hair
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &2034033869895580056
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2034033869895580038}
  m_LocalRotation: {x: 0, y: 0.23356412, z: 0, w: 0.9723415}
  m_LocalPosition: {x: 0, y: 1, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 2195987187783948249}
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 27.014, z: 0}
--- !u!114 &2034033869895580039
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2034033869895580038}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5e3c4c7574c547e4685bfb8817fbe6f3, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  strandGroupChecksums:
  - 88f602f4086046583d1a34670a7944e3
  strandGroupProviders:
  - hairAsset: {fileID: 11400000, guid: 8eb9a34a36e03bd44ab91a8369408d08, type: 2}
    hairAssetQuickEdit: 0
  strandGroupInstances:
  - groupAssetReference:
      hairAsset: {fileID: 11400000, guid: 8eb9a34a36e03bd44ab91a8369408d08, type: 2}
      hairAssetGroupIndex: 0
    sceneObjects:
      groupContainer: {fileID: 7948216322921854393}
      rootMeshContainer: {fileID: 6953803782446183462}
      rootMeshFilter: {fileID: 780408439620275695}
      strandMeshContainer: {fileID: 2824165130904731610}
      strandMeshFilter: {fileID: 4559418031648212631}
      strandMeshRenderer: {fileID: 1303284163179071079}
    settingsIndex: -1
  strandGroupSettings: []
  strandGroupDefaults:
    groupAssetReferences: []
    settingsSkinningToggle: 0
    settingsGeometry:
      strandScale: 0
      strandLength: 0
      strandLengthValue: 0.25
      strandDiameter: 1
      strandDiameterValue: 20.8
      strandSeparation: 0
      tipScale: 0
      tipScaleValue: 0.15
      tipScaleOffset: 0
      tipScaleOffsetValue: 0.75
      boundsMode: 0
      boundsCenter: {x: 0, y: 0, z: 0}
      boundsExtent: {x: 1, y: 1, z: 1}
      boundsScale: 0
      boundsScaleValue: 1.25
      stagingPrecision: 1
      stagingSubdivision: 0
      stagingSubdivisionCount: 1
    settingsGeometryToggle: 0
    settingsRendering:
      material: 0
      materialAsset: {fileID: 0}
      renderer: 1
      rendererLayers: 257
      rendererShadows: 1
      shadowLayers: 0
      shadowLayersValue: 257
      shadowSubstitute: 0
      shadowSubstituteValue: 0
      motionVectors: 0
      allowIndirect: 1
      allowInstancing: 1
      kLODSelection: 0
      kLODSelectionValue: 1
      kLODCeiling: 1
      kLODScale: 1
      kLODBias: 0
      clipThreshold: 0.05
    settingsRenderingToggle: 0
    settingsPhysics:
      solver: 1
      solverSubsteps: 1
      constraintIterations: 5
      constraintStiffness: 1
      constraintSOR: 1
      dampingLinear: 0
      dampingLinearFactor: 0.5
      dampingLinearInterval: 0
      dampingAngular: 0
      dampingAngularFactor: 0.5
      dampingAngularInterval: 0
      cellPressure: 1
      cellVelocity: 0.05
      cellExternal: 1
      gravity: 1
      boundaryCollision: 1
      boundaryCollisionFriction: 0.5
      distance: 1
      distanceLRA: 1
      distanceFTL: 0
      distanceFTLCorrection: 0.8
      localCurvature: 0
      localCurvatureMode: 1
      localCurvatureValue: 0.1
      localShape: 1
      localShapeMode: 1
      localShapeInfluence: 1
      localShapeBias: 1
      localShapeBiasValue: 0.5
      globalPosition: 0
      globalPositionInfluence: 1
      globalPositionInterval: 0
      globalRotation: 0
      globalRotationInfluence: 0.257
      globalFade: 0
      globalFadeOffset: 0.1
      globalFadeExtent: 0.3
      kLODSelection: 2
      kLODSelectionValue: 0
      kLODCeiling: 1
      kLODScale: 1
      kLODBias: 0
    settingsPhysicsToggle: 0
  settingsExecutive:
    updateMode: 0
    updateSimulation: 1
    updateSimulationRate: 1
    updateSimulationInEditor: 1
    updateTimeStep: 0.01
    updateStepsMin: 0
    updateStepsMinValue: 1
    updateStepsMax: 1
    updateStepsMaxValue: 2
  settingsDebugging:
    drawStrandRoots: 0
    drawStrandParticles: 0
    drawStrandVelocities: 0
    drawStrandClusters: 0
    specificCluster: -1
    drawCellDensity: 0
    drawCellGradient: 0
    drawIsosurface: 0
    drawIsosurfaceDensity: 0.5
    drawIsosurfaceSubsteps: 4
    drawSliceX: 0
    drawSliceXOffset: 0.5
    drawSliceY: 0
    drawSliceYOffset: 0.5
    drawSliceZ: 0
    drawSliceZOffset: 0.5
    drawSliceDivider: 0
  settingsEnvironment:
    gravityScale: 1
    gravityRotation: {x: 0, y: 0, z: 0, w: 1}
    emitterCapture: 1
    emitterCaptureMode: 0
    emitterCaptureLayer:
      serializedVersion: 2
      m_Bits: 4294967295
    emitterResident: []
    boundaryCapture: 1
    boundaryCaptureMode: 1
    boundaryCaptureLayer:
      serializedVersion: 2
      m_Bits: 4294967295
    boundaryResident: []
    defaultSolidMargin: 0.25
    defaultSolidDensity: 5
  settingsVolumetrics:
    gridPrecision: 0
    gridResolution: 32
    gridStaggered: 0
    splatMethod: 1
    splatClusters: 1
    pressureIterations: 3
    pressureSolution: 1
    restDensity: 0
    restDensityScale: 1
    restDensityInfluence: 1
    scatteringProbe: 0
    scatteringProbeCellSubsteps: 1
    scatteringProbeBias: 1
    probeSamplesTheta: 5
    probeSamplesPhi: 10
    probeOcclusion: 1
    probeOcclusionMode: 0
    probeOcclusionSolidDensity: 5
    windPropagation: 1
    windPropagationCellSubsteps: 1
    windOcclusion: 1
    windOcclusionMode: 1
    windDepth: 1
  data_0_settingsSystem:
    boundsMode: 0
    boundsCenter: {x: 0, y: 0, z: 0}
    boundsExtent: {x: 1, y: 1, z: 1}
    boundsScale: 0
    boundsScaleValue: 1.25
    kLODSearch: 1
    kLODSearchViews: -3
    kLODSearchCurve:
      serializedVersion: 2
      m_Curve:
      - serializedVersion: 3
        time: 0
        value: 0
        inSlope: 0
        outSlope: 1
        tangentMode: 0
        weightedMode: 0
        inWeight: 0
        outWeight: 0
      - serializedVersion: 3
        time: 1
        value: 1
        inSlope: 1
        outSlope: 0
        tangentMode: 0
        weightedMode: 0
        inWeight: 0
        outWeight: 0
      m_PreInfinity: 2
      m_PostInfinity: 2
      m_RotationOrder: 4
    kLODSearchValue: 0
    kLODBlending: 0
    strandRenderer: 1
    strandShadows: 1
    strandLayers: 257
    motionVectors: 0
    updateMode: 0
    simulation: 1
    simulationRate: 1
    simulationInEditor: 1
    simulationTimeStep: 0.01
    stepsMin: 0
    stepsMinValue: 1
    stepsMax: 1
    stepsMaxValue: 2
  data_0_settingsVolume:
    gridPrecision: 0
    gridResolution: 32
    splatMethod: 1
    splatClusters: 1
    pressureIterations: 3
    pressureSolution: 1
    targetDensity: 0
    targetDensityInfluence: 1
    scatteringProbe: 0
    scatteringProbeCellSubsteps: 1
    scatteringProbeBias: 1
    probeSamplesTheta: 5
    probeSamplesPhi: 10
    probeOcclusion: 1
    probeOcclusionMode: 0
    probeOcclusionSolidDensity: 5
    windPropagation: 1
    windPropagationCellSubsteps: 1
    windOcclusion: 1
    windOcclusionMode: 1
    windExtinction: 1
    collisionMargin: 0.25
    boundariesCollect: 1
    boundariesCollectMode: 1
    boundariesCollectLayer:
      serializedVersion: 2
      m_Bits: 4294967295
    boundariesPriority: []
  data_0_strandGroupDefaults:
    settingsStrands:
      material: 0
      materialValue: {fileID: 0}
      strandScale: 0
      strandDiameter: 20.8
      strandMargin: 0
      stagingPrecision: 1
      stagingSubdivision: 0
    settingsStrandsToggle: 0
    settingsSolver:
      method: 1
      iterations: 5
      substeps: 1
      stiffness: 1
      kSOR: 1
      damping: 0
      dampingFactor: 0.5
      dampingInterval: 0
      angularDamping: 0
      angularDampingFactor: 0.5
      angularDampingInterval: 0
      cellPressure: 1
      cellVelocity: 0.05
      cellForces: 1
      gravity: 1
      gravityRotation: {x: 0, y: 0, z: 0}
      boundaryCollision: 1
      boundaryCollisionFriction: 0.5
      distance: 1
      distanceLRA: 1
      distanceFTL: 0
      distanceFTLCorrection: 0.8
      localCurvature: 0
      localCurvatureMode: 1
      localCurvatureValue: 0.1
      localShape: 1
      localShapeMode: 1
      localShapeInfluence: 1
      localShapeBias: 1
      localShapeBiasValue: 0.5
      globalPosition: 0
      globalPositionInfluence: 1
      globalPositionInterval: 0
      globalRotation: 0
      globalRotationInfluence: 0.257
      globalFade: 0
      globalFadeOffset: 0.1
      globalFadeExtent: 0.3
    settingsSolverToggle: 0
  data_0_strandGroupSettings: []
  <version>k__BackingField: 2
--- !u!1 &2824165130904731610
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1760501148571291488}
  - component: {fileID: 4559418031648212631}
  - component: {fileID: 1303284163179071079}
  m_Layer: 0
  m_Name: Strands:0
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &1760501148571291488
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2824165130904731610}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 2195987187783948249}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!33 &4559418031648212631
MeshFilter:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2824165130904731610}
  m_Mesh: {fileID: 0}
--- !u!23 &1303284163179071079
MeshRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2824165130904731610}
  m_Enabled: 1
  m_CastShadows: 1
  m_ReceiveShadows: 1
  m_DynamicOccludee: 1
  m_StaticShadowCaster: 0
  m_MotionVectors: 0
  m_LightProbeUsage: 1
  m_ReflectionProbeUsage: 1
  m_RayTracingMode: 2
  m_RayTraceProcedural: 0
  m_RenderingLayerMask: 257
  m_RendererPriority: 0
  m_Materials:
  - {fileID: 0}
  m_StaticBatchInfo:
    firstSubMesh: 0
    subMeshCount: 0
  m_StaticBatchRoot: {fileID: 0}
  m_ProbeAnchor: {fileID: 0}
  m_LightProbeVolumeOverride: {fileID: 0}
  m_ScaleInLightmap: 1
  m_ReceiveGI: 1
  m_PreserveUVs: 0
  m_IgnoreNormalsForChartDetection: 0
  m_ImportantGI: 0
  m_StitchLightmapSeams: 1
  m_SelectedEditorRenderState: 3
  m_MinimumChartSize: 4
  m_AutoUVMaxDistance: 0.5
  m_AutoUVMaxAngle: 89
  m_LightmapParameters: {fileID: 0}
  m_SortingLayerID: 0
  m_SortingLayer: 0
  m_SortingOrder: 0
  m_AdditionalVertexStreams: {fileID: 0}
--- !u!1 &6953803782446183462
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 5865708551041691187}
  - component: {fileID: 780408439620275695}
  m_Layer: 0
  m_Name: Roots:0
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &5865708551041691187
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 6953803782446183462}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 2195987187783948249}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!33 &780408439620275695
MeshFilter:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 6953803782446183462}
  m_Mesh: {fileID: 305566116149346885, guid: 8eb9a34a36e03bd44ab91a8369408d08, type: 2}
--- !u!1 &7948216322921854393
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2195987187783948249}
  m_Layer: 0
  m_Name: Group:0
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &2195987187783948249
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7948216322921854393}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 5865708551041691187}
  - {fileID: 1760501148571291488}
  m_Father: {fileID: 2034033869895580056}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}

```

`Samples~/HairSample/Prefabs/Hair.prefab.meta`:

```meta
fileFormatVersion: 2
guid: bef18da41f24f044cb72b7768bbedb05
PrefabImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Prefabs/Lights.prefab`:

```prefab
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &297400364091726750
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 297400364091726751}
  - component: {fileID: 297400364091726721}
  m_Layer: 0
  m_Name: Spot Light (1)
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &297400364091726751
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 297400364091726750}
  m_LocalRotation: {x: -0.3568577, y: 0.33364394, z: -0.13820003, w: -0.8615307}
  m_LocalPosition: {x: 1.82, y: 3.02, z: -2.26}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 2075889177198007447}
  m_RootOrder: 2
  m_LocalEulerAnglesHint: {x: 45, y: -402.34, z: 0}
--- !u!108 &297400364091726721
Light:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 297400364091726750}
  m_Enabled: 1
  serializedVersion: 10
  m_Type: 0
  m_Shape: 0
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_Intensity: 1
  m_Range: 10
  m_SpotAngle: 30
  m_InnerSpotAngle: 21.80208
  m_CookieSize: 10
  m_Shadows:
    m_Type: 1
    m_Resolution: -1
    m_CustomResolution: -1
    m_Strength: 1
    m_Bias: 0.05
    m_NormalBias: 0.4
    m_NearPlane: 0.2
    m_CullingMatrixOverride:
      e00: 1
      e01: 0
      e02: 0
      e03: 0
      e10: 0
      e11: 1
      e12: 0
      e13: 0
      e20: 0
      e21: 0
      e22: 1
      e23: 0
      e30: 0
      e31: 0
      e32: 0
      e33: 1
    m_UseCullingMatrixOverride: 0
  m_Cookie: {fileID: 0}
  m_DrawHalo: 0
  m_Flare: {fileID: 0}
  m_RenderMode: 0
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingLayerMask: 1
  m_Lightmapping: 4
  m_LightShadowCasterMode: 2
  m_AreaSize: {x: 0.5, y: 0.5}
  m_BounceIntensity: 1
  m_ColorTemperature: 6570
  m_UseColorTemperature: 0
  m_BoundingSphereOverride: {x: 0, y: 0, z: 0, w: 0}
  m_UseBoundingSphereOverride: 0
  m_UseViewFrustumForShadowCasterCull: 1
  m_ShadowRadius: 0
  m_ShadowAngle: 0
--- !u!1 &297400364136588157
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 297400364136588158}
  - component: {fileID: 297400364136588128}
  m_Layer: 0
  m_Name: Point Light
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &297400364136588158
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 297400364136588157}
  m_LocalRotation: {x: 0.7071068, y: -0, z: -0, w: 0.7071068}
  m_LocalPosition: {x: 0.137, y: 3.026, z: 0.118}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 2075889177198007447}
  m_RootOrder: 4
  m_LocalEulerAnglesHint: {x: 90, y: 0, z: 0}
--- !u!108 &297400364136588128
Light:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 297400364136588157}
  m_Enabled: 1
  serializedVersion: 10
  m_Type: 0
  m_Shape: 0
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_Intensity: 1
  m_Range: 10
  m_SpotAngle: 109.38996
  m_InnerSpotAngle: 21.80208
  m_CookieSize: 10
  m_Shadows:
    m_Type: 1
    m_Resolution: -1
    m_CustomResolution: -1
    m_Strength: 1
    m_Bias: 0.05
    m_NormalBias: 0.4
    m_NearPlane: 0.2
    m_CullingMatrixOverride:
      e00: 1
      e01: 0
      e02: 0
      e03: 0
      e10: 0
      e11: 1
      e12: 0
      e13: 0
      e20: 0
      e21: 0
      e22: 1
      e23: 0
      e30: 0
      e31: 0
      e32: 0
      e33: 1
    m_UseCullingMatrixOverride: 0
  m_Cookie: {fileID: 0}
  m_DrawHalo: 0
  m_Flare: {fileID: 0}
  m_RenderMode: 0
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingLayerMask: 1
  m_Lightmapping: 4
  m_LightShadowCasterMode: 2
  m_AreaSize: {x: 0.5, y: 0.5}
  m_BounceIntensity: 1
  m_ColorTemperature: 6570
  m_UseColorTemperature: 0
  m_BoundingSphereOverride: {x: 0, y: 0, z: 0, w: 0}
  m_UseBoundingSphereOverride: 0
  m_UseViewFrustumForShadowCasterCull: 1
  m_ShadowRadius: 0
  m_ShadowAngle: 0
--- !u!1 &297400364489881681
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 297400364489881682}
  - component: {fileID: 297400364489881684}
  m_Layer: 0
  m_Name: Spot Light (2)
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &297400364489881682
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 297400364489881681}
  m_LocalRotation: {x: 0.12304662, y: -0.8477814, z: 0.22462572, w: 0.4644024}
  m_LocalPosition: {x: 3.252, y: 2.295, z: 1.833}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 2075889177198007447}
  m_RootOrder: 3
  m_LocalEulerAnglesHint: {x: 29.68, y: -122.573, z: 0}
--- !u!108 &297400364489881684
Light:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 297400364489881681}
  m_Enabled: 1
  serializedVersion: 10
  m_Type: 0
  m_Shape: 0
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_Intensity: 1
  m_Range: 10
  m_SpotAngle: 30
  m_InnerSpotAngle: 21.80208
  m_CookieSize: 10
  m_Shadows:
    m_Type: 1
    m_Resolution: -1
    m_CustomResolution: -1
    m_Strength: 1
    m_Bias: 0.05
    m_NormalBias: 0.4
    m_NearPlane: 0.2
    m_CullingMatrixOverride:
      e00: 1
      e01: 0
      e02: 0
      e03: 0
      e10: 0
      e11: 1
      e12: 0
      e13: 0
      e20: 0
      e21: 0
      e22: 1
      e23: 0
      e30: 0
      e31: 0
      e32: 0
      e33: 1
    m_UseCullingMatrixOverride: 0
  m_Cookie: {fileID: 0}
  m_DrawHalo: 0
  m_Flare: {fileID: 0}
  m_RenderMode: 0
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingLayerMask: 1
  m_Lightmapping: 4
  m_LightShadowCasterMode: 2
  m_AreaSize: {x: 0.5, y: 0.5}
  m_BounceIntensity: 1
  m_ColorTemperature: 6570
  m_UseColorTemperature: 0
  m_BoundingSphereOverride: {x: 0, y: 0, z: 0, w: 0}
  m_UseBoundingSphereOverride: 0
  m_UseViewFrustumForShadowCasterCull: 1
  m_ShadowRadius: 0
  m_ShadowAngle: 0
--- !u!1 &297400364496499657
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 297400364496499659}
  - component: {fileID: 297400364496499658}
  m_Layer: 0
  m_Name: Directional Light
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &297400364496499659
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 297400364496499657}
  m_LocalRotation: {x: 0.40821788, y: -0.23456968, z: 0.10938163, w: 0.8754261}
  m_LocalPosition: {x: 0, y: 3, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 2075889177198007447}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 50, y: -30, z: 0}
--- !u!108 &297400364496499658
Light:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 297400364496499657}
  m_Enabled: 1
  serializedVersion: 10
  m_Type: 1
  m_Shape: 0
  m_Color: {r: 1, g: 0.95686275, b: 0.8392157, a: 1}
  m_Intensity: 1
  m_Range: 10
  m_SpotAngle: 30
  m_InnerSpotAngle: 21.80208
  m_CookieSize: 10
  m_Shadows:
    m_Type: 2
    m_Resolution: -1
    m_CustomResolution: -1
    m_Strength: 1
    m_Bias: 0.05
    m_NormalBias: 0.4
    m_NearPlane: 0.2
    m_CullingMatrixOverride:
      e00: 1
      e01: 0
      e02: 0
      e03: 0
      e10: 0
      e11: 1
      e12: 0
      e13: 0
      e20: 0
      e21: 0
      e22: 1
      e23: 0
      e30: 0
      e31: 0
      e32: 0
      e33: 1
    m_UseCullingMatrixOverride: 0
  m_Cookie: {fileID: 0}
  m_DrawHalo: 0
  m_Flare: {fileID: 0}
  m_RenderMode: 0
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingLayerMask: 1
  m_Lightmapping: 4
  m_LightShadowCasterMode: 2
  m_AreaSize: {x: 1, y: 1}
  m_BounceIntensity: 1
  m_ColorTemperature: 6570
  m_UseColorTemperature: 0
  m_BoundingSphereOverride: {x: 0, y: 0, z: 0, w: 0}
  m_UseBoundingSphereOverride: 0
  m_UseViewFrustumForShadowCasterCull: 1
  m_ShadowRadius: 0
  m_ShadowAngle: 0
--- !u!1 &297400365269625769
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 297400365269625770}
  - component: {fileID: 297400365269625772}
  m_Layer: 0
  m_Name: Spot Light
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &297400365269625770
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 297400365269625769}
  m_LocalRotation: {x: 0.64670235, y: 0.28596526, z: 0.28596526, w: 0.64670235}
  m_LocalPosition: {x: -3.69, y: 3.3000002, z: 0.25}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 2075889177198007447}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 137.709, y: 270, z: -90}
--- !u!108 &297400365269625772
Light:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 297400365269625769}
  m_Enabled: 1
  serializedVersion: 10
  m_Type: 0
  m_Shape: 0
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_Intensity: 1
  m_Range: 10
  m_SpotAngle: 30
  m_InnerSpotAngle: 21.80208
  m_CookieSize: 10
  m_Shadows:
    m_Type: 1
    m_Resolution: -1
    m_CustomResolution: -1
    m_Strength: 1
    m_Bias: 0.05
    m_NormalBias: 0.4
    m_NearPlane: 0.2
    m_CullingMatrixOverride:
      e00: 1
      e01: 0
      e02: 0
      e03: 0
      e10: 0
      e11: 1
      e12: 0
      e13: 0
      e20: 0
      e21: 0
      e22: 1
      e23: 0
      e30: 0
      e31: 0
      e32: 0
      e33: 1
    m_UseCullingMatrixOverride: 0
  m_Cookie: {fileID: 0}
  m_DrawHalo: 0
  m_Flare: {fileID: 0}
  m_RenderMode: 0
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingLayerMask: 1
  m_Lightmapping: 4
  m_LightShadowCasterMode: 2
  m_AreaSize: {x: 0.5, y: 0.5}
  m_BounceIntensity: 1
  m_ColorTemperature: 6570
  m_UseColorTemperature: 0
  m_BoundingSphereOverride: {x: 0, y: 0, z: 0, w: 0}
  m_UseBoundingSphereOverride: 0
  m_UseViewFrustumForShadowCasterCull: 1
  m_ShadowRadius: 0
  m_ShadowAngle: 0
--- !u!1 &8270402660517999592
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2075889177198007447}
  m_Layer: 0
  m_Name: Lights_Builtin
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &2075889177198007447
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 8270402660517999592}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 297400364496499659}
  - {fileID: 297400365269625770}
  - {fileID: 297400364091726751}
  - {fileID: 297400364489881682}
  - {fileID: 297400364136588158}
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}

```

`Samples~/HairSample/Prefabs/Lights.prefab.meta`:

```meta
fileFormatVersion: 2
guid: c7912e2b6bcc5c8468290c1e54e1bd6d
PrefabImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Prefabs/Lights_HDRP.prefab`:

```prefab
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &876280721
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 9181194116206944279}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 7a68c43fe1f2a47cfa234b5eeaa98012, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Version: 11
  m_ObsoleteShadowResolutionTier: 1
  m_ObsoleteUseShadowQualitySettings: 0
  m_ObsoleteCustomShadowResolution: 512
  m_ObsoleteContactShadows: 0
  m_PointlightHDType: 0
  m_SpotLightShape: 0
  m_AreaLightShape: 0
  m_Intensity: 600
  m_EnableSpotReflector: 0
  m_LuxAtDistance: 1
  m_InnerSpotPercent: 0
  m_SpotIESCutoffPercent: 100
  m_LightDimmer: 1
  m_VolumetricDimmer: 1
  m_LightUnit: 0
  m_FadeDistance: 10000
  m_VolumetricFadeDistance: 10000
  m_AffectDiffuse: 1
  m_AffectSpecular: 1
  m_NonLightmappedOnly: 0
  m_ShapeWidth: 0.5
  m_ShapeHeight: 0.5
  m_AspectRatio: 1
  m_ShapeRadius: 0.025
  m_SoftnessScale: 1
  m_UseCustomSpotLightShadowCone: 0
  m_CustomSpotLightShadowCone: 30
  m_MaxSmoothness: 0.99
  m_ApplyRangeAttenuation: 1
  m_DisplayAreaLightEmissiveMesh: 0
  m_AreaLightCookie: {fileID: 0}
  m_IESPoint: {fileID: 0}
  m_IESSpot: {fileID: 0}
  m_IncludeForRayTracing: 1
  m_AreaLightShadowCone: 120
  m_UseScreenSpaceShadows: 0
  m_InteractsWithSky: 1
  m_AngularDiameter: 0.5
  m_FlareSize: 2
  m_FlareTint: {r: 1, g: 1, b: 1, a: 1}
  m_FlareFalloff: 4
  m_SurfaceTexture: {fileID: 0}
  m_SurfaceTint: {r: 1, g: 1, b: 1, a: 1}
  m_Distance: 1.5e+11
  m_UseRayTracedShadows: 0
  m_NumRayTracingSamples: 4
  m_FilterTracedShadow: 1
  m_FilterSizeTraced: 16
  m_SunLightConeAngle: 0.5
  m_LightShadowRadius: 0.5
  m_SemiTransparentShadow: 0
  m_ColorShadow: 1
  m_DistanceBasedFiltering: 0
  m_EvsmExponent: 15
  m_EvsmLightLeakBias: 0
  m_EvsmVarianceBias: 0.00001
  m_EvsmBlurPasses: 0
  m_LightlayersMask: 1
  m_LinkShadowLayers: 1
  m_ShadowNearPlane: 0.1
  m_BlockerSampleCount: 24
  m_FilterSampleCount: 16
  m_MinFilterSize: 0.1
  m_KernelSize: 5
  m_LightAngle: 1
  m_MaxDepthBias: 0.001
  m_ShadowResolution:
    m_Override: 512
    m_UseOverride: 1
    m_Level: 0
  m_ShadowDimmer: 1
  m_VolumetricShadowDimmer: 1
  m_ShadowFadeDistance: 10000
  m_UseContactShadow:
    m_Override: 0
    m_UseOverride: 1
    m_Level: 0
  m_RayTracedContactShadow: 0
  m_ShadowTint: {r: 0, g: 0, b: 0, a: 1}
  m_PenumbraTint: 0
  m_NormalBias: 0.75
  m_SlopeBias: 0.5
  m_ShadowUpdateMode: 0
  m_AlwaysDrawDynamicShadows: 0
  m_UpdateShadowOnLightMovement: 0
  m_CachedShadowTranslationThreshold: 0.01
  m_CachedShadowAngularThreshold: 0.5
  m_BarnDoorAngle: 90
  m_BarnDoorLength: 0.05
  m_preserveCachedShadow: 0
  m_ShadowCascadeRatios:
  - 0.05
  - 0.2
  - 0.3
  m_ShadowCascadeBorders:
  - 0.2
  - 0.2
  - 0.2
  - 0.2
  m_ShadowAlgorithm: 0
  m_ShadowVariant: 0
  m_ShadowPrecision: 0
  useOldInspector: 0
  useVolumetric: 1
  featuresFoldout: 1
  showAdditionalSettings: 0
  m_AreaLightEmissiveMeshShadowCastingMode: 0
  m_AreaLightEmissiveMeshMotionVectorGenerationMode: 0
  m_AreaLightEmissiveMeshLayer: -1
--- !u!114 &876280719
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 9181194116215925647}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 7a68c43fe1f2a47cfa234b5eeaa98012, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Version: 11
  m_ObsoleteShadowResolutionTier: 1
  m_ObsoleteUseShadowQualitySettings: 0
  m_ObsoleteCustomShadowResolution: 512
  m_ObsoleteContactShadows: 0
  m_PointlightHDType: 0
  m_SpotLightShape: 0
  m_AreaLightShape: 0
  m_Intensity: 3.141593
  m_EnableSpotReflector: 0
  m_LuxAtDistance: 1
  m_InnerSpotPercent: 0
  m_SpotIESCutoffPercent: 100
  m_LightDimmer: 1
  m_VolumetricDimmer: 1
  m_LightUnit: 2
  m_FadeDistance: 10000
  m_VolumetricFadeDistance: 10000
  m_AffectDiffuse: 1
  m_AffectSpecular: 1
  m_NonLightmappedOnly: 0
  m_ShapeWidth: 0.5
  m_ShapeHeight: 0.5
  m_AspectRatio: 1
  m_ShapeRadius: 0.025
  m_SoftnessScale: 1
  m_UseCustomSpotLightShadowCone: 0
  m_CustomSpotLightShadowCone: 30
  m_MaxSmoothness: 0.99
  m_ApplyRangeAttenuation: 1
  m_DisplayAreaLightEmissiveMesh: 0
  m_AreaLightCookie: {fileID: 0}
  m_IESPoint: {fileID: 0}
  m_IESSpot: {fileID: 0}
  m_IncludeForRayTracing: 1
  m_AreaLightShadowCone: 120
  m_UseScreenSpaceShadows: 0
  m_InteractsWithSky: 1
  m_AngularDiameter: 0.5
  m_FlareSize: 2
  m_FlareTint: {r: 1, g: 1, b: 1, a: 1}
  m_FlareFalloff: 4
  m_SurfaceTexture: {fileID: 0}
  m_SurfaceTint: {r: 1, g: 1, b: 1, a: 1}
  m_Distance: 1.5e+11
  m_UseRayTracedShadows: 0
  m_NumRayTracingSamples: 4
  m_FilterTracedShadow: 1
  m_FilterSizeTraced: 16
  m_SunLightConeAngle: 0.5
  m_LightShadowRadius: 0.5
  m_SemiTransparentShadow: 0
  m_ColorShadow: 1
  m_DistanceBasedFiltering: 0
  m_EvsmExponent: 15
  m_EvsmLightLeakBias: 0
  m_EvsmVarianceBias: 0.00001
  m_EvsmBlurPasses: 0
  m_LightlayersMask: 1
  m_LinkShadowLayers: 1
  m_ShadowNearPlane: 0.1
  m_BlockerSampleCount: 24
  m_FilterSampleCount: 16
  m_MinFilterSize: 0.1
  m_KernelSize: 5
  m_LightAngle: 1
  m_MaxDepthBias: 0.001
  m_ShadowResolution:
    m_Override: 512
    m_UseOverride: 1
    m_Level: 0
  m_ShadowDimmer: 1
  m_VolumetricShadowDimmer: 1
  m_ShadowFadeDistance: 10000
  m_UseContactShadow:
    m_Override: 0
    m_UseOverride: 1
    m_Level: 0
  m_RayTracedContactShadow: 0
  m_ShadowTint: {r: 0, g: 0, b: 0, a: 1}
  m_PenumbraTint: 0
  m_NormalBias: 0.75
  m_SlopeBias: 0.5
  m_ShadowUpdateMode: 0
  m_AlwaysDrawDynamicShadows: 0
  m_UpdateShadowOnLightMovement: 0
  m_CachedShadowTranslationThreshold: 0.01
  m_CachedShadowAngularThreshold: 0.5
  m_BarnDoorAngle: 90
  m_BarnDoorLength: 0.05
  m_preserveCachedShadow: 0
  m_ShadowCascadeRatios:
  - 0.05
  - 0.2
  - 0.3
  m_ShadowCascadeBorders:
  - 0.2
  - 0.2
  - 0.2
  - 0.2
  m_ShadowAlgorithm: 0
  m_ShadowVariant: 0
  m_ShadowPrecision: 0
  useOldInspector: 0
  useVolumetric: 1
  featuresFoldout: 1
  showAdditionalSettings: 0
  m_AreaLightEmissiveMeshShadowCastingMode: 0
  m_AreaLightEmissiveMeshMotionVectorGenerationMode: 0
  m_AreaLightEmissiveMeshLayer: -1
--- !u!114 &876280718
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 9181194116516672495}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 7a68c43fe1f2a47cfa234b5eeaa98012, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Version: 11
  m_ObsoleteShadowResolutionTier: 1
  m_ObsoleteUseShadowQualitySettings: 0
  m_ObsoleteCustomShadowResolution: 512
  m_ObsoleteContactShadows: 0
  m_PointlightHDType: 0
  m_SpotLightShape: 0
  m_AreaLightShape: 0
  m_Intensity: 600
  m_EnableSpotReflector: 0
  m_LuxAtDistance: 1
  m_InnerSpotPercent: 0
  m_SpotIESCutoffPercent: 100
  m_LightDimmer: 1
  m_VolumetricDimmer: 1
  m_LightUnit: 0
  m_FadeDistance: 10000
  m_VolumetricFadeDistance: 10000
  m_AffectDiffuse: 1
  m_AffectSpecular: 1
  m_NonLightmappedOnly: 0
  m_ShapeWidth: 0.5
  m_ShapeHeight: 0.5
  m_AspectRatio: 1
  m_ShapeRadius: 0.025
  m_SoftnessScale: 1
  m_UseCustomSpotLightShadowCone: 0
  m_CustomSpotLightShadowCone: 30
  m_MaxSmoothness: 0.99
  m_ApplyRangeAttenuation: 1
  m_DisplayAreaLightEmissiveMesh: 0
  m_AreaLightCookie: {fileID: 0}
  m_IESPoint: {fileID: 0}
  m_IESSpot: {fileID: 0}
  m_IncludeForRayTracing: 1
  m_AreaLightShadowCone: 120
  m_UseScreenSpaceShadows: 0
  m_InteractsWithSky: 1
  m_AngularDiameter: 0.5
  m_FlareSize: 2
  m_FlareTint: {r: 1, g: 1, b: 1, a: 1}
  m_FlareFalloff: 4
  m_SurfaceTexture: {fileID: 0}
  m_SurfaceTint: {r: 1, g: 1, b: 1, a: 1}
  m_Distance: 1.5e+11
  m_UseRayTracedShadows: 0
  m_NumRayTracingSamples: 4
  m_FilterTracedShadow: 1
  m_FilterSizeTraced: 16
  m_SunLightConeAngle: 0.5
  m_LightShadowRadius: 0.5
  m_SemiTransparentShadow: 0
  m_ColorShadow: 1
  m_DistanceBasedFiltering: 0
  m_EvsmExponent: 15
  m_EvsmLightLeakBias: 0
  m_EvsmVarianceBias: 0.00001
  m_EvsmBlurPasses: 0
  m_LightlayersMask: 1
  m_LinkShadowLayers: 1
  m_ShadowNearPlane: 0.1
  m_BlockerSampleCount: 24
  m_FilterSampleCount: 16
  m_MinFilterSize: 0.1
  m_KernelSize: 5
  m_LightAngle: 1
  m_MaxDepthBias: 0.001
  m_ShadowResolution:
    m_Override: 512
    m_UseOverride: 1
    m_Level: 0
  m_ShadowDimmer: 1
  m_VolumetricShadowDimmer: 1
  m_ShadowFadeDistance: 10000
  m_UseContactShadow:
    m_Override: 0
    m_UseOverride: 1
    m_Level: 0
  m_RayTracedContactShadow: 0
  m_ShadowTint: {r: 0, g: 0, b: 0, a: 1}
  m_PenumbraTint: 0
  m_NormalBias: 0.75
  m_SlopeBias: 0.5
  m_ShadowUpdateMode: 0
  m_AlwaysDrawDynamicShadows: 0
  m_UpdateShadowOnLightMovement: 0
  m_CachedShadowTranslationThreshold: 0.01
  m_CachedShadowAngularThreshold: 0.5
  m_BarnDoorAngle: 90
  m_BarnDoorLength: 0.05
  m_preserveCachedShadow: 0
  m_ShadowCascadeRatios:
  - 0.05
  - 0.2
  - 0.3
  m_ShadowCascadeBorders:
  - 0.2
  - 0.2
  - 0.2
  - 0.2
  m_ShadowAlgorithm: 0
  m_ShadowVariant: 0
  m_ShadowPrecision: 0
  useOldInspector: 0
  useVolumetric: 1
  featuresFoldout: 1
  showAdditionalSettings: 0
  m_AreaLightEmissiveMeshShadowCastingMode: 0
  m_AreaLightEmissiveMeshMotionVectorGenerationMode: 0
  m_AreaLightEmissiveMeshLayer: -1
--- !u!114 &876280723
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 9181194117633850171}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 7a68c43fe1f2a47cfa234b5eeaa98012, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Version: 11
  m_ObsoleteShadowResolutionTier: 1
  m_ObsoleteUseShadowQualitySettings: 0
  m_ObsoleteCustomShadowResolution: 512
  m_ObsoleteContactShadows: 0
  m_PointlightHDType: 0
  m_SpotLightShape: 0
  m_AreaLightShape: 0
  m_Intensity: 600
  m_EnableSpotReflector: 0
  m_LuxAtDistance: 1
  m_InnerSpotPercent: 0
  m_SpotIESCutoffPercent: 100
  m_LightDimmer: 1
  m_VolumetricDimmer: 1
  m_LightUnit: 0
  m_FadeDistance: 10000
  m_VolumetricFadeDistance: 10000
  m_AffectDiffuse: 1
  m_AffectSpecular: 1
  m_NonLightmappedOnly: 0
  m_ShapeWidth: 0.5
  m_ShapeHeight: 0.5
  m_AspectRatio: 1
  m_ShapeRadius: 0.025
  m_SoftnessScale: 1
  m_UseCustomSpotLightShadowCone: 0
  m_CustomSpotLightShadowCone: 30
  m_MaxSmoothness: 0.99
  m_ApplyRangeAttenuation: 1
  m_DisplayAreaLightEmissiveMesh: 0
  m_AreaLightCookie: {fileID: 0}
  m_IESPoint: {fileID: 0}
  m_IESSpot: {fileID: 0}
  m_IncludeForRayTracing: 1
  m_AreaLightShadowCone: 120
  m_UseScreenSpaceShadows: 0
  m_InteractsWithSky: 1
  m_AngularDiameter: 0.5
  m_FlareSize: 2
  m_FlareTint: {r: 1, g: 1, b: 1, a: 1}
  m_FlareFalloff: 4
  m_SurfaceTexture: {fileID: 0}
  m_SurfaceTint: {r: 1, g: 1, b: 1, a: 1}
  m_Distance: 1.5e+11
  m_UseRayTracedShadows: 0
  m_NumRayTracingSamples: 4
  m_FilterTracedShadow: 1
  m_FilterSizeTraced: 16
  m_SunLightConeAngle: 0.5
  m_LightShadowRadius: 0.5
  m_SemiTransparentShadow: 0
  m_ColorShadow: 1
  m_DistanceBasedFiltering: 0
  m_EvsmExponent: 15
  m_EvsmLightLeakBias: 0
  m_EvsmVarianceBias: 0.00001
  m_EvsmBlurPasses: 0
  m_LightlayersMask: 1
  m_LinkShadowLayers: 1
  m_ShadowNearPlane: 0.1
  m_BlockerSampleCount: 24
  m_FilterSampleCount: 16
  m_MinFilterSize: 0.1
  m_KernelSize: 5
  m_LightAngle: 1
  m_MaxDepthBias: 0.001
  m_ShadowResolution:
    m_Override: 512
    m_UseOverride: 1
    m_Level: 0
  m_ShadowDimmer: 1
  m_VolumetricShadowDimmer: 1
  m_ShadowFadeDistance: 10000
  m_UseContactShadow:
    m_Override: 0
    m_UseOverride: 1
    m_Level: 0
  m_RayTracedContactShadow: 0
  m_ShadowTint: {r: 0, g: 0, b: 0, a: 1}
  m_PenumbraTint: 0
  m_NormalBias: 0.75
  m_SlopeBias: 0.5
  m_ShadowUpdateMode: 0
  m_AlwaysDrawDynamicShadows: 0
  m_UpdateShadowOnLightMovement: 0
  m_CachedShadowTranslationThreshold: 0.01
  m_CachedShadowAngularThreshold: 0.5
  m_BarnDoorAngle: 90
  m_BarnDoorLength: 0.05
  m_preserveCachedShadow: 0
  m_ShadowCascadeRatios:
  - 0.05
  - 0.2
  - 0.3
  m_ShadowCascadeBorders:
  - 0.2
  - 0.2
  - 0.2
  - 0.2
  m_ShadowAlgorithm: 0
  m_ShadowVariant: 0
  m_ShadowPrecision: 0
  useOldInspector: 0
  useVolumetric: 1
  featuresFoldout: 1
  showAdditionalSettings: 0
  m_AreaLightEmissiveMeshShadowCastingMode: 0
  m_AreaLightEmissiveMeshMotionVectorGenerationMode: 0
  m_AreaLightEmissiveMeshLayer: -1
--- !u!114 &876280717
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 9181194117690164184}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 7a68c43fe1f2a47cfa234b5eeaa98012, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Version: 11
  m_ObsoleteShadowResolutionTier: 1
  m_ObsoleteUseShadowQualitySettings: 0
  m_ObsoleteCustomShadowResolution: 512
  m_ObsoleteContactShadows: 0
  m_PointlightHDType: 0
  m_SpotLightShape: 0
  m_AreaLightShape: 0
  m_Intensity: 600
  m_EnableSpotReflector: 0
  m_LuxAtDistance: 1
  m_InnerSpotPercent: 0
  m_SpotIESCutoffPercent: 100
  m_LightDimmer: 1
  m_VolumetricDimmer: 1
  m_LightUnit: 0
  m_FadeDistance: 10000
  m_VolumetricFadeDistance: 10000
  m_AffectDiffuse: 1
  m_AffectSpecular: 1
  m_NonLightmappedOnly: 0
  m_ShapeWidth: 0.5
  m_ShapeHeight: 0.5
  m_AspectRatio: 1
  m_ShapeRadius: 0.025
  m_SoftnessScale: 1
  m_UseCustomSpotLightShadowCone: 0
  m_CustomSpotLightShadowCone: 30
  m_MaxSmoothness: 0.99
  m_ApplyRangeAttenuation: 1
  m_DisplayAreaLightEmissiveMesh: 0
  m_AreaLightCookie: {fileID: 0}
  m_IESPoint: {fileID: 0}
  m_IESSpot: {fileID: 0}
  m_IncludeForRayTracing: 1
  m_AreaLightShadowCone: 120
  m_UseScreenSpaceShadows: 0
  m_InteractsWithSky: 1
  m_AngularDiameter: 0.5
  m_FlareSize: 2
  m_FlareTint: {r: 1, g: 1, b: 1, a: 1}
  m_FlareFalloff: 4
  m_SurfaceTexture: {fileID: 0}
  m_SurfaceTint: {r: 1, g: 1, b: 1, a: 1}
  m_Distance: 1.5e+11
  m_UseRayTracedShadows: 0
  m_NumRayTracingSamples: 4
  m_FilterTracedShadow: 1
  m_FilterSizeTraced: 16
  m_SunLightConeAngle: 0.5
  m_LightShadowRadius: 0.5
  m_SemiTransparentShadow: 0
  m_ColorShadow: 1
  m_DistanceBasedFiltering: 0
  m_EvsmExponent: 15
  m_EvsmLightLeakBias: 0
  m_EvsmVarianceBias: 0.00001
  m_EvsmBlurPasses: 0
  m_LightlayersMask: 1
  m_LinkShadowLayers: 1
  m_ShadowNearPlane: 0.1
  m_BlockerSampleCount: 24
  m_FilterSampleCount: 16
  m_MinFilterSize: 0.1
  m_KernelSize: 5
  m_LightAngle: 1
  m_MaxDepthBias: 0.001
  m_ShadowResolution:
    m_Override: 512
    m_UseOverride: 1
    m_Level: 0
  m_ShadowDimmer: 1
  m_VolumetricShadowDimmer: 1
  m_ShadowFadeDistance: 10000
  m_UseContactShadow:
    m_Override: 0
    m_UseOverride: 1
    m_Level: 0
  m_RayTracedContactShadow: 0
  m_ShadowTint: {r: 0, g: 0, b: 0, a: 1}
  m_PenumbraTint: 0
  m_NormalBias: 0.75
  m_SlopeBias: 0.5
  m_ShadowUpdateMode: 0
  m_AlwaysDrawDynamicShadows: 0
  m_UpdateShadowOnLightMovement: 0
  m_CachedShadowTranslationThreshold: 0.01
  m_CachedShadowAngularThreshold: 0.5
  m_BarnDoorAngle: 90
  m_BarnDoorLength: 0.05
  m_preserveCachedShadow: 0
  m_ShadowCascadeRatios:
  - 0.05
  - 0.2
  - 0.3
  m_ShadowCascadeBorders:
  - 0.2
  - 0.2
  - 0.2
  - 0.2
  m_ShadowAlgorithm: 0
  m_ShadowVariant: 0
  m_ShadowPrecision: 0
  useOldInspector: 0
  useVolumetric: 1
  featuresFoldout: 1
  showAdditionalSettings: 0
  m_AreaLightEmissiveMeshShadowCastingMode: 0
  m_AreaLightEmissiveMeshMotionVectorGenerationMode: 0
  m_AreaLightEmissiveMeshLayer: -1
--- !u!1001 &8884110482237446214
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 297400364091726721, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_Intensity
      value: 47.746483
      objectReference: {fileID: 0}
    - target: {fileID: 297400364136588128, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_Intensity
      value: 47.746483
      objectReference: {fileID: 0}
    - target: {fileID: 297400364489881684, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_Intensity
      value: 47.746483
      objectReference: {fileID: 0}
    - target: {fileID: 297400364496499658, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_Intensity
      value: 3.1415927
      objectReference: {fileID: 0}
    - target: {fileID: 297400364496499658, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_AreaSize.x
      value: 0.5
      objectReference: {fileID: 0}
    - target: {fileID: 297400364496499658, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_AreaSize.y
      value: 0.5
      objectReference: {fileID: 0}
    - target: {fileID: 297400365269625772, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_Intensity
      value: 47.746483
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_RootOrder
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalPosition.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalRotation.w
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalRotation.x
      value: -0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalRotation.y
      value: -0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalRotation.z
      value: -0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 8270402660517999592, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_Name
      value: Lights_HDRP
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
--- !u!1 &9181194116215925647 stripped
GameObject:
  m_CorrespondingSourceObject: {fileID: 297400364496499657, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
  m_PrefabInstance: {fileID: 8884110482237446214}
  m_PrefabAsset: {fileID: 0}
--- !u!1 &9181194116516672495 stripped
GameObject:
  m_CorrespondingSourceObject: {fileID: 297400365269625769, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
  m_PrefabInstance: {fileID: 8884110482237446214}
  m_PrefabAsset: {fileID: 0}
--- !u!1 &9181194117690164184 stripped
GameObject:
  m_CorrespondingSourceObject: {fileID: 297400364091726750, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
  m_PrefabInstance: {fileID: 8884110482237446214}
  m_PrefabAsset: {fileID: 0}
--- !u!1 &9181194116206944279 stripped
GameObject:
  m_CorrespondingSourceObject: {fileID: 297400364489881681, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
  m_PrefabInstance: {fileID: 8884110482237446214}
  m_PrefabAsset: {fileID: 0}
--- !u!1 &9181194117633850171 stripped
GameObject:
  m_CorrespondingSourceObject: {fileID: 297400364136588157, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
  m_PrefabInstance: {fileID: 8884110482237446214}
  m_PrefabAsset: {fileID: 0}

```

`Samples~/HairSample/Prefabs/Lights_HDRP.prefab.meta`:

```meta
fileFormatVersion: 2
guid: aa2b0f38cbcba7441a466b61973fcc8f
PrefabImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Prefabs/Lights_URP.prefab`:

```prefab
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1001 &1218032760090535411
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_RootOrder
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalPosition.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalRotation.w
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalRotation.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalRotation.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalRotation.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 8270402660517999592, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_Name
      value: Lights
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}

```

`Samples~/HairSample/Prefabs/Lights_URP.prefab.meta`:

```meta
fileFormatVersion: 2
guid: 2b394c264c59e084e8bef700ec3a3027
PrefabImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Profiles.meta`:

```meta
fileFormatVersion: 2
guid: c0d9acc7a8adb6940a76191438656b72
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Profiles/VolumeProfile_HDRP.asset`:

```asset
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &-3688828918237369320
MonoBehaviour:
  m_ObjectHideFlags: 3
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: bcf384b154398e341b6b29969c078198, type: 3}
  m_Name: MotionBlur
  m_EditorClassIdentifier: 
  active: 0
  m_AdvancedMode: 0
  quality:
    m_OverrideState: 0
    m_Value: 2
  intensity:
    m_OverrideState: 1
    m_Value: 1
    min: 0
  maximumVelocity:
    m_OverrideState: 0
    m_Value: 200
    min: 0
    max: 1500
  minimumVelocity:
    m_OverrideState: 0
    m_Value: 2
    min: 0
    max: 64
  cameraMotionBlur:
    m_OverrideState: 0
    m_Value: 1
  specialCameraClampMode:
    m_OverrideState: 0
    m_Value: 0
  cameraVelocityClamp:
    m_OverrideState: 0
    m_Value: 0.05
    min: 0
    max: 0.3
  cameraTranslationVelocityClamp:
    m_OverrideState: 0
    m_Value: 0.05
    min: 0
    max: 0.3
  cameraRotationVelocityClamp:
    m_OverrideState: 0
    m_Value: 0.03
    min: 0
    max: 0.2
  depthComparisonExtent:
    m_OverrideState: 0
    m_Value: 1
    min: 0
    max: 20
  m_SampleCount:
    m_OverrideState: 0
    m_Value: 12
    min: 2
--- !u!114 &-1622065639258195466
MonoBehaviour:
  m_ObjectHideFlags: 3
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 2d08ce26990eb1a4a9177b860541e702, type: 3}
  m_Name: Exposure
  m_EditorClassIdentifier: 
  active: 1
  m_AdvancedMode: 0
  mode:
    m_OverrideState: 1
    m_Value: 0
  meteringMode:
    m_OverrideState: 0
    m_Value: 2
  luminanceSource:
    m_OverrideState: 0
    m_Value: 1
  fixedExposure:
    m_OverrideState: 0
    m_Value: 0.11
  compensation:
    m_OverrideState: 0
    m_Value: 0
  limitMin:
    m_OverrideState: 0
    m_Value: -10
  limitMax:
    m_OverrideState: 0
    m_Value: 20
  curveMap:
    m_OverrideState: 0
    m_Value:
      serializedVersion: 2
      m_Curve:
      - serializedVersion: 3
        time: -10
        value: -10
        inSlope: 0
        outSlope: 1
        tangentMode: 0
        weightedMode: 0
        inWeight: 0
        outWeight: 0
      - serializedVersion: 3
        time: 20
        value: 20
        inSlope: 1
        outSlope: 0
        tangentMode: 0
        weightedMode: 0
        inWeight: 0
        outWeight: 0
      m_PreInfinity: 2
      m_PostInfinity: 2
      m_RotationOrder: 4
  limitMinCurveMap:
    m_OverrideState: 0
    m_Value:
      serializedVersion: 2
      m_Curve:
      - serializedVersion: 3
        time: -10
        value: -12
        inSlope: 0
        outSlope: 1
        tangentMode: 0
        weightedMode: 0
        inWeight: 0
        outWeight: 0
      - serializedVersion: 3
        time: 20
        value: 18
        inSlope: 1
        outSlope: 0
        tangentMode: 0
        weightedMode: 0
        inWeight: 0
        outWeight: 0
      m_PreInfinity: 2
      m_PostInfinity: 2
      m_RotationOrder: 4
  limitMaxCurveMap:
    m_OverrideState: 0
    m_Value:
      serializedVersion: 2
      m_Curve:
      - serializedVersion: 3
        time: -10
        value: -8
        inSlope: 0
        outSlope: 1
        tangentMode: 0
        weightedMode: 0
        inWeight: 0
        outWeight: 0
      - serializedVersion: 3
        time: 20
        value: 22
        inSlope: 1
        outSlope: 0
        tangentMode: 0
        weightedMode: 0
        inWeight: 0
        outWeight: 0
      m_PreInfinity: 2
      m_PostInfinity: 2
      m_RotationOrder: 4
  adaptationMode:
    m_OverrideState: 0
    m_Value: 1
  adaptationSpeedDarkToLight:
    m_OverrideState: 0
    m_Value: 3
    min: 0.001
  adaptationSpeedLightToDark:
    m_OverrideState: 0
    m_Value: 1
    min: 0.001
  weightTextureMask:
    m_OverrideState: 0
    m_Value: {fileID: 0}
  histogramPercentages:
    m_OverrideState: 0
    m_Value: {x: 40, y: 90}
    min: 0
    max: 100
  histogramUseCurveRemapping:
    m_OverrideState: 0
    m_Value: 0
  targetMidGray:
    m_OverrideState: 0
    m_Value: 0
  centerAroundExposureTarget:
    m_OverrideState: 0
    m_Value: 0
  proceduralCenter:
    m_OverrideState: 0
    m_Value: {x: 0.5, y: 0.5}
  proceduralRadii:
    m_OverrideState: 0
    m_Value: {x: 0.3, y: 0.3}
  maskMinIntensity:
    m_OverrideState: 0
    m_Value: -30
  maskMaxIntensity:
    m_OverrideState: 0
    m_Value: 30
  proceduralSoftness:
    m_OverrideState: 0
    m_Value: 0.5
    min: 0
--- !u!114 &-496575378058219023
MonoBehaviour:
  m_ObjectHideFlags: 3
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a81bcacc415a1f743bfdf703afc52027, type: 3}
  m_Name: GradientSky
  m_EditorClassIdentifier: 
  active: 1
  m_AdvancedMode: 0
  rotation:
    m_OverrideState: 0
    m_Value: 0
    min: 0
    max: 360
  skyIntensityMode:
    m_OverrideState: 1
    m_Value: 0
  exposure:
    m_OverrideState: 1
    m_Value: -1.5
  multiplier:
    m_OverrideState: 1
    m_Value: 26.18
    min: 0
  upperHemisphereLuxValue:
    m_OverrideState: 0
    m_Value: 1
    min: 0
  upperHemisphereLuxColor:
    m_OverrideState: 0
    m_Value: {x: 0, y: 0, z: 0}
  desiredLuxValue:
    m_OverrideState: 0
    m_Value: 20000
  updateMode:
    m_OverrideState: 0
    m_Value: 0
  updatePeriod:
    m_OverrideState: 0
    m_Value: 0
    min: 0
  includeSunInBaking:
    m_OverrideState: 0
    m_Value: 0
  top:
    m_OverrideState: 1
    m_Value: {r: 1, g: 0, b: 0, a: 1}
    hdr: 1
    showAlpha: 0
    showEyeDropper: 1
  middle:
    m_OverrideState: 1
    m_Value: {r: 1, g: 0.7537085, b: 0.2980392, a: 1}
    hdr: 1
    showAlpha: 0
    showEyeDropper: 1
  bottom:
    m_OverrideState: 1
    m_Value: {r: 0, g: 1, b: 0.95832705, a: 1}
    hdr: 1
    showAlpha: 0
    showEyeDropper: 1
  gradientDiffusion:
    m_OverrideState: 0
    m_Value: -0.98
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: d7fd9488000d3734a9e00ee676215985, type: 3}
  m_Name: VolumeProfile_HDRP
  m_EditorClassIdentifier: 
  components:
  - {fileID: -3688828918237369320}
  - {fileID: -496575378058219023}
  - {fileID: 6974059576867971045}
  - {fileID: -1622065639258195466}
  - {fileID: 6095410644738775737}
--- !u!114 &6095410644738775737
MonoBehaviour:
  m_ObjectHideFlags: 3
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 953beb541740ddc499d005ee80c9ff29, type: 3}
  m_Name: Fog
  m_EditorClassIdentifier: 
  active: 1
  m_AdvancedMode: 0
  quality:
    m_OverrideState: 0
    m_Value: 1
  enabled:
    m_OverrideState: 1
    m_Value: 1
  colorMode:
    m_OverrideState: 0
    m_Value: 1
  color:
    m_OverrideState: 1
    m_Value: {r: 0, g: 0, b: 0, a: 1}
    hdr: 1
    showAlpha: 0
    showEyeDropper: 1
  tint:
    m_OverrideState: 0
    m_Value: {r: 1, g: 1, b: 1, a: 1}
    hdr: 1
    showAlpha: 0
    showEyeDropper: 1
  maxFogDistance:
    m_OverrideState: 1
    m_Value: 5000
    min: 0
  mipFogMaxMip:
    m_OverrideState: 0
    m_Value: 0.5
    min: 0
    max: 1
  mipFogNear:
    m_OverrideState: 0
    m_Value: 0
    min: 0
  mipFogFar:
    m_OverrideState: 0
    m_Value: 1000
    min: 0
  baseHeight:
    m_OverrideState: 0
    m_Value: 0
  maximumHeight:
    m_OverrideState: 0
    m_Value: 50
  meanFreePath:
    m_OverrideState: 1
    m_Value: 97.5
    min: 1
  enableVolumetricFog:
    m_OverrideState: 1
    m_Value: 1
  albedo:
    m_OverrideState: 0
    m_Value: {r: 1, g: 1, b: 1, a: 1}
    hdr: 0
    showAlpha: 1
    showEyeDropper: 1
  globalLightProbeDimmer:
    m_OverrideState: 0
    m_Value: 1
    min: 0
    max: 1
  depthExtent:
    m_OverrideState: 0
    m_Value: 64
    min: 0.1
  denoisingMode:
    m_OverrideState: 0
    m_Value: 2
  anisotropy:
    m_OverrideState: 0
    m_Value: 0
    min: -1
    max: 1
  sliceDistributionUniformity:
    m_OverrideState: 0
    m_Value: 0.75
    min: 0
    max: 1
  m_FogControlMode:
    m_OverrideState: 0
    m_Value: 0
  screenResolutionPercentage:
    m_OverrideState: 0
    m_Value: 12.5
    min: 6.25
    max: 100
  volumeSliceCount:
    m_OverrideState: 0
    m_Value: 64
    min: 1
    max: 1024
  m_VolumetricFogBudget:
    m_OverrideState: 0
    m_Value: 0.33
    min: 0
    max: 1
  m_ResolutionDepthRatio:
    m_OverrideState: 0
    m_Value: 0.666
    min: 0
    max: 1
  directionalLightsOnly:
    m_OverrideState: 0
    m_Value: 0
  filter:
    m_OverrideState: 0
    m_Value: 0
--- !u!114 &6974059576867971045
MonoBehaviour:
  m_ObjectHideFlags: 3
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 0d7593b3a9277ac4696b20006c21dde2, type: 3}
  m_Name: VisualEnvironment
  m_EditorClassIdentifier: 
  active: 1
  m_AdvancedMode: 0
  skyType:
    m_OverrideState: 1
    m_Value: 3
  skyAmbientMode:
    m_OverrideState: 0
    m_Value: 1
  fogType:
    m_OverrideState: 0
    m_Value: 0

```

`Samples~/HairSample/Profiles/VolumeProfile_HDRP.asset.meta`:

```meta
fileFormatVersion: 2
guid: a4a8e754c7d994940a91f588a736b4c4
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Profiles/VolumeProfile_URP.asset`:

```asset
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &-8355069246219174162
MonoBehaviour:
  m_ObjectHideFlags: 3
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 953beb541740ddc499d005ee80c9ff29, type: 3}
  m_Name: Fog
  m_EditorClassIdentifier: 
  active: 1
  m_AdvancedMode: 0
  quality:
    m_OverrideState: 0
    m_Value: 1
  enabled:
    m_OverrideState: 0
    m_Value: 0
  colorMode:
    m_OverrideState: 0
    m_Value: 1
  color:
    m_OverrideState: 0
    m_Value: {r: 0.5, g: 0.5, b: 0.5, a: 1}
    hdr: 1
    showAlpha: 0
    showEyeDropper: 1
  tint:
    m_OverrideState: 0
    m_Value: {r: 1, g: 1, b: 1, a: 1}
    hdr: 1
    showAlpha: 0
    showEyeDropper: 1
  maxFogDistance:
    m_OverrideState: 0
    m_Value: 5000
    min: 0
  mipFogMaxMip:
    m_OverrideState: 0
    m_Value: 0.5
    min: 0
    max: 1
  mipFogNear:
    m_OverrideState: 0
    m_Value: 0
    min: 0
  mipFogFar:
    m_OverrideState: 0
    m_Value: 1000
    min: 0
  baseHeight:
    m_OverrideState: 0
    m_Value: 0
  maximumHeight:
    m_OverrideState: 0
    m_Value: 50
  meanFreePath:
    m_OverrideState: 0
    m_Value: 400
    min: 1
  enableVolumetricFog:
    m_OverrideState: 0
    m_Value: 0
  albedo:
    m_OverrideState: 0
    m_Value: {r: 1, g: 1, b: 1, a: 1}
    hdr: 0
    showAlpha: 1
    showEyeDropper: 1
  globalLightProbeDimmer:
    m_OverrideState: 0
    m_Value: 1
    min: 0
    max: 1
  depthExtent:
    m_OverrideState: 0
    m_Value: 64
    min: 0.1
  denoisingMode:
    m_OverrideState: 0
    m_Value: 2
  anisotropy:
    m_OverrideState: 0
    m_Value: 0
    min: -1
    max: 1
  sliceDistributionUniformity:
    m_OverrideState: 0
    m_Value: 0.75
    min: 0
    max: 1
  m_FogControlMode:
    m_OverrideState: 0
    m_Value: 0
  screenResolutionPercentage:
    m_OverrideState: 0
    m_Value: 12.5
    min: 6.25
    max: 50
  volumeSliceCount:
    m_OverrideState: 0
    m_Value: 64
    min: 1
    max: 512
  m_VolumetricFogBudget:
    m_OverrideState: 0
    m_Value: 0.25
    min: 0
    max: 1
  m_ResolutionDepthRatio:
    m_OverrideState: 0
    m_Value: 0.5
    min: 0
    max: 1
  directionalLightsOnly:
    m_OverrideState: 0
    m_Value: 0
  filter:
    m_OverrideState: 0
    m_Value: 0
--- !u!114 &-7210520465697480128
MonoBehaviour:
  m_ObjectHideFlags: 3
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 953beb541740ddc499d005ee80c9ff29, type: 3}
  m_Name: Fog
  m_EditorClassIdentifier: 
  active: 1
  m_AdvancedMode: 0
  quality:
    m_OverrideState: 0
    m_Value: 1
  enabled:
    m_OverrideState: 0
    m_Value: 0
  colorMode:
    m_OverrideState: 0
    m_Value: 1
  color:
    m_OverrideState: 0
    m_Value: {r: 0.5, g: 0.5, b: 0.5, a: 1}
    hdr: 1
    showAlpha: 0
    showEyeDropper: 1
  tint:
    m_OverrideState: 0
    m_Value: {r: 1, g: 1, b: 1, a: 1}
    hdr: 1
    showAlpha: 0
    showEyeDropper: 1
  maxFogDistance:
    m_OverrideState: 0
    m_Value: 5000
    min: 0
  mipFogMaxMip:
    m_OverrideState: 0
    m_Value: 0.5
    min: 0
    max: 1
  mipFogNear:
    m_OverrideState: 0
    m_Value: 0
    min: 0
  mipFogFar:
    m_OverrideState: 0
    m_Value: 1000
    min: 0
  baseHeight:
    m_OverrideState: 0
    m_Value: 0
  maximumHeight:
    m_OverrideState: 0
    m_Value: 50
  meanFreePath:
    m_OverrideState: 0
    m_Value: 400
    min: 1
  enableVolumetricFog:
    m_OverrideState: 0
    m_Value: 0
  albedo:
    m_OverrideState: 0
    m_Value: {r: 1, g: 1, b: 1, a: 1}
    hdr: 0
    showAlpha: 1
    showEyeDropper: 1
  globalLightProbeDimmer:
    m_OverrideState: 0
    m_Value: 1
    min: 0
    max: 1
  depthExtent:
    m_OverrideState: 0
    m_Value: 64
    min: 0.1
  denoisingMode:
    m_OverrideState: 0
    m_Value: 2
  anisotropy:
    m_OverrideState: 0
    m_Value: 0
    min: -1
    max: 1
  sliceDistributionUniformity:
    m_OverrideState: 0
    m_Value: 0.75
    min: 0
    max: 1
  m_FogControlMode:
    m_OverrideState: 0
    m_Value: 0
  screenResolutionPercentage:
    m_OverrideState: 0
    m_Value: 12.5
    min: 6.25
    max: 50
  volumeSliceCount:
    m_OverrideState: 0
    m_Value: 64
    min: 1
    max: 512
  m_VolumetricFogBudget:
    m_OverrideState: 0
    m_Value: 0.25
    min: 0
    max: 1
  m_ResolutionDepthRatio:
    m_OverrideState: 0
    m_Value: 0.5
    min: 0
    max: 1
  directionalLightsOnly:
    m_OverrideState: 0
    m_Value: 0
  filter:
    m_OverrideState: 0
    m_Value: 0
--- !u!114 &-2960115604230813497
MonoBehaviour:
  m_ObjectHideFlags: 3
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 953beb541740ddc499d005ee80c9ff29, type: 3}
  m_Name: Fog
  m_EditorClassIdentifier: 
  active: 1
  m_AdvancedMode: 0
  quality:
    m_OverrideState: 0
    m_Value: 1
  enabled:
    m_OverrideState: 0
    m_Value: 0
  colorMode:
    m_OverrideState: 0
    m_Value: 1
  color:
    m_OverrideState: 0
    m_Value: {r: 0.5, g: 0.5, b: 0.5, a: 1}
    hdr: 1
    showAlpha: 0
    showEyeDropper: 1
  tint:
    m_OverrideState: 0
    m_Value: {r: 1, g: 1, b: 1, a: 1}
    hdr: 1
    showAlpha: 0
    showEyeDropper: 1
  maxFogDistance:
    m_OverrideState: 0
    m_Value: 5000
    min: 0
  mipFogMaxMip:
    m_OverrideState: 0
    m_Value: 0.5
    min: 0
    max: 1
  mipFogNear:
    m_OverrideState: 0
    m_Value: 0
    min: 0
  mipFogFar:
    m_OverrideState: 0
    m_Value: 1000
    min: 0
  baseHeight:
    m_OverrideState: 0
    m_Value: 0
  maximumHeight:
    m_OverrideState: 0
    m_Value: 50
  meanFreePath:
    m_OverrideState: 0
    m_Value: 400
    min: 1
  enableVolumetricFog:
    m_OverrideState: 0
    m_Value: 0
  albedo:
    m_OverrideState: 0
    m_Value: {r: 1, g: 1, b: 1, a: 1}
    hdr: 0
    showAlpha: 1
    showEyeDropper: 1
  globalLightProbeDimmer:
    m_OverrideState: 0
    m_Value: 1
    min: 0
    max: 1
  depthExtent:
    m_OverrideState: 0
    m_Value: 64
    min: 0.1
  denoisingMode:
    m_OverrideState: 0
    m_Value: 2
  anisotropy:
    m_OverrideState: 0
    m_Value: 0
    min: -1
    max: 1
  sliceDistributionUniformity:
    m_OverrideState: 0
    m_Value: 0.75
    min: 0
    max: 1
  m_FogControlMode:
    m_OverrideState: 0
    m_Value: 0
  screenResolutionPercentage:
    m_OverrideState: 0
    m_Value: 12.5
    min: 6.25
    max: 50
  volumeSliceCount:
    m_OverrideState: 0
    m_Value: 64
    min: 1
    max: 512
  m_VolumetricFogBudget:
    m_OverrideState: 0
    m_Value: 0.25
    min: 0
    max: 1
  m_ResolutionDepthRatio:
    m_OverrideState: 0
    m_Value: 0.5
    min: 0
    max: 1
  directionalLightsOnly:
    m_OverrideState: 0
    m_Value: 0
  filter:
    m_OverrideState: 0
    m_Value: 0
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: d7fd9488000d3734a9e00ee676215985, type: 3}
  m_Name: VolumeProfile_URP
  m_EditorClassIdentifier: 
  components: []
--- !u!114 &2897187614850466217
MonoBehaviour:
  m_ObjectHideFlags: 3
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 953beb541740ddc499d005ee80c9ff29, type: 3}
  m_Name: Fog
  m_EditorClassIdentifier: 
  active: 1
  m_AdvancedMode: 0
  quality:
    m_OverrideState: 0
    m_Value: 1
  enabled:
    m_OverrideState: 0
    m_Value: 0
  colorMode:
    m_OverrideState: 0
    m_Value: 1
  color:
    m_OverrideState: 0
    m_Value: {r: 0.5, g: 0.5, b: 0.5, a: 1}
    hdr: 1
    showAlpha: 0
    showEyeDropper: 1
  tint:
    m_OverrideState: 0
    m_Value: {r: 1, g: 1, b: 1, a: 1}
    hdr: 1
    showAlpha: 0
    showEyeDropper: 1
  maxFogDistance:
    m_OverrideState: 0
    m_Value: 5000
    min: 0
  mipFogMaxMip:
    m_OverrideState: 0
    m_Value: 0.5
    min: 0
    max: 1
  mipFogNear:
    m_OverrideState: 0
    m_Value: 0
    min: 0
  mipFogFar:
    m_OverrideState: 0
    m_Value: 1000
    min: 0
  baseHeight:
    m_OverrideState: 0
    m_Value: 0
  maximumHeight:
    m_OverrideState: 0
    m_Value: 50
  meanFreePath:
    m_OverrideState: 0
    m_Value: 400
    min: 1
  enableVolumetricFog:
    m_OverrideState: 0
    m_Value: 0
  albedo:
    m_OverrideState: 0
    m_Value: {r: 1, g: 1, b: 1, a: 1}
    hdr: 0
    showAlpha: 1
    showEyeDropper: 1
  globalLightProbeDimmer:
    m_OverrideState: 0
    m_Value: 1
    min: 0
    max: 1
  depthExtent:
    m_OverrideState: 0
    m_Value: 64
    min: 0.1
  denoisingMode:
    m_OverrideState: 0
    m_Value: 2
  anisotropy:
    m_OverrideState: 0
    m_Value: 0
    min: -1
    max: 1
  sliceDistributionUniformity:
    m_OverrideState: 0
    m_Value: 0.75
    min: 0
    max: 1
  m_FogControlMode:
    m_OverrideState: 0
    m_Value: 0
  screenResolutionPercentage:
    m_OverrideState: 0
    m_Value: 12.5
    min: 6.25
    max: 50
  volumeSliceCount:
    m_OverrideState: 0
    m_Value: 64
    min: 1
    max: 512
  m_VolumetricFogBudget:
    m_OverrideState: 0
    m_Value: 0.25
    min: 0
    max: 1
  m_ResolutionDepthRatio:
    m_OverrideState: 0
    m_Value: 0.5
    min: 0
    max: 1
  directionalLightsOnly:
    m_OverrideState: 0
    m_Value: 0
  filter:
    m_OverrideState: 0
    m_Value: 0

```

`Samples~/HairSample/Profiles/VolumeProfile_URP.asset.meta`:

```meta
fileFormatVersion: 2
guid: 71f811389c245fe48b2dfb7b39ba9cd1
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Providers.meta`:

```meta
fileFormatVersion: 2
guid: 2ee444c826a77074e9a10a27a476d590
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Providers/SineWave1D.asset`:

```asset
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 3538844661ff9d149a8da7210a37d2f1, type: 3}
  m_Name: SineWave1D
  m_EditorClassIdentifier: 
  amplitude: 0.5
  frequency: 1
  duration: 2
  phase: 0

```

`Samples~/HairSample/Providers/SineWave1D.asset.meta`:

```meta
fileFormatVersion: 2
guid: d869298448776534e996976012b98b05
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Providers/SineWave1D.cs`:

```cs
using UnityEngine;
using Unity.DemoTeam.Hair;

[CreateAssetMenu(menuName = "Hair/Custom Placement/SineWave1D")]
public class SineWave1D : HairAssetCustomPlacement
{
	public float amplitude = 0.5f;
	public float frequency = 1.0f;
	public float duration = 2.0f;
	public float phase = 0.0f;

	public override bool GenerateRoots(in HairAssetProvisional.ProceduralRoots roots)
	{
		var step = 1.0f / (roots.strandCount - 1);
		var stepA = step * frequency * 2.0f * Mathf.PI;
		var offsetA = (0.5f * frequency + phase) * 2.0f * Mathf.PI;

		unsafe
		{
			roots.GetUnsafePtrs(out var rootPos, out var rootDir, out var rootUV0, out var rootVar);

			for (int i = 0; i != roots.strandCount; i++)
			{
				rootPos[i] = new Vector3(duration * ((step * i) - 0.5f), amplitude * Mathf.Sin(stepA * i - offsetA), 0.0f);
				rootDir[i] = Vector3.down;
				rootUV0[i] = new Vector2((step * i), 0.0f);
				rootVar[i] = HairAssetProvisional.ProceduralRoots.RootParameters.defaults;
			}
		}

		return true;// success
	}
}

```

`Samples~/HairSample/Providers/SineWave1D.cs.meta`:

```meta
fileFormatVersion: 2
guid: 3538844661ff9d149a8da7210a37d2f1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Scenes.meta`:

```meta
fileFormatVersion: 2
guid: 119276f942291324ea76d6ed54730879
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Scenes/HairSample_Builtin.unity`:

```unity
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!29 &1
OcclusionCullingSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_OcclusionBakeSettings:
    smallestOccluder: 5
    smallestHole: 0.25
    backfaceThreshold: 100
  m_SceneGUID: 00000000000000000000000000000000
  m_OcclusionCullingData: {fileID: 0}
--- !u!104 &2
RenderSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 9
  m_Fog: 1
  m_FogColor: {r: 0.23100002, g: 0.29700002, b: 0.12650001, a: 1}
  m_FogMode: 3
  m_FogDensity: 0.01
  m_LinearFogStart: 0
  m_LinearFogEnd: 300
  m_AmbientSkyColor: {r: 0.212, g: 0.227, b: 0.259, a: 1}
  m_AmbientEquatorColor: {r: 0.114, g: 0.125, b: 0.133, a: 1}
  m_AmbientGroundColor: {r: 0.047, g: 0.043, b: 0.035, a: 1}
  m_AmbientIntensity: 1
  m_AmbientMode: 0
  m_SubtractiveShadowColor: {r: 0.42, g: 0.478, b: 0.627, a: 1}
  m_SkyboxMaterial: {fileID: 2100000, guid: 37565627c08575c4bb329ed5a68bc511, type: 2}
  m_HaloStrength: 0.5
  m_FlareStrength: 1
  m_FlareFadeSpeed: 3
  m_HaloTexture: {fileID: 0}
  m_SpotCookie: {fileID: 10001, guid: 0000000000000000e000000000000000, type: 0}
  m_DefaultReflectionMode: 0
  m_DefaultReflectionResolution: 128
  m_ReflectionBounces: 1
  m_ReflectionIntensity: 1
  m_CustomReflection: {fileID: 0}
  m_Sun: {fileID: 5982689899449178246}
  m_IndirectSpecularColor: {r: 0, g: 0, b: 0, a: 1}
  m_UseRadianceAmbientProbe: 0
--- !u!157 &3
LightmapSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 12
  m_GIWorkflowMode: 1
  m_GISettings:
    serializedVersion: 2
    m_BounceScale: 1
    m_IndirectOutputScale: 1
    m_AlbedoBoost: 1
    m_EnvironmentLightingMode: 0
    m_EnableBakedLightmaps: 1
    m_EnableRealtimeLightmaps: 0
  m_LightmapEditorSettings:
    serializedVersion: 12
    m_Resolution: 2
    m_BakeResolution: 40
    m_AtlasSize: 1024
    m_AO: 0
    m_AOMaxDistance: 1
    m_CompAOExponent: 1
    m_CompAOExponentDirect: 0
    m_ExtractAmbientOcclusion: 0
    m_Padding: 2
    m_LightmapParameters: {fileID: 0}
    m_LightmapsBakeMode: 1
    m_TextureCompression: 1
    m_FinalGather: 0
    m_FinalGatherFiltering: 1
    m_FinalGatherRayCount: 256
    m_ReflectionCompression: 2
    m_MixedBakeMode: 2
    m_BakeBackend: 1
    m_PVRSampling: 1
    m_PVRDirectSampleCount: 32
    m_PVRSampleCount: 512
    m_PVRBounces: 2
    m_PVREnvironmentSampleCount: 256
    m_PVREnvironmentReferencePointCount: 2048
    m_PVRFilteringMode: 1
    m_PVRDenoiserTypeDirect: 1
    m_PVRDenoiserTypeIndirect: 1
    m_PVRDenoiserTypeAO: 1
    m_PVRFilterTypeDirect: 0
    m_PVRFilterTypeIndirect: 0
    m_PVRFilterTypeAO: 0
    m_PVREnvironmentMIS: 1
    m_PVRCulling: 1
    m_PVRFilteringGaussRadiusDirect: 1
    m_PVRFilteringGaussRadiusIndirect: 5
    m_PVRFilteringGaussRadiusAO: 2
    m_PVRFilteringAtrousPositionSigmaDirect: 0.5
    m_PVRFilteringAtrousPositionSigmaIndirect: 2
    m_PVRFilteringAtrousPositionSigmaAO: 1
    m_ExportTrainingData: 0
    m_TrainingDataDestination: TrainingData
    m_LightProbeSampleCountMultiplier: 4
  m_LightingDataAsset: {fileID: 0}
  m_LightingSettings: {fileID: 0}
--- !u!196 &4
NavMeshSettings:
  serializedVersion: 2
  m_ObjectHideFlags: 0
  m_BuildSettings:
    serializedVersion: 2
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.4
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    accuratePlacement: 0
    maxJobWorkers: 0
    preserveTilesOutsideBounds: 0
    debug:
      m_Flags: 0
  m_NavMeshData: {fileID: 0}
--- !u!1001 &1140757028
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 7510820715701891250, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_Name
      value: Boundaries
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_RootOrder
      value: 2
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalPosition.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalRotation.w
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalRotation.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalRotation.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalRotation.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7510820715701891251, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: 82ca5ad9930bff94b8bb66a60ccff66c, type: 3}
--- !u!1001 &1250198590
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 2034033869895580038, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_Name
      value: Hair
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_RootOrder
      value: 3
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalPosition.y
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalRotation.w
      value: 0.9723411
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalRotation.x
      value: -0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalRotation.y
      value: 0.23356526
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalRotation.z
      value: -0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 27.014
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033870785485706, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_Materials.Array.data[0]
      value: 
      objectReference: {fileID: 0}
    - target: {fileID: 2034033870785485707, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_Mesh
      value: 
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
--- !u!1001 &5127100956696949659
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_RootOrder
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalPosition.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalRotation.w
      value: 0.9070465
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalRotation.x
      value: 0.13464461
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalRotation.y
      value: 0.39459655
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalRotation.z
      value: -0.05857508
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 16.887
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 47.021
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770968, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7494141127162770975, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
      propertyPath: m_Name
      value: Camera
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: f6205044afc2bf74888d8020858b4c5b, type: 3}
--- !u!1001 &5982689899449178245
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_RootOrder
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalPosition.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalRotation.w
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalRotation.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalRotation.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalRotation.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2075889177198007447, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 8270402660517999592, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
      propertyPath: m_Name
      value: Lights
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
--- !u!108 &5982689899449178246 stripped
Light:
  m_CorrespondingSourceObject: {fileID: 297400364496499658, guid: c7912e2b6bcc5c8468290c1e54e1bd6d, type: 3}
  m_PrefabInstance: {fileID: 5982689899449178245}
  m_PrefabAsset: {fileID: 0}

```

`Samples~/HairSample/Scenes/HairSample_Builtin.unity.meta`:

```meta
fileFormatVersion: 2
guid: 596767a14da7dcd4ca6e2ed6a252d333
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Scenes/HairSample_HDRP.unity`:

```unity
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!29 &1
OcclusionCullingSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_OcclusionBakeSettings:
    smallestOccluder: 5
    smallestHole: 0.25
    backfaceThreshold: 100
  m_SceneGUID: 00000000000000000000000000000000
  m_OcclusionCullingData: {fileID: 0}
--- !u!104 &2
RenderSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 9
  m_Fog: 0
  m_FogColor: {r: 0.5, g: 0.5, b: 0.5, a: 1}
  m_FogMode: 3
  m_FogDensity: 0.01
  m_LinearFogStart: 0
  m_LinearFogEnd: 300
  m_AmbientSkyColor: {r: 0.212, g: 0.227, b: 0.259, a: 1}
  m_AmbientEquatorColor: {r: 0.114, g: 0.125, b: 0.133, a: 1}
  m_AmbientGroundColor: {r: 0.047, g: 0.043, b: 0.035, a: 1}
  m_AmbientIntensity: 1
  m_AmbientMode: 0
  m_SubtractiveShadowColor: {r: 0.42, g: 0.478, b: 0.627, a: 1}
  m_SkyboxMaterial: {fileID: 0}
  m_HaloStrength: 0.5
  m_FlareStrength: 1
  m_FlareFadeSpeed: 3
  m_HaloTexture: {fileID: 0}
  m_SpotCookie: {fileID: 10001, guid: 0000000000000000e000000000000000, type: 0}
  m_DefaultReflectionMode: 0
  m_DefaultReflectionResolution: 128
  m_ReflectionBounces: 1
  m_ReflectionIntensity: 1
  m_CustomReflection: {fileID: 0}
  m_Sun: {fileID: 0}
  m_IndirectSpecularColor: {r: 0, g: 0, b: 0, a: 1}
  m_UseRadianceAmbientProbe: 0
--- !u!157 &3
LightmapSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 12
  m_GIWorkflowMode: 1
  m_GISettings:
    serializedVersion: 2
    m_BounceScale: 1
    m_IndirectOutputScale: 1
    m_AlbedoBoost: 1
    m_EnvironmentLightingMode: 0
    m_EnableBakedLightmaps: 1
    m_EnableRealtimeLightmaps: 0
  m_LightmapEditorSettings:
    serializedVersion: 12
    m_Resolution: 2
    m_BakeResolution: 40
    m_AtlasSize: 1024
    m_AO: 0
    m_AOMaxDistance: 1
    m_CompAOExponent: 1
    m_CompAOExponentDirect: 0
    m_ExtractAmbientOcclusion: 0
    m_Padding: 2
    m_LightmapParameters: {fileID: 0}
    m_LightmapsBakeMode: 1
    m_TextureCompression: 1
    m_FinalGather: 0
    m_FinalGatherFiltering: 1
    m_FinalGatherRayCount: 256
    m_ReflectionCompression: 2
    m_MixedBakeMode: 2
    m_BakeBackend: 1
    m_PVRSampling: 1
    m_PVRDirectSampleCount: 32
    m_PVRSampleCount: 512
    m_PVRBounces: 2
    m_PVREnvironmentSampleCount: 256
    m_PVREnvironmentReferencePointCount: 2048
    m_PVRFilteringMode: 1
    m_PVRDenoiserTypeDirect: 1
    m_PVRDenoiserTypeIndirect: 1
    m_PVRDenoiserTypeAO: 1
    m_PVRFilterTypeDirect: 0
    m_PVRFilterTypeIndirect: 0
    m_PVRFilterTypeAO: 0
    m_PVREnvironmentMIS: 1
    m_PVRCulling: 1
    m_PVRFilteringGaussRadiusDirect: 1
    m_PVRFilteringGaussRadiusIndirect: 5
    m_PVRFilteringGaussRadiusAO: 2
    m_PVRFilteringAtrousPositionSigmaDirect: 0.5
    m_PVRFilteringAtrousPositionSigmaIndirect: 2
    m_PVRFilteringAtrousPositionSigmaAO: 1
    m_ExportTrainingData: 0
    m_TrainingDataDestination: TrainingData
    m_LightProbeSampleCountMultiplier: 4
  m_LightingDataAsset: {fileID: 0}
  m_LightingSettings: {fileID: 0}
--- !u!196 &4
NavMeshSettings:
  serializedVersion: 2
  m_ObjectHideFlags: 0
  m_BuildSettings:
    serializedVersion: 2
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.4
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    accuratePlacement: 0
    maxJobWorkers: 0
    preserveTilesOutsideBounds: 0
    debug:
      m_Flags: 0
  m_NavMeshData: {fileID: 0}
--- !u!1001 &459202537
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 2034033869895580038, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_Name
      value: Hair
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_RootOrder
      value: 3
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalPosition.y
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalRotation.w
      value: 0.9723415
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalRotation.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalRotation.y
      value: 0.23356412
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalRotation.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 27.014
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033870785485706, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_Materials.Array.data[0]
      value: 
      objectReference: {fileID: 0}
    - target: {fileID: 2034033870785485707, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_Mesh
      value: 
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
--- !u!1 &524724990
GameObject:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 524724992}
  - component: {fileID: 524724991}
  m_Layer: 0
  m_Name: StaticLightingSky
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!114 &524724991
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 524724990}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 441482e8936e35048a1dffac814e3ef8, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Profile: {fileID: 0}
  m_StaticLightingSkyUniqueID: 0
--- !u!4 &524724992
Transform:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 524724990}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 4
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!1001 &876280713
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 688184393969740718, guid: aa2b0f38cbcba7441a466b61973fcc8f, type: 3}
      propertyPath: m_Name
      value: Lights_HDRP
      objectReference: {fileID: 0}
    - target: {fileID: 7459572165162126545, guid: aa2b0f38cbcba7441a466b61973fcc8f, type: 3}
      propertyPath: m_RootOrder
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7459572165162126545, guid: aa2b0f38cbcba7441a466b61973fcc8f, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7459572165162126545, guid: aa2b0f38cbcba7441a466b61973fcc8f, type: 3}
      propertyPath: m_LocalPosition.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7459572165162126545, guid: aa2b0f38cbcba7441a466b61973fcc8f, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7459572165162126545, guid: aa2b0f38cbcba7441a466b61973fcc8f, type: 3}
      propertyPath: m_LocalRotation.w
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 7459572165162126545, guid: aa2b0f38cbcba7441a466b61973fcc8f, type: 3}
      propertyPath: m_LocalRotation.x
      value: -0
      objectReference: {fileID: 0}
    - target: {fileID: 7459572165162126545, guid: aa2b0f38cbcba7441a466b61973fcc8f, type: 3}
      propertyPath: m_LocalRotation.y
      value: -0
      objectReference: {fileID: 0}
    - target: {fileID: 7459572165162126545, guid: aa2b0f38cbcba7441a466b61973fcc8f, type: 3}
      propertyPath: m_LocalRotation.z
      value: -0
      objectReference: {fileID: 0}
    - target: {fileID: 7459572165162126545, guid: aa2b0f38cbcba7441a466b61973fcc8f, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7459572165162126545, guid: aa2b0f38cbcba7441a466b61973fcc8f, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7459572165162126545, guid: aa2b0f38cbcba7441a466b61973fcc8f, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 9181194116215925644, guid: aa2b0f38cbcba7441a466b61973fcc8f, type: 3}
      propertyPath: m_Intensity
      value: 3.141593
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: aa2b0f38cbcba7441a466b61973fcc8f, type: 3}
--- !u!1001 &1227295475
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 7811172989583810330, guid: e733d904bfa68ac449bd39236b4c8d72, type: 3}
      propertyPath: m_Name
      value: Camera_HDRP
      objectReference: {fileID: 0}
    - target: {fileID: 7811172989583810333, guid: e733d904bfa68ac449bd39236b4c8d72, type: 3}
      propertyPath: m_RootOrder
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 7811172989583810333, guid: e733d904bfa68ac449bd39236b4c8d72, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7811172989583810333, guid: e733d904bfa68ac449bd39236b4c8d72, type: 3}
      propertyPath: m_LocalPosition.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7811172989583810333, guid: e733d904bfa68ac449bd39236b4c8d72, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 7811172989583810333, guid: e733d904bfa68ac449bd39236b4c8d72, type: 3}
      propertyPath: m_LocalRotation.w
      value: 0.9070465
      objectReference: {fileID: 0}
    - target: {fileID: 7811172989583810333, guid: e733d904bfa68ac449bd39236b4c8d72, type: 3}
      propertyPath: m_LocalRotation.x
      value: 0.13464461
      objectReference: {fileID: 0}
    - target: {fileID: 7811172989583810333, guid: e733d904bfa68ac449bd39236b4c8d72, type: 3}
      propertyPath: m_LocalRotation.y
      value: 0.39459655
      objectReference: {fileID: 0}
    - target: {fileID: 7811172989583810333, guid: e733d904bfa68ac449bd39236b4c8d72, type: 3}
      propertyPath: m_LocalRotation.z
      value: -0.05857508
      objectReference: {fileID: 0}
    - target: {fileID: 7811172989583810333, guid: e733d904bfa68ac449bd39236b4c8d72, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 16.887
      objectReference: {fileID: 0}
    - target: {fileID: 7811172989583810333, guid: e733d904bfa68ac449bd39236b4c8d72, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 47.021
      objectReference: {fileID: 0}
    - target: {fileID: 7811172989583810333, guid: e733d904bfa68ac449bd39236b4c8d72, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: e733d904bfa68ac449bd39236b4c8d72, type: 3}
--- !u!1001 &1964415343
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 2401662996135154584, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_Name
      value: Boundaries_SRP
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_RootOrder
      value: 2
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalPosition.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalRotation.w
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalRotation.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalRotation.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalRotation.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}

```

`Samples~/HairSample/Scenes/HairSample_HDRP.unity.meta`:

```meta
fileFormatVersion: 2
guid: 392deafd1a40c1446ae2f51f689809e7
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Scenes/HairSample_URP.unity`:

```unity
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!29 &1
OcclusionCullingSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_OcclusionBakeSettings:
    smallestOccluder: 5
    smallestHole: 0.25
    backfaceThreshold: 100
  m_SceneGUID: 00000000000000000000000000000000
  m_OcclusionCullingData: {fileID: 0}
--- !u!104 &2
RenderSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 9
  m_Fog: 0
  m_FogColor: {r: 0.5, g: 0.5, b: 0.5, a: 1}
  m_FogMode: 3
  m_FogDensity: 0
  m_LinearFogStart: 0
  m_LinearFogEnd: 300
  m_AmbientSkyColor: {r: 0.212, g: 0.227, b: 0.259, a: 1}
  m_AmbientEquatorColor: {r: 0.114, g: 0.125, b: 0.133, a: 1}
  m_AmbientGroundColor: {r: 0.047, g: 0.043, b: 0.035, a: 1}
  m_AmbientIntensity: 1
  m_AmbientMode: 0
  m_SubtractiveShadowColor: {r: 0.42, g: 0.478, b: 0.627, a: 1}
  m_SkyboxMaterial: {fileID: 2100000, guid: 37565627c08575c4bb329ed5a68bc511, type: 2}
  m_HaloStrength: 0.5
  m_FlareStrength: 1
  m_FlareFadeSpeed: 3
  m_HaloTexture: {fileID: 0}
  m_SpotCookie: {fileID: 10001, guid: 0000000000000000e000000000000000, type: 0}
  m_DefaultReflectionMode: 0
  m_DefaultReflectionResolution: 128
  m_ReflectionBounces: 1
  m_ReflectionIntensity: 1
  m_CustomReflection: {fileID: 0}
  m_Sun: {fileID: 0}
  m_IndirectSpecularColor: {r: 0, g: 0, b: 0, a: 1}
  m_UseRadianceAmbientProbe: 0
--- !u!157 &3
LightmapSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 12
  m_GIWorkflowMode: 1
  m_GISettings:
    serializedVersion: 2
    m_BounceScale: 1
    m_IndirectOutputScale: 1
    m_AlbedoBoost: 1
    m_EnvironmentLightingMode: 0
    m_EnableBakedLightmaps: 1
    m_EnableRealtimeLightmaps: 0
  m_LightmapEditorSettings:
    serializedVersion: 12
    m_Resolution: 2
    m_BakeResolution: 40
    m_AtlasSize: 1024
    m_AO: 0
    m_AOMaxDistance: 1
    m_CompAOExponent: 1
    m_CompAOExponentDirect: 0
    m_ExtractAmbientOcclusion: 0
    m_Padding: 2
    m_LightmapParameters: {fileID: 0}
    m_LightmapsBakeMode: 1
    m_TextureCompression: 1
    m_FinalGather: 0
    m_FinalGatherFiltering: 1
    m_FinalGatherRayCount: 256
    m_ReflectionCompression: 2
    m_MixedBakeMode: 2
    m_BakeBackend: 1
    m_PVRSampling: 1
    m_PVRDirectSampleCount: 32
    m_PVRSampleCount: 512
    m_PVRBounces: 2
    m_PVREnvironmentSampleCount: 256
    m_PVREnvironmentReferencePointCount: 2048
    m_PVRFilteringMode: 1
    m_PVRDenoiserTypeDirect: 1
    m_PVRDenoiserTypeIndirect: 1
    m_PVRDenoiserTypeAO: 1
    m_PVRFilterTypeDirect: 0
    m_PVRFilterTypeIndirect: 0
    m_PVRFilterTypeAO: 0
    m_PVREnvironmentMIS: 1
    m_PVRCulling: 1
    m_PVRFilteringGaussRadiusDirect: 1
    m_PVRFilteringGaussRadiusIndirect: 5
    m_PVRFilteringGaussRadiusAO: 2
    m_PVRFilteringAtrousPositionSigmaDirect: 0.5
    m_PVRFilteringAtrousPositionSigmaIndirect: 2
    m_PVRFilteringAtrousPositionSigmaAO: 1
    m_ExportTrainingData: 0
    m_TrainingDataDestination: TrainingData
    m_LightProbeSampleCountMultiplier: 4
  m_LightingDataAsset: {fileID: 0}
  m_LightingSettings: {fileID: 0}
--- !u!196 &4
NavMeshSettings:
  serializedVersion: 2
  m_ObjectHideFlags: 0
  m_BuildSettings:
    serializedVersion: 2
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.4
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    accuratePlacement: 0
    maxJobWorkers: 0
    preserveTilesOutsideBounds: 0
    debug:
      m_Flags: 0
  m_NavMeshData: {fileID: 0}
--- !u!1001 &287823099
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 876047308709114212, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_RootOrder
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 876047308709114212, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 876047308709114212, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_LocalPosition.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 876047308709114212, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 876047308709114212, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_LocalRotation.w
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 876047308709114212, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_LocalRotation.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 876047308709114212, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_LocalRotation.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 876047308709114212, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_LocalRotation.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 876047308709114212, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 876047308709114212, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 876047308709114212, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 1497383489657554579, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_Intensity
      value: 5
      objectReference: {fileID: 0}
    - target: {fileID: 1497383489702362738, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_Intensity
      value: 5
      objectReference: {fileID: 0}
    - target: {fileID: 1497383490109414823, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_Intensity
      value: 5
      objectReference: {fileID: 0}
    - target: {fileID: 1497383490739211871, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_Intensity
      value: 5
      objectReference: {fileID: 0}
    - target: {fileID: 7070947395066058267, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
      propertyPath: m_Name
      value: Lights_URP
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: 2b394c264c59e084e8bef700ec3a3027, type: 3}
--- !u!1001 &584058098
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 2513776440376746481, guid: 852440ec915fcf247a8093430de4542c, type: 3}
      propertyPath: m_Name
      value: Camera_URP
      objectReference: {fileID: 0}
    - target: {fileID: 2513776440376746486, guid: 852440ec915fcf247a8093430de4542c, type: 3}
      propertyPath: m_RootOrder
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 2513776440376746486, guid: 852440ec915fcf247a8093430de4542c, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2513776440376746486, guid: 852440ec915fcf247a8093430de4542c, type: 3}
      propertyPath: m_LocalPosition.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2513776440376746486, guid: 852440ec915fcf247a8093430de4542c, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2513776440376746486, guid: 852440ec915fcf247a8093430de4542c, type: 3}
      propertyPath: m_LocalRotation.w
      value: 0.9070465
      objectReference: {fileID: 0}
    - target: {fileID: 2513776440376746486, guid: 852440ec915fcf247a8093430de4542c, type: 3}
      propertyPath: m_LocalRotation.x
      value: 0.13464461
      objectReference: {fileID: 0}
    - target: {fileID: 2513776440376746486, guid: 852440ec915fcf247a8093430de4542c, type: 3}
      propertyPath: m_LocalRotation.y
      value: 0.39459655
      objectReference: {fileID: 0}
    - target: {fileID: 2513776440376746486, guid: 852440ec915fcf247a8093430de4542c, type: 3}
      propertyPath: m_LocalRotation.z
      value: -0.05857508
      objectReference: {fileID: 0}
    - target: {fileID: 2513776440376746486, guid: 852440ec915fcf247a8093430de4542c, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 16.887
      objectReference: {fileID: 0}
    - target: {fileID: 2513776440376746486, guid: 852440ec915fcf247a8093430de4542c, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 47.021
      objectReference: {fileID: 0}
    - target: {fileID: 2513776440376746486, guid: 852440ec915fcf247a8093430de4542c, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 6435278038070898012, guid: 852440ec915fcf247a8093430de4542c, type: 3}
      propertyPath: m_Enabled
      value: 1
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: 852440ec915fcf247a8093430de4542c, type: 3}
--- !u!1001 &1376303331
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 2401662996135154584, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_Name
      value: Boundaries_SRP
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_RootOrder
      value: 2
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalPosition.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalRotation.w
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalRotation.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalRotation.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalRotation.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2401662996135154585, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: 72a09331ad1a1224ebf2ec83225bcb0b, type: 3}
--- !u!1001 &1631925198
PrefabInstance:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Modification:
    m_TransformParent: {fileID: 0}
    m_Modifications:
    - target: {fileID: 2034033869895580038, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_Name
      value: Hair
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_RootOrder
      value: 3
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalPosition.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalPosition.y
      value: 1
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalPosition.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalRotation.w
      value: 0.9723415
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalRotation.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalRotation.y
      value: 0.23356412
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalRotation.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalEulerAnglesHint.x
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalEulerAnglesHint.y
      value: 27.014
      objectReference: {fileID: 0}
    - target: {fileID: 2034033869895580056, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_LocalEulerAnglesHint.z
      value: 0
      objectReference: {fileID: 0}
    - target: {fileID: 2034033870785485706, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_Materials.Array.data[0]
      value: 
      objectReference: {fileID: 0}
    - target: {fileID: 2034033870785485707, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}
      propertyPath: m_Mesh
      value: 
      objectReference: {fileID: 0}
    m_RemovedComponents: []
  m_SourcePrefab: {fileID: 100100000, guid: bef18da41f24f044cb72b7768bbedb05, type: 3}

```

`Samples~/HairSample/Scenes/HairSample_URP.unity.meta`:

```meta
fileFormatVersion: 2
guid: 605684e745c36a547b27ce659c7f21fe
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Scripts.meta`:

```meta
fileFormatVersion: 2
guid: 7f0dc2119a0115845982caffbbbffc49
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Scripts/Orbit.cs`:

```cs
using UnityEngine;

[ExecuteInEditMode]
public class Orbit : MonoBehaviour
{
	public float positionPitch = 0.0f;
	public float positionYaw = 0.0f;

	public float extentPitch = 25.0f;

	[Min(float.Epsilon)] public float periodPitch = 1.0f;// seconds
	[Min(float.Epsilon)] public float periodYaw = 10.0f;// yaw

	private void LateUpdate()
	{
		float dt = Time.deltaTime;

		positionPitch += dt / periodPitch;
		positionPitch -= Mathf.Floor(positionPitch);

		positionYaw += dt / periodYaw;
		positionYaw -= Mathf.Floor(positionYaw);

		if (float.IsNaN(positionPitch))
			positionPitch = 0.0f;
		if (float.IsNaN(positionYaw))
			positionYaw = 0.0f;

		float degreesPitch = extentPitch * Mathf.Sin(positionPitch * Mathf.PI * 2.0f);
		float degreesYaw = 360.0f * positionYaw;

		transform.localRotation = Quaternion.Euler(degreesPitch, degreesYaw, 0.0f);
	}
}

```

`Samples~/HairSample/Scripts/Orbit.cs.meta`:

```meta
fileFormatVersion: 2
guid: fc8de30d327db604fb21c85f9a111a5f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Scripts/SetSky.cs`:

```cs
using UnityEngine;
using UnityEngine.Rendering;

[ExecuteAlways]
public class SetSky : MonoBehaviour
{
	public Material builtinSkybox;

	public void Update()
	{
		if (RenderSettings.skybox != builtinSkybox)
			RenderSettings.skybox = builtinSkybox;
	}
}

```

`Samples~/HairSample/Scripts/SetSky.cs.meta`:

```meta
fileFormatVersion: 2
guid: 23920834ba9472542b1b6bcf69359a2f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences:
  - builtinSkybox: {fileID: 2100000, guid: 37565627c08575c4bb329ed5a68bc511, type: 2}
  - builtinSunSource: {instanceID: 0}
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Scripts/Slide.cs`:

```cs
using UnityEngine;

[ExecuteInEditMode]
public class Slide : MonoBehaviour
{
	public float position = 0.0f;

	public Vector3 extent;

	[Min(float.Epsilon)]
	public float period;// seconds

	private void LateUpdate()
	{
		float dt = Time.deltaTime;

		position += dt / period;

		if (float.IsNaN(position) || float.IsInfinity(position))
			position = 0.0f;

		transform.localPosition = extent * Mathf.Sin(position * Mathf.PI * 2.0f);
	}
}

```

`Samples~/HairSample/Scripts/Slide.cs.meta`:

```meta
fileFormatVersion: 2
guid: 1a27b43bb34ede141b4e3d7b94829221
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Styles.meta`:

```meta
fileFormatVersion: 2
guid: 915613c1eb3d9bc4c8e74a104b992432
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Samples~/HairSample/Styles/CurlyCurtain.asset.meta`:

```meta
fileFormatVersion: 2
guid: 8eb9a34a36e03bd44ab91a8369408d08
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Tests.meta`:

```meta
fileFormatVersion: 2
guid: bd9a2f4a9ac1425429f19ec5b56c0089
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Tests/Editor.meta`:

```meta
fileFormatVersion: 2
guid: c79c965b049663044806a1bf1862c0dd
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Tests/Editor/HairTestsEditor.cs`:

```cs
using UnityEngine;
using UnityEditor;
using UnityEngine.TestTools;
using NUnit.Framework;
using System.Collections;

class HairTestsEditor
{
	[Test]
	public void Passes()
	{
		// Use the Assert class to test conditions.
	}
}

```

`Tests/Editor/HairTestsEditor.cs.meta`:

```meta
fileFormatVersion: 2
guid: c70f85574e8e9b04ca0cc98da57a33ef
```

`Tests/Editor/Unity.DemoTeam.Hair.Tests.Editor.asmdef`:

```asmdef
{
    "name": "Unity.DemoTeam.Hair.Tests.Editor",
    "rootNamespace": "",
    "references": [
        "Unity.DemoTeam.Hair.Runtime",
        "Unity.DemoTeam.Hair.Editor",
        "UnityEngine.TestRunner",
        "UnityEditor.TestRunner"
    ],
    "includePlatforms": [
        "Editor"
    ],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": true,
    "precompiledReferences": [
        "nunit.framework.dll"
    ],
    "autoReferenced": false,
    "defineConstraints": [
        "UNITY_INCLUDE_TESTS"
    ],
    "versionDefines": [],
    "noEngineReferences": false
}
```

`Tests/Editor/Unity.DemoTeam.Hair.Tests.Editor.asmdef.meta`:

```meta
fileFormatVersion: 2
guid: e7438fac4ec3f8642950ec33f15cdaf1
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Tests/Runtime.meta`:

```meta
fileFormatVersion: 2
guid: e9ffcb13e1dda26489b8c5c21701f435
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Tests/Runtime/HairTests.cs`:

```cs
using UnityEngine;
using UnityEngine.TestTools;
using NUnit.Framework;
using System.Collections;

class HairTestsRuntime
{
	[Test]
	public void Passes()
	{
		// Use the Assert class to test conditions.
	}
}

```

`Tests/Runtime/HairTests.cs.meta`:

```meta
fileFormatVersion: 2
guid: 89c5e3777f077e44d93bb3d114961111
```

`Tests/Runtime/Unity.DemoTeam.Hair.Tests.Runtime.asmdef`:

```asmdef
{
    "name": "Unity.DemoTeam.Hair.Tests.Runtime",
    "rootNamespace": "",
    "references": [
        "Unity.DemoTeam.Hair.Runtime",
        "UnityEngine.TestRunner",
        "UnityEditor.TestRunner"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": true,
    "precompiledReferences": [
        "nunit.framework.dll"
    ],
    "autoReferenced": false,
    "defineConstraints": [
        "UNITY_INCLUDE_TESTS"
    ],
    "versionDefines": [],
    "noEngineReferences": false
}
```

`Tests/Runtime/Unity.DemoTeam.Hair.Tests.Runtime.asmdef.meta`:

```meta
fileFormatVersion: 2
guid: d2f6089fde7b8254dba8fb77665536c8
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`package.json`:

```json
{
  "name": "com.unity.demoteam.hair",
  "displayName": "Demo Team Hair System",
  "version": "0.19.0-preview.1",
  "unity": "2020.2",
  "unityRelease": "0f1",
  "description": "An integrated solution for authoring / importing / simulating / rendering strand-based hair in Unity.",
  "dependencies": {
      "com.unity.burst": "1.4.1",
      "com.unity.collections": "0.15.0-preview.21",
      "com.unity.mathematics": "1.3.2",
      "com.unity.render-pipelines.core": "10.2.2",
      "com.unity.shadergraph": "10.2.2"
  },
  "samples": [
    {
      "displayName": "Minimal Hair Sample",
      "description": "Interactive scene featuring a simple hair setup. Contains variants for all current rendering pipelines: HDRP, URP, and Built-in.",
      "path": "Samples~/HairSample"
    }
  ]
}
```

`package.json.meta`:

```meta
fileFormatVersion: 2
guid: 8071d457981555341be65eb28a009f22
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```