Project Path: arc_Invoke-RE_binja-lattice-mcp_j87sq1c9

Source Tree:

```txt
arc_Invoke-RE_binja-lattice-mcp_j87sq1c9
├── LICENSE
├── README.md
├── img
│   └── lattice-logo.png
├── lattice_client.py
├── lib
│   └── lattice.py
├── mcp_server.py
├── plugin
│   ├── __init__.py
│   └── lattice_server_plugin.py
├── requirements.txt
├── scripts
│   └── install_windows.ps1
├── setup.py
└── tests
    ├── conftest.py
    ├── data
    │   ├── test_binary
    │   └── test_program.c
    └── test_lattice_server.py

```

`LICENSE`:

```
Copyright 2025 Invoke Reversing Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`README.md`:

```md
![BinjaLattice Logo](img/lattice-logo.png)

# BinjaLattice

BinjaLattice is a secure communication protocol for Binary Ninja that enables interaction with external Model Context Protocol (MCP) servers and tools. It provides a structured way to acquire information from Binary Ninja and the ability to modify an active Binary Ninja database over HTTP with a REST API.

## Demo

[![BinjaLattice Demo](https://img.youtube.com/vi/xfDRVn0VIA0/0.jpg)](https://www.youtube.com/watch?v=xfDRVn0VIA0)

## Features

- **Secure Authentication**: Token-based authentication system
- **Encrypted Communication**: Optional SSL/TLS encryption
- **Binary Analysis Context**: Export pseudocode, disassembly, variable names, binary information etc.
- **Binary Modification**: Update function names, add comments, rename variables
- **Token Management**: Automatic expiration and renewal of authentication tokens

## Installation

### Windows (Automated)

Run the PowerShell installer for a one-shot setup:

```powershell
.\scripts\install_windows.ps1
```

This will:
- Install the plugin to `%APPDATA%\Binary Ninja\plugins\`
- Create a Python virtual environment (`.venv`)
- Install all dependencies
- Output a ready-to-use MCP configuration

### Manual Installation (All Platforms)

1. Copy `plugin/lattice_server_plugin.py` to your Binary Ninja plugins directory:
   - Linux: `~/.binaryninja/plugins/`
   - macOS: `~/Library/Application Support/Binary Ninja/plugins/`
   - Windows: `%APPDATA%\Binary Ninja\plugins\`

2. Create a virtual environment:
   ```bash
   python -m venv .venv
   ```

3. Activate and install dependencies:
   ```bash
   # Linux/macOS
   source .venv/bin/activate
   
   # Windows
   .venv\Scripts\activate
   
   pip install -r requirements.txt
   ```

## Usage

### Starting the Server in Binary Ninja

1. Open Binary Ninja and load a binary file
2. Go to `Plugins > Start Lattice Protocol Server`
3. The server will start and display the API key in the log console
4. Set the API key as the `BNJLAT` environment variable in your MCP configuration

Example MCP configuration (`mcp.json`):
```json
{
    "mcpServers": {
      "binja-lattice-mcp": {
        "command": "/path/to/BinjaLattice/.venv/bin/python",
        "args": ["/path/to/BinjaLattice/mcp_server.py"],
        "env": {
            "BNJLAT": "your_api_key_here"
        }
      }
    }
}
```

On Windows, use backslashes:
```json
{
    "mcpServers": {
      "binja-lattice-mcp": {
        "command": "C:\\path\\to\\BinjaLattice\\.venv\\Scripts\\python.exe",
        "args": ["C:\\path\\to\\BinjaLattice\\mcp_server.py"],
        "env": {
            "BNJLAT": "your_api_key_here"
        }
      }
    }
}
```

> **Tip**: The Windows installer outputs a ready-to-paste configuration with the correct paths.

### Available MCP Tools

The following tools are available through the MCP server:

#### Binary Information
- `get_binary_info`: Get metadata about the binary (filename, architecture, entry point, segments, sections, function count)
- `get_all_function_names`: List all function names in the binary
- `get_strings`: Get strings with optional min_length and substring filter
- `get_imports`: List imported functions with addresses and source libraries
- `get_exports`: List exported functions with addresses
- `get_analysis_progress`: Get Binary Ninja analysis status and progress percentage

#### Function Analysis
- `get_function_disassembly`: Get assembly instructions for function by name
- `get_function_pseudocode`: Get decompiled C-like pseudocode for function
- `get_function_variables`: Get parameters, local variables, and global variables
- `get_cross_references_to_function`: List functions that call the specified function
- `get_call_graph`: Get callers and callees of function with configurable depth
- `get_global_variable_data`: Read data from global variable referenced in function

#### Data Access
- `get_data_at_address`: Read bytes at address with optional type interpretation
- `search_bytes`: Search for hex byte pattern with wildcard support (e.g., '48 89 ?? 24')

#### Type Management
- `get_types`: List defined types (structs, enums, typedefs) with optional filter
- `create_struct`: Create a new struct type with JSON member definitions
- `update_struct`: Update an existing struct type

#### Annotations
- `update_function_name`: Rename a function
- `update_variable_name`: Rename a variable in a function
- `set_variable_type`: Set variable type annotation (C-style like 'uint32_t')
- `set_function_signature`: Set function prototype (C-style like 'int foo(char* arg1)')
- `add_comment_to_address`: Add comment at address
- `add_comment_to_function`: Add comment to function
- `create_tag`: Create tag at address with type and optional description
- `get_tags`: List all tags with optional type filter

### Client Library Usage

The `Lattice` client library provides a Python interface for interacting with the BinjaLattice server:

```python
from lib.lattice import Lattice

# Initialize client
client = Lattice(host='localhost', port=9000, use_ssl=False)

# Authenticate with API key
client.authenticate("username", "API_KEY")

# Example: Get binary information
binary_info = client.get_binary_info()

# Example: Update function name
client.update_function_name("old_name", "new_name")

# Example: Add comment to function
client.add_comment_to_function("function_name", "This function handles authentication")
```

### Command Line Interface

The project includes `lattice_client.py`, which provides an interactive command-line interface for testing and debugging the BinjaLattice server:

```bash
python lattice_client.py --host localhost --port 9000 [--ssl] --username user --password YOUR_API_KEY
```

#### Command Line Options

- `--host`: Server host (default: localhost)
- `--port`: Server port (default: 9000)
- `--ssl`: Enable SSL/TLS encryption
- `--interactive`, `-i`: Run in interactive mode
- `--username`: Username for authentication
- `--password`: Password/API key for authentication
- `--token`: Authentication token (if you have one from previous authentication)

#### Interactive Mode

The interactive mode provides a menu-driven interface with the following options:

1. Get Binary Information
2. Get Function Context by Address
3. Get Function Context by Name
4. Update Function Name
5. Update Variable Name
6. Add Comment to Function
7. Add Comment to Address
8. Reconnect to Server
9. Get All Function Names
10. Get Function Disassembly
11. Get Function Pseudocode
12. Get Function Variables
13. Get Cross References to Function
14. Exit

Example usage with interactive mode:

```bash
python lattice_client.py -i --ssl --username user --password YOUR_API_KEY
```

#### Non-Interactive Commands

You can also use the client to execute single commands:

```bash
# Get binary information
python lattice_client.py --username user --password YOUR_API_KEY --get-binary-info

# Get function disassembly
python lattice_client.py --username user --password YOUR_API_KEY --get-function-disassembly "main"

# Add comment to a function
python lattice_client.py --username user --password YOUR_API_KEY --add-comment-to-function "main" "Entry point of the program"
```

### Security Notes

- The API key is generated randomly on server start and shown in the Binary Ninja log
- Tokens expire after 8 hours by default
- SSL/TLS requires a certificate and key be provided by the user (disabled by default)
- All requests require authentication via API key or token
- The server runs locally by default on port 9000

## Development

- The main server implementation is in `plugin/lattice_server_plugin.py`
- MCP server implementation is in `mcp_server.py`
- Client library is in `lib/lattice.py`

### Adding New Features

To add new functionality:

1. Add new endpoint handlers in `LatticeRequestHandler` class in `lattice_server_plugin.py`
2. Add corresponding client methods in `Lattice` class in `lib/lattice.py`
3. Add new MCP tools in `mcp_server.py`

### Running Tests

1. Create a Python virtual environment and install the `requirements.txt`
2. Install the Binary Ninja Python API with the `install_api.py` provided in your Binary Ninja installation directory
3. Run the tests with `pytest tests/ -v`

## License

[MIT License](LICENSE) 

```

`lattice_client.py`:

```py
from lib.lattice import Lattice
import argparse, sys, json, logging

logger = logging.getLogger(__name__)

def print_menu():
    """Print the interactive menu"""
    print("\nBinjaLattice Client Menu:")
    print("1. Get Binary Information")
    print("2. Get Function Context by Address")
    print("3. Get Function Context by Name")
    print("4. Update Function Name")
    print("5. Update Variable Name")
    print("6. Add Comment to Function")
    print("7. Add Comment to Address")
    print("8. Reconnect to Server")
    print("9. Get All Function Names")
    print("10. Get Function Disassembly")
    print("11. Get Function Pseudocode")
    print("12. Get Function Variables")
    print("13. Get Cross References to Function")
    print("14. Get Global Variable Data")
    print("15. Exit")
    print()

def interactive_mode(client: Lattice):
    """Run the interactive REPL mode"""
    while True:
        print_menu()
        try:
            choice = input("Enter your choice (1-15): ").strip()
            
            if choice == '1':
                result = client.get_binary_info()
                print(json.dumps(result, indent=2))
                
            elif choice == '2':
                addr = input("Enter function address (hex or decimal): ").strip()
                try:
                    address = int(addr, 0)
                    result = client.get_function_context(address)
                    print(json.dumps(result, indent=2))
                except ValueError:
                    logger.error("Invalid address format")
            elif choice == '3':
                name = input("Enter function name: ").strip()
                try:
                    result = client.get_function_context_by_name(name)
                    print(json.dumps(result, indent=2))
                except ValueError:
                    logger.error("Invalid function name")
                    
            elif choice == '4':
                name = input("Enter function name: ").strip()
                new_name = input("Enter new function name: ").strip()
                try:
                    result = client.update_function_name(name, new_name)
                    print(json.dumps(result, indent=2))
                except ValueError:
                    logger.error("Invalid function name")
                    
            elif choice == '5':
                func_name = input("Enter function name: ").strip()
                var_name = input("Enter variable name: ").strip()
                new_name = input("Enter new variable name: ").strip()
                try:
                    result = client.update_variable_name(func_name, var_name, new_name)
                    print(json.dumps(result, indent=2))
                except ValueError:
                    logger.error("Invalid input format")
                    
            elif choice == '6':
                name = input("Enter function name: ").strip()
                comment = input("Enter comment: ").strip()
                try:
                    result = client.add_comment_to_function(name, comment)
                    print(json.dumps(result, indent=2))
                except ValueError:
                    logger.error("Invalid function name")
            elif choice == '7':
                address = input("Enter address (hex or decimal): ").strip()
                comment = input("Enter comment: ").strip()
                try:
                    result = client.add_comment_to_address(address, comment)
                    logger.error(json.dumps(result, indent=2))
                except ValueError:
                    print("Invalid address format")
            elif choice == '8':
                client.close()
                if client.connect():
                    print("Reconnected successfully")
                    if client.auth_token:
                        print("Previous authentication token is still valid")
                else:
                    logger.error("Failed to reconnect")
            elif choice == '9':
                result = client.get_all_function_names()
                print(json.dumps(result, indent=2))
            elif choice == '10':
                name = input("Enter function name: ").strip()
                try:
                    result = client.get_function_disassembly(name)
                    print(json.dumps(result, indent=2))
                except ValueError:
                    logger.error("Invalid function name")
            elif choice == '11':
                name = input("Enter function name: ").strip()
                try:
                    result = client.get_function_pseudocode(name)
                    print(json.dumps(result, indent=2))
                except ValueError:
                    logger.error("Invalid function name")
            elif choice == '12':
                name = input("Enter function name: ").strip()
                try:
                    result = client.get_function_variables(name)
                    print(json.dumps(result, indent=2))
                except ValueError:
                    logger.error("Invalid function name")
            elif choice == '13':
                name = input("Enter function name: ").strip()
                try:
                    result = client.get_cross_references_to_function(name)
                    print(json.dumps(result, indent=2))
                except ValueError:
                    logger.error("Invalid function name")
            elif choice == '14':
                func_name = input("Enter function name: ").strip()
                var_name = input("Enter variable name: ").strip()
                try:
                    result = client.get_global_variable_data(func_name, var_name)
                    print(json.dumps(result, indent=2))
                except ValueError:
                    logger.error("Invalid function name")
            elif choice == '15':
                print("Goodbye!")
                break
            else:
                print("Invalid choice. Please try again.")
                
        except KeyboardInterrupt:
            print("\nGoodbye!")
            break
        except Exception as e:
            logger.error(f"Error: {e}")
            print("Try reconnecting to the server (option 8)")

def main():
    parser = argparse.ArgumentParser(description='BinjaLattice Client - Communicate with Binary Ninja Lattice Protocol Server')
    parser.add_argument('--host', default='localhost', help='Server host (default: localhost)')
    parser.add_argument('--port', type=int, default=9000, help='Server port (default: 9000)')
    parser.add_argument('--ssl', action='store_true', help='Use SSL/TLS encryption')
    parser.add_argument('--interactive', '-i', action='store_true', help='Run in interactive mode')
    
    # Authentication options
    auth_group = parser.add_argument_group('Authentication')
    auth_group.add_argument('--username', help='Username for authentication')
    auth_group.add_argument('--password', help='Password/API key for authentication')
    auth_group.add_argument('--token', help='Authentication token')
    
    # Command options (only used in non-interactive mode)
    command_group = parser.add_argument_group('Commands')
    command_group.add_argument('--get-binary-info', action='store_true', help='Get binary information')
    command_group.add_argument('--get-function-context', type=lambda x: int(x, 0), help='Get function context at address (hex or decimal)')
    command_group.add_argument('--get-basic-block-context', type=lambda x: int(x, 0), help='Get basic block context at address (hex or decimal)')
    command_group.add_argument('--update-function-name', nargs=2, help='Update function name: <address> <new_name>')
    command_group.add_argument('--update-variable-name', nargs=3, help='Update variable name: <function_address> <var_id> <new_name>')
    command_group.add_argument('--add-comment-to-address', nargs=2, help='Add comment to address: <address> <comment>')
    command_group.add_argument('--add-comment-to-function', nargs=2, help='Add comment to function: <function_name> <comment>')
    command_group.add_argument('--get-function-disassembly', type=str, help='Get function disassembly for function name')
    command_group.add_argument('--get-function-pseudocode', type=str, help='Get function pseudocode for function name')
    command_group.add_argument('--get-function-variables', type=str, help='Get function variables for function name')
    command_group.add_argument('--get-cross-references-to-function', type=str, help='Get cross references to function name')
    args = parser.parse_args()
    
    # Create client
    client = Lattice(host=args.host, port=args.port, use_ssl=args.ssl)
    
    # Authenticate
    if args.token:
        if not client.authenticate_with_token(args.token):
            print("Authentication failed with token")
            client.close()
            sys.exit(1)
    elif args.username and args.password:
        if not client.authenticate(args.username, args.password):
            print("Authentication failed with username/password")
            client.close()
            sys.exit(1)
    else:
        print("Authentication credentials required (--token or --username/--password)")
        client.close()
        sys.exit(1)
    
    try:
        if args.interactive:
            interactive_mode(client)
        else:
            # Execute requested command
            if args.get_binary_info:
                result = client.get_binary_info()
                print(json.dumps(result, indent=2))
                
            elif args.get_function_context:
                result = client.get_function_context(args.get_function_context)
                print(json.dumps(result, indent=2))
            elif args.update_function_name:
                address = int(args.update_function_name[0], 0)
                new_name = args.update_function_name[1]
                result = client.update_function_name(address, new_name)
                print(json.dumps(result, indent=2))
                
            elif args.update_variable_name:
                func_addr = int(args.update_variable_name[0], 0)
                var_id = int(args.update_variable_name[1])
                new_name = args.update_variable_name[2]
                result = client.update_variable_name(func_addr, var_id, new_name)
                print(json.dumps(result, indent=2))
                
            elif args.add_comment_to_address:
                address = int(args.add_comment_to_address[0], 0)
                comment = args.add_comment_to_address[1]
                result = client.add_comment_to_address(address, comment)
                print(json.dumps(result, indent=2))

            elif args.add_comment_to_function:
                name = args.add_comment_to_function[0]
                comment = args.add_comment_to_function[1]
                result = client.add_comment_to_function(name, comment)

                print(json.dumps(result, indent=2))
            elif args.get_function_disassembly:
                result = client.get_function_disassembly(args.get_function_disassembly)
                print(json.dumps(result, indent=2))
                
            elif args.get_function_pseudocode:
                result = client.get_function_pseudocode(args.get_function_pseudocode)
                print(json.dumps(result, indent=2))
                
            elif args.get_function_variables:
                result = client.get_function_variables(args.get_function_variables)
                print(json.dumps(result, indent=2))

            elif args.get_cross_references_to_function:
                result = client.get_cross_references_to_function(args.get_cross_references_to_function)
                print(json.dumps(result, indent=2))
            else:
                print("No command specified. Use --help to see available commands.")
                
    finally:
        client.close()

if __name__ == "__main__":
    main() 

```

`lib/lattice.py`:

```py
import requests
import json
import logging
import sys
from typing import Optional, Dict, Any, List, Tuple, Union
from urllib.parse import urljoin

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class Lattice:
    """Client for communicating with a BinjaLattice server"""
    
    def __init__(self, host: str = "localhost", port: int = 9000, use_ssl: bool = False):
        """
        Initialize the client.
        
        Args:
            host: Host address of the server
            port: Port number of the server
            use_ssl: Whether to use SSL/TLS encryption
        """
        self.host = host
        self.port = port
        self.use_ssl = use_ssl
        self.auth_token = None
        self.base_url = f"{'https' if use_ssl else 'http'}://{host}:{port}"
        self.session = requests.Session()
        if not use_ssl:
            self.session.verify = False  # Disable SSL verification for non-SSL connections
    
    def connect(self) -> bool:
        """Connect to the server"""
        #try:
        response = self.session.get(urljoin(self.base_url, '/binary/info'))
        if response.status_code == 200:
            logger.info(f"Connected to {self.host}:{self.port}")
            return True
        elif response.status_code == 401:
            logger.error(f"Authentication failed with status code: {response.status_code}")
            logger.error(f"Response: {response.text}")
            return False
        else:
            logger.error(f"Failed to connect: {response.status_code}")
            return False
        #except Exception as e:
        #    logger.error(f"Failed to connect: {e}")
        #    return False
    
    def authenticate(self, username: str, password: str) -> bool:
        """
        Authenticate with the server using username/password
        
        Args:
            username: Username for authentication
            password: Password (API key) for authentication
            
        Returns:
            True if authentication successful, False otherwise
        """
        response = self.session.post(
            urljoin(self.base_url, '/auth'),
            json={
                'username': username,
                'password': password
            }
        )
        
        if response.status_code == 200:
            print(response.content)
            data = json.loads(response.content)
            if data.get('status') == 'success':
                self.auth_token = data.get('token')
                self.session.headers.update({'Authorization': f'Bearer {self.auth_token}'})
                logger.info("Authentication successful")
                return True
            else:
                logger.error(f"Authentication failed: {data.get('message')}")
        else:
            logger.error(f"Authentication failed with status code: {response.status_code}")
        
        return False
    
    def authenticate_with_token(self, token: str) -> bool:
        """
        Authenticate with the server using a token
        
        Args:
            token: Authentication token
            
        Returns:
            True if authentication successful, False otherwise
        """
        try:
            response = self.session.post(
                urljoin(self.base_url, '/auth'),
                json={'token': token}
            )
            
            if response.status_code == 200:
                data = response.json()
                if data.get('status') == 'success':
                    self.auth_token = token
                    self.session.headers.update({'Authorization': f'Bearer {self.auth_token}'})
                    logger.info("Token authentication successful")
                    return True
                else:
                    logger.error(f"Token authentication failed: {data.get('message')}")
            else:
                logger.error(f"Token authentication failed with status code: {response.status_code}")
            
            return False
            
        except Exception as e:
            logger.error(f"Token authentication error: {e}")
            return False
    
    def get_binary_info(self) -> Optional[Dict[str, Any]]:
        """Get information about the binary"""
        try:
            response = self.session.get(urljoin(self.base_url, '/binary/info'))
            if response.status_code == 200:
                return response.json()
            return None
        except Exception as e:
            logger.error(f"Error getting binary info: {e}")
            return None
    
    def get_function_context(self, address: int) -> Optional[Dict[str, Any]]:
        """
        Get context for a function at the specified address
        
        Args:
            address: Address of the function
            
        Returns:
            Dictionary containing function context
        """
        try:
            response = self.session.get(urljoin(self.base_url, f'/functions/{address}'))
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to get function context'}
        except Exception as e:
            logger.error(f"Error getting function context: {e}")
            return {'status': 'error', 'message': str(e)}

    def get_function_context_by_name(self, name: str) -> Optional[Dict[str, Any]]:
        """
        Get context for a function by name
        
        Args:
            name: Name of the function
            
        Returns:
            Dictionary containing function context
        """
        try:
            response = self.session.get(urljoin(self.base_url, f'/functions/name/{name}'))
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to get function context by name'}
        except Exception as e:
            logger.error(f"Error getting function context by name: {e}")
            return {'status': 'error', 'message': str(e)}
    
    def get_all_function_names(self) -> Optional[Dict[str, Any]]:
        """
        Get all function names
        """
        try:
            response = self.session.get(urljoin(self.base_url, '/functions'))
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to get all function names'}
        except Exception as e:
            logger.error(f"Error getting all function names: {e}")
            return {'status': 'error', 'message': str(e)}
    
    def update_function_name(self, name: str, new_name: str) -> Optional[Dict[str, Any]]:
        """
        Update the name of a function
        
        Args:
            name: Current name of the function
            new_name: New name for the function
            
        Returns:
            Dictionary containing the result of the operation
        """
        try:
            response = self.session.put(
                urljoin(self.base_url, f'/functions/{name}/name'),
                json={'name': new_name}
            )
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to update function name'}
        except Exception as e:
            logger.error(f"Error updating function name: {e}")
            return {'status': 'error', 'message': str(e)}
    
    def update_variable_name(self, function_name: str, var_name: str, new_name: str) -> Optional[Dict[str, Any]]:
        """
        Update the name of a variable in a function
        
        Args:
            function_name: Name of the function containing the variable
            var_name: Name of the variable to rename
            new_name: New name for the variable
            
        Returns:
            Dictionary containing the result of the operation
        """
        try:
            response = self.session.put(
                urljoin(self.base_url, f'/variables/{function_name}/{var_name}/name'),
                json={'name': new_name}
            )
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to update variable name'}
        except Exception as e:
            logger.error(f"Error updating variable name: {e}")
            return {'status': 'error', 'message': str(e)}
    
    def get_global_variable_data(self, function_name: str, global_var_name: str) -> Optional[Dict[str, Any]]:
        """
        Get data for a global variable
        """
        try:
            response = self.session.get(urljoin(self.base_url, f'/global_variable_data/{function_name}/{global_var_name}'))
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to get global variable data'}
        except Exception as e:
            logger.error(f"Error getting global variable data: {e}")
            return {'status': 'error', 'message': str(e)}
    
    def add_comment_to_address(self, address: int, comment: str) -> Optional[Dict[str, Any]]:
        """
        Add a comment at the specified address
        
        Args:
            address: Address to add the comment at
            comment: Comment text to add
            
        Returns:
            Dictionary containing the result of the operation
        """
        try:
            response = self.session.post(
                urljoin(self.base_url, f'/comments/{address}'),
                json={'comment': comment}
            )
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to add comment'}
        except Exception as e:
            logger.error(f"Error adding comment: {e}")
            return {'status': 'error', 'message': str(e)}

    def add_comment_to_function(self, name: str, comment: str) -> Optional[Dict[str, Any]]:
        """
        Add a comment to a function with specified function name
        """
        try:
            response = self.session.post(
                urljoin(self.base_url, f'/functions/{name}/comments'),
                json={'comment': comment}
            )
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to add comment'}  
        except Exception as e:
            logger.error(f"Error adding comment to function: {e}")
            return {'status': 'error', 'message': str(e)}
    
    def get_function_disassembly(self, name: str) -> Optional[Dict[str, Any]]:
        """
        Get disassembly for a function with specified function name
        
        Args:
            name: Address of the function
            
        Returns:
            Dictionary containing function disassembly
        """
        try:
            response = self.session.get(urljoin(self.base_url, f'/functions/{name}/disassembly'))
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to get function disassembly'}
        except Exception as e:
            logger.error(f"Error getting function disassembly: {e}")
            return {'status': 'error', 'message': str(e)}
        
    def get_cross_references_to_function(self, name: str) -> Optional[Dict[str, Any]]:
        """
        Get cross references to a function
        """
        try:
            response = self.session.get(urljoin(self.base_url, f'/cross-references/{name}'))
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to get cross references to function'}
        except Exception as e:
            logger.error(f"Error getting cross references to function: {e}")
            return {'status': 'error', 'message': str(e)}

    def get_function_pseudocode(self, name: str) -> Optional[Dict[str, Any]]:
        """
        Get pseudocode for a function with specified function name
        
        Args:
            name: Name of the function
            
        Returns:
            Dictionary containing function pseudocode
        """
        try:
            response = self.session.get(urljoin(self.base_url, f'/functions/{name}/pseudocode'))
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to get function pseudocode'}
        except Exception as e:
            logger.error(f"Error getting function pseudocode: {e}")
            return {'status': 'error', 'message': str(e)}

    def get_function_variables(self, name: str) -> Optional[Dict[str, Any]]:
        """
        Get variables for a function at the specified address
        
        Args:
            name: Name of function 
            
        Returns:
            Dictionary containing function variables
        """
        try:
            response = self.session.get(urljoin(self.base_url, f'/functions/{name}/variables'))
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to get function variables'}
        except Exception as e:
            logger.error(f"Error getting function variables: {e}")
            return {'status': 'error', 'message': str(e)}
    
    def get_strings(self, min_length: int = 4, filter: str = None) -> Optional[Dict[str, Any]]:
        """
        Get strings from the binary with optional filtering
        
        Args:
            min_length: Minimum string length to return (default: 4)
            filter: Substring filter for string values (case-insensitive)
            
        Returns:
            Dictionary containing list of strings with address, value, and length
        """
        try:
            params = {'min_length': min_length}
            if filter is not None:
                params['filter'] = filter
            response = self.session.get(urljoin(self.base_url, '/strings'), params=params)
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to get strings'}
        except Exception as e:
            logger.error(f"Error getting strings: {e}")
            return {'status': 'error', 'message': str(e)}

    def get_imports(self) -> Optional[Dict[str, Any]]:
        """
        Get imported functions from the binary
        
        Returns:
            Dictionary containing list of imports with name, address, and library
        """
        try:
            response = self.session.get(urljoin(self.base_url, '/imports'))
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to get imports'}
        except Exception as e:
            logger.error(f"Error getting imports: {e}")
            return {'status': 'error', 'message': str(e)}

    def get_exports(self) -> Optional[Dict[str, Any]]:
        """
        Get exported functions from the binary
        
        Returns:
            Dictionary containing list of exports with name and address
        """
        try:
            response = self.session.get(urljoin(self.base_url, '/exports'))
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to get exports'}
        except Exception as e:
            logger.error(f"Error getting exports: {e}")
            return {'status': 'error', 'message': str(e)}

    def get_data_at_address(self, address: int, length: int = 16, type_name: str = None) -> Optional[Dict[str, Any]]:
        """
        Read raw bytes or typed data at a specific address
        
        Args:
            address: Memory address to read from
            length: Number of bytes to read (default: 16)
            type_name: Optional type name for typed interpretation
            
        Returns:
            Dictionary containing hex data, length, and optional typed value
        """
        try:
            params = {'length': length}
            if type_name is not None:
                params['type'] = type_name
            response = self.session.get(urljoin(self.base_url, f'/data/{address}'), params=params)
            if response.status_code == 200:
                return response.json()
            return response.json() if response.status_code == 400 else {'status': 'error', 'message': 'Failed to read data'}
        except Exception as e:
            logger.error(f"Error reading data at address: {e}")
            return {'status': 'error', 'message': str(e)}

    def search_bytes(self, pattern: str, max_results: int = 100) -> Optional[Dict[str, Any]]:
        """
        Search for byte patterns in the binary
        
        Args:
            pattern: Hex byte pattern to search for (e.g., "48 89 5c 24" or "48??5c??")
                     Use ?? for wildcard bytes that match any value
            max_results: Maximum number of results to return (default: 100)
            
        Returns:
            Dictionary containing list of matching addresses and count
        """
        try:
            response = self.session.post(
                urljoin(self.base_url, '/search/bytes'),
                json={'pattern': pattern, 'max_results': max_results}
            )
            if response.status_code == 200:
                return response.json()
            return response.json() if response.status_code == 400 else {'status': 'error', 'message': 'Failed to search bytes'}
        except Exception as e:
            logger.error(f"Error searching bytes: {e}")
            return {'status': 'error', 'message': str(e)}

    def get_types(self, filter: str = None) -> Optional[Dict[str, Any]]:
        """
        Get defined types from the binary with optional filtering
        
        Args:
            filter: Substring filter for type names (case-insensitive)
            
        Returns:
            Dictionary containing list of types with name, kind, size, and members
        """
        try:
            params = {}
            if filter is not None:
                params['filter'] = filter
            response = self.session.get(urljoin(self.base_url, '/types'), params=params)
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to get types'}
        except Exception as e:
            logger.error(f"Error getting types: {e}")
            return {'status': 'error', 'message': str(e)}

    def create_struct(self, name: str, members: List[Dict], overwrite: bool = False) -> Optional[Dict[str, Any]]:
        """
        Create a new structure type in Binary Ninja
        
        Args:
            name: Name of the structure to create
            members: List of member definitions, each with:
                     - name: Member name
                     - type: Type string (e.g., "uint32_t", "char*")
                     - count: Optional array count (default: 1)
            overwrite: If True, overwrite existing structure with same name
            
        Returns:
            Dictionary containing the created structure info
        """
        try:
            response = self.session.post(
                urljoin(self.base_url, '/types/struct'),
                json={'name': name, 'members': members, 'overwrite': overwrite}
            )
            return response.json()
        except Exception as e:
            logger.error(f"Error creating structure: {e}")
            return {'status': 'error', 'message': str(e)}

    def update_struct(self, name: str, members: List[Dict]) -> Optional[Dict[str, Any]]:
        """
        Update an existing structure type in Binary Ninja
        
        Args:
            name: Name of the structure to update
            members: List of member definitions, each with:
                     - name: Member name
                     - type: Type string (e.g., "uint32_t", "char*")
                     - count: Optional array count (default: 1)
            
        Returns:
            Dictionary containing the updated structure info
        """
        try:
            response = self.session.put(
                urljoin(self.base_url, f'/types/struct/{name}'),
                json={'members': members}
            )
            return response.json()
        except Exception as e:
            logger.error(f"Error updating structure: {e}")
            return {'status': 'error', 'message': str(e)}
    
    def set_variable_type(self, function_name: str, variable_name: str, type_name: str) -> Optional[Dict[str, Any]]:
        """
        Set the type annotation for a variable in a function
        
        Args:
            function_name: Name of the function containing the variable
            variable_name: Name of the variable to update
            type_name: C-style type string (e.g., "uint32_t", "char*")
            
        Returns:
            Dictionary containing the result of the operation
        """
        try:
            response = self.session.put(
                urljoin(self.base_url, f'/functions/{function_name}/variables/{variable_name}/type'),
                json={'type': type_name}
            )
            return response.json()
        except Exception as e:
            logger.error(f"Error setting variable type: {e}")
            return {'status': 'error', 'message': str(e)}
    
    def set_function_signature(self, function_name: str, signature: str) -> Optional[Dict[str, Any]]:
        """
        Update a function's signature/prototype
        
        Args:
            function_name: Name of the function to update
            signature: C-style function signature (e.g., "int foo(char* arg1, int arg2)")
            
        Returns:
            Dictionary containing the result of the operation
        """
        try:
            response = self.session.put(
                urljoin(self.base_url, f'/functions/{function_name}/signature'),
                json={'signature': signature}
            )
            return response.json()
        except Exception as e:
            logger.error(f"Error setting function signature: {e}")
            return {'status': 'error', 'message': str(e)}

    def get_call_graph(self, function_name: str, depth: int = 1) -> Optional[Dict[str, Any]]:
        """
        Get the call graph for a function
        
        Args:
            function_name: Name of the function to get call graph for
            depth: Depth of call graph traversal (default: 1, max: 10)
            
        Returns:
            Dictionary containing the call graph with callers and callees
        """
        try:
            params = {'depth': depth}
            response = self.session.get(
                urljoin(self.base_url, f'/functions/{function_name}/callgraph'),
                params=params
            )
            if response.status_code == 200:
                return response.json()
            return response.json() if response.status_code != 500 else {'status': 'error', 'message': 'Failed to get call graph'}
        except Exception as e:
            logger.error(f"Error getting call graph: {e}")
            return {'status': 'error', 'message': str(e)}

    def create_tag(self, address: int, tag_type: str, data: str = None) -> Optional[Dict[str, Any]]:
        """
        Create a tag at a specific address
        
        Args:
            address: The address to tag
            tag_type: The type/category of the tag
            data: Optional data/description for the tag
            
        Returns:
            Dictionary containing the created tag information
        """
        try:
            payload = {
                'address': address,
                'tag_type': tag_type
            }
            if data is not None:
                payload['data'] = data
            
            response = self.session.post(
                urljoin(self.base_url, '/tags'),
                json=payload
            )
            if response.status_code == 200:
                return response.json()
            return response.json() if response.status_code == 400 else {'status': 'error', 'message': 'Failed to create tag'}
        except Exception as e:
            logger.error(f"Error creating tag: {e}")
            return {'status': 'error', 'message': str(e)}

    def get_tags(self, tag_type: str = None) -> Optional[Dict[str, Any]]:
        """
        Get all tags with optional type filtering
        
        Args:
            tag_type: Optional filter to only return tags of this type
            
        Returns:
            Dictionary containing list of tags with address, type, data, and function
        """
        try:
            params = {}
            if tag_type is not None:
                params['type'] = tag_type
            
            response = self.session.get(
                urljoin(self.base_url, '/tags'),
                params=params
            )
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to get tags'}
        except Exception as e:
            logger.error(f"Error getting tags: {e}")
            return {'status': 'error', 'message': str(e)}

    def get_analysis_progress(self) -> Optional[Dict[str, Any]]:
        """
        Get the current analysis progress state
        
        Returns:
            Dictionary containing:
            - state: Current analysis state name
            - is_complete: Boolean indicating if analysis is complete
            - progress: Float from 0.0 to 1.0 indicating progress
            - description: Human-readable status description
        """
        try:
            response = self.session.get(
                urljoin(self.base_url, '/analysis/progress')
            )
            if response.status_code == 200:
                return response.json()
            return {'status': 'error', 'message': 'Failed to get analysis progress'}
        except Exception as e:
            logger.error(f"Error getting analysis progress: {e}")
            return {'status': 'error', 'message': str(e)}
    
    def close(self):
        """Close the connection to the server"""
        self.session.close()
        logger.info("Connection closed")

```

`mcp_server.py`:

```py
from mcp.server.fastmcp import FastMCP
from lib.lattice import Lattice
import os, json

# Initialize FastMCP server
mcp = FastMCP("binja-lattice", log_level="ERROR")

@mcp.tool()
def get_all_function_names() -> str:
    """List all function names in the binary."""
    response = lattice_client.get_all_function_names()
    if response and 'status' in response and response['status'] == 'success':
        return '\n'.join([f"{func['name']}" for func in response['function_names']])
    return "Error: Could not retrieve function names"

@mcp.tool()
def get_binary_info() -> str:
    """Get metadata about the binary: filename, architecture, entry point, segments, sections, function count."""
    response = lattice_client.get_binary_info()
    if response and 'status' in response and response['status'] == 'success':
        return json.dumps(response, indent=2)
    return "Error: Could not retrieve binary information"

@mcp.tool()
def get_strings(min_length: int = 4, filter: str = None) -> str:
    """Get strings from the binary. min_length filters by length, filter matches substring (case-insensitive)."""
    response = lattice_client.get_strings(min_length, filter)
    if response and 'status' in response and response['status'] == 'success':
        strings = response.get('strings', [])
        if not strings:
            return "No strings found matching the criteria"
        return '\n'.join([f"0x{s['address']:x}: {s['value']} (len={s['length']})" for s in strings])
    return "Error: Could not retrieve strings"

@mcp.tool()
def get_imports() -> str:
    """List imported functions with addresses and source libraries."""
    response = lattice_client.get_imports()
    if response and 'status' in response and response['status'] == 'success':
        imports = response.get('imports', [])
        if not imports:
            return "No imports found"
        return '\n'.join([f"0x{imp['address']:x}: {imp['name']} ({imp['library']})" if imp['library'] else f"0x{imp['address']:x}: {imp['name']}" for imp in imports])
    return "Error: Could not retrieve imports"

@mcp.tool()
def get_exports() -> str:
    """List exported functions with addresses."""
    response = lattice_client.get_exports()
    if response and 'status' in response and response['status'] == 'success':
        exports = response.get('exports', [])
        if not exports:
            return "No exports found"
        return '\n'.join([f"0x{exp['address']:x}: {exp['name']}" for exp in exports])
    return "Error: Could not retrieve exports"

@mcp.tool()
def get_data_at_address(address: int, length: int = 16, type_name: str = None) -> str:
    """Read bytes at address. address is integer, length is byte count, type_name optionally interprets as C type."""
    response = lattice_client.get_data_at_address(address, length, type_name)
    if response and 'status' in response:
        if response['status'] == 'success':
            result = f"Address: 0x{response['address']:x}\n"
            result += f"Length: {response['length']} bytes\n"
            
            # Format hex output readably (16 bytes per line)
            hex_str = response['hex']
            hex_lines = []
            for i in range(0, len(hex_str), 32):  # 32 hex chars = 16 bytes
                chunk = hex_str[i:i+32]
                # Add spaces between bytes
                spaced = ' '.join(chunk[j:j+2] for j in range(0, len(chunk), 2))
                hex_lines.append(spaced)
            result += f"Hex:\n" + '\n'.join(hex_lines)
            
            if response.get('truncated'):
                result += f"\n\nWarning: {response.get('warning', 'Data truncated')}"
            
            if response.get('typed_value'):
                result += f"\n\nTyped value ({type_name}): {response['typed_value']}"
            elif response.get('type_error'):
                result += f"\n\nType error: {response['type_error']}"
            
            return result
        else:
            return f"Error: {response.get('message', 'Unknown error')}"
    return "Error: Could not read data at address"

@mcp.tool()
def search_bytes(pattern: str, max_results: int = 100) -> str:
    """Search for hex byte pattern. Example: '48 89 5c 24' or '48??5c??' where ?? is wildcard."""
    response = lattice_client.search_bytes(pattern, max_results)
    if response and 'status' in response:
        if response['status'] == 'success':
            results = response.get('results', [])
            if not results:
                return f"No matches found for pattern: {pattern}"
            
            result = f"Found {response['count']} matches for pattern: {pattern}\n\n"
            result += '\n'.join([f"0x{r['address']:x}" for r in results])
            
            if response.get('truncated'):
                result += f"\n\n(Results limited to {max_results})"
            
            return result
        else:
            return f"Error: {response.get('message', 'Unknown error')}"
    return "Error: Could not search bytes"

@mcp.tool()
def get_types(filter: str = None) -> str:
    """List defined types (structs, enums, typedefs). filter matches type name substring."""
    response = lattice_client.get_types(filter)
    if response and 'status' in response and response['status'] == 'success':
        types = response.get('types', [])
        if not types:
            return "No types found" + (f" matching filter: {filter}" if filter else "")
        
        result_lines = []
        for t in types:
            line = f"{t['name']} ({t['kind']}, size={t['size']})"
            
            # Add member details for structures and enums
            members = t.get('members', [])
            if members:
                if t['kind'] == 'struct':
                    member_strs = [f"  +{m['offset']:04x}: {m['type']} {m['name']}" for m in members]
                elif t['kind'] == 'enum':
                    member_strs = [f"  {m['name']} = {m['value']}" for m in members]
                else:
                    member_strs = []
                
                if member_strs:
                    line += "\n" + "\n".join(member_strs)
            
            result_lines.append(line)
        
        return '\n\n'.join(result_lines)
    return "Error: Could not retrieve types"

@mcp.tool()
def create_struct(name: str, members: str, overwrite: bool = False) -> str:
    """Create a struct. members is JSON: [{"name":"field1","type":"uint32_t"},{"name":"field2","type":"char*"}]"""
    try:
        members_list = json.loads(members)
    except json.JSONDecodeError as e:
        return f"Error: Invalid JSON for members: {str(e)}"
    
    response = lattice_client.create_struct(name, members_list, overwrite)
    if response and 'status' in response:
        if response['status'] == 'success':
            struct_info = response.get('structure', {})
            if struct_info:
                result = f"Structure '{name}' created successfully (size={struct_info.get('size', 'unknown')})"
                members_info = struct_info.get('members', [])
                if members_info:
                    result += "\nMembers:"
                    for m in members_info:
                        result += f"\n  +{m['offset']:04x}: {m['type']} {m['name']}"
                return result
            return response.get('message', 'Structure created successfully')
        else:
            return f"Error: {response.get('message', 'Unknown error')}"
    return "Error: Could not create structure"

@mcp.tool()
def update_struct(name: str, members: str) -> str:
    """Update existing struct. members is JSON: [{"name":"field1","type":"uint32_t"}]"""
    try:
        members_list = json.loads(members)
    except json.JSONDecodeError as e:
        return f"Error: Invalid JSON for members: {str(e)}"
    
    response = lattice_client.update_struct(name, members_list)
    if response and 'status' in response:
        if response['status'] == 'success':
            struct_info = response.get('structure', {})
            if struct_info:
                result = f"Structure '{name}' updated successfully (size={struct_info.get('size', 'unknown')})"
                members_info = struct_info.get('members', [])
                if members_info:
                    result += "\nMembers:"
                    for m in members_info:
                        result += f"\n  +{m['offset']:04x}: {m['type']} {m['name']}"
                return result
            return response.get('message', 'Structure updated successfully')
        else:
            return f"Error: {response.get('message', 'Unknown error')}"
    return "Error: Could not update structure"

@mcp.tool()
def update_function_name(name: str, new_name: str) -> str:
    """Rename a function. name is current name, new_name is desired name."""
    response = lattice_client.update_function_name(name, new_name)
    if response and 'status' in response and response['status'] == 'success':
        return f"Successfully renamed function {name} to {new_name}"
    return f"Error: Could not update function name {name}"

@mcp.tool()
def add_comment_to_address(address: int, comment: str) -> str:
    """Add comment at address. address is integer."""
    response = lattice_client.add_comment_to_address(address, comment)
    if response and 'status' in response and response['status'] == 'success':
        return f"Successfully added comment to address {address}"
    return f"Error: Could not add comment to address {address}"

@mcp.tool()
def add_comment_to_function(name: str, comment: str) -> str:
    """Add comment to function by name."""
    response = lattice_client.add_comment_to_function(name, comment)
    if response and 'status' in response and response['status'] == 'success':
        return f"Successfully added comment to function {name}"
    return f"Error: Could not add comment to function {name}"

@mcp.tool()
def get_function_disassembly(name: str) -> str:
    """Get assembly instructions for function by name."""
    response = lattice_client.get_function_disassembly(name)
    if response and 'status' in response and response['status'] == 'success':
        return '\n'.join([f"{block['address']}: {block['text']}" for block in response['disassembly']])
    return f"Error: Could not retrieve function disassembly for function {name}"

@mcp.tool()
def get_function_pseudocode(name: str) -> str:
    """Get decompiled C-like pseudocode for function by name."""
    response = lattice_client.get_function_pseudocode(name)
    if response and 'status' in response and response['status'] == 'success':
        return '\n'.join([f"{block['address']}: {block['text']}" for block in response['pseudocode']])
    return f"Error: Could not retrieve function pseudocode for function {name}"

@mcp.tool()
def get_function_variables(name: str) -> str:
    """Get parameters, local variables, and global variables for function by name."""
    response = lattice_client.get_function_variables(name)
    if response and 'status' in response and response['status'] == 'success':
        rstr = 'Parameters: ' + '\n'.join([f"{param['name']}: {param['type']}" for param in response['variables']['parameters']]) \
        + '\nLocal Variables: ' + '\n'.join([f"{var['name']}: {var['type']}" for var in response['variables']['local_variables']]) \
        + '\nGlobal Variables: ' + '\n'.join([f"{var['name']}: {var['type']}" for var in response['variables']['global_variables']])
        return rstr

    return f"Error: Could not retrieve function variables for function {name}"

@mcp.tool()
def update_variable_name(function_name: str, var_name: str, new_name: str) -> str:
    """Rename variable in function. Provide function_name, current var_name, and new_name."""
    response = lattice_client.update_variable_name(function_name, var_name, new_name)
    if response and 'status' in response and response['status'] == 'success':
        return f"Successfully renamed variable {var_name} to {new_name}"
    return f"Error: Could not update variable name {var_name}"

@mcp.tool()
def set_variable_type(function_name: str, variable_name: str, type_name: str) -> str:
    """Set variable type. type_name is C-style like 'uint32_t' or 'char*'."""
    response = lattice_client.set_variable_type(function_name, variable_name, type_name)
    if response and 'status' in response and response['status'] == 'success':
        return f"Successfully set variable '{variable_name}' type to '{type_name}' in function '{function_name}'"
    error_msg = response.get('message', 'Unknown error') if response else 'No response'
    return f"Error: Could not set variable type - {error_msg}"

@mcp.tool()
def set_function_signature(function_name: str, signature: str) -> str:
    """Set function prototype. signature is C-style like 'int foo(char* arg1, int arg2)'."""
    response = lattice_client.set_function_signature(function_name, signature)
    if response and 'status' in response and response['status'] == 'success':
        return f"Successfully updated function '{function_name}' signature to '{signature}'"
    error_msg = response.get('message', 'Unknown error') if response else 'No response'
    return f"Error: Could not set function signature - {error_msg}"

@mcp.tool()
def get_global_variable_data(function_name: str, global_var_name: str) -> str:
    """Read data from global variable referenced in function."""
    response = lattice_client.get_global_variable_data(function_name, global_var_name)
    if response and 'status' in response and response['status'] == 'success':
        return response['message']
    return f"Error: Could not retrieve global variable data for function {function_name} and variable {global_var_name}"

@mcp.tool()
def get_cross_references_to_function(name: str) -> str:
    """List functions that call the specified function."""
    response = lattice_client.get_cross_references_to_function(name)
    if response and 'status' in response and response['status'] == 'success':
        return '\n'.join([f"{ref['function']}" for ref in response['cross_references']])
    return f"Error: Could not retrieve cross references for function {name}"

def _format_call_graph_tree(nodes: list, prefix: str = "", is_last: bool = True, direction: str = "callee") -> list:
    """Helper function to format call graph nodes as a tree structure"""
    lines = []
    for i, node in enumerate(nodes):
        is_node_last = (i == len(nodes) - 1)
        connector = "└── " if is_node_last else "├── "
        lines.append(f"{prefix}{connector}{node['name']} @ 0x{node['address']:x}")
        
        # Get nested nodes based on direction
        nested_key = 'callees' if direction == 'callee' else 'callers'
        nested = node.get(nested_key, [])
        if nested:
            extension = "    " if is_node_last else "│   "
            lines.extend(_format_call_graph_tree(nested, prefix + extension, is_node_last, direction))
    return lines

@mcp.tool()
def get_call_graph(function_name: str, depth: int = 1) -> str:
    """Get callers and callees of function. depth controls traversal depth (1-10)."""
    response = lattice_client.get_call_graph(function_name, depth)
    if response and 'status' in response and response['status'] == 'success':
        call_graph = response.get('call_graph', {})
        
        result_lines = []
        result_lines.append(f"Call Graph for: {call_graph['name']} @ 0x{call_graph['address']:x}")
        result_lines.append(f"Depth: {depth}")
        result_lines.append("")
        
        # Format callers
        callers = call_graph.get('callers', [])
        result_lines.append(f"Callers ({len(callers)}):")
        if callers:
            result_lines.extend(_format_call_graph_tree(callers, "  ", True, "caller"))
        else:
            result_lines.append("  (none)")
        
        result_lines.append("")
        
        # Format callees
        callees = call_graph.get('callees', [])
        result_lines.append(f"Callees ({len(callees)}):")
        if callees:
            result_lines.extend(_format_call_graph_tree(callees, "  ", True, "callee"))
        else:
            result_lines.append("  (none)")
        
        return '\n'.join(result_lines)
    
    # Handle error responses
    if response and 'message' in response:
        return f"Error: {response['message']}"
    return f"Error: Could not retrieve call graph for function {function_name}"

@mcp.tool()
def create_tag(address: int, tag_type: str, data: str = None) -> str:
    """Create tag at address. tag_type is category name, data is optional description."""
    response = lattice_client.create_tag(address, tag_type, data)
    if response and 'status' in response and response['status'] == 'success':
        tag = response.get('tag', {})
        result_lines = [f"Tag created at 0x{tag.get('address', address):x}"]
        result_lines.append(f"Type: {tag.get('type', tag_type)}")
        if tag.get('data'):
            result_lines.append(f"Data: {tag.get('data')}")
        if tag.get('function'):
            result_lines.append(f"Function: {tag.get('function')}")
        return '\n'.join(result_lines)
    
    if response and 'message' in response:
        return f"Error: {response['message']}"
    return "Error: Could not create tag"

@mcp.tool()
def get_tags(tag_type: str = None) -> str:
    """List all tags. tag_type optionally filters by category."""
    response = lattice_client.get_tags(tag_type)
    if response and 'status' in response and response['status'] == 'success':
        tags = response.get('tags', [])
        if not tags:
            return "No tags found" + (f" with type '{tag_type}'" if tag_type else "")
        
        result_lines = [f"Found {len(tags)} tag(s):"]
        for tag in tags:
            line = f"  0x{tag['address']:x}: [{tag['type']}]"
            if tag.get('data'):
                line += f" - {tag['data']}"
            if tag.get('function'):
                line += f" (in {tag['function']})"
            result_lines.append(line)
        return '\n'.join(result_lines)
    
    if response and 'message' in response:
        return f"Error: {response['message']}"
    return "Error: Could not retrieve tags"


@mcp.tool()
def get_analysis_progress() -> str:
    """Get Binary Ninja analysis status: state, completion, and progress percentage."""
    response = lattice_client.get_analysis_progress()
    if response and 'status' in response and response['status'] == 'success':
        state = response.get('state', 'Unknown')
        is_complete = response.get('is_complete', False)
        progress = response.get('progress', 0.0)
        description = response.get('description', '')
        
        status_str = "Complete" if is_complete else "In Progress"
        progress_pct = f"{progress * 100:.1f}%"
        
        return f"Analysis Status: {status_str}\nState: {state}\nProgress: {progress_pct}\nDescription: {description}"
    
    if response and 'message' in response:
        return f"Error: {response['message']}"
    return "Error: Could not retrieve analysis progress"


# Initialize and run the server
api_key = os.getenv("BNJLAT")
if not api_key:
    raise ValueError("BNJLAT environment variable not set")

global lattice_client
lattice_client = Lattice()
print(f"Authenticating with {api_key}")
lattice_client.authenticate("mcp-user", api_key)
mcp.run(transport='stdio')

```

`plugin/__init__.py`:

```py
"""
Binary Ninja Lattice Server Plugin
""" 
```

`plugin/lattice_server_plugin.py`:

```py
from binaryninja import *
from binaryninja.binaryview import BinaryView
from binaryninja.enums import DisassemblyOption
from binaryninja.function import DisassemblySettings, Function 
from binaryninja.lineardisassembly import LinearViewCursor, LinearViewObject
from binaryninja.plugin import PluginCommand
from binaryninja.log import Logger
from typing import Optional, Dict, Any, List, Tuple
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs, unquote
import json
import os
import secrets
import time
import ssl
import re
import traceback
import threading

logger = Logger(session_id=0, logger_name=__name__)

class AuthManager:
    """Manages authentication for the Lattice Protocol"""
    def __init__(self, token_expiry_seconds=28800):
        """
        Initialize the authentication manager
        
        Args:
            token_expiry_seconds: How long tokens are valid (default: 1 hour)
        """
        self.token_expiry_seconds = token_expiry_seconds
        self.tokens = {}  # Map of token -> (expiry_time, client_info)
        
        # Generate a secure API key on startup
        self.api_key = secrets.token_hex(16)
        logger.log_info(f"API key: {self.api_key}")
    
    def generate_token(self, client_info: Dict[str, Any]) -> str:
        """
        Generate a new authentication token
        
        Args:
            client_info: Information about the client requesting the token
            
        Returns:
            A new authentication token
        """
        token = secrets.token_hex(16)
        expiry = time.time() + self.token_expiry_seconds
        self.tokens[token] = (expiry, client_info)
        
        # Cleanup expired tokens
        self._cleanup_expired_tokens()
        
        return token
    
    def validate_token(self, token: str) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """
        Validate an authentication token
        
        Args:
            token: The token to validate
            
        Returns:
            Tuple of (is_valid, client_info)
        """
        logger.log_info(f"Validating token: {token}")
        if token not in self.tokens:
            return False, None
        
        expiry, client_info = self.tokens[token]
        
        if time.time() > expiry:
            # Token has expired
            del self.tokens[token]
            return False, None
        
        return True, client_info
    
    def revoke_token(self, token: str) -> bool:
        """
        Revoke a token
        
        Args:
            token: The token to revoke
            
        Returns:
            True if the token was revoked, False if it didn't exist
        """
        if token in self.tokens:
            del self.tokens[token]
            return True
        return False
    
    def _cleanup_expired_tokens(self):
        """Remove expired tokens from the tokens dictionary"""
        current_time = time.time()
        expired_tokens = [
            token for token, (expiry, _) in self.tokens.items() 
            if current_time > expiry
        ]
        
        for token in expired_tokens:
            del self.tokens[token]
    
    def verify_credentials(self, password: str) -> bool:
        """
        Verify a username and password against stored credentials.
        For simplicity, this just verifies against the API key.
        In a real implementation, this would check against a secure credential store.
        
        Args:
            username: The username to tie to session token
            password: The password to verify
            
        Returns:
            True if the credentials are valid, False otherwise
        """
        # For simplicity, we're using the API key as the "password"
        # In a real implementation, this would use secure password hashing
        return password == self.api_key

class LatticeRequestHandler(BaseHTTPRequestHandler):
    """HTTP request handler for the Lattice Protocol"""
    
    def __init__(self, *args, **kwargs):
        self.protocol = kwargs.pop('protocol')
        super().__init__(*args, **kwargs)
    
    def _send_response(self, data: Dict[str, Any], status: int = 200):
        """Send JSON response"""
        self.send_response(status)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps(data).encode())
    
    def _require_auth(self, handler):
        """Decorator to require authentication"""
        def decorated(*args, **kwargs):
            auth_header = self.headers.get('Authorization')
            if not auth_header:
                self._send_response({'status': 'error', 'message': 'No token provided'}, 401)
                return
            
            # Remove 'Bearer ' prefix if present
            token = auth_header[7:] if auth_header.startswith('Bearer ') else auth_header
            
            is_valid, client_info = self.protocol.auth_manager.validate_token(token)
            if not is_valid:
                self._send_response({'status': 'error', 'message': 'Invalid token'}, 401)
                return
            
            return handler(*args, **kwargs)
        return decorated
    
    def do_POST(self):
        """Handle POST requests"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        try:
            content_length = int(self.headers.get('Content-Length', 0))
            body = self.rfile.read(content_length)
            data = json.loads(body.decode())
        except Exception as e:
            self._send_response({'status': 'error', 'message': str(e)}, 400)
            return
        
        if path == '/auth':
            self._handle_auth(data)
        elif path == '/search/bytes':
            self._require_auth(self._handle_search_bytes)(data)
        elif path == '/types/struct':
            self._require_auth(self._handle_create_struct)(data)
        elif path.startswith('/comments/'):
            self._require_auth(self._handle_add_comment_to_address)(data)
        elif path.startswith('/functions/'):
            logger.log_info(f"Handling add comment to function request: {data}")
            self._require_auth(self._handle_add_comment_to_function)(data)
        elif path == '/tags':
            self._require_auth(self._handle_create_tag)(data)
        else:
            self._send_response({'status': 'error', 'message': 'Invalid endpoint'}, 404)
    
    def do_PUT(self):
        """Handle PUT requests"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        try:
            content_length = int(self.headers.get('Content-Length', 0))
            body = self.rfile.read(content_length)
            data = json.loads(body.decode())
        except Exception as e:
            self._send_response({'status': 'error', 'message': str(e)}, 400)
            return
        
        if path.startswith('/functions/') and path.endswith('/name'):
            self._require_auth(self._handle_update_function_name)(data)
        elif path.startswith('/variables/') and path.endswith('/name'):
            self._require_auth(self._handle_update_variable_name)(data)
        elif path.startswith('/types/struct/'):
            self._require_auth(self._handle_update_struct)(data)
        elif path.startswith('/functions/') and '/variables/' in path and path.endswith('/type'):
            self._require_auth(self._handle_set_variable_type)(data)
        elif path.startswith('/functions/') and path.endswith('/signature'):
            self._require_auth(self._handle_set_function_signature)(data)
        else:
            self._send_response({'status': 'error', 'message': 'Invalid endpoint'}, 404)
    
    def do_GET(self):
        """Handle GET requests"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        if path == '/binary/info':
            self._require_auth(self._handle_get_binary_info)()
        elif path == '/strings':
            self._require_auth(self._handle_get_strings)()
        elif path == '/imports':
            self._require_auth(self._handle_get_imports)()
        elif path == '/exports':
            self._require_auth(self._handle_get_exports)()
        elif path == '/functions':
            self._require_auth(self._handle_get_all_function_names)()
        elif path.startswith('/functions/'):
            if path.startswith('/functions/name/'):
                self._require_auth(self._handle_get_function_context_by_name)()
            elif path.endswith('/disassembly'):
                self._require_auth(self._handle_get_function_disassembly)()
            elif path.endswith('/pseudocode'):
                self._require_auth(self._handle_get_function_pseudocode)()
            elif path.endswith('/variables'):
                self._require_auth(self._handle_get_function_variables)()
            elif path.endswith('/callgraph'):
                self._require_auth(self._handle_get_call_graph)()
            else:
                self._require_auth(self._handle_get_function_context_by_address)()
        elif path.startswith('/global_variable_data'):
            self._require_auth(self._handle_get_global_variable_data)()
        elif path.startswith('/cross-references/'):
            self._require_auth(self._handle_get_cross_references_to_function)()
        elif path.startswith('/data/'):
            self._require_auth(self._handle_get_data_at_address)()
        elif path == '/types':
            self._require_auth(self._handle_get_types)()
        elif path == '/tags':
            self._require_auth(self._handle_get_tags)()
        elif path == '/analysis/progress':
            self._require_auth(self._handle_get_analysis_progress)()
        else:
            self._send_response({'status': 'error', 'message': 'Invalid endpoint'}, 404)
    
    def _handle_auth(self, data):
        """Handle authentication requests"""
        username = data.get('username')
        password = data.get('password')
        token = data.get('token')
        
        if token:
            is_valid, client_info = self.protocol.auth_manager.validate_token(token)
            if is_valid:
                self._send_response({
                    'status': 'success',
                    'message': 'Authentication successful',
                    'token': token
                })
                return
        
        if password:
            if self.protocol.auth_manager.verify_credentials(password):
                client_info = {'username': username, 'address': self.client_address[0]}
                new_token = self.protocol.auth_manager.generate_token(client_info)
                self._send_response({
                    'status': 'success',
                    'message': 'Authentication successful',
                    'token': new_token
                })
                return
        
        self._send_response({'status': 'error', 'message': 'Authentication failed'}, 401)
    
    def _handle_get_binary_info(self):
        """Handle requests for binary information"""
        try:
            binary_info = {
                'filename': self.protocol.bv.file.filename,
                'file_size': self.protocol.bv.end,
                'start': self.protocol.bv.start,
                'end': self.protocol.bv.end,
                'entry_point': self.protocol.bv.entry_point,
                'arch': self.protocol.bv.arch.name,
                'platform': self.protocol.bv.platform.name,
                'segments': self.protocol._get_segments_info(),
                'sections': self.protocol._get_sections_info(),
                'functions_count': len(self.protocol.bv.functions),
                'symbols_count': len(self.protocol.bv.symbols)
            }
            
            self._send_response({
                'status': 'success',
                'binary_info': binary_info
            })
            
        except Exception as e:
            logger.log_error(f"Error getting binary info: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_get_strings(self):
        """Handle requests for strings in the binary with optional filtering"""
        try:
            parsed_path = urlparse(self.path)
            query_params = parse_qs(parsed_path.query)
            
            # Get filter parameters
            min_length = int(query_params.get('min_length', ['4'])[0])
            filter_str = query_params.get('filter', [None])[0]
            
            strings_list = []
            for string_ref in self.protocol.bv.get_strings():
                # Apply minimum length filter
                if string_ref.length < min_length:
                    continue
                
                # Apply substring filter (case-insensitive)
                if filter_str and filter_str.lower() not in string_ref.value.lower():
                    continue
                
                strings_list.append({
                    'address': string_ref.start,
                    'value': string_ref.value,
                    'length': string_ref.length
                })
            
            self._send_response({
                'status': 'success',
                'strings': strings_list
            })
            
        except Exception as e:
            logger.log_error(f"Error getting strings: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_get_imports(self):
        """Handle requests for imported functions in the binary"""
        try:
            imports_list = []
            for sym in self.protocol.bv.get_symbols_of_type(SymbolType.ImportedFunctionSymbol):
                # Convert NameSpace to string for JSON serialization
                library = str(sym.namespace) if sym.namespace else ''
                imports_list.append({
                    'name': sym.name,
                    'address': sym.address,
                    'library': library
                })

            self._send_response({
                'status': 'success',
                'imports': imports_list
            })

        except Exception as e:
            logger.log_error(f"Error getting imports: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_get_exports(self):
        """Handle requests for exported functions in the binary"""
        try:
            exports_list = []
            for sym in self.protocol.bv.get_symbols_of_type(SymbolType.FunctionSymbol):
                if sym.binding == SymbolBinding.GlobalBinding:
                    exports_list.append({
                        'name': sym.name,
                        'address': sym.address
                    })

            self._send_response({
                'status': 'success',
                'exports': exports_list
            })

        except Exception as e:
            logger.log_error(f"Error getting exports: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_get_data_at_address(self):
        """Handle requests for reading data at a specific address"""
        try:
            parsed_path = urlparse(self.path)
            query_params = parse_qs(parsed_path.query)

            # Extract address from path: /data/{address}
            path_parts = parsed_path.path.split('/')
            if len(path_parts) < 3:
                self._send_response({'status': 'error', 'message': 'Address required'}, 400)
                return

            # Parse address (supports hex with 0x prefix or decimal)
            addr_str = path_parts[2]
            try:
                if addr_str.startswith('0x') or addr_str.startswith('0X'):
                    address = int(addr_str, 16)
                else:
                    address = int(addr_str)
            except ValueError:
                self._send_response({'status': 'error', 'message': f'Invalid address format: {addr_str}'}, 400)
                return

            # Get query parameters
            length = int(query_params.get('length', ['16'])[0])
            type_name = query_params.get('type', [None])[0]

            # Check if address is readable
            if not self.protocol.bv.is_valid_offset(address):
                self._send_response({
                    'status': 'error',
                    'message': f'Address 0x{address:x} is not readable'
                }, 400)
                return

            # Read raw bytes
            data = self.protocol.bv.read(address, length)
            if data is None:
                self._send_response({
                    'status': 'error',
                    'message': f'Address 0x{address:x} is not readable'
                }, 400)
                return

            # Check if we got less data than requested
            actual_length = len(data)
            truncated = actual_length < length

            response = {
                'status': 'success',
                'address': address,
                'hex': data.hex(),
                'length': actual_length
            }

            if truncated:
                response['warning'] = f'Only {actual_length} bytes available (requested {length})'
                response['truncated'] = True

            # If type is specified, try to interpret the data
            if type_name:
                try:
                    type_obj, _ = self.protocol.bv.parse_type_string(type_name)
                    if type_obj:
                        # Get typed interpretation
                        data_var = self.protocol.bv.get_data_var_at(address)
                        if data_var:
                            response['typed_value'] = str(data_var.value)
                        else:
                            # Try to interpret based on common types
                            response['type'] = type_name
                            response['type_size'] = type_obj.width
                except Exception as type_err:
                    response['type_error'] = f'Could not interpret as {type_name}: {str(type_err)}'

            self._send_response(response)

        except Exception as e:
            logger.log_error(f"Error reading data at address: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_search_bytes(self, data):
        """Handle requests for searching byte patterns in the binary

        Supports hex patterns with optional ?? wildcards for any byte.
        Example patterns: "48 89 5c 24", "48 ?? 5c ??", "488b"
        """
        try:
            pattern = data.get('pattern', '')
            max_results = data.get('max_results', 100)

            if not pattern:
                self._send_response({'status': 'error', 'message': 'Pattern required'}, 400)
                return

            # Parse the hex pattern, handling spaces and wildcards
            pattern_clean = pattern.replace(' ', '').upper()

            # Validate pattern length (must be even number of hex chars)
            if len(pattern_clean) % 2 != 0:
                self._send_response({
                    'status': 'error',
                    'message': 'Invalid pattern: must have even number of hex characters'
                }, 400)
                return

            # Parse pattern into bytes and mask
            pattern_bytes = []
            mask_bytes = []
            has_wildcards = False

            for i in range(0, len(pattern_clean), 2):
                byte_str = pattern_clean[i:i+2]
                if byte_str == '??':
                    pattern_bytes.append(0x00)
                    mask_bytes.append(0x00)  # 0 mask = don't care
                    has_wildcards = True
                else:
                    try:
                        byte_val = int(byte_str, 16)
                        pattern_bytes.append(byte_val)
                        mask_bytes.append(0xFF)  # FF mask = must match
                    except ValueError:
                        self._send_response({
                            'status': 'error',
                            'message': f'Invalid hex byte: {byte_str}'
                        }, 400)
                        return

            pattern_len = len(pattern_bytes)
            results = []
            truncated = False

            if not has_wildcards:
                # Use Binary Ninja's optimized search for exact patterns
                search_bytes = bytes(pattern_bytes)
                bv = self.protocol.bv

                try:
                    for match in bv.find_all_data(bv.start, bv.end, search_bytes):
                        # find_all_data returns tuples of (address, DataBuffer) or just addresses
                        if isinstance(match, tuple):
                            addr = match[0]  # First element is the address
                        elif isinstance(match, int):
                            addr = match
                        elif hasattr(match, 'start'):
                            addr = match.start
                        else:
                            # Skip if we can't determine the address
                            continue
                        results.append({'address': int(addr)})
                        if len(results) >= max_results:
                            truncated = True
                            break
                except Exception as search_err:
                    logger.log_error(f"Error in find_all_data: {search_err}")
                    # Fall back to manual search
                    has_wildcards = True
            else:
                # Manual search with masking for wildcard patterns
                bv = self.protocol.bv

                # Search through all segments
                for segment in bv.segments:
                    if len(results) >= max_results:
                        truncated = True
                        break

                    seg_start = segment.start
                    seg_end = segment.end
                    seg_len = seg_end - seg_start

                    # Read segment data
                    seg_data = bv.read(seg_start, seg_len)
                    if seg_data is None:
                        continue

                    # Search within segment
                    for offset in range(len(seg_data) - pattern_len + 1):
                        if len(results) >= max_results:
                            truncated = True
                            break

                        match = True
                        for j in range(pattern_len):
                            if mask_bytes[j] != 0:  # Only check non-wildcard bytes
                                if seg_data[offset + j] != pattern_bytes[j]:
                                    match = False
                                    break

                        if match:
                            results.append({'address': seg_start + offset})

            # Sort results by address ascending
            results.sort(key=lambda x: x['address'])

            response = {
                'status': 'success',
                'pattern': pattern,
                'results': results,
                'count': len(results)
            }

            if truncated:
                response['truncated'] = True
                response['message'] = f'Results limited to {max_results}'

            self._send_response(response)

        except Exception as e:
            logger.log_error(f"Error searching bytes: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_get_types(self):
        """Handle requests for defined types in the binary with optional filtering"""
        try:
            parsed_path = urlparse(self.path)
            query_params = parse_qs(parsed_path.query)
            
            # Get filter parameter
            filter_str = query_params.get('filter', [None])[0]
            
            types_list = []
            for type_name, type_obj in self.protocol.bv.types.items():
                try:
                    # Convert QualifiedName to string
                    name_str = str(type_name)
                    
                    # Apply name filter (case-insensitive)
                    if filter_str and filter_str.lower() not in name_str.lower():
                        continue
                    
                    type_info = {
                        'name': name_str,
                        'size': type_obj.width if hasattr(type_obj, 'width') else 0
                    }
                    
                    # Determine kind based on type_class
                    type_class = type_obj.type_class if hasattr(type_obj, 'type_class') else None
                    
                    if type_class == TypeClass.StructureTypeClass:
                        type_info['kind'] = 'struct'
                        members = []
                        # Access structure members safely
                        try:
                            struct = type_obj.structure
                            if struct and hasattr(struct, 'members'):
                                for m in struct.members:
                                    members.append({
                                        'name': m.name,
                                        'type': str(m.type),
                                        'offset': m.offset
                                    })
                        except Exception:
                            pass
                        type_info['members'] = members
                    elif type_class == TypeClass.EnumerationTypeClass:
                        type_info['kind'] = 'enum'
                        members = []
                        try:
                            enum = type_obj.enumeration
                            if enum and hasattr(enum, 'members'):
                                for m in enum.members:
                                    members.append({
                                        'name': m.name,
                                        'value': m.value
                                    })
                        except Exception:
                            pass
                        type_info['members'] = members
                    elif type_class == TypeClass.NamedTypeReferenceClass:
                        type_info['kind'] = 'typedef'
                    elif type_class == TypeClass.FunctionTypeClass:
                        type_info['kind'] = 'function'
                    elif type_class == TypeClass.PointerTypeClass:
                        type_info['kind'] = 'pointer'
                    elif type_class == TypeClass.ArrayTypeClass:
                        type_info['kind'] = 'array'
                    else:
                        type_info['kind'] = str(type_class).split('.')[-1].replace('TypeClass', '').lower() if type_class else 'unknown'
                    
                    types_list.append(type_info)
                except Exception as inner_e:
                    # Skip types that cause errors
                    logger.log_warn(f"Skipping type {type_name}: {inner_e}")
                    continue
            
            self._send_response({
                'status': 'success',
                'types': types_list
            })
            
        except Exception as e:
            logger.log_error(f"Error getting types: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_create_struct(self, data):
        """Handle requests to create a new structure type

        Expected JSON body:
        {
            "name": "MyStruct",
            "members": [
                {"name": "field1", "type": "uint32_t"},
                {"name": "field2", "type": "char*", "count": 1}
            ],
            "overwrite": false  # optional, default false
        }
        """
        try:
            name = data.get('name')
            members = data.get('members', [])
            overwrite = data.get('overwrite', False)

            if not name:
                self._send_response({'status': 'error', 'message': 'Structure name is required'}, 400)
                return

            if not members:
                self._send_response({'status': 'error', 'message': 'Structure must have at least one member'}, 400)
                return

            bv = self.protocol.bv

            # Check if structure already exists
            existing_type = None
            for type_name, type_obj in bv.types.items():
                if str(type_name) == name:
                    existing_type = type_obj
                    break

            if existing_type and not overwrite:
                self._send_response({
                    'status': 'error',
                    'message': f"Structure '{name}' already exists. Use overwrite=true to replace."
                }, 409)
                return

            # Validate member types and build structure
            struct_builder = StructureBuilder.create()

            for member in members:
                member_name = member.get('name')
                member_type_str = member.get('type')
                member_count = member.get('count', 1)

                if not member_name or not member_type_str:
                    self._send_response({
                        'status': 'error',
                        'message': 'Each member must have a name and type'
                    }, 400)
                    return

                # Parse the type string
                try:
                    parsed_type, _ = bv.parse_type_string(member_type_str)
                except Exception as e:
                    self._send_response({
                        'status': 'error',
                        'message': f"Member type '{member_type_str}' does not exist or is invalid: {str(e)}"
                    }, 400)
                    return

                # Handle array types
                if member_count > 1:
                    parsed_type = Type.array(parsed_type, member_count)

                struct_builder.append(parsed_type, member_name)

            # Define the structure type
            bv.define_user_type(name, struct_builder.immutable_copy())

            # Retrieve the created structure to return its info
            # Use types dictionary to get the actual type object
            created_type = None
            for type_name, type_obj in bv.types.items():
                if str(type_name) == name:
                    created_type = type_obj
                    break

            if created_type:
                result_members = []
                try:
                    # Check if it's a structure type and get members
                    if hasattr(created_type, 'type_class') and created_type.type_class == TypeClass.StructureTypeClass:
                        struct = created_type.structure
                        if struct and hasattr(struct, 'members'):
                            for m in struct.members:
                                result_members.append({
                                    'name': m.name,
                                    'type': str(m.type),
                                    'offset': m.offset
                                })
                except Exception as member_err:
                    logger.log_warn(f"Could not get structure members: {member_err}")

                self._send_response({
                    'status': 'success',
                    'message': f"Structure '{name}' created successfully",
                    'structure': {
                        'name': name,
                        'size': created_type.width if hasattr(created_type, 'width') else 0,
                        'members': result_members
                    }
                })
            else:
                self._send_response({
                    'status': 'success',
                    'message': f"Structure '{name}' created successfully"
                })

        except Exception as e:
            logger.log_error(f"Error creating structure: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_update_struct(self, data):
        """Handle requests to update an existing structure type

        Expected JSON body:
        {
            "members": [
                {"name": "field1", "type": "uint32_t"},
                {"name": "field2", "type": "char*", "count": 1}
            ]
        }

        The structure name is extracted from the URL path.
        """
        try:
            # Extract structure name from URL path
            parsed_path = urlparse(self.path)
            path = parsed_path.path
            # Path format: /types/struct/{name}
            path_parts = path.split('/')
            if len(path_parts) < 4:
                self._send_response({'status': 'error', 'message': 'Invalid path format'}, 400)
                return

            name = path_parts[3]  # /types/struct/{name}
            members = data.get('members', [])

            if not members:
                self._send_response({'status': 'error', 'message': 'Structure must have at least one member'}, 400)
                return

            bv = self.protocol.bv

            # Check if structure exists
            existing_type = None
            for type_name, type_obj in bv.types.items():
                if str(type_name) == name:
                    existing_type = type_obj
                    break

            if not existing_type:
                self._send_response({
                    'status': 'error',
                    'message': f"Structure '{name}' does not exist"
                }, 404)
                return

            # Validate member types and build new structure
            struct_builder = StructureBuilder.create()

            for member in members:
                member_name = member.get('name')
                member_type_str = member.get('type')
                member_count = member.get('count', 1)

                if not member_name or not member_type_str:
                    self._send_response({
                        'status': 'error',
                        'message': 'Each member must have a name and type'
                    }, 400)
                    return

                # Parse the type string
                try:
                    parsed_type, _ = bv.parse_type_string(member_type_str)
                except Exception as e:
                    self._send_response({
                        'status': 'error',
                        'message': f"Member type '{member_type_str}' does not exist or is invalid: {str(e)}"
                    }, 400)
                    return

                # Handle array types
                if member_count > 1:
                    parsed_type = Type.array(parsed_type, member_count)

                struct_builder.append(parsed_type, member_name)

            # Update the structure type (define_user_type will replace existing)
            bv.define_user_type(name, struct_builder.immutable_copy())

            # Retrieve the updated structure to return its info
            # Use types dictionary to get the actual type object
            updated_type = None
            for type_name, type_obj in bv.types.items():
                if str(type_name) == name:
                    updated_type = type_obj
                    break

            if updated_type:
                result_members = []
                try:
                    # Check if it's a structure type and get members
                    if hasattr(updated_type, 'type_class') and updated_type.type_class == TypeClass.StructureTypeClass:
                        struct = updated_type.structure
                        if struct and hasattr(struct, 'members'):
                            for m in struct.members:
                                result_members.append({
                                    'name': m.name,
                                    'type': str(m.type),
                                    'offset': m.offset
                                })
                except Exception as member_err:
                    logger.log_warn(f"Could not get structure members: {member_err}")

                self._send_response({
                    'status': 'success',
                    'message': f"Structure '{name}' updated successfully",
                    'structure': {
                        'name': name,
                        'size': updated_type.width if hasattr(updated_type, 'width') else 0,
                        'members': result_members
                    }
                })
            else:
                self._send_response({
                    'status': 'success',
                    'message': f"Structure '{name}' updated successfully"
                })

        except Exception as e:
            logger.log_error(f"Error updating structure: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)



    def _get_function_context(self, address: int) -> Dict[str, Any]:
        res = self.protocol.bv.get_functions_containing(address)
        func = None
        if len(res) > 0:
            func = res[0]
        else:
            return None
        
        function_info = {
            'name': func.name,
            'start': func.address_ranges[0].start,
            'end': func.address_ranges[0].end,
            'pseudo_c': self._get_pseudo_c_text(self.protocol.bv, func),
            'call_sites': self._get_call_sites(func),
            'basic_blocks': self._get_basic_blocks_info(func),
            'parameters': self._get_parameters(func),
            'variables': self._get_variables(func),
            'global_variables': self._get_global_variables(),
            'disassembly': self._get_disassembly(func),
            'incoming_calls': self._get_incoming_calls(func)
        }
        return function_info

    def _handle_get_function_context_by_address(self):
        """Handle requests for function context"""
        try:
            address = int(self.path.split('/')[-1], 0)
            function_info = self._get_function_context(address)
            if function_info is None:
                self._send_response({'status': 'error', 'message': f'No function found at address 0x{address:x}'}, 404)
                return
            
            self._send_response({
                'status': 'success',
                'function': function_info
            })
            
        except Exception as e:
            logger.log_error(f"Error getting function context: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)
    
    def _handle_get_function_context_by_name(self):
        """Handle requests for function context by name"""
        try:
            name = self.path.split('/')[-1]
            res = self.protocol.bv.get_functions_by_name(name)
            func = None
            if len(res) > 0:
                func = res[0]
            else:
                self._send_response({'status': 'error', 'message': f'No function found with name: {name}'}, 404)
                return
            
            function_info = self._get_function_context(func.start)
            if function_info is None:
                self._send_response({'status': 'error', 'message': f'No function found with name: {name}'}, 404)
                return
            self._send_response({
                'status': 'success',
                'function': function_info
            })
        except Exception as e:
            logger.log_error(f"Error getting function context by name: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)
    
    def _handle_get_all_function_names(self):
        """Handle requests for all function names"""
        try:
            function_names = [{'name': func.name, 'address': func.start} for func in self.protocol.bv.functions]
            self._send_response({
                'status': 'success',
                'function_names': function_names
            })
        except Exception as e:
            logger.log_error(f"Error getting all function names: {e}")
            self._send_response({'status': 'error', 'message': str(e)}, 500)
    
    def _handle_update_function_name(self, data):
        """Handle requests to update function name"""
        try:
            if not data or 'name' not in data:
                self._send_response({'status': 'error', 'message': 'New name is required'}, 400)
                return
            
            new_name = data['name']
            name = self.path.split('/')[-2]
            func = self._get_function_by_name(name)
            if not func:
                self._send_response({'status': 'error', 'message': f'No function found with name {name}'}, 404)
                return
            
            old_name = func.name
            func.name = new_name
            
            self._send_response({
                'status': 'success',
                'message': f'Function name updated from "{old_name}" to "{new_name}"'
            })
            
        except Exception as e:
            logger.log_error(f"Error updating function name: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_update_variable_name(self, data):
        """Handle requests to update variable name"""
        try:
            if not data or 'name' not in data:
                self._send_response({'status': 'error', 'message': 'New name is required'}, 400)
                return
            
            new_name = data['name']
            func_name = self.path.split('/')[-3]
            func = self._get_function_by_name(func_name)
            if not func:
                self._send_response({'status': 'error', 'message': f'No function found at address {func_name}'}, 404)
                return

            # Find the variable by name
            for var in func.vars:
                if var.name == self.path.split('/')[-2]:
                    old_name = var.name
                    var.name = new_name
                    self._send_response({
                        'status': 'success',
                        'message': f'Variable name updated from "{old_name}" to "{new_name}"'
                    })
                    return
            """
                We need to handle the case where the LLM is trying to change
                the name of a global variable. We need to find the global and
                rename it.
            """
            for var in self._get_globals_from_func(func):
                current_var_name = self.path.split('/')[-2]
                if var['name'] == current_var_name:
                    for addr, gvar in self.protocol.bv.data_vars.items():
                        if addr == var['location']:
                            gvar.name = new_name
                            self._send_response({
                                'status': 'success',
                                'message': f'Variable name updated from "{current_var_name}" to "{new_name}"'
                            })
                            return
            
            self._send_response({'status': 'error', 'message': f'No variable with name {self.path.split("/")[-1]} found in function'}, 404)
            
        except Exception as e:
            logger.log_error(f"Error updating variable name: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_set_variable_type(self, data):
        """Handle requests to set a variable's type annotation
        
        Endpoint: PUT /functions/{name}/variables/{var}/type
        Expected JSON body:
        {
            "type": "uint32_t"  # C-style type string
        }
        """
        try:
            if not data or 'type' not in data:
                self._send_response({'status': 'error', 'message': 'Type is required'}, 400)
                return
            
            type_name = data['type']
            
            # Parse path: /functions/{func_name}/variables/{var_name}/type
            path_parts = self.path.split('/')
            func_name = path_parts[2]
            var_name = path_parts[4]
            
            func = self._get_function_by_name(func_name)
            if not func:
                self._send_response({'status': 'error', 'message': f"Function '{func_name}' not found"}, 404)
                return
            
            bv = self.protocol.bv
            
            # Parse and validate the type string
            try:
                parsed_type, _ = bv.parse_type_string(type_name)
            except Exception as e:
                self._send_response({
                    'status': 'error',
                    'message': f"Type '{type_name}' not found or is invalid: {str(e)}"
                }, 400)
                return
            
            # Find the variable in the function
            target_var = None
            for var in func.vars:
                if var.name == var_name:
                    target_var = var
                    break
            
            if not target_var:
                self._send_response({
                    'status': 'error',
                    'message': f"Variable '{var_name}' not found in function '{func_name}'"
                }, 404)
                return
            
            old_type = str(target_var.type)
            
            # Set the variable type using create_user_var
            func.create_user_var(target_var, parsed_type, target_var.name)
            
            self._send_response({
                'status': 'success',
                'message': f"Variable '{var_name}' type updated from '{old_type}' to '{type_name}'",
                'variable': {
                    'name': var_name,
                    'old_type': old_type,
                    'new_type': type_name,
                    'function': func_name
                }
            })
            
        except Exception as e:
            logger.log_error(f"Error setting variable type: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_set_function_signature(self, data):
        """Handle requests to update a function's signature/prototype
        
        Endpoint: PUT /functions/{name}/signature
        Expected JSON body:
        {
            "signature": "int foo(char* arg1, int arg2)"  # C-style function signature
        }
        """
        try:
            if not data or 'signature' not in data:
                self._send_response({'status': 'error', 'message': 'Signature is required'}, 400)
                return
            
            signature = data['signature']
            
            # Parse path: /functions/{func_name}/signature
            path_parts = self.path.split('/')
            func_name = path_parts[2]
            
            func = self._get_function_by_name(func_name)
            if not func:
                self._send_response({'status': 'error', 'message': f"Function '{func_name}' not found"}, 404)
                return
            
            bv = self.protocol.bv
            old_signature = str(func.type)
            
            # Parse the C-style signature using Binary Ninja's type parser
            try:
                parsed_type, _ = bv.parse_type_string(signature)
            except Exception as e:
                self._send_response({
                    'status': 'error',
                    'message': f"Failed to parse signature '{signature}': {str(e)}"
                }, 400)
                return
            
            # Verify the parsed type is a function type
            if not hasattr(parsed_type, 'parameters'):
                self._send_response({
                    'status': 'error',
                    'message': f"Signature '{signature}' does not represent a function type"
                }, 400)
                return
            
            # Set the function's type to the parsed signature
            func.type = parsed_type
            
            self._send_response({
                'status': 'success',
                'message': f"Function '{func_name}' signature updated",
                'function': {
                    'name': func_name,
                    'old_signature': old_signature,
                    'new_signature': str(func.type)
                }
            })
            
        except Exception as e:
            logger.log_error(f"Error setting function signature: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _get_callees(self, func: binaryninja.function.Function, depth: int, visited: set) -> List[Dict[str, Any]]:
        """Get functions called by func, up to depth levels"""
        if depth == 0 or func.start in visited:
            return []
        visited.add(func.start)
        callees = []
        for site in func.call_sites:
            # Get the target address from the call site
            target_addr = None
            # Try to get the target from MLIL if available
            if hasattr(site, 'mlil') and site.mlil:
                mlil = site.mlil
                if hasattr(mlil, 'dest') and hasattr(mlil.dest, 'constant'):
                    target_addr = mlil.dest.constant

            # Fallback: try to get function at the call site address
            if target_addr is None:
                # Get the callee from the call site's referenced address
                for ref in self.protocol.bv.get_callees(site.address):
                    target_addr = ref
                    break

            if target_addr is not None:
                target = self.protocol.bv.get_function_at(target_addr)
                if target and target.start not in visited:
                    callees.append({
                        'name': target.name,
                        'address': target.start,
                        'callees': self._get_callees(target, depth - 1, visited.copy())
                    })
        return callees

    def _get_callers(self, func: binaryninja.function.Function, depth: int, visited: set) -> List[Dict[str, Any]]:
        """Get functions that call func, up to depth levels"""
        if depth == 0 or func.start in visited:
            return []
        visited.add(func.start)
        callers = []
        for ref in self.protocol.bv.get_code_refs(func.start):
            caller_funcs = self.protocol.bv.get_functions_containing(ref.address)
            if caller_funcs:
                caller = caller_funcs[0]
                if caller.start not in visited:
                    callers.append({
                        'name': caller.name,
                        'address': caller.start,
                        'callers': self._get_callers(caller, depth - 1, visited.copy())
                    })
        return callers

    def _handle_get_call_graph(self):
        """Handle requests for call graph of a function"""
        try:
            parsed_path = urlparse(self.path)
            query_params = parse_qs(parsed_path.query)

            # Extract function name from path: /functions/{name}/callgraph
            path_parts = parsed_path.path.split('/')
            func_name = unquote(path_parts[2]) if len(path_parts) > 2 else None

            if not func_name:
                self._send_response({'status': 'error', 'message': 'Function name required'}, 400)
                return

            # Get depth parameter (default 1, max 10)
            depth = min(int(query_params.get('depth', ['1'])[0]), 10)

            # Find the function
            func = self._get_function_by_name(func_name)
            if not func:
                self._send_response({'status': 'error', 'message': f"Function '{func_name}' not found"}, 404)
                return

            # Build call graph
            call_graph = {
                'name': func.name,
                'address': func.start,
                'callers': self._get_callers(func, depth, set()),
                'callees': self._get_callees(func, depth, set())
            }

            self._send_response({
                'status': 'success',
                'call_graph': call_graph
            })

        except Exception as e:
            logger.log_error(f"Error getting call graph: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)


    def _handle_get_global_variable_data(self):
        """Handle requests access data from a global address"""
        try:
            func_name = self.path.split('/')[-2]
            func = self._get_function_by_name(func_name)
            if not func:
                self._send_response({'status': 'error', 'message': f'No function found at address {func_name}'}, 404)
                return
            # Find the variable by name
            global_name = self.path.split('/')[-1]
            """
                We need to handle the case where the LLM is trying to change
                the name of a global variable. We need to find the global and
                rename it.
            """
            for var in self._get_globals_from_func(func):
                if var['name'] == global_name:
                    for addr, gvar in self.protocol.bv.data_vars.items():
                        if addr == var['location']:
                            read_address = None
                            rbytes = None
                            if gvar.value:
                                target_val = gvar.value
                                # Getting the .value for a value found with heuristics
                                # will actually return this value. If it's an int
                                # then it's likely a pointer for us to follow.
                                if isinstance(target_val, bytes):
                                    rbytes = target_val
                                elif isinstance(target_val, int):
                                    read_address = target_val
                            else:
                                read_address = addr

                            # If there is not a defined value at address, then read
                            # an arbitrary amount of data as a last ditch effort.
                            if read_address and not rbytes:
                                rbytes = self.protocol.bv.read(read_address, 256)
                            self._send_response({
                                'status': 'success',
                                'message': f'Byte slice from global: {rbytes}'
                            })
                            return
        except Exception as e:
            logger.log_error(f"Error updating variable name: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_add_comment_to_address(self, data):
        """Handle requests to add a comment to an address"""
        try:
            if not data or 'comment' not in data:
                self._send_response({'status': 'error', 'message': 'Comment text is required'}, 400)
                return
            
            comment = data['comment']
            self.protocol.bv.set_comment_at(int(self.path.split('/')[-1], 0), comment)
            
            self._send_response({
                'status': 'success',
                'message': f'Comment added at address 0x{int(self.path.split("/")[-1], 0):x}'
            })
            
        except Exception as e:
            logger.log_error(f"Error adding comment: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_add_comment_to_function(self, data):
        """Handle requests to add a comment to a function"""
        try:
            if not data or 'comment' not in data:
                self._send_response({'status': 'error', 'message': 'Comment text is required'}, 400)
                return
            
            comment = data['comment']
            name = self.path.split('/')[-2]
            func = self._get_function_by_name(name)
            if not func:
                self._send_response({'status': 'error', 'message': f'No function found with name: {name}'}, 404)
                return
            self.protocol.bv.set_comment_at(func.start, comment)
            
            self._send_response({
                'status': 'success',
                'message': f'Comment added to function {name}'
            })
            
        except Exception as e:
            logger.log_error(f"Error adding comment: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_create_tag(self, data):
        """Handle requests to create a tag at an address

        Expected JSON body:
        {
            "address": 0x401000,
            "tag_type": "review",
            "data": "needs review"  # optional
        }
        """
        try:
            address = data.get('address')
            tag_type_name = data.get('tag_type')
            tag_data = data.get('data', '')

            if address is None:
                self._send_response({'status': 'error', 'message': 'Address is required'}, 400)
                return

            if not tag_type_name:
                self._send_response({'status': 'error', 'message': 'Tag type is required'}, 400)
                return

            # Convert address if string
            if isinstance(address, str):
                address = int(address, 16) if address.startswith('0x') else int(address)

            bv = self.protocol.bv

            # Check if address is valid/mapped
            if not bv.is_valid_offset(address):
                self._send_response({
                    'status': 'error',
                    'message': f'Cannot create tag at unmapped address 0x{address:x}'
                }, 400)
                return

            # Ensure tag type exists (create if not)
            if not bv.get_tag_type(tag_type_name):
                bv.create_tag_type(tag_type_name, "⭐")

            # Find function containing this address
            funcs = bv.get_functions_containing(address)
            if funcs:
                # Create address tag within function context
                # API: func.add_tag("TagType", "data", address)
                func = funcs[0]
                func.add_tag(tag_type_name, tag_data, address)
                self._send_response({
                    'status': 'success',
                    'message': f"Tag created at 0x{address:x}",
                    'tag': {
                        'address': address,
                        'type': tag_type_name,
                        'data': tag_data,
                        'function': func.name
                    }
                })
            else:
                # Create data tag at address (not in a function)
                # API: bv.add_tag(address, "TagType", "data")
                bv.add_tag(address, tag_type_name, tag_data)
                self._send_response({
                    'status': 'success',
                    'message': f"Tag created at 0x{address:x}",
                    'tag': {
                        'address': address,
                        'type': tag_type_name,
                        'data': tag_data,
                        'function': None
                    }
                })

        except Exception as e:
            logger.log_error(f"Error creating tag: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_get_tags(self):
        """Handle requests to list all tags

        Query parameters:
        - type: Optional filter by tag type name
        """
        try:
            parsed_path = urlparse(self.path)
            query_params = parse_qs(parsed_path.query)
            tag_type_filter = query_params.get('type', [None])[0]

            bv = self.protocol.bv
            tags = []

            # Iterate through all tag types and get tags
            for tag_type in bv.tag_types.values():
                tag_type_name = tag_type.name
                
                # Apply filter if specified
                if tag_type_filter and tag_type_name != tag_type_filter:
                    continue
                
                # Get all tags of this type using bv.get_tags_at or iterate functions
                # Try to get tags from each function
                for func in bv.functions:
                    try:
                        # Get tags at each address in the function
                        func_tags = bv.get_tags_in_range(func.start, func.address_ranges[0].end - func.start) if func.address_ranges else []
                        for addr, tag_list in func_tags if isinstance(func_tags, dict) else []:
                            for tag in (tag_list if isinstance(tag_list, list) else [tag_list]):
                                if tag.type.name == tag_type_name:
                                    tags.append({
                                        'address': addr,
                                        'type': tag_type_name,
                                        'data': tag.data,
                                        'function': func.name
                                    })
                    except Exception:
                        pass

            # Deduplicate tags by address+type
            seen = set()
            unique_tags = []
            for tag in tags:
                key = (tag['address'], tag['type'])
                if key not in seen:
                    seen.add(key)
                    unique_tags.append(tag)

            self._send_response({
                'status': 'success',
                'tags': unique_tags,
                'count': len(unique_tags)
            })

        except Exception as e:
            logger.log_error(f"Error getting tags: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_get_analysis_progress(self):
        """Handle requests to get analysis progress

        Returns the current analysis state, completion status, and progress percentage.
        """
        try:
            bv = self.protocol.bv

            # Try different ways to get analysis state
            state_name = 'Unknown'
            is_complete = False
            progress = 0.5
            
            # Method 1: Try analysis_info.state
            if hasattr(bv, 'analysis_info') and bv.analysis_info:
                try:
                    state = bv.analysis_info.state
                    state_name = state.name if hasattr(state, 'name') else str(state)
                except:
                    pass
            
            # Method 2: Try analysis_progress directly on bv
            if hasattr(bv, 'analysis_progress'):
                try:
                    ap = bv.analysis_progress
                    if hasattr(ap, 'state'):
                        state_name = ap.state.name if hasattr(ap.state, 'name') else str(ap.state)
                except:
                    pass
            
            # Determine if analysis is complete
            is_complete = 'Idle' in state_name or state_name == 'IdleState'

            # Estimate progress based on state
            state_progress_map = {
                'InitialState': 0.0,
                'HoldState': 0.0,
                'DisassembleState': 0.25,
                'AnalyzeState': 0.5,
                'ExtendedAnalyzeState': 0.75,
                'IdleState': 1.0
            }
            progress = state_progress_map.get(state_name, 1.0 if is_complete else 0.5)

            # Build description based on state
            state_descriptions = {
                'InitialState': 'Initial analysis starting',
                'HoldState': 'Analysis on hold',
                'IdleState': 'Analysis complete',
                'DisassembleState': 'Disassembling binary',
                'AnalyzeState': 'Analyzing functions',
                'ExtendedAnalyzeState': 'Performing extended analysis'
            }
            description = state_descriptions.get(state_name, f'Analysis in progress ({state_name})')

            self._send_response({
                'status': 'success',
                'state': state_name,
                'is_complete': is_complete,
                'progress': round(progress, 4),
                'description': description
            })

        except Exception as e:
            logger.log_error(f"Error getting analysis progress: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)




    def _get_function_by_name(self, name):
        """Acquire function by name instead of address"""
        logger.log_info(f"Getting function by name: {name}")
        res = self.protocol.bv.get_functions_by_name(name)
        # TODO: is there a scenario where there's more than one with the same name?
        if len(res) > 0:
            return res[0]
        else:
            return None

    def _get_function_by_address(self, address):
        """Acquire function by address instead of name"""
        res = self.protocol.bv.get_functions_containing(address)
        if res:
            return res[0]
        else:
            return None
    
    def _handle_get_function_disassembly(self):
        """Handle requests for function disassembly with function name"""
        try:
            name = self.path.split('/')[-2]
            func = self._get_function_by_name(name)
            if not func:
                self._send_response({'status': 'error', 'message': f'No function found with name: {name}'}, 404)
                return
            else:
                disassembly = self._get_disassembly(func)
                self._send_response({
                    'status': 'success',
                    'disassembly': disassembly
                })
        except Exception as e:
            logger.log_error(f"Error getting function disassembly: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)
    
    def _handle_get_function_pseudocode(self):
        """Handle requests for function pseudocode with function name"""
        try:
            name = self.path.split('/')[-2]
            func = self._get_function_by_name(name)
            if not func:
                self._send_response({'status': 'error', 'message': f'No function found with name: {name}'}, 404)
                return
            
            pseudocode = self._get_pseudo_c_text(self.protocol.bv, func)
            
            self._send_response({
                'status': 'success',
                'pseudocode': pseudocode
            })
            
        except Exception as e:
            logger.log_error(f"Error getting function pseudocode: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)
    
    def _is_global_ptr(self, obj):
        """Callback to look for a HighLevelILConstPtr in instruction line"""
        if(isinstance(obj, HighLevelILConstPtr)):
            return obj

    def _get_globals_from_func(self, func: binaryninja.function.Function) -> List[Dict[str, Any]]:
        """Get global variables in a given HLIL function"""
        res = []
        gvar_results = []
        """
            We enumerate all instructions in basic blocks to find
            pointers to global variables. We recursively enumerate
            each instruction line for HighLevelILConstPtr to do this.
        """
        for bb in func.hlil:
            for instr in bb:
                res += (list(instr.traverse(self._is_global_ptr)))

        """
            Once we find a pointer, we get the pointer's address value
            and find the data variable that this corresponds to in
            order to find the variable's name. Unnamed variables
            in the format of data_[address] return None for their name
            so we need to format this ourselves to match the pseudocode
            output.
        """
        for r in res:
            address = r.constant
            for gaddr, gvar in self.protocol.bv.data_vars.items():
                if address == gaddr:
                    var_name = None
                    if not gvar.name:
                        var_name = f"data_{address:2x}"
                    else:
                        var_name = gvar.name
                    gvar_results.append({
                        'name': var_name,
                        'type': str(gvar.type),
                        'location': gaddr
                    })
        return gvar_results

    def _handle_get_function_variables(self):
        """Handle requests for function variables"""
        try:
            name = self.path.split('/')[-2]
            func = self._get_function_by_name(name)
            if not func:
                self._send_response({'status': 'error', 'message': f'No function found with name {name}'}, 404)
                return
            
            variables = {
                'parameters': self._get_parameters(func),
                'local_variables': self._get_variables(func),
                'global_variables': self._get_globals_from_func(func)
            }
            
            self._send_response({
                'status': 'success',
                'variables': variables
            })
            
        except Exception as e:
            logger.log_error(f"Error getting function variables: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)

    def _handle_get_cross_references_to_function(self):
        """Handle requests for cross references to a function by address or name"""
        try:
            val = self.path.split('/')[-1]
            logger.log_info(f"Getting cross references to function: {val}")
            if val.startswith('0x'):
                val = int(val, 0)
                func = self._get_function_by_address(val)
            else:
                func = self._get_function_by_name(val)
            if func is None:
                self._send_response({'status': 'error', 'message': f'No function found with name {val}'}, 404)
                return
            cross_references = self._get_cross_references_to_function(func.name)
            if len(cross_references) == 0:
                self._send_response({'status': 'error', 'message': f'No cross references found for function {name}'}, 404)
            self._send_response({
                'status': 'success',
                'cross_references': cross_references
            })
        except Exception as e:
            logger.log_error(f"Error getting cross references to function: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self._send_response({'status': 'error', 'message': str(e)}, 500)
    
    def _get_llil_text(self, func: binaryninja.function.Function) -> List[str]:
        """Get LLIL text for a function"""
        result = []
        for block in func.llil:
            for instruction in block:
                result.append({'address': instruction.address, 'text': str(instruction)})
        return result
    
    def _get_mlil_text(self, func: binaryninja.function.Function) -> List[str]:
        """Get MLIL text for a function"""
        result = []
        for block in func.mlil:
            for instruction in block:
                result.append({'address': instruction.address, 'text': str(instruction)})
        return result
    
    def _get_hlil_text(self, func: binaryninja.function.Function) -> List[str]:
        """Get HLIL text for a function"""
        result = []
        for block in func.hlil:
            for instruction in block:
                result.append({'address': instruction.address, 'text': str(instruction)})
        return result

    def _get_pseudo_c_text(self, bv: BinaryView, function: Function) -> List[str]:
        """
        Get pseudo-c text for a function, big thanks to Asher Devila L.
        for help with this https://github.com/AsherDLL/PCDump-bn/blob/main/__init__.py
        """
        lines = []
        settings = DisassemblySettings()
        settings.set_option(DisassemblyOption.ShowAddress, True)
        settings.set_option(DisassemblyOption.WaitForIL, True)
        obj = LinearViewObject.language_representation(bv, settings)
        cursor_end = LinearViewCursor(obj)
        cursor_end.seek_to_address(function.highest_address)
        body = bv.get_next_linear_disassembly_lines(cursor_end)
        cursor_end.seek_to_address(function.highest_address)
        header = bv.get_previous_linear_disassembly_lines(cursor_end)
        for line in header:
            lines.append(f'{str(line)}\n')
        for line in body:
            lines.append(f'{str(line)}\n')
        with_addr = self._get_addr_pseudo_c_from_text(lines)
        return with_addr

    def _get_addr_pseudo_c_from_text(self, lines: list) -> List[str]:
        """Get addresses and pseudo-c from pseudo-c text output"""
        if lines is None:
            return []
        else:
            result = []
            for l in lines:
                lr = re.findall("(^[0-9A-Fa-f]+)(.*)$", l)
                if lr:
                    # Converting binja address format of 0x[Address]
                    addr = int("0x" + lr[0][0], 0)
                    pseudo_c = lr[0][1]
                    result.append({'address': addr, 'text': pseudo_c})
            return result
    
    def _get_call_sites(self, func: binaryninja.function.Function) -> List[Dict[str, Any]]:
        """Get call sites within a function"""
        result = []
        for ref in func.call_sites:
            called_func = self.protocol.bv.get_function_at(ref.address)
            called_name = called_func.name if called_func else "unknown"
            result.append({
                'address': ref.address,
                'target': called_name
            })
        return result
    
    def _get_cross_references_to_function(self, name: str) -> List[Dict[str, Any]]:
        """
        Get cross references to a function by name.
        This returns functions containing cross-reference locations,
        instead of the actual cross-reference locations.
        """
        result = []
        func = self._get_function_by_name(name)
        if not func:
            return []
        for ref in self.protocol.bv.get_code_refs(func.start):
            called_func = self.protocol.bv.get_functions_containing(ref.address)[0]
            result.append({
                'address': ref.address,
                'function': called_func.name
            })
        return result

    def _get_basic_blocks_info(self, func: binaryninja.function.Function) -> List[Dict[str, Any]]:
        """Get information about basic blocks in a function"""
        result = []
        for block in func.basic_blocks:
            result.append({
                'start': block.start,
                'end': block.end,
                'incoming_edges': [edge.source.start for edge in block.incoming_edges],
                'outgoing_edges': [edge.target.start for edge in block.outgoing_edges]
            })
        return result
    
    def _get_parameters(self, func: binaryninja.function.Function) -> List[Dict[str, Any]]:
        """Get information about function parameters"""
        result = []
        for param in func.parameter_vars:
            result.append({
                'name': param.name,
                'type': str(param.type),
                'location': str(param.storage)
            })
        return result
    
    def _get_variables(self, func: binaryninja.function.Function) -> List[Dict[str, Any]]:
        """Get information about function variables"""
        result = []
        for var in func.vars:
            result.append({
                'name': var.name,
                'type': str(var.type),
                'location': str(var.storage),
                'id': var.identifier
            })
        return result

    def _get_global_variables(self) -> List[Dict[str, Any]]:
        """Get information about global variables"""
        result = []
        for address, var in self.protocol.bv.data_vars.items():
            result.append({
                'name': var.name,
                'type': str(var.type),
                'location': address
            })
        return result
    
    def _get_disassembly(self, func: binaryninja.function.Function) -> List[Dict[str, Any]]:
        """Get disassembly for a function"""
        result = []
        for block in func:
            all_dis = block.get_disassembly_text()
            for i, instruction in enumerate(all_dis):
                if i == len(all_dis)-1:
                    instr_len = block.end-instruction.address
                else:
                    instr_len = all_dis[i+1].address-all_dis[i].address
                result.append({
                    'address': instruction.address,
                    'text': str(instruction)
                })
        return result
    
    def _get_incoming_calls(self, func: binaryninja.function.Function) -> List[Dict[str, Any]]:
        """Get incoming calls to a function"""
        result = []
        for ref in self.protocol.bv.get_code_refs(func.start):
            caller = self.protocol.bv.get_function_at(ref.address)
            if caller:
                result.append({
                    'address': ref.address,
                    'function': caller.name
                })
        return result
    
    def _get_block_disassembly(self, block) -> List[Dict[str, Any]]:
        """Get disassembly for a basic block"""
        result = []
        for instruction in block:
            result.append({
                'address': instruction.address,
                'text': instruction.get_disassembly_text(),
                'bytes': [b for b in instruction.bytes],
                'length': instruction.length
            })
        return result
    
    def _get_block_llil(self, block) -> List[str]:
        """Get LLIL text for a basic block"""
        result = []
        func = block.function
        llil_block = func.get_low_level_il_at(block.start).ssa_form
        if llil_block:
            for instruction in llil_block:
                result.append(f"0x{instruction.address:x}: {instruction}")
        return result
    
    def _get_block_mlil(self, block) -> List[str]:
        """Get MLIL text for a basic block"""
        result = []
        func = block.function
        mlil_block = func.get_medium_level_il_at(block.start).ssa_form
        if mlil_block:
            for instruction in mlil_block:
                result.append(f"0x{instruction.address:x}: {instruction}")
        return result
    
    def _get_block_hlil(self, block) -> List[str]:
        """Get HLIL text for a basic block"""
        result = []
        func = block.function
        hlil_block = func.get_high_level_il_at(block.start).ssa_form
        if hlil_block:
            for instruction in hlil_block:
                result.append(f"0x{instruction.address:x}: {instruction}")
        return result

class BinjaLattice:
    """
    Protocol for communicating between Binary Ninja an external MCP Server or tools.
    This protocol handles sending context from Binary Ninja to MCP Server and receiving
    responses to integrate back into the Binary Ninja UI.
    """
    
    def __init__(self, bv: BinaryView, port: int = 9000, host: str = "localhost", use_ssl: bool = False):
        """
        Initialize the model context protocol.
        
        Args:
            bv: BinaryView object representing the currently analyzed binary
            port: Port number for communication
            host: Host address for the server
            use_ssl: Whether to use SSL/TLS encryption
        """
        self.bv = bv
        self.port = port
        self.host = host
        self.use_ssl = use_ssl
        self.auth_manager = AuthManager()
        self.server = None
    
    def start_server(self):
        """Start the HTTP server"""
        try:
            if self.use_ssl:
                logger.log_info("Starting server with SSL")
                cert_file = os.path.join(os.path.dirname(__file__), "server.crt")
                key_file = os.path.join(os.path.dirname(__file__), "server.key")
                
                self.server = HTTPServer((self.host, self.port), 
                    lambda *args, **kwargs: LatticeRequestHandler(*args, protocol=self, **kwargs))
                self.server.socket = ssl.wrap_socket(self.server.socket,
                    server_side=True,
                    certfile=cert_file,
                    keyfile=key_file)
            else:
                self.server = HTTPServer((self.host, self.port),
                    lambda *args, **kwargs: LatticeRequestHandler(*args, protocol=self, **kwargs))
            
            # Run server in a separate thread
            server_thread = threading.Thread(target=self.server.serve_forever)
            server_thread.daemon = True
            server_thread.start()
            
            logger.log_info(f"Server started on {self.host}:{self.port}")
            logger.log_info(f"Authentication API key: {self.auth_manager.api_key}")
            logger.log_info(f"Use this key to authenticate clients")
            
        except Exception as e:
            logger.log_error(f"Failed to start server: {e}")
            logger.log_error("Stack trace: %s" % traceback.format_exc())
            self.stop_server()
    
    def stop_server(self):
        """Stop the server"""
        if self.server:
            self.server.shutdown()
            self.server.server_close()
            logger.log_info("Server stopped")
    
    def _get_segments_info(self) -> List[Dict[str, Any]]:
        """Get information about binary segments"""
        result = []
        for segment in self.bv.segments:
            result.append({
                'start': segment.start,
                'end': segment.end,
                'length': segment.length,
                'permissions': {
                    'read': segment.readable,
                    'write': segment.writable,
                    'execute': segment.executable
                }
            })
        return result
    
    def _get_sections_info(self) -> List[Dict[str, Any]]:
        """Get information about binary sections"""
        result = []
        for section in self.bv.sections.values():
            result.append({
                'name': section.name,
                'start': section.start,
                'end': section.end,
                'length': section.length,
                'semantics': str(section.semantics)
            })
        return result

protocol_instances = {}

def register_plugin_command(view):
    protocol = BinjaLattice(view, use_ssl=False)
    protocol.start_server()
    protocol_instances[view] = protocol
    return protocol

def stop_lattice_protocol_server(view):
    protocol = protocol_instances.get(view)
    if protocol:
        protocol.stop_server()
        del protocol_instances[view]

PluginCommand.register(
    "Start Lattice Protocol Server",
    "Start server for Binary Ninja Lattice protocol with authentication",
    register_plugin_command
)

PluginCommand.register(
    "Stop Lattice Protocol Server",
    "Stop server for Binary Ninja Lattice protocol",
    stop_lattice_protocol_server
)

```

`requirements.txt`:

```txt
mcp>=1.6.0
requests>=2.32.3
pytest>=7.4.0
pytest-cov>=4.1.0

```

`scripts/install_windows.ps1`:

```ps1
#Requires -Version 5.1
<#
.SYNOPSIS
    BinjaLattice Windows Installer

.DESCRIPTION
    Complete one-shot installer that:
    1. Installs the Binary Ninja plugin to the correct directory
    2. Creates a Python virtual environment for the MCP server
    3. Installs all dependencies
    4. Outputs ready-to-use MCP configuration
    
    Plugin install path (per Binary Ninja docs):
    https://docs.binary.ninja/guide/plugins.html
    Windows: %APPDATA%\Binary Ninja\plugins

.EXAMPLE
    .\install_windows.ps1
    
.EXAMPLE
    .\install_windows.ps1 -Force
#>

param(
    [switch]$Force
)

$ErrorActionPreference = "Stop"

Write-Host ""
Write-Host "============================================" -ForegroundColor Cyan
Write-Host "   BinjaLattice Windows Installer" -ForegroundColor Cyan
Write-Host "============================================" -ForegroundColor Cyan
Write-Host ""

# Get paths
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$RepoRoot = Split-Path -Parent $ScriptDir
$PluginSource = Join-Path $RepoRoot "plugin\lattice_server_plugin.py"
$McpServerPath = Join-Path $RepoRoot "mcp_server.py"
$RequirementsPath = Join-Path $RepoRoot "requirements.txt"
$VenvPath = Join-Path $RepoRoot ".venv"
$VenvPython = Join-Path $VenvPath "Scripts\python.exe"

# Binary Ninja plugins directory per official documentation
$BNPluginsDir = Join-Path $env:APPDATA "Binary Ninja\plugins"

# ============================================
# STEP 1: Validate environment
# ============================================
Write-Host "[STEP 1/4] Validating environment..." -ForegroundColor Cyan

# Check Python is available
$pythonCmd = Get-Command python -ErrorAction SilentlyContinue
if (-not $pythonCmd) {
    Write-Host "[ERROR] Python not found in PATH." -ForegroundColor Red
    Write-Host "        Please install Python 3.8+ and ensure it's in your PATH." -ForegroundColor Yellow
    Read-Host "Press Enter to exit"
    exit 1
}

$pythonVersion = & python --version 2>&1
Write-Host "          Found: $pythonVersion" -ForegroundColor Green

# Check Binary Ninja plugins directory
if (-not (Test-Path $BNPluginsDir)) {
    Write-Host "[ERROR] Binary Ninja plugins directory not found at:" -ForegroundColor Red
    Write-Host "        $BNPluginsDir" -ForegroundColor Yellow
    Write-Host ""
    Write-Host "Please ensure Binary Ninja is installed and has been run at least once." -ForegroundColor Yellow
    Read-Host "Press Enter to exit"
    exit 1
}
Write-Host "          Found Binary Ninja plugins dir" -ForegroundColor Green

# Check plugin source exists
if (-not (Test-Path $PluginSource)) {
    Write-Host "[ERROR] Plugin file not found. Run from BinjaLattice repo." -ForegroundColor Red
    Read-Host "Press Enter to exit"
    exit 1
}
Write-Host ""

# ============================================
# STEP 2: Install Binary Ninja plugin
# ============================================
Write-Host "[STEP 2/4] Installing Binary Ninja plugin..." -ForegroundColor Cyan

$PluginDest = Join-Path $BNPluginsDir "lattice_server_plugin.py"
if ((Test-Path $PluginDest) -and -not $Force) {
    Write-Host "          Plugin already exists." -ForegroundColor Yellow
    $response = Read-Host "          Overwrite? (y/N)"
    if ($response -ne 'y' -and $response -ne 'Y') {
        Write-Host "          Skipping plugin install." -ForegroundColor Yellow
    }
    else {
        Copy-Item -Path $PluginSource -Destination $PluginDest -Force
        Write-Host "          Plugin updated." -ForegroundColor Green
    }
}
else {
    Copy-Item -Path $PluginSource -Destination $PluginDest -Force
    Write-Host "          Plugin installed to:" -ForegroundColor Green
    Write-Host "          $PluginDest" -ForegroundColor White
}
Write-Host ""

# ============================================
# STEP 3: Create virtual environment
# ============================================
Write-Host "[STEP 3/4] Setting up Python virtual environment..." -ForegroundColor Cyan

if ((Test-Path $VenvPath) -and -not $Force) {
    Write-Host "          Virtual environment already exists at .venv" -ForegroundColor Yellow
    $response = Read-Host "          Recreate? (y/N)"
    if ($response -eq 'y' -or $response -eq 'Y') {
        Remove-Item -Recurse -Force $VenvPath
        & python -m venv $VenvPath
        Write-Host "          Virtual environment recreated." -ForegroundColor Green
    }
}
else {
    if (Test-Path $VenvPath) {
        Remove-Item -Recurse -Force $VenvPath
    }
    & python -m venv $VenvPath
    Write-Host "          Virtual environment created at .venv" -ForegroundColor Green
}
Write-Host ""

# ============================================
# STEP 4: Install dependencies
# ============================================
Write-Host "[STEP 4/4] Installing dependencies..." -ForegroundColor Cyan

try {
    & $VenvPython -m pip install --upgrade pip --quiet 2>&1 | Out-Null
    & $VenvPython -m pip install mcp requests --quiet 2>&1 | Out-Null
    Write-Host "          Dependencies installed (mcp, requests)" -ForegroundColor Green
}
catch {
    Write-Host "[ERROR] Failed to install dependencies: $_" -ForegroundColor Red
    Read-Host "Press Enter to exit"
    exit 1
}
Write-Host ""

# ============================================
# SUCCESS - Output configuration
# ============================================
Write-Host "============================================" -ForegroundColor Green
Write-Host "   Installation Complete!" -ForegroundColor Green
Write-Host "============================================" -ForegroundColor Green
Write-Host ""
Write-Host "Binary Ninja Plugin:" -ForegroundColor Cyan
Write-Host "  Installed to: $PluginDest" -ForegroundColor White
Write-Host ""
Write-Host "MCP Server:" -ForegroundColor Cyan
Write-Host "  Python: $VenvPython" -ForegroundColor White
Write-Host "  Server: $McpServerPath" -ForegroundColor White
Write-Host ""
Write-Host "Add this to your MCP configuration (mcp.json):" -ForegroundColor Yellow
Write-Host ""

# Output JSON config with escaped backslashes for Windows paths
$escapedPython = $VenvPython -replace '\\', '\\'
$escapedServer = $McpServerPath -replace '\\', '\\'

Write-Host @"
{
  "mcpServers": {
    "binja-lattice-mcp": {
      "command": "$escapedPython",
      "args": ["$escapedServer"],
      "env": {
        "BNJLAT": "YOUR_API_KEY_HERE"
      }
    }
  }
}
"@ -ForegroundColor Gray

Write-Host ""
Write-Host "Next steps:" -ForegroundColor Cyan
Write-Host "  1. Restart Binary Ninja"
Write-Host "  2. Open a binary file"
Write-Host "  3. Plugins > Start Lattice Protocol Server"
Write-Host "  4. Copy the API key from the log console"
Write-Host "  5. Replace YOUR_API_KEY_HERE in your mcp.json"
Write-Host ""
Read-Host "Press Enter to exit"

```

`setup.py`:

```py
from setuptools import setup, find_packages

setup(
    name="binja-mcp-server",
    version="0.1.0",
    packages=find_packages(),
    install_requires=[
        "mcp>=1.6.0",
        "requests>=2.32.3",
    ],
    extras_require={
        "test": [
            "pytest>=7.4.0",
            "pytest-cov>=4.1.0",
        ],
    },
) 
```

`tests/conftest.py`:

```py
import os
import pytest

@pytest.fixture(scope="session", autouse=True)
def setup_test_env():
    """Ensure Binary Ninja is in headless mode for testing"""
    os.environ["BN_DISABLE_UI"] = "1"
    yield 
```

`tests/data/test_program.c`:

```c
#include <stdio.h>

int global_var = 42;

int add(int a, int b) {
    int result = a + b;
    return result;
}

void print_message(const char* message) {
    printf("%s\n", message);
}

int main() {
    int local_var = 10;
    int sum = add(local_var, global_var);
    print_message("Hello, World!");
    return sum;
} 
```

`tests/test_lattice_server.py`:

```py
import os
import sys
import time
import requests
import pytest
import binaryninja

# Add the project root directory to Python path
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, project_root)

from plugin.lattice_server_plugin import BinjaLattice

@pytest.fixture(scope="module")
def bv():
    """Create a headless BinaryView from our test binary"""
    bv = binaryninja.load("tests/data/test_binary")
    return bv

@pytest.fixture(scope="module")
def lattice_server(bv):
    """Start the Lattice server and yield its configuration"""
    protocol = BinjaLattice(bv, host="127.0.0.1", port=0)
    protocol.start_server()
    # Give it a moment to bind
    time.sleep(0.1)

    host, port = protocol.server.server_address
    base = f"http://{host}:{port}"
    api_key = protocol.auth_manager.api_key

    yield {
        "protocol": protocol,
        "base": base,
        "api_key": api_key,
        "bv": bv
    }

    # Teardown
    protocol.stop_server()
    # TODO figure out if this is actually possible
    # bv.close()

def test_auth_fails_without_credentials(lattice_server):
    """Test that authentication fails without proper credentials"""
    r = requests.post(f"{lattice_server['base']}/auth", json={})
    assert r.status_code == 401
    assert r.json()["status"] == "error"

def test_auth_succeeds_with_valid_credentials(lattice_server):
    """Test that authentication succeeds with valid API key"""
    base = lattice_server["base"]
    api_key = lattice_server["api_key"]

    r = requests.post(
        f"{base}/auth",
        json={"username": "test_user", "password": api_key}
    )
    assert r.status_code == 200
    j = r.json()
    assert j["status"] == "success"
    assert "token" in j
    return j["token"]  # Return token for other tests

def test_binary_info_endpoint(lattice_server):
    """Test the binary info endpoint"""
    base = lattice_server["base"]
    bv = lattice_server["bv"]
    token = test_auth_succeeds_with_valid_credentials(lattice_server)

    r = requests.get(
        f"{base}/binary/info",
        headers={"Authorization": f"Bearer {token}"}
    )
    assert r.status_code == 200
    j = r.json()
    assert j["status"] == "success"
    info = j["binary_info"]
    
    # Assert against actual BinaryView properties
    assert info["filename"].endswith("test_binary")
    assert info["arch"] == bv.arch.name
    assert info["platform"] == bv.platform.name
    assert info["entry_point"] == bv.entry_point
    assert info["start"] == bv.start
    assert info["end"] == bv.end

def test_function_operations(lattice_server):
    """Test function-related endpoints"""
    base = lattice_server["base"]
    bv = lattice_server["bv"]
    token = test_auth_succeeds_with_valid_credentials(lattice_server)
    headers = {"Authorization": f"Bearer {token}"}

    # Test getting all functions
    r = requests.get(f"{base}/functions", headers=headers)
    assert r.status_code == 200
    functions = r.json()["function_names"]
    assert len(functions) > 0
    
    # Test getting function context for main function
    main_func = next(f for f in functions if f["name"] == "_main")
    r = requests.get(
        f"{base}/functions/{main_func['address']}",
        headers=headers
    )
    assert r.status_code == 200
    func_info = r.json()["function"]
    
    # Assert function properties match BinaryView
    actual_func = bv.get_function_at(main_func["address"])
    assert func_info["name"] == actual_func.name
    assert func_info["start"] == actual_func.start
    assert func_info["end"] == actual_func.address_ranges[0].end

def test_comment_operations(lattice_server):
    """Test comment-related endpoints"""
    base = lattice_server["base"]
    bv = lattice_server["bv"]
    token = test_auth_succeeds_with_valid_credentials(lattice_server)
    headers = {"Authorization": f"Bearer {token}"}

    # Test adding a comment to main function
    main_func = next(f for f in bv.functions if f.name == "_main")
    test_comment = "Test comment for main function"
    
    r = requests.post(
        f"{base}/functions/{main_func.name}/comments",
        headers=headers,
        json={"comment": test_comment}
    )
    assert r.status_code == 200
    
    # Verify comment was added
    assert bv.get_comment_at(main_func.start) == test_comment

def test_variable_operations(lattice_server):
    """Test variable-related endpoints"""
    base = lattice_server["base"]
    bv = lattice_server["bv"]
    token = test_auth_succeeds_with_valid_credentials(lattice_server)
    headers = {"Authorization": f"Bearer {token}"}

    # Test getting variables for main function
    main_func = next(f for f in bv.functions if f.name == "_main")
    r = requests.get(
        f"{base}/functions/{main_func.name}/variables",
        headers=headers
    )
    assert r.status_code == 200
    vars_info = r.json()["variables"]
    
    # Assert variables match BinaryView
    assert len(vars_info["parameters"]) == len(main_func.parameter_vars)
    assert len(vars_info["local_variables"]) == len(main_func.vars)
    # This should be dynamic in case binja changes their pointer ref implementation etc.
    # Leaving it for now because getting function globals is a pain.
    assert len(vars_info["global_variables"]) == 4

def test_variable_name_update(lattice_server):
    """Test variable name update endpoint"""
    base = lattice_server["base"]
    bv = lattice_server["bv"]
    token = test_auth_succeeds_with_valid_credentials(lattice_server)
    headers = {"Authorization": f"Bearer {token}"}

    # Test getting variables for main function
    main_func = next(f for f in bv.functions if f.name == "_main")
    r = requests.get(
        f"{base}/functions/{main_func.name}/variables",
        headers=headers
    )
    assert r.status_code == 200
    vars_info = r.json()["variables"]
    var_name = vars_info["local_variables"][0]["name"]
    # Test updating variable name
    r = requests.put(
        f"{base}/variables/{main_func.name}/{var_name}/name",
        headers=headers,
        json={"name": "new_var_name"}
    )
    assert r.status_code == 200
    r = requests.get(
        f"{base}/functions/{main_func.name}/variables",
        headers=headers
    )
    assert r.status_code == 200
    vars_info = r.json()["variables"]
    print(vars_info)
    # This assumes that the variables maintain order after being renamed
    assert vars_info["local_variables"][0]["name"] == "new_var_name"

def test_get_global_variable_data(lattice_server):
    """Test getting data for a global variable"""
    base = lattice_server["base"]
    bv = lattice_server["bv"]
    token = test_auth_succeeds_with_valid_credentials(lattice_server)
    headers = {"Authorization": f"Bearer {token}"}
    
    # This is a global variable in the main function
    # as per our returned convention because it is unnamed
    r = requests.get(
        f"{base}/global_variable_data/_main/data_100003f90",
        headers=headers
    )
    assert r.status_code == 200
    data = r.json()
    assert data["status"] == "success"
    assert "Hello, World!" in data["message"]

def test_cross_references(lattice_server):
    """Test cross-reference endpoints"""
    base = lattice_server["base"]
    bv = lattice_server["bv"]
    token = test_auth_succeeds_with_valid_credentials(lattice_server)
    headers = {"Authorization": f"Bearer {token}"}

    # Test getting cross references to print_message function
    print_func = next(f for f in bv.functions if f.name == "_print_message")
    r = requests.get(
        f"{base}/cross-references/{print_func.name}",
        headers=headers
    )
    assert r.status_code == 200
    refs = r.json()["cross_references"]
    
    # Should have at least one reference from main
    assert len(refs) > 0
    assert any(ref["function"] == "_main" for ref in refs)

def test_protected_endpoints_require_auth(lattice_server):
    """Test that protected endpoints require authentication"""
    base = lattice_server["base"]
    endpoints = [
        "/binary/info",
        "/functions",
        "/functions/main",
        "/functions/main/variables"
    ]
    
    for endpoint in endpoints:
        r = requests.get(f"{base}{endpoint}")
        assert r.status_code == 401
        assert r.json()["status"] == "error" 
```