Project Path: arc_mrexodia_lldbext-dump_c8l0isjn

Source Tree:

```txt
arc_mrexodia_lldbext-dump_c8l0isjn
├── coredump.py
├── coredump_impl.py
├── emulate.py
├── lldb
│   ├── __init__.py
│   ├── diagnose
│   │   ├── __init__.py
│   │   ├── diagnose_nsstring.py
│   │   └── diagnose_unwind.py
│   ├── embedded_interpreter.py
│   ├── formatters
│   │   ├── Logger.py
│   │   ├── __init__.py
│   │   ├── attrib_fromdict.py
│   │   ├── cache.py
│   │   ├── cpp
│   │   │   ├── __init__.py
│   │   │   ├── gnu_libstdcpp.py
│   │   │   └── libcxx.py
│   │   ├── metrics.py
│   │   └── synth.py
│   ├── macosx
│   │   ├── __init__.py
│   │   ├── crashlog.py
│   │   ├── crashlog_scripted_process.py
│   │   ├── heap
│   │   │   ├── Makefile
│   │   │   └── heap_find.cpp
│   │   └── heap.py
│   ├── plugins
│   │   ├── __init__.py
│   │   ├── scripted_platform.py
│   │   └── scripted_process.py
│   └── utils
│       ├── __init__.py
│       ├── in_call_stack.py
│       └── symbolication.py
└── requirements.txt

```

`coredump.py`:

```py
# import this into lldb with a command like
# command script import -r coredump.py
import lldb
import importlib
import coredump_impl

def coredump(debugger: lldb.SBDebugger, command: str, exe_ctx: lldb.SBExecutionContext, result: lldb.SBCommandReturnObject, internal_dict: dict):
  importlib.reload(coredump_impl)
  return coredump_impl.coredump(debugger, command, exe_ctx, result, internal_dict)

#
# code that runs when this script is imported into LLDB
#
def __lldb_init_module(debugger: lldb.SBDebugger, internal_dict: dict):
  # This initializer is being run from LLDB in the embedded command interpreter
  # Make the options so we can generate the help text for the new LLDB
  # command line command prior to registering it with LLDB below

  parser = coredump_impl.create_coredump_options()
  coredump.__doc__ = parser.format_help()
  # Add any commands contained in this module to LLDB
  debugger.HandleCommand('command script add -o -f %s.coredump coredump' % __name__)

```

`coredump_impl.py`:

```py
import lldb
import shlex
import argparse
import json
import base64
import os
import gzip
import shutil

def create_coredump_options():
  parser = argparse.ArgumentParser("coredump", description="Attempt to dump the process to a filename")
  parser.add_argument("file", help="The filename to dump to.")
  return parser

def coredump(debugger: lldb.SBDebugger, command: str, exe_ctx: lldb.SBExecutionContext, result: lldb.SBCommandReturnObject, internal_dict: dict):
  parser = create_coredump_options()
  try:
    command_args = shlex.split(command)
    args = parser.parse_args(command_args)
  except:
    print("Failed to parse arguments!")
    return

  file: str = os.path.expanduser(args.file)
  basedir = os.path.dirname(file)
  regiondir = os.path.join(basedir, "regions")
  #if os.path.exists(regiondir):
  #  os.removedirs(regiondir)
  #os.mkdir(regiondir)
  if not os.path.exists(regiondir):
    os.mkdir(regiondir)

  target = debugger.GetSelectedTarget()
  print(f"Target: {target}")
  process = target.GetProcess()
  pinfo = process.GetProcessInfo()
  print(f"Process: {process}")
  thread = process.GetSelectedThread()
  print(f"Thread: {thread}")
  frame = thread.GetSelectedFrame()
  print(f"Frame: {frame}")
  registers = frame.GetRegisters()
  asize = process.GetAddressByteSize()
  print(f"Address size: {asize}")

  dump = {
    "process": {
      "pid": pinfo.GetProcessID(),
      "ppid": pinfo.GetParentProcessID(),
      "executable": pinfo.GetName(),
    },
    "thread": {
      "tid": thread.GetThreadID(),
      "name": thread.GetName(),
    },
    "registers": {},
    "regions": [],
  }

  for i in range(len(registers)):
    group = registers.GetValueAtIndex(i)
    print(f"[{i}] name: {group.name}")

    child: lldb.SBValue
    for child in group.children:
      if child.GetByteSize() == asize:
        dump["registers"][child.name] = child.GetValueAsUnsigned()
    break

  dump_regions = False
  regions = process.GetMemoryRegions()
  for i in range(len(regions)):
    region = lldb.SBMemoryRegionInfo()
    if not regions.GetMemoryRegionAtIndex(i, region):
      print(f"[{i}] Failed to get region info!")
      continue

    #interpreter = debugger.GetCommandInterpreter()
    #res = lldb.SBCommandReturnObject()
    #interpreter.ResolveCommand("memory region --all", res)

    base = region.GetRegionBase()
    end = region.GetRegionEnd()
    name = region.GetName()
    if name is None:
      name = ""

    if dump_regions:
      size = end - base
      error = lldb.SBError()
      data = process.ReadMemory(base, size, error)
      if not error.Success():
        print(f"Failed to read region {region}, error: {error}")
      else:
        datab = bytearray(data)
        with gzip.open(os.path.join(regiondir, f"{hex(base)}-{hex(end)}.bin"), "wb") as f:
          f.write(datab)

    jinfo = {
      "start": base,
      "end": end,
      "x": region.IsExecutable(),
      "r": region.IsReadable(),
      "w": region.IsWritable(),
      "m": region.IsMapped(),
      "name": name,
      "pretty": str(region)
    }
    dump["regions"].append(jinfo)

  with open(file, "w") as f:
    json.dump(dump, f, indent=2)

  print("Command completed!")

```

`emulate.py`:

```py
import os
import json
import gzip
from typing import TypedDict

from icicle import *

class Process(TypedDict):
    pid: int
    ppid: int
    executable: str

class Thread(TypedDict):
    tid: int
    name: str

class Region(TypedDict):
    start: int
    end: int
    r: bool
    w: bool
    x: bool
    m: bool # TODO: never false?
    name: str

class Coredump(TypedDict):
    process: Process
    thread: Thread
    registers: dict[str, int]
    regions: list[Region]

with open("dump.json", "r") as f:
    dump: Coredump = json.load(f)

pid = dump["process"]["pid"]
executable = dump["process"]["executable"]
print(f"Process: {pid}, {executable}")

emu = Icicle("aarch64")
print(emu)

def mem_protection(r: bool, w: bool, x: bool):
    if not r and not w and not x:
        return MemoryProtection.NoAccess
    if r and not w and not x:
        return MemoryProtection.ReadOnly
    if r and w and not x:
        return MemoryProtection.ReadWrite
    if not r and not w and x:
        return MemoryProtection.ExecuteOnly
    if r and not w and x:
        return MemoryProtection.ExecuteRead
    if r and w and x:
        return MemoryProtection.ExecuteReadWrite
    raise NotImplementedError(f"Unsupported combination: R={r}, W={w}, X={x}")

lazy_regions = []
total_size = 0
for region in dump["regions"]:
    start = region["start"]
    end = region["end"]
    r = region["r"]
    w = region["w"]
    x = region["x"]

    perms = "r" if r else "-"
    perms += "w" if w else "-"
    perms += "x" if x else "-"
    name = region["name"]

    size = end - start
    total_size += size

    print(f"Mapping {hex(start)}-{hex(end)}[{hex(size)}] {perms} {name}")
    emu.mem_map(start, size, MemoryProtection.NoAccess)
    lazy_regions.append((start, end, mem_protection(r, w, x)))

    """
    datafile = os.path.join("regions", f"{hex(start)}-{hex(end)}.bin")
    if not os.path.exists(datafile):
        print(f"   ERROR: {datafile} not found")
    else:
        with gzip.open(datafile, "rb") as f:
            data = f.read()
        try:
            emu.mem_write(start, data)
        except MemoryException as e:
            print(f"    ERROR: {e}")
    """

print(f"Total size: {total_size / 1024 / 1024:.2f} MiB")

# Set registers
for name, value in dump["registers"].items():
    reg_name = {
        "fp": "x29",
        "lr": "x30",
    }.get(name, name)
    print(f"{name} -> {reg_name} = {hex(value)}")
    emu.reg_write(reg_name, value)

def step():
    status = emu.step(1)
    if status == RunStatus.UnhandledException and emu.exception_code == ExceptionCode.ExecViolation:
        address = emu.exception_value
        for i, (start, end, protection) in enumerate(lazy_regions):
            if address >= start and address < end:
                size = end - start
                print(f"Remapping region {hex(start)}-{hex(end)}[{hex(size)}]")
                emu.mem_protect(start, size, protection)
                datafile = os.path.join("regions", f"{hex(start)}-{hex(end)}.bin")
                if not os.path.exists(datafile):
                    print(f"   ERROR: {datafile} not found")
                    raise NotImplementedError()
                else:
                    with gzip.open(datafile, "rb") as f:
                        data = f.read()
                    try:
                        emu.mem_write(start, data)
                    except MemoryException as e:
                        print(f"    ERROR: {e}")

                del lazy_regions[i]
                status = emu.step(1)
                return status

pc = emu.reg_read("pc")
x8 = emu.reg_read("x8")
print(f"PC: {hex(pc)}, X8: {hex(x8)}")
status = step()
pc = emu.reg_read("pc")
x8 = emu.reg_read("x8")
print(f"status: {status}, PC: {hex(pc)}, X8: {hex(x8)}")
```

`lldb/__init__.py`:

```py
# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
The lldb module contains the public APIs for Python binding.

Some of the important classes are described here:

* :py:class:`SBTarget`: Represents the target program running under the debugger.
* :py:class:`SBProcess`: Represents the process associated with the target program.
* :py:class:`SBThread`: Represents a thread of execution. :py:class:`SBProcess` contains SBThreads.
* :py:class:`SBFrame`: Represents one of the stack frames associated with a thread. :py:class:`SBThread`
  contains SBFrame(s).
* :py:class:`SBSymbolContext`: A container that stores various debugger related info.
* :py:class:`SBValue`: Represents the value of a variable, a register, or an expression.
* :py:class:`SBModule`: Represents an executable image and its associated object and symbol
  files.  :py:class:`SBTarget` contains SBModule.
* :py:class:`SBBreakpoint`: Represents a logical breakpoint and its associated settings.
  :py:class:`SBTarget` contains SBBreakpoints.
* :py:class:`SBSymbol`: Represents the symbol possibly associated with a stack frame.
* :py:class:`SBCompileUnit`: Represents a compilation unit, or compiled source file.
* :py:class:`SBFunction`: Represents a generic function, which can be inlined or not.
* :py:class:`SBBlock`: Represents a lexical block. :py:class:`SBFunction` contains SBBlocks.
* :py:class:`SBLineEntry`: Specifies an association with a contiguous range of instructions
  and a source file location. :py:class:`SBCompileUnit` contains SBLineEntry.

The different enums in the `lldb` module are described in :doc:`python_api_enums`.


"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

try:
    # Try an absolute import first.  If we're being loaded from lldb,
    # _lldb should be a built-in module.
    import _lldb
except ImportError:
    # Relative import should work if we are being loaded by Python.
    from . import _lldb

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



import uuid
import re
import os


#SWIG_VERSION is written as a single hex number, but the components of it are
#meant to be interpreted in decimal. So, 0x030012 is swig 3.0.12, and not
#3.0.18.
def _to_int(hex):
    return hex // 0x10 % 0x10 * 10 + hex % 0x10
swig_version = (_to_int(0x040001 // 0x10000), _to_int(0x040001 // 0x100), _to_int(0x040001))
del _to_int


# ===================================
# Iterator for lldb container objects
# ===================================
def lldb_iter(obj, getsize, getelem):
    """A generator adaptor to support iteration for lldb container objects."""
    size = getattr(obj, getsize)
    elem = getattr(obj, getelem)
    for i in range(size()):
        yield elem(i)

def __int__(self):
  pass

def __hex__(self):
  pass

def __oct__(self):
  pass

def __len__(self):
  pass

def __iter__(self):
  pass

INT32_MAX = _lldb.INT32_MAX

UINT32_MAX = _lldb.UINT32_MAX

UINT64_MAX = _lldb.UINT64_MAX

LLDB_GENERIC_ERROR = _lldb.LLDB_GENERIC_ERROR

LLDB_INVALID_BREAK_ID = _lldb.LLDB_INVALID_BREAK_ID

LLDB_DEFAULT_BREAK_SIZE = _lldb.LLDB_DEFAULT_BREAK_SIZE

LLDB_INVALID_WATCH_ID = _lldb.LLDB_INVALID_WATCH_ID

LLDB_WATCH_TYPE_READ = _lldb.LLDB_WATCH_TYPE_READ

LLDB_WATCH_TYPE_WRITE = _lldb.LLDB_WATCH_TYPE_WRITE

LLDB_REGNUM_GENERIC_PC = _lldb.LLDB_REGNUM_GENERIC_PC

LLDB_REGNUM_GENERIC_SP = _lldb.LLDB_REGNUM_GENERIC_SP

LLDB_REGNUM_GENERIC_FP = _lldb.LLDB_REGNUM_GENERIC_FP

LLDB_REGNUM_GENERIC_RA = _lldb.LLDB_REGNUM_GENERIC_RA

LLDB_REGNUM_GENERIC_FLAGS = _lldb.LLDB_REGNUM_GENERIC_FLAGS

LLDB_REGNUM_GENERIC_ARG1 = _lldb.LLDB_REGNUM_GENERIC_ARG1

LLDB_REGNUM_GENERIC_ARG2 = _lldb.LLDB_REGNUM_GENERIC_ARG2

LLDB_REGNUM_GENERIC_ARG3 = _lldb.LLDB_REGNUM_GENERIC_ARG3

LLDB_REGNUM_GENERIC_ARG4 = _lldb.LLDB_REGNUM_GENERIC_ARG4

LLDB_REGNUM_GENERIC_ARG5 = _lldb.LLDB_REGNUM_GENERIC_ARG5

LLDB_REGNUM_GENERIC_ARG6 = _lldb.LLDB_REGNUM_GENERIC_ARG6

LLDB_REGNUM_GENERIC_ARG7 = _lldb.LLDB_REGNUM_GENERIC_ARG7

LLDB_REGNUM_GENERIC_ARG8 = _lldb.LLDB_REGNUM_GENERIC_ARG8

LLDB_INVALID_STOP_ID = _lldb.LLDB_INVALID_STOP_ID

LLDB_INVALID_ADDRESS = _lldb.LLDB_INVALID_ADDRESS

LLDB_INVALID_INDEX32 = _lldb.LLDB_INVALID_INDEX32

LLDB_INVALID_IVAR_OFFSET = _lldb.LLDB_INVALID_IVAR_OFFSET

LLDB_INVALID_IMAGE_TOKEN = _lldb.LLDB_INVALID_IMAGE_TOKEN

LLDB_INVALID_MODULE_VERSION = _lldb.LLDB_INVALID_MODULE_VERSION

LLDB_INVALID_REGNUM = _lldb.LLDB_INVALID_REGNUM

LLDB_INVALID_UID = _lldb.LLDB_INVALID_UID

LLDB_INVALID_PROCESS_ID = _lldb.LLDB_INVALID_PROCESS_ID

LLDB_INVALID_THREAD_ID = _lldb.LLDB_INVALID_THREAD_ID

LLDB_INVALID_FRAME_ID = _lldb.LLDB_INVALID_FRAME_ID

LLDB_INVALID_SIGNAL_NUMBER = _lldb.LLDB_INVALID_SIGNAL_NUMBER

LLDB_INVALID_OFFSET = _lldb.LLDB_INVALID_OFFSET

LLDB_INVALID_LINE_NUMBER = _lldb.LLDB_INVALID_LINE_NUMBER

LLDB_INVALID_COLUMN_NUMBER = _lldb.LLDB_INVALID_COLUMN_NUMBER

LLDB_INVALID_QUEUE_ID = _lldb.LLDB_INVALID_QUEUE_ID

LLDB_INVALID_CPU_ID = _lldb.LLDB_INVALID_CPU_ID

LLDB_ARCH_DEFAULT = _lldb.LLDB_ARCH_DEFAULT

LLDB_ARCH_DEFAULT_32BIT = _lldb.LLDB_ARCH_DEFAULT_32BIT

LLDB_ARCH_DEFAULT_64BIT = _lldb.LLDB_ARCH_DEFAULT_64BIT

LLDB_INVALID_CPUTYPE = _lldb.LLDB_INVALID_CPUTYPE

LLDB_MAX_NUM_OPTION_SETS = _lldb.LLDB_MAX_NUM_OPTION_SETS

LLDB_OPT_SET_ALL = _lldb.LLDB_OPT_SET_ALL

LLDB_OPT_SET_1 = _lldb.LLDB_OPT_SET_1

LLDB_OPT_SET_2 = _lldb.LLDB_OPT_SET_2

LLDB_OPT_SET_3 = _lldb.LLDB_OPT_SET_3

LLDB_OPT_SET_4 = _lldb.LLDB_OPT_SET_4

LLDB_OPT_SET_5 = _lldb.LLDB_OPT_SET_5

LLDB_OPT_SET_6 = _lldb.LLDB_OPT_SET_6

LLDB_OPT_SET_7 = _lldb.LLDB_OPT_SET_7

LLDB_OPT_SET_8 = _lldb.LLDB_OPT_SET_8

LLDB_OPT_SET_9 = _lldb.LLDB_OPT_SET_9

LLDB_OPT_SET_10 = _lldb.LLDB_OPT_SET_10

LLDB_OPT_SET_11 = _lldb.LLDB_OPT_SET_11

LLDB_OPT_SET_12 = _lldb.LLDB_OPT_SET_12

eStateInvalid = _lldb.eStateInvalid

eStateUnloaded = _lldb.eStateUnloaded

eStateConnected = _lldb.eStateConnected

eStateAttaching = _lldb.eStateAttaching

eStateLaunching = _lldb.eStateLaunching

eStateStopped = _lldb.eStateStopped

eStateRunning = _lldb.eStateRunning

eStateStepping = _lldb.eStateStepping

eStateCrashed = _lldb.eStateCrashed

eStateDetached = _lldb.eStateDetached

eStateExited = _lldb.eStateExited

eStateSuspended = _lldb.eStateSuspended

kLastStateType = _lldb.kLastStateType

eLaunchFlagNone = _lldb.eLaunchFlagNone

eLaunchFlagExec = _lldb.eLaunchFlagExec

eLaunchFlagDebug = _lldb.eLaunchFlagDebug

eLaunchFlagStopAtEntry = _lldb.eLaunchFlagStopAtEntry

eLaunchFlagDisableASLR = _lldb.eLaunchFlagDisableASLR

eLaunchFlagDisableSTDIO = _lldb.eLaunchFlagDisableSTDIO

eLaunchFlagLaunchInTTY = _lldb.eLaunchFlagLaunchInTTY

eLaunchFlagLaunchInShell = _lldb.eLaunchFlagLaunchInShell

eLaunchFlagLaunchInSeparateProcessGroup = _lldb.eLaunchFlagLaunchInSeparateProcessGroup

eLaunchFlagDontSetExitStatus = _lldb.eLaunchFlagDontSetExitStatus

eLaunchFlagDetachOnError = _lldb.eLaunchFlagDetachOnError

eLaunchFlagShellExpandArguments = _lldb.eLaunchFlagShellExpandArguments

eLaunchFlagCloseTTYOnExit = _lldb.eLaunchFlagCloseTTYOnExit

eLaunchFlagInheritTCCFromParent = _lldb.eLaunchFlagInheritTCCFromParent

eOnlyThisThread = _lldb.eOnlyThisThread

eAllThreads = _lldb.eAllThreads

eOnlyDuringStepping = _lldb.eOnlyDuringStepping

eByteOrderInvalid = _lldb.eByteOrderInvalid

eByteOrderBig = _lldb.eByteOrderBig

eByteOrderPDP = _lldb.eByteOrderPDP

eByteOrderLittle = _lldb.eByteOrderLittle

eEncodingInvalid = _lldb.eEncodingInvalid

eEncodingUint = _lldb.eEncodingUint

eEncodingSint = _lldb.eEncodingSint

eEncodingIEEE754 = _lldb.eEncodingIEEE754

eEncodingVector = _lldb.eEncodingVector

eFormatDefault = _lldb.eFormatDefault

eFormatInvalid = _lldb.eFormatInvalid

eFormatBoolean = _lldb.eFormatBoolean

eFormatBinary = _lldb.eFormatBinary

eFormatBytes = _lldb.eFormatBytes

eFormatBytesWithASCII = _lldb.eFormatBytesWithASCII

eFormatChar = _lldb.eFormatChar

eFormatCharPrintable = _lldb.eFormatCharPrintable

eFormatComplex = _lldb.eFormatComplex

eFormatComplexFloat = _lldb.eFormatComplexFloat

eFormatCString = _lldb.eFormatCString

eFormatDecimal = _lldb.eFormatDecimal

eFormatEnum = _lldb.eFormatEnum

eFormatHex = _lldb.eFormatHex

eFormatHexUppercase = _lldb.eFormatHexUppercase

eFormatFloat = _lldb.eFormatFloat

eFormatOctal = _lldb.eFormatOctal

eFormatOSType = _lldb.eFormatOSType

eFormatUnicode16 = _lldb.eFormatUnicode16

eFormatUnicode32 = _lldb.eFormatUnicode32

eFormatUnsigned = _lldb.eFormatUnsigned

eFormatPointer = _lldb.eFormatPointer

eFormatVectorOfChar = _lldb.eFormatVectorOfChar

eFormatVectorOfSInt8 = _lldb.eFormatVectorOfSInt8

eFormatVectorOfUInt8 = _lldb.eFormatVectorOfUInt8

eFormatVectorOfSInt16 = _lldb.eFormatVectorOfSInt16

eFormatVectorOfUInt16 = _lldb.eFormatVectorOfUInt16

eFormatVectorOfSInt32 = _lldb.eFormatVectorOfSInt32

eFormatVectorOfUInt32 = _lldb.eFormatVectorOfUInt32

eFormatVectorOfSInt64 = _lldb.eFormatVectorOfSInt64

eFormatVectorOfUInt64 = _lldb.eFormatVectorOfUInt64

eFormatVectorOfFloat16 = _lldb.eFormatVectorOfFloat16

eFormatVectorOfFloat32 = _lldb.eFormatVectorOfFloat32

eFormatVectorOfFloat64 = _lldb.eFormatVectorOfFloat64

eFormatVectorOfUInt128 = _lldb.eFormatVectorOfUInt128

eFormatComplexInteger = _lldb.eFormatComplexInteger

eFormatCharArray = _lldb.eFormatCharArray

eFormatAddressInfo = _lldb.eFormatAddressInfo

eFormatHexFloat = _lldb.eFormatHexFloat

eFormatInstruction = _lldb.eFormatInstruction

eFormatVoid = _lldb.eFormatVoid

eFormatUnicode8 = _lldb.eFormatUnicode8

kNumFormats = _lldb.kNumFormats

eDescriptionLevelBrief = _lldb.eDescriptionLevelBrief

eDescriptionLevelFull = _lldb.eDescriptionLevelFull

eDescriptionLevelVerbose = _lldb.eDescriptionLevelVerbose

eDescriptionLevelInitial = _lldb.eDescriptionLevelInitial

kNumDescriptionLevels = _lldb.kNumDescriptionLevels

eScriptLanguageNone = _lldb.eScriptLanguageNone

eScriptLanguagePython = _lldb.eScriptLanguagePython

eScriptLanguageLua = _lldb.eScriptLanguageLua

eScriptLanguageUnknown = _lldb.eScriptLanguageUnknown

eScriptLanguageDefault = _lldb.eScriptLanguageDefault

eRegisterKindEHFrame = _lldb.eRegisterKindEHFrame

eRegisterKindDWARF = _lldb.eRegisterKindDWARF

eRegisterKindGeneric = _lldb.eRegisterKindGeneric

eRegisterKindProcessPlugin = _lldb.eRegisterKindProcessPlugin

eRegisterKindLLDB = _lldb.eRegisterKindLLDB

kNumRegisterKinds = _lldb.kNumRegisterKinds

eStopReasonInvalid = _lldb.eStopReasonInvalid

eStopReasonNone = _lldb.eStopReasonNone

eStopReasonTrace = _lldb.eStopReasonTrace

eStopReasonBreakpoint = _lldb.eStopReasonBreakpoint

eStopReasonWatchpoint = _lldb.eStopReasonWatchpoint

eStopReasonSignal = _lldb.eStopReasonSignal

eStopReasonException = _lldb.eStopReasonException

eStopReasonExec = _lldb.eStopReasonExec

eStopReasonPlanComplete = _lldb.eStopReasonPlanComplete

eStopReasonThreadExiting = _lldb.eStopReasonThreadExiting

eStopReasonInstrumentation = _lldb.eStopReasonInstrumentation

eStopReasonProcessorTrace = _lldb.eStopReasonProcessorTrace

eStopReasonFork = _lldb.eStopReasonFork

eStopReasonVFork = _lldb.eStopReasonVFork

eStopReasonVForkDone = _lldb.eStopReasonVForkDone

eReturnStatusInvalid = _lldb.eReturnStatusInvalid

eReturnStatusSuccessFinishNoResult = _lldb.eReturnStatusSuccessFinishNoResult

eReturnStatusSuccessFinishResult = _lldb.eReturnStatusSuccessFinishResult

eReturnStatusSuccessContinuingNoResult = _lldb.eReturnStatusSuccessContinuingNoResult

eReturnStatusSuccessContinuingResult = _lldb.eReturnStatusSuccessContinuingResult

eReturnStatusStarted = _lldb.eReturnStatusStarted

eReturnStatusFailed = _lldb.eReturnStatusFailed

eReturnStatusQuit = _lldb.eReturnStatusQuit

eExpressionCompleted = _lldb.eExpressionCompleted

eExpressionSetupError = _lldb.eExpressionSetupError

eExpressionParseError = _lldb.eExpressionParseError

eExpressionDiscarded = _lldb.eExpressionDiscarded

eExpressionInterrupted = _lldb.eExpressionInterrupted

eExpressionHitBreakpoint = _lldb.eExpressionHitBreakpoint

eExpressionTimedOut = _lldb.eExpressionTimedOut

eExpressionResultUnavailable = _lldb.eExpressionResultUnavailable

eExpressionStoppedForDebug = _lldb.eExpressionStoppedForDebug

eExpressionThreadVanished = _lldb.eExpressionThreadVanished

eSearchDepthInvalid = _lldb.eSearchDepthInvalid

eSearchDepthTarget = _lldb.eSearchDepthTarget

eSearchDepthModule = _lldb.eSearchDepthModule

eSearchDepthCompUnit = _lldb.eSearchDepthCompUnit

eSearchDepthFunction = _lldb.eSearchDepthFunction

eSearchDepthBlock = _lldb.eSearchDepthBlock

eSearchDepthAddress = _lldb.eSearchDepthAddress

kLastSearchDepthKind = _lldb.kLastSearchDepthKind

eConnectionStatusSuccess = _lldb.eConnectionStatusSuccess

eConnectionStatusEndOfFile = _lldb.eConnectionStatusEndOfFile

eConnectionStatusError = _lldb.eConnectionStatusError

eConnectionStatusTimedOut = _lldb.eConnectionStatusTimedOut

eConnectionStatusNoConnection = _lldb.eConnectionStatusNoConnection

eConnectionStatusLostConnection = _lldb.eConnectionStatusLostConnection

eConnectionStatusInterrupted = _lldb.eConnectionStatusInterrupted

eErrorTypeInvalid = _lldb.eErrorTypeInvalid

eErrorTypeGeneric = _lldb.eErrorTypeGeneric

eErrorTypeMachKernel = _lldb.eErrorTypeMachKernel

eErrorTypePOSIX = _lldb.eErrorTypePOSIX

eErrorTypeExpression = _lldb.eErrorTypeExpression

eErrorTypeWin32 = _lldb.eErrorTypeWin32

eValueTypeInvalid = _lldb.eValueTypeInvalid

eValueTypeVariableGlobal = _lldb.eValueTypeVariableGlobal

eValueTypeVariableStatic = _lldb.eValueTypeVariableStatic

eValueTypeVariableArgument = _lldb.eValueTypeVariableArgument

eValueTypeVariableLocal = _lldb.eValueTypeVariableLocal

eValueTypeRegister = _lldb.eValueTypeRegister

eValueTypeRegisterSet = _lldb.eValueTypeRegisterSet

eValueTypeConstResult = _lldb.eValueTypeConstResult

eValueTypeVariableThreadLocal = _lldb.eValueTypeVariableThreadLocal

eInputReaderGranularityInvalid = _lldb.eInputReaderGranularityInvalid

eInputReaderGranularityByte = _lldb.eInputReaderGranularityByte

eInputReaderGranularityWord = _lldb.eInputReaderGranularityWord

eInputReaderGranularityLine = _lldb.eInputReaderGranularityLine

eInputReaderGranularityAll = _lldb.eInputReaderGranularityAll

eSymbolContextTarget = _lldb.eSymbolContextTarget

eSymbolContextModule = _lldb.eSymbolContextModule

eSymbolContextCompUnit = _lldb.eSymbolContextCompUnit

eSymbolContextFunction = _lldb.eSymbolContextFunction

eSymbolContextBlock = _lldb.eSymbolContextBlock

eSymbolContextLineEntry = _lldb.eSymbolContextLineEntry

eSymbolContextSymbol = _lldb.eSymbolContextSymbol

eSymbolContextEverything = _lldb.eSymbolContextEverything

eSymbolContextVariable = _lldb.eSymbolContextVariable

eSymbolContextLastItem = _lldb.eSymbolContextLastItem

ePermissionsWritable = _lldb.ePermissionsWritable

ePermissionsReadable = _lldb.ePermissionsReadable

ePermissionsExecutable = _lldb.ePermissionsExecutable

eInputReaderActivate = _lldb.eInputReaderActivate

eInputReaderAsynchronousOutputWritten = _lldb.eInputReaderAsynchronousOutputWritten

eInputReaderReactivate = _lldb.eInputReaderReactivate

eInputReaderDeactivate = _lldb.eInputReaderDeactivate

eInputReaderGotToken = _lldb.eInputReaderGotToken

eInputReaderInterrupt = _lldb.eInputReaderInterrupt

eInputReaderEndOfFile = _lldb.eInputReaderEndOfFile

eInputReaderDone = _lldb.eInputReaderDone

eBreakpointEventTypeInvalidType = _lldb.eBreakpointEventTypeInvalidType

eBreakpointEventTypeAdded = _lldb.eBreakpointEventTypeAdded

eBreakpointEventTypeRemoved = _lldb.eBreakpointEventTypeRemoved

eBreakpointEventTypeLocationsAdded = _lldb.eBreakpointEventTypeLocationsAdded

eBreakpointEventTypeLocationsRemoved = _lldb.eBreakpointEventTypeLocationsRemoved

eBreakpointEventTypeLocationsResolved = _lldb.eBreakpointEventTypeLocationsResolved

eBreakpointEventTypeEnabled = _lldb.eBreakpointEventTypeEnabled

eBreakpointEventTypeDisabled = _lldb.eBreakpointEventTypeDisabled

eBreakpointEventTypeCommandChanged = _lldb.eBreakpointEventTypeCommandChanged

eBreakpointEventTypeConditionChanged = _lldb.eBreakpointEventTypeConditionChanged

eBreakpointEventTypeIgnoreChanged = _lldb.eBreakpointEventTypeIgnoreChanged

eBreakpointEventTypeThreadChanged = _lldb.eBreakpointEventTypeThreadChanged

eBreakpointEventTypeAutoContinueChanged = _lldb.eBreakpointEventTypeAutoContinueChanged

eWatchpointEventTypeInvalidType = _lldb.eWatchpointEventTypeInvalidType

eWatchpointEventTypeAdded = _lldb.eWatchpointEventTypeAdded

eWatchpointEventTypeRemoved = _lldb.eWatchpointEventTypeRemoved

eWatchpointEventTypeEnabled = _lldb.eWatchpointEventTypeEnabled

eWatchpointEventTypeDisabled = _lldb.eWatchpointEventTypeDisabled

eWatchpointEventTypeCommandChanged = _lldb.eWatchpointEventTypeCommandChanged

eWatchpointEventTypeConditionChanged = _lldb.eWatchpointEventTypeConditionChanged

eWatchpointEventTypeIgnoreChanged = _lldb.eWatchpointEventTypeIgnoreChanged

eWatchpointEventTypeThreadChanged = _lldb.eWatchpointEventTypeThreadChanged

eWatchpointEventTypeTypeChanged = _lldb.eWatchpointEventTypeTypeChanged

eLanguageTypeUnknown = _lldb.eLanguageTypeUnknown

eLanguageTypeC89 = _lldb.eLanguageTypeC89

eLanguageTypeC = _lldb.eLanguageTypeC

eLanguageTypeAda83 = _lldb.eLanguageTypeAda83

eLanguageTypeC_plus_plus = _lldb.eLanguageTypeC_plus_plus

eLanguageTypeCobol74 = _lldb.eLanguageTypeCobol74

eLanguageTypeCobol85 = _lldb.eLanguageTypeCobol85

eLanguageTypeFortran77 = _lldb.eLanguageTypeFortran77

eLanguageTypeFortran90 = _lldb.eLanguageTypeFortran90

eLanguageTypePascal83 = _lldb.eLanguageTypePascal83

eLanguageTypeModula2 = _lldb.eLanguageTypeModula2

eLanguageTypeJava = _lldb.eLanguageTypeJava

eLanguageTypeC99 = _lldb.eLanguageTypeC99

eLanguageTypeAda95 = _lldb.eLanguageTypeAda95

eLanguageTypeFortran95 = _lldb.eLanguageTypeFortran95

eLanguageTypePLI = _lldb.eLanguageTypePLI

eLanguageTypeObjC = _lldb.eLanguageTypeObjC

eLanguageTypeObjC_plus_plus = _lldb.eLanguageTypeObjC_plus_plus

eLanguageTypeUPC = _lldb.eLanguageTypeUPC

eLanguageTypeD = _lldb.eLanguageTypeD

eLanguageTypePython = _lldb.eLanguageTypePython

eLanguageTypeOpenCL = _lldb.eLanguageTypeOpenCL

eLanguageTypeGo = _lldb.eLanguageTypeGo

eLanguageTypeModula3 = _lldb.eLanguageTypeModula3

eLanguageTypeHaskell = _lldb.eLanguageTypeHaskell

eLanguageTypeC_plus_plus_03 = _lldb.eLanguageTypeC_plus_plus_03

eLanguageTypeC_plus_plus_11 = _lldb.eLanguageTypeC_plus_plus_11

eLanguageTypeOCaml = _lldb.eLanguageTypeOCaml

eLanguageTypeRust = _lldb.eLanguageTypeRust

eLanguageTypeC11 = _lldb.eLanguageTypeC11

eLanguageTypeSwift = _lldb.eLanguageTypeSwift

eLanguageTypeJulia = _lldb.eLanguageTypeJulia

eLanguageTypeDylan = _lldb.eLanguageTypeDylan

eLanguageTypeC_plus_plus_14 = _lldb.eLanguageTypeC_plus_plus_14

eLanguageTypeFortran03 = _lldb.eLanguageTypeFortran03

eLanguageTypeFortran08 = _lldb.eLanguageTypeFortran08

eLanguageTypeRenderScript = _lldb.eLanguageTypeRenderScript

eLanguageTypeBLISS = _lldb.eLanguageTypeBLISS

eLanguageTypeKotlin = _lldb.eLanguageTypeKotlin

eLanguageTypeZig = _lldb.eLanguageTypeZig

eLanguageTypeCrystal = _lldb.eLanguageTypeCrystal

eLanguageTypeC_plus_plus_17 = _lldb.eLanguageTypeC_plus_plus_17

eLanguageTypeC_plus_plus_20 = _lldb.eLanguageTypeC_plus_plus_20

eLanguageTypeC17 = _lldb.eLanguageTypeC17

eLanguageTypeFortran18 = _lldb.eLanguageTypeFortran18

eLanguageTypeAda2005 = _lldb.eLanguageTypeAda2005

eLanguageTypeAda2012 = _lldb.eLanguageTypeAda2012

eLanguageTypeHIP = _lldb.eLanguageTypeHIP

eLanguageTypeAssembly = _lldb.eLanguageTypeAssembly

eLanguageTypeC_sharp = _lldb.eLanguageTypeC_sharp

eLanguageTypeMojo = _lldb.eLanguageTypeMojo

eLanguageTypeMipsAssembler = _lldb.eLanguageTypeMipsAssembler

eNumLanguageTypes = _lldb.eNumLanguageTypes

eInstrumentationRuntimeTypeAddressSanitizer = _lldb.eInstrumentationRuntimeTypeAddressSanitizer

eInstrumentationRuntimeTypeThreadSanitizer = _lldb.eInstrumentationRuntimeTypeThreadSanitizer

eInstrumentationRuntimeTypeUndefinedBehaviorSanitizer = _lldb.eInstrumentationRuntimeTypeUndefinedBehaviorSanitizer

eInstrumentationRuntimeTypeMainThreadChecker = _lldb.eInstrumentationRuntimeTypeMainThreadChecker

eInstrumentationRuntimeTypeSwiftRuntimeReporting = _lldb.eInstrumentationRuntimeTypeSwiftRuntimeReporting

eNumInstrumentationRuntimeTypes = _lldb.eNumInstrumentationRuntimeTypes

eNoDynamicValues = _lldb.eNoDynamicValues

eDynamicCanRunTarget = _lldb.eDynamicCanRunTarget

eDynamicDontRunTarget = _lldb.eDynamicDontRunTarget

eStopShowColumnAnsiOrCaret = _lldb.eStopShowColumnAnsiOrCaret

eStopShowColumnAnsi = _lldb.eStopShowColumnAnsi

eStopShowColumnCaret = _lldb.eStopShowColumnCaret

eStopShowColumnNone = _lldb.eStopShowColumnNone

eAccessNone = _lldb.eAccessNone

eAccessPublic = _lldb.eAccessPublic

eAccessPrivate = _lldb.eAccessPrivate

eAccessProtected = _lldb.eAccessProtected

eAccessPackage = _lldb.eAccessPackage

eArgTypeAddress = _lldb.eArgTypeAddress

eArgTypeAddressOrExpression = _lldb.eArgTypeAddressOrExpression

eArgTypeAliasName = _lldb.eArgTypeAliasName

eArgTypeAliasOptions = _lldb.eArgTypeAliasOptions

eArgTypeArchitecture = _lldb.eArgTypeArchitecture

eArgTypeBoolean = _lldb.eArgTypeBoolean

eArgTypeBreakpointID = _lldb.eArgTypeBreakpointID

eArgTypeBreakpointIDRange = _lldb.eArgTypeBreakpointIDRange

eArgTypeBreakpointName = _lldb.eArgTypeBreakpointName

eArgTypeByteSize = _lldb.eArgTypeByteSize

eArgTypeClassName = _lldb.eArgTypeClassName

eArgTypeCommandName = _lldb.eArgTypeCommandName

eArgTypeCount = _lldb.eArgTypeCount

eArgTypeDescriptionVerbosity = _lldb.eArgTypeDescriptionVerbosity

eArgTypeDirectoryName = _lldb.eArgTypeDirectoryName

eArgTypeDisassemblyFlavor = _lldb.eArgTypeDisassemblyFlavor

eArgTypeEndAddress = _lldb.eArgTypeEndAddress

eArgTypeExpression = _lldb.eArgTypeExpression

eArgTypeExpressionPath = _lldb.eArgTypeExpressionPath

eArgTypeExprFormat = _lldb.eArgTypeExprFormat

eArgTypeFileLineColumn = _lldb.eArgTypeFileLineColumn

eArgTypeFilename = _lldb.eArgTypeFilename

eArgTypeFormat = _lldb.eArgTypeFormat

eArgTypeFrameIndex = _lldb.eArgTypeFrameIndex

eArgTypeFullName = _lldb.eArgTypeFullName

eArgTypeFunctionName = _lldb.eArgTypeFunctionName

eArgTypeFunctionOrSymbol = _lldb.eArgTypeFunctionOrSymbol

eArgTypeGDBFormat = _lldb.eArgTypeGDBFormat

eArgTypeHelpText = _lldb.eArgTypeHelpText

eArgTypeIndex = _lldb.eArgTypeIndex

eArgTypeLanguage = _lldb.eArgTypeLanguage

eArgTypeLineNum = _lldb.eArgTypeLineNum

eArgTypeLogCategory = _lldb.eArgTypeLogCategory

eArgTypeLogChannel = _lldb.eArgTypeLogChannel

eArgTypeMethod = _lldb.eArgTypeMethod

eArgTypeName = _lldb.eArgTypeName

eArgTypeNewPathPrefix = _lldb.eArgTypeNewPathPrefix

eArgTypeNumLines = _lldb.eArgTypeNumLines

eArgTypeNumberPerLine = _lldb.eArgTypeNumberPerLine

eArgTypeOffset = _lldb.eArgTypeOffset

eArgTypeOldPathPrefix = _lldb.eArgTypeOldPathPrefix

eArgTypeOneLiner = _lldb.eArgTypeOneLiner

eArgTypePath = _lldb.eArgTypePath

eArgTypePermissionsNumber = _lldb.eArgTypePermissionsNumber

eArgTypePermissionsString = _lldb.eArgTypePermissionsString

eArgTypePid = _lldb.eArgTypePid

eArgTypePlugin = _lldb.eArgTypePlugin

eArgTypeProcessName = _lldb.eArgTypeProcessName

eArgTypePythonClass = _lldb.eArgTypePythonClass

eArgTypePythonFunction = _lldb.eArgTypePythonFunction

eArgTypePythonScript = _lldb.eArgTypePythonScript

eArgTypeQueueName = _lldb.eArgTypeQueueName

eArgTypeRegisterName = _lldb.eArgTypeRegisterName

eArgTypeRegularExpression = _lldb.eArgTypeRegularExpression

eArgTypeRunArgs = _lldb.eArgTypeRunArgs

eArgTypeRunMode = _lldb.eArgTypeRunMode

eArgTypeScriptedCommandSynchronicity = _lldb.eArgTypeScriptedCommandSynchronicity

eArgTypeScriptLang = _lldb.eArgTypeScriptLang

eArgTypeSearchWord = _lldb.eArgTypeSearchWord

eArgTypeSelector = _lldb.eArgTypeSelector

eArgTypeSettingIndex = _lldb.eArgTypeSettingIndex

eArgTypeSettingKey = _lldb.eArgTypeSettingKey

eArgTypeSettingPrefix = _lldb.eArgTypeSettingPrefix

eArgTypeSettingVariableName = _lldb.eArgTypeSettingVariableName

eArgTypeShlibName = _lldb.eArgTypeShlibName

eArgTypeSourceFile = _lldb.eArgTypeSourceFile

eArgTypeSortOrder = _lldb.eArgTypeSortOrder

eArgTypeStartAddress = _lldb.eArgTypeStartAddress

eArgTypeSummaryString = _lldb.eArgTypeSummaryString

eArgTypeSymbol = _lldb.eArgTypeSymbol

eArgTypeThreadID = _lldb.eArgTypeThreadID

eArgTypeThreadIndex = _lldb.eArgTypeThreadIndex

eArgTypeThreadName = _lldb.eArgTypeThreadName

eArgTypeTypeName = _lldb.eArgTypeTypeName

eArgTypeUnsignedInteger = _lldb.eArgTypeUnsignedInteger

eArgTypeUnixSignal = _lldb.eArgTypeUnixSignal

eArgTypeVarName = _lldb.eArgTypeVarName

eArgTypeValue = _lldb.eArgTypeValue

eArgTypeWidth = _lldb.eArgTypeWidth

eArgTypeNone = _lldb.eArgTypeNone

eArgTypePlatform = _lldb.eArgTypePlatform

eArgTypeWatchpointID = _lldb.eArgTypeWatchpointID

eArgTypeWatchpointIDRange = _lldb.eArgTypeWatchpointIDRange

eArgTypeWatchType = _lldb.eArgTypeWatchType

eArgRawInput = _lldb.eArgRawInput

eArgTypeCommand = _lldb.eArgTypeCommand

eArgTypeColumnNum = _lldb.eArgTypeColumnNum

eArgTypeModuleUUID = _lldb.eArgTypeModuleUUID

eArgTypeSaveCoreStyle = _lldb.eArgTypeSaveCoreStyle

eArgTypeLogHandler = _lldb.eArgTypeLogHandler

eArgTypeSEDStylePair = _lldb.eArgTypeSEDStylePair

eArgTypeRecognizerID = _lldb.eArgTypeRecognizerID

eArgTypeConnectURL = _lldb.eArgTypeConnectURL

eArgTypeTargetID = _lldb.eArgTypeTargetID

eArgTypeStopHookID = _lldb.eArgTypeStopHookID

eArgTypeCompletionType = _lldb.eArgTypeCompletionType

eArgTypeLastArg = _lldb.eArgTypeLastArg

eSymbolTypeAny = _lldb.eSymbolTypeAny

eSymbolTypeInvalid = _lldb.eSymbolTypeInvalid

eSymbolTypeAbsolute = _lldb.eSymbolTypeAbsolute

eSymbolTypeCode = _lldb.eSymbolTypeCode

eSymbolTypeResolver = _lldb.eSymbolTypeResolver

eSymbolTypeData = _lldb.eSymbolTypeData

eSymbolTypeTrampoline = _lldb.eSymbolTypeTrampoline

eSymbolTypeRuntime = _lldb.eSymbolTypeRuntime

eSymbolTypeException = _lldb.eSymbolTypeException

eSymbolTypeSourceFile = _lldb.eSymbolTypeSourceFile

eSymbolTypeHeaderFile = _lldb.eSymbolTypeHeaderFile

eSymbolTypeObjectFile = _lldb.eSymbolTypeObjectFile

eSymbolTypeCommonBlock = _lldb.eSymbolTypeCommonBlock

eSymbolTypeBlock = _lldb.eSymbolTypeBlock

eSymbolTypeLocal = _lldb.eSymbolTypeLocal

eSymbolTypeParam = _lldb.eSymbolTypeParam

eSymbolTypeVariable = _lldb.eSymbolTypeVariable

eSymbolTypeVariableType = _lldb.eSymbolTypeVariableType

eSymbolTypeLineEntry = _lldb.eSymbolTypeLineEntry

eSymbolTypeLineHeader = _lldb.eSymbolTypeLineHeader

eSymbolTypeScopeBegin = _lldb.eSymbolTypeScopeBegin

eSymbolTypeScopeEnd = _lldb.eSymbolTypeScopeEnd

eSymbolTypeAdditional = _lldb.eSymbolTypeAdditional

eSymbolTypeCompiler = _lldb.eSymbolTypeCompiler

eSymbolTypeInstrumentation = _lldb.eSymbolTypeInstrumentation

eSymbolTypeUndefined = _lldb.eSymbolTypeUndefined

eSymbolTypeObjCClass = _lldb.eSymbolTypeObjCClass

eSymbolTypeObjCMetaClass = _lldb.eSymbolTypeObjCMetaClass

eSymbolTypeObjCIVar = _lldb.eSymbolTypeObjCIVar

eSymbolTypeReExported = _lldb.eSymbolTypeReExported

eSectionTypeInvalid = _lldb.eSectionTypeInvalid

eSectionTypeCode = _lldb.eSectionTypeCode

eSectionTypeContainer = _lldb.eSectionTypeContainer

eSectionTypeData = _lldb.eSectionTypeData

eSectionTypeDataCString = _lldb.eSectionTypeDataCString

eSectionTypeDataCStringPointers = _lldb.eSectionTypeDataCStringPointers

eSectionTypeDataSymbolAddress = _lldb.eSectionTypeDataSymbolAddress

eSectionTypeData4 = _lldb.eSectionTypeData4

eSectionTypeData8 = _lldb.eSectionTypeData8

eSectionTypeData16 = _lldb.eSectionTypeData16

eSectionTypeDataPointers = _lldb.eSectionTypeDataPointers

eSectionTypeDebug = _lldb.eSectionTypeDebug

eSectionTypeZeroFill = _lldb.eSectionTypeZeroFill

eSectionTypeDataObjCMessageRefs = _lldb.eSectionTypeDataObjCMessageRefs

eSectionTypeDataObjCCFStrings = _lldb.eSectionTypeDataObjCCFStrings

eSectionTypeDWARFDebugAbbrev = _lldb.eSectionTypeDWARFDebugAbbrev

eSectionTypeDWARFDebugAddr = _lldb.eSectionTypeDWARFDebugAddr

eSectionTypeDWARFDebugAranges = _lldb.eSectionTypeDWARFDebugAranges

eSectionTypeDWARFDebugCuIndex = _lldb.eSectionTypeDWARFDebugCuIndex

eSectionTypeDWARFDebugFrame = _lldb.eSectionTypeDWARFDebugFrame

eSectionTypeDWARFDebugInfo = _lldb.eSectionTypeDWARFDebugInfo

eSectionTypeDWARFDebugLine = _lldb.eSectionTypeDWARFDebugLine

eSectionTypeDWARFDebugLoc = _lldb.eSectionTypeDWARFDebugLoc

eSectionTypeDWARFDebugMacInfo = _lldb.eSectionTypeDWARFDebugMacInfo

eSectionTypeDWARFDebugMacro = _lldb.eSectionTypeDWARFDebugMacro

eSectionTypeDWARFDebugPubNames = _lldb.eSectionTypeDWARFDebugPubNames

eSectionTypeDWARFDebugPubTypes = _lldb.eSectionTypeDWARFDebugPubTypes

eSectionTypeDWARFDebugRanges = _lldb.eSectionTypeDWARFDebugRanges

eSectionTypeDWARFDebugStr = _lldb.eSectionTypeDWARFDebugStr

eSectionTypeDWARFDebugStrOffsets = _lldb.eSectionTypeDWARFDebugStrOffsets

eSectionTypeDWARFAppleNames = _lldb.eSectionTypeDWARFAppleNames

eSectionTypeDWARFAppleTypes = _lldb.eSectionTypeDWARFAppleTypes

eSectionTypeDWARFAppleNamespaces = _lldb.eSectionTypeDWARFAppleNamespaces

eSectionTypeDWARFAppleObjC = _lldb.eSectionTypeDWARFAppleObjC

eSectionTypeELFSymbolTable = _lldb.eSectionTypeELFSymbolTable

eSectionTypeELFDynamicSymbols = _lldb.eSectionTypeELFDynamicSymbols

eSectionTypeELFRelocationEntries = _lldb.eSectionTypeELFRelocationEntries

eSectionTypeELFDynamicLinkInfo = _lldb.eSectionTypeELFDynamicLinkInfo

eSectionTypeEHFrame = _lldb.eSectionTypeEHFrame

eSectionTypeARMexidx = _lldb.eSectionTypeARMexidx

eSectionTypeARMextab = _lldb.eSectionTypeARMextab

eSectionTypeCompactUnwind = _lldb.eSectionTypeCompactUnwind

eSectionTypeGoSymtab = _lldb.eSectionTypeGoSymtab

eSectionTypeAbsoluteAddress = _lldb.eSectionTypeAbsoluteAddress

eSectionTypeDWARFGNUDebugAltLink = _lldb.eSectionTypeDWARFGNUDebugAltLink

eSectionTypeDWARFDebugTypes = _lldb.eSectionTypeDWARFDebugTypes

eSectionTypeDWARFDebugNames = _lldb.eSectionTypeDWARFDebugNames

eSectionTypeOther = _lldb.eSectionTypeOther

eSectionTypeDWARFDebugLineStr = _lldb.eSectionTypeDWARFDebugLineStr

eSectionTypeDWARFDebugRngLists = _lldb.eSectionTypeDWARFDebugRngLists

eSectionTypeDWARFDebugLocLists = _lldb.eSectionTypeDWARFDebugLocLists

eSectionTypeDWARFDebugAbbrevDwo = _lldb.eSectionTypeDWARFDebugAbbrevDwo

eSectionTypeDWARFDebugInfoDwo = _lldb.eSectionTypeDWARFDebugInfoDwo

eSectionTypeDWARFDebugStrDwo = _lldb.eSectionTypeDWARFDebugStrDwo

eSectionTypeDWARFDebugStrOffsetsDwo = _lldb.eSectionTypeDWARFDebugStrOffsetsDwo

eSectionTypeDWARFDebugTypesDwo = _lldb.eSectionTypeDWARFDebugTypesDwo

eSectionTypeDWARFDebugRngListsDwo = _lldb.eSectionTypeDWARFDebugRngListsDwo

eSectionTypeDWARFDebugLocDwo = _lldb.eSectionTypeDWARFDebugLocDwo

eSectionTypeDWARFDebugLocListsDwo = _lldb.eSectionTypeDWARFDebugLocListsDwo

eSectionTypeDWARFDebugTuIndex = _lldb.eSectionTypeDWARFDebugTuIndex

eSectionTypeCTF = _lldb.eSectionTypeCTF

eEmulateInstructionOptionNone = _lldb.eEmulateInstructionOptionNone

eEmulateInstructionOptionAutoAdvancePC = _lldb.eEmulateInstructionOptionAutoAdvancePC

eEmulateInstructionOptionIgnoreConditions = _lldb.eEmulateInstructionOptionIgnoreConditions

eFunctionNameTypeNone = _lldb.eFunctionNameTypeNone

eFunctionNameTypeAuto = _lldb.eFunctionNameTypeAuto

eFunctionNameTypeFull = _lldb.eFunctionNameTypeFull

eFunctionNameTypeBase = _lldb.eFunctionNameTypeBase

eFunctionNameTypeMethod = _lldb.eFunctionNameTypeMethod

eFunctionNameTypeSelector = _lldb.eFunctionNameTypeSelector

eFunctionNameTypeAny = _lldb.eFunctionNameTypeAny

eBasicTypeInvalid = _lldb.eBasicTypeInvalid

eBasicTypeVoid = _lldb.eBasicTypeVoid

eBasicTypeChar = _lldb.eBasicTypeChar

eBasicTypeSignedChar = _lldb.eBasicTypeSignedChar

eBasicTypeUnsignedChar = _lldb.eBasicTypeUnsignedChar

eBasicTypeWChar = _lldb.eBasicTypeWChar

eBasicTypeSignedWChar = _lldb.eBasicTypeSignedWChar

eBasicTypeUnsignedWChar = _lldb.eBasicTypeUnsignedWChar

eBasicTypeChar16 = _lldb.eBasicTypeChar16

eBasicTypeChar32 = _lldb.eBasicTypeChar32

eBasicTypeChar8 = _lldb.eBasicTypeChar8

eBasicTypeShort = _lldb.eBasicTypeShort

eBasicTypeUnsignedShort = _lldb.eBasicTypeUnsignedShort

eBasicTypeInt = _lldb.eBasicTypeInt

eBasicTypeUnsignedInt = _lldb.eBasicTypeUnsignedInt

eBasicTypeLong = _lldb.eBasicTypeLong

eBasicTypeUnsignedLong = _lldb.eBasicTypeUnsignedLong

eBasicTypeLongLong = _lldb.eBasicTypeLongLong

eBasicTypeUnsignedLongLong = _lldb.eBasicTypeUnsignedLongLong

eBasicTypeInt128 = _lldb.eBasicTypeInt128

eBasicTypeUnsignedInt128 = _lldb.eBasicTypeUnsignedInt128

eBasicTypeBool = _lldb.eBasicTypeBool

eBasicTypeHalf = _lldb.eBasicTypeHalf

eBasicTypeFloat = _lldb.eBasicTypeFloat

eBasicTypeDouble = _lldb.eBasicTypeDouble

eBasicTypeLongDouble = _lldb.eBasicTypeLongDouble

eBasicTypeFloatComplex = _lldb.eBasicTypeFloatComplex

eBasicTypeDoubleComplex = _lldb.eBasicTypeDoubleComplex

eBasicTypeLongDoubleComplex = _lldb.eBasicTypeLongDoubleComplex

eBasicTypeObjCID = _lldb.eBasicTypeObjCID

eBasicTypeObjCClass = _lldb.eBasicTypeObjCClass

eBasicTypeObjCSel = _lldb.eBasicTypeObjCSel

eBasicTypeNullPtr = _lldb.eBasicTypeNullPtr

eBasicTypeOther = _lldb.eBasicTypeOther

eTraceTypeNone = _lldb.eTraceTypeNone

eTraceTypeProcessorTrace = _lldb.eTraceTypeProcessorTrace

eStructuredDataTypeInvalid = _lldb.eStructuredDataTypeInvalid

eStructuredDataTypeNull = _lldb.eStructuredDataTypeNull

eStructuredDataTypeGeneric = _lldb.eStructuredDataTypeGeneric

eStructuredDataTypeArray = _lldb.eStructuredDataTypeArray

eStructuredDataTypeInteger = _lldb.eStructuredDataTypeInteger

eStructuredDataTypeFloat = _lldb.eStructuredDataTypeFloat

eStructuredDataTypeBoolean = _lldb.eStructuredDataTypeBoolean

eStructuredDataTypeString = _lldb.eStructuredDataTypeString

eStructuredDataTypeDictionary = _lldb.eStructuredDataTypeDictionary

eStructuredDataTypeSignedInteger = _lldb.eStructuredDataTypeSignedInteger

eStructuredDataTypeUnsignedInteger = _lldb.eStructuredDataTypeUnsignedInteger

eTypeClassInvalid = _lldb.eTypeClassInvalid

eTypeClassArray = _lldb.eTypeClassArray

eTypeClassBlockPointer = _lldb.eTypeClassBlockPointer

eTypeClassBuiltin = _lldb.eTypeClassBuiltin

eTypeClassClass = _lldb.eTypeClassClass

eTypeClassComplexFloat = _lldb.eTypeClassComplexFloat

eTypeClassComplexInteger = _lldb.eTypeClassComplexInteger

eTypeClassEnumeration = _lldb.eTypeClassEnumeration

eTypeClassFunction = _lldb.eTypeClassFunction

eTypeClassMemberPointer = _lldb.eTypeClassMemberPointer

eTypeClassObjCObject = _lldb.eTypeClassObjCObject

eTypeClassObjCInterface = _lldb.eTypeClassObjCInterface

eTypeClassObjCObjectPointer = _lldb.eTypeClassObjCObjectPointer

eTypeClassPointer = _lldb.eTypeClassPointer

eTypeClassReference = _lldb.eTypeClassReference

eTypeClassStruct = _lldb.eTypeClassStruct

eTypeClassTypedef = _lldb.eTypeClassTypedef

eTypeClassUnion = _lldb.eTypeClassUnion

eTypeClassVector = _lldb.eTypeClassVector

eTypeClassOther = _lldb.eTypeClassOther

eTypeClassAny = _lldb.eTypeClassAny

eTemplateArgumentKindNull = _lldb.eTemplateArgumentKindNull

eTemplateArgumentKindType = _lldb.eTemplateArgumentKindType

eTemplateArgumentKindDeclaration = _lldb.eTemplateArgumentKindDeclaration

eTemplateArgumentKindIntegral = _lldb.eTemplateArgumentKindIntegral

eTemplateArgumentKindTemplate = _lldb.eTemplateArgumentKindTemplate

eTemplateArgumentKindTemplateExpansion = _lldb.eTemplateArgumentKindTemplateExpansion

eTemplateArgumentKindExpression = _lldb.eTemplateArgumentKindExpression

eTemplateArgumentKindPack = _lldb.eTemplateArgumentKindPack

eTemplateArgumentKindNullPtr = _lldb.eTemplateArgumentKindNullPtr

eFormatterMatchExact = _lldb.eFormatterMatchExact

eFormatterMatchRegex = _lldb.eFormatterMatchRegex

eFormatterMatchCallback = _lldb.eFormatterMatchCallback

eLastFormatterMatchType = _lldb.eLastFormatterMatchType

eTypeOptionNone = _lldb.eTypeOptionNone

eTypeOptionCascade = _lldb.eTypeOptionCascade

eTypeOptionSkipPointers = _lldb.eTypeOptionSkipPointers

eTypeOptionSkipReferences = _lldb.eTypeOptionSkipReferences

eTypeOptionHideChildren = _lldb.eTypeOptionHideChildren

eTypeOptionHideValue = _lldb.eTypeOptionHideValue

eTypeOptionShowOneLiner = _lldb.eTypeOptionShowOneLiner

eTypeOptionHideNames = _lldb.eTypeOptionHideNames

eTypeOptionNonCacheable = _lldb.eTypeOptionNonCacheable

eTypeOptionHideEmptyAggregates = _lldb.eTypeOptionHideEmptyAggregates

eTypeOptionFrontEndWantsDereference = _lldb.eTypeOptionFrontEndWantsDereference

eFrameCompareInvalid = _lldb.eFrameCompareInvalid

eFrameCompareUnknown = _lldb.eFrameCompareUnknown

eFrameCompareEqual = _lldb.eFrameCompareEqual

eFrameCompareSameParent = _lldb.eFrameCompareSameParent

eFrameCompareYounger = _lldb.eFrameCompareYounger

eFrameCompareOlder = _lldb.eFrameCompareOlder

eFilePermissionsUserRead = _lldb.eFilePermissionsUserRead

eFilePermissionsUserWrite = _lldb.eFilePermissionsUserWrite

eFilePermissionsUserExecute = _lldb.eFilePermissionsUserExecute

eFilePermissionsGroupRead = _lldb.eFilePermissionsGroupRead

eFilePermissionsGroupWrite = _lldb.eFilePermissionsGroupWrite

eFilePermissionsGroupExecute = _lldb.eFilePermissionsGroupExecute

eFilePermissionsWorldRead = _lldb.eFilePermissionsWorldRead

eFilePermissionsWorldWrite = _lldb.eFilePermissionsWorldWrite

eFilePermissionsWorldExecute = _lldb.eFilePermissionsWorldExecute

eFilePermissionsUserRW = _lldb.eFilePermissionsUserRW

eFileFilePermissionsUserRX = _lldb.eFileFilePermissionsUserRX

eFilePermissionsUserRWX = _lldb.eFilePermissionsUserRWX

eFilePermissionsGroupRW = _lldb.eFilePermissionsGroupRW

eFilePermissionsGroupRX = _lldb.eFilePermissionsGroupRX

eFilePermissionsGroupRWX = _lldb.eFilePermissionsGroupRWX

eFilePermissionsWorldRW = _lldb.eFilePermissionsWorldRW

eFilePermissionsWorldRX = _lldb.eFilePermissionsWorldRX

eFilePermissionsWorldRWX = _lldb.eFilePermissionsWorldRWX

eFilePermissionsEveryoneR = _lldb.eFilePermissionsEveryoneR

eFilePermissionsEveryoneW = _lldb.eFilePermissionsEveryoneW

eFilePermissionsEveryoneX = _lldb.eFilePermissionsEveryoneX

eFilePermissionsEveryoneRW = _lldb.eFilePermissionsEveryoneRW

eFilePermissionsEveryoneRX = _lldb.eFilePermissionsEveryoneRX

eFilePermissionsEveryoneRWX = _lldb.eFilePermissionsEveryoneRWX

eFilePermissionsFileDefault = _lldb.eFilePermissionsFileDefault

eFilePermissionsDirectoryDefault = _lldb.eFilePermissionsDirectoryDefault

eQueueItemKindUnknown = _lldb.eQueueItemKindUnknown

eQueueItemKindFunction = _lldb.eQueueItemKindFunction

eQueueItemKindBlock = _lldb.eQueueItemKindBlock

eQueueKindUnknown = _lldb.eQueueKindUnknown

eQueueKindSerial = _lldb.eQueueKindSerial

eQueueKindConcurrent = _lldb.eQueueKindConcurrent

eExpressionEvaluationParse = _lldb.eExpressionEvaluationParse

eExpressionEvaluationIRGen = _lldb.eExpressionEvaluationIRGen

eExpressionEvaluationExecution = _lldb.eExpressionEvaluationExecution

eExpressionEvaluationComplete = _lldb.eExpressionEvaluationComplete

eInstructionControlFlowKindUnknown = _lldb.eInstructionControlFlowKindUnknown

eInstructionControlFlowKindOther = _lldb.eInstructionControlFlowKindOther

eInstructionControlFlowKindCall = _lldb.eInstructionControlFlowKindCall

eInstructionControlFlowKindReturn = _lldb.eInstructionControlFlowKindReturn

eInstructionControlFlowKindJump = _lldb.eInstructionControlFlowKindJump

eInstructionControlFlowKindCondJump = _lldb.eInstructionControlFlowKindCondJump

eInstructionControlFlowKindFarCall = _lldb.eInstructionControlFlowKindFarCall

eInstructionControlFlowKindFarReturn = _lldb.eInstructionControlFlowKindFarReturn

eInstructionControlFlowKindFarJump = _lldb.eInstructionControlFlowKindFarJump

eWatchpointKindWrite = _lldb.eWatchpointKindWrite

eWatchpointKindRead = _lldb.eWatchpointKindRead

eGdbSignalBadAccess = _lldb.eGdbSignalBadAccess

eGdbSignalBadInstruction = _lldb.eGdbSignalBadInstruction

eGdbSignalArithmetic = _lldb.eGdbSignalArithmetic

eGdbSignalEmulation = _lldb.eGdbSignalEmulation

eGdbSignalSoftware = _lldb.eGdbSignalSoftware

eGdbSignalBreakpoint = _lldb.eGdbSignalBreakpoint

ePathTypeLLDBShlibDir = _lldb.ePathTypeLLDBShlibDir

ePathTypeSupportExecutableDir = _lldb.ePathTypeSupportExecutableDir

ePathTypeHeaderDir = _lldb.ePathTypeHeaderDir

ePathTypePythonDir = _lldb.ePathTypePythonDir

ePathTypeLLDBSystemPlugins = _lldb.ePathTypeLLDBSystemPlugins

ePathTypeLLDBUserPlugins = _lldb.ePathTypeLLDBUserPlugins

ePathTypeLLDBTempSystemDir = _lldb.ePathTypeLLDBTempSystemDir

ePathTypeGlobalLLDBTempSystemDir = _lldb.ePathTypeGlobalLLDBTempSystemDir

ePathTypeClangDir = _lldb.ePathTypeClangDir

eMemberFunctionKindUnknown = _lldb.eMemberFunctionKindUnknown

eMemberFunctionKindConstructor = _lldb.eMemberFunctionKindConstructor

eMemberFunctionKindDestructor = _lldb.eMemberFunctionKindDestructor

eMemberFunctionKindInstanceMethod = _lldb.eMemberFunctionKindInstanceMethod

eMemberFunctionKindStaticMethod = _lldb.eMemberFunctionKindStaticMethod

eMatchTypeNormal = _lldb.eMatchTypeNormal

eMatchTypeRegex = _lldb.eMatchTypeRegex

eMatchTypeStartsWith = _lldb.eMatchTypeStartsWith

eTypeHasChildren = _lldb.eTypeHasChildren

eTypeHasValue = _lldb.eTypeHasValue

eTypeIsArray = _lldb.eTypeIsArray

eTypeIsBlock = _lldb.eTypeIsBlock

eTypeIsBuiltIn = _lldb.eTypeIsBuiltIn

eTypeIsClass = _lldb.eTypeIsClass

eTypeIsCPlusPlus = _lldb.eTypeIsCPlusPlus

eTypeIsEnumeration = _lldb.eTypeIsEnumeration

eTypeIsFuncPrototype = _lldb.eTypeIsFuncPrototype

eTypeIsMember = _lldb.eTypeIsMember

eTypeIsObjC = _lldb.eTypeIsObjC

eTypeIsPointer = _lldb.eTypeIsPointer

eTypeIsReference = _lldb.eTypeIsReference

eTypeIsStructUnion = _lldb.eTypeIsStructUnion

eTypeIsTemplate = _lldb.eTypeIsTemplate

eTypeIsTypedef = _lldb.eTypeIsTypedef

eTypeIsVector = _lldb.eTypeIsVector

eTypeIsScalar = _lldb.eTypeIsScalar

eTypeIsInteger = _lldb.eTypeIsInteger

eTypeIsFloat = _lldb.eTypeIsFloat

eTypeIsComplex = _lldb.eTypeIsComplex

eTypeIsSigned = _lldb.eTypeIsSigned

eTypeInstanceIsPointer = _lldb.eTypeInstanceIsPointer

eCommandRequiresTarget = _lldb.eCommandRequiresTarget

eCommandRequiresProcess = _lldb.eCommandRequiresProcess

eCommandRequiresThread = _lldb.eCommandRequiresThread

eCommandRequiresFrame = _lldb.eCommandRequiresFrame

eCommandRequiresRegContext = _lldb.eCommandRequiresRegContext

eCommandTryTargetAPILock = _lldb.eCommandTryTargetAPILock

eCommandProcessMustBeLaunched = _lldb.eCommandProcessMustBeLaunched

eCommandProcessMustBePaused = _lldb.eCommandProcessMustBePaused

eCommandProcessMustBeTraced = _lldb.eCommandProcessMustBeTraced

eTypeSummaryCapped = _lldb.eTypeSummaryCapped

eTypeSummaryUncapped = _lldb.eTypeSummaryUncapped

eCommandInterpreterResultSuccess = _lldb.eCommandInterpreterResultSuccess

eCommandInterpreterResultInferiorCrash = _lldb.eCommandInterpreterResultInferiorCrash

eCommandInterpreterResultCommandError = _lldb.eCommandInterpreterResultCommandError

eCommandInterpreterResultQuitRequested = _lldb.eCommandInterpreterResultQuitRequested

eSaveCoreUnspecified = _lldb.eSaveCoreUnspecified

eSaveCoreFull = _lldb.eSaveCoreFull

eSaveCoreDirtyOnly = _lldb.eSaveCoreDirtyOnly

eSaveCoreStackOnly = _lldb.eSaveCoreStackOnly

eTraceEventDisabledSW = _lldb.eTraceEventDisabledSW

eTraceEventDisabledHW = _lldb.eTraceEventDisabledHW

eTraceEventCPUChanged = _lldb.eTraceEventCPUChanged

eTraceEventHWClockTick = _lldb.eTraceEventHWClockTick

eTraceEventSyncPoint = _lldb.eTraceEventSyncPoint

eTraceItemKindError = _lldb.eTraceItemKindError

eTraceItemKindEvent = _lldb.eTraceItemKindEvent

eTraceItemKindInstruction = _lldb.eTraceItemKindInstruction

eTraceCursorSeekTypeBeginning = _lldb.eTraceCursorSeekTypeBeginning

eTraceCursorSeekTypeCurrent = _lldb.eTraceCursorSeekTypeCurrent

eTraceCursorSeekTypeEnd = _lldb.eTraceCursorSeekTypeEnd

eDWIMPrintVerbosityNone = _lldb.eDWIMPrintVerbosityNone

eDWIMPrintVerbosityExpression = _lldb.eDWIMPrintVerbosityExpression

eDWIMPrintVerbosityFull = _lldb.eDWIMPrintVerbosityFull

eWatchPointValueKindInvalid = _lldb.eWatchPointValueKindInvalid

eWatchPointValueKindVariable = _lldb.eWatchPointValueKindVariable

eWatchPointValueKindExpression = _lldb.eWatchPointValueKindExpression

eNoCompletion = _lldb.eNoCompletion

eSourceFileCompletion = _lldb.eSourceFileCompletion

eDiskFileCompletion = _lldb.eDiskFileCompletion

eDiskDirectoryCompletion = _lldb.eDiskDirectoryCompletion

eSymbolCompletion = _lldb.eSymbolCompletion

eModuleCompletion = _lldb.eModuleCompletion

eSettingsNameCompletion = _lldb.eSettingsNameCompletion

ePlatformPluginCompletion = _lldb.ePlatformPluginCompletion

eArchitectureCompletion = _lldb.eArchitectureCompletion

eVariablePathCompletion = _lldb.eVariablePathCompletion

eRegisterCompletion = _lldb.eRegisterCompletion

eBreakpointCompletion = _lldb.eBreakpointCompletion

eProcessPluginCompletion = _lldb.eProcessPluginCompletion

eDisassemblyFlavorCompletion = _lldb.eDisassemblyFlavorCompletion

eTypeLanguageCompletion = _lldb.eTypeLanguageCompletion

eFrameIndexCompletion = _lldb.eFrameIndexCompletion

eModuleUUIDCompletion = _lldb.eModuleUUIDCompletion

eStopHookIDCompletion = _lldb.eStopHookIDCompletion

eThreadIndexCompletion = _lldb.eThreadIndexCompletion

eWatchpointIDCompletion = _lldb.eWatchpointIDCompletion

eBreakpointNameCompletion = _lldb.eBreakpointNameCompletion

eProcessIDCompletion = _lldb.eProcessIDCompletion

eProcessNameCompletion = _lldb.eProcessNameCompletion

eRemoteDiskFileCompletion = _lldb.eRemoteDiskFileCompletion

eRemoteDiskDirectoryCompletion = _lldb.eRemoteDiskDirectoryCompletion

eTypeCategoryNameCompletion = _lldb.eTypeCategoryNameCompletion

eCustomCompletion = _lldb.eCustomCompletion

class SBAddress(object):
    r"""
    A section + offset based address class.

    The SBAddress class allows addresses to be relative to a section
    that can move during runtime due to images (executables, shared
    libraries, bundles, frameworks) being loaded at different
    addresses than the addresses found in the object file that
    represents them on disk. There are currently two types of addresses
    for a section:

    * file addresses
    * load addresses

    File addresses represents the virtual addresses that are in the 'on
    disk' object files. These virtual addresses are converted to be
    relative to unique sections scoped to the object file so that
    when/if the addresses slide when the images are loaded/unloaded
    in memory, we can easily track these changes without having to
    update every object (compile unit ranges, line tables, function
    address ranges, lexical block and inlined subroutine address
    ranges, global and static variables) each time an image is loaded or
    unloaded.

    Load addresses represents the virtual addresses where each section
    ends up getting loaded at runtime. Before executing a program, it
    is common for all of the load addresses to be unresolved. When a
    DynamicLoader plug-in receives notification that shared libraries
    have been loaded/unloaded, the load addresses of the main executable
    and any images (shared libraries) will be  resolved/unresolved. When
    this happens, breakpoints that are in one of these sections can be
    set/cleared.

    See docstring of SBFunction for example usage of SBAddress.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBAddress self) -> SBAddress
        __init__(SBAddress self, SBAddress rhs) -> SBAddress
        __init__(SBAddress self, SBSection section, lldb::addr_t offset) -> SBAddress
        __init__(SBAddress self, lldb::addr_t load_addr, SBTarget target) -> SBAddress

            Create an address by resolving a load address using the supplied target.
        """
        _lldb.SBAddress_swiginit(self, _lldb.new_SBAddress(*args))
    __swig_destroy__ = _lldb.delete_SBAddress

    def __nonzero__(self):
        return _lldb.SBAddress___nonzero__(self)
    __bool__ = __nonzero__



    def __ne__(self, rhs: "SBAddress") -> "bool":
        r"""__ne__(SBAddress self, SBAddress rhs) -> bool"""
        return _lldb.SBAddress___ne__(self, rhs)

    def IsValid(self) -> "bool":
        r"""IsValid(SBAddress self) -> bool"""
        return _lldb.SBAddress_IsValid(self)

    def Clear(self):
        r"""Clear(SBAddress self)"""
        return _lldb.SBAddress_Clear(self)

    def GetFileAddress(self) -> int:
        r"""GetFileAddress(SBAddress self) -> lldb::addr_t"""
        return _lldb.SBAddress_GetFileAddress(self)

    def GetLoadAddress(self, target: "SBTarget") -> int:
        r"""GetLoadAddress(SBAddress self, SBTarget target) -> lldb::addr_t"""
        return _lldb.SBAddress_GetLoadAddress(self, target)

    def SetAddress(self, section: "SBSection", offset: int):
        r"""SetAddress(SBAddress self, SBSection section, lldb::addr_t offset)"""
        return _lldb.SBAddress_SetAddress(self, section, offset)

    def SetLoadAddress(self, load_addr: int, target: "SBTarget"):
        r"""SetLoadAddress(SBAddress self, lldb::addr_t load_addr, SBTarget target)"""
        return _lldb.SBAddress_SetLoadAddress(self, load_addr, target)

    def OffsetAddress(self, offset: int) -> "bool":
        r"""OffsetAddress(SBAddress self, lldb::addr_t offset) -> bool"""
        return _lldb.SBAddress_OffsetAddress(self, offset)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBAddress self, SBStream description) -> bool"""
        return _lldb.SBAddress_GetDescription(self, description)

    def GetSymbolContext(self, resolve_scope: int) -> "SBSymbolContext":
        r"""
        GetSymbolContext(SBAddress self, uint32_t resolve_scope) -> SBSymbolContext

            GetSymbolContext() and the following can lookup symbol information for a given address.
            An address might refer to code or data from an existing module, or it
            might refer to something on the stack or heap. The following functions
            will only return valid values if the address has been resolved to a code
            or data address using :py:class:`SBAddress.SetLoadAddress' or
            :py:class:`SBTarget.ResolveLoadAddress`.
        """
        return _lldb.SBAddress_GetSymbolContext(self, resolve_scope)

    def GetSection(self) -> "SBSection":
        r"""GetSection(SBAddress self) -> SBSection"""
        return _lldb.SBAddress_GetSection(self)

    def GetOffset(self) -> int:
        r"""GetOffset(SBAddress self) -> lldb::addr_t"""
        return _lldb.SBAddress_GetOffset(self)

    def GetModule(self) -> "SBModule":
        r"""
        GetModule(SBAddress self) -> SBModule

            GetModule() and the following grab individual objects for a given address and
            are less efficient if you want more than one symbol related objects.
            Use :py:class:`SBAddress.GetSymbolContext` or
            :py:class:`SBTarget.ResolveSymbolContextForAddress` when you want multiple
            debug symbol related objects for an address.
            One or more bits from the SymbolContextItem enumerations can be logically
            OR'ed together to more efficiently retrieve multiple symbol objects.
        """
        return _lldb.SBAddress_GetModule(self)

    def GetCompileUnit(self) -> "SBCompileUnit":
        r"""GetCompileUnit(SBAddress self) -> SBCompileUnit"""
        return _lldb.SBAddress_GetCompileUnit(self)

    def GetFunction(self) -> "SBFunction":
        r"""GetFunction(SBAddress self) -> SBFunction"""
        return _lldb.SBAddress_GetFunction(self)

    def GetBlock(self) -> "SBBlock":
        r"""GetBlock(SBAddress self) -> SBBlock"""
        return _lldb.SBAddress_GetBlock(self)

    def GetSymbol(self) -> "SBSymbol":
        r"""GetSymbol(SBAddress self) -> SBSymbol"""
        return _lldb.SBAddress_GetSymbol(self)

    def GetLineEntry(self) -> "SBLineEntry":
        r"""GetLineEntry(SBAddress self) -> SBLineEntry"""
        return _lldb.SBAddress_GetLineEntry(self)

    def __repr__(self) -> str:
        r"""__repr__(SBAddress self) -> std::string"""
        return _lldb.SBAddress___repr__(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __len__(self):
        pass

    def __iter__(self):
        pass


    __runtime_error_str = 'This resolves the SBAddress using the SBTarget from lldb.target so this property can ONLY be used in the interactive script interpreter (i.e. under the lldb script command). For things like Python based commands and breakpoint callbacks use GetLoadAddress instead.'

    def __get_load_addr_property__ (self):
        '''Get the load address for a lldb.SBAddress using the current target. This resolves the SBAddress using the SBTarget from lldb.target so this property can ONLY be used in the interactive script interpreter (i.e. under the lldb script command). For things like Python based commands and breakpoint callbacks use GetLoadAddress instead.'''
        if not target:
            raise RuntimeError(self.__runtime_error_str)
        return self.GetLoadAddress (target)

    def __set_load_addr_property__ (self, load_addr):
        '''Set the load address for a lldb.SBAddress using the current target. This resolves the SBAddress using the SBTarget from lldb.target so this property can ONLY be used in the interactive script interpreter (i.e. under the lldb script command). For things like Python based commands and breakpoint callbacks use GetLoadAddress instead.'''
        if not target:
            raise RuntimeError(self.__runtime_error_str)
        return self.SetLoadAddress (load_addr, target)

    def __int__(self):
        '''Convert an address to a load address if there is a process and that process is alive, or to a file address otherwise. This resolves the SBAddress using the SBTarget from lldb.target so this property can ONLY be used in the interactive script interpreter (i.e. under the lldb script command). For things like Python based commands and breakpoint callbacks use GetLoadAddress instead.'''
        if not process or not target:
            raise RuntimeError(self.__runtime_error_str)
        if process.is_alive:
            return self.GetLoadAddress (target)
        return self.GetFileAddress ()

    def __oct__(self):
        '''Convert the address to an octal string. This resolves the SBAddress using the SBTarget from lldb.target so this property can ONLY be used in the interactive script interpreter (i.e. under the lldb script command). For things like Python based commands and breakpoint callbacks use GetLoadAddress instead.'''
        return '%o' % int(self)

    def __hex__(self):
        '''Convert the address to an hex string. This resolves the SBAddress using the SBTarget from lldb.target so this property can ONLY be used in the interactive script interpreter (i.e. under the lldb script command). For things like Python based commands and breakpoint callbacks use GetLoadAddress instead.'''
        return '0x%x' % int(self)

    module = property(GetModule, None, doc='''A read only property that returns an lldb object that represents the module (lldb.SBModule) that this address resides within.''')
    compile_unit = property(GetCompileUnit, None, doc='''A read only property that returns an lldb object that represents the compile unit (lldb.SBCompileUnit) that this address resides within.''')
    line_entry = property(GetLineEntry, None, doc='''A read only property that returns an lldb object that represents the line entry (lldb.SBLineEntry) that this address resides within.''')
    function = property(GetFunction, None, doc='''A read only property that returns an lldb object that represents the function (lldb.SBFunction) that this address resides within.''')
    block = property(GetBlock, None, doc='''A read only property that returns an lldb object that represents the block (lldb.SBBlock) that this address resides within.''')
    symbol = property(GetSymbol, None, doc='''A read only property that returns an lldb object that represents the symbol (lldb.SBSymbol) that this address resides within.''')
    offset = property(GetOffset, None, doc='''A read only property that returns the section offset in bytes as an integer.''')
    section = property(GetSection, None, doc='''A read only property that returns an lldb object that represents the section (lldb.SBSection) that this address resides within.''')
    file_addr = property(GetFileAddress, None, doc='''A read only property that returns file address for the section as an integer. This is the address that represents the address as it is found in the object file that defines it.''')
    load_addr = property(__get_load_addr_property__, __set_load_addr_property__, doc='''A read/write property that gets/sets the SBAddress using load address. This resolves the SBAddress using the SBTarget from lldb.target so this property can ONLY be used in the interactive script interpreter (i.e. under the lldb script command). For things like Python based commands and breakpoint callbacks use GetLoadAddress instead.''')


# Register SBAddress in _lldb:
_lldb.SBAddress_swigregister(SBAddress)

class SBAttachInfo(object):
    r"""Describes how to attach when calling :py:class:`SBTarget.Attach`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBAttachInfo self) -> SBAttachInfo
        __init__(SBAttachInfo self, lldb::pid_t pid) -> SBAttachInfo
        __init__(SBAttachInfo self, char const * path, bool wait_for) -> SBAttachInfo
        __init__(SBAttachInfo self, char const * path, bool wait_for, bool _async) -> SBAttachInfo
        __init__(SBAttachInfo self, SBAttachInfo rhs) -> SBAttachInfo
        """
        _lldb.SBAttachInfo_swiginit(self, _lldb.new_SBAttachInfo(*args))
    __swig_destroy__ = _lldb.delete_SBAttachInfo

    def GetProcessID(self) -> int:
        r"""GetProcessID(SBAttachInfo self) -> lldb::pid_t"""
        return _lldb.SBAttachInfo_GetProcessID(self)

    def SetProcessID(self, pid: int):
        r"""SetProcessID(SBAttachInfo self, lldb::pid_t pid)"""
        return _lldb.SBAttachInfo_SetProcessID(self, pid)

    def SetExecutable(self, *args):
        r"""
        SetExecutable(SBAttachInfo self, char const * path)
        SetExecutable(SBAttachInfo self, SBFileSpec exe_file)
        """
        return _lldb.SBAttachInfo_SetExecutable(self, *args)

    def GetWaitForLaunch(self) -> "bool":
        r"""GetWaitForLaunch(SBAttachInfo self) -> bool"""
        return _lldb.SBAttachInfo_GetWaitForLaunch(self)

    def SetWaitForLaunch(self, *args):
        r"""
        SetWaitForLaunch(SBAttachInfo self, bool b)
        SetWaitForLaunch(SBAttachInfo self, bool b, bool _async)
        """
        return _lldb.SBAttachInfo_SetWaitForLaunch(self, *args)

    def GetIgnoreExisting(self) -> "bool":
        r"""GetIgnoreExisting(SBAttachInfo self) -> bool"""
        return _lldb.SBAttachInfo_GetIgnoreExisting(self)

    def SetIgnoreExisting(self, b: "bool"):
        r"""SetIgnoreExisting(SBAttachInfo self, bool b)"""
        return _lldb.SBAttachInfo_SetIgnoreExisting(self, b)

    def GetResumeCount(self) -> int:
        r"""GetResumeCount(SBAttachInfo self) -> uint32_t"""
        return _lldb.SBAttachInfo_GetResumeCount(self)

    def SetResumeCount(self, c: int):
        r"""SetResumeCount(SBAttachInfo self, uint32_t c)"""
        return _lldb.SBAttachInfo_SetResumeCount(self, c)

    def GetProcessPluginName(self) -> str:
        r"""GetProcessPluginName(SBAttachInfo self) -> char const *"""
        return _lldb.SBAttachInfo_GetProcessPluginName(self)

    def SetProcessPluginName(self, plugin_name: str):
        r"""SetProcessPluginName(SBAttachInfo self, char const * plugin_name)"""
        return _lldb.SBAttachInfo_SetProcessPluginName(self, plugin_name)

    def GetUserID(self) -> int:
        r"""GetUserID(SBAttachInfo self) -> uint32_t"""
        return _lldb.SBAttachInfo_GetUserID(self)

    def GetGroupID(self) -> int:
        r"""GetGroupID(SBAttachInfo self) -> uint32_t"""
        return _lldb.SBAttachInfo_GetGroupID(self)

    def UserIDIsValid(self) -> "bool":
        r"""UserIDIsValid(SBAttachInfo self) -> bool"""
        return _lldb.SBAttachInfo_UserIDIsValid(self)

    def GroupIDIsValid(self) -> "bool":
        r"""GroupIDIsValid(SBAttachInfo self) -> bool"""
        return _lldb.SBAttachInfo_GroupIDIsValid(self)

    def SetUserID(self, uid: int):
        r"""SetUserID(SBAttachInfo self, uint32_t uid)"""
        return _lldb.SBAttachInfo_SetUserID(self, uid)

    def SetGroupID(self, gid: int):
        r"""SetGroupID(SBAttachInfo self, uint32_t gid)"""
        return _lldb.SBAttachInfo_SetGroupID(self, gid)

    def GetEffectiveUserID(self) -> int:
        r"""GetEffectiveUserID(SBAttachInfo self) -> uint32_t"""
        return _lldb.SBAttachInfo_GetEffectiveUserID(self)

    def GetEffectiveGroupID(self) -> int:
        r"""GetEffectiveGroupID(SBAttachInfo self) -> uint32_t"""
        return _lldb.SBAttachInfo_GetEffectiveGroupID(self)

    def EffectiveUserIDIsValid(self) -> "bool":
        r"""EffectiveUserIDIsValid(SBAttachInfo self) -> bool"""
        return _lldb.SBAttachInfo_EffectiveUserIDIsValid(self)

    def EffectiveGroupIDIsValid(self) -> "bool":
        r"""EffectiveGroupIDIsValid(SBAttachInfo self) -> bool"""
        return _lldb.SBAttachInfo_EffectiveGroupIDIsValid(self)

    def SetEffectiveUserID(self, uid: int):
        r"""SetEffectiveUserID(SBAttachInfo self, uint32_t uid)"""
        return _lldb.SBAttachInfo_SetEffectiveUserID(self, uid)

    def SetEffectiveGroupID(self, gid: int):
        r"""SetEffectiveGroupID(SBAttachInfo self, uint32_t gid)"""
        return _lldb.SBAttachInfo_SetEffectiveGroupID(self, gid)

    def GetParentProcessID(self) -> int:
        r"""GetParentProcessID(SBAttachInfo self) -> lldb::pid_t"""
        return _lldb.SBAttachInfo_GetParentProcessID(self)

    def SetParentProcessID(self, pid: int):
        r"""SetParentProcessID(SBAttachInfo self, lldb::pid_t pid)"""
        return _lldb.SBAttachInfo_SetParentProcessID(self, pid)

    def ParentProcessIDIsValid(self) -> "bool":
        r"""ParentProcessIDIsValid(SBAttachInfo self) -> bool"""
        return _lldb.SBAttachInfo_ParentProcessIDIsValid(self)

    def GetListener(self) -> "SBListener":
        r"""GetListener(SBAttachInfo self) -> SBListener"""
        return _lldb.SBAttachInfo_GetListener(self)

    def SetListener(self, listener: "SBListener"):
        r"""SetListener(SBAttachInfo self, SBListener listener)"""
        return _lldb.SBAttachInfo_SetListener(self, listener)

    def GetShadowListener(self) -> "SBListener":
        r"""GetShadowListener(SBAttachInfo self) -> SBListener"""
        return _lldb.SBAttachInfo_GetShadowListener(self)

    def SetShadowListener(self, listener: "SBListener"):
        r"""SetShadowListener(SBAttachInfo self, SBListener listener)"""
        return _lldb.SBAttachInfo_SetShadowListener(self, listener)

    def GetScriptedProcessClassName(self) -> str:
        r"""GetScriptedProcessClassName(SBAttachInfo self) -> char const *"""
        return _lldb.SBAttachInfo_GetScriptedProcessClassName(self)

    def SetScriptedProcessClassName(self, class_name: str):
        r"""SetScriptedProcessClassName(SBAttachInfo self, char const * class_name)"""
        return _lldb.SBAttachInfo_SetScriptedProcessClassName(self, class_name)

    def GetScriptedProcessDictionary(self) -> "SBStructuredData":
        r"""GetScriptedProcessDictionary(SBAttachInfo self) -> SBStructuredData"""
        return _lldb.SBAttachInfo_GetScriptedProcessDictionary(self)

    def SetScriptedProcessDictionary(self, dict: "SBStructuredData"):
        r"""SetScriptedProcessDictionary(SBAttachInfo self, SBStructuredData dict)"""
        return _lldb.SBAttachInfo_SetScriptedProcessDictionary(self, dict)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __len__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __iter__(self):
      pass


# Register SBAttachInfo in _lldb:
_lldb.SBAttachInfo_swigregister(SBAttachInfo)

class SBBlock(object):
    r"""Represents a lexical block. SBFunction contains SBBlock(s)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBBlock self) -> SBBlock
        __init__(SBBlock self, SBBlock rhs) -> SBBlock
        """
        _lldb.SBBlock_swiginit(self, _lldb.new_SBBlock(*args))
    __swig_destroy__ = _lldb.delete_SBBlock

    def IsInlined(self) -> "bool":
        r"""
        IsInlined(SBBlock self) -> bool
        Is this block contained within an inlined function?
        """
        return _lldb.SBBlock_IsInlined(self)

    def __nonzero__(self):
        return _lldb.SBBlock___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBBlock self) -> bool"""
        return _lldb.SBBlock_IsValid(self)

    def GetInlinedName(self) -> str:
        r"""
        GetInlinedName(SBBlock self) -> char const *

            Get the function name if this block represents an inlined function;
            otherwise, return None.
        """
        return _lldb.SBBlock_GetInlinedName(self)

    def GetInlinedCallSiteFile(self) -> "SBFileSpec":
        r"""
        GetInlinedCallSiteFile(SBBlock self) -> SBFileSpec

            Get the call site file if this block represents an inlined function;
            otherwise, return an invalid file spec.
        """
        return _lldb.SBBlock_GetInlinedCallSiteFile(self)

    def GetInlinedCallSiteLine(self) -> int:
        r"""
        GetInlinedCallSiteLine(SBBlock self) -> uint32_t

            Get the call site line if this block represents an inlined function;
            otherwise, return 0.
        """
        return _lldb.SBBlock_GetInlinedCallSiteLine(self)

    def GetInlinedCallSiteColumn(self) -> int:
        r"""
        GetInlinedCallSiteColumn(SBBlock self) -> uint32_t

            Get the call site column if this block represents an inlined function;
            otherwise, return 0.
        """
        return _lldb.SBBlock_GetInlinedCallSiteColumn(self)

    def GetParent(self) -> "SBBlock":
        r"""
        GetParent(SBBlock self) -> SBBlock
        Get the parent block.
        """
        return _lldb.SBBlock_GetParent(self)

    def GetSibling(self) -> "SBBlock":
        r"""
        GetSibling(SBBlock self) -> SBBlock
        Get the sibling block for this block.
        """
        return _lldb.SBBlock_GetSibling(self)

    def GetFirstChild(self) -> "SBBlock":
        r"""
        GetFirstChild(SBBlock self) -> SBBlock
        Get the first child block.
        """
        return _lldb.SBBlock_GetFirstChild(self)

    def GetNumRanges(self) -> int:
        r"""GetNumRanges(SBBlock self) -> uint32_t"""
        return _lldb.SBBlock_GetNumRanges(self)

    def GetRangeStartAddress(self, idx: int) -> "SBAddress":
        r"""GetRangeStartAddress(SBBlock self, uint32_t idx) -> SBAddress"""
        return _lldb.SBBlock_GetRangeStartAddress(self, idx)

    def GetRangeEndAddress(self, idx: int) -> "SBAddress":
        r"""GetRangeEndAddress(SBBlock self, uint32_t idx) -> SBAddress"""
        return _lldb.SBBlock_GetRangeEndAddress(self, idx)

    def GetRangeIndexForBlockAddress(self, block_addr: "SBAddress") -> int:
        r"""GetRangeIndexForBlockAddress(SBBlock self, SBAddress block_addr) -> uint32_t"""
        return _lldb.SBBlock_GetRangeIndexForBlockAddress(self, block_addr)

    def GetVariables(self, *args) -> "SBValueList":
        r"""
        GetVariables(SBBlock self, SBFrame frame, bool arguments, bool locals, bool statics, lldb::DynamicValueType use_dynamic) -> SBValueList
        GetVariables(SBBlock self, SBTarget target, bool arguments, bool locals, bool statics) -> SBValueList
        """
        return _lldb.SBBlock_GetVariables(self, *args)

    def GetContainingInlinedBlock(self) -> "SBBlock":
        r"""
        GetContainingInlinedBlock(SBBlock self) -> SBBlock
        Get the inlined block that is or contains this block.
        """
        return _lldb.SBBlock_GetContainingInlinedBlock(self)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBBlock self, SBStream description) -> bool"""
        return _lldb.SBBlock_GetDescription(self, description)

    def __repr__(self) -> str:
        r"""__repr__(SBBlock self) -> std::string"""
        return _lldb.SBBlock___repr__(self)

    def __int__(self):
        pass

    def __len__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __iter__(self):
        pass

    def get_range_at_index(self, idx):
        if idx < self.GetNumRanges():
            return [self.GetRangeStartAddress(idx), self.GetRangeEndAddress(idx)]
        return []

    class ranges_access(object):
        '''A helper object that will lazily hand out an array of lldb.SBAddress that represent address ranges for a block.'''
        def __init__(self, sbblock):
            self.sbblock = sbblock

        def __len__(self):
            if self.sbblock:
                return int(self.sbblock.GetNumRanges())
            return 0

        def __getitem__(self, key):
            count = len(self)
            if type(key) is int:
                return self.sbblock.get_range_at_index (key);
            if isinstance(key, SBAddress):
                range_idx = self.sbblock.GetRangeIndexForBlockAddress(key);
                if range_idx < len(self):
                    return [self.sbblock.GetRangeStartAddress(range_idx), self.sbblock.GetRangeEndAddress(range_idx)]
            else:
                print("error: unsupported item type: %s" % type(key))
            return None

    def get_ranges_access_object(self):
        '''An accessor function that returns a ranges_access() object which allows lazy block address ranges access.'''
        return self.ranges_access (self)

    def get_ranges_array(self):
        '''An accessor function that returns an array object that contains all ranges in this block object.'''
        if not hasattr(self, 'ranges_array'):
            self.ranges_array = []
            for idx in range(self.num_ranges):
                self.ranges_array.append ([self.GetRangeStartAddress(idx), self.GetRangeEndAddress(idx)])
        return self.ranges_array

    def get_call_site(self):
        return declaration(self.GetInlinedCallSiteFile(), self.GetInlinedCallSiteLine(), self.GetInlinedCallSiteColumn())

    parent = property(GetParent, None, doc='''A read only property that returns the same result as GetParent().''')
    first_child = property(GetFirstChild, None, doc='''A read only property that returns the same result as GetFirstChild().''')
    call_site = property(get_call_site, None, doc='''A read only property that returns a lldb.declaration object that contains the inlined call site file, line and column.''')
    sibling = property(GetSibling, None, doc='''A read only property that returns the same result as GetSibling().''')
    name = property(GetInlinedName, None, doc='''A read only property that returns the same result as GetInlinedName().''')
    inlined_block = property(GetContainingInlinedBlock, None, doc='''A read only property that returns the same result as GetContainingInlinedBlock().''')
    range = property(get_ranges_access_object, None, doc='''A read only property that allows item access to the address ranges for a block by integer (range = block.range[0]) and by lldb.SBAddress (find the range that contains the specified lldb.SBAddress like "pc_range = lldb.frame.block.range[frame.addr]").''')
    ranges = property(get_ranges_array, None, doc='''A read only property that returns a list() object that contains all of the address ranges for the block.''')
    num_ranges = property(GetNumRanges, None, doc='''A read only property that returns the same result as GetNumRanges().''')


# Register SBBlock in _lldb:
_lldb.SBBlock_swigregister(SBBlock)

class SBBreakpoint(object):
    r"""
    Represents a logical breakpoint and its associated settings.

    For example (from test/functionalities/breakpoint/breakpoint_ignore_count/
    TestBreakpointIgnoreCount.py),::

        def breakpoint_ignore_count_python(self):
            '''Use Python APIs to set breakpoint ignore count.'''
            exe = os.path.join(os.getcwd(), 'a.out')

            # Create a target by the debugger.
            target = self.dbg.CreateTarget(exe)
            self.assertTrue(target, VALID_TARGET)

            # Now create a breakpoint on main.c by name 'c'.
            breakpoint = target.BreakpointCreateByName('c', 'a.out')
            self.assertTrue(breakpoint and
                            breakpoint.GetNumLocations() == 1,
                            VALID_BREAKPOINT)

            # Get the breakpoint location from breakpoint after we verified that,
            # indeed, it has one location.
            location = breakpoint.GetLocationAtIndex(0)
            self.assertTrue(location and
                            location.IsEnabled(),
                            VALID_BREAKPOINT_LOCATION)

            # Set the ignore count on the breakpoint location.
            location.SetIgnoreCount(2)
            self.assertTrue(location.GetIgnoreCount() == 2,
                            'SetIgnoreCount() works correctly')

            # Now launch the process, and do not stop at entry point.
            process = target.LaunchSimple(None, None, os.getcwd())
            self.assertTrue(process, PROCESS_IS_VALID)

            # Frame#0 should be on main.c:37, frame#1 should be on main.c:25, and
            # frame#2 should be on main.c:48.
            #lldbutil.print_stacktraces(process)
            from lldbutil import get_stopped_thread
            thread = get_stopped_thread(process, lldb.eStopReasonBreakpoint)
            self.assertTrue(thread != None, 'There should be a thread stopped due to breakpoint')
            frame0 = thread.GetFrameAtIndex(0)
            frame1 = thread.GetFrameAtIndex(1)
            frame2 = thread.GetFrameAtIndex(2)
            self.assertTrue(frame0.GetLineEntry().GetLine() == self.line1 and
                            frame1.GetLineEntry().GetLine() == self.line3 and
                            frame2.GetLineEntry().GetLine() == self.line4,
                            STOPPED_DUE_TO_BREAKPOINT_IGNORE_COUNT)

            # The hit count for the breakpoint should be 3.
            self.assertTrue(breakpoint.GetHitCount() == 3)

            process.Continue()

    SBBreakpoint supports breakpoint location iteration, for example,::

        for bl in breakpoint:
            print('breakpoint location load addr: %s' % hex(bl.GetLoadAddress()))
            print('breakpoint location condition: %s' % hex(bl.GetCondition()))

    and rich comparison methods which allow the API program to use,::

        if aBreakpoint == bBreakpoint:
            ...

    to compare two breakpoints for equality.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBBreakpoint self) -> SBBreakpoint
        __init__(SBBreakpoint self, SBBreakpoint rhs) -> SBBreakpoint
        """
        _lldb.SBBreakpoint_swiginit(self, _lldb.new_SBBreakpoint(*args))
    __swig_destroy__ = _lldb.delete_SBBreakpoint

    def __eq__(self, rhs: "SBBreakpoint") -> "bool":
        r"""__eq__(SBBreakpoint self, SBBreakpoint rhs) -> bool"""
        return _lldb.SBBreakpoint___eq__(self, rhs)

    def __ne__(self, rhs: "SBBreakpoint") -> "bool":
        r"""__ne__(SBBreakpoint self, SBBreakpoint rhs) -> bool"""
        return _lldb.SBBreakpoint___ne__(self, rhs)

    def GetID(self) -> int:
        r"""GetID(SBBreakpoint self) -> lldb::break_id_t"""
        return _lldb.SBBreakpoint_GetID(self)

    def __nonzero__(self):
        return _lldb.SBBreakpoint___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBBreakpoint self) -> bool"""
        return _lldb.SBBreakpoint_IsValid(self)

    def ClearAllBreakpointSites(self):
        r"""ClearAllBreakpointSites(SBBreakpoint self)"""
        return _lldb.SBBreakpoint_ClearAllBreakpointSites(self)

    def GetTarget(self) -> "SBTarget":
        r"""GetTarget(SBBreakpoint self) -> SBTarget"""
        return _lldb.SBBreakpoint_GetTarget(self)

    def FindLocationByAddress(self, vm_addr: int) -> "SBBreakpointLocation":
        r"""FindLocationByAddress(SBBreakpoint self, lldb::addr_t vm_addr) -> SBBreakpointLocation"""
        return _lldb.SBBreakpoint_FindLocationByAddress(self, vm_addr)

    def FindLocationIDByAddress(self, vm_addr: int) -> int:
        r"""FindLocationIDByAddress(SBBreakpoint self, lldb::addr_t vm_addr) -> lldb::break_id_t"""
        return _lldb.SBBreakpoint_FindLocationIDByAddress(self, vm_addr)

    def FindLocationByID(self, bp_loc_id: int) -> "SBBreakpointLocation":
        r"""FindLocationByID(SBBreakpoint self, lldb::break_id_t bp_loc_id) -> SBBreakpointLocation"""
        return _lldb.SBBreakpoint_FindLocationByID(self, bp_loc_id)

    def GetLocationAtIndex(self, index: int) -> "SBBreakpointLocation":
        r"""GetLocationAtIndex(SBBreakpoint self, uint32_t index) -> SBBreakpointLocation"""
        return _lldb.SBBreakpoint_GetLocationAtIndex(self, index)

    def SetEnabled(self, enable: "bool"):
        r"""SetEnabled(SBBreakpoint self, bool enable)"""
        return _lldb.SBBreakpoint_SetEnabled(self, enable)

    def IsEnabled(self) -> "bool":
        r"""IsEnabled(SBBreakpoint self) -> bool"""
        return _lldb.SBBreakpoint_IsEnabled(self)

    def SetOneShot(self, one_shot: "bool"):
        r"""SetOneShot(SBBreakpoint self, bool one_shot)"""
        return _lldb.SBBreakpoint_SetOneShot(self, one_shot)

    def IsOneShot(self) -> "bool":
        r"""IsOneShot(SBBreakpoint self) -> bool"""
        return _lldb.SBBreakpoint_IsOneShot(self)

    def IsInternal(self) -> "bool":
        r"""IsInternal(SBBreakpoint self) -> bool"""
        return _lldb.SBBreakpoint_IsInternal(self)

    def GetHitCount(self) -> int:
        r"""GetHitCount(SBBreakpoint self) -> uint32_t"""
        return _lldb.SBBreakpoint_GetHitCount(self)

    def SetIgnoreCount(self, count: int):
        r"""SetIgnoreCount(SBBreakpoint self, uint32_t count)"""
        return _lldb.SBBreakpoint_SetIgnoreCount(self, count)

    def GetIgnoreCount(self) -> int:
        r"""GetIgnoreCount(SBBreakpoint self) -> uint32_t"""
        return _lldb.SBBreakpoint_GetIgnoreCount(self)

    def SetCondition(self, condition: str):
        r"""
        SetCondition(SBBreakpoint self, char const * condition)

            The breakpoint stops only if the condition expression evaluates to true.
        """
        return _lldb.SBBreakpoint_SetCondition(self, condition)

    def GetCondition(self) -> str:
        r"""
        GetCondition(SBBreakpoint self) -> char const *

            Get the condition expression for the breakpoint.
        """
        return _lldb.SBBreakpoint_GetCondition(self)

    def SetAutoContinue(self, auto_continue: "bool"):
        r"""SetAutoContinue(SBBreakpoint self, bool auto_continue)"""
        return _lldb.SBBreakpoint_SetAutoContinue(self, auto_continue)

    def GetAutoContinue(self) -> "bool":
        r"""GetAutoContinue(SBBreakpoint self) -> bool"""
        return _lldb.SBBreakpoint_GetAutoContinue(self)

    def SetThreadID(self, sb_thread_id: "lldb::tid_t"):
        r"""SetThreadID(SBBreakpoint self, lldb::tid_t sb_thread_id)"""
        return _lldb.SBBreakpoint_SetThreadID(self, sb_thread_id)

    def GetThreadID(self) -> "lldb::tid_t":
        r"""GetThreadID(SBBreakpoint self) -> lldb::tid_t"""
        return _lldb.SBBreakpoint_GetThreadID(self)

    def SetThreadIndex(self, index: int):
        r"""SetThreadIndex(SBBreakpoint self, uint32_t index)"""
        return _lldb.SBBreakpoint_SetThreadIndex(self, index)

    def GetThreadIndex(self) -> int:
        r"""GetThreadIndex(SBBreakpoint self) -> uint32_t"""
        return _lldb.SBBreakpoint_GetThreadIndex(self)

    def SetThreadName(self, thread_name: str):
        r"""SetThreadName(SBBreakpoint self, char const * thread_name)"""
        return _lldb.SBBreakpoint_SetThreadName(self, thread_name)

    def GetThreadName(self) -> str:
        r"""GetThreadName(SBBreakpoint self) -> char const *"""
        return _lldb.SBBreakpoint_GetThreadName(self)

    def SetQueueName(self, queue_name: str):
        r"""SetQueueName(SBBreakpoint self, char const * queue_name)"""
        return _lldb.SBBreakpoint_SetQueueName(self, queue_name)

    def GetQueueName(self) -> str:
        r"""GetQueueName(SBBreakpoint self) -> char const *"""
        return _lldb.SBBreakpoint_GetQueueName(self)

    def SetScriptCallbackFunction(self, *args) -> "SBError":
        r"""
        SetScriptCallbackFunction(SBBreakpoint self, char const * callback_function_name)
        SetScriptCallbackFunction(SBBreakpoint self, char const * callback_function_name, SBStructuredData extra_args) -> SBError

            Set the name of the script function to be called when the breakpoint is hit.
            To use this variant, the function should take (frame, bp_loc, extra_args, internal_dict) and
            when the breakpoint is hit the extra_args will be passed to the callback function.
        """
        return _lldb.SBBreakpoint_SetScriptCallbackFunction(self, *args)

    def SetCommandLineCommands(self, commands: "SBStringList"):
        r"""SetCommandLineCommands(SBBreakpoint self, SBStringList commands)"""
        return _lldb.SBBreakpoint_SetCommandLineCommands(self, commands)

    def GetCommandLineCommands(self, commands: "SBStringList") -> "bool":
        r"""GetCommandLineCommands(SBBreakpoint self, SBStringList commands) -> bool"""
        return _lldb.SBBreakpoint_GetCommandLineCommands(self, commands)

    def SetScriptCallbackBody(self, script_body_text: str) -> "SBError":
        r"""
        SetScriptCallbackBody(SBBreakpoint self, char const * script_body_text) -> SBError

            Provide the body for the script function to be called when the breakpoint is hit.
            The body will be wrapped in a function, which be passed two arguments:
            'frame' - which holds the bottom-most SBFrame of the thread that hit the breakpoint
            'bpno'  - which is the SBBreakpointLocation to which the callback was attached.

            The error parameter is currently ignored, but will at some point hold the Python
            compilation diagnostics.
            Returns true if the body compiles successfully, false if not.
        """
        return _lldb.SBBreakpoint_SetScriptCallbackBody(self, script_body_text)

    def AddName(self, new_name: str) -> "bool":
        r"""AddName(SBBreakpoint self, char const * new_name) -> bool"""
        return _lldb.SBBreakpoint_AddName(self, new_name)

    def AddNameWithErrorHandling(self, new_name: str) -> "SBError":
        r"""AddNameWithErrorHandling(SBBreakpoint self, char const * new_name) -> SBError"""
        return _lldb.SBBreakpoint_AddNameWithErrorHandling(self, new_name)

    def RemoveName(self, name_to_remove: str):
        r"""RemoveName(SBBreakpoint self, char const * name_to_remove)"""
        return _lldb.SBBreakpoint_RemoveName(self, name_to_remove)

    def MatchesName(self, name: str) -> "bool":
        r"""MatchesName(SBBreakpoint self, char const * name) -> bool"""
        return _lldb.SBBreakpoint_MatchesName(self, name)

    def GetNames(self, names: "SBStringList"):
        r"""GetNames(SBBreakpoint self, SBStringList names)"""
        return _lldb.SBBreakpoint_GetNames(self, names)

    def GetNumResolvedLocations(self) -> "size_t":
        r"""GetNumResolvedLocations(SBBreakpoint self) -> size_t"""
        return _lldb.SBBreakpoint_GetNumResolvedLocations(self)

    def GetNumLocations(self) -> "size_t":
        r"""GetNumLocations(SBBreakpoint self) -> size_t"""
        return _lldb.SBBreakpoint_GetNumLocations(self)

    def GetDescription(self, *args) -> "bool":
        r"""
        GetDescription(SBBreakpoint self, SBStream description) -> bool
        GetDescription(SBBreakpoint self, SBStream description, bool include_locations) -> bool
        """
        return _lldb.SBBreakpoint_GetDescription(self, *args)

    @staticmethod
    def EventIsBreakpointEvent(event: "SBEvent") -> "bool":
        r"""EventIsBreakpointEvent(SBEvent event) -> bool"""
        return _lldb.SBBreakpoint_EventIsBreakpointEvent(event)

    @staticmethod
    def GetBreakpointEventTypeFromEvent(event: "SBEvent") -> "lldb::BreakpointEventType":
        r"""GetBreakpointEventTypeFromEvent(SBEvent event) -> lldb::BreakpointEventType"""
        return _lldb.SBBreakpoint_GetBreakpointEventTypeFromEvent(event)

    @staticmethod
    def GetBreakpointFromEvent(event: "SBEvent") -> "SBBreakpoint":
        r"""GetBreakpointFromEvent(SBEvent event) -> SBBreakpoint"""
        return _lldb.SBBreakpoint_GetBreakpointFromEvent(event)

    @staticmethod
    def GetBreakpointLocationAtIndexFromEvent(event: "SBEvent", loc_idx: int) -> "SBBreakpointLocation":
        r"""GetBreakpointLocationAtIndexFromEvent(SBEvent event, uint32_t loc_idx) -> SBBreakpointLocation"""
        return _lldb.SBBreakpoint_GetBreakpointLocationAtIndexFromEvent(event, loc_idx)

    @staticmethod
    def GetNumBreakpointLocationsFromEvent(event_sp: "SBEvent") -> int:
        r"""GetNumBreakpointLocationsFromEvent(SBEvent event_sp) -> uint32_t"""
        return _lldb.SBBreakpoint_GetNumBreakpointLocationsFromEvent(event_sp)

    def IsHardware(self) -> "bool":
        r"""IsHardware(SBBreakpoint self) -> bool"""
        return _lldb.SBBreakpoint_IsHardware(self)

    def AddLocation(self, address: "SBAddress") -> "SBError":
        r"""AddLocation(SBBreakpoint self, SBAddress address) -> SBError"""
        return _lldb.SBBreakpoint_AddLocation(self, address)

    def SerializeToStructuredData(self) -> "SBStructuredData":
        r"""SerializeToStructuredData(SBBreakpoint self) -> SBStructuredData"""
        return _lldb.SBBreakpoint_SerializeToStructuredData(self)

    def __repr__(self) -> str:
        r"""__repr__(SBBreakpoint self) -> std::string"""
        return _lldb.SBBreakpoint___repr__(self)


    class locations_access(object):
        '''A helper object that will lazily hand out locations for a breakpoint when supplied an index.'''
        def __init__(self, sbbreakpoint):
            self.sbbreakpoint = sbbreakpoint

        def __len__(self):
            if self.sbbreakpoint:
                return int(self.sbbreakpoint.GetNumLocations())
            return 0

        def __getitem__(self, key):
            if isinstance(key, int):
                count = len(self)
                if -count <= key < count:
                    key %= count
                    return self.sbbreakpoint.GetLocationAtIndex(key)
            return None

    def get_locations_access_object(self):
        '''An accessor function that returns a locations_access() object which allows lazy location access from a lldb.SBBreakpoint object.'''
        return self.locations_access (self)

    def get_breakpoint_location_list(self):
        '''An accessor function that returns a list() that contains all locations in a lldb.SBBreakpoint object.'''
        locations = []
        accessor = self.get_locations_access_object()
        for idx in range(len(accessor)):
            locations.append(accessor[idx])
        return locations

    def __iter__(self):
        '''Iterate over all breakpoint locations in a lldb.SBBreakpoint
        object.'''
        return lldb_iter(self, 'GetNumLocations', 'GetLocationAtIndex')

    def __len__(self):
        '''Return the number of breakpoint locations in a lldb.SBBreakpoint
        object.'''
        return self.GetNumLocations()

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    locations = property(get_breakpoint_location_list, None, doc='''A read only property that returns a list() of lldb.SBBreakpointLocation objects for this breakpoint.''')
    location = property(get_locations_access_object, None, doc='''A read only property that returns an object that can access locations by index (not location ID) (location = bkpt.location[12]).''')
    id = property(GetID, None, doc='''A read only property that returns the ID of this breakpoint.''')
    enabled = property(IsEnabled, SetEnabled, doc='''A read/write property that configures whether this breakpoint is enabled or not.''')
    one_shot = property(IsOneShot, SetOneShot, doc='''A read/write property that configures whether this breakpoint is one-shot (deleted when hit) or not.''')
    num_locations = property(GetNumLocations, None, doc='''A read only property that returns the count of locations of this breakpoint.''')


    def __eq__(self, rhs):
        if not isinstance(rhs, type(self)):
            return False

        return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)

    def __ne__(self, rhs):
        if not isinstance(rhs, type(self)):
            return True

        return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)


# Register SBBreakpoint in _lldb:
_lldb.SBBreakpoint_swigregister(SBBreakpoint)

def SBBreakpoint_EventIsBreakpointEvent(event: "SBEvent") -> "bool":
    r"""SBBreakpoint_EventIsBreakpointEvent(SBEvent event) -> bool"""
    return _lldb.SBBreakpoint_EventIsBreakpointEvent(event)

def SBBreakpoint_GetBreakpointEventTypeFromEvent(event: "SBEvent") -> "lldb::BreakpointEventType":
    r"""SBBreakpoint_GetBreakpointEventTypeFromEvent(SBEvent event) -> lldb::BreakpointEventType"""
    return _lldb.SBBreakpoint_GetBreakpointEventTypeFromEvent(event)

def SBBreakpoint_GetBreakpointFromEvent(event: "SBEvent") -> "SBBreakpoint":
    r"""SBBreakpoint_GetBreakpointFromEvent(SBEvent event) -> SBBreakpoint"""
    return _lldb.SBBreakpoint_GetBreakpointFromEvent(event)

def SBBreakpoint_GetBreakpointLocationAtIndexFromEvent(event: "SBEvent", loc_idx: int) -> "SBBreakpointLocation":
    r"""SBBreakpoint_GetBreakpointLocationAtIndexFromEvent(SBEvent event, uint32_t loc_idx) -> SBBreakpointLocation"""
    return _lldb.SBBreakpoint_GetBreakpointLocationAtIndexFromEvent(event, loc_idx)

def SBBreakpoint_GetNumBreakpointLocationsFromEvent(event_sp: "SBEvent") -> int:
    r"""SBBreakpoint_GetNumBreakpointLocationsFromEvent(SBEvent event_sp) -> uint32_t"""
    return _lldb.SBBreakpoint_GetNumBreakpointLocationsFromEvent(event_sp)

class SBBreakpointList(object):
    r"""Represents a list of :py:class:`SBBreakpoint`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, target: "SBTarget"):
        r"""__init__(SBBreakpointList self, SBTarget target) -> SBBreakpointList"""
        _lldb.SBBreakpointList_swiginit(self, _lldb.new_SBBreakpointList(target))
    __swig_destroy__ = _lldb.delete_SBBreakpointList

    def GetSize(self) -> "size_t":
        r"""GetSize(SBBreakpointList self) -> size_t"""
        return _lldb.SBBreakpointList_GetSize(self)

    def GetBreakpointAtIndex(self, idx: "size_t") -> "SBBreakpoint":
        r"""GetBreakpointAtIndex(SBBreakpointList self, size_t idx) -> SBBreakpoint"""
        return _lldb.SBBreakpointList_GetBreakpointAtIndex(self, idx)

    def FindBreakpointByID(self, arg2: int) -> "SBBreakpoint":
        r"""FindBreakpointByID(SBBreakpointList self, lldb::break_id_t arg2) -> SBBreakpoint"""
        return _lldb.SBBreakpointList_FindBreakpointByID(self, arg2)

    def Append(self, sb_bkpt: "SBBreakpoint"):
        r"""Append(SBBreakpointList self, SBBreakpoint sb_bkpt)"""
        return _lldb.SBBreakpointList_Append(self, sb_bkpt)

    def AppendIfUnique(self, sb_bkpt: "SBBreakpoint") -> "bool":
        r"""AppendIfUnique(SBBreakpointList self, SBBreakpoint sb_bkpt) -> bool"""
        return _lldb.SBBreakpointList_AppendIfUnique(self, sb_bkpt)

    def AppendByID(self, id: int):
        r"""AppendByID(SBBreakpointList self, lldb::break_id_t id)"""
        return _lldb.SBBreakpointList_AppendByID(self, id)

    def Clear(self):
        r"""Clear(SBBreakpointList self)"""
        return _lldb.SBBreakpointList_Clear(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __len__(self):
        '''Return the number of breakpoints in a lldb.SBBreakpointList object.'''
        return self.GetSize()

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __iter__(self):
        '''Iterate over all breakpoints in a lldb.SBBreakpointList object.'''
        return lldb_iter(self, 'GetSize', 'GetBreakpointAtIndex')


# Register SBBreakpointList in _lldb:
_lldb.SBBreakpointList_swigregister(SBBreakpointList)

class SBBreakpointLocation(object):
    r"""
    Represents one unique instance (by address) of a logical breakpoint.

    A breakpoint location is defined by the breakpoint that produces it,
    and the address that resulted in this particular instantiation.
    Each breakpoint location has its settable options.

    :py:class:`SBBreakpoint` contains SBBreakpointLocation(s). See docstring of SBBreakpoint
    for retrieval of an SBBreakpointLocation from an SBBreakpoint.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBBreakpointLocation self) -> SBBreakpointLocation
        __init__(SBBreakpointLocation self, SBBreakpointLocation rhs) -> SBBreakpointLocation
        """
        _lldb.SBBreakpointLocation_swiginit(self, _lldb.new_SBBreakpointLocation(*args))
    __swig_destroy__ = _lldb.delete_SBBreakpointLocation

    def GetID(self) -> int:
        r"""GetID(SBBreakpointLocation self) -> lldb::break_id_t"""
        return _lldb.SBBreakpointLocation_GetID(self)

    def __nonzero__(self):
        return _lldb.SBBreakpointLocation___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBBreakpointLocation self) -> bool"""
        return _lldb.SBBreakpointLocation_IsValid(self)

    def GetAddress(self) -> "SBAddress":
        r"""GetAddress(SBBreakpointLocation self) -> SBAddress"""
        return _lldb.SBBreakpointLocation_GetAddress(self)

    def GetLoadAddress(self) -> int:
        r"""GetLoadAddress(SBBreakpointLocation self) -> lldb::addr_t"""
        return _lldb.SBBreakpointLocation_GetLoadAddress(self)

    def SetEnabled(self, enabled: "bool"):
        r"""SetEnabled(SBBreakpointLocation self, bool enabled)"""
        return _lldb.SBBreakpointLocation_SetEnabled(self, enabled)

    def IsEnabled(self) -> "bool":
        r"""IsEnabled(SBBreakpointLocation self) -> bool"""
        return _lldb.SBBreakpointLocation_IsEnabled(self)

    def GetHitCount(self) -> int:
        r"""GetHitCount(SBBreakpointLocation self) -> uint32_t"""
        return _lldb.SBBreakpointLocation_GetHitCount(self)

    def GetIgnoreCount(self) -> int:
        r"""GetIgnoreCount(SBBreakpointLocation self) -> uint32_t"""
        return _lldb.SBBreakpointLocation_GetIgnoreCount(self)

    def SetIgnoreCount(self, n: int):
        r"""SetIgnoreCount(SBBreakpointLocation self, uint32_t n)"""
        return _lldb.SBBreakpointLocation_SetIgnoreCount(self, n)

    def SetCondition(self, condition: str):
        r"""
        SetCondition(SBBreakpointLocation self, char const * condition)

            The breakpoint location stops only if the condition expression evaluates
            to true.
        """
        return _lldb.SBBreakpointLocation_SetCondition(self, condition)

    def GetCondition(self) -> str:
        r"""
        GetCondition(SBBreakpointLocation self) -> char const *

            Get the condition expression for the breakpoint location.
        """
        return _lldb.SBBreakpointLocation_GetCondition(self)

    def SetAutoContinue(self, auto_continue: "bool"):
        r"""SetAutoContinue(SBBreakpointLocation self, bool auto_continue)"""
        return _lldb.SBBreakpointLocation_SetAutoContinue(self, auto_continue)

    def GetAutoContinue(self) -> "bool":
        r"""GetAutoContinue(SBBreakpointLocation self) -> bool"""
        return _lldb.SBBreakpointLocation_GetAutoContinue(self)

    def SetScriptCallbackFunction(self, *args) -> "SBError":
        r"""
        SetScriptCallbackFunction(SBBreakpointLocation self, char const * callback_function_name)
        SetScriptCallbackFunction(SBBreakpointLocation self, char const * callback_function_name, SBStructuredData extra_args) -> SBError

            Set the name of the script function to be called when the breakpoint is hit.
            To use this variant, the function should take (frame, bp_loc, extra_args, internal_dict) and
            when the breakpoint is hit the extra_args will be passed to the callback function.
        """
        return _lldb.SBBreakpointLocation_SetScriptCallbackFunction(self, *args)

    def SetScriptCallbackBody(self, script_body_text: str) -> "SBError":
        r"""
        SetScriptCallbackBody(SBBreakpointLocation self, char const * script_body_text) -> SBError

            Provide the body for the script function to be called when the breakpoint location is hit.
            The body will be wrapped in a function, which be passed two arguments:
            'frame' - which holds the bottom-most SBFrame of the thread that hit the breakpoint
            'bpno'  - which is the SBBreakpointLocation to which the callback was attached.

            The error parameter is currently ignored, but will at some point hold the Python
            compilation diagnostics.
            Returns true if the body compiles successfully, false if not.
        """
        return _lldb.SBBreakpointLocation_SetScriptCallbackBody(self, script_body_text)

    def SetCommandLineCommands(self, commands: "SBStringList"):
        r"""SetCommandLineCommands(SBBreakpointLocation self, SBStringList commands)"""
        return _lldb.SBBreakpointLocation_SetCommandLineCommands(self, commands)

    def GetCommandLineCommands(self, commands: "SBStringList") -> "bool":
        r"""GetCommandLineCommands(SBBreakpointLocation self, SBStringList commands) -> bool"""
        return _lldb.SBBreakpointLocation_GetCommandLineCommands(self, commands)

    def SetThreadID(self, sb_thread_id: "lldb::tid_t"):
        r"""SetThreadID(SBBreakpointLocation self, lldb::tid_t sb_thread_id)"""
        return _lldb.SBBreakpointLocation_SetThreadID(self, sb_thread_id)

    def GetThreadID(self) -> "lldb::tid_t":
        r"""GetThreadID(SBBreakpointLocation self) -> lldb::tid_t"""
        return _lldb.SBBreakpointLocation_GetThreadID(self)

    def SetThreadIndex(self, index: int):
        r"""SetThreadIndex(SBBreakpointLocation self, uint32_t index)"""
        return _lldb.SBBreakpointLocation_SetThreadIndex(self, index)

    def GetThreadIndex(self) -> int:
        r"""GetThreadIndex(SBBreakpointLocation self) -> uint32_t"""
        return _lldb.SBBreakpointLocation_GetThreadIndex(self)

    def SetThreadName(self, thread_name: str):
        r"""SetThreadName(SBBreakpointLocation self, char const * thread_name)"""
        return _lldb.SBBreakpointLocation_SetThreadName(self, thread_name)

    def GetThreadName(self) -> str:
        r"""GetThreadName(SBBreakpointLocation self) -> char const *"""
        return _lldb.SBBreakpointLocation_GetThreadName(self)

    def SetQueueName(self, queue_name: str):
        r"""SetQueueName(SBBreakpointLocation self, char const * queue_name)"""
        return _lldb.SBBreakpointLocation_SetQueueName(self, queue_name)

    def GetQueueName(self) -> str:
        r"""GetQueueName(SBBreakpointLocation self) -> char const *"""
        return _lldb.SBBreakpointLocation_GetQueueName(self)

    def IsResolved(self) -> "bool":
        r"""IsResolved(SBBreakpointLocation self) -> bool"""
        return _lldb.SBBreakpointLocation_IsResolved(self)

    def GetDescription(self, description: "SBStream", level: "lldb::DescriptionLevel") -> "bool":
        r"""GetDescription(SBBreakpointLocation self, SBStream description, lldb::DescriptionLevel level) -> bool"""
        return _lldb.SBBreakpointLocation_GetDescription(self, description, level)

    def GetBreakpoint(self) -> "SBBreakpoint":
        r"""GetBreakpoint(SBBreakpointLocation self) -> SBBreakpoint"""
        return _lldb.SBBreakpointLocation_GetBreakpoint(self)

    def __repr__(self) -> str:
        r"""__repr__(SBBreakpointLocation self) -> std::string"""
        return _lldb.SBBreakpointLocation___repr__(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __len__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __iter__(self):
      pass


# Register SBBreakpointLocation in _lldb:
_lldb.SBBreakpointLocation_swigregister(SBBreakpointLocation)

class SBBreakpointName(object):
    r"""
    Represents a breakpoint name registered in a given :py:class:`SBTarget`.

    Breakpoint names provide a way to act on groups of breakpoints.  When you add a
    name to a group of breakpoints, you can then use the name in all the command
    line lldb commands for that name.  You can also configure the SBBreakpointName
    options and those options will be propagated to any :py:class:`SBBreakpoint` s currently
    using that name.  Adding a name to a breakpoint will also apply any of the
    set options to that breakpoint.

    You can also set permissions on a breakpoint name to disable listing, deleting
    and disabling breakpoints.  That will disallow the given operation for breakpoints
    except when the breakpoint is mentioned by ID.  So for instance deleting all the
    breakpoints won't delete breakpoints so marked.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBBreakpointName self) -> SBBreakpointName
        __init__(SBBreakpointName self, SBTarget target, char const * name) -> SBBreakpointName
        __init__(SBBreakpointName self, SBBreakpoint bkpt, char const * name) -> SBBreakpointName
        __init__(SBBreakpointName self, SBBreakpointName rhs) -> SBBreakpointName
        """
        _lldb.SBBreakpointName_swiginit(self, _lldb.new_SBBreakpointName(*args))
    __swig_destroy__ = _lldb.delete_SBBreakpointName

    def __eq__(self, rhs: "SBBreakpointName") -> "bool":
        r"""__eq__(SBBreakpointName self, SBBreakpointName rhs) -> bool"""
        return _lldb.SBBreakpointName___eq__(self, rhs)

    def __ne__(self, rhs: "SBBreakpointName") -> "bool":
        r"""__ne__(SBBreakpointName self, SBBreakpointName rhs) -> bool"""
        return _lldb.SBBreakpointName___ne__(self, rhs)

    def __nonzero__(self):
        return _lldb.SBBreakpointName___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBBreakpointName self) -> bool"""
        return _lldb.SBBreakpointName_IsValid(self)

    def GetName(self) -> str:
        r"""GetName(SBBreakpointName self) -> char const *"""
        return _lldb.SBBreakpointName_GetName(self)

    def SetEnabled(self, enable: "bool"):
        r"""SetEnabled(SBBreakpointName self, bool enable)"""
        return _lldb.SBBreakpointName_SetEnabled(self, enable)

    def IsEnabled(self) -> "bool":
        r"""IsEnabled(SBBreakpointName self) -> bool"""
        return _lldb.SBBreakpointName_IsEnabled(self)

    def SetOneShot(self, one_shot: "bool"):
        r"""SetOneShot(SBBreakpointName self, bool one_shot)"""
        return _lldb.SBBreakpointName_SetOneShot(self, one_shot)

    def IsOneShot(self) -> "bool":
        r"""IsOneShot(SBBreakpointName self) -> bool"""
        return _lldb.SBBreakpointName_IsOneShot(self)

    def SetIgnoreCount(self, count: int):
        r"""SetIgnoreCount(SBBreakpointName self, uint32_t count)"""
        return _lldb.SBBreakpointName_SetIgnoreCount(self, count)

    def GetIgnoreCount(self) -> int:
        r"""GetIgnoreCount(SBBreakpointName self) -> uint32_t"""
        return _lldb.SBBreakpointName_GetIgnoreCount(self)

    def SetCondition(self, condition: str):
        r"""SetCondition(SBBreakpointName self, char const * condition)"""
        return _lldb.SBBreakpointName_SetCondition(self, condition)

    def GetCondition(self) -> str:
        r"""GetCondition(SBBreakpointName self) -> char const *"""
        return _lldb.SBBreakpointName_GetCondition(self)

    def SetAutoContinue(self, auto_continue: "bool"):
        r"""SetAutoContinue(SBBreakpointName self, bool auto_continue)"""
        return _lldb.SBBreakpointName_SetAutoContinue(self, auto_continue)

    def GetAutoContinue(self) -> "bool":
        r"""GetAutoContinue(SBBreakpointName self) -> bool"""
        return _lldb.SBBreakpointName_GetAutoContinue(self)

    def SetThreadID(self, sb_thread_id: "lldb::tid_t"):
        r"""SetThreadID(SBBreakpointName self, lldb::tid_t sb_thread_id)"""
        return _lldb.SBBreakpointName_SetThreadID(self, sb_thread_id)

    def GetThreadID(self) -> "lldb::tid_t":
        r"""GetThreadID(SBBreakpointName self) -> lldb::tid_t"""
        return _lldb.SBBreakpointName_GetThreadID(self)

    def SetThreadIndex(self, index: int):
        r"""SetThreadIndex(SBBreakpointName self, uint32_t index)"""
        return _lldb.SBBreakpointName_SetThreadIndex(self, index)

    def GetThreadIndex(self) -> int:
        r"""GetThreadIndex(SBBreakpointName self) -> uint32_t"""
        return _lldb.SBBreakpointName_GetThreadIndex(self)

    def SetThreadName(self, thread_name: str):
        r"""SetThreadName(SBBreakpointName self, char const * thread_name)"""
        return _lldb.SBBreakpointName_SetThreadName(self, thread_name)

    def GetThreadName(self) -> str:
        r"""GetThreadName(SBBreakpointName self) -> char const *"""
        return _lldb.SBBreakpointName_GetThreadName(self)

    def SetQueueName(self, queue_name: str):
        r"""SetQueueName(SBBreakpointName self, char const * queue_name)"""
        return _lldb.SBBreakpointName_SetQueueName(self, queue_name)

    def GetQueueName(self) -> str:
        r"""GetQueueName(SBBreakpointName self) -> char const *"""
        return _lldb.SBBreakpointName_GetQueueName(self)

    def SetScriptCallbackFunction(self, *args) -> "SBError":
        r"""
        SetScriptCallbackFunction(SBBreakpointName self, char const * callback_function_name)
        SetScriptCallbackFunction(SBBreakpointName self, char const * callback_function_name, SBStructuredData extra_args) -> SBError
        """
        return _lldb.SBBreakpointName_SetScriptCallbackFunction(self, *args)

    def SetCommandLineCommands(self, commands: "SBStringList"):
        r"""SetCommandLineCommands(SBBreakpointName self, SBStringList commands)"""
        return _lldb.SBBreakpointName_SetCommandLineCommands(self, commands)

    def GetCommandLineCommands(self, commands: "SBStringList") -> "bool":
        r"""GetCommandLineCommands(SBBreakpointName self, SBStringList commands) -> bool"""
        return _lldb.SBBreakpointName_GetCommandLineCommands(self, commands)

    def SetScriptCallbackBody(self, script_body_text: str) -> "SBError":
        r"""SetScriptCallbackBody(SBBreakpointName self, char const * script_body_text) -> SBError"""
        return _lldb.SBBreakpointName_SetScriptCallbackBody(self, script_body_text)

    def GetHelpString(self) -> str:
        r"""GetHelpString(SBBreakpointName self) -> char const *"""
        return _lldb.SBBreakpointName_GetHelpString(self)

    def SetHelpString(self, help_string: str):
        r"""SetHelpString(SBBreakpointName self, char const * help_string)"""
        return _lldb.SBBreakpointName_SetHelpString(self, help_string)

    def GetAllowList(self) -> "bool":
        r"""GetAllowList(SBBreakpointName self) -> bool"""
        return _lldb.SBBreakpointName_GetAllowList(self)

    def SetAllowList(self, value: "bool"):
        r"""SetAllowList(SBBreakpointName self, bool value)"""
        return _lldb.SBBreakpointName_SetAllowList(self, value)

    def GetAllowDelete(self) -> "bool":
        r"""GetAllowDelete(SBBreakpointName self) -> bool"""
        return _lldb.SBBreakpointName_GetAllowDelete(self)

    def SetAllowDelete(self, value: "bool"):
        r"""SetAllowDelete(SBBreakpointName self, bool value)"""
        return _lldb.SBBreakpointName_SetAllowDelete(self, value)

    def GetAllowDisable(self) -> "bool":
        r"""GetAllowDisable(SBBreakpointName self) -> bool"""
        return _lldb.SBBreakpointName_GetAllowDisable(self)

    def SetAllowDisable(self, value: "bool"):
        r"""SetAllowDisable(SBBreakpointName self, bool value)"""
        return _lldb.SBBreakpointName_SetAllowDisable(self, value)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBBreakpointName self, SBStream description) -> bool"""
        return _lldb.SBBreakpointName_GetDescription(self, description)

    def __repr__(self) -> str:
        r"""__repr__(SBBreakpointName self) -> std::string"""
        return _lldb.SBBreakpointName___repr__(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __len__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __iter__(self):
      pass


# Register SBBreakpointName in _lldb:
_lldb.SBBreakpointName_swigregister(SBBreakpointName)

class SBBroadcaster(object):
    r"""
    Represents an entity which can broadcast events.

    A default broadcaster is
    associated with an SBCommandInterpreter, SBProcess, and SBTarget.  For
    example, use ::

        broadcaster = process.GetBroadcaster()

    to retrieve the process's broadcaster.

    See also SBEvent for example usage of interacting with a broadcaster.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBBroadcaster self) -> SBBroadcaster
        __init__(SBBroadcaster self, char const * name) -> SBBroadcaster
        __init__(SBBroadcaster self, SBBroadcaster rhs) -> SBBroadcaster
        """
        _lldb.SBBroadcaster_swiginit(self, _lldb.new_SBBroadcaster(*args))
    __swig_destroy__ = _lldb.delete_SBBroadcaster

    def __nonzero__(self):
        return _lldb.SBBroadcaster___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBBroadcaster self) -> bool"""
        return _lldb.SBBroadcaster_IsValid(self)

    def Clear(self):
        r"""Clear(SBBroadcaster self)"""
        return _lldb.SBBroadcaster_Clear(self)

    def BroadcastEventByType(self, event_type: int, unique: "bool"=False):
        r"""BroadcastEventByType(SBBroadcaster self, uint32_t event_type, bool unique=False)"""
        return _lldb.SBBroadcaster_BroadcastEventByType(self, event_type, unique)

    def BroadcastEvent(self, event: "SBEvent", unique: "bool"=False):
        r"""BroadcastEvent(SBBroadcaster self, SBEvent event, bool unique=False)"""
        return _lldb.SBBroadcaster_BroadcastEvent(self, event, unique)

    def AddInitialEventsToListener(self, listener: "SBListener", requested_events: int):
        r"""AddInitialEventsToListener(SBBroadcaster self, SBListener listener, uint32_t requested_events)"""
        return _lldb.SBBroadcaster_AddInitialEventsToListener(self, listener, requested_events)

    def AddListener(self, listener: "SBListener", event_mask: int) -> int:
        r"""AddListener(SBBroadcaster self, SBListener listener, uint32_t event_mask) -> uint32_t"""
        return _lldb.SBBroadcaster_AddListener(self, listener, event_mask)

    def GetName(self) -> str:
        r"""GetName(SBBroadcaster self) -> char const *"""
        return _lldb.SBBroadcaster_GetName(self)

    def EventTypeHasListeners(self, event_type: int) -> "bool":
        r"""EventTypeHasListeners(SBBroadcaster self, uint32_t event_type) -> bool"""
        return _lldb.SBBroadcaster_EventTypeHasListeners(self, event_type)

    def RemoveListener(self, *args) -> "bool":
        r"""RemoveListener(SBBroadcaster self, SBListener listener, uint32_t event_mask=4294967295U) -> bool"""
        return _lldb.SBBroadcaster_RemoveListener(self, *args)

    def __eq__(self, rhs: "SBBroadcaster") -> "bool":
        r"""__eq__(SBBroadcaster self, SBBroadcaster rhs) -> bool"""
        return _lldb.SBBroadcaster___eq__(self, rhs)

    def __ne__(self, rhs: "SBBroadcaster") -> "bool":
        r"""__ne__(SBBroadcaster self, SBBroadcaster rhs) -> bool"""
        return _lldb.SBBroadcaster___ne__(self, rhs)

    def __lt__(self, rhs: "SBBroadcaster") -> "bool":
        r"""__lt__(SBBroadcaster self, SBBroadcaster rhs) -> bool"""
        return _lldb.SBBroadcaster___lt__(self, rhs)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __len__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __iter__(self):
      pass


    def __eq__(self, rhs):
        if not isinstance(rhs, type(self)):
            return False

        return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)

    def __ne__(self, rhs):
        if not isinstance(rhs, type(self)):
            return True

        return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)


# Register SBBroadcaster in _lldb:
_lldb.SBBroadcaster_swigregister(SBBroadcaster)

class SBCommandInterpreter(object):
    r"""
    SBCommandInterpreter handles/interprets commands for lldb.

    You get the command interpreter from the :py:class:`SBDebugger` instance.

    For example (from test/ python_api/interpreter/TestCommandInterpreterAPI.py),::

        def command_interpreter_api(self):
            '''Test the SBCommandInterpreter APIs.'''
            exe = os.path.join(os.getcwd(), 'a.out')

            # Create a target by the debugger.
            target = self.dbg.CreateTarget(exe)
            self.assertTrue(target, VALID_TARGET)

            # Retrieve the associated command interpreter from our debugger.
            ci = self.dbg.GetCommandInterpreter()
            self.assertTrue(ci, VALID_COMMAND_INTERPRETER)

            # Exercise some APIs....

            self.assertTrue(ci.HasCommands())
            self.assertTrue(ci.HasAliases())
            self.assertTrue(ci.HasAliasOptions())
            self.assertTrue(ci.CommandExists('breakpoint'))
            self.assertTrue(ci.CommandExists('target'))
            self.assertTrue(ci.CommandExists('platform'))
            self.assertTrue(ci.AliasExists('file'))
            self.assertTrue(ci.AliasExists('run'))
            self.assertTrue(ci.AliasExists('bt'))

            res = lldb.SBCommandReturnObject()
            ci.HandleCommand('breakpoint set -f main.c -l %d' % self.line, res)
            self.assertTrue(res.Succeeded())
            ci.HandleCommand('process launch', res)
            self.assertTrue(res.Succeeded())

            process = ci.GetProcess()
            self.assertTrue(process)

            ...

    The HandleCommand() instance method takes two args: the command string and
    an SBCommandReturnObject instance which encapsulates the result of command
    execution.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    eBroadcastBitThreadShouldExit = _lldb.SBCommandInterpreter_eBroadcastBitThreadShouldExit

    eBroadcastBitResetPrompt = _lldb.SBCommandInterpreter_eBroadcastBitResetPrompt

    eBroadcastBitQuitCommandReceived = _lldb.SBCommandInterpreter_eBroadcastBitQuitCommandReceived

    eBroadcastBitAsynchronousOutputData = _lldb.SBCommandInterpreter_eBroadcastBitAsynchronousOutputData

    eBroadcastBitAsynchronousErrorData = _lldb.SBCommandInterpreter_eBroadcastBitAsynchronousErrorData


    def __init__(self, rhs: "SBCommandInterpreter"):
        r"""__init__(SBCommandInterpreter self, SBCommandInterpreter rhs) -> SBCommandInterpreter"""
        _lldb.SBCommandInterpreter_swiginit(self, _lldb.new_SBCommandInterpreter(rhs))
    __swig_destroy__ = _lldb.delete_SBCommandInterpreter

    @staticmethod
    def GetArgumentTypeAsCString(arg_type: "lldb::CommandArgumentType const") -> str:
        r"""GetArgumentTypeAsCString(lldb::CommandArgumentType const arg_type) -> char const *"""
        return _lldb.SBCommandInterpreter_GetArgumentTypeAsCString(arg_type)

    @staticmethod
    def GetArgumentDescriptionAsCString(arg_type: "lldb::CommandArgumentType const") -> str:
        r"""GetArgumentDescriptionAsCString(lldb::CommandArgumentType const arg_type) -> char const *"""
        return _lldb.SBCommandInterpreter_GetArgumentDescriptionAsCString(arg_type)

    @staticmethod
    def EventIsCommandInterpreterEvent(event: "SBEvent") -> "bool":
        r"""EventIsCommandInterpreterEvent(SBEvent event) -> bool"""
        return _lldb.SBCommandInterpreter_EventIsCommandInterpreterEvent(event)

    def __nonzero__(self):
        return _lldb.SBCommandInterpreter___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBCommandInterpreter self) -> bool"""
        return _lldb.SBCommandInterpreter_IsValid(self)

    def CommandExists(self, cmd: str) -> "bool":
        r"""CommandExists(SBCommandInterpreter self, char const * cmd) -> bool"""
        return _lldb.SBCommandInterpreter_CommandExists(self, cmd)

    def UserCommandExists(self, cmd: str) -> "bool":
        r"""UserCommandExists(SBCommandInterpreter self, char const * cmd) -> bool"""
        return _lldb.SBCommandInterpreter_UserCommandExists(self, cmd)

    def AliasExists(self, cmd: str) -> "bool":
        r"""AliasExists(SBCommandInterpreter self, char const * cmd) -> bool"""
        return _lldb.SBCommandInterpreter_AliasExists(self, cmd)

    def GetBroadcaster(self) -> "SBBroadcaster":
        r"""GetBroadcaster(SBCommandInterpreter self) -> SBBroadcaster"""
        return _lldb.SBCommandInterpreter_GetBroadcaster(self)

    @staticmethod
    def GetBroadcasterClass() -> str:
        r"""GetBroadcasterClass() -> char const *"""
        return _lldb.SBCommandInterpreter_GetBroadcasterClass()

    def HasCommands(self) -> "bool":
        r"""HasCommands(SBCommandInterpreter self) -> bool"""
        return _lldb.SBCommandInterpreter_HasCommands(self)

    def HasAliases(self) -> "bool":
        r"""HasAliases(SBCommandInterpreter self) -> bool"""
        return _lldb.SBCommandInterpreter_HasAliases(self)

    def HasAliasOptions(self) -> "bool":
        r"""HasAliasOptions(SBCommandInterpreter self) -> bool"""
        return _lldb.SBCommandInterpreter_HasAliasOptions(self)

    def IsInteractive(self) -> "bool":
        r"""IsInteractive(SBCommandInterpreter self) -> bool"""
        return _lldb.SBCommandInterpreter_IsInteractive(self)

    def GetProcess(self) -> "SBProcess":
        r"""GetProcess(SBCommandInterpreter self) -> SBProcess"""
        return _lldb.SBCommandInterpreter_GetProcess(self)

    def GetDebugger(self) -> "SBDebugger":
        r"""GetDebugger(SBCommandInterpreter self) -> SBDebugger"""
        return _lldb.SBCommandInterpreter_GetDebugger(self)

    def SourceInitFileInHomeDirectory(self, *args):
        r"""
        SourceInitFileInHomeDirectory(SBCommandInterpreter self, SBCommandReturnObject result)
        SourceInitFileInHomeDirectory(SBCommandInterpreter self, SBCommandReturnObject result, bool is_repl)
        """
        return _lldb.SBCommandInterpreter_SourceInitFileInHomeDirectory(self, *args)

    def SourceInitFileInCurrentWorkingDirectory(self, result: "SBCommandReturnObject"):
        r"""SourceInitFileInCurrentWorkingDirectory(SBCommandInterpreter self, SBCommandReturnObject result)"""
        return _lldb.SBCommandInterpreter_SourceInitFileInCurrentWorkingDirectory(self, result)

    def HandleCommand(self, *args) -> "lldb::ReturnStatus":
        r"""
        HandleCommand(SBCommandInterpreter self, char const * command_line, SBCommandReturnObject result, bool add_to_history=False) -> lldb::ReturnStatus
        HandleCommand(SBCommandInterpreter self, char const * command_line, SBExecutionContext exe_ctx, SBCommandReturnObject result, bool add_to_history=False) -> lldb::ReturnStatus
        """
        return _lldb.SBCommandInterpreter_HandleCommand(self, *args)

    def HandleCommandsFromFile(self, file: "SBFileSpec", override_context: "SBExecutionContext", options: "SBCommandInterpreterRunOptions", result: "SBCommandReturnObject"):
        r"""HandleCommandsFromFile(SBCommandInterpreter self, SBFileSpec file, SBExecutionContext override_context, SBCommandInterpreterRunOptions options, SBCommandReturnObject result)"""
        return _lldb.SBCommandInterpreter_HandleCommandsFromFile(self, file, override_context, options, result)

    def HandleCompletion(self, current_line: str, cursor_pos: int, match_start_point: "int", max_return_elements: "int", matches: "SBStringList") -> "int":
        r"""HandleCompletion(SBCommandInterpreter self, char const * current_line, uint32_t cursor_pos, int match_start_point, int max_return_elements, SBStringList matches) -> int"""
        return _lldb.SBCommandInterpreter_HandleCompletion(self, current_line, cursor_pos, match_start_point, max_return_elements, matches)

    def HandleCompletionWithDescriptions(self, current_line: str, cursor_pos: int, match_start_point: "int", max_return_elements: "int", matches: "SBStringList", descriptions: "SBStringList") -> "int":
        r"""HandleCompletionWithDescriptions(SBCommandInterpreter self, char const * current_line, uint32_t cursor_pos, int match_start_point, int max_return_elements, SBStringList matches, SBStringList descriptions) -> int"""
        return _lldb.SBCommandInterpreter_HandleCompletionWithDescriptions(self, current_line, cursor_pos, match_start_point, max_return_elements, matches, descriptions)

    def WasInterrupted(self) -> "bool":
        r"""WasInterrupted(SBCommandInterpreter self) -> bool"""
        return _lldb.SBCommandInterpreter_WasInterrupted(self)

    def InterruptCommand(self) -> "bool":
        r"""InterruptCommand(SBCommandInterpreter self) -> bool"""
        return _lldb.SBCommandInterpreter_InterruptCommand(self)

    def IsActive(self) -> "bool":
        r"""IsActive(SBCommandInterpreter self) -> bool"""
        return _lldb.SBCommandInterpreter_IsActive(self)

    def GetIOHandlerControlSequence(self, ch: "char") -> str:
        r"""GetIOHandlerControlSequence(SBCommandInterpreter self, char ch) -> char const *"""
        return _lldb.SBCommandInterpreter_GetIOHandlerControlSequence(self, ch)

    def GetPromptOnQuit(self) -> "bool":
        r"""GetPromptOnQuit(SBCommandInterpreter self) -> bool"""
        return _lldb.SBCommandInterpreter_GetPromptOnQuit(self)

    def SetPromptOnQuit(self, b: "bool"):
        r"""SetPromptOnQuit(SBCommandInterpreter self, bool b)"""
        return _lldb.SBCommandInterpreter_SetPromptOnQuit(self, b)

    def AllowExitCodeOnQuit(self, allow: "bool"):
        r"""AllowExitCodeOnQuit(SBCommandInterpreter self, bool allow)"""
        return _lldb.SBCommandInterpreter_AllowExitCodeOnQuit(self, allow)

    def HasCustomQuitExitCode(self) -> "bool":
        r"""HasCustomQuitExitCode(SBCommandInterpreter self) -> bool"""
        return _lldb.SBCommandInterpreter_HasCustomQuitExitCode(self)

    def GetQuitStatus(self) -> "int":
        r"""GetQuitStatus(SBCommandInterpreter self) -> int"""
        return _lldb.SBCommandInterpreter_GetQuitStatus(self)

    def ResolveCommand(self, command_line: str, result: "SBCommandReturnObject"):
        r"""ResolveCommand(SBCommandInterpreter self, char const * command_line, SBCommandReturnObject result)"""
        return _lldb.SBCommandInterpreter_ResolveCommand(self, command_line, result)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __len__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __iter__(self):
      pass


# Register SBCommandInterpreter in _lldb:
_lldb.SBCommandInterpreter_swigregister(SBCommandInterpreter)

def SBCommandInterpreter_GetArgumentTypeAsCString(arg_type: "lldb::CommandArgumentType const") -> str:
    r"""SBCommandInterpreter_GetArgumentTypeAsCString(lldb::CommandArgumentType const arg_type) -> char const *"""
    return _lldb.SBCommandInterpreter_GetArgumentTypeAsCString(arg_type)

def SBCommandInterpreter_GetArgumentDescriptionAsCString(arg_type: "lldb::CommandArgumentType const") -> str:
    r"""SBCommandInterpreter_GetArgumentDescriptionAsCString(lldb::CommandArgumentType const arg_type) -> char const *"""
    return _lldb.SBCommandInterpreter_GetArgumentDescriptionAsCString(arg_type)

def SBCommandInterpreter_EventIsCommandInterpreterEvent(event: "SBEvent") -> "bool":
    r"""SBCommandInterpreter_EventIsCommandInterpreterEvent(SBEvent event) -> bool"""
    return _lldb.SBCommandInterpreter_EventIsCommandInterpreterEvent(event)

def SBCommandInterpreter_GetBroadcasterClass() -> str:
    r"""SBCommandInterpreter_GetBroadcasterClass() -> char const *"""
    return _lldb.SBCommandInterpreter_GetBroadcasterClass()

class SBCommandInterpreterRunOptions(object):
    r"""
    SBCommandInterpreterRunOptions controls how the RunCommandInterpreter runs the code it is fed.

    A default SBCommandInterpreterRunOptions object has:

    * StopOnContinue: false
    * StopOnError:    false
    * StopOnCrash:    false
    * EchoCommands:   true
    * PrintResults:   true
    * PrintErrors:    true
    * AddToHistory:   true


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBCommandInterpreterRunOptions self) -> SBCommandInterpreterRunOptions
        __init__(SBCommandInterpreterRunOptions self, SBCommandInterpreterRunOptions rhs) -> SBCommandInterpreterRunOptions
        """
        _lldb.SBCommandInterpreterRunOptions_swiginit(self, _lldb.new_SBCommandInterpreterRunOptions(*args))
    __swig_destroy__ = _lldb.delete_SBCommandInterpreterRunOptions

    def GetStopOnContinue(self) -> "bool":
        r"""GetStopOnContinue(SBCommandInterpreterRunOptions self) -> bool"""
        return _lldb.SBCommandInterpreterRunOptions_GetStopOnContinue(self)

    def SetStopOnContinue(self, arg2: "bool"):
        r"""SetStopOnContinue(SBCommandInterpreterRunOptions self, bool arg2)"""
        return _lldb.SBCommandInterpreterRunOptions_SetStopOnContinue(self, arg2)

    def GetStopOnError(self) -> "bool":
        r"""GetStopOnError(SBCommandInterpreterRunOptions self) -> bool"""
        return _lldb.SBCommandInterpreterRunOptions_GetStopOnError(self)

    def SetStopOnError(self, arg2: "bool"):
        r"""SetStopOnError(SBCommandInterpreterRunOptions self, bool arg2)"""
        return _lldb.SBCommandInterpreterRunOptions_SetStopOnError(self, arg2)

    def GetStopOnCrash(self) -> "bool":
        r"""GetStopOnCrash(SBCommandInterpreterRunOptions self) -> bool"""
        return _lldb.SBCommandInterpreterRunOptions_GetStopOnCrash(self)

    def SetStopOnCrash(self, arg2: "bool"):
        r"""SetStopOnCrash(SBCommandInterpreterRunOptions self, bool arg2)"""
        return _lldb.SBCommandInterpreterRunOptions_SetStopOnCrash(self, arg2)

    def GetEchoCommands(self) -> "bool":
        r"""GetEchoCommands(SBCommandInterpreterRunOptions self) -> bool"""
        return _lldb.SBCommandInterpreterRunOptions_GetEchoCommands(self)

    def SetEchoCommands(self, arg2: "bool"):
        r"""SetEchoCommands(SBCommandInterpreterRunOptions self, bool arg2)"""
        return _lldb.SBCommandInterpreterRunOptions_SetEchoCommands(self, arg2)

    def GetEchoCommentCommands(self) -> "bool":
        r"""GetEchoCommentCommands(SBCommandInterpreterRunOptions self) -> bool"""
        return _lldb.SBCommandInterpreterRunOptions_GetEchoCommentCommands(self)

    def SetEchoCommentCommands(self, echo: "bool"):
        r"""SetEchoCommentCommands(SBCommandInterpreterRunOptions self, bool echo)"""
        return _lldb.SBCommandInterpreterRunOptions_SetEchoCommentCommands(self, echo)

    def GetPrintResults(self) -> "bool":
        r"""GetPrintResults(SBCommandInterpreterRunOptions self) -> bool"""
        return _lldb.SBCommandInterpreterRunOptions_GetPrintResults(self)

    def SetPrintResults(self, arg2: "bool"):
        r"""SetPrintResults(SBCommandInterpreterRunOptions self, bool arg2)"""
        return _lldb.SBCommandInterpreterRunOptions_SetPrintResults(self, arg2)

    def GetPrintErrors(self) -> "bool":
        r"""GetPrintErrors(SBCommandInterpreterRunOptions self) -> bool"""
        return _lldb.SBCommandInterpreterRunOptions_GetPrintErrors(self)

    def SetPrintErrors(self, arg2: "bool"):
        r"""SetPrintErrors(SBCommandInterpreterRunOptions self, bool arg2)"""
        return _lldb.SBCommandInterpreterRunOptions_SetPrintErrors(self, arg2)

    def GetAddToHistory(self) -> "bool":
        r"""GetAddToHistory(SBCommandInterpreterRunOptions self) -> bool"""
        return _lldb.SBCommandInterpreterRunOptions_GetAddToHistory(self)

    def SetAddToHistory(self, arg2: "bool"):
        r"""SetAddToHistory(SBCommandInterpreterRunOptions self, bool arg2)"""
        return _lldb.SBCommandInterpreterRunOptions_SetAddToHistory(self, arg2)

    def GetAutoHandleEvents(self) -> "bool":
        r"""GetAutoHandleEvents(SBCommandInterpreterRunOptions self) -> bool"""
        return _lldb.SBCommandInterpreterRunOptions_GetAutoHandleEvents(self)

    def SetAutoHandleEvents(self, arg2: "bool"):
        r"""SetAutoHandleEvents(SBCommandInterpreterRunOptions self, bool arg2)"""
        return _lldb.SBCommandInterpreterRunOptions_SetAutoHandleEvents(self, arg2)

    def GetSpawnThread(self) -> "bool":
        r"""GetSpawnThread(SBCommandInterpreterRunOptions self) -> bool"""
        return _lldb.SBCommandInterpreterRunOptions_GetSpawnThread(self)

    def SetSpawnThread(self, arg2: "bool"):
        r"""SetSpawnThread(SBCommandInterpreterRunOptions self, bool arg2)"""
        return _lldb.SBCommandInterpreterRunOptions_SetSpawnThread(self, arg2)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __len__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __iter__(self):
      pass


# Register SBCommandInterpreterRunOptions in _lldb:
_lldb.SBCommandInterpreterRunOptions_swigregister(SBCommandInterpreterRunOptions)

class SBCommandReturnObject(object):
    r"""
    Represents a container which holds the result from command execution.
    It works with :py:class:`SBCommandInterpreter.HandleCommand()` to encapsulate the result
    of command execution.

    See :py:class:`SBCommandInterpreter` for example usage of SBCommandReturnObject.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBCommandReturnObject self) -> SBCommandReturnObject
        __init__(SBCommandReturnObject self, SBCommandReturnObject rhs) -> SBCommandReturnObject
        """
        _lldb.SBCommandReturnObject_swiginit(self, _lldb.new_SBCommandReturnObject(*args))
    __swig_destroy__ = _lldb.delete_SBCommandReturnObject

    def __nonzero__(self):
        return _lldb.SBCommandReturnObject___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBCommandReturnObject self) -> bool"""
        return _lldb.SBCommandReturnObject_IsValid(self)

    def PutOutput(self, *args) -> "size_t":
        r"""
        PutOutput(SBCommandReturnObject self, SBFile file) -> size_t
        PutOutput(SBCommandReturnObject self, lldb::FileSP BORROWED) -> size_t
        """
        return _lldb.SBCommandReturnObject_PutOutput(self, *args)

    def GetOutputSize(self) -> "size_t":
        r"""GetOutputSize(SBCommandReturnObject self) -> size_t"""
        return _lldb.SBCommandReturnObject_GetOutputSize(self)

    def GetErrorSize(self) -> "size_t":
        r"""GetErrorSize(SBCommandReturnObject self) -> size_t"""
        return _lldb.SBCommandReturnObject_GetErrorSize(self)

    def PutError(self, *args) -> "size_t":
        r"""
        PutError(SBCommandReturnObject self, SBFile file) -> size_t
        PutError(SBCommandReturnObject self, lldb::FileSP BORROWED) -> size_t
        """
        return _lldb.SBCommandReturnObject_PutError(self, *args)

    def Clear(self):
        r"""Clear(SBCommandReturnObject self)"""
        return _lldb.SBCommandReturnObject_Clear(self)

    def GetStatus(self) -> "lldb::ReturnStatus":
        r"""GetStatus(SBCommandReturnObject self) -> lldb::ReturnStatus"""
        return _lldb.SBCommandReturnObject_GetStatus(self)

    def SetStatus(self, status: "lldb::ReturnStatus"):
        r"""SetStatus(SBCommandReturnObject self, lldb::ReturnStatus status)"""
        return _lldb.SBCommandReturnObject_SetStatus(self, status)

    def Succeeded(self) -> "bool":
        r"""Succeeded(SBCommandReturnObject self) -> bool"""
        return _lldb.SBCommandReturnObject_Succeeded(self)

    def HasResult(self) -> "bool":
        r"""HasResult(SBCommandReturnObject self) -> bool"""
        return _lldb.SBCommandReturnObject_HasResult(self)

    def AppendMessage(self, message: str):
        r"""AppendMessage(SBCommandReturnObject self, char const * message)"""
        return _lldb.SBCommandReturnObject_AppendMessage(self, message)

    def AppendWarning(self, message: str):
        r"""AppendWarning(SBCommandReturnObject self, char const * message)"""
        return _lldb.SBCommandReturnObject_AppendWarning(self, message)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBCommandReturnObject self, SBStream description) -> bool"""
        return _lldb.SBCommandReturnObject_GetDescription(self, description)

    def PutCString(self, string: str):
        r"""PutCString(SBCommandReturnObject self, char const * string)"""
        return _lldb.SBCommandReturnObject_PutCString(self, string)

    def GetOutput(self, *args) -> str:
        r"""
        GetOutput(SBCommandReturnObject self) -> char const
        GetOutput(SBCommandReturnObject self, bool only_if_no_immediate) -> char const *
        """
        return _lldb.SBCommandReturnObject_GetOutput(self, *args)

    def GetError(self, *args) -> str:
        r"""
        GetError(SBCommandReturnObject self) -> char const
        GetError(SBCommandReturnObject self, bool only_if_no_immediate) -> char const *
        """
        return _lldb.SBCommandReturnObject_GetError(self, *args)

    def SetError(self, *args):
        r"""
        SetError(SBCommandReturnObject self, SBError error, char const * fallback_error_cstr=None)
        SetError(SBCommandReturnObject self, char const * error_cstr)
        """
        return _lldb.SBCommandReturnObject_SetError(self, *args)

    def __repr__(self) -> str:
        r"""__repr__(SBCommandReturnObject self) -> std::string"""
        return _lldb.SBCommandReturnObject___repr__(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __len__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __iter__(self):
      pass


    def SetImmediateOutputFile(self, *args):
        r"""
        SetImmediateOutputFile(SBCommandReturnObject self, SBFile file)
        SetImmediateOutputFile(SBCommandReturnObject self, lldb::FileSP BORROWED)
        SetImmediateOutputFile(SBCommandReturnObject self, lldb::FileSP BORROWED, bool transfer_ownership)
        """
        return _lldb.SBCommandReturnObject_SetImmediateOutputFile(self, *args)

    def SetImmediateErrorFile(self, *args):
        r"""
        SetImmediateErrorFile(SBCommandReturnObject self, SBFile file)
        SetImmediateErrorFile(SBCommandReturnObject self, lldb::FileSP BORROWED)
        SetImmediateErrorFile(SBCommandReturnObject self, lldb::FileSP BORROWED, bool transfer_ownership)
        """
        return _lldb.SBCommandReturnObject_SetImmediateErrorFile(self, *args)

    def Print(self, str: str):
        r"""Print(SBCommandReturnObject self, char const * str)"""
        return _lldb.SBCommandReturnObject_Print(self, str)

    def write(self, str: str):
        r"""write(SBCommandReturnObject self, char const * str)"""
        return _lldb.SBCommandReturnObject_write(self, str)

    def flush(self):
        r"""flush(SBCommandReturnObject self)"""
        return _lldb.SBCommandReturnObject_flush(self)

# Register SBCommandReturnObject in _lldb:
_lldb.SBCommandReturnObject_swigregister(SBCommandReturnObject)

class SBCommunication(object):
    r"""Allows sending/receiving data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    eBroadcastBitDisconnected = _lldb.SBCommunication_eBroadcastBitDisconnected

    eBroadcastBitReadThreadGotBytes = _lldb.SBCommunication_eBroadcastBitReadThreadGotBytes

    eBroadcastBitReadThreadDidExit = _lldb.SBCommunication_eBroadcastBitReadThreadDidExit

    eBroadcastBitReadThreadShouldExit = _lldb.SBCommunication_eBroadcastBitReadThreadShouldExit

    eBroadcastBitPacketAvailable = _lldb.SBCommunication_eBroadcastBitPacketAvailable

    eAllEventBits = _lldb.SBCommunication_eAllEventBits


    def __init__(self, *args):
        r"""
        __init__(SBCommunication self) -> SBCommunication
        __init__(SBCommunication self, char const * broadcaster_name) -> SBCommunication
        """
        _lldb.SBCommunication_swiginit(self, _lldb.new_SBCommunication(*args))
    __swig_destroy__ = _lldb.delete_SBCommunication

    def __nonzero__(self):
        return _lldb.SBCommunication___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBCommunication self) -> bool"""
        return _lldb.SBCommunication_IsValid(self)

    def GetBroadcaster(self) -> "SBBroadcaster":
        r"""GetBroadcaster(SBCommunication self) -> SBBroadcaster"""
        return _lldb.SBCommunication_GetBroadcaster(self)

    @staticmethod
    def GetBroadcasterClass() -> str:
        r"""GetBroadcasterClass() -> char const *"""
        return _lldb.SBCommunication_GetBroadcasterClass()

    def AdoptFileDesriptor(self, fd: "int", owns_fd: "bool") -> "lldb::ConnectionStatus":
        r"""AdoptFileDesriptor(SBCommunication self, int fd, bool owns_fd) -> lldb::ConnectionStatus"""
        return _lldb.SBCommunication_AdoptFileDesriptor(self, fd, owns_fd)

    def Connect(self, url: str) -> "lldb::ConnectionStatus":
        r"""Connect(SBCommunication self, char const * url) -> lldb::ConnectionStatus"""
        return _lldb.SBCommunication_Connect(self, url)

    def Disconnect(self) -> "lldb::ConnectionStatus":
        r"""Disconnect(SBCommunication self) -> lldb::ConnectionStatus"""
        return _lldb.SBCommunication_Disconnect(self)

    def IsConnected(self) -> "bool":
        r"""IsConnected(SBCommunication self) -> bool"""
        return _lldb.SBCommunication_IsConnected(self)

    def GetCloseOnEOF(self) -> "bool":
        r"""GetCloseOnEOF(SBCommunication self) -> bool"""
        return _lldb.SBCommunication_GetCloseOnEOF(self)

    def SetCloseOnEOF(self, b: "bool"):
        r"""SetCloseOnEOF(SBCommunication self, bool b)"""
        return _lldb.SBCommunication_SetCloseOnEOF(self, b)

    def Read(self, dst: "void *", dst_len: "size_t", timeout_usec: int, status: "lldb::ConnectionStatus &") -> "size_t":
        r"""Read(SBCommunication self, void * dst, size_t dst_len, uint32_t timeout_usec, lldb::ConnectionStatus & status) -> size_t"""
        return _lldb.SBCommunication_Read(self, dst, dst_len, timeout_usec, status)

    def Write(self, src: "void const *", src_len: "size_t", status: "lldb::ConnectionStatus &") -> "size_t":
        r"""Write(SBCommunication self, void const * src, size_t src_len, lldb::ConnectionStatus & status) -> size_t"""
        return _lldb.SBCommunication_Write(self, src, src_len, status)

    def ReadThreadStart(self) -> "bool":
        r"""ReadThreadStart(SBCommunication self) -> bool"""
        return _lldb.SBCommunication_ReadThreadStart(self)

    def ReadThreadStop(self) -> "bool":
        r"""ReadThreadStop(SBCommunication self) -> bool"""
        return _lldb.SBCommunication_ReadThreadStop(self)

    def ReadThreadIsRunning(self) -> "bool":
        r"""ReadThreadIsRunning(SBCommunication self) -> bool"""
        return _lldb.SBCommunication_ReadThreadIsRunning(self)

    def SetReadThreadBytesReceivedCallback(self, callback: "SBCommunication::ReadThreadBytesReceived", callback_baton: "void *") -> "bool":
        r"""SetReadThreadBytesReceivedCallback(SBCommunication self, lldb::SBCommunication::ReadThreadBytesReceived callback, void * callback_baton) -> bool"""
        return _lldb.SBCommunication_SetReadThreadBytesReceivedCallback(self, callback, callback_baton)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __len__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __iter__(self):
      pass


# Register SBCommunication in _lldb:
_lldb.SBCommunication_swigregister(SBCommunication)

def SBCommunication_GetBroadcasterClass() -> str:
    r"""SBCommunication_GetBroadcasterClass() -> char const *"""
    return _lldb.SBCommunication_GetBroadcasterClass()

class SBCompileUnit(object):
    r"""
    Represents a compilation unit, or compiled source file.

    SBCompileUnit supports line entry iteration. For example,::

        # Now get the SBSymbolContext from this frame.  We want everything. :-)
        context = frame0.GetSymbolContext(lldb.eSymbolContextEverything)
        ...

        compileUnit = context.GetCompileUnit()

        for lineEntry in compileUnit:
            print('line entry: %s:%d' % (str(lineEntry.GetFileSpec()),
                                        lineEntry.GetLine()))
            print('start addr: %s' % str(lineEntry.GetStartAddress()))
            print('end   addr: %s' % str(lineEntry.GetEndAddress()))

    produces: ::

      line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:20
      start addr: a.out[0x100000d98]
      end   addr: a.out[0x100000da3]
      line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:21
      start addr: a.out[0x100000da3]
      end   addr: a.out[0x100000da9]
      line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:22
      start addr: a.out[0x100000da9]
      end   addr: a.out[0x100000db6]
      line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:23
      start addr: a.out[0x100000db6]
      end   addr: a.out[0x100000dbc]
      ...

    See also :py:class:`SBSymbolContext` and :py:class:`SBLineEntry`
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBCompileUnit self) -> SBCompileUnit
        __init__(SBCompileUnit self, SBCompileUnit rhs) -> SBCompileUnit
        """
        _lldb.SBCompileUnit_swiginit(self, _lldb.new_SBCompileUnit(*args))
    __swig_destroy__ = _lldb.delete_SBCompileUnit

    def __nonzero__(self):
        return _lldb.SBCompileUnit___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBCompileUnit self) -> bool"""
        return _lldb.SBCompileUnit_IsValid(self)

    def GetFileSpec(self) -> "SBFileSpec":
        r"""GetFileSpec(SBCompileUnit self) -> SBFileSpec"""
        return _lldb.SBCompileUnit_GetFileSpec(self)

    def GetNumLineEntries(self) -> int:
        r"""GetNumLineEntries(SBCompileUnit self) -> uint32_t"""
        return _lldb.SBCompileUnit_GetNumLineEntries(self)

    def GetLineEntryAtIndex(self, idx: int) -> "SBLineEntry":
        r"""GetLineEntryAtIndex(SBCompileUnit self, uint32_t idx) -> SBLineEntry"""
        return _lldb.SBCompileUnit_GetLineEntryAtIndex(self, idx)

    def FindLineEntryIndex(self, *args) -> int:
        r"""
        FindLineEntryIndex(SBCompileUnit self, SBLineEntry line_entry, bool exact=False) -> uint32_t
        FindLineEntryIndex(SBCompileUnit self, uint32_t start_idx, uint32_t line, SBFileSpec inline_file_spec) -> uint32_t
        FindLineEntryIndex(SBCompileUnit self, uint32_t start_idx, uint32_t line, SBFileSpec inline_file_spec, bool exact) -> uint32_t

             Get the index for a provided line entry in this compile unit.

             @param[in] line_entry
                The SBLineEntry object for which we are looking for the index.

             @param[in] exact
                An optional boolean defaulting to false that ensures that the provided
                line entry has a perfect match in the compile unit.

             @return
                The index of the user-provided line entry. UINT32_MAX if the line entry
                was not found in the compile unit.
        """
        return _lldb.SBCompileUnit_FindLineEntryIndex(self, *args)

    def GetSupportFileAtIndex(self, idx: int) -> "SBFileSpec":
        r"""GetSupportFileAtIndex(SBCompileUnit self, uint32_t idx) -> SBFileSpec"""
        return _lldb.SBCompileUnit_GetSupportFileAtIndex(self, idx)

    def GetNumSupportFiles(self) -> int:
        r"""GetNumSupportFiles(SBCompileUnit self) -> uint32_t"""
        return _lldb.SBCompileUnit_GetNumSupportFiles(self)

    def FindSupportFileIndex(self, start_idx: int, sb_file: "SBFileSpec", full: "bool") -> int:
        r"""FindSupportFileIndex(SBCompileUnit self, uint32_t start_idx, SBFileSpec sb_file, bool full) -> uint32_t"""
        return _lldb.SBCompileUnit_FindSupportFileIndex(self, start_idx, sb_file, full)

    def GetTypes(self, *args) -> "SBTypeList":
        r"""
        GetTypes(SBCompileUnit self, uint32_t type_mask=eTypeClassAny) -> SBTypeList

             Get all types matching type_mask from debug info in this
             compile unit.

             @param[in] type_mask
                A bitfield that consists of one or more bits logically OR'ed
                together from the lldb::TypeClass enumeration. This allows
                you to request only structure types, or only class, struct
                and union types. Passing in lldb::eTypeClassAny will return
                all types found in the debug information for this compile
                unit.

             @return
                A list of types in this compile unit that match type_mask
        """
        return _lldb.SBCompileUnit_GetTypes(self, *args)

    def GetLanguage(self) -> "lldb::LanguageType":
        r"""GetLanguage(SBCompileUnit self) -> lldb::LanguageType"""
        return _lldb.SBCompileUnit_GetLanguage(self)

    def __eq__(self, rhs: "SBCompileUnit") -> "bool":
        r"""__eq__(SBCompileUnit self, SBCompileUnit rhs) -> bool"""
        return _lldb.SBCompileUnit___eq__(self, rhs)

    def __ne__(self, rhs: "SBCompileUnit") -> "bool":
        r"""__ne__(SBCompileUnit self, SBCompileUnit rhs) -> bool"""
        return _lldb.SBCompileUnit___ne__(self, rhs)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBCompileUnit self, SBStream description) -> bool"""
        return _lldb.SBCompileUnit_GetDescription(self, description)

    def __repr__(self) -> str:
        r"""__repr__(SBCompileUnit self) -> std::string"""
        return _lldb.SBCompileUnit___repr__(self)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __iter__(self):
        '''Iterate over all line entries in a lldb.SBCompileUnit object.'''
        return lldb_iter(self, 'GetNumLineEntries', 'GetLineEntryAtIndex')

    def __len__(self):
        '''Return the number of line entries in a lldb.SBCompileUnit
        object.'''
        return self.GetNumLineEntries()

    file = property(GetFileSpec, None, doc='''A read only property that returns the same result an lldb object that represents the source file (lldb.SBFileSpec) for the compile unit.''')
    num_line_entries = property(GetNumLineEntries, None, doc='''A read only property that returns the number of line entries in a compile unit as an integer.''')


    def __eq__(self, rhs):
        if not isinstance(rhs, type(self)):
            return False

        return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)

    def __ne__(self, rhs):
        if not isinstance(rhs, type(self)):
            return True

        return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)


# Register SBCompileUnit in _lldb:
_lldb.SBCompileUnit_swigregister(SBCompileUnit)

class SBData(object):
    r"""Represents a data buffer."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBData self) -> SBData
        __init__(SBData self, SBData rhs) -> SBData
        """
        _lldb.SBData_swiginit(self, _lldb.new_SBData(*args))
    __swig_destroy__ = _lldb.delete_SBData

    def GetAddressByteSize(self) -> "uint8_t":
        r"""GetAddressByteSize(SBData self) -> uint8_t"""
        return _lldb.SBData_GetAddressByteSize(self)

    def SetAddressByteSize(self, addr_byte_size: "uint8_t"):
        r"""SetAddressByteSize(SBData self, uint8_t addr_byte_size)"""
        return _lldb.SBData_SetAddressByteSize(self, addr_byte_size)

    def Clear(self):
        r"""Clear(SBData self)"""
        return _lldb.SBData_Clear(self)

    def __nonzero__(self):
        return _lldb.SBData___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBData self) -> bool"""
        return _lldb.SBData_IsValid(self)

    def GetByteSize(self) -> "size_t":
        r"""GetByteSize(SBData self) -> size_t"""
        return _lldb.SBData_GetByteSize(self)

    def GetByteOrder(self) -> "lldb::ByteOrder":
        r"""GetByteOrder(SBData self) -> lldb::ByteOrder"""
        return _lldb.SBData_GetByteOrder(self)

    def SetByteOrder(self, endian: "lldb::ByteOrder"):
        r"""SetByteOrder(SBData self, lldb::ByteOrder endian)"""
        return _lldb.SBData_SetByteOrder(self, endian)

    def GetFloat(self, error: "SBError", offset: "lldb::offset_t") -> "float":
        r"""GetFloat(SBData self, SBError error, lldb::offset_t offset) -> float"""
        return _lldb.SBData_GetFloat(self, error, offset)

    def GetDouble(self, error: "SBError", offset: "lldb::offset_t") -> "double":
        r"""GetDouble(SBData self, SBError error, lldb::offset_t offset) -> double"""
        return _lldb.SBData_GetDouble(self, error, offset)

    def GetLongDouble(self, error: "SBError", offset: "lldb::offset_t") -> "long double":
        r"""GetLongDouble(SBData self, SBError error, lldb::offset_t offset) -> long double"""
        return _lldb.SBData_GetLongDouble(self, error, offset)

    def GetAddress(self, error: "SBError", offset: "lldb::offset_t") -> int:
        r"""GetAddress(SBData self, SBError error, lldb::offset_t offset) -> lldb::addr_t"""
        return _lldb.SBData_GetAddress(self, error, offset)

    def GetUnsignedInt8(self, error: "SBError", offset: "lldb::offset_t") -> "uint8_t":
        r"""GetUnsignedInt8(SBData self, SBError error, lldb::offset_t offset) -> uint8_t"""
        return _lldb.SBData_GetUnsignedInt8(self, error, offset)

    def GetUnsignedInt16(self, error: "SBError", offset: "lldb::offset_t") -> "uint16_t":
        r"""GetUnsignedInt16(SBData self, SBError error, lldb::offset_t offset) -> uint16_t"""
        return _lldb.SBData_GetUnsignedInt16(self, error, offset)

    def GetUnsignedInt32(self, error: "SBError", offset: "lldb::offset_t") -> int:
        r"""GetUnsignedInt32(SBData self, SBError error, lldb::offset_t offset) -> uint32_t"""
        return _lldb.SBData_GetUnsignedInt32(self, error, offset)

    def GetUnsignedInt64(self, error: "SBError", offset: "lldb::offset_t") -> int:
        r"""GetUnsignedInt64(SBData self, SBError error, lldb::offset_t offset) -> uint64_t"""
        return _lldb.SBData_GetUnsignedInt64(self, error, offset)

    def GetSignedInt8(self, error: "SBError", offset: "lldb::offset_t") -> "int8_t":
        r"""GetSignedInt8(SBData self, SBError error, lldb::offset_t offset) -> int8_t"""
        return _lldb.SBData_GetSignedInt8(self, error, offset)

    def GetSignedInt16(self, error: "SBError", offset: "lldb::offset_t") -> "int16_t":
        r"""GetSignedInt16(SBData self, SBError error, lldb::offset_t offset) -> int16_t"""
        return _lldb.SBData_GetSignedInt16(self, error, offset)

    def GetSignedInt32(self, error: "SBError", offset: "lldb::offset_t") -> "int32_t":
        r"""GetSignedInt32(SBData self, SBError error, lldb::offset_t offset) -> int32_t"""
        return _lldb.SBData_GetSignedInt32(self, error, offset)

    def GetSignedInt64(self, error: "SBError", offset: "lldb::offset_t") -> "int64_t":
        r"""GetSignedInt64(SBData self, SBError error, lldb::offset_t offset) -> int64_t"""
        return _lldb.SBData_GetSignedInt64(self, error, offset)

    def GetString(self, error: "SBError", offset: "lldb::offset_t") -> str:
        r"""GetString(SBData self, SBError error, lldb::offset_t offset) -> char const *"""
        return _lldb.SBData_GetString(self, error, offset)

    def ReadRawData(self, error: "SBError", offset: "lldb::offset_t", buf: "void *") -> "size_t":
        r"""ReadRawData(SBData self, SBError error, lldb::offset_t offset, void * buf) -> size_t"""
        return _lldb.SBData_ReadRawData(self, error, offset, buf)

    def GetDescription(self, *args) -> "bool":
        r"""GetDescription(SBData self, SBStream description, lldb::addr_t base_addr=18446744073709551615ULL) -> bool"""
        return _lldb.SBData_GetDescription(self, *args)

    def SetData(self, error: "SBError", buf: "void const *", endian: "lldb::ByteOrder", addr_size: "uint8_t"):
        r"""SetData(SBData self, SBError error, void const * buf, lldb::ByteOrder endian, uint8_t addr_size)"""
        return _lldb.SBData_SetData(self, error, buf, endian, addr_size)

    def SetDataWithOwnership(self, error: "SBError", buf: "void const *", endian: "lldb::ByteOrder", addr_size: "uint8_t"):
        r"""SetDataWithOwnership(SBData self, SBError error, void const * buf, lldb::ByteOrder endian, uint8_t addr_size)"""
        return _lldb.SBData_SetDataWithOwnership(self, error, buf, endian, addr_size)

    def Append(self, rhs: "SBData") -> "bool":
        r"""Append(SBData self, SBData rhs) -> bool"""
        return _lldb.SBData_Append(self, rhs)

    @staticmethod
    def CreateDataFromCString(endian: "lldb::ByteOrder", addr_byte_size: int, data: str) -> "SBData":
        r"""CreateDataFromCString(lldb::ByteOrder endian, uint32_t addr_byte_size, char const * data) -> SBData"""
        return _lldb.SBData_CreateDataFromCString(endian, addr_byte_size, data)

    @staticmethod
    def CreateDataFromUInt64Array(endian: "lldb::ByteOrder", addr_byte_size: int, array: "uint64_t *") -> "SBData":
        r"""CreateDataFromUInt64Array(lldb::ByteOrder endian, uint32_t addr_byte_size, uint64_t * array) -> SBData"""
        return _lldb.SBData_CreateDataFromUInt64Array(endian, addr_byte_size, array)

    @staticmethod
    def CreateDataFromUInt32Array(endian: "lldb::ByteOrder", addr_byte_size: int, array: "uint32_t *") -> "SBData":
        r"""CreateDataFromUInt32Array(lldb::ByteOrder endian, uint32_t addr_byte_size, uint32_t * array) -> SBData"""
        return _lldb.SBData_CreateDataFromUInt32Array(endian, addr_byte_size, array)

    @staticmethod
    def CreateDataFromSInt64Array(endian: "lldb::ByteOrder", addr_byte_size: int, array: "int64_t *") -> "SBData":
        r"""CreateDataFromSInt64Array(lldb::ByteOrder endian, uint32_t addr_byte_size, int64_t * array) -> SBData"""
        return _lldb.SBData_CreateDataFromSInt64Array(endian, addr_byte_size, array)

    @staticmethod
    def CreateDataFromSInt32Array(endian: "lldb::ByteOrder", addr_byte_size: int, array: "int32_t *") -> "SBData":
        r"""CreateDataFromSInt32Array(lldb::ByteOrder endian, uint32_t addr_byte_size, int32_t * array) -> SBData"""
        return _lldb.SBData_CreateDataFromSInt32Array(endian, addr_byte_size, array)

    @staticmethod
    def CreateDataFromDoubleArray(endian: "lldb::ByteOrder", addr_byte_size: int, array: "double *") -> "SBData":
        r"""CreateDataFromDoubleArray(lldb::ByteOrder endian, uint32_t addr_byte_size, double * array) -> SBData"""
        return _lldb.SBData_CreateDataFromDoubleArray(endian, addr_byte_size, array)

    def SetDataFromCString(self, data: str) -> "bool":
        r"""SetDataFromCString(SBData self, char const * data) -> bool"""
        return _lldb.SBData_SetDataFromCString(self, data)

    def SetDataFromUInt64Array(self, array: "uint64_t *") -> "bool":
        r"""SetDataFromUInt64Array(SBData self, uint64_t * array) -> bool"""
        return _lldb.SBData_SetDataFromUInt64Array(self, array)

    def SetDataFromUInt32Array(self, array: "uint32_t *") -> "bool":
        r"""SetDataFromUInt32Array(SBData self, uint32_t * array) -> bool"""
        return _lldb.SBData_SetDataFromUInt32Array(self, array)

    def SetDataFromSInt64Array(self, array: "int64_t *") -> "bool":
        r"""SetDataFromSInt64Array(SBData self, int64_t * array) -> bool"""
        return _lldb.SBData_SetDataFromSInt64Array(self, array)

    def SetDataFromSInt32Array(self, array: "int32_t *") -> "bool":
        r"""SetDataFromSInt32Array(SBData self, int32_t * array) -> bool"""
        return _lldb.SBData_SetDataFromSInt32Array(self, array)

    def SetDataFromDoubleArray(self, array: "double *") -> "bool":
        r"""SetDataFromDoubleArray(SBData self, double * array) -> bool"""
        return _lldb.SBData_SetDataFromDoubleArray(self, array)

    def __repr__(self) -> str:
        r"""__repr__(SBData self) -> std::string"""
        return _lldb.SBData___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        return self.GetByteSize()

    def __iter__(self):
        pass

    class read_data_helper:
        def __init__(self, sbdata, readerfunc, item_size):
            self.sbdata = sbdata
            self.readerfunc = readerfunc
            self.item_size = item_size
        def __getitem__(self,key):
            if isinstance(key,slice):
                list = []
                for x in range(*key.indices(self.__len__())):
                    list.append(self.__getitem__(x))
                return list
            if not (isinstance(key, int)):
                raise TypeError('must be int')
            key = key * self.item_size # SBData uses byte-based indexes, but we want to use itemsize-based indexes here
            error = SBError()
            my_data = self.readerfunc(self.sbdata,error,key)
            if error.Fail():
                raise IndexError(error.GetCString())
            else:
                return my_data
        def __len__(self):
            return int(self.sbdata.GetByteSize()/self.item_size)
        def all(self):
            return self[0:len(self)]

    @classmethod
    def CreateDataFromInt (cls, value, size = None, target = None, ptr_size = None, endian = None):
        import sys
        lldbmodule = sys.modules[cls.__module__]
        lldbdict = lldbmodule.__dict__
        if 'target' in lldbdict:
            lldbtarget = lldbdict['target']
        else:
            lldbtarget = None
        if target == None and lldbtarget != None and lldbtarget.IsValid():
            target = lldbtarget
        if ptr_size == None:
            if target and target.IsValid():
                ptr_size = target.addr_size
            else:
                ptr_size = 8
        if endian == None:
            if target and target.IsValid():
                endian = target.byte_order
            else:
                endian = lldbdict['eByteOrderLittle']
        if size == None:
            if value > 2147483647:
                size = 8
            elif value < -2147483648:
                size = 8
            elif value > 4294967295:
                size = 8
            else:
                size = 4
        if size == 4:
            if value < 0:
                return SBData().CreateDataFromSInt32Array(endian, ptr_size, [value])
            return SBData().CreateDataFromUInt32Array(endian, ptr_size, [value])
        if size == 8:
            if value < 0:
                return SBData().CreateDataFromSInt64Array(endian, ptr_size, [value])
            return SBData().CreateDataFromUInt64Array(endian, ptr_size, [value])
        return None

    def _make_helper(self, sbdata, getfunc, itemsize):
        return self.read_data_helper(sbdata, getfunc, itemsize)

    def _make_helper_uint8(self):
        return self._make_helper(self, SBData.GetUnsignedInt8, 1)

    def _make_helper_uint16(self):
        return self._make_helper(self, SBData.GetUnsignedInt16, 2)

    def _make_helper_uint32(self):
        return self._make_helper(self, SBData.GetUnsignedInt32, 4)

    def _make_helper_uint64(self):
        return self._make_helper(self, SBData.GetUnsignedInt64, 8)

    def _make_helper_sint8(self):
        return self._make_helper(self, SBData.GetSignedInt8, 1)

    def _make_helper_sint16(self):
        return self._make_helper(self, SBData.GetSignedInt16, 2)

    def _make_helper_sint32(self):
        return self._make_helper(self, SBData.GetSignedInt32, 4)

    def _make_helper_sint64(self):
        return self._make_helper(self, SBData.GetSignedInt64, 8)

    def _make_helper_float(self):
        return self._make_helper(self, SBData.GetFloat, 4)

    def _make_helper_double(self):
        return self._make_helper(self, SBData.GetDouble, 8)

    def _read_all_uint8(self):
        return self._make_helper_uint8().all()

    def _read_all_uint16(self):
        return self._make_helper_uint16().all()

    def _read_all_uint32(self):
        return self._make_helper_uint32().all()

    def _read_all_uint64(self):
        return self._make_helper_uint64().all()

    def _read_all_sint8(self):
        return self._make_helper_sint8().all()

    def _read_all_sint16(self):
        return self._make_helper_sint16().all()

    def _read_all_sint32(self):
        return self._make_helper_sint32().all()

    def _read_all_sint64(self):
        return self._make_helper_sint64().all()

    def _read_all_float(self):
        return self._make_helper_float().all()

    def _read_all_double(self):
        return self._make_helper_double().all()

    uint8 = property(_make_helper_uint8, None, doc='''A read only property that returns an array-like object out of which you can read uint8 values.''')
    uint16 = property(_make_helper_uint16, None, doc='''A read only property that returns an array-like object out of which you can read uint16 values.''')
    uint32 = property(_make_helper_uint32, None, doc='''A read only property that returns an array-like object out of which you can read uint32 values.''')
    uint64 = property(_make_helper_uint64, None, doc='''A read only property that returns an array-like object out of which you can read uint64 values.''')
    sint8 = property(_make_helper_sint8, None, doc='''A read only property that returns an array-like object out of which you can read sint8 values.''')
    sint16 = property(_make_helper_sint16, None, doc='''A read only property that returns an array-like object out of which you can read sint16 values.''')
    sint32 = property(_make_helper_sint32, None, doc='''A read only property that returns an array-like object out of which you can read sint32 values.''')
    sint64 = property(_make_helper_sint64, None, doc='''A read only property that returns an array-like object out of which you can read sint64 values.''')
    float = property(_make_helper_float, None, doc='''A read only property that returns an array-like object out of which you can read float values.''')
    double = property(_make_helper_double, None, doc='''A read only property that returns an array-like object out of which you can read double values.''')
    uint8s = property(_read_all_uint8, None, doc='''A read only property that returns an array with all the contents of this SBData represented as uint8 values.''')
    uint16s = property(_read_all_uint16, None, doc='''A read only property that returns an array with all the contents of this SBData represented as uint16 values.''')
    uint32s = property(_read_all_uint32, None, doc='''A read only property that returns an array with all the contents of this SBData represented as uint32 values.''')
    uint64s = property(_read_all_uint64, None, doc='''A read only property that returns an array with all the contents of this SBData represented as uint64 values.''')
    sint8s = property(_read_all_sint8, None, doc='''A read only property that returns an array with all the contents of this SBData represented as sint8 values.''')
    sint16s = property(_read_all_sint16, None, doc='''A read only property that returns an array with all the contents of this SBData represented as sint16 values.''')
    sint32s = property(_read_all_sint32, None, doc='''A read only property that returns an array with all the contents of this SBData represented as sint32 values.''')
    sint64s = property(_read_all_sint64, None, doc='''A read only property that returns an array with all the contents of this SBData represented as sint64 values.''')
    floats = property(_read_all_float, None, doc='''A read only property that returns an array with all the contents of this SBData represented as float values.''')
    doubles = property(_read_all_double, None, doc='''A read only property that returns an array with all the contents of this SBData represented as double values.''')
    byte_order = property(GetByteOrder, SetByteOrder, doc='''A read/write property getting and setting the endianness of this SBData (data.byte_order = lldb.eByteOrderLittle).''')
    size = property(GetByteSize, None, doc='''A read only property that returns the size the same result as GetByteSize().''')


# Register SBData in _lldb:
_lldb.SBData_swigregister(SBData)

def SBData_CreateDataFromCString(endian: "lldb::ByteOrder", addr_byte_size: int, data: str) -> "SBData":
    r"""SBData_CreateDataFromCString(lldb::ByteOrder endian, uint32_t addr_byte_size, char const * data) -> SBData"""
    return _lldb.SBData_CreateDataFromCString(endian, addr_byte_size, data)

def SBData_CreateDataFromUInt64Array(endian: "lldb::ByteOrder", addr_byte_size: int, array: "uint64_t *") -> "SBData":
    r"""SBData_CreateDataFromUInt64Array(lldb::ByteOrder endian, uint32_t addr_byte_size, uint64_t * array) -> SBData"""
    return _lldb.SBData_CreateDataFromUInt64Array(endian, addr_byte_size, array)

def SBData_CreateDataFromUInt32Array(endian: "lldb::ByteOrder", addr_byte_size: int, array: "uint32_t *") -> "SBData":
    r"""SBData_CreateDataFromUInt32Array(lldb::ByteOrder endian, uint32_t addr_byte_size, uint32_t * array) -> SBData"""
    return _lldb.SBData_CreateDataFromUInt32Array(endian, addr_byte_size, array)

def SBData_CreateDataFromSInt64Array(endian: "lldb::ByteOrder", addr_byte_size: int, array: "int64_t *") -> "SBData":
    r"""SBData_CreateDataFromSInt64Array(lldb::ByteOrder endian, uint32_t addr_byte_size, int64_t * array) -> SBData"""
    return _lldb.SBData_CreateDataFromSInt64Array(endian, addr_byte_size, array)

def SBData_CreateDataFromSInt32Array(endian: "lldb::ByteOrder", addr_byte_size: int, array: "int32_t *") -> "SBData":
    r"""SBData_CreateDataFromSInt32Array(lldb::ByteOrder endian, uint32_t addr_byte_size, int32_t * array) -> SBData"""
    return _lldb.SBData_CreateDataFromSInt32Array(endian, addr_byte_size, array)

def SBData_CreateDataFromDoubleArray(endian: "lldb::ByteOrder", addr_byte_size: int, array: "double *") -> "SBData":
    r"""SBData_CreateDataFromDoubleArray(lldb::ByteOrder endian, uint32_t addr_byte_size, double * array) -> SBData"""
    return _lldb.SBData_CreateDataFromDoubleArray(endian, addr_byte_size, array)

class SBDebugger(object):
    r"""
    SBDebugger is the primordial object that creates SBTargets and provides
    access to them.  It also manages the overall debugging experiences.

    For example (from example/disasm.py),::

        import lldb
        import os
        import sys

        def disassemble_instructions (insts):
            for i in insts:
                print i

        ...

        # Create a new debugger instance
        debugger = lldb.SBDebugger.Create()

        # When we step or continue, don't return from the function until the process
        # stops. We do this by setting the async mode to false.
        debugger.SetAsync (False)

        # Create a target from a file and arch
        print('Creating a target for '%s'' % exe)

        target = debugger.CreateTargetWithFileAndArch (exe, lldb.LLDB_ARCH_DEFAULT)

        if target:
            # If the target is valid set a breakpoint at main
            main_bp = target.BreakpointCreateByName (fname, target.GetExecutable().GetFilename());

            print main_bp

            # Launch the process. Since we specified synchronous mode, we won't return
            # from this function until we hit the breakpoint at main
            process = target.LaunchSimple (None, None, os.getcwd())

            # Make sure the launch went ok
            if process:
                # Print some simple process info
                state = process.GetState ()
                print process
                if state == lldb.eStateStopped:
                    # Get the first thread
                    thread = process.GetThreadAtIndex (0)
                    if thread:
                        # Print some simple thread info
                        print thread
                        # Get the first frame
                        frame = thread.GetFrameAtIndex (0)
                        if frame:
                            # Print some simple frame info
                            print frame
                            function = frame.GetFunction()
                            # See if we have debug info (a function)
                            if function:
                                # We do have a function, print some info for the function
                                print function
                                # Now get all instructions for this function and print them
                                insts = function.GetInstructions(target)
                                disassemble_instructions (insts)
                            else:
                                # See if we have a symbol in the symbol table for where we stopped
                                symbol = frame.GetSymbol();
                                if symbol:
                                    # We do have a symbol, print some info for the symbol
                                    print symbol
                                    # Now get all instructions for this symbol and print them
                                    insts = symbol.GetInstructions(target)
                                    disassemble_instructions (insts)

                            registerList = frame.GetRegisters()
                            print('Frame registers (size of register set = %d):' % registerList.GetSize())
                            for value in registerList:
                                #print value
                                print('%s (number of children = %d):' % (value.GetName(), value.GetNumChildren()))
                                for child in value:
                                    print('Name: ', child.GetName(), ' Value: ', child.GetValue())

                    print('Hit the breakpoint at main, enter to continue and wait for program to exit or 'Ctrl-D'/'quit' to terminate the program')
                    next = sys.stdin.readline()
                    if not next or next.rstrip('\n') == 'quit':
                        print('Terminating the inferior process...')
                        process.Kill()
                    else:
                        # Now continue to the program exit
                        process.Continue()
                        # When we return from the above function we will hopefully be at the
                        # program exit. Print out some process info
                        print process
                elif state == lldb.eStateExited:
                    print('Didn't hit the breakpoint at main, program has exited...')
                else:
                    print('Unexpected process state: %s, killing process...' % debugger.StateAsCString (state))
                    process.Kill()

    Sometimes you need to create an empty target that will get filled in later.  The most common use for this
    is to attach to a process by name or pid where you don't know the executable up front.  The most convenient way
    to do this is: ::

        target = debugger.CreateTarget('')
        error = lldb.SBError()
        process = target.AttachToProcessWithName(debugger.GetListener(), 'PROCESS_NAME', False, error)

    or the equivalent arguments for :py:class:`SBTarget.AttachToProcessWithID` .
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    eBroadcastBitProgress = _lldb.SBDebugger_eBroadcastBitProgress

    eBroadcastBitWarning = _lldb.SBDebugger_eBroadcastBitWarning

    eBroadcastBitError = _lldb.SBDebugger_eBroadcastBitError


    def __init__(self, *args):
        r"""
        __init__(SBDebugger self) -> SBDebugger
        __init__(SBDebugger self, SBDebugger rhs) -> SBDebugger
        """
        _lldb.SBDebugger_swiginit(self, _lldb.new_SBDebugger(*args))
    __swig_destroy__ = _lldb.delete_SBDebugger

    @staticmethod
    def GetBroadcasterClass() -> str:
        r"""GetBroadcasterClass() -> char const *"""
        return _lldb.SBDebugger_GetBroadcasterClass()

    def GetBroadcaster(self) -> "SBBroadcaster":
        r"""GetBroadcaster(SBDebugger self) -> SBBroadcaster"""
        return _lldb.SBDebugger_GetBroadcaster(self)

    @staticmethod
    def GetProgressFromEvent(event: "SBEvent") -> "unsigned long long &, unsigned long long &, unsigned long long &, bool &":
        r"""GetProgressFromEvent(SBEvent event) -> char const *"""
        return _lldb.SBDebugger_GetProgressFromEvent(event)

    @staticmethod
    def GetProgressDataFromEvent(event: "SBEvent") -> "SBStructuredData":
        r"""GetProgressDataFromEvent(SBEvent event) -> SBStructuredData"""
        return _lldb.SBDebugger_GetProgressDataFromEvent(event)

    @staticmethod
    def GetDiagnosticFromEvent(event: "SBEvent") -> "SBStructuredData":
        r"""GetDiagnosticFromEvent(SBEvent event) -> SBStructuredData"""
        return _lldb.SBDebugger_GetDiagnosticFromEvent(event)

    @staticmethod
    def Initialize():
        r"""Initialize()"""
        return _lldb.SBDebugger_Initialize()

    @staticmethod
    def InitializeWithErrorHandling() -> "SBError":
        r"""InitializeWithErrorHandling() -> SBError"""
        return _lldb.SBDebugger_InitializeWithErrorHandling()

    @staticmethod
    def PrintStackTraceOnError():
        r"""PrintStackTraceOnError()"""
        return _lldb.SBDebugger_PrintStackTraceOnError()

    @staticmethod
    def PrintDiagnosticsOnError():
        r"""PrintDiagnosticsOnError()"""
        return _lldb.SBDebugger_PrintDiagnosticsOnError()

    @staticmethod
    def Terminate():
        r"""Terminate()"""
        return _lldb.SBDebugger_Terminate()

    @staticmethod
    def Create(*args) -> "SBDebugger":
        r"""
        Create() -> SBDebugger
        Create(bool source_init_files) -> SBDebugger
        Create(bool source_init_files, lldb::LogOutputCallback log_callback) -> SBDebugger
        """
        return _lldb.SBDebugger_Create(*args)

    @staticmethod
    def Destroy(debugger: "SBDebugger"):
        r"""Destroy(SBDebugger debugger)"""
        return _lldb.SBDebugger_Destroy(debugger)

    @staticmethod
    def MemoryPressureDetected():
        r"""MemoryPressureDetected()"""
        return _lldb.SBDebugger_MemoryPressureDetected()

    def __nonzero__(self):
        return _lldb.SBDebugger___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBDebugger self) -> bool"""
        return _lldb.SBDebugger_IsValid(self)

    def Clear(self):
        r"""Clear(SBDebugger self)"""
        return _lldb.SBDebugger_Clear(self)

    def GetSetting(self, setting: str=None) -> "SBStructuredData":
        r"""GetSetting(SBDebugger self, char const * setting=None) -> SBStructuredData"""
        return _lldb.SBDebugger_GetSetting(self, setting)

    def SetAsync(self, b: "bool"):
        r"""SetAsync(SBDebugger self, bool b)"""
        return _lldb.SBDebugger_SetAsync(self, b)

    def GetAsync(self) -> "bool":
        r"""GetAsync(SBDebugger self) -> bool"""
        return _lldb.SBDebugger_GetAsync(self)

    def SkipLLDBInitFiles(self, b: "bool"):
        r"""SkipLLDBInitFiles(SBDebugger self, bool b)"""
        return _lldb.SBDebugger_SkipLLDBInitFiles(self, b)

    def SkipAppInitFiles(self, b: "bool"):
        r"""SkipAppInitFiles(SBDebugger self, bool b)"""
        return _lldb.SBDebugger_SkipAppInitFiles(self, b)

    def SetInputString(self, data: str) -> "SBError":
        r"""SetInputString(SBDebugger self, char const * data) -> SBError"""
        return _lldb.SBDebugger_SetInputString(self, data)

    def SetInputFile(self, *args) -> "SBError":
        r"""
        SetInputFile(SBDebugger self, SBFile file) -> SBError
        SetInputFile(SBDebugger self, lldb::FileSP file) -> SBError
        """
        return _lldb.SBDebugger_SetInputFile(self, *args)

    def SetOutputFile(self, *args) -> "SBError":
        r"""
        SetOutputFile(SBDebugger self, SBFile file) -> SBError
        SetOutputFile(SBDebugger self, lldb::FileSP file) -> SBError
        """
        return _lldb.SBDebugger_SetOutputFile(self, *args)

    def SetErrorFile(self, *args) -> "SBError":
        r"""
        SetErrorFile(SBDebugger self, SBFile file) -> SBError
        SetErrorFile(SBDebugger self, lldb::FileSP file) -> SBError
        """
        return _lldb.SBDebugger_SetErrorFile(self, *args)

    def GetInputFile(self) -> "SBFile":
        r"""GetInputFile(SBDebugger self) -> SBFile"""
        return _lldb.SBDebugger_GetInputFile(self)

    def GetOutputFile(self) -> "SBFile":
        r"""GetOutputFile(SBDebugger self) -> SBFile"""
        return _lldb.SBDebugger_GetOutputFile(self)

    def GetErrorFile(self) -> "SBFile":
        r"""GetErrorFile(SBDebugger self) -> SBFile"""
        return _lldb.SBDebugger_GetErrorFile(self)

    def SaveInputTerminalState(self):
        r"""SaveInputTerminalState(SBDebugger self)"""
        return _lldb.SBDebugger_SaveInputTerminalState(self)

    def RestoreInputTerminalState(self):
        r"""RestoreInputTerminalState(SBDebugger self)"""
        return _lldb.SBDebugger_RestoreInputTerminalState(self)

    def GetCommandInterpreter(self) -> "SBCommandInterpreter":
        r"""GetCommandInterpreter(SBDebugger self) -> SBCommandInterpreter"""
        return _lldb.SBDebugger_GetCommandInterpreter(self)

    def HandleCommand(self, command: str):
        r"""HandleCommand(SBDebugger self, char const * command)"""
        return _lldb.SBDebugger_HandleCommand(self, command)

    def RequestInterrupt(self):
        r"""RequestInterrupt(SBDebugger self)"""
        return _lldb.SBDebugger_RequestInterrupt(self)

    def CancelInterruptRequest(self):
        r"""CancelInterruptRequest(SBDebugger self)"""
        return _lldb.SBDebugger_CancelInterruptRequest(self)

    def InterruptRequested(self) -> "bool":
        r"""InterruptRequested(SBDebugger self) -> bool"""
        return _lldb.SBDebugger_InterruptRequested(self)

    def GetListener(self) -> "SBListener":
        r"""GetListener(SBDebugger self) -> SBListener"""
        return _lldb.SBDebugger_GetListener(self)

    def HandleProcessEvent(self, *args):
        r"""
        HandleProcessEvent(SBDebugger self, SBProcess process, SBEvent event, SBFile out, SBFile err)
        HandleProcessEvent(SBDebugger self, SBProcess process, SBEvent event, lldb::FileSP arg4, lldb::FileSP arg5)
        """
        return _lldb.SBDebugger_HandleProcessEvent(self, *args)

    def CreateTargetWithFileAndTargetTriple(self, filename: str, target_triple: str) -> "SBTarget":
        r"""CreateTargetWithFileAndTargetTriple(SBDebugger self, char const * filename, char const * target_triple) -> SBTarget"""
        return _lldb.SBDebugger_CreateTargetWithFileAndTargetTriple(self, filename, target_triple)

    def CreateTargetWithFileAndArch(self, filename: str, archname: str) -> "SBTarget":
        r"""CreateTargetWithFileAndArch(SBDebugger self, char const * filename, char const * archname) -> SBTarget"""
        return _lldb.SBDebugger_CreateTargetWithFileAndArch(self, filename, archname)

    def CreateTarget(self, *args) -> "SBTarget":
        r"""
        CreateTarget(SBDebugger self, char const * filename, char const * target_triple, char const * platform_name, bool add_dependent_modules, SBError error) -> SBTarget
        CreateTarget(SBDebugger self, char const * filename) -> SBTarget
        """
        return _lldb.SBDebugger_CreateTarget(self, *args)

    def GetDummyTarget(self) -> "SBTarget":
        r"""
        GetDummyTarget(SBDebugger self) -> SBTarget
        The dummy target holds breakpoints and breakpoint names that will prime newly created targets.
        """
        return _lldb.SBDebugger_GetDummyTarget(self)

    def DeleteTarget(self, target: "SBTarget") -> "bool":
        r"""
        DeleteTarget(SBDebugger self, SBTarget target) -> bool
        Return true if target is deleted from the target list of the debugger.
        """
        return _lldb.SBDebugger_DeleteTarget(self, target)

    def GetTargetAtIndex(self, idx: int) -> "SBTarget":
        r"""GetTargetAtIndex(SBDebugger self, uint32_t idx) -> SBTarget"""
        return _lldb.SBDebugger_GetTargetAtIndex(self, idx)

    def GetIndexOfTarget(self, target: "SBTarget") -> int:
        r"""GetIndexOfTarget(SBDebugger self, SBTarget target) -> uint32_t"""
        return _lldb.SBDebugger_GetIndexOfTarget(self, target)

    def FindTargetWithProcessID(self, pid: int) -> "SBTarget":
        r"""FindTargetWithProcessID(SBDebugger self, lldb::pid_t pid) -> SBTarget"""
        return _lldb.SBDebugger_FindTargetWithProcessID(self, pid)

    def FindTargetWithFileAndArch(self, filename: str, arch: str) -> "SBTarget":
        r"""FindTargetWithFileAndArch(SBDebugger self, char const * filename, char const * arch) -> SBTarget"""
        return _lldb.SBDebugger_FindTargetWithFileAndArch(self, filename, arch)

    def GetNumTargets(self) -> int:
        r"""GetNumTargets(SBDebugger self) -> uint32_t"""
        return _lldb.SBDebugger_GetNumTargets(self)

    def GetSelectedTarget(self) -> "SBTarget":
        r"""GetSelectedTarget(SBDebugger self) -> SBTarget"""
        return _lldb.SBDebugger_GetSelectedTarget(self)

    def SetSelectedTarget(self, target: "SBTarget"):
        r"""SetSelectedTarget(SBDebugger self, SBTarget target)"""
        return _lldb.SBDebugger_SetSelectedTarget(self, target)

    def GetSelectedPlatform(self) -> "SBPlatform":
        r"""GetSelectedPlatform(SBDebugger self) -> SBPlatform"""
        return _lldb.SBDebugger_GetSelectedPlatform(self)

    def SetSelectedPlatform(self, platform: "SBPlatform"):
        r"""SetSelectedPlatform(SBDebugger self, SBPlatform platform)"""
        return _lldb.SBDebugger_SetSelectedPlatform(self, platform)

    def GetNumPlatforms(self) -> int:
        r"""
        GetNumPlatforms(SBDebugger self) -> uint32_t
        Get the number of currently active platforms.
        """
        return _lldb.SBDebugger_GetNumPlatforms(self)

    def GetPlatformAtIndex(self, idx: int) -> "SBPlatform":
        r"""
        GetPlatformAtIndex(SBDebugger self, uint32_t idx) -> SBPlatform
        Get one of the currently active platforms.
        """
        return _lldb.SBDebugger_GetPlatformAtIndex(self, idx)

    def GetNumAvailablePlatforms(self) -> int:
        r"""
        GetNumAvailablePlatforms(SBDebugger self) -> uint32_t
        Get the number of available platforms.
        """
        return _lldb.SBDebugger_GetNumAvailablePlatforms(self)

    def GetAvailablePlatformInfoAtIndex(self, idx: int) -> "SBStructuredData":
        r"""
        GetAvailablePlatformInfoAtIndex(SBDebugger self, uint32_t idx) -> SBStructuredData

            Get the name and description of one of the available platforms.

            @param idx Zero-based index of the platform for which info should be
                       retrieved, must be less than the value returned by
                       GetNumAvailablePlatforms().
        """
        return _lldb.SBDebugger_GetAvailablePlatformInfoAtIndex(self, idx)

    def GetSourceManager(self) -> "SBSourceManager":
        r"""GetSourceManager(SBDebugger self) -> SBSourceManager"""
        return _lldb.SBDebugger_GetSourceManager(self)

    def SetCurrentPlatform(self, platform_name: str) -> "SBError":
        r"""SetCurrentPlatform(SBDebugger self, char const * platform_name) -> SBError"""
        return _lldb.SBDebugger_SetCurrentPlatform(self, platform_name)

    def SetCurrentPlatformSDKRoot(self, sysroot: str) -> "bool":
        r"""SetCurrentPlatformSDKRoot(SBDebugger self, char const * sysroot) -> bool"""
        return _lldb.SBDebugger_SetCurrentPlatformSDKRoot(self, sysroot)

    def SetUseExternalEditor(self, input: "bool") -> "bool":
        r"""SetUseExternalEditor(SBDebugger self, bool input) -> bool"""
        return _lldb.SBDebugger_SetUseExternalEditor(self, input)

    def GetUseExternalEditor(self) -> "bool":
        r"""GetUseExternalEditor(SBDebugger self) -> bool"""
        return _lldb.SBDebugger_GetUseExternalEditor(self)

    def SetUseColor(self, use_color: "bool") -> "bool":
        r"""SetUseColor(SBDebugger self, bool use_color) -> bool"""
        return _lldb.SBDebugger_SetUseColor(self, use_color)

    def GetUseColor(self) -> "bool":
        r"""GetUseColor(SBDebugger self) -> bool"""
        return _lldb.SBDebugger_GetUseColor(self)

    def SetUseSourceCache(self, use_source_cache: "bool") -> "bool":
        r"""SetUseSourceCache(SBDebugger self, bool use_source_cache) -> bool"""
        return _lldb.SBDebugger_SetUseSourceCache(self, use_source_cache)

    def GetUseSourceCache(self) -> "bool":
        r"""GetUseSourceCache(SBDebugger self) -> bool"""
        return _lldb.SBDebugger_GetUseSourceCache(self)

    @staticmethod
    def GetDefaultArchitecture(arch_name: "char *", arch_name_len: "size_t") -> "bool":
        r"""GetDefaultArchitecture(char * arch_name, size_t arch_name_len) -> bool"""
        return _lldb.SBDebugger_GetDefaultArchitecture(arch_name, arch_name_len)

    @staticmethod
    def SetDefaultArchitecture(arch_name: str) -> "bool":
        r"""SetDefaultArchitecture(char const * arch_name) -> bool"""
        return _lldb.SBDebugger_SetDefaultArchitecture(arch_name)

    def GetScriptingLanguage(self, script_language_name: str) -> "lldb::ScriptLanguage":
        r"""GetScriptingLanguage(SBDebugger self, char const * script_language_name) -> lldb::ScriptLanguage"""
        return _lldb.SBDebugger_GetScriptingLanguage(self, script_language_name)

    def GetScriptInterpreterInfo(self, arg2: "lldb::ScriptLanguage") -> "SBStructuredData":
        r"""GetScriptInterpreterInfo(SBDebugger self, lldb::ScriptLanguage arg2) -> SBStructuredData"""
        return _lldb.SBDebugger_GetScriptInterpreterInfo(self, arg2)

    @staticmethod
    def GetVersionString() -> str:
        r"""GetVersionString() -> char const *"""
        return _lldb.SBDebugger_GetVersionString()

    @staticmethod
    def StateAsCString(state: "lldb::StateType") -> str:
        r"""StateAsCString(lldb::StateType state) -> char const *"""
        return _lldb.SBDebugger_StateAsCString(state)

    @staticmethod
    def GetBuildConfiguration() -> "SBStructuredData":
        r"""GetBuildConfiguration() -> SBStructuredData"""
        return _lldb.SBDebugger_GetBuildConfiguration()

    @staticmethod
    def StateIsRunningState(state: "lldb::StateType") -> "bool":
        r"""StateIsRunningState(lldb::StateType state) -> bool"""
        return _lldb.SBDebugger_StateIsRunningState(state)

    @staticmethod
    def StateIsStoppedState(state: "lldb::StateType") -> "bool":
        r"""StateIsStoppedState(lldb::StateType state) -> bool"""
        return _lldb.SBDebugger_StateIsStoppedState(state)

    def EnableLog(self, channel: str, categories: "char const **") -> "bool":
        r"""EnableLog(SBDebugger self, char const * channel, char const ** categories) -> bool"""
        return _lldb.SBDebugger_EnableLog(self, channel, categories)

    def SetLoggingCallback(self, log_callback: "lldb::LogOutputCallback"):
        r"""SetLoggingCallback(SBDebugger self, lldb::LogOutputCallback log_callback)"""
        return _lldb.SBDebugger_SetLoggingCallback(self, log_callback)

    def SetDestroyCallback(self, destroy_callback: "SBDebuggerDestroyCallback"):
        r"""SetDestroyCallback(SBDebugger self, lldb::SBDebuggerDestroyCallback destroy_callback)"""
        return _lldb.SBDebugger_SetDestroyCallback(self, destroy_callback)

    def DispatchInput(self, data: "void const *"):
        r"""DispatchInput(SBDebugger self, void const * data)"""
        return _lldb.SBDebugger_DispatchInput(self, data)

    def DispatchInputInterrupt(self):
        r"""DispatchInputInterrupt(SBDebugger self)"""
        return _lldb.SBDebugger_DispatchInputInterrupt(self)

    def DispatchInputEndOfFile(self):
        r"""DispatchInputEndOfFile(SBDebugger self)"""
        return _lldb.SBDebugger_DispatchInputEndOfFile(self)

    def GetInstanceName(self) -> str:
        r"""GetInstanceName(SBDebugger self) -> char const *"""
        return _lldb.SBDebugger_GetInstanceName(self)

    @staticmethod
    def FindDebuggerWithID(id: "int") -> "SBDebugger":
        r"""FindDebuggerWithID(int id) -> SBDebugger"""
        return _lldb.SBDebugger_FindDebuggerWithID(id)

    @staticmethod
    def SetInternalVariable(var_name: str, value: str, debugger_instance_name: str) -> "SBError":
        r"""SetInternalVariable(char const * var_name, char const * value, char const * debugger_instance_name) -> SBError"""
        return _lldb.SBDebugger_SetInternalVariable(var_name, value, debugger_instance_name)

    @staticmethod
    def GetInternalVariableValue(var_name: str, debugger_instance_name: str) -> "SBStringList":
        r"""GetInternalVariableValue(char const * var_name, char const * debugger_instance_name) -> SBStringList"""
        return _lldb.SBDebugger_GetInternalVariableValue(var_name, debugger_instance_name)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBDebugger self, SBStream description) -> bool"""
        return _lldb.SBDebugger_GetDescription(self, description)

    def GetTerminalWidth(self) -> int:
        r"""GetTerminalWidth(SBDebugger self) -> uint32_t"""
        return _lldb.SBDebugger_GetTerminalWidth(self)

    def SetTerminalWidth(self, term_width: int):
        r"""SetTerminalWidth(SBDebugger self, uint32_t term_width)"""
        return _lldb.SBDebugger_SetTerminalWidth(self, term_width)

    def GetID(self) -> int:
        r"""GetID(SBDebugger self) -> lldb::user_id_t"""
        return _lldb.SBDebugger_GetID(self)

    def GetPrompt(self) -> str:
        r"""GetPrompt(SBDebugger self) -> char const *"""
        return _lldb.SBDebugger_GetPrompt(self)

    def SetPrompt(self, prompt: str):
        r"""SetPrompt(SBDebugger self, char const * prompt)"""
        return _lldb.SBDebugger_SetPrompt(self, prompt)

    def GetReproducerPath(self) -> str:
        r"""GetReproducerPath(SBDebugger self) -> char const *"""
        return _lldb.SBDebugger_GetReproducerPath(self)

    def GetScriptLanguage(self) -> "lldb::ScriptLanguage":
        r"""GetScriptLanguage(SBDebugger self) -> lldb::ScriptLanguage"""
        return _lldb.SBDebugger_GetScriptLanguage(self)

    def SetScriptLanguage(self, script_lang: "lldb::ScriptLanguage"):
        r"""SetScriptLanguage(SBDebugger self, lldb::ScriptLanguage script_lang)"""
        return _lldb.SBDebugger_SetScriptLanguage(self, script_lang)

    def GetREPLLanguage(self) -> "lldb::LanguageType":
        r"""GetREPLLanguage(SBDebugger self) -> lldb::LanguageType"""
        return _lldb.SBDebugger_GetREPLLanguage(self)

    def SetREPLLanguage(self, repl_lang: "lldb::LanguageType"):
        r"""SetREPLLanguage(SBDebugger self, lldb::LanguageType repl_lang)"""
        return _lldb.SBDebugger_SetREPLLanguage(self, repl_lang)

    def GetCloseInputOnEOF(self) -> "bool":
        r"""GetCloseInputOnEOF(SBDebugger self) -> bool"""
        return _lldb.SBDebugger_GetCloseInputOnEOF(self)

    def SetCloseInputOnEOF(self, b: "bool"):
        r"""SetCloseInputOnEOF(SBDebugger self, bool b)"""
        return _lldb.SBDebugger_SetCloseInputOnEOF(self, b)

    def GetCategory(self, *args) -> "SBTypeCategory":
        r"""
        GetCategory(SBDebugger self, char const * category_name) -> SBTypeCategory
        GetCategory(SBDebugger self, lldb::LanguageType lang_type) -> SBTypeCategory
        """
        return _lldb.SBDebugger_GetCategory(self, *args)

    def CreateCategory(self, category_name: str) -> "SBTypeCategory":
        r"""CreateCategory(SBDebugger self, char const * category_name) -> SBTypeCategory"""
        return _lldb.SBDebugger_CreateCategory(self, category_name)

    def DeleteCategory(self, category_name: str) -> "bool":
        r"""DeleteCategory(SBDebugger self, char const * category_name) -> bool"""
        return _lldb.SBDebugger_DeleteCategory(self, category_name)

    def GetNumCategories(self) -> int:
        r"""GetNumCategories(SBDebugger self) -> uint32_t"""
        return _lldb.SBDebugger_GetNumCategories(self)

    def GetCategoryAtIndex(self, arg2: int) -> "SBTypeCategory":
        r"""GetCategoryAtIndex(SBDebugger self, uint32_t arg2) -> SBTypeCategory"""
        return _lldb.SBDebugger_GetCategoryAtIndex(self, arg2)

    def GetDefaultCategory(self) -> "SBTypeCategory":
        r"""GetDefaultCategory(SBDebugger self) -> SBTypeCategory"""
        return _lldb.SBDebugger_GetDefaultCategory(self)

    def GetFormatForType(self, arg2: "SBTypeNameSpecifier") -> "SBTypeFormat":
        r"""GetFormatForType(SBDebugger self, SBTypeNameSpecifier arg2) -> SBTypeFormat"""
        return _lldb.SBDebugger_GetFormatForType(self, arg2)

    def GetSummaryForType(self, arg2: "SBTypeNameSpecifier") -> "SBTypeSummary":
        r"""GetSummaryForType(SBDebugger self, SBTypeNameSpecifier arg2) -> SBTypeSummary"""
        return _lldb.SBDebugger_GetSummaryForType(self, arg2)

    def GetFilterForType(self, arg2: "SBTypeNameSpecifier") -> "SBTypeFilter":
        r"""GetFilterForType(SBDebugger self, SBTypeNameSpecifier arg2) -> SBTypeFilter"""
        return _lldb.SBDebugger_GetFilterForType(self, arg2)

    def GetSyntheticForType(self, arg2: "SBTypeNameSpecifier") -> "SBTypeSynthetic":
        r"""GetSyntheticForType(SBDebugger self, SBTypeNameSpecifier arg2) -> SBTypeSynthetic"""
        return _lldb.SBDebugger_GetSyntheticForType(self, arg2)

    def RunCommandInterpreter(self, auto_handle_events: "bool", spawn_thread: "bool", options: "SBCommandInterpreterRunOptions", num_errors: "int &", quit_requested: "bool &", stopped_for_crash: "bool &"):
        r"""
        RunCommandInterpreter(SBDebugger self, bool auto_handle_events, bool spawn_thread, SBCommandInterpreterRunOptions options, int & num_errors, bool & quit_requested, bool & stopped_for_crash)
        Launch a command interpreter session. Commands are read from standard input or
        from the input handle specified for the debugger object. Output/errors are
        similarly redirected to standard output/error or the configured handles.

        @param[in] auto_handle_events If true, automatically handle resulting events.
        @param[in] spawn_thread If true, start a new thread for IO handling.
        @param[in] options Parameter collection of type SBCommandInterpreterRunOptions.
        @param[in] num_errors Initial error counter.
        @param[in] quit_requested Initial quit request flag.
        @param[in] stopped_for_crash Initial crash flag.

        @return
        A tuple with the number of errors encountered by the interpreter, a boolean
        indicating whether quitting the interpreter was requested and another boolean
        set to True in case of a crash.

        Example: ::

            # Start an interactive lldb session from a script (with a valid debugger object
            # created beforehand):
            n_errors, quit_requested, has_crashed = debugger.RunCommandInterpreter(True,
                False, lldb.SBCommandInterpreterRunOptions(), 0, False, False)
        """
        return _lldb.SBDebugger_RunCommandInterpreter(self, auto_handle_events, spawn_thread, options, num_errors, quit_requested, stopped_for_crash)

    def RunREPL(self, language: "lldb::LanguageType", repl_options: str) -> "SBError":
        r"""RunREPL(SBDebugger self, lldb::LanguageType language, char const * repl_options) -> SBError"""
        return _lldb.SBDebugger_RunREPL(self, language, repl_options)

    def LoadTraceFromFile(self, error: "SBError", trace_description_file: "SBFileSpec") -> "SBTrace":
        r"""LoadTraceFromFile(SBDebugger self, SBError error, SBFileSpec trace_description_file) -> SBTrace"""
        return _lldb.SBDebugger_LoadTraceFromFile(self, error, trace_description_file)

    def __repr__(self) -> str:
        r"""__repr__(SBDebugger self) -> std::string"""
        return _lldb.SBDebugger___repr__(self)

    def SetOutputFileHandle(self, file, transfer_ownership):
        "DEPRECATED, use SetOutputFile"
        if file is None:
            import sys
            file = sys.stdout
        self.SetOutputFile(SBFile.Create(file, borrow=True))

    def SetInputFileHandle(self, file, transfer_ownership):
        "DEPRECATED, use SetInputFile"
        if file is None:
            import sys
            file = sys.stdin
        self.SetInputFile(SBFile.Create(file, borrow=True))

    def SetErrorFileHandle(self, file, transfer_ownership):
        "DEPRECATED, use SetErrorFile"
        if file is None:
            import sys
            file = sys.stderr
        self.SetErrorFile(SBFile.Create(file, borrow=True))

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __iter__(self):
        '''Iterate over all targets in a lldb.SBDebugger object.'''
        return lldb_iter(self, 'GetNumTargets', 'GetTargetAtIndex')

    def __len__(self):
        '''Return the number of targets in a lldb.SBDebugger object.'''
        return self.GetNumTargets()


    def GetInputFileHandle(self) -> "lldb::FileSP":
        r"""GetInputFileHandle(SBDebugger self) -> lldb::FileSP"""
        return _lldb.SBDebugger_GetInputFileHandle(self)

    def GetOutputFileHandle(self) -> "lldb::FileSP":
        r"""GetOutputFileHandle(SBDebugger self) -> lldb::FileSP"""
        return _lldb.SBDebugger_GetOutputFileHandle(self)

    def GetErrorFileHandle(self) -> "lldb::FileSP":
        r"""GetErrorFileHandle(SBDebugger self) -> lldb::FileSP"""
        return _lldb.SBDebugger_GetErrorFileHandle(self)

# Register SBDebugger in _lldb:
_lldb.SBDebugger_swigregister(SBDebugger)

def SBDebugger_GetBroadcasterClass() -> str:
    r"""SBDebugger_GetBroadcasterClass() -> char const *"""
    return _lldb.SBDebugger_GetBroadcasterClass()

def SBDebugger_GetProgressFromEvent(event: "SBEvent") -> "unsigned long long &, unsigned long long &, unsigned long long &, bool &":
    r"""SBDebugger_GetProgressFromEvent(SBEvent event) -> char const *"""
    return _lldb.SBDebugger_GetProgressFromEvent(event)

def SBDebugger_GetProgressDataFromEvent(event: "SBEvent") -> "SBStructuredData":
    r"""SBDebugger_GetProgressDataFromEvent(SBEvent event) -> SBStructuredData"""
    return _lldb.SBDebugger_GetProgressDataFromEvent(event)

def SBDebugger_GetDiagnosticFromEvent(event: "SBEvent") -> "SBStructuredData":
    r"""SBDebugger_GetDiagnosticFromEvent(SBEvent event) -> SBStructuredData"""
    return _lldb.SBDebugger_GetDiagnosticFromEvent(event)

def SBDebugger_Initialize():
    r"""SBDebugger_Initialize()"""
    return _lldb.SBDebugger_Initialize()

def SBDebugger_InitializeWithErrorHandling() -> "SBError":
    r"""SBDebugger_InitializeWithErrorHandling() -> SBError"""
    return _lldb.SBDebugger_InitializeWithErrorHandling()

def SBDebugger_PrintStackTraceOnError():
    r"""SBDebugger_PrintStackTraceOnError()"""
    return _lldb.SBDebugger_PrintStackTraceOnError()

def SBDebugger_PrintDiagnosticsOnError():
    r"""SBDebugger_PrintDiagnosticsOnError()"""
    return _lldb.SBDebugger_PrintDiagnosticsOnError()

def SBDebugger_Terminate():
    r"""SBDebugger_Terminate()"""
    return _lldb.SBDebugger_Terminate()

def SBDebugger_Create(*args) -> "SBDebugger":
    r"""
    SBDebugger_Create() -> SBDebugger
    SBDebugger_Create(bool source_init_files) -> SBDebugger
    SBDebugger_Create(bool source_init_files, lldb::LogOutputCallback log_callback) -> SBDebugger
    """
    return _lldb.SBDebugger_Create(*args)

def SBDebugger_Destroy(debugger: "SBDebugger"):
    r"""SBDebugger_Destroy(SBDebugger debugger)"""
    return _lldb.SBDebugger_Destroy(debugger)

def SBDebugger_MemoryPressureDetected():
    r"""SBDebugger_MemoryPressureDetected()"""
    return _lldb.SBDebugger_MemoryPressureDetected()

def SBDebugger_GetDefaultArchitecture(arch_name: "char *", arch_name_len: "size_t") -> "bool":
    r"""SBDebugger_GetDefaultArchitecture(char * arch_name, size_t arch_name_len) -> bool"""
    return _lldb.SBDebugger_GetDefaultArchitecture(arch_name, arch_name_len)

def SBDebugger_SetDefaultArchitecture(arch_name: str) -> "bool":
    r"""SBDebugger_SetDefaultArchitecture(char const * arch_name) -> bool"""
    return _lldb.SBDebugger_SetDefaultArchitecture(arch_name)

def SBDebugger_GetVersionString() -> str:
    r"""SBDebugger_GetVersionString() -> char const *"""
    return _lldb.SBDebugger_GetVersionString()

def SBDebugger_StateAsCString(state: "lldb::StateType") -> str:
    r"""SBDebugger_StateAsCString(lldb::StateType state) -> char const *"""
    return _lldb.SBDebugger_StateAsCString(state)

def SBDebugger_GetBuildConfiguration() -> "SBStructuredData":
    r"""SBDebugger_GetBuildConfiguration() -> SBStructuredData"""
    return _lldb.SBDebugger_GetBuildConfiguration()

def SBDebugger_StateIsRunningState(state: "lldb::StateType") -> "bool":
    r"""SBDebugger_StateIsRunningState(lldb::StateType state) -> bool"""
    return _lldb.SBDebugger_StateIsRunningState(state)

def SBDebugger_StateIsStoppedState(state: "lldb::StateType") -> "bool":
    r"""SBDebugger_StateIsStoppedState(lldb::StateType state) -> bool"""
    return _lldb.SBDebugger_StateIsStoppedState(state)

def SBDebugger_FindDebuggerWithID(id: "int") -> "SBDebugger":
    r"""SBDebugger_FindDebuggerWithID(int id) -> SBDebugger"""
    return _lldb.SBDebugger_FindDebuggerWithID(id)

def SBDebugger_SetInternalVariable(var_name: str, value: str, debugger_instance_name: str) -> "SBError":
    r"""SBDebugger_SetInternalVariable(char const * var_name, char const * value, char const * debugger_instance_name) -> SBError"""
    return _lldb.SBDebugger_SetInternalVariable(var_name, value, debugger_instance_name)

def SBDebugger_GetInternalVariableValue(var_name: str, debugger_instance_name: str) -> "SBStringList":
    r"""SBDebugger_GetInternalVariableValue(char const * var_name, char const * debugger_instance_name) -> SBStringList"""
    return _lldb.SBDebugger_GetInternalVariableValue(var_name, debugger_instance_name)

class SBDeclaration(object):
    r"""Specifies an association with a line and column for a variable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBDeclaration self) -> SBDeclaration
        __init__(SBDeclaration self, SBDeclaration rhs) -> SBDeclaration
        """
        _lldb.SBDeclaration_swiginit(self, _lldb.new_SBDeclaration(*args))
    __swig_destroy__ = _lldb.delete_SBDeclaration

    def __nonzero__(self):
        return _lldb.SBDeclaration___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBDeclaration self) -> bool"""
        return _lldb.SBDeclaration_IsValid(self)

    def GetFileSpec(self) -> "SBFileSpec":
        r"""GetFileSpec(SBDeclaration self) -> SBFileSpec"""
        return _lldb.SBDeclaration_GetFileSpec(self)

    def GetLine(self) -> int:
        r"""GetLine(SBDeclaration self) -> uint32_t"""
        return _lldb.SBDeclaration_GetLine(self)

    def GetColumn(self) -> int:
        r"""GetColumn(SBDeclaration self) -> uint32_t"""
        return _lldb.SBDeclaration_GetColumn(self)

    def SetFileSpec(self, filespec: "SBFileSpec"):
        r"""SetFileSpec(SBDeclaration self, SBFileSpec filespec)"""
        return _lldb.SBDeclaration_SetFileSpec(self, filespec)

    def SetLine(self, line: int):
        r"""SetLine(SBDeclaration self, uint32_t line)"""
        return _lldb.SBDeclaration_SetLine(self, line)

    def SetColumn(self, column: int):
        r"""SetColumn(SBDeclaration self, uint32_t column)"""
        return _lldb.SBDeclaration_SetColumn(self, column)

    def __eq__(self, rhs: "SBDeclaration") -> "bool":
        r"""__eq__(SBDeclaration self, SBDeclaration rhs) -> bool"""
        return _lldb.SBDeclaration___eq__(self, rhs)

    def __ne__(self, rhs: "SBDeclaration") -> "bool":
        r"""__ne__(SBDeclaration self, SBDeclaration rhs) -> bool"""
        return _lldb.SBDeclaration___ne__(self, rhs)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBDeclaration self, SBStream description) -> bool"""
        return _lldb.SBDeclaration_GetDescription(self, description)

    def __repr__(self) -> str:
        r"""__repr__(SBDeclaration self) -> std::string"""
        return _lldb.SBDeclaration___repr__(self)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    file = property(GetFileSpec, None, doc='''A read only property that returns an lldb object that represents the file (lldb.SBFileSpec) for this line entry.''')
    line = property(GetLine, None, doc='''A read only property that returns the 1 based line number for this line entry, a return value of zero indicates that no line information is available.''')
    column = property(GetColumn, None, doc='''A read only property that returns the 1 based column number for this line entry, a return value of zero indicates that no column information is available.''')


    def __eq__(self, rhs):
        if not isinstance(rhs, type(self)):
            return False

        return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)

    def __ne__(self, rhs):
        if not isinstance(rhs, type(self)):
            return True

        return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)


# Register SBDeclaration in _lldb:
_lldb.SBDeclaration_swigregister(SBDeclaration)

class SBError(object):
    r"""
    Represents a container for holding any error code.

    For example (from test/python_api/hello_world/TestHelloWorld.py), ::

        def hello_world_attach_with_id_api(self):
            '''Create target, spawn a process, and attach to it by id.'''

            target = self.dbg.CreateTarget(self.exe)

            # Spawn a new process and don't display the stdout if not in TraceOn() mode.
            import subprocess
            popen = subprocess.Popen([self.exe, 'abc', 'xyz'],
                                     stdout = open(os.devnull, 'w') if not self.TraceOn() else None)

            listener = lldb.SBListener('my.attach.listener')
            error = lldb.SBError()
            process = target.AttachToProcessWithID(listener, popen.pid, error)

            self.assertTrue(error.Success() and process, PROCESS_IS_VALID)

            # Let's check the stack traces of the attached process.
            import lldbutil
            stacktraces = lldbutil.print_stacktraces(process, string_buffer=True)
            self.expect(stacktraces, exe=False,
                substrs = ['main.c:%d' % self.line2,
                           '(int)argc=3'])

            listener = lldb.SBListener('my.attach.listener')
            error = lldb.SBError()
            process = target.AttachToProcessWithID(listener, popen.pid, error)

            self.assertTrue(error.Success() and process, PROCESS_IS_VALID)

    checks that after the attach, there is no error condition by asserting
    that error.Success() is True and we get back a valid process object.

    And (from test/python_api/event/TestEvent.py), ::

            # Now launch the process, and do not stop at entry point.
            error = lldb.SBError()
            process = target.Launch(listener, None, None, None, None, None, None, 0, False, error)
            self.assertTrue(error.Success() and process, PROCESS_IS_VALID)

    checks that after calling the target.Launch() method there's no error
    condition and we get back a void process object.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBError self) -> SBError
        __init__(SBError self, SBError rhs) -> SBError
        __init__(SBError self, char const * message) -> SBError
        """
        _lldb.SBError_swiginit(self, _lldb.new_SBError(*args))
    __swig_destroy__ = _lldb.delete_SBError

    def GetCString(self) -> str:
        r"""GetCString(SBError self) -> char const *"""
        return _lldb.SBError_GetCString(self)

    def Clear(self):
        r"""Clear(SBError self)"""
        return _lldb.SBError_Clear(self)

    def Fail(self) -> "bool":
        r"""Fail(SBError self) -> bool"""
        return _lldb.SBError_Fail(self)

    def Success(self) -> "bool":
        r"""Success(SBError self) -> bool"""
        return _lldb.SBError_Success(self)

    def GetError(self) -> int:
        r"""GetError(SBError self) -> uint32_t"""
        return _lldb.SBError_GetError(self)

    def GetType(self) -> "lldb::ErrorType":
        r"""GetType(SBError self) -> lldb::ErrorType"""
        return _lldb.SBError_GetType(self)

    def SetError(self, err: int, type: "lldb::ErrorType"):
        r"""SetError(SBError self, uint32_t err, lldb::ErrorType type)"""
        return _lldb.SBError_SetError(self, err, type)

    def SetErrorToErrno(self):
        r"""SetErrorToErrno(SBError self)"""
        return _lldb.SBError_SetErrorToErrno(self)

    def SetErrorToGenericError(self):
        r"""SetErrorToGenericError(SBError self)"""
        return _lldb.SBError_SetErrorToGenericError(self)

    def SetErrorString(self, err_str: str):
        r"""SetErrorString(SBError self, char const * err_str)"""
        return _lldb.SBError_SetErrorString(self, err_str)

    def SetErrorStringWithFormat(self, format: str, str1: "char *"=None, str2: "char *"=None, str3: "char *"=None) -> "int":
        r"""SetErrorStringWithFormat(SBError self, char const * format, char * str1=None, char * str2=None, char * str3=None) -> int"""
        return _lldb.SBError_SetErrorStringWithFormat(self, format, str1, str2, str3)

    def __nonzero__(self):
        return _lldb.SBError___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBError self) -> bool"""
        return _lldb.SBError_IsValid(self)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBError self, SBStream description) -> bool"""
        return _lldb.SBError_GetDescription(self, description)

    def __repr__(self) -> str:
        r"""__repr__(SBError self) -> std::string"""
        return _lldb.SBError___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        return self.GetError()

    def __hex__(self):
        return self.GetError()

    def __oct__(self):
        return self.GetError()

    def __len__(self):
        pass

    def __iter__(self):
        pass

    value = property(GetError, None, doc='''A read only property that returns the same result as GetError().''')
    fail = property(Fail, None, doc='''A read only property that returns the same result as Fail().''')
    success = property(Success, None, doc='''A read only property that returns the same result as Success().''')
    description = property(GetCString, None, doc='''A read only property that returns the same result as GetCString().''')
    type = property(GetType, None, doc='''A read only property that returns the same result as GetType().''')


# Register SBError in _lldb:
_lldb.SBError_swigregister(SBError)

class SBEnvironment(object):
    r"""
    Represents the environment of a certain process.

    Example: ::

      for entry in lldb.debugger.GetSelectedTarget().GetEnvironment().GetEntries():
        print(entry)


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBEnvironment self) -> SBEnvironment
        __init__(SBEnvironment self, SBEnvironment rhs) -> SBEnvironment
        """
        _lldb.SBEnvironment_swiginit(self, _lldb.new_SBEnvironment(*args))
    __swig_destroy__ = _lldb.delete_SBEnvironment

    def Get(self, name: str) -> str:
        r"""Get(SBEnvironment self, char const * name) -> char const *"""
        return _lldb.SBEnvironment_Get(self, name)

    def GetNumValues(self) -> "size_t":
        r"""GetNumValues(SBEnvironment self) -> size_t"""
        return _lldb.SBEnvironment_GetNumValues(self)

    def GetNameAtIndex(self, index: "size_t") -> str:
        r"""GetNameAtIndex(SBEnvironment self, size_t index) -> char const *"""
        return _lldb.SBEnvironment_GetNameAtIndex(self, index)

    def GetValueAtIndex(self, index: "size_t") -> str:
        r"""GetValueAtIndex(SBEnvironment self, size_t index) -> char const *"""
        return _lldb.SBEnvironment_GetValueAtIndex(self, index)

    def GetEntries(self) -> "SBStringList":
        r"""GetEntries(SBEnvironment self) -> SBStringList"""
        return _lldb.SBEnvironment_GetEntries(self)

    def PutEntry(self, name_and_value: str):
        r"""PutEntry(SBEnvironment self, char const * name_and_value)"""
        return _lldb.SBEnvironment_PutEntry(self, name_and_value)

    def SetEntries(self, entries: "SBStringList", append: "bool"):
        r"""SetEntries(SBEnvironment self, SBStringList entries, bool append)"""
        return _lldb.SBEnvironment_SetEntries(self, entries, append)

    def Set(self, name: str, value: str, overwrite: "bool") -> "bool":
        r"""Set(SBEnvironment self, char const * name, char const * value, bool overwrite) -> bool"""
        return _lldb.SBEnvironment_Set(self, name, value, overwrite)

    def Unset(self, name: str) -> "bool":
        r"""Unset(SBEnvironment self, char const * name) -> bool"""
        return _lldb.SBEnvironment_Unset(self, name)

    def Clear(self):
        r"""Clear(SBEnvironment self)"""
        return _lldb.SBEnvironment_Clear(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBEnvironment in _lldb:
_lldb.SBEnvironment_swigregister(SBEnvironment)

class SBEvent(object):
    r"""
    API clients can register to receive events.

    For example, check out the following output: ::

        Try wait for event...
        Event description: 0x103d0bb70 Event: broadcaster = 0x1009c8410, type = 0x00000001, data = { process = 0x1009c8400 (pid = 21528), state = running}
        Event data flavor: Process::ProcessEventData
        Process state: running

        Try wait for event...
        Event description: 0x103a700a0 Event: broadcaster = 0x1009c8410, type = 0x00000001, data = { process = 0x1009c8400 (pid = 21528), state = stopped}
        Event data flavor: Process::ProcessEventData
        Process state: stopped

        Try wait for event...
        Event description: 0x103d0d4a0 Event: broadcaster = 0x1009c8410, type = 0x00000001, data = { process = 0x1009c8400 (pid = 21528), state = exited}
        Event data flavor: Process::ProcessEventData
        Process state: exited

        Try wait for event...
        timeout occurred waiting for event...

    from test/python_api/event/TestEventspy: ::

        def do_listen_for_and_print_event(self):
            '''Create a listener and use SBEvent API to print the events received.'''
            exe = os.path.join(os.getcwd(), 'a.out')

            # Create a target by the debugger.
            target = self.dbg.CreateTarget(exe)
            self.assertTrue(target, VALID_TARGET)

            # Now create a breakpoint on main.c by name 'c'.
            breakpoint = target.BreakpointCreateByName('c', 'a.out')

            # Now launch the process, and do not stop at the entry point.
            process = target.LaunchSimple(None, None, os.getcwd())
            self.assertTrue(process.GetState() == lldb.eStateStopped,
                            PROCESS_STOPPED)

            # Get a handle on the process's broadcaster.
            broadcaster = process.GetBroadcaster()

            # Create an empty event object.
            event = lldb.SBEvent()

            # Create a listener object and register with the broadcaster.
            listener = lldb.SBListener('my listener')
            rc = broadcaster.AddListener(listener, lldb.SBProcess.eBroadcastBitStateChanged)
            self.assertTrue(rc, 'AddListener successfully retruns')

            traceOn = self.TraceOn()
            if traceOn:
                lldbutil.print_stacktraces(process)

            # Create MyListeningThread class to wait for any kind of event.
            import threading
            class MyListeningThread(threading.Thread):
                def run(self):
                    count = 0
                    # Let's only try at most 4 times to retrieve any kind of event.
                    # After that, the thread exits.
                    while not count > 3:
                        if traceOn:
                            print('Try wait for event...')
                        if listener.WaitForEventForBroadcasterWithType(5,
                                                                       broadcaster,
                                                                       lldb.SBProcess.eBroadcastBitStateChanged,
                                                                       event):
                            if traceOn:
                                desc = lldbutil.get_description(event))
                                print('Event description:', desc)
                                print('Event data flavor:', event.GetDataFlavor())
                                print('Process state:', lldbutil.state_type_to_str(process.GetState()))
                                print()
                        else:
                            if traceOn:
                                print 'timeout occurred waiting for event...'
                        count = count + 1
                    return

            # Let's start the listening thread to retrieve the events.
            my_thread = MyListeningThread()
            my_thread.start()

            # Use Python API to continue the process.  The listening thread should be
            # able to receive the state changed events.
            process.Continue()

            # Use Python API to kill the process.  The listening thread should be
            # able to receive the state changed event, too.
            process.Kill()

            # Wait until the 'MyListeningThread' terminates.
            my_thread.join()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""__init__(self, int type, str data) -> SBEvent (make an event that contains a C string)__init__(self, int type, str data) -> SBEvent (make an event that contains a C string)__init__(self, int type, str data) -> SBEvent (make an event that contains a C string)"""
        _lldb.SBEvent_swiginit(self, _lldb.new_SBEvent(*args))
    __swig_destroy__ = _lldb.delete_SBEvent

    def __nonzero__(self):
        return _lldb.SBEvent___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBEvent self) -> bool"""
        return _lldb.SBEvent_IsValid(self)

    def GetDataFlavor(self) -> str:
        r"""GetDataFlavor(SBEvent self) -> char const *"""
        return _lldb.SBEvent_GetDataFlavor(self)

    def GetType(self) -> int:
        r"""GetType(SBEvent self) -> uint32_t"""
        return _lldb.SBEvent_GetType(self)

    def GetBroadcaster(self) -> "SBBroadcaster":
        r"""GetBroadcaster(SBEvent self) -> SBBroadcaster"""
        return _lldb.SBEvent_GetBroadcaster(self)

    def GetBroadcasterClass(self) -> str:
        r"""GetBroadcasterClass(SBEvent self) -> char const *"""
        return _lldb.SBEvent_GetBroadcasterClass(self)

    def BroadcasterMatchesRef(self, broadcaster: "SBBroadcaster") -> "bool":
        r"""BroadcasterMatchesRef(SBEvent self, SBBroadcaster broadcaster) -> bool"""
        return _lldb.SBEvent_BroadcasterMatchesRef(self, broadcaster)

    def Clear(self):
        r"""Clear(SBEvent self)"""
        return _lldb.SBEvent_Clear(self)

    @staticmethod
    def GetCStringFromEvent(event: "SBEvent") -> str:
        r"""GetCStringFromEvent(SBEvent event) -> char const *"""
        return _lldb.SBEvent_GetCStringFromEvent(event)

    def GetDescription(self, *args) -> "bool":
        r"""
        GetDescription(SBEvent self, SBStream description) -> bool
        GetDescription(SBEvent self, SBStream description) -> bool
        """
        return _lldb.SBEvent_GetDescription(self, *args)

    def __repr__(self) -> str:
        r"""__repr__(SBEvent self) -> std::string"""
        return _lldb.SBEvent___repr__(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBEvent in _lldb:
_lldb.SBEvent_swigregister(SBEvent)

def SBEvent_GetCStringFromEvent(event: "SBEvent") -> str:
    r"""SBEvent_GetCStringFromEvent(SBEvent event) -> char const *"""
    return _lldb.SBEvent_GetCStringFromEvent(event)

class SBExecutionContext(object):
    r"""Describes the program context in which a command should be executed."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBExecutionContext self) -> SBExecutionContext
        __init__(SBExecutionContext self, SBExecutionContext rhs) -> SBExecutionContext
        __init__(SBExecutionContext self, SBTarget target) -> SBExecutionContext
        __init__(SBExecutionContext self, SBProcess process) -> SBExecutionContext
        __init__(SBExecutionContext self, SBThread thread) -> SBExecutionContext
        __init__(SBExecutionContext self, SBFrame frame) -> SBExecutionContext
        """
        _lldb.SBExecutionContext_swiginit(self, _lldb.new_SBExecutionContext(*args))
    __swig_destroy__ = _lldb.delete_SBExecutionContext

    def GetTarget(self) -> "SBTarget":
        r"""GetTarget(SBExecutionContext self) -> SBTarget"""
        return _lldb.SBExecutionContext_GetTarget(self)

    def GetProcess(self) -> "SBProcess":
        r"""GetProcess(SBExecutionContext self) -> SBProcess"""
        return _lldb.SBExecutionContext_GetProcess(self)

    def GetThread(self) -> "SBThread":
        r"""GetThread(SBExecutionContext self) -> SBThread"""
        return _lldb.SBExecutionContext_GetThread(self)

    def GetFrame(self) -> "SBFrame":
        r"""GetFrame(SBExecutionContext self) -> SBFrame"""
        return _lldb.SBExecutionContext_GetFrame(self)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    target = property(GetTarget, None, doc='''A read only property that returns the same result as GetTarget().''')
    process = property(GetProcess, None, doc='''A read only property that returns the same result as GetProcess().''')
    thread = property(GetThread, None, doc='''A read only property that returns the same result as GetThread().''')
    frame = property(GetFrame, None, doc='''A read only property that returns the same result as GetFrame().''')


# Register SBExecutionContext in _lldb:
_lldb.SBExecutionContext_swigregister(SBExecutionContext)

class SBExpressionOptions(object):
    r"""A container for options to use when evaluating expressions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBExpressionOptions self) -> SBExpressionOptions
        __init__(SBExpressionOptions self, SBExpressionOptions rhs) -> SBExpressionOptions
        """
        _lldb.SBExpressionOptions_swiginit(self, _lldb.new_SBExpressionOptions(*args))
    __swig_destroy__ = _lldb.delete_SBExpressionOptions

    def GetCoerceResultToId(self) -> "bool":
        r"""GetCoerceResultToId(SBExpressionOptions self) -> bool"""
        return _lldb.SBExpressionOptions_GetCoerceResultToId(self)

    def SetCoerceResultToId(self, coerce: "bool"=True):
        r"""
        SetCoerceResultToId(SBExpressionOptions self, bool coerce=True)
        Sets whether to coerce the expression result to ObjC id type after evaluation.
        """
        return _lldb.SBExpressionOptions_SetCoerceResultToId(self, coerce)

    def GetUnwindOnError(self) -> "bool":
        r"""GetUnwindOnError(SBExpressionOptions self) -> bool"""
        return _lldb.SBExpressionOptions_GetUnwindOnError(self)

    def SetUnwindOnError(self, unwind: "bool"=True):
        r"""
        SetUnwindOnError(SBExpressionOptions self, bool unwind=True)
        Sets whether to unwind the expression stack on error.
        """
        return _lldb.SBExpressionOptions_SetUnwindOnError(self, unwind)

    def GetIgnoreBreakpoints(self) -> "bool":
        r"""GetIgnoreBreakpoints(SBExpressionOptions self) -> bool"""
        return _lldb.SBExpressionOptions_GetIgnoreBreakpoints(self)

    def SetIgnoreBreakpoints(self, ignore: "bool"=True):
        r"""
        SetIgnoreBreakpoints(SBExpressionOptions self, bool ignore=True)
        Sets whether to ignore breakpoint hits while running expressions.
        """
        return _lldb.SBExpressionOptions_SetIgnoreBreakpoints(self, ignore)

    def GetFetchDynamicValue(self) -> "lldb::DynamicValueType":
        r"""GetFetchDynamicValue(SBExpressionOptions self) -> lldb::DynamicValueType"""
        return _lldb.SBExpressionOptions_GetFetchDynamicValue(self)

    def SetFetchDynamicValue(self, *args):
        r"""
        SetFetchDynamicValue(SBExpressionOptions self, lldb::DynamicValueType dynamic=eDynamicCanRunTarget)
        Sets whether to cast the expression result to its dynamic type.
        """
        return _lldb.SBExpressionOptions_SetFetchDynamicValue(self, *args)

    def GetTimeoutInMicroSeconds(self) -> int:
        r"""GetTimeoutInMicroSeconds(SBExpressionOptions self) -> uint32_t"""
        return _lldb.SBExpressionOptions_GetTimeoutInMicroSeconds(self)

    def SetTimeoutInMicroSeconds(self, timeout: int=0):
        r"""
        SetTimeoutInMicroSeconds(SBExpressionOptions self, uint32_t timeout=0)
        Sets the timeout in microseconds to run the expression for. If try all threads is set to true and the expression doesn't complete within the specified timeout, all threads will be resumed for the same timeout to see if the expression will finish.
        """
        return _lldb.SBExpressionOptions_SetTimeoutInMicroSeconds(self, timeout)

    def GetOneThreadTimeoutInMicroSeconds(self) -> int:
        r"""GetOneThreadTimeoutInMicroSeconds(SBExpressionOptions self) -> uint32_t"""
        return _lldb.SBExpressionOptions_GetOneThreadTimeoutInMicroSeconds(self)

    def SetOneThreadTimeoutInMicroSeconds(self, timeout: int=0):
        r"""
        SetOneThreadTimeoutInMicroSeconds(SBExpressionOptions self, uint32_t timeout=0)
        Sets the timeout in microseconds to run the expression on one thread before either timing out or trying all threads.
        """
        return _lldb.SBExpressionOptions_SetOneThreadTimeoutInMicroSeconds(self, timeout)

    def GetTryAllThreads(self) -> "bool":
        r"""GetTryAllThreads(SBExpressionOptions self) -> bool"""
        return _lldb.SBExpressionOptions_GetTryAllThreads(self)

    def SetTryAllThreads(self, run_others: "bool"=True):
        r"""
        SetTryAllThreads(SBExpressionOptions self, bool run_others=True)
        Sets whether to run all threads if the expression does not complete on one thread.
        """
        return _lldb.SBExpressionOptions_SetTryAllThreads(self, run_others)

    def GetStopOthers(self) -> "bool":
        r"""GetStopOthers(SBExpressionOptions self) -> bool"""
        return _lldb.SBExpressionOptions_GetStopOthers(self)

    def SetStopOthers(self, stop_others: "bool"=True):
        r"""
        SetStopOthers(SBExpressionOptions self, bool stop_others=True)
        Sets whether to stop other threads at all while running expressions.  If false, TryAllThreads does nothing.
        """
        return _lldb.SBExpressionOptions_SetStopOthers(self, stop_others)

    def GetTrapExceptions(self) -> "bool":
        r"""GetTrapExceptions(SBExpressionOptions self) -> bool"""
        return _lldb.SBExpressionOptions_GetTrapExceptions(self)

    def SetTrapExceptions(self, trap_exceptions: "bool"=True):
        r"""
        SetTrapExceptions(SBExpressionOptions self, bool trap_exceptions=True)
        Sets whether to abort expression evaluation if an exception is thrown while executing.  Don't set this to false unless you know the function you are calling traps all exceptions itself.
        """
        return _lldb.SBExpressionOptions_SetTrapExceptions(self, trap_exceptions)

    def SetLanguage(self, language: "lldb::LanguageType"):
        r"""
        SetLanguage(SBExpressionOptions self, lldb::LanguageType language)
        Sets the language that LLDB should assume the expression is written in
        """
        return _lldb.SBExpressionOptions_SetLanguage(self, language)

    def GetGenerateDebugInfo(self) -> "bool":
        r"""GetGenerateDebugInfo(SBExpressionOptions self) -> bool"""
        return _lldb.SBExpressionOptions_GetGenerateDebugInfo(self)

    def SetGenerateDebugInfo(self, b: "bool"=True):
        r"""
        SetGenerateDebugInfo(SBExpressionOptions self, bool b=True)
        Sets whether to generate debug information for the expression and also controls if a SBModule is generated.
        """
        return _lldb.SBExpressionOptions_SetGenerateDebugInfo(self, b)

    def GetSuppressPersistentResult(self) -> "bool":
        r"""GetSuppressPersistentResult(SBExpressionOptions self) -> bool"""
        return _lldb.SBExpressionOptions_GetSuppressPersistentResult(self)

    def SetSuppressPersistentResult(self, b: "bool"=False):
        r"""
        SetSuppressPersistentResult(SBExpressionOptions self, bool b=False)
        Sets whether to produce a persistent result that can be used in future expressions.
        """
        return _lldb.SBExpressionOptions_SetSuppressPersistentResult(self, b)

    def GetPrefix(self) -> str:
        r"""
        GetPrefix(SBExpressionOptions self) -> char const *
        Gets the prefix to use for this expression.
        """
        return _lldb.SBExpressionOptions_GetPrefix(self)

    def SetPrefix(self, prefix: str):
        r"""
        SetPrefix(SBExpressionOptions self, char const * prefix)
        Sets the prefix to use for this expression. This prefix gets inserted after the 'target.expr-prefix' prefix contents, but before the wrapped expression function body.
        """
        return _lldb.SBExpressionOptions_SetPrefix(self, prefix)

    def SetAutoApplyFixIts(self, b: "bool"=True):
        r"""
        SetAutoApplyFixIts(SBExpressionOptions self, bool b=True)
        Sets whether to auto-apply fix-it hints to the expression being evaluated.
        """
        return _lldb.SBExpressionOptions_SetAutoApplyFixIts(self, b)

    def GetAutoApplyFixIts(self) -> "bool":
        r"""
        GetAutoApplyFixIts(SBExpressionOptions self) -> bool
        Gets whether to auto-apply fix-it hints to an expression.
        """
        return _lldb.SBExpressionOptions_GetAutoApplyFixIts(self)

    def SetRetriesWithFixIts(self, retries: int):
        r"""
        SetRetriesWithFixIts(SBExpressionOptions self, uint64_t retries)
        Sets how often LLDB should retry applying fix-its to an expression.
        """
        return _lldb.SBExpressionOptions_SetRetriesWithFixIts(self, retries)

    def GetRetriesWithFixIts(self) -> int:
        r"""
        GetRetriesWithFixIts(SBExpressionOptions self) -> uint64_t
        Gets how often LLDB will retry applying fix-its to an expression.
        """
        return _lldb.SBExpressionOptions_GetRetriesWithFixIts(self)

    def GetTopLevel(self) -> "bool":
        r"""GetTopLevel(SBExpressionOptions self) -> bool"""
        return _lldb.SBExpressionOptions_GetTopLevel(self)

    def SetTopLevel(self, b: "bool"=True):
        r"""SetTopLevel(SBExpressionOptions self, bool b=True)"""
        return _lldb.SBExpressionOptions_SetTopLevel(self, b)

    def GetAllowJIT(self) -> "bool":
        r"""
        GetAllowJIT(SBExpressionOptions self) -> bool
        Gets whether to JIT an expression if it cannot be interpreted.
        """
        return _lldb.SBExpressionOptions_GetAllowJIT(self)

    def SetAllowJIT(self, allow: "bool"):
        r"""
        SetAllowJIT(SBExpressionOptions self, bool allow)
        Sets whether to JIT an expression if it cannot be interpreted.
        """
        return _lldb.SBExpressionOptions_SetAllowJIT(self, allow)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBExpressionOptions in _lldb:
_lldb.SBExpressionOptions_swigregister(SBExpressionOptions)

class SBFile(object):
    r"""Represents a file."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBFile self) -> SBFile
        __init__(SBFile self, lldb::FileSP file_sp) -> SBFile
        __init__(SBFile self, int fd, char const * mode, bool transfer_ownership) -> SBFile
        initialize a SBFile from a python file object
        """
        _lldb.SBFile_swiginit(self, _lldb.new_SBFile(*args))
    __swig_destroy__ = _lldb.delete_SBFile

    def Read(self, buf: "uint8_t *") -> "SBError":
        r"""Read(buffer) -> SBError, bytes_read"""
        return _lldb.SBFile_Read(self, buf)

    def Write(self, buf: "uint8_t const *") -> "SBError":
        r"""Write(buffer) -> SBError, written_read"""
        return _lldb.SBFile_Write(self, buf)

    def Flush(self) -> "SBError":
        r"""Flush(SBFile self) -> SBError"""
        return _lldb.SBFile_Flush(self)

    def IsValid(self) -> "bool":
        r"""IsValid(SBFile self) -> bool"""
        return _lldb.SBFile_IsValid(self)

    def Close(self) -> "SBError":
        r"""Close(SBFile self) -> SBError"""
        return _lldb.SBFile_Close(self)

    def __nonzero__(self):
        return _lldb.SBFile___nonzero__(self)
    __bool__ = __nonzero__



    def GetFile(self) -> "lldb::FileSP":
        r"""
        GetFile(SBFile self) -> lldb::FileSP

            Convert this SBFile into a python io.IOBase file object.

            If the SBFile is itself a wrapper around a python file object,
            this will return that original object.

            The file returned from here should be considered borrowed,
            in the sense that you may read and write to it, and flush it,
            etc, but you should not close it.   If you want to close the
            SBFile, call SBFile.Close().

            If there is no underlying python file to unwrap, GetFile will
            use the file descriptor, if available to create a new python
            file object using ``open(fd, mode=..., closefd=False)``

        """
        return _lldb.SBFile_GetFile(self)

    @staticmethod
    def MakeBorrowed(BORROWED: "lldb::FileSP") -> "SBFile":
        r"""MakeBorrowed(lldb::FileSP BORROWED) -> SBFile"""
        return _lldb.SBFile_MakeBorrowed(BORROWED)

    @staticmethod
    def MakeForcingIOMethods(FORCE_IO_METHODS: "lldb::FileSP") -> "SBFile":
        r"""MakeForcingIOMethods(lldb::FileSP FORCE_IO_METHODS) -> SBFile"""
        return _lldb.SBFile_MakeForcingIOMethods(FORCE_IO_METHODS)

    @staticmethod
    def MakeBorrowedForcingIOMethods(BORROWED_FORCE_IO_METHODS: "lldb::FileSP") -> "SBFile":
        r"""MakeBorrowedForcingIOMethods(lldb::FileSP BORROWED_FORCE_IO_METHODS) -> SBFile"""
        return _lldb.SBFile_MakeBorrowedForcingIOMethods(BORROWED_FORCE_IO_METHODS)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    @classmethod
    def Create(cls, file, borrow=False, force_io_methods=False):
        """
        Create a SBFile from a python file object, with options.

        If borrow is set then the underlying file will
        not be closed when the SBFile is closed or destroyed.

        If force_scripting_io is set then the python read/write
        methods will be called even if a file descriptor is available.
        """
        if borrow:
            if force_io_methods:
                return cls.MakeBorrowedForcingIOMethods(file)
            else:
                return cls.MakeBorrowed(file)
        else:
            if force_io_methods:
                return cls.MakeForcingIOMethods(file)
            else:
                return cls(file)


# Register SBFile in _lldb:
_lldb.SBFile_swigregister(SBFile)

def SBFile_MakeBorrowed(BORROWED: "lldb::FileSP") -> "SBFile":
    r"""SBFile_MakeBorrowed(lldb::FileSP BORROWED) -> SBFile"""
    return _lldb.SBFile_MakeBorrowed(BORROWED)

def SBFile_MakeForcingIOMethods(FORCE_IO_METHODS: "lldb::FileSP") -> "SBFile":
    r"""SBFile_MakeForcingIOMethods(lldb::FileSP FORCE_IO_METHODS) -> SBFile"""
    return _lldb.SBFile_MakeForcingIOMethods(FORCE_IO_METHODS)

def SBFile_MakeBorrowedForcingIOMethods(BORROWED_FORCE_IO_METHODS: "lldb::FileSP") -> "SBFile":
    r"""SBFile_MakeBorrowedForcingIOMethods(lldb::FileSP BORROWED_FORCE_IO_METHODS) -> SBFile"""
    return _lldb.SBFile_MakeBorrowedForcingIOMethods(BORROWED_FORCE_IO_METHODS)

class SBFileSpec(object):
    r"""
    Represents a file specification that divides the path into a directory and
    basename.  The string values of the paths are put into uniqued string pools
    for fast comparisons and efficient memory usage.

    For example, the following code ::

            lineEntry = context.GetLineEntry()
            self.expect(lineEntry.GetFileSpec().GetDirectory(), 'The line entry should have the correct directory',
                        exe=False,
                substrs = [self.mydir])
            self.expect(lineEntry.GetFileSpec().GetFilename(), 'The line entry should have the correct filename',
                        exe=False,
                substrs = ['main.c'])
            self.assertTrue(lineEntry.GetLine() == self.line,
                            'The line entry's line number should match ')

    gets the line entry from the symbol context when a thread is stopped.
    It gets the file spec corresponding to the line entry and checks that
    the filename and the directory matches what we expect.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBFileSpec self) -> SBFileSpec
        __init__(SBFileSpec self, SBFileSpec rhs) -> SBFileSpec
        __init__(SBFileSpec self, char const * path) -> SBFileSpec
        __init__(SBFileSpec self, char const * path, bool resolve) -> SBFileSpec
        """
        _lldb.SBFileSpec_swiginit(self, _lldb.new_SBFileSpec(*args))
    __swig_destroy__ = _lldb.delete_SBFileSpec

    def __nonzero__(self):
        return _lldb.SBFileSpec___nonzero__(self)
    __bool__ = __nonzero__



    def __eq__(self, rhs: "SBFileSpec") -> "bool":
        r"""__eq__(SBFileSpec self, SBFileSpec rhs) -> bool"""
        return _lldb.SBFileSpec___eq__(self, rhs)

    def __ne__(self, rhs: "SBFileSpec") -> "bool":
        r"""__ne__(SBFileSpec self, SBFileSpec rhs) -> bool"""
        return _lldb.SBFileSpec___ne__(self, rhs)

    def IsValid(self) -> "bool":
        r"""IsValid(SBFileSpec self) -> bool"""
        return _lldb.SBFileSpec_IsValid(self)

    def Exists(self) -> "bool":
        r"""Exists(SBFileSpec self) -> bool"""
        return _lldb.SBFileSpec_Exists(self)

    def ResolveExecutableLocation(self) -> "bool":
        r"""ResolveExecutableLocation(SBFileSpec self) -> bool"""
        return _lldb.SBFileSpec_ResolveExecutableLocation(self)

    def GetFilename(self) -> str:
        r"""GetFilename(SBFileSpec self) -> char const *"""
        return _lldb.SBFileSpec_GetFilename(self)

    def GetDirectory(self) -> str:
        r"""GetDirectory(SBFileSpec self) -> char const *"""
        return _lldb.SBFileSpec_GetDirectory(self)

    def SetFilename(self, filename: str):
        r"""SetFilename(SBFileSpec self, char const * filename)"""
        return _lldb.SBFileSpec_SetFilename(self, filename)

    def SetDirectory(self, directory: str):
        r"""SetDirectory(SBFileSpec self, char const * directory)"""
        return _lldb.SBFileSpec_SetDirectory(self, directory)

    def GetPath(self, dst_path: "char *", dst_len: "size_t") -> int:
        r"""GetPath(SBFileSpec self, char * dst_path, size_t dst_len) -> uint32_t"""
        return _lldb.SBFileSpec_GetPath(self, dst_path, dst_len)

    @staticmethod
    def ResolvePath(src_path: str, dst_path: "char *", dst_len: "size_t") -> "int":
        r"""ResolvePath(char const * src_path, char * dst_path, size_t dst_len) -> int"""
        return _lldb.SBFileSpec_ResolvePath(src_path, dst_path, dst_len)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBFileSpec self, SBStream description) -> bool"""
        return _lldb.SBFileSpec_GetDescription(self, description)

    def AppendPathComponent(self, file_or_directory: str):
        r"""AppendPathComponent(SBFileSpec self, char const * file_or_directory)"""
        return _lldb.SBFileSpec_AppendPathComponent(self, file_or_directory)

    def __repr__(self) -> str:
        r"""__repr__(SBFileSpec self) -> std::string"""
        return _lldb.SBFileSpec___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    fullpath = property(str, None, doc='''A read only property that returns the fullpath as a python string.''')
    basename = property(GetFilename, None, doc='''A read only property that returns the path basename as a python string.''')
    dirname = property(GetDirectory, None, doc='''A read only property that returns the path directory name as a python string.''')
    exists = property(Exists, None, doc='''A read only property that returns a boolean value that indicates if the file exists.''')


# Register SBFileSpec in _lldb:
_lldb.SBFileSpec_swigregister(SBFileSpec)

def SBFileSpec_ResolvePath(src_path: str, dst_path: "char *", dst_len: "size_t") -> "int":
    r"""SBFileSpec_ResolvePath(char const * src_path, char * dst_path, size_t dst_len) -> int"""
    return _lldb.SBFileSpec_ResolvePath(src_path, dst_path, dst_len)

class SBFileSpecList(object):
    r"""Represents a list of :py:class:`SBFileSpec`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBFileSpecList self) -> SBFileSpecList
        __init__(SBFileSpecList self, SBFileSpecList rhs) -> SBFileSpecList
        """
        _lldb.SBFileSpecList_swiginit(self, _lldb.new_SBFileSpecList(*args))
    __swig_destroy__ = _lldb.delete_SBFileSpecList

    def GetSize(self) -> int:
        r"""GetSize(SBFileSpecList self) -> uint32_t"""
        return _lldb.SBFileSpecList_GetSize(self)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBFileSpecList self, SBStream description) -> bool"""
        return _lldb.SBFileSpecList_GetDescription(self, description)

    def Append(self, sb_file: "SBFileSpec"):
        r"""Append(SBFileSpecList self, SBFileSpec sb_file)"""
        return _lldb.SBFileSpecList_Append(self, sb_file)

    def AppendIfUnique(self, sb_file: "SBFileSpec") -> "bool":
        r"""AppendIfUnique(SBFileSpecList self, SBFileSpec sb_file) -> bool"""
        return _lldb.SBFileSpecList_AppendIfUnique(self, sb_file)

    def Clear(self):
        r"""Clear(SBFileSpecList self)"""
        return _lldb.SBFileSpecList_Clear(self)

    def FindFileIndex(self, idx: int, sb_file: "SBFileSpec", full: "bool") -> int:
        r"""FindFileIndex(SBFileSpecList self, uint32_t idx, SBFileSpec sb_file, bool full) -> uint32_t"""
        return _lldb.SBFileSpecList_FindFileIndex(self, idx, sb_file, full)

    def GetFileSpecAtIndex(self, idx: int) -> "SBFileSpec const":
        r"""GetFileSpecAtIndex(SBFileSpecList self, uint32_t idx) -> SBFileSpec"""
        return _lldb.SBFileSpecList_GetFileSpecAtIndex(self, idx)

    def __repr__(self) -> str:
        r"""__repr__(SBFileSpecList self) -> std::string"""
        return _lldb.SBFileSpecList___repr__(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      '''Return the number of FileSpec in a lldb.SBFileSpecList object.'''
      return self.GetSize()

    def __iter__(self):
      '''Iterate over all FileSpecs in a lldb.SBFileSpecList object.'''
      return lldb_iter(self, 'GetSize', 'GetFileSpecAtIndex')


# Register SBFileSpecList in _lldb:
_lldb.SBFileSpecList_swigregister(SBFileSpecList)

class SBFrame(object):
    r"""
    Represents one of the stack frames associated with a thread.

    SBThread contains SBFrame(s). For example (from test/lldbutil.py), ::

        def print_stacktrace(thread, string_buffer = False):
            '''Prints a simple stack trace of this thread.'''

            ...

            for i in range(depth):
                frame = thread.GetFrameAtIndex(i)
                function = frame.GetFunction()

                load_addr = addrs[i].GetLoadAddress(target)
                if not function:
                    file_addr = addrs[i].GetFileAddress()
                    start_addr = frame.GetSymbol().GetStartAddress().GetFileAddress()
                    symbol_offset = file_addr - start_addr
                    print >> output, '  frame #{num}: {addr:#016x} {mod}`{symbol} + {offset}'.format(
                        num=i, addr=load_addr, mod=mods[i], symbol=symbols[i], offset=symbol_offset)
                else:
                    print >> output, '  frame #{num}: {addr:#016x} {mod}`{func} at {file}:{line} {args}'.format(
                        num=i, addr=load_addr, mod=mods[i],
                        func='%s [inlined]' % funcs[i] if frame.IsInlined() else funcs[i],
                        file=files[i], line=lines[i],
                        args=get_args_as_string(frame, showFuncName=False) if not frame.IsInlined() else '()')

            ...

    And, ::

        for frame in thread:
            print frame

    See also SBThread.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBFrame self) -> SBFrame
        __init__(SBFrame self, SBFrame rhs) -> SBFrame
        """
        _lldb.SBFrame_swiginit(self, _lldb.new_SBFrame(*args))
    __swig_destroy__ = _lldb.delete_SBFrame

    def IsEqual(self, that: "SBFrame") -> "bool":
        r"""IsEqual(SBFrame self, SBFrame that) -> bool"""
        return _lldb.SBFrame_IsEqual(self, that)

    def __nonzero__(self):
        return _lldb.SBFrame___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBFrame self) -> bool"""
        return _lldb.SBFrame_IsValid(self)

    def GetFrameID(self) -> int:
        r"""GetFrameID(SBFrame self) -> uint32_t"""
        return _lldb.SBFrame_GetFrameID(self)

    def GetCFA(self) -> int:
        r"""
        GetCFA(SBFrame self) -> lldb::addr_t

            Get the Canonical Frame Address for this stack frame.
            This is the DWARF standard's definition of a CFA, a stack address
            that remains constant throughout the lifetime of the function.
            Returns an lldb::addr_t stack address, or LLDB_INVALID_ADDRESS if
            the CFA cannot be determined.
        """
        return _lldb.SBFrame_GetCFA(self)

    def GetPC(self) -> int:
        r"""GetPC(SBFrame self) -> lldb::addr_t"""
        return _lldb.SBFrame_GetPC(self)

    def SetPC(self, new_pc: int) -> "bool":
        r"""SetPC(SBFrame self, lldb::addr_t new_pc) -> bool"""
        return _lldb.SBFrame_SetPC(self, new_pc)

    def GetSP(self) -> int:
        r"""GetSP(SBFrame self) -> lldb::addr_t"""
        return _lldb.SBFrame_GetSP(self)

    def GetFP(self) -> int:
        r"""GetFP(SBFrame self) -> lldb::addr_t"""
        return _lldb.SBFrame_GetFP(self)

    def GetPCAddress(self) -> "SBAddress":
        r"""GetPCAddress(SBFrame self) -> SBAddress"""
        return _lldb.SBFrame_GetPCAddress(self)

    def GetSymbolContext(self, resolve_scope: int) -> "SBSymbolContext":
        r"""GetSymbolContext(SBFrame self, uint32_t resolve_scope) -> SBSymbolContext"""
        return _lldb.SBFrame_GetSymbolContext(self, resolve_scope)

    def GetModule(self) -> "SBModule":
        r"""GetModule(SBFrame self) -> SBModule"""
        return _lldb.SBFrame_GetModule(self)

    def GetCompileUnit(self) -> "SBCompileUnit":
        r"""GetCompileUnit(SBFrame self) -> SBCompileUnit"""
        return _lldb.SBFrame_GetCompileUnit(self)

    def GetFunction(self) -> "SBFunction":
        r"""GetFunction(SBFrame self) -> SBFunction"""
        return _lldb.SBFrame_GetFunction(self)

    def GetSymbol(self) -> "SBSymbol":
        r"""GetSymbol(SBFrame self) -> SBSymbol"""
        return _lldb.SBFrame_GetSymbol(self)

    def GetBlock(self) -> "SBBlock":
        r"""
        GetBlock(SBFrame self) -> SBBlock

            Gets the deepest block that contains the frame PC.

            See also GetFrameBlock().
        """
        return _lldb.SBFrame_GetBlock(self)

    def GetDisplayFunctionName(self) -> str:
        r"""GetDisplayFunctionName(SBFrame self) -> char const *"""
        return _lldb.SBFrame_GetDisplayFunctionName(self)

    def GetFunctionName(self, *args) -> str:
        r"""
        GetFunctionName(SBFrame self) -> char const
        GetFunctionName(SBFrame self) -> char const *

            Get the appropriate function name for this frame. Inlined functions in
            LLDB are represented by Blocks that have inlined function information, so
            just looking at the SBFunction or SBSymbol for a frame isn't enough.
            This function will return the appropriate function, symbol or inlined
            function name for the frame.

            This function returns:
            - the name of the inlined function (if there is one)
            - the name of the concrete function (if there is one)
            - the name of the symbol (if there is one)
            - NULL

            See also IsInlined().
        """
        return _lldb.SBFrame_GetFunctionName(self, *args)

    def GuessLanguage(self) -> "lldb::LanguageType":
        r"""
        GuessLanguage(SBFrame self) -> lldb::LanguageType

            Returns the language of the frame's SBFunction, or if there.
            is no SBFunction, guess the language from the mangled name.
            .
        """
        return _lldb.SBFrame_GuessLanguage(self)

    def IsInlined(self, *args) -> "bool":
        r"""
        IsInlined(SBFrame self) -> bool
        IsInlined(SBFrame self) -> bool

            Return true if this frame represents an inlined function.

            See also GetFunctionName().
        """
        return _lldb.SBFrame_IsInlined(self, *args)

    def IsArtificial(self, *args) -> "bool":
        r"""
        IsArtificial(SBFrame self) -> bool
        IsArtificial(SBFrame self) -> bool

            Return true if this frame is artificial (e.g a frame synthesized to
            capture a tail call). Local variables may not be available in an artificial
            frame.
        """
        return _lldb.SBFrame_IsArtificial(self, *args)

    def EvaluateExpression(self, *args) -> "SBValue":
        r"""
        EvaluateExpression(SBFrame self, char const * expr) -> SBValue
        EvaluateExpression(SBFrame self, char const * expr, lldb::DynamicValueType use_dynamic) -> SBValue
        EvaluateExpression(SBFrame self, char const * expr, lldb::DynamicValueType use_dynamic, bool unwind_on_error) -> SBValue
        EvaluateExpression(SBFrame self, char const * expr, SBExpressionOptions options) -> SBValue

            The version that doesn't supply a 'use_dynamic' value will use the
            target's default.
        """
        return _lldb.SBFrame_EvaluateExpression(self, *args)

    def GetFrameBlock(self) -> "SBBlock":
        r"""
        GetFrameBlock(SBFrame self) -> SBBlock

            Gets the lexical block that defines the stack frame. Another way to think
            of this is it will return the block that contains all of the variables
            for a stack frame. Inlined functions are represented as SBBlock objects
            that have inlined function information: the name of the inlined function,
            where it was called from. The block that is returned will be the first
            block at or above the block for the PC (SBFrame::GetBlock()) that defines
            the scope of the frame. When a function contains no inlined functions,
            this will be the top most lexical block that defines the function.
            When a function has inlined functions and the PC is currently
            in one of those inlined functions, this method will return the inlined
            block that defines this frame. If the PC isn't currently in an inlined
            function, the lexical block that defines the function is returned.
        """
        return _lldb.SBFrame_GetFrameBlock(self)

    def GetLineEntry(self) -> "SBLineEntry":
        r"""GetLineEntry(SBFrame self) -> SBLineEntry"""
        return _lldb.SBFrame_GetLineEntry(self)

    def GetThread(self) -> "SBThread":
        r"""GetThread(SBFrame self) -> SBThread"""
        return _lldb.SBFrame_GetThread(self)

    def Disassemble(self) -> str:
        r"""Disassemble(SBFrame self) -> char const *"""
        return _lldb.SBFrame_Disassemble(self)

    def Clear(self):
        r"""Clear(SBFrame self)"""
        return _lldb.SBFrame_Clear(self)

    def __eq__(self, rhs: "SBFrame") -> "bool":
        r"""__eq__(SBFrame self, SBFrame rhs) -> bool"""
        return _lldb.SBFrame___eq__(self, rhs)

    def __ne__(self, rhs: "SBFrame") -> "bool":
        r"""__ne__(SBFrame self, SBFrame rhs) -> bool"""
        return _lldb.SBFrame___ne__(self, rhs)

    def GetVariables(self, *args) -> "SBValueList":
        r"""
        GetVariables(SBFrame self, bool arguments, bool locals, bool statics, bool in_scope_only) -> SBValueList
        GetVariables(SBFrame self, bool arguments, bool locals, bool statics, bool in_scope_only, lldb::DynamicValueType use_dynamic) -> SBValueList
        GetVariables(SBFrame self, SBVariablesOptions options) -> SBValueList

            The version that doesn't supply a 'use_dynamic' value will use the
            target's default.
        """
        return _lldb.SBFrame_GetVariables(self, *args)

    def GetRegisters(self) -> "SBValueList":
        r"""GetRegisters(SBFrame self) -> SBValueList"""
        return _lldb.SBFrame_GetRegisters(self)

    def FindRegister(self, name: str) -> "SBValue":
        r"""FindRegister(SBFrame self, char const * name) -> SBValue"""
        return _lldb.SBFrame_FindRegister(self, name)

    def FindVariable(self, *args) -> "SBValue":
        r"""
        FindVariable(SBFrame self, char const * var_name) -> SBValue
        FindVariable(SBFrame self, char const * var_name, lldb::DynamicValueType use_dynamic) -> SBValue

            The version that doesn't supply a 'use_dynamic' value will use the
            target's default.
        """
        return _lldb.SBFrame_FindVariable(self, *args)

    def GetValueForVariablePath(self, *args) -> "SBValue":
        r"""
        GetValueForVariablePath(SBFrame self, char const * var_expr_cstr, lldb::DynamicValueType use_dynamic) -> SBValue
        GetValueForVariablePath(SBFrame self, char const * var_path) -> SBValue

            Get a lldb.SBValue for a variable path.

            Variable paths can include access to pointer or instance members: ::

                rect_ptr->origin.y
                pt.x

            Pointer dereferences: ::

                *this->foo_ptr
                **argv

            Address of: ::

                &pt
                &my_array[3].x

            Array accesses and treating pointers as arrays: ::

                int_array[1]
                pt_ptr[22].x

            Unlike `EvaluateExpression()` which returns :py:class:`SBValue` objects
            with constant copies of the values at the time of evaluation,
            the result of this function is a value that will continue to
            track the current value of the value as execution progresses
            in the current frame.
        """
        return _lldb.SBFrame_GetValueForVariablePath(self, *args)

    def FindValue(self, *args) -> "SBValue":
        r"""
        FindValue(SBFrame self, char const * name, lldb::ValueType value_type) -> SBValue
        FindValue(SBFrame self, char const * name, lldb::ValueType value_type, lldb::DynamicValueType use_dynamic) -> SBValue

            Find variables, register sets, registers, or persistent variables using
            the frame as the scope.

            The version that doesn't supply a ``use_dynamic`` value will use the
            target's default.
        """
        return _lldb.SBFrame_FindValue(self, *args)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBFrame self, SBStream description) -> bool"""
        return _lldb.SBFrame_GetDescription(self, description)

    def __repr__(self) -> str:
        r"""__repr__(SBFrame self) -> std::string"""
        return _lldb.SBFrame___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    def get_all_variables(self):
        return self.GetVariables(True,True,True,True)

    def get_parent_frame(self):
        parent_idx = self.idx + 1
        if parent_idx >= 0 and parent_idx < len(self.thread.frame):
            return self.thread.frame[parent_idx]
        else:
            return SBFrame()

    def get_arguments(self):
        return self.GetVariables(True,False,False,False)

    def get_locals(self):
        return self.GetVariables(False,True,False,False)

    def get_statics(self):
        return self.GetVariables(False,False,True,False)

    def var(self, var_expr_path):
        '''Calls through to lldb.SBFrame.GetValueForVariablePath() and returns
        a value that represents the variable expression path'''
        return self.GetValueForVariablePath(var_expr_path)

    def get_registers_access(self):
        class registers_access(object):
            '''A helper object that exposes a flattened view of registers, masking away the notion of register sets for easy scripting.'''
            def __init__(self, regs):
                self.regs = regs

            def __getitem__(self, key):
                if type(key) is str:
                    for i in range(0,len(self.regs)):
                        rs = self.regs[i]
                        for j in range (0,rs.num_children):
                            reg = rs.GetChildAtIndex(j)
                            if reg.name == key: return reg
                else:
                    return lldb.SBValue()

        return registers_access(self.registers)

    pc = property(GetPC, SetPC)
    addr = property(GetPCAddress, None, doc='''A read only property that returns the program counter (PC) as a section offset address (lldb.SBAddress).''')
    fp = property(GetFP, None, doc='''A read only property that returns the frame pointer (FP) as an unsigned integer.''')
    sp = property(GetSP, None, doc='''A read only property that returns the stack pointer (SP) as an unsigned integer.''')
    module = property(GetModule, None, doc='''A read only property that returns an lldb object that represents the module (lldb.SBModule) for this stack frame.''')
    compile_unit = property(GetCompileUnit, None, doc='''A read only property that returns an lldb object that represents the compile unit (lldb.SBCompileUnit) for this stack frame.''')
    function = property(GetFunction, None, doc='''A read only property that returns an lldb object that represents the function (lldb.SBFunction) for this stack frame.''')
    symbol = property(GetSymbol, None, doc='''A read only property that returns an lldb object that represents the symbol (lldb.SBSymbol) for this stack frame.''')
    block = property(GetBlock, None, doc='''A read only property that returns an lldb object that represents the block (lldb.SBBlock) for this stack frame.''')
    is_inlined = property(IsInlined, None, doc='''A read only property that returns an boolean that indicates if the block frame is an inlined function.''')
    name = property(GetFunctionName, None, doc='''A read only property that retuns the name for the function that this frame represents. Inlined stack frame might have a concrete function that differs from the name of the inlined function (a named lldb.SBBlock).''')
    line_entry = property(GetLineEntry, None, doc='''A read only property that returns an lldb object that represents the line table entry (lldb.SBLineEntry) for this stack frame.''')
    thread = property(GetThread, None, doc='''A read only property that returns an lldb object that represents the thread (lldb.SBThread) for this stack frame.''')
    disassembly = property(Disassemble, None, doc='''A read only property that returns the disassembly for this stack frame as a python string.''')
    idx = property(GetFrameID, None, doc='''A read only property that returns the zero based stack frame index.''')
    variables = property(get_all_variables, None, doc='''A read only property that returns a list() that contains a collection of lldb.SBValue objects that represent the variables in this stack frame.''')
    vars = property(get_all_variables, None, doc='''A read only property that returns a list() that contains a collection of lldb.SBValue objects that represent the variables in this stack frame.''')
    locals = property(get_locals, None, doc='''A read only property that returns a list() that contains a collection of lldb.SBValue objects that represent the local variables in this stack frame.''')
    args = property(get_arguments, None, doc='''A read only property that returns a list() that contains a collection of lldb.SBValue objects that represent the argument variables in this stack frame.''')
    arguments = property(get_arguments, None, doc='''A read only property that returns a list() that contains a collection of lldb.SBValue objects that represent the argument variables in this stack frame.''')
    statics = property(get_statics, None, doc='''A read only property that returns a list() that contains a collection of lldb.SBValue objects that represent the static variables in this stack frame.''')
    registers = property(GetRegisters, None, doc='''A read only property that returns a list() that contains a collection of lldb.SBValue objects that represent the CPU registers for this stack frame.''')
    regs = property(GetRegisters, None, doc='''A read only property that returns a list() that contains a collection of lldb.SBValue objects that represent the CPU registers for this stack frame.''')
    register = property(get_registers_access, None, doc='''A read only property that returns an helper object providing a flattened indexable view of the CPU registers for this stack frame.''')
    reg = property(get_registers_access, None, doc='''A read only property that returns an helper object providing a flattened indexable view of the CPU registers for this stack frame''')
    parent = property(get_parent_frame, None, doc='''A read only property that returns the parent (caller) frame of the current frame.''')


# Register SBFrame in _lldb:
_lldb.SBFrame_swigregister(SBFrame)

class SBFunction(object):
    r"""
    Represents a generic function, which can be inlined or not.

    For example (from test/lldbutil.py, but slightly modified for doc purpose),::

            ...

            frame = thread.GetFrameAtIndex(i)
            addr = frame.GetPCAddress()
            load_addr = addr.GetLoadAddress(target)
            function = frame.GetFunction()
            mod_name = frame.GetModule().GetFileSpec().GetFilename()

            if not function:
                # No debug info for 'function'.
                symbol = frame.GetSymbol()
                file_addr = addr.GetFileAddress()
                start_addr = symbol.GetStartAddress().GetFileAddress()
                symbol_name = symbol.GetName()
                symbol_offset = file_addr - start_addr
                print >> output, '  frame #{num}: {addr:#016x} {mod}`{symbol} + {offset}'.format(
                    num=i, addr=load_addr, mod=mod_name, symbol=symbol_name, offset=symbol_offset)
            else:
                # Debug info is available for 'function'.
                func_name = frame.GetFunctionName()
                file_name = frame.GetLineEntry().GetFileSpec().GetFilename()
                line_num = frame.GetLineEntry().GetLine()
                print >> output, '  frame #{num}: {addr:#016x} {mod}`{func} at {file}:{line} {args}'.format(
                    num=i, addr=load_addr, mod=mod_name,
                    func='%s [inlined]' % func_name] if frame.IsInlined() else func_name,
                    file=file_name, line=line_num, args=get_args_as_string(frame, showFuncName=False))

            ...
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBFunction self) -> SBFunction
        __init__(SBFunction self, SBFunction rhs) -> SBFunction
        """
        _lldb.SBFunction_swiginit(self, _lldb.new_SBFunction(*args))
    __swig_destroy__ = _lldb.delete_SBFunction

    def __nonzero__(self):
        return _lldb.SBFunction___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBFunction self) -> bool"""
        return _lldb.SBFunction_IsValid(self)

    def GetName(self) -> str:
        r"""GetName(SBFunction self) -> char const *"""
        return _lldb.SBFunction_GetName(self)

    def GetDisplayName(self) -> str:
        r"""GetDisplayName(SBFunction self) -> char const *"""
        return _lldb.SBFunction_GetDisplayName(self)

    def GetMangledName(self) -> str:
        r"""GetMangledName(SBFunction self) -> char const *"""
        return _lldb.SBFunction_GetMangledName(self)

    def GetInstructions(self, *args) -> "SBInstructionList":
        r"""
        GetInstructions(SBFunction self, SBTarget target) -> SBInstructionList
        GetInstructions(SBFunction self, SBTarget target, char const * flavor) -> SBInstructionList
        """
        return _lldb.SBFunction_GetInstructions(self, *args)

    def GetStartAddress(self) -> "SBAddress":
        r"""GetStartAddress(SBFunction self) -> SBAddress"""
        return _lldb.SBFunction_GetStartAddress(self)

    def GetEndAddress(self) -> "SBAddress":
        r"""GetEndAddress(SBFunction self) -> SBAddress"""
        return _lldb.SBFunction_GetEndAddress(self)

    def GetArgumentName(self, arg_idx: int) -> str:
        r"""GetArgumentName(SBFunction self, uint32_t arg_idx) -> char const *"""
        return _lldb.SBFunction_GetArgumentName(self, arg_idx)

    def GetPrologueByteSize(self) -> int:
        r"""GetPrologueByteSize(SBFunction self) -> uint32_t"""
        return _lldb.SBFunction_GetPrologueByteSize(self)

    def GetType(self) -> "SBType":
        r"""GetType(SBFunction self) -> SBType"""
        return _lldb.SBFunction_GetType(self)

    def GetBlock(self) -> "SBBlock":
        r"""GetBlock(SBFunction self) -> SBBlock"""
        return _lldb.SBFunction_GetBlock(self)

    def GetLanguage(self) -> "lldb::LanguageType":
        r"""GetLanguage(SBFunction self) -> lldb::LanguageType"""
        return _lldb.SBFunction_GetLanguage(self)

    def GetIsOptimized(self) -> "bool":
        r"""
        GetIsOptimized(SBFunction self) -> bool

            Returns true if the function was compiled with optimization.
            Optimization, in this case, is meant to indicate that the debugger
            experience may be confusing for the user -- variables optimized away,
            stepping jumping between source lines -- and the driver may want to
            provide some guidance to the user about this.
            Returns false if unoptimized, or unknown.
        """
        return _lldb.SBFunction_GetIsOptimized(self)

    def __eq__(self, rhs: "SBFunction") -> "bool":
        r"""__eq__(SBFunction self, SBFunction rhs) -> bool"""
        return _lldb.SBFunction___eq__(self, rhs)

    def __ne__(self, rhs: "SBFunction") -> "bool":
        r"""__ne__(SBFunction self, SBFunction rhs) -> bool"""
        return _lldb.SBFunction___ne__(self, rhs)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBFunction self, SBStream description) -> bool"""
        return _lldb.SBFunction_GetDescription(self, description)

    def __repr__(self) -> str:
        r"""__repr__(SBFunction self) -> std::string"""
        return _lldb.SBFunction___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    def get_instructions_from_current_target (self):
        return self.GetInstructions (target)

    addr = property(GetStartAddress, None, doc='''A read only property that returns an lldb object that represents the start address (lldb.SBAddress) for this function.''')
    end_addr = property(GetEndAddress, None, doc='''A read only property that returns an lldb object that represents the end address (lldb.SBAddress) for this function.''')
    block = property(GetBlock, None, doc='''A read only property that returns an lldb object that represents the top level lexical block (lldb.SBBlock) for this function.''')
    instructions = property(get_instructions_from_current_target, None, doc='''A read only property that returns an lldb object that represents the instructions (lldb.SBInstructionList) for this function.''')
    mangled = property(GetMangledName, None, doc='''A read only property that returns the mangled (linkage) name for this function as a string.''')
    name = property(GetName, None, doc='''A read only property that returns the name for this function as a string.''')
    prologue_size = property(GetPrologueByteSize, None, doc='''A read only property that returns the size in bytes of the prologue instructions as an unsigned integer.''')
    type = property(GetType, None, doc='''A read only property that returns an lldb object that represents the return type (lldb.SBType) for this function.''')


    def __eq__(self, rhs):
        if not isinstance(rhs, type(self)):
            return False

        return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)

    def __ne__(self, rhs):
        if not isinstance(rhs, type(self)):
            return True

        return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)


# Register SBFunction in _lldb:
_lldb.SBFunction_swigregister(SBFunction)

class SBHostOS(object):
    r"""Provides information about the host system."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def GetProgramFileSpec() -> "SBFileSpec":
        r"""GetProgramFileSpec() -> SBFileSpec"""
        return _lldb.SBHostOS_GetProgramFileSpec()

    @staticmethod
    def GetLLDBPythonPath() -> "SBFileSpec":
        r"""GetLLDBPythonPath() -> SBFileSpec"""
        return _lldb.SBHostOS_GetLLDBPythonPath()

    @staticmethod
    def GetLLDBPath(path_type: "lldb::PathType") -> "SBFileSpec":
        r"""GetLLDBPath(lldb::PathType path_type) -> SBFileSpec"""
        return _lldb.SBHostOS_GetLLDBPath(path_type)

    @staticmethod
    def GetUserHomeDirectory() -> "SBFileSpec":
        r"""GetUserHomeDirectory() -> SBFileSpec"""
        return _lldb.SBHostOS_GetUserHomeDirectory()

    @staticmethod
    def ThreadCreated(name: str):
        r"""ThreadCreated(char const * name)"""
        return _lldb.SBHostOS_ThreadCreated(name)

    @staticmethod
    def ThreadCreate(name: str, thread_function: "lldb::thread_func_t", thread_arg: "void *", err: "SBError") -> "lldb::thread_t":
        r"""ThreadCreate(char const * name, lldb::thread_func_t thread_function, void * thread_arg, SBError err) -> lldb::thread_t"""
        return _lldb.SBHostOS_ThreadCreate(name, thread_function, thread_arg, err)

    @staticmethod
    def ThreadCancel(thread: "lldb::thread_t", err: "SBError") -> "bool":
        r"""ThreadCancel(lldb::thread_t thread, SBError err) -> bool"""
        return _lldb.SBHostOS_ThreadCancel(thread, err)

    @staticmethod
    def ThreadDetach(thread: "lldb::thread_t", err: "SBError") -> "bool":
        r"""ThreadDetach(lldb::thread_t thread, SBError err) -> bool"""
        return _lldb.SBHostOS_ThreadDetach(thread, err)

    @staticmethod
    def ThreadJoin(thread: "lldb::thread_t", result: "lldb::thread_result_t *", err: "SBError") -> "bool":
        r"""ThreadJoin(lldb::thread_t thread, lldb::thread_result_t * result, SBError err) -> bool"""
        return _lldb.SBHostOS_ThreadJoin(thread, result, err)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


    def __init__(self):
        r"""__init__(SBHostOS self) -> SBHostOS"""
        _lldb.SBHostOS_swiginit(self, _lldb.new_SBHostOS())
    __swig_destroy__ = _lldb.delete_SBHostOS

# Register SBHostOS in _lldb:
_lldb.SBHostOS_swigregister(SBHostOS)

def SBHostOS_GetProgramFileSpec() -> "SBFileSpec":
    r"""SBHostOS_GetProgramFileSpec() -> SBFileSpec"""
    return _lldb.SBHostOS_GetProgramFileSpec()

def SBHostOS_GetLLDBPythonPath() -> "SBFileSpec":
    r"""SBHostOS_GetLLDBPythonPath() -> SBFileSpec"""
    return _lldb.SBHostOS_GetLLDBPythonPath()

def SBHostOS_GetLLDBPath(path_type: "lldb::PathType") -> "SBFileSpec":
    r"""SBHostOS_GetLLDBPath(lldb::PathType path_type) -> SBFileSpec"""
    return _lldb.SBHostOS_GetLLDBPath(path_type)

def SBHostOS_GetUserHomeDirectory() -> "SBFileSpec":
    r"""SBHostOS_GetUserHomeDirectory() -> SBFileSpec"""
    return _lldb.SBHostOS_GetUserHomeDirectory()

def SBHostOS_ThreadCreated(name: str):
    r"""SBHostOS_ThreadCreated(char const * name)"""
    return _lldb.SBHostOS_ThreadCreated(name)

def SBHostOS_ThreadCreate(name: str, thread_function: "lldb::thread_func_t", thread_arg: "void *", err: "SBError") -> "lldb::thread_t":
    r"""SBHostOS_ThreadCreate(char const * name, lldb::thread_func_t thread_function, void * thread_arg, SBError err) -> lldb::thread_t"""
    return _lldb.SBHostOS_ThreadCreate(name, thread_function, thread_arg, err)

def SBHostOS_ThreadCancel(thread: "lldb::thread_t", err: "SBError") -> "bool":
    r"""SBHostOS_ThreadCancel(lldb::thread_t thread, SBError err) -> bool"""
    return _lldb.SBHostOS_ThreadCancel(thread, err)

def SBHostOS_ThreadDetach(thread: "lldb::thread_t", err: "SBError") -> "bool":
    r"""SBHostOS_ThreadDetach(lldb::thread_t thread, SBError err) -> bool"""
    return _lldb.SBHostOS_ThreadDetach(thread, err)

def SBHostOS_ThreadJoin(thread: "lldb::thread_t", result: "lldb::thread_result_t *", err: "SBError") -> "bool":
    r"""SBHostOS_ThreadJoin(lldb::thread_t thread, lldb::thread_result_t * result, SBError err) -> bool"""
    return _lldb.SBHostOS_ThreadJoin(thread, result, err)

class SBInstruction(object):
    r"""Represents a (machine language) instruction."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBInstruction self) -> SBInstruction
        __init__(SBInstruction self, SBInstruction rhs) -> SBInstruction
        """
        _lldb.SBInstruction_swiginit(self, _lldb.new_SBInstruction(*args))
    __swig_destroy__ = _lldb.delete_SBInstruction

    def __nonzero__(self):
        return _lldb.SBInstruction___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBInstruction self) -> bool"""
        return _lldb.SBInstruction_IsValid(self)

    def GetAddress(self) -> "SBAddress":
        r"""GetAddress(SBInstruction self) -> SBAddress"""
        return _lldb.SBInstruction_GetAddress(self)

    def GetMnemonic(self, target: "SBTarget") -> str:
        r"""GetMnemonic(SBInstruction self, SBTarget target) -> char const *"""
        return _lldb.SBInstruction_GetMnemonic(self, target)

    def GetOperands(self, target: "SBTarget") -> str:
        r"""GetOperands(SBInstruction self, SBTarget target) -> char const *"""
        return _lldb.SBInstruction_GetOperands(self, target)

    def GetComment(self, target: "SBTarget") -> str:
        r"""GetComment(SBInstruction self, SBTarget target) -> char const *"""
        return _lldb.SBInstruction_GetComment(self, target)

    def GetControlFlowKind(self, target: "SBTarget") -> "lldb::InstructionControlFlowKind":
        r"""GetControlFlowKind(SBInstruction self, SBTarget target) -> lldb::InstructionControlFlowKind"""
        return _lldb.SBInstruction_GetControlFlowKind(self, target)

    def GetData(self, target: "SBTarget") -> "SBData":
        r"""GetData(SBInstruction self, SBTarget target) -> SBData"""
        return _lldb.SBInstruction_GetData(self, target)

    def GetByteSize(self) -> "size_t":
        r"""GetByteSize(SBInstruction self) -> size_t"""
        return _lldb.SBInstruction_GetByteSize(self)

    def DoesBranch(self) -> "bool":
        r"""DoesBranch(SBInstruction self) -> bool"""
        return _lldb.SBInstruction_DoesBranch(self)

    def HasDelaySlot(self) -> "bool":
        r"""HasDelaySlot(SBInstruction self) -> bool"""
        return _lldb.SBInstruction_HasDelaySlot(self)

    def CanSetBreakpoint(self) -> "bool":
        r"""CanSetBreakpoint(SBInstruction self) -> bool"""
        return _lldb.SBInstruction_CanSetBreakpoint(self)

    def Print(self, *args):
        r"""
        Print(SBInstruction self, SBFile out)
        Print(SBInstruction self, lldb::FileSP BORROWED)
        """
        return _lldb.SBInstruction_Print(self, *args)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBInstruction self, SBStream description) -> bool"""
        return _lldb.SBInstruction_GetDescription(self, description)

    def EmulateWithFrame(self, frame: "SBFrame", evaluate_options: int) -> "bool":
        r"""EmulateWithFrame(SBInstruction self, SBFrame frame, uint32_t evaluate_options) -> bool"""
        return _lldb.SBInstruction_EmulateWithFrame(self, frame, evaluate_options)

    def DumpEmulation(self, triple: str) -> "bool":
        r"""DumpEmulation(SBInstruction self, char const * triple) -> bool"""
        return _lldb.SBInstruction_DumpEmulation(self, triple)

    def TestEmulation(self, output_stream: "SBStream", test_file: str) -> "bool":
        r"""TestEmulation(SBInstruction self, SBStream output_stream, char const * test_file) -> bool"""
        return _lldb.SBInstruction_TestEmulation(self, output_stream, test_file)

    def __repr__(self) -> str:
        r"""__repr__(SBInstruction self) -> std::string"""
        return _lldb.SBInstruction___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        """ Returns the address of the instruction. """
        return self.GetAddress()

    def __oct__(self):
        pass

    def __len__(self):
        """ Returns the size of the instruction. """
        return self.GetByteSize()

    def __iter__(self):
        pass

    def __mnemonic_property__ (self):
        return self.GetMnemonic (target)
    def __operands_property__ (self):
        return self.GetOperands (target)
    def __comment_property__ (self):
        return self.GetComment (target)
    def __file_addr_property__ (self):
        return self.GetAddress ().GetFileAddress()
    def __load_adrr_property__ (self):
        return self.GetComment (target)

    mnemonic = property(__mnemonic_property__, None, doc='''A read only property that returns the mnemonic for this instruction as a string.''')
    operands = property(__operands_property__, None, doc='''A read only property that returns the operands for this instruction as a string.''')
    comment = property(__comment_property__, None, doc='''A read only property that returns the comment for this instruction as a string.''')
    addr = property(GetAddress, None, doc='''A read only property that returns an lldb object that represents the address (lldb.SBAddress) for this instruction.''')
    size = property(GetByteSize, None, doc='''A read only property that returns the size in bytes for this instruction as an integer.''')
    is_branch = property(DoesBranch, None, doc='''A read only property that returns a boolean value that indicates if this instruction is a branch instruction.''')


# Register SBInstruction in _lldb:
_lldb.SBInstruction_swigregister(SBInstruction)

class SBInstructionList(object):
    r"""
    Represents a list of machine instructions.  SBFunction and SBSymbol have
    GetInstructions() methods which return SBInstructionList instances.

    SBInstructionList supports instruction (:py:class:`SBInstruction` instance) iteration.
    For example (see also :py:class:`SBDebugger` for a more complete example), ::

        def disassemble_instructions (insts):
            for i in insts:
                print i

    defines a function which takes an SBInstructionList instance and prints out
    the machine instructions in assembly format.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBInstructionList self) -> SBInstructionList
        __init__(SBInstructionList self, SBInstructionList rhs) -> SBInstructionList
        """
        _lldb.SBInstructionList_swiginit(self, _lldb.new_SBInstructionList(*args))
    __swig_destroy__ = _lldb.delete_SBInstructionList

    def __nonzero__(self):
        return _lldb.SBInstructionList___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBInstructionList self) -> bool"""
        return _lldb.SBInstructionList_IsValid(self)

    def GetSize(self) -> "size_t":
        r"""GetSize(SBInstructionList self) -> size_t"""
        return _lldb.SBInstructionList_GetSize(self)

    def GetInstructionAtIndex(self, idx: int) -> "SBInstruction":
        r"""GetInstructionAtIndex(SBInstructionList self, uint32_t idx) -> SBInstruction"""
        return _lldb.SBInstructionList_GetInstructionAtIndex(self, idx)

    def GetInstructionsCount(self, start: "SBAddress", end: "SBAddress", canSetBreakpoint: "bool"=False) -> "size_t":
        r"""GetInstructionsCount(SBInstructionList self, SBAddress start, SBAddress end, bool canSetBreakpoint=False) -> size_t"""
        return _lldb.SBInstructionList_GetInstructionsCount(self, start, end, canSetBreakpoint)

    def Clear(self):
        r"""Clear(SBInstructionList self)"""
        return _lldb.SBInstructionList_Clear(self)

    def AppendInstruction(self, inst: "SBInstruction"):
        r"""AppendInstruction(SBInstructionList self, SBInstruction inst)"""
        return _lldb.SBInstructionList_AppendInstruction(self, inst)

    def Print(self, *args):
        r"""
        Print(SBInstructionList self, SBFile out)
        Print(SBInstructionList self, lldb::FileSP BORROWED)
        """
        return _lldb.SBInstructionList_Print(self, *args)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBInstructionList self, SBStream description) -> bool"""
        return _lldb.SBInstructionList_GetDescription(self, description)

    def DumpEmulationForAllInstructions(self, triple: str) -> "bool":
        r"""DumpEmulationForAllInstructions(SBInstructionList self, char const * triple) -> bool"""
        return _lldb.SBInstructionList_DumpEmulationForAllInstructions(self, triple)

    def __repr__(self) -> str:
        r"""__repr__(SBInstructionList self) -> std::string"""
        return _lldb.SBInstructionList___repr__(self)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __iter__(self):
        '''Iterate over all instructions in a lldb.SBInstructionList
        object.'''
        return lldb_iter(self, 'GetSize', 'GetInstructionAtIndex')

    def __len__(self):
        '''Access len of the instruction list.'''
        return int(self.GetSize())

    def __getitem__(self, key):
        '''Access instructions by integer index for array access or by lldb.SBAddress to find an instruction that matches a section offset address object.'''
        if type(key) is int:
    # Find an instruction by index
            count = len(self)
            if -count <= key < count:
                key %= count
                return self.GetInstructionAtIndex(key)
        elif type(key) is SBAddress:
    # Find an instruction using a lldb.SBAddress object
            lookup_file_addr = key.file_addr
            closest_inst = None
            for idx in range(self.GetSize()):
                inst = self.GetInstructionAtIndex(idx)
                inst_file_addr = inst.addr.file_addr
                if inst_file_addr == lookup_file_addr:
                    return inst
                elif inst_file_addr > lookup_file_addr:
                    return closest_inst
                else:
                    closest_inst = inst
        return None


# Register SBInstructionList in _lldb:
_lldb.SBInstructionList_swigregister(SBInstructionList)

class SBLanguageRuntime(object):
    r"""Utility functions for :ref:`LanguageType`"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def GetLanguageTypeFromString(string: str) -> "lldb::LanguageType":
        r"""GetLanguageTypeFromString(char const * string) -> lldb::LanguageType"""
        return _lldb.SBLanguageRuntime_GetLanguageTypeFromString(string)

    @staticmethod
    def GetNameForLanguageType(language: "lldb::LanguageType") -> str:
        r"""GetNameForLanguageType(lldb::LanguageType language) -> char const *"""
        return _lldb.SBLanguageRuntime_GetNameForLanguageType(language)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


    def __init__(self):
        r"""__init__(SBLanguageRuntime self) -> SBLanguageRuntime"""
        _lldb.SBLanguageRuntime_swiginit(self, _lldb.new_SBLanguageRuntime())
    __swig_destroy__ = _lldb.delete_SBLanguageRuntime

# Register SBLanguageRuntime in _lldb:
_lldb.SBLanguageRuntime_swigregister(SBLanguageRuntime)

def SBLanguageRuntime_GetLanguageTypeFromString(string: str) -> "lldb::LanguageType":
    r"""SBLanguageRuntime_GetLanguageTypeFromString(char const * string) -> lldb::LanguageType"""
    return _lldb.SBLanguageRuntime_GetLanguageTypeFromString(string)

def SBLanguageRuntime_GetNameForLanguageType(language: "lldb::LanguageType") -> str:
    r"""SBLanguageRuntime_GetNameForLanguageType(lldb::LanguageType language) -> char const *"""
    return _lldb.SBLanguageRuntime_GetNameForLanguageType(language)

class SBLaunchInfo(object):
    r"""Describes how a target or program should be launched."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, argv: "char const **"):
        r"""__init__(SBLaunchInfo self, char const ** argv) -> SBLaunchInfo"""
        _lldb.SBLaunchInfo_swiginit(self, _lldb.new_SBLaunchInfo(argv))
    __swig_destroy__ = _lldb.delete_SBLaunchInfo

    def GetProcessID(self) -> int:
        r"""GetProcessID(SBLaunchInfo self) -> lldb::pid_t"""
        return _lldb.SBLaunchInfo_GetProcessID(self)

    def GetUserID(self) -> int:
        r"""GetUserID(SBLaunchInfo self) -> uint32_t"""
        return _lldb.SBLaunchInfo_GetUserID(self)

    def GetGroupID(self) -> int:
        r"""GetGroupID(SBLaunchInfo self) -> uint32_t"""
        return _lldb.SBLaunchInfo_GetGroupID(self)

    def UserIDIsValid(self) -> "bool":
        r"""UserIDIsValid(SBLaunchInfo self) -> bool"""
        return _lldb.SBLaunchInfo_UserIDIsValid(self)

    def GroupIDIsValid(self) -> "bool":
        r"""GroupIDIsValid(SBLaunchInfo self) -> bool"""
        return _lldb.SBLaunchInfo_GroupIDIsValid(self)

    def SetUserID(self, uid: int):
        r"""SetUserID(SBLaunchInfo self, uint32_t uid)"""
        return _lldb.SBLaunchInfo_SetUserID(self, uid)

    def SetGroupID(self, gid: int):
        r"""SetGroupID(SBLaunchInfo self, uint32_t gid)"""
        return _lldb.SBLaunchInfo_SetGroupID(self, gid)

    def GetExecutableFile(self) -> "SBFileSpec":
        r"""GetExecutableFile(SBLaunchInfo self) -> SBFileSpec"""
        return _lldb.SBLaunchInfo_GetExecutableFile(self)

    def SetExecutableFile(self, exe_file: "SBFileSpec", add_as_first_arg: "bool"):
        r"""SetExecutableFile(SBLaunchInfo self, SBFileSpec exe_file, bool add_as_first_arg)"""
        return _lldb.SBLaunchInfo_SetExecutableFile(self, exe_file, add_as_first_arg)

    def GetListener(self) -> "SBListener":
        r"""GetListener(SBLaunchInfo self) -> SBListener"""
        return _lldb.SBLaunchInfo_GetListener(self)

    def SetListener(self, listener: "SBListener"):
        r"""SetListener(SBLaunchInfo self, SBListener listener)"""
        return _lldb.SBLaunchInfo_SetListener(self, listener)

    def GetShadowListener(self) -> "SBListener":
        r"""GetShadowListener(SBLaunchInfo self) -> SBListener"""
        return _lldb.SBLaunchInfo_GetShadowListener(self)

    def SetShadowListener(self, listener: "SBListener"):
        r"""SetShadowListener(SBLaunchInfo self, SBListener listener)"""
        return _lldb.SBLaunchInfo_SetShadowListener(self, listener)

    def GetNumArguments(self) -> int:
        r"""GetNumArguments(SBLaunchInfo self) -> uint32_t"""
        return _lldb.SBLaunchInfo_GetNumArguments(self)

    def GetArgumentAtIndex(self, idx: int) -> str:
        r"""GetArgumentAtIndex(SBLaunchInfo self, uint32_t idx) -> char const *"""
        return _lldb.SBLaunchInfo_GetArgumentAtIndex(self, idx)

    def SetArguments(self, argv: "char const **", append: "bool"):
        r"""SetArguments(SBLaunchInfo self, char const ** argv, bool append)"""
        return _lldb.SBLaunchInfo_SetArguments(self, argv, append)

    def GetNumEnvironmentEntries(self) -> int:
        r"""GetNumEnvironmentEntries(SBLaunchInfo self) -> uint32_t"""
        return _lldb.SBLaunchInfo_GetNumEnvironmentEntries(self)

    def GetEnvironmentEntryAtIndex(self, idx: int) -> str:
        r"""GetEnvironmentEntryAtIndex(SBLaunchInfo self, uint32_t idx) -> char const *"""
        return _lldb.SBLaunchInfo_GetEnvironmentEntryAtIndex(self, idx)

    def SetEnvironmentEntries(self, envp: "char const **", append: "bool"):
        r"""SetEnvironmentEntries(SBLaunchInfo self, char const ** envp, bool append)"""
        return _lldb.SBLaunchInfo_SetEnvironmentEntries(self, envp, append)

    def SetEnvironment(self, env: "SBEnvironment", append: "bool"):
        r"""SetEnvironment(SBLaunchInfo self, SBEnvironment env, bool append)"""
        return _lldb.SBLaunchInfo_SetEnvironment(self, env, append)

    def GetEnvironment(self) -> "SBEnvironment":
        r"""GetEnvironment(SBLaunchInfo self) -> SBEnvironment"""
        return _lldb.SBLaunchInfo_GetEnvironment(self)

    def Clear(self):
        r"""Clear(SBLaunchInfo self)"""
        return _lldb.SBLaunchInfo_Clear(self)

    def GetWorkingDirectory(self) -> str:
        r"""GetWorkingDirectory(SBLaunchInfo self) -> char const *"""
        return _lldb.SBLaunchInfo_GetWorkingDirectory(self)

    def SetWorkingDirectory(self, working_dir: str):
        r"""SetWorkingDirectory(SBLaunchInfo self, char const * working_dir)"""
        return _lldb.SBLaunchInfo_SetWorkingDirectory(self, working_dir)

    def GetLaunchFlags(self) -> int:
        r"""GetLaunchFlags(SBLaunchInfo self) -> uint32_t"""
        return _lldb.SBLaunchInfo_GetLaunchFlags(self)

    def SetLaunchFlags(self, flags: int):
        r"""SetLaunchFlags(SBLaunchInfo self, uint32_t flags)"""
        return _lldb.SBLaunchInfo_SetLaunchFlags(self, flags)

    def GetProcessPluginName(self) -> str:
        r"""GetProcessPluginName(SBLaunchInfo self) -> char const *"""
        return _lldb.SBLaunchInfo_GetProcessPluginName(self)

    def SetProcessPluginName(self, plugin_name: str):
        r"""SetProcessPluginName(SBLaunchInfo self, char const * plugin_name)"""
        return _lldb.SBLaunchInfo_SetProcessPluginName(self, plugin_name)

    def GetShell(self) -> str:
        r"""GetShell(SBLaunchInfo self) -> char const *"""
        return _lldb.SBLaunchInfo_GetShell(self)

    def SetShell(self, path: str):
        r"""SetShell(SBLaunchInfo self, char const * path)"""
        return _lldb.SBLaunchInfo_SetShell(self, path)

    def GetShellExpandArguments(self) -> "bool":
        r"""GetShellExpandArguments(SBLaunchInfo self) -> bool"""
        return _lldb.SBLaunchInfo_GetShellExpandArguments(self)

    def SetShellExpandArguments(self, expand: "bool"):
        r"""SetShellExpandArguments(SBLaunchInfo self, bool expand)"""
        return _lldb.SBLaunchInfo_SetShellExpandArguments(self, expand)

    def GetResumeCount(self) -> int:
        r"""GetResumeCount(SBLaunchInfo self) -> uint32_t"""
        return _lldb.SBLaunchInfo_GetResumeCount(self)

    def SetResumeCount(self, c: int):
        r"""SetResumeCount(SBLaunchInfo self, uint32_t c)"""
        return _lldb.SBLaunchInfo_SetResumeCount(self, c)

    def AddCloseFileAction(self, fd: "int") -> "bool":
        r"""AddCloseFileAction(SBLaunchInfo self, int fd) -> bool"""
        return _lldb.SBLaunchInfo_AddCloseFileAction(self, fd)

    def AddDuplicateFileAction(self, fd: "int", dup_fd: "int") -> "bool":
        r"""AddDuplicateFileAction(SBLaunchInfo self, int fd, int dup_fd) -> bool"""
        return _lldb.SBLaunchInfo_AddDuplicateFileAction(self, fd, dup_fd)

    def AddOpenFileAction(self, fd: "int", path: str, read: "bool", write: "bool") -> "bool":
        r"""AddOpenFileAction(SBLaunchInfo self, int fd, char const * path, bool read, bool write) -> bool"""
        return _lldb.SBLaunchInfo_AddOpenFileAction(self, fd, path, read, write)

    def AddSuppressFileAction(self, fd: "int", read: "bool", write: "bool") -> "bool":
        r"""AddSuppressFileAction(SBLaunchInfo self, int fd, bool read, bool write) -> bool"""
        return _lldb.SBLaunchInfo_AddSuppressFileAction(self, fd, read, write)

    def SetLaunchEventData(self, data: str):
        r"""SetLaunchEventData(SBLaunchInfo self, char const * data)"""
        return _lldb.SBLaunchInfo_SetLaunchEventData(self, data)

    def GetLaunchEventData(self) -> str:
        r"""GetLaunchEventData(SBLaunchInfo self) -> char const *"""
        return _lldb.SBLaunchInfo_GetLaunchEventData(self)

    def GetDetachOnError(self) -> "bool":
        r"""GetDetachOnError(SBLaunchInfo self) -> bool"""
        return _lldb.SBLaunchInfo_GetDetachOnError(self)

    def SetDetachOnError(self, enable: "bool"):
        r"""SetDetachOnError(SBLaunchInfo self, bool enable)"""
        return _lldb.SBLaunchInfo_SetDetachOnError(self, enable)

    def GetScriptedProcessClassName(self) -> str:
        r"""GetScriptedProcessClassName(SBLaunchInfo self) -> char const *"""
        return _lldb.SBLaunchInfo_GetScriptedProcessClassName(self)

    def SetScriptedProcessClassName(self, class_name: str):
        r"""SetScriptedProcessClassName(SBLaunchInfo self, char const * class_name)"""
        return _lldb.SBLaunchInfo_SetScriptedProcessClassName(self, class_name)

    def GetScriptedProcessDictionary(self) -> "SBStructuredData":
        r"""GetScriptedProcessDictionary(SBLaunchInfo self) -> SBStructuredData"""
        return _lldb.SBLaunchInfo_GetScriptedProcessDictionary(self)

    def SetScriptedProcessDictionary(self, dict: "SBStructuredData"):
        r"""SetScriptedProcessDictionary(SBLaunchInfo self, SBStructuredData dict)"""
        return _lldb.SBLaunchInfo_SetScriptedProcessDictionary(self, dict)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBLaunchInfo in _lldb:
_lldb.SBLaunchInfo_swigregister(SBLaunchInfo)

class SBLineEntry(object):
    r"""
    Specifies an association with a contiguous range of instructions and
    a source file location.

    :py:class:`SBCompileUnit` contains SBLineEntry(s). For example, ::

        for lineEntry in compileUnit:
            print('line entry: %s:%d' % (str(lineEntry.GetFileSpec()),
                                        lineEntry.GetLine()))
            print('start addr: %s' % str(lineEntry.GetStartAddress()))
            print('end   addr: %s' % str(lineEntry.GetEndAddress()))

    produces: ::

        line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:20
        start addr: a.out[0x100000d98]
        end   addr: a.out[0x100000da3]
        line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:21
        start addr: a.out[0x100000da3]
        end   addr: a.out[0x100000da9]
        line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:22
        start addr: a.out[0x100000da9]
        end   addr: a.out[0x100000db6]
        line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:23
        start addr: a.out[0x100000db6]
        end   addr: a.out[0x100000dbc]
        ...

    See also :py:class:`SBCompileUnit` .
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBLineEntry self) -> SBLineEntry
        __init__(SBLineEntry self, SBLineEntry rhs) -> SBLineEntry
        """
        _lldb.SBLineEntry_swiginit(self, _lldb.new_SBLineEntry(*args))
    __swig_destroy__ = _lldb.delete_SBLineEntry

    def GetStartAddress(self) -> "SBAddress":
        r"""GetStartAddress(SBLineEntry self) -> SBAddress"""
        return _lldb.SBLineEntry_GetStartAddress(self)

    def GetEndAddress(self) -> "SBAddress":
        r"""GetEndAddress(SBLineEntry self) -> SBAddress"""
        return _lldb.SBLineEntry_GetEndAddress(self)

    def __nonzero__(self):
        return _lldb.SBLineEntry___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBLineEntry self) -> bool"""
        return _lldb.SBLineEntry_IsValid(self)

    def GetFileSpec(self) -> "SBFileSpec":
        r"""GetFileSpec(SBLineEntry self) -> SBFileSpec"""
        return _lldb.SBLineEntry_GetFileSpec(self)

    def GetLine(self) -> int:
        r"""GetLine(SBLineEntry self) -> uint32_t"""
        return _lldb.SBLineEntry_GetLine(self)

    def GetColumn(self) -> int:
        r"""GetColumn(SBLineEntry self) -> uint32_t"""
        return _lldb.SBLineEntry_GetColumn(self)

    def SetFileSpec(self, filespec: "SBFileSpec"):
        r"""SetFileSpec(SBLineEntry self, SBFileSpec filespec)"""
        return _lldb.SBLineEntry_SetFileSpec(self, filespec)

    def SetLine(self, line: int):
        r"""SetLine(SBLineEntry self, uint32_t line)"""
        return _lldb.SBLineEntry_SetLine(self, line)

    def SetColumn(self, column: int):
        r"""SetColumn(SBLineEntry self, uint32_t column)"""
        return _lldb.SBLineEntry_SetColumn(self, column)

    def __eq__(self, rhs: "SBLineEntry") -> "bool":
        r"""__eq__(SBLineEntry self, SBLineEntry rhs) -> bool"""
        return _lldb.SBLineEntry___eq__(self, rhs)

    def __ne__(self, rhs: "SBLineEntry") -> "bool":
        r"""__ne__(SBLineEntry self, SBLineEntry rhs) -> bool"""
        return _lldb.SBLineEntry___ne__(self, rhs)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBLineEntry self, SBStream description) -> bool"""
        return _lldb.SBLineEntry_GetDescription(self, description)

    def __repr__(self) -> str:
        r"""__repr__(SBLineEntry self) -> std::string"""
        return _lldb.SBLineEntry___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        return self.GetLine()

    def __hex__(self):
        return self.GetStartAddress()

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    file = property(GetFileSpec, None, doc='''A read only property that returns an lldb object that represents the file (lldb.SBFileSpec) for this line entry.''')
    line = property(GetLine, None, doc='''A read only property that returns the 1 based line number for this line entry, a return value of zero indicates that no line information is available.''')
    column = property(GetColumn, None, doc='''A read only property that returns the 1 based column number for this line entry, a return value of zero indicates that no column information is available.''')
    addr = property(GetStartAddress, None, doc='''A read only property that returns an lldb object that represents the start address (lldb.SBAddress) for this line entry.''')
    end_addr = property(GetEndAddress, None, doc='''A read only property that returns an lldb object that represents the end address (lldb.SBAddress) for this line entry.''')


    def __eq__(self, rhs):
        if not isinstance(rhs, type(self)):
            return False

        return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)

    def __ne__(self, rhs):
        if not isinstance(rhs, type(self)):
            return True

        return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)


# Register SBLineEntry in _lldb:
_lldb.SBLineEntry_swigregister(SBLineEntry)

class SBListener(object):
    r"""
    API clients can register its own listener to debugger events.

    See also :py:class:`SBEvent` for example usage of creating and adding a listener.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBListener self) -> SBListener
        __init__(SBListener self, char const * name) -> SBListener
        __init__(SBListener self, SBListener rhs) -> SBListener
        """
        _lldb.SBListener_swiginit(self, _lldb.new_SBListener(*args))
    __swig_destroy__ = _lldb.delete_SBListener

    def AddEvent(self, event: "SBEvent"):
        r"""AddEvent(SBListener self, SBEvent event)"""
        return _lldb.SBListener_AddEvent(self, event)

    def Clear(self):
        r"""Clear(SBListener self)"""
        return _lldb.SBListener_Clear(self)

    def __nonzero__(self):
        return _lldb.SBListener___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBListener self) -> bool"""
        return _lldb.SBListener_IsValid(self)

    def StartListeningForEventClass(self, debugger: "SBDebugger", broadcaster_class: str, event_mask: int) -> int:
        r"""StartListeningForEventClass(SBListener self, SBDebugger debugger, char const * broadcaster_class, uint32_t event_mask) -> uint32_t"""
        return _lldb.SBListener_StartListeningForEventClass(self, debugger, broadcaster_class, event_mask)

    def StopListeningForEventClass(self, debugger: "SBDebugger", broadcaster_class: str, event_mask: int) -> "bool":
        r"""StopListeningForEventClass(SBListener self, SBDebugger debugger, char const * broadcaster_class, uint32_t event_mask) -> bool"""
        return _lldb.SBListener_StopListeningForEventClass(self, debugger, broadcaster_class, event_mask)

    def StartListeningForEvents(self, broadcaster: "SBBroadcaster", event_mask: int) -> int:
        r"""StartListeningForEvents(SBListener self, SBBroadcaster broadcaster, uint32_t event_mask) -> uint32_t"""
        return _lldb.SBListener_StartListeningForEvents(self, broadcaster, event_mask)

    def StopListeningForEvents(self, broadcaster: "SBBroadcaster", event_mask: int) -> "bool":
        r"""StopListeningForEvents(SBListener self, SBBroadcaster broadcaster, uint32_t event_mask) -> bool"""
        return _lldb.SBListener_StopListeningForEvents(self, broadcaster, event_mask)

    def WaitForEvent(self, num_seconds: int, event: "SBEvent") -> "bool":
        r"""WaitForEvent(SBListener self, uint32_t num_seconds, SBEvent event) -> bool"""
        return _lldb.SBListener_WaitForEvent(self, num_seconds, event)

    def WaitForEventForBroadcaster(self, num_seconds: int, broadcaster: "SBBroadcaster", sb_event: "SBEvent") -> "bool":
        r"""WaitForEventForBroadcaster(SBListener self, uint32_t num_seconds, SBBroadcaster broadcaster, SBEvent sb_event) -> bool"""
        return _lldb.SBListener_WaitForEventForBroadcaster(self, num_seconds, broadcaster, sb_event)

    def WaitForEventForBroadcasterWithType(self, num_seconds: int, broadcaster: "SBBroadcaster", event_type_mask: int, sb_event: "SBEvent") -> "bool":
        r"""WaitForEventForBroadcasterWithType(SBListener self, uint32_t num_seconds, SBBroadcaster broadcaster, uint32_t event_type_mask, SBEvent sb_event) -> bool"""
        return _lldb.SBListener_WaitForEventForBroadcasterWithType(self, num_seconds, broadcaster, event_type_mask, sb_event)

    def PeekAtNextEvent(self, sb_event: "SBEvent") -> "bool":
        r"""PeekAtNextEvent(SBListener self, SBEvent sb_event) -> bool"""
        return _lldb.SBListener_PeekAtNextEvent(self, sb_event)

    def PeekAtNextEventForBroadcaster(self, broadcaster: "SBBroadcaster", sb_event: "SBEvent") -> "bool":
        r"""PeekAtNextEventForBroadcaster(SBListener self, SBBroadcaster broadcaster, SBEvent sb_event) -> bool"""
        return _lldb.SBListener_PeekAtNextEventForBroadcaster(self, broadcaster, sb_event)

    def PeekAtNextEventForBroadcasterWithType(self, broadcaster: "SBBroadcaster", event_type_mask: int, sb_event: "SBEvent") -> "bool":
        r"""PeekAtNextEventForBroadcasterWithType(SBListener self, SBBroadcaster broadcaster, uint32_t event_type_mask, SBEvent sb_event) -> bool"""
        return _lldb.SBListener_PeekAtNextEventForBroadcasterWithType(self, broadcaster, event_type_mask, sb_event)

    def GetNextEvent(self, sb_event: "SBEvent") -> "bool":
        r"""GetNextEvent(SBListener self, SBEvent sb_event) -> bool"""
        return _lldb.SBListener_GetNextEvent(self, sb_event)

    def GetNextEventForBroadcaster(self, broadcaster: "SBBroadcaster", sb_event: "SBEvent") -> "bool":
        r"""GetNextEventForBroadcaster(SBListener self, SBBroadcaster broadcaster, SBEvent sb_event) -> bool"""
        return _lldb.SBListener_GetNextEventForBroadcaster(self, broadcaster, sb_event)

    def GetNextEventForBroadcasterWithType(self, broadcaster: "SBBroadcaster", event_type_mask: int, sb_event: "SBEvent") -> "bool":
        r"""GetNextEventForBroadcasterWithType(SBListener self, SBBroadcaster broadcaster, uint32_t event_type_mask, SBEvent sb_event) -> bool"""
        return _lldb.SBListener_GetNextEventForBroadcasterWithType(self, broadcaster, event_type_mask, sb_event)

    def HandleBroadcastEvent(self, event: "SBEvent") -> "bool":
        r"""HandleBroadcastEvent(SBListener self, SBEvent event) -> bool"""
        return _lldb.SBListener_HandleBroadcastEvent(self, event)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBListener in _lldb:
_lldb.SBListener_swigregister(SBListener)

class SBMemoryRegionInfo(object):
    r"""API clients can get information about memory regions in processes."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBMemoryRegionInfo self) -> SBMemoryRegionInfo
        __init__(SBMemoryRegionInfo self, SBMemoryRegionInfo rhs) -> SBMemoryRegionInfo
        __init__(SBMemoryRegionInfo self, char const * name, lldb::addr_t begin, lldb::addr_t end, uint32_t permissions, bool mapped, bool stack_memory=False) -> SBMemoryRegionInfo
        """
        _lldb.SBMemoryRegionInfo_swiginit(self, _lldb.new_SBMemoryRegionInfo(*args))
    __swig_destroy__ = _lldb.delete_SBMemoryRegionInfo

    def Clear(self):
        r"""Clear(SBMemoryRegionInfo self)"""
        return _lldb.SBMemoryRegionInfo_Clear(self)

    def GetRegionBase(self) -> int:
        r"""GetRegionBase(SBMemoryRegionInfo self) -> lldb::addr_t"""
        return _lldb.SBMemoryRegionInfo_GetRegionBase(self)

    def GetRegionEnd(self) -> int:
        r"""GetRegionEnd(SBMemoryRegionInfo self) -> lldb::addr_t"""
        return _lldb.SBMemoryRegionInfo_GetRegionEnd(self)

    def IsReadable(self) -> "bool":
        r"""IsReadable(SBMemoryRegionInfo self) -> bool"""
        return _lldb.SBMemoryRegionInfo_IsReadable(self)

    def IsWritable(self) -> "bool":
        r"""IsWritable(SBMemoryRegionInfo self) -> bool"""
        return _lldb.SBMemoryRegionInfo_IsWritable(self)

    def IsExecutable(self) -> "bool":
        r"""IsExecutable(SBMemoryRegionInfo self) -> bool"""
        return _lldb.SBMemoryRegionInfo_IsExecutable(self)

    def IsMapped(self) -> "bool":
        r"""IsMapped(SBMemoryRegionInfo self) -> bool"""
        return _lldb.SBMemoryRegionInfo_IsMapped(self)

    def GetName(self) -> str:
        r"""GetName(SBMemoryRegionInfo self) -> char const *"""
        return _lldb.SBMemoryRegionInfo_GetName(self)

    def HasDirtyMemoryPageList(self) -> "bool":
        r"""

        GetRegionEnd(SBMemoryRegionInfo self) -> lldb::addr_t
        Returns whether this memory region has a list of modified (dirty)
        pages available or not.  When calling GetNumDirtyPages(), you will
        have 0 returned for both "dirty page list is not known" and
        "empty dirty page list" (that is, no modified pages in this
        memory region).  You must use this method to disambiguate.
        """
        return _lldb.SBMemoryRegionInfo_HasDirtyMemoryPageList(self)

    def GetNumDirtyPages(self) -> int:
        r"""

        GetNumDirtyPages(SBMemoryRegionInfo self) -> uint32_t
        Return the number of dirty (modified) memory pages in this
        memory region, if available.  You must use the
        SBMemoryRegionInfo::HasDirtyMemoryPageList() method to
        determine if a dirty memory list is available; it will depend
        on the target system can provide this information.
        """
        return _lldb.SBMemoryRegionInfo_GetNumDirtyPages(self)

    def GetDirtyPageAddressAtIndex(self, idx: int) -> int:
        r"""

        GetDirtyPageAddressAtIndex(SBMemoryRegionInfo self, uint32_t idx) -> lldb::addr_t
        Return the address of a modified, or dirty, page of memory.
        If the provided index is out of range, or this memory region
        does not have dirty page information, LLDB_INVALID_ADDRESS
        is returned.
        """
        return _lldb.SBMemoryRegionInfo_GetDirtyPageAddressAtIndex(self, idx)

    def GetPageSize(self) -> "int":
        r"""

        GetPageSize(SBMemoryRegionInfo self) -> int
        Return the size of pages in this memory region.  0 will be returned
        if this information was unavailable.
        """
        return _lldb.SBMemoryRegionInfo_GetPageSize(self)

    def __eq__(self, rhs: "SBMemoryRegionInfo") -> "bool":
        r"""__eq__(SBMemoryRegionInfo self, SBMemoryRegionInfo rhs) -> bool"""
        return _lldb.SBMemoryRegionInfo___eq__(self, rhs)

    def __ne__(self, rhs: "SBMemoryRegionInfo") -> "bool":
        r"""__ne__(SBMemoryRegionInfo self, SBMemoryRegionInfo rhs) -> bool"""
        return _lldb.SBMemoryRegionInfo___ne__(self, rhs)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBMemoryRegionInfo self, SBStream description) -> bool"""
        return _lldb.SBMemoryRegionInfo_GetDescription(self, description)

    def __repr__(self) -> str:
        r"""__repr__(SBMemoryRegionInfo self) -> std::string"""
        return _lldb.SBMemoryRegionInfo___repr__(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      return self.GetRegionBase()

    def __oct__(self):
      pass

    def __len__(self):
      return self.GetRegionEnd() - self.GetRegionBase()

    def __iter__(self):
      pass


# Register SBMemoryRegionInfo in _lldb:
_lldb.SBMemoryRegionInfo_swigregister(SBMemoryRegionInfo)

class SBMemoryRegionInfoList(object):
    r"""Represents a list of :py:class:`SBMemoryRegionInfo`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBMemoryRegionInfoList self) -> SBMemoryRegionInfoList
        __init__(SBMemoryRegionInfoList self, SBMemoryRegionInfoList rhs) -> SBMemoryRegionInfoList
        """
        _lldb.SBMemoryRegionInfoList_swiginit(self, _lldb.new_SBMemoryRegionInfoList(*args))
    __swig_destroy__ = _lldb.delete_SBMemoryRegionInfoList

    def GetSize(self) -> int:
        r"""GetSize(SBMemoryRegionInfoList self) -> uint32_t"""
        return _lldb.SBMemoryRegionInfoList_GetSize(self)

    def GetMemoryRegionContainingAddress(self, addr: int, region_info: "SBMemoryRegionInfo") -> "bool":
        r"""GetMemoryRegionContainingAddress(SBMemoryRegionInfoList self, lldb::addr_t addr, SBMemoryRegionInfo region_info) -> bool"""
        return _lldb.SBMemoryRegionInfoList_GetMemoryRegionContainingAddress(self, addr, region_info)

    def GetMemoryRegionAtIndex(self, idx: int, region_info: "SBMemoryRegionInfo") -> "bool":
        r"""GetMemoryRegionAtIndex(SBMemoryRegionInfoList self, uint32_t idx, SBMemoryRegionInfo region_info) -> bool"""
        return _lldb.SBMemoryRegionInfoList_GetMemoryRegionAtIndex(self, idx, region_info)

    def Append(self, *args):
        r"""
        Append(SBMemoryRegionInfoList self, SBMemoryRegionInfo region)
        Append(SBMemoryRegionInfoList self, SBMemoryRegionInfoList region_list)
        """
        return _lldb.SBMemoryRegionInfoList_Append(self, *args)

    def Clear(self):
        r"""Clear(SBMemoryRegionInfoList self)"""
        return _lldb.SBMemoryRegionInfoList_Clear(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      '''Return the number of memory region info in a lldb.SBMemoryRegionInfoList object.'''
      return self.GetSize()

    def __iter__(self):
      '''Iterate over all the memory regions in a lldb.SBMemoryRegionInfoList object.'''
      return lldb_iter(self, 'GetSize', 'GetMemoryRegionAtIndex')


# Register SBMemoryRegionInfoList in _lldb:
_lldb.SBMemoryRegionInfoList_swigregister(SBMemoryRegionInfoList)

class SBModule(object):
    r"""
    Represents an executable image and its associated object and symbol files.

    The module is designed to be able to select a single slice of an
    executable image as it would appear on disk and during program
    execution.

    You can retrieve SBModule from :py:class:`SBSymbolContext` , which in turn is available
    from SBFrame.

    SBModule supports symbol iteration, for example, ::

        for symbol in module:
            name = symbol.GetName()
            saddr = symbol.GetStartAddress()
            eaddr = symbol.GetEndAddress()

    and rich comparison methods which allow the API program to use, ::

        if thisModule == thatModule:
            print('This module is the same as that module')

    to test module equality.  A module also contains object file sections, namely
    :py:class:`SBSection` .  SBModule supports section iteration through section_iter(), for
    example, ::

        print('Number of sections: %d' % module.GetNumSections())
        for sec in module.section_iter():
            print(sec)

    And to iterate the symbols within a SBSection, use symbol_in_section_iter(), ::

        # Iterates the text section and prints each symbols within each sub-section.
        for subsec in text_sec:
            print(INDENT + repr(subsec))
            for sym in exe_module.symbol_in_section_iter(subsec):
                print(INDENT2 + repr(sym))
                print(INDENT2 + 'symbol type: %s' % symbol_type_to_str(sym.GetType()))

    produces this following output: ::

        [0x0000000100001780-0x0000000100001d5c) a.out.__TEXT.__text
            id = {0x00000004}, name = 'mask_access(MaskAction, unsigned int)', range = [0x00000001000017c0-0x0000000100001870)
            symbol type: code
            id = {0x00000008}, name = 'thread_func(void*)', range = [0x0000000100001870-0x00000001000019b0)
            symbol type: code
            id = {0x0000000c}, name = 'main', range = [0x00000001000019b0-0x0000000100001d5c)
            symbol type: code
            id = {0x00000023}, name = 'start', address = 0x0000000100001780
            symbol type: code
        [0x0000000100001d5c-0x0000000100001da4) a.out.__TEXT.__stubs
            id = {0x00000024}, name = '__stack_chk_fail', range = [0x0000000100001d5c-0x0000000100001d62)
            symbol type: trampoline
            id = {0x00000028}, name = 'exit', range = [0x0000000100001d62-0x0000000100001d68)
            symbol type: trampoline
            id = {0x00000029}, name = 'fflush', range = [0x0000000100001d68-0x0000000100001d6e)
            symbol type: trampoline
            id = {0x0000002a}, name = 'fgets', range = [0x0000000100001d6e-0x0000000100001d74)
            symbol type: trampoline
            id = {0x0000002b}, name = 'printf', range = [0x0000000100001d74-0x0000000100001d7a)
            symbol type: trampoline
            id = {0x0000002c}, name = 'pthread_create', range = [0x0000000100001d7a-0x0000000100001d80)
            symbol type: trampoline
            id = {0x0000002d}, name = 'pthread_join', range = [0x0000000100001d80-0x0000000100001d86)
            symbol type: trampoline
            id = {0x0000002e}, name = 'pthread_mutex_lock', range = [0x0000000100001d86-0x0000000100001d8c)
            symbol type: trampoline
            id = {0x0000002f}, name = 'pthread_mutex_unlock', range = [0x0000000100001d8c-0x0000000100001d92)
            symbol type: trampoline
            id = {0x00000030}, name = 'rand', range = [0x0000000100001d92-0x0000000100001d98)
            symbol type: trampoline
            id = {0x00000031}, name = 'strtoul', range = [0x0000000100001d98-0x0000000100001d9e)
            symbol type: trampoline
            id = {0x00000032}, name = 'usleep', range = [0x0000000100001d9e-0x0000000100001da4)
            symbol type: trampoline
        [0x0000000100001da4-0x0000000100001e2c) a.out.__TEXT.__stub_helper
        [0x0000000100001e2c-0x0000000100001f10) a.out.__TEXT.__cstring
        [0x0000000100001f10-0x0000000100001f68) a.out.__TEXT.__unwind_info
        [0x0000000100001f68-0x0000000100001ff8) a.out.__TEXT.__eh_frame

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBModule self) -> SBModule
        __init__(SBModule self, SBModule rhs) -> SBModule
        __init__(SBModule self, SBModuleSpec module_spec) -> SBModule
        __init__(SBModule self, SBProcess process, lldb::addr_t header_addr) -> SBModule
        """
        _lldb.SBModule_swiginit(self, _lldb.new_SBModule(*args))
    __swig_destroy__ = _lldb.delete_SBModule

    def __nonzero__(self):
        return _lldb.SBModule___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBModule self) -> bool"""
        return _lldb.SBModule_IsValid(self)

    def Clear(self):
        r"""Clear(SBModule self)"""
        return _lldb.SBModule_Clear(self)

    def IsFileBacked(self) -> "bool":
        r"""
        IsFileBacked(SBModule self) -> bool

            Check if the module is file backed.

            @return

                True, if the module is backed by an object file on disk.
                False, if the module is backed by an object file in memory.
        """
        return _lldb.SBModule_IsFileBacked(self)

    def GetFileSpec(self) -> "SBFileSpec":
        r"""
        GetFileSpec(SBModule self) -> SBFileSpec

            Get const accessor for the module file specification.

            This function returns the file for the module on the host system
            that is running LLDB. This can differ from the path on the
            platform since we might be doing remote debugging.

            @return
                A const reference to the file specification object.
        """
        return _lldb.SBModule_GetFileSpec(self)

    def GetPlatformFileSpec(self) -> "SBFileSpec":
        r"""
        GetPlatformFileSpec(SBModule self) -> SBFileSpec

            Get accessor for the module platform file specification.

            Platform file refers to the path of the module as it is known on
            the remote system on which it is being debugged. For local
            debugging this is always the same as Module::GetFileSpec(). But
            remote debugging might mention a file '/usr/lib/liba.dylib'
            which might be locally downloaded and cached. In this case the
            platform file could be something like:
            '/tmp/lldb/platform-cache/remote.host.computer/usr/lib/liba.dylib'
            The file could also be cached in a local developer kit directory.

            @return
                A const reference to the file specification object.
        """
        return _lldb.SBModule_GetPlatformFileSpec(self)

    def SetPlatformFileSpec(self, platform_file: "SBFileSpec") -> "bool":
        r"""SetPlatformFileSpec(SBModule self, SBFileSpec platform_file) -> bool"""
        return _lldb.SBModule_SetPlatformFileSpec(self, platform_file)

    def GetRemoteInstallFileSpec(self) -> "SBFileSpec":
        r"""GetRemoteInstallFileSpec(SBModule self) -> SBFileSpec"""
        return _lldb.SBModule_GetRemoteInstallFileSpec(self)

    def SetRemoteInstallFileSpec(self, file: "SBFileSpec") -> "bool":
        r"""SetRemoteInstallFileSpec(SBModule self, SBFileSpec file) -> bool"""
        return _lldb.SBModule_SetRemoteInstallFileSpec(self, file)

    def GetByteOrder(self) -> "lldb::ByteOrder":
        r"""GetByteOrder(SBModule self) -> lldb::ByteOrder"""
        return _lldb.SBModule_GetByteOrder(self)

    def GetAddressByteSize(self) -> int:
        r"""GetAddressByteSize(SBModule self) -> uint32_t"""
        return _lldb.SBModule_GetAddressByteSize(self)

    def GetTriple(self) -> str:
        r"""GetTriple(SBModule self) -> char const *"""
        return _lldb.SBModule_GetTriple(self)

    def GetUUIDBytes(self) -> "uint8_t const *":
        r"""GetUUIDBytes(SBModule self) -> uint8_t const *"""
        return _lldb.SBModule_GetUUIDBytes(self)

    def GetUUIDString(self) -> str:
        r"""
        GetUUIDString(SBModule self) -> char const *
        Returns the UUID of the module as a Python string.
        """
        return _lldb.SBModule_GetUUIDString(self)

    def __eq__(self, rhs: "SBModule") -> "bool":
        r"""__eq__(SBModule self, SBModule rhs) -> bool"""
        return _lldb.SBModule___eq__(self, rhs)

    def __ne__(self, rhs: "SBModule") -> "bool":
        r"""__ne__(SBModule self, SBModule rhs) -> bool"""
        return _lldb.SBModule___ne__(self, rhs)

    def FindSection(self, sect_name: str) -> "SBSection":
        r"""FindSection(SBModule self, char const * sect_name) -> SBSection"""
        return _lldb.SBModule_FindSection(self, sect_name)

    def ResolveFileAddress(self, vm_addr: int) -> "SBAddress":
        r"""ResolveFileAddress(SBModule self, lldb::addr_t vm_addr) -> SBAddress"""
        return _lldb.SBModule_ResolveFileAddress(self, vm_addr)

    def ResolveSymbolContextForAddress(self, addr: "SBAddress", resolve_scope: int) -> "SBSymbolContext":
        r"""ResolveSymbolContextForAddress(SBModule self, SBAddress addr, uint32_t resolve_scope) -> SBSymbolContext"""
        return _lldb.SBModule_ResolveSymbolContextForAddress(self, addr, resolve_scope)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBModule self, SBStream description) -> bool"""
        return _lldb.SBModule_GetDescription(self, description)

    def GetNumCompileUnits(self) -> int:
        r"""GetNumCompileUnits(SBModule self) -> uint32_t"""
        return _lldb.SBModule_GetNumCompileUnits(self)

    def GetCompileUnitAtIndex(self, arg2: int) -> "SBCompileUnit":
        r"""GetCompileUnitAtIndex(SBModule self, uint32_t arg2) -> SBCompileUnit"""
        return _lldb.SBModule_GetCompileUnitAtIndex(self, arg2)

    def FindCompileUnits(self, sb_file_spec: "SBFileSpec") -> "SBSymbolContextList":
        r"""
        FindCompileUnits(SBModule self, SBFileSpec sb_file_spec) -> SBSymbolContextList

            Find compile units related to this module and passed source
            file.

            @param[in] sb_file_spec
                A :py:class:`SBFileSpec` object that contains source file
                specification.

            @return
                A :py:class:`SBSymbolContextList` that gets filled in with all of
                the symbol contexts for all the matches.
        """
        return _lldb.SBModule_FindCompileUnits(self, sb_file_spec)

    def GetNumSymbols(self) -> "size_t":
        r"""GetNumSymbols(SBModule self) -> size_t"""
        return _lldb.SBModule_GetNumSymbols(self)

    def GetSymbolAtIndex(self, idx: "size_t") -> "SBSymbol":
        r"""GetSymbolAtIndex(SBModule self, size_t idx) -> SBSymbol"""
        return _lldb.SBModule_GetSymbolAtIndex(self, idx)

    def FindSymbol(self, *args) -> "SBSymbol":
        r"""FindSymbol(SBModule self, char const * name, lldb::SymbolType type=eSymbolTypeAny) -> SBSymbol"""
        return _lldb.SBModule_FindSymbol(self, *args)

    def FindSymbols(self, *args) -> "SBSymbolContextList":
        r"""FindSymbols(SBModule self, char const * name, lldb::SymbolType type=eSymbolTypeAny) -> SBSymbolContextList"""
        return _lldb.SBModule_FindSymbols(self, *args)

    def GetNumSections(self) -> "size_t":
        r"""GetNumSections(SBModule self) -> size_t"""
        return _lldb.SBModule_GetNumSections(self)

    def GetSectionAtIndex(self, idx: "size_t") -> "SBSection":
        r"""GetSectionAtIndex(SBModule self, size_t idx) -> SBSection"""
        return _lldb.SBModule_GetSectionAtIndex(self, idx)

    def FindFunctions(self, *args) -> "SBSymbolContextList":
        r"""
        FindFunctions(SBModule self, char const * name, uint32_t name_type_mask=eFunctionNameTypeAny) -> SBSymbolContextList

            Find functions by name.

            @param[in] name
                The name of the function we are looking for.

            @param[in] name_type_mask
                A logical OR of one or more FunctionNameType enum bits that
                indicate what kind of names should be used when doing the
                lookup. Bits include fully qualified names, base names,
                C++ methods, or ObjC selectors.
                See FunctionNameType for more details.

            @return
                A symbol context list that gets filled in with all of the
                matches.
        """
        return _lldb.SBModule_FindFunctions(self, *args)

    def FindGlobalVariables(self, target: "SBTarget", name: str, max_matches: int) -> "SBValueList":
        r"""
        FindGlobalVariables(SBModule self, SBTarget target, char const * name, uint32_t max_matches) -> SBValueList

            Find global and static variables by name.

            @param[in] target
                A valid SBTarget instance representing the debuggee.

            @param[in] name
                The name of the global or static variable we are looking
                for.

            @param[in] max_matches
                Allow the number of matches to be limited to max_matches.

            @return
                A list of matched variables in an SBValueList.
        """
        return _lldb.SBModule_FindGlobalVariables(self, target, name, max_matches)

    def FindFirstGlobalVariable(self, target: "SBTarget", name: str) -> "SBValue":
        r"""
        FindFirstGlobalVariable(SBModule self, SBTarget target, char const * name) -> SBValue

            Find the first global (or static) variable by name.

            @param[in] target
                A valid SBTarget instance representing the debuggee.

            @param[in] name
                The name of the global or static variable we are looking
                for.

            @return
                An SBValue that gets filled in with the found variable (if any).
        """
        return _lldb.SBModule_FindFirstGlobalVariable(self, target, name)

    def FindFirstType(self, name: str) -> "SBType":
        r"""FindFirstType(SBModule self, char const * name) -> SBType"""
        return _lldb.SBModule_FindFirstType(self, name)

    def FindTypes(self, type: str) -> "SBTypeList":
        r"""FindTypes(SBModule self, char const * type) -> SBTypeList"""
        return _lldb.SBModule_FindTypes(self, type)

    def GetTypeByID(self, uid: int) -> "SBType":
        r"""GetTypeByID(SBModule self, lldb::user_id_t uid) -> SBType"""
        return _lldb.SBModule_GetTypeByID(self, uid)

    def GetBasicType(self, type: "lldb::BasicType") -> "SBType":
        r"""GetBasicType(SBModule self, lldb::BasicType type) -> SBType"""
        return _lldb.SBModule_GetBasicType(self, type)

    def GetTypes(self, *args) -> "SBTypeList":
        r"""
        GetTypes(SBModule self, uint32_t type_mask=eTypeClassAny) -> SBTypeList

            Get all types matching type_mask from debug info in this
            module.

            @param[in] type_mask
                A bitfield that consists of one or more bits logically OR'ed
                together from the lldb::TypeClass enumeration. This allows
                you to request only structure types, or only class, struct
                and union types. Passing in lldb::eTypeClassAny will return
                all types found in the debug information for this module.

            @return
                A list of types in this module that match type_mask
        """
        return _lldb.SBModule_GetTypes(self, *args)

    def GetVersion(self) -> int:
        r"""GetVersion(SBModule self) -> uint32_t"""
        return _lldb.SBModule_GetVersion(self)

    def GetSymbolFileSpec(self) -> "SBFileSpec":
        r"""GetSymbolFileSpec(SBModule self) -> SBFileSpec"""
        return _lldb.SBModule_GetSymbolFileSpec(self)

    def GetObjectFileHeaderAddress(self) -> "SBAddress":
        r"""GetObjectFileHeaderAddress(SBModule self) -> SBAddress"""
        return _lldb.SBModule_GetObjectFileHeaderAddress(self)

    def GetObjectFileEntryPointAddress(self) -> "SBAddress":
        r"""GetObjectFileEntryPointAddress(SBModule self) -> SBAddress"""
        return _lldb.SBModule_GetObjectFileEntryPointAddress(self)

    @staticmethod
    def GetNumberAllocatedModules() -> int:
        r"""
        GetNumberAllocatedModules() -> uint32_t

            Returns the number of modules in the module cache. This is an
            implementation detail exposed for testing and should not be relied upon.

            @return
                The number of modules in the module cache.
        """
        return _lldb.SBModule_GetNumberAllocatedModules()

    @staticmethod
    def GarbageCollectAllocatedModules():
        r"""
        GarbageCollectAllocatedModules()

            Removes all modules which are no longer needed by any part of LLDB from
            the module cache.

            This is an implementation detail exposed for testing and should not be
            relied upon. Use SBDebugger::MemoryPressureDetected instead to reduce
            LLDB's memory consumption during execution.

        """
        return _lldb.SBModule_GarbageCollectAllocatedModules()

    def __repr__(self) -> str:
        r"""__repr__(SBModule self) -> std::string"""
        return _lldb.SBModule___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        '''Return the number of symbols in a lldb.SBModule object.'''
        return self.GetNumSymbols()

    def __iter__(self):
        '''Iterate over all symbols in a lldb.SBModule object.'''
        return lldb_iter(self, 'GetNumSymbols', 'GetSymbolAtIndex')

    def section_iter(self):
        '''Iterate over all sections in a lldb.SBModule object.'''
        return lldb_iter(self, 'GetNumSections', 'GetSectionAtIndex')

    def compile_unit_iter(self):
        '''Iterate over all compile units in a lldb.SBModule object.'''
        return lldb_iter(self, 'GetNumCompileUnits', 'GetCompileUnitAtIndex')

    def symbol_in_section_iter(self, section):
        '''Given a module and its contained section, returns an iterator on the
        symbols within the section.'''
        for sym in self:
            if in_range(sym, section):
                yield sym

    class symbols_access(object):
        re_compile_type = type(re.compile('.'))
        '''A helper object that will lazily hand out lldb.SBSymbol objects for a module when supplied an index, name, or regular expression.'''
        def __init__(self, sbmodule):
            self.sbmodule = sbmodule

        def __len__(self):
            if self.sbmodule:
                return int(self.sbmodule.GetNumSymbols())
            return 0

        def __getitem__(self, key):
            count = len(self)
            if type(key) is int:
                if -count <= key < count:
                    key %= count
                    return self.sbmodule.GetSymbolAtIndex(key)
            elif type(key) is str:
                matches = []
                sc_list = self.sbmodule.FindSymbols(key)
                for sc in sc_list:
                    symbol = sc.symbol
                    if symbol:
                        matches.append(symbol)
                return matches
            elif isinstance(key, self.re_compile_type):
                matches = []
                for idx in range(count):
                    symbol = self.sbmodule.GetSymbolAtIndex(idx)
                    added = False
                    name = symbol.name
                    if name:
                        re_match = key.search(name)
                        if re_match:
                            matches.append(symbol)
                            added = True
                    if not added:
                        mangled = symbol.mangled
                        if mangled:
                            re_match = key.search(mangled)
                            if re_match:
                                matches.append(symbol)
                return matches
            else:
                print("error: unsupported item type: %s" % type(key))
            return None

    def get_symbols_access_object(self):
        '''An accessor function that returns a symbols_access() object which allows lazy symbol access from a lldb.SBModule object.'''
        return self.symbols_access (self)

    def get_compile_units_access_object (self):
        '''An accessor function that returns a compile_units_access() object which allows lazy compile unit access from a lldb.SBModule object.'''
        return self.compile_units_access (self)

    def get_symbols_array(self):
        '''An accessor function that returns a list() that contains all symbols in a lldb.SBModule object.'''
        symbols = []
        for idx in range(self.num_symbols):
            symbols.append(self.GetSymbolAtIndex(idx))
        return symbols

    class sections_access(object):
        re_compile_type = type(re.compile('.'))
        '''A helper object that will lazily hand out lldb.SBSection objects for a module when supplied an index, name, or regular expression.'''
        def __init__(self, sbmodule):
            self.sbmodule = sbmodule

        def __len__(self):
            if self.sbmodule:
                return int(self.sbmodule.GetNumSections())
            return 0

        def __getitem__(self, key):
            count = len(self)
            if type(key) is int:
                if -count <= key < count:
                    key %= count
                    return self.sbmodule.GetSectionAtIndex(key)
            elif type(key) is str:
                for idx in range(count):
                    section = self.sbmodule.GetSectionAtIndex(idx)
                    if section.name == key:
                        return section
            elif isinstance(key, self.re_compile_type):
                matches = []
                for idx in range(count):
                    section = self.sbmodule.GetSectionAtIndex(idx)
                    name = section.name
                    if name:
                        re_match = key.search(name)
                        if re_match:
                            matches.append(section)
                return matches
            else:
                print("error: unsupported item type: %s" % type(key))
            return None

    class compile_units_access(object):
        re_compile_type = type(re.compile('.'))
        '''A helper object that will lazily hand out lldb.SBCompileUnit objects for a module when supplied an index, full or partial path, or regular expression.'''
        def __init__(self, sbmodule):
            self.sbmodule = sbmodule

        def __len__(self):
            if self.sbmodule:
                return int(self.sbmodule.GetNumCompileUnits())
            return 0

        def __getitem__(self, key):
            count = len(self)
            if type(key) is int:
                if -count <= key < count:
                    key %= count
                    return self.sbmodule.GetCompileUnitAtIndex(key)
            elif type(key) is str:
                is_full_path = key[0] == '/'
                for idx in range(count):
                    comp_unit = self.sbmodule.GetCompileUnitAtIndex(idx)
                    if is_full_path:
                        if comp_unit.file.fullpath == key:
                            return comp_unit
                    else:
                        if comp_unit.file.basename == key:
                            return comp_unit
            elif isinstance(key, self.re_compile_type):
                matches = []
                for idx in range(count):
                    comp_unit = self.sbmodule.GetCompileUnitAtIndex(idx)
                    fullpath = comp_unit.file.fullpath
                    if fullpath:
                        re_match = key.search(fullpath)
                        if re_match:
                            matches.append(comp_unit)
                return matches
            else:
                print("error: unsupported item type: %s" % type(key))
            return None

    def get_sections_access_object(self):
        '''An accessor function that returns a sections_access() object which allows lazy section array access.'''
        return self.sections_access (self)

    def get_sections_array(self):
        '''An accessor function that returns an array object that contains all sections in this module object.'''
        if not hasattr(self, 'sections_array'):
            self.sections_array = []
            for idx in range(self.num_sections):
                self.sections_array.append(self.GetSectionAtIndex(idx))
        return self.sections_array

    def get_compile_units_array(self):
        '''An accessor function that returns an array object that contains all compile_units in this module object.'''
        if not hasattr(self, 'compile_units_array'):
            self.compile_units_array = []
            for idx in range(self.GetNumCompileUnits()):
                self.compile_units_array.append(self.GetCompileUnitAtIndex(idx))
        return self.compile_units_array

    symbols = property(get_symbols_array, None, doc='''A read only property that returns a list() of lldb.SBSymbol objects contained in this module.''')
    symbol = property(get_symbols_access_object, None, doc='''A read only property that can be used to access symbols by index ("symbol = module.symbol[0]"), name ("symbols = module.symbol['main']"), or using a regular expression ("symbols = module.symbol[re.compile(...)]"). The return value is a single lldb.SBSymbol object for array access, and a list() of lldb.SBSymbol objects for name and regular expression access''')
    sections = property(get_sections_array, None, doc='''A read only property that returns a list() of lldb.SBSection objects contained in this module.''')
    compile_units = property(get_compile_units_array, None, doc='''A read only property that returns a list() of lldb.SBCompileUnit objects contained in this module.''')
    section = property(get_sections_access_object, None, doc='''A read only property that can be used to access symbols by index ("section = module.section[0]"), name ("sections = module.section[\'main\']"), or using a regular expression ("sections = module.section[re.compile(...)]"). The return value is a single lldb.SBSection object for array access, and a list() of lldb.SBSection objects for name and regular expression access''')
    section = property(get_sections_access_object, None, doc='''A read only property that can be used to access compile units by index ("compile_unit = module.compile_unit[0]"), name ("compile_unit = module.compile_unit[\'main.cpp\']"), or using a regular expression ("compile_unit = module.compile_unit[re.compile(...)]"). The return value is a single lldb.SBCompileUnit object for array access or by full or partial path, and a list() of lldb.SBCompileUnit objects regular expressions.''')

    def get_uuid(self):
        return uuid.UUID (self.GetUUIDString())

    uuid = property(get_uuid, None, doc='''A read only property that returns a standard python uuid.UUID object that represents the UUID of this module.''')
    file = property(GetFileSpec, None, doc='''A read only property that returns an lldb object that represents the file (lldb.SBFileSpec) for this object file for this module as it is represented where it is being debugged.''')
    platform_file = property(GetPlatformFileSpec, None, doc='''A read only property that returns an lldb object that represents the file (lldb.SBFileSpec) for this object file for this module as it is represented on the current host system.''')
    byte_order = property(GetByteOrder, None, doc='''A read only property that returns an lldb enumeration value (lldb.eByteOrderLittle, lldb.eByteOrderBig, lldb.eByteOrderInvalid) that represents the byte order for this module.''')
    addr_size = property(GetAddressByteSize, None, doc='''A read only property that returns the size in bytes of an address for this module.''')
    triple = property(GetTriple, None, doc='''A read only property that returns the target triple (arch-vendor-os) for this module.''')
    num_symbols = property(GetNumSymbols, None, doc='''A read only property that returns number of symbols in the module symbol table as an integer.''')
    num_sections = property(GetNumSections, None, doc='''A read only property that returns number of sections in the module as an integer.''')



    def __eq__(self, rhs):
        if not isinstance(rhs, type(self)):
            return False

        return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)

    def __ne__(self, rhs):
        if not isinstance(rhs, type(self)):
            return True

        return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)


# Register SBModule in _lldb:
_lldb.SBModule_swigregister(SBModule)

def SBModule_GetNumberAllocatedModules() -> int:
    r"""
    SBModule_GetNumberAllocatedModules() -> uint32_t

        Returns the number of modules in the module cache. This is an
        implementation detail exposed for testing and should not be relied upon.

        @return
            The number of modules in the module cache.
    """
    return _lldb.SBModule_GetNumberAllocatedModules()

def SBModule_GarbageCollectAllocatedModules():
    r"""
    SBModule_GarbageCollectAllocatedModules()

        Removes all modules which are no longer needed by any part of LLDB from
        the module cache.

        This is an implementation detail exposed for testing and should not be
        relied upon. Use SBDebugger::MemoryPressureDetected instead to reduce
        LLDB's memory consumption during execution.

    """
    return _lldb.SBModule_GarbageCollectAllocatedModules()

class SBModuleSpec(object):
    r"""Proxy of C++ lldb::SBModuleSpec class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBModuleSpec self) -> SBModuleSpec
        __init__(SBModuleSpec self, SBModuleSpec rhs) -> SBModuleSpec
        """
        _lldb.SBModuleSpec_swiginit(self, _lldb.new_SBModuleSpec(*args))
    __swig_destroy__ = _lldb.delete_SBModuleSpec

    def __nonzero__(self):
        return _lldb.SBModuleSpec___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBModuleSpec self) -> bool"""
        return _lldb.SBModuleSpec_IsValid(self)

    def Clear(self):
        r"""Clear(SBModuleSpec self)"""
        return _lldb.SBModuleSpec_Clear(self)

    def GetFileSpec(self) -> "SBFileSpec":
        r"""
        GetFileSpec(SBModuleSpec self) -> SBFileSpec

            Get const accessor for the module file.

            This function returns the file for the module on the host system
            that is running LLDB. This can differ from the path on the
            platform since we might be doing remote debugging.

            @return
                A const reference to the file specification object.
        """
        return _lldb.SBModuleSpec_GetFileSpec(self)

    def SetFileSpec(self, fspec: "SBFileSpec"):
        r"""SetFileSpec(SBModuleSpec self, SBFileSpec fspec)"""
        return _lldb.SBModuleSpec_SetFileSpec(self, fspec)

    def GetPlatformFileSpec(self) -> "SBFileSpec":
        r"""
        GetPlatformFileSpec(SBModuleSpec self) -> SBFileSpec

            Get accessor for the module platform file.

            Platform file refers to the path of the module as it is known on
            the remote system on which it is being debugged. For local
            debugging this is always the same as Module::GetFileSpec(). But
            remote debugging might mention a file '/usr/lib/liba.dylib'
            which might be locally downloaded and cached. In this case the
            platform file could be something like:
            '/tmp/lldb/platform-cache/remote.host.computer/usr/lib/liba.dylib'
            The file could also be cached in a local developer kit directory.

            @return
                A const reference to the file specification object.
        """
        return _lldb.SBModuleSpec_GetPlatformFileSpec(self)

    def SetPlatformFileSpec(self, fspec: "SBFileSpec"):
        r"""SetPlatformFileSpec(SBModuleSpec self, SBFileSpec fspec)"""
        return _lldb.SBModuleSpec_SetPlatformFileSpec(self, fspec)

    def GetSymbolFileSpec(self) -> "SBFileSpec":
        r"""GetSymbolFileSpec(SBModuleSpec self) -> SBFileSpec"""
        return _lldb.SBModuleSpec_GetSymbolFileSpec(self)

    def SetSymbolFileSpec(self, fspec: "SBFileSpec"):
        r"""SetSymbolFileSpec(SBModuleSpec self, SBFileSpec fspec)"""
        return _lldb.SBModuleSpec_SetSymbolFileSpec(self, fspec)

    def GetObjectName(self) -> str:
        r"""GetObjectName(SBModuleSpec self) -> char const *"""
        return _lldb.SBModuleSpec_GetObjectName(self)

    def SetObjectName(self, name: str):
        r"""SetObjectName(SBModuleSpec self, char const * name)"""
        return _lldb.SBModuleSpec_SetObjectName(self, name)

    def GetTriple(self) -> str:
        r"""GetTriple(SBModuleSpec self) -> char const *"""
        return _lldb.SBModuleSpec_GetTriple(self)

    def SetTriple(self, triple: str):
        r"""SetTriple(SBModuleSpec self, char const * triple)"""
        return _lldb.SBModuleSpec_SetTriple(self, triple)

    def GetUUIDBytes(self) -> "uint8_t const *":
        r"""GetUUIDBytes(SBModuleSpec self) -> uint8_t const *"""
        return _lldb.SBModuleSpec_GetUUIDBytes(self)

    def GetUUIDLength(self) -> "size_t":
        r"""GetUUIDLength(SBModuleSpec self) -> size_t"""
        return _lldb.SBModuleSpec_GetUUIDLength(self)

    def SetUUIDBytes(self, uuid: "uint8_t const *", uuid_len: "size_t") -> "bool":
        r"""SetUUIDBytes(SBModuleSpec self, uint8_t const * uuid, size_t uuid_len) -> bool"""
        return _lldb.SBModuleSpec_SetUUIDBytes(self, uuid, uuid_len)

    def GetObjectOffset(self) -> int:
        r"""GetObjectOffset(SBModuleSpec self) -> uint64_t"""
        return _lldb.SBModuleSpec_GetObjectOffset(self)

    def SetObjectOffset(self, object_offset: int):
        r"""SetObjectOffset(SBModuleSpec self, uint64_t object_offset)"""
        return _lldb.SBModuleSpec_SetObjectOffset(self, object_offset)

    def GetObjectSize(self) -> int:
        r"""GetObjectSize(SBModuleSpec self) -> uint64_t"""
        return _lldb.SBModuleSpec_GetObjectSize(self)

    def SetObjectSize(self, object_size: int):
        r"""SetObjectSize(SBModuleSpec self, uint64_t object_size)"""
        return _lldb.SBModuleSpec_SetObjectSize(self, object_size)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBModuleSpec self, SBStream description) -> bool"""
        return _lldb.SBModuleSpec_GetDescription(self, description)

    def __repr__(self) -> str:
        r"""__repr__(SBModuleSpec self) -> std::string"""
        return _lldb.SBModuleSpec___repr__(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBModuleSpec in _lldb:
_lldb.SBModuleSpec_swigregister(SBModuleSpec)

class SBModuleSpecList(object):
    r"""Represents a list of :py:class:`SBModuleSpec`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBModuleSpecList self) -> SBModuleSpecList
        __init__(SBModuleSpecList self, SBModuleSpecList rhs) -> SBModuleSpecList
        """
        _lldb.SBModuleSpecList_swiginit(self, _lldb.new_SBModuleSpecList(*args))
    __swig_destroy__ = _lldb.delete_SBModuleSpecList

    @staticmethod
    def GetModuleSpecifications(path: str) -> "SBModuleSpecList":
        r"""GetModuleSpecifications(char const * path) -> SBModuleSpecList"""
        return _lldb.SBModuleSpecList_GetModuleSpecifications(path)

    def Append(self, *args):
        r"""
        Append(SBModuleSpecList self, SBModuleSpec spec)
        Append(SBModuleSpecList self, SBModuleSpecList spec_list)
        """
        return _lldb.SBModuleSpecList_Append(self, *args)

    def FindFirstMatchingSpec(self, match_spec: "SBModuleSpec") -> "SBModuleSpec":
        r"""FindFirstMatchingSpec(SBModuleSpecList self, SBModuleSpec match_spec) -> SBModuleSpec"""
        return _lldb.SBModuleSpecList_FindFirstMatchingSpec(self, match_spec)

    def FindMatchingSpecs(self, match_spec: "SBModuleSpec") -> "SBModuleSpecList":
        r"""FindMatchingSpecs(SBModuleSpecList self, SBModuleSpec match_spec) -> SBModuleSpecList"""
        return _lldb.SBModuleSpecList_FindMatchingSpecs(self, match_spec)

    def GetSize(self) -> "size_t":
        r"""GetSize(SBModuleSpecList self) -> size_t"""
        return _lldb.SBModuleSpecList_GetSize(self)

    def GetSpecAtIndex(self, i: "size_t") -> "SBModuleSpec":
        r"""GetSpecAtIndex(SBModuleSpecList self, size_t i) -> SBModuleSpec"""
        return _lldb.SBModuleSpecList_GetSpecAtIndex(self, i)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBModuleSpecList self, SBStream description) -> bool"""
        return _lldb.SBModuleSpecList_GetDescription(self, description)

    def __repr__(self) -> str:
        r"""__repr__(SBModuleSpecList self) -> std::string"""
        return _lldb.SBModuleSpecList___repr__(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      '''Return the number of ModuleSpec in a lldb.SBModuleSpecList object.'''
      return self.GetSize()

    def __iter__(self):
      '''Iterate over all ModuleSpecs in a lldb.SBModuleSpecList object.'''
      return lldb_iter(self, 'GetSize', 'GetSpecAtIndex')


# Register SBModuleSpecList in _lldb:
_lldb.SBModuleSpecList_swigregister(SBModuleSpecList)

def SBModuleSpecList_GetModuleSpecifications(path: str) -> "SBModuleSpecList":
    r"""SBModuleSpecList_GetModuleSpecifications(char const * path) -> SBModuleSpecList"""
    return _lldb.SBModuleSpecList_GetModuleSpecifications(path)

class SBPlatformConnectOptions(object):
    r"""Describes how :py:class:`SBPlatform.ConnectRemote` connects to a remote platform."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBPlatformConnectOptions self, char const * url) -> SBPlatformConnectOptions
        __init__(SBPlatformConnectOptions self, SBPlatformConnectOptions rhs) -> SBPlatformConnectOptions
        """
        _lldb.SBPlatformConnectOptions_swiginit(self, _lldb.new_SBPlatformConnectOptions(*args))
    __swig_destroy__ = _lldb.delete_SBPlatformConnectOptions

    def GetURL(self) -> str:
        r"""GetURL(SBPlatformConnectOptions self) -> char const *"""
        return _lldb.SBPlatformConnectOptions_GetURL(self)

    def SetURL(self, url: str):
        r"""SetURL(SBPlatformConnectOptions self, char const * url)"""
        return _lldb.SBPlatformConnectOptions_SetURL(self, url)

    def GetRsyncEnabled(self) -> "bool":
        r"""GetRsyncEnabled(SBPlatformConnectOptions self) -> bool"""
        return _lldb.SBPlatformConnectOptions_GetRsyncEnabled(self)

    def EnableRsync(self, options: str, remote_path_prefix: str, omit_remote_hostname: "bool"):
        r"""EnableRsync(SBPlatformConnectOptions self, char const * options, char const * remote_path_prefix, bool omit_remote_hostname)"""
        return _lldb.SBPlatformConnectOptions_EnableRsync(self, options, remote_path_prefix, omit_remote_hostname)

    def DisableRsync(self):
        r"""DisableRsync(SBPlatformConnectOptions self)"""
        return _lldb.SBPlatformConnectOptions_DisableRsync(self)

    def GetLocalCacheDirectory(self) -> str:
        r"""GetLocalCacheDirectory(SBPlatformConnectOptions self) -> char const *"""
        return _lldb.SBPlatformConnectOptions_GetLocalCacheDirectory(self)

    def SetLocalCacheDirectory(self, path: str):
        r"""SetLocalCacheDirectory(SBPlatformConnectOptions self, char const * path)"""
        return _lldb.SBPlatformConnectOptions_SetLocalCacheDirectory(self, path)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBPlatformConnectOptions in _lldb:
_lldb.SBPlatformConnectOptions_swigregister(SBPlatformConnectOptions)

class SBPlatformShellCommand(object):
    r"""Represents a shell command that can be run by :py:class:`SBPlatform.Run`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBPlatformShellCommand self, char const * shell, char const * shell_command) -> SBPlatformShellCommand
        __init__(SBPlatformShellCommand self, char const * shell_command) -> SBPlatformShellCommand
        __init__(SBPlatformShellCommand self, SBPlatformShellCommand rhs) -> SBPlatformShellCommand
        """
        _lldb.SBPlatformShellCommand_swiginit(self, _lldb.new_SBPlatformShellCommand(*args))
    __swig_destroy__ = _lldb.delete_SBPlatformShellCommand

    def Clear(self):
        r"""Clear(SBPlatformShellCommand self)"""
        return _lldb.SBPlatformShellCommand_Clear(self)

    def GetShell(self) -> str:
        r"""GetShell(SBPlatformShellCommand self) -> char const *"""
        return _lldb.SBPlatformShellCommand_GetShell(self)

    def SetShell(self, shell: str):
        r"""SetShell(SBPlatformShellCommand self, char const * shell)"""
        return _lldb.SBPlatformShellCommand_SetShell(self, shell)

    def GetCommand(self) -> str:
        r"""GetCommand(SBPlatformShellCommand self) -> char const *"""
        return _lldb.SBPlatformShellCommand_GetCommand(self)

    def SetCommand(self, shell_command: str):
        r"""SetCommand(SBPlatformShellCommand self, char const * shell_command)"""
        return _lldb.SBPlatformShellCommand_SetCommand(self, shell_command)

    def GetWorkingDirectory(self) -> str:
        r"""GetWorkingDirectory(SBPlatformShellCommand self) -> char const *"""
        return _lldb.SBPlatformShellCommand_GetWorkingDirectory(self)

    def SetWorkingDirectory(self, path: str):
        r"""SetWorkingDirectory(SBPlatformShellCommand self, char const * path)"""
        return _lldb.SBPlatformShellCommand_SetWorkingDirectory(self, path)

    def GetTimeoutSeconds(self) -> int:
        r"""GetTimeoutSeconds(SBPlatformShellCommand self) -> uint32_t"""
        return _lldb.SBPlatformShellCommand_GetTimeoutSeconds(self)

    def SetTimeoutSeconds(self, sec: int):
        r"""SetTimeoutSeconds(SBPlatformShellCommand self, uint32_t sec)"""
        return _lldb.SBPlatformShellCommand_SetTimeoutSeconds(self, sec)

    def GetSignal(self) -> "int":
        r"""GetSignal(SBPlatformShellCommand self) -> int"""
        return _lldb.SBPlatformShellCommand_GetSignal(self)

    def GetStatus(self) -> "int":
        r"""GetStatus(SBPlatformShellCommand self) -> int"""
        return _lldb.SBPlatformShellCommand_GetStatus(self)

    def GetOutput(self) -> str:
        r"""GetOutput(SBPlatformShellCommand self) -> char const *"""
        return _lldb.SBPlatformShellCommand_GetOutput(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBPlatformShellCommand in _lldb:
_lldb.SBPlatformShellCommand_swigregister(SBPlatformShellCommand)

class SBPlatform(object):
    r"""
    A class that represents a platform that can represent the current host or a remote host debug platform.

    The SBPlatform class represents the current host, or a remote host.
    It can be connected to a remote platform in order to provide ways
    to remotely launch and attach to processes, upload/download files,
    create directories, run remote shell commands, find locally cached
    versions of files from the remote system, and much more.

    SBPlatform objects can be created and then used to connect to a remote
    platform which allows the SBPlatform to be used to get a list of the
    current processes on the remote host, attach to one of those processes,
    install programs on the remote system, attach and launch processes,
    and much more.

    Every :py:class:`SBTarget` has a corresponding SBPlatform. The platform can be
    specified upon target creation, or the currently selected platform
    will attempt to be used when creating the target automatically as long
    as the currently selected platform matches the target architecture
    and executable type. If the architecture or executable type do not match,
    a suitable platform will be found automatically.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBPlatform self) -> SBPlatform
        __init__(SBPlatform self, char const * platform_name) -> SBPlatform
        __init__(SBPlatform self, SBPlatform rhs) -> SBPlatform
        """
        _lldb.SBPlatform_swiginit(self, _lldb.new_SBPlatform(*args))
    __swig_destroy__ = _lldb.delete_SBPlatform

    @staticmethod
    def GetHostPlatform() -> "SBPlatform":
        r"""GetHostPlatform() -> SBPlatform"""
        return _lldb.SBPlatform_GetHostPlatform()

    def __nonzero__(self):
        return _lldb.SBPlatform___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBPlatform self) -> bool"""
        return _lldb.SBPlatform_IsValid(self)

    def Clear(self):
        r"""Clear(SBPlatform self)"""
        return _lldb.SBPlatform_Clear(self)

    def GetWorkingDirectory(self) -> str:
        r"""GetWorkingDirectory(SBPlatform self) -> char const *"""
        return _lldb.SBPlatform_GetWorkingDirectory(self)

    def SetWorkingDirectory(self, path: str) -> "bool":
        r"""SetWorkingDirectory(SBPlatform self, char const * path) -> bool"""
        return _lldb.SBPlatform_SetWorkingDirectory(self, path)

    def GetName(self) -> str:
        r"""GetName(SBPlatform self) -> char const *"""
        return _lldb.SBPlatform_GetName(self)

    def ConnectRemote(self, connect_options: "SBPlatformConnectOptions") -> "SBError":
        r"""ConnectRemote(SBPlatform self, SBPlatformConnectOptions connect_options) -> SBError"""
        return _lldb.SBPlatform_ConnectRemote(self, connect_options)

    def DisconnectRemote(self):
        r"""DisconnectRemote(SBPlatform self)"""
        return _lldb.SBPlatform_DisconnectRemote(self)

    def IsConnected(self) -> "bool":
        r"""IsConnected(SBPlatform self) -> bool"""
        return _lldb.SBPlatform_IsConnected(self)

    def GetTriple(self) -> str:
        r"""GetTriple(SBPlatform self) -> char const *"""
        return _lldb.SBPlatform_GetTriple(self)

    def GetHostname(self) -> str:
        r"""GetHostname(SBPlatform self) -> char const *"""
        return _lldb.SBPlatform_GetHostname(self)

    def GetOSBuild(self) -> str:
        r"""GetOSBuild(SBPlatform self) -> char const *"""
        return _lldb.SBPlatform_GetOSBuild(self)

    def GetOSDescription(self) -> str:
        r"""GetOSDescription(SBPlatform self) -> char const *"""
        return _lldb.SBPlatform_GetOSDescription(self)

    def GetOSMajorVersion(self) -> int:
        r"""GetOSMajorVersion(SBPlatform self) -> uint32_t"""
        return _lldb.SBPlatform_GetOSMajorVersion(self)

    def GetOSMinorVersion(self) -> int:
        r"""GetOSMinorVersion(SBPlatform self) -> uint32_t"""
        return _lldb.SBPlatform_GetOSMinorVersion(self)

    def GetOSUpdateVersion(self) -> int:
        r"""GetOSUpdateVersion(SBPlatform self) -> uint32_t"""
        return _lldb.SBPlatform_GetOSUpdateVersion(self)

    def SetSDKRoot(self, sysroot: str):
        r"""SetSDKRoot(SBPlatform self, char const * sysroot)"""
        return _lldb.SBPlatform_SetSDKRoot(self, sysroot)

    def Put(self, src: "SBFileSpec", dst: "SBFileSpec") -> "SBError":
        r"""Put(SBPlatform self, SBFileSpec src, SBFileSpec dst) -> SBError"""
        return _lldb.SBPlatform_Put(self, src, dst)

    def Get(self, src: "SBFileSpec", dst: "SBFileSpec") -> "SBError":
        r"""Get(SBPlatform self, SBFileSpec src, SBFileSpec dst) -> SBError"""
        return _lldb.SBPlatform_Get(self, src, dst)

    def Install(self, src: "SBFileSpec", dst: "SBFileSpec") -> "SBError":
        r"""Install(SBPlatform self, SBFileSpec src, SBFileSpec dst) -> SBError"""
        return _lldb.SBPlatform_Install(self, src, dst)

    def Run(self, shell_command: "SBPlatformShellCommand") -> "SBError":
        r"""Run(SBPlatform self, SBPlatformShellCommand shell_command) -> SBError"""
        return _lldb.SBPlatform_Run(self, shell_command)

    def Launch(self, launch_info: "SBLaunchInfo") -> "SBError":
        r"""Launch(SBPlatform self, SBLaunchInfo launch_info) -> SBError"""
        return _lldb.SBPlatform_Launch(self, launch_info)

    def Kill(self, pid: "lldb::pid_t const") -> "SBError":
        r"""Kill(SBPlatform self, lldb::pid_t const pid) -> SBError"""
        return _lldb.SBPlatform_Kill(self, pid)

    def MakeDirectory(self, *args) -> "SBError":
        r"""MakeDirectory(SBPlatform self, char const * path, uint32_t file_permissions=eFilePermissionsDirectoryDefault) -> SBError"""
        return _lldb.SBPlatform_MakeDirectory(self, *args)

    def GetFilePermissions(self, path: str) -> int:
        r"""GetFilePermissions(SBPlatform self, char const * path) -> uint32_t"""
        return _lldb.SBPlatform_GetFilePermissions(self, path)

    def SetFilePermissions(self, path: str, file_permissions: int) -> "SBError":
        r"""SetFilePermissions(SBPlatform self, char const * path, uint32_t file_permissions) -> SBError"""
        return _lldb.SBPlatform_SetFilePermissions(self, path, file_permissions)

    def GetUnixSignals(self) -> "SBUnixSignals":
        r"""GetUnixSignals(SBPlatform self) -> SBUnixSignals"""
        return _lldb.SBPlatform_GetUnixSignals(self)

    def GetEnvironment(self) -> "SBEnvironment":
        r"""GetEnvironment(SBPlatform self) -> SBEnvironment"""
        return _lldb.SBPlatform_GetEnvironment(self)

    def SetLocateModuleCallback(self, callback: "SBPlatformLocateModuleCallback") -> "SBError":
        r"""SetLocateModuleCallback(SBPlatform self, lldb::SBPlatformLocateModuleCallback callback) -> SBError"""
        return _lldb.SBPlatform_SetLocateModuleCallback(self, callback)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBPlatform in _lldb:
_lldb.SBPlatform_swigregister(SBPlatform)

def SBPlatform_GetHostPlatform() -> "SBPlatform":
    r"""SBPlatform_GetHostPlatform() -> SBPlatform"""
    return _lldb.SBPlatform_GetHostPlatform()

class SBProcess(object):
    r"""
    Represents the process associated with the target program.

    SBProcess supports thread iteration. For example (from test/lldbutil.py), ::

        # ==================================================
        # Utility functions related to Threads and Processes
        # ==================================================

        def get_stopped_threads(process, reason):
            '''Returns the thread(s) with the specified stop reason in a list.

            The list can be empty if no such thread exists.
            '''
            threads = []
            for t in process:
                if t.GetStopReason() == reason:
                    threads.append(t)
            return threads

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    eBroadcastBitStateChanged = _lldb.SBProcess_eBroadcastBitStateChanged

    eBroadcastBitInterrupt = _lldb.SBProcess_eBroadcastBitInterrupt

    eBroadcastBitSTDOUT = _lldb.SBProcess_eBroadcastBitSTDOUT

    eBroadcastBitSTDERR = _lldb.SBProcess_eBroadcastBitSTDERR

    eBroadcastBitProfileData = _lldb.SBProcess_eBroadcastBitProfileData

    eBroadcastBitStructuredData = _lldb.SBProcess_eBroadcastBitStructuredData


    def __init__(self, *args):
        r"""
        __init__(SBProcess self) -> SBProcess
        __init__(SBProcess self, SBProcess rhs) -> SBProcess
        """
        _lldb.SBProcess_swiginit(self, _lldb.new_SBProcess(*args))
    __swig_destroy__ = _lldb.delete_SBProcess

    @staticmethod
    def GetBroadcasterClassName() -> str:
        r"""GetBroadcasterClassName() -> char const *"""
        return _lldb.SBProcess_GetBroadcasterClassName()

    def GetPluginName(self) -> str:
        r"""GetPluginName(SBProcess self) -> char const *"""
        return _lldb.SBProcess_GetPluginName(self)

    def GetShortPluginName(self) -> str:
        r"""GetShortPluginName(SBProcess self) -> char const *"""
        return _lldb.SBProcess_GetShortPluginName(self)

    def Clear(self):
        r"""Clear(SBProcess self)"""
        return _lldb.SBProcess_Clear(self)

    def __nonzero__(self):
        return _lldb.SBProcess___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBProcess self) -> bool"""
        return _lldb.SBProcess_IsValid(self)

    def GetTarget(self) -> "SBTarget":
        r"""GetTarget(SBProcess self) -> SBTarget"""
        return _lldb.SBProcess_GetTarget(self)

    def GetByteOrder(self) -> "lldb::ByteOrder":
        r"""GetByteOrder(SBProcess self) -> lldb::ByteOrder"""
        return _lldb.SBProcess_GetByteOrder(self)

    def PutSTDIN(self, src: str) -> "size_t":
        r"""

        Writes data into the current process's stdin. API client specifies a Python
        string as the only argument.
        """
        return _lldb.SBProcess_PutSTDIN(self, src)

    def GetSTDOUT(self, dst: "char *") -> "size_t":
        r"""

        Reads data from the current process's stdout stream. API client specifies
        the size of the buffer to read data into. It returns the byte buffer in a
        Python string.
        """
        return _lldb.SBProcess_GetSTDOUT(self, dst)

    def GetSTDERR(self, dst: "char *") -> "size_t":
        r"""

        Reads data from the current process's stderr stream. API client specifies
        the size of the buffer to read data into. It returns the byte buffer in a
        Python string.
        """
        return _lldb.SBProcess_GetSTDERR(self, dst)

    def GetAsyncProfileData(self, dst: "char *") -> "size_t":
        r"""GetAsyncProfileData(SBProcess self, char * dst) -> size_t"""
        return _lldb.SBProcess_GetAsyncProfileData(self, dst)

    def ReportEventState(self, *args):
        r"""
        ReportEventState(SBProcess self, SBEvent event, SBFile file)
        ReportEventState(SBProcess self, SBEvent event, lldb::FileSP BORROWED)
        """
        return _lldb.SBProcess_ReportEventState(self, *args)

    def AppendEventStateReport(self, event: "SBEvent", result: "SBCommandReturnObject"):
        r"""AppendEventStateReport(SBProcess self, SBEvent event, SBCommandReturnObject result)"""
        return _lldb.SBProcess_AppendEventStateReport(self, event, result)

    def RemoteAttachToProcessWithID(self, pid: int, error: "SBError") -> "bool":
        r"""
        RemoteAttachToProcessWithID(SBProcess self, lldb::pid_t pid, SBError error) -> bool

            Remote connection related functions. These will fail if the
            process is not in eStateConnected. They are intended for use
            when connecting to an externally managed debugserver instance.
        """
        return _lldb.SBProcess_RemoteAttachToProcessWithID(self, pid, error)

    def RemoteLaunch(self, argv: "char const **", envp: "char const **", stdin_path: str, stdout_path: str, stderr_path: str, working_directory: str, launch_flags: int, stop_at_entry: "bool", error: "SBError") -> "bool":
        r"""
        RemoteLaunch(SBProcess self, char const ** argv, char const ** envp, char const * stdin_path, char const * stdout_path, char const * stderr_path, char const * working_directory, uint32_t launch_flags, bool stop_at_entry, SBError error) -> bool
        See SBTarget.Launch for argument description and usage.
        """
        return _lldb.SBProcess_RemoteLaunch(self, argv, envp, stdin_path, stdout_path, stderr_path, working_directory, launch_flags, stop_at_entry, error)

    def GetNumThreads(self) -> int:
        r"""GetNumThreads(SBProcess self) -> uint32_t"""
        return _lldb.SBProcess_GetNumThreads(self)

    def GetThreadAtIndex(self, index: "size_t") -> "SBThread":
        r"""

        Returns the INDEX'th thread from the list of current threads.  The index
        of a thread is only valid for the current stop.  For a persistent thread
        identifier use either the thread ID or the IndexID.  See help on SBThread
        for more details.
        """
        return _lldb.SBProcess_GetThreadAtIndex(self, index)

    def GetThreadByID(self, sb_thread_id: "lldb::tid_t") -> "SBThread":
        r"""

        Returns the thread with the given thread ID.
        """
        return _lldb.SBProcess_GetThreadByID(self, sb_thread_id)

    def GetThreadByIndexID(self, index_id: int) -> "SBThread":
        r"""

        Returns the thread with the given thread IndexID.
        """
        return _lldb.SBProcess_GetThreadByIndexID(self, index_id)

    def GetSelectedThread(self) -> "SBThread":
        r"""

        Returns the currently selected thread.
        """
        return _lldb.SBProcess_GetSelectedThread(self)

    def CreateOSPluginThread(self, tid: "lldb::tid_t", context: int) -> "SBThread":
        r"""

        Lazily create a thread on demand through the current OperatingSystem plug-in, if the current OperatingSystem plug-in supports it.
        """
        return _lldb.SBProcess_CreateOSPluginThread(self, tid, context)

    def SetSelectedThread(self, thread: "SBThread") -> "bool":
        r"""SetSelectedThread(SBProcess self, SBThread thread) -> bool"""
        return _lldb.SBProcess_SetSelectedThread(self, thread)

    def SetSelectedThreadByID(self, tid: "lldb::tid_t") -> "bool":
        r"""SetSelectedThreadByID(SBProcess self, lldb::tid_t tid) -> bool"""
        return _lldb.SBProcess_SetSelectedThreadByID(self, tid)

    def SetSelectedThreadByIndexID(self, index_id: int) -> "bool":
        r"""SetSelectedThreadByIndexID(SBProcess self, uint32_t index_id) -> bool"""
        return _lldb.SBProcess_SetSelectedThreadByIndexID(self, index_id)

    def GetNumQueues(self) -> int:
        r"""GetNumQueues(SBProcess self) -> uint32_t"""
        return _lldb.SBProcess_GetNumQueues(self)

    def GetQueueAtIndex(self, index: "size_t") -> "SBQueue":
        r"""GetQueueAtIndex(SBProcess self, size_t index) -> SBQueue"""
        return _lldb.SBProcess_GetQueueAtIndex(self, index)

    def GetState(self) -> "lldb::StateType":
        r"""GetState(SBProcess self) -> lldb::StateType"""
        return _lldb.SBProcess_GetState(self)

    def GetExitStatus(self) -> "int":
        r"""GetExitStatus(SBProcess self) -> int"""
        return _lldb.SBProcess_GetExitStatus(self)

    def GetExitDescription(self) -> str:
        r"""GetExitDescription(SBProcess self) -> char const *"""
        return _lldb.SBProcess_GetExitDescription(self)

    def GetProcessID(self) -> int:
        r"""

        Returns the process ID of the process.
        """
        return _lldb.SBProcess_GetProcessID(self)

    def GetUniqueID(self) -> int:
        r"""

        Returns an integer ID that is guaranteed to be unique across all process instances. This is not the process ID, just a unique integer for comparison and caching purposes.
        """
        return _lldb.SBProcess_GetUniqueID(self)

    def GetAddressByteSize(self) -> int:
        r"""GetAddressByteSize(SBProcess self) -> uint32_t"""
        return _lldb.SBProcess_GetAddressByteSize(self)

    def Destroy(self) -> "SBError":
        r"""
        Destroy(SBProcess self) -> SBError

            Kills the process and shuts down all threads that were spawned to
            track and monitor process.
        """
        return _lldb.SBProcess_Destroy(self)

    def Continue(self) -> "SBError":
        r"""Continue(SBProcess self) -> SBError"""
        return _lldb.SBProcess_Continue(self)

    def Stop(self) -> "SBError":
        r"""Stop(SBProcess self) -> SBError"""
        return _lldb.SBProcess_Stop(self)

    def Kill(self) -> "SBError":
        r"""
        Kill(SBProcess self) -> SBError
        Same as Destroy(self).
        """
        return _lldb.SBProcess_Kill(self)

    def Detach(self, *args) -> "SBError":
        r"""
        Detach(SBProcess self) -> SBError
        Detach(SBProcess self, bool keep_stopped) -> SBError
        """
        return _lldb.SBProcess_Detach(self, *args)

    def Signal(self, signal: "int") -> "SBError":
        r"""
        Signal(SBProcess self, int signal) -> SBError
        Sends the process a unix signal.
        """
        return _lldb.SBProcess_Signal(self, signal)

    def GetUnixSignals(self) -> "SBUnixSignals":
        r"""GetUnixSignals(SBProcess self) -> SBUnixSignals"""
        return _lldb.SBProcess_GetUnixSignals(self)

    def SendAsyncInterrupt(self):
        r"""SendAsyncInterrupt(SBProcess self)"""
        return _lldb.SBProcess_SendAsyncInterrupt(self)

    def GetStopID(self, include_expression_stops: "bool"=False) -> int:
        r"""
        GetStopID(SBProcess self, bool include_expression_stops=False) -> uint32_t

            Returns a stop id that will increase every time the process executes.  If
            include_expression_stops is true, then stops caused by expression evaluation
            will cause the returned value to increase, otherwise the counter returned will
            only increase when execution is continued explicitly by the user.  Note, the value
            will always increase, but may increase by more than one per stop.
        """
        return _lldb.SBProcess_GetStopID(self, include_expression_stops)

    def GetStopEventForStopID(self, stop_id: int) -> "SBEvent":
        r"""GetStopEventForStopID(SBProcess self, uint32_t stop_id) -> SBEvent"""
        return _lldb.SBProcess_GetStopEventForStopID(self, stop_id)

    def ForceScriptedState(self, new_state: "lldb::StateType"):
        r"""ForceScriptedState(SBProcess self, lldb::StateType new_state)"""
        return _lldb.SBProcess_ForceScriptedState(self, new_state)

    def ReadMemory(self, addr: int, buf: "void *", error: "SBError") -> "size_t":
        r"""

        Reads memory from the current process's address space and removes any
        traps that may have been inserted into the memory. It returns the byte
        buffer in a Python string. Example: ::

            # Read 4 bytes from address 'addr' and assume error.Success() is True.
            content = process.ReadMemory(addr, 4, error)
            new_bytes = bytearray(content)
        """
        return _lldb.SBProcess_ReadMemory(self, addr, buf, error)

    def WriteMemory(self, addr: int, buf: "void const *", error: "SBError") -> "size_t":
        r"""

        Writes memory to the current process's address space and maintains any
        traps that might be present due to software breakpoints. Example: ::

            # Create a Python string from the byte array.
            new_value = str(bytes)
            result = process.WriteMemory(addr, new_value, error)
            if not error.Success() or result != len(bytes):
                print('SBProcess.WriteMemory() failed!')
        """
        return _lldb.SBProcess_WriteMemory(self, addr, buf, error)

    def ReadCStringFromMemory(self, addr: int, char_buf: "void *", error: "SBError") -> "size_t":
        r"""

        Reads a NULL terminated C string from the current process's address space.
        It returns a python string of the exact length, or truncates the string if
        the maximum character limit is reached. Example: ::

            # Read a C string of at most 256 bytes from address '0x1000'
            error = lldb.SBError()
            cstring = process.ReadCStringFromMemory(0x1000, 256, error)
            if error.Success():
                print('cstring: ', cstring)
            else
                print('error: ', error)
        """
        return _lldb.SBProcess_ReadCStringFromMemory(self, addr, char_buf, error)

    def ReadUnsignedFromMemory(self, addr: int, byte_size: int, error: "SBError") -> int:
        r"""

        Reads an unsigned integer from memory given a byte size and an address.
        Returns the unsigned integer that was read. Example: ::

            # Read a 4 byte unsigned integer from address 0x1000
            error = lldb.SBError()
            uint = ReadUnsignedFromMemory(0x1000, 4, error)
            if error.Success():
                print('integer: %u' % uint)
            else
                print('error: ', error)
        """
        return _lldb.SBProcess_ReadUnsignedFromMemory(self, addr, byte_size, error)

    def ReadPointerFromMemory(self, addr: int, error: "SBError") -> int:
        r"""

        Reads a pointer from memory from an address and returns the value. Example: ::

            # Read a pointer from address 0x1000
            error = lldb.SBError()
            ptr = ReadPointerFromMemory(0x1000, error)
            if error.Success():
                print('pointer: 0x%x' % ptr)
            else
                print('error: ', error)
        """
        return _lldb.SBProcess_ReadPointerFromMemory(self, addr, error)

    @staticmethod
    def GetStateFromEvent(event: "SBEvent") -> "lldb::StateType":
        r"""GetStateFromEvent(SBEvent event) -> lldb::StateType"""
        return _lldb.SBProcess_GetStateFromEvent(event)

    @staticmethod
    def GetRestartedFromEvent(event: "SBEvent") -> "bool":
        r"""GetRestartedFromEvent(SBEvent event) -> bool"""
        return _lldb.SBProcess_GetRestartedFromEvent(event)

    @staticmethod
    def GetNumRestartedReasonsFromEvent(event: "SBEvent") -> "size_t":
        r"""GetNumRestartedReasonsFromEvent(SBEvent event) -> size_t"""
        return _lldb.SBProcess_GetNumRestartedReasonsFromEvent(event)

    @staticmethod
    def GetRestartedReasonAtIndexFromEvent(event: "SBEvent", idx: "size_t") -> str:
        r"""GetRestartedReasonAtIndexFromEvent(SBEvent event, size_t idx) -> char const *"""
        return _lldb.SBProcess_GetRestartedReasonAtIndexFromEvent(event, idx)

    @staticmethod
    def GetProcessFromEvent(event: "SBEvent") -> "SBProcess":
        r"""GetProcessFromEvent(SBEvent event) -> SBProcess"""
        return _lldb.SBProcess_GetProcessFromEvent(event)

    @staticmethod
    def GetInterruptedFromEvent(event: "SBEvent") -> "bool":
        r"""GetInterruptedFromEvent(SBEvent event) -> bool"""
        return _lldb.SBProcess_GetInterruptedFromEvent(event)

    @staticmethod
    def GetStructuredDataFromEvent(event: "SBEvent") -> "SBStructuredData":
        r"""GetStructuredDataFromEvent(SBEvent event) -> SBStructuredData"""
        return _lldb.SBProcess_GetStructuredDataFromEvent(event)

    @staticmethod
    def EventIsProcessEvent(event: "SBEvent") -> "bool":
        r"""EventIsProcessEvent(SBEvent event) -> bool"""
        return _lldb.SBProcess_EventIsProcessEvent(event)

    @staticmethod
    def EventIsStructuredDataEvent(event: "SBEvent") -> "bool":
        r"""EventIsStructuredDataEvent(SBEvent event) -> bool"""
        return _lldb.SBProcess_EventIsStructuredDataEvent(event)

    def GetBroadcaster(self) -> "SBBroadcaster":
        r"""GetBroadcaster(SBProcess self) -> SBBroadcaster"""
        return _lldb.SBProcess_GetBroadcaster(self)

    @staticmethod
    def GetBroadcasterClass() -> str:
        r"""Get default process broadcaster class name (lldb.process)."""
        return _lldb.SBProcess_GetBroadcasterClass()

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBProcess self, SBStream description) -> bool"""
        return _lldb.SBProcess_GetDescription(self, description)

    def GetExtendedCrashInformation(self) -> "SBStructuredData":
        r"""

        Returns the process' extended crash information.
        """
        return _lldb.SBProcess_GetExtendedCrashInformation(self)

    def GetNumSupportedHardwareWatchpoints(self, error: "SBError") -> int:
        r"""GetNumSupportedHardwareWatchpoints(SBProcess self, SBError error) -> uint32_t"""
        return _lldb.SBProcess_GetNumSupportedHardwareWatchpoints(self, error)

    def LoadImage(self, *args) -> int:
        r"""
        LoadImage(SBProcess self, SBFileSpec remote_image_spec, SBError error) -> uint32_t
        LoadImage(SBProcess self, SBFileSpec local_image_spec, SBFileSpec remote_image_spec, SBError error) -> uint32_t
        """
        return _lldb.SBProcess_LoadImage(self, *args)

    def LoadImageUsingPaths(self, image_spec: "SBFileSpec", paths: "SBStringList", loaded_path: "SBFileSpec", error: "SBError") -> int:
        r"""

        Load the library whose filename is given by image_spec looking in all the
        paths supplied in the paths argument.  If successful, return a token that
        can be passed to UnloadImage and fill loaded_path with the path that was
        successfully loaded.  On failure, return
        lldb.LLDB_INVALID_IMAGE_TOKEN.
        """
        return _lldb.SBProcess_LoadImageUsingPaths(self, image_spec, paths, loaded_path, error)

    def UnloadImage(self, image_token: int) -> "SBError":
        r"""UnloadImage(SBProcess self, uint32_t image_token) -> SBError"""
        return _lldb.SBProcess_UnloadImage(self, image_token)

    def SendEventData(self, data: str) -> "SBError":
        r"""SendEventData(SBProcess self, char const * data) -> SBError"""
        return _lldb.SBProcess_SendEventData(self, data)

    def GetNumExtendedBacktraceTypes(self) -> int:
        r"""

        Return the number of different thread-origin extended backtraces
        this process can support as a uint32_t.
        When the process is stopped and you have an SBThread, lldb may be
        able to show a backtrace of when that thread was originally created,
        or the work item was enqueued to it (in the case of a libdispatch
        queue).
        """
        return _lldb.SBProcess_GetNumExtendedBacktraceTypes(self)

    def GetExtendedBacktraceTypeAtIndex(self, idx: int) -> str:
        r"""

        Takes an index argument, returns the name of one of the thread-origin
        extended backtrace methods as a str.
        """
        return _lldb.SBProcess_GetExtendedBacktraceTypeAtIndex(self, idx)

    def GetHistoryThreads(self, addr: int) -> "SBThreadCollection":
        r"""GetHistoryThreads(SBProcess self, lldb::addr_t addr) -> SBThreadCollection"""
        return _lldb.SBProcess_GetHistoryThreads(self, addr)

    def IsInstrumentationRuntimePresent(self, type: "lldb::InstrumentationRuntimeType") -> "bool":
        r"""IsInstrumentationRuntimePresent(SBProcess self, lldb::InstrumentationRuntimeType type) -> bool"""
        return _lldb.SBProcess_IsInstrumentationRuntimePresent(self, type)

    def SaveCore(self, *args) -> "SBError":
        r"""
        SaveCore(SBProcess self, char const * file_name, char const * flavor, lldb::SaveCoreStyle core_style) -> SBError
        SaveCore(SBProcess self, char const * file_name) -> SBError
        """
        return _lldb.SBProcess_SaveCore(self, *args)

    def GetMemoryRegionInfo(self, load_addr: int, region_info: "SBMemoryRegionInfo") -> "SBError":
        r"""GetMemoryRegionInfo(SBProcess self, lldb::addr_t load_addr, SBMemoryRegionInfo region_info) -> SBError"""
        return _lldb.SBProcess_GetMemoryRegionInfo(self, load_addr, region_info)

    def GetMemoryRegions(self) -> "SBMemoryRegionInfoList":
        r"""GetMemoryRegions(SBProcess self) -> SBMemoryRegionInfoList"""
        return _lldb.SBProcess_GetMemoryRegions(self)

    def GetProcessInfo(self) -> "SBProcessInfo":
        r"""

        Get information about the process.
        Valid process info will only be returned when the process is alive,
        use IsValid() to check if the info returned is valid. ::

            process_info = process.GetProcessInfo()
            if process_info.IsValid():
                process_info.GetProcessID()
        """
        return _lldb.SBProcess_GetProcessInfo(self)

    def AllocateMemory(self, size: "size_t", permissions: int, error: "SBError") -> int:
        r"""

        Allocates a block of memory within the process, with size and
        access permissions specified in the arguments. The permissions
        argument is an or-combination of zero or more of
        lldb.ePermissionsWritable, lldb.ePermissionsReadable, and
        lldb.ePermissionsExecutable. Returns the address
        of the allocated buffer in the process, or
        lldb.LLDB_INVALID_ADDRESS if the allocation failed.
        """
        return _lldb.SBProcess_AllocateMemory(self, size, permissions, error)

    def DeallocateMemory(self, ptr: int) -> "SBError":
        r"""

        Deallocates the block of memory (previously allocated using
        AllocateMemory) given in the argument.
        """
        return _lldb.SBProcess_DeallocateMemory(self, ptr)

    def GetScriptedImplementation(self) -> "SBScriptObject":
        r"""

        Returns the implementation object of the process plugin if available. None
        otherwise.
        """
        return _lldb.SBProcess_GetScriptedImplementation(self)

    def __repr__(self) -> str:
        r"""__repr__(SBProcess self) -> std::string"""
        return _lldb.SBProcess___repr__(self)

    def WriteMemoryAsCString(self, addr, str, error):
        '''
          WriteMemoryAsCString(self, addr, str, error):
            This functions the same as `WriteMemory` except a null-terminator is appended
            to the end of the buffer if it is not there already.
        '''
        if not str or len(str) == 0:
            return 0
        if not str[-1] == '\0':
            str += '\0'
        return self.WriteMemory(addr, str, error)

    def __get_is_alive__(self):
        '''Returns "True" if the process is currently alive, "False" otherwise'''
        s = self.GetState()
        if (s == eStateAttaching or
            s == eStateLaunching or
            s == eStateStopped or
            s == eStateRunning or
            s == eStateStepping or
            s == eStateCrashed or
            s == eStateSuspended):
            return True
        return False

    def __get_is_running__(self):
        '''Returns "True" if the process is currently running, "False" otherwise'''
        state = self.GetState()
        if state == eStateRunning or state == eStateStepping:
            return True
        return False

    def __get_is_stopped__(self):
        '''Returns "True" if the process is currently stopped, "False" otherwise'''
        state = self.GetState()
        if state == eStateStopped or state == eStateCrashed or state == eStateSuspended:
            return True
        return False

    class threads_access(object):
        '''A helper object that will lazily hand out thread for a process when supplied an index.'''
        def __init__(self, sbprocess):
            self.sbprocess = sbprocess

        def __len__(self):
            if self.sbprocess:
                return int(self.sbprocess.GetNumThreads())
            return 0

        def __getitem__(self, key):
            if isinstance(key, int):
                count = len(self)
                if -count <= key < count:
                    key %= count
                    return self.sbprocess.GetThreadAtIndex(key)
            return None

    def get_threads_access_object(self):
        '''An accessor function that returns a modules_access() object which allows lazy thread access from a lldb.SBProcess object.'''
        return self.threads_access (self)

    def get_process_thread_list(self):
        '''An accessor function that returns a list() that contains all threads in a lldb.SBProcess object.'''
        threads = []
        accessor = self.get_threads_access_object()
        for idx in range(len(accessor)):
            threads.append(accessor[idx])
        return threads

    def __iter__(self):
        '''Iterate over all threads in a lldb.SBProcess object.'''
        return lldb_iter(self, 'GetNumThreads', 'GetThreadAtIndex')

    def __len__(self):
        '''Return the number of threads in a lldb.SBProcess object.'''
        return self.GetNumThreads()

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    threads = property(get_process_thread_list, None, doc='''A read only property that returns a list() of lldb.SBThread objects for this process.''')
    thread = property(get_threads_access_object, None, doc='''A read only property that returns an object that can access threads by thread index (thread = lldb.process.thread[12]).''')
    is_alive = property(__get_is_alive__, None, doc='''A read only property that returns a boolean value that indicates if this process is currently alive.''')
    is_running = property(__get_is_running__, None, doc='''A read only property that returns a boolean value that indicates if this process is currently running.''')
    is_stopped = property(__get_is_stopped__, None, doc='''A read only property that returns a boolean value that indicates if this process is currently stopped.''')
    id = property(GetProcessID, None, doc='''A read only property that returns the process ID as an integer.''')
    target = property(GetTarget, None, doc='''A read only property that an lldb object that represents the target (lldb.SBTarget) that owns this process.''')
    num_threads = property(GetNumThreads, None, doc='''A read only property that returns the number of threads in this process as an integer.''')
    selected_thread = property(GetSelectedThread, SetSelectedThread, doc='''A read/write property that gets/sets the currently selected thread in this process. The getter returns a lldb.SBThread object and the setter takes an lldb.SBThread object.''')
    state = property(GetState, None, doc='''A read only property that returns an lldb enumeration value (see enumerations that start with "lldb.eState") that represents the current state of this process (running, stopped, exited, etc.).''')
    exit_state = property(GetExitStatus, None, doc='''A read only property that returns an exit status as an integer of this process when the process state is lldb.eStateExited.''')
    exit_description = property(GetExitDescription, None, doc='''A read only property that returns an exit description as a string of this process when the process state is lldb.eStateExited.''')
    broadcaster = property(GetBroadcaster, None, doc='''A read only property that an lldb object that represents the broadcaster (lldb.SBBroadcaster) for this process.''')


# Register SBProcess in _lldb:
_lldb.SBProcess_swigregister(SBProcess)

def SBProcess_GetBroadcasterClassName() -> str:
    r"""SBProcess_GetBroadcasterClassName() -> char const *"""
    return _lldb.SBProcess_GetBroadcasterClassName()

def SBProcess_GetStateFromEvent(event: "SBEvent") -> "lldb::StateType":
    r"""SBProcess_GetStateFromEvent(SBEvent event) -> lldb::StateType"""
    return _lldb.SBProcess_GetStateFromEvent(event)

def SBProcess_GetRestartedFromEvent(event: "SBEvent") -> "bool":
    r"""SBProcess_GetRestartedFromEvent(SBEvent event) -> bool"""
    return _lldb.SBProcess_GetRestartedFromEvent(event)

def SBProcess_GetNumRestartedReasonsFromEvent(event: "SBEvent") -> "size_t":
    r"""SBProcess_GetNumRestartedReasonsFromEvent(SBEvent event) -> size_t"""
    return _lldb.SBProcess_GetNumRestartedReasonsFromEvent(event)

def SBProcess_GetRestartedReasonAtIndexFromEvent(event: "SBEvent", idx: "size_t") -> str:
    r"""SBProcess_GetRestartedReasonAtIndexFromEvent(SBEvent event, size_t idx) -> char const *"""
    return _lldb.SBProcess_GetRestartedReasonAtIndexFromEvent(event, idx)

def SBProcess_GetProcessFromEvent(event: "SBEvent") -> "SBProcess":
    r"""SBProcess_GetProcessFromEvent(SBEvent event) -> SBProcess"""
    return _lldb.SBProcess_GetProcessFromEvent(event)

def SBProcess_GetInterruptedFromEvent(event: "SBEvent") -> "bool":
    r"""SBProcess_GetInterruptedFromEvent(SBEvent event) -> bool"""
    return _lldb.SBProcess_GetInterruptedFromEvent(event)

def SBProcess_GetStructuredDataFromEvent(event: "SBEvent") -> "SBStructuredData":
    r"""SBProcess_GetStructuredDataFromEvent(SBEvent event) -> SBStructuredData"""
    return _lldb.SBProcess_GetStructuredDataFromEvent(event)

def SBProcess_EventIsProcessEvent(event: "SBEvent") -> "bool":
    r"""SBProcess_EventIsProcessEvent(SBEvent event) -> bool"""
    return _lldb.SBProcess_EventIsProcessEvent(event)

def SBProcess_EventIsStructuredDataEvent(event: "SBEvent") -> "bool":
    r"""SBProcess_EventIsStructuredDataEvent(SBEvent event) -> bool"""
    return _lldb.SBProcess_EventIsStructuredDataEvent(event)

def SBProcess_GetBroadcasterClass() -> str:
    r"""Get default process broadcaster class name (lldb.process)."""
    return _lldb.SBProcess_GetBroadcasterClass()

class SBProcessInfo(object):
    r"""
    Describes an existing process and any discoverable information that pertains to
    that process.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBProcessInfo self) -> SBProcessInfo
        __init__(SBProcessInfo self, SBProcessInfo rhs) -> SBProcessInfo
        """
        _lldb.SBProcessInfo_swiginit(self, _lldb.new_SBProcessInfo(*args))
    __swig_destroy__ = _lldb.delete_SBProcessInfo

    def __nonzero__(self):
        return _lldb.SBProcessInfo___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBProcessInfo self) -> bool"""
        return _lldb.SBProcessInfo_IsValid(self)

    def GetName(self) -> str:
        r"""GetName(SBProcessInfo self) -> char const *"""
        return _lldb.SBProcessInfo_GetName(self)

    def GetExecutableFile(self) -> "SBFileSpec":
        r"""GetExecutableFile(SBProcessInfo self) -> SBFileSpec"""
        return _lldb.SBProcessInfo_GetExecutableFile(self)

    def GetProcessID(self) -> int:
        r"""GetProcessID(SBProcessInfo self) -> lldb::pid_t"""
        return _lldb.SBProcessInfo_GetProcessID(self)

    def GetUserID(self) -> int:
        r"""GetUserID(SBProcessInfo self) -> uint32_t"""
        return _lldb.SBProcessInfo_GetUserID(self)

    def GetGroupID(self) -> int:
        r"""GetGroupID(SBProcessInfo self) -> uint32_t"""
        return _lldb.SBProcessInfo_GetGroupID(self)

    def UserIDIsValid(self) -> "bool":
        r"""UserIDIsValid(SBProcessInfo self) -> bool"""
        return _lldb.SBProcessInfo_UserIDIsValid(self)

    def GroupIDIsValid(self) -> "bool":
        r"""GroupIDIsValid(SBProcessInfo self) -> bool"""
        return _lldb.SBProcessInfo_GroupIDIsValid(self)

    def GetEffectiveUserID(self) -> int:
        r"""GetEffectiveUserID(SBProcessInfo self) -> uint32_t"""
        return _lldb.SBProcessInfo_GetEffectiveUserID(self)

    def GetEffectiveGroupID(self) -> int:
        r"""GetEffectiveGroupID(SBProcessInfo self) -> uint32_t"""
        return _lldb.SBProcessInfo_GetEffectiveGroupID(self)

    def EffectiveUserIDIsValid(self) -> "bool":
        r"""EffectiveUserIDIsValid(SBProcessInfo self) -> bool"""
        return _lldb.SBProcessInfo_EffectiveUserIDIsValid(self)

    def EffectiveGroupIDIsValid(self) -> "bool":
        r"""EffectiveGroupIDIsValid(SBProcessInfo self) -> bool"""
        return _lldb.SBProcessInfo_EffectiveGroupIDIsValid(self)

    def GetParentProcessID(self) -> int:
        r"""GetParentProcessID(SBProcessInfo self) -> lldb::pid_t"""
        return _lldb.SBProcessInfo_GetParentProcessID(self)

    def GetTriple(self) -> str:
        r"""
        GetTriple(SBProcessInfo self) -> char const *
        Return the target triple (arch-vendor-os) for the described process.
        """
        return _lldb.SBProcessInfo_GetTriple(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBProcessInfo in _lldb:
_lldb.SBProcessInfo_swigregister(SBProcessInfo)

class SBQueue(object):
    r"""Represents a libdispatch queue in the process."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBQueue self) -> SBQueue
        __init__(SBQueue self, SBQueue rhs) -> SBQueue
        """
        _lldb.SBQueue_swiginit(self, _lldb.new_SBQueue(*args))
    __swig_destroy__ = _lldb.delete_SBQueue

    def __nonzero__(self):
        return _lldb.SBQueue___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBQueue self) -> bool"""
        return _lldb.SBQueue_IsValid(self)

    def Clear(self):
        r"""Clear(SBQueue self)"""
        return _lldb.SBQueue_Clear(self)

    def GetProcess(self) -> "SBProcess":
        r"""GetProcess(SBQueue self) -> SBProcess"""
        return _lldb.SBQueue_GetProcess(self)

    def GetQueueID(self) -> "lldb::queue_id_t":
        r"""

        Returns an lldb::queue_id_t type unique identifier number for this
        queue that will not be used by any other queue during this process'
        execution.  These ID numbers often start at 1 with the first
        system-created queues and increment from there.
        """
        return _lldb.SBQueue_GetQueueID(self)

    def GetName(self) -> str:
        r"""GetName(SBQueue self) -> char const *"""
        return _lldb.SBQueue_GetName(self)

    def GetIndexID(self) -> int:
        r"""GetIndexID(SBQueue self) -> uint32_t"""
        return _lldb.SBQueue_GetIndexID(self)

    def GetNumThreads(self) -> int:
        r"""GetNumThreads(SBQueue self) -> uint32_t"""
        return _lldb.SBQueue_GetNumThreads(self)

    def GetThreadAtIndex(self, arg2: int) -> "SBThread":
        r"""GetThreadAtIndex(SBQueue self, uint32_t arg2) -> SBThread"""
        return _lldb.SBQueue_GetThreadAtIndex(self, arg2)

    def GetNumPendingItems(self) -> int:
        r"""GetNumPendingItems(SBQueue self) -> uint32_t"""
        return _lldb.SBQueue_GetNumPendingItems(self)

    def GetPendingItemAtIndex(self, arg2: int) -> "SBQueueItem":
        r"""GetPendingItemAtIndex(SBQueue self, uint32_t arg2) -> SBQueueItem"""
        return _lldb.SBQueue_GetPendingItemAtIndex(self, arg2)

    def GetNumRunningItems(self) -> int:
        r"""GetNumRunningItems(SBQueue self) -> uint32_t"""
        return _lldb.SBQueue_GetNumRunningItems(self)

    def GetKind(self) -> "lldb::QueueKind":
        r"""

        Returns an lldb::QueueKind enumerated value (e.g. eQueueKindUnknown,
        eQueueKindSerial, eQueueKindConcurrent) describing the type of this
        queue.
        """
        return _lldb.SBQueue_GetKind(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBQueue in _lldb:
_lldb.SBQueue_swigregister(SBQueue)

class SBQueueItem(object):
    r"""This class represents an item in an :py:class:`SBQueue`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(SBQueueItem self) -> SBQueueItem"""
        _lldb.SBQueueItem_swiginit(self, _lldb.new_SBQueueItem())
    __swig_destroy__ = _lldb.delete_SBQueueItem

    def __nonzero__(self):
        return _lldb.SBQueueItem___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBQueueItem self) -> bool"""
        return _lldb.SBQueueItem_IsValid(self)

    def Clear(self):
        r"""Clear(SBQueueItem self)"""
        return _lldb.SBQueueItem_Clear(self)

    def GetKind(self) -> "lldb::QueueItemKind":
        r"""GetKind(SBQueueItem self) -> lldb::QueueItemKind"""
        return _lldb.SBQueueItem_GetKind(self)

    def SetKind(self, kind: "lldb::QueueItemKind"):
        r"""SetKind(SBQueueItem self, lldb::QueueItemKind kind)"""
        return _lldb.SBQueueItem_SetKind(self, kind)

    def GetAddress(self) -> "SBAddress":
        r"""GetAddress(SBQueueItem self) -> SBAddress"""
        return _lldb.SBQueueItem_GetAddress(self)

    def SetAddress(self, addr: "SBAddress"):
        r"""SetAddress(SBQueueItem self, SBAddress addr)"""
        return _lldb.SBQueueItem_SetAddress(self, addr)

    def GetExtendedBacktraceThread(self, type: str) -> "SBThread":
        r"""GetExtendedBacktraceThread(SBQueueItem self, char const * type) -> SBThread"""
        return _lldb.SBQueueItem_GetExtendedBacktraceThread(self, type)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      return self.GetAddress()

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBQueueItem in _lldb:
_lldb.SBQueueItem_swigregister(SBQueueItem)

class SBReproducer(object):
    r"""Controls LLDB's reproducer functionality."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def Capture(path: str) -> str:
        r"""Capture(char const * path) -> char const *"""
        return _lldb.SBReproducer_Capture(path)

    @staticmethod
    def PassiveReplay(path: str) -> str:
        r"""PassiveReplay(char const * path) -> char const *"""
        return _lldb.SBReproducer_PassiveReplay(path)

    @staticmethod
    def SetAutoGenerate(b: "bool") -> "bool":
        r"""SetAutoGenerate(bool b) -> bool"""
        return _lldb.SBReproducer_SetAutoGenerate(b)

    @staticmethod
    def SetWorkingDirectory(path: str):
        r"""SetWorkingDirectory(char const * path)"""
        return _lldb.SBReproducer_SetWorkingDirectory(path)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


    def __init__(self):
        r"""__init__(SBReproducer self) -> SBReproducer"""
        _lldb.SBReproducer_swiginit(self, _lldb.new_SBReproducer())
    __swig_destroy__ = _lldb.delete_SBReproducer

# Register SBReproducer in _lldb:
_lldb.SBReproducer_swigregister(SBReproducer)

def SBReproducer_Capture(path: str) -> str:
    r"""SBReproducer_Capture(char const * path) -> char const *"""
    return _lldb.SBReproducer_Capture(path)

def SBReproducer_PassiveReplay(path: str) -> str:
    r"""SBReproducer_PassiveReplay(char const * path) -> char const *"""
    return _lldb.SBReproducer_PassiveReplay(path)

def SBReproducer_SetAutoGenerate(b: "bool") -> "bool":
    r"""SBReproducer_SetAutoGenerate(bool b) -> bool"""
    return _lldb.SBReproducer_SetAutoGenerate(b)

def SBReproducer_SetWorkingDirectory(path: str):
    r"""SBReproducer_SetWorkingDirectory(char const * path)"""
    return _lldb.SBReproducer_SetWorkingDirectory(path)

class SBScriptObject(object):
    r"""Proxy of C++ lldb::SBScriptObject class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBScriptObject self, lldb::ScriptObjectPtr const ptr, lldb::ScriptLanguage lang) -> SBScriptObject
        __init__(SBScriptObject self, SBScriptObject rhs) -> SBScriptObject
        """
        _lldb.SBScriptObject_swiginit(self, _lldb.new_SBScriptObject(*args))
    __swig_destroy__ = _lldb.delete_SBScriptObject

    def __nonzero__(self):
        return _lldb.SBScriptObject___nonzero__(self)
    __bool__ = __nonzero__



    def __ne__(self, rhs: "SBScriptObject") -> "bool":
        r"""__ne__(SBScriptObject self, SBScriptObject rhs) -> bool"""
        return _lldb.SBScriptObject___ne__(self, rhs)

    def IsValid(self) -> "bool":
        r"""IsValid(SBScriptObject self) -> bool"""
        return _lldb.SBScriptObject_IsValid(self)

    def GetPointer(self) -> "lldb::ScriptObjectPtr":
        r"""GetPointer(SBScriptObject self) -> lldb::ScriptObjectPtr"""
        return _lldb.SBScriptObject_GetPointer(self)

    def GetLanguage(self) -> "lldb::ScriptLanguage":
        r"""GetLanguage(SBScriptObject self) -> lldb::ScriptLanguage"""
        return _lldb.SBScriptObject_GetLanguage(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    ptr = property(GetPointer, None, doc='''A read only property that returns the underlying script object.''')
    lang = property(GetLanguage, None, doc='''A read only property that returns the script language associated with with this script object.''')


# Register SBScriptObject in _lldb:
_lldb.SBScriptObject_swigregister(SBScriptObject)

class SBSection(object):
    r"""
    Represents an executable image section.

    SBSection supports iteration through its subsection, represented as SBSection
    as well.  For example, ::

        for sec in exe_module:
            if sec.GetName() == '__TEXT':
                print sec
                break
        print INDENT + 'Number of subsections: %d' % sec.GetNumSubSections()
        for subsec in sec:
            print INDENT + repr(subsec)

    produces: ::

      [0x0000000100000000-0x0000000100002000) a.out.__TEXT
          Number of subsections: 6
          [0x0000000100001780-0x0000000100001d5c) a.out.__TEXT.__text
          [0x0000000100001d5c-0x0000000100001da4) a.out.__TEXT.__stubs
          [0x0000000100001da4-0x0000000100001e2c) a.out.__TEXT.__stub_helper
          [0x0000000100001e2c-0x0000000100001f10) a.out.__TEXT.__cstring
          [0x0000000100001f10-0x0000000100001f68) a.out.__TEXT.__unwind_info
          [0x0000000100001f68-0x0000000100001ff8) a.out.__TEXT.__eh_frame

    See also :py:class:`SBModule` .
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBSection self) -> SBSection
        __init__(SBSection self, SBSection rhs) -> SBSection
        """
        _lldb.SBSection_swiginit(self, _lldb.new_SBSection(*args))
    __swig_destroy__ = _lldb.delete_SBSection

    def __nonzero__(self):
        return _lldb.SBSection___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBSection self) -> bool"""
        return _lldb.SBSection_IsValid(self)

    def GetName(self) -> str:
        r"""GetName(SBSection self) -> char const *"""
        return _lldb.SBSection_GetName(self)

    def GetParent(self) -> "SBSection":
        r"""GetParent(SBSection self) -> SBSection"""
        return _lldb.SBSection_GetParent(self)

    def FindSubSection(self, sect_name: str) -> "SBSection":
        r"""FindSubSection(SBSection self, char const * sect_name) -> SBSection"""
        return _lldb.SBSection_FindSubSection(self, sect_name)

    def GetNumSubSections(self) -> "size_t":
        r"""GetNumSubSections(SBSection self) -> size_t"""
        return _lldb.SBSection_GetNumSubSections(self)

    def GetSubSectionAtIndex(self, idx: "size_t") -> "SBSection":
        r"""GetSubSectionAtIndex(SBSection self, size_t idx) -> SBSection"""
        return _lldb.SBSection_GetSubSectionAtIndex(self, idx)

    def GetFileAddress(self) -> int:
        r"""GetFileAddress(SBSection self) -> lldb::addr_t"""
        return _lldb.SBSection_GetFileAddress(self)

    def GetLoadAddress(self, target: "SBTarget") -> int:
        r"""GetLoadAddress(SBSection self, SBTarget target) -> lldb::addr_t"""
        return _lldb.SBSection_GetLoadAddress(self, target)

    def GetByteSize(self) -> int:
        r"""GetByteSize(SBSection self) -> lldb::addr_t"""
        return _lldb.SBSection_GetByteSize(self)

    def GetFileOffset(self) -> int:
        r"""GetFileOffset(SBSection self) -> uint64_t"""
        return _lldb.SBSection_GetFileOffset(self)

    def GetFileByteSize(self) -> int:
        r"""GetFileByteSize(SBSection self) -> uint64_t"""
        return _lldb.SBSection_GetFileByteSize(self)

    def GetSectionData(self, *args) -> "SBData":
        r"""
        GetSectionData(SBSection self) -> SBData
        GetSectionData(SBSection self, uint64_t offset, uint64_t size) -> SBData
        """
        return _lldb.SBSection_GetSectionData(self, *args)

    def GetSectionType(self) -> "lldb::SectionType":
        r"""GetSectionType(SBSection self) -> lldb::SectionType"""
        return _lldb.SBSection_GetSectionType(self)

    def GetPermissions(self) -> int:
        r"""GetPermissions(SBSection self) -> uint32_t"""
        return _lldb.SBSection_GetPermissions(self)

    def GetTargetByteSize(self) -> int:
        r"""
        GetTargetByteSize(SBSection self) -> uint32_t

            Return the size of a target's byte represented by this section
            in numbers of host bytes. Note that certain architectures have
            varying minimum addressable unit (i.e. byte) size for their
            CODE or DATA buses.

            @return
                The number of host (8-bit) bytes needed to hold a target byte
        """
        return _lldb.SBSection_GetTargetByteSize(self)

    def GetAlignment(self) -> int:
        r"""GetAlignment(SBSection self) -> uint32_t"""
        return _lldb.SBSection_GetAlignment(self)

    def __eq__(self, rhs: "SBSection") -> "bool":
        r"""__eq__(SBSection self, SBSection rhs) -> bool"""
        return _lldb.SBSection___eq__(self, rhs)

    def __ne__(self, rhs: "SBSection") -> "bool":
        r"""__ne__(SBSection self, SBSection rhs) -> bool"""
        return _lldb.SBSection___ne__(self, rhs)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBSection self, SBStream description) -> bool"""
        return _lldb.SBSection_GetDescription(self, description)

    def __repr__(self) -> str:
        r"""__repr__(SBSection self) -> std::string"""
        return _lldb.SBSection___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __iter__(self):
        '''Iterate over all subsections in a lldb.SBSection object.'''
        return lldb_iter(self, 'GetNumSubSections', 'GetSubSectionAtIndex')

    def __len__(self):
        '''Return the number of subsections in a lldb.SBSection object.'''
        return self.GetNumSubSections()

    def get_addr(self):
        return SBAddress(self, 0)

    name = property(GetName, None, doc='''A read only property that returns the name of this section as a string.''')
    addr = property(get_addr, None, doc='''A read only property that returns an lldb object that represents the start address (lldb.SBAddress) for this section.''')
    file_addr = property(GetFileAddress, None, doc='''A read only property that returns an integer that represents the starting "file" address for this section, or the address of the section in the object file in which it is defined.''')
    size = property(GetByteSize, None, doc='''A read only property that returns the size in bytes of this section as an integer.''')
    file_offset = property(GetFileOffset, None, doc='''A read only property that returns the file offset in bytes of this section as an integer.''')
    file_size = property(GetFileByteSize, None, doc='''A read only property that returns the file size in bytes of this section as an integer.''')
    data = property(GetSectionData, None, doc='''A read only property that returns an lldb object that represents the bytes for this section (lldb.SBData) for this section.''')
    type = property(GetSectionType, None, doc='''A read only property that returns an lldb enumeration value (see enumerations that start with "lldb.eSectionType") that represents the type of this section (code, data, etc.).''')
    target_byte_size = property(GetTargetByteSize, None, doc='''A read only property that returns the size of a target byte represented by this section as a number of host bytes.''')
    alignment = property(GetAlignment, None, doc='''A read only property that returns the alignment of this section as a number of host bytes.''')


    def __eq__(self, rhs):
        if not isinstance(rhs, type(self)):
            return False

        return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)

    def __ne__(self, rhs):
        if not isinstance(rhs, type(self)):
            return True

        return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)


# Register SBSection in _lldb:
_lldb.SBSection_swigregister(SBSection)

class SBSourceManager(object):
    r"""
    Represents a central authority for displaying source code.

    For example (from test/source-manager/TestSourceManager.py), ::

            # Create the filespec for 'main.c'.
            filespec = lldb.SBFileSpec('main.c', False)
            source_mgr = self.dbg.GetSourceManager()
            # Use a string stream as the destination.
            stream = lldb.SBStream()
            source_mgr.DisplaySourceLinesWithLineNumbers(filespec,
                                                         self.line,
                                                         2, # context before
                                                         2, # context after
                                                         '=>', # prefix for current line
                                                         stream)

            #    2
            #    3    int main(int argc, char const *argv[]) {
            # => 4        printf('Hello world.\n'); // Set break point at this line.
            #    5        return 0;
            #    6    }
            self.expect(stream.GetData(), 'Source code displayed correctly',
                        exe=False,
                patterns = ['=> %d.*Hello world' % self.line])
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBSourceManager self, SBDebugger debugger) -> SBSourceManager
        __init__(SBSourceManager self, SBTarget target) -> SBSourceManager
        __init__(SBSourceManager self, SBSourceManager rhs) -> SBSourceManager
        """
        _lldb.SBSourceManager_swiginit(self, _lldb.new_SBSourceManager(*args))
    __swig_destroy__ = _lldb.delete_SBSourceManager

    def DisplaySourceLinesWithLineNumbers(self, file: "SBFileSpec", line: int, context_before: int, context_after: int, current_line_cstr: str, s: "SBStream") -> "size_t":
        r"""DisplaySourceLinesWithLineNumbers(SBSourceManager self, SBFileSpec file, uint32_t line, uint32_t context_before, uint32_t context_after, char const * current_line_cstr, SBStream s) -> size_t"""
        return _lldb.SBSourceManager_DisplaySourceLinesWithLineNumbers(self, file, line, context_before, context_after, current_line_cstr, s)

    def DisplaySourceLinesWithLineNumbersAndColumn(self, file: "SBFileSpec", line: int, column: int, context_before: int, context_after: int, current_line_cstr: str, s: "SBStream") -> "size_t":
        r"""DisplaySourceLinesWithLineNumbersAndColumn(SBSourceManager self, SBFileSpec file, uint32_t line, uint32_t column, uint32_t context_before, uint32_t context_after, char const * current_line_cstr, SBStream s) -> size_t"""
        return _lldb.SBSourceManager_DisplaySourceLinesWithLineNumbersAndColumn(self, file, line, column, context_before, context_after, current_line_cstr, s)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBSourceManager in _lldb:
_lldb.SBSourceManager_swigregister(SBSourceManager)

class SBStream(object):
    r"""
    Represents a destination for streaming data output to. By default, a string
    stream is created.

    For example (from test/source-manager/TestSourceManager.py), ::

            # Create the filespec for 'main.c'.
            filespec = lldb.SBFileSpec('main.c', False)
            source_mgr = self.dbg.GetSourceManager()
            # Use a string stream as the destination.
            stream = lldb.SBStream()
            source_mgr.DisplaySourceLinesWithLineNumbers(filespec,
                                                         self.line,
                                                         2, # context before
                                                         2, # context after
                                                         '=>', # prefix for current line
                                                         stream)

            #    2
            #    3    int main(int argc, char const *argv[]) {
            # => 4        printf('Hello world.\n'); // Set break point at this line.
            #    5        return 0;
            #    6    }
            self.expect(stream.GetData(), 'Source code displayed correctly',
                        exe=False,
                patterns = ['=> %d.*Hello world' % self.line])
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(SBStream self) -> SBStream"""
        _lldb.SBStream_swiginit(self, _lldb.new_SBStream())
    __swig_destroy__ = _lldb.delete_SBStream

    def __nonzero__(self):
        return _lldb.SBStream___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBStream self) -> bool"""
        return _lldb.SBStream_IsValid(self)

    def GetData(self) -> str:
        r"""
        GetData(SBStream self) -> char const *

            If this stream is not redirected to a file, it will maintain a local
            cache for the stream data which can be accessed using this accessor.
        """
        return _lldb.SBStream_GetData(self)

    def GetSize(self) -> "size_t":
        r"""
        GetSize(SBStream self) -> size_t

            If this stream is not redirected to a file, it will maintain a local
            cache for the stream output whose length can be accessed using this
            accessor.
        """
        return _lldb.SBStream_GetSize(self)

    def Print(self, str: str):
        r"""Print(SBStream self, char const * str)"""
        return _lldb.SBStream_Print(self, str)

    def RedirectToFile(self, *args):
        r"""
        RedirectToFile(SBStream self, char const * path, bool append)
        RedirectToFile(SBStream self, SBFile file)
        RedirectToFile(SBStream self, lldb::FileSP file)
        """
        return _lldb.SBStream_RedirectToFile(self, *args)

    def RedirectToFileDescriptor(self, fd: "int", transfer_fh_ownership: "bool"):
        r"""RedirectToFileDescriptor(SBStream self, int fd, bool transfer_fh_ownership)"""
        return _lldb.SBStream_RedirectToFileDescriptor(self, fd, transfer_fh_ownership)

    def Clear(self):
        r"""
        Clear(SBStream self)

            If the stream is redirected to a file, forget about the file and if
            ownership of the file was transferred to this object, close the file.
            If the stream is backed by a local cache, clear this cache.
        """
        return _lldb.SBStream_Clear(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      return self.GetSize()

    def __iter__(self):
      pass


    def RedirectToFileHandle(self, file: "lldb::FileSP", transfer_fh_ownership: "bool"):
        r"""DEPRECATED, use RedirectToFile"""
        return _lldb.SBStream_RedirectToFileHandle(self, file, transfer_fh_ownership)

    def write(self, str: str):
        r"""write(SBStream self, char const * str)"""
        return _lldb.SBStream_write(self, str)

    def flush(self):
        r"""flush(SBStream self)"""
        return _lldb.SBStream_flush(self)

# Register SBStream in _lldb:
_lldb.SBStream_swigregister(SBStream)

class SBStringList(object):
    r"""Represents a list of strings."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBStringList self) -> SBStringList
        __init__(SBStringList self, SBStringList rhs) -> SBStringList
        """
        _lldb.SBStringList_swiginit(self, _lldb.new_SBStringList(*args))
    __swig_destroy__ = _lldb.delete_SBStringList

    def __nonzero__(self):
        return _lldb.SBStringList___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBStringList self) -> bool"""
        return _lldb.SBStringList_IsValid(self)

    def AppendString(self, str: str):
        r"""AppendString(SBStringList self, char const * str)"""
        return _lldb.SBStringList_AppendString(self, str)

    def AppendList(self, *args):
        r"""
        AppendList(SBStringList self, char const ** strv, int strc)
        AppendList(SBStringList self, SBStringList strings)
        """
        return _lldb.SBStringList_AppendList(self, *args)

    def GetSize(self) -> int:
        r"""GetSize(SBStringList self) -> uint32_t"""
        return _lldb.SBStringList_GetSize(self)

    def GetStringAtIndex(self, *args) -> str:
        r"""
        GetStringAtIndex(SBStringList self, size_t idx) -> char const
        GetStringAtIndex(SBStringList self, size_t idx) -> char const *
        """
        return _lldb.SBStringList_GetStringAtIndex(self, *args)

    def Clear(self):
        r"""Clear(SBStringList self)"""
        return _lldb.SBStringList_Clear(self)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __iter__(self):
        '''Iterate over all strings in a lldb.SBStringList object.'''
        return lldb_iter(self, 'GetSize', 'GetStringAtIndex')

    def __len__(self):
        '''Return the number of strings in a lldb.SBStringList object.'''
        return self.GetSize()


# Register SBStringList in _lldb:
_lldb.SBStringList_swigregister(SBStringList)

class SBStructuredData(object):
    r"""
    A class representing a StructuredData event.

    This class wraps the event type generated by StructuredData features.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBStructuredData self) -> SBStructuredData
        __init__(SBStructuredData self, SBStructuredData rhs) -> SBStructuredData
        __init__(SBStructuredData self, SBScriptObject obj, SBDebugger debugger) -> SBStructuredData
        """
        _lldb.SBStructuredData_swiginit(self, _lldb.new_SBStructuredData(*args))
    __swig_destroy__ = _lldb.delete_SBStructuredData

    def __nonzero__(self):
        return _lldb.SBStructuredData___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBStructuredData self) -> bool"""
        return _lldb.SBStructuredData_IsValid(self)

    def SetFromJSON(self, *args) -> "SBError":
        r"""
        SetFromJSON(SBStructuredData self, SBStream stream) -> SBError
        SetFromJSON(SBStructuredData self, char const * json) -> SBError
        """
        return _lldb.SBStructuredData_SetFromJSON(self, *args)

    def Clear(self):
        r"""Clear(SBStructuredData self)"""
        return _lldb.SBStructuredData_Clear(self)

    def GetAsJSON(self, stream: "SBStream") -> "SBError":
        r"""GetAsJSON(SBStructuredData self, SBStream stream) -> SBError"""
        return _lldb.SBStructuredData_GetAsJSON(self, stream)

    def GetDescription(self, stream: "SBStream") -> "SBError":
        r"""GetDescription(SBStructuredData self, SBStream stream) -> SBError"""
        return _lldb.SBStructuredData_GetDescription(self, stream)

    def GetType(self) -> "lldb::StructuredDataType":
        r"""GetType(SBStructuredData self) -> lldb::StructuredDataType"""
        return _lldb.SBStructuredData_GetType(self)

    def GetSize(self) -> "size_t":
        r"""GetSize(SBStructuredData self) -> size_t"""
        return _lldb.SBStructuredData_GetSize(self)

    def GetKeys(self, keys: "SBStringList") -> "bool":
        r"""GetKeys(SBStructuredData self, SBStringList keys) -> bool"""
        return _lldb.SBStructuredData_GetKeys(self, keys)

    def GetValueForKey(self, key: str) -> "SBStructuredData":
        r"""GetValueForKey(SBStructuredData self, char const * key) -> SBStructuredData"""
        return _lldb.SBStructuredData_GetValueForKey(self, key)

    def GetItemAtIndex(self, idx: "size_t") -> "SBStructuredData":
        r"""GetItemAtIndex(SBStructuredData self, size_t idx) -> SBStructuredData"""
        return _lldb.SBStructuredData_GetItemAtIndex(self, idx)

    def GetUnsignedIntegerValue(self, fail_value: int=0) -> int:
        r"""GetUnsignedIntegerValue(SBStructuredData self, uint64_t fail_value=0) -> uint64_t"""
        return _lldb.SBStructuredData_GetUnsignedIntegerValue(self, fail_value)

    def GetSignedIntegerValue(self, fail_value: "int64_t"=0) -> "int64_t":
        r"""GetSignedIntegerValue(SBStructuredData self, int64_t fail_value=0) -> int64_t"""
        return _lldb.SBStructuredData_GetSignedIntegerValue(self, fail_value)

    def GetIntegerValue(self, fail_value: int=0) -> int:
        r"""GetIntegerValue(SBStructuredData self, uint64_t fail_value=0) -> uint64_t"""
        return _lldb.SBStructuredData_GetIntegerValue(self, fail_value)

    def GetFloatValue(self, fail_value: "double"=0.0) -> "double":
        r"""GetFloatValue(SBStructuredData self, double fail_value=0.0) -> double"""
        return _lldb.SBStructuredData_GetFloatValue(self, fail_value)

    def GetBooleanValue(self, fail_value: "bool"=False) -> "bool":
        r"""GetBooleanValue(SBStructuredData self, bool fail_value=False) -> bool"""
        return _lldb.SBStructuredData_GetBooleanValue(self, fail_value)

    def GetStringValue(self, dst: "char *") -> "size_t":
        r"""GetStringValue(SBStructuredData self, char * dst) -> size_t"""
        return _lldb.SBStructuredData_GetStringValue(self, dst)

    def GetGenericValue(self) -> "SBScriptObject":
        r"""GetGenericValue(SBStructuredData self) -> SBScriptObject"""
        return _lldb.SBStructuredData_GetGenericValue(self)

    def __repr__(self) -> str:
        r"""__repr__(SBStructuredData self) -> std::string"""
        return _lldb.SBStructuredData___repr__(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      return self.GetSignedInteger()

    def __hex__(self):
      return hex(self.GetSignedInteger())

    def __oct__(self):
      return oct(self.GetSignedInteger())

    def __len__(self):
      '''Return the number of element in a lldb.SBStructuredData object.'''
      return self.GetSize()

    def __iter__(self):
        '''Iterate over all the elements in a lldb.SBStructuredData object.'''
        return lldb_iter(self, 'GetSize', 'GetItemAtIndex')


# Register SBStructuredData in _lldb:
_lldb.SBStructuredData_swigregister(SBStructuredData)

class SBSymbol(object):
    r"""
    Represents the symbol possibly associated with a stack frame.
    :py:class:`SBModule` contains SBSymbol(s). SBSymbol can also be retrieved from :py:class:`SBFrame` .
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __swig_destroy__ = _lldb.delete_SBSymbol

    def __init__(self, *args):
        r"""
        __init__(SBSymbol self) -> SBSymbol
        __init__(SBSymbol self, SBSymbol rhs) -> SBSymbol
        """
        _lldb.SBSymbol_swiginit(self, _lldb.new_SBSymbol(*args))

    def __nonzero__(self):
        return _lldb.SBSymbol___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBSymbol self) -> bool"""
        return _lldb.SBSymbol_IsValid(self)

    def GetName(self) -> str:
        r"""GetName(SBSymbol self) -> char const *"""
        return _lldb.SBSymbol_GetName(self)

    def GetDisplayName(self) -> str:
        r"""GetDisplayName(SBSymbol self) -> char const *"""
        return _lldb.SBSymbol_GetDisplayName(self)

    def GetMangledName(self) -> str:
        r"""GetMangledName(SBSymbol self) -> char const *"""
        return _lldb.SBSymbol_GetMangledName(self)

    def GetInstructions(self, *args) -> "SBInstructionList":
        r"""
        GetInstructions(SBSymbol self, SBTarget target) -> SBInstructionList
        GetInstructions(SBSymbol self, SBTarget target, char const * flavor_string) -> SBInstructionList
        """
        return _lldb.SBSymbol_GetInstructions(self, *args)

    def GetStartAddress(self) -> "SBAddress":
        r"""GetStartAddress(SBSymbol self) -> SBAddress"""
        return _lldb.SBSymbol_GetStartAddress(self)

    def GetEndAddress(self) -> "SBAddress":
        r"""GetEndAddress(SBSymbol self) -> SBAddress"""
        return _lldb.SBSymbol_GetEndAddress(self)

    def GetValue(self) -> int:
        r"""GetValue(SBSymbol self) -> uint64_t"""
        return _lldb.SBSymbol_GetValue(self)

    def GetSize(self) -> int:
        r"""GetSize(SBSymbol self) -> uint64_t"""
        return _lldb.SBSymbol_GetSize(self)

    def GetPrologueByteSize(self) -> int:
        r"""GetPrologueByteSize(SBSymbol self) -> uint32_t"""
        return _lldb.SBSymbol_GetPrologueByteSize(self)

    def GetType(self) -> "lldb::SymbolType":
        r"""GetType(SBSymbol self) -> lldb::SymbolType"""
        return _lldb.SBSymbol_GetType(self)

    def __eq__(self, rhs: "SBSymbol") -> "bool":
        r"""__eq__(SBSymbol self, SBSymbol rhs) -> bool"""
        return _lldb.SBSymbol___eq__(self, rhs)

    def __ne__(self, rhs: "SBSymbol") -> "bool":
        r"""__ne__(SBSymbol self, SBSymbol rhs) -> bool"""
        return _lldb.SBSymbol___ne__(self, rhs)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBSymbol self, SBStream description) -> bool"""
        return _lldb.SBSymbol_GetDescription(self, description)

    def IsExternal(self) -> "bool":
        r"""IsExternal(SBSymbol self) -> bool"""
        return _lldb.SBSymbol_IsExternal(self)

    def IsSynthetic(self) -> "bool":
        r"""IsSynthetic(SBSymbol self) -> bool"""
        return _lldb.SBSymbol_IsSynthetic(self)

    def __repr__(self) -> str:
        r"""__repr__(SBSymbol self) -> std::string"""
        return _lldb.SBSymbol___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        return self.GetStartAddress()

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    def get_instructions_from_current_target (self):
        return self.GetInstructions (target)

    name = property(GetName, None, doc='''A read only property that returns the name for this symbol as a string.''')
    mangled = property(GetMangledName, None, doc='''A read only property that returns the mangled (linkage) name for this symbol as a string.''')
    type = property(GetType, None, doc='''A read only property that returns an lldb enumeration value (see enumerations that start with "lldb.eSymbolType") that represents the type of this symbol.''')
    addr = property(GetStartAddress, None, doc='''A read only property that returns an lldb object that represents the start address (lldb.SBAddress) for this symbol.''')
    end_addr = property(GetEndAddress, None, doc='''A read only property that returns an lldb object that represents the end address (lldb.SBAddress) for this symbol.''')
    prologue_size = property(GetPrologueByteSize, None, doc='''A read only property that returns the size in bytes of the prologue instructions as an unsigned integer.''')
    instructions = property(get_instructions_from_current_target, None, doc='''A read only property that returns an lldb object that represents the instructions (lldb.SBInstructionList) for this symbol.''')
    external = property(IsExternal, None, doc='''A read only property that returns a boolean value that indicates if this symbol is externally visiable (exported) from the module that contains it.''')
    synthetic = property(IsSynthetic, None, doc='''A read only property that returns a boolean value that indicates if this symbol was synthetically created from information in module that contains it.''')


    def __eq__(self, rhs):
        if not isinstance(rhs, type(self)):
            return False

        return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)

    def __ne__(self, rhs):
        if not isinstance(rhs, type(self)):
            return True

        return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)


# Register SBSymbol in _lldb:
_lldb.SBSymbol_swigregister(SBSymbol)

class SBSymbolContext(object):
    r"""
    A context object that provides access to core debugger entities.

    Many debugger functions require a context when doing lookups. This class
    provides a common structure that can be used as the result of a query that
    can contain a single result.

    For example, ::

            exe = os.path.join(os.getcwd(), 'a.out')

            # Create a target for the debugger.
            target = self.dbg.CreateTarget(exe)

            # Now create a breakpoint on main.c by name 'c'.
            breakpoint = target.BreakpointCreateByName('c', 'a.out')

            # Now launch the process, and do not stop at entry point.
            process = target.LaunchSimple(None, None, os.getcwd())

            # The inferior should stop on 'c'.
            from lldbutil import get_stopped_thread
            thread = get_stopped_thread(process, lldb.eStopReasonBreakpoint)
            frame0 = thread.GetFrameAtIndex(0)

            # Now get the SBSymbolContext from this frame.  We want everything. :-)
            context = frame0.GetSymbolContext(lldb.eSymbolContextEverything)

            # Get the module.
            module = context.GetModule()
            ...

            # And the compile unit associated with the frame.
            compileUnit = context.GetCompileUnit()
            ...

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBSymbolContext self) -> SBSymbolContext
        __init__(SBSymbolContext self, SBSymbolContext rhs) -> SBSymbolContext
        """
        _lldb.SBSymbolContext_swiginit(self, _lldb.new_SBSymbolContext(*args))
    __swig_destroy__ = _lldb.delete_SBSymbolContext

    def __nonzero__(self):
        return _lldb.SBSymbolContext___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBSymbolContext self) -> bool"""
        return _lldb.SBSymbolContext_IsValid(self)

    def GetModule(self) -> "SBModule":
        r"""GetModule(SBSymbolContext self) -> SBModule"""
        return _lldb.SBSymbolContext_GetModule(self)

    def GetCompileUnit(self) -> "SBCompileUnit":
        r"""GetCompileUnit(SBSymbolContext self) -> SBCompileUnit"""
        return _lldb.SBSymbolContext_GetCompileUnit(self)

    def GetFunction(self) -> "SBFunction":
        r"""GetFunction(SBSymbolContext self) -> SBFunction"""
        return _lldb.SBSymbolContext_GetFunction(self)

    def GetBlock(self) -> "SBBlock":
        r"""GetBlock(SBSymbolContext self) -> SBBlock"""
        return _lldb.SBSymbolContext_GetBlock(self)

    def GetLineEntry(self) -> "SBLineEntry":
        r"""GetLineEntry(SBSymbolContext self) -> SBLineEntry"""
        return _lldb.SBSymbolContext_GetLineEntry(self)

    def GetSymbol(self) -> "SBSymbol":
        r"""GetSymbol(SBSymbolContext self) -> SBSymbol"""
        return _lldb.SBSymbolContext_GetSymbol(self)

    def SetModule(self, module: "SBModule"):
        r"""SetModule(SBSymbolContext self, SBModule module)"""
        return _lldb.SBSymbolContext_SetModule(self, module)

    def SetCompileUnit(self, compile_unit: "SBCompileUnit"):
        r"""SetCompileUnit(SBSymbolContext self, SBCompileUnit compile_unit)"""
        return _lldb.SBSymbolContext_SetCompileUnit(self, compile_unit)

    def SetFunction(self, function: "SBFunction"):
        r"""SetFunction(SBSymbolContext self, SBFunction function)"""
        return _lldb.SBSymbolContext_SetFunction(self, function)

    def SetBlock(self, block: "SBBlock"):
        r"""SetBlock(SBSymbolContext self, SBBlock block)"""
        return _lldb.SBSymbolContext_SetBlock(self, block)

    def SetLineEntry(self, line_entry: "SBLineEntry"):
        r"""SetLineEntry(SBSymbolContext self, SBLineEntry line_entry)"""
        return _lldb.SBSymbolContext_SetLineEntry(self, line_entry)

    def SetSymbol(self, symbol: "SBSymbol"):
        r"""SetSymbol(SBSymbolContext self, SBSymbol symbol)"""
        return _lldb.SBSymbolContext_SetSymbol(self, symbol)

    def GetParentOfInlinedScope(self, curr_frame_pc: "SBAddress", parent_frame_addr: "SBAddress") -> "SBSymbolContext":
        r"""GetParentOfInlinedScope(SBSymbolContext self, SBAddress curr_frame_pc, SBAddress parent_frame_addr) -> SBSymbolContext"""
        return _lldb.SBSymbolContext_GetParentOfInlinedScope(self, curr_frame_pc, parent_frame_addr)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBSymbolContext self, SBStream description) -> bool"""
        return _lldb.SBSymbolContext_GetDescription(self, description)

    def __repr__(self) -> str:
        r"""__repr__(SBSymbolContext self) -> std::string"""
        return _lldb.SBSymbolContext___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    module = property(GetModule, SetModule, doc='''A read/write property that allows the getting/setting of the module (lldb.SBModule) in this symbol context.''')
    compile_unit = property(GetCompileUnit, SetCompileUnit, doc='''A read/write property that allows the getting/setting of the compile unit (lldb.SBCompileUnit) in this symbol context.''')
    function = property(GetFunction, SetFunction, doc='''A read/write property that allows the getting/setting of the function (lldb.SBFunction) in this symbol context.''')
    block = property(GetBlock, SetBlock, doc='''A read/write property that allows the getting/setting of the block (lldb.SBBlock) in this symbol context.''')
    symbol = property(GetSymbol, SetSymbol, doc='''A read/write property that allows the getting/setting of the symbol (lldb.SBSymbol) in this symbol context.''')
    line_entry = property(GetLineEntry, SetLineEntry, doc='''A read/write property that allows the getting/setting of the line entry (lldb.SBLineEntry) in this symbol context.''')


# Register SBSymbolContext in _lldb:
_lldb.SBSymbolContext_swigregister(SBSymbolContext)

class SBSymbolContextList(object):
    r"""
    Represents a list of symbol context object. See also SBSymbolContext.

    For example (from test/python_api/target/TestTargetAPI.py), ::

        def find_functions(self, exe_name):
            '''Exercise SBTarget.FindFunctions() API.'''
            exe = os.path.join(os.getcwd(), exe_name)

            # Create a target by the debugger.
            target = self.dbg.CreateTarget(exe)
            self.assertTrue(target, VALID_TARGET)

            list = lldb.SBSymbolContextList()
            num = target.FindFunctions('c', lldb.eFunctionNameTypeAuto, False, list)
            self.assertTrue(num == 1 and list.GetSize() == 1)

            for sc in list:
                self.assertTrue(sc.GetModule().GetFileSpec().GetFilename() == exe_name)
                self.assertTrue(sc.GetSymbol().GetName() == 'c')
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBSymbolContextList self) -> SBSymbolContextList
        __init__(SBSymbolContextList self, SBSymbolContextList rhs) -> SBSymbolContextList
        """
        _lldb.SBSymbolContextList_swiginit(self, _lldb.new_SBSymbolContextList(*args))
    __swig_destroy__ = _lldb.delete_SBSymbolContextList

    def __nonzero__(self):
        return _lldb.SBSymbolContextList___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBSymbolContextList self) -> bool"""
        return _lldb.SBSymbolContextList_IsValid(self)

    def GetSize(self) -> int:
        r"""GetSize(SBSymbolContextList self) -> uint32_t"""
        return _lldb.SBSymbolContextList_GetSize(self)

    def GetContextAtIndex(self, idx: int) -> "SBSymbolContext":
        r"""GetContextAtIndex(SBSymbolContextList self, uint32_t idx) -> SBSymbolContext"""
        return _lldb.SBSymbolContextList_GetContextAtIndex(self, idx)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBSymbolContextList self, SBStream description) -> bool"""
        return _lldb.SBSymbolContextList_GetDescription(self, description)

    def Append(self, *args):
        r"""
        Append(SBSymbolContextList self, SBSymbolContext sc)
        Append(SBSymbolContextList self, SBSymbolContextList sc_list)
        """
        return _lldb.SBSymbolContextList_Append(self, *args)

    def Clear(self):
        r"""Clear(SBSymbolContextList self)"""
        return _lldb.SBSymbolContextList_Clear(self)

    def __repr__(self) -> str:
        r"""__repr__(SBSymbolContextList self) -> std::string"""
        return _lldb.SBSymbolContextList___repr__(self)

    def __iter__(self):
        '''Iterate over all symbol contexts in a lldb.SBSymbolContextList
        object.'''
        return lldb_iter(self, 'GetSize', 'GetContextAtIndex')

    def __len__(self):
        return int(self.GetSize())

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __getitem__(self, key):
        count = len(self)
        if isinstance(key, int):
            if -count <= key < count:
                key %= count
                return self.GetContextAtIndex(key)
            else:
                raise IndexError
        raise TypeError

    def get_module_array(self):
        a = []
        for i in range(len(self)):
            obj = self.GetContextAtIndex(i).module
            if obj:
                a.append(obj)
        return a

    def get_compile_unit_array(self):
        a = []
        for i in range(len(self)):
            obj = self.GetContextAtIndex(i).compile_unit
            if obj:
                a.append(obj)
        return a
    def get_function_array(self):
        a = []
        for i in range(len(self)):
            obj = self.GetContextAtIndex(i).function
            if obj:
                a.append(obj)
        return a
    def get_block_array(self):
        a = []
        for i in range(len(self)):
            obj = self.GetContextAtIndex(i).block
            if obj:
                a.append(obj)
        return a
    def get_symbol_array(self):
        a = []
        for i in range(len(self)):
            obj = self.GetContextAtIndex(i).symbol
            if obj:
                a.append(obj)
        return a
    def get_line_entry_array(self):
        a = []
        for i in range(len(self)):
            obj = self.GetContextAtIndex(i).line_entry
            if obj:
                a.append(obj)
        return a

    modules = property(get_module_array, None, doc='''Returns a list() of lldb.SBModule objects, one for each module in each SBSymbolContext object in this list.''')
    compile_units = property(get_compile_unit_array, None, doc='''Returns a list() of lldb.SBCompileUnit objects, one for each compile unit in each SBSymbolContext object in this list.''')
    functions = property(get_function_array, None, doc='''Returns a list() of lldb.SBFunction objects, one for each function in each SBSymbolContext object in this list.''')
    blocks = property(get_block_array, None, doc='''Returns a list() of lldb.SBBlock objects, one for each block in each SBSymbolContext object in this list.''')
    line_entries = property(get_line_entry_array, None, doc='''Returns a list() of lldb.SBLineEntry objects, one for each line entry in each SBSymbolContext object in this list.''')
    symbols = property(get_symbol_array, None, doc='''Returns a list() of lldb.SBSymbol objects, one for each symbol in each SBSymbolContext object in this list.''')


# Register SBSymbolContextList in _lldb:
_lldb.SBSymbolContextList_swigregister(SBSymbolContextList)

class SBTarget(object):
    r"""
    Represents the target program running under the debugger.

    SBTarget supports module, breakpoint, and watchpoint iterations. For example, ::

        for m in target.module_iter():
            print m

    produces: ::

        (x86_64) /Volumes/data/lldb/svn/trunk/test/python_api/lldbutil/iter/a.out
        (x86_64) /usr/lib/dyld
        (x86_64) /usr/lib/libstdc++.6.dylib
        (x86_64) /usr/lib/libSystem.B.dylib
        (x86_64) /usr/lib/system/libmathCommon.A.dylib
        (x86_64) /usr/lib/libSystem.B.dylib(__commpage)

    and, ::

        for b in target.breakpoint_iter():
            print b

    produces: ::

        SBBreakpoint: id = 1, file ='main.cpp', line = 66, locations = 1
        SBBreakpoint: id = 2, file ='main.cpp', line = 85, locations = 1

    and, ::

        for wp_loc in target.watchpoint_iter():
            print wp_loc

    produces: ::

        Watchpoint 1: addr = 0x1034ca048 size = 4 state = enabled type = rw
            declare @ '/Volumes/data/lldb/svn/trunk/test/python_api/watchpoint/main.c:12'
            hw_index = 0  hit_count = 2     ignore_count = 0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    eBroadcastBitBreakpointChanged = _lldb.SBTarget_eBroadcastBitBreakpointChanged

    eBroadcastBitModulesLoaded = _lldb.SBTarget_eBroadcastBitModulesLoaded

    eBroadcastBitModulesUnloaded = _lldb.SBTarget_eBroadcastBitModulesUnloaded

    eBroadcastBitWatchpointChanged = _lldb.SBTarget_eBroadcastBitWatchpointChanged

    eBroadcastBitSymbolsLoaded = _lldb.SBTarget_eBroadcastBitSymbolsLoaded


    def __init__(self, *args):
        r"""
        __init__(SBTarget self) -> SBTarget
        __init__(SBTarget self, SBTarget rhs) -> SBTarget
        """
        _lldb.SBTarget_swiginit(self, _lldb.new_SBTarget(*args))
    __swig_destroy__ = _lldb.delete_SBTarget

    def __nonzero__(self):
        return _lldb.SBTarget___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBTarget self) -> bool"""
        return _lldb.SBTarget_IsValid(self)

    @staticmethod
    def EventIsTargetEvent(event: "SBEvent") -> "bool":
        r"""EventIsTargetEvent(SBEvent event) -> bool"""
        return _lldb.SBTarget_EventIsTargetEvent(event)

    @staticmethod
    def GetTargetFromEvent(event: "SBEvent") -> "SBTarget":
        r"""GetTargetFromEvent(SBEvent event) -> SBTarget"""
        return _lldb.SBTarget_GetTargetFromEvent(event)

    @staticmethod
    def GetNumModulesFromEvent(event: "SBEvent") -> int:
        r"""GetNumModulesFromEvent(SBEvent event) -> uint32_t"""
        return _lldb.SBTarget_GetNumModulesFromEvent(event)

    @staticmethod
    def GetModuleAtIndexFromEvent(idx: "uint32_t const", event: "SBEvent") -> "SBModule":
        r"""GetModuleAtIndexFromEvent(uint32_t const idx, SBEvent event) -> SBModule"""
        return _lldb.SBTarget_GetModuleAtIndexFromEvent(idx, event)

    @staticmethod
    def GetBroadcasterClassName() -> str:
        r"""GetBroadcasterClassName() -> char const *"""
        return _lldb.SBTarget_GetBroadcasterClassName()

    def GetProcess(self) -> "SBProcess":
        r"""GetProcess(SBTarget self) -> SBProcess"""
        return _lldb.SBTarget_GetProcess(self)

    def SetCollectingStats(self, v: "bool"):
        r"""SetCollectingStats(SBTarget self, bool v)"""
        return _lldb.SBTarget_SetCollectingStats(self, v)

    def GetCollectingStats(self) -> "bool":
        r"""GetCollectingStats(SBTarget self) -> bool"""
        return _lldb.SBTarget_GetCollectingStats(self)

    def GetStatistics(self) -> "SBStructuredData":
        r"""GetStatistics(SBTarget self) -> SBStructuredData"""
        return _lldb.SBTarget_GetStatistics(self)

    def GetPlatform(self) -> "SBPlatform":
        r"""
        GetPlatform(SBTarget self) -> SBPlatform

            Return the platform object associated with the target.

            After return, the platform object should be checked for
            validity.

            @return
                A platform object.
        """
        return _lldb.SBTarget_GetPlatform(self)

    def GetEnvironment(self) -> "SBEnvironment":
        r"""GetEnvironment(SBTarget self) -> SBEnvironment"""
        return _lldb.SBTarget_GetEnvironment(self)

    def Install(self) -> "SBError":
        r"""
        Install(SBTarget self) -> SBError

            Install any binaries that need to be installed.

            This function does nothing when debugging on the host system.
            When connected to remote platforms, the target's main executable
            and any modules that have their install path set will be
            installed on the remote platform. If the main executable doesn't
            have an install location set, it will be installed in the remote
            platform's working directory.

            @return
                An error describing anything that went wrong during
                installation.
        """
        return _lldb.SBTarget_Install(self)

    def LoadCore(self, *args) -> "SBProcess":
        r"""
        LoadCore(SBTarget self, char const * core_file) -> SBProcess
        LoadCore(SBTarget self, char const * core_file, SBError error) -> SBProcess

            Load a core file

            @param[in] core_file
                File path of the core dump.

            @param[out] error
                An error explaining what went wrong if the operation fails.
                (Optional)

            @return
                 A process object for the newly created core file.

            For example,

                process = target.LoadCore('./a.out.core')

            loads a new core file and returns the process object.
        """
        return _lldb.SBTarget_LoadCore(self, *args)

    def LaunchSimple(self, argv: "char const **", envp: "char const **", working_directory: str) -> "SBProcess":
        r"""
        LaunchSimple(SBTarget self, char const ** argv, char const ** envp, char const * working_directory) -> SBProcess

            Launch a new process with sensible defaults.

            :param argv: The argument array.
            :param envp: The environment array.
            :param working_directory: The working directory to have the child process run in
            :return: The newly created process.
            :rtype: SBProcess

            A pseudo terminal will be used as stdin/stdout/stderr.
            No launch flags are passed and the target's debuger is used as a listener.

            For example, ::

                process = target.LaunchSimple(['X', 'Y', 'Z'], None, os.getcwd())

            launches a new process by passing 'X', 'Y', 'Z' as the args to the
            executable.
        """
        return _lldb.SBTarget_LaunchSimple(self, argv, envp, working_directory)

    def Launch(self, *args) -> "SBProcess":
        r"""
        Launch(SBTarget self, SBListener listener, char const ** argv, char const ** envp, char const * stdin_path, char const * stdout_path, char const * stderr_path, char const * working_directory, uint32_t launch_flags, bool stop_at_entry, SBError error) -> SBProcess
        Launch(SBTarget self, SBLaunchInfo launch_info, SBError error) -> SBProcess

            Launch a new process.

            Launch a new process by spawning a new process using the
            target object's executable module's file as the file to launch.
            Arguments are given in argv, and the environment variables
            are in envp. Standard input and output files can be
            optionally re-directed to stdin_path, stdout_path, and
            stderr_path.

            @param[in] listener
                An optional listener that will receive all process events.
                If listener is valid then listener will listen to all
                process events. If not valid, then this target's debugger
                (SBTarget::GetDebugger()) will listen to all process events.

            @param[in] argv
                The argument array.

            @param[in] envp
                The environment array.

            @param[in] launch_flags
                Flags to modify the launch (@see lldb::LaunchFlags)

            @param[in] stdin_path
                The path to use when re-directing the STDIN of the new
                process. If all stdXX_path arguments are NULL, a pseudo
                terminal will be used.

            @param[in] stdout_path
                The path to use when re-directing the STDOUT of the new
                process. If all stdXX_path arguments are NULL, a pseudo
                terminal will be used.

            @param[in] stderr_path
                The path to use when re-directing the STDERR of the new
                process. If all stdXX_path arguments are NULL, a pseudo
                terminal will be used.

            @param[in] working_directory
                The working directory to have the child process run in

            @param[in] launch_flags
                Some launch options specified by logical OR'ing
                lldb::LaunchFlags enumeration values together.

            @param[in] stop_at_entry
                If false do not stop the inferior at the entry point.

            @param[out]
                An error object. Contains the reason if there is some failure.

            @return
                 A process object for the newly created process.

            For example,

                process = target.Launch(self.dbg.GetListener(), None, None,
                                        None, '/tmp/stdout.txt', None,
                                        None, 0, False, error)

            launches a new process by passing nothing for both the args and the envs
            and redirect the standard output of the inferior to the /tmp/stdout.txt
            file. It does not specify a working directory so that the debug server
            will use its idea of what the current working directory is for the
            inferior. Also, we ask the debugger not to stop the inferior at the
            entry point. If no breakpoint is specified for the inferior, it should
            run to completion if no user interaction is required.
        """
        return _lldb.SBTarget_Launch(self, *args)

    def Attach(self, attach_info: "SBAttachInfo", error: "SBError") -> "SBProcess":
        r"""Attach(SBTarget self, SBAttachInfo attach_info, SBError error) -> SBProcess"""
        return _lldb.SBTarget_Attach(self, attach_info, error)

    def AttachToProcessWithID(self, listener: "SBListener", pid: int, error: "SBError") -> "SBProcess":
        r"""
        AttachToProcessWithID(SBTarget self, SBListener listener, lldb::pid_t pid, SBError error) -> SBProcess

            Attach to process with pid.

            @param[in] listener
                An optional listener that will receive all process events.
                If listener is valid then listener will listen to all
                process events. If not valid, then this target's debugger
                (SBTarget::GetDebugger()) will listen to all process events.

            @param[in] pid
                The process ID to attach to.

            @param[out]
                An error explaining what went wrong if attach fails.

            @return
                 A process object for the attached process.
        """
        return _lldb.SBTarget_AttachToProcessWithID(self, listener, pid, error)

    def AttachToProcessWithName(self, listener: "SBListener", name: str, wait_for: "bool", error: "SBError") -> "SBProcess":
        r"""
        AttachToProcessWithName(SBTarget self, SBListener listener, char const * name, bool wait_for, SBError error) -> SBProcess

            Attach to process with name.

            @param[in] listener
                An optional listener that will receive all process events.
                If listener is valid then listener will listen to all
                process events. If not valid, then this target's debugger
                (SBTarget::GetDebugger()) will listen to all process events.

            @param[in] name
                Basename of process to attach to.

            @param[in] wait_for
                If true wait for a new instance of 'name' to be launched.

            @param[out]
                An error explaining what went wrong if attach fails.

            @return
                 A process object for the attached process.
        """
        return _lldb.SBTarget_AttachToProcessWithName(self, listener, name, wait_for, error)

    def ConnectRemote(self, listener: "SBListener", url: str, plugin_name: str, error: "SBError") -> "SBProcess":
        r"""
        ConnectRemote(SBTarget self, SBListener listener, char const * url, char const * plugin_name, SBError error) -> SBProcess

            Connect to a remote debug server with url.

            @param[in] listener
                An optional listener that will receive all process events.
                If listener is valid then listener will listen to all
                process events. If not valid, then this target's debugger
                (SBTarget::GetDebugger()) will listen to all process events.

            @param[in] url
                The url to connect to, e.g., 'connect://localhost:12345'.

            @param[in] plugin_name
                The plugin name to be used; can be NULL.

            @param[out]
                An error explaining what went wrong if the connect fails.

            @return
                 A process object for the connected process.
        """
        return _lldb.SBTarget_ConnectRemote(self, listener, url, plugin_name, error)

    def GetExecutable(self) -> "SBFileSpec":
        r"""GetExecutable(SBTarget self) -> SBFileSpec"""
        return _lldb.SBTarget_GetExecutable(self)

    def AppendImageSearchPath(self, _from: str, to: str, error: "SBError"):
        r"""
        AppendImageSearchPath(SBTarget self, char const * _from, char const * to, SBError error)

            Append the path mapping (from -> to) to the target's paths mapping list.
        """
        return _lldb.SBTarget_AppendImageSearchPath(self, _from, to, error)

    def AddModule(self, *args) -> "SBModule":
        r"""
        AddModule(SBTarget self, SBModule module) -> bool
        AddModule(SBTarget self, char const * path, char const * triple, char const * uuid) -> SBModule
        AddModule(SBTarget self, char const * path, char const * triple, char const * uuid_cstr, char const * symfile) -> SBModule
        AddModule(SBTarget self, SBModuleSpec module_spec) -> SBModule
        """
        return _lldb.SBTarget_AddModule(self, *args)

    def GetNumModules(self) -> int:
        r"""GetNumModules(SBTarget self) -> uint32_t"""
        return _lldb.SBTarget_GetNumModules(self)

    def GetModuleAtIndex(self, idx: int) -> "SBModule":
        r"""GetModuleAtIndex(SBTarget self, uint32_t idx) -> SBModule"""
        return _lldb.SBTarget_GetModuleAtIndex(self, idx)

    def RemoveModule(self, module: "SBModule") -> "bool":
        r"""RemoveModule(SBTarget self, SBModule module) -> bool"""
        return _lldb.SBTarget_RemoveModule(self, module)

    def GetDebugger(self) -> "SBDebugger":
        r"""GetDebugger(SBTarget self) -> SBDebugger"""
        return _lldb.SBTarget_GetDebugger(self)

    def FindModule(self, file_spec: "SBFileSpec") -> "SBModule":
        r"""FindModule(SBTarget self, SBFileSpec file_spec) -> SBModule"""
        return _lldb.SBTarget_FindModule(self, file_spec)

    def FindCompileUnits(self, sb_file_spec: "SBFileSpec") -> "SBSymbolContextList":
        r"""
        FindCompileUnits(SBTarget self, SBFileSpec sb_file_spec) -> SBSymbolContextList

            Find compile units related to this target and passed source
            file.

            :param sb_file_spec: A :py:class:`lldb::SBFileSpec` object that contains source file
                specification.
            :return: The symbol contexts for all the matches.
            :rtype: SBSymbolContextList
        """
        return _lldb.SBTarget_FindCompileUnits(self, sb_file_spec)

    def GetByteOrder(self) -> "lldb::ByteOrder":
        r"""GetByteOrder(SBTarget self) -> lldb::ByteOrder"""
        return _lldb.SBTarget_GetByteOrder(self)

    def GetAddressByteSize(self) -> int:
        r"""GetAddressByteSize(SBTarget self) -> uint32_t"""
        return _lldb.SBTarget_GetAddressByteSize(self)

    def GetTriple(self) -> str:
        r"""GetTriple(SBTarget self) -> char const *"""
        return _lldb.SBTarget_GetTriple(self)

    def GetABIName(self) -> str:
        r"""GetABIName(SBTarget self) -> char const *"""
        return _lldb.SBTarget_GetABIName(self)

    def GetLabel(self) -> str:
        r"""GetLabel(SBTarget self) -> char const *"""
        return _lldb.SBTarget_GetLabel(self)

    def SetLabel(self, label: str) -> "SBError":
        r"""SetLabel(SBTarget self, char const * label) -> SBError"""
        return _lldb.SBTarget_SetLabel(self, label)

    def GetDataByteSize(self) -> int:
        r"""
        GetDataByteSize(SBTarget self) -> uint32_t

            Architecture data byte width accessor

            :return: The size in 8-bit (host) bytes of a minimum addressable unit from the Architecture's data bus.


        """
        return _lldb.SBTarget_GetDataByteSize(self)

    def GetCodeByteSize(self) -> int:
        r"""
        GetCodeByteSize(SBTarget self) -> uint32_t

            Architecture code byte width accessor.

            :return: The size in 8-bit (host) bytes of a minimum addressable unit from the Architecture's code bus.


        """
        return _lldb.SBTarget_GetCodeByteSize(self)

    def GetMaximumNumberOfChildrenToDisplay(self) -> int:
        r"""GetMaximumNumberOfChildrenToDisplay(SBTarget self) -> uint32_t"""
        return _lldb.SBTarget_GetMaximumNumberOfChildrenToDisplay(self)

    def SetSectionLoadAddress(self, section: "SBSection", section_base_addr: int) -> "SBError":
        r"""SetSectionLoadAddress(SBTarget self, SBSection section, lldb::addr_t section_base_addr) -> SBError"""
        return _lldb.SBTarget_SetSectionLoadAddress(self, section, section_base_addr)

    def ClearSectionLoadAddress(self, section: "SBSection") -> "SBError":
        r"""ClearSectionLoadAddress(SBTarget self, SBSection section) -> SBError"""
        return _lldb.SBTarget_ClearSectionLoadAddress(self, section)

    def SetModuleLoadAddress(self, module: "SBModule", sections_offset: int) -> "SBError":
        r"""SetModuleLoadAddress(SBTarget self, SBModule module, uint64_t sections_offset) -> SBError"""
        return _lldb.SBTarget_SetModuleLoadAddress(self, module, sections_offset)

    def ClearModuleLoadAddress(self, module: "SBModule") -> "SBError":
        r"""ClearModuleLoadAddress(SBTarget self, SBModule module) -> SBError"""
        return _lldb.SBTarget_ClearModuleLoadAddress(self, module)

    def FindFunctions(self, *args) -> "SBSymbolContextList":
        r"""
        FindFunctions(SBTarget self, char const * name, uint32_t name_type_mask=eFunctionNameTypeAny) -> SBSymbolContextList

            Find functions by name.

            :param name: The name of the function we are looking for.

            :param name_type_mask:
                A logical OR of one or more FunctionNameType enum bits that
                indicate what kind of names should be used when doing the
                lookup. Bits include fully qualified names, base names,
                C++ methods, or ObjC selectors.
                See FunctionNameType for more details.

            :return:
                A lldb::SBSymbolContextList that gets filled in with all of
                the symbol contexts for all the matches.
        """
        return _lldb.SBTarget_FindFunctions(self, *args)

    def FindFirstGlobalVariable(self, name: str) -> "SBValue":
        r"""
        FindFirstGlobalVariable(SBTarget self, char const * name) -> SBValue

            Find the first global (or static) variable by name.

            @param[in] name
                The name of the global or static variable we are looking
                for.

            @return
                An SBValue that gets filled in with the found variable (if any).
        """
        return _lldb.SBTarget_FindFirstGlobalVariable(self, name)

    def FindGlobalVariables(self, *args) -> "SBValueList":
        r"""
        FindGlobalVariables(SBTarget self, char const * name, uint32_t max_matches) -> SBValueList
        FindGlobalVariables(SBTarget self, char const * name, uint32_t max_matches, lldb::MatchType matchtype) -> SBValueList

            Find global and static variables by name.

            @param[in] name
                The name of the global or static variable we are looking
                for.

            @param[in] max_matches
                Allow the number of matches to be limited to max_matches.

            @return
                A list of matched variables in an SBValueList.
        """
        return _lldb.SBTarget_FindGlobalVariables(self, *args)

    def FindGlobalFunctions(self, name: str, max_matches: int, matchtype: "lldb::MatchType") -> "SBSymbolContextList":
        r"""FindGlobalFunctions(SBTarget self, char const * name, uint32_t max_matches, lldb::MatchType matchtype) -> SBSymbolContextList"""
        return _lldb.SBTarget_FindGlobalFunctions(self, name, max_matches, matchtype)

    def Clear(self):
        r"""Clear(SBTarget self)"""
        return _lldb.SBTarget_Clear(self)

    def ResolveFileAddress(self, file_addr: int) -> "SBAddress":
        r"""
        ResolveFileAddress(SBTarget self, lldb::addr_t file_addr) -> SBAddress

            Resolve a current file address into a section offset address.

            @param[in] file_addr

            @return
                An SBAddress which will be valid if...
        """
        return _lldb.SBTarget_ResolveFileAddress(self, file_addr)

    def ResolveLoadAddress(self, vm_addr: int) -> "SBAddress":
        r"""ResolveLoadAddress(SBTarget self, lldb::addr_t vm_addr) -> SBAddress"""
        return _lldb.SBTarget_ResolveLoadAddress(self, vm_addr)

    def ResolvePastLoadAddress(self, stop_id: int, vm_addr: int) -> "SBAddress":
        r"""ResolvePastLoadAddress(SBTarget self, uint32_t stop_id, lldb::addr_t vm_addr) -> SBAddress"""
        return _lldb.SBTarget_ResolvePastLoadAddress(self, stop_id, vm_addr)

    def ResolveSymbolContextForAddress(self, addr: "SBAddress", resolve_scope: int) -> "SBSymbolContext":
        r"""ResolveSymbolContextForAddress(SBTarget self, SBAddress addr, uint32_t resolve_scope) -> SBSymbolContext"""
        return _lldb.SBTarget_ResolveSymbolContextForAddress(self, addr, resolve_scope)

    def ReadMemory(self, addr: "SBAddress", buf: "void *", error: "SBError") -> "size_t":
        r"""
        ReadMemory(SBTarget self, SBAddress addr, void * buf, SBError error) -> size_t

            Read target memory. If a target process is running then memory
            is read from here. Otherwise the memory is read from the object
            files. For a target whose bytes are sized as a multiple of host
            bytes, the data read back will preserve the target's byte order.

            @param[in] addr
                A target address to read from.

            @param[out] buf
                The buffer to read memory into.

            @param[in] size
                The maximum number of host bytes to read in the buffer passed
                into this call

            @param[out] error
                Error information is written here if the memory read fails.

            @return
                The amount of data read in host bytes.
        """
        return _lldb.SBTarget_ReadMemory(self, addr, buf, error)

    def BreakpointCreateByLocation(self, *args) -> "SBBreakpoint":
        r"""
        BreakpointCreateByLocation(SBTarget self, char const * file, uint32_t line) -> SBBreakpoint
        BreakpointCreateByLocation(SBTarget self, SBFileSpec file_spec, uint32_t line) -> SBBreakpoint
        BreakpointCreateByLocation(SBTarget self, SBFileSpec file_spec, uint32_t line, lldb::addr_t offset) -> SBBreakpoint
        BreakpointCreateByLocation(SBTarget self, SBFileSpec file_spec, uint32_t line, lldb::addr_t offset, SBFileSpecList module_list) -> SBBreakpoint
        BreakpointCreateByLocation(SBTarget self, SBFileSpec file_spec, uint32_t line, uint32_t column, lldb::addr_t offset, SBFileSpecList module_list) -> SBBreakpoint
        BreakpointCreateByLocation(SBTarget self, SBFileSpec file_spec, uint32_t line, uint32_t column, lldb::addr_t offset, SBFileSpecList module_list, bool move_to_nearest_code) -> SBBreakpoint
        """
        return _lldb.SBTarget_BreakpointCreateByLocation(self, *args)

    def BreakpointCreateByName(self, *args) -> "SBBreakpoint":
        r"""
        BreakpointCreateByName(SBTarget self, char const * symbol_name, char const * module_name=None) -> SBBreakpoint
        BreakpointCreateByName(SBTarget self, char const * symbol_name, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        BreakpointCreateByName(SBTarget self, char const * symbol_name, uint32_t name_type_mask, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        BreakpointCreateByName(SBTarget self, char const * symbol_name, uint32_t name_type_mask, lldb::LanguageType symbol_language, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        """
        return _lldb.SBTarget_BreakpointCreateByName(self, *args)

    def BreakpointCreateByNames(self, *args) -> "SBBreakpoint":
        r"""
        BreakpointCreateByNames(SBTarget self, char const ** symbol_name, uint32_t name_type_mask, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        BreakpointCreateByNames(SBTarget self, char const ** symbol_name, uint32_t name_type_mask, lldb::LanguageType symbol_language, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        BreakpointCreateByNames(SBTarget self, char const ** symbol_name, uint32_t name_type_mask, lldb::LanguageType symbol_language, lldb::addr_t offset, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        """
        return _lldb.SBTarget_BreakpointCreateByNames(self, *args)

    def BreakpointCreateByRegex(self, *args) -> "SBBreakpoint":
        r"""
        BreakpointCreateByRegex(SBTarget self, char const * symbol_name_regex, char const * module_name=None) -> SBBreakpoint
        BreakpointCreateByRegex(SBTarget self, char const * symbol_name_regex, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        BreakpointCreateByRegex(SBTarget self, char const * symbol_name_regex, lldb::LanguageType symbol_language, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        """
        return _lldb.SBTarget_BreakpointCreateByRegex(self, *args)

    def BreakpointCreateBySourceRegex(self, *args) -> "SBBreakpoint":
        r"""
        BreakpointCreateBySourceRegex(SBTarget self, char const * source_regex, SBFileSpec source_file, char const * module_name=None) -> SBBreakpoint
        BreakpointCreateBySourceRegex(SBTarget self, char const * source_regex, SBFileSpecList module_list, SBFileSpecList source_file) -> SBBreakpoint
        BreakpointCreateBySourceRegex(SBTarget self, char const * source_regex, SBFileSpecList module_list, SBFileSpecList source_file, SBStringList func_names) -> SBBreakpoint
        """
        return _lldb.SBTarget_BreakpointCreateBySourceRegex(self, *args)

    def BreakpointCreateForException(self, language: "lldb::LanguageType", catch_bp: "bool", throw_bp: "bool") -> "SBBreakpoint":
        r"""BreakpointCreateForException(SBTarget self, lldb::LanguageType language, bool catch_bp, bool throw_bp) -> SBBreakpoint"""
        return _lldb.SBTarget_BreakpointCreateForException(self, language, catch_bp, throw_bp)

    def BreakpointCreateByAddress(self, address: int) -> "SBBreakpoint":
        r"""BreakpointCreateByAddress(SBTarget self, lldb::addr_t address) -> SBBreakpoint"""
        return _lldb.SBTarget_BreakpointCreateByAddress(self, address)

    def BreakpointCreateBySBAddress(self, address: "SBAddress") -> "SBBreakpoint":
        r"""BreakpointCreateBySBAddress(SBTarget self, SBAddress address) -> SBBreakpoint"""
        return _lldb.SBTarget_BreakpointCreateBySBAddress(self, address)

    def BreakpointCreateFromScript(self, class_name: str, extra_args: "SBStructuredData", module_list: "SBFileSpecList", file_list: "SBFileSpecList", request_hardware: "bool"=False) -> "SBBreakpoint":
        r"""
        BreakpointCreateFromScript(SBTarget self, char const * class_name, SBStructuredData extra_args, SBFileSpecList module_list, SBFileSpecList file_list, bool request_hardware=False) -> SBBreakpoint

            Create a breakpoint using a scripted resolver.

            @param[in] class_name
               This is the name of the class that implements a scripted resolver.
               The class should have the following signature: ::

                   class Resolver:
                       def __init__(self, bkpt, extra_args):
                           # bkpt - the breakpoint for which this is the resolver.  When
                           # the resolver finds an interesting address, call AddLocation
                           # on this breakpoint to add it.
                           #
                           # extra_args - an SBStructuredData that can be used to
                           # parametrize this instance.  Same as the extra_args passed
                           # to BreakpointCreateFromScript.

                       def __get_depth__ (self):
                           # This is optional, but if defined, you should return the
                           # depth at which you want the callback to be called.  The
                           # available options are:
                           #    lldb.eSearchDepthModule
                           #    lldb.eSearchDepthCompUnit
                           # The default if you don't implement this method is
                           # eSearchDepthModule.

                       def __callback__(self, sym_ctx):
                           # sym_ctx - an SBSymbolContext that is the cursor in the
                           # search through the program to resolve breakpoints.
                           # The sym_ctx will be filled out to the depth requested in
                           # __get_depth__.
                           # Look in this sym_ctx for new breakpoint locations,
                           # and if found use bkpt.AddLocation to add them.
                           # Note, you will only get called for modules/compile_units that
                           # pass the SearchFilter provided by the module_list & file_list
                           # passed into BreakpointCreateFromScript.

                       def get_short_help(self):
                           # Optional, but if implemented return a short string that will
                           # be printed at the beginning of the break list output for the
                           # breakpoint.

            @param[in] extra_args
               This is an SBStructuredData object that will get passed to the
               constructor of the class in class_name.  You can use this to
               reuse the same class, parametrizing it with entries from this
               dictionary.

            @param module_list
               If this is non-empty, this will be used as the module filter in the
               SearchFilter created for this breakpoint.

            @param file_list
               If this is non-empty, this will be used as the comp unit filter in the
               SearchFilter created for this breakpoint.

            @return
                An SBBreakpoint that will set locations based on the logic in the
                resolver's search callback.
        """
        return _lldb.SBTarget_BreakpointCreateFromScript(self, class_name, extra_args, module_list, file_list, request_hardware)

    def BreakpointsCreateFromFile(self, *args) -> "SBError":
        r"""
        BreakpointsCreateFromFile(SBTarget self, SBFileSpec source_file, SBBreakpointList new_bps) -> SBError
        BreakpointsCreateFromFile(SBTarget self, SBFileSpec source_file, SBStringList matching_names, SBBreakpointList new_bps) -> SBError

            Read breakpoints from source_file and return the newly created
            breakpoints in bkpt_list.

            @param[in] source_file
               The file from which to read the breakpoints

            @param[in] matching_names
               Only read in breakpoints whose names match one of the names in this
               list.

            @param[out] bkpt_list
               A list of the newly created breakpoints.

            @return
                An SBError detailing any errors in reading in the breakpoints.
        """
        return _lldb.SBTarget_BreakpointsCreateFromFile(self, *args)

    def BreakpointsWriteToFile(self, *args) -> "SBError":
        r"""
        BreakpointsWriteToFile(SBTarget self, SBFileSpec dest_file) -> SBError
        BreakpointsWriteToFile(SBTarget self, SBFileSpec dest_file, SBBreakpointList bkpt_list, bool append=False) -> SBError

            Write breakpoints listed in bkpt_list to dest_file.

            @param[in] dest_file
               The file to which to write the breakpoints.

            @param[in] bkpt_list
               Only write breakpoints from this list.

            @param[in] append
               If true, append the breakpoints in bkpt_list to the others
               serialized in dest_file.  If dest_file doesn't exist, then a new
               file will be created and the breakpoints in bkpt_list written to it.

            @return
                An SBError detailing any errors in writing in the breakpoints.
        """
        return _lldb.SBTarget_BreakpointsWriteToFile(self, *args)

    def GetNumBreakpoints(self) -> int:
        r"""GetNumBreakpoints(SBTarget self) -> uint32_t"""
        return _lldb.SBTarget_GetNumBreakpoints(self)

    def GetBreakpointAtIndex(self, idx: int) -> "SBBreakpoint":
        r"""GetBreakpointAtIndex(SBTarget self, uint32_t idx) -> SBBreakpoint"""
        return _lldb.SBTarget_GetBreakpointAtIndex(self, idx)

    def BreakpointDelete(self, break_id: int) -> "bool":
        r"""BreakpointDelete(SBTarget self, lldb::break_id_t break_id) -> bool"""
        return _lldb.SBTarget_BreakpointDelete(self, break_id)

    def FindBreakpointByID(self, break_id: int) -> "SBBreakpoint":
        r"""FindBreakpointByID(SBTarget self, lldb::break_id_t break_id) -> SBBreakpoint"""
        return _lldb.SBTarget_FindBreakpointByID(self, break_id)

    def FindBreakpointsByName(self, name: str, bkpt_list: "SBBreakpointList") -> "bool":
        r"""FindBreakpointsByName(SBTarget self, char const * name, SBBreakpointList bkpt_list) -> bool"""
        return _lldb.SBTarget_FindBreakpointsByName(self, name, bkpt_list)

    def GetBreakpointNames(self, names: "SBStringList"):
        r"""GetBreakpointNames(SBTarget self, SBStringList names)"""
        return _lldb.SBTarget_GetBreakpointNames(self, names)

    def DeleteBreakpointName(self, name: str):
        r"""DeleteBreakpointName(SBTarget self, char const * name)"""
        return _lldb.SBTarget_DeleteBreakpointName(self, name)

    def EnableAllBreakpoints(self) -> "bool":
        r"""EnableAllBreakpoints(SBTarget self) -> bool"""
        return _lldb.SBTarget_EnableAllBreakpoints(self)

    def DisableAllBreakpoints(self) -> "bool":
        r"""DisableAllBreakpoints(SBTarget self) -> bool"""
        return _lldb.SBTarget_DisableAllBreakpoints(self)

    def DeleteAllBreakpoints(self) -> "bool":
        r"""DeleteAllBreakpoints(SBTarget self) -> bool"""
        return _lldb.SBTarget_DeleteAllBreakpoints(self)

    def GetNumWatchpoints(self) -> int:
        r"""GetNumWatchpoints(SBTarget self) -> uint32_t"""
        return _lldb.SBTarget_GetNumWatchpoints(self)

    def GetWatchpointAtIndex(self, idx: int) -> "SBWatchpoint":
        r"""GetWatchpointAtIndex(SBTarget self, uint32_t idx) -> SBWatchpoint"""
        return _lldb.SBTarget_GetWatchpointAtIndex(self, idx)

    def DeleteWatchpoint(self, watch_id: "lldb::watch_id_t") -> "bool":
        r"""DeleteWatchpoint(SBTarget self, lldb::watch_id_t watch_id) -> bool"""
        return _lldb.SBTarget_DeleteWatchpoint(self, watch_id)

    def FindWatchpointByID(self, watch_id: "lldb::watch_id_t") -> "SBWatchpoint":
        r"""FindWatchpointByID(SBTarget self, lldb::watch_id_t watch_id) -> SBWatchpoint"""
        return _lldb.SBTarget_FindWatchpointByID(self, watch_id)

    def WatchAddress(self, addr: int, size: "size_t", read: "bool", write: "bool", error: "SBError") -> "SBWatchpoint":
        r"""WatchAddress(SBTarget self, lldb::addr_t addr, size_t size, bool read, bool write, SBError error) -> SBWatchpoint"""
        return _lldb.SBTarget_WatchAddress(self, addr, size, read, write, error)

    def EnableAllWatchpoints(self) -> "bool":
        r"""EnableAllWatchpoints(SBTarget self) -> bool"""
        return _lldb.SBTarget_EnableAllWatchpoints(self)

    def DisableAllWatchpoints(self) -> "bool":
        r"""DisableAllWatchpoints(SBTarget self) -> bool"""
        return _lldb.SBTarget_DisableAllWatchpoints(self)

    def DeleteAllWatchpoints(self) -> "bool":
        r"""DeleteAllWatchpoints(SBTarget self) -> bool"""
        return _lldb.SBTarget_DeleteAllWatchpoints(self)

    def GetBroadcaster(self) -> "SBBroadcaster":
        r"""GetBroadcaster(SBTarget self) -> SBBroadcaster"""
        return _lldb.SBTarget_GetBroadcaster(self)

    def FindFirstType(self, type: str) -> "SBType":
        r"""FindFirstType(SBTarget self, char const * type) -> SBType"""
        return _lldb.SBTarget_FindFirstType(self, type)

    def FindTypes(self, type: str) -> "SBTypeList":
        r"""FindTypes(SBTarget self, char const * type) -> SBTypeList"""
        return _lldb.SBTarget_FindTypes(self, type)

    def GetBasicType(self, type: "lldb::BasicType") -> "SBType":
        r"""GetBasicType(SBTarget self, lldb::BasicType type) -> SBType"""
        return _lldb.SBTarget_GetBasicType(self, type)

    def CreateValueFromAddress(self, name: str, addr: "SBAddress", type: "SBType") -> "SBValue":
        r"""
        CreateValueFromAddress(SBTarget self, char const * name, SBAddress addr, SBType type) -> SBValue

            Create an SBValue with the given name by treating the memory starting at addr as an entity of type.

            @param[in] name
                The name of the resultant SBValue

            @param[in] addr
                The address of the start of the memory region to be used.

            @param[in] type
                The type to use to interpret the memory starting at addr.

            @return
                An SBValue of the given type, may be invalid if there was an error reading
                the underlying memory.
        """
        return _lldb.SBTarget_CreateValueFromAddress(self, name, addr, type)

    def CreateValueFromData(self, name: str, data: "SBData", type: "SBType") -> "SBValue":
        r"""CreateValueFromData(SBTarget self, char const * name, SBData data, SBType type) -> SBValue"""
        return _lldb.SBTarget_CreateValueFromData(self, name, data, type)

    def CreateValueFromExpression(self, name: str, expr: str) -> "SBValue":
        r"""CreateValueFromExpression(SBTarget self, char const * name, char const * expr) -> SBValue"""
        return _lldb.SBTarget_CreateValueFromExpression(self, name, expr)

    def GetSourceManager(self) -> "SBSourceManager":
        r"""GetSourceManager(SBTarget self) -> SBSourceManager"""
        return _lldb.SBTarget_GetSourceManager(self)

    def ReadInstructions(self, *args) -> "SBInstructionList":
        r"""
        ReadInstructions(SBTarget self, SBAddress base_addr, uint32_t count) -> SBInstructionList
        ReadInstructions(SBTarget self, SBAddress base_addr, uint32_t count, char const * flavor_string) -> SBInstructionList

            Disassemble a specified number of instructions starting at an address.

            :param base_addr: the address to start disassembly from.
            :param count: the number of instructions to disassemble.
            :param flavor_string: may be 'intel' or 'att' on x86 targets to specify that style of disassembly.
            :rtype: SBInstructionList

        """
        return _lldb.SBTarget_ReadInstructions(self, *args)

    def GetInstructions(self, base_addr: "SBAddress", buf: "void const *") -> "SBInstructionList":
        r"""
        GetInstructions(SBTarget self, SBAddress base_addr, void const * buf) -> SBInstructionList

            Disassemble the bytes in a buffer and return them in an SBInstructionList.

            :param base_addr: used for symbolicating the offsets in the byte stream when disassembling.
            :param buf: bytes to be disassembled.
            :param size: (C++) size of the buffer.
            :rtype: SBInstructionList

        """
        return _lldb.SBTarget_GetInstructions(self, base_addr, buf)

    def GetInstructionsWithFlavor(self, base_addr: "SBAddress", flavor_string: str, buf: "void const *") -> "SBInstructionList":
        r"""
        GetInstructionsWithFlavor(SBTarget self, SBAddress base_addr, char const * flavor_string, void const * buf) -> SBInstructionList

            Disassemble the bytes in a buffer and return them in an SBInstructionList, with a supplied flavor.

            :param base_addr: used for symbolicating the offsets in the byte stream when disassembling.
            :param flavor:  may be 'intel' or 'att' on x86 targets to specify that style of disassembly.
            :param buf: bytes to be disassembled.
            :param size: (C++) size of the buffer.
            :rtype: SBInstructionList

        """
        return _lldb.SBTarget_GetInstructionsWithFlavor(self, base_addr, flavor_string, buf)

    def FindSymbols(self, *args) -> "SBSymbolContextList":
        r"""FindSymbols(SBTarget self, char const * name, lldb::SymbolType type=eSymbolTypeAny) -> SBSymbolContextList"""
        return _lldb.SBTarget_FindSymbols(self, *args)

    def __eq__(self, rhs: "SBTarget") -> "bool":
        r"""__eq__(SBTarget self, SBTarget rhs) -> bool"""
        return _lldb.SBTarget___eq__(self, rhs)

    def __ne__(self, rhs: "SBTarget") -> "bool":
        r"""__ne__(SBTarget self, SBTarget rhs) -> bool"""
        return _lldb.SBTarget___ne__(self, rhs)

    def GetDescription(self, description: "SBStream", description_level: "lldb::DescriptionLevel") -> "bool":
        r"""GetDescription(SBTarget self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        return _lldb.SBTarget_GetDescription(self, description, description_level)

    def EvaluateExpression(self, *args) -> "SBValue":
        r"""
        EvaluateExpression(SBTarget self, char const * expr) -> SBValue
        EvaluateExpression(SBTarget self, char const * expr, SBExpressionOptions options) -> SBValue
        """
        return _lldb.SBTarget_EvaluateExpression(self, *args)

    def GetStackRedZoneSize(self) -> int:
        r"""GetStackRedZoneSize(SBTarget self) -> lldb::addr_t"""
        return _lldb.SBTarget_GetStackRedZoneSize(self)

    def IsLoaded(self, module: "SBModule") -> "bool":
        r"""
        IsLoaded(SBTarget self, SBModule module) -> bool

            Returns true if the module has been loaded in this `SBTarget`.
            A module can be loaded either by the dynamic loader or by being manually
            added to the target (see `SBTarget.AddModule` and the ``target module add`` command).

            :rtype: bool

        """
        return _lldb.SBTarget_IsLoaded(self, module)

    def GetLaunchInfo(self) -> "SBLaunchInfo":
        r"""GetLaunchInfo(SBTarget self) -> SBLaunchInfo"""
        return _lldb.SBTarget_GetLaunchInfo(self)

    def SetLaunchInfo(self, launch_info: "SBLaunchInfo"):
        r"""SetLaunchInfo(SBTarget self, SBLaunchInfo launch_info)"""
        return _lldb.SBTarget_SetLaunchInfo(self, launch_info)

    def GetTrace(self) -> "SBTrace":
        r"""GetTrace(SBTarget self) -> SBTrace"""
        return _lldb.SBTarget_GetTrace(self)

    def CreateTrace(self, error: "SBError") -> "SBTrace":
        r"""CreateTrace(SBTarget self, SBError error) -> SBTrace"""
        return _lldb.SBTarget_CreateTrace(self, error)

    def __repr__(self) -> str:
        r"""__repr__(SBTarget self) -> std::string"""
        return _lldb.SBTarget___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    class modules_access(object):
        '''A helper object that will lazily hand out lldb.SBModule objects for a target when supplied an index, or by full or partial path.'''
        def __init__(self, sbtarget):
            self.sbtarget = sbtarget

        def __len__(self):
            if self.sbtarget:
                return int(self.sbtarget.GetNumModules())
            return 0

        def __getitem__(self, key):
            num_modules = self.sbtarget.GetNumModules()
            if type(key) is int:
                if -num_modules <= key < num_modules:
                    key %= num_modules
                    return self.sbtarget.GetModuleAtIndex(key)
            elif type(key) is str:
                if key.find('/') == -1:
                    for idx in range(num_modules):
                        module = self.sbtarget.GetModuleAtIndex(idx)
                        if module.file.basename == key:
                            return module
                else:
                    for idx in range(num_modules):
                        module = self.sbtarget.GetModuleAtIndex(idx)
                        if module.file.fullpath == key:
                            return module
    # See if the string is a UUID
                try:
                    the_uuid = uuid.UUID(key)
                    if the_uuid:
                        for idx in range(num_modules):
                            module = self.sbtarget.GetModuleAtIndex(idx)
                            if module.uuid == the_uuid:
                                return module
                except:
                    return None
            elif type(key) is uuid.UUID:
                for idx in range(num_modules):
                    module = self.sbtarget.GetModuleAtIndex(idx)
                    if module.uuid == key:
                        return module
            elif type(key) is re.SRE_Pattern:
                matching_modules = []
                for idx in range(num_modules):
                    module = self.sbtarget.GetModuleAtIndex(idx)
                    re_match = key.search(module.path.fullpath)
                    if re_match:
                        matching_modules.append(module)
                return matching_modules
            else:
                print("error: unsupported item type: %s" % type(key))
            return None

    def get_modules_access_object(self):
        '''An accessor function that returns a modules_access() object which allows lazy module access from a lldb.SBTarget object.'''
        return self.modules_access(self)

    def get_modules_array(self):
        '''An accessor function that returns a list() that contains all modules in a lldb.SBTarget object.'''
        modules = []
        for idx in range(self.GetNumModules()):
            modules.append(self.GetModuleAtIndex(idx))
        return modules

    def module_iter(self):
        '''Returns an iterator over all modules in a lldb.SBTarget
        object.'''
        return lldb_iter(self, 'GetNumModules', 'GetModuleAtIndex')

    def breakpoint_iter(self):
        '''Returns an iterator over all breakpoints in a lldb.SBTarget
        object.'''
        return lldb_iter(self, 'GetNumBreakpoints', 'GetBreakpointAtIndex')

    class bkpts_access(object):
        '''A helper object that will lazily hand out bkpts for a target when supplied an index.'''
        def __init__(self, sbtarget):
            self.sbtarget = sbtarget

        def __len__(self):
            if self.sbtarget:
                return int(self.sbtarget.GetNumBreakpoints())
            return 0

        def __getitem__(self, key):
            if isinstance(key, int):
                count = len(self)
                if -count <= key < count:
                    key %= count
                    return self.sbtarget.GetBreakpointAtIndex(key)
            return None

    def get_bkpts_access_object(self):
        '''An accessor function that returns a bkpts_access() object which allows lazy bkpt access from a lldb.SBtarget object.'''
        return self.bkpts_access(self)

    def get_target_bkpts(self):
        '''An accessor function that returns a list() that contains all bkpts in a lldb.SBtarget object.'''
        bkpts = []
        for idx in range(self.GetNumBreakpoints()):
            bkpts.append(self.GetBreakpointAtIndex(idx))
        return bkpts

    def watchpoint_iter(self):
        '''Returns an iterator over all watchpoints in a lldb.SBTarget
        object.'''
        return lldb_iter(self, 'GetNumWatchpoints', 'GetWatchpointAtIndex')

    class watchpoints_access(object):
        '''A helper object that will lazily hand out watchpoints for a target when supplied an index.'''
        def __init__(self, sbtarget):
            self.sbtarget = sbtarget

        def __len__(self):
            if self.sbtarget:
                return int(self.sbtarget.GetNumWatchpoints())
            return 0

        def __getitem__(self, key):
            if isinstance(key, int):
                count = len(self)
                if -count <= key < count:
                    key %= count
                    return self.sbtarget.GetWatchpointAtIndex(key)
            return None

    def get_watchpoints_access_object(self):
        '''An accessor function that returns a watchpoints_access() object which allows lazy watchpoint access from a lldb.SBtarget object.'''
        return self.watchpoints_access(self)

    def get_target_watchpoints(self):
        '''An accessor function that returns a list() that contains all watchpoints in a lldb.SBtarget object.'''
        watchpoints = []
        for idx in range(self.GetNumWatchpoints()):
            bkpts.append(self.GetWatchpointAtIndex(idx))
        return watchpoints

    modules = property(get_modules_array, None, doc='''A read only property that returns a list() of lldb.SBModule objects contained in this target. This list is a list all modules that the target currently is tracking (the main executable and all dependent shared libraries).''')
    module = property(get_modules_access_object, None, doc=r'''A read only property that returns an object that implements python operator overloading with the square brackets().\n    target.module[<int>] allows array access to any modules.\n    target.module[<str>] allows access to modules by basename, full path, or uuid string value.\n    target.module[uuid.UUID()] allows module access by UUID.\n    target.module[re] allows module access using a regular expression that matches the module full path.''')
    process = property(GetProcess, None, doc='''A read only property that returns an lldb object that represents the process (lldb.SBProcess) that this target owns.''')
    executable = property(GetExecutable, None, doc='''A read only property that returns an lldb object that represents the main executable module (lldb.SBModule) for this target.''')
    debugger = property(GetDebugger, None, doc='''A read only property that returns an lldb object that represents the debugger (lldb.SBDebugger) that owns this target.''')
    num_breakpoints = property(GetNumBreakpoints, None, doc='''A read only property that returns the number of breakpoints that this target has as an integer.''')
    breakpoints = property(get_target_bkpts, None, doc='''A read only property that returns a list() of lldb.SBBreakpoint objects for all breakpoints in this target.''')
    breakpoint = property(get_bkpts_access_object, None, doc='''A read only property that returns an object that can be used to access breakpoints as an array ("bkpt_12 = lldb.target.bkpt[12]").''')
    num_watchpoints = property(GetNumWatchpoints, None, doc='''A read only property that returns the number of watchpoints that this target has as an integer.''')
    watchpoints = property(get_target_watchpoints, None, doc='''A read only property that returns a list() of lldb.SBwatchpoint objects for all watchpoints in this target.''')
    watchpoint = property(get_watchpoints_access_object, None, doc='''A read only property that returns an object that can be used to access watchpoints as an array ("watchpoint_12 = lldb.target.watchpoint[12]").''')
    broadcaster = property(GetBroadcaster, None, doc='''A read only property that an lldb object that represents the broadcaster (lldb.SBBroadcaster) for this target.''')
    byte_order = property(GetByteOrder, None, doc='''A read only property that returns an lldb enumeration value (lldb.eByteOrderLittle, lldb.eByteOrderBig, lldb.eByteOrderInvalid) that represents the byte order for this target.''')
    addr_size = property(GetAddressByteSize, None, doc='''A read only property that returns the size in bytes of an address for this target.''')
    triple = property(GetTriple, None, doc='''A read only property that returns the target triple (arch-vendor-os) for this target as a string.''')
    data_byte_size = property(GetDataByteSize, None, doc='''A read only property that returns the size in host bytes of a byte in the data address space for this target.''')
    code_byte_size = property(GetCodeByteSize, None, doc='''A read only property that returns the size in host bytes of a byte in the code address space for this target.''')
    platform = property(GetPlatform, None, doc='''A read only property that returns the platform associated with with this target.''')


    def __eq__(self, rhs):
        if not isinstance(rhs, type(self)):
            return False

        return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)

    def __ne__(self, rhs):
        if not isinstance(rhs, type(self)):
            return True

        return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)


# Register SBTarget in _lldb:
_lldb.SBTarget_swigregister(SBTarget)

def SBTarget_EventIsTargetEvent(event: "SBEvent") -> "bool":
    r"""SBTarget_EventIsTargetEvent(SBEvent event) -> bool"""
    return _lldb.SBTarget_EventIsTargetEvent(event)

def SBTarget_GetTargetFromEvent(event: "SBEvent") -> "SBTarget":
    r"""SBTarget_GetTargetFromEvent(SBEvent event) -> SBTarget"""
    return _lldb.SBTarget_GetTargetFromEvent(event)

def SBTarget_GetNumModulesFromEvent(event: "SBEvent") -> int:
    r"""SBTarget_GetNumModulesFromEvent(SBEvent event) -> uint32_t"""
    return _lldb.SBTarget_GetNumModulesFromEvent(event)

def SBTarget_GetModuleAtIndexFromEvent(idx: "uint32_t const", event: "SBEvent") -> "SBModule":
    r"""SBTarget_GetModuleAtIndexFromEvent(uint32_t const idx, SBEvent event) -> SBModule"""
    return _lldb.SBTarget_GetModuleAtIndexFromEvent(idx, event)

def SBTarget_GetBroadcasterClassName() -> str:
    r"""SBTarget_GetBroadcasterClassName() -> char const *"""
    return _lldb.SBTarget_GetBroadcasterClassName()

class SBThread(object):
    r"""
    Represents a thread of execution. :py:class:`SBProcess` contains SBThread(s).

    SBThreads can be referred to by their ID, which maps to the system specific thread
    identifier, or by IndexID.  The ID may or may not be unique depending on whether the
    system reuses its thread identifiers.  The IndexID is a monotonically increasing identifier
    that will always uniquely reference a particular thread, and when that thread goes
    away it will not be reused.

    SBThread supports frame iteration. For example (from test/python_api/
    lldbutil/iter/TestLLDBIterator.py), ::

            from lldbutil import print_stacktrace
            stopped_due_to_breakpoint = False
            for thread in process:
                if self.TraceOn():
                    print_stacktrace(thread)
                ID = thread.GetThreadID()
                if thread.GetStopReason() == lldb.eStopReasonBreakpoint:
                    stopped_due_to_breakpoint = True
                for frame in thread:
                    self.assertTrue(frame.GetThread().GetThreadID() == ID)
                    if self.TraceOn():
                        print frame

            self.assertTrue(stopped_due_to_breakpoint)

    See also :py:class:`SBFrame` .
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    eBroadcastBitStackChanged = _lldb.SBThread_eBroadcastBitStackChanged

    eBroadcastBitThreadSuspended = _lldb.SBThread_eBroadcastBitThreadSuspended

    eBroadcastBitThreadResumed = _lldb.SBThread_eBroadcastBitThreadResumed

    eBroadcastBitSelectedFrameChanged = _lldb.SBThread_eBroadcastBitSelectedFrameChanged

    eBroadcastBitThreadSelected = _lldb.SBThread_eBroadcastBitThreadSelected


    @staticmethod
    def GetBroadcasterClassName() -> str:
        r"""GetBroadcasterClassName() -> char const *"""
        return _lldb.SBThread_GetBroadcasterClassName()

    def __init__(self, *args):
        r"""
        __init__(SBThread self) -> SBThread
        __init__(SBThread self, SBThread thread) -> SBThread
        """
        _lldb.SBThread_swiginit(self, _lldb.new_SBThread(*args))
    __swig_destroy__ = _lldb.delete_SBThread

    def GetQueue(self) -> "SBQueue":
        r"""

        Return the SBQueue for this thread.  If this thread is not currently associated
        with a libdispatch queue, the SBQueue object's IsValid() method will return false.
        If this SBThread is actually a HistoryThread, we may be able to provide QueueID
        and QueueName, but not provide an SBQueue.  Those individual attributes may have
        been saved for the HistoryThread without enough information to reconstitute the
        entire SBQueue at that time.
        This method takes no arguments, returns an SBQueue.
        """
        return _lldb.SBThread_GetQueue(self)

    def __nonzero__(self):
        return _lldb.SBThread___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBThread self) -> bool"""
        return _lldb.SBThread_IsValid(self)

    def Clear(self):
        r"""Clear(SBThread self)"""
        return _lldb.SBThread_Clear(self)

    def GetStopReason(self) -> "lldb::StopReason":
        r"""GetStopReason(SBThread self) -> lldb::StopReason"""
        return _lldb.SBThread_GetStopReason(self)

    def GetStopReasonDataCount(self) -> "size_t":
        r"""
        GetStopReasonDataCount(SBThread self) -> size_t

            Get the number of words associated with the stop reason.
            See also GetStopReasonDataAtIndex().
        """
        return _lldb.SBThread_GetStopReasonDataCount(self)

    def GetStopReasonDataAtIndex(self, idx: int) -> int:
        r"""
        GetStopReasonDataAtIndex(SBThread self, uint32_t idx) -> uint64_t

            Get information associated with a stop reason.

            Breakpoint stop reasons will have data that consists of pairs of
            breakpoint IDs followed by the breakpoint location IDs (they always come
            in pairs).

            Stop Reason              Count Data Type
            ======================== ===== =========================================
            eStopReasonNone          0
            eStopReasonTrace         0
            eStopReasonBreakpoint    N     duple: {breakpoint id, location id}
            eStopReasonWatchpoint    1     watchpoint id
            eStopReasonSignal        1     unix signal number
            eStopReasonException     N     exception data
            eStopReasonExec          0
            eStopReasonFork          1     pid of the child process
            eStopReasonVFork         1     pid of the child process
            eStopReasonVForkDone     0
            eStopReasonPlanComplete  0
        """
        return _lldb.SBThread_GetStopReasonDataAtIndex(self, idx)

    def GetStopReasonExtendedInfoAsJSON(self, stream: "SBStream") -> "bool":
        r"""

        Collects a thread's stop reason extended information dictionary and prints it
        into the SBStream in a JSON format. The format of this JSON dictionary depends
        on the stop reason and is currently used only for instrumentation plugins.
        """
        return _lldb.SBThread_GetStopReasonExtendedInfoAsJSON(self, stream)

    def GetStopReasonExtendedBacktraces(self, type: "lldb::InstrumentationRuntimeType") -> "SBThreadCollection":
        r"""

        Returns a collection of historical stack traces that are significant to the
        current stop reason. Used by ThreadSanitizer, where we provide various stack
        traces that were involved in a data race or other type of detected issue.
        """
        return _lldb.SBThread_GetStopReasonExtendedBacktraces(self, type)

    def GetStopDescription(self, dst_or_null: "char *") -> "size_t":
        r"""

        Pass only an (int)length and expect to get a Python string describing the
        stop reason.
        """
        return _lldb.SBThread_GetStopDescription(self, dst_or_null)

    def GetStopReturnValue(self) -> "SBValue":
        r"""GetStopReturnValue(SBThread self) -> SBValue"""
        return _lldb.SBThread_GetStopReturnValue(self)

    def GetThreadID(self) -> "lldb::tid_t":
        r"""

        Returns a unique thread identifier (type lldb::tid_t, typically a 64-bit type)
        for the current SBThread that will remain constant throughout the thread's
        lifetime in this process and will not be reused by another thread during this
        process lifetime.  On Mac OS X systems, this is a system-wide unique thread
        identifier; this identifier is also used by other tools like sample which helps
        to associate data from those tools with lldb.  See related GetIndexID.
        """
        return _lldb.SBThread_GetThreadID(self)

    def GetIndexID(self) -> int:
        r"""

        Return the index number for this SBThread.  The index number is the same thing
        that a user gives as an argument to 'thread select' in the command line lldb.
        These numbers start at 1 (for the first thread lldb sees in a debug session)
        and increments up throughout the process lifetime.  An index number will not be
        reused for a different thread later in a process - thread 1 will always be
        associated with the same thread.  See related GetThreadID.
        This method returns a uint32_t index number, takes no arguments.
        """
        return _lldb.SBThread_GetIndexID(self)

    def GetName(self) -> str:
        r"""GetName(SBThread self) -> char const *"""
        return _lldb.SBThread_GetName(self)

    def GetQueueName(self) -> str:
        r"""

        Return the queue name associated with this thread, if any, as a str.
        For example, with a libdispatch (aka Grand Central Dispatch) queue.
        """
        return _lldb.SBThread_GetQueueName(self)

    def GetQueueID(self) -> "lldb::queue_id_t":
        r"""

        Return the dispatch_queue_id for this thread, if any, as a lldb::queue_id_t.
        For example, with a libdispatch (aka Grand Central Dispatch) queue.
        """
        return _lldb.SBThread_GetQueueID(self)

    def GetInfoItemByPathAsString(self, path: str, strm: "SBStream") -> "bool":
        r"""
        GetInfoItemByPathAsString(SBThread self, char const * path, SBStream strm) -> bool

            Takes a path string and a SBStream reference as parameters, returns a bool.
            Collects the thread's 'info' dictionary from the remote system, uses the path
            argument to descend into the dictionary to an item of interest, and prints
            it into the SBStream in a natural format.  Return bool is to indicate if
            anything was printed into the stream (true) or not (false).
        """
        return _lldb.SBThread_GetInfoItemByPathAsString(self, path, strm)

    def StepOver(self, *args):
        r"""
        StepOver(SBThread self, lldb::RunMode stop_other_threads=eOnlyDuringStepping)
        StepOver(SBThread self, lldb::RunMode stop_other_threads, SBError error)
        Do a source level single step over in the currently selected thread.
        """
        return _lldb.SBThread_StepOver(self, *args)

    def StepInto(self, *args):
        r"""
        StepInto(SBThread self, lldb::RunMode stop_other_threads=eOnlyDuringStepping)
        StepInto(SBThread self, char const * target_name, lldb::RunMode stop_other_threads=eOnlyDuringStepping)
        StepInto(SBThread self, char const * target_name, uint32_t end_line, SBError error, lldb::RunMode stop_other_threads=eOnlyDuringStepping)

            Step the current thread from the current source line to the line given by end_line, stopping if
            the thread steps into the function given by target_name.  If target_name is None, then stepping will stop
            in any of the places we would normally stop.
        """
        return _lldb.SBThread_StepInto(self, *args)

    def StepOut(self, *args):
        r"""
        StepOut(SBThread self)
        StepOut(SBThread self, SBError error)
        Step out of the currently selected thread.
        """
        return _lldb.SBThread_StepOut(self, *args)

    def StepOutOfFrame(self, *args):
        r"""
        StepOutOfFrame(SBThread self, SBFrame frame)
        StepOutOfFrame(SBThread self, SBFrame frame, SBError error)
        Step out of the specified frame.
        """
        return _lldb.SBThread_StepOutOfFrame(self, *args)

    def StepInstruction(self, *args):
        r"""
        StepInstruction(SBThread self, bool step_over)
        StepInstruction(SBThread self, bool step_over, SBError error)
        Do an instruction level single step in the currently selected thread.
        """
        return _lldb.SBThread_StepInstruction(self, *args)

    def StepOverUntil(self, frame: "SBFrame", file_spec: "SBFileSpec", line: int) -> "SBError":
        r"""StepOverUntil(SBThread self, SBFrame frame, SBFileSpec file_spec, uint32_t line) -> SBError"""
        return _lldb.SBThread_StepOverUntil(self, frame, file_spec, line)

    def StepUsingScriptedThreadPlan(self, *args) -> "SBError":
        r"""
        StepUsingScriptedThreadPlan(SBThread self, char const * script_class_name) -> SBError
        StepUsingScriptedThreadPlan(SBThread self, char const * script_class_name, bool resume_immediately) -> SBError
        StepUsingScriptedThreadPlan(SBThread self, char const * script_class_name, SBStructuredData args_data, bool resume_immediately) -> SBError
        """
        return _lldb.SBThread_StepUsingScriptedThreadPlan(self, *args)

    def JumpToLine(self, file_spec: "SBFileSpec", line: int) -> "SBError":
        r"""JumpToLine(SBThread self, SBFileSpec file_spec, uint32_t line) -> SBError"""
        return _lldb.SBThread_JumpToLine(self, file_spec, line)

    def RunToAddress(self, *args):
        r"""
        RunToAddress(SBThread self, lldb::addr_t addr)
        RunToAddress(SBThread self, lldb::addr_t addr, SBError error)
        """
        return _lldb.SBThread_RunToAddress(self, *args)

    def ReturnFromFrame(self, frame: "SBFrame", return_value: "SBValue") -> "SBError":
        r"""

        Force a return from the frame passed in (and any frames younger than it)
        without executing any more code in those frames.  If return_value contains
        a valid SBValue, that will be set as the return value from frame.  Note, at
        present only scalar return values are supported.
        """
        return _lldb.SBThread_ReturnFromFrame(self, frame, return_value)

    def UnwindInnermostExpression(self) -> "SBError":
        r"""

        Unwind the stack frames from the innermost expression evaluation.
        This API is equivalent to 'thread return -x'.
        """
        return _lldb.SBThread_UnwindInnermostExpression(self)

    def Suspend(self, *args) -> "bool":
        r"""
        Suspend(SBThread self) -> bool
        Suspend(SBThread self, SBError error) -> bool

            LLDB currently supports process centric debugging which means when any
            thread in a process stops, all other threads are stopped. The Suspend()
            call here tells our process to suspend a thread and not let it run when
            the other threads in a process are allowed to run. So when
            SBProcess::Continue() is called, any threads that aren't suspended will
            be allowed to run. If any of the SBThread functions for stepping are
            called (StepOver, StepInto, StepOut, StepInstruction, RunToAddres), the
            thread will now be allowed to run and these functions will simply return.

            Eventually we plan to add support for thread centric debugging where
            each thread is controlled individually and each thread would broadcast
            its state, but we haven't implemented this yet.

            Likewise the SBThread::Resume() call will again allow the thread to run
            when the process is continued.

            Suspend() and Resume() functions are not currently reference counted, if
            anyone has the need for them to be reference counted, please let us
            know.
        """
        return _lldb.SBThread_Suspend(self, *args)

    def Resume(self, *args) -> "bool":
        r"""
        Resume(SBThread self) -> bool
        Resume(SBThread self, SBError error) -> bool
        """
        return _lldb.SBThread_Resume(self, *args)

    def IsSuspended(self) -> "bool":
        r"""IsSuspended(SBThread self) -> bool"""
        return _lldb.SBThread_IsSuspended(self)

    def IsStopped(self) -> "bool":
        r"""IsStopped(SBThread self) -> bool"""
        return _lldb.SBThread_IsStopped(self)

    def GetNumFrames(self) -> int:
        r"""GetNumFrames(SBThread self) -> uint32_t"""
        return _lldb.SBThread_GetNumFrames(self)

    def GetFrameAtIndex(self, idx: int) -> "SBFrame":
        r"""GetFrameAtIndex(SBThread self, uint32_t idx) -> SBFrame"""
        return _lldb.SBThread_GetFrameAtIndex(self, idx)

    def GetSelectedFrame(self) -> "SBFrame":
        r"""GetSelectedFrame(SBThread self) -> SBFrame"""
        return _lldb.SBThread_GetSelectedFrame(self)

    def SetSelectedFrame(self, frame_idx: int) -> "SBFrame":
        r"""SetSelectedFrame(SBThread self, uint32_t frame_idx) -> SBFrame"""
        return _lldb.SBThread_SetSelectedFrame(self, frame_idx)

    @staticmethod
    def EventIsThreadEvent(event: "SBEvent") -> "bool":
        r"""EventIsThreadEvent(SBEvent event) -> bool"""
        return _lldb.SBThread_EventIsThreadEvent(event)

    @staticmethod
    def GetStackFrameFromEvent(event: "SBEvent") -> "SBFrame":
        r"""GetStackFrameFromEvent(SBEvent event) -> SBFrame"""
        return _lldb.SBThread_GetStackFrameFromEvent(event)

    @staticmethod
    def GetThreadFromEvent(event: "SBEvent") -> "SBThread":
        r"""GetThreadFromEvent(SBEvent event) -> SBThread"""
        return _lldb.SBThread_GetThreadFromEvent(event)

    def GetProcess(self) -> "SBProcess":
        r"""GetProcess(SBThread self) -> SBProcess"""
        return _lldb.SBThread_GetProcess(self)

    def __eq__(self, rhs: "SBThread") -> "bool":
        r"""__eq__(SBThread self, SBThread rhs) -> bool"""
        return _lldb.SBThread___eq__(self, rhs)

    def __ne__(self, rhs: "SBThread") -> "bool":
        r"""__ne__(SBThread self, SBThread rhs) -> bool"""
        return _lldb.SBThread___ne__(self, rhs)

    def GetDescription(self, *args) -> "bool":
        r"""
        GetDescription(SBThread self, SBStream description) -> bool
        GetDescription(SBThread self, SBStream description, bool stop_format) -> bool

            Get the description strings for this thread that match what the
            lldb driver will present, using the thread-format (stop_format==false)
            or thread-stop-format (stop_format = true).
        """
        return _lldb.SBThread_GetDescription(self, *args)

    def GetStatus(self, status: "SBStream") -> "bool":
        r"""GetStatus(SBThread self, SBStream status) -> bool"""
        return _lldb.SBThread_GetStatus(self, status)

    def GetExtendedBacktraceThread(self, type: str) -> "SBThread":
        r"""

        Given an argument of str to specify the type of thread-origin extended
        backtrace to retrieve, query whether the origin of this thread is
        available.  An SBThread is retured; SBThread.IsValid will return true
        if an extended backtrace was available.  The returned SBThread is not
        a part of the SBProcess' thread list and it cannot be manipulated like
        normal threads -- you cannot step or resume it, for instance -- it is
        intended to used primarily for generating a backtrace.  You may request
        the returned thread's own thread origin in turn.
        """
        return _lldb.SBThread_GetExtendedBacktraceThread(self, type)

    def GetExtendedBacktraceOriginatingIndexID(self) -> int:
        r"""

        Takes no arguments, returns a uint32_t.
        If this SBThread is an ExtendedBacktrace thread, get the IndexID of the
        original thread that this ExtendedBacktrace thread represents, if
        available.  The thread that was running this backtrace in the past may
        not have been registered with lldb's thread index (if it was created,
        did its work, and was destroyed without lldb ever stopping execution).
        In that case, this ExtendedBacktrace thread's IndexID will be returned.
        """
        return _lldb.SBThread_GetExtendedBacktraceOriginatingIndexID(self)

    def GetCurrentException(self) -> "SBValue":
        r"""

        Returns an SBValue object represeting the current exception for the thread,
        if there is any. Currently, this works for Obj-C code and returns an SBValue
        representing the NSException object at the throw site or that's currently
        being processes.
        """
        return _lldb.SBThread_GetCurrentException(self)

    def GetCurrentExceptionBacktrace(self) -> "SBThread":
        r"""

        Returns a historical (fake) SBThread representing the stack trace of an
        exception, if there is one for the thread. Currently, this works for Obj-C
        code, and can retrieve the throw-site backtrace of an NSException object
        even when the program is no longer at the throw site.
        """
        return _lldb.SBThread_GetCurrentExceptionBacktrace(self)

    def SafeToCallFunctions(self) -> "bool":
        r"""

        Takes no arguments, returns a bool.
        lldb may be able to detect that function calls should not be executed
        on a given thread at a particular point in time.  It is recommended that
        this is checked before performing an inferior function call on a given
        thread.
        """
        return _lldb.SBThread_SafeToCallFunctions(self)

    def GetSiginfo(self) -> "SBValue":
        r"""

        Retruns a SBValue object representing the siginfo for the current signal.

        """
        return _lldb.SBThread_GetSiginfo(self)

    def __repr__(self) -> str:
        r"""__repr__(SBThread self) -> std::string"""
        return _lldb.SBThread___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __iter__(self):
        '''Iterate over all frames in a lldb.SBThread object.'''
        return lldb_iter(self, 'GetNumFrames', 'GetFrameAtIndex')

    def __len__(self):
        '''Return the number of frames in a lldb.SBThread object.'''
        return self.GetNumFrames()

    class frames_access(object):
        '''A helper object that will lazily hand out frames for a thread when supplied an index.'''
        def __init__(self, sbthread):
            self.sbthread = sbthread

        def __len__(self):
            if self.sbthread:
                return int(self.sbthread.GetNumFrames())
            return 0

        def __getitem__(self, key):
            if isinstance(key, int):
                count = len(self)
                if -count <= key < count:
                    key %= count
                    return self.sbthread.GetFrameAtIndex(key)
            return None

    def get_frames_access_object(self):
        '''An accessor function that returns a frames_access() object which allows lazy frame access from a lldb.SBThread object.'''
        return self.frames_access (self)

    def get_thread_frames(self):
        '''An accessor function that returns a list() that contains all frames in a lldb.SBThread object.'''
        frames = []
        for frame in self:
            frames.append(frame)
        return frames

    id = property(GetThreadID, None, doc='''A read only property that returns the thread ID as an integer.''')
    idx = property(GetIndexID, None, doc='''A read only property that returns the thread index ID as an integer. Thread index ID values start at 1 and increment as threads come and go and can be used to uniquely identify threads.''')
    return_value = property(GetStopReturnValue, None, doc='''A read only property that returns an lldb object that represents the return value from the last stop (lldb.SBValue) if we just stopped due to stepping out of a function.''')
    process = property(GetProcess, None, doc='''A read only property that returns an lldb object that represents the process (lldb.SBProcess) that owns this thread.''')
    num_frames = property(GetNumFrames, None, doc='''A read only property that returns the number of stack frames in this thread as an integer.''')
    frames = property(get_thread_frames, None, doc='''A read only property that returns a list() of lldb.SBFrame objects for all frames in this thread.''')
    frame = property(get_frames_access_object, None, doc='''A read only property that returns an object that can be used to access frames as an array ("frame_12 = lldb.thread.frame[12]").''')
    name = property(GetName, None, doc='''A read only property that returns the name of this thread as a string.''')
    queue = property(GetQueueName, None, doc='''A read only property that returns the dispatch queue name of this thread as a string.''')
    queue_id = property(GetQueueID, None, doc='''A read only property that returns the dispatch queue id of this thread as an integer.''')
    stop_reason = property(GetStopReason, None, doc='''A read only property that returns an lldb enumeration value (see enumerations that start with "lldb.eStopReason") that represents the reason this thread stopped.''')
    is_suspended = property(IsSuspended, None, doc='''A read only property that returns a boolean value that indicates if this thread is suspended.''')
    is_stopped = property(IsStopped, None, doc='''A read only property that returns a boolean value that indicates if this thread is stopped but not exited.''')


    def __eq__(self, rhs):
        if not isinstance(rhs, type(self)):
            return False

        return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)

    def __ne__(self, rhs):
        if not isinstance(rhs, type(self)):
            return True

        return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)


# Register SBThread in _lldb:
_lldb.SBThread_swigregister(SBThread)

def SBThread_GetBroadcasterClassName() -> str:
    r"""SBThread_GetBroadcasterClassName() -> char const *"""
    return _lldb.SBThread_GetBroadcasterClassName()

def SBThread_EventIsThreadEvent(event: "SBEvent") -> "bool":
    r"""SBThread_EventIsThreadEvent(SBEvent event) -> bool"""
    return _lldb.SBThread_EventIsThreadEvent(event)

def SBThread_GetStackFrameFromEvent(event: "SBEvent") -> "SBFrame":
    r"""SBThread_GetStackFrameFromEvent(SBEvent event) -> SBFrame"""
    return _lldb.SBThread_GetStackFrameFromEvent(event)

def SBThread_GetThreadFromEvent(event: "SBEvent") -> "SBThread":
    r"""SBThread_GetThreadFromEvent(SBEvent event) -> SBThread"""
    return _lldb.SBThread_GetThreadFromEvent(event)

class SBThreadCollection(object):
    r"""Represents a collection of SBThread objects."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBThreadCollection self) -> SBThreadCollection
        __init__(SBThreadCollection self, SBThreadCollection rhs) -> SBThreadCollection
        """
        _lldb.SBThreadCollection_swiginit(self, _lldb.new_SBThreadCollection(*args))
    __swig_destroy__ = _lldb.delete_SBThreadCollection

    def __nonzero__(self):
        return _lldb.SBThreadCollection___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBThreadCollection self) -> bool"""
        return _lldb.SBThreadCollection_IsValid(self)

    def GetSize(self) -> "size_t":
        r"""GetSize(SBThreadCollection self) -> size_t"""
        return _lldb.SBThreadCollection_GetSize(self)

    def GetThreadAtIndex(self, idx: "size_t") -> "SBThread":
        r"""GetThreadAtIndex(SBThreadCollection self, size_t idx) -> SBThread"""
        return _lldb.SBThreadCollection_GetThreadAtIndex(self, idx)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __iter__(self):
        '''Iterate over all threads in a lldb.SBThreadCollection object.'''
        return lldb_iter(self, 'GetSize', 'GetThreadAtIndex')

    def __len__(self):
        '''Return the number of threads in a lldb.SBThreadCollection object.'''
        return self.GetSize()


# Register SBThreadCollection in _lldb:
_lldb.SBThreadCollection_swigregister(SBThreadCollection)

class SBThreadPlan(object):
    r"""
    Represents a plan for the execution control of a given thread.

    See also :py:class:`SBThread` and :py:class:`SBFrame`.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBThreadPlan self) -> SBThreadPlan
        __init__(SBThreadPlan self, SBThreadPlan threadPlan) -> SBThreadPlan
        __init__(SBThreadPlan self, SBThread thread, char const * class_name) -> SBThreadPlan
        __init__(SBThreadPlan self, SBThread thread, char const * class_name, SBStructuredData args_data) -> SBThreadPlan
        """
        _lldb.SBThreadPlan_swiginit(self, _lldb.new_SBThreadPlan(*args))
    __swig_destroy__ = _lldb.delete_SBThreadPlan

    def __nonzero__(self):
        return _lldb.SBThreadPlan___nonzero__(self)
    __bool__ = __nonzero__



    def Clear(self):
        r"""Clear(SBThreadPlan self)"""
        return _lldb.SBThreadPlan_Clear(self)

    def GetStopReason(self) -> "lldb::StopReason":
        r"""GetStopReason(SBThreadPlan self) -> lldb::StopReason"""
        return _lldb.SBThreadPlan_GetStopReason(self)

    def GetStopReasonDataCount(self) -> "size_t":
        r"""
        GetStopReasonDataCount(SBThreadPlan self) -> size_t

            Get the number of words associated with the stop reason.
            See also GetStopReasonDataAtIndex().
        """
        return _lldb.SBThreadPlan_GetStopReasonDataCount(self)

    def GetStopReasonDataAtIndex(self, idx: int) -> int:
        r"""
        GetStopReasonDataAtIndex(SBThreadPlan self, uint32_t idx) -> uint64_t

            Get information associated with a stop reason.

            Breakpoint stop reasons will have data that consists of pairs of
            breakpoint IDs followed by the breakpoint location IDs (they always come
            in pairs).

            Stop Reason              Count Data Type
            ======================== ===== =========================================
            eStopReasonNone          0
            eStopReasonTrace         0
            eStopReasonBreakpoint    N     duple: {breakpoint id, location id}
            eStopReasonWatchpoint    1     watchpoint id
            eStopReasonSignal        1     unix signal number
            eStopReasonException     N     exception data
            eStopReasonExec          0
            eStopReasonFork          1     pid of the child process
            eStopReasonVFork         1     pid of the child process
            eStopReasonVForkDone     0
            eStopReasonPlanComplete  0
        """
        return _lldb.SBThreadPlan_GetStopReasonDataAtIndex(self, idx)

    def GetThread(self) -> "SBThread":
        r"""GetThread(SBThreadPlan self) -> SBThread"""
        return _lldb.SBThreadPlan_GetThread(self)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBThreadPlan self, SBStream description) -> bool"""
        return _lldb.SBThreadPlan_GetDescription(self, description)

    def SetPlanComplete(self, success: "bool"):
        r"""SetPlanComplete(SBThreadPlan self, bool success)"""
        return _lldb.SBThreadPlan_SetPlanComplete(self, success)

    def IsPlanComplete(self) -> "bool":
        r"""IsPlanComplete(SBThreadPlan self) -> bool"""
        return _lldb.SBThreadPlan_IsPlanComplete(self)

    def IsPlanStale(self) -> "bool":
        r"""IsPlanStale(SBThreadPlan self) -> bool"""
        return _lldb.SBThreadPlan_IsPlanStale(self)

    def IsValid(self, *args) -> "bool":
        r"""
        IsValid(SBThreadPlan self) -> bool
        IsValid(SBThreadPlan self) -> bool
        """
        return _lldb.SBThreadPlan_IsValid(self, *args)

    def GetStopOthers(self) -> "bool":
        r"""
        GetStopOthers(SBThreadPlan self) -> bool
        Return whether this plan will ask to stop other threads when it runs.
        """
        return _lldb.SBThreadPlan_GetStopOthers(self)

    def SetStopOthers(self, stop_others: "bool"):
        r"""
        SetStopOthers(SBThreadPlan self, bool stop_others)
        Set whether this plan will ask to stop other threads when it runs.
        """
        return _lldb.SBThreadPlan_SetStopOthers(self, stop_others)

    def QueueThreadPlanForStepOverRange(self, *args) -> "SBThreadPlan":
        r"""
        QueueThreadPlanForStepOverRange(SBThreadPlan self, SBAddress start_address, lldb::addr_t range_size) -> SBThreadPlan
        QueueThreadPlanForStepOverRange(SBThreadPlan self, SBAddress start_address, lldb::addr_t range_size, SBError error) -> SBThreadPlan
        """
        return _lldb.SBThreadPlan_QueueThreadPlanForStepOverRange(self, *args)

    def QueueThreadPlanForStepInRange(self, *args) -> "SBThreadPlan":
        r"""
        QueueThreadPlanForStepInRange(SBThreadPlan self, SBAddress start_address, lldb::addr_t range_size) -> SBThreadPlan
        QueueThreadPlanForStepInRange(SBThreadPlan self, SBAddress start_address, lldb::addr_t range_size, SBError error) -> SBThreadPlan
        """
        return _lldb.SBThreadPlan_QueueThreadPlanForStepInRange(self, *args)

    def QueueThreadPlanForStepOut(self, *args) -> "SBThreadPlan":
        r"""
        QueueThreadPlanForStepOut(SBThreadPlan self, uint32_t frame_idx_to_step_to, bool first_insn=False) -> SBThreadPlan
        QueueThreadPlanForStepOut(SBThreadPlan self, uint32_t frame_idx_to_step_to, bool first_insn, SBError error) -> SBThreadPlan
        """
        return _lldb.SBThreadPlan_QueueThreadPlanForStepOut(self, *args)

    def QueueThreadPlanForRunToAddress(self, *args) -> "SBThreadPlan":
        r"""
        QueueThreadPlanForRunToAddress(SBThreadPlan self, SBAddress address) -> SBThreadPlan
        QueueThreadPlanForRunToAddress(SBThreadPlan self, SBAddress address, SBError error) -> SBThreadPlan
        """
        return _lldb.SBThreadPlan_QueueThreadPlanForRunToAddress(self, *args)

    def QueueThreadPlanForStepScripted(self, *args) -> "SBThreadPlan":
        r"""
        QueueThreadPlanForStepScripted(SBThreadPlan self, char const * script_class_name) -> SBThreadPlan
        QueueThreadPlanForStepScripted(SBThreadPlan self, char const * script_class_name, SBError error) -> SBThreadPlan
        QueueThreadPlanForStepScripted(SBThreadPlan self, char const * script_class_name, SBStructuredData args_data, SBError error) -> SBThreadPlan
        """
        return _lldb.SBThreadPlan_QueueThreadPlanForStepScripted(self, *args)

    def __repr__(self) -> str:
        r"""__repr__(SBThreadPlan self) -> std::string"""
        return _lldb.SBThreadPlan___repr__(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBThreadPlan in _lldb:
_lldb.SBThreadPlan_swigregister(SBThreadPlan)

class SBTrace(object):
    r"""Represents a processor trace."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(SBTrace self) -> SBTrace"""
        _lldb.SBTrace_swiginit(self, _lldb.new_SBTrace())

    @staticmethod
    def LoadTraceFromFile(error: "SBError", debugger: "SBDebugger", trace_description_file: "SBFileSpec") -> "SBTrace":
        r"""LoadTraceFromFile(SBError error, SBDebugger debugger, SBFileSpec trace_description_file) -> SBTrace"""
        return _lldb.SBTrace_LoadTraceFromFile(error, debugger, trace_description_file)

    def CreateNewCursor(self, error: "SBError", thread: "SBThread") -> "SBTraceCursor":
        r"""CreateNewCursor(SBTrace self, SBError error, SBThread thread) -> SBTraceCursor"""
        return _lldb.SBTrace_CreateNewCursor(self, error, thread)

    def SaveToDisk(self, error: "SBError", bundle_dir: "SBFileSpec", compact: "bool"=False) -> "SBFileSpec":
        r"""SaveToDisk(SBTrace self, SBError error, SBFileSpec bundle_dir, bool compact=False) -> SBFileSpec"""
        return _lldb.SBTrace_SaveToDisk(self, error, bundle_dir, compact)

    def GetStartConfigurationHelp(self) -> str:
        r"""GetStartConfigurationHelp(SBTrace self) -> char const *"""
        return _lldb.SBTrace_GetStartConfigurationHelp(self)

    def Start(self, *args) -> "SBError":
        r"""
        Start(SBTrace self, SBStructuredData configuration) -> SBError
        Start(SBTrace self, SBThread thread, SBStructuredData configuration) -> SBError
        """
        return _lldb.SBTrace_Start(self, *args)

    def Stop(self, *args) -> "SBError":
        r"""
        Stop(SBTrace self) -> SBError
        Stop(SBTrace self, SBThread thread) -> SBError
        """
        return _lldb.SBTrace_Stop(self, *args)

    def __nonzero__(self):
        return _lldb.SBTrace___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBTrace self) -> bool"""
        return _lldb.SBTrace_IsValid(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass

    __swig_destroy__ = _lldb.delete_SBTrace

# Register SBTrace in _lldb:
_lldb.SBTrace_swigregister(SBTrace)

def SBTrace_LoadTraceFromFile(error: "SBError", debugger: "SBDebugger", trace_description_file: "SBFileSpec") -> "SBTrace":
    r"""SBTrace_LoadTraceFromFile(SBError error, SBDebugger debugger, SBFileSpec trace_description_file) -> SBTrace"""
    return _lldb.SBTrace_LoadTraceFromFile(error, debugger, trace_description_file)

class SBTraceCursor(object):
    r"""Represents a trace cursor."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(SBTraceCursor self) -> SBTraceCursor"""
        _lldb.SBTraceCursor_swiginit(self, _lldb.new_SBTraceCursor())

    def SetForwards(self, forwards: "bool"):
        r"""SetForwards(SBTraceCursor self, bool forwards)"""
        return _lldb.SBTraceCursor_SetForwards(self, forwards)

    def IsForwards(self) -> "bool":
        r"""IsForwards(SBTraceCursor self) -> bool"""
        return _lldb.SBTraceCursor_IsForwards(self)

    def Next(self):
        r"""Next(SBTraceCursor self)"""
        return _lldb.SBTraceCursor_Next(self)

    def HasValue(self) -> "bool":
        r"""HasValue(SBTraceCursor self) -> bool"""
        return _lldb.SBTraceCursor_HasValue(self)

    def GoToId(self, id: int) -> "bool":
        r"""GoToId(SBTraceCursor self, lldb::user_id_t id) -> bool"""
        return _lldb.SBTraceCursor_GoToId(self, id)

    def HasId(self, id: int) -> "bool":
        r"""HasId(SBTraceCursor self, lldb::user_id_t id) -> bool"""
        return _lldb.SBTraceCursor_HasId(self, id)

    def GetId(self) -> int:
        r"""GetId(SBTraceCursor self) -> lldb::user_id_t"""
        return _lldb.SBTraceCursor_GetId(self)

    def Seek(self, offset: "int64_t", origin: "lldb::TraceCursorSeekType") -> "bool":
        r"""Seek(SBTraceCursor self, int64_t offset, lldb::TraceCursorSeekType origin) -> bool"""
        return _lldb.SBTraceCursor_Seek(self, offset, origin)

    def GetItemKind(self) -> "lldb::TraceItemKind":
        r"""GetItemKind(SBTraceCursor self) -> lldb::TraceItemKind"""
        return _lldb.SBTraceCursor_GetItemKind(self)

    def IsError(self) -> "bool":
        r"""IsError(SBTraceCursor self) -> bool"""
        return _lldb.SBTraceCursor_IsError(self)

    def GetError(self) -> str:
        r"""GetError(SBTraceCursor self) -> char const *"""
        return _lldb.SBTraceCursor_GetError(self)

    def IsEvent(self) -> "bool":
        r"""IsEvent(SBTraceCursor self) -> bool"""
        return _lldb.SBTraceCursor_IsEvent(self)

    def GetEventType(self) -> "lldb::TraceEvent":
        r"""GetEventType(SBTraceCursor self) -> lldb::TraceEvent"""
        return _lldb.SBTraceCursor_GetEventType(self)

    def GetEventTypeAsString(self) -> str:
        r"""GetEventTypeAsString(SBTraceCursor self) -> char const *"""
        return _lldb.SBTraceCursor_GetEventTypeAsString(self)

    def IsInstruction(self) -> "bool":
        r"""IsInstruction(SBTraceCursor self) -> bool"""
        return _lldb.SBTraceCursor_IsInstruction(self)

    def GetLoadAddress(self) -> int:
        r"""GetLoadAddress(SBTraceCursor self) -> lldb::addr_t"""
        return _lldb.SBTraceCursor_GetLoadAddress(self)

    def GetCPU(self) -> "lldb::cpu_id_t":
        r"""GetCPU(SBTraceCursor self) -> lldb::cpu_id_t"""
        return _lldb.SBTraceCursor_GetCPU(self)

    def IsValid(self) -> "bool":
        r"""IsValid(SBTraceCursor self) -> bool"""
        return _lldb.SBTraceCursor_IsValid(self)

    def __nonzero__(self):
        return _lldb.SBTraceCursor___nonzero__(self)
    __bool__ = __nonzero__



    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass

    __swig_destroy__ = _lldb.delete_SBTraceCursor

# Register SBTraceCursor in _lldb:
_lldb.SBTraceCursor_swigregister(SBTraceCursor)

class SBTypeMember(object):
    r"""Represents a member of a type."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBTypeMember self) -> SBTypeMember
        __init__(SBTypeMember self, SBTypeMember rhs) -> SBTypeMember
        """
        _lldb.SBTypeMember_swiginit(self, _lldb.new_SBTypeMember(*args))
    __swig_destroy__ = _lldb.delete_SBTypeMember

    def __nonzero__(self):
        return _lldb.SBTypeMember___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBTypeMember self) -> bool"""
        return _lldb.SBTypeMember_IsValid(self)

    def GetName(self) -> str:
        r"""GetName(SBTypeMember self) -> char const *"""
        return _lldb.SBTypeMember_GetName(self)

    def GetType(self) -> "SBType":
        r"""GetType(SBTypeMember self) -> SBType"""
        return _lldb.SBTypeMember_GetType(self)

    def GetOffsetInBytes(self) -> int:
        r"""GetOffsetInBytes(SBTypeMember self) -> uint64_t"""
        return _lldb.SBTypeMember_GetOffsetInBytes(self)

    def GetOffsetInBits(self) -> int:
        r"""GetOffsetInBits(SBTypeMember self) -> uint64_t"""
        return _lldb.SBTypeMember_GetOffsetInBits(self)

    def IsBitfield(self) -> "bool":
        r"""IsBitfield(SBTypeMember self) -> bool"""
        return _lldb.SBTypeMember_IsBitfield(self)

    def GetBitfieldSizeInBits(self) -> int:
        r"""GetBitfieldSizeInBits(SBTypeMember self) -> uint32_t"""
        return _lldb.SBTypeMember_GetBitfieldSizeInBits(self)

    def GetDescription(self, description: "SBStream", description_level: "lldb::DescriptionLevel") -> "bool":
        r"""GetDescription(SBTypeMember self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        return _lldb.SBTypeMember_GetDescription(self, description, description_level)

    def __repr__(self) -> str:
        r"""__repr__(SBTypeMember self) -> std::string"""
        return _lldb.SBTypeMember___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    name = property(GetName, None, doc='''A read only property that returns the name for this member as a string.''')
    type = property(GetType, None, doc='''A read only property that returns an lldb object that represents the type (lldb.SBType) for this member.''')
    byte_offset = property(GetOffsetInBytes, None, doc='''A read only property that returns offset in bytes for this member as an integer.''')
    bit_offset = property(GetOffsetInBits, None, doc='''A read only property that returns offset in bits for this member as an integer.''')
    is_bitfield = property(IsBitfield, None, doc='''A read only property that returns true if this member is a bitfield.''')
    bitfield_bit_size = property(GetBitfieldSizeInBits, None, doc='''A read only property that returns the bitfield size in bits for this member as an integer, or zero if this member is not a bitfield.''')


# Register SBTypeMember in _lldb:
_lldb.SBTypeMember_swigregister(SBTypeMember)

class SBTypeMemberFunction(object):
    r"""Represents a member function of a type."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBTypeMemberFunction self) -> SBTypeMemberFunction
        __init__(SBTypeMemberFunction self, SBTypeMemberFunction rhs) -> SBTypeMemberFunction
        """
        _lldb.SBTypeMemberFunction_swiginit(self, _lldb.new_SBTypeMemberFunction(*args))
    __swig_destroy__ = _lldb.delete_SBTypeMemberFunction

    def __nonzero__(self):
        return _lldb.SBTypeMemberFunction___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBTypeMemberFunction self) -> bool"""
        return _lldb.SBTypeMemberFunction_IsValid(self)

    def GetName(self) -> str:
        r"""GetName(SBTypeMemberFunction self) -> char const *"""
        return _lldb.SBTypeMemberFunction_GetName(self)

    def GetDemangledName(self) -> str:
        r"""GetDemangledName(SBTypeMemberFunction self) -> char const *"""
        return _lldb.SBTypeMemberFunction_GetDemangledName(self)

    def GetMangledName(self) -> str:
        r"""GetMangledName(SBTypeMemberFunction self) -> char const *"""
        return _lldb.SBTypeMemberFunction_GetMangledName(self)

    def GetType(self) -> "SBType":
        r"""GetType(SBTypeMemberFunction self) -> SBType"""
        return _lldb.SBTypeMemberFunction_GetType(self)

    def GetReturnType(self) -> "SBType":
        r"""GetReturnType(SBTypeMemberFunction self) -> SBType"""
        return _lldb.SBTypeMemberFunction_GetReturnType(self)

    def GetNumberOfArguments(self) -> int:
        r"""GetNumberOfArguments(SBTypeMemberFunction self) -> uint32_t"""
        return _lldb.SBTypeMemberFunction_GetNumberOfArguments(self)

    def GetArgumentTypeAtIndex(self, arg2: int) -> "SBType":
        r"""GetArgumentTypeAtIndex(SBTypeMemberFunction self, uint32_t arg2) -> SBType"""
        return _lldb.SBTypeMemberFunction_GetArgumentTypeAtIndex(self, arg2)

    def GetKind(self) -> "lldb::MemberFunctionKind":
        r"""GetKind(SBTypeMemberFunction self) -> lldb::MemberFunctionKind"""
        return _lldb.SBTypeMemberFunction_GetKind(self)

    def GetDescription(self, description: "SBStream", description_level: "lldb::DescriptionLevel") -> "bool":
        r"""GetDescription(SBTypeMemberFunction self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        return _lldb.SBTypeMemberFunction_GetDescription(self, description, description_level)

    def __repr__(self) -> str:
        r"""__repr__(SBTypeMemberFunction self) -> std::string"""
        return _lldb.SBTypeMemberFunction___repr__(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBTypeMemberFunction in _lldb:
_lldb.SBTypeMemberFunction_swigregister(SBTypeMemberFunction)

class SBType(object):
    r"""
    Represents a data type in lldb.

    The actual characteristics of each type are defined by the semantics of the
    programming language and the specific language implementation that was used
    to compile the target program. See the language-specific notes in the
    documentation of each method.

    SBType instances can be obtained by a variety of methods.
    `SBTarget.FindFirstType` and `SBModule.FindFirstType` can be used to create
    `SBType` representations of types in executables/libraries with debug
    information. For some languages such as C, C++ and Objective-C it is possible
    to create new types by evaluating expressions that define a new type.

    Note that most `SBType` properties are computed independently of any runtime
    information so for dynamic languages the functionality can be very limited.
    `SBValue` can be used to represent runtime values which then can be more
    accurately queried for certain information such as byte size.


    SBType supports the eq/ne operator. For example,::

        //main.cpp:

        class Task {
        public:
            int id;
            Task *next;
            Task(int i, Task *n):
                id(i),
                next(n)
            {}
        };

        int main (int argc, char const *argv[])
        {
            Task *task_head = new Task(-1, NULL);
            Task *task1 = new Task(1, NULL);
            Task *task2 = new Task(2, NULL);
            Task *task3 = new Task(3, NULL); // Orphaned.
            Task *task4 = new Task(4, NULL);
            Task *task5 = new Task(5, NULL);

            task_head->next = task1;
            task1->next = task2;
            task2->next = task4;
            task4->next = task5;

            int total = 0;
            Task *t = task_head;
            while (t != NULL) {
                if (t->id >= 0)
                    ++total;
                t = t->next;
            }
            printf('We have a total number of %d tasks\n', total);

            // This corresponds to an empty task list.
            Task *empty_task_head = new Task(-1, NULL);

            return 0; // Break at this line
        }

        # find_type.py:

                # Get the type 'Task'.
                task_type = target.FindFirstType('Task')
                self.assertTrue(task_type)

                # Get the variable 'task_head'.
                frame0.FindVariable('task_head')
                task_head_type = task_head.GetType()
                self.assertTrue(task_head_type.IsPointerType())

                # task_head_type is 'Task *'.
                task_pointer_type = task_type.GetPointerType()
                self.assertTrue(task_head_type == task_pointer_type)

                # Get the child mmember 'id' from 'task_head'.
                id = task_head.GetChildMemberWithName('id')
                id_type = id.GetType()

                # SBType.GetBasicType() takes an enum 'BasicType' (lldb-enumerations.h).
                int_type = id_type.GetBasicType(lldb.eBasicTypeInt)
                # id_type and int_type should be the same type!
                self.assertTrue(id_type == int_type)


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBType self) -> SBType
        __init__(SBType self, SBType rhs) -> SBType
        """
        _lldb.SBType_swiginit(self, _lldb.new_SBType(*args))
    __swig_destroy__ = _lldb.delete_SBType

    def __nonzero__(self):
        return _lldb.SBType___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBType self) -> bool"""
        return _lldb.SBType_IsValid(self)

    def GetByteSize(self) -> int:
        r"""
        GetByteSize(SBType self) -> uint64_t
        Returns the number of bytes a variable with the given types occupies in memory.

            Returns ``0`` if the size can't be determined.

            If a type occupies ``N`` bytes + ``M`` bits in memory, this function returns
            the rounded up amount of bytes (i.e., if ``M`` is ``0``,
            this function returns ``N`` and otherwise ``N + 1``).

            Language-specific behaviour:

            * C: The output is expected to match the value of ``sizeof(Type)``. If
              ``sizeof(Type)`` is not a valid expression for the given type, the
              function returns ``0``.
            * C++: Same as in C.
            * Objective-C: Same as in C. For Objective-C classes this always returns
              ``0`` as the actual size depends on runtime information.

        """
        return _lldb.SBType_GetByteSize(self)

    def IsPointerType(self) -> "bool":
        r"""
        IsPointerType(SBType self) -> bool
        Returns true if this type is a pointer type.

            Language-specific behaviour:

            * C: Returns true for C pointer types (or typedefs of these types).
            * C++: Pointer types include the C pointer types as well as pointers to data
              mebers or member functions.
            * Objective-C: Pointer types include the C pointer types. ``id``, ``Class``
              and pointers to blocks are also considered pointer types.

        """
        return _lldb.SBType_IsPointerType(self)

    def IsReferenceType(self) -> "bool":
        r"""
        IsReferenceType(SBType self) -> bool
        Returns true if this type is a reference type.

            Language-specific behaviour:

            * C: Returns false for all types.
            * C++: Both l-value and r-value references are considered reference types.
            * Objective-C: Returns false for all types.

        """
        return _lldb.SBType_IsReferenceType(self)

    def IsFunctionType(self) -> "bool":
        r"""IsFunctionType(SBType self) -> bool"""
        return _lldb.SBType_IsFunctionType(self)

    def IsPolymorphicClass(self) -> "bool":
        r"""
        IsPolymorphicClass(SBType self) -> bool
        Returns true if this type is a polymorphic type.

            Language-specific behaviour:

            * C: Returns false for all types.
            * C++: Returns true if the type is a class type that contains at least one
              virtual member function or if at least one of its base classes is
              considered a polymorphic type.
            * Objective-C: Returns false for all types.

        """
        return _lldb.SBType_IsPolymorphicClass(self)

    def IsArrayType(self) -> "bool":
        r"""
        IsArrayType(SBType self) -> bool
        Returns true if this type is an array type.

            Language-specific behaviour:

            * C: Returns true if the types is an array type. This includes incomplete
              array types ``T[]`` and array types with integer (``T[1]``) or variable
              length (``T[some_variable]``). Pointer types are not considered arrays.
            * C++: Includes C's array types and dependent array types (i.e., array types
              in templates which size depends on template arguments).
            * Objective-C: Same as in C.

        """
        return _lldb.SBType_IsArrayType(self)

    def IsVectorType(self) -> "bool":
        r"""
        IsVectorType(SBType self) -> bool
        Returns true if this type is a vector type.

            Language-specific behaviour:

            * C: Returns true if the types is a vector type created with
              GCC's ``vector_size`` or Clang's ``ext_vector_type`` feature.
            * C++: Same as in C.
            * Objective-C: Same as in C.

        """
        return _lldb.SBType_IsVectorType(self)

    def IsTypedefType(self) -> "bool":
        r"""
        IsTypedefType(SBType self) -> bool
        Returns true if this type is a typedef.

            Language-specific behaviour:

            * C: Returns true if the type is a C typedef.
            * C++: Same as in C. Also treats type aliases as typedefs.
            * Objective-C: Same as in C.

        """
        return _lldb.SBType_IsTypedefType(self)

    def IsAnonymousType(self) -> "bool":
        r"""
        IsAnonymousType(SBType self) -> bool
        Returns true if this type is an anonymous type.

            Language-specific behaviour:

            * C: Returns true for anonymous unions. Also returns true for
              anonymous structs (which are a GNU language extension).
            * C++: Same as in C.
            * Objective-C: Same as in C.

        """
        return _lldb.SBType_IsAnonymousType(self)

    def IsScopedEnumerationType(self) -> "bool":
        r"""
        IsScopedEnumerationType(SBType self) -> bool
        Returns true if this type is a scoped enum.

            Language-specific behaviour:

            * C: Returns false for all types.
            * C++: Return true only for C++11 scoped enums.
            * Objective-C: Returns false for all types.

        """
        return _lldb.SBType_IsScopedEnumerationType(self)

    def IsAggregateType(self) -> "bool":
        r"""
        IsAggregateType(SBType self) -> bool
        Returns true if this type is an aggregate type.

            Language-specific behaviour:

            * C: Returns true for struct values, arrays, and vectors.
            * C++: Same a C. Also includes class instances.
            * Objective-C: Same as C. Also includes class instances.

        """
        return _lldb.SBType_IsAggregateType(self)

    def GetPointerType(self) -> "SBType":
        r"""
        GetPointerType(SBType self) -> SBType
        Returns a type that represents a pointer to this type.

            If the type system of the current language can't represent a pointer to this
            type or this type is invalid, an invalid `SBType` is returned.

            Language-specific behaviour:

            * C: Returns the pointer type of this type.
            * C++: Same as in C.
            * Objective-C: Same as in C.

        """
        return _lldb.SBType_GetPointerType(self)

    def GetPointeeType(self) -> "SBType":
        r"""
        GetPointeeType(SBType self) -> SBType
        Returns the underlying pointee type.

            If this type is a pointer type as specified by `IsPointerType` then this
            returns the underlying type. If this is not a pointer type or an invalid
            `SBType` then this returns an invalid `SBType`.

            Language-specific behaviour:

            * C: Returns the underlying type for for C pointer types or typedefs of
              these types). For example, ``int *`` will return ``int``.
            * C++: Same as in C. Returns an `SBType` representation for data members/
              member functions in case the `SBType` is a pointer to data member or
              pointer to member function.
            * Objective-C: Same as in C. The pointee type of ``id`` and ``Class`` is
              an invalid `SBType`. The pointee type of pointers Objective-C types is an
              `SBType` for the non-pointer type of the respective type. For example,
              ``NSString *`` will return ``NSString`` as a pointee type.

        """
        return _lldb.SBType_GetPointeeType(self)

    def GetReferenceType(self) -> "SBType":
        r"""
        GetReferenceType(SBType self) -> SBType
        Returns a type that represents a reference to this type.

            If the type system of the current language can't represent a reference to
            this type, an invalid `SBType` is returned.

            Language-specific behaviour:

            * C: Currently assumes the type system is C++ and returns an l-value
              reference type. For example, ``int`` will return ``int&``. This behavior
              is likely to change in the future and shouldn't be relied on.
            * C++: Same as in C.
            * Objective-C: Same as in C.

        """
        return _lldb.SBType_GetReferenceType(self)

    def GetTypedefedType(self) -> "SBType":
        r"""
        GetTypedefedType(SBType self) -> SBType
        Returns the underlying type of a typedef.

            If this type is a typedef as designated by `IsTypedefType`, then the
            underlying type is being returned. Otherwise an invalid `SBType` is
            returned.

            Language-specific behaviour:

            * C: Returns the underlying type of a typedef type.
            * C++: Same as in C. For type aliases, the underlying type is returned.
            * Objective-C: Same as in C.

        """
        return _lldb.SBType_GetTypedefedType(self)

    def GetDereferencedType(self) -> "SBType":
        r"""
        GetDereferencedType(SBType self) -> SBType
        Returns the underlying type of a reference type.

            If this type is a reference as designated by `IsReferenceType`, then the
            underlying type is being returned. Otherwise an invalid `SBType` is
            returned.

            Language-specific behaviour:

            * C: Always returns an invalid type.
            * C++: For l-value and r-value references the underlying type is returned.
              For example, ``int &`` will return ``int``.
            * Objective-C: Same as in C.

        """
        return _lldb.SBType_GetDereferencedType(self)

    def GetUnqualifiedType(self) -> "SBType":
        r"""
        GetUnqualifiedType(SBType self) -> SBType
        Returns the unqualified version of this type.

            Language-specific behaviour:

            * C: If this type with any const or volatile specifier removed.
            * C++: Same as in C.
            * Objective-C: Same as in C.

        """
        return _lldb.SBType_GetUnqualifiedType(self)

    def GetArrayElementType(self) -> "SBType":
        r"""
        GetArrayElementType(SBType self) -> SBType
        Returns the array element type if this type is an array type.

            Otherwise returns an invalid `SBType` if this type is invalid or not an
            array type.

            Language-specific behaviour:

            * C: If this is an array type (see `IsArrayType`) such as ``T[]``, returns
              the element type.
            * C++: Same as in C.
            * Objective-C: Same as in C.

            See also `IsArrayType`.

        """
        return _lldb.SBType_GetArrayElementType(self)

    def GetArrayType(self, size: int) -> "SBType":
        r"""
        GetArrayType(SBType self, uint64_t size) -> SBType
        Returns the array type with the given constant size.

            Language-specific behaviour:

            * C: Returns a constant-size array ``T[size]`` for any non-void type.
            * C++: Same as in C.
            * Objective-C: Same as in C.

            See also `IsArrayType` and `GetArrayElementType`.

        """
        return _lldb.SBType_GetArrayType(self, size)

    def GetVectorElementType(self) -> "SBType":
        r"""
        GetVectorElementType(SBType self) -> SBType
        Returns the vector element type if this type is a vector type.

            Otherwise returns an invalid `SBType` if this type is invalid or not a
            vector type.

            Language-specific behaviour:

            * C: If this is a vector type (see `IsVectorType`), returns the element
              type.
            * C++: Same as in C.
            * Objective-C: Same as in C.

            See also `IsVectorType`.

        """
        return _lldb.SBType_GetVectorElementType(self)

    def GetCanonicalType(self) -> "SBType":
        r"""GetCanonicalType(SBType self) -> SBType"""
        return _lldb.SBType_GetCanonicalType(self)

    def GetEnumerationIntegerType(self) -> "SBType":
        r"""
        GetEnumerationIntegerType(SBType self) -> SBType
        Returns the underlying integer type if this is an enumeration type.

            If this type is an invalid `SBType` or not an enumeration type an invalid
            `SBType` is returned.

            Language-specific behaviour:

            * C: Returns the underlying type for enums.
            * C++: Same as in C but also returns the underlying type for scoped enums.
            * Objective-C: Same as in C.

        """
        return _lldb.SBType_GetEnumerationIntegerType(self)

    def GetBasicType(self, *args) -> "SBType":
        r"""
        GetBasicType(SBType self) -> lldb::BasicType
        GetBasicType(SBType self, lldb::BasicType type) -> SBType
        Returns the `BasicType` value that is most appropriate to this type.

            Returns `eBasicTypeInvalid` if no appropriate `BasicType` was found or this
            type is invalid. See the `BasicType` documentation for the language-specific
            meaning of each `BasicType` value.

            **Overload behaviour:** When called with a `BasicType` parameter, the
            following behaviour applies:

            Returns the `SBType` that represents the passed `BasicType` value. Returns
            an invalid `SBType` if no fitting `SBType` could be created.

            Language-specific behaviour:

            * C: Returns the respective builtin type. Note that some types
              (e.g. ``__uint128_t``) might even be successfully created even if they are
              not available on the target platform. C++ and Objective-C specific types
              might also be created even if the target program is not written in C++ or
              Objective-C.
            * C++: Same as in C.
            * Objective-C: Same as in C.

        """
        return _lldb.SBType_GetBasicType(self, *args)

    def GetNumberOfFields(self) -> int:
        r"""
        GetNumberOfFields(SBType self) -> uint32_t
        Returns the number of fields of this type.

            Returns ``0`` if this type does not have fields.

            Language-specific behaviour:

            * C: Returns the number of fields if the type is a struct. If the type
              contains an anonymous struct/union it only counts as a single field (even
              if the struct/union contains several fields).
            * C++: Returns the number of non-static fields if the type is a
              struct/class. If the type contains an anonymous struct/union it only
              counts as a single field (even if the struct/union contains several
              fields). The fields of any base classes are not included in the count.
            * Objective-C: Same as in C for structs. For Objective-C classes the number
              of ivars is returned.

            See also `GetFieldAtIndex`.

        """
        return _lldb.SBType_GetNumberOfFields(self)

    def GetNumberOfDirectBaseClasses(self) -> int:
        r"""
        GetNumberOfDirectBaseClasses(SBType self) -> uint32_t
        Returns the number of base/parent classes of this type.

            Returns ``0`` if this type doesn't have any base classes.

            Language-specific behaviour:

            * C: Returns always ``0``.
            * C++: The number of direct non-virtual base classes if this type is
              a class.
            * Objective-C: The number of super classes for Objective-C classes.
              As Objective-C doesn't have multiple inheritance this is usually returns 1
              except for NSObject.

        """
        return _lldb.SBType_GetNumberOfDirectBaseClasses(self)

    def GetNumberOfVirtualBaseClasses(self) -> int:
        r"""
        GetNumberOfVirtualBaseClasses(SBType self) -> uint32_t
        Returns the number of virtual base/parent classes of this type

            Returns ``0`` if this type doesn't have any base classes.

            Language-specific behaviour:

            * C: Returns always ``0``.
            * C++: The number of direct virtual base classes if this type is a
              class.
            * Objective-C: Returns always ``0``.

        """
        return _lldb.SBType_GetNumberOfVirtualBaseClasses(self)

    def GetFieldAtIndex(self, idx: int) -> "SBTypeMember":
        r"""
        GetFieldAtIndex(SBType self, uint32_t idx) -> SBTypeMember
        Returns the field at the given index.

            Returns an invalid `SBType` if the index is out of range or the current
            type doesn't have any fields.

            Language-specific behaviour:

            * C: Returns the field with the given index for struct types. Fields are
              ordered/indexed starting from ``0`` for the first field in a struct (as
              declared in the definition).
            * C++: Returns the non-static field with the given index for struct types.
              Fields are ordered/indexed starting from ``0`` for the first field in a
              struct (as declared in the definition).
            * Objective-C: Same as in C for structs. For Objective-C classes the ivar
              with the given index is returned. ivars are indexed starting from ``0``.

        """
        return _lldb.SBType_GetFieldAtIndex(self, idx)

    def GetDirectBaseClassAtIndex(self, idx: int) -> "SBTypeMember":
        r"""
        GetDirectBaseClassAtIndex(SBType self, uint32_t idx) -> SBTypeMember
        Returns the direct base class as indexed by `GetNumberOfDirectBaseClasses`.

            Returns an invalid SBTypeMember if the index is invalid or this SBType is
            invalid.

        """
        return _lldb.SBType_GetDirectBaseClassAtIndex(self, idx)

    def GetVirtualBaseClassAtIndex(self, idx: int) -> "SBTypeMember":
        r"""
        GetVirtualBaseClassAtIndex(SBType self, uint32_t idx) -> SBTypeMember
        Returns the virtual base class as indexed by
            `GetNumberOfVirtualBaseClasses`.

            Returns an invalid SBTypeMember if the index is invalid or this SBType is
            invalid.

        """
        return _lldb.SBType_GetVirtualBaseClassAtIndex(self, idx)

    def GetEnumMembers(self) -> "SBTypeEnumMemberList":
        r"""GetEnumMembers(SBType self) -> SBTypeEnumMemberList"""
        return _lldb.SBType_GetEnumMembers(self)

    def GetNumberOfTemplateArguments(self) -> int:
        r"""
        GetNumberOfTemplateArguments(SBType self) -> uint32_t
        Returns the number of template arguments of this type.

            Returns ``0`` if this type is not a template.

            Language-specific behaviour:

            * C: Always returns ``0``.
            * C++: If this type is a class template instantiation then this returns the
              number of template parameters that were used in this instantiation. This
              includes both explicit and implicit template parameters.
            * Objective-C: Always returns ``0``.

        """
        return _lldb.SBType_GetNumberOfTemplateArguments(self)

    def GetTemplateArgumentType(self, idx: int) -> "SBType":
        r"""
        GetTemplateArgumentType(SBType self, uint32_t idx) -> SBType
        Returns the type of the template argument with the given index.

            Returns an invalid `SBType` if there is no template argument with the given
            index or this type is not a template. The first template  argument has the
            index ``0``.

            Language-specific behaviour:

            * C: Always returns an invalid SBType.
            * C++: If this type is a class template instantiation and the template
              parameter with the given index is a type template parameter, then this
              returns the type of that parameter. Otherwise returns an invalid `SBType`.
            * Objective-C: Always returns an invalid SBType.

        """
        return _lldb.SBType_GetTemplateArgumentType(self, idx)

    def GetTemplateArgumentKind(self, idx: int) -> "lldb::TemplateArgumentKind":
        r"""
        GetTemplateArgumentKind(SBType self, uint32_t idx) -> lldb::TemplateArgumentKind
        Returns the kind of the template argument with the given index.

            Returns `eTemplateArgumentKindNull` if there is no template argument
            with the given index or this type is not a template. The first template
            argument has the index ``0``.

            Language-specific behaviour:

            * C: Always returns `eTemplateArgumentKindNull`.
            * C++: If this type is a class template instantiation then this returns
              the appropriate `TemplateArgument` value for the parameter with the given
              index. See the documentation of `TemplateArgument` for how certain C++
              template parameter kinds are mapped to `TemplateArgument` values.
            * Objective-C: Always returns `eTemplateArgumentKindNull`.

        """
        return _lldb.SBType_GetTemplateArgumentKind(self, idx)

    def GetFunctionReturnType(self) -> "SBType":
        r"""
        GetFunctionReturnType(SBType self) -> SBType
        Returns the return type if this type represents a function.

            Returns an invalid `SBType` if this type is not a function type or invalid.

            Language-specific behaviour:

            * C: For functions return the return type. Returns an invalid `SBType` if
              this type is a function pointer type.
            * C++: Same as in C for functions and instantiated template functions.
              Member functions are also considered functions. For functions that have
              their return type specified by a placeholder type specifier (``auto``)
              this returns the deduced return type.
            * Objective-C: Same as in C for functions. For Objective-C methods this
              returns the return type of the method.

        """
        return _lldb.SBType_GetFunctionReturnType(self)

    def GetFunctionArgumentTypes(self) -> "SBTypeList":
        r"""
        GetFunctionArgumentTypes(SBType self) -> SBTypeList
        Returns the list of argument types if this type represents a function.

            Returns an invalid `SBType` if this type is not a function type or invalid.

            Language-specific behaviour:

            * C: For functions return the types of each parameter. Returns an invalid
              `SBType` if this type is a function pointer. For variadic functions this
              just returns the list of parameters before the variadic arguments.
            * C++: Same as in C for functions and instantiated template functions.
              Member functions are also considered functions.
            * Objective-C: Always returns an invalid SBType for Objective-C methods.

        """
        return _lldb.SBType_GetFunctionArgumentTypes(self)

    def GetNumberOfMemberFunctions(self) -> int:
        r"""
        GetNumberOfMemberFunctions(SBType self) -> uint32_t
        Returns the number of member functions of this type.

            Returns ``0`` if an error occurred or this type is invalid.

            Language-specific behaviour:

            * C: Always returns ``0``.
            * C++: If this type represents a struct/class, then the number of
              member functions (static and non-static) is returned. The count includes
              constructors and destructors (both explicit and implicit). Member
              functions of base classes are not included in the count.
            * Objective-C: If this type represents a struct/class, then the
              number of methods is returned. Methods in categories or super classes
              are not counted.

        """
        return _lldb.SBType_GetNumberOfMemberFunctions(self)

    def GetMemberFunctionAtIndex(self, idx: int) -> "SBTypeMemberFunction":
        r"""
        GetMemberFunctionAtIndex(SBType self, uint32_t idx) -> SBTypeMemberFunction
        Returns the member function of this type with the given index.

            Returns an invalid `SBTypeMemberFunction` if the index is invalid or this
            type is invalid.

            Language-specific behaviour:

            * C: Always returns an invalid `SBTypeMemberFunction`.
            * C++: Returns the member function or constructor/destructor with the given
              index.
            * Objective-C: Returns the method with the given index.

            See `GetNumberOfMemberFunctions` for what functions can be queried by this
            function.

        """
        return _lldb.SBType_GetMemberFunctionAtIndex(self, idx)

    def GetModule(self) -> "SBModule":
        r"""
        GetModule(SBType self) -> SBModule
        Returns the `SBModule` this `SBType` belongs to.

            Returns no `SBModule` if this type does not belong to any specific
            `SBModule` or this `SBType` is invalid. An invalid `SBModule` might also
            indicate that once came from an `SBModule` but LLDB could no longer
            determine the original module.

        """
        return _lldb.SBType_GetModule(self)

    def GetName(self) -> str:
        r"""
        GetName() -> string
        Returns the name of this type.

            Returns an empty string if an error occurred or this type is invalid.

            Use this function when trying to match a specific type by name in a script.
            The names returned by this function try to uniquely identify a name but
            conflicts can occur (for example, if a C++ program contains two different
            classes with the same name in different translation units. `GetName` can
            return the same name for both class types.)


            Language-specific behaviour:

            * C: The name of the type. For structs the ``struct`` prefix is omitted.
            * C++: Returns the qualified name of the type (including anonymous/inline
              namespaces and all template arguments).
            * Objective-C: Same as in C.

        """
        return _lldb.SBType_GetName(self)

    def GetDisplayTypeName(self) -> str:
        r"""
        GetDisplayTypeName() -> string
        Returns the name of this type in a user-friendly format.

            Returns an empty string if an error occurred or this type is invalid.

            Use this function when displaying a type name to the user.

            Language-specific behaviour:

            * C: Returns the type name. For structs the ``struct`` prefix is omitted.
            * C++: Returns the qualified name. Anonymous/inline namespaces are omitted.
              Template arguments that match their default value might also be hidden
              (this functionality depends on whether LLDB can determine the template's
              default arguments).
            * Objective-C: Same as in C.

        """
        return _lldb.SBType_GetDisplayTypeName(self)

    def GetTypeClass(self) -> "lldb::TypeClass":
        r"""
        GetTypeClass() -> TypeClass
        Returns the `TypeClass` for this type.

            Returns an `eTypeClassInvalid` if this `SBType` is invalid.

            See `TypeClass` for the language-specific meaning of each `TypeClass` value.

        """
        return _lldb.SBType_GetTypeClass(self)

    def IsTypeComplete(self) -> "bool":
        r"""
        IsTypeComplete(SBType self) -> bool
        Returns true if the type is completely defined.

            Language-specific behaviour:

            * C: Returns false for struct types that were only forward declared in the
              type's `SBTarget`/`SBModule`. Otherwise returns true.
            * C++: Returns false for template/non-template struct/class types and
              scoped enums that were only forward declared inside the type's
              `SBTarget`/`SBModule`. Otherwise returns true.
            * Objective-C: Follows the same behavior as C for struct types. Objective-C
              classes are considered complete unless they were only forward declared via
              ``@class ClassName`` in the type's `SBTarget`/`SBModule`. Otherwise
              returns true.

        """
        return _lldb.SBType_IsTypeComplete(self)

    def GetTypeFlags(self) -> int:
        r"""
        GetTypeFlags(SBType self) -> uint32_t
        Returns the `TypeFlags` values for this type.

            See the respective `TypeFlags` values for what values can be set. Returns an
            integer in which each `TypeFlags` value is represented by a bit. Specific
            flags can be checked via Python's bitwise operators. For example, the
            `eTypeIsInteger` flag can be checked like this:

            ``(an_sb_type.GetTypeFlags() & lldb.eTypeIsInteger) != 0``

            If this type is invalid this returns ``0``.

            See the different values for `TypeFlags` for the language-specific meanings
            of each `TypeFlags` value.

        """
        return _lldb.SBType_GetTypeFlags(self)

    def GetDescription(self, description: "SBStream", description_level: "lldb::DescriptionLevel") -> "bool":
        r"""GetDescription(SBType self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        return _lldb.SBType_GetDescription(self, description, description_level)

    def __eq__(self, rhs: "SBType") -> "bool":
        r"""__eq__(SBType self, SBType rhs) -> bool"""
        return _lldb.SBType___eq__(self, rhs)

    def __ne__(self, rhs: "SBType") -> "bool":
        r"""__ne__(SBType self, SBType rhs) -> bool"""
        return _lldb.SBType___ne__(self, rhs)

    def __repr__(self) -> str:
        r"""__repr__(SBType self) -> std::string"""
        return _lldb.SBType___repr__(self)

    def template_arg_array(self):
        num_args = self.num_template_args
        if num_args:
            template_args = []
            for i in range(num_args):
                template_args.append(self.GetTemplateArgumentType(i))
            return template_args
        return None

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        return self.GetByteSize()

    def __iter__(self):
        pass

    module = property(GetModule, None, doc='''A read only property that returns the module in which type is defined.''')
    name = property(GetName, None, doc='''A read only property that returns the name for this type as a string.''')
    size = property(GetByteSize, None, doc='''A read only property that returns size in bytes for this type as an integer.''')
    is_pointer = property(IsPointerType, None, doc='''A read only property that returns a boolean value that indicates if this type is a pointer type.''')
    is_reference = property(IsReferenceType, None, doc='''A read only property that returns a boolean value that indicates if this type is a reference type.''')
    is_reference = property(IsReferenceType, None, doc='''A read only property that returns a boolean value that indicates if this type is a function type.''')
    num_fields = property(GetNumberOfFields, None, doc='''A read only property that returns number of fields in this type as an integer.''')
    num_bases = property(GetNumberOfDirectBaseClasses, None, doc='''A read only property that returns number of direct base classes in this type as an integer.''')
    num_vbases = property(GetNumberOfVirtualBaseClasses, None, doc='''A read only property that returns number of virtual base classes in this type as an integer.''')
    num_template_args = property(GetNumberOfTemplateArguments, None, doc='''A read only property that returns number of template arguments in this type as an integer.''')
    template_args = property(template_arg_array, None, doc='''A read only property that returns a list() of lldb.SBType objects that represent all template arguments in this type.''')
    type = property(GetTypeClass, None, doc='''A read only property that returns an lldb enumeration value (see enumerations that start with "lldb.eTypeClass") that represents a classification for this type.''')
    is_complete = property(IsTypeComplete, None, doc='''A read only property that returns a boolean value that indicates if this type is a complete type (True) or a forward declaration (False).''')

    def get_bases_array(self):
        '''An accessor function that returns a list() that contains all direct base classes in a lldb.SBType object.'''
        bases = []
        for idx in range(self.GetNumberOfDirectBaseClasses()):
            bases.append(self.GetDirectBaseClassAtIndex(idx))
        return bases

    def get_vbases_array(self):
        '''An accessor function that returns a list() that contains all fields in a lldb.SBType object.'''
        vbases = []
        for idx in range(self.GetNumberOfVirtualBaseClasses()):
            vbases.append(self.GetVirtualBaseClassAtIndex(idx))
        return vbases

    def get_fields_array(self):
        '''An accessor function that returns a list() that contains all fields in a lldb.SBType object.'''
        fields = []
        for idx in range(self.GetNumberOfFields()):
            fields.append(self.GetFieldAtIndex(idx))
        return fields

    def get_members_array(self):
        '''An accessor function that returns a list() that contains all members (base classes and fields) in a lldb.SBType object in ascending bit offset order.'''
        members = []
        bases = self.get_bases_array()
        fields = self.get_fields_array()
        vbases = self.get_vbases_array()
        for base in bases:
            bit_offset = base.bit_offset
            added = False
            for idx, member in enumerate(members):
                if member.bit_offset > bit_offset:
                    members.insert(idx, base)
                    added = True
                    break
            if not added:
                members.append(base)
        for vbase in vbases:
            bit_offset = vbase.bit_offset
            added = False
            for idx, member in enumerate(members):
                if member.bit_offset > bit_offset:
                    members.insert(idx, vbase)
                    added = True
                    break
            if not added:
                members.append(vbase)
        for field in fields:
            bit_offset = field.bit_offset
            added = False
            for idx, member in enumerate(members):
                if member.bit_offset > bit_offset:
                    members.insert(idx, field)
                    added = True
                    break
            if not added:
                members.append(field)
        return members

    def get_enum_members_array(self):
        '''An accessor function that returns a list() that contains all enum members in an lldb.SBType object.'''
        enum_members_list = []
        sb_enum_members = self.GetEnumMembers()
        for idx in range(sb_enum_members.GetSize()):
            enum_members_list.append(sb_enum_members.GetTypeEnumMemberAtIndex(idx))
        return enum_members_list

    bases = property(get_bases_array, None, doc='''A read only property that returns a list() of lldb.SBTypeMember objects that represent all of the direct base classes for this type.''')
    vbases = property(get_vbases_array, None, doc='''A read only property that returns a list() of lldb.SBTypeMember objects that represent all of the virtual base classes for this type.''')
    fields = property(get_fields_array, None, doc='''A read only property that returns a list() of lldb.SBTypeMember objects that represent all of the fields for this type.''')
    members = property(get_members_array, None, doc='''A read only property that returns a list() of all lldb.SBTypeMember objects that represent all of the base classes, virtual base classes and fields for this type in ascending bit offset order.''')
    enum_members = property(get_enum_members_array, None, doc='''A read only property that returns a list() of all lldb.SBTypeEnumMember objects that represent the enum members for this type.''')


# Register SBType in _lldb:
_lldb.SBType_swigregister(SBType)

class SBTypeList(object):
    r"""
    Represents a list of :py:class:`SBType` s.

    The FindTypes() method of :py:class:`SBTarget`/:py:class:`SBModule` returns a SBTypeList.

    SBTypeList supports :py:class:`SBType` iteration. For example,

    .. code-block:: cpp

        // main.cpp:

        class Task {
        public:
            int id;
            Task *next;
            Task(int i, Task *n):
                id(i),
                next(n)
            {}
        };

    .. code-block:: python

        # find_type.py:

        # Get the type 'Task'.
        type_list = target.FindTypes('Task')
        self.assertTrue(len(type_list) == 1)
        # To illustrate the SBType iteration.
        for type in type_list:
            # do something with type


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBTypeList self) -> SBTypeList
        __init__(SBTypeList self, SBTypeList rhs) -> SBTypeList
        """
        _lldb.SBTypeList_swiginit(self, _lldb.new_SBTypeList(*args))
    __swig_destroy__ = _lldb.delete_SBTypeList

    def __nonzero__(self):
        return _lldb.SBTypeList___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBTypeList self) -> bool"""
        return _lldb.SBTypeList_IsValid(self)

    def Append(self, type: "SBType"):
        r"""Append(SBTypeList self, SBType type)"""
        return _lldb.SBTypeList_Append(self, type)

    def GetTypeAtIndex(self, index: int) -> "SBType":
        r"""GetTypeAtIndex(SBTypeList self, uint32_t index) -> SBType"""
        return _lldb.SBTypeList_GetTypeAtIndex(self, index)

    def GetSize(self) -> int:
        r"""GetSize(SBTypeList self) -> uint32_t"""
        return _lldb.SBTypeList_GetSize(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __iter__(self):
        '''Iterate over all types in a lldb.SBTypeList object.'''
        return lldb_iter(self, 'GetSize', 'GetTypeAtIndex')

    def __len__(self):
        '''Return the number of types in a lldb.SBTypeList object.'''
        return self.GetSize()


# Register SBTypeList in _lldb:
_lldb.SBTypeList_swigregister(SBTypeList)

class SBTypeCategory(object):
    r"""Represents a category that can contain formatters for types."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBTypeCategory self) -> SBTypeCategory
        __init__(SBTypeCategory self, SBTypeCategory rhs) -> SBTypeCategory
        """
        _lldb.SBTypeCategory_swiginit(self, _lldb.new_SBTypeCategory(*args))
    __swig_destroy__ = _lldb.delete_SBTypeCategory

    def __nonzero__(self):
        return _lldb.SBTypeCategory___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBTypeCategory self) -> bool"""
        return _lldb.SBTypeCategory_IsValid(self)

    def GetEnabled(self) -> "bool":
        r"""GetEnabled(SBTypeCategory self) -> bool"""
        return _lldb.SBTypeCategory_GetEnabled(self)

    def SetEnabled(self, arg2: "bool"):
        r"""SetEnabled(SBTypeCategory self, bool arg2)"""
        return _lldb.SBTypeCategory_SetEnabled(self, arg2)

    def GetName(self) -> str:
        r"""GetName(SBTypeCategory self) -> char const *"""
        return _lldb.SBTypeCategory_GetName(self)

    def GetLanguageAtIndex(self, idx: int) -> "lldb::LanguageType":
        r"""GetLanguageAtIndex(SBTypeCategory self, uint32_t idx) -> lldb::LanguageType"""
        return _lldb.SBTypeCategory_GetLanguageAtIndex(self, idx)

    def GetNumLanguages(self) -> int:
        r"""GetNumLanguages(SBTypeCategory self) -> uint32_t"""
        return _lldb.SBTypeCategory_GetNumLanguages(self)

    def AddLanguage(self, language: "lldb::LanguageType"):
        r"""AddLanguage(SBTypeCategory self, lldb::LanguageType language)"""
        return _lldb.SBTypeCategory_AddLanguage(self, language)

    def GetDescription(self, description: "SBStream", description_level: "lldb::DescriptionLevel") -> "bool":
        r"""GetDescription(SBTypeCategory self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        return _lldb.SBTypeCategory_GetDescription(self, description, description_level)

    def GetNumFormats(self) -> int:
        r"""GetNumFormats(SBTypeCategory self) -> uint32_t"""
        return _lldb.SBTypeCategory_GetNumFormats(self)

    def GetNumSummaries(self) -> int:
        r"""GetNumSummaries(SBTypeCategory self) -> uint32_t"""
        return _lldb.SBTypeCategory_GetNumSummaries(self)

    def GetNumFilters(self) -> int:
        r"""GetNumFilters(SBTypeCategory self) -> uint32_t"""
        return _lldb.SBTypeCategory_GetNumFilters(self)

    def GetNumSynthetics(self) -> int:
        r"""GetNumSynthetics(SBTypeCategory self) -> uint32_t"""
        return _lldb.SBTypeCategory_GetNumSynthetics(self)

    def GetTypeNameSpecifierForFilterAtIndex(self, arg2: int) -> "SBTypeNameSpecifier":
        r"""GetTypeNameSpecifierForFilterAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeNameSpecifier"""
        return _lldb.SBTypeCategory_GetTypeNameSpecifierForFilterAtIndex(self, arg2)

    def GetTypeNameSpecifierForFormatAtIndex(self, arg2: int) -> "SBTypeNameSpecifier":
        r"""GetTypeNameSpecifierForFormatAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeNameSpecifier"""
        return _lldb.SBTypeCategory_GetTypeNameSpecifierForFormatAtIndex(self, arg2)

    def GetTypeNameSpecifierForSummaryAtIndex(self, arg2: int) -> "SBTypeNameSpecifier":
        r"""GetTypeNameSpecifierForSummaryAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeNameSpecifier"""
        return _lldb.SBTypeCategory_GetTypeNameSpecifierForSummaryAtIndex(self, arg2)

    def GetTypeNameSpecifierForSyntheticAtIndex(self, arg2: int) -> "SBTypeNameSpecifier":
        r"""GetTypeNameSpecifierForSyntheticAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeNameSpecifier"""
        return _lldb.SBTypeCategory_GetTypeNameSpecifierForSyntheticAtIndex(self, arg2)

    def GetFilterForType(self, arg2: "SBTypeNameSpecifier") -> "SBTypeFilter":
        r"""GetFilterForType(SBTypeCategory self, SBTypeNameSpecifier arg2) -> SBTypeFilter"""
        return _lldb.SBTypeCategory_GetFilterForType(self, arg2)

    def GetFormatForType(self, arg2: "SBTypeNameSpecifier") -> "SBTypeFormat":
        r"""GetFormatForType(SBTypeCategory self, SBTypeNameSpecifier arg2) -> SBTypeFormat"""
        return _lldb.SBTypeCategory_GetFormatForType(self, arg2)

    def GetSummaryForType(self, arg2: "SBTypeNameSpecifier") -> "SBTypeSummary":
        r"""GetSummaryForType(SBTypeCategory self, SBTypeNameSpecifier arg2) -> SBTypeSummary"""
        return _lldb.SBTypeCategory_GetSummaryForType(self, arg2)

    def GetSyntheticForType(self, arg2: "SBTypeNameSpecifier") -> "SBTypeSynthetic":
        r"""GetSyntheticForType(SBTypeCategory self, SBTypeNameSpecifier arg2) -> SBTypeSynthetic"""
        return _lldb.SBTypeCategory_GetSyntheticForType(self, arg2)

    def GetFilterAtIndex(self, arg2: int) -> "SBTypeFilter":
        r"""GetFilterAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeFilter"""
        return _lldb.SBTypeCategory_GetFilterAtIndex(self, arg2)

    def GetFormatAtIndex(self, arg2: int) -> "SBTypeFormat":
        r"""GetFormatAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeFormat"""
        return _lldb.SBTypeCategory_GetFormatAtIndex(self, arg2)

    def GetSummaryAtIndex(self, arg2: int) -> "SBTypeSummary":
        r"""GetSummaryAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeSummary"""
        return _lldb.SBTypeCategory_GetSummaryAtIndex(self, arg2)

    def GetSyntheticAtIndex(self, arg2: int) -> "SBTypeSynthetic":
        r"""GetSyntheticAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeSynthetic"""
        return _lldb.SBTypeCategory_GetSyntheticAtIndex(self, arg2)

    def AddTypeFormat(self, arg2: "SBTypeNameSpecifier", arg3: "SBTypeFormat") -> "bool":
        r"""AddTypeFormat(SBTypeCategory self, SBTypeNameSpecifier arg2, SBTypeFormat arg3) -> bool"""
        return _lldb.SBTypeCategory_AddTypeFormat(self, arg2, arg3)

    def DeleteTypeFormat(self, arg2: "SBTypeNameSpecifier") -> "bool":
        r"""DeleteTypeFormat(SBTypeCategory self, SBTypeNameSpecifier arg2) -> bool"""
        return _lldb.SBTypeCategory_DeleteTypeFormat(self, arg2)

    def AddTypeSummary(self, arg2: "SBTypeNameSpecifier", arg3: "SBTypeSummary") -> "bool":
        r"""AddTypeSummary(SBTypeCategory self, SBTypeNameSpecifier arg2, SBTypeSummary arg3) -> bool"""
        return _lldb.SBTypeCategory_AddTypeSummary(self, arg2, arg3)

    def DeleteTypeSummary(self, arg2: "SBTypeNameSpecifier") -> "bool":
        r"""DeleteTypeSummary(SBTypeCategory self, SBTypeNameSpecifier arg2) -> bool"""
        return _lldb.SBTypeCategory_DeleteTypeSummary(self, arg2)

    def AddTypeFilter(self, arg2: "SBTypeNameSpecifier", arg3: "SBTypeFilter") -> "bool":
        r"""AddTypeFilter(SBTypeCategory self, SBTypeNameSpecifier arg2, SBTypeFilter arg3) -> bool"""
        return _lldb.SBTypeCategory_AddTypeFilter(self, arg2, arg3)

    def DeleteTypeFilter(self, arg2: "SBTypeNameSpecifier") -> "bool":
        r"""DeleteTypeFilter(SBTypeCategory self, SBTypeNameSpecifier arg2) -> bool"""
        return _lldb.SBTypeCategory_DeleteTypeFilter(self, arg2)

    def AddTypeSynthetic(self, arg2: "SBTypeNameSpecifier", arg3: "SBTypeSynthetic") -> "bool":
        r"""AddTypeSynthetic(SBTypeCategory self, SBTypeNameSpecifier arg2, SBTypeSynthetic arg3) -> bool"""
        return _lldb.SBTypeCategory_AddTypeSynthetic(self, arg2, arg3)

    def DeleteTypeSynthetic(self, arg2: "SBTypeNameSpecifier") -> "bool":
        r"""DeleteTypeSynthetic(SBTypeCategory self, SBTypeNameSpecifier arg2) -> bool"""
        return _lldb.SBTypeCategory_DeleteTypeSynthetic(self, arg2)

    def __eq__(self, rhs: "SBTypeCategory") -> "bool":
        r"""__eq__(SBTypeCategory self, SBTypeCategory rhs) -> bool"""
        return _lldb.SBTypeCategory___eq__(self, rhs)

    def __ne__(self, rhs: "SBTypeCategory") -> "bool":
        r"""__ne__(SBTypeCategory self, SBTypeCategory rhs) -> bool"""
        return _lldb.SBTypeCategory___ne__(self, rhs)

    def __repr__(self) -> str:
        r"""__repr__(SBTypeCategory self) -> std::string"""
        return _lldb.SBTypeCategory___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    class formatters_access_class(object):
        '''A helper object that will lazily hand out formatters for a specific category.'''
        def __init__(self, sbcategory, get_count_function, get_at_index_function, get_by_name_function):
            self.sbcategory = sbcategory
            self.get_count_function = get_count_function
            self.get_at_index_function = get_at_index_function
            self.get_by_name_function = get_by_name_function
            self.regex_type = type(re.compile('.'))


        def __len__(self):
            if self.sbcategory and self.get_count_function:
                return int(self.get_count_function(self.sbcategory))
            return 0

        def __getitem__(self, key):
            num_items = len(self)
            if type(key) is int:
                if -num_items <= key < num_items:
                    key %= num_items
                    return self.get_at_index_function(self.sbcategory,key)
            elif type(key) is str:
                return self.get_by_name_function(self.sbcategory,SBTypeNameSpecifier(key))
            elif isinstance(key,self.regex_type):
                return self.get_by_name_function(self.sbcategory,SBTypeNameSpecifier(key.pattern,True))
            else:
                print("error: unsupported item type: %s" % type(key))
            return None

    def get_formats_access_object(self):
        '''An accessor function that returns an accessor object which allows lazy format access from a lldb.SBTypeCategory object.'''
        return self.formatters_access_class (self,self.__class__.GetNumFormats,self.__class__.GetFormatAtIndex,self.__class__.GetFormatForType)

    def get_formats_array(self):
        '''An accessor function that returns a list() that contains all formats in a lldb.SBCategory object.'''
        formats = []
        for idx in range(self.GetNumFormats()):
            formats.append(self.GetFormatAtIndex(idx))
        return formats

    def get_summaries_access_object(self):
        '''An accessor function that returns an accessor object which allows lazy summary access from a lldb.SBTypeCategory object.'''
        return self.formatters_access_class (self,self.__class__.GetNumSummaries,self.__class__.GetSummaryAtIndex,self.__class__.GetSummaryForType)

    def get_summaries_array(self):
        '''An accessor function that returns a list() that contains all summaries in a lldb.SBCategory object.'''
        summaries = []
        for idx in range(self.GetNumSummaries()):
            summaries.append(self.GetSummaryAtIndex(idx))
        return summaries

    def get_synthetics_access_object(self):
        '''An accessor function that returns an accessor object which allows lazy synthetic children provider access from a lldb.SBTypeCategory object.'''
        return self.formatters_access_class (self,self.__class__.GetNumSynthetics,self.__class__.GetSyntheticAtIndex,self.__class__.GetSyntheticForType)

    def get_synthetics_array(self):
        '''An accessor function that returns a list() that contains all synthetic children providers in a lldb.SBCategory object.'''
        synthetics = []
        for idx in range(self.GetNumSynthetics()):
            synthetics.append(self.GetSyntheticAtIndex(idx))
        return synthetics

    def get_filters_access_object(self):
        '''An accessor function that returns an accessor object which allows lazy filter access from a lldb.SBTypeCategory object.'''
        return self.formatters_access_class (self,self.__class__.GetNumFilters,self.__class__.GetFilterAtIndex,self.__class__.GetFilterForType)

    def get_filters_array(self):
        '''An accessor function that returns a list() that contains all filters in a lldb.SBCategory object.'''
        filters = []
        for idx in range(self.GetNumFilters()):
            filters.append(self.GetFilterAtIndex(idx))
        return filters

    formats = property(get_formats_array, None, doc='''A read only property that returns a list() of lldb.SBTypeFormat objects contained in this category''')
    format = property(get_formats_access_object, None, doc=r'''A read only property that returns an object that you can use to look for formats by index or type name.''')
    summaries = property(get_summaries_array, None, doc='''A read only property that returns a list() of lldb.SBTypeSummary objects contained in this category''')
    summary = property(get_summaries_access_object, None, doc=r'''A read only property that returns an object that you can use to look for summaries by index or type name or regular expression.''')
    filters = property(get_filters_array, None, doc='''A read only property that returns a list() of lldb.SBTypeFilter objects contained in this category''')
    filter = property(get_filters_access_object, None, doc=r'''A read only property that returns an object that you can use to look for filters by index or type name or regular expression.''')
    synthetics = property(get_synthetics_array, None, doc='''A read only property that returns a list() of lldb.SBTypeSynthetic objects contained in this category''')
    synthetic = property(get_synthetics_access_object, None, doc=r'''A read only property that returns an object that you can use to look for synthetic children provider by index or type name or regular expression.''')
    num_formats = property(GetNumFormats, None)
    num_summaries = property(GetNumSummaries, None)
    num_filters = property(GetNumFilters, None)
    num_synthetics = property(GetNumSynthetics, None)
    name = property(GetName, None)
    enabled = property(GetEnabled, SetEnabled)


# Register SBTypeCategory in _lldb:
_lldb.SBTypeCategory_swigregister(SBTypeCategory)

class SBTypeEnumMember(object):
    r"""Represents a member of an enum in lldb."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBTypeEnumMember self) -> SBTypeEnumMember
        __init__(SBTypeEnumMember self, SBTypeEnumMember rhs) -> SBTypeEnumMember
        """
        _lldb.SBTypeEnumMember_swiginit(self, _lldb.new_SBTypeEnumMember(*args))
    __swig_destroy__ = _lldb.delete_SBTypeEnumMember

    def __nonzero__(self):
        return _lldb.SBTypeEnumMember___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBTypeEnumMember self) -> bool"""
        return _lldb.SBTypeEnumMember_IsValid(self)

    def GetValueAsSigned(self) -> "int64_t":
        r"""GetValueAsSigned(SBTypeEnumMember self) -> int64_t"""
        return _lldb.SBTypeEnumMember_GetValueAsSigned(self)

    def GetValueAsUnsigned(self) -> int:
        r"""GetValueAsUnsigned(SBTypeEnumMember self) -> uint64_t"""
        return _lldb.SBTypeEnumMember_GetValueAsUnsigned(self)

    def GetName(self) -> str:
        r"""GetName(SBTypeEnumMember self) -> char const *"""
        return _lldb.SBTypeEnumMember_GetName(self)

    def GetType(self) -> "SBType":
        r"""GetType(SBTypeEnumMember self) -> SBType"""
        return _lldb.SBTypeEnumMember_GetType(self)

    def GetDescription(self, description: "SBStream", description_level: "lldb::DescriptionLevel") -> "bool":
        r"""GetDescription(SBTypeEnumMember self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        return _lldb.SBTypeEnumMember_GetDescription(self, description, description_level)

    def __repr__(self) -> str:
        r"""__repr__(SBTypeEnumMember self) -> std::string"""
        return _lldb.SBTypeEnumMember___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __iter__(self):
        '''Iterate over all members in a lldb.SBTypeEnumMemberList object.'''
        return lldb_iter(self, 'GetSize', 'GetTypeEnumMemberAtIndex')

    def __len__(self):
        '''Return the number of members in a lldb.SBTypeEnumMemberList object.'''
        return self.GetSize()

    name = property(GetName, None, doc='''A read only property that returns the name for this enum member as a string.''')
    type = property(GetType, None, doc='''A read only property that returns an lldb object that represents the type (lldb.SBType) for this enum member.''')
    signed = property(GetValueAsSigned, None, doc='''A read only property that returns the value of this enum member as a signed integer.''')
    unsigned = property(GetValueAsUnsigned, None, doc='''A read only property that returns the value of this enum member as a unsigned integer.''')


# Register SBTypeEnumMember in _lldb:
_lldb.SBTypeEnumMember_swigregister(SBTypeEnumMember)

class SBTypeEnumMemberList(object):
    r"""
    Represents a list of SBTypeEnumMembers.

    SBTypeEnumMemberList supports SBTypeEnumMember iteration.
    It also supports [] access either by index, or by enum
    element name by doing: ::

      myType = target.FindFirstType('MyEnumWithElementA')
      members = myType.GetEnumMembers()
      first_elem = members[0]
      elem_A = members['A']


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBTypeEnumMemberList self) -> SBTypeEnumMemberList
        __init__(SBTypeEnumMemberList self, SBTypeEnumMemberList rhs) -> SBTypeEnumMemberList
        """
        _lldb.SBTypeEnumMemberList_swiginit(self, _lldb.new_SBTypeEnumMemberList(*args))
    __swig_destroy__ = _lldb.delete_SBTypeEnumMemberList

    def __nonzero__(self):
        return _lldb.SBTypeEnumMemberList___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBTypeEnumMemberList self) -> bool"""
        return _lldb.SBTypeEnumMemberList_IsValid(self)

    def Append(self, entry: "SBTypeEnumMember"):
        r"""Append(SBTypeEnumMemberList self, SBTypeEnumMember entry)"""
        return _lldb.SBTypeEnumMemberList_Append(self, entry)

    def GetTypeEnumMemberAtIndex(self, index: int) -> "SBTypeEnumMember":
        r"""GetTypeEnumMemberAtIndex(SBTypeEnumMemberList self, uint32_t index) -> SBTypeEnumMember"""
        return _lldb.SBTypeEnumMemberList_GetTypeEnumMemberAtIndex(self, index)

    def GetSize(self) -> int:
        r"""GetSize(SBTypeEnumMemberList self) -> uint32_t"""
        return _lldb.SBTypeEnumMemberList_GetSize(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __iter__(self):
        '''Iterate over all members in a lldb.SBTypeEnumMemberList object.'''
        return lldb_iter(self, 'GetSize', 'GetTypeEnumMemberAtIndex')

    def __len__(self):
        '''Return the number of members in a lldb.SBTypeEnumMemberList object.'''
        return self.GetSize()

    def __getitem__(self, key):
      num_elements = self.GetSize()
      if type(key) is int:
          if -num_elements <= key < num_elements:
              key %= num_elements
              return self.GetTypeEnumMemberAtIndex(key)
      elif type(key) is str:
          for idx in range(num_elements):
              item = self.GetTypeEnumMemberAtIndex(idx)
              if item.name == key:
                  return item
      return None


# Register SBTypeEnumMemberList in _lldb:
_lldb.SBTypeEnumMemberList_swigregister(SBTypeEnumMemberList)

class SBTypeFilter(object):
    r"""Represents a filter that can be associated to one or more types."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBTypeFilter self) -> SBTypeFilter
        __init__(SBTypeFilter self, uint32_t options) -> SBTypeFilter
        __init__(SBTypeFilter self, SBTypeFilter rhs) -> SBTypeFilter
        """
        _lldb.SBTypeFilter_swiginit(self, _lldb.new_SBTypeFilter(*args))
    __swig_destroy__ = _lldb.delete_SBTypeFilter

    def __nonzero__(self):
        return _lldb.SBTypeFilter___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBTypeFilter self) -> bool"""
        return _lldb.SBTypeFilter_IsValid(self)

    def GetNumberOfExpressionPaths(self) -> int:
        r"""GetNumberOfExpressionPaths(SBTypeFilter self) -> uint32_t"""
        return _lldb.SBTypeFilter_GetNumberOfExpressionPaths(self)

    def GetExpressionPathAtIndex(self, i: int) -> str:
        r"""GetExpressionPathAtIndex(SBTypeFilter self, uint32_t i) -> char const *"""
        return _lldb.SBTypeFilter_GetExpressionPathAtIndex(self, i)

    def ReplaceExpressionPathAtIndex(self, i: int, item: str) -> "bool":
        r"""ReplaceExpressionPathAtIndex(SBTypeFilter self, uint32_t i, char const * item) -> bool"""
        return _lldb.SBTypeFilter_ReplaceExpressionPathAtIndex(self, i, item)

    def AppendExpressionPath(self, item: str):
        r"""AppendExpressionPath(SBTypeFilter self, char const * item)"""
        return _lldb.SBTypeFilter_AppendExpressionPath(self, item)

    def Clear(self):
        r"""Clear(SBTypeFilter self)"""
        return _lldb.SBTypeFilter_Clear(self)

    def GetOptions(self) -> int:
        r"""GetOptions(SBTypeFilter self) -> uint32_t"""
        return _lldb.SBTypeFilter_GetOptions(self)

    def SetOptions(self, arg2: int):
        r"""SetOptions(SBTypeFilter self, uint32_t arg2)"""
        return _lldb.SBTypeFilter_SetOptions(self, arg2)

    def GetDescription(self, description: "SBStream", description_level: "lldb::DescriptionLevel") -> "bool":
        r"""GetDescription(SBTypeFilter self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        return _lldb.SBTypeFilter_GetDescription(self, description, description_level)

    def IsEqualTo(self, rhs: "SBTypeFilter") -> "bool":
        r"""IsEqualTo(SBTypeFilter self, SBTypeFilter rhs) -> bool"""
        return _lldb.SBTypeFilter_IsEqualTo(self, rhs)

    def __eq__(self, rhs: "SBTypeFilter") -> "bool":
        r"""__eq__(SBTypeFilter self, SBTypeFilter rhs) -> bool"""
        return _lldb.SBTypeFilter___eq__(self, rhs)

    def __ne__(self, rhs: "SBTypeFilter") -> "bool":
        r"""__ne__(SBTypeFilter self, SBTypeFilter rhs) -> bool"""
        return _lldb.SBTypeFilter___ne__(self, rhs)

    def __repr__(self) -> str:
        r"""__repr__(SBTypeFilter self) -> std::string"""
        return _lldb.SBTypeFilter___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    options = property(GetOptions, SetOptions)
    count = property(GetNumberOfExpressionPaths)


    def __eq__(self, rhs):
        if not isinstance(rhs, type(self)):
            return False

        return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)

    def __ne__(self, rhs):
        if not isinstance(rhs, type(self)):
            return True

        return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)


# Register SBTypeFilter in _lldb:
_lldb.SBTypeFilter_swigregister(SBTypeFilter)

class SBTypeFormat(object):
    r"""Represents a format that can be associated to one or more types."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBTypeFormat self) -> SBTypeFormat
        __init__(SBTypeFormat self, lldb::Format format, uint32_t options=0) -> SBTypeFormat
        __init__(SBTypeFormat self, char const * type, uint32_t options=0) -> SBTypeFormat
        __init__(SBTypeFormat self, SBTypeFormat rhs) -> SBTypeFormat
        """
        _lldb.SBTypeFormat_swiginit(self, _lldb.new_SBTypeFormat(*args))
    __swig_destroy__ = _lldb.delete_SBTypeFormat

    def __nonzero__(self):
        return _lldb.SBTypeFormat___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBTypeFormat self) -> bool"""
        return _lldb.SBTypeFormat_IsValid(self)

    def GetFormat(self) -> "lldb::Format":
        r"""GetFormat(SBTypeFormat self) -> lldb::Format"""
        return _lldb.SBTypeFormat_GetFormat(self)

    def GetTypeName(self) -> str:
        r"""GetTypeName(SBTypeFormat self) -> char const *"""
        return _lldb.SBTypeFormat_GetTypeName(self)

    def GetOptions(self) -> int:
        r"""GetOptions(SBTypeFormat self) -> uint32_t"""
        return _lldb.SBTypeFormat_GetOptions(self)

    def SetFormat(self, arg2: "lldb::Format"):
        r"""SetFormat(SBTypeFormat self, lldb::Format arg2)"""
        return _lldb.SBTypeFormat_SetFormat(self, arg2)

    def SetTypeName(self, arg2: str):
        r"""SetTypeName(SBTypeFormat self, char const * arg2)"""
        return _lldb.SBTypeFormat_SetTypeName(self, arg2)

    def SetOptions(self, arg2: int):
        r"""SetOptions(SBTypeFormat self, uint32_t arg2)"""
        return _lldb.SBTypeFormat_SetOptions(self, arg2)

    def GetDescription(self, description: "SBStream", description_level: "lldb::DescriptionLevel") -> "bool":
        r"""GetDescription(SBTypeFormat self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        return _lldb.SBTypeFormat_GetDescription(self, description, description_level)

    def IsEqualTo(self, rhs: "SBTypeFormat") -> "bool":
        r"""IsEqualTo(SBTypeFormat self, SBTypeFormat rhs) -> bool"""
        return _lldb.SBTypeFormat_IsEqualTo(self, rhs)

    def __eq__(self, rhs: "SBTypeFormat") -> "bool":
        r"""__eq__(SBTypeFormat self, SBTypeFormat rhs) -> bool"""
        return _lldb.SBTypeFormat___eq__(self, rhs)

    def __ne__(self, rhs: "SBTypeFormat") -> "bool":
        r"""__ne__(SBTypeFormat self, SBTypeFormat rhs) -> bool"""
        return _lldb.SBTypeFormat___ne__(self, rhs)

    def __repr__(self) -> str:
        r"""__repr__(SBTypeFormat self) -> std::string"""
        return _lldb.SBTypeFormat___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    format = property(GetFormat, SetFormat)
    options = property(GetOptions, SetOptions)


# Register SBTypeFormat in _lldb:
_lldb.SBTypeFormat_swigregister(SBTypeFormat)

class SBTypeNameSpecifier(object):
    r"""Represents a general way to provide a type name to LLDB APIs."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBTypeNameSpecifier self) -> SBTypeNameSpecifier
        __init__(SBTypeNameSpecifier self, char const * name, bool is_regex=False) -> SBTypeNameSpecifier
        __init__(SBTypeNameSpecifier self, char const * name, lldb::FormatterMatchType match_type) -> SBTypeNameSpecifier
        __init__(SBTypeNameSpecifier self, SBType type) -> SBTypeNameSpecifier
        __init__(SBTypeNameSpecifier self, SBTypeNameSpecifier rhs) -> SBTypeNameSpecifier
        """
        _lldb.SBTypeNameSpecifier_swiginit(self, _lldb.new_SBTypeNameSpecifier(*args))
    __swig_destroy__ = _lldb.delete_SBTypeNameSpecifier

    def __nonzero__(self):
        return _lldb.SBTypeNameSpecifier___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBTypeNameSpecifier self) -> bool"""
        return _lldb.SBTypeNameSpecifier_IsValid(self)

    def GetName(self) -> str:
        r"""GetName(SBTypeNameSpecifier self) -> char const *"""
        return _lldb.SBTypeNameSpecifier_GetName(self)

    def GetType(self) -> "SBType":
        r"""GetType(SBTypeNameSpecifier self) -> SBType"""
        return _lldb.SBTypeNameSpecifier_GetType(self)

    def GetMatchType(self) -> "lldb::FormatterMatchType":
        r"""GetMatchType(SBTypeNameSpecifier self) -> lldb::FormatterMatchType"""
        return _lldb.SBTypeNameSpecifier_GetMatchType(self)

    def IsRegex(self) -> "bool":
        r"""IsRegex(SBTypeNameSpecifier self) -> bool"""
        return _lldb.SBTypeNameSpecifier_IsRegex(self)

    def GetDescription(self, description: "SBStream", description_level: "lldb::DescriptionLevel") -> "bool":
        r"""GetDescription(SBTypeNameSpecifier self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        return _lldb.SBTypeNameSpecifier_GetDescription(self, description, description_level)

    def IsEqualTo(self, rhs: "SBTypeNameSpecifier") -> "bool":
        r"""IsEqualTo(SBTypeNameSpecifier self, SBTypeNameSpecifier rhs) -> bool"""
        return _lldb.SBTypeNameSpecifier_IsEqualTo(self, rhs)

    def __eq__(self, rhs: "SBTypeNameSpecifier") -> "bool":
        r"""__eq__(SBTypeNameSpecifier self, SBTypeNameSpecifier rhs) -> bool"""
        return _lldb.SBTypeNameSpecifier___eq__(self, rhs)

    def __ne__(self, rhs: "SBTypeNameSpecifier") -> "bool":
        r"""__ne__(SBTypeNameSpecifier self, SBTypeNameSpecifier rhs) -> bool"""
        return _lldb.SBTypeNameSpecifier___ne__(self, rhs)

    def __repr__(self) -> str:
        r"""__repr__(SBTypeNameSpecifier self) -> std::string"""
        return _lldb.SBTypeNameSpecifier___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    name = property(GetName)
    is_regex = property(IsRegex)


    def __eq__(self, rhs):
        if not isinstance(rhs, type(self)):
            return False

        return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)

    def __ne__(self, rhs):
        if not isinstance(rhs, type(self)):
            return True

        return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)


# Register SBTypeNameSpecifier in _lldb:
_lldb.SBTypeNameSpecifier_swigregister(SBTypeNameSpecifier)

class SBTypeSummaryOptions(object):
    r"""Proxy of C++ lldb::SBTypeSummaryOptions class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBTypeSummaryOptions self) -> SBTypeSummaryOptions
        __init__(SBTypeSummaryOptions self, SBTypeSummaryOptions rhs) -> SBTypeSummaryOptions
        """
        _lldb.SBTypeSummaryOptions_swiginit(self, _lldb.new_SBTypeSummaryOptions(*args))
    __swig_destroy__ = _lldb.delete_SBTypeSummaryOptions

    def __nonzero__(self):
        return _lldb.SBTypeSummaryOptions___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBTypeSummaryOptions self) -> bool"""
        return _lldb.SBTypeSummaryOptions_IsValid(self)

    def GetLanguage(self) -> "lldb::LanguageType":
        r"""GetLanguage(SBTypeSummaryOptions self) -> lldb::LanguageType"""
        return _lldb.SBTypeSummaryOptions_GetLanguage(self)

    def GetCapping(self) -> "lldb::TypeSummaryCapping":
        r"""GetCapping(SBTypeSummaryOptions self) -> lldb::TypeSummaryCapping"""
        return _lldb.SBTypeSummaryOptions_GetCapping(self)

    def SetLanguage(self, arg2: "lldb::LanguageType"):
        r"""SetLanguage(SBTypeSummaryOptions self, lldb::LanguageType arg2)"""
        return _lldb.SBTypeSummaryOptions_SetLanguage(self, arg2)

    def SetCapping(self, arg2: "lldb::TypeSummaryCapping"):
        r"""SetCapping(SBTypeSummaryOptions self, lldb::TypeSummaryCapping arg2)"""
        return _lldb.SBTypeSummaryOptions_SetCapping(self, arg2)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBTypeSummaryOptions in _lldb:
_lldb.SBTypeSummaryOptions_swigregister(SBTypeSummaryOptions)

class SBTypeSummary(object):
    r"""Represents a summary that can be associated to one or more types."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    @staticmethod
    def CreateWithSummaryString(data: str, options: int=0) -> "SBTypeSummary":
        r"""CreateWithSummaryString(char const * data, uint32_t options=0) -> SBTypeSummary"""
        return _lldb.SBTypeSummary_CreateWithSummaryString(data, options)

    @staticmethod
    def CreateWithFunctionName(data: str, options: int=0) -> "SBTypeSummary":
        r"""CreateWithFunctionName(char const * data, uint32_t options=0) -> SBTypeSummary"""
        return _lldb.SBTypeSummary_CreateWithFunctionName(data, options)

    @staticmethod
    def CreateWithScriptCode(data: str, options: int=0) -> "SBTypeSummary":
        r"""CreateWithScriptCode(char const * data, uint32_t options=0) -> SBTypeSummary"""
        return _lldb.SBTypeSummary_CreateWithScriptCode(data, options)

    def __init__(self, *args):
        r"""
        __init__(SBTypeSummary self) -> SBTypeSummary
        __init__(SBTypeSummary self, SBTypeSummary rhs) -> SBTypeSummary
        """
        _lldb.SBTypeSummary_swiginit(self, _lldb.new_SBTypeSummary(*args))
    __swig_destroy__ = _lldb.delete_SBTypeSummary

    def __nonzero__(self):
        return _lldb.SBTypeSummary___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBTypeSummary self) -> bool"""
        return _lldb.SBTypeSummary_IsValid(self)

    def IsFunctionCode(self) -> "bool":
        r"""IsFunctionCode(SBTypeSummary self) -> bool"""
        return _lldb.SBTypeSummary_IsFunctionCode(self)

    def IsFunctionName(self) -> "bool":
        r"""IsFunctionName(SBTypeSummary self) -> bool"""
        return _lldb.SBTypeSummary_IsFunctionName(self)

    def IsSummaryString(self) -> "bool":
        r"""IsSummaryString(SBTypeSummary self) -> bool"""
        return _lldb.SBTypeSummary_IsSummaryString(self)

    def GetData(self) -> str:
        r"""GetData(SBTypeSummary self) -> char const *"""
        return _lldb.SBTypeSummary_GetData(self)

    def SetSummaryString(self, data: str):
        r"""SetSummaryString(SBTypeSummary self, char const * data)"""
        return _lldb.SBTypeSummary_SetSummaryString(self, data)

    def SetFunctionName(self, data: str):
        r"""SetFunctionName(SBTypeSummary self, char const * data)"""
        return _lldb.SBTypeSummary_SetFunctionName(self, data)

    def SetFunctionCode(self, data: str):
        r"""SetFunctionCode(SBTypeSummary self, char const * data)"""
        return _lldb.SBTypeSummary_SetFunctionCode(self, data)

    def GetOptions(self) -> int:
        r"""GetOptions(SBTypeSummary self) -> uint32_t"""
        return _lldb.SBTypeSummary_GetOptions(self)

    def SetOptions(self, arg2: int):
        r"""SetOptions(SBTypeSummary self, uint32_t arg2)"""
        return _lldb.SBTypeSummary_SetOptions(self, arg2)

    def GetDescription(self, description: "SBStream", description_level: "lldb::DescriptionLevel") -> "bool":
        r"""GetDescription(SBTypeSummary self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        return _lldb.SBTypeSummary_GetDescription(self, description, description_level)

    def DoesPrintValue(self, value: "SBValue") -> "bool":
        r"""DoesPrintValue(SBTypeSummary self, SBValue value) -> bool"""
        return _lldb.SBTypeSummary_DoesPrintValue(self, value)

    def IsEqualTo(self, rhs: "SBTypeSummary") -> "bool":
        r"""IsEqualTo(SBTypeSummary self, SBTypeSummary rhs) -> bool"""
        return _lldb.SBTypeSummary_IsEqualTo(self, rhs)

    def __eq__(self, rhs: "SBTypeSummary") -> "bool":
        r"""__eq__(SBTypeSummary self, SBTypeSummary rhs) -> bool"""
        return _lldb.SBTypeSummary___eq__(self, rhs)

    def __ne__(self, rhs: "SBTypeSummary") -> "bool":
        r"""__ne__(SBTypeSummary self, SBTypeSummary rhs) -> bool"""
        return _lldb.SBTypeSummary___ne__(self, rhs)

    def __repr__(self) -> str:
        r"""__repr__(SBTypeSummary self) -> std::string"""
        return _lldb.SBTypeSummary___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    options = property(GetOptions, SetOptions)
    is_summary_string = property(IsSummaryString)
    is_function_name = property(IsFunctionName)
    is_function_name = property(IsFunctionCode)
    summary_data = property(GetData)


    def __eq__(self, rhs):
        if not isinstance(rhs, type(self)):
            return False

        return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)

    def __ne__(self, rhs):
        if not isinstance(rhs, type(self)):
            return True

        return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)


# Register SBTypeSummary in _lldb:
_lldb.SBTypeSummary_swigregister(SBTypeSummary)

def SBTypeSummary_CreateWithSummaryString(data: str, options: int=0) -> "SBTypeSummary":
    r"""SBTypeSummary_CreateWithSummaryString(char const * data, uint32_t options=0) -> SBTypeSummary"""
    return _lldb.SBTypeSummary_CreateWithSummaryString(data, options)

def SBTypeSummary_CreateWithFunctionName(data: str, options: int=0) -> "SBTypeSummary":
    r"""SBTypeSummary_CreateWithFunctionName(char const * data, uint32_t options=0) -> SBTypeSummary"""
    return _lldb.SBTypeSummary_CreateWithFunctionName(data, options)

def SBTypeSummary_CreateWithScriptCode(data: str, options: int=0) -> "SBTypeSummary":
    r"""SBTypeSummary_CreateWithScriptCode(char const * data, uint32_t options=0) -> SBTypeSummary"""
    return _lldb.SBTypeSummary_CreateWithScriptCode(data, options)

class SBTypeSynthetic(object):
    r"""Represents a summary that can be associated to one or more types."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    @staticmethod
    def CreateWithClassName(data: str, options: int=0) -> "SBTypeSynthetic":
        r"""CreateWithClassName(char const * data, uint32_t options=0) -> SBTypeSynthetic"""
        return _lldb.SBTypeSynthetic_CreateWithClassName(data, options)

    @staticmethod
    def CreateWithScriptCode(data: str, options: int=0) -> "SBTypeSynthetic":
        r"""CreateWithScriptCode(char const * data, uint32_t options=0) -> SBTypeSynthetic"""
        return _lldb.SBTypeSynthetic_CreateWithScriptCode(data, options)

    def __init__(self, *args):
        r"""
        __init__(SBTypeSynthetic self) -> SBTypeSynthetic
        __init__(SBTypeSynthetic self, SBTypeSynthetic rhs) -> SBTypeSynthetic
        """
        _lldb.SBTypeSynthetic_swiginit(self, _lldb.new_SBTypeSynthetic(*args))
    __swig_destroy__ = _lldb.delete_SBTypeSynthetic

    def __nonzero__(self):
        return _lldb.SBTypeSynthetic___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBTypeSynthetic self) -> bool"""
        return _lldb.SBTypeSynthetic_IsValid(self)

    def IsClassCode(self) -> "bool":
        r"""IsClassCode(SBTypeSynthetic self) -> bool"""
        return _lldb.SBTypeSynthetic_IsClassCode(self)

    def IsClassName(self) -> "bool":
        r"""IsClassName(SBTypeSynthetic self) -> bool"""
        return _lldb.SBTypeSynthetic_IsClassName(self)

    def GetData(self) -> str:
        r"""GetData(SBTypeSynthetic self) -> char const *"""
        return _lldb.SBTypeSynthetic_GetData(self)

    def SetClassName(self, data: str):
        r"""SetClassName(SBTypeSynthetic self, char const * data)"""
        return _lldb.SBTypeSynthetic_SetClassName(self, data)

    def SetClassCode(self, data: str):
        r"""SetClassCode(SBTypeSynthetic self, char const * data)"""
        return _lldb.SBTypeSynthetic_SetClassCode(self, data)

    def GetOptions(self) -> int:
        r"""GetOptions(SBTypeSynthetic self) -> uint32_t"""
        return _lldb.SBTypeSynthetic_GetOptions(self)

    def SetOptions(self, arg2: int):
        r"""SetOptions(SBTypeSynthetic self, uint32_t arg2)"""
        return _lldb.SBTypeSynthetic_SetOptions(self, arg2)

    def GetDescription(self, description: "SBStream", description_level: "lldb::DescriptionLevel") -> "bool":
        r"""GetDescription(SBTypeSynthetic self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        return _lldb.SBTypeSynthetic_GetDescription(self, description, description_level)

    def IsEqualTo(self, rhs: "SBTypeSynthetic") -> "bool":
        r"""IsEqualTo(SBTypeSynthetic self, SBTypeSynthetic rhs) -> bool"""
        return _lldb.SBTypeSynthetic_IsEqualTo(self, rhs)

    def __eq__(self, rhs: "SBTypeSynthetic") -> "bool":
        r"""__eq__(SBTypeSynthetic self, SBTypeSynthetic rhs) -> bool"""
        return _lldb.SBTypeSynthetic___eq__(self, rhs)

    def __ne__(self, rhs: "SBTypeSynthetic") -> "bool":
        r"""__ne__(SBTypeSynthetic self, SBTypeSynthetic rhs) -> bool"""
        return _lldb.SBTypeSynthetic___ne__(self, rhs)

    def __repr__(self) -> str:
        r"""__repr__(SBTypeSynthetic self) -> std::string"""
        return _lldb.SBTypeSynthetic___repr__(self)

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

    options = property(GetOptions, SetOptions)
    contains_code = property(IsClassCode, None)
    synthetic_data = property(GetData, None)


    def __eq__(self, rhs):
        if not isinstance(rhs, type(self)):
            return False

        return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)

    def __ne__(self, rhs):
        if not isinstance(rhs, type(self)):
            return True

        return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)


# Register SBTypeSynthetic in _lldb:
_lldb.SBTypeSynthetic_swigregister(SBTypeSynthetic)

def SBTypeSynthetic_CreateWithClassName(data: str, options: int=0) -> "SBTypeSynthetic":
    r"""SBTypeSynthetic_CreateWithClassName(char const * data, uint32_t options=0) -> SBTypeSynthetic"""
    return _lldb.SBTypeSynthetic_CreateWithClassName(data, options)

def SBTypeSynthetic_CreateWithScriptCode(data: str, options: int=0) -> "SBTypeSynthetic":
    r"""SBTypeSynthetic_CreateWithScriptCode(char const * data, uint32_t options=0) -> SBTypeSynthetic"""
    return _lldb.SBTypeSynthetic_CreateWithScriptCode(data, options)

class SBUnixSignals(object):
    r"""Allows you to manipulate LLDB's signal disposition"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBUnixSignals self) -> SBUnixSignals
        __init__(SBUnixSignals self, SBUnixSignals rhs) -> SBUnixSignals
        """
        _lldb.SBUnixSignals_swiginit(self, _lldb.new_SBUnixSignals(*args))
    __swig_destroy__ = _lldb.delete_SBUnixSignals

    def Clear(self):
        r"""Clear(SBUnixSignals self)"""
        return _lldb.SBUnixSignals_Clear(self)

    def __nonzero__(self):
        return _lldb.SBUnixSignals___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBUnixSignals self) -> bool"""
        return _lldb.SBUnixSignals_IsValid(self)

    def GetSignalAsCString(self, signo: "int32_t") -> str:
        r"""GetSignalAsCString(SBUnixSignals self, int32_t signo) -> char const *"""
        return _lldb.SBUnixSignals_GetSignalAsCString(self, signo)

    def GetSignalNumberFromName(self, name: str) -> "int32_t":
        r"""GetSignalNumberFromName(SBUnixSignals self, char const * name) -> int32_t"""
        return _lldb.SBUnixSignals_GetSignalNumberFromName(self, name)

    def GetShouldSuppress(self, signo: "int32_t") -> "bool":
        r"""GetShouldSuppress(SBUnixSignals self, int32_t signo) -> bool"""
        return _lldb.SBUnixSignals_GetShouldSuppress(self, signo)

    def SetShouldSuppress(self, signo: "int32_t", value: "bool") -> "bool":
        r"""SetShouldSuppress(SBUnixSignals self, int32_t signo, bool value) -> bool"""
        return _lldb.SBUnixSignals_SetShouldSuppress(self, signo, value)

    def GetShouldStop(self, signo: "int32_t") -> "bool":
        r"""GetShouldStop(SBUnixSignals self, int32_t signo) -> bool"""
        return _lldb.SBUnixSignals_GetShouldStop(self, signo)

    def SetShouldStop(self, signo: "int32_t", value: "bool") -> "bool":
        r"""SetShouldStop(SBUnixSignals self, int32_t signo, bool value) -> bool"""
        return _lldb.SBUnixSignals_SetShouldStop(self, signo, value)

    def GetShouldNotify(self, signo: "int32_t") -> "bool":
        r"""GetShouldNotify(SBUnixSignals self, int32_t signo) -> bool"""
        return _lldb.SBUnixSignals_GetShouldNotify(self, signo)

    def SetShouldNotify(self, signo: "int32_t", value: "bool") -> "bool":
        r"""SetShouldNotify(SBUnixSignals self, int32_t signo, bool value) -> bool"""
        return _lldb.SBUnixSignals_SetShouldNotify(self, signo, value)

    def GetNumSignals(self) -> "int32_t":
        r"""GetNumSignals(SBUnixSignals self) -> int32_t"""
        return _lldb.SBUnixSignals_GetNumSignals(self)

    def GetSignalAtIndex(self, index: "int32_t") -> "int32_t":
        r"""GetSignalAtIndex(SBUnixSignals self, int32_t index) -> int32_t"""
        return _lldb.SBUnixSignals_GetSignalAtIndex(self, index)

    def __iter__(self):
        '''Iterate over all signals in a lldb.SBUnixSignals object.'''
        return lldb_iter(self, 'GetNumSignals', 'GetSignalAtIndex')

    def __len__(self):
        return int(self.GetNumSignals())

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def get_unix_signals_list(self):
        signals = []
        for idx in range(0, self.GetNumSignals()):
            signals.append(self.GetSignalAtIndex(sig))
        return signals

    threads = property(get_unix_signals_list, None, doc='''A read only property that returns a list() of valid signal numbers for this platform.''')


# Register SBUnixSignals in _lldb:
_lldb.SBUnixSignals_swigregister(SBUnixSignals)

class SBValue(object):
    r"""
    Represents the value of a variable, a register, or an expression.

    SBValue supports iteration through its child, which in turn is represented
    as an SBValue.  For example, we can get the general purpose registers of a
    frame as an SBValue, and iterate through all the registers,::

        registerSet = frame.registers # Returns an SBValueList.
        for regs in registerSet:
            if 'general purpose registers' in regs.name.lower():
                GPRs = regs
                break

        print('%s (number of children = %d):' % (GPRs.name, GPRs.num_children))
        for reg in GPRs:
            print('Name: ', reg.name, ' Value: ', reg.value)

    produces the output: ::

        General Purpose Registers (number of children = 21):
        Name:  rax  Value:  0x0000000100000c5c
        Name:  rbx  Value:  0x0000000000000000
        Name:  rcx  Value:  0x00007fff5fbffec0
        Name:  rdx  Value:  0x00007fff5fbffeb8
        Name:  rdi  Value:  0x0000000000000001
        Name:  rsi  Value:  0x00007fff5fbffea8
        Name:  rbp  Value:  0x00007fff5fbffe80
        Name:  rsp  Value:  0x00007fff5fbffe60
        Name:  r8  Value:  0x0000000008668682
        Name:  r9  Value:  0x0000000000000000
        Name:  r10  Value:  0x0000000000001200
        Name:  r11  Value:  0x0000000000000206
        Name:  r12  Value:  0x0000000000000000
        Name:  r13  Value:  0x0000000000000000
        Name:  r14  Value:  0x0000000000000000
        Name:  r15  Value:  0x0000000000000000
        Name:  rip  Value:  0x0000000100000dae
        Name:  rflags  Value:  0x0000000000000206
        Name:  cs  Value:  0x0000000000000027
        Name:  fs  Value:  0x0000000000000010
        Name:  gs  Value:  0x0000000000000048

    See also linked_list_iter() for another perspective on how to iterate through an
    SBValue instance which interprets the value object as representing the head of a
    linked list.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBValue self) -> SBValue
        __init__(SBValue self, SBValue rhs) -> SBValue
        """
        _lldb.SBValue_swiginit(self, _lldb.new_SBValue(*args))
    __swig_destroy__ = _lldb.delete_SBValue

    def __nonzero__(self):
        return _lldb.SBValue___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBValue self) -> bool"""
        return _lldb.SBValue_IsValid(self)

    def Clear(self):
        r"""Clear(SBValue self)"""
        return _lldb.SBValue_Clear(self)

    def GetError(self) -> "SBError":
        r"""GetError(SBValue self) -> SBError"""
        return _lldb.SBValue_GetError(self)

    def GetID(self) -> int:
        r"""GetID(SBValue self) -> lldb::user_id_t"""
        return _lldb.SBValue_GetID(self)

    def GetName(self) -> str:
        r"""GetName(SBValue self) -> char const *"""
        return _lldb.SBValue_GetName(self)

    def GetTypeName(self) -> str:
        r"""GetTypeName(SBValue self) -> char const *"""
        return _lldb.SBValue_GetTypeName(self)

    def GetDisplayTypeName(self) -> str:
        r"""GetDisplayTypeName(SBValue self) -> char const *"""
        return _lldb.SBValue_GetDisplayTypeName(self)

    def GetByteSize(self) -> "size_t":
        r"""GetByteSize(SBValue self) -> size_t"""
        return _lldb.SBValue_GetByteSize(self)

    def IsInScope(self) -> "bool":
        r"""IsInScope(SBValue self) -> bool"""
        return _lldb.SBValue_IsInScope(self)

    def GetFormat(self) -> "lldb::Format":
        r"""GetFormat(SBValue self) -> lldb::Format"""
        return _lldb.SBValue_GetFormat(self)

    def SetFormat(self, format: "lldb::Format"):
        r"""SetFormat(SBValue self, lldb::Format format)"""
        return _lldb.SBValue_SetFormat(self, format)

    def GetValue(self) -> str:
        r"""GetValue(SBValue self) -> char const *"""
        return _lldb.SBValue_GetValue(self)

    def GetValueAsSigned(self, *args) -> "int64_t":
        r"""
        GetValueAsSigned(SBValue self, SBError error, int64_t fail_value=0) -> int64_t
        GetValueAsSigned(SBValue self, int64_t fail_value=0) -> int64_t
        """
        return _lldb.SBValue_GetValueAsSigned(self, *args)

    def GetValueAsUnsigned(self, *args) -> int:
        r"""
        GetValueAsUnsigned(SBValue self, SBError error, uint64_t fail_value=0) -> uint64_t
        GetValueAsUnsigned(SBValue self, uint64_t fail_value=0) -> uint64_t
        """
        return _lldb.SBValue_GetValueAsUnsigned(self, *args)

    def GetValueType(self) -> "lldb::ValueType":
        r"""GetValueType(SBValue self) -> lldb::ValueType"""
        return _lldb.SBValue_GetValueType(self)

    def GetValueDidChange(self) -> "bool":
        r"""GetValueDidChange(SBValue self) -> bool"""
        return _lldb.SBValue_GetValueDidChange(self)

    def GetSummary(self, *args) -> str:
        r"""
        GetSummary(SBValue self) -> char const
        GetSummary(SBValue self, SBStream stream, SBTypeSummaryOptions options) -> char const *
        """
        return _lldb.SBValue_GetSummary(self, *args)

    def GetObjectDescription(self) -> str:
        r"""GetObjectDescription(SBValue self) -> char const *"""
        return _lldb.SBValue_GetObjectDescription(self)

    def GetDynamicValue(self, use_dynamic: "lldb::DynamicValueType") -> "SBValue":
        r"""GetDynamicValue(SBValue self, lldb::DynamicValueType use_dynamic) -> SBValue"""
        return _lldb.SBValue_GetDynamicValue(self, use_dynamic)

    def GetStaticValue(self) -> "SBValue":
        r"""GetStaticValue(SBValue self) -> SBValue"""
        return _lldb.SBValue_GetStaticValue(self)

    def GetNonSyntheticValue(self) -> "SBValue":
        r"""GetNonSyntheticValue(SBValue self) -> SBValue"""
        return _lldb.SBValue_GetNonSyntheticValue(self)

    def GetPreferDynamicValue(self) -> "lldb::DynamicValueType":
        r"""GetPreferDynamicValue(SBValue self) -> lldb::DynamicValueType"""
        return _lldb.SBValue_GetPreferDynamicValue(self)

    def SetPreferDynamicValue(self, use_dynamic: "lldb::DynamicValueType"):
        r"""SetPreferDynamicValue(SBValue self, lldb::DynamicValueType use_dynamic)"""
        return _lldb.SBValue_SetPreferDynamicValue(self, use_dynamic)

    def GetPreferSyntheticValue(self) -> "bool":
        r"""GetPreferSyntheticValue(SBValue self) -> bool"""
        return _lldb.SBValue_GetPreferSyntheticValue(self)

    def SetPreferSyntheticValue(self, use_synthetic: "bool"):
        r"""SetPreferSyntheticValue(SBValue self, bool use_synthetic)"""
        return _lldb.SBValue_SetPreferSyntheticValue(self, use_synthetic)

    def IsDynamic(self) -> "bool":
        r"""IsDynamic(SBValue self) -> bool"""
        return _lldb.SBValue_IsDynamic(self)

    def IsSynthetic(self) -> "bool":
        r"""IsSynthetic(SBValue self) -> bool"""
        return _lldb.SBValue_IsSynthetic(self)

    def IsSyntheticChildrenGenerated(self) -> "bool":
        r"""IsSyntheticChildrenGenerated(SBValue self) -> bool"""
        return _lldb.SBValue_IsSyntheticChildrenGenerated(self)

    def SetSyntheticChildrenGenerated(self, arg2: "bool"):
        r"""SetSyntheticChildrenGenerated(SBValue self, bool arg2)"""
        return _lldb.SBValue_SetSyntheticChildrenGenerated(self, arg2)

    def GetLocation(self) -> str:
        r"""GetLocation(SBValue self) -> char const *"""
        return _lldb.SBValue_GetLocation(self)

    def SetValueFromCString(self, *args) -> "bool":
        r"""
        SetValueFromCString(SBValue self, char const * value_str) -> bool
        SetValueFromCString(SBValue self, char const * value_str, SBError error) -> bool
        """
        return _lldb.SBValue_SetValueFromCString(self, *args)

    def GetTypeFormat(self) -> "SBTypeFormat":
        r"""GetTypeFormat(SBValue self) -> SBTypeFormat"""
        return _lldb.SBValue_GetTypeFormat(self)

    def GetTypeSummary(self) -> "SBTypeSummary":
        r"""GetTypeSummary(SBValue self) -> SBTypeSummary"""
        return _lldb.SBValue_GetTypeSummary(self)

    def GetTypeFilter(self) -> "SBTypeFilter":
        r"""GetTypeFilter(SBValue self) -> SBTypeFilter"""
        return _lldb.SBValue_GetTypeFilter(self)

    def GetTypeSynthetic(self) -> "SBTypeSynthetic":
        r"""GetTypeSynthetic(SBValue self) -> SBTypeSynthetic"""
        return _lldb.SBValue_GetTypeSynthetic(self)

    def CreateChildAtOffset(self, name: str, offset: int, type: "SBType") -> "SBValue":
        r"""CreateChildAtOffset(SBValue self, char const * name, uint32_t offset, SBType type) -> SBValue"""
        return _lldb.SBValue_CreateChildAtOffset(self, name, offset, type)

    def Cast(self, type: "SBType") -> "SBValue":
        r"""Cast(SBValue self, SBType type) -> SBValue"""
        return _lldb.SBValue_Cast(self, type)

    def CreateValueFromExpression(self, *args) -> "SBValue":
        r"""
        CreateValueFromExpression(SBValue self, char const * name, char const * expression) -> SBValue
        CreateValueFromExpression(SBValue self, char const * name, char const * expression, SBExpressionOptions options) -> SBValue
        """
        return _lldb.SBValue_CreateValueFromExpression(self, *args)

    def CreateValueFromAddress(self, name: str, address: int, type: "SBType") -> "SBValue":
        r"""CreateValueFromAddress(SBValue self, char const * name, lldb::addr_t address, SBType type) -> SBValue"""
        return _lldb.SBValue_CreateValueFromAddress(self, name, address, type)

    def CreateValueFromData(self, name: str, data: "SBData", type: "SBType") -> "SBValue":
        r"""CreateValueFromData(SBValue self, char const * name, SBData data, SBType type) -> SBValue"""
        return _lldb.SBValue_CreateValueFromData(self, name, data, type)

    def GetChildAtIndex(self, *args) -> "SBValue":
        r"""
        GetChildAtIndex(SBValue self, uint32_t idx) -> SBValue
        GetChildAtIndex(SBValue self, uint32_t idx, lldb::DynamicValueType use_dynamic, bool can_create_synthetic) -> SBValue

            Get a child value by index from a value.

            Structs, unions, classes, arrays and pointers have child
            values that can be access by index.

            Structs and unions access child members using a zero based index
            for each child member. For

            Classes reserve the first indexes for base classes that have
            members (empty base classes are omitted), and all members of the
            current class will then follow the base classes.

            Pointers differ depending on what they point to. If the pointer
            points to a simple type, the child at index zero
            is the only child value available, unless synthetic_allowed
            is true, in which case the pointer will be used as an array
            and can create 'synthetic' child values using positive or
            negative indexes. If the pointer points to an aggregate type
            (an array, class, union, struct), then the pointee is
            transparently skipped and any children are going to be the indexes
            of the child values within the aggregate type. For example if
            we have a 'Point' type and we have a SBValue that contains a
            pointer to a 'Point' type, then the child at index zero will be
            the 'x' member, and the child at index 1 will be the 'y' member
            (the child at index zero won't be a 'Point' instance).

            If you actually need an SBValue that represents the type pointed
            to by a SBValue for which GetType().IsPointeeType() returns true,
            regardless of the pointee type, you can do that with the SBValue.Dereference
            method (or the equivalent deref property).

            Arrays have a preset number of children that can be accessed by
            index and will returns invalid child values for indexes that are
            out of bounds unless the synthetic_allowed is true. In this
            case the array can create 'synthetic' child values for indexes
            that aren't in the array bounds using positive or negative
            indexes.

            @param[in] idx
                The index of the child value to get

            @param[in] use_dynamic
                An enumeration that specifies whether to get dynamic values,
                and also if the target can be run to figure out the dynamic
                type of the child value.

            @param[in] synthetic_allowed
                If true, then allow child values to be created by index
                for pointers and arrays for indexes that normally wouldn't
                be allowed.

            @return
                A new SBValue object that represents the child member value.
        """
        return _lldb.SBValue_GetChildAtIndex(self, *args)

    def GetIndexOfChildWithName(self, name: str) -> int:
        r"""
        GetIndexOfChildWithName(SBValue self, char const * name) -> uint32_t

            Returns the child member index.

            Matches children of this object only and will match base classes and
            member names if this is a clang typed object.

            @param[in] name
                The name of the child value to get

            @return
                An index to the child member value.
        """
        return _lldb.SBValue_GetIndexOfChildWithName(self, name)

    def GetChildMemberWithName(self, *args) -> "SBValue":
        r"""
        GetChildMemberWithName(SBValue self, char const * name) -> SBValue
        GetChildMemberWithName(SBValue self, char const * name, lldb::DynamicValueType use_dynamic) -> SBValue

            Returns the child member value.

            Matches child members of this object and child members of any base
            classes.

            @param[in] name
                The name of the child value to get

            @param[in] use_dynamic
                An enumeration that specifies whether to get dynamic values,
                and also if the target can be run to figure out the dynamic
                type of the child value.

            @return
                A new SBValue object that represents the child member value.
        """
        return _lldb.SBValue_GetChildMemberWithName(self, *args)

    def GetValueForExpressionPath(self, expr_path: str) -> "SBValue":
        r"""
        GetValueForExpressionPath(SBValue self, char const * expr_path) -> SBValue
        Expands nested expressions like .a->b[0].c[1]->d.
        """
        return _lldb.SBValue_GetValueForExpressionPath(self, expr_path)

    def AddressOf(self) -> "SBValue":
        r"""AddressOf(SBValue self) -> SBValue"""
        return _lldb.SBValue_AddressOf(self)

    def GetLoadAddress(self) -> int:
        r"""GetLoadAddress(SBValue self) -> lldb::addr_t"""
        return _lldb.SBValue_GetLoadAddress(self)

    def GetAddress(self) -> "SBAddress":
        r"""GetAddress(SBValue self) -> SBAddress"""
        return _lldb.SBValue_GetAddress(self)

    def GetPointeeData(self, item_idx: int=0, item_count: int=1) -> "SBData":
        r"""
        GetPointeeData(SBValue self, uint32_t item_idx=0, uint32_t item_count=1) -> SBData

            Get an SBData wrapping what this SBValue points to.

            This method will dereference the current SBValue, if its
            data type is a ``T\*`` or ``T[]``, and extract ``item_count`` elements
            of type ``T`` from it, copying their contents in an :py:class:`SBData`.

            :param item_idx: The index of the first item to retrieve. For an array
                this is equivalent to array[item_idx], for a pointer
                to ``\*(pointer + item_idx)``. In either case, the measurement
                unit for item_idx is the ``sizeof(T)`` rather than the byte
            :param item_count: How many items should be copied into the output. By default
                only one item is copied, but more can be asked for.
            :return: The contents of the copied items on success. An empty :py:class:`SBData` otherwise.
            :rtype: SBData

        """
        return _lldb.SBValue_GetPointeeData(self, item_idx, item_count)

    def GetData(self) -> "SBData":
        r"""
        GetData(SBValue self) -> SBData

            Get an SBData wrapping the contents of this SBValue.

            This method will read the contents of this object in memory
            and copy them into an SBData for future use.

            @return
                An SBData with the contents of this SBValue, on success.
                An empty SBData otherwise.
        """
        return _lldb.SBValue_GetData(self)

    def SetData(self, data: "SBData", error: "SBError") -> "bool":
        r"""SetData(SBValue self, SBData data, SBError error) -> bool"""
        return _lldb.SBValue_SetData(self, data, error)

    def Clone(self, new_name: str) -> "SBValue":
        r"""Clone(SBValue self, char const * new_name) -> SBValue"""
        return _lldb.SBValue_Clone(self, new_name)

    def GetDeclaration(self) -> "SBDeclaration":
        r"""GetDeclaration(SBValue self) -> SBDeclaration"""
        return _lldb.SBValue_GetDeclaration(self)

    def MightHaveChildren(self) -> "bool":
        r"""MightHaveChildren(SBValue self) -> bool"""
        return _lldb.SBValue_MightHaveChildren(self)

    def IsRuntimeSupportValue(self) -> "bool":
        r"""IsRuntimeSupportValue(SBValue self) -> bool"""
        return _lldb.SBValue_IsRuntimeSupportValue(self)

    def GetNumChildren(self, *args) -> int:
        r"""
        GetNumChildren(SBValue self) -> uint32_t
        GetNumChildren(SBValue self, uint32_t max) -> uint32_t
        """
        return _lldb.SBValue_GetNumChildren(self, *args)

    def GetOpaqueType(self) -> "void *":
        r"""GetOpaqueType(SBValue self) -> void *"""
        return _lldb.SBValue_GetOpaqueType(self)

    def GetTarget(self) -> "SBTarget":
        r"""GetTarget(SBValue self) -> SBTarget"""
        return _lldb.SBValue_GetTarget(self)

    def GetProcess(self) -> "SBProcess":
        r"""GetProcess(SBValue self) -> SBProcess"""
        return _lldb.SBValue_GetProcess(self)

    def GetThread(self) -> "SBThread":
        r"""GetThread(SBValue self) -> SBThread"""
        return _lldb.SBValue_GetThread(self)

    def GetFrame(self) -> "SBFrame":
        r"""GetFrame(SBValue self) -> SBFrame"""
        return _lldb.SBValue_GetFrame(self)

    def Dereference(self) -> "SBValue":
        r"""Dereference(SBValue self) -> SBValue"""
        return _lldb.SBValue_Dereference(self)

    def TypeIsPointerType(self) -> "bool":
        r"""TypeIsPointerType(SBValue self) -> bool"""
        return _lldb.SBValue_TypeIsPointerType(self)

    def GetType(self) -> "SBType":
        r"""GetType(SBValue self) -> SBType"""
        return _lldb.SBValue_GetType(self)

    def Persist(self) -> "SBValue":
        r"""Persist(SBValue self) -> SBValue"""
        return _lldb.SBValue_Persist(self)

    def GetDescription(self, description: "SBStream") -> "bool":
        r"""GetDescription(SBValue self, SBStream description) -> bool"""
        return _lldb.SBValue_GetDescription(self, description)

    def GetExpressionPath(self, *args) -> "bool":
        r"""
        GetExpressionPath(SBValue self, SBStream description) -> bool
        GetExpressionPath(SBValue self, SBStream description, bool qualify_cxx_base_classes) -> bool
        Returns an expression path for this value.
        """
        return _lldb.SBValue_GetExpressionPath(self, *args)

    def EvaluateExpression(self, *args) -> "SBValue":
        r"""
        EvaluateExpression(SBValue self, char const * expr) -> SBValue
        EvaluateExpression(SBValue self, char const * expr, SBExpressionOptions options) -> SBValue
        EvaluateExpression(SBValue self, char const * expr, SBExpressionOptions options, char const * name) -> SBValue
        """
        return _lldb.SBValue_EvaluateExpression(self, *args)

    def Watch(self, *args) -> "SBWatchpoint":
        r"""
        Watch(SBValue self, bool resolve_location, bool read, bool write, SBError error) -> SBWatchpoint
        Watch(SBValue self, bool resolve_location, bool read, bool write) -> SBWatchpoint

            Find and watch a variable.
            It returns an SBWatchpoint, which may be invalid.
        """
        return _lldb.SBValue_Watch(self, *args)

    def WatchPointee(self, resolve_location: "bool", read: "bool", write: "bool", error: "SBError") -> "SBWatchpoint":
        r"""
        WatchPointee(SBValue self, bool resolve_location, bool read, bool write, SBError error) -> SBWatchpoint

            Find and watch the location pointed to by a variable.
            It returns an SBWatchpoint, which may be invalid.
        """
        return _lldb.SBValue_WatchPointee(self, resolve_location, read, write, error)

    def __repr__(self) -> str:
        r"""__repr__(SBValue self) -> std::string"""
        return _lldb.SBValue___repr__(self)

    def __get_dynamic__ (self):
        '''Helper function for the "SBValue.dynamic" property.'''
        return self.GetDynamicValue (eDynamicCanRunTarget)

    class children_access(object):
        '''A helper object that will lazily hand out thread for a process when supplied an index.'''

        def __init__(self, sbvalue):
            self.sbvalue = sbvalue

        def __len__(self):
            if self.sbvalue:
                return int(self.sbvalue.GetNumChildren())
            return 0

        def __getitem__(self, key):
            if isinstance(key, int):
                count = len(self)
                if -count <= key < count:
                    key %= count
                    return self.sbvalue.GetChildAtIndex(key)
            return None

    def get_child_access_object(self):
        '''An accessor function that returns a children_access() object which allows lazy member variable access from a lldb.SBValue object.'''
        return self.children_access (self)

    def get_value_child_list(self):
        '''An accessor function that returns a list() that contains all children in a lldb.SBValue object.'''
        children = []
        accessor = self.get_child_access_object()
        for idx in range(len(accessor)):
            children.append(accessor[idx])
        return children

    def __int__(self):
        pass

    def __hex__(self):
        return self.GetAddress()

    def __oct__(self):
        pass

    def __iter__(self):
        '''Iterate over all child values of a lldb.SBValue object.'''
        return lldb_iter(self, 'GetNumChildren', 'GetChildAtIndex')

    def __len__(self):
        '''Return the number of child values of a lldb.SBValue object.'''
        return self.GetNumChildren()

    children = property(get_value_child_list, None, doc='''A read only property that returns a list() of lldb.SBValue objects for the children of the value.''')
    child = property(get_child_access_object, None, doc='''A read only property that returns an object that can access children of a variable by index (child_value = value.children[12]).''')
    name = property(GetName, None, doc='''A read only property that returns the name of this value as a string.''')
    type = property(GetType, None, doc='''A read only property that returns a lldb.SBType object that represents the type for this value.''')
    size = property(GetByteSize, None, doc='''A read only property that returns the size in bytes of this value.''')
    is_in_scope = property(IsInScope, None, doc='''A read only property that returns a boolean value that indicates whether this value is currently lexically in scope.''')
    format = property(GetName, SetFormat, doc='''A read/write property that gets/sets the format used for lldb.SBValue().GetValue() for this value. See enumerations that start with "lldb.eFormat".''')
    value = property(GetValue, SetValueFromCString, doc='''A read/write property that gets/sets value from a string.''')
    value_type = property(GetValueType, None, doc='''A read only property that returns an lldb enumeration value (see enumerations that start with "lldb.eValueType") that represents the type of this value (local, argument, global, register, etc.).''')
    changed = property(GetValueDidChange, None, doc='''A read only property that returns a boolean value that indicates if this value has changed since it was last updated.''')
    data = property(GetData, None, doc='''A read only property that returns an lldb object (lldb.SBData) that represents the bytes that make up the value for this object.''')
    load_addr = property(GetLoadAddress, None, doc='''A read only property that returns the load address of this value as an integer.''')
    addr = property(GetAddress, None, doc='''A read only property that returns an lldb.SBAddress that represents the address of this value if it is in memory.''')
    deref = property(Dereference, None, doc='''A read only property that returns an lldb.SBValue that is created by dereferencing this value.''')
    address_of = property(AddressOf, None, doc='''A read only property that returns an lldb.SBValue that represents the address-of this value.''')
    error = property(GetError, None, doc='''A read only property that returns the lldb.SBError that represents the error from the last time the variable value was calculated.''')
    summary = property(GetSummary, None, doc='''A read only property that returns the summary for this value as a string''')
    description = property(GetObjectDescription, None, doc='''A read only property that returns the language-specific description of this value as a string''')
    dynamic = property(__get_dynamic__, None, doc='''A read only property that returns an lldb.SBValue that is created by finding the dynamic type of this value.''')
    location = property(GetLocation, None, doc='''A read only property that returns the location of this value as a string.''')
    target = property(GetTarget, None, doc='''A read only property that returns the lldb.SBTarget that this value is associated with.''')
    process = property(GetProcess, None, doc='''A read only property that returns the lldb.SBProcess that this value is associated with, the returned value might be invalid and should be tested.''')
    thread = property(GetThread, None, doc='''A read only property that returns the lldb.SBThread that this value is associated with, the returned value might be invalid and should be tested.''')
    frame = property(GetFrame, None, doc='''A read only property that returns the lldb.SBFrame that this value is associated with, the returned value might be invalid and should be tested.''')
    num_children = property(GetNumChildren, None, doc='''A read only property that returns the number of child lldb.SBValues that this value has.''')
    unsigned = property(GetValueAsUnsigned, None, doc='''A read only property that returns the value of this SBValue as an usigned integer.''')
    signed = property(GetValueAsSigned, None, doc='''A read only property that returns the value of this SBValue as a signed integer.''')

    def get_expr_path(self):
        s = SBStream()
        self.GetExpressionPath (s)
        return s.GetData()

    path = property(get_expr_path, None, doc='''A read only property that returns the expression path that one can use to reach this value in an expression.''')

    def synthetic_child_from_expression(self, name, expr, options=None):
        if options is None: options = lldb.SBExpressionOptions()
        child = self.CreateValueFromExpression(name, expr, options)
        child.SetSyntheticChildrenGenerated(True)
        return child

    def synthetic_child_from_data(self, name, data, type):
        child = self.CreateValueFromData(name, data, type)
        child.SetSyntheticChildrenGenerated(True)
        return child

    def synthetic_child_from_address(self, name, addr, type):
        child = self.CreateValueFromAddress(name, addr, type)
        child.SetSyntheticChildrenGenerated(True)
        return child

    def __eol_test(val):
        """Default function for end of list test takes an SBValue object.

        Return True if val is invalid or it corresponds to a null pointer.
        Otherwise, return False.
        """
        if not val or val.GetValueAsUnsigned() == 0:
            return True
        else:
            return False

    # ==================================================
    # Iterator for lldb.SBValue treated as a linked list
    # ==================================================
    def linked_list_iter(self, next_item_name, end_of_list_test=__eol_test):
        """Generator adaptor to support iteration for SBValue as a linked list.

        linked_list_iter() is a special purpose iterator to treat the SBValue as
        the head of a list data structure, where you specify the child member
        name which points to the next item on the list and you specify the
        end-of-list test function which takes an SBValue for an item and returns
        True if EOL is reached and False if not.

        linked_list_iter() also detects infinite loop and bails out early.

        The end_of_list_test arg, if omitted, defaults to the __eol_test
        function above.

        For example,

    # Get Frame #0.
        ...

    # Get variable 'task_head'.
        task_head = frame0.FindVariable('task_head')
        ...

        for t in task_head.linked_list_iter('next'):
            print t
        """
        if end_of_list_test(self):
            return
        item = self
        visited = set()
        try:
            while not end_of_list_test(item) and not item.GetValueAsUnsigned() in visited:
                visited.add(item.GetValueAsUnsigned())
                yield item
    # Prepare for the next iteration.
                item = item.GetChildMemberWithName(next_item_name)
        except:
    # Exception occurred.  Stop the generator.
            pass

        return


# Register SBValue in _lldb:
_lldb.SBValue_swigregister(SBValue)

class SBValueList(object):
    r"""
    Represents a collection of SBValues.  Both :py:class:`SBFrame.GetVariables()` and
    :py:class:`SBFrame.GetRegisters()` return a SBValueList.

    SBValueList supports :py:class:`SBValue` iteration. For example (from test/lldbutil.py),::

        def get_registers(frame, kind):
            '''Returns the registers given the frame and the kind of registers desired.

            Returns None if there's no such kind.
            '''
            registerSet = frame.GetRegisters() # Return type of SBValueList.
            for value in registerSet:
                if kind.lower() in value.GetName().lower():
                    return value

            return None

        def get_GPRs(frame):
            '''Returns the general purpose registers of the frame as an SBValue.

            The returned SBValue object is iterable.  An example:
                ...
                from lldbutil import get_GPRs
                regs = get_GPRs(frame)
                for reg in regs:
                    print('%s => %s' % (reg.GetName(), reg.GetValue()))
                ...
            '''
            return get_registers(frame, 'general purpose')

        def get_FPRs(frame):
            '''Returns the floating point registers of the frame as an SBValue.

            The returned SBValue object is iterable.  An example:
                ...
                from lldbutil import get_FPRs
                regs = get_FPRs(frame)
                for reg in regs:
                    print('%s => %s' % (reg.GetName(), reg.GetValue()))
                ...
            '''
            return get_registers(frame, 'floating point')

        def get_ESRs(frame):
            '''Returns the exception state registers of the frame as an SBValue.

            The returned SBValue object is iterable.  An example:
                ...
                from lldbutil import get_ESRs
                regs = get_ESRs(frame)
                for reg in regs:
                    print('%s => %s' % (reg.GetName(), reg.GetValue()))
                ...
            '''
            return get_registers(frame, 'exception state')

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBValueList self) -> SBValueList
        __init__(SBValueList self, SBValueList rhs) -> SBValueList
        """
        _lldb.SBValueList_swiginit(self, _lldb.new_SBValueList(*args))
    __swig_destroy__ = _lldb.delete_SBValueList

    def __nonzero__(self):
        return _lldb.SBValueList___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBValueList self) -> bool"""
        return _lldb.SBValueList_IsValid(self)

    def Clear(self):
        r"""Clear(SBValueList self)"""
        return _lldb.SBValueList_Clear(self)

    def Append(self, *args):
        r"""
        Append(SBValueList self, SBValue val_obj)
        Append(SBValueList self, SBValueList value_list)
        """
        return _lldb.SBValueList_Append(self, *args)

    def GetSize(self) -> int:
        r"""GetSize(SBValueList self) -> uint32_t"""
        return _lldb.SBValueList_GetSize(self)

    def GetValueAtIndex(self, idx: int) -> "SBValue":
        r"""GetValueAtIndex(SBValueList self, uint32_t idx) -> SBValue"""
        return _lldb.SBValueList_GetValueAtIndex(self, idx)

    def GetFirstValueByName(self, name: str) -> "SBValue":
        r"""GetFirstValueByName(SBValueList self, char const * name) -> SBValue"""
        return _lldb.SBValueList_GetFirstValueByName(self, name)

    def FindValueObjectByUID(self, uid: int) -> "SBValue":
        r"""FindValueObjectByUID(SBValueList self, lldb::user_id_t uid) -> SBValue"""
        return _lldb.SBValueList_FindValueObjectByUID(self, uid)

    def GetError(self) -> "SBError":
        r"""GetError(SBValueList self) -> SBError"""
        return _lldb.SBValueList_GetError(self)

    def __str__(self) -> str:
        r"""__str__(SBValueList self) -> std::string"""
        return _lldb.SBValueList___str__(self)

    def __iter__(self):
        '''Iterate over all values in a lldb.SBValueList object.'''
        return lldb_iter(self, 'GetSize', 'GetValueAtIndex')

    def __len__(self):
        return int(self.GetSize())

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __getitem__(self, key):
        count = len(self)
    #------------------------------------------------------------
    # Access with "int" to get Nth item in the list
    #------------------------------------------------------------
        if type(key) is int:
            if -count <= key < count:
                key %= count
                return self.GetValueAtIndex(key)
    #------------------------------------------------------------
    # Access with "str" to get values by name
    #------------------------------------------------------------
        elif type(key) is str:
            matches = []
            for idx in range(count):
                value = self.GetValueAtIndex(idx)
                if value.name == key:
                    matches.append(value)
            return matches
    #------------------------------------------------------------
    # Match with regex
    #------------------------------------------------------------
        elif isinstance(key, type(re.compile('.'))):
            matches = []
            for idx in range(count):
                value = self.GetValueAtIndex(idx)
                re_match = key.search(value.name)
                if re_match:
                    matches.append(value)
            return matches



# Register SBValueList in _lldb:
_lldb.SBValueList_swigregister(SBValueList)

class SBVariablesOptions(object):
    r"""Describes which variables should be returned from :py:class:`SBFrame.GetVariables`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SBVariablesOptions self) -> SBVariablesOptions
        __init__(SBVariablesOptions self, SBVariablesOptions options) -> SBVariablesOptions
        """
        _lldb.SBVariablesOptions_swiginit(self, _lldb.new_SBVariablesOptions(*args))
    __swig_destroy__ = _lldb.delete_SBVariablesOptions

    def __nonzero__(self):
        return _lldb.SBVariablesOptions___nonzero__(self)
    __bool__ = __nonzero__



    def IsValid(self) -> "bool":
        r"""IsValid(SBVariablesOptions self) -> bool"""
        return _lldb.SBVariablesOptions_IsValid(self)

    def GetIncludeArguments(self) -> "bool":
        r"""GetIncludeArguments(SBVariablesOptions self) -> bool"""
        return _lldb.SBVariablesOptions_GetIncludeArguments(self)

    def SetIncludeArguments(self, arg2: "bool"):
        r"""SetIncludeArguments(SBVariablesOptions self, bool arg2)"""
        return _lldb.SBVariablesOptions_SetIncludeArguments(self, arg2)

    def GetIncludeRecognizedArguments(self, arg2: "SBTarget") -> "bool":
        r"""GetIncludeRecognizedArguments(SBVariablesOptions self, SBTarget arg2) -> bool"""
        return _lldb.SBVariablesOptions_GetIncludeRecognizedArguments(self, arg2)

    def SetIncludeRecognizedArguments(self, arg2: "bool"):
        r"""SetIncludeRecognizedArguments(SBVariablesOptions self, bool arg2)"""
        return _lldb.SBVariablesOptions_SetIncludeRecognizedArguments(self, arg2)

    def GetIncludeLocals(self) -> "bool":
        r"""GetIncludeLocals(SBVariablesOptions self) -> bool"""
        return _lldb.SBVariablesOptions_GetIncludeLocals(self)

    def SetIncludeLocals(self, arg2: "bool"):
        r"""SetIncludeLocals(SBVariablesOptions self, bool arg2)"""
        return _lldb.SBVariablesOptions_SetIncludeLocals(self, arg2)

    def GetIncludeStatics(self) -> "bool":
        r"""GetIncludeStatics(SBVariablesOptions self) -> bool"""
        return _lldb.SBVariablesOptions_GetIncludeStatics(self)

    def SetIncludeStatics(self, arg2: "bool"):
        r"""SetIncludeStatics(SBVariablesOptions self, bool arg2)"""
        return _lldb.SBVariablesOptions_SetIncludeStatics(self, arg2)

    def GetInScopeOnly(self) -> "bool":
        r"""GetInScopeOnly(SBVariablesOptions self) -> bool"""
        return _lldb.SBVariablesOptions_GetInScopeOnly(self)

    def SetInScopeOnly(self, arg2: "bool"):
        r"""SetInScopeOnly(SBVariablesOptions self, bool arg2)"""
        return _lldb.SBVariablesOptions_SetInScopeOnly(self, arg2)

    def GetIncludeRuntimeSupportValues(self) -> "bool":
        r"""GetIncludeRuntimeSupportValues(SBVariablesOptions self) -> bool"""
        return _lldb.SBVariablesOptions_GetIncludeRuntimeSupportValues(self)

    def SetIncludeRuntimeSupportValues(self, arg2: "bool"):
        r"""SetIncludeRuntimeSupportValues(SBVariablesOptions self, bool arg2)"""
        return _lldb.SBVariablesOptions_SetIncludeRuntimeSupportValues(self, arg2)

    def GetUseDynamic(self) -> "lldb::DynamicValueType":
        r"""GetUseDynamic(SBVariablesOptions self) -> lldb::DynamicValueType"""
        return _lldb.SBVariablesOptions_GetUseDynamic(self)

    def SetUseDynamic(self, arg2: "lldb::DynamicValueType"):
        r"""SetUseDynamic(SBVariablesOptions self, lldb::DynamicValueType arg2)"""
        return _lldb.SBVariablesOptions_SetUseDynamic(self, arg2)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      pass

    def __iter__(self):
      pass


# Register SBVariablesOptions in _lldb:
_lldb.SBVariablesOptions_swigregister(SBVariablesOptions)

class SBWatchpoint(object):
    r"""
    Represents an instance of watchpoint for a specific target program.

    A watchpoint is determined by the address and the byte size that resulted in
    this particular instantiation.  Each watchpoint has its settable options.

    See also :py:class:`SBTarget.watchpoint_iter()` for example usage of iterating through the
    watchpoints of the target.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(SBWatchpoint self) -> SBWatchpoint
        __init__(SBWatchpoint self, SBWatchpoint rhs) -> SBWatchpoint
        """
        _lldb.SBWatchpoint_swiginit(self, _lldb.new_SBWatchpoint(*args))
    __swig_destroy__ = _lldb.delete_SBWatchpoint

    def __nonzero__(self):
        return _lldb.SBWatchpoint___nonzero__(self)
    __bool__ = __nonzero__



    def __eq__(self, rhs: "SBWatchpoint") -> "bool":
        r"""__eq__(SBWatchpoint self, SBWatchpoint rhs) -> bool"""
        return _lldb.SBWatchpoint___eq__(self, rhs)

    def __ne__(self, rhs: "SBWatchpoint") -> "bool":
        r"""__ne__(SBWatchpoint self, SBWatchpoint rhs) -> bool"""
        return _lldb.SBWatchpoint___ne__(self, rhs)

    def IsValid(self) -> "bool":
        r"""IsValid(SBWatchpoint self) -> bool"""
        return _lldb.SBWatchpoint_IsValid(self)

    def GetError(self) -> "SBError":
        r"""GetError(SBWatchpoint self) -> SBError"""
        return _lldb.SBWatchpoint_GetError(self)

    def GetID(self) -> "lldb::watch_id_t":
        r"""GetID(SBWatchpoint self) -> lldb::watch_id_t"""
        return _lldb.SBWatchpoint_GetID(self)

    def GetHardwareIndex(self) -> "int32_t":
        r"""
        GetHardwareIndex(SBWatchpoint self) -> int32_t

            With -1 representing an invalid hardware index.
        """
        return _lldb.SBWatchpoint_GetHardwareIndex(self)

    def GetWatchAddress(self) -> int:
        r"""GetWatchAddress(SBWatchpoint self) -> lldb::addr_t"""
        return _lldb.SBWatchpoint_GetWatchAddress(self)

    def GetWatchSize(self) -> "size_t":
        r"""GetWatchSize(SBWatchpoint self) -> size_t"""
        return _lldb.SBWatchpoint_GetWatchSize(self)

    def SetEnabled(self, enabled: "bool"):
        r"""SetEnabled(SBWatchpoint self, bool enabled)"""
        return _lldb.SBWatchpoint_SetEnabled(self, enabled)

    def IsEnabled(self) -> "bool":
        r"""IsEnabled(SBWatchpoint self) -> bool"""
        return _lldb.SBWatchpoint_IsEnabled(self)

    def GetHitCount(self) -> int:
        r"""GetHitCount(SBWatchpoint self) -> uint32_t"""
        return _lldb.SBWatchpoint_GetHitCount(self)

    def GetIgnoreCount(self) -> int:
        r"""GetIgnoreCount(SBWatchpoint self) -> uint32_t"""
        return _lldb.SBWatchpoint_GetIgnoreCount(self)

    def SetIgnoreCount(self, n: int):
        r"""SetIgnoreCount(SBWatchpoint self, uint32_t n)"""
        return _lldb.SBWatchpoint_SetIgnoreCount(self, n)

    def GetCondition(self) -> str:
        r"""
        GetCondition(SBWatchpoint self) -> char const *

            Get the condition expression for the watchpoint.
        """
        return _lldb.SBWatchpoint_GetCondition(self)

    def SetCondition(self, condition: str):
        r"""
        SetCondition(SBWatchpoint self, char const * condition)

            The watchpoint stops only if the condition expression evaluates to true.
        """
        return _lldb.SBWatchpoint_SetCondition(self, condition)

    def GetDescription(self, description: "SBStream", level: "lldb::DescriptionLevel") -> "bool":
        r"""GetDescription(SBWatchpoint self, SBStream description, lldb::DescriptionLevel level) -> bool"""
        return _lldb.SBWatchpoint_GetDescription(self, description, level)

    def Clear(self):
        r"""Clear(SBWatchpoint self)"""
        return _lldb.SBWatchpoint_Clear(self)

    @staticmethod
    def EventIsWatchpointEvent(event: "SBEvent") -> "bool":
        r"""EventIsWatchpointEvent(SBEvent event) -> bool"""
        return _lldb.SBWatchpoint_EventIsWatchpointEvent(event)

    @staticmethod
    def GetWatchpointEventTypeFromEvent(event: "SBEvent") -> "lldb::WatchpointEventType":
        r"""GetWatchpointEventTypeFromEvent(SBEvent event) -> lldb::WatchpointEventType"""
        return _lldb.SBWatchpoint_GetWatchpointEventTypeFromEvent(event)

    @staticmethod
    def GetWatchpointFromEvent(event: "SBEvent") -> "SBWatchpoint":
        r"""GetWatchpointFromEvent(SBEvent event) -> SBWatchpoint"""
        return _lldb.SBWatchpoint_GetWatchpointFromEvent(event)

    def GetType(self) -> "SBType":
        r"""
        GetType(SBWatchpoint self) -> SBType

            Returns the type recorded when the watchpoint was created. For variable
            watchpoints it is the type of the watched variable. For expression
            watchpoints it is the type of the provided expression.
        """
        return _lldb.SBWatchpoint_GetType(self)

    def GetWatchValueKind(self) -> "lldb::WatchpointValueKind":
        r"""
        GetWatchValueKind(SBWatchpoint self) -> lldb::WatchpointValueKind

            Returns the kind of value that was watched when the watchpoint was created.
            Returns one of the following eWatchPointValueKindVariable,
            eWatchPointValueKindExpression, eWatchPointValueKindInvalid.

        """
        return _lldb.SBWatchpoint_GetWatchValueKind(self)

    def GetWatchSpec(self) -> str:
        r"""
        GetWatchSpec(SBWatchpoint self) -> char const *

            Get the spec for the watchpoint. For variable watchpoints this is the name
            of the variable. For expression watchpoints it is empty
            (may change in the future).
        """
        return _lldb.SBWatchpoint_GetWatchSpec(self)

    def IsWatchingReads(self) -> "bool":
        r"""
        IsWatchingReads(SBWatchpoint self) -> bool

            Returns true if the watchpoint is watching reads. Returns false otherwise.
        """
        return _lldb.SBWatchpoint_IsWatchingReads(self)

    def IsWatchingWrites(self) -> "bool":
        r"""
        IsWatchingWrites(SBWatchpoint self) -> bool

            Returns true if the watchpoint is watching writes. Returns false otherwise.
        """
        return _lldb.SBWatchpoint_IsWatchingWrites(self)

    def __repr__(self) -> str:
        r"""__repr__(SBWatchpoint self) -> std::string"""
        return _lldb.SBWatchpoint___repr__(self)

    def __eq__(self, other):
      return not self.__ne__(other)

    def __int__(self):
      pass

    def __hex__(self):
      return self.GetWatchAddress()

    def __oct__(self):
      pass

    def __len__(self):
      return self.GetWatchSize()

    def __iter__(self):
      pass


# Register SBWatchpoint in _lldb:
_lldb.SBWatchpoint_swigregister(SBWatchpoint)

def SBWatchpoint_EventIsWatchpointEvent(event: "SBEvent") -> "bool":
    r"""SBWatchpoint_EventIsWatchpointEvent(SBEvent event) -> bool"""
    return _lldb.SBWatchpoint_EventIsWatchpointEvent(event)

def SBWatchpoint_GetWatchpointEventTypeFromEvent(event: "SBEvent") -> "lldb::WatchpointEventType":
    r"""SBWatchpoint_GetWatchpointEventTypeFromEvent(SBEvent event) -> lldb::WatchpointEventType"""
    return _lldb.SBWatchpoint_GetWatchpointEventTypeFromEvent(event)

def SBWatchpoint_GetWatchpointFromEvent(event: "SBEvent") -> "SBWatchpoint":
    r"""SBWatchpoint_GetWatchpointFromEvent(SBEvent event) -> SBWatchpoint"""
    return _lldb.SBWatchpoint_GetWatchpointFromEvent(event)


# ==================================
# Helper function for SBModule class
# ==================================
def in_range(symbol, section):
    """Test whether a symbol is within the range of a section."""
    symSA = symbol.GetStartAddress().GetFileAddress()
    symEA = symbol.GetEndAddress().GetFileAddress()
    secSA = section.GetFileAddress()
    secEA = secSA + section.GetByteSize()

    if symEA != LLDB_INVALID_ADDRESS:
        if secSA <= symSA and symEA <= secEA:
            return True
        else:
            return False
    else:
        if secSA <= symSA and symSA < secEA:
            return True
        else:
            return False



def command(command_name=None, doc=None):
    import lldb
    """A decorator function that registers an LLDB command line
        command that is bound to the function it is attached to."""
    def callable(function):
        """Registers an lldb command for the decorated function."""
        command = "command script add -f %s.%s %s" % (function.__module__, function.__name__, command_name or function.__name__)
        lldb.debugger.HandleCommand(command)
        if doc:
            function.__doc__ = doc
        return function

    return callable

class declaration(object):
    '''A class that represents a source declaration location with file, line and column.'''
    def __init__(self, file, line, col):
        self.file = file
        self.line = line
        self.col = col

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        pass

    def __iter__(self):
        pass

class value_iter(object):
    '''Allows iterating over the children of an :py:class:`SBValue`.'''
    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= self.length:
            raise StopIteration()
        child_sbvalue = self.sbvalue.GetChildAtIndex(self.index)
        self.index += 1
        return value(child_sbvalue)

    def next(self):
        return self.__next__()

    def __eq__(self, other):
        return not self.__ne__(other)

    def __int__(self):
        pass

    def __hex__(self):
        pass

    def __oct__(self):
        pass

    def __len__(self):
        return self.length

    def __init__(self,value):
        self.index = 0
        self.length = 0
        self.sbvalue = value
        if type(self.sbvalue) is value:
            self.sbvalue = self.sbvalue.sbvalue
        self.length = self.sbvalue.GetNumChildren()

class value(object):
    '''Wraps :py:class:`SBValue` objects so the resulting object can be used as a variable would be in code.

    So if you have a Point structure variable in your code in the current frame named "pt",
    you can initialize an instance of this class with it: ::

        pt = lldb.value(lldb.frame.FindVariable("pt"))
        print pt
        print pt.x
        print pt.y

        pt = lldb.value(lldb.frame.FindVariable("rectangle_array"))
        print rectangle_array[12]
        print rectangle_array[5].origin.x'''
    def __init__(self, sbvalue):
        self.sbvalue = sbvalue

    def __nonzero__(self):
        return self.sbvalue.__nonzero__()

    def __bool__(self):
        return self.sbvalue.__bool__()

    def __str__(self):
        return self.sbvalue.__str__()

    def __getitem__(self, key):
# Allow array access if this value has children...
        if type(key) is value:
            key = int(key)
        if type(key) is int:
            child_sbvalue = (self.sbvalue.GetValueForExpressionPath("[%i]" % key))
            if child_sbvalue and child_sbvalue.IsValid():
                return value(child_sbvalue)
            raise IndexError("Index '%d' is out of range" % key)
        raise TypeError("No array item of type %s" % str(type(key)))

    def __iter__(self):
        return value_iter(self.sbvalue)

    def __getattr__(self, name):
        child_sbvalue = self.sbvalue.GetChildMemberWithName (name)
        if child_sbvalue and child_sbvalue.IsValid():
            return value(child_sbvalue)
        raise AttributeError("Attribute '%s' is not defined" % name)

    def __add__(self, other):
        return int(self) + int(other)

    def __sub__(self, other):
        return int(self) - int(other)

    def __mul__(self, other):
        return int(self) * int(other)

    def __floordiv__(self, other):
        return int(self) // int(other)

    def __mod__(self, other):
        return int(self) % int(other)

    def __divmod__(self, other):
        return int(self) % int(other)

    def __pow__(self, other):
        return int(self) ** int(other)

    def __lshift__(self, other):
        return int(self) << int(other)

    def __rshift__(self, other):
        return int(self) >> int(other)

    def __and__(self, other):
        return int(self) & int(other)

    def __xor__(self, other):
        return int(self) ^ int(other)

    def __or__(self, other):
        return int(self) | int(other)

    def __div__(self, other):
        return int(self) / int(other)

    def __truediv__(self, other):
        return int(self) / int(other)

    def __iadd__(self, other):
        result = self.__add__(other)
        self.sbvalue.SetValueFromCString (str(result))
        return result

    def __isub__(self, other):
        result = self.__sub__(other)
        self.sbvalue.SetValueFromCString (str(result))
        return result

    def __imul__(self, other):
        result = self.__mul__(other)
        self.sbvalue.SetValueFromCString (str(result))
        return result

    def __idiv__(self, other):
        result = self.__div__(other)
        self.sbvalue.SetValueFromCString (str(result))
        return result

    def __itruediv__(self, other):
        result = self.__truediv__(other)
        self.sbvalue.SetValueFromCString (str(result))
        return result

    def __ifloordiv__(self, other):
        result =  self.__floordiv__(self, other)
        self.sbvalue.SetValueFromCString (str(result))
        return result

    def __imod__(self, other):
        result =  self.__and__(self, other)
        self.sbvalue.SetValueFromCString (str(result))
        return result

    def __ipow__(self, other):
        result = self.__pow__(self, other)
        self.sbvalue.SetValueFromCString (str(result))
        return result

    def __ipow__(self, other, modulo):
        result = self.__pow__(self, other, modulo)
        self.sbvalue.SetValueFromCString (str(result))
        return result

    def __ilshift__(self, other):
        result = self.__lshift__(other)
        self.sbvalue.SetValueFromCString (str(result))
        return result

    def __irshift__(self, other):
        result =  self.__rshift__(other)
        self.sbvalue.SetValueFromCString (str(result))
        return result

    def __iand__(self, other):
        result =  self.__and__(self, other)
        self.sbvalue.SetValueFromCString (str(result))
        return result

    def __ixor__(self, other):
        result =  self.__xor__(self, other)
        self.sbvalue.SetValueFromCString (str(result))
        return result

    def __ior__(self, other):
        result =  self.__ior__(self, other)
        self.sbvalue.SetValueFromCString (str(result))
        return result

    def __neg__(self):
        return -int(self)

    def __pos__(self):
        return +int(self)

    def __abs__(self):
        return abs(int(self))

    def __invert__(self):
        return ~int(self)

    def __complex__(self):
        return complex (int(self))

    def __int__(self):
        is_num,is_sign = is_numeric_type(self.sbvalue.GetType().GetCanonicalType().GetBasicType())
        if is_num and not is_sign: return self.sbvalue.GetValueAsUnsigned()
        return self.sbvalue.GetValueAsSigned()

    def __long__(self):
        return self.__int__()

    def __float__(self):
        return float (self.sbvalue.GetValueAsSigned())

    def __oct__(self):
        return '0%o' % self.sbvalue.GetValueAsUnsigned()

    def __hex__(self):
        return '0x%x' % self.sbvalue.GetValueAsUnsigned()

    def __len__(self):
        return self.sbvalue.GetNumChildren()

    def __eq__(self, other):
        if type(other) is int:
                return int(self) == other
        elif type(other) is str:
                return str(self) == other
        elif type(other) is value:
                self_err = SBError()
                other_err = SBError()
                self_val = self.sbvalue.GetValueAsUnsigned(self_err)
                if self_err.fail:
                        raise ValueError("unable to extract value of self")
                other_val = other.sbvalue.GetValueAsUnsigned(other_err)
                if other_err.fail:
                        raise ValueError("unable to extract value of other")
                return self_val == other_val
        raise TypeError("Unknown type %s, No equality operation defined." % str(type(other)))

    def __ne__(self, other):
        return not self.__eq__(other)



class SBSyntheticValueProvider(object):
    def __init__(self,valobj):
        pass

    def num_children(self):
        return 0

    def get_child_index(self,name):
        return None

    def get_child_at_index(self,idx):
        return None

    def update(self):
        pass

    def has_children(self):
        return False

    def __int__(self):
      pass

    def __hex__(self):
      pass

    def __oct__(self):
      pass

    def __len__(self):
      return self.num_children()

    def __iter__(self):
      '''Iterate over all children in a lldb.SBSyntheticValueProvider object.'''
      return lldb_iter(self, 'num_children', 'get_child_at_index')




# given an lldb.SBBasicType it returns a tuple
# (is_numeric, is_signed)
# the value of is_signed is undefined if is_numeric == false
def is_numeric_type(basic_type):
    if basic_type == eBasicTypeInvalid: return (False,False)
    if basic_type == eBasicTypeVoid: return (False,False)
    if basic_type == eBasicTypeChar: return (True,False)
    if basic_type == eBasicTypeSignedChar: return (True,True)
    if basic_type == eBasicTypeUnsignedChar: return (True,False)
    if basic_type == eBasicTypeWChar: return (True,False)
    if basic_type == eBasicTypeSignedWChar: return (True,True)
    if basic_type == eBasicTypeUnsignedWChar: return (True,False)
    if basic_type == eBasicTypeChar16: return (True,False)
    if basic_type == eBasicTypeChar32: return (True,False)
    if basic_type == eBasicTypeChar8: return (True,False)
    if basic_type == eBasicTypeShort: return (True,True)
    if basic_type == eBasicTypeUnsignedShort: return (True,False)
    if basic_type == eBasicTypeInt: return (True,True)
    if basic_type == eBasicTypeUnsignedInt: return (True,False)
    if basic_type == eBasicTypeLong: return (True,True)
    if basic_type == eBasicTypeUnsignedLong: return (True,False)
    if basic_type == eBasicTypeLongLong: return (True,True)
    if basic_type == eBasicTypeUnsignedLongLong: return (True,False)
    if basic_type == eBasicTypeInt128: return (True,True)
    if basic_type == eBasicTypeUnsignedInt128: return (True,False)
    if basic_type == eBasicTypeBool: return (False,False)
    if basic_type == eBasicTypeHalf: return (True,True)
    if basic_type == eBasicTypeFloat: return (True,True)
    if basic_type == eBasicTypeDouble: return (True,True)
    if basic_type == eBasicTypeLongDouble: return (True,True)
    if basic_type == eBasicTypeFloatComplex: return (True,True)
    if basic_type == eBasicTypeDoubleComplex: return (True,True)
    if basic_type == eBasicTypeLongDoubleComplex: return (True,True)
    if basic_type == eBasicTypeObjCID: return (False,False)
    if basic_type == eBasicTypeObjCClass: return (False,False)
    if basic_type == eBasicTypeObjCSel: return (False,False)
    if basic_type == eBasicTypeNullPtr: return (False,False)
#if basic_type == eBasicTypeOther:
    return (False,False)



debugger_unique_id = 0
SBDebugger.Initialize()
debugger = None
target = None
process = None
thread = None
frame = None




```

`lldb/diagnose/__init__.py`:

```py
__all__ = ["diagnose_unwind", "diagnose_nsstring"]
for x in __all__:
  __import__('lldb.diagnose.' + x)

def __lldb_init_module(debugger, internal_dict):
  import lldb
  for x in __all__:
    submodule = getattr(lldb.diagnose, x)
    lldb_init = getattr(submodule, '__lldb_init_module', None)
    if lldb_init:
      lldb_init(debugger, internal_dict)

```

`lldb/diagnose/diagnose_nsstring.py`:

```py
# This implements the "diagnose-nsstring" command, usually installed in the debug session like
#   command script import lldb.diagnose
# it is used when NSString summary formatter fails to replicate the logic that went into LLDB making the
# decisions it did and  providing some useful context information that can
# be used for improving the formatter

import lldb


def read_memory(process, location, size):
    data = ""
    error = lldb.SBError()
    for x in range(0, size - 1):
        byte = process.ReadUnsignedFromMemory(x + location, 1, error)
        if error.fail:
            data = data + "err%s" % "" if x == size - 2 else ":"
        else:
            try:
                data = data + "0x%x" % byte
                if byte == 0:
                    data = data + "(\\0)"
                elif byte == 0xA:
                    data = data + "(\\a)"
                elif byte == 0xB:
                    data = data + "(\\b)"
                elif byte == 0xC:
                    data = data + "(\\c)"
                elif byte == "\n":
                    data = data + "(\\n)"
                else:
                    data = data + "(%s)" % chr(byte)
                if x < size - 2:
                    data = data + ":"
            except Exception as e:
                print(e)
    return data


def diagnose_nsstring_Command_Impl(debugger, command, result, internal_dict):
    """
    A command to diagnose the LLDB NSString data formatter
    invoke as
    (lldb) diagnose-nsstring <expr returning NSString>
    e.g.
    (lldb) diagnose-nsstring @"Hello world"
    """
    target = debugger.GetSelectedTarget()
    process = target.GetProcess()
    thread = process.GetSelectedThread()
    frame = thread.GetSelectedFrame()
    if not target.IsValid() or not process.IsValid():
        return "unable to get target/process - cannot proceed"
    options = lldb.SBExpressionOptions()
    options.SetFetchDynamicValue()
    error = lldb.SBError()
    if frame.IsValid():
        nsstring = frame.EvaluateExpression(command, options)
    else:
        nsstring = target.EvaluateExpression(command, options)
    print(str(nsstring), file=result)
    nsstring_address = nsstring.GetValueAsUnsigned(0)
    if nsstring_address == 0:
        return "unable to obtain the string - cannot proceed"
    expression = "\
struct $__lldb__notInlineMutable {\
    char* buffer;\
    signed long length;\
    signed long capacity;\
    unsigned int hasGap:1;\
    unsigned int isFixedCapacity:1;\
    unsigned int isExternalMutable:1;\
    unsigned int capacityProvidedExternally:1;\n\
#if __LP64__\n\
    unsigned long desiredCapacity:60;\n\
#else\n\
    unsigned long desiredCapacity:28;\n\
#endif\n\
    void* contentsAllocator;\
};\
\
struct $__lldb__CFString {\
    void* _cfisa;\
    uint8_t _cfinfo[4];\
    uint32_t _rc;\
    union {\
        struct __inline1 {\
            signed long length;\
        } inline1;\
        struct __notInlineImmutable1 {\
            char* buffer;\
            signed long length;\
            void* contentsDeallocator;\
        } notInlineImmutable1;\
        struct __notInlineImmutable2 {\
            char* buffer;\
            void* contentsDeallocator;\
        } notInlineImmutable2;\
        struct $__lldb__notInlineMutable notInlineMutable;\
    } variants;\
};\
"

    expression = expression + "*(($__lldb__CFString*) %d)" % nsstring_address
    # print expression
    dumped = target.EvaluateExpression(expression, options)
    print(str(dumped), file=result)

    little_endian = target.byte_order == lldb.eByteOrderLittle
    ptr_size = target.addr_size

    info_bits = (
        dumped.GetChildMemberWithName("_cfinfo")
        .GetChildAtIndex(0 if little_endian else 3)
        .GetValueAsUnsigned(0)
    )
    is_mutable = (info_bits & 1) == 1
    is_inline = (info_bits & 0x60) == 0
    has_explicit_length = (info_bits & (1 | 4)) != 4
    is_unicode = (info_bits & 0x10) == 0x10
    is_special = (
        nsstring.GetDynamicValue(lldb.eDynamicCanRunTarget).GetTypeName()
        == "NSPathStore2"
    )
    has_null = (info_bits & 8) == 8

    print(
        "\nInfo=%d\nMutable=%s\nInline=%s\nExplicit=%s\nUnicode=%s\nSpecial=%s\nNull=%s\n"
        % (
            info_bits,
            "yes" if is_mutable else "no",
            "yes" if is_inline else "no",
            "yes" if has_explicit_length else "no",
            "yes" if is_unicode else "no",
            "yes" if is_special else "no",
            "yes" if has_null else "no",
        ),
        file=result,
    )

    explicit_length_offset = 0
    if not has_null and has_explicit_length and not is_special:
        explicit_length_offset = 2 * ptr_size
        if is_mutable and not is_inline:
            explicit_length_offset = explicit_length_offset + ptr_size
        elif is_inline:
            pass
        elif not is_inline and not is_mutable:
            explicit_length_offset = explicit_length_offset + ptr_size
        else:
            explicit_length_offset = 0

    if explicit_length_offset == 0:
        print("There is no explicit length marker - skipping this step\n", file=result)
    else:
        explicit_length_offset = nsstring_address + explicit_length_offset
        explicit_length = process.ReadUnsignedFromMemory(
            explicit_length_offset, 4, error
        )
        print(
            "Explicit length location is at 0x%x - read value is %d\n"
            % (explicit_length_offset, explicit_length),
            file=result,
        )

    if is_mutable:
        location = 2 * ptr_size + nsstring_address
        location = process.ReadPointerFromMemory(location, error)
    elif (
        is_inline
        and has_explicit_length
        and not is_unicode
        and not is_special
        and not is_mutable
    ):
        location = 3 * ptr_size + nsstring_address
    elif is_unicode:
        location = 2 * ptr_size + nsstring_address
        if is_inline:
            if not has_explicit_length:
                print(
                    "Unicode & Inline & !Explicit is a new combo - no formula for it",
                    file=result,
                )
            else:
                location += ptr_size
        else:
            location = process.ReadPointerFromMemory(location, error)
    elif is_special:
        location = nsstring_address + ptr_size + 4
    elif is_inline:
        location = 2 * ptr_size + nsstring_address
        if not has_explicit_length:
            location += 1
    else:
        location = 2 * ptr_size + nsstring_address
        location = process.ReadPointerFromMemory(location, error)
    print("Expected data location: 0x%x\n" % (location), file=result)
    print(
        "1K of data around location: %s\n" % read_memory(process, location, 1024),
        file=result,
    )
    print(
        "5K of data around string pointer: %s\n"
        % read_memory(process, nsstring_address, 1024 * 5),
        file=result,
    )


def __lldb_init_module(debugger, internal_dict):
    debugger.HandleCommand(
        "command script add -o -f %s.diagnose_nsstring_Command_Impl diagnose-nsstring"
        % __name__
    )
    print(
        'The "diagnose-nsstring" command has been installed, type "help diagnose-nsstring" for detailed help.'
    )


__lldb_init_module(lldb.debugger, None)
__lldb_init_module = None

```

`lldb/diagnose/diagnose_unwind.py`:

```py
# This implements the "diagnose-unwind" command, usually installed
# in the debug session like
#   command script import lldb.diagnose
# it is used when lldb's backtrace fails -- it collects and prints
# information about the stack frames, and tries an alternate unwind
# algorithm, that will help to understand why lldb's unwind algorithm
# did not succeed.

import optparse
import lldb
import re
import shlex

# Print the frame number, pc, frame pointer, module UUID and function name
# Returns the SBModule that contains the PC, if it could be found


def backtrace_print_frame(target, frame_num, addr, fp):
    process = target.GetProcess()
    addr_for_printing = addr
    addr_width = process.GetAddressByteSize() * 2
    if frame_num > 0:
        addr = addr - 1

    sbaddr = lldb.SBAddress()
    try:
        sbaddr.SetLoadAddress(addr, target)
        module_description = ""
        if sbaddr.GetModule():
            module_filename = ""
            module_uuid_str = sbaddr.GetModule().GetUUIDString()
            if module_uuid_str is None:
                module_uuid_str = ""
            if sbaddr.GetModule().GetFileSpec():
                module_filename = sbaddr.GetModule().GetFileSpec().GetFilename()
                if module_filename is None:
                    module_filename = ""
            if module_uuid_str != "" or module_filename != "":
                module_description = "%s %s" % (module_filename, module_uuid_str)
    except Exception:
        print(
            "%2d: pc==0x%-*x fp==0x%-*x"
            % (frame_num, addr_width, addr_for_printing, addr_width, fp)
        )
        return

    sym_ctx = target.ResolveSymbolContextForAddress(
        sbaddr, lldb.eSymbolContextEverything
    )
    if sym_ctx.IsValid() and sym_ctx.GetSymbol().IsValid():
        function_start = sym_ctx.GetSymbol().GetStartAddress().GetLoadAddress(target)
        offset = addr - function_start
        print(
            "%2d: pc==0x%-*x fp==0x%-*x %s %s + %d"
            % (
                frame_num,
                addr_width,
                addr_for_printing,
                addr_width,
                fp,
                module_description,
                sym_ctx.GetSymbol().GetName(),
                offset,
            )
        )
    else:
        print(
            "%2d: pc==0x%-*x fp==0x%-*x %s"
            % (
                frame_num,
                addr_width,
                addr_for_printing,
                addr_width,
                fp,
                module_description,
            )
        )
    return sbaddr.GetModule()


# A simple stack walk algorithm that follows the frame chain.
# Returns a two-element list; the first element is a list of modules
# seen and the second element is a list of addresses seen during the backtrace.


def simple_backtrace(debugger):
    target = debugger.GetSelectedTarget()
    process = target.GetProcess()
    cur_thread = process.GetSelectedThread()

    initial_fp = cur_thread.GetFrameAtIndex(0).GetFP()

    # If the pseudoreg "fp" isn't recognized, on arm hardcode to r7 which is
    # correct for Darwin programs.
    if initial_fp == lldb.LLDB_INVALID_ADDRESS and target.triple[0:3] == "arm":
        for reggroup in cur_thread.GetFrameAtIndex(1).registers:
            if reggroup.GetName() == "General Purpose Registers":
                for reg in reggroup:
                    if reg.GetName() == "r7":
                        initial_fp = int(reg.GetValue(), 16)

    module_list = []
    address_list = [cur_thread.GetFrameAtIndex(0).GetPC()]
    this_module = backtrace_print_frame(
        target, 0, cur_thread.GetFrameAtIndex(0).GetPC(), initial_fp
    )
    print_stack_frame(process, initial_fp)
    print("")
    if this_module is not None:
        module_list.append(this_module)
    if cur_thread.GetNumFrames() < 2:
        return [module_list, address_list]

    cur_fp = process.ReadPointerFromMemory(initial_fp, lldb.SBError())
    cur_pc = process.ReadPointerFromMemory(
        initial_fp + process.GetAddressByteSize(), lldb.SBError()
    )

    frame_num = 1

    while (
        cur_pc != 0
        and cur_fp != 0
        and cur_pc != lldb.LLDB_INVALID_ADDRESS
        and cur_fp != lldb.LLDB_INVALID_ADDRESS
    ):
        address_list.append(cur_pc)
        this_module = backtrace_print_frame(target, frame_num, cur_pc, cur_fp)
        print_stack_frame(process, cur_fp)
        print("")
        if this_module is not None:
            module_list.append(this_module)
        frame_num = frame_num + 1
        next_pc = 0
        next_fp = 0
        if (
            target.triple[0:6] == "x86_64"
            or target.triple[0:4] == "i386"
            or target.triple[0:3] == "arm"
        ):
            error = lldb.SBError()
            next_pc = process.ReadPointerFromMemory(
                cur_fp + process.GetAddressByteSize(), error
            )
            if not error.Success():
                next_pc = 0
            next_fp = process.ReadPointerFromMemory(cur_fp, error)
            if not error.Success():
                next_fp = 0
        # Clear the 0th bit for arm frames - this indicates it is a thumb frame
        if target.triple[0:3] == "arm" and (next_pc & 1) == 1:
            next_pc = next_pc & ~1
        cur_pc = next_pc
        cur_fp = next_fp
    this_module = backtrace_print_frame(target, frame_num, cur_pc, cur_fp)
    print_stack_frame(process, cur_fp)
    print("")
    if this_module is not None:
        module_list.append(this_module)
    return [module_list, address_list]


def print_stack_frame(process, fp):
    if fp == 0 or fp == lldb.LLDB_INVALID_ADDRESS or fp == 1:
        return
    addr_size = process.GetAddressByteSize()
    addr = fp - (2 * addr_size)
    i = 0
    outline = "Stack frame from $fp-%d: " % (2 * addr_size)
    error = lldb.SBError()
    try:
        while i < 5 and error.Success():
            address = process.ReadPointerFromMemory(addr + (i * addr_size), error)
            outline += " 0x%x" % address
            i += 1
        print(outline)
    except Exception:
        return


def diagnose_unwind(debugger, command, result, dict):
    """
    Gather diagnostic information to help debug incorrect unwind (backtrace)
    behavior in lldb.  When there is a backtrace that doesn't look
    correct, run this command with the correct thread selected and a
    large amount of diagnostic information will be printed, it is likely
    to be helpful when reporting the problem.
    """

    command_args = shlex.split(command)
    parser = create_diagnose_unwind_options()
    try:
        (options, args) = parser.parse_args(command_args)
    except:
        return
    target = debugger.GetSelectedTarget()
    if target:
        process = target.GetProcess()
        if process:
            thread = process.GetSelectedThread()
            if thread:
                lldb_versions_match = re.search(
                    r"[lL][lL][dD][bB]-(\d+)([.](\d+))?([.](\d+))?",
                    debugger.GetVersionString(),
                )
                lldb_version = 0
                lldb_minor = 0
                if (
                    len(lldb_versions_match.groups()) >= 1
                    and lldb_versions_match.groups()[0]
                ):
                    lldb_major = int(lldb_versions_match.groups()[0])
                if (
                    len(lldb_versions_match.groups()) >= 5
                    and lldb_versions_match.groups()[4]
                ):
                    lldb_minor = int(lldb_versions_match.groups()[4])

                modules_seen = []
                addresses_seen = []

                print("LLDB version %s" % debugger.GetVersionString())
                print("Unwind diagnostics for thread %d" % thread.GetIndexID())
                print("")
                print(
                    "============================================================================================="
                )
                print("")
                print("OS plugin setting:")
                debugger.HandleCommand(
                    "settings show target.process.python-os-plugin-path"
                )
                print("")
                print("Live register context:")
                thread.SetSelectedFrame(0)
                debugger.HandleCommand("register read")
                print("")
                print(
                    "============================================================================================="
                )
                print("")
                print("lldb's unwind algorithm:")
                print("")
                frame_num = 0
                for frame in thread.frames:
                    if not frame.IsInlined():
                        this_module = backtrace_print_frame(
                            target, frame_num, frame.GetPC(), frame.GetFP()
                        )
                        print_stack_frame(process, frame.GetFP())
                        print("")
                        if this_module is not None:
                            modules_seen.append(this_module)
                        addresses_seen.append(frame.GetPC())
                        frame_num = frame_num + 1
                print("")
                print(
                    "============================================================================================="
                )
                print("")
                print("Simple stack walk algorithm:")
                print("")
                (module_list, address_list) = simple_backtrace(debugger)
                if module_list and module_list is not None:
                    modules_seen += module_list
                if address_list and address_list is not None:
                    addresses_seen = set(addresses_seen)
                    addresses_seen.update(set(address_list))

                print("")
                print(
                    "============================================================================================="
                )
                print("")
                print("Modules seen in stack walks:")
                print("")
                modules_already_seen = set()
                for module in modules_seen:
                    if (
                        module is not None
                        and module.GetFileSpec().GetFilename() is not None
                    ):
                        if (
                            not module.GetFileSpec().GetFilename()
                            in modules_already_seen
                        ):
                            debugger.HandleCommand(
                                "image list %s" % module.GetFileSpec().GetFilename()
                            )
                            modules_already_seen.add(module.GetFileSpec().GetFilename())

                print("")
                print(
                    "============================================================================================="
                )
                print("")
                print("Disassembly ofaddresses seen in stack walks:")
                print("")
                additional_addresses_to_disassemble = addresses_seen
                for frame in thread.frames:
                    if not frame.IsInlined():
                        print(
                            "--------------------------------------------------------------------------------------"
                        )
                        print("")
                        print(
                            "Disassembly of %s, frame %d, address 0x%x"
                            % (
                                frame.GetFunctionName(),
                                frame.GetFrameID(),
                                frame.GetPC(),
                            )
                        )
                        print("")
                        if (
                            target.triple[0:6] == "x86_64"
                            or target.triple[0:4] == "i386"
                        ):
                            debugger.HandleCommand(
                                "disassemble -F att -a 0x%x" % frame.GetPC()
                            )
                        else:
                            debugger.HandleCommand(
                                "disassemble -a 0x%x" % frame.GetPC()
                            )
                        if frame.GetPC() in additional_addresses_to_disassemble:
                            additional_addresses_to_disassemble.remove(frame.GetPC())

                for address in list(additional_addresses_to_disassemble):
                    print(
                        "--------------------------------------------------------------------------------------"
                    )
                    print("")
                    print("Disassembly of 0x%x" % address)
                    print("")
                    if target.triple[0:6] == "x86_64" or target.triple[0:4] == "i386":
                        debugger.HandleCommand("disassemble -F att -a 0x%x" % address)
                    else:
                        debugger.HandleCommand("disassemble -a 0x%x" % address)

                print("")
                print(
                    "============================================================================================="
                )
                print("")
                additional_addresses_to_show_unwind = addresses_seen
                for frame in thread.frames:
                    if not frame.IsInlined():
                        print(
                            "--------------------------------------------------------------------------------------"
                        )
                        print("")
                        print(
                            "Unwind instructions for %s, frame %d"
                            % (frame.GetFunctionName(), frame.GetFrameID())
                        )
                        print("")
                        debugger.HandleCommand(
                            'image show-unwind -a "0x%x"' % frame.GetPC()
                        )
                        if frame.GetPC() in additional_addresses_to_show_unwind:
                            additional_addresses_to_show_unwind.remove(frame.GetPC())

                for address in list(additional_addresses_to_show_unwind):
                    print(
                        "--------------------------------------------------------------------------------------"
                    )
                    print("")
                    print("Unwind instructions for 0x%x" % address)
                    print("")
                    debugger.HandleCommand('image show-unwind -a "0x%x"' % address)


def create_diagnose_unwind_options():
    usage = "usage: %prog"
    description = """Print diagnostic information about a thread backtrace which will help to debug unwind problems"""
    parser = optparse.OptionParser(
        description=description, prog="diagnose_unwind", usage=usage
    )
    return parser


def __lldb_init_module(debugger, internal_dict):
    debugger.HandleCommand(
        "command script add -o -f %s.diagnose_unwind diagnose-unwind" % __name__
    )
    print(
        'The "diagnose-unwind" command has been installed, type "help diagnose-unwind" for detailed help.'
    )

```

`lldb/embedded_interpreter.py`:

```py
import sys
if sys.version_info[0] < 3:
    import __builtin__ as builtins
else:
    import builtins
import code
import lldb
import traceback

try:
    import readline
    import rlcompleter
except ImportError:
    have_readline = False
except AttributeError:
    # This exception gets hit by the rlcompleter when Linux is using
    # the readline suppression import.
    have_readline = False
else:
    have_readline = True
    if 'libedit' in readline.__doc__:
        readline.parse_and_bind('bind ^I rl_complete')
    else:
        readline.parse_and_bind('tab: complete')

# When running one line, we might place the string to run in this string
# in case it would be hard to correctly escape a string's contents

g_run_one_line_str = None


def get_terminal_size(fd):
    try:
        import fcntl
        import termios
        import struct
        hw = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))
    except:
        hw = (0, 0)
    return hw


class LLDBExit(SystemExit):
    pass


def strip_and_check_exit(line):
    line = line.rstrip()
    if line in ('exit', 'quit'):
        raise LLDBExit
    return line


def readfunc(prompt):
    line = input(prompt)
    return strip_and_check_exit(line)


def readfunc_stdio(prompt):
    sys.stdout.write(prompt)
    sys.stdout.flush()
    line = sys.stdin.readline()
    # Readline always includes a trailing newline character unless the file
    # ends with an incomplete line. An empty line indicates EOF.
    if not line:
        raise EOFError
    return strip_and_check_exit(line)


def run_python_interpreter(local_dict):
    # Pass in the dictionary, for continuity from one session to the next.
    try:
        fd = sys.stdin.fileno()
        interacted = False
        if get_terminal_size(fd)[1] == 0:
            try:
                import termios
                old = termios.tcgetattr(fd)
                if old[3] & termios.ECHO:
                    # Need to turn off echoing and restore
                    new = termios.tcgetattr(fd)
                    new[3] = new[3] & ~termios.ECHO
                    try:
                        termios.tcsetattr(fd, termios.TCSADRAIN, new)
                        interacted = True
                        code.interact(
                            banner="Python Interactive Interpreter. To exit, type 'quit()', 'exit()'.",
                            readfunc=readfunc_stdio,
                            local=local_dict)
                    finally:
                        termios.tcsetattr(fd, termios.TCSADRAIN, old)
            except:
                pass
            # Don't need to turn off echoing
            if not interacted:
                code.interact(
                    banner="Python Interactive Interpreter. To exit, type 'quit()', 'exit()' or Ctrl-D.",
                    readfunc=readfunc_stdio,
                    local=local_dict)
        else:
            # We have a real interactive terminal
            code.interact(
                banner="Python Interactive Interpreter. To exit, type 'quit()', 'exit()' or Ctrl-D.",
                readfunc=readfunc,
                local=local_dict)
    except LLDBExit:
        pass
    except SystemExit as e:
        if e.code:
            print('Script exited with code %s' % e.code)


def run_one_line(local_dict, input_string):
    global g_run_one_line_str
    try:
        input_string = strip_and_check_exit(input_string)
        repl = code.InteractiveConsole(local_dict)
        if input_string:
            # A newline is appended to support one-line statements containing
            # control flow. For example "if True: print(1)" silently does
            # nothing, but works with a newline: "if True: print(1)\n".
            input_string += "\n"
            repl.runsource(input_string)
        elif g_run_one_line_str:
            repl.runsource(g_run_one_line_str)
    except LLDBExit:
        pass
    except SystemExit as e:
        if e.code:
            print('Script exited with code %s' % e.code)

```

`lldb/formatters/Logger.py`:

```py
import sys
import os.path
import inspect


class NopLogger:
    def __init__(self):
        pass

    def write(self, data):
        pass

    def flush(self):
        pass

    def close(self):
        pass


class StdoutLogger:
    def __init__(self):
        pass

    def write(self, data):
        print(data)

    def flush(self):
        pass

    def close(self):
        pass


class FileLogger:
    def __init__(self, name):
        self.file = None
        try:
            name = os.path.abspath(name)
            self.file = open(name, "a")
        except:
            try:
                self.file = open("formatters.log", "a")
            except:
                pass

    def write(self, data):
        if self.file is not None:
            print(data, file=self.file)
        else:
            print(data)

    def flush(self):
        if self.file is not None:
            self.file.flush()

    def close(self):
        if self.file is not None:
            self.file.close()
            self.file = None


# to enable logging:
# define lldb.formatters.Logger._lldb_formatters_debug_level to any number greater than 0
# if you define it to any value greater than 1, the log will be automatically flushed after each write (slower but should make sure most of the stuff makes it to the log even if we crash)
# if you define it to any value greater than 2, the calling function's details will automatically be logged (even slower, but provides additional details)
# if you need the log to go to a file instead of on screen, define
# lldb.formatters.Logger._lldb_formatters_debug_filename to a valid
# filename


class Logger:
    def __init__(self, autoflush=False, logcaller=False):
        global _lldb_formatters_debug_level
        global _lldb_formatters_debug_filename
        self.autoflush = autoflush
        want_log = False
        try:
            want_log = _lldb_formatters_debug_level > 0
        except:
            pass
        if not (want_log):
            self.impl = NopLogger()
            return
        want_file = False
        try:
            want_file = (
                _lldb_formatters_debug_filename is not None
                and _lldb_formatters_debug_filename != ""
                and _lldb_formatters_debug_filename != 0
            )
        except:
            pass
        if want_file:
            self.impl = FileLogger(_lldb_formatters_debug_filename)
        else:
            self.impl = StdoutLogger()
        try:
            self.autoflush = _lldb_formatters_debug_level > 1
        except:
            self.autoflush = autoflush
        want_caller_info = False
        try:
            want_caller_info = _lldb_formatters_debug_level > 2
        except:
            pass
        if want_caller_info:
            self._log_caller()

    def _log_caller(self):
        caller = inspect.stack()[2]
        try:
            if caller is not None and len(caller) > 3:
                self.write("Logging from function " + str(caller))
            else:
                self.write(
                    "Caller info not available - Required caller logging not possible"
                )
        finally:
            del caller  # needed per Python docs to avoid keeping objects alive longer than we care

    def write(self, data):
        self.impl.write(data)
        if self.autoflush:
            self.flush()

    def __rshift__(self, data):
        self.write(data)

    def flush(self):
        self.impl.flush()

    def close(self):
        self.impl.close()

```

`lldb/formatters/__init__.py`:

```py
__all__ = ["cache", "synth", "metrics", "attrib_fromdict", "Logger"]
for x in __all__:
  __import__('lldb.formatters.' + x)

def __lldb_init_module(debugger, internal_dict):
  import lldb
  for x in __all__:
    submodule = getattr(lldb.formatters, x)
    lldb_init = getattr(submodule, '__lldb_init_module', None)
    if lldb_init:
      lldb_init(debugger, internal_dict)

```

`lldb/formatters/attrib_fromdict.py`:

```py
"""
Objective-C runtime wrapper for use by LLDB Python formatters

Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
See https://llvm.org/LICENSE.txt for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
"""


class AttributesDictionary:
    def __init__(self, allow_reset=True):
        # need to do it this way to prevent endless recursion
        self.__dict__["_dictionary"] = {}
        self.__dict__["_allow_reset"] = allow_reset

    def __getattr__(self, name):
        if not self._check_exists(name):
            return None
        value = self._dictionary[name]
        return value

    def _set_impl(self, name, value):
        self._dictionary[name] = value

    def _check_exists(self, name):
        return name in self._dictionary

    def __setattr__(self, name, value):
        if self._allow_reset:
            self._set_impl(name, value)
        else:
            self.set_if_necessary(name, value)

    def set_if_necessary(self, name, value):
        if not self._check_exists(name):
            self._set_impl(name, value)
            return True
        return False

    def __len__(self):
        return len(self._dictionary)

```

`lldb/formatters/cache.py`:

```py
"""
Objective-C runtime wrapper for use by LLDB Python formatters

Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
See https://llvm.org/LICENSE.txt for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
"""
import lldb.formatters.metrics


class Cache:
    def __init__(self):
        self.data = {}
        self.statistics = lldb.formatters.metrics.Metrics()
        self.statistics.add_metric("hit")
        self.statistics.add_metric("miss")

    def look_for_key(self, key):
        if key in self.data:
            return True
        return False

    def add_item(self, key, value, ok_to_replace=True):
        if not (ok_to_replace) and self.look_for_key(key):
            return False
        self.data[key] = value
        return True

    def get_value(self, key, default=None):
        if self.look_for_key(key):
            self.statistics.metric_hit("hit", key)
            return self.data[key]
        else:
            self.statistics.metric_hit("miss", key)
            return default

```

`lldb/formatters/cpp/__init__.py`:

```py
__all__ = ["gnu_libstdcpp", "libcxx"]
for x in __all__:
  __import__('lldb.formatters.cpp.' + x)

def __lldb_init_module(debugger, internal_dict):
  import lldb
  for x in __all__:
    submodule = getattr(lldb.formatters.cpp, x)
    lldb_init = getattr(submodule, '__lldb_init_module', None)
    if lldb_init:
      lldb_init(debugger, internal_dict)

```

`lldb/formatters/cpp/gnu_libstdcpp.py`:

```py
import lldb.formatters.Logger

# C++ STL formatters for LLDB
# As there are many versions of the libstdc++, you are encouraged to look at the STL
# implementation for your platform before relying on these formatters to do the right
# thing for your setup


def ForwardListSummaryProvider(valobj, dict):
    list_capping_size = valobj.GetTarget().GetMaximumNumberOfChildrenToDisplay()
    text = "size=" + str(valobj.GetNumChildren())
    if valobj.GetNumChildren() > list_capping_size:
        return "(capped) " + text
    else:
        return text


def StdOptionalSummaryProvider(valobj, dict):
    has_value = valobj.GetNumChildren() > 0
    # We add wrapping spaces for consistency with the libcxx formatter
    return " Has Value=" + ("true" if has_value else "false") + " "


class StdOptionalSynthProvider:
    def __init__(self, valobj, dict):
        self.valobj = valobj

    def update(self):
        try:
            self.payload = self.valobj.GetChildMemberWithName("_M_payload")
            self.value = self.payload.GetChildMemberWithName("_M_payload")
            self.has_value = (
                self.payload.GetChildMemberWithName("_M_engaged").GetValueAsUnsigned(0)
                != 0
            )
        except:
            self.has_value = False
        return False

    def num_children(self):
        return 1 if self.has_value else 0

    def get_child_index(self, name):
        return 0

    def get_child_at_index(self, index):
        # some versions of libstdcpp have an additional _M_value child with the actual value
        possible_value = self.value.GetChildMemberWithName("_M_value")
        if possible_value.IsValid():
            return possible_value.Clone("Value")
        return self.value.Clone("Value")


"""
 This formatter can be applied to all
 unordered map-like structures (unordered_map, unordered_multimap, unordered_set, unordered_multiset)
"""


class StdUnorderedMapSynthProvider:
    def __init__(self, valobj, dict):
        self.valobj = valobj
        self.count = None
        self.kind = self.get_object_kind(valobj)

    def get_object_kind(self, valobj):
        type_name = valobj.GetTypeName()
        return "set" if "set" in type_name else "map"

    def extract_type(self):
        type = self.valobj.GetType()
        # type of std::pair<key, value> is the first template
        # argument type of the 4th template argument to std::map and
        # 3rd template argument for std::set. That's why
        # we need to know kind of the object
        template_arg_num = 4 if self.kind == "map" else 3
        allocator_type = type.GetTemplateArgumentType(template_arg_num)
        data_type = allocator_type.GetTemplateArgumentType(0)
        return data_type

    def update(self):
        # preemptively setting this to None - we might end up changing our mind
        # later
        self.count = None
        try:
            self.head = self.valobj.GetChildMemberWithName("_M_h")
            self.before_begin = self.head.GetChildMemberWithName("_M_before_begin")
            self.next = self.before_begin.GetChildMemberWithName("_M_nxt")
            self.data_type = self.extract_type()
            self.skip_size = self.next.GetType().GetByteSize()
            self.data_size = self.data_type.GetByteSize()
            if (not self.data_type.IsValid()) or (not self.next.IsValid()):
                self.count = 0
        except:
            self.count = 0
        return False

    def get_child_index(self, name):
        try:
            return int(name.lstrip("[").rstrip("]"))
        except:
            return -1

    def get_child_at_index(self, index):
        logger = lldb.formatters.Logger.Logger()
        logger >> "Being asked to fetch child[" + str(index) + "]"
        if index < 0:
            return None
        if index >= self.num_children():
            return None
        try:
            offset = index
            current = self.next
            while offset > 0:
                current = current.GetChildMemberWithName("_M_nxt")
                offset = offset - 1
            return current.CreateChildAtOffset(
                "[" + str(index) + "]", self.skip_size, self.data_type
            )

        except:
            logger >> "Cannot get child"
            return None

    def num_children(self):
        if self.count is None:
            self.count = self.num_children_impl()
        return self.count

    def num_children_impl(self):
        logger = lldb.formatters.Logger.Logger()
        try:
            count = self.head.GetChildMemberWithName(
                "_M_element_count"
            ).GetValueAsUnsigned(0)
            return count
        except:
            logger >> "Could not determine the size"
            return 0


class AbstractListSynthProvider:
    def __init__(self, valobj, dict, has_prev):
        """
        :param valobj: The value object of the list
        :param dict: A dict with metadata provided by LLDB
        :param has_prev: Whether the list supports a 'prev' pointer besides a 'next' one
        """
        logger = lldb.formatters.Logger.Logger()
        self.valobj = valobj
        self.count = None
        self.has_prev = has_prev
        self.list_capping_size = (
            self.valobj.GetTarget().GetMaximumNumberOfChildrenToDisplay()
        )
        logger >> "Providing synthetic children for a list named " + str(
            valobj.GetName()
        )

    def next_node(self, node):
        logger = lldb.formatters.Logger.Logger()
        return node.GetChildMemberWithName("_M_next")

    def is_valid(self, node):
        logger = lldb.formatters.Logger.Logger()
        valid = self.value(self.next_node(node)) != self.get_end_of_list_address()
        if valid:
            logger >> "%s is valid" % str(self.valobj.GetName())
        else:
            logger >> "synthetic value is not valid"
        return valid

    def value(self, node):
        logger = lldb.formatters.Logger.Logger()
        value = node.GetValueAsUnsigned()
        logger >> "synthetic value for {}: {}".format(str(self.valobj.GetName()), value)
        return value

    # Floyd's cycle-finding algorithm
    # try to detect if this list has a loop
    def has_loop(self):
        global _list_uses_loop_detector
        logger = lldb.formatters.Logger.Logger()
        if not _list_uses_loop_detector:
            logger >> "Asked not to use loop detection"
            return False
        slow = self.next
        fast1 = self.next
        fast2 = self.next
        while self.is_valid(slow):
            slow_value = self.value(slow)
            fast1 = self.next_node(fast2)
            fast2 = self.next_node(fast1)
            if self.value(fast1) == slow_value or self.value(fast2) == slow_value:
                return True
            slow = self.next_node(slow)
        return False

    def num_children(self):
        logger = lldb.formatters.Logger.Logger()
        if self.count is None:
            # libstdc++ 6.0.21 added dedicated count field.
            count_child = self.node.GetChildMemberWithName("_M_data")
            if count_child and count_child.IsValid():
                self.count = count_child.GetValueAsUnsigned(0)
            if self.count is None:
                self.count = self.num_children_impl()
        return self.count

    def num_children_impl(self):
        logger = lldb.formatters.Logger.Logger()
        try:
            # After a std::list has been initialized, both next and prev will
            # be non-NULL
            next_val = self.next.GetValueAsUnsigned(0)
            if next_val == 0:
                return 0
            if self.has_loop():
                return 0
            if self.has_prev:
                prev_val = self.prev.GetValueAsUnsigned(0)
                if prev_val == 0:
                    return 0
                if next_val == self.node_address:
                    return 0
                if next_val == prev_val:
                    return 1
            size = 1
            current = self.next
            while (
                current.GetChildMemberWithName("_M_next").GetValueAsUnsigned(0)
                != self.get_end_of_list_address()
            ):
                current = current.GetChildMemberWithName("_M_next")
                if not current.IsValid():
                    break
                size = size + 1
                if size >= self.list_capping_size:
                    break

            return size
        except:
            logger >> "Error determining the size"
            return 0

    def get_child_index(self, name):
        logger = lldb.formatters.Logger.Logger()
        try:
            return int(name.lstrip("[").rstrip("]"))
        except:
            return -1

    def get_child_at_index(self, index):
        logger = lldb.formatters.Logger.Logger()
        logger >> "Fetching child " + str(index)
        if index < 0:
            return None
        if index >= self.num_children():
            return None
        try:
            offset = index
            current = self.next
            while offset > 0:
                current = current.GetChildMemberWithName("_M_next")
                offset = offset - 1
            # C++ lists store the data of a node after its pointers. In the case of a forward list, there's just one pointer (next), and
            # in the case of a double-linked list, there's an additional pointer (prev).
            return current.CreateChildAtOffset(
                "[" + str(index) + "]",
                (2 if self.has_prev else 1) * current.GetType().GetByteSize(),
                self.data_type,
            )
        except:
            return None

    def extract_type(self):
        logger = lldb.formatters.Logger.Logger()
        list_type = self.valobj.GetType().GetUnqualifiedType()
        if list_type.IsReferenceType():
            list_type = list_type.GetDereferencedType()
        if list_type.GetNumberOfTemplateArguments() > 0:
            return list_type.GetTemplateArgumentType(0)
        return lldb.SBType()

    def update(self):
        logger = lldb.formatters.Logger.Logger()
        # preemptively setting this to None - we might end up changing our mind
        # later
        self.count = None
        try:
            self.impl = self.valobj.GetChildMemberWithName("_M_impl")
            self.data_type = self.extract_type()
            if (not self.data_type.IsValid()) or (not self.impl.IsValid()):
                self.count = 0
            elif not self.updateNodes():
                self.count = 0
            else:
                self.data_size = self.data_type.GetByteSize()
        except:
            self.count = 0
        return False

    """
    Method is used to extract the list pointers into the variables (e.g self.node, self.next, and optionally to self.prev)
    and is mandatory to be overriden in each AbstractListSynthProvider subclass.
    This should return True or False depending on wheter it found valid data.
    """

    def updateNodes(self):
        raise NotImplementedError

    def has_children(self):
        return True

    """
     Method is used to identify if a node traversal has reached its end
     and is mandatory to be overriden in each AbstractListSynthProvider subclass
    """

    def get_end_of_list_address(self):
        raise NotImplementedError


class StdForwardListSynthProvider(AbstractListSynthProvider):
    def __init__(self, valobj, dict):
        has_prev = False
        super().__init__(valobj, dict, has_prev)

    def updateNodes(self):
        self.node = self.impl.GetChildMemberWithName("_M_head")
        self.next = self.node.GetChildMemberWithName("_M_next")
        if (not self.node.IsValid()) or (not self.next.IsValid()):
            return False
        return True

    def get_end_of_list_address(self):
        return 0


class StdListSynthProvider(AbstractListSynthProvider):
    def __init__(self, valobj, dict):
        has_prev = True
        super().__init__(valobj, dict, has_prev)

    def updateNodes(self):
        self.node_address = self.valobj.AddressOf().GetValueAsUnsigned(0)
        self.node = self.impl.GetChildMemberWithName("_M_node")
        self.prev = self.node.GetChildMemberWithName("_M_prev")
        self.next = self.node.GetChildMemberWithName("_M_next")
        if (
            self.node_address == 0
            or (not self.node.IsValid())
            or (not self.next.IsValid())
            or (not self.prev.IsValid())
        ):
            return False
        return True

    def get_end_of_list_address(self):
        return self.node_address


class StdVectorSynthProvider:
    class StdVectorImplementation(object):
        def __init__(self, valobj):
            self.valobj = valobj
            self.count = None

        def num_children(self):
            if self.count is None:
                self.count = self.num_children_impl()
            return self.count

        def num_children_impl(self):
            try:
                start_val = self.start.GetValueAsUnsigned(0)
                finish_val = self.finish.GetValueAsUnsigned(0)
                end_val = self.end.GetValueAsUnsigned(0)
                # Before a vector has been constructed, it will contain bad values
                # so we really need to be careful about the length we return since
                # uninitialized data can cause us to return a huge number. We need
                # to also check for any of the start, finish or end of storage values
                # being zero (NULL). If any are, then this vector has not been
                # initialized yet and we should return zero

                # Make sure nothing is NULL
                if start_val == 0 or finish_val == 0 or end_val == 0:
                    return 0
                # Make sure start is less than finish
                if start_val >= finish_val:
                    return 0
                # Make sure finish is less than or equal to end of storage
                if finish_val > end_val:
                    return 0

                # if we have a struct (or other data type that the compiler pads to native word size)
                # this check might fail, unless the sizeof() we get is itself incremented to take the
                # padding bytes into account - on current clang it looks like
                # this is the case
                num_children = finish_val - start_val
                if (num_children % self.data_size) != 0:
                    return 0
                else:
                    num_children = num_children // self.data_size
                return num_children
            except:
                return 0

        def get_child_at_index(self, index):
            logger = lldb.formatters.Logger.Logger()
            logger >> "Retrieving child " + str(index)
            if index < 0:
                return None
            if index >= self.num_children():
                return None
            try:
                offset = index * self.data_size
                return self.start.CreateChildAtOffset(
                    "[" + str(index) + "]", offset, self.data_type
                )
            except:
                return None

        def update(self):
            # preemptively setting this to None - we might end up changing our
            # mind later
            self.count = None
            try:
                impl = self.valobj.GetChildMemberWithName("_M_impl")
                self.start = impl.GetChildMemberWithName("_M_start")
                self.finish = impl.GetChildMemberWithName("_M_finish")
                self.end = impl.GetChildMemberWithName("_M_end_of_storage")
                self.data_type = self.start.GetType().GetPointeeType()
                self.data_size = self.data_type.GetByteSize()
                # if any of these objects is invalid, it means there is no
                # point in trying to fetch anything
                if (
                    self.start.IsValid()
                    and self.finish.IsValid()
                    and self.end.IsValid()
                    and self.data_type.IsValid()
                ):
                    self.count = None
                else:
                    self.count = 0
            except:
                self.count = 0
            return False

    class StdVBoolImplementation(object):
        def __init__(self, valobj, bool_type):
            self.valobj = valobj
            self.bool_type = bool_type
            self.valid = False

        def num_children(self):
            if self.valid:
                start = self.start_p.GetValueAsUnsigned(0)
                finish = self.finish_p.GetValueAsUnsigned(0)
                offset = self.offset.GetValueAsUnsigned(0)
                if finish >= start:
                    return (finish - start) * 8 + offset
            return 0

        def get_child_at_index(self, index):
            if index >= self.num_children():
                return None
            element_type = self.start_p.GetType().GetPointeeType()
            element_bits = 8 * element_type.GetByteSize()
            element_offset = (index // element_bits) * element_type.GetByteSize()
            bit_offset = index % element_bits
            element = self.start_p.CreateChildAtOffset(
                "[" + str(index) + "]", element_offset, element_type
            )
            bit = element.GetValueAsUnsigned(0) & (1 << bit_offset)
            if bit != 0:
                value_expr = "(bool)true"
            else:
                value_expr = "(bool)false"
            return self.valobj.CreateValueFromExpression("[%d]" % index, value_expr)

        def update(self):
            try:
                m_impl = self.valobj.GetChildMemberWithName("_M_impl")
                self.m_start = m_impl.GetChildMemberWithName("_M_start")
                self.m_finish = m_impl.GetChildMemberWithName("_M_finish")
                self.start_p = self.m_start.GetChildMemberWithName("_M_p")
                self.finish_p = self.m_finish.GetChildMemberWithName("_M_p")
                self.offset = self.m_finish.GetChildMemberWithName("_M_offset")
                if (
                    self.offset.IsValid()
                    and self.start_p.IsValid()
                    and self.finish_p.IsValid()
                ):
                    self.valid = True
                else:
                    self.valid = False
            except:
                self.valid = False
            return False

    def __init__(self, valobj, dict):
        logger = lldb.formatters.Logger.Logger()
        first_template_arg_type = valobj.GetType().GetTemplateArgumentType(0)
        if str(first_template_arg_type.GetName()) == "bool":
            self.impl = self.StdVBoolImplementation(valobj, first_template_arg_type)
        else:
            self.impl = self.StdVectorImplementation(valobj)
        logger >> "Providing synthetic children for a vector named " + str(
            valobj.GetName()
        )

    def num_children(self):
        return self.impl.num_children()

    def get_child_index(self, name):
        try:
            return int(name.lstrip("[").rstrip("]"))
        except:
            return -1

    def get_child_at_index(self, index):
        return self.impl.get_child_at_index(index)

    def update(self):
        return self.impl.update()

    def has_children(self):
        return True

    """
     This formatter can be applied to all
     map-like structures (map, multimap, set, multiset)
    """


class StdMapLikeSynthProvider:
    def __init__(self, valobj, dict):
        logger = lldb.formatters.Logger.Logger()
        self.valobj = valobj
        self.count = None
        self.kind = self.get_object_kind(valobj)
        (
            logger
            >> "Providing synthetic children for a "
            + self.kind
            + " named "
            + str(valobj.GetName())
        )

    def get_object_kind(self, valobj):
        type_name = valobj.GetTypeName()
        for kind in ["multiset", "multimap", "set", "map"]:
            if kind in type_name:
                return kind
        return type_name

    # we need this function as a temporary workaround for rdar://problem/10801549
    # which prevents us from extracting the std::pair<K,V> SBType out of the template
    # arguments for _Rep_Type _M_t in the object itself - because we have to make up the
    # typename and then find it, we may hit the situation were std::string has multiple
    # names but only one is actually referenced in the debug information. hence, we need
    # to replace the longer versions of std::string with the shorter one in order to be able
    # to find the type name
    def fixup_class_name(self, class_name):
        logger = lldb.formatters.Logger.Logger()
        if (
            class_name
            == "std::basic_string<char, std::char_traits<char>, std::allocator<char> >"
        ):
            return "std::basic_string<char>", True
        if (
            class_name
            == "basic_string<char, std::char_traits<char>, std::allocator<char> >"
        ):
            return "std::basic_string<char>", True
        if (
            class_name
            == "std::basic_string<char, std::char_traits<char>, std::allocator<char> >"
        ):
            return "std::basic_string<char>", True
        if (
            class_name
            == "basic_string<char, std::char_traits<char>, std::allocator<char> >"
        ):
            return "std::basic_string<char>", True
        return class_name, False

    def update(self):
        logger = lldb.formatters.Logger.Logger()
        # preemptively setting this to None - we might end up changing our mind
        # later
        self.count = None
        try:
            # we will set this to True if we find out that discovering a node in the object takes more steps than the overall size of the RB tree
            # if this gets set to True, then we will merrily return None for
            # any child from that moment on
            self.garbage = False
            self.Mt = self.valobj.GetChildMemberWithName("_M_t")
            self.Mimpl = self.Mt.GetChildMemberWithName("_M_impl")
            self.Mheader = self.Mimpl.GetChildMemberWithName("_M_header")
            if not self.Mheader.IsValid():
                self.count = 0
            else:
                map_type = self.valobj.GetType()
                if map_type.IsReferenceType():
                    logger >> "Dereferencing type"
                    map_type = map_type.GetDereferencedType()

                # Get the type of std::pair<key, value>. It is the first template
                # argument type of the 4th template argument to std::map.
                allocator_type = map_type.GetTemplateArgumentType(3)
                self.data_type = allocator_type.GetTemplateArgumentType(0)
                if not self.data_type:
                    # GCC does not emit DW_TAG_template_type_parameter for
                    # std::allocator<...>. For such a case, get the type of
                    # std::pair from a member of std::map.
                    rep_type = self.valobj.GetChildMemberWithName("_M_t").GetType()
                    self.data_type = (
                        rep_type.GetTypedefedType().GetTemplateArgumentType(1)
                    )

                # from libstdc++ implementation of _M_root for rbtree
                self.Mroot = self.Mheader.GetChildMemberWithName("_M_parent")
                self.data_size = self.data_type.GetByteSize()
                self.skip_size = self.Mheader.GetType().GetByteSize()
        except:
            self.count = 0
        return False

    def num_children(self):
        logger = lldb.formatters.Logger.Logger()
        if self.count is None:
            self.count = self.num_children_impl()
        return self.count

    def num_children_impl(self):
        logger = lldb.formatters.Logger.Logger()
        try:
            root_ptr_val = self.node_ptr_value(self.Mroot)
            if root_ptr_val == 0:
                return 0
            count = self.Mimpl.GetChildMemberWithName(
                "_M_node_count"
            ).GetValueAsUnsigned(0)
            logger >> "I have " + str(count) + " children available"
            return count
        except:
            return 0

    def get_child_index(self, name):
        logger = lldb.formatters.Logger.Logger()
        try:
            return int(name.lstrip("[").rstrip("]"))
        except:
            return -1

    def get_child_at_index(self, index):
        logger = lldb.formatters.Logger.Logger()
        logger >> "Being asked to fetch child[" + str(index) + "]"
        if index < 0:
            return None
        if index >= self.num_children():
            return None
        if self.garbage:
            logger >> "Returning None since we are a garbage tree"
            return None
        try:
            offset = index
            current = self.left(self.Mheader)
            while offset > 0:
                current = self.increment_node(current)
                offset = offset - 1
            # skip all the base stuff and get at the data
            return current.CreateChildAtOffset(
                "[" + str(index) + "]", self.skip_size, self.data_type
            )
        except:
            return None

    # utility functions
    def node_ptr_value(self, node):
        logger = lldb.formatters.Logger.Logger()
        return node.GetValueAsUnsigned(0)

    def right(self, node):
        logger = lldb.formatters.Logger.Logger()
        return node.GetChildMemberWithName("_M_right")

    def left(self, node):
        logger = lldb.formatters.Logger.Logger()
        return node.GetChildMemberWithName("_M_left")

    def parent(self, node):
        logger = lldb.formatters.Logger.Logger()
        return node.GetChildMemberWithName("_M_parent")

    # from libstdc++ implementation of iterator for rbtree
    def increment_node(self, node):
        logger = lldb.formatters.Logger.Logger()
        max_steps = self.num_children()
        if self.node_ptr_value(self.right(node)) != 0:
            x = self.right(node)
            max_steps -= 1
            while self.node_ptr_value(self.left(x)) != 0:
                x = self.left(x)
                max_steps -= 1
                logger >> str(max_steps) + " more to go before giving up"
                if max_steps <= 0:
                    self.garbage = True
                    return None
            return x
        else:
            x = node
            y = self.parent(x)
            max_steps -= 1
            while self.node_ptr_value(x) == self.node_ptr_value(self.right(y)):
                x = y
                y = self.parent(y)
                max_steps -= 1
                logger >> str(max_steps) + " more to go before giving up"
                if max_steps <= 0:
                    self.garbage = True
                    return None
            if self.node_ptr_value(self.right(x)) != self.node_ptr_value(y):
                x = y
            return x

    def has_children(self):
        return True


_list_uses_loop_detector = True


class StdDequeSynthProvider:
    def __init__(self, valobj, d):
        self.valobj = valobj
        self.pointer_size = self.valobj.GetProcess().GetAddressByteSize()
        self.count = None
        self.block_size = -1
        self.element_size = -1
        self.find_block_size()

    def find_block_size(self):
        # in order to use the deque we must have the block size, or else
        # it's impossible to know what memory addresses are valid
        self.element_type = self.valobj.GetType().GetTemplateArgumentType(0)
        if not self.element_type.IsValid():
            return
        self.element_size = self.element_type.GetByteSize()
        # The block size (i.e. number of elements per subarray) is defined in
        # this piece of code, so we need to replicate it.
        #
        # #define _GLIBCXX_DEQUE_BUF_SIZE 512
        #
        # return (__size < _GLIBCXX_DEQUE_BUF_SIZE
        #   ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1));
        if self.element_size < 512:
            self.block_size = 512 // self.element_size
        else:
            self.block_size = 1

    def num_children(self):
        if self.count is None:
            return 0
        return self.count

    def has_children(self):
        return True

    def get_child_index(self, name):
        try:
            return int(name.lstrip("[").rstrip("]"))
        except:
            return -1

    def get_child_at_index(self, index):
        if index < 0 or self.count is None:
            return None
        if index >= self.num_children():
            return None
        try:
            name = "[" + str(index) + "]"
            # We first look for the element in the first subarray,
            # which might be incomplete.
            if index < self.first_node_size:
                # The following statement is valid because self.first_elem is the pointer
                # to the first element
                return self.first_elem.CreateChildAtOffset(
                    name, index * self.element_size, self.element_type
                )

            # Now the rest of the subarrays except for maybe the last one
            # are going to be complete, so the final expression is simpler
            i, j = divmod(index - self.first_node_size, self.block_size)

            # We first move to the beginning of the node/subarray were our element is
            node = self.start_node.CreateChildAtOffset(
                "",
                (1 + i) * self.valobj.GetProcess().GetAddressByteSize(),
                self.element_type.GetPointerType(),
            )
            return node.CreateChildAtOffset(
                name, j * self.element_size, self.element_type
            )

        except:
            return None

    def update(self):
        logger = lldb.formatters.Logger.Logger()
        self.count = 0
        try:
            # A deque is effectively a two-dim array, with fixed width.
            # However, only a subset of this memory contains valid data
            # since a deque may have some slack at the front and back in
            # order to have O(1) insertion at both ends.
            # The rows in active use are delimited by '_M_start' and
            # '_M_finish'.
            #
            # To find the elements that are actually constructed, the 'start'
            # variable tells which element in this NxM array is the 0th
            # one.
            if self.block_size < 0 or self.element_size < 0:
                return False

            count = 0

            impl = self.valobj.GetChildMemberWithName("_M_impl")

            # we calculate the size of the first node (i.e. first internal array)
            self.start = impl.GetChildMemberWithName("_M_start")
            self.start_node = self.start.GetChildMemberWithName("_M_node")
            first_node_address = self.start_node.GetValueAsUnsigned(0)
            first_node_last_elem = self.start.GetChildMemberWithName(
                "_M_last"
            ).GetValueAsUnsigned(0)
            self.first_elem = self.start.GetChildMemberWithName("_M_cur")
            first_node_first_elem = self.first_elem.GetValueAsUnsigned(0)

            finish = impl.GetChildMemberWithName("_M_finish")
            last_node_address = finish.GetChildMemberWithName(
                "_M_node"
            ).GetValueAsUnsigned(0)
            last_node_first_elem = finish.GetChildMemberWithName(
                "_M_first"
            ).GetValueAsUnsigned(0)
            last_node_last_elem = finish.GetChildMemberWithName(
                "_M_cur"
            ).GetValueAsUnsigned(0)

            if (
                first_node_first_elem == 0
                or first_node_last_elem == 0
                or first_node_first_elem > first_node_last_elem
            ):
                return False
            if (
                last_node_first_elem == 0
                or last_node_last_elem == 0
                or last_node_first_elem > last_node_last_elem
            ):
                return False

            if last_node_address == first_node_address:
                self.first_node_size = (
                    last_node_last_elem - first_node_first_elem
                ) // self.element_size
                count += self.first_node_size
            else:
                self.first_node_size = (
                    first_node_last_elem - first_node_first_elem
                ) // self.element_size
                count += self.first_node_size

                # we calculate the size of the last node
                finish = impl.GetChildMemberWithName("_M_finish")
                last_node_address = finish.GetChildMemberWithName(
                    "_M_node"
                ).GetValueAsUnsigned(0)
                count += (
                    last_node_last_elem - last_node_first_elem
                ) // self.element_size

                # we calculate the size of the intermediate nodes
                num_intermediate_nodes = (
                    last_node_address - first_node_address - 1
                ) // self.valobj.GetProcess().GetAddressByteSize()
                count += self.block_size * num_intermediate_nodes
            self.count = count
        except:
            pass
        return False

```

`lldb/formatters/cpp/libcxx.py`:

```py
import lldb
import lldb.formatters.Logger

# libcxx STL formatters for LLDB
# These formatters are based upon the implementation of libc++ that
# ships with current releases of OS X - They will not work for other implementations
# of the standard C++ library - and they are bound to use the
# libc++-specific namespace

# the std::string summary is just an example for your convenience
# the actual summary that LLDB uses is C++ code inside the debugger's own core

# this could probably be made more efficient but since it only reads a handful of bytes at a time
# we probably don't need to worry too much about this for the time being


def make_string(F, L):
    strval = ""
    G = F.GetData().uint8
    for X in range(L):
        V = G[X]
        if V == 0:
            break
        strval = strval + chr(V % 256)
    return '"' + strval + '"'


# if we ever care about big-endian, these two functions might need to change


def is_short_string(value):
    return True if (value & 1) == 0 else False


def extract_short_size(value):
    return (value >> 1) % 256


# some of the members of libc++ std::string are anonymous or have internal names that convey
# no external significance - we access them by index since this saves a name lookup that would add
# no information for readers of the code, but when possible try to use
# meaningful variable names


def stdstring_SummaryProvider(valobj, dict):
    logger = lldb.formatters.Logger.Logger()
    r = valobj.GetChildAtIndex(0)
    B = r.GetChildAtIndex(0)
    first = B.GetChildAtIndex(0)
    D = first.GetChildAtIndex(0)
    l = D.GetChildAtIndex(0)
    s = D.GetChildAtIndex(1)
    D20 = s.GetChildAtIndex(0)
    size_mode = D20.GetChildAtIndex(0).GetValueAsUnsigned(0)
    if is_short_string(size_mode):
        size = extract_short_size(size_mode)
        return make_string(s.GetChildAtIndex(1), size)
    else:
        data_ptr = l.GetChildAtIndex(2)
        size_vo = l.GetChildAtIndex(1)
        # the NULL terminator must be accounted for
        size = size_vo.GetValueAsUnsigned(0) + 1
        if size <= 1 or size is None:  # should never be the case
            return '""'
        try:
            data = data_ptr.GetPointeeData(0, size)
        except:
            return '""'
        error = lldb.SBError()
        strval = data.GetString(error, 0)
        if error.Fail():
            return "<error:" + error.GetCString() + ">"
        else:
            return '"' + strval + '"'


class stdvector_SynthProvider:
    def __init__(self, valobj, dict):
        logger = lldb.formatters.Logger.Logger()
        self.valobj = valobj

    def num_children(self):
        logger = lldb.formatters.Logger.Logger()
        try:
            start_val = self.start.GetValueAsUnsigned(0)
            finish_val = self.finish.GetValueAsUnsigned(0)
            # Before a vector has been constructed, it will contain bad values
            # so we really need to be careful about the length we return since
            # uninitialized data can cause us to return a huge number. We need
            # to also check for any of the start, finish or end of storage values
            # being zero (NULL). If any are, then this vector has not been
            # initialized yet and we should return zero

            # Make sure nothing is NULL
            if start_val == 0 or finish_val == 0:
                return 0
            # Make sure start is less than finish
            if start_val >= finish_val:
                return 0

            num_children = finish_val - start_val
            if (num_children % self.data_size) != 0:
                return 0
            else:
                num_children = num_children / self.data_size
            return num_children
        except:
            return 0

    def get_child_index(self, name):
        logger = lldb.formatters.Logger.Logger()
        try:
            return int(name.lstrip("[").rstrip("]"))
        except:
            return -1

    def get_child_at_index(self, index):
        logger = lldb.formatters.Logger.Logger()
        logger >> "Retrieving child " + str(index)
        if index < 0:
            return None
        if index >= self.num_children():
            return None
        try:
            offset = index * self.data_size
            return self.start.CreateChildAtOffset(
                "[" + str(index) + "]", offset, self.data_type
            )
        except:
            return None

    def update(self):
        logger = lldb.formatters.Logger.Logger()
        try:
            self.start = self.valobj.GetChildMemberWithName("__begin_")
            self.finish = self.valobj.GetChildMemberWithName("__end_")
            # the purpose of this field is unclear, but it is the only field whose type is clearly T* for a vector<T>
            # if this ends up not being correct, we can use the APIs to get at
            # template arguments
            data_type_finder = self.valobj.GetChildMemberWithName(
                "__end_cap_"
            ).GetChildMemberWithName("__first_")
            self.data_type = data_type_finder.GetType().GetPointeeType()
            self.data_size = self.data_type.GetByteSize()
        except:
            pass

    def has_children(self):
        return True


# Just an example: the actual summary is produced by a summary string:
# size=${svar%#}


def stdvector_SummaryProvider(valobj, dict):
    prov = stdvector_SynthProvider(valobj, None)
    return "size=" + str(prov.num_children())


class stdlist_entry:
    def __init__(self, entry):
        logger = lldb.formatters.Logger.Logger()
        self.entry = entry

    def _next_impl(self):
        logger = lldb.formatters.Logger.Logger()
        return stdlist_entry(self.entry.GetChildMemberWithName("__next_"))

    def _prev_impl(self):
        logger = lldb.formatters.Logger.Logger()
        return stdlist_entry(self.entry.GetChildMemberWithName("__prev_"))

    def _value_impl(self):
        logger = lldb.formatters.Logger.Logger()
        return self.entry.GetValueAsUnsigned(0)

    def _isnull_impl(self):
        logger = lldb.formatters.Logger.Logger()
        return self._value_impl() == 0

    def _sbvalue_impl(self):
        logger = lldb.formatters.Logger.Logger()
        return self.entry

    next = property(_next_impl, None)
    value = property(_value_impl, None)
    is_null = property(_isnull_impl, None)
    sbvalue = property(_sbvalue_impl, None)


class stdlist_iterator:
    def increment_node(self, node):
        logger = lldb.formatters.Logger.Logger()
        if node.is_null:
            return None
        return node.next

    def __init__(self, node):
        logger = lldb.formatters.Logger.Logger()
        # we convert the SBValue to an internal node object on entry
        self.node = stdlist_entry(node)

    def value(self):
        logger = lldb.formatters.Logger.Logger()
        return self.node.sbvalue  # and return the SBValue back on exit

    def next(self):
        logger = lldb.formatters.Logger.Logger()
        node = self.increment_node(self.node)
        if node is not None and node.sbvalue.IsValid() and not (node.is_null):
            self.node = node
            return self.value()
        else:
            return None

    def advance(self, N):
        logger = lldb.formatters.Logger.Logger()
        if N < 0:
            return None
        if N == 0:
            return self.value()
        if N == 1:
            return self.next()
        while N > 0:
            self.next()
            N = N - 1
        return self.value()


class stdlist_SynthProvider:
    def __init__(self, valobj, dict):
        logger = lldb.formatters.Logger.Logger()
        self.valobj = valobj
        self.count = None

    def next_node(self, node):
        logger = lldb.formatters.Logger.Logger()
        return node.GetChildMemberWithName("__next_")

    def value(self, node):
        logger = lldb.formatters.Logger.Logger()
        return node.GetValueAsUnsigned()

    # Floyd's cycle-finding algorithm
    # try to detect if this list has a loop
    def has_loop(self):
        global _list_uses_loop_detector
        logger = lldb.formatters.Logger.Logger()
        if not _list_uses_loop_detector:
            logger >> "Asked not to use loop detection"
            return False
        slow = stdlist_entry(self.head)
        fast1 = stdlist_entry(self.head)
        fast2 = stdlist_entry(self.head)
        while slow.next.value != self.node_address:
            slow_value = slow.value
            fast1 = fast2.next
            fast2 = fast1.next
            if fast1.value == slow_value or fast2.value == slow_value:
                return True
            slow = slow.next
        return False

    def num_children(self):
        global _list_capping_size
        logger = lldb.formatters.Logger.Logger()
        if self.count is None:
            self.count = self.num_children_impl()
            if self.count > _list_capping_size:
                self.count = _list_capping_size
        return self.count

    def num_children_impl(self):
        global _list_capping_size
        logger = lldb.formatters.Logger.Logger()
        try:
            next_val = self.head.GetValueAsUnsigned(0)
            prev_val = self.tail.GetValueAsUnsigned(0)
            # After a std::list has been initialized, both next and prev will
            # be non-NULL
            if next_val == 0 or prev_val == 0:
                return 0
            if next_val == self.node_address:
                return 0
            if next_val == prev_val:
                return 1
            if self.has_loop():
                return 0
            size = 2
            current = stdlist_entry(self.head)
            while current.next.value != self.node_address:
                size = size + 1
                current = current.next
                if size > _list_capping_size:
                    return _list_capping_size
            return size - 1
        except:
            return 0

    def get_child_index(self, name):
        logger = lldb.formatters.Logger.Logger()
        try:
            return int(name.lstrip("[").rstrip("]"))
        except:
            return -1

    def get_child_at_index(self, index):
        logger = lldb.formatters.Logger.Logger()
        logger >> "Fetching child " + str(index)
        if index < 0:
            return None
        if index >= self.num_children():
            return None
        try:
            current = stdlist_iterator(self.head)
            current = current.advance(index)
            # we do not return __value_ because then all our children would be named __value_
            # we need to make a copy of __value__ with the right name -
            # unfortunate
            obj = current.GetChildMemberWithName("__value_")
            obj_data = obj.GetData()
            return self.valobj.CreateValueFromData(
                "[" + str(index) + "]", obj_data, self.data_type
            )
        except:
            return None

    def extract_type(self):
        logger = lldb.formatters.Logger.Logger()
        list_type = self.valobj.GetType().GetUnqualifiedType()
        if list_type.IsReferenceType():
            list_type = list_type.GetDereferencedType()
        if list_type.GetNumberOfTemplateArguments() > 0:
            data_type = list_type.GetTemplateArgumentType(0)
        else:
            data_type = None
        return data_type

    def update(self):
        logger = lldb.formatters.Logger.Logger()
        self.count = None
        try:
            impl = self.valobj.GetChildMemberWithName("__end_")
            self.node_address = self.valobj.AddressOf().GetValueAsUnsigned(0)
            self.head = impl.GetChildMemberWithName("__next_")
            self.tail = impl.GetChildMemberWithName("__prev_")
            self.data_type = self.extract_type()
            self.data_size = self.data_type.GetByteSize()
        except:
            pass

    def has_children(self):
        return True


# Just an example: the actual summary is produced by a summary string:
# size=${svar%#}
def stdlist_SummaryProvider(valobj, dict):
    prov = stdlist_SynthProvider(valobj, None)
    return "size=" + str(prov.num_children())


# a tree node - this class makes the syntax in the actual iterator nicer
# to read and maintain


class stdmap_iterator_node:
    def _left_impl(self):
        logger = lldb.formatters.Logger.Logger()
        return stdmap_iterator_node(self.node.GetChildMemberWithName("__left_"))

    def _right_impl(self):
        logger = lldb.formatters.Logger.Logger()
        return stdmap_iterator_node(self.node.GetChildMemberWithName("__right_"))

    def _parent_impl(self):
        logger = lldb.formatters.Logger.Logger()
        return stdmap_iterator_node(self.node.GetChildMemberWithName("__parent_"))

    def _value_impl(self):
        logger = lldb.formatters.Logger.Logger()
        return self.node.GetValueAsUnsigned(0)

    def _sbvalue_impl(self):
        logger = lldb.formatters.Logger.Logger()
        return self.node

    def _null_impl(self):
        logger = lldb.formatters.Logger.Logger()
        return self.value == 0

    def __init__(self, node):
        logger = lldb.formatters.Logger.Logger()
        self.node = node

    left = property(_left_impl, None)
    right = property(_right_impl, None)
    parent = property(_parent_impl, None)
    value = property(_value_impl, None)
    is_null = property(_null_impl, None)
    sbvalue = property(_sbvalue_impl, None)


# a Python implementation of the tree iterator used by libc++


class stdmap_iterator:
    def tree_min(self, x):
        logger = lldb.formatters.Logger.Logger()
        steps = 0
        if x.is_null:
            return None
        while not x.left.is_null:
            x = x.left
            steps += 1
            if steps > self.max_count:
                logger >> "Returning None - we overflowed"
                return None
        return x

    def tree_max(self, x):
        logger = lldb.formatters.Logger.Logger()
        if x.is_null:
            return None
        while not x.right.is_null:
            x = x.right
        return x

    def tree_is_left_child(self, x):
        logger = lldb.formatters.Logger.Logger()
        if x.is_null:
            return None
        return True if x.value == x.parent.left.value else False

    def increment_node(self, node):
        logger = lldb.formatters.Logger.Logger()
        if node.is_null:
            return None
        if not node.right.is_null:
            return self.tree_min(node.right)
        steps = 0
        while not self.tree_is_left_child(node):
            steps += 1
            if steps > self.max_count:
                logger >> "Returning None - we overflowed"
                return None
            node = node.parent
        return node.parent

    def __init__(self, node, max_count=0):
        logger = lldb.formatters.Logger.Logger()
        # we convert the SBValue to an internal node object on entry
        self.node = stdmap_iterator_node(node)
        self.max_count = max_count

    def value(self):
        logger = lldb.formatters.Logger.Logger()
        return self.node.sbvalue  # and return the SBValue back on exit

    def next(self):
        logger = lldb.formatters.Logger.Logger()
        node = self.increment_node(self.node)
        if node is not None and node.sbvalue.IsValid() and not (node.is_null):
            self.node = node
            return self.value()
        else:
            return None

    def advance(self, N):
        logger = lldb.formatters.Logger.Logger()
        if N < 0:
            return None
        if N == 0:
            return self.value()
        if N == 1:
            return self.next()
        while N > 0:
            if self.next() is None:
                return None
            N = N - 1
        return self.value()


class stdmap_SynthProvider:
    def __init__(self, valobj, dict):
        logger = lldb.formatters.Logger.Logger()
        self.valobj = valobj
        self.pointer_size = self.valobj.GetProcess().GetAddressByteSize()
        self.count = None

    def update(self):
        logger = lldb.formatters.Logger.Logger()
        self.count = None
        try:
            # we will set this to True if we find out that discovering a node in the map takes more steps than the overall size of the RB tree
            # if this gets set to True, then we will merrily return None for
            # any child from that moment on
            self.garbage = False
            self.tree = self.valobj.GetChildMemberWithName("__tree_")
            self.root_node = self.tree.GetChildMemberWithName("__begin_node_")
            # this data is either lazily-calculated, or cannot be inferred at this moment
            # we still need to mark it as None, meaning "please set me ASAP"
            self.data_type = None
            self.data_size = None
            self.skip_size = None
        except:
            pass

    def num_children(self):
        global _map_capping_size
        logger = lldb.formatters.Logger.Logger()
        if self.count is None:
            self.count = self.num_children_impl()
            if self.count > _map_capping_size:
                self.count = _map_capping_size
        return self.count

    def num_children_impl(self):
        logger = lldb.formatters.Logger.Logger()
        try:
            return (
                self.valobj.GetChildMemberWithName("__tree_")
                .GetChildMemberWithName("__pair3_")
                .GetChildMemberWithName("__first_")
                .GetValueAsUnsigned()
            )
        except:
            return 0

    def has_children(self):
        return True

    def get_data_type(self):
        logger = lldb.formatters.Logger.Logger()
        if self.data_type is None or self.data_size is None:
            if self.num_children() == 0:
                return False
            deref = self.root_node.Dereference()
            if not (deref.IsValid()):
                return False
            value = deref.GetChildMemberWithName("__value_")
            if not (value.IsValid()):
                return False
            self.data_type = value.GetType()
            self.data_size = self.data_type.GetByteSize()
            self.skip_size = None
            return True
        else:
            return True

    def get_value_offset(self, node):
        logger = lldb.formatters.Logger.Logger()
        if self.skip_size is None:
            node_type = node.GetType()
            fields_count = node_type.GetNumberOfFields()
            for i in range(fields_count):
                field = node_type.GetFieldAtIndex(i)
                if field.GetName() == "__value_":
                    self.skip_size = field.GetOffsetInBytes()
                    break
        return self.skip_size is not None

    def get_child_index(self, name):
        logger = lldb.formatters.Logger.Logger()
        try:
            return int(name.lstrip("[").rstrip("]"))
        except:
            return -1

    def get_child_at_index(self, index):
        logger = lldb.formatters.Logger.Logger()
        logger >> "Retrieving child " + str(index)
        if index < 0:
            return None
        if index >= self.num_children():
            return None
        if self.garbage:
            logger >> "Returning None since this tree is garbage"
            return None
        try:
            iterator = stdmap_iterator(self.root_node, max_count=self.num_children())
            # the debug info for libc++ std::map is such that __begin_node_ has a very nice and useful type
            # out of which we can grab the information we need - every other node has a less informative
            # type which omits all value information and only contains housekeeping information for the RB tree
            # hence, we need to know if we are at a node != 0, so that we can
            # still get at the data
            need_to_skip = index > 0
            current = iterator.advance(index)
            if current is None:
                logger >> "Tree is garbage - returning None"
                self.garbage = True
                return None
            if self.get_data_type():
                if not (need_to_skip):
                    current = current.Dereference()
                    obj = current.GetChildMemberWithName("__value_")
                    obj_data = obj.GetData()
                    # make sure we have a valid offset for the next items
                    self.get_value_offset(current)
                    # we do not return __value_ because then we would end up with a child named
                    # __value_ instead of [0]
                    return self.valobj.CreateValueFromData(
                        "[" + str(index) + "]", obj_data, self.data_type
                    )
                else:
                    # FIXME we need to have accessed item 0 before accessing
                    # any other item!
                    if self.skip_size is None:
                        (
                            logger
                            >> "You asked for item > 0 before asking for item == 0, I will fetch 0 now then retry"
                        )
                        if self.get_child_at_index(0):
                            return self.get_child_at_index(index)
                        else:
                            (
                                logger
                                >> "item == 0 could not be found. sorry, nothing can be done here."
                            )
                            return None
                    return current.CreateChildAtOffset(
                        "[" + str(index) + "]", self.skip_size, self.data_type
                    )
            else:
                (
                    logger
                    >> "Unable to infer data-type - returning None (should mark tree as garbage here?)"
                )
                return None
        except Exception as err:
            logger >> "Hit an exception: " + str(err)
            return None


# Just an example: the actual summary is produced by a summary string:
# size=${svar%#}


def stdmap_SummaryProvider(valobj, dict):
    prov = stdmap_SynthProvider(valobj, None)
    return "size=" + str(prov.num_children())


class stddeque_SynthProvider:
    def __init__(self, valobj, d):
        logger = lldb.formatters.Logger.Logger()
        logger.write("init")
        self.valobj = valobj
        self.pointer_size = self.valobj.GetProcess().GetAddressByteSize()
        self.count = None
        try:
            self.find_block_size()
        except:
            self.block_size = -1
            self.element_size = -1
        logger.write(
            "block_size=%d, element_size=%d" % (self.block_size, self.element_size)
        )

    def find_block_size(self):
        # in order to use the deque we must have the block size, or else
        # it's impossible to know what memory addresses are valid
        obj_type = self.valobj.GetType()
        if obj_type.IsReferenceType():
            obj_type = obj_type.GetDereferencedType()
        elif obj_type.IsPointerType():
            obj_type = obj_type.GetPointeeType()
        self.element_type = obj_type.GetTemplateArgumentType(0)
        self.element_size = self.element_type.GetByteSize()
        # The code says this, but there must be a better way:
        # template <class _Tp, class _Allocator>
        # class __deque_base {
        #    static const difference_type __block_size = sizeof(value_type) < 256 ? 4096 / sizeof(value_type) : 16;
        # }
        if self.element_size < 256:
            self.block_size = 4096 // self.element_size
        else:
            self.block_size = 16

    def num_children(self):
        logger = lldb.formatters.Logger.Logger()
        if self.count is None:
            return 0
        return self.count

    def has_children(self):
        return True

    def get_child_index(self, name):
        logger = lldb.formatters.Logger.Logger()
        try:
            return int(name.lstrip("[").rstrip("]"))
        except:
            return -1

    def get_child_at_index(self, index):
        logger = lldb.formatters.Logger.Logger()
        logger.write("Fetching child " + str(index))
        if index < 0 or self.count is None:
            return None
        if index >= self.num_children():
            return None
        try:
            i, j = divmod(self.start + index, self.block_size)

            return self.first.CreateValueFromExpression(
                "[" + str(index) + "]",
                "*(*(%s + %d) + %d)" % (self.map_begin.get_expr_path(), i, j),
            )
        except:
            return None

    def _get_value_of_compressed_pair(self, pair):
        value = pair.GetChildMemberWithName("__value_")
        if not value.IsValid():
            # pre-r300140 member name
            value = pair.GetChildMemberWithName("__first_")
        return value.GetValueAsUnsigned(0)

    def update(self):
        logger = lldb.formatters.Logger.Logger()
        try:
            # A deque is effectively a two-dim array, with fixed width.
            # 'map' contains pointers to the rows of this array. The
            # full memory area allocated by the deque is delimited
            # by 'first' and 'end_cap'. However, only a subset of this
            # memory contains valid data since a deque may have some slack
            # at the front and back in order to have O(1) insertion at
            # both ends. The rows in active use are delimited by
            # 'begin' and 'end'.
            #
            # To find the elements that are actually constructed, the 'start'
            # variable tells which element in this NxM array is the 0th
            # one, and the 'size' element gives the number of elements
            # in the deque.
            count = self._get_value_of_compressed_pair(
                self.valobj.GetChildMemberWithName("__size_")
            )
            # give up now if we cant access memory reliably
            if self.block_size < 0:
                logger.write("block_size < 0")
                return
            map_ = self.valobj.GetChildMemberWithName("__map_")
            start = self.valobj.GetChildMemberWithName("__start_").GetValueAsUnsigned(0)
            first = map_.GetChildMemberWithName("__first_")
            map_first = first.GetValueAsUnsigned(0)
            self.map_begin = map_.GetChildMemberWithName("__begin_")
            map_begin = self.map_begin.GetValueAsUnsigned(0)
            map_end = map_.GetChildMemberWithName("__end_").GetValueAsUnsigned(0)
            map_endcap = self._get_value_of_compressed_pair(
                map_.GetChildMemberWithName("__end_cap_")
            )

            # check consistency
            if not map_first <= map_begin <= map_end <= map_endcap:
                logger.write("map pointers are not monotonic")
                return
            total_rows, junk = divmod(map_endcap - map_first, self.pointer_size)
            if junk:
                logger.write("endcap-first doesnt align correctly")
                return
            active_rows, junk = divmod(map_end - map_begin, self.pointer_size)
            if junk:
                logger.write("end-begin doesnt align correctly")
                return
            start_row, junk = divmod(map_begin - map_first, self.pointer_size)
            if junk:
                logger.write("begin-first doesnt align correctly")
                return

            logger.write(
                "update success: count=%r, start=%r, first=%r" % (count, start, first)
            )
            # if consistent, save all we really need:
            self.count = count
            self.start = start
            self.first = first
        except:
            self.count = None
            self.start = None
            self.map_first = None
            self.map_begin = None
        return False


class stdsharedptr_SynthProvider:
    def __init__(self, valobj, d):
        logger = lldb.formatters.Logger.Logger()
        logger.write("init")
        self.valobj = valobj
        # self.element_ptr_type = self.valobj.GetType().GetTemplateArgumentType(0).GetPointerType()
        self.ptr = None
        self.cntrl = None
        process = valobj.GetProcess()
        self.endianness = process.GetByteOrder()
        self.pointer_size = process.GetAddressByteSize()
        self.count_type = valobj.GetType().GetBasicType(lldb.eBasicTypeUnsignedLong)

    def num_children(self):
        return 1

    def has_children(self):
        return True

    def get_child_index(self, name):
        if name == "__ptr_":
            return 0
        if name == "count":
            return 1
        if name == "weak_count":
            return 2
        return -1

    def get_child_at_index(self, index):
        if index == 0:
            return self.ptr
        if index == 1:
            if self.cntrl is None:
                count = 0
            else:
                count = (
                    1
                    + self.cntrl.GetChildMemberWithName(
                        "__shared_owners_"
                    ).GetValueAsSigned()
                )
            return self.valobj.CreateValueFromData(
                "count",
                lldb.SBData.CreateDataFromUInt64Array(
                    self.endianness, self.pointer_size, [count]
                ),
                self.count_type,
            )
        if index == 2:
            if self.cntrl is None:
                count = 0
            else:
                count = (
                    1
                    + self.cntrl.GetChildMemberWithName(
                        "__shared_weak_owners_"
                    ).GetValueAsSigned()
                )
            return self.valobj.CreateValueFromData(
                "weak_count",
                lldb.SBData.CreateDataFromUInt64Array(
                    self.endianness, self.pointer_size, [count]
                ),
                self.count_type,
            )
        return None

    def update(self):
        logger = lldb.formatters.Logger.Logger()
        self.ptr = self.valobj.GetChildMemberWithName(
            "__ptr_"
        )  # .Cast(self.element_ptr_type)
        cntrl = self.valobj.GetChildMemberWithName("__cntrl_")
        if cntrl.GetValueAsUnsigned(0):
            self.cntrl = cntrl.Dereference()
        else:
            self.cntrl = None


# we can use two different categories for old and new formatters - type names are different enough that we should make no confusion
# talking with libc++ developer: "std::__1::class_name is set in stone
# until we decide to change the ABI. That shouldn't happen within a 5 year
# time frame"


def __lldb_init_module(debugger, dict):
    debugger.HandleCommand(
        'type summary add -F libcxx.stdstring_SummaryProvider "std::__1::string" -w libcxx'
    )
    debugger.HandleCommand(
        'type summary add -F libcxx.stdstring_SummaryProvider "std::__1::basic_string<char, class std::__1::char_traits<char>, class std::__1::allocator<char> >" -w libcxx'
    )
    debugger.HandleCommand(
        'type synthetic add -l libcxx.stdvector_SynthProvider -x "^(std::__1::)vector<.+>$" -w libcxx'
    )
    debugger.HandleCommand(
        'type summary add -F libcxx.stdvector_SummaryProvider -e -x "^(std::__1::)vector<.+>$" -w libcxx'
    )
    debugger.HandleCommand(
        'type synthetic add -l libcxx.stdlist_SynthProvider -x "^(std::__1::)list<.+>$" -w libcxx'
    )
    debugger.HandleCommand(
        'type summary add -F libcxx.stdlist_SummaryProvider -e -x "^(std::__1::)list<.+>$" -w libcxx'
    )
    debugger.HandleCommand(
        'type synthetic add -l libcxx.stdmap_SynthProvider -x "^(std::__1::)map<.+> >$" -w libcxx'
    )
    debugger.HandleCommand(
        'type summary add -F libcxx.stdmap_SummaryProvider -e -x "^(std::__1::)map<.+> >$" -w libcxx'
    )
    debugger.HandleCommand("type category enable libcxx")
    debugger.HandleCommand(
        'type synthetic add -l libcxx.stddeque_SynthProvider -x "^(std::__1::)deque<.+>$" -w libcxx'
    )
    debugger.HandleCommand(
        'type synthetic add -l libcxx.stdsharedptr_SynthProvider -x "^(std::__1::)shared_ptr<.+>$" -w libcxx'
    )
    # turns out the structs look the same, so weak_ptr can be handled the same!
    debugger.HandleCommand(
        'type synthetic add -l libcxx.stdsharedptr_SynthProvider -x "^(std::__1::)weak_ptr<.+>$" -w libcxx'
    )


_map_capping_size = 255
_list_capping_size = 255
_list_uses_loop_detector = True

```

`lldb/formatters/metrics.py`:

```py
"""
Objective-C runtime wrapper for use by LLDB Python formatters

Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
See https://llvm.org/LICENSE.txt for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
"""
import lldb
import time
import datetime
import inspect


class TimeMetrics:
    @staticmethod
    def generate(label=None):
        return TimeMetrics(label)

    def __init__(self, lbl=None):
        self.label = "" if lbl is None else lbl
        pass

    def __enter__(self):
        caller = inspect.stack()[1]
        self.function = str(caller)
        self.enter_time = time.clock()

    def __exit__(self, a, b, c):
        self.exit_time = time.clock()
        print(
            "It took "
            + str(self.exit_time - self.enter_time)
            + " time units to run through "
            + self.function
            + self.label
        )
        return False


class Counter:
    def __init__(self):
        self.count = 0
        self.list = []

    def update(self, name):
        self.count = self.count + 1
        # avoid getting the full dump of this ValueObject just to save its
        # metrics
        if isinstance(name, lldb.SBValue):
            self.list.append(name.GetName())
        else:
            self.list.append(str(name))

    def __str__(self):
        return str(self.count) + " times, for items [" + str(self.list) + "]"


class MetricsPrinter_Verbose:
    def __init__(self, metrics):
        self.metrics = metrics

    def __str__(self):
        string = ""
        for key, value in self.metrics.metrics.items():
            string = string + "metric " + str(key) + ": " + str(value) + "\n"
        return string


class MetricsPrinter_Compact:
    def __init__(self, metrics):
        self.metrics = metrics

    def __str__(self):
        string = ""
        for key, value in self.metrics.metrics.items():
            string = (
                string
                + "metric "
                + str(key)
                + " was hit "
                + str(value.count)
                + " times\n"
            )
        return string


class Metrics:
    def __init__(self):
        self.metrics = {}

    def add_metric(self, name):
        self.metrics[name] = Counter()

    def metric_hit(self, metric, trigger):
        self.metrics[metric].update(trigger)

    def __getitem__(self, key):
        return self.metrics[key]

    def __getattr__(self, name):
        if name == "compact":
            return MetricsPrinter_Compact(self)
        if name == "verbose":
            return MetricsPrinter_Verbose(self)
        raise AttributeError(
            "%r object has no attribute %r" % (type(self).__name__, name)
        )

    def __str__(self):
        return str(self.verbose)

    def metric_success(self, metric):
        total_count = 0
        metric_count = self[metric].count
        for key, value in self.metrics.items():
            total_count = total_count + value.count
        if total_count > 0:
            return metric_count / float(total_count)
        return 0

```

`lldb/formatters/synth.py`:

```py
import lldb


class PythonObjectSyntheticChildProvider(object):
    def __init__(self, value, internal_dict):
        self.value = value
        self.values = self.make_children()
        self.built_values = {}
        self.bo = self.value.target.byte_order
        self.ps = self.value.target.addr_size

    def make_children(self):
        pass

    def num_children(self):
        return len(self.values)

    def get_child_index(self, name):
        i = 0
        for N, value in self.values:
            if N == name:
                return i
            i += 1
        return None

    def update(self):
        pass

    def has_children(self):
        return len(self.values) > 0

    def gen_child(self, name, value):
        data = None
        type = None
        if isinstance(value, int):
            data = lldb.SBData.CreateDataFromUInt64Array(self.bo, self.ps, [value])
            type = self.value.target.GetBasicType(lldb.eBasicTypeLong)
        elif isinstance(value, float):
            data = lldb.SBData.CreateDataFromDoubleArray(self.bo, self.ps, [value])
            type = self.value.target.GetBasicType(lldb.eBasicTypeDouble)
        elif isinstance(value, str):
            data = lldb.SBData.CreateDataFromCString(self.bo, self.ps, value)
            type = self.value.target.GetBasicType(lldb.eBasicTypeChar).GetArrayType(
                len(value)
            )
        if (data is not None) and (type is not None):
            return self.value.CreateValueFromData(name, data, type)
        return None

    def get_child_at_index(self, index):
        if index in self.built_values:
            return self.built_values[index]

        bv = None

        name, value = self.values[index]
        bv = self.gen_child(name, value)
        self.built_values[index] = bv
        return bv

```

`lldb/macosx/__init__.py`:

```py
__all__ = ["crashlog", "crashlog_scripted_process", "heap"]
for x in __all__:
  __import__('lldb.macosx.' + x)

def __lldb_init_module(debugger, internal_dict):
  import lldb
  for x in __all__:
    submodule = getattr(lldb.macosx, x)
    lldb_init = getattr(submodule, '__lldb_init_module', None)
    if lldb_init:
      lldb_init(debugger, internal_dict)

```

`lldb/macosx/crashlog.py`:

```py
#!/usr/bin/env python3

# ----------------------------------------------------------------------
# Be sure to add the python path that points to the LLDB shared library.
#
# To use this in the embedded python interpreter using "lldb":
#
#   cd /path/containing/crashlog.py
#   lldb
#   (lldb) script import crashlog
#   "crashlog" command installed, type "crashlog --help" for detailed help
#   (lldb) crashlog ~/Library/Logs/DiagnosticReports/a.crash
#
# The benefit of running the crashlog command inside lldb in the
# embedded python interpreter is when the command completes, there
# will be a target with all of the files loaded at the locations
# described in the crash log. Only the files that have stack frames
# in the backtrace will be loaded unless the "--load-all" option
# has been specified. This allows users to explore the program in the
# state it was in right at crash time.
#
# On MacOSX csh, tcsh:
#   ( setenv PYTHONPATH /path/to/LLDB.framework/Resources/Python ; ./crashlog.py ~/Library/Logs/DiagnosticReports/a.crash )
#
# On MacOSX sh, bash:
#   PYTHONPATH=/path/to/LLDB.framework/Resources/Python ./crashlog.py ~/Library/Logs/DiagnosticReports/a.crash
# ----------------------------------------------------------------------

import abc
import argparse
import concurrent.futures
import contextlib
import datetime
import json
import os
import platform
import plistlib
import re
import shlex
import string
import subprocess
import sys
import tempfile
import threading
import time
import uuid


print_lock = threading.RLock()

try:
    # First try for LLDB in case PYTHONPATH is already correctly setup.
    import lldb
except ImportError:
    # Ask the command line driver for the path to the lldb module. Copy over
    # the environment so that SDKROOT is propagated to xcrun.
    command = (
        ["xcrun", "lldb", "-P"] if platform.system() == "Darwin" else ["lldb", "-P"]
    )
    # Extend the PYTHONPATH if the path exists and isn't already there.
    lldb_python_path = subprocess.check_output(command).decode("utf-8").strip()
    if os.path.exists(lldb_python_path) and not sys.path.__contains__(lldb_python_path):
        sys.path.append(lldb_python_path)
    # Try importing LLDB again.
    try:
        import lldb
    except ImportError:
        print(
            "error: couldn't locate the 'lldb' module, please set PYTHONPATH correctly"
        )
        sys.exit(1)

from lldb.utils import symbolication
from lldb.plugins.scripted_process import INTEL64_GPR, ARM64_GPR


def read_plist(s):
    if sys.version_info.major == 3:
        return plistlib.loads(s)
    else:
        return plistlib.readPlistFromString(s)


class CrashLog(symbolication.Symbolicator):
    class Thread:
        """Class that represents a thread in a darwin crash log"""

        def __init__(self, index, app_specific_backtrace, arch):
            self.index = index
            self.id = index
            self.images = list()
            self.frames = list()
            self.idents = list()
            self.registers = dict()
            self.reason = None
            self.name = None
            self.queue = None
            self.crashed = False
            self.app_specific_backtrace = app_specific_backtrace
            self.arch = arch

        def dump_registers(self, prefix=""):
            registers_info = None
            sorted_registers = {}

            def sort_dict(d):
                sorted_keys = list(d.keys())
                sorted_keys.sort()
                return {k: d[k] for k in sorted_keys}

            if self.arch:
                if "x86_64" == self.arch:
                    registers_info = INTEL64_GPR
                elif "arm64" in self.arch:
                    registers_info = ARM64_GPR
                else:
                    print("unknown target architecture: %s" % self.arch)
                    return

                # Add registers available in the register information dictionary.
                for reg_info in registers_info:
                    reg_name = None
                    if reg_info["name"] in self.registers:
                        reg_name = reg_info["name"]
                    elif (
                        "generic" in reg_info and reg_info["generic"] in self.registers
                    ):
                        reg_name = reg_info["generic"]
                    else:
                        # Skip register that are present in the register information dictionary but not present in the report.
                        continue

                    reg_val = self.registers[reg_name]
                    sorted_registers[reg_name] = reg_val

                unknown_parsed_registers = {}
                for reg_name in self.registers:
                    if reg_name not in sorted_registers:
                        unknown_parsed_registers[reg_name] = self.registers[reg_name]

                sorted_registers.update(sort_dict(unknown_parsed_registers))

            else:
                sorted_registers = sort_dict(self.registers)

            for reg_name, reg_val in sorted_registers.items():
                print("%s    %-8s = %#16.16x" % (prefix, reg_name, reg_val))

        def dump(self, prefix=""):
            if self.app_specific_backtrace:
                print(
                    "%Application Specific Backtrace[%u] %s"
                    % (prefix, self.index, self.reason)
                )
            else:
                print("%sThread[%u] %s" % (prefix, self.index, self.reason))
            if self.frames:
                print("%s  Frames:" % (prefix))
                for frame in self.frames:
                    frame.dump(prefix + "    ")
            if self.registers:
                print("%s  Registers:" % (prefix))
                self.dump_registers(prefix)

        def dump_symbolicated(self, crash_log, options):
            this_thread_crashed = self.app_specific_backtrace
            if not this_thread_crashed:
                this_thread_crashed = self.did_crash()
                if options.crashed_only and this_thread_crashed == False:
                    return

            print("%s" % self)
            display_frame_idx = -1
            for frame_idx, frame in enumerate(self.frames):
                disassemble = (
                    this_thread_crashed or options.disassemble_all_threads
                ) and frame_idx < options.disassemble_depth

                # Except for the zeroth frame, we should subtract 1 from every
                # frame pc to get the previous line entry.
                pc = frame.pc & crash_log.addr_mask
                pc = pc if frame_idx == 0 or pc == 0 else pc - 1
                symbolicated_frame_addresses = crash_log.symbolicate(
                    pc, options.verbose
                )

                if symbolicated_frame_addresses:
                    symbolicated_frame_address_idx = 0
                    for symbolicated_frame_address in symbolicated_frame_addresses:
                        display_frame_idx += 1
                        print("[%3u] %s" % (frame_idx, symbolicated_frame_address))
                        if (
                            (options.source_all or self.did_crash())
                            and display_frame_idx < options.source_frames
                            and options.source_context
                        ):
                            source_context = options.source_context
                            line_entry = (
                                symbolicated_frame_address.get_symbol_context().line_entry
                            )
                            if line_entry.IsValid():
                                strm = lldb.SBStream()
                                if line_entry:
                                    crash_log.debugger.GetSourceManager().DisplaySourceLinesWithLineNumbers(
                                        line_entry.file,
                                        line_entry.line,
                                        source_context,
                                        source_context,
                                        "->",
                                        strm,
                                    )
                                source_text = strm.GetData()
                                if source_text:
                                    # Indent the source a bit
                                    indent_str = "    "
                                    join_str = "\n" + indent_str
                                    print(
                                        "%s%s"
                                        % (
                                            indent_str,
                                            join_str.join(source_text.split("\n")),
                                        )
                                    )
                        if symbolicated_frame_address_idx == 0:
                            if disassemble:
                                instructions = (
                                    symbolicated_frame_address.get_instructions()
                                )
                                if instructions:
                                    print()
                                    symbolication.disassemble_instructions(
                                        crash_log.get_target(),
                                        instructions,
                                        frame.pc,
                                        options.disassemble_before,
                                        options.disassemble_after,
                                        frame.index > 0,
                                    )
                                    print()
                        symbolicated_frame_address_idx += 1
                else:
                    print(frame)
            if self.registers:
                print()
                self.dump_registers()
            elif self.crashed:
                print()
                print("No thread state (register information) available")

        def add_ident(self, ident):
            if ident not in self.idents:
                self.idents.append(ident)

        def did_crash(self):
            return self.reason is not None

        def __str__(self):
            if self.app_specific_backtrace:
                s = "Application Specific Backtrace[%u]" % self.index
            else:
                s = "Thread[%u]" % self.index
            if self.reason:
                s += " %s" % self.reason
            return s

    class Frame:
        """Class that represents a stack frame in a thread in a darwin crash log"""

        def __init__(self, index, pc, description):
            self.pc = pc
            self.description = description
            self.index = index

        def __str__(self):
            if self.description:
                return "[%3u] 0x%16.16x %s" % (self.index, self.pc, self.description)
            else:
                return "[%3u] 0x%16.16x" % (self.index, self.pc)

        def dump(self, prefix):
            print("%s%s" % (prefix, str(self)))

    class DarwinImage(symbolication.Image):
        """Class that represents a binary images in a darwin crash log"""

        dsymForUUIDBinary = "/usr/local/bin/dsymForUUID"
        if not os.path.exists(dsymForUUIDBinary):
            try:
                dsymForUUIDBinary = (
                    subprocess.check_output("which dsymForUUID", shell=True)
                    .decode("utf-8")
                    .rstrip("\n")
                )
            except:
                dsymForUUIDBinary = ""

        dwarfdump_uuid_regex = re.compile("UUID: ([-0-9a-fA-F]+) \(([^\(]+)\) .*")

        def __init__(
            self, text_addr_lo, text_addr_hi, identifier, version, uuid, path, verbose
        ):
            symbolication.Image.__init__(self, path, uuid)
            self.add_section(
                symbolication.Section(text_addr_lo, text_addr_hi, "__TEXT")
            )
            self.identifier = identifier
            self.version = version
            self.verbose = verbose

        def show_symbol_progress(self):
            """
            Hide progress output and errors from system frameworks as they are plentiful.
            """
            if self.verbose:
                return True
            return not (
                self.path.startswith("/System/Library/")
                or self.path.startswith("/usr/lib/")
            )

        def find_matching_slice(self):
            dwarfdump_cmd_output = subprocess.check_output(
                'dwarfdump --uuid "%s"' % self.path, shell=True
            ).decode("utf-8")
            self_uuid = self.get_uuid()
            for line in dwarfdump_cmd_output.splitlines():
                match = self.dwarfdump_uuid_regex.search(line)
                if match:
                    dwarf_uuid_str = match.group(1)
                    dwarf_uuid = uuid.UUID(dwarf_uuid_str)
                    if self_uuid == dwarf_uuid:
                        self.resolved_path = self.path
                        self.arch = match.group(2)
                        return True
            if not self.resolved_path:
                self.unavailable = True
                if self.show_symbol_progress():
                    print(
                        (
                            "error\n    error: unable to locate '%s' with UUID %s"
                            % (self.path, self.get_normalized_uuid_string())
                        )
                    )
                return False

        def locate_module_and_debug_symbols(self):
            # Don't load a module twice...
            if self.resolved:
                return True
            # Mark this as resolved so we don't keep trying
            self.resolved = True
            uuid_str = self.get_normalized_uuid_string()
            if self.show_symbol_progress():
                with print_lock:
                    print("Getting symbols for %s %s..." % (uuid_str, self.path))
            # Keep track of unresolved source paths.
            unavailable_source_paths = set()
            if os.path.exists(self.dsymForUUIDBinary):
                dsym_for_uuid_command = "%s %s" % (self.dsymForUUIDBinary, uuid_str)
                s = subprocess.check_output(dsym_for_uuid_command, shell=True)
                if s:
                    try:
                        plist_root = read_plist(s)
                    except:
                        with print_lock:
                            print(
                                (
                                    "Got exception: ",
                                    sys.exc_info()[1],
                                    " handling dsymForUUID output: \n",
                                    s,
                                )
                            )
                        raise
                    if plist_root:
                        plist = plist_root[uuid_str]
                        if plist:
                            if "DBGArchitecture" in plist:
                                self.arch = plist["DBGArchitecture"]
                            if "DBGDSYMPath" in plist:
                                self.symfile = os.path.realpath(plist["DBGDSYMPath"])
                            if "DBGSymbolRichExecutable" in plist:
                                self.path = os.path.expanduser(
                                    plist["DBGSymbolRichExecutable"]
                                )
                                self.resolved_path = self.path
                            if "DBGSourcePathRemapping" in plist:
                                path_remapping = plist["DBGSourcePathRemapping"]
                                for _, value in path_remapping.items():
                                    source_path = os.path.expanduser(value)
                                    if not os.path.exists(source_path):
                                        unavailable_source_paths.add(source_path)
            if not self.resolved_path and os.path.exists(self.path):
                if not self.find_matching_slice():
                    return False
            if not self.resolved_path and not os.path.exists(self.path):
                try:
                    mdfind_results = (
                        subprocess.check_output(
                            [
                                "/usr/bin/mdfind",
                                "com_apple_xcode_dsym_uuids == %s" % uuid_str,
                            ]
                        )
                        .decode("utf-8")
                        .splitlines()
                    )
                    found_matching_slice = False
                    for dsym in mdfind_results:
                        dwarf_dir = os.path.join(dsym, "Contents/Resources/DWARF")
                        if not os.path.exists(dwarf_dir):
                            # Not a dSYM bundle, probably an Xcode archive.
                            continue
                        with print_lock:
                            print('falling back to binary inside "%s"' % dsym)
                        self.symfile = dsym
                        for filename in os.listdir(dwarf_dir):
                            self.path = os.path.join(dwarf_dir, filename)
                            if self.find_matching_slice():
                                found_matching_slice = True
                                break
                        if found_matching_slice:
                            break
                except:
                    pass
            if (self.resolved_path and os.path.exists(self.resolved_path)) or (
                self.path and os.path.exists(self.path)
            ):
                with print_lock:
                    print("Resolved symbols for %s %s..." % (uuid_str, self.path))
                    if len(unavailable_source_paths):
                        for source_path in unavailable_source_paths:
                            print(
                                "Could not access remapped source path for %s %s"
                                % (uuid_str, source_path)
                            )
                return True
            else:
                self.unavailable = True
            return False

    def __init__(self, debugger, path, verbose):
        """CrashLog constructor that take a path to a darwin crash log file"""
        symbolication.Symbolicator.__init__(self, debugger)
        self.path = os.path.expanduser(path)
        self.info_lines = list()
        self.system_profile = list()
        self.threads = list()
        self.backtraces = list()  # For application specific backtraces
        self.idents = (
            list()
        )  # A list of the required identifiers for doing all stack backtraces
        self.errors = list()
        self.exception = dict()
        self.crashed_thread_idx = -1
        self.version = -1
        self.target = None
        self.verbose = verbose
        self.process_id = None
        self.process_identifier = None
        self.process_path = None
        self.process_arch = None

    def dump(self):
        print("Crash Log File: %s" % (self.path))
        if self.backtraces:
            print("\nApplication Specific Backtraces:")
            for thread in self.backtraces:
                thread.dump("  ")
        print("\nThreads:")
        for thread in self.threads:
            thread.dump("  ")
        print("\nImages:")
        for image in self.images:
            image.dump("  ")

    def set_main_image(self, identifier):
        for i, image in enumerate(self.images):
            if image.identifier == identifier:
                self.images.insert(0, self.images.pop(i))
                break

    def find_image_with_identifier(self, identifier):
        for image in self.images:
            if image.identifier == identifier:
                return image
        regex_text = "^.*\.%s$" % (re.escape(identifier))
        regex = re.compile(regex_text)
        for image in self.images:
            if regex.match(image.identifier):
                return image
        return None

    def create_target(self):
        if self.target is None:
            self.target = symbolication.Symbolicator.create_target(self)
            if self.target:
                return self.target
            # We weren't able to open the main executable as, but we can still
            # symbolicate
            print("crashlog.create_target()...2")
            if self.idents:
                for ident in self.idents:
                    image = self.find_image_with_identifier(ident)
                    if image:
                        self.target = image.create_target(self.debugger)
                        if self.target:
                            return self.target  # success
            print("crashlog.create_target()...3")
            for image in self.images:
                self.target = image.create_target(self.debugger)
                if self.target:
                    return self.target  # success
            print("crashlog.create_target()...4")
            print("error: Unable to locate any executables from the crash log.")
            print("       Try loading the executable into lldb before running crashlog")
            print(
                "       and/or make sure the .dSYM bundles can be found by Spotlight."
            )
        return self.target

    def get_target(self):
        return self.target


class CrashLogFormatException(Exception):
    pass


class CrashLogParseException(Exception):
    pass


class InteractiveCrashLogException(Exception):
    pass


class CrashLogParser:
    @staticmethod
    def create(debugger, path, options):
        data = JSONCrashLogParser.is_valid_json(path)
        if data:
            parser = JSONCrashLogParser(debugger, path, options)
            parser.data = data
            return parser
        else:
            return TextCrashLogParser(debugger, path, options)

    def __init__(self, debugger, path, options):
        self.path = os.path.expanduser(path)
        self.options = options
        self.crashlog = CrashLog(debugger, self.path, self.options.verbose)

    @abc.abstractmethod
    def parse(self):
        pass


class JSONCrashLogParser(CrashLogParser):
    @staticmethod
    def is_valid_json(path):
        def parse_json(buffer):
            try:
                return json.loads(buffer)
            except:
                # The first line can contain meta data. Try stripping it and
                # try again.
                head, _, tail = buffer.partition("\n")
                return json.loads(tail)

        with open(path, "r", encoding="utf-8") as f:
            buffer = f.read()
        try:
            return parse_json(buffer)
        except:
            return None

    def __init__(self, debugger, path, options):
        super().__init__(debugger, path, options)

    def parse(self):
        try:
            self.parse_process_info(self.data)
            self.parse_images(self.data["usedImages"])
            self.parse_main_image(self.data)
            self.parse_threads(self.data["threads"])
            if "asi" in self.data:
                self.crashlog.asi = self.data["asi"]
            # FIXME: With the current design, we can either show the ASI or Last
            # Exception Backtrace, not both. Is there a situation where we would
            # like to show both ?
            if "asiBacktraces" in self.data:
                self.parse_app_specific_backtraces(self.data["asiBacktraces"])
            if "lastExceptionBacktrace" in self.data:
                self.parse_last_exception_backtraces(
                    self.data["lastExceptionBacktrace"]
                )
            self.parse_errors(self.data)
            thread = self.crashlog.threads[self.crashlog.crashed_thread_idx]
            reason = self.parse_crash_reason(self.data["exception"])
            if thread.reason:
                thread.reason = "{} {}".format(thread.reason, reason)
            else:
                thread.reason = reason
        except (KeyError, ValueError, TypeError) as e:
            raise CrashLogParseException(
                "Failed to parse JSON crashlog: {}: {}".format(type(e).__name__, e)
            )

        return self.crashlog

    def get_used_image(self, idx):
        return self.data["usedImages"][idx]

    def parse_process_info(self, json_data):
        self.crashlog.process_id = json_data["pid"]
        self.crashlog.process_identifier = json_data["procName"]
        if "procPath" in json_data:
            self.crashlog.process_path = json_data["procPath"]

    def parse_crash_reason(self, json_exception):
        self.crashlog.exception = json_exception
        exception_type = json_exception["type"]
        exception_signal = " "
        if "signal" in json_exception:
            exception_signal += "({})".format(json_exception["signal"])

        if "codes" in json_exception:
            exception_extra = " ({})".format(json_exception["codes"])
        elif "subtype" in json_exception:
            exception_extra = " ({})".format(json_exception["subtype"])
        else:
            exception_extra = ""
        return "{}{}{}".format(exception_type, exception_signal, exception_extra)

    def parse_images(self, json_images):
        for json_image in json_images:
            img_uuid = uuid.UUID(json_image["uuid"])
            low = int(json_image["base"])
            high = low + int(json_image["size"]) if "size" in json_image else low
            name = json_image["name"] if "name" in json_image else ""
            path = json_image["path"] if "path" in json_image else ""
            version = ""
            darwin_image = self.crashlog.DarwinImage(
                low, high, name, version, img_uuid, path, self.options.verbose
            )
            if "arch" in json_image:
                darwin_image.arch = json_image["arch"]
                if path == self.crashlog.process_path:
                    self.crashlog.process_arch = darwin_image.arch
            self.crashlog.images.append(darwin_image)

    def parse_main_image(self, json_data):
        if "procName" in json_data:
            proc_name = json_data["procName"]
            self.crashlog.set_main_image(proc_name)

    def parse_frames(self, thread, json_frames):
        idx = 0
        for json_frame in json_frames:
            image_id = int(json_frame["imageIndex"])
            json_image = self.get_used_image(image_id)
            ident = json_image["name"] if "name" in json_image else ""
            thread.add_ident(ident)
            if ident not in self.crashlog.idents:
                self.crashlog.idents.append(ident)

            frame_offset = int(json_frame["imageOffset"])
            image_addr = self.get_used_image(image_id)["base"]
            pc = image_addr + frame_offset

            if "symbol" in json_frame:
                symbol = json_frame["symbol"]
                location = 0
                if "symbolLocation" in json_frame and json_frame["symbolLocation"]:
                    location = int(json_frame["symbolLocation"])
                image = self.crashlog.images[image_id]
                image.symbols[symbol] = {
                    "name": symbol,
                    "type": "code",
                    "address": frame_offset - location,
                }

            thread.frames.append(self.crashlog.Frame(idx, pc, frame_offset))

            # on arm64 systems, if it jump through a null function pointer,
            # we end up at address 0 and the crash reporter unwinder
            # misses the frame that actually faulted.
            # But $lr can tell us where the last BL/BLR instruction used
            # was at, so insert that address as the caller stack frame.
            if idx == 0 and pc == 0 and "lr" in thread.registers:
                pc = thread.registers["lr"]
                for image in self.data["usedImages"]:
                    text_lo = image["base"]
                    text_hi = text_lo + image["size"]
                    if text_lo <= pc < text_hi:
                        idx += 1
                        frame_offset = pc - text_lo
                        thread.frames.append(self.crashlog.Frame(idx, pc, frame_offset))
                        break

            idx += 1

    def parse_threads(self, json_threads):
        idx = 0
        for json_thread in json_threads:
            thread = self.crashlog.Thread(idx, False, self.crashlog.process_arch)
            if "name" in json_thread:
                thread.name = json_thread["name"]
                thread.reason = json_thread["name"]
            if "id" in json_thread:
                thread.id = int(json_thread["id"])
            if json_thread.get("triggered", False):
                self.crashlog.crashed_thread_idx = idx
                thread.crashed = True
                if "threadState" in json_thread:
                    thread.registers = self.parse_thread_registers(
                        json_thread["threadState"]
                    )
            if "queue" in json_thread:
                thread.queue = json_thread.get("queue")
            self.parse_frames(thread, json_thread.get("frames", []))
            self.crashlog.threads.append(thread)
            idx += 1

    def parse_asi_backtrace(self, thread, bt):
        for line in bt.split("\n"):
            frame_match = TextCrashLogParser.frame_regex.search(line)
            if not frame_match:
                print("error: can't parse application specific backtrace.")
                return False

            frame_id = (
                frame_img_name
            ) = (
                frame_addr
            ) = (
                frame_symbol
            ) = frame_offset = frame_file = frame_line = frame_column = None

            if len(frame_match.groups()) == 3:
                # Get the image UUID from the frame image name.
                (frame_id, frame_img_name, frame_addr) = frame_match.groups()
            elif len(frame_match.groups()) == 5:
                (
                    frame_id,
                    frame_img_name,
                    frame_addr,
                    frame_symbol,
                    frame_offset,
                ) = frame_match.groups()
            elif len(frame_match.groups()) == 7:
                (
                    frame_id,
                    frame_img_name,
                    frame_addr,
                    frame_symbol,
                    frame_offset,
                    frame_file,
                    frame_line,
                ) = frame_match.groups()
            elif len(frame_match.groups()) == 8:
                (
                    frame_id,
                    frame_img_name,
                    frame_addr,
                    frame_symbol,
                    frame_offset,
                    frame_file,
                    frame_line,
                    frame_column,
                ) = frame_match.groups()

            thread.add_ident(frame_img_name)
            if frame_img_name not in self.crashlog.idents:
                self.crashlog.idents.append(frame_img_name)

            description = ""
            if frame_img_name and frame_addr and frame_symbol:
                description = frame_symbol
                frame_offset_value = 0
                if frame_offset:
                    description += " + " + frame_offset
                    frame_offset_value = int(frame_offset, 0)
                for image in self.crashlog.images:
                    if image.identifier == frame_img_name:
                        image.symbols[frame_symbol] = {
                            "name": frame_symbol,
                            "type": "code",
                            "address": int(frame_addr, 0) - frame_offset_value,
                        }

            thread.frames.append(
                self.crashlog.Frame(int(frame_id), int(frame_addr, 0), description)
            )

        return True

    def parse_app_specific_backtraces(self, json_app_specific_bts):
        thread = self.crashlog.Thread(
            len(self.crashlog.threads), True, self.crashlog.process_arch
        )
        thread.queue = "Application Specific Backtrace"
        if self.parse_asi_backtrace(thread, json_app_specific_bts[0]):
            self.crashlog.threads.append(thread)
        else:
            print("error: Couldn't parse Application Specific Backtrace.")

    def parse_last_exception_backtraces(self, json_last_exc_bts):
        thread = self.crashlog.Thread(
            len(self.crashlog.threads), True, self.crashlog.process_arch
        )
        thread.queue = "Last Exception Backtrace"
        self.parse_frames(thread, json_last_exc_bts)
        self.crashlog.threads.append(thread)

    def parse_thread_registers(self, json_thread_state, prefix=None):
        registers = dict()
        for key, state in json_thread_state.items():
            if key == "rosetta":
                registers.update(self.parse_thread_registers(state))
                continue
            if key == "x":
                gpr_dict = {str(idx): reg for idx, reg in enumerate(state)}
                registers.update(self.parse_thread_registers(gpr_dict, key))
                continue
            if key == "flavor":
                if not self.crashlog.process_arch:
                    if state == "ARM_THREAD_STATE64":
                        self.crashlog.process_arch = "arm64"
                    elif state == "X86_THREAD_STATE":
                        self.crashlog.process_arch = "x86_64"
                continue
            try:
                value = int(state["value"])
                registers["{}{}".format(prefix or "", key)] = value
            except (KeyError, ValueError, TypeError):
                pass
        return registers

    def parse_errors(self, json_data):
        if "reportNotes" in json_data:
            self.crashlog.errors = json_data["reportNotes"]


class TextCrashLogParser(CrashLogParser):
    parent_process_regex = re.compile(r"^Parent Process:\s*(.*)\[(\d+)\]")
    thread_state_regex = re.compile(r"^Thread \d+ crashed with")
    thread_instrs_regex = re.compile(r"^Thread \d+ instruction stream")
    thread_regex = re.compile(r"^Thread (\d+).*:")
    app_backtrace_regex = re.compile(r"^Application Specific Backtrace (\d+).*:")

    class VersionRegex:
        version = r"\(.+\)|(?:arm|x86_)[0-9a-z]+"

    class FrameRegex(VersionRegex):
        @classmethod
        def get(cls):
            index = r"^(\d+)\s+"
            img_name = r"(.+?)\s+"
            version = r"(?:" + super().version + r"\s+)?"
            address = r"(0x[0-9a-fA-F]{4,})"  # 4 digits or more

            symbol = """
                        (?:
                            [ ]+
                            (?P<symbol>.+)
                            (?:
                                [ ]\+[ ]
                                (?P<symbol_offset>\d+)
                            )
                            (?:
                                [ ]\(
                                (?P<file_name>[^:]+):(?P<line_number>\d+)
                                (?:
                                    :(?P<column_num>\d+)
                                )?
                            )?
                        )?
                       """

            return re.compile(
                index + img_name + version + address + symbol, flags=re.VERBOSE
            )

    frame_regex = FrameRegex.get()
    null_frame_regex = re.compile(r"^\d+\s+\?\?\?\s+0{4,} +")
    image_regex_uuid = re.compile(
        r"(0x[0-9a-fA-F]+)"  # img_lo
        r"\s+-\s+"  #   -
        r"(0x[0-9a-fA-F]+)\s+"  # img_hi
        r"[+]?(.+?)\s+"  # img_name
        r"(?:(" + VersionRegex.version + r")\s+)?"  # img_version
        r"(?:<([-0-9a-fA-F]+)>\s+)?"  # img_uuid
        r"(\?+|/.*)"  # img_path
    )
    exception_type_regex = re.compile(
        r"^Exception Type:\s+(EXC_[A-Z_]+)(?:\s+\((.*)\))?"
    )
    exception_codes_regex = re.compile(
        r"^Exception Codes:\s+(0x[0-9a-fA-F]+),\s*(0x[0-9a-fA-F]+)"
    )
    exception_extra_regex = re.compile(r"^Exception\s+.*:\s+(.*)")

    class CrashLogParseMode:
        NORMAL = 0
        THREAD = 1
        IMAGES = 2
        THREGS = 3
        SYSTEM = 4
        INSTRS = 5

    def __init__(self, debugger, path, options):
        super().__init__(debugger, path, options)
        self.thread = None
        self.app_specific_backtrace = False
        self.parse_mode = self.CrashLogParseMode.NORMAL
        self.parsers = {
            self.CrashLogParseMode.NORMAL: self.parse_normal,
            self.CrashLogParseMode.THREAD: self.parse_thread,
            self.CrashLogParseMode.IMAGES: self.parse_images,
            self.CrashLogParseMode.THREGS: self.parse_thread_registers,
            self.CrashLogParseMode.SYSTEM: self.parse_system,
            self.CrashLogParseMode.INSTRS: self.parse_instructions,
        }
        self.symbols = {}

    def parse(self):
        with open(self.path, "r", encoding="utf-8") as f:
            lines = f.read().splitlines()

        idx = 0
        lines_count = len(lines)
        while True:
            if idx >= lines_count:
                break

            line = lines[idx]
            line_len = len(line)

            if line_len == 0:
                if self.thread:
                    if self.parse_mode == self.CrashLogParseMode.THREAD:
                        if self.thread.index == self.crashlog.crashed_thread_idx:
                            self.thread.reason = ""
                            if hasattr(self.crashlog, "thread_exception"):
                                self.thread.reason += self.crashlog.thread_exception
                            if hasattr(self.crashlog, "thread_exception_data"):
                                self.thread.reason += (
                                    " (%s)" % self.crashlog.thread_exception_data
                                )
                            self.thread.crashed = True
                        if self.app_specific_backtrace:
                            self.crashlog.backtraces.append(self.thread)
                        else:
                            self.crashlog.threads.append(self.thread)
                    self.thread = None

                empty_lines = 1
                while (
                    idx + empty_lines < lines_count
                    and len(lines[idx + empty_lines]) == 0
                ):
                    empty_lines = empty_lines + 1

                if (
                    empty_lines == 1
                    and idx + empty_lines < lines_count - 1
                    and self.parse_mode != self.CrashLogParseMode.NORMAL
                ):
                    # check if next line can be parsed with the current parse mode
                    next_line_idx = idx + empty_lines
                    if self.parsers[self.parse_mode](lines[next_line_idx]):
                        # If that suceeded, skip the empty line and the next line.
                        idx = next_line_idx + 1
                        continue
                self.parse_mode = self.CrashLogParseMode.NORMAL

            self.parsers[self.parse_mode](line)

            idx = idx + 1

        return self.crashlog

    def parse_exception(self, line):
        if not line.startswith("Exception"):
            return False
        if line.startswith("Exception Type:"):
            self.crashlog.thread_exception = line[15:].strip()
            exception_type_match = self.exception_type_regex.search(line)
            if exception_type_match:
                exc_type, exc_signal = exception_type_match.groups()
                self.crashlog.exception["type"] = exc_type
                if exc_signal:
                    self.crashlog.exception["signal"] = exc_signal
        elif line.startswith("Exception Subtype:"):
            self.crashlog.thread_exception_subtype = line[18:].strip()
            if "type" in self.crashlog.exception:
                self.crashlog.exception[
                    "subtype"
                ] = self.crashlog.thread_exception_subtype
        elif line.startswith("Exception Codes:"):
            self.crashlog.thread_exception_data = line[16:].strip()
            if "type" not in self.crashlog.exception:
                return False
            exception_codes_match = self.exception_codes_regex.search(line)
            if exception_codes_match:
                self.crashlog.exception["codes"] = self.crashlog.thread_exception_data
                code, subcode = exception_codes_match.groups()
                self.crashlog.exception["rawCodes"] = [
                    int(code, base=16),
                    int(subcode, base=16),
                ]
        else:
            if "type" not in self.crashlog.exception:
                return False
            exception_extra_match = self.exception_extra_regex.search(line)
            if exception_extra_match:
                self.crashlog.exception["message"] = exception_extra_match.group(1)
        return True

    def parse_normal(self, line):
        if line.startswith("Process:"):
            (self.crashlog.process_name, pid_with_brackets) = (
                line[8:].strip().split(" [")
            )
            self.crashlog.process_id = pid_with_brackets.strip("[]")
        elif line.startswith("Path:"):
            self.crashlog.process_path = line[5:].strip()
        elif line.startswith("Identifier:"):
            self.crashlog.process_identifier = line[11:].strip()
        elif line.startswith("Version:"):
            version_string = line[8:].strip()
            matched_pair = re.search("(.+)\((.+)\)", version_string)
            if matched_pair:
                self.crashlog.process_version = matched_pair.group(1)
                self.crashlog.process_compatability_version = matched_pair.group(2)
            else:
                self.crashlog.process = version_string
                self.crashlog.process_compatability_version = version_string
        elif line.startswith("Code Type:"):
            if "ARM-64" in line:
                self.crashlog.process_arch = "arm64"
            elif "X86-64" in line:
                self.crashlog.process_arch = "x86_64"
        elif self.parent_process_regex.search(line):
            parent_process_match = self.parent_process_regex.search(line)
            self.crashlog.parent_process_name = parent_process_match.group(1)
            self.crashlog.parent_process_id = parent_process_match.group(2)
        elif line.startswith("Exception"):
            self.parse_exception(line)
            return
        elif line.startswith("Crashed Thread:"):
            self.crashlog.crashed_thread_idx = int(line[15:].strip().split()[0])
            return
        elif line.startswith("Triggered by Thread:"):  # iOS
            self.crashlog.crashed_thread_idx = int(line[20:].strip().split()[0])
            return
        elif line.startswith("Report Version:"):
            self.crashlog.version = int(line[15:].strip())
            return
        elif line.startswith("System Profile:"):
            self.parse_mode = self.CrashLogParseMode.SYSTEM
            return
        elif (
            line.startswith("Interval Since Last Report:")
            or line.startswith("Crashes Since Last Report:")
            or line.startswith("Per-App Interval Since Last Report:")
            or line.startswith("Per-App Crashes Since Last Report:")
            or line.startswith("Sleep/Wake UUID:")
            or line.startswith("Anonymous UUID:")
        ):
            # ignore these
            return
        elif line.startswith("Thread"):
            thread_state_match = self.thread_state_regex.search(line)
            if thread_state_match:
                self.app_specific_backtrace = False
                thread_state_match = self.thread_regex.search(line)
                thread_idx = int(thread_state_match.group(1))
                self.parse_mode = self.CrashLogParseMode.THREGS
                self.thread = self.crashlog.threads[thread_idx]
                return
            thread_insts_match = self.thread_instrs_regex.search(line)
            if thread_insts_match:
                self.parse_mode = self.CrashLogParseMode.INSTRS
                return
            thread_match = self.thread_regex.search(line)
            if thread_match:
                self.app_specific_backtrace = False
                self.parse_mode = self.CrashLogParseMode.THREAD
                thread_idx = int(thread_match.group(1))
                self.thread = self.crashlog.Thread(
                    thread_idx, False, self.crashlog.process_arch
                )
                return
            return
        elif line.startswith("Binary Images:"):
            self.parse_mode = self.CrashLogParseMode.IMAGES
            return
        elif line.startswith("Application Specific Backtrace"):
            app_backtrace_match = self.app_backtrace_regex.search(line)
            if app_backtrace_match:
                self.parse_mode = self.CrashLogParseMode.THREAD
                self.app_specific_backtrace = True
                idx = int(app_backtrace_match.group(1))
                self.thread = self.crashlog.Thread(
                    idx, True, self.crashlog.process_arch
                )
        elif line.startswith("Last Exception Backtrace:"):  # iOS
            self.parse_mode = self.CrashLogParseMode.THREAD
            self.app_specific_backtrace = True
            idx = 1
            self.thread = self.crashlog.Thread(idx, True, self.crashlog.process_arch)
        self.crashlog.info_lines.append(line.strip())

    def parse_thread(self, line):
        if line.startswith("Thread"):
            return False
        if self.null_frame_regex.search(line):
            print('warning: thread parser ignored null-frame: "%s"' % line)
            return False
        frame_match = self.frame_regex.search(line)
        if not frame_match:
            print('error: frame regex failed for line: "%s"' % line)
            return False

        frame_id = (
            frame_img_name
        ) = (
            frame_addr
        ) = frame_symbol = frame_offset = frame_file = frame_line = frame_column = None

        if len(frame_match.groups()) == 3:
            # Get the image UUID from the frame image name.
            (frame_id, frame_img_name, frame_addr) = frame_match.groups()
        elif len(frame_match.groups()) == 5:
            (
                frame_id,
                frame_img_name,
                frame_addr,
                frame_symbol,
                frame_offset,
            ) = frame_match.groups()
        elif len(frame_match.groups()) == 7:
            (
                frame_id,
                frame_img_name,
                frame_addr,
                frame_symbol,
                frame_offset,
                frame_file,
                frame_line,
            ) = frame_match.groups()
        elif len(frame_match.groups()) == 8:
            (
                frame_id,
                frame_img_name,
                frame_addr,
                frame_symbol,
                frame_offset,
                frame_file,
                frame_line,
                frame_column,
            ) = frame_match.groups()

        self.thread.add_ident(frame_img_name)
        if frame_img_name not in self.crashlog.idents:
            self.crashlog.idents.append(frame_img_name)

        description = ""
        # Since images are parsed after threads, we need to build a
        # map for every image with a list of all the symbols and addresses
        if frame_img_name and frame_addr and frame_symbol:
            description = frame_symbol
            frame_offset_value = 0
            if frame_offset:
                description += " + " + frame_offset
                frame_offset_value = int(frame_offset, 0)
            if frame_img_name not in self.symbols:
                self.symbols[frame_img_name] = list()
            self.symbols[frame_img_name].append(
                {
                    "name": frame_symbol,
                    "address": int(frame_addr, 0) - frame_offset_value,
                }
            )

        self.thread.frames.append(
            self.crashlog.Frame(int(frame_id), int(frame_addr, 0), description)
        )

        return True

    def parse_images(self, line):
        image_match = self.image_regex_uuid.search(line)
        if image_match:
            (
                img_lo,
                img_hi,
                img_name,
                img_version,
                img_uuid,
                img_path,
            ) = image_match.groups()

            image = self.crashlog.DarwinImage(
                int(img_lo, 0),
                int(img_hi, 0),
                img_name.strip(),
                img_version.strip() if img_version else "",
                uuid.UUID(img_uuid),
                img_path,
                self.options.verbose,
            )
            unqualified_img_name = os.path.basename(img_path)
            if unqualified_img_name in self.symbols:
                for symbol in self.symbols[unqualified_img_name]:
                    image.symbols[symbol["name"]] = {
                        "name": symbol["name"],
                        "type": "code",
                        # NOTE: "address" is actually the symbol image offset
                        "address": symbol["address"] - int(img_lo, 0),
                    }

            self.crashlog.images.append(image)
            return True
        else:
            if self.options.debug:
                print("error: image regex failed for: %s" % line)
            return False

    def parse_thread_registers(self, line):
        # "r12: 0x00007fff6b5939c8  r13: 0x0000000007000006  r14: 0x0000000000002a03  r15: 0x0000000000000c00"
        reg_values = re.findall("([a-z0-9]+): (0x[0-9a-f]+)", line, re.I)
        for reg, value in reg_values:
            self.thread.registers[reg] = int(value, 16)
        return len(reg_values) != 0

    def parse_system(self, line):
        self.crashlog.system_profile.append(line)
        return True

    def parse_instructions(self, line):
        pass


def save_crashlog(debugger, command, exe_ctx, result, dict):
    usage = "save_crashlog [options] <output-path>"
    description = """Export the state of current target into a crashlog file"""
    parser = argparse.ArgumentParser(
        description=description,
        prog="save_crashlog",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "output",
        metavar="output-file",
        type=argparse.FileType("w", encoding="utf-8"),
        nargs=1,
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        dest="verbose",
        help="display verbose debug info",
        default=False,
    )
    try:
        options = parser.parse_args(shlex.split(command))
    except Exception as e:
        result.SetError(str(e))
        return
    target = exe_ctx.target
    if target:
        out_file = options.output[0]
        identifier = target.executable.basename
        process = exe_ctx.process
        if process:
            pid = process.id
            if pid != lldb.LLDB_INVALID_PROCESS_ID:
                out_file.write("Process:         %s [%u]\n" % (identifier, pid))
        out_file.write("Path:            %s\n" % (target.executable.fullpath))
        out_file.write("Identifier:      %s\n" % (identifier))
        out_file.write(
            "\nDate/Time:       %s\n"
            % (datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        )
        out_file.write(
            "OS Version:      Mac OS X %s (%s)\n"
            % (
                platform.mac_ver()[0],
                subprocess.check_output("sysctl -n kern.osversion", shell=True).decode(
                    "utf-8"
                ),
            )
        )
        out_file.write("Report Version:  9\n")
        for thread_idx in range(process.num_threads):
            thread = process.thread[thread_idx]
            out_file.write("\nThread %u:\n" % (thread_idx))
            for frame_idx, frame in enumerate(thread.frames):
                frame_pc = frame.pc
                frame_offset = 0
                if frame.function:
                    block = frame.GetFrameBlock()
                    block_range = block.range[frame.addr]
                    if block_range:
                        block_start_addr = block_range[0]
                        frame_offset = frame_pc - block_start_addr.GetLoadAddress(
                            target
                        )
                    else:
                        frame_offset = frame_pc - frame.function.addr.GetLoadAddress(
                            target
                        )
                elif frame.symbol:
                    frame_offset = frame_pc - frame.symbol.addr.GetLoadAddress(target)
                out_file.write(
                    "%-3u %-32s 0x%16.16x %s"
                    % (frame_idx, frame.module.file.basename, frame_pc, frame.name)
                )
                if frame_offset > 0:
                    out_file.write(" + %u" % (frame_offset))
                line_entry = frame.line_entry
                if line_entry:
                    if options.verbose:
                        # This will output the fullpath + line + column
                        out_file.write(" %s" % (line_entry))
                    else:
                        out_file.write(
                            " %s:%u" % (line_entry.file.basename, line_entry.line)
                        )
                        column = line_entry.column
                        if column:
                            out_file.write(":%u" % (column))
                out_file.write("\n")

        out_file.write("\nBinary Images:\n")
        for module in target.modules:
            text_segment = module.section["__TEXT"]
            if text_segment:
                text_segment_load_addr = text_segment.GetLoadAddress(target)
                if text_segment_load_addr != lldb.LLDB_INVALID_ADDRESS:
                    text_segment_end_load_addr = (
                        text_segment_load_addr + text_segment.size
                    )
                    identifier = module.file.basename
                    module_version = "???"
                    module_version_array = module.GetVersion()
                    if module_version_array:
                        module_version = ".".join(map(str, module_version_array))
                    out_file.write(
                        "    0x%16.16x - 0x%16.16x  %s (%s - ???) <%s> %s\n"
                        % (
                            text_segment_load_addr,
                            text_segment_end_load_addr,
                            identifier,
                            module_version,
                            module.GetUUIDString(),
                            module.file.fullpath,
                        )
                    )
        out_file.close()
    else:
        result.SetError("invalid target")


class Symbolicate:
    def __init__(self, debugger, internal_dict):
        pass

    def __call__(self, debugger, command, exe_ctx, result):
        SymbolicateCrashLogs(debugger, shlex.split(command), result, True)

    def get_short_help(self):
        return "Symbolicate one or more darwin crash log files."

    def get_long_help(self):
        arg_parser = CrashLogOptionParser()
        return arg_parser.format_help()


def SymbolicateCrashLog(crash_log, options):
    if options.debug:
        crash_log.dump()
    if not crash_log.images:
        print("error: no images in crash log")
        return

    if options.dump_image_list:
        print("Binary Images:")
        for image in crash_log.images:
            if options.verbose:
                print(image.debug_dump())
            else:
                print(image)

    target = crash_log.create_target()
    if not target:
        return

    if options.load_all_images:
        for image in crash_log.images:
            image.resolve = True
    elif options.crashed_only:
        for thread in crash_log.threads:
            if thread.did_crash():
                for ident in thread.idents:
                    for image in crash_log.find_images_with_identifier(ident):
                        image.resolve = True

    futures = []
    loaded_images = []
    with tempfile.TemporaryDirectory() as obj_dir:
        with concurrent.futures.ThreadPoolExecutor() as executor:

            def add_module(image, target, obj_dir):
                return image, image.add_module(target, obj_dir)

            for image in crash_log.images:
                futures.append(
                    executor.submit(
                        add_module, image=image, target=target, obj_dir=obj_dir
                    )
                )
            for future in concurrent.futures.as_completed(futures):
                image, err = future.result()
                if err:
                    print(err)
                else:
                    loaded_images.append(image)

    if crash_log.backtraces:
        for thread in crash_log.backtraces:
            thread.dump_symbolicated(crash_log, options)
            print()

    for thread in crash_log.threads:
        if options.crashed_only and not (
            thread.crashed or thread.app_specific_backtrace
        ):
            continue
        thread.dump_symbolicated(crash_log, options)
        print()

    if crash_log.errors:
        print("Errors:")
        for error in crash_log.errors:
            print(error)


def load_crashlog_in_scripted_process(debugger, crashlog_path, options, result):
    crashlog = CrashLogParser.create(debugger, crashlog_path, options).parse()

    target = lldb.SBTarget()
    # 1. Try to use the user-provided target
    if options.target_path:
        target = debugger.CreateTarget(options.target_path)
        if not target:
            raise InteractiveCrashLogException(
                "couldn't create target provided by the user (%s)" % options.target_path
            )

    # 2. If the user didn't provide a target, try to create a target using the symbolicator
    if not target or not target.IsValid():
        target = crashlog.create_target()
    # 3. If that didn't work, create a dummy target
    if target is None or not target.IsValid():
        arch = crashlog.process_arch
        if not arch:
            raise InteractiveCrashLogException(
                "couldn't create find the architecture to create the target"
            )
        target = debugger.CreateTargetWithFileAndArch(None, arch)
    # 4. Fail
    if target is None or not target.IsValid():
        raise InteractiveCrashLogException("couldn't create target")

    ci = debugger.GetCommandInterpreter()
    if not ci:
        raise InteractiveCrashLogException("couldn't get command interpreter")

    ci.HandleCommand("script from lldb.macosx import crashlog_scripted_process", result)
    if not result.Succeeded():
        raise InteractiveCrashLogException(
            "couldn't import crashlog scripted process module"
        )

    structured_data = lldb.SBStructuredData()
    structured_data.SetFromJSON(
        json.dumps(
            {"file_path": crashlog_path, "load_all_images": options.load_all_images}
        )
    )
    launch_info = lldb.SBLaunchInfo(None)
    launch_info.SetProcessPluginName("ScriptedProcess")
    launch_info.SetScriptedProcessClassName(
        "crashlog_scripted_process.CrashLogScriptedProcess"
    )
    launch_info.SetScriptedProcessDictionary(structured_data)
    launch_info.SetLaunchFlags(lldb.eLaunchFlagStopAtEntry)

    error = lldb.SBError()
    process = target.Launch(launch_info, error)

    if not process or error.Fail():
        raise InteractiveCrashLogException("couldn't launch Scripted Process", error)

    process.GetScriptedImplementation().set_crashlog(crashlog)
    process.Continue()

    if not options.skip_status:

        @contextlib.contextmanager
        def synchronous(debugger):
            async_state = debugger.GetAsync()
            debugger.SetAsync(False)
            try:
                yield
            finally:
                debugger.SetAsync(async_state)

        with synchronous(debugger):
            run_options = lldb.SBCommandInterpreterRunOptions()
            run_options.SetStopOnError(True)
            run_options.SetStopOnCrash(True)
            run_options.SetEchoCommands(True)

            commands_stream = lldb.SBStream()
            commands_stream.Print("process status --verbose\n")
            commands_stream.Print("thread backtrace --extended true\n")
            error = debugger.SetInputString(commands_stream.GetData())
            if error.Success():
                debugger.RunCommandInterpreter(True, False, run_options, 0, False, True)


def CreateSymbolicateCrashLogOptions(
    command_name, description, add_interactive_options
):
    usage = "crashlog [options] <FILE> [FILE ...]"
    arg_parser = argparse.ArgumentParser(
        description=description,
        prog="crashlog",
        usage=usage,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    arg_parser.add_argument(
        "reports",
        metavar="FILE",
        type=str,
        nargs="*",
        help="crash report(s) to symbolicate",
    )

    arg_parser.add_argument(
        "--version",
        "-V",
        dest="version",
        action="store_true",
        help="Show crashlog version",
        default=False,
    )
    arg_parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        dest="verbose",
        help="display verbose debug info",
        default=False,
    )
    arg_parser.add_argument(
        "--debug",
        "-g",
        action="store_true",
        dest="debug",
        help="display verbose debug logging",
        default=False,
    )
    arg_parser.add_argument(
        "--load-all",
        "-a",
        action="store_true",
        dest="load_all_images",
        help="load all executable images, not just the images found in the "
        "crashed stack frames, loads stackframes for all the threads in "
        "interactive mode.",
        default=False,
    )
    arg_parser.add_argument(
        "--images",
        action="store_true",
        dest="dump_image_list",
        help="show image list",
        default=False,
    )
    arg_parser.add_argument(
        "--debug-delay",
        type=int,
        dest="debug_delay",
        metavar="NSEC",
        help="pause for NSEC seconds for debugger",
        default=0,
    )
    # NOTE: Requires python 3.9
    # arg_parser.add_argument(
    #     "--crashed-only",
    #     "-c",
    #     action=argparse.BooleanOptionalAction,
    #     dest="crashed_only",
    #     help="only symbolicate the crashed thread",
    #     default=True,
    # )
    arg_parser.add_argument(
        "--crashed-only",
        "-c",
        action="store_true",
        dest="crashed_only",
        help="only symbolicate the crashed thread",
        default=True,
    )
    arg_parser.add_argument(
        "--no-crashed-only",
        action="store_false",
        dest="crashed_only",
        help="do not symbolicate the crashed thread",
    )
    arg_parser.add_argument(
        "--disasm-depth",
        "-d",
        type=int,
        dest="disassemble_depth",
        help="set the depth in stack frames that should be disassembled",
        default=1,
    )
    arg_parser.add_argument(
        "--disasm-all",
        "-D",
        action="store_true",
        dest="disassemble_all_threads",
        help="enabled disassembly of frames on all threads (not just the crashed thread)",
        default=False,
    )
    arg_parser.add_argument(
        "--disasm-before",
        "-B",
        type=int,
        dest="disassemble_before",
        help="the number of instructions to disassemble before the frame PC",
        default=4,
    )
    arg_parser.add_argument(
        "--disasm-after",
        "-A",
        type=int,
        dest="disassemble_after",
        help="the number of instructions to disassemble after the frame PC",
        default=4,
    )
    arg_parser.add_argument(
        "--source-context",
        "-C",
        type=int,
        metavar="NLINES",
        dest="source_context",
        help="show NLINES source lines of source context",
        default=4,
    )
    arg_parser.add_argument(
        "--source-frames",
        type=int,
        metavar="NFRAMES",
        dest="source_frames",
        help="show source for NFRAMES",
        default=4,
    )
    arg_parser.add_argument(
        "--source-all",
        action="store_true",
        dest="source_all",
        help="show source for all threads, not just the crashed thread",
        default=False,
    )
    if add_interactive_options:
        arg_parser.add_argument(
            "-i",
            "--interactive",
            action="store_true",
            help="parse a crash log and load it in a ScriptedProcess",
            default=False,
        )
        arg_parser.add_argument(
            "-b",
            "--batch",
            action="store_true",
            help="dump symbolicated stackframes without creating a debug session",
            default=True,
        )
        arg_parser.add_argument(
            "--target",
            "-t",
            dest="target_path",
            help="the target binary path that should be used for interactive crashlog (optional)",
            default=None,
        )
        arg_parser.add_argument(
            "--skip-status",
            "-s",
            dest="skip_status",
            action="store_true",
            help="prevent the interactive crashlog to dump the process status and thread backtrace at launch",
            default=False,
        )
    return arg_parser


def CrashLogOptionParser():
    description = """Symbolicate one or more darwin crash log files to provide source file and line information,
inlined stack frames back to the concrete functions, and disassemble the location of the crash
for the first frame of the crashed thread.
If this script is imported into the LLDB command interpreter, a "crashlog" command will be added to the interpreter
for use at the LLDB command line. After a crash log has been parsed and symbolicated, a target will have been
created that has all of the shared libraries loaded at the load addresses found in the crash log file. This allows
you to explore the program as if it were stopped at the locations described in the crash log and functions can
be disassembled and lookups can be performed using the addresses found in the crash log."""
    return CreateSymbolicateCrashLogOptions("crashlog", description, True)


def SymbolicateCrashLogs(debugger, command_args, result, is_command):
    arg_parser = CrashLogOptionParser()

    if not len(command_args):
        arg_parser.print_help()
        return

    try:
        options = arg_parser.parse_args(command_args)
    except Exception as e:
        result.SetError(str(e))
        return

    # Interactive mode requires running the crashlog command from inside lldb.
    if options.interactive and not is_command:
        lldb_exec = (
            subprocess.check_output(["/usr/bin/xcrun", "-f", "lldb"])
            .decode("utf-8")
            .strip()
        )
        sys.exit(
            os.execv(
                lldb_exec,
                [
                    lldb_exec,
                    "-o",
                    "command script import lldb.macosx",
                    "-o",
                    "crashlog {}".format(shlex.join(command_args)),
                ],
            )
        )

    if options.version:
        print(debugger.GetVersionString())
        return

    if options.debug:
        print("command_args = %s" % command_args)
        print("options", options)
        print("args", options.reports)

    if options.debug_delay > 0:
        print("Waiting %u seconds for debugger to attach..." % options.debug_delay)
        time.sleep(options.debug_delay)
    error = lldb.SBError()

    def should_run_in_interactive_mode(options, ci):
        if options.interactive:
            return True
        elif options.batch:
            return False
        # elif ci and ci.IsInteractive():
        #     return True
        else:
            return False

    ci = debugger.GetCommandInterpreter()

    if options.reports:
        for crashlog_file in options.reports:
            crashlog_path = os.path.expanduser(crashlog_file)
            if not os.path.exists(crashlog_path):
                raise FileNotFoundError(
                    "crashlog file %s does not exist" % crashlog_path
                )
            if should_run_in_interactive_mode(options, ci):
                try:
                    load_crashlog_in_scripted_process(
                        debugger, crashlog_path, options, result
                    )
                except InteractiveCrashLogException as e:
                    result.SetError(str(e))
            else:
                crash_log = CrashLogParser.create(
                    debugger, crashlog_path, options
                ).parse()
                SymbolicateCrashLog(crash_log, options)


if __name__ == "__main__":
    # Create a new debugger instance
    debugger = lldb.SBDebugger.Create()
    result = lldb.SBCommandReturnObject()
    SymbolicateCrashLogs(debugger, sys.argv[1:], result, False)
    lldb.SBDebugger.Destroy(debugger)


def __lldb_init_module(debugger, internal_dict):
    debugger.HandleCommand(
        "command script add -o -c lldb.macosx.crashlog.Symbolicate -C disk-file crashlog"
    )
    debugger.HandleCommand(
        "command script add -o -f lldb.macosx.crashlog.save_crashlog -C disk-file save_crashlog"
    )
    print(
        '"crashlog" and "save_crashlog" commands have been installed, use '
        'the "--help" options on these commands for detailed help.'
    )

```

`lldb/macosx/crashlog_scripted_process.py`:

```py
import os, json, struct, signal, uuid, tempfile

from typing import Any, Dict

import lldb
from lldb.plugins.scripted_process import ScriptedProcess
from lldb.plugins.scripted_process import ScriptedThread

from lldb.macosx.crashlog import CrashLog, CrashLogParser


class CrashLogScriptedProcess(ScriptedProcess):
    def set_crashlog(self, crashlog):
        self.crashlog = crashlog
        if self.crashlog.process_id:
            if type(self.crashlog.process_id) is int:
                self.pid = self.crashlog.process_id
            elif type(self.crashlog.process_id) is str:
                self.pid = int(self.crashlog.process_id, 0)
            else:
                self.pid = super().get_process_id()
        self.addr_mask = self.crashlog.addr_mask
        self.crashed_thread_idx = self.crashlog.crashed_thread_idx
        self.loaded_images = []
        self.exception = self.crashlog.exception
        self.app_specific_thread = None
        if hasattr(self.crashlog, "asi"):
            self.metadata["asi"] = self.crashlog.asi
        if hasattr(self.crashlog, "asb"):
            self.extended_thread_info = self.crashlog.asb

        if self.load_all_images:
            for image in self.crashlog.images:
                image.resolve = True
        else:
            for thread in self.crashlog.threads:
                if thread.did_crash():
                    for ident in thread.idents:
                        for image in self.crashlog.find_images_with_identifier(ident):
                            image.resolve = True

        with tempfile.TemporaryDirectory() as obj_dir:
            for image in self.crashlog.images:
                if image not in self.loaded_images:
                    if image.uuid == uuid.UUID(int=0):
                        continue
                    err = image.add_module(self.target, obj_dir)
                    if err:
                        # Append to SBCommandReturnObject
                        print(err)
                    else:
                        self.loaded_images.append(image)

        for thread in self.crashlog.threads:
            if (
                hasattr(thread, "app_specific_backtrace")
                and thread.app_specific_backtrace
            ):
                # We don't want to include the Application Specific Backtrace
                # Thread into the Scripted Process' Thread list.
                # Instead, we will try to extract the stackframe pcs from the
                # backtrace and inject that as the extended thread info.
                self.app_specific_thread = thread
                continue

            self.threads[thread.index] = CrashLogScriptedThread(self, None, thread)

        if self.app_specific_thread:
            self.extended_thread_info = CrashLogScriptedThread.resolve_stackframes(
                self.app_specific_thread, self.addr_mask, self.target
            )

    def __init__(self, exe_ctx: lldb.SBExecutionContext, args: lldb.SBStructuredData):
        super().__init__(exe_ctx, args)

        if not self.target or not self.target.IsValid():
            # Return error
            return

        self.crashlog_path = None

        crashlog_path = args.GetValueForKey("file_path")
        if crashlog_path and crashlog_path.IsValid():
            if crashlog_path.GetType() == lldb.eStructuredDataTypeString:
                self.crashlog_path = crashlog_path.GetStringValue(4096)

        if not self.crashlog_path:
            # Return error
            return

        load_all_images = args.GetValueForKey("load_all_images")
        if load_all_images and load_all_images.IsValid():
            if load_all_images.GetType() == lldb.eStructuredDataTypeBoolean:
                self.load_all_images = load_all_images.GetBooleanValue()

        if not self.load_all_images:
            self.load_all_images = False

        self.pid = super().get_process_id()
        self.crashed_thread_idx = 0
        self.exception = None
        self.extended_thread_info = None

    def read_memory_at_address(
        self, addr: int, size: int, error: lldb.SBError
    ) -> lldb.SBData:
        # NOTE: CrashLogs don't contain any memory.
        return lldb.SBData()

    def get_loaded_images(self):
        # TODO: Iterate over corefile_target modules and build a data structure
        # from it.
        return self.loaded_images

    def should_stop(self) -> bool:
        return True

    def is_alive(self) -> bool:
        return True

    def get_scripted_thread_plugin(self):
        return CrashLogScriptedThread.__module__ + "." + CrashLogScriptedThread.__name__

    def get_process_metadata(self):
        return self.metadata


class CrashLogScriptedThread(ScriptedThread):
    def create_register_ctx(self):
        if not self.has_crashed:
            return dict.fromkeys(
                [*map(lambda reg: reg["name"], self.register_info["registers"])], 0
            )

        if not self.backing_thread or not len(self.backing_thread.registers):
            return dict.fromkeys(
                [*map(lambda reg: reg["name"], self.register_info["registers"])], 0
            )

        for reg in self.register_info["registers"]:
            reg_name = reg["name"]
            if reg_name in self.backing_thread.registers:
                self.register_ctx[reg_name] = self.backing_thread.registers[reg_name]
            else:
                self.register_ctx[reg_name] = 0

        return self.register_ctx

    def resolve_stackframes(thread, addr_mask, target):
        frames = []
        for frame in thread.frames:
            frame_pc = frame.pc & addr_mask
            pc = frame_pc if frame.index == 0 or frame_pc == 0 else frame_pc - 1
            sym_addr = lldb.SBAddress()
            sym_addr.SetLoadAddress(pc, target)
            if not sym_addr.IsValid():
                continue
            frames.append({"idx": frame.index, "pc": pc})
        return frames

    def create_stackframes(self):
        if not (self.scripted_process.load_all_images or self.has_crashed):
            return None

        if not self.backing_thread or not len(self.backing_thread.frames):
            return None

        self.frames = CrashLogScriptedThread.resolve_stackframes(
            self.backing_thread, self.scripted_process.addr_mask, self.target
        )

        return self.frames

    def __init__(self, process, args, crashlog_thread):
        super().__init__(process, args)

        self.backing_thread = crashlog_thread
        self.idx = self.backing_thread.index
        self.tid = self.backing_thread.id
        if self.backing_thread.app_specific_backtrace:
            self.name = "Application Specific Backtrace"
        else:
            self.name = self.backing_thread.name
        self.queue = self.backing_thread.queue
        self.has_crashed = self.scripted_process.crashed_thread_idx == self.idx
        self.create_stackframes()

    def get_state(self):
        if not self.has_crashed:
            return lldb.eStateStopped
        return lldb.eStateCrashed

    def get_stop_reason(self) -> Dict[str, Any]:
        if not self.has_crashed:
            return {"type": lldb.eStopReasonNone}
        # TODO: Investigate what stop reason should be reported when crashed
        stop_reason = {"type": lldb.eStopReasonException, "data": {}}
        if self.scripted_process.exception:
            stop_reason["data"]["mach_exception"] = self.scripted_process.exception
        return stop_reason

    def get_register_context(self) -> str:
        if not self.register_ctx:
            self.register_ctx = self.create_register_ctx()

        return struct.pack(
            "{}Q".format(len(self.register_ctx)), *self.register_ctx.values()
        )

    def get_extended_info(self):
        if self.has_crashed:
            self.extended_info = self.scripted_process.extended_thread_info
        return self.extended_info

```

`lldb/macosx/heap.py`:

```py
#!/usr/bin/env python3

# ----------------------------------------------------------------------
# This module is designed to live inside the "lldb" python package
# in the "lldb.macosx" package. To use this in the embedded python
# interpreter using "lldb" just import it:
#
#   (lldb) script import lldb.macosx.heap
# ----------------------------------------------------------------------

import lldb
import optparse
import os
import os.path
import re
import shlex
import string
import sys
import tempfile
import lldb.utils.symbolication

g_libheap_dylib_dir = None
g_libheap_dylib_dict = dict()


def get_iterate_memory_expr(options, process, user_init_code, user_return_code):
    expr = """
typedef unsigned natural_t;
typedef uintptr_t vm_size_t;
typedef uintptr_t vm_address_t;
typedef natural_t task_t;
typedef int kern_return_t;
#define KERN_SUCCESS 0
typedef void (*range_callback_t)(task_t, void *, unsigned, uintptr_t, uintptr_t);
"""
    if options.search_vm_regions:
        expr += """
typedef int vm_prot_t;
typedef unsigned int vm_inherit_t;
typedef unsigned long long	memory_object_offset_t;
typedef unsigned int boolean_t;
typedef int vm_behavior_t;
typedef uint32_t vm32_object_id_t;
typedef natural_t mach_msg_type_number_t;
typedef uint64_t mach_vm_address_t;
typedef uint64_t mach_vm_offset_t;
typedef uint64_t mach_vm_size_t;
typedef uint64_t vm_map_offset_t;
typedef uint64_t vm_map_address_t;
typedef uint64_t vm_map_size_t;
#define	VM_PROT_NONE ((vm_prot_t) 0x00)
#define VM_PROT_READ ((vm_prot_t) 0x01)
#define VM_PROT_WRITE ((vm_prot_t) 0x02)
#define VM_PROT_EXECUTE ((vm_prot_t) 0x04)
typedef struct vm_region_submap_short_info_data_64_t {
    vm_prot_t protection;
    vm_prot_t max_protection;
    vm_inherit_t inheritance;
    memory_object_offset_t offset;		// offset into object/map
    unsigned int user_tag;	// user tag on map entry
    unsigned int ref_count;	 // obj/map mappers, etc
    unsigned short shadow_depth; 	// only for obj
    unsigned char external_pager;  // only for obj
    unsigned char share_mode;	// see enumeration
    boolean_t is_submap;	// submap vs obj
    vm_behavior_t behavior;	// access behavior hint
    vm32_object_id_t object_id;	// obj/map name, not a handle
    unsigned short user_wired_count;
} vm_region_submap_short_info_data_64_t;
#define VM_REGION_SUBMAP_SHORT_INFO_COUNT_64 ((mach_msg_type_number_t)(sizeof(vm_region_submap_short_info_data_64_t)/sizeof(int)))"""
        if user_init_code:
            expr += user_init_code
        expr += """
task_t task = (task_t)mach_task_self();
mach_vm_address_t vm_region_base_addr;
mach_vm_size_t vm_region_size;
natural_t vm_region_depth;
vm_region_submap_short_info_data_64_t vm_region_info;
kern_return_t err;
for (vm_region_base_addr = 0, vm_region_size = 1; vm_region_size != 0; vm_region_base_addr += vm_region_size)
{
    mach_msg_type_number_t vm_region_info_size = VM_REGION_SUBMAP_SHORT_INFO_COUNT_64;
    err = (kern_return_t)mach_vm_region_recurse (task,
                                                 &vm_region_base_addr,
                                                 &vm_region_size,
                                                 &vm_region_depth,
                                                 &vm_region_info,
                                                 &vm_region_info_size);
    if (err)
        break;
    // Check all read + write regions. This will cover the thread stacks
    // and any regions of memory like __DATA segments, that might contain
    // data we are looking for
    if (vm_region_info.protection & VM_PROT_WRITE &&
        vm_region_info.protection & VM_PROT_READ)
    {
        baton.callback (task,
                        &baton,
                        64,
                        vm_region_base_addr,
                        vm_region_size);
    }
}"""
    else:
        if options.search_stack:
            expr += get_thread_stack_ranges_struct(process)
        if options.search_segments:
            expr += get_sections_ranges_struct(process)
        if user_init_code:
            expr += user_init_code
        if options.search_heap:
            expr += """
#define MALLOC_PTR_IN_USE_RANGE_TYPE 1
typedef struct vm_range_t {
    vm_address_t	address;
    vm_size_t		size;
} vm_range_t;
typedef kern_return_t (*memory_reader_t)(task_t, vm_address_t, vm_size_t, void **);
typedef void (*vm_range_recorder_t)(task_t, void *, unsigned, vm_range_t *, unsigned);
typedef struct malloc_introspection_t {
    kern_return_t (*enumerator)(task_t task, void *, unsigned type_mask, vm_address_t zone_address, memory_reader_t reader, vm_range_recorder_t recorder); /* enumerates all the malloc pointers in use */
} malloc_introspection_t;
typedef struct malloc_zone_t {
    void *reserved1[12];
    struct malloc_introspection_t	*introspect;
} malloc_zone_t;
kern_return_t malloc_get_all_zones(task_t, memory_reader_t, vm_address_t **, unsigned *);
memory_reader_t task_peek = [](task_t, vm_address_t remote_address, vm_size_t, void **local_memory) -> kern_return_t {
    *local_memory = (void*) remote_address;
    return KERN_SUCCESS;
};
vm_address_t *zones = 0;
unsigned int num_zones = 0;task_t task = 0;
kern_return_t err = (kern_return_t)malloc_get_all_zones (task, task_peek, &zones, &num_zones);
if (KERN_SUCCESS == err)
{
    for (unsigned int i=0; i<num_zones; ++i)
    {
        const malloc_zone_t *zone = (const malloc_zone_t *)zones[i];
        if (zone && zone->introspect)
            zone->introspect->enumerator (task,
                                          &baton,
                                          MALLOC_PTR_IN_USE_RANGE_TYPE,
                                          (vm_address_t)zone,
                                          task_peek,
                                          [] (task_t task, void *baton, unsigned type, vm_range_t *ranges, unsigned size) -> void
                                          {
                                              range_callback_t callback = ((callback_baton_t *)baton)->callback;
                                              for (unsigned i=0; i<size; ++i)
                                              {
                                                  callback (task, baton, type, ranges[i].address, ranges[i].size);
                                              }
                                          });
    }
}"""

        if options.search_stack:
            expr += """
#ifdef NUM_STACKS
// Call the callback for the thread stack ranges
for (uint32_t i=0; i<NUM_STACKS; ++i) {
    range_callback(task, &baton, 8, stacks[i].base, stacks[i].size);
    if (STACK_RED_ZONE_SIZE > 0) {
        range_callback(task, &baton, 16, stacks[i].base - STACK_RED_ZONE_SIZE, STACK_RED_ZONE_SIZE);
    }
}
#endif"""

        if options.search_segments:
            expr += """
#ifdef NUM_SEGMENTS
// Call the callback for all segments
for (uint32_t i=0; i<NUM_SEGMENTS; ++i)
    range_callback(task, &baton, 32, segments[i].base, segments[i].size);
#endif"""

    if user_return_code:
        expr += "\n%s" % (user_return_code,)

    return expr


def get_member_types_for_offset(value_type, offset, member_list):
    member = value_type.GetFieldAtIndex(0)
    search_bases = False
    if member:
        if member.GetOffsetInBytes() <= offset:
            for field_idx in range(value_type.GetNumberOfFields()):
                member = value_type.GetFieldAtIndex(field_idx)
                member_byte_offset = member.GetOffsetInBytes()
                member_end_byte_offset = member_byte_offset + member.type.size
                if member_byte_offset <= offset and offset < member_end_byte_offset:
                    member_list.append(member)
                    get_member_types_for_offset(
                        member.type, offset - member_byte_offset, member_list
                    )
                    return
        else:
            search_bases = True
    else:
        search_bases = True
    if search_bases:
        for field_idx in range(value_type.GetNumberOfDirectBaseClasses()):
            member = value_type.GetDirectBaseClassAtIndex(field_idx)
            member_byte_offset = member.GetOffsetInBytes()
            member_end_byte_offset = member_byte_offset + member.type.size
            if member_byte_offset <= offset and offset < member_end_byte_offset:
                member_list.append(member)
                get_member_types_for_offset(
                    member.type, offset - member_byte_offset, member_list
                )
                return
        for field_idx in range(value_type.GetNumberOfVirtualBaseClasses()):
            member = value_type.GetVirtualBaseClassAtIndex(field_idx)
            member_byte_offset = member.GetOffsetInBytes()
            member_end_byte_offset = member_byte_offset + member.type.size
            if member_byte_offset <= offset and offset < member_end_byte_offset:
                member_list.append(member)
                get_member_types_for_offset(
                    member.type, offset - member_byte_offset, member_list
                )
                return


def append_regex_callback(option, opt, value, parser):
    try:
        ivar_regex = re.compile(value)
        parser.values.ivar_regex_exclusions.append(ivar_regex)
    except:
        print(
            'error: an exception was thrown when compiling the ivar regular expression for "%s"'
            % value
        )


def add_common_options(parser):
    parser.add_option(
        "-v",
        "--verbose",
        action="store_true",
        dest="verbose",
        help="display verbose debug info",
        default=False,
    )
    parser.add_option(
        "-t",
        "--type",
        action="store_true",
        dest="print_type",
        help="print the full value of the type for each matching malloc block",
        default=False,
    )
    parser.add_option(
        "-o",
        "--po",
        action="store_true",
        dest="print_object_description",
        help="print the object descriptions for any matches",
        default=False,
    )
    parser.add_option(
        "-z",
        "--size",
        action="store_true",
        dest="show_size",
        help="print the allocation size in bytes",
        default=False,
    )
    parser.add_option(
        "-r",
        "--range",
        action="store_true",
        dest="show_range",
        help="print the allocation address range instead of just the allocation base address",
        default=False,
    )
    parser.add_option(
        "-m",
        "--memory",
        action="store_true",
        dest="memory",
        help="dump the memory for each matching block",
        default=False,
    )
    parser.add_option(
        "-f",
        "--format",
        type="string",
        dest="format",
        help="the format to use when dumping memory if --memory is specified",
        default=None,
    )
    parser.add_option(
        "-I",
        "--omit-ivar-regex",
        type="string",
        action="callback",
        callback=append_regex_callback,
        dest="ivar_regex_exclusions",
        default=[],
        help="specify one or more regular expressions used to backlist any matches that are in ivars",
    )
    parser.add_option(
        "-s",
        "--stack",
        action="store_true",
        dest="stack",
        help="gets the stack that allocated each malloc block if MallocStackLogging is enabled",
        default=False,
    )
    parser.add_option(
        "-S",
        "--stack-history",
        action="store_true",
        dest="stack_history",
        help="gets the stack history for all allocations whose start address matches each malloc block if MallocStackLogging is enabled",
        default=False,
    )
    parser.add_option(
        "-F",
        "--max-frames",
        type="int",
        dest="max_frames",
        help="the maximum number of stack frames to print when using the --stack or --stack-history options (default=128)",
        default=128,
    )
    parser.add_option(
        "-H",
        "--max-history",
        type="int",
        dest="max_history",
        help="the maximum number of stack history backtraces to print for each allocation when using the --stack-history option (default=16)",
        default=16,
    )
    parser.add_option(
        "-M",
        "--max-matches",
        type="int",
        dest="max_matches",
        help="the maximum number of matches to print",
        default=32,
    )
    parser.add_option(
        "-O",
        "--offset",
        type="int",
        dest="offset",
        help="the matching data must be at this offset",
        default=-1,
    )
    parser.add_option(
        "--ignore-stack",
        action="store_false",
        dest="search_stack",
        help="Don't search the stack when enumerating memory",
        default=True,
    )
    parser.add_option(
        "--ignore-heap",
        action="store_false",
        dest="search_heap",
        help="Don't search the heap allocations when enumerating memory",
        default=True,
    )
    parser.add_option(
        "--ignore-segments",
        action="store_false",
        dest="search_segments",
        help="Don't search readable executable segments enumerating memory",
        default=True,
    )
    parser.add_option(
        "-V",
        "--vm-regions",
        action="store_true",
        dest="search_vm_regions",
        help="Check all VM regions instead of searching the heap, stack and segments",
        default=False,
    )


def type_flags_to_string(type_flags):
    if type_flags == 0:
        type_str = "free"
    elif type_flags & 2:
        type_str = "malloc"
    elif type_flags & 4:
        type_str = "free"
    elif type_flags & 1:
        type_str = "generic"
    elif type_flags & 8:
        type_str = "stack"
    elif type_flags & 16:
        type_str = "stack (red zone)"
    elif type_flags & 32:
        type_str = "segment"
    elif type_flags & 64:
        type_str = "vm_region"
    else:
        type_str = hex(type_flags)
    return type_str


def find_variable_containing_address(verbose, frame, match_addr):
    variables = frame.GetVariables(True, True, True, True)
    matching_var = None
    for var in variables:
        var_addr = var.GetLoadAddress()
        if var_addr != lldb.LLDB_INVALID_ADDRESS:
            byte_size = var.GetType().GetByteSize()
            if verbose:
                print(
                    "frame #%u: [%#x - %#x) %s"
                    % (
                        frame.GetFrameID(),
                        var.load_addr,
                        var.load_addr + byte_size,
                        var.name,
                    )
                )
            if var_addr == match_addr:
                if verbose:
                    print("match")
                return var
            else:
                if (
                    byte_size > 0
                    and var_addr <= match_addr
                    and match_addr < (var_addr + byte_size)
                ):
                    if verbose:
                        print("match")
                    return var
    return None


def find_frame_for_stack_address(process, addr):
    closest_delta = sys.maxsize
    closest_frame = None
    # print 'find_frame_for_stack_address(%#x)' % (addr)
    for thread in process:
        prev_sp = lldb.LLDB_INVALID_ADDRESS
        for frame in thread:
            cfa = frame.GetCFA()
            # print 'frame #%u: cfa = %#x' % (frame.GetFrameID(), cfa)
            if addr < cfa:
                delta = cfa - addr
                # print '%#x < %#x, delta = %i' % (addr, cfa, delta)
                if delta < closest_delta:
                    # print 'closest'
                    closest_delta = delta
                    closest_frame = frame
                # else:
                #     print 'delta >= closest_delta'
    return closest_frame


def type_flags_to_description(
    process, type_flags, ptr_addr, ptr_size, offset, match_addr
):
    show_offset = False
    if type_flags == 0 or type_flags & 4:
        type_str = "free(%#x)" % (ptr_addr,)
    elif type_flags & 2 or type_flags & 1:
        type_str = "malloc(%6u) -> %#x" % (ptr_size, ptr_addr)
        show_offset = True
    elif type_flags & 8:
        type_str = "stack"
        frame = find_frame_for_stack_address(process, match_addr)
        if frame:
            type_str += " in frame #%u of thread #%u: tid %#x" % (
                frame.GetFrameID(),
                frame.GetThread().GetIndexID(),
                frame.GetThread().GetThreadID(),
            )
        variables = frame.GetVariables(True, True, True, True)
        matching_var = None
        for var in variables:
            var_addr = var.GetLoadAddress()
            if var_addr != lldb.LLDB_INVALID_ADDRESS:
                # print 'variable "%s" @ %#x (%#x)' % (var.name, var.load_addr,
                # match_addr)
                if var_addr == match_addr:
                    matching_var = var
                    break
                else:
                    byte_size = var.GetType().GetByteSize()
                    if (
                        byte_size > 0
                        and var_addr <= match_addr
                        and match_addr < (var_addr + byte_size)
                    ):
                        matching_var = var
                        break
        if matching_var:
            type_str += " in variable at %#x:\n    %s" % (
                matching_var.GetLoadAddress(),
                matching_var,
            )
    elif type_flags & 16:
        type_str = "stack (red zone)"
    elif type_flags & 32:
        sb_addr = process.GetTarget().ResolveLoadAddress(ptr_addr + offset)
        type_str = "segment [%#x - %#x), %s + %u, %s" % (
            ptr_addr,
            ptr_addr + ptr_size,
            sb_addr.section.name,
            sb_addr.offset,
            sb_addr,
        )
    elif type_flags & 64:
        sb_addr = process.GetTarget().ResolveLoadAddress(ptr_addr + offset)
        type_str = "vm_region [%#x - %#x), %s + %u, %s" % (
            ptr_addr,
            ptr_addr + ptr_size,
            sb_addr.section.name,
            sb_addr.offset,
            sb_addr,
        )
    else:
        type_str = "%#x" % (ptr_addr,)
        show_offset = True
    if show_offset and offset != 0:
        type_str += " + %-6u" % (offset,)
    return type_str


def dump_stack_history_entry(options, result, stack_history_entry, idx):
    address = int(stack_history_entry.address)
    if address:
        type_flags = int(stack_history_entry.type_flags)
        symbolicator = lldb.utils.symbolication.Symbolicator()
        symbolicator.target = lldb.debugger.GetSelectedTarget()
        type_str = type_flags_to_string(type_flags)
        result.AppendMessage(
            "stack[%u]: addr = 0x%x, type=%s, frames:" % (idx, address, type_str)
        )
        frame_idx = 0
        idx = 0
        pc = int(stack_history_entry.frames[idx])
        while pc != 0:
            if pc >= 0x1000:
                frames = symbolicator.symbolicate(pc)
                if frames:
                    for frame in frames:
                        result.AppendMessage("     [%u] %s" % (frame_idx, frame))
                        frame_idx += 1
                else:
                    result.AppendMessage("     [%u] 0x%x" % (frame_idx, pc))
                    frame_idx += 1
                idx = idx + 1
                pc = int(stack_history_entry.frames[idx])
            else:
                pc = 0
        if idx >= options.max_frames:
            result.AppendMessage(
                'warning: the max number of stack frames (%u) was reached, use the "--max-frames=<COUNT>" option to see more frames'
                % (options.max_frames)
            )

        result.AppendMessage("")


def dump_stack_history_entries(options, result, addr, history):
    # malloc_stack_entry *get_stack_history_for_address (const void * addr)
    expr_prefix = """
typedef int kern_return_t;
typedef struct $malloc_stack_entry {
    uint64_t address;
    uint64_t argument;
    uint32_t type_flags;
    uint32_t num_frames;
    uint64_t frames[512];
    kern_return_t err;
} $malloc_stack_entry;
"""
    single_expr = """
#define MAX_FRAMES %u
typedef unsigned task_t;
$malloc_stack_entry stack;
stack.address = 0x%x;
stack.type_flags = 2;
stack.num_frames = 0;
stack.frames[0] = 0;
uint32_t max_stack_frames = MAX_FRAMES;
stack.err = (kern_return_t)__mach_stack_logging_get_frames (
    (task_t)mach_task_self(),
    stack.address,
    &stack.frames[0],
    max_stack_frames,
    &stack.num_frames);
if (stack.num_frames < MAX_FRAMES)
    stack.frames[stack.num_frames] = 0;
else
    stack.frames[MAX_FRAMES-1] = 0;
stack""" % (
        options.max_frames,
        addr,
    )

    history_expr = """
typedef int kern_return_t;
typedef unsigned task_t;
#define MAX_FRAMES %u
#define MAX_HISTORY %u
typedef struct mach_stack_logging_record_t {
	uint32_t type_flags;
	uint64_t stack_identifier;
	uint64_t argument;
	uint64_t address;
} mach_stack_logging_record_t;
typedef void (*enumerate_callback_t)(mach_stack_logging_record_t, void *);
typedef struct malloc_stack_entry {
    uint64_t address;
    uint64_t argument;
    uint32_t type_flags;
    uint32_t num_frames;
    uint64_t frames[MAX_FRAMES];
    kern_return_t frames_err;
} malloc_stack_entry;
typedef struct $malloc_stack_history {
    task_t task;
    unsigned idx;
    malloc_stack_entry entries[MAX_HISTORY];
} $malloc_stack_history;
$malloc_stack_history lldb_info = { (task_t)mach_task_self(), 0 };
uint32_t max_stack_frames = MAX_FRAMES;
enumerate_callback_t callback = [] (mach_stack_logging_record_t stack_record, void *baton) -> void {
    $malloc_stack_history *lldb_info = ($malloc_stack_history *)baton;
    if (lldb_info->idx < MAX_HISTORY) {
        malloc_stack_entry *stack_entry = &(lldb_info->entries[lldb_info->idx]);
        stack_entry->address = stack_record.address;
        stack_entry->type_flags = stack_record.type_flags;
        stack_entry->argument = stack_record.argument;
        stack_entry->num_frames = 0;
        stack_entry->frames[0] = 0;
        stack_entry->frames_err = (kern_return_t)__mach_stack_logging_frames_for_uniqued_stack (
            lldb_info->task,
            stack_record.stack_identifier,
            stack_entry->frames,
            (uint32_t)MAX_FRAMES,
            &stack_entry->num_frames);
        // Terminate the frames with zero if there is room
        if (stack_entry->num_frames < MAX_FRAMES)
            stack_entry->frames[stack_entry->num_frames] = 0;
    }
    ++lldb_info->idx;
};
(kern_return_t)__mach_stack_logging_enumerate_records (lldb_info.task, (uint64_t)0x%x, callback, &lldb_info);
lldb_info""" % (
        options.max_frames,
        options.max_history,
        addr,
    )

    frame = (
        lldb.debugger.GetSelectedTarget()
        .GetProcess()
        .GetSelectedThread()
        .GetSelectedFrame()
    )
    if history:
        expr = history_expr
    else:
        expr = single_expr
    expr_options = lldb.SBExpressionOptions()
    expr_options.SetIgnoreBreakpoints(True)
    expr_options.SetTimeoutInMicroSeconds(5 * 1000 * 1000)  # 5 second timeout
    expr_options.SetTryAllThreads(True)
    expr_options.SetLanguage(lldb.eLanguageTypeObjC_plus_plus)
    expr_options.SetPrefix(expr_prefix)
    expr_sbvalue = frame.EvaluateExpression(expr, expr_options)
    if options.verbose:
        print("expression:")
        print(expr)
        print("expression result:")
        print(expr_sbvalue)
    if expr_sbvalue.error.Success():
        if history:
            malloc_stack_history = lldb.value(expr_sbvalue)
            num_stacks = int(malloc_stack_history.idx)
            if num_stacks <= options.max_history:
                i_max = num_stacks
            else:
                i_max = options.max_history
            for i in range(i_max):
                stack_history_entry = malloc_stack_history.entries[i]
                dump_stack_history_entry(options, result, stack_history_entry, i)
            if num_stacks > options.max_history:
                result.AppendMessage(
                    'warning: the max number of stacks (%u) was reached, use the "--max-history=%u" option to see all of the stacks'
                    % (options.max_history, num_stacks)
                )
        else:
            stack_history_entry = lldb.value(expr_sbvalue)
            dump_stack_history_entry(options, result, stack_history_entry, 0)

    else:
        result.AppendMessage(
            'error: expression failed "%s" => %s' % (expr, expr_sbvalue.error)
        )


def display_match_results(
    process,
    result,
    options,
    arg_str_description,
    expr,
    print_no_matches,
    expr_prefix=None,
):
    frame = (
        lldb.debugger.GetSelectedTarget()
        .GetProcess()
        .GetSelectedThread()
        .GetSelectedFrame()
    )
    if not frame:
        result.AppendMessage("error: invalid frame")
        return 0
    expr_options = lldb.SBExpressionOptions()
    expr_options.SetIgnoreBreakpoints(True)
    expr_options.SetFetchDynamicValue(lldb.eNoDynamicValues)
    expr_options.SetTimeoutInMicroSeconds(30 * 1000 * 1000)  # 30 second timeout
    expr_options.SetTryAllThreads(False)
    expr_options.SetLanguage(lldb.eLanguageTypeObjC_plus_plus)
    if expr_prefix:
        expr_options.SetPrefix(expr_prefix)
    expr_sbvalue = frame.EvaluateExpression(expr, expr_options)
    if options.verbose:
        print("expression:")
        print(expr)
        print("expression result:")
        print(expr_sbvalue)
    if expr_sbvalue.error.Success():
        match_value = lldb.value(expr_sbvalue)
        i = 0
        match_idx = 0
        while True:
            print_entry = True
            match_entry = match_value[i]
            i += 1
            if i > options.max_matches:
                result.AppendMessage(
                    "warning: the max number of matches (%u) was reached, use the --max-matches option to get more results"
                    % (options.max_matches)
                )
                break
            malloc_addr = match_entry.addr.sbvalue.unsigned
            if malloc_addr == 0:
                break
            malloc_size = int(match_entry.size)
            offset = int(match_entry.offset)

            if options.offset >= 0 and options.offset != offset:
                print_entry = False
            else:
                match_addr = malloc_addr + offset
                type_flags = int(match_entry.type)
                # result.AppendMessage (hex(malloc_addr + offset))
                if type_flags == 64:
                    search_stack_old = options.search_stack
                    search_segments_old = options.search_segments
                    search_heap_old = options.search_heap
                    search_vm_regions = options.search_vm_regions
                    options.search_stack = True
                    options.search_segments = True
                    options.search_heap = True
                    options.search_vm_regions = False
                    if malloc_info_impl(
                        lldb.debugger, result, options, [hex(malloc_addr + offset)]
                    ):
                        print_entry = False
                    options.search_stack = search_stack_old
                    options.search_segments = search_segments_old
                    options.search_heap = search_heap_old
                    options.search_vm_regions = search_vm_regions
                if print_entry:
                    description = "%#16.16x: %s" % (
                        match_addr,
                        type_flags_to_description(
                            process,
                            type_flags,
                            malloc_addr,
                            malloc_size,
                            offset,
                            match_addr,
                        ),
                    )
                    if options.show_size:
                        description += " <%5u>" % (malloc_size)
                    if options.show_range:
                        description += " [%#x - %#x)" % (
                            malloc_addr,
                            malloc_addr + malloc_size,
                        )
                    derefed_dynamic_value = None
                    dynamic_value = match_entry.addr.sbvalue.GetDynamicValue(
                        lldb.eDynamicCanRunTarget
                    )
                    if dynamic_value.type.name == "void *":
                        if options.type == "pointer" and malloc_size == 4096:
                            error = lldb.SBError()
                            process = expr_sbvalue.GetProcess()
                            target = expr_sbvalue.GetTarget()
                            data = bytearray(process.ReadMemory(malloc_addr, 16, error))
                            if data == "\xa1\xa1\xa1\xa1AUTORELEASE!":
                                ptr_size = target.addr_size
                                thread = process.ReadUnsignedFromMemory(
                                    malloc_addr + 16 + ptr_size, ptr_size, error
                                )
                                #   4 bytes  0xa1a1a1a1
                                #  12 bytes  'AUTORELEASE!'
                                # ptr bytes  autorelease insertion point
                                # ptr bytes  pthread_t
                                # ptr bytes  next colder page
                                # ptr bytes  next hotter page
                                #   4 bytes  this page's depth in the list
                                #   4 bytes  high-water mark
                                description += " AUTORELEASE! for pthread_t %#x" % (
                                    thread
                                )
                        #     else:
                        #         description += 'malloc(%u)' % (malloc_size)
                        # else:
                        #     description += 'malloc(%u)' % (malloc_size)
                    else:
                        derefed_dynamic_value = dynamic_value.deref
                        if derefed_dynamic_value:
                            derefed_dynamic_type = derefed_dynamic_value.type
                            derefed_dynamic_type_size = derefed_dynamic_type.size
                            derefed_dynamic_type_name = derefed_dynamic_type.name
                            description += " "
                            description += derefed_dynamic_type_name
                            if offset < derefed_dynamic_type_size:
                                member_list = list()
                                get_member_types_for_offset(
                                    derefed_dynamic_type, offset, member_list
                                )
                                if member_list:
                                    member_path = ""
                                    for member in member_list:
                                        member_name = member.name
                                        if member_name:
                                            if member_path:
                                                member_path += "."
                                            member_path += member_name
                                    if member_path:
                                        if options.ivar_regex_exclusions:
                                            for (
                                                ivar_regex
                                            ) in options.ivar_regex_exclusions:
                                                if ivar_regex.match(member_path):
                                                    print_entry = False
                                        description += ".%s" % (member_path)
                            else:
                                description += "%u bytes after %s" % (
                                    offset - derefed_dynamic_type_size,
                                    derefed_dynamic_type_name,
                                )
                        else:
                            # strip the "*" from the end of the name since we
                            # were unable to dereference this
                            description += dynamic_value.type.name[0:-1]
            if print_entry:
                match_idx += 1
                result_output = ""
                if description:
                    result_output += description
                    if options.print_type and derefed_dynamic_value:
                        result_output += " %s" % (derefed_dynamic_value)
                    if options.print_object_description and dynamic_value:
                        desc = dynamic_value.GetObjectDescription()
                        if desc:
                            result_output += "\n%s" % (desc)
                if result_output:
                    result.AppendMessage(result_output)
                if options.memory:
                    cmd_result = lldb.SBCommandReturnObject()
                    if options.format is None:
                        memory_command = "memory read --force 0x%x 0x%x" % (
                            malloc_addr,
                            malloc_addr + malloc_size,
                        )
                    else:
                        memory_command = "memory read --force -f %s 0x%x 0x%x" % (
                            options.format,
                            malloc_addr,
                            malloc_addr + malloc_size,
                        )
                    if options.verbose:
                        result.AppendMessage(memory_command)
                    lldb.debugger.GetCommandInterpreter().HandleCommand(
                        memory_command, cmd_result
                    )
                    result.AppendMessage(cmd_result.GetOutput())
                if options.stack_history:
                    dump_stack_history_entries(options, result, malloc_addr, 1)
                elif options.stack:
                    dump_stack_history_entries(options, result, malloc_addr, 0)
        return i
    else:
        result.AppendMessage(str(expr_sbvalue.error))
    return 0


def get_ptr_refs_options():
    usage = "usage: %prog [options] <EXPR> [EXPR ...]"
    description = """Searches all allocations on the heap for pointer values on
darwin user space programs. Any matches that were found will dump the malloc
blocks that contain the pointers and might be able to print what kind of
objects the pointers are contained in using dynamic type information in the
program."""
    parser = optparse.OptionParser(
        description=description, prog="ptr_refs", usage=usage
    )
    add_common_options(parser)
    return parser


def find_variable(debugger, command, result, dict):
    usage = "usage: %prog [options] <ADDR> [ADDR ...]"
    description = (
        """Searches for a local variable in all frames that contains a hex ADDR."""
    )
    command_args = shlex.split(command)
    parser = optparse.OptionParser(
        description=description, prog="find_variable", usage=usage
    )
    parser.add_option(
        "-v",
        "--verbose",
        action="store_true",
        dest="verbose",
        help="display verbose debug info",
        default=False,
    )
    try:
        (options, args) = parser.parse_args(command_args)
    except:
        return

    process = debugger.GetSelectedTarget().GetProcess()
    if not process:
        result.AppendMessage("error: invalid process")
        return

    for arg in args:
        var_addr = int(arg, 16)
        print("Finding a variable with address %#x..." % (var_addr), file=result)
        done = False
        for thread in process:
            for frame in thread:
                var = find_variable_containing_address(options.verbose, frame, var_addr)
                if var:
                    print(var)
                    done = True
                    break
            if done:
                break


def ptr_refs(debugger, command, result, dict):
    command_args = shlex.split(command)
    parser = get_ptr_refs_options()
    try:
        (options, args) = parser.parse_args(command_args)
    except:
        return

    process = debugger.GetSelectedTarget().GetProcess()
    if not process:
        result.AppendMessage("error: invalid process")
        return
    frame = process.GetSelectedThread().GetSelectedFrame()
    if not frame:
        result.AppendMessage("error: invalid frame")
        return

    options.type = "pointer"
    if options.format is None:
        options.format = "A"  # 'A' is "address" format

    if args:
        # When we initialize the expression, we must define any types that
        # we will need when looking at every allocation. We must also define
        # a type named callback_baton_t and make an instance named "baton"
        # and initialize it how ever we want to. The address of "baton" will
        # be passed into our range callback. callback_baton_t must contain
        # a member named "callback" whose type is "range_callback_t". This
        # will be used by our zone callbacks to call the range callback for
        # each malloc range.
        expr_prefix = """
struct $malloc_match {
    void *addr;
    uintptr_t size;
    uintptr_t offset;
    uintptr_t type;
};
"""
        user_init_code_format = """
#define MAX_MATCHES %u
typedef struct callback_baton_t {
    range_callback_t callback;
    unsigned num_matches;
    $malloc_match matches[MAX_MATCHES];
    void *ptr;
} callback_baton_t;
range_callback_t range_callback = [](task_t task, void *baton, unsigned type, uintptr_t ptr_addr, uintptr_t ptr_size) -> void {
    callback_baton_t *lldb_info = (callback_baton_t *)baton;
    typedef void* T;
    const unsigned size = sizeof(T);
    T *array = (T*)ptr_addr;
    for (unsigned idx = 0; ((idx + 1) * sizeof(T)) <= ptr_size; ++idx) {
        if (array[idx] == lldb_info->ptr) {
            if (lldb_info->num_matches < MAX_MATCHES) {
                lldb_info->matches[lldb_info->num_matches].addr = (void*)ptr_addr;
                lldb_info->matches[lldb_info->num_matches].size = ptr_size;
                lldb_info->matches[lldb_info->num_matches].offset = idx*sizeof(T);
                lldb_info->matches[lldb_info->num_matches].type = type;
                ++lldb_info->num_matches;
            }
        }
    }
};
callback_baton_t baton = { range_callback, 0, {0}, (void *)%s };
"""
        # We must also define a snippet of code to be run that returns
        # the result of the expression we run.
        # Here we return NULL if our pointer was not found in any malloc blocks,
        # and we return the address of the matches array so we can then access
        # the matching results
        user_return_code = """if (baton.num_matches < MAX_MATCHES)
    baton.matches[baton.num_matches].addr = 0; // Terminate the matches array
baton.matches"""
        # Iterate through all of our pointer expressions and display the
        # results
        for ptr_expr in args:
            user_init_code = user_init_code_format % (options.max_matches, ptr_expr)
            expr = get_iterate_memory_expr(
                options, process, user_init_code, user_return_code
            )
            arg_str_description = "malloc block containing pointer %s" % ptr_expr
            display_match_results(
                process, result, options, arg_str_description, expr, True, expr_prefix
            )
    else:
        result.AppendMessage("error: no pointer arguments were given")


def get_cstr_refs_options():
    usage = "usage: %prog [options] <CSTR> [CSTR ...]"
    description = """Searches all allocations on the heap for C string values on
darwin user space programs. Any matches that were found will dump the malloc
blocks that contain the C strings and might be able to print what kind of
objects the pointers are contained in using dynamic type information in the
program."""
    parser = optparse.OptionParser(
        description=description, prog="cstr_refs", usage=usage
    )
    add_common_options(parser)
    return parser


def cstr_refs(debugger, command, result, dict):
    command_args = shlex.split(command)
    parser = get_cstr_refs_options()
    try:
        (options, args) = parser.parse_args(command_args)
    except:
        return

    process = debugger.GetSelectedTarget().GetProcess()
    if not process:
        result.AppendMessage("error: invalid process")
        return
    frame = process.GetSelectedThread().GetSelectedFrame()
    if not frame:
        result.AppendMessage("error: invalid frame")
        return

    options.type = "cstr"
    if options.format is None:
        options.format = "Y"  # 'Y' is "bytes with ASCII" format

    if args:
        # When we initialize the expression, we must define any types that
        # we will need when looking at every allocation. We must also define
        # a type named callback_baton_t and make an instance named "baton"
        # and initialize it how ever we want to. The address of "baton" will
        # be passed into our range callback. callback_baton_t must contain
        # a member named "callback" whose type is "range_callback_t". This
        # will be used by our zone callbacks to call the range callback for
        # each malloc range.
        expr_prefix = """
struct $malloc_match {
    void *addr;
    uintptr_t size;
    uintptr_t offset;
    uintptr_t type;
};
"""
        user_init_code_format = """
#define MAX_MATCHES %u
typedef struct callback_baton_t {
    range_callback_t callback;
    unsigned num_matches;
    $malloc_match matches[MAX_MATCHES];
    const char *cstr;
    unsigned cstr_len;
} callback_baton_t;
range_callback_t range_callback = [](task_t task, void *baton, unsigned type, uintptr_t ptr_addr, uintptr_t ptr_size) -> void {
    callback_baton_t *lldb_info = (callback_baton_t *)baton;
    if (lldb_info->cstr_len < ptr_size) {
        const char *begin = (const char *)ptr_addr;
        const char *end = begin + ptr_size - lldb_info->cstr_len;
        for (const char *s = begin; s < end; ++s) {
            if ((int)memcmp(s, lldb_info->cstr, lldb_info->cstr_len) == 0) {
                if (lldb_info->num_matches < MAX_MATCHES) {
                    lldb_info->matches[lldb_info->num_matches].addr = (void*)ptr_addr;
                    lldb_info->matches[lldb_info->num_matches].size = ptr_size;
                    lldb_info->matches[lldb_info->num_matches].offset = s - begin;
                    lldb_info->matches[lldb_info->num_matches].type = type;
                    ++lldb_info->num_matches;
                }
            }
        }
    }
};
const char *cstr = "%s";
callback_baton_t baton = { range_callback, 0, {0}, cstr, (unsigned)strlen(cstr) };"""
        # We must also define a snippet of code to be run that returns
        # the result of the expression we run.
        # Here we return NULL if our pointer was not found in any malloc blocks,
        # and we return the address of the matches array so we can then access
        # the matching results
        user_return_code = """if (baton.num_matches < MAX_MATCHES)
    baton.matches[baton.num_matches].addr = 0; // Terminate the matches array
baton.matches"""
        # Iterate through all of our pointer expressions and display the
        # results
        for cstr in args:
            user_init_code = user_init_code_format % (options.max_matches, cstr)
            expr = get_iterate_memory_expr(
                options, process, user_init_code, user_return_code
            )
            arg_str_description = 'malloc block containing "%s"' % cstr
            display_match_results(
                process, result, options, arg_str_description, expr, True, expr_prefix
            )
    else:
        result.AppendMessage("error: command takes one or more C string arguments")


def get_malloc_info_options():
    usage = "usage: %prog [options] <EXPR> [EXPR ...]"
    description = """Searches the heap a malloc block that contains the addresses
specified as one or more address expressions. Any matches that were found will
dump the malloc blocks that match or contain the specified address. The matching
blocks might be able to show what kind of objects they are using dynamic type
information in the program."""
    parser = optparse.OptionParser(
        description=description, prog="malloc_info", usage=usage
    )
    add_common_options(parser)
    return parser


def malloc_info(debugger, command, result, dict):
    command_args = shlex.split(command)
    parser = get_malloc_info_options()
    try:
        (options, args) = parser.parse_args(command_args)
    except:
        return
    malloc_info_impl(debugger, result, options, args)


def malloc_info_impl(debugger, result, options, args):
    # We are specifically looking for something on the heap only
    options.type = "malloc_info"

    process = debugger.GetSelectedTarget().GetProcess()
    if not process:
        result.AppendMessage("error: invalid process")
        return
    frame = process.GetSelectedThread().GetSelectedFrame()
    if not frame:
        result.AppendMessage("error: invalid frame")
        return
    expr_prefix = """
struct $malloc_match {
    void *addr;
    uintptr_t size;
    uintptr_t offset;
    uintptr_t type;
};
"""

    user_init_code_format = """
typedef struct callback_baton_t {
    range_callback_t callback;
    unsigned num_matches;
    $malloc_match matches[2]; // Two items so they can be NULL terminated
    void *ptr;
} callback_baton_t;
range_callback_t range_callback = [](task_t task, void *baton, unsigned type, uintptr_t ptr_addr, uintptr_t ptr_size) -> void {
    callback_baton_t *lldb_info = (callback_baton_t *)baton;
    if (lldb_info->num_matches == 0) {
        uint8_t *p = (uint8_t *)lldb_info->ptr;
        uint8_t *lo = (uint8_t *)ptr_addr;
        uint8_t *hi = lo + ptr_size;
        if (lo <= p && p < hi) {
            lldb_info->matches[lldb_info->num_matches].addr = (void*)ptr_addr;
            lldb_info->matches[lldb_info->num_matches].size = ptr_size;
            lldb_info->matches[lldb_info->num_matches].offset = p - lo;
            lldb_info->matches[lldb_info->num_matches].type = type;
            lldb_info->num_matches = 1;
        }
    }
};
callback_baton_t baton = { range_callback, 0, {0}, (void *)%s };
baton.matches[0].addr = 0;
baton.matches[1].addr = 0;"""
    if args:
        total_matches = 0
        for ptr_expr in args:
            user_init_code = user_init_code_format % (ptr_expr)
            expr = get_iterate_memory_expr(
                options, process, user_init_code, "baton.matches"
            )
            arg_str_description = "malloc block that contains %s" % ptr_expr
            total_matches += display_match_results(
                process, result, options, arg_str_description, expr, True, expr_prefix
            )
        return total_matches
    else:
        result.AppendMessage("error: command takes one or more pointer expressions")
        return 0


def get_thread_stack_ranges_struct(process):
    """Create code that defines a structure that represents threads stack bounds
    for all  threads. It returns a static sized array initialized with all of
    the tid, base, size structs for all the threads."""
    stack_dicts = list()
    if process:
        i = 0
        for thread in process:
            min_sp = thread.frame[0].sp
            max_sp = min_sp
            for frame in thread.frames:
                sp = frame.sp
                if sp < min_sp:
                    min_sp = sp
                if sp > max_sp:
                    max_sp = sp
            if min_sp < max_sp:
                stack_dicts.append(
                    {
                        "tid": thread.GetThreadID(),
                        "base": min_sp,
                        "size": max_sp - min_sp,
                        "index": i,
                    }
                )
                i += 1
    stack_dicts_len = len(stack_dicts)
    if stack_dicts_len > 0:
        result = """
#define NUM_STACKS %u
#define STACK_RED_ZONE_SIZE %u
typedef struct thread_stack_t { uint64_t tid, base, size; } thread_stack_t;
thread_stack_t stacks[NUM_STACKS];""" % (
            stack_dicts_len,
            process.target.GetStackRedZoneSize(),
        )
        for stack_dict in stack_dicts:
            result += (
                """
stacks[%(index)u].tid  = 0x%(tid)x;
stacks[%(index)u].base = 0x%(base)x;
stacks[%(index)u].size = 0x%(size)x;"""
                % stack_dict
            )
        return result
    else:
        return ""


def get_sections_ranges_struct(process):
    """Create code that defines a structure that represents all segments that
    can contain data for all images in "target". It returns a static sized
    array initialized with all of base, size structs for all the threads."""
    target = process.target
    segment_dicts = list()
    for module_idx, module in enumerate(target.modules):
        for sect_idx in range(module.GetNumSections()):
            section = module.GetSectionAtIndex(sect_idx)
            if not section:
                break
            name = section.name
            if name != "__TEXT" and name != "__LINKEDIT" and name != "__PAGEZERO":
                base = section.GetLoadAddress(target)
                size = section.GetByteSize()
                if base != lldb.LLDB_INVALID_ADDRESS and size > 0:
                    segment_dicts.append({"base": base, "size": size})
    segment_dicts_len = len(segment_dicts)
    if segment_dicts_len > 0:
        result = """
#define NUM_SEGMENTS %u
typedef struct segment_range_t { uint64_t base; uint32_t size; } segment_range_t;
segment_range_t segments[NUM_SEGMENTS];""" % (
            segment_dicts_len,
        )
        for idx, segment_dict in enumerate(segment_dicts):
            segment_dict["index"] = idx
            result += (
                """
segments[%(index)u].base = 0x%(base)x;
segments[%(index)u].size = 0x%(size)x;"""
                % segment_dict
            )
        return result
    else:
        return ""


def section_ptr_refs(debugger, command, result, dict):
    command_args = shlex.split(command)
    usage = "usage: %prog [options] <EXPR> [EXPR ...]"
    description = """Searches section contents for pointer values in darwin user space programs."""
    parser = optparse.OptionParser(
        description=description, prog="section_ptr_refs", usage=usage
    )
    add_common_options(parser)
    parser.add_option(
        "--section",
        action="append",
        type="string",
        dest="section_names",
        help="section name to search",
        default=list(),
    )
    try:
        (options, args) = parser.parse_args(command_args)
    except:
        return

    options.type = "pointer"

    sections = list()
    section_modules = list()
    if not options.section_names:
        result.AppendMessage(
            "error: at least one section must be specified with the --section option"
        )
        return

    target = debugger.GetSelectedTarget()
    for module in target.modules:
        for section_name in options.section_names:
            section = module.section[section_name]
            if section:
                sections.append(section)
                section_modules.append(module)
    if sections:
        dylid_load_err = load_dylib()
        if dylid_load_err:
            result.AppendMessage(dylid_load_err)
            return
        frame = target.GetProcess().GetSelectedThread().GetSelectedFrame()
        for expr_str in args:
            for idx, section in enumerate(sections):
                expr = "find_pointer_in_memory(0x%xllu, %ullu, (void *)%s)" % (
                    section.addr.load_addr,
                    section.size,
                    expr_str,
                )
                arg_str_description = 'section %s.%s containing "%s"' % (
                    section_modules[idx].file.fullpath,
                    section.name,
                    expr_str,
                )
                num_matches = display_match_results(
                    target.GetProcess(),
                    result,
                    options,
                    arg_str_description,
                    expr,
                    False,
                )
                if num_matches:
                    if num_matches < options.max_matches:
                        options.max_matches = options.max_matches - num_matches
                    else:
                        options.max_matches = 0
                if options.max_matches == 0:
                    return
    else:
        result.AppendMessage(
            "error: no sections were found that match any of %s"
            % (", ".join(options.section_names))
        )


def get_objc_refs_options():
    usage = "usage: %prog [options] <CLASS> [CLASS ...]"
    description = """Searches all allocations on the heap for instances of
objective C classes, or any classes that inherit from the specified classes
in darwin user space programs. Any matches that were found will dump the malloc
blocks that contain the C strings and might be able to print what kind of
objects the pointers are contained in using dynamic type information in the
program."""
    parser = optparse.OptionParser(
        description=description, prog="objc_refs", usage=usage
    )
    add_common_options(parser)
    return parser


def objc_refs(debugger, command, result, dict):
    command_args = shlex.split(command)
    parser = get_objc_refs_options()
    try:
        (options, args) = parser.parse_args(command_args)
    except:
        return

    process = debugger.GetSelectedTarget().GetProcess()
    if not process:
        result.AppendMessage("error: invalid process")
        return
    frame = process.GetSelectedThread().GetSelectedFrame()
    if not frame:
        result.AppendMessage("error: invalid frame")
        return

    options.type = "isa"
    if options.format is None:
        options.format = "A"  # 'A' is "address" format

    expr_options = lldb.SBExpressionOptions()
    expr_options.SetIgnoreBreakpoints(True)
    expr_options.SetTimeoutInMicroSeconds(3 * 1000 * 1000)  # 3 second infinite timeout
    expr_options.SetTryAllThreads(True)
    expr_options.SetLanguage(lldb.eLanguageTypeObjC_plus_plus)
    num_objc_classes_value = frame.EvaluateExpression(
        "(int)objc_getClassList((void *)0, (int)0)", expr_options
    )
    if not num_objc_classes_value.error.Success():
        result.AppendMessage("error: %s" % num_objc_classes_value.error.GetCString())
        return

    num_objc_classes = num_objc_classes_value.GetValueAsUnsigned()
    if num_objc_classes == 0:
        result.AppendMessage("error: no objective C classes in program")
        return

    if args:
        # When we initialize the expression, we must define any types that
        # we will need when looking at every allocation. We must also define
        # a type named callback_baton_t and make an instance named "baton"
        # and initialize it how ever we want to. The address of "baton" will
        # be passed into our range callback. callback_baton_t must contain
        # a member named "callback" whose type is "range_callback_t". This
        # will be used by our zone callbacks to call the range callback for
        # each malloc range.
        expr_prefix = """
struct $malloc_match {
    void *addr;
    uintptr_t size;
    uintptr_t offset;
    uintptr_t type;
};
"""

        user_init_code_format = """
#define MAX_MATCHES %u
typedef int (*compare_callback_t)(const void *a, const void *b);
typedef struct callback_baton_t {
    range_callback_t callback;
    compare_callback_t compare_callback;
    unsigned num_matches;
    $malloc_match matches[MAX_MATCHES];
    void *isa;
    Class classes[%u];
} callback_baton_t;
compare_callback_t compare_callback = [](const void *a, const void *b) -> int {
     Class a_ptr = *(Class *)a;
     Class b_ptr = *(Class *)b;
     if (a_ptr < b_ptr) return -1;
     if (a_ptr > b_ptr) return +1;
     return 0;
};
typedef Class (*class_getSuperclass_type)(void *isa);
range_callback_t range_callback = [](task_t task, void *baton, unsigned type, uintptr_t ptr_addr, uintptr_t ptr_size) -> void {
    class_getSuperclass_type class_getSuperclass_impl = (class_getSuperclass_type)class_getSuperclass;
    callback_baton_t *lldb_info = (callback_baton_t *)baton;
    if (sizeof(Class) <= ptr_size) {
        Class *curr_class_ptr = (Class *)ptr_addr;
        Class *matching_class_ptr = (Class *)bsearch (curr_class_ptr,
                                                      (const void *)lldb_info->classes,
                                                      sizeof(lldb_info->classes)/sizeof(Class),
                                                      sizeof(Class),
                                                      lldb_info->compare_callback);
        if (matching_class_ptr) {
            bool match = false;
            if (lldb_info->isa) {
                Class isa = *curr_class_ptr;
                if (lldb_info->isa == isa)
                    match = true;
                else { // if (lldb_info->objc.match_superclasses) {
                    Class super = class_getSuperclass_impl(isa);
                    while (super) {
                        if (super == lldb_info->isa) {
                            match = true;
                            break;
                        }
                        super = class_getSuperclass_impl(super);
                    }
                }
            }
            else
                match = true;
            if (match) {
                if (lldb_info->num_matches < MAX_MATCHES) {
                    lldb_info->matches[lldb_info->num_matches].addr = (void*)ptr_addr;
                    lldb_info->matches[lldb_info->num_matches].size = ptr_size;
                    lldb_info->matches[lldb_info->num_matches].offset = 0;
                    lldb_info->matches[lldb_info->num_matches].type = type;
                    ++lldb_info->num_matches;
                }
            }
        }
    }
};
callback_baton_t baton = { range_callback, compare_callback, 0, {0}, (void *)0x%x, {0} };
int nc = (int)objc_getClassList(baton.classes, sizeof(baton.classes)/sizeof(Class));
(void)qsort (baton.classes, sizeof(baton.classes)/sizeof(Class), sizeof(Class), compare_callback);"""
        # We must also define a snippet of code to be run that returns
        # the result of the expression we run.
        # Here we return NULL if our pointer was not found in any malloc blocks,
        # and we return the address of the matches array so we can then access
        # the matching results
        user_return_code = """if (baton.num_matches < MAX_MATCHES)
    baton.matches[baton.num_matches].addr = 0; // Terminate the matches array
        baton.matches"""
        # Iterate through all of our ObjC class name arguments
        for class_name in args:
            addr_expr_str = "(void *)[%s class]" % class_name
            expr_options = lldb.SBExpressionOptions()
            expr_options.SetIgnoreBreakpoints(True)
            expr_options.SetTimeoutInMicroSeconds(1 * 1000 * 1000)  # 1 second timeout
            expr_options.SetTryAllThreads(True)
            expr_options.SetLanguage(lldb.eLanguageTypeObjC_plus_plus)
            expr_sbvalue = frame.EvaluateExpression(addr_expr_str, expr_options)
            if expr_sbvalue.error.Success():
                isa = expr_sbvalue.unsigned
                if isa:
                    options.type = "isa"
                    result.AppendMessage(
                        'Searching for all instances of classes or subclasses of "%s" (isa=0x%x)'
                        % (class_name, isa)
                    )
                    user_init_code = user_init_code_format % (
                        options.max_matches,
                        num_objc_classes,
                        isa,
                    )
                    expr = get_iterate_memory_expr(
                        options, process, user_init_code, user_return_code
                    )
                    arg_str_description = "objective C classes with isa 0x%x" % isa
                    display_match_results(
                        process,
                        result,
                        options,
                        arg_str_description,
                        expr,
                        True,
                        expr_prefix,
                    )
                else:
                    result.AppendMessage(
                        'error: Can\'t find isa for an ObjC class named "%s"'
                        % (class_name)
                    )
            else:
                result.AppendMessage(
                    'error: expression error for "%s": %s'
                    % (addr_expr_str, expr_sbvalue.error)
                )
    else:
        result.AppendMessage("error: command takes one or more C string arguments")


if __name__ == "__main__":
    lldb.debugger = lldb.SBDebugger.Create()


def __lldb_init_module(debugger, internal_dict):
    # Make the options so we can generate the help text for the new LLDB
    # command line command prior to registering it with LLDB below. This way
    # if clients in LLDB type "help malloc_info", they will see the exact same
    # output as typing "malloc_info --help".
    ptr_refs.__doc__ = get_ptr_refs_options().format_help()
    cstr_refs.__doc__ = get_cstr_refs_options().format_help()
    malloc_info.__doc__ = get_malloc_info_options().format_help()
    objc_refs.__doc__ = get_objc_refs_options().format_help()
    debugger.HandleCommand("command script add -o -f %s.ptr_refs ptr_refs" % __name__)
    debugger.HandleCommand("command script add -o -f %s.cstr_refs cstr_refs" % __name__)
    debugger.HandleCommand(
        "command script add -o -f %s.malloc_info malloc_info" % __name__
    )
    debugger.HandleCommand(
        "command script add -o -f %s.find_variable find_variable" % __name__
    )
    # debugger.HandleCommand('command script add -o -f %s.section_ptr_refs section_ptr_refs' % package_name)
    debugger.HandleCommand("command script add -o -f %s.objc_refs objc_refs" % __name__)
    print(
        '"malloc_info", "ptr_refs", "cstr_refs", "find_variable", and "objc_refs" commands have been installed, use the "--help" options on these commands for detailed help.'
    )

```

`lldb/macosx/heap/Makefile`:

```
#----------------------------------------------------------------------
# Fill in the source files to build
#----------------------------------------------------------------------
# Uncomment line below for debugging shell commands
# SHELL = /bin/sh -x

#----------------------------------------------------------------------
# Change any build/tool options needed
#----------------------------------------------------------------------
ARCH ?= x86_64
CFLAGS ?=-arch $(ARCH) -gdwarf-2 -O0
CXX ?= $(shell xcrun -find clang++)
EXE ?= libheap.dylib
DSYM ?= $(EXE).dSYM

#----------------------------------------------------------------------
# Compile the executable from all the objects (default rule) with no
# dsym file.
#----------------------------------------------------------------------
$(EXE) : heap_find.cpp
	$(CXX) $(CFLAGS) -install_name "@executable_path/libheap.dylib" -dynamiclib -lobjc heap_find.cpp -o "$(EXE)"

#----------------------------------------------------------------------
# Include all of the makefiles for each source file so we don't have
# to manually track all of the prerequisites for each source file.
#----------------------------------------------------------------------
.PHONY: clean
all:	$(EXE)
clean:
	rm -rf "$(EXE)" "$(DSYM)"




```

`lldb/macosx/heap/heap_find.cpp`:

```cpp
//===-- heap_find.c ---------------------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file compiles into a dylib and can be used on darwin to find data that
// is contained in active malloc blocks. To use this make the project, then
// load the shared library in a debug session while you are stopped:
//
// (lldb) process load /path/to/libheap.dylib
//
// Now you can use the "find_pointer_in_heap" and "find_cstring_in_heap"
// functions in the expression parser.
//
// This will grep everything in all active allocation blocks and print and
// malloc blocks that contain the pointer 0x112233000000:
//
// (lldb) expression find_pointer_in_heap (0x112233000000)
//
// This will grep everything in all active allocation blocks and print and
// malloc blocks that contain the C string "hello" (as a substring, no
// NULL termination included):
//
// (lldb) expression find_cstring_in_heap ("hello")
//
// The results will be printed to the STDOUT of the inferior program. The
// return value of the "find_pointer_in_heap" function is the number of
// pointer references that were found. A quick example shows
//
// (lldb) expr find_pointer_in_heap(0x0000000104000410)
// (uint32_t) $5 = 0x00000002
// 0x104000740: 0x0000000104000410 found in malloc block 0x104000730 + 16
// (malloc_size = 48)
// 0x100820060: 0x0000000104000410 found in malloc block 0x100820000 + 96
// (malloc_size = 4096)
//
// From the above output we see that 0x104000410 was found in the malloc block
// at 0x104000730 and 0x100820000. If we want to see what these blocks are, we
// can display the memory for this block using the "address" ("A" for short)
// format. The address format shows pointers, and if those pointers point to
// objects that have symbols or know data contents, it will display information
// about the pointers:
//
// (lldb) memory read --format address --count 1 0x104000730
// 0x104000730: 0x0000000100002460 (void *)0x0000000100002488: MyString
//
// We can see that the first block is a "MyString" object that contains our
// pointer value at offset 16.
//
// Looking at the next pointers, are a bit more tricky:
// (lldb) memory read -fA 0x100820000 -c1
// 0x100820000: 0x4f545541a1a1a1a1
// (lldb) memory read 0x100820000
// 0x100820000: a1 a1 a1 a1 41 55 54 4f 52 45 4c 45 41 53 45 21 ....AUTORELEASE!
// 0x100820010: 78 00 82 00 01 00 00 00 60 f9 e8 75 ff 7f 00 00 x.......`..u....
//
// This is an objective C auto release pool object that contains our pointer.
// C++ classes will show up if they are virtual as something like:
// (lldb) memory read --format address --count 1 0x104008000
// 0x104008000: 0x109008000 vtable for lldb_private::Process
//
// This is a clue that the 0x104008000 is a "lldb_private::Process *".
//===----------------------------------------------------------------------===//
// C includes
#include <assert.h>
#include <ctype.h>
#include <dlfcn.h>
#include <mach/mach.h>
#include <mach/mach_vm.h>
#include <malloc/malloc.h>
#include <objc/objc-runtime.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// C++ includes
#include <vector>

// Redefine private types from "/usr/local/include/stack_logging.h"
typedef struct {
  uint32_t type_flags;
  uint64_t stack_identifier;
  uint64_t argument;
  mach_vm_address_t address;
} mach_stack_logging_record_t;

// Redefine private defines from "/usr/local/include/stack_logging.h"
#define stack_logging_type_free 0
#define stack_logging_type_generic 1
#define stack_logging_type_alloc 2
#define stack_logging_type_dealloc 4
// This bit is made up by this code
#define stack_logging_type_vm_region 8

// Redefine private function prototypes from
// "/usr/local/include/stack_logging.h"
extern "C" kern_return_t __mach_stack_logging_set_file_path(task_t task,
                                                            char *file_path);

extern "C" kern_return_t
__mach_stack_logging_get_frames(task_t task, mach_vm_address_t address,
                                mach_vm_address_t *stack_frames_buffer,
                                uint32_t max_stack_frames, uint32_t *count);

extern "C" kern_return_t __mach_stack_logging_enumerate_records(
    task_t task, mach_vm_address_t address,
    void enumerator(mach_stack_logging_record_t, void *), void *context);

extern "C" kern_return_t __mach_stack_logging_frames_for_uniqued_stack(
    task_t task, uint64_t stack_identifier,
    mach_vm_address_t *stack_frames_buffer, uint32_t max_stack_frames,
    uint32_t *count);

extern "C" void *gdb_class_getClass(void *objc_class);

static void range_info_callback(task_t task, void *baton, unsigned type,
                                uint64_t ptr_addr, uint64_t ptr_size);

// Redefine private global variables prototypes from
// "/usr/local/include/stack_logging.h"

extern "C" int stack_logging_enable_logging;

// Local defines
#define MAX_FRAMES 1024

// Local Typedefs and Types
typedef void range_callback_t(task_t task, void *baton, unsigned type,
                              uint64_t ptr_addr, uint64_t ptr_size);
typedef void zone_callback_t(void *info, const malloc_zone_t *zone);
typedef int (*comare_function_t)(const void *, const void *);
struct range_callback_info_t {
  zone_callback_t *zone_callback;
  range_callback_t *range_callback;
  void *baton;
  int check_vm_regions;
};

enum data_type_t {
  eDataTypeAddress,
  eDataTypeContainsData,
  eDataTypeObjC,
  eDataTypeHeapInfo
};

struct aligned_data_t {
  const uint8_t *buffer;
  uint32_t size;
  uint32_t align;
};

struct objc_data_t {
  void *match_isa; // Set to NULL for all objective C objects
  bool match_superclasses;
};

struct range_contains_data_callback_info_t {
  data_type_t type;
  const void *lookup_addr;
  union {
    uintptr_t addr;
    aligned_data_t data;
    objc_data_t objc;
  };
  uint32_t match_count;
  bool done;
  bool unique;
};

struct malloc_match {
  void *addr;
  intptr_t size;
  intptr_t offset;
  uintptr_t type;
};

struct malloc_stack_entry {
  const void *address;
  uint64_t argument;
  uint32_t type_flags;
  uint32_t num_frames;
  mach_vm_address_t frames[MAX_FRAMES];
};

struct malloc_block_contents {
  union {
    Class isa;
    void *pointers[2];
  };
};

static int compare_void_ptr(const void *a, const void *b) {
  Class a_ptr = *(Class *)a;
  Class b_ptr = *(Class *)b;
  if (a_ptr < b_ptr)
    return -1;
  if (a_ptr > b_ptr)
    return +1;
  return 0;
}

class MatchResults {
  enum { k_max_entries = 8 * 1024 };

public:
  MatchResults() : m_size(0) {}

  void clear() {
    m_size = 0;
    bzero(&m_entries, sizeof(m_entries));
  }

  bool empty() const { return m_size == 0; }

  void push_back(const malloc_match &m, bool unique = false) {
    if (unique) {
      // Don't add the entry if there is already a match for this address
      for (uint32_t i = 0; i < m_size; ++i) {
        if (((uint8_t *)m_entries[i].addr + m_entries[i].offset) ==
            ((uint8_t *)m.addr + m.offset))
          return; // Duplicate entry
      }
    }
    if (m_size < k_max_entries - 1) {
      m_entries[m_size] = m;
      m_size++;
    }
  }

  malloc_match *data() {
    // If empty, return NULL
    if (empty())
      return NULL;
    // In not empty, terminate and return the result
    malloc_match terminator_entry = {NULL, 0, 0, 0};
    // We always leave room for an empty entry at the end
    m_entries[m_size] = terminator_entry;
    return m_entries;
  }

protected:
  malloc_match m_entries[k_max_entries];
  uint32_t m_size;
};

class MallocStackLoggingEntries {
  enum { k_max_entries = 128 };

public:
  MallocStackLoggingEntries() : m_size(0) {}

  void clear() { m_size = 0; }

  bool empty() const { return m_size == 0; }

  malloc_stack_entry *next() {
    if (m_size < k_max_entries - 1) {
      malloc_stack_entry *result = m_entries + m_size;
      ++m_size;
      return result;
    }
    return NULL; // Out of entries...
  }

  malloc_stack_entry *data() {
    // If empty, return NULL
    if (empty())
      return NULL;
    // In not empty, terminate and return the result
    m_entries[m_size].address = NULL;
    m_entries[m_size].argument = 0;
    m_entries[m_size].type_flags = 0;
    m_entries[m_size].num_frames = 0;
    return m_entries;
  }

protected:
  malloc_stack_entry m_entries[k_max_entries];
  uint32_t m_size;
};

// A safe way to allocate memory and keep it from interfering with the
// malloc enumerators.
void *safe_malloc(size_t n_bytes) {
  if (n_bytes > 0) {
    const int k_page_size = getpagesize();
    const mach_vm_size_t vm_size =
        ((n_bytes + k_page_size - 1) / k_page_size) * k_page_size;
    vm_address_t address = 0;
    kern_return_t kerr = vm_allocate(mach_task_self(), &address, vm_size, true);
    if (kerr == KERN_SUCCESS)
      return (void *)address;
  }
  return NULL;
}

// ObjCClasses
class ObjCClasses {
public:
  ObjCClasses() : m_objc_class_ptrs(NULL), m_size(0) {}

  bool Update() {
    // TODO: find out if class list has changed and update if needed
    if (m_objc_class_ptrs == NULL) {
      m_size = objc_getClassList(NULL, 0);
      if (m_size > 0) {
        // Allocate the class pointers
        m_objc_class_ptrs = (Class *)safe_malloc(m_size * sizeof(Class));
        m_size = objc_getClassList(m_objc_class_ptrs, m_size);
        // Sort Class pointers for quick lookup
        ::qsort(m_objc_class_ptrs, m_size, sizeof(Class), compare_void_ptr);
      } else
        return false;
    }
    return true;
  }

  uint32_t FindClassIndex(Class isa) {
    Class *matching_class = (Class *)bsearch(&isa, m_objc_class_ptrs, m_size,
                                             sizeof(Class), compare_void_ptr);
    if (matching_class) {
      uint32_t idx = matching_class - m_objc_class_ptrs;
      return idx;
    }
    return UINT32_MAX;
  }

  Class GetClassAtIndex(uint32_t idx) const {
    if (idx < m_size)
      return m_objc_class_ptrs[idx];
    return NULL;
  }
  uint32_t GetSize() const { return m_size; }

private:
  Class *m_objc_class_ptrs;
  uint32_t m_size;
};

// Local global variables
MatchResults g_matches;
MallocStackLoggingEntries g_malloc_stack_history;
ObjCClasses g_objc_classes;

// ObjCClassInfo

enum HeapInfoSortType { eSortTypeNone, eSortTypeBytes, eSortTypeCount };

class ObjCClassInfo {
public:
  ObjCClassInfo() : m_entries(NULL), m_size(0), m_sort_type(eSortTypeNone) {}

  void Update(const ObjCClasses &objc_classes) {
    m_size = objc_classes.GetSize();
    m_entries = (Entry *)safe_malloc(m_size * sizeof(Entry));
    m_sort_type = eSortTypeNone;
    Reset();
  }

  bool AddInstance(uint32_t idx, uint64_t ptr_size) {
    if (m_size == 0)
      Update(g_objc_classes);
    // Update the totals for the classes
    if (idx < m_size) {
      m_entries[idx].bytes += ptr_size;
      ++m_entries[idx].count;
      return true;
    }
    return false;
  }

  void Reset() {
    m_sort_type = eSortTypeNone;
    for (uint32_t i = 0; i < m_size; ++i) {
      // In case we sort the entries after gathering the data, we will
      // want to know the index into the m_objc_class_ptrs[] array.
      m_entries[i].idx = i;
      m_entries[i].bytes = 0;
      m_entries[i].count = 0;
    }
  }
  void SortByTotalBytes(const ObjCClasses &objc_classes, bool print) {
    if (m_sort_type != eSortTypeBytes && m_size > 0) {
      ::qsort(m_entries, m_size, sizeof(Entry),
              (comare_function_t)compare_bytes);
      m_sort_type = eSortTypeBytes;
    }
    if (print && m_size > 0) {
      puts("Objective-C objects by total bytes:");
      puts("Total Bytes Class Name");
      puts("----------- "
           "-----------------------------------------------------------------");
      for (uint32_t i = 0; i < m_size && m_entries[i].bytes > 0; ++i) {
        printf("%11llu %s\n", m_entries[i].bytes,
               class_getName(objc_classes.GetClassAtIndex(m_entries[i].idx)));
      }
    }
  }
  void SortByTotalCount(const ObjCClasses &objc_classes, bool print) {
    if (m_sort_type != eSortTypeCount && m_size > 0) {
      ::qsort(m_entries, m_size, sizeof(Entry),
              (comare_function_t)compare_count);
      m_sort_type = eSortTypeCount;
    }
    if (print && m_size > 0) {
      puts("Objective-C objects by total count:");
      puts("Count    Class Name");
      puts("-------- "
           "-----------------------------------------------------------------");
      for (uint32_t i = 0; i < m_size && m_entries[i].count > 0; ++i) {
        printf("%8u %s\n", m_entries[i].count,
               class_getName(objc_classes.GetClassAtIndex(m_entries[i].idx)));
      }
    }
  }

private:
  struct Entry {
    uint32_t idx;   // Index into the m_objc_class_ptrs[] array
    uint32_t count; // Number of object instances that were found
    uint64_t bytes; // Total number of bytes for each objc class
  };

  static int compare_bytes(const Entry *a, const Entry *b) {
    // Reverse the comparison to most bytes entries end up at top of list
    if (a->bytes > b->bytes)
      return -1;
    if (a->bytes < b->bytes)
      return +1;
    return 0;
  }

  static int compare_count(const Entry *a, const Entry *b) {
    // Reverse the comparison to most count entries end up at top of list
    if (a->count > b->count)
      return -1;
    if (a->count < b->count)
      return +1;
    return 0;
  }

  Entry *m_entries;
  uint32_t m_size;
  HeapInfoSortType m_sort_type;
};

ObjCClassInfo g_objc_class_snapshot;

// task_peek
//
// Reads memory from this tasks address space. This callback is needed
// by the code that iterates through all of the malloc blocks to read
// the memory in this process.
static kern_return_t task_peek(task_t task, vm_address_t remote_address,
                               vm_size_t size, void **local_memory) {
  *local_memory = (void *)remote_address;
  return KERN_SUCCESS;
}

static const void foreach_zone_in_this_process(range_callback_info_t *info) {
  if (info == NULL || info->zone_callback == NULL)
    return;

  vm_address_t *zones = NULL;
  unsigned int num_zones = 0;

  kern_return_t err = malloc_get_all_zones(0, task_peek, &zones, &num_zones);
  if (KERN_SUCCESS == err) {
    for (unsigned int i = 0; i < num_zones; ++i) {
      info->zone_callback(info, (const malloc_zone_t *)zones[i]);
    }
  }

  if (info->check_vm_regions) {
#if defined(VM_REGION_SUBMAP_SHORT_INFO_COUNT_64)
    typedef vm_region_submap_short_info_data_64_t RegionInfo;
    enum { kRegionInfoSize = VM_REGION_SUBMAP_SHORT_INFO_COUNT_64 };
#else
    typedef vm_region_submap_info_data_64_t RegionInfo;
    enum { kRegionInfoSize = VM_REGION_SUBMAP_INFO_COUNT_64 };
#endif
    task_t task = mach_task_self();
    mach_vm_address_t vm_region_base_addr;
    mach_vm_size_t vm_region_size;
    natural_t vm_region_depth;
    RegionInfo vm_region_info;

    ((range_contains_data_callback_info_t *)info->baton)->unique = true;

    for (vm_region_base_addr = 0, vm_region_size = 1; vm_region_size != 0;
         vm_region_base_addr += vm_region_size) {
      mach_msg_type_number_t vm_region_info_size = kRegionInfoSize;
      const kern_return_t err = mach_vm_region_recurse(
          task, &vm_region_base_addr, &vm_region_size, &vm_region_depth,
          (vm_region_recurse_info_t)&vm_region_info, &vm_region_info_size);
      if (err)
        break;
      // Check all read + write regions. This will cover the thread stacks
      // and any regions of memory that aren't covered by the heap
      if (vm_region_info.protection & VM_PROT_WRITE &&
          vm_region_info.protection & VM_PROT_READ) {
        // printf ("checking vm_region: [0x%16.16llx - 0x%16.16llx)\n",
        // (uint64_t)vm_region_base_addr, (uint64_t)vm_region_base_addr +
        // vm_region_size);
        range_info_callback(task, info->baton, stack_logging_type_vm_region,
                            vm_region_base_addr, vm_region_size);
      }
    }
  }
}

// dump_malloc_block_callback
//
// A simple callback that will dump each malloc block and all available
// info from the enumeration callback perspective.
static void dump_malloc_block_callback(task_t task, void *baton, unsigned type,
                                       uint64_t ptr_addr, uint64_t ptr_size) {
  printf("task = 0x%4.4x: baton = %p, type = %u, ptr_addr = 0x%llx + 0x%llu\n",
         task, baton, type, ptr_addr, ptr_size);
}

static void ranges_callback(task_t task, void *baton, unsigned type,
                            vm_range_t *ptrs, unsigned count) {
  range_callback_info_t *info = (range_callback_info_t *)baton;
  while (count--) {
    info->range_callback(task, info->baton, type, ptrs->address, ptrs->size);
    ptrs++;
  }
}

static void enumerate_range_in_zone(void *baton, const malloc_zone_t *zone) {
  range_callback_info_t *info = (range_callback_info_t *)baton;

  if (zone && zone->introspect)
    zone->introspect->enumerator(
        mach_task_self(), info, MALLOC_PTR_IN_USE_RANGE_TYPE,
        (vm_address_t)zone, task_peek, ranges_callback);
}

static void range_info_callback(task_t task, void *baton, unsigned type,
                                uint64_t ptr_addr, uint64_t ptr_size) {
  const uint64_t end_addr = ptr_addr + ptr_size;

  range_contains_data_callback_info_t *info =
      (range_contains_data_callback_info_t *)baton;
  switch (info->type) {
  case eDataTypeAddress:
    // Check if the current malloc block contains an address specified by
    // "info->addr"
    if (ptr_addr <= info->addr && info->addr < end_addr) {
      ++info->match_count;
      malloc_match match = {(void *)ptr_addr, ptr_size, info->addr - ptr_addr,
                            type};
      g_matches.push_back(match, info->unique);
    }
    break;

  case eDataTypeContainsData:
    // Check if the current malloc block contains data specified in "info->data"
    {
      const uint32_t size = info->data.size;
      if (size < ptr_size) // Make sure this block can contain this data
      {
        uint8_t *ptr_data = NULL;
        if (task_peek(task, ptr_addr, ptr_size, (void **)&ptr_data) ==
            KERN_SUCCESS) {
          const void *buffer = info->data.buffer;
          assert(ptr_data);
          const uint32_t align = info->data.align;
          for (uint64_t addr = ptr_addr;
               addr < end_addr && ((end_addr - addr) >= size);
               addr += align, ptr_data += align) {
            if (memcmp(buffer, ptr_data, size) == 0) {
              ++info->match_count;
              malloc_match match = {(void *)ptr_addr, ptr_size, addr - ptr_addr,
                                    type};
              g_matches.push_back(match, info->unique);
            }
          }
        } else {
          printf("0x%llx: error: couldn't read %llu bytes\n", ptr_addr,
                 ptr_size);
        }
      }
    }
    break;

  case eDataTypeObjC:
    // Check if the current malloc block contains an objective C object
    // of any sort where the first pointer in the object is an OBJC class
    // pointer (an isa)
    {
      malloc_block_contents *block_contents = NULL;
      if (task_peek(task, ptr_addr, sizeof(void *), (void **)&block_contents) ==
          KERN_SUCCESS) {
        // We assume that g_objc_classes is up to date
        // that the class list was verified to have some classes in it
        // before calling this function
        const uint32_t objc_class_idx =
            g_objc_classes.FindClassIndex(block_contents->isa);
        if (objc_class_idx != UINT32_MAX) {
          bool match = false;
          if (info->objc.match_isa == 0) {
            // Match any objective C object
            match = true;
          } else {
            // Only match exact isa values in the current class or
            // optionally in the super classes
            if (info->objc.match_isa == block_contents->isa)
              match = true;
            else if (info->objc.match_superclasses) {
              Class super = class_getSuperclass(block_contents->isa);
              while (super) {
                match = super == info->objc.match_isa;
                if (match)
                  break;
                super = class_getSuperclass(super);
              }
            }
          }
          if (match) {
            // printf (" success\n");
            ++info->match_count;
            malloc_match match = {(void *)ptr_addr, ptr_size, 0, type};
            g_matches.push_back(match, info->unique);
          } else {
            // printf (" error: wrong class: %s\n", dl_info.dli_sname);
          }
        } else {
          // printf ("\terror: symbol not objc class: %s\n", dl_info.dli_sname);
          return;
        }
      }
    }
    break;

  case eDataTypeHeapInfo:
    // Check if the current malloc block contains an objective C object
    // of any sort where the first pointer in the object is an OBJC class
    // pointer (an isa)
    {
      malloc_block_contents *block_contents = NULL;
      if (task_peek(task, ptr_addr, sizeof(void *), (void **)&block_contents) ==
          KERN_SUCCESS) {
        // We assume that g_objc_classes is up to date
        // that the class list was verified to have some classes in it
        // before calling this function
        const uint32_t objc_class_idx =
            g_objc_classes.FindClassIndex(block_contents->isa);
        if (objc_class_idx != UINT32_MAX) {
          // This is an objective C object
          g_objc_class_snapshot.AddInstance(objc_class_idx, ptr_size);
        } else {
          // Classify other heap info
        }
      }
    }
    break;
  }
}

static void
get_stack_for_address_enumerator(mach_stack_logging_record_t stack_record,
                                 void *task_ptr) {
  malloc_stack_entry *stack_entry = g_malloc_stack_history.next();
  if (stack_entry) {
    stack_entry->address = (void *)stack_record.address;
    stack_entry->type_flags = stack_record.type_flags;
    stack_entry->argument = stack_record.argument;
    stack_entry->num_frames = 0;
    stack_entry->frames[0] = 0;
    kern_return_t err = __mach_stack_logging_frames_for_uniqued_stack(
        *(task_t *)task_ptr, stack_record.stack_identifier, stack_entry->frames,
        MAX_FRAMES, &stack_entry->num_frames);
    // Terminate the frames with zero if there is room
    if (stack_entry->num_frames < MAX_FRAMES)
      stack_entry->frames[stack_entry->num_frames] = 0;
  }
}

malloc_stack_entry *get_stack_history_for_address(const void *addr,
                                                  int history) {
  if (!stack_logging_enable_logging)
    return NULL;
  g_malloc_stack_history.clear();
  kern_return_t err;
  task_t task = mach_task_self();
  if (history) {
    err = __mach_stack_logging_enumerate_records(
        task, (mach_vm_address_t)addr, get_stack_for_address_enumerator, &task);
  } else {
    malloc_stack_entry *stack_entry = g_malloc_stack_history.next();
    if (stack_entry) {
      stack_entry->address = addr;
      stack_entry->type_flags = stack_logging_type_alloc;
      stack_entry->argument = 0;
      stack_entry->num_frames = 0;
      stack_entry->frames[0] = 0;
      err = __mach_stack_logging_get_frames(task, (mach_vm_address_t)addr,
                                            stack_entry->frames, MAX_FRAMES,
                                            &stack_entry->num_frames);
      if (err == 0 && stack_entry->num_frames > 0) {
        // Terminate the frames with zero if there is room
        if (stack_entry->num_frames < MAX_FRAMES)
          stack_entry->frames[stack_entry->num_frames] = 0;
      } else {
        g_malloc_stack_history.clear();
      }
    }
  }
  // Return data if there is any
  return g_malloc_stack_history.data();
}

// find_pointer_in_heap
//
// Finds a pointer value inside one or more currently valid malloc
// blocks.
malloc_match *find_pointer_in_heap(const void *addr, int check_vm_regions) {
  g_matches.clear();
  // Setup "info" to look for a malloc block that contains data
  // that is the pointer
  if (addr) {
    range_contains_data_callback_info_t data_info;
    data_info.type = eDataTypeContainsData; // Check each block for data
    data_info.data.buffer =
        (uint8_t *)&addr; // What data? The pointer value passed in
    data_info.data.size =
        sizeof(addr); // How many bytes? The byte size of a pointer
    data_info.data.align = sizeof(addr); // Align to a pointer byte size
    data_info.match_count = 0;           // Initialize the match count to zero
    data_info.done = false;   // Set done to false so searching doesn't stop
    data_info.unique = false; // Set to true when iterating on the vm_regions
    range_callback_info_t info = {enumerate_range_in_zone, range_info_callback,
                                  &data_info, check_vm_regions};
    foreach_zone_in_this_process(&info);
  }
  return g_matches.data();
}

// find_pointer_in_memory
//
// Finds a pointer value inside one or more currently valid malloc
// blocks.
malloc_match *find_pointer_in_memory(uint64_t memory_addr, uint64_t memory_size,
                                     const void *addr) {
  g_matches.clear();
  // Setup "info" to look for a malloc block that contains data
  // that is the pointer
  range_contains_data_callback_info_t data_info;
  data_info.type = eDataTypeContainsData; // Check each block for data
  data_info.data.buffer =
      (uint8_t *)&addr; // What data? The pointer value passed in
  data_info.data.size =
      sizeof(addr); // How many bytes? The byte size of a pointer
  data_info.data.align = sizeof(addr); // Align to a pointer byte size
  data_info.match_count = 0;           // Initialize the match count to zero
  data_info.done = false;   // Set done to false so searching doesn't stop
  data_info.unique = false; // Set to true when iterating on the vm_regions
  range_info_callback(mach_task_self(), &data_info, stack_logging_type_generic,
                      memory_addr, memory_size);
  return g_matches.data();
}

// find_objc_objects_in_memory
//
// Find all instances of ObjC classes 'c', or all ObjC classes if 'c' is
// NULL. If 'c' is non NULL, then also check objects to see if they
// inherit from 'c'
malloc_match *find_objc_objects_in_memory(void *isa, int check_vm_regions) {
  g_matches.clear();
  if (g_objc_classes.Update()) {
    // Setup "info" to look for a malloc block that contains data
    // that is the pointer
    range_contains_data_callback_info_t data_info;
    data_info.type = eDataTypeObjC; // Check each block for data
    data_info.objc.match_isa = isa;
    data_info.objc.match_superclasses = true;
    data_info.match_count = 0; // Initialize the match count to zero
    data_info.done = false;    // Set done to false so searching doesn't stop
    data_info.unique = false;  // Set to true when iterating on the vm_regions
    range_callback_info_t info = {enumerate_range_in_zone, range_info_callback,
                                  &data_info, check_vm_regions};
    foreach_zone_in_this_process(&info);
  }
  return g_matches.data();
}

// get_heap_info
//
// Gather information for all allocations on the heap and report
// statistics.

void get_heap_info(int sort_type) {
  if (g_objc_classes.Update()) {
    // Reset all stats
    g_objc_class_snapshot.Reset();
    // Setup "info" to look for a malloc block that contains data
    // that is the pointer
    range_contains_data_callback_info_t data_info;
    data_info.type = eDataTypeHeapInfo; // Check each block for data
    data_info.match_count = 0;          // Initialize the match count to zero
    data_info.done = false;   // Set done to false so searching doesn't stop
    data_info.unique = false; // Set to true when iterating on the vm_regions
    const int check_vm_regions = false;
    range_callback_info_t info = {enumerate_range_in_zone, range_info_callback,
                                  &data_info, check_vm_regions};
    foreach_zone_in_this_process(&info);

    // Sort and print byte total bytes
    switch (sort_type) {
    case eSortTypeNone:
    default:
    case eSortTypeBytes:
      g_objc_class_snapshot.SortByTotalBytes(g_objc_classes, true);
      break;

    case eSortTypeCount:
      g_objc_class_snapshot.SortByTotalCount(g_objc_classes, true);
      break;
    }
  } else {
    printf("error: no objective C classes\n");
  }
}

// find_cstring_in_heap
//
// Finds a C string inside one or more currently valid malloc blocks.
malloc_match *find_cstring_in_heap(const char *s, int check_vm_regions) {
  g_matches.clear();
  if (s == NULL || s[0] == '\0') {
    printf("error: invalid argument (empty cstring)\n");
    return NULL;
  }
  // Setup "info" to look for a malloc block that contains data
  // that is the C string passed in aligned on a 1 byte boundary
  range_contains_data_callback_info_t data_info;
  data_info.type = eDataTypeContainsData; // Check each block for data
  data_info.data.buffer = (uint8_t *)s;   // What data? The C string passed in
  data_info.data.size = strlen(s); // How many bytes? The length of the C string
  data_info.data.align =
      1; // Data doesn't need to be aligned, so set the alignment to 1
  data_info.match_count = 0; // Initialize the match count to zero
  data_info.done = false;    // Set done to false so searching doesn't stop
  data_info.unique = false;  // Set to true when iterating on the vm_regions
  range_callback_info_t info = {enumerate_range_in_zone, range_info_callback,
                                &data_info, check_vm_regions};
  foreach_zone_in_this_process(&info);
  return g_matches.data();
}

// find_block_for_address
//
// Find the malloc block that whose address range contains "addr".
malloc_match *find_block_for_address(const void *addr, int check_vm_regions) {
  g_matches.clear();
  // Setup "info" to look for a malloc block that contains data
  // that is the C string passed in aligned on a 1 byte boundary
  range_contains_data_callback_info_t data_info;
  data_info.type = eDataTypeAddress; // Check each block to see if the block
                                     // contains the address passed in
  data_info.addr = (uintptr_t)addr;  // What data? The C string passed in
  data_info.match_count = 0;         // Initialize the match count to zero
  data_info.done = false;   // Set done to false so searching doesn't stop
  data_info.unique = false; // Set to true when iterating on the vm_regions
  range_callback_info_t info = {enumerate_range_in_zone, range_info_callback,
                                &data_info, check_vm_regions};
  foreach_zone_in_this_process(&info);
  return g_matches.data();
}

```

`lldb/plugins/__init__.py`:

```py
__all__ = ["scripted_process", "scripted_platform"]
for x in __all__:
  __import__('lldb.plugins.' + x)

def __lldb_init_module(debugger, internal_dict):
  import lldb
  for x in __all__:
    submodule = getattr(lldb.plugins, x)
    lldb_init = getattr(submodule, '__lldb_init_module', None)
    if lldb_init:
      lldb_init(debugger, internal_dict)

```

`lldb/plugins/scripted_platform.py`:

```py
from abc import ABCMeta, abstractmethod

import lldb


class ScriptedPlatform(metaclass=ABCMeta):

    """
    The base class for a scripted platform.

    Most of the base class methods are `@abstractmethod` that need to be
    overwritten by the inheriting class.

    DISCLAIMER: THIS INTERFACE IS STILL UNDER DEVELOPMENT AND NOT STABLE.
                THE METHODS EXPOSED MIGHT CHANGE IN THE FUTURE.
    """

    processes = None

    @abstractmethod
    def __init__(self, exe_ctx, args):
        """Construct a scripted platform.

        Args:
            exe_ctx (lldb.SBExecutionContext): The execution context for the scripted platform
            args (lldb.SBStructuredData): A Dictionary holding arbitrary
                key/value pairs used by the scripted platform.
        """
        processes = []

    @abstractmethod
    def list_processes(self):
        """Get a list of processes that are running or that can be attached to on the platform.

        processes = {
            420: {
                    name: a.out,
                    arch: aarch64,
                    pid: 420,
                    parent_pid: 42 (optional),
                    uid: 0 (optional),
                    gid: 0 (optional),
            },
        }

        Returns:
            Dict: The processes represented as a dictionary, with at least the
                process ID, name, architecture. Optionally, the user can also
                provide the parent process ID and the user and group IDs.
                The dictionary can be empty.
        """
        pass

    def get_process_info(self, pid):
        """Get the dictionary describing the process.

        Returns:
            Dict: The dictionary of process info that matched process ID.
            None if the process doesn't exists
        """
        pass

    @abstractmethod
    def attach_to_process(self, attach_info):
        """Attach to a process.

        Args:
            attach_info (lldb.SBAttachInfo): The information related to attach to a process.

        Returns:
            lldb.SBError: A status object notifying if the attach succeeded.
        """
        pass

    @abstractmethod
    def launch_process(self, launch_info):
        """Launch a process.

        Args:
            launch_info (lldb.SBLaunchInfo): The information related to the process launch.

        Returns:
            lldb.SBError: A status object notifying if the launch succeeded.
        """
        pass

    @abstractmethod
    def kill_process(self, pid):
        """Kill a process.

        Args:
            pid (int): Process ID for the process to be killed.

        Returns:
            lldb.SBError: A status object notifying if the shutdown succeeded.
        """
        pass

```

`lldb/plugins/scripted_process.py`:

```py
from abc import ABCMeta, abstractmethod

import lldb
import json, struct, signal


class ScriptedProcess(metaclass=ABCMeta):

    """
    The base class for a scripted process.

    Most of the base class methods are `@abstractmethod` that need to be
    overwritten by the inheriting class.

    DISCLAIMER: THIS INTERFACE IS STILL UNDER DEVELOPMENT AND NOT STABLE.
                THE METHODS EXPOSED MIGHT CHANGE IN THE FUTURE.
    """

    capabilities = None
    memory_regions = None
    loaded_images = None
    threads = None
    metadata = None

    @abstractmethod
    def __init__(self, exe_ctx, args):
        """Construct a scripted process.

        Args:
            exe_ctx (lldb.SBExecutionContext): The execution context for the scripted process.
            args (lldb.SBStructuredData): A Dictionary holding arbitrary
                key/value pairs used by the scripted process.
        """
        target = None
        self.target = None
        self.args = None
        self.arch = None
        if isinstance(exe_ctx, lldb.SBExecutionContext):
            target = exe_ctx.target
        if isinstance(target, lldb.SBTarget) and target.IsValid():
            self.target = target
            triple = self.target.triple
            if triple:
                self.arch = triple.split("-")[0]
            self.dbg = target.GetDebugger()
        if isinstance(args, lldb.SBStructuredData) and args.IsValid():
            self.args = args
        self.threads = {}
        self.loaded_images = []
        self.metadata = {}
        self.capabilities = {}
        self.pid = 42

    def get_capabilities(self):
        """Get a dictionary containing the process capabilities.

        Returns:
            Dict[str:bool]: The dictionary of capability, with the capability
            name as the key and a boolean flag as the value.
            The dictionary can be empty.
        """
        return self.capabilities

    def get_memory_region_containing_address(self, addr):
        """Get the memory region for the scripted process, containing a
            specific address.

        Args:
            addr (int): Address to look for in the scripted process memory
                regions.

        Returns:
            lldb.SBMemoryRegionInfo: The memory region containing the address.
                None if out of bounds.
        """
        return None

    def get_threads_info(self):
        """Get the dictionary describing the process' Scripted Threads.

        Returns:
            Dict: The dictionary of threads, with the thread ID as the key and
            a Scripted Thread instance as the value.
            The dictionary can be empty.
        """
        return self.threads

    @abstractmethod
    def read_memory_at_address(self, addr, size, error):
        """Get a memory buffer from the scripted process at a certain address,
            of a certain size.

        Args:
            addr (int): Address from which we should start reading.
            size (int): Size of the memory to read.
            error (lldb.SBError): Error object.

        Returns:
            lldb.SBData: An `lldb.SBData` buffer with the target byte size and
                byte order storing the memory read.
        """
        pass

    def write_memory_at_address(self, addr, data, error):
        """Write a buffer to the scripted process memory.

        Args:
            addr (int): Address from which we should start reading.
            data (lldb.SBData): An `lldb.SBData` buffer to write to the
                process memory.
            error (lldb.SBError): Error object.

        Returns:
            size (int): Size of the memory to read.
        """
        error.SetErrorString(
            "%s doesn't support memory writes." % self.__class__.__name__
        )
        return 0

    def get_loaded_images(self):
        """Get the list of loaded images for the scripted process.

        ```
        scripted_image = {
            uuid = "c6ea2b64-f77c-3d27-9528-74f507b9078b",
            path = "/usr/lib/dyld"
            load_addr = 0xbadc0ffee
        }
        ```

        Returns:
            List[scripted_image]: A list of `scripted_image` dictionaries
                containing for each entry the library UUID or its file path
                and its load address.
                None if the list is empty.
        """
        return self.loaded_images

    def get_process_id(self):
        """Get the scripted process identifier.

        Returns:
            int: The scripted process identifier.
        """
        return self.pid

    def launch(self):
        """Simulate the scripted process launch.

        Returns:
            lldb.SBError: An `lldb.SBError` with error code 0.
        """
        return lldb.SBError()

    def attach(self, attach_info):
        """Simulate the scripted process attach.

        Args:
            attach_info (lldb.SBAttachInfo): The information related to the
            process we're attaching to.

        Returns:
            lldb.SBError: An `lldb.SBError` with error code 0.
        """
        return lldb.SBError()

    def resume(self, should_stop=True):
        """Simulate the scripted process resume.

        Args:
            should_stop (bool): If True, resume will also force the process
            state to stopped after running it.

        Returns:
            lldb.SBError: An `lldb.SBError` with error code 0.
        """
        process = self.target.GetProcess()
        if not process:
            error = lldb.SBError()
            error.SetErrorString("Invalid process.")
            return error

        process.ForceScriptedState(lldb.eStateRunning)
        if should_stop:
            process.ForceScriptedState(lldb.eStateStopped)
        return lldb.SBError()

    @abstractmethod
    def is_alive(self):
        """Check if the scripted process is alive.

        Returns:
            bool: True if scripted process is alive. False otherwise.
        """
        pass

    @abstractmethod
    def get_scripted_thread_plugin(self):
        """Get scripted thread plugin name.

        Returns:
            str: Name of the scripted thread plugin.
        """
        return None

    def get_process_metadata(self):
        """Get some metadata for the scripted process.

        Returns:
            Dict: A dictionary containing metadata for the scripted process.
                  None if the process as no metadata.
        """
        return self.metadata

    def create_breakpoint(self, addr, error):
        """Create a breakpoint in the scripted process from an address.
            This is mainly used with interactive scripted process debugging.

        Args:
            addr (int): Address at which the breakpoint should be set.
            error (lldb.SBError): Error object.

        Returns:
            SBBreakpoint: A valid breakpoint object that was created a the specified
                          address. None if the breakpoint creation failed.
        """
        error.SetErrorString(
            "%s doesn't support creating breakpoints." % self.__class__.__name__
        )
        return False


class ScriptedThread(metaclass=ABCMeta):

    """
    The base class for a scripted thread.

    Most of the base class methods are `@abstractmethod` that need to be
    overwritten by the inheriting class.

    DISCLAIMER: THIS INTERFACE IS STILL UNDER DEVELOPMENT AND NOT STABLE.
                THE METHODS EXPOSED MIGHT CHANGE IN THE FUTURE.
    """

    @abstractmethod
    def __init__(self, scripted_process, args):
        """Construct a scripted thread.

        Args:
            process (ScriptedProcess): The scripted process owning this thread.
            args (lldb.SBStructuredData): A Dictionary holding arbitrary
                key/value pairs used by the scripted thread.
        """
        self.target = None
        self.scripted_process = None
        self.process = None
        self.args = None
        self.idx = 0
        self.tid = 0
        self.idx = None
        self.name = None
        self.queue = None
        self.state = None
        self.stop_reason = None
        self.register_info = None
        self.register_ctx = {}
        self.frames = []
        self.extended_info = []

        if isinstance(scripted_process, ScriptedProcess):
            self.target = scripted_process.target
            self.scripted_process = scripted_process
            self.process = self.target.GetProcess()
            self.get_register_info()

    def get_thread_idx(self):
        """Get the scripted thread index.

        Returns:
            int: The index of the scripted thread in the scripted process.
        """
        return self.idx

    def get_thread_id(self):
        """Get the scripted thread identifier.

        Returns:
            int: The identifier of the scripted thread.
        """
        return self.tid

    def get_name(self):
        """Get the scripted thread name.

        Returns:
            str: The name of the scripted thread.
        """
        return self.name

    def get_state(self):
        """Get the scripted thread state type.

            eStateStopped,   ///< Process or thread is stopped and can be examined.
            eStateRunning,   ///< Process or thread is running and can't be examined.
            eStateStepping,  ///< Process or thread is in the process of stepping and can
                             /// not be examined.
            eStateCrashed,   ///< Process or thread has crashed and can be examined.

        Returns:
            int: The state type of the scripted thread.
                 Returns lldb.eStateStopped by default.
        """
        return lldb.eStateStopped

    def get_queue(self):
        """Get the scripted thread associated queue name.
            This method is optional.

        Returns:
            str: The queue name associated with the scripted thread.
        """
        return self.queue

    @abstractmethod
    def get_stop_reason(self):
        """Get the dictionary describing the stop reason type with some data.
            This method is optional.

        Returns:
            Dict: The dictionary holding the stop reason type and the possibly
            the stop reason data.
        """
        pass

    def get_stackframes(self):
        """Get the list of stack frames for the scripted thread.

        ```
        scripted_frame = {
            idx = 0,
            pc = 0xbadc0ffee
        }
        ```

        Returns:
            List[scripted_frame]: A list of `scripted_frame` dictionaries
                containing at least for each entry, the frame index and
                the program counter value for that frame.
                The list can be empty.
        """
        return self.frames

    def get_register_info(self):
        if self.register_info is None:
            self.register_info = dict()
            if self.scripted_process.arch == "x86_64":
                self.register_info["sets"] = ["General Purpose Registers"]
                self.register_info["registers"] = INTEL64_GPR
            elif "arm64" in self.scripted_process.arch:
                self.register_info["sets"] = ["General Purpose Registers"]
                self.register_info["registers"] = ARM64_GPR
            else:
                raise ValueError("Unknown architecture", self.scripted_process.arch)
        return self.register_info

    @abstractmethod
    def get_register_context(self):
        """Get the scripted thread register context

        Returns:
            str: A byte representing all register's value.
        """
        pass

    def get_extended_info(self):
        """Get scripted thread extended information.

        Returns:
            List: A list containing the extended information for the scripted process.
                  None if the thread as no extended information.
        """
        return self.extended_info


class PassthroughScriptedProcess(ScriptedProcess):
    driving_target = None
    driving_process = None

    def __init__(self, exe_ctx, args, launched_driving_process=True):
        super().__init__(exe_ctx, args)

        self.driving_target = None
        self.driving_process = None

        self.driving_target_idx = args.GetValueForKey("driving_target_idx")
        if self.driving_target_idx and self.driving_target_idx.IsValid():
            idx = self.driving_target_idx.GetUnsignedIntegerValue(42)
            self.driving_target = self.target.GetDebugger().GetTargetAtIndex(idx)

            if launched_driving_process:
                self.driving_process = self.driving_target.GetProcess()
                for driving_thread in self.driving_process:
                    structured_data = lldb.SBStructuredData()
                    structured_data.SetFromJSON(
                        json.dumps(
                            {
                                "driving_target_idx": idx,
                                "thread_idx": driving_thread.GetIndexID(),
                            }
                        )
                    )

                    self.threads[
                        driving_thread.GetThreadID()
                    ] = PassthroughScriptedThread(self, structured_data)

                for module in self.driving_target.modules:
                    path = module.file.fullpath
                    load_addr = module.GetObjectFileHeaderAddress().GetLoadAddress(
                        self.driving_target
                    )
                    self.loaded_images.append({"path": path, "load_addr": load_addr})

    def get_memory_region_containing_address(self, addr):
        mem_region = lldb.SBMemoryRegionInfo()
        error = self.driving_process.GetMemoryRegionInfo(addr, mem_region)
        if error.Fail():
            return None
        return mem_region

    def read_memory_at_address(self, addr, size, error):
        data = lldb.SBData()
        bytes_read = self.driving_process.ReadMemory(addr, size, error)

        if error.Fail():
            return data

        data.SetDataWithOwnership(
            error,
            bytes_read,
            self.driving_target.GetByteOrder(),
            self.driving_target.GetAddressByteSize(),
        )

        return data

    def write_memory_at_address(self, addr, data, error):
        return self.driving_process.WriteMemory(
            addr, bytearray(data.uint8.all()), error
        )

    def get_process_id(self):
        return self.driving_process.GetProcessID()

    def is_alive(self):
        return True

    def get_scripted_thread_plugin(self):
        return f"{PassthroughScriptedThread.__module__}.{PassthroughScriptedThread.__name__}"


class PassthroughScriptedThread(ScriptedThread):
    def __init__(self, process, args):
        super().__init__(process, args)
        driving_target_idx = args.GetValueForKey("driving_target_idx")
        thread_idx = args.GetValueForKey("thread_idx")

        # TODO: Change to Walrus operator (:=) with oneline if assignment
        # Requires python 3.8
        val = thread_idx.GetUnsignedIntegerValue()
        if val is not None:
            self.idx = val

        self.driving_target = None
        self.driving_process = None
        self.driving_thread = None

        # TODO: Change to Walrus operator (:=) with oneline if assignment
        # Requires python 3.8
        val = driving_target_idx.GetUnsignedIntegerValue()
        if val is not None:
            self.driving_target = self.target.GetDebugger().GetTargetAtIndex(val)
            self.driving_process = self.driving_target.GetProcess()
            self.driving_thread = self.driving_process.GetThreadByIndexID(self.idx)

        if self.driving_thread:
            self.id = self.driving_thread.GetThreadID()

    def get_thread_id(self):
        return self.id

    def get_name(self):
        return f"{PassthroughScriptedThread.__name__}.thread-{self.idx}"

    def get_stop_reason(self):
        stop_reason = {"type": lldb.eStopReasonInvalid, "data": {}}

        if (
            self.driving_thread
            and self.driving_thread.IsValid()
            and self.get_thread_id() == self.driving_thread.GetThreadID()
        ):
            stop_reason["type"] = lldb.eStopReasonNone

            # TODO: Passthrough stop reason from driving process
            if self.driving_thread.GetStopReason() != lldb.eStopReasonNone:
                if "arm64" in self.scripted_process.arch:
                    stop_reason["type"] = lldb.eStopReasonException
                    stop_reason["data"][
                        "desc"
                    ] = self.driving_thread.GetStopDescription(100)
                elif self.scripted_process.arch == "x86_64":
                    stop_reason["type"] = lldb.eStopReasonSignal
                    stop_reason["data"]["signal"] = signal.SIGTRAP
                else:
                    stop_reason["type"] = self.driving_thread.GetStopReason()

        return stop_reason

    def get_register_context(self):
        if not self.driving_thread or self.driving_thread.GetNumFrames() == 0:
            return None
        frame = self.driving_thread.GetFrameAtIndex(0)

        GPRs = None
        registerSet = frame.registers  # Returns an SBValueList.
        for regs in registerSet:
            if "general purpose" in regs.name.lower():
                GPRs = regs
                break

        if not GPRs:
            return None

        for reg in GPRs:
            self.register_ctx[reg.name] = int(reg.value, base=16)

        return struct.pack(f"{len(self.register_ctx)}Q", *self.register_ctx.values())


ARM64_GPR = [
    {
        "name": "x0",
        "bitsize": 64,
        "offset": 0,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 0,
        "dwarf": 0,
        "generic": "arg0",
        "alt-name": "arg0",
    },
    {
        "name": "x1",
        "bitsize": 64,
        "offset": 8,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 1,
        "dwarf": 1,
        "generic": "arg1",
        "alt-name": "arg1",
    },
    {
        "name": "x2",
        "bitsize": 64,
        "offset": 16,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 2,
        "dwarf": 2,
        "generic": "arg2",
        "alt-name": "arg2",
    },
    {
        "name": "x3",
        "bitsize": 64,
        "offset": 24,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 3,
        "dwarf": 3,
        "generic": "arg3",
        "alt-name": "arg3",
    },
    {
        "name": "x4",
        "bitsize": 64,
        "offset": 32,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 4,
        "dwarf": 4,
        "generic": "arg4",
        "alt-name": "arg4",
    },
    {
        "name": "x5",
        "bitsize": 64,
        "offset": 40,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 5,
        "dwarf": 5,
        "generic": "arg5",
        "alt-name": "arg5",
    },
    {
        "name": "x6",
        "bitsize": 64,
        "offset": 48,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 6,
        "dwarf": 6,
        "generic": "arg6",
        "alt-name": "arg6",
    },
    {
        "name": "x7",
        "bitsize": 64,
        "offset": 56,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 7,
        "dwarf": 7,
        "generic": "arg7",
        "alt-name": "arg7",
    },
    {
        "name": "x8",
        "bitsize": 64,
        "offset": 64,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 8,
        "dwarf": 8,
    },
    {
        "name": "x9",
        "bitsize": 64,
        "offset": 72,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 9,
        "dwarf": 9,
    },
    {
        "name": "x10",
        "bitsize": 64,
        "offset": 80,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 10,
        "dwarf": 10,
    },
    {
        "name": "x11",
        "bitsize": 64,
        "offset": 88,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 11,
        "dwarf": 11,
    },
    {
        "name": "x12",
        "bitsize": 64,
        "offset": 96,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 12,
        "dwarf": 12,
    },
    {
        "name": "x13",
        "bitsize": 64,
        "offset": 104,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 13,
        "dwarf": 13,
    },
    {
        "name": "x14",
        "bitsize": 64,
        "offset": 112,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 14,
        "dwarf": 14,
    },
    {
        "name": "x15",
        "bitsize": 64,
        "offset": 120,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 15,
        "dwarf": 15,
    },
    {
        "name": "x16",
        "bitsize": 64,
        "offset": 128,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 16,
        "dwarf": 16,
    },
    {
        "name": "x17",
        "bitsize": 64,
        "offset": 136,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 17,
        "dwarf": 17,
    },
    {
        "name": "x18",
        "bitsize": 64,
        "offset": 144,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 18,
        "dwarf": 18,
    },
    {
        "name": "x19",
        "bitsize": 64,
        "offset": 152,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 19,
        "dwarf": 19,
    },
    {
        "name": "x20",
        "bitsize": 64,
        "offset": 160,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 20,
        "dwarf": 20,
    },
    {
        "name": "x21",
        "bitsize": 64,
        "offset": 168,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 21,
        "dwarf": 21,
    },
    {
        "name": "x22",
        "bitsize": 64,
        "offset": 176,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 22,
        "dwarf": 22,
    },
    {
        "name": "x23",
        "bitsize": 64,
        "offset": 184,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 23,
        "dwarf": 23,
    },
    {
        "name": "x24",
        "bitsize": 64,
        "offset": 192,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 24,
        "dwarf": 24,
    },
    {
        "name": "x25",
        "bitsize": 64,
        "offset": 200,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 25,
        "dwarf": 25,
    },
    {
        "name": "x26",
        "bitsize": 64,
        "offset": 208,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 26,
        "dwarf": 26,
    },
    {
        "name": "x27",
        "bitsize": 64,
        "offset": 216,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 27,
        "dwarf": 27,
    },
    {
        "name": "x28",
        "bitsize": 64,
        "offset": 224,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 28,
        "dwarf": 28,
    },
    {
        "name": "x29",
        "bitsize": 64,
        "offset": 232,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 29,
        "dwarf": 29,
        "generic": "fp",
        "alt-name": "fp",
    },
    {
        "name": "x30",
        "bitsize": 64,
        "offset": 240,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 30,
        "dwarf": 30,
        "generic": "lr",
        "alt-name": "lr",
    },
    {
        "name": "sp",
        "bitsize": 64,
        "offset": 248,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 31,
        "dwarf": 31,
        "generic": "sp",
        "alt-name": "sp",
    },
    {
        "name": "pc",
        "bitsize": 64,
        "offset": 256,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 32,
        "dwarf": 32,
        "generic": "pc",
        "alt-name": "pc",
    },
    {
        "name": "cpsr",
        "bitsize": 32,
        "offset": 264,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 33,
        "dwarf": 33,
    },
]

INTEL64_GPR = [
    {
        "name": "rax",
        "bitsize": 64,
        "offset": 0,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 0,
        "dwarf": 0,
    },
    {
        "name": "rbx",
        "bitsize": 64,
        "offset": 8,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 3,
        "dwarf": 3,
    },
    {
        "name": "rcx",
        "bitsize": 64,
        "offset": 16,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 2,
        "dwarf": 2,
        "generic": "arg4",
        "alt-name": "arg4",
    },
    {
        "name": "rdx",
        "bitsize": 64,
        "offset": 24,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 1,
        "dwarf": 1,
        "generic": "arg3",
        "alt-name": "arg3",
    },
    {
        "name": "rdi",
        "bitsize": 64,
        "offset": 32,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 5,
        "dwarf": 5,
        "generic": "arg1",
        "alt-name": "arg1",
    },
    {
        "name": "rsi",
        "bitsize": 64,
        "offset": 40,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 4,
        "dwarf": 4,
        "generic": "arg2",
        "alt-name": "arg2",
    },
    {
        "name": "rbp",
        "bitsize": 64,
        "offset": 48,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 6,
        "dwarf": 6,
        "generic": "fp",
        "alt-name": "fp",
    },
    {
        "name": "rsp",
        "bitsize": 64,
        "offset": 56,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 7,
        "dwarf": 7,
        "generic": "sp",
        "alt-name": "sp",
    },
    {
        "name": "r8",
        "bitsize": 64,
        "offset": 64,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 8,
        "dwarf": 8,
        "generic": "arg5",
        "alt-name": "arg5",
    },
    {
        "name": "r9",
        "bitsize": 64,
        "offset": 72,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 9,
        "dwarf": 9,
        "generic": "arg6",
        "alt-name": "arg6",
    },
    {
        "name": "r10",
        "bitsize": 64,
        "offset": 80,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 10,
        "dwarf": 10,
    },
    {
        "name": "r11",
        "bitsize": 64,
        "offset": 88,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 11,
        "dwarf": 11,
    },
    {
        "name": "r12",
        "bitsize": 64,
        "offset": 96,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 12,
        "dwarf": 12,
    },
    {
        "name": "r13",
        "bitsize": 64,
        "offset": 104,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 13,
        "dwarf": 13,
    },
    {
        "name": "r14",
        "bitsize": 64,
        "offset": 112,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 14,
        "dwarf": 14,
    },
    {
        "name": "r15",
        "bitsize": 64,
        "offset": 120,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 15,
        "dwarf": 15,
    },
    {
        "name": "rip",
        "bitsize": 64,
        "offset": 128,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 16,
        "dwarf": 16,
        "generic": "pc",
        "alt-name": "pc",
    },
    {
        "name": "rflags",
        "bitsize": 64,
        "offset": 136,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "generic": "flags",
        "alt-name": "flags",
    },
    {
        "name": "cs",
        "bitsize": 64,
        "offset": 144,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
    },
    {
        "name": "fs",
        "bitsize": 64,
        "offset": 152,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
    },
    {
        "name": "gs",
        "bitsize": 64,
        "offset": 160,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
    },
]

ARM64_GPR = [
    {
        "name": "x0",
        "bitsize": 64,
        "offset": 0,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 0,
        "dwarf": 0,
        "generic": "arg0",
        "alt-name": "arg0",
    },
    {
        "name": "x1",
        "bitsize": 64,
        "offset": 8,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 1,
        "dwarf": 1,
        "generic": "arg1",
        "alt-name": "arg1",
    },
    {
        "name": "x2",
        "bitsize": 64,
        "offset": 16,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 2,
        "dwarf": 2,
        "generic": "arg2",
        "alt-name": "arg2",
    },
    {
        "name": "x3",
        "bitsize": 64,
        "offset": 24,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 3,
        "dwarf": 3,
        "generic": "arg3",
        "alt-name": "arg3",
    },
    {
        "name": "x4",
        "bitsize": 64,
        "offset": 32,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 4,
        "dwarf": 4,
        "generic": "arg4",
        "alt-name": "arg4",
    },
    {
        "name": "x5",
        "bitsize": 64,
        "offset": 40,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 5,
        "dwarf": 5,
        "generic": "arg5",
        "alt-name": "arg5",
    },
    {
        "name": "x6",
        "bitsize": 64,
        "offset": 48,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 6,
        "dwarf": 6,
        "generic": "arg6",
        "alt-name": "arg6",
    },
    {
        "name": "x7",
        "bitsize": 64,
        "offset": 56,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 7,
        "dwarf": 7,
        "generic": "arg7",
        "alt-name": "arg7",
    },
    {
        "name": "x8",
        "bitsize": 64,
        "offset": 64,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 8,
        "dwarf": 8,
    },
    {
        "name": "x9",
        "bitsize": 64,
        "offset": 72,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 9,
        "dwarf": 9,
    },
    {
        "name": "x10",
        "bitsize": 64,
        "offset": 80,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 10,
        "dwarf": 10,
    },
    {
        "name": "x11",
        "bitsize": 64,
        "offset": 88,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 11,
        "dwarf": 11,
    },
    {
        "name": "x12",
        "bitsize": 64,
        "offset": 96,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 12,
        "dwarf": 12,
    },
    {
        "name": "x13",
        "bitsize": 64,
        "offset": 104,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 13,
        "dwarf": 13,
    },
    {
        "name": "x14",
        "bitsize": 64,
        "offset": 112,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 14,
        "dwarf": 14,
    },
    {
        "name": "x15",
        "bitsize": 64,
        "offset": 120,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 15,
        "dwarf": 15,
    },
    {
        "name": "x16",
        "bitsize": 64,
        "offset": 128,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 16,
        "dwarf": 16,
    },
    {
        "name": "x17",
        "bitsize": 64,
        "offset": 136,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 17,
        "dwarf": 17,
    },
    {
        "name": "x18",
        "bitsize": 64,
        "offset": 144,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 18,
        "dwarf": 18,
    },
    {
        "name": "x19",
        "bitsize": 64,
        "offset": 152,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 19,
        "dwarf": 19,
    },
    {
        "name": "x20",
        "bitsize": 64,
        "offset": 160,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 20,
        "dwarf": 20,
    },
    {
        "name": "x21",
        "bitsize": 64,
        "offset": 168,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 21,
        "dwarf": 21,
    },
    {
        "name": "x22",
        "bitsize": 64,
        "offset": 176,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 22,
        "dwarf": 22,
    },
    {
        "name": "x23",
        "bitsize": 64,
        "offset": 184,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 23,
        "dwarf": 23,
    },
    {
        "name": "x24",
        "bitsize": 64,
        "offset": 192,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 24,
        "dwarf": 24,
    },
    {
        "name": "x25",
        "bitsize": 64,
        "offset": 200,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 25,
        "dwarf": 25,
    },
    {
        "name": "x26",
        "bitsize": 64,
        "offset": 208,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 26,
        "dwarf": 26,
    },
    {
        "name": "x27",
        "bitsize": 64,
        "offset": 216,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 27,
        "dwarf": 27,
    },
    {
        "name": "x28",
        "bitsize": 64,
        "offset": 224,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 28,
        "dwarf": 28,
    },
    {
        "name": "x29",
        "bitsize": 64,
        "offset": 232,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 29,
        "dwarf": 29,
        "generic": "fp",
        "alt-name": "fp",
    },
    {
        "name": "x30",
        "bitsize": 64,
        "offset": 240,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 30,
        "dwarf": 30,
        "generic": "lr",
        "alt-name": "lr",
    },
    {
        "name": "sp",
        "bitsize": 64,
        "offset": 248,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 31,
        "dwarf": 31,
        "generic": "sp",
        "alt-name": "sp",
    },
    {
        "name": "pc",
        "bitsize": 64,
        "offset": 256,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 32,
        "dwarf": 32,
        "generic": "pc",
        "alt-name": "pc",
    },
    {
        "name": "cpsr",
        "bitsize": 32,
        "offset": 264,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 33,
        "dwarf": 33,
    },
]

INTEL64_GPR = [
    {
        "name": "rax",
        "bitsize": 64,
        "offset": 0,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 0,
        "dwarf": 0,
    },
    {
        "name": "rbx",
        "bitsize": 64,
        "offset": 8,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 3,
        "dwarf": 3,
    },
    {
        "name": "rcx",
        "bitsize": 64,
        "offset": 16,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 2,
        "dwarf": 2,
        "generic": "arg4",
        "alt-name": "arg4",
    },
    {
        "name": "rdx",
        "bitsize": 64,
        "offset": 24,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 1,
        "dwarf": 1,
        "generic": "arg3",
        "alt-name": "arg3",
    },
    {
        "name": "rdi",
        "bitsize": 64,
        "offset": 32,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 5,
        "dwarf": 5,
        "generic": "arg1",
        "alt-name": "arg1",
    },
    {
        "name": "rsi",
        "bitsize": 64,
        "offset": 40,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 4,
        "dwarf": 4,
        "generic": "arg2",
        "alt-name": "arg2",
    },
    {
        "name": "rbp",
        "bitsize": 64,
        "offset": 48,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 6,
        "dwarf": 6,
        "generic": "fp",
        "alt-name": "fp",
    },
    {
        "name": "rsp",
        "bitsize": 64,
        "offset": 56,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 7,
        "dwarf": 7,
        "generic": "sp",
        "alt-name": "sp",
    },
    {
        "name": "r8",
        "bitsize": 64,
        "offset": 64,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 8,
        "dwarf": 8,
        "generic": "arg5",
        "alt-name": "arg5",
    },
    {
        "name": "r9",
        "bitsize": 64,
        "offset": 72,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 9,
        "dwarf": 9,
        "generic": "arg6",
        "alt-name": "arg6",
    },
    {
        "name": "r10",
        "bitsize": 64,
        "offset": 80,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 10,
        "dwarf": 10,
    },
    {
        "name": "r11",
        "bitsize": 64,
        "offset": 88,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 11,
        "dwarf": 11,
    },
    {
        "name": "r12",
        "bitsize": 64,
        "offset": 96,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 12,
        "dwarf": 12,
    },
    {
        "name": "r13",
        "bitsize": 64,
        "offset": 104,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 13,
        "dwarf": 13,
    },
    {
        "name": "r14",
        "bitsize": 64,
        "offset": 112,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 14,
        "dwarf": 14,
    },
    {
        "name": "r15",
        "bitsize": 64,
        "offset": 120,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 15,
        "dwarf": 15,
    },
    {
        "name": "rip",
        "bitsize": 64,
        "offset": 128,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "gcc": 16,
        "dwarf": 16,
        "generic": "pc",
        "alt-name": "pc",
    },
    {
        "name": "rflags",
        "bitsize": 64,
        "offset": 136,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
        "generic": "flags",
        "alt-name": "flags",
    },
    {
        "name": "cs",
        "bitsize": 64,
        "offset": 144,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
    },
    {
        "name": "fs",
        "bitsize": 64,
        "offset": 152,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
    },
    {
        "name": "gs",
        "bitsize": 64,
        "offset": 160,
        "encoding": "uint",
        "format": "hex",
        "set": 0,
    },
]

```

`lldb/utils/__init__.py`:

```py
__all__ = ["in_call_stack", "symbolication"]
for x in __all__:
  __import__('lldb.utils.' + x)

def __lldb_init_module(debugger, internal_dict):
  import lldb
  for x in __all__:
    submodule = getattr(lldb.utils, x)
    lldb_init = getattr(submodule, '__lldb_init_module', None)
    if lldb_init:
      lldb_init(debugger, internal_dict)

```

`lldb/utils/in_call_stack.py`:

```py
#!/usr/bin/env python


def __lldb_init_module(debugger, internal_dict):
    debugger.HandleCommand(
        f"command alias in_call_stack breakpoint command add --python-function {__name__}.in_call_stack -k name -v %1"
    )


def in_call_stack(frame, bp_loc, arg_dict, _):
    """Only break if the given name is in the current call stack."""
    name = arg_dict.GetValueForKey("name").GetStringValue(1000)
    thread = frame.GetThread()
    found = False
    for frame in thread.frames:
        # Check the symbol.
        symbol = frame.GetSymbol()
        if symbol and name in frame.GetSymbol().GetName():
            return True
        # Check the function.
        function = frame.GetFunction()
        if function and name in function.GetName():
            return True
    return False

```

`lldb/utils/symbolication.py`:

```py
#!/usr/bin/env python

# ----------------------------------------------------------------------
# Be sure to add the python path that points to the LLDB shared library.
#
# To use this in the embedded python interpreter using "lldb":
#
#   cd /path/containing/crashlog.py
#   lldb
#   (lldb) script import crashlog
#   "crashlog" command installed, type "crashlog --help" for detailed help
#   (lldb) crashlog ~/Library/Logs/DiagnosticReports/a.crash
#
# The benefit of running the crashlog command inside lldb in the
# embedded python interpreter is when the command completes, there
# will be a target with all of the files loaded at the locations
# described in the crash log. Only the files that have stack frames
# in the backtrace will be loaded unless the "--load-all" option
# has been specified. This allows users to explore the program in the
# state it was in right at crash time.
#
# On MacOSX csh, tcsh:
#   ( setenv PYTHONPATH /path/to/LLDB.framework/Resources/Python ; ./crashlog.py ~/Library/Logs/DiagnosticReports/a.crash )
#
# On MacOSX sh, bash:
#   PYTHONPATH=/path/to/LLDB.framework/Resources/Python ./crashlog.py ~/Library/Logs/DiagnosticReports/a.crash
# ----------------------------------------------------------------------

import lldb
import optparse
import os
import plistlib
import re
import shlex
import sys
import time
import uuid
import json
import tempfile


class Address:
    """Class that represents an address that will be symbolicated"""

    def __init__(self, target, load_addr):
        self.target = target
        self.load_addr = load_addr  # The load address that this object represents
        # the resolved lldb.SBAddress (if any), named so_addr for
        # section/offset address
        self.so_addr = None
        self.sym_ctx = None  # The cached symbol context for this address
        # Any original textual description of this address to be used as a
        # backup in case symbolication fails
        self.description = None
        self.symbolication = (
            None  # The cached symbolicated string that describes this address
        )
        self.inlined = False

    def __str__(self):
        s = "%#16.16x" % (self.load_addr)
        if self.symbolication:
            s += " %s" % (self.symbolication)
        elif self.description:
            s += " %s" % (self.description)
        elif self.so_addr:
            s += " %s" % (self.so_addr)
        return s

    def resolve_addr(self):
        if self.so_addr is None:
            self.so_addr = self.target.ResolveLoadAddress(self.load_addr)
        return self.so_addr

    def is_inlined(self):
        return self.inlined

    def get_symbol_context(self):
        if self.sym_ctx is None:
            sb_addr = self.resolve_addr()
            if sb_addr:
                self.sym_ctx = self.target.ResolveSymbolContextForAddress(
                    sb_addr, lldb.eSymbolContextEverything
                )
            else:
                self.sym_ctx = lldb.SBSymbolContext()
        return self.sym_ctx

    def get_instructions(self):
        sym_ctx = self.get_symbol_context()
        if sym_ctx:
            function = sym_ctx.GetFunction()
            if function:
                return function.GetInstructions(self.target)
            return sym_ctx.GetSymbol().GetInstructions(self.target)
        return None

    def symbolicate(self, verbose=False):
        if self.symbolication is None:
            self.symbolication = ""
            self.inlined = False
            sym_ctx = self.get_symbol_context()
            if sym_ctx:
                module = sym_ctx.GetModule()
                if module:
                    # Print full source file path in verbose mode
                    if verbose:
                        self.symbolication += str(module.GetFileSpec()) + "`"
                    else:
                        self.symbolication += module.GetFileSpec().GetFilename() + "`"
                    function_start_load_addr = -1
                    function = sym_ctx.GetFunction()
                    block = sym_ctx.GetBlock()
                    line_entry = sym_ctx.GetLineEntry()
                    symbol = sym_ctx.GetSymbol()
                    inlined_block = block.GetContainingInlinedBlock()
                    if function:
                        self.symbolication += function.GetName()

                        if inlined_block:
                            self.inlined = True
                            self.symbolication += (
                                " [inlined] " + inlined_block.GetInlinedName()
                            )
                            block_range_idx = (
                                inlined_block.GetRangeIndexForBlockAddress(self.so_addr)
                            )
                            if block_range_idx < lldb.UINT32_MAX:
                                block_range_start_addr = (
                                    inlined_block.GetRangeStartAddress(block_range_idx)
                                )
                                function_start_load_addr = (
                                    block_range_start_addr.GetLoadAddress(self.target)
                                )
                        if function_start_load_addr == -1:
                            function_start_load_addr = (
                                function.GetStartAddress().GetLoadAddress(self.target)
                            )
                    elif symbol:
                        self.symbolication += symbol.GetName()
                        function_start_load_addr = (
                            symbol.GetStartAddress().GetLoadAddress(self.target)
                        )
                    else:
                        self.symbolication = ""
                        return False

                    # Dump the offset from the current function or symbol if it
                    # is non zero
                    function_offset = self.load_addr - function_start_load_addr
                    if function_offset > 0:
                        self.symbolication += " + %u" % (function_offset)
                    elif function_offset < 0:
                        self.symbolication += (
                            " %i (invalid negative offset, file a bug) "
                            % function_offset
                        )

                    # Print out any line information if any is available
                    if line_entry.GetFileSpec():
                        # Print full source file path in verbose mode
                        if verbose:
                            self.symbolication += " at %s" % line_entry.GetFileSpec()
                        else:
                            self.symbolication += (
                                " at %s" % line_entry.GetFileSpec().GetFilename()
                            )
                        self.symbolication += ":%u" % line_entry.GetLine()
                        column = line_entry.GetColumn()
                        if column > 0:
                            self.symbolication += ":%u" % column
                    return True
        return False


class Section:
    """Class that represents an load address range"""

    sect_info_regex = re.compile("(?P<name>[^=]+)=(?P<range>.*)")
    addr_regex = re.compile("^\s*(?P<start>0x[0-9A-Fa-f]+)\s*$")
    range_regex = re.compile(
        "^\s*(?P<start>0x[0-9A-Fa-f]+)\s*(?P<op>[-+])\s*(?P<end>0x[0-9A-Fa-f]+)\s*$"
    )

    def __init__(self, start_addr=None, end_addr=None, name=None):
        self.start_addr = start_addr
        self.end_addr = end_addr
        self.name = name

    @classmethod
    def InitWithSBTargetAndSBSection(cls, target, section):
        sect_load_addr = section.GetLoadAddress(target)
        if sect_load_addr != lldb.LLDB_INVALID_ADDRESS:
            obj = cls(sect_load_addr, sect_load_addr + section.size, section.name)
            return obj
        else:
            return None

    def contains(self, addr):
        return self.start_addr <= addr and addr < self.end_addr

    def set_from_string(self, s):
        match = self.sect_info_regex.match(s)
        if match:
            self.name = match.group("name")
            range_str = match.group("range")
            addr_match = self.addr_regex.match(range_str)
            if addr_match:
                self.start_addr = int(addr_match.group("start"), 16)
                self.end_addr = None
                return True

            range_match = self.range_regex.match(range_str)
            if range_match:
                self.start_addr = int(range_match.group("start"), 16)
                self.end_addr = int(range_match.group("end"), 16)
                op = range_match.group("op")
                if op == "+":
                    self.end_addr += self.start_addr
                return True
        print('error: invalid section info string "%s"' % s)
        print("Valid section info formats are:")
        print("Format                Example                    Description")
        print("--------------------- -----------------------------------------------")
        print(
            "<name>=<base>        __TEXT=0x123000             Section from base address only"
        )
        print(
            "<name>=<base>-<end>  __TEXT=0x123000-0x124000    Section from base address and end address"
        )
        print(
            "<name>=<base>+<size> __TEXT=0x123000+0x1000      Section from base address and size"
        )
        return False

    def __str__(self):
        if self.name:
            if self.end_addr is not None:
                if self.start_addr is not None:
                    return "%s=[0x%16.16x - 0x%16.16x)" % (
                        self.name,
                        self.start_addr,
                        self.end_addr,
                    )
            else:
                if self.start_addr is not None:
                    return "%s=0x%16.16x" % (self.name, self.start_addr)
            return self.name
        return "<invalid>"


class Image:
    """A class that represents an executable image and any associated data"""

    def __init__(self, path, uuid=None):
        self.path = path
        self.resolved_path = None
        self.resolve = False
        self.resolved = False
        self.unavailable = False
        self.uuid = uuid
        self.section_infos = list()
        self.identifier = None
        self.version = None
        self.arch = None
        self.module = None
        self.symfile = None
        self.slide = None
        self.symbols = dict()

    @classmethod
    def InitWithSBTargetAndSBModule(cls, target, module):
        """Initialize this Image object with a module from a target."""
        obj = cls(module.file.fullpath, module.uuid)
        obj.resolved_path = module.platform_file.fullpath
        obj.resolved = True
        for section in module.sections:
            symb_section = Section.InitWithSBTargetAndSBSection(target, section)
            if symb_section:
                obj.section_infos.append(symb_section)
        obj.arch = module.triple
        obj.module = module
        obj.symfile = None
        obj.slide = None
        return obj

    def dump(self, prefix):
        print("%s%s" % (prefix, self))

    def debug_dump(self):
        print('path = "%s"' % (self.path))
        print('resolved_path = "%s"' % (self.resolved_path))
        print("resolved = %i" % (self.resolved))
        print("unavailable = %i" % (self.unavailable))
        print("uuid = %s" % (self.uuid))
        print("section_infos = %s" % (self.section_infos))
        print('identifier = "%s"' % (self.identifier))
        print("version = %s" % (self.version))
        print("arch = %s" % (self.arch))
        print("module = %s" % (self.module))
        print('symfile = "%s"' % (self.symfile))
        print("slide = %i (0x%x)" % (self.slide, self.slide))

    def __str__(self):
        s = ""
        if self.uuid:
            s += "%s " % (self.get_uuid())
        if self.arch:
            s += "%s " % (self.arch)
        if self.version:
            s += "%s " % (self.version)
        resolved_path = self.get_resolved_path()
        if resolved_path:
            s += "%s " % (resolved_path)
        for section_info in self.section_infos:
            s += ", %s" % (section_info)
        if self.slide is not None:
            s += ", slide = 0x%16.16x" % self.slide
        return s

    def add_section(self, section):
        # print "added '%s' to '%s'" % (section, self.path)
        self.section_infos.append(section)

    def get_section_containing_load_addr(self, load_addr):
        for section_info in self.section_infos:
            if section_info.contains(load_addr):
                return section_info
        return None

    def get_resolved_path(self):
        if self.resolved_path:
            return self.resolved_path
        elif self.path:
            return self.path
        return None

    def get_resolved_path_basename(self):
        path = self.get_resolved_path()
        if path:
            return os.path.basename(path)
        return None

    def symfile_basename(self):
        if self.symfile:
            return os.path.basename(self.symfile)
        return None

    def has_section_load_info(self):
        return self.section_infos or self.slide is not None

    def load_module(self, target):
        if self.unavailable:
            return None  # We already warned that we couldn't find this module, so don't return an error string
        # Load this module into "target" using the section infos to
        # set the section load addresses
        if self.has_section_load_info():
            if target:
                if self.module:
                    if self.section_infos:
                        num_sections_loaded = 0
                        for section_info in self.section_infos:
                            if section_info.name:
                                section = self.module.FindSection(section_info.name)
                                if section:
                                    error = target.SetSectionLoadAddress(
                                        section, section_info.start_addr
                                    )
                                    if error.Success():
                                        num_sections_loaded += 1
                                    else:
                                        return "error: %s" % error.GetCString()
                                else:
                                    return (
                                        'error: unable to find the section named "%s"'
                                        % section_info.name
                                    )
                            else:
                                return 'error: unable to find "%s" section in "%s"' % (
                                    range.name,
                                    self.get_resolved_path(),
                                )
                        if num_sections_loaded == 0:
                            return "error: no sections were successfully loaded"
                    else:
                        err = target.SetModuleLoadAddress(self.module, self.slide)
                        if err.Fail():
                            return err.GetCString()
                    return None
                else:
                    return "error: invalid module"
            else:
                return "error: invalid target"
        else:
            return "error: no section infos"

    def add_module(self, target, obj_dir=None):
        """Add the Image described in this object to "target" and load the sections if "load" is True."""
        if not self.path and self.uuid == uuid.UUID(int=0):
            return "error: invalid image"

        if target:
            # Try and find using UUID only first so that paths need not match
            # up
            uuid_str = self.get_normalized_uuid_string()
            if uuid_str:
                self.module = target.AddModule(None, None, uuid_str)
            if not self.module and self.resolve:
                self.locate_module_and_debug_symbols()
                if not self.unavailable:
                    resolved_path = self.get_resolved_path()
                    self.module = target.AddModule(
                        resolved_path, None, uuid_str, self.symfile
                    )
            if not self.module and self.section_infos:
                name = os.path.basename(self.path)
                if obj_dir and os.path.isdir(obj_dir):
                    data = {
                        "triple": target.triple,
                        "uuid": uuid_str,
                        "type": "sharedlibrary",
                        "sections": list(),
                        "symbols": list(),
                    }
                    for section in self.section_infos:
                        data["sections"].append(
                            {
                                "name": section.name,
                                "size": section.end_addr - section.start_addr,
                            }
                        )
                    data["symbols"] = list(self.symbols.values())
                    obj_file = os.path.join(obj_dir, name)
                    with open(obj_file, "w") as f:
                        f.write(json.dumps(data, indent=4))
                    self.module = target.AddModule(obj_file, None, uuid_str)
                    if self.module:
                        # If we were able to add the module with inlined
                        # symbols, we should mark it as available so load_module
                        # does not exit early.
                        self.unavailable = False
            if not self.module and not self.unavailable:
                return 'error: unable to get module for (%s) "%s"' % (
                    self.arch,
                    self.get_resolved_path(),
                )
            if self.has_section_load_info():
                return self.load_module(target)
            else:
                return (
                    None  # No sections, the module was added to the target, so success
                )
        else:
            return "error: invalid target"

    def locate_module_and_debug_symbols(self):
        # By default, just use the paths that were supplied in:
        # self.path
        # self.resolved_path
        # self.module
        # self.symfile
        # Subclasses can inherit from this class and override this function
        self.resolved = True
        return True

    def get_uuid(self):
        if not self.uuid and self.module:
            self.uuid = uuid.UUID(self.module.GetUUIDString())
        return self.uuid

    def get_normalized_uuid_string(self):
        if self.uuid:
            return str(self.uuid).upper()
        return None

    def create_target(self, debugger):
        """Create a target using the information in this Image object."""
        if self.unavailable:
            return None

        if self.locate_module_and_debug_symbols():
            resolved_path = self.get_resolved_path()
            path_spec = lldb.SBFileSpec(resolved_path)
            error = lldb.SBError()
            target = debugger.CreateTarget(resolved_path, self.arch, None, False, error)
            if target:
                self.module = target.FindModule(path_spec)
                if self.has_section_load_info():
                    err = self.load_module(target)
                    if err:
                        print("ERROR: ", err)
                return target
            else:
                print(
                    'error: unable to create a valid target for (%s) "%s"'
                    % (self.arch, self.path)
                )
        else:
            print(
                'error: unable to locate main executable (%s) "%s"'
                % (self.arch, self.path)
            )
        return None


class Symbolicator:
    def __init__(self, debugger=None, target=None, images=None):
        """A class the represents the information needed to symbolicate
        addresses in a program.

        Do not call this initializer directly, but rather use the factory
        methods.
        """
        self.debugger = debugger
        self.target = target
        # a list of images to be used when symbolicating
        self.images = images if images else list()
        self.addr_mask = 0xFFFFFFFFFFFFFFFF

    @classmethod
    def InitWithSBTarget(cls, target):
        """Initialize a new Symbolicator with an existing SBTarget."""
        obj = cls(target=target)
        triple = target.triple
        if triple:
            arch = triple.split("-")[0]
            if "arm" in arch:
                obj.addr_mask = 0xFFFFFFFFFFFFFFFE

        for module in target.modules:
            image = Image.InitWithSBTargetAndSBModule(target, module)
            obj.images.append(image)
        return obj

    @classmethod
    def InitWithSBDebugger(cls, debugger, images):
        """Initialize a new Symbolicator with an existing debugger and list of
        images. The Symbolicator will create the target."""
        obj = cls(debugger=debugger, images=images)
        return obj

    def __str__(self):
        s = "Symbolicator:\n"
        if self.target:
            s += "Target = '%s'\n" % (self.target)
            s += "Target modules:\n"
            for m in self.target.modules:
                s += str(m) + "\n"
        s += "Images:\n"
        for image in self.images:
            s += "    %s\n" % (image)
        return s

    def find_images_with_identifier(self, identifier):
        images = list()
        for image in self.images:
            if image.identifier == identifier:
                images.append(image)
        if len(images) == 0:
            regex_text = "^.*\.%s$" % (re.escape(identifier))
            regex = re.compile(regex_text)
            for image in self.images:
                if regex.match(image.identifier):
                    images.append(image)
        return images

    def find_image_containing_load_addr(self, load_addr):
        for image in self.images:
            if image.get_section_containing_load_addr(load_addr):
                return image
        return None

    def create_target(self):
        if self.target:
            return self.target

        if self.images:
            for image in self.images:
                self.target = image.create_target(self.debugger)
                if self.target:
                    if self.target.GetAddressByteSize() == 4:
                        triple = self.target.triple
                        if triple:
                            arch = triple.split("-")[0]
                            if "arm" in arch:
                                self.addr_mask = 0xFFFFFFFFFFFFFFFE
                    return self.target
        return None

    def symbolicate(self, load_addr, verbose=False):
        if not self.target:
            self.create_target()
        if self.target:
            live_process = False
            process = self.target.process
            if process:
                state = process.state
                if state > lldb.eStateUnloaded and state < lldb.eStateDetached:
                    live_process = True
            # If we don't have a live process, we can attempt to find the image
            # that a load address belongs to and lazily load its module in the
            # target, but we shouldn't do any of this if we have a live process
            if not live_process:
                image = self.find_image_containing_load_addr(load_addr)
                if image:
                    image.add_module(self.target)
            symbolicated_address = Address(self.target, load_addr)
            if symbolicated_address.symbolicate(verbose):
                if symbolicated_address.so_addr:
                    symbolicated_addresses = list()
                    symbolicated_addresses.append(symbolicated_address)
                    # See if we were able to reconstruct anything?
                    while True:
                        inlined_parent_so_addr = lldb.SBAddress()
                        inlined_parent_sym_ctx = (
                            symbolicated_address.sym_ctx.GetParentOfInlinedScope(
                                symbolicated_address.so_addr, inlined_parent_so_addr
                            )
                        )
                        if not inlined_parent_sym_ctx:
                            break
                        if not inlined_parent_so_addr:
                            break

                        symbolicated_address = Address(
                            self.target,
                            inlined_parent_so_addr.GetLoadAddress(self.target),
                        )
                        symbolicated_address.sym_ctx = inlined_parent_sym_ctx
                        symbolicated_address.so_addr = inlined_parent_so_addr
                        symbolicated_address.symbolicate(verbose)

                        # push the new frame onto the new frame stack
                        symbolicated_addresses.append(symbolicated_address)

                    if symbolicated_addresses:
                        return symbolicated_addresses
        else:
            print("error: no target in Symbolicator")
        return None


def disassemble_instructions(
    target, instructions, pc, insts_before_pc, insts_after_pc, non_zeroeth_frame
):
    lines = list()
    pc_index = -1
    comment_column = 50
    for inst_idx, inst in enumerate(instructions):
        inst_pc = inst.GetAddress().GetLoadAddress(target)
        if pc == inst_pc:
            pc_index = inst_idx
        mnemonic = inst.GetMnemonic(target)
        operands = inst.GetOperands(target)
        comment = inst.GetComment(target)
        lines.append("%#16.16x: %8s %s" % (inst_pc, mnemonic, operands))
        if comment:
            line_len = len(lines[-1])
            if line_len < comment_column:
                lines[-1] += " " * (comment_column - line_len)
                lines[-1] += "; %s" % comment

    if pc_index >= 0:
        # If we are disassembling the non-zeroeth frame, we need to backup the
        # PC by 1
        if non_zeroeth_frame and pc_index > 0:
            pc_index = pc_index - 1
        if insts_before_pc == -1:
            start_idx = 0
        else:
            start_idx = pc_index - insts_before_pc
        if start_idx < 0:
            start_idx = 0
        if insts_before_pc == -1:
            end_idx = inst_idx
        else:
            end_idx = pc_index + insts_after_pc
        if end_idx > inst_idx:
            end_idx = inst_idx
        for i in range(start_idx, end_idx + 1):
            if i == pc_index:
                print(" -> ", lines[i])
            else:
                print("    ", lines[i])


def print_module_section_data(section):
    print(section)
    section_data = section.GetSectionData()
    if section_data:
        ostream = lldb.SBStream()
        section_data.GetDescription(ostream, section.GetFileAddress())
        print(ostream.GetData())


def print_module_section(section, depth):
    print(section)
    if depth > 0:
        num_sub_sections = section.GetNumSubSections()
        for sect_idx in range(num_sub_sections):
            print_module_section(section.GetSubSectionAtIndex(sect_idx), depth - 1)


def print_module_sections(module, depth):
    for sect in module.section_iter():
        print_module_section(sect, depth)


def print_module_symbols(module):
    for sym in module:
        print(sym)


def Symbolicate(debugger, command_args):
    usage = "usage: %prog [options] <addr1> [addr2 ...]"
    description = (
        """Symbolicate one or more addresses using LLDB's python scripting API.."""
    )
    parser = optparse.OptionParser(
        description=description, prog="crashlog.py", usage=usage
    )
    parser.add_option(
        "-v",
        "--verbose",
        action="store_true",
        dest="verbose",
        help="display verbose debug info",
        default=False,
    )
    parser.add_option(
        "-p",
        "--platform",
        type="string",
        metavar="platform",
        dest="platform",
        help='Specify the platform to use when creating the debug target. Valid values include "localhost", "darwin-kernel", "ios-simulator", "remote-freebsd", "remote-macosx", "remote-ios", "remote-linux".',
    )
    parser.add_option(
        "-f",
        "--file",
        type="string",
        metavar="file",
        dest="file",
        help="Specify a file to use when symbolicating",
    )
    parser.add_option(
        "-a",
        "--arch",
        type="string",
        metavar="arch",
        dest="arch",
        help="Specify a architecture to use when symbolicating",
    )
    parser.add_option(
        "-s",
        "--slide",
        type="int",
        metavar="slide",
        dest="slide",
        help="Specify the slide to use on the file specified with the --file option",
        default=None,
    )
    parser.add_option(
        "--section",
        type="string",
        action="append",
        dest="section_strings",
        help="specify <sect-name>=<start-addr> or <sect-name>=<start-addr>-<end-addr>",
    )
    try:
        (options, args) = parser.parse_args(command_args)
    except:
        return
    symbolicator = Symbolicator(debugger)
    images = list()
    if options.file:
        image = Image(options.file)
        image.arch = options.arch
        # Add any sections that were specified with one or more --section
        # options
        if options.section_strings:
            for section_str in options.section_strings:
                section = Section()
                if section.set_from_string(section_str):
                    image.add_section(section)
                else:
                    sys.exit(1)
        if options.slide is not None:
            image.slide = options.slide
        symbolicator.images.append(image)

    target = symbolicator.create_target()
    if options.verbose:
        print(symbolicator)
    if target:
        for addr_str in args:
            addr = int(addr_str, 0)
            symbolicated_addrs = symbolicator.symbolicate(addr, options.verbose)
            for symbolicated_addr in symbolicated_addrs:
                print(symbolicated_addr)
            print()
    else:
        print("error: no target for %s" % (symbolicator))


if __name__ == "__main__":
    # Create a new debugger instance
    debugger = lldb.SBDebugger.Create()
    Symbolicate(debugger, sys.argv[1:])
    SBDebugger.Destroy(debugger)

```

`requirements.txt`:

```txt
icicle-emu
```