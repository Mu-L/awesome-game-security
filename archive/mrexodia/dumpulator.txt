Project Path: arc_mrexodia_dumpulator_72n7hua8

Source Tree:

```txt
arc_mrexodia_dumpulator_72n7hua8
├── LICENSE
├── README.md
├── pyproject.toml
├── setup.cfg
├── setup.py
├── src
│   ├── dumpulator
│   │   ├── __init__.py
│   │   ├── details.py
│   │   ├── dumpulator.py
│   │   ├── handles.py
│   │   ├── memory.py
│   │   ├── modules.py
│   │   ├── native.py
│   │   ├── ntdevices.py
│   │   ├── ntenums.py
│   │   ├── ntprimitives.py
│   │   ├── ntstructs.py
│   │   └── ntsyscalls.py
│   └── minidump
│       ├── README.md
│       ├── __amain__.py
│       ├── __init__.py
│       ├── __main__.py
│       ├── _version.py
│       ├── aminidumpfile.py
│       ├── aminidumpreader.py
│       ├── common_structs.py
│       ├── constants.py
│       ├── directory.py
│       ├── exceptions.py
│       ├── header.py
│       ├── minidumpfile.py
│       ├── minidumpreader.py
│       ├── minidumpshell.py
│       ├── streams
│       │   ├── CommentStreamA.py
│       │   ├── CommentStreamW.py
│       │   ├── ContextStream.py
│       │   ├── ExceptionStream.py
│       │   ├── FunctionTableStream.py
│       │   ├── HandleDataStream.py
│       │   ├── HandleOperationListStream.py
│       │   ├── JavaScriptDataStream.py
│       │   ├── LastReservedStream.py
│       │   ├── Memory64ListStream.py
│       │   ├── MemoryInfoListStream.py
│       │   ├── MemoryListStream.py
│       │   ├── MiscInfoStream.py
│       │   ├── ModuleListStream.py
│       │   ├── ProcessVmCountersStream.py
│       │   ├── SystemInfoStream.py
│       │   ├── SystemMemoryInfoStream.py
│       │   ├── ThreadExListStream.py
│       │   ├── ThreadInfoListStream.py
│       │   ├── ThreadListStream.py
│       │   ├── TokenStream.py
│       │   ├── UnloadedModuleListStream.py
│       │   └── __init__.py
│       ├── utils
│       │   ├── __init__.py
│       │   ├── createminidump.py
│       │   ├── privileges.py
│       │   ├── privileges_types.py
│       │   └── winapi
│       │       ├── __init__.py
│       │       ├── defines.py
│       │       ├── kernel32.py
│       │       ├── psapi.py
│       │       └── version.py
│       ├── win_datatypes.py
│       └── writer.py
├── tests
│   ├── DumpulatorTests
│   │   ├── DumpulatorTests.sln
│   │   ├── ExceptionTest
│   │   │   ├── ExceptionTest.cpp
│   │   │   ├── ExceptionTest.vcxproj
│   │   │   └── ExceptionTest.vcxproj.filters
│   │   ├── HarnessFull
│   │   │   ├── HarnessFull.cpp
│   │   │   ├── HarnessFull.vcxproj
│   │   │   └── HarnessFull.vcxproj.filters
│   │   ├── HarnessMinimal
│   │   │   ├── HarnessMinimal.cpp
│   │   │   ├── HarnessMinimal.vcxproj
│   │   │   ├── HarnessMinimal.vcxproj.filters
│   │   │   ├── msvcrt_x86.def
│   │   │   └── msvcrt_x86.lib
│   │   ├── Loader
│   │   │   ├── Loader.cpp
│   │   │   ├── Loader.vcxproj
│   │   │   └── Loader.vcxproj.filters
│   │   ├── README.md
│   │   └── Tests
│   │       ├── DllMain.cpp
│   │       ├── HandleTest.cpp
│   │       ├── MemoryTest.cpp
│   │       ├── Tests.vcxproj
│   │       ├── Tests.vcxproj.filters
│   │       ├── debug.h
│   │       ├── exception_handler_x64.def
│   │       ├── exception_handler_x64.lib
│   │       ├── exception_handler_x86.def
│   │       ├── exception_handler_x86.lib
│   │       ├── ntstatusdb.cpp
│   │       ├── ntstatusdb.h
│   │       └── phnt.h
│   ├── StringEncryptionFun
│   │   ├── StringEncryptionFun
│   │   │   ├── StringEncryptionFun.vcxproj
│   │   │   ├── StringEncryptionFun.vcxproj.filters
│   │   │   ├── decryption.cpp
│   │   │   └── main.cpp
│   │   └── StringEncryptionFun.sln
│   ├── download_artifacts.py
│   ├── emulate-process.py
│   ├── exception-test32.py
│   ├── exception-test64.py
│   ├── execute-dump.py
│   ├── getting-started.py
│   ├── getting-started32.py
│   ├── handletest.py
│   ├── memory_test.py
│   ├── run-tests.py
│   └── x64dbg-tracedump.py
└── utils
    ├── parse_phnt.py
    └── phnt.c

```

`LICENSE`:

```
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
```

`README.md`:

```md
# dumpulator

**Note: This is a work-in-progress prototype, please treat it as such. Pull requests are welcome! You can get your feet wet with [good first issues](https://github.com/mrexodia/dumpulator/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22)**

An easy-to-use library for emulating code in minidump files. Here are some links to posts/videos using dumpulator:

- Introduction video with [OALabs](https://oalabs.openanalysis.net): [Dumpulator - Using Binary Emulation To Automate Reverse Engineering](https://youtu.be/4Pfu98Xx9Yo)
- [Emulating malware with Dumpulator](https://rioasmara.com/2022/07/23/emulating-malware-with-dumpulator/)
- [Emotet x64 Stack Strings Config Emulation | OALabs Research](https://research.openanalysis.net/emotet/emulation/config/dumpulator/malware/2022/05/19/emotet_x64_emulation.html)
- [Native function and Assembly Code Invocation](https://research.checkpoint.com/2022/native-function-and-assembly-code-invocation/)
- [Guloader string decryption (VEH)](https://research.openanalysis.net/guloader/emulation/dumpulator/veh/exceptions/2023/01/15/dumpulator-veh.html)
- [Rhadamanthys | OALabs Research](https://research.openanalysis.net/rhadamanthys/config/ida/shifted%20pointers/peb/_list_entry/_ldr_data_table_entry/2023/01/19/rhadamanthys.html)
- [\[Case study\] Decrypt strings using Dumpulator](https://kienmanowar.wordpress.com/2023/05/22/case-study-decrypt-strings-using-dumpulator/)

<sub>Feel free to send a pull request to add your article here!</sub>


## Examples

### Calling a function

The example below opens `StringEncryptionFun_x64.dmp` (download a copy [here](https://github.com/mrexodia/dumpulator/releases/download/v0.0.1/StringEncryptionFun_x64.dmp)), allocates some memory and calls the decryption function at `0x140001000` to decrypt the string at `0x140017000`:

```python
from dumpulator import Dumpulator

dp = Dumpulator("StringEncryptionFun_x64.dmp")
temp_addr = dp.allocate(256)
dp.call(0x140001000, [temp_addr, 0x140017000])
decrypted = dp.read_str(temp_addr)
print(f"decrypted: '{decrypted}'")
```

The `StringEncryptionFun_x64.dmp` is collected at the entry point of the `tests/StringEncryptionFun` example. You can get the compiled binaries for `StringEncryptionFun` [here](https://github.com/mrexodia/dumpulator/releases/download/v0.0.1/StringEncryptionFun.7z)

### Tracing execution

```python
from dumpulator import Dumpulator

dp = Dumpulator("StringEncryptionFun_x64.dmp", trace=True)
dp.start(dp.regs.rip)
```

This will create `StringEncryptionFun_x64.dmp.trace` with a list of instructions executed and some helpful indications when switching modules etc. Note that tracing _significantly_ slows down emulation and it's mostly meant for debugging.

### Reading utf-16 strings

```python
from dumpulator import Dumpulator

dp = Dumpulator("my.dmp")
buf = dp.call(0x140001000)
dp.read_str(buf, encoding='utf-16')
```

### Running a snippet of code

Say you have the following function:

```
00007FFFC81C06C0 | mov qword ptr [rsp+0x10],rbx       ; prolog_start
00007FFFC81C06C5 | mov qword ptr [rsp+0x18],rsi
00007FFFC81C06CA | push rbp
00007FFFC81C06CB | push rdi
00007FFFC81C06CC | push r14
00007FFFC81C06CE | lea rbp,qword ptr [rsp-0x100]
00007FFFC81C06D6 | sub rsp,0x200                      ; prolog_end
00007FFFC81C06DD | mov rax,qword ptr [0x7FFFC8272510]
```

You only want to execute the prolog and set up some registers:

```python
from dumpulator import Dumpulator

prolog_start = 0x00007FFFC81C06C0
# we want to stop the instruction after the prolog
prolog_end = 0x00007FFFC81C06D6 + 7

dp = Dumpulator("my.dmp", quiet=True)
dp.regs.rcx = 0x1337
dp.start(begin=prolog_start, end=prolog_end)
print(f"rsp: {hex(dp.regs.rsp)}")
```

The `quiet` flag suppresses the logs about DLLs loaded and memory regions set up (for use in scripts where you want to reduce log spam).

### Custom syscall implementation

You can (re)implement syscalls by using the `@syscall` decorator:

```python
from dumpulator import *
from dumpulator.native import *
from dumpulator.handles import *
from dumpulator.memory import *

@syscall
def ZwQueryVolumeInformationFile(dp: Dumpulator,
                                 FileHandle: HANDLE,
                                 IoStatusBlock: P[IO_STATUS_BLOCK],
                                 FsInformation: PVOID,
                                 Length: ULONG,
                                 FsInformationClass: FSINFOCLASS
                                 ):
    return STATUS_NOT_IMPLEMENTED
```

All the syscall function prototypes can be found in [ntsyscalls.py](https://github.com/mrexodia/dumpulator/blob/main/src/dumpulator/ntsyscalls.py). There are also a lot of examples  there on how to use the API.

To hook an existing syscall implementation you can do the following:

```python
import dumpulator.ntsyscalls as ntsyscalls

@syscall
def ZwOpenProcess(dp: Dumpulator,
                  ProcessHandle: Annotated[P[HANDLE], SAL("_Out_")],
                  DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                  ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                  ClientId: Annotated[P[CLIENT_ID], SAL("_In_opt_")]
                  ):
    process_id = ClientId.read_ptr()
    assert process_id == dp.parent_process_id
    ProcessHandle.write_ptr(0x1337)
    return STATUS_SUCCESS

@syscall
def ZwQueryInformationProcess(dp: Dumpulator,
                              ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                              ProcessInformationClass: Annotated[PROCESSINFOCLASS, SAL("_In_")],
                              ProcessInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(ProcessInformationLength)")],
                              ProcessInformationLength: Annotated[ULONG, SAL("_In_")],
                              ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                              ):
    if ProcessInformationClass == PROCESSINFOCLASS.ProcessImageFileNameWin32:
        if ProcessHandle == dp.NtCurrentProcess():
            main_module = dp.modules[dp.modules.main]
            image_path = main_module.path
        elif ProcessHandle == 0x1337:
            image_path = R"C:\Windows\explorer.exe"
        else:
            raise NotImplementedError()
        buffer = UNICODE_STRING.create_buffer(image_path, ProcessInformation)
        assert ProcessInformationLength >= len(buffer)
        if ReturnLength.ptr:
            dp.write_ulong(ReturnLength.ptr, len(buffer))
        ProcessInformation.write(buffer)
        return STATUS_SUCCESS
    return ntsyscalls.ZwQueryInformationProcess(dp,
                                                ProcessHandle,
                                                ProcessInformationClass,
                                                ProcessInformation,
                                                ProcessInformationLength,
                                                ReturnLength
                                                )
```

### Custom structures

Since `v0.2.0` there is support for easily declaring your own structures:

```python
from dumpulator.native import *

class PROCESS_BASIC_INFORMATION(Struct):
    ExitStatus: ULONG
    PebBaseAddress: PVOID
    AffinityMask: KAFFINITY
    BasePriority: KPRIORITY
    UniqueProcessId: ULONG_PTR
    InheritedFromUniqueProcessId: ULONG_PTR
```

To instantiate these structures you have to use a `Dumpulator` instance:

```python
pbi = PROCESS_BASIC_INFORMATION(dp)
assert ProcessInformationLength == Struct.sizeof(pbi)
pbi.ExitStatus = 259  # STILL_ACTIVE
pbi.PebBaseAddress = dp.peb
pbi.AffinityMask = 0xFFFF
pbi.BasePriority = 8
pbi.UniqueProcessId = dp.process_id
pbi.InheritedFromUniqueProcessId = dp.parent_process_id
ProcessInformation.write(bytes(pbi))
if ReturnLength.ptr:
    dp.write_ulong(ReturnLength.ptr, Struct.sizeof(pbi))
return STATUS_SUCCESS
```

If you pass a pointer value as a second argument the structure will be read from memory. You can declare pointers with `myptr: P[MY_STRUCT]` and dereferences them with `myptr[0]`.

## Collecting the dump

~~There is a simple [x64dbg](https://github.com/x64dbg/x64dbg) plugin available called [MiniDumpPlugin](https://github.com/mrexodia/MiniDumpPlugin/releases)~~ The [minidump](https://help.x64dbg.com/en/latest/commands/memory-operations/minidump.html) command has been integrated into x64dbg since 2022-10-10. To create a dump, pause execution and execute the command `MiniDump my.dmp`.

## Installation

From [PyPI](https://pypi.org/project/dumpulator) (latest [release](https://github.com/mrexodia/dumpulator/releases)):

```
python -m pip install dumpulator
```

To install from source:

```
python setup.py install
```

Install for a development environment:

```
python setup.py develop
```

## Related work

- [Dumpulator-IDA](https://github.com/michaeljgoodman/Dumpulator-IDA): This project is a small POC plugin for launching dumpulator emulation within IDA, passing it addresses from your IDA view using the context menu.
- [wtf](https://github.com/0vercl0k/wtf): Distributed, code-coverage guided, customizable, cross-platform snapshot-based fuzzer designed for attacking user and / or kernel-mode targets running on Microsoft Windows
- [speakeasy](https://github.com/mandiant/speakeasy): Windows sandbox on top of unicorn.
- [qiling](https://github.com/qilingframework/qiling): Binary emulation framework on top of unicorn.
- [Simpleator](https://github.com/ionescu007/Simpleator): User-mode application emulator based on the Hyper-V Platform API.

What sets dumpulator apart from sandboxes like speakeasy and qiling is that the full process memory is available. This improves performance because you can emulate large parts of malware without ever leaving unicorn. Additionally only syscalls have to be emulated to provide a realistic Windows environment (since everything actually _is_ a legitimate process environment).

## Credits

- [herrcore](https://twitter.com/herrcore) for inspiring me to make this
- [secret club](https://secret.club)
- [JetBrains](https://www.jetbrains.com/opensource/) for free PyCharm license!
- [Image by GraphiqaStock](https://www.freepik.com/free-vector/virus-internet_1040653.htm) on Freepik

```

`pyproject.toml`:

```toml
# Source: https://packaging.python.org/tutorials/packaging-projects/#creating-pyproject-toml

[build-system]
requires = [
    "setuptools>=42",
    "wheel"
]
build-backend = "setuptools.build_meta"

```

`setup.cfg`:

```cfg
# Source: https://packaging.python.org/tutorials/packaging-projects/#configuring-metadata

[metadata]
name = dumpulator
version = v1.0.0
author = Duncan Ogilvie
author_email = dumpulator@mrexodia.re
description = An easy-to-use library for emulating code in minidump files.
long_description = file: README.md
long_description_content_type = text/markdown
url = https://github.com/mrexodia/dumpulator
project_urls =
    Bug Tracker = https://github.com/mrexodia/dumpulator/issues
classifiers =
    Programming Language :: Python :: 3
    License :: OSI Approved :: Boost Software License 1.0 (BSL-1.0)
    Operating System :: OS Independent

[options]
package_dir =
    = src
packages = find:
python_requires = >=3.9
install_requires =
    #minidump ~=0.0.21 # this library has a bug, is vendored locally
    unicorn ~=2.0.0
    pefile >=2021.9.3
    capstone ~=4.0.2
develop_requires =
    libclang ~=15.0.0

[options.packages.find]
where = src

```

`setup.py`:

```py
#!/usr/bin/env python
import subprocess
import sys

# Based on: https://stackoverflow.com/a/62983901/1806760

import setuptools
import os

if __name__ == "__main__":
    ref_name = os.getenv("GITHUB_REF_NAME")
    if ref_name:
        from pkg_resources import parse_version
        try:
            parse_version(ref_name)
            print(f"injecting version = {ref_name} into setup.cfg")
            with open("setup.cfg", "r") as f:
                lines = f.readlines()
            with open("setup.cfg", "w") as f:
                for line in lines:
                    if line.startswith("version = "):
                        line = f"version = {ref_name}\n"
                    f.write(line)
        except Exception:
            pass
    # HACK: support [options].develop_requires install development dependencies
    if "develop" in sys.argv:
        import configparser
        config = configparser.ConfigParser()
        config.read("setup.cfg")
        if "options" in config:
            options = config["options"]
            if "develop_requires" in options:
                develop_requires = [line for line in options["develop_requires"].splitlines() if line]
                pip_args = [sys.executable, "-m", "pip", "install", *develop_requires]
                print(f"Installing development requirements: python " + " ".join(pip_args[1:]))
                try:
                    subprocess.check_call(pip_args)
                except subprocess.CalledProcessError:
                    sys.exit(1)
    setuptools.setup()

```

`src/dumpulator/__init__.py`:

```py
from .dumpulator import Dumpulator, ExceptionType, MemoryViolation, ExceptionInfo
from .ntsyscalls import syscall

```

`src/dumpulator/details.py`:

```py
import struct
from collections import namedtuple
from typing import List, Dict, Optional, Iterable

from unicorn import *
from unicorn.x86_const import *

from dumpulator.memory import MemoryProtect, PageManager

def map_unicorn_perms(protect: MemoryProtect):
    if isinstance(protect, int):
        protect = MemoryProtect(protect)
    assert isinstance(protect, MemoryProtect)
    baseprotect = protect & ~(MemoryProtect.PAGE_WRITECOMBINE | MemoryProtect.PAGE_NOCACHE | MemoryProtect.PAGE_GUARD)
    mapping = {
        MemoryProtect.PAGE_EXECUTE: UC_PROT_EXEC | UC_PROT_READ,
        MemoryProtect.PAGE_EXECUTE_READ: UC_PROT_EXEC | UC_PROT_READ,
        MemoryProtect.PAGE_EXECUTE_READWRITE: UC_PROT_ALL,
        MemoryProtect.PAGE_EXECUTE_WRITECOPY: UC_PROT_ALL,
        MemoryProtect.PAGE_NOACCESS: UC_PROT_NONE,
        MemoryProtect.PAGE_READONLY: UC_PROT_READ,
        MemoryProtect.PAGE_READWRITE: UC_PROT_READ | UC_PROT_WRITE,
        MemoryProtect.PAGE_WRITECOPY: UC_PROT_READ | UC_PROT_WRITE,
    }
    perms = mapping[baseprotect]
    if protect & MemoryProtect.PAGE_GUARD:
        perms = UC_PROT_NONE
    return perms


class Registers:
    def __init__(self, uc: Uc, x64):
        self._uc = uc
        self._x64 = x64
        self._regmap = {
            "ah": UC_X86_REG_AH,
            "al": UC_X86_REG_AL,
            "ax": UC_X86_REG_AX,
            "bh": UC_X86_REG_BH,
            "bl": UC_X86_REG_BL,
            "bp": UC_X86_REG_BP,
            "bpl": UC_X86_REG_BPL,
            "bx": UC_X86_REG_BX,
            "ch": UC_X86_REG_CH,
            "cl": UC_X86_REG_CL,
            "cs": UC_X86_REG_CS,
            "cx": UC_X86_REG_CX,
            "dh": UC_X86_REG_DH,
            "di": UC_X86_REG_DI,
            "dil": UC_X86_REG_DIL,
            "dl": UC_X86_REG_DL,
            "ds": UC_X86_REG_DS,
            "dx": UC_X86_REG_DX,
            "eax": UC_X86_REG_EAX,
            "ebp": UC_X86_REG_EBP,
            "ebx": UC_X86_REG_EBX,
            "ecx": UC_X86_REG_ECX,
            "edi": UC_X86_REG_EDI,
            "edx": UC_X86_REG_EDX,
            "eflags": UC_X86_REG_EFLAGS,
            "eip": UC_X86_REG_EIP,
            "es": UC_X86_REG_ES,
            "esi": UC_X86_REG_ESI,
            "esp": UC_X86_REG_ESP,
            "fpsw": UC_X86_REG_FPSW,
            "fs": UC_X86_REG_FS,
            "gs": UC_X86_REG_GS,
            "ip": UC_X86_REG_IP,
            "rax": UC_X86_REG_RAX,
            "rbp": UC_X86_REG_RBP,
            "rbx": UC_X86_REG_RBX,
            "rcx": UC_X86_REG_RCX,
            "rdi": UC_X86_REG_RDI,
            "rdx": UC_X86_REG_RDX,
            "rip": UC_X86_REG_RIP,
            "rsi": UC_X86_REG_RSI,
            "rsp": UC_X86_REG_RSP,
            "si": UC_X86_REG_SI,
            "sil": UC_X86_REG_SIL,
            "sp": UC_X86_REG_SP,
            "spl": UC_X86_REG_SPL,
            "ss": UC_X86_REG_SS,
            "cr0": UC_X86_REG_CR0,
            "cr1": UC_X86_REG_CR1,
            "cr2": UC_X86_REG_CR2,
            "cr3": UC_X86_REG_CR3,
            "cr4": UC_X86_REG_CR4,
            "cr8": UC_X86_REG_CR8,
            "dr0": UC_X86_REG_DR0,
            "dr1": UC_X86_REG_DR1,
            "dr2": UC_X86_REG_DR2,
            "dr3": UC_X86_REG_DR3,
            "dr4": UC_X86_REG_DR4,
            "dr5": UC_X86_REG_DR5,
            "dr6": UC_X86_REG_DR6,
            "dr7": UC_X86_REG_DR7,
            "fp0": UC_X86_REG_FP0,
            "fp1": UC_X86_REG_FP1,
            "fp2": UC_X86_REG_FP2,
            "fp3": UC_X86_REG_FP3,
            "fp4": UC_X86_REG_FP4,
            "fp5": UC_X86_REG_FP5,
            "fp6": UC_X86_REG_FP6,
            "fp7": UC_X86_REG_FP7,
            "k0": UC_X86_REG_K0,
            "k1": UC_X86_REG_K1,
            "k2": UC_X86_REG_K2,
            "k3": UC_X86_REG_K3,
            "k4": UC_X86_REG_K4,
            "k5": UC_X86_REG_K5,
            "k6": UC_X86_REG_K6,
            "k7": UC_X86_REG_K7,
            "mm0": UC_X86_REG_MM0,
            "mm1": UC_X86_REG_MM1,
            "mm2": UC_X86_REG_MM2,
            "mm3": UC_X86_REG_MM3,
            "mm4": UC_X86_REG_MM4,
            "mm5": UC_X86_REG_MM5,
            "mm6": UC_X86_REG_MM6,
            "mm7": UC_X86_REG_MM7,
            "r8": UC_X86_REG_R8,
            "r9": UC_X86_REG_R9,
            "r10": UC_X86_REG_R10,
            "r11": UC_X86_REG_R11,
            "r12": UC_X86_REG_R12,
            "r13": UC_X86_REG_R13,
            "r14": UC_X86_REG_R14,
            "r15": UC_X86_REG_R15,
            "st0": UC_X86_REG_ST0,
            "st1": UC_X86_REG_ST1,
            "st2": UC_X86_REG_ST2,
            "st3": UC_X86_REG_ST3,
            "st4": UC_X86_REG_ST4,
            "st5": UC_X86_REG_ST5,
            "st6": UC_X86_REG_ST6,
            "st7": UC_X86_REG_ST7,
            "xmm0": UC_X86_REG_XMM0,
            "xmm1": UC_X86_REG_XMM1,
            "xmm2": UC_X86_REG_XMM2,
            "xmm3": UC_X86_REG_XMM3,
            "xmm4": UC_X86_REG_XMM4,
            "xmm5": UC_X86_REG_XMM5,
            "xmm6": UC_X86_REG_XMM6,
            "xmm7": UC_X86_REG_XMM7,
            "xmm8": UC_X86_REG_XMM8,
            "xmm9": UC_X86_REG_XMM9,
            "xmm10": UC_X86_REG_XMM10,
            "xmm11": UC_X86_REG_XMM11,
            "xmm12": UC_X86_REG_XMM12,
            "xmm13": UC_X86_REG_XMM13,
            "xmm14": UC_X86_REG_XMM14,
            "xmm15": UC_X86_REG_XMM15,
            "xmm16": UC_X86_REG_XMM16,
            "xmm17": UC_X86_REG_XMM17,
            "xmm18": UC_X86_REG_XMM18,
            "xmm19": UC_X86_REG_XMM19,
            "xmm20": UC_X86_REG_XMM20,
            "xmm21": UC_X86_REG_XMM21,
            "xmm22": UC_X86_REG_XMM22,
            "xmm23": UC_X86_REG_XMM23,
            "xmm24": UC_X86_REG_XMM24,
            "xmm25": UC_X86_REG_XMM25,
            "xmm26": UC_X86_REG_XMM26,
            "xmm27": UC_X86_REG_XMM27,
            "xmm28": UC_X86_REG_XMM28,
            "xmm29": UC_X86_REG_XMM29,
            "xmm30": UC_X86_REG_XMM30,
            "xmm31": UC_X86_REG_XMM31,
            "ymm0": UC_X86_REG_YMM0,
            "ymm1": UC_X86_REG_YMM1,
            "ymm2": UC_X86_REG_YMM2,
            "ymm3": UC_X86_REG_YMM3,
            "ymm4": UC_X86_REG_YMM4,
            "ymm5": UC_X86_REG_YMM5,
            "ymm6": UC_X86_REG_YMM6,
            "ymm7": UC_X86_REG_YMM7,
            "ymm8": UC_X86_REG_YMM8,
            "ymm9": UC_X86_REG_YMM9,
            "ymm10": UC_X86_REG_YMM10,
            "ymm11": UC_X86_REG_YMM11,
            "ymm12": UC_X86_REG_YMM12,
            "ymm13": UC_X86_REG_YMM13,
            "ymm14": UC_X86_REG_YMM14,
            "ymm15": UC_X86_REG_YMM15,
            "ymm16": UC_X86_REG_YMM16,
            "ymm17": UC_X86_REG_YMM17,
            "ymm18": UC_X86_REG_YMM18,
            "ymm19": UC_X86_REG_YMM19,
            "ymm20": UC_X86_REG_YMM20,
            "ymm21": UC_X86_REG_YMM21,
            "ymm22": UC_X86_REG_YMM22,
            "ymm23": UC_X86_REG_YMM23,
            "ymm24": UC_X86_REG_YMM24,
            "ymm25": UC_X86_REG_YMM25,
            "ymm26": UC_X86_REG_YMM26,
            "ymm27": UC_X86_REG_YMM27,
            "ymm28": UC_X86_REG_YMM28,
            "ymm29": UC_X86_REG_YMM29,
            "ymm30": UC_X86_REG_YMM30,
            "ymm31": UC_X86_REG_YMM31,
            "zmm0": UC_X86_REG_ZMM0,
            "zmm1": UC_X86_REG_ZMM1,
            "zmm2": UC_X86_REG_ZMM2,
            "zmm3": UC_X86_REG_ZMM3,
            "zmm4": UC_X86_REG_ZMM4,
            "zmm5": UC_X86_REG_ZMM5,
            "zmm6": UC_X86_REG_ZMM6,
            "zmm7": UC_X86_REG_ZMM7,
            "zmm8": UC_X86_REG_ZMM8,
            "zmm9": UC_X86_REG_ZMM9,
            "zmm10": UC_X86_REG_ZMM10,
            "zmm11": UC_X86_REG_ZMM11,
            "zmm12": UC_X86_REG_ZMM12,
            "zmm13": UC_X86_REG_ZMM13,
            "zmm14": UC_X86_REG_ZMM14,
            "zmm15": UC_X86_REG_ZMM15,
            "zmm16": UC_X86_REG_ZMM16,
            "zmm17": UC_X86_REG_ZMM17,
            "zmm18": UC_X86_REG_ZMM18,
            "zmm19": UC_X86_REG_ZMM19,
            "zmm20": UC_X86_REG_ZMM20,
            "zmm21": UC_X86_REG_ZMM21,
            "zmm22": UC_X86_REG_ZMM22,
            "zmm23": UC_X86_REG_ZMM23,
            "zmm24": UC_X86_REG_ZMM24,
            "zmm25": UC_X86_REG_ZMM25,
            "zmm26": UC_X86_REG_ZMM26,
            "zmm27": UC_X86_REG_ZMM27,
            "zmm28": UC_X86_REG_ZMM28,
            "zmm29": UC_X86_REG_ZMM29,
            "zmm30": UC_X86_REG_ZMM30,
            "zmm31": UC_X86_REG_ZMM31,
            "r8b": UC_X86_REG_R8B,
            "r9b": UC_X86_REG_R9B,
            "r10b": UC_X86_REG_R10B,
            "r11b": UC_X86_REG_R11B,
            "r12b": UC_X86_REG_R12B,
            "r13b": UC_X86_REG_R13B,
            "r14b": UC_X86_REG_R14B,
            "r15b": UC_X86_REG_R15B,
            "r8d": UC_X86_REG_R8D,
            "r9d": UC_X86_REG_R9D,
            "r10d": UC_X86_REG_R10D,
            "r11d": UC_X86_REG_R11D,
            "r12d": UC_X86_REG_R12D,
            "r13d": UC_X86_REG_R13D,
            "r14d": UC_X86_REG_R14D,
            "r15d": UC_X86_REG_R15D,
            "r8w": UC_X86_REG_R8W,
            "r9w": UC_X86_REG_R9W,
            "r10w": UC_X86_REG_R10W,
            "r11w": UC_X86_REG_R11W,
            "r12w": UC_X86_REG_R12W,
            "r13w": UC_X86_REG_R13W,
            "r14w": UC_X86_REG_R14W,
            "r15w": UC_X86_REG_R15W,
            "idtr": UC_X86_REG_IDTR,
            "gdtr": UC_X86_REG_GDTR,
            "ldtr": UC_X86_REG_LDTR,
            "tr": UC_X86_REG_TR,
            "fpcw": UC_X86_REG_FPCW,
            "fptag": UC_X86_REG_FPTAG,
            "msr": UC_X86_REG_MSR,
            "mxcsr": UC_X86_REG_MXCSR,
            "fs_base": UC_X86_REG_FS_BASE,
            "gs_base": UC_X86_REG_GS_BASE,
        }
        for i in range(8):
            reg = UC_X86_REG_ST0 + i
            self._regmap[f"st{i}"] = reg
            self._regmap[f"st({i})"] = reg
        if unicorn.__version__[0] < '2':
            self._regmap.update({
                "riz": UC_X86_REG_RIZ,
                "cr5": UC_X86_REG_CR5,
                "cr6": UC_X86_REG_CR6,
                "cr7": UC_X86_REG_CR7,
                "cr9": UC_X86_REG_CR9,
                "cr10": UC_X86_REG_CR10,
                "cr11": UC_X86_REG_CR11,
                "cr12": UC_X86_REG_CR12,
                "cr13": UC_X86_REG_CR13,
                "cr14": UC_X86_REG_CR14,
                "cr15": UC_X86_REG_CR15,
                "dr8": UC_X86_REG_DR8,
                "dr9": UC_X86_REG_DR9,
                "dr10": UC_X86_REG_DR10,
                "dr11": UC_X86_REG_DR11,
                "dr12": UC_X86_REG_DR12,
                "dr13": UC_X86_REG_DR13,
                "dr14": UC_X86_REG_DR14,
                "dr15": UC_X86_REG_DR15,
                "rflags": UC_X86_REG_EFLAGS,
            })
        else:
            self._regmap.update({
                "flags": UC_X86_REG_FLAGS,
                "rflags": UC_X86_REG_RFLAGS
            })
        if self._x64:
            self._regmap.update({
                "cax": UC_X86_REG_RAX,
                "cbx": UC_X86_REG_RBX,
                "ccx": UC_X86_REG_RCX,
                "cdx": UC_X86_REG_RDX,
                "cbp": UC_X86_REG_RBP,
                "csp": UC_X86_REG_RSP,
                "csi": UC_X86_REG_RSI,
                "cdi": UC_X86_REG_RDI,
                "cip": UC_X86_REG_RIP,
            })
        else:
            self._regmap.update({
                "cax": UC_X86_REG_EAX,
                "cbx": UC_X86_REG_EBX,
                "ccx": UC_X86_REG_ECX,
                "cdx": UC_X86_REG_EDX,
                "cbp": UC_X86_REG_EBP,
                "csp": UC_X86_REG_ESP,
                "csi": UC_X86_REG_ESI,
                "cdi": UC_X86_REG_EDI,
                "cip": UC_X86_REG_EIP,
            })
        self._flagposdict = {
            "cf": 0,
            "pf": 1,
            "af": 3,
            "zf": 5,
            "sf": 6,
            "tf": 7,
            "if": 8,
            "df": 9,
            "of": 10,
            "iopl": 12,
            "nt": 13,
            "rf": 15,
            "vm": 16,
            "ac": 17,
            "vif": 18,
            "vip": 19,
            "id": 20
        }

    def _resolve_reg(self, regname):
        uc_reg = self._regmap.get(regname, None)
        if uc_reg is None:
            raise KeyError(f"Unknown register '{regname}'")
        #if not self._x64 and regname.startswith("r"):
        #    raise Exception(f"Register {regname} is not available in 32-bit mode")
        return uc_reg

    def __getattr__(self, name: str):
        if name in self._flagposdict:
            eflags = self._uc.reg_read(self._resolve_reg("eflags"))
            return (eflags >> self._flagposdict[name]) & 1
        return self._uc.reg_read(self._resolve_reg(name))

    def __setattr__(self, name: str, value):
        if name.startswith("_"):
            object.__setattr__(self, name, value)
        elif name in self._flagposdict: # For setting specific flags
            resolved_reg = self._resolve_reg("eflags")
            holder = self._uc.reg_read(resolved_reg)
            if value == 0:
                repl_value = holder & ~(1 << self._flagposdict[name])
                self._uc.reg_write(resolved_reg, repl_value)
            elif value == 1:
                repl_value = holder | (1 << self._flagposdict[name])
                self._uc.reg_write(resolved_reg, repl_value)
            else:
                raise Exception(f"Attempted to improperly set flag '{name}'")
        else:
            self._uc.reg_write(self._resolve_reg(name), value)

    # value = dp.regs[myname]
    def __getitem__(self, name: str):
        return self.__getattr__(name)

    # dp.regs[myname] = value
    def __setitem__(self, name: str, value):
        return self.__setattr__(name, value)

    def __contains__(self, name: str):
        try:
            self._resolve_reg(name)
            return True
        except Exception:
            return False

    @property
    def volatile(self):
        if self._x64:
            return ["rax", "rcx", "rdx", "r8", "r9", "r10", "r11"]
        else:
            return ["eax", "ecx", "edx"]

    @property
    def nonvolatile(self):
        if self._x64:
            return ["rbx", "rbp", "rsp", "rsi", "rdi",
                    "r12", "r13", "r14", "r15"]
        else:
            return ["ebx", "ebp", "esp", "esi", "edi"]

    @property
    def gp(self):
        if self._x64:
            return ["rax", "rbx", "rcx", "rdx", "rbp", "rsp", "rsi", "rdi",
                    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"]
        else:
            return ["eax", "ebx", "ecx", "edx", "ebp", "esp", "esi", "edi"]

    @property
    def integer(self):
        if self._x64:
            return ["rax", "rbx", "rcx", "rdx", "rbp", "rsi", "rdi",
                    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"]
        else:
            return ["eax", "ebx", "ecx", "edx", "ebp", "esi", "edi"]

    @property
    def control(self):
        if self._x64:
            return ["rip", "rsp", "rflags"]
        else:
            return ["eip", "esp", "eflags"]

    @property
    def debug(self):
        return ["dr0", "dr1", "dr2", "dr6", "dr7"]

    @property
    def fpu(self):
        if self._x64:
            return [f"ymm{i}" for i in range(16)]
        else:
            return [f"ymm{i}" for i in range(8)]

    def save(self, regs: Optional[Iterable[str]] = None):
        if regs is None:
            if self._x64:
                regs = self.gp + ["rip", "rflags"]
            else:
                regs = self.gp + ["eip", "eflags"]
        return { reg: self[reg] for reg in regs}

    def load(self, regs: Dict[str, int]):
        for reg, value in regs.items():
            self[reg] = value


class Arguments:
    def __init__(self, uc: Uc, memory: PageManager, regs: Registers, x64):
        self._uc = uc
        self._memory = memory
        self._regs = regs
        self._x64 = x64

    def __getitem__(self, index):
        regs = self._regs

        if not self._x64:
            arg_addr = regs.esp + (index + 1) * 4
            data = self._memory.read(arg_addr, 4)
            return struct.unpack("<I", data)[0]

        if index == 0:
            return regs.rcx
        elif index == 1:
            return regs.rdx
        elif index == 2:
            return regs.r8
        elif index == 3:
            return regs.r9
        elif index < 20:
            arg_addr = regs.rsp + (index + 1) * 8
            data = self._memory.read(arg_addr, 8)
            return struct.unpack("<Q", data)[0]
        else:
            raise Exception("not implemented!")

    def __setitem__(self, index, value):
        if not self._x64:
            raise Exception("not implemented!")
        regs = self._regs
        if index == 0:
            regs.rcx = value
        elif index == 1:
            regs.rdx = value
        elif index == 2:
            regs.r8 = value
        elif index == 3:
            regs.r9 = value
        else:
            raise Exception("not implemented!")

"""
These values are copied from a live Windows 10 VM.

References:
- https://wiki.osdev.org/Global_Descriptor_Table
- daax and lauree for helping me understand this stuff

Selector 0x10 (index 2)
UInt64: 0x00209b0000000000 => kernel CS
  Base: 0x0000000000000000
 Limit: 0x0000000000000000
  Type: 11 <- code execute+read+access
     S: 1
   DPL: 0 <- ring0
     P: 1
     L: 1 <- 64-bit
    DB: 0

Selector 0x18 (index 3) => kernel SS
UInt64: 0x0040930000000000
  Base: 0x0000000000000000
 Limit: 0x0000000000000000
  Type: 3 <- data read+write+access
     S: 1
   DPL: 0 <- ring0
     P: 1
     L: 0
    DB: 1 <- 32-bit

Selector 0x20 (index 4) => user wow64 CS
UInt64: 0x00cffb000000ffff
  Base: 0x0000000000000000
 Limit: 0x00000000ffffffff
  Type: 11 <- code execute+read+access
     S: 1
   DPL: 3 <- ring3
     P: 1
     L: 0
    DB: 1 <- 32-bit

Selector 0x28 (index 5) => kernel DS,ES,GS + user SS
UInt64: 0x00cff3000000ffff
  Base: 0x0000000000000000
 Limit: 0x00000000ffffffff
  Type: 3 <- data read+write+access
     S: 1
   DPL: 3 <- ring3
     P: 1
     L: 0
    DB: 1 <- 32-bit

Selector 0x30 (index 6) => user CS
UInt64: 0x0020fb0000000000
  Base: 0x0000000000000000
 Limit: 0x0000000000000000
  Type: 11 <- code execute+read+access
     S: 1
   DPL: 3 <- ring3
     P: 1
     L: 1 <- 64-bit
    DB: 0

Selector 0x40 (index 8) => TSS
UInt64: 0x6d008b9630000067
  Base: 0xfffff8076d963000
 Limit: 0x0000000000000067
  Type: 11 <- 64-bit TSS (Busy)
     S: 0 <- system segment
   DPL: 0 <- ring0
     P: 1
     L: 0
    DB: 0

Selector 0x50 (index 10) => kernel FS
UInt64: 0x0040f30000003c00
  Base: 0x0000000000000000
 Limit: 0x0000000000003c00
  Type: 3 <- data read+write+access
     S: 1
   DPL: 3 <- ring3
     P: 1
     L: 0
    DB: 1 <- 32-bit
"""
windows_gdt = [
    0x0000000000000000,  # NULL
    0x0000000000000000,
    0x00209b0000000000,  # kernel CS
    0x0040930000000000,  # kernel SS
    0x00cffb000000ffff,  # user wow64 CS
    0x00cff3000000ffff,  # kernel DS,ES,GS + user SS
    0x0020fb0000000000,  # user CS
    0x0000000000000000,
    0x6d008b9630000067,  # TSS (base: 0xfffff8076d963000)
    0x00000000fffff807,
    0x0040f30000003c00,  # kernel FS
]

SegmentRegisters = namedtuple("SegmentRegisters", ["cs", "ss", "ds", "es", "fs", "gs"])

windows_kernel_segment = SegmentRegisters(0x10, 0x18, 0x2B, 0x2B, 0x53, 0x2B)
windows_user_segment = SegmentRegisters(0x33, 0x2B, 0x2B, 0x2B, 0x53, 0x2B)
windows_wow64_segment = SegmentRegisters(0x23, 0x2B, 0x2B, 0x2B, 0x53, 0x2B)

# Reference: https://wiki.osdev.org/Exceptions
interrupt_names = [
    "#DE, Division by Zero",
    "#DB, Debug",
    "Non-maskable Interrupt",
    "#BP, Breakpoint",
    "#OF, Overflow",
    "#BR, Bound Range Exceeded",
    "#UD, Invalid Opcode",
    "#NM, Device Not Available",
    "#DF, Double Fault",
    "Coprocessor Segment Overrun",
    "#TS, Invalid TSS",
    "#NP, Segment Not Present",
    "#SS, Stack-Segment Fault",
    "#GP, General Protection Fault",
    "#PF, Page Fault",
    "Reserved",
    "#MF, x87 Floating-Point Exception",
    "#AC, Alignment Check",
    "#MC, Machine Check",
    "SIMD Floating-Point Exception, #XM/#XF",
    "#VE, Virtualization Exception",
    "#CP, Control Protection Exception",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "#HV, Hypervisor Injection Exception",
    "#VC, VMM Communication Exception",
    "#SX, Security Exception",
    "Reserved"
]
assert len(interrupt_names) == 32

def format_table(table: List[List[str]]):
    result = ""
    header = table[0]
    lengths = [0] * len(header)
    for row in table:
        for index, col in enumerate(row):
            lengths[index] = max(lengths[index], len(col))
    for row in table:
        if len(result) > 0:
            result += "\n"
        line = ""
        for index, col in enumerate(row):
            if index > 0:
                line += " "
            if index + 1 == len(row):
                line += col
            else:
                line += f"{col:>{lengths[index]}}"
        result += line.rstrip()
    return result

```

`src/dumpulator/dumpulator.py`:

```py
import ctypes
import struct
import sys
import traceback
from enum import Enum
from typing import List, Union, NamedTuple, Callable
import inspect
from collections import OrderedDict
from dataclasses import dataclass, field

import minidump.minidumpfile as minidump
from unicorn import *
from unicorn.x86_const import *
from pefile import *

from .handles import *
from .native import *
from .details import *
from .memory import *
from .modules import *
from capstone import *
from capstone.x86 import *

syscall_functions = {}

PAGE_SIZE = 0x1000
USER_CAVE = 0x5000
FORCE_KILL_ADDR = USER_CAVE - 0x20
TSS_BASE = 0xfffff8076d963000
KERNEL_CAVE = TSS_BASE - 0x2000
IRETQ_OFFSET = 0x100
IRETD_OFFSET = IRETQ_OFFSET + 1
GDT_BASE = TSS_BASE - 0x3000

class ExceptionType(Enum):
    NoException = 0
    Memory = 1
    Interrupt = 2
    ContextSwitch = 3
    Terminate = 4

class MemoryViolation(Enum):
    Unknown = 0
    ReadUnmapped = 1
    WriteUnmapped = 2
    ExecuteUnmapped = 3
    ReadProtect = 4
    WriteProtect = 5
    ExecuteProtect = 6
    ReadUnaligned = 7
    WriteUnaligned = 8
    ExecuteUnaligned = 9

@dataclass
class ExceptionInfo:
    type: ExceptionType = ExceptionType.NoException
    # type == ExceptionType.Memory
    memory_violation: MemoryViolation = MemoryViolation.Unknown
    memory_address: int = 0
    memory_size: int = 0
    memory_value: int = 0
    # type == ExceptionType.Interrupt
    interrupt_number: int = 0

    # Internal state
    _handling: bool = False

@dataclass
class UnicornExceptionInfo(ExceptionInfo):
    final: bool = False
    code_hook_h: Optional[int] = None  # represents a `unicorn.uc_hook_h` value (from uc.hook_add)
    context: Optional[unicorn.UcContext] = None
    tb_start: int = 0
    tb_size: int = 0
    tb_icount: int = 0
    step_count: int = 0

    def __str__(self):
        return f"{self.type}, ({hex(self.tb_start)}, {hex(self.tb_size)}, {self.tb_icount})"

@dataclass
class UnicornPageManager(PageManager):
    _uc: Uc

    def commit(self, addr: int, size: int, protect: MemoryProtect) -> None:
        perms = map_unicorn_perms(protect)
        self._uc.mem_map(addr, size, perms)

    def decommit(self, addr: int, size: int) -> None:
        self._uc.mem_unmap(addr, size)

    def protect(self, addr: int, size: int, protect: MemoryProtect) -> None:
        self._uc.mem_protect(addr, size, map_unicorn_perms(protect))

    def read(self, addr: int, size: int) -> bytearray:
        return self._uc.mem_read(addr, size)

    def write(self, addr: int, data: bytes) -> None:
        if not isinstance(data, bytes):
            data = bytes(data)
        self._uc.mem_write(addr, data)

@dataclass
class LazyPage:
    addr: int
    protect: MemoryProtect
    committed: bool
    data: Optional[bytearray] = None

    @property
    def size(self):
        return PAGE_SIZE

@dataclass
class LazyPageManager(PageManager):
    child: PageManager
    total_commit: int = 0
    pages: Dict[int, LazyPage] = field(default_factory=dict)
    lazy: bool = True

    @staticmethod
    def iter_pages(addr: int, size: int):
        for i in range(0, size // PAGE_SIZE):
            page_addr = addr + i * PAGE_SIZE
            yield page_addr

    @staticmethod
    def iter_chunks(addr: int, size: int):
        # TODO: rewrite this to not be so disgusting
        page = addr & ~0xFFF
        index = addr & 0xFFF
        while True:
            if page >= addr + size:
                break
            length = min(PAGE_SIZE, (addr + size) - (page + index))
            yield page, index, length
            page += PAGE_SIZE
            index = 0

    def handle_lazy_page(self, addr: int, size: int) -> bool:
        try:
            result = False
            for page_addr, index, length in self.iter_chunks(addr, size):
                page = self.pages.get(page_addr, None)
                if page is None:
                    continue
                if not page.committed:
                    self.child.commit(page.addr, page.size, page.protect)
                    page.committed = True
                    if page.data is not None:
                        self.child.write(page.addr, page.data)
                        page.data = None
                    result = True
            return result
        except UcError as err:
            print(f"FATAL ERROR {err}: handle_lazy_page({hex(addr)}[{hex(size)}])")
            return False

    def commit(self, addr: int, size: int, protect: MemoryProtect) -> None:
        assert addr & 0xFFF == 0
        assert size & 0xFFF == 0

        if not self.lazy:
            self.child.commit(addr, size, protect)
        for page_addr in self.iter_pages(addr, size):
            assert page_addr not in self.pages
            self.pages[page_addr] = LazyPage(page_addr, protect, not self.lazy)
        self.total_commit += size

    def decommit(self, addr: int, size: int) -> None:
        assert addr & 0xFFF == 0
        assert size & 0xFFF == 0

        pages = []
        for page_addr in self.iter_pages(addr, size):
            assert page_addr in self.pages
            pages.append(self.pages[page_addr])

        if all(page.committed for page in pages):
            self.child.decommit(addr, size)
        else:
            for page in pages:
                if page.committed:
                    self.child.decommit(page.addr, page.size)

        for page_addr in self.iter_pages(addr, size):
            del self.pages[page_addr]

    def protect(self, addr: int, size: int, protect: MemoryProtect) -> None:
        assert addr & 0xFFF == 0
        assert size & 0xFFF == 0

        pages = []
        for page_addr in self.iter_pages(addr, size):
            assert page_addr in self.pages
            pages.append(self.pages[page_addr])

        if all(page.committed for page in pages):
            self.child.protect(addr, size, protect)
        else:
            for page in pages:
                if page.committed:
                    self.child.protect(page.addr, page.size, protect)

        for page in pages:
            page.protect = protect

    def read(self, addr: int, size: int) -> bytearray:
        pages = []
        for page_addr, index, length in self.iter_chunks(addr, size):
            page = self.pages.get(page_addr, None)
            if page is None:
                raise IndexError(f"Could not find page {hex(page_addr)} while reading {hex(addr)}[{hex(size)}]")
            pages.append((page, index, length))

        if all([page.committed for page, _, _ in pages]):
            return self.child.read(addr, size)
        else:
            data = bytearray(size)
            for page, index, length in pages:
                data_index = (page.addr + index) - addr
                if page.committed:
                    data[data_index:data_index + length] = self.child.read(page.addr + index, length)
                else:
                    if page.data is None:
                        page.data = bytearray(page.size)
                    data_chunk = page.data[index:index + length]
                    data[data_index:data_index + length] = data_chunk
            assert len(data) == size
            return data

    def write(self, addr: int, data: bytes) -> None:
        pages = []
        for page_addr, index, length in self.iter_chunks(addr, len(data)):
            page = self.pages.get(page_addr, None)
            if page is None:
                raise IndexError(f"Could not find page {hex(page_addr)} while writing {hex(addr)}[{hex(len(data))}]")
            pages.append((page, index, length))

        if all([page.committed for page, _, _ in pages]):
            self.child.write(addr, data)
        else:
            for page, index, length in pages:
                data_index = (page.addr + index) - addr
                data_chunk = data[data_index:data_index + length]
                assert len(data_chunk) == length
                if page.committed:
                    self.child.write(page.addr + index, data_chunk)
                else:
                    if page.data is None:
                        page.data = bytearray(page.size)
                    page.data[index:index + length] = data_chunk
                    assert len(page.data) == page.size

class SimpleTimer:
    def __init__(self):
        self.time = 0.0
        self.start()

    def start(self):
        import time
        self.time = time.perf_counter()

    def __call__(self, name: str):
        prev = self.time
        self.start()
        diff = self.time - prev
        print(f"{name}: {diff*1000:.0f}ms")

class Dumpulator(Architecture):
    def __init__(self, minidump_file, *, trace=False, quiet=False, thread_id=None, debug_logs=False):
        self._quiet = quiet
        self._debug = debug_logs
        self.sequence_id = 0

        # Load the minidump
        self._minidump = minidump.MinidumpFile.parse(minidump_file)
        if thread_id is None and self._minidump.exception is not None:
            thread_id = self._minidump.exception.exception_records[0].ThreadId
        if thread_id is None:
            thread = self._minidump.threads.threads[0]
        else:
            thread = self._find_thread(thread_id)

        self.thread_id = thread.ThreadId
        self.process_id = self._minidump.misc_info.ProcessId
        self.parent_process_id = (self.process_id // 4 + 69) * 4

        super().__init__(type(thread.ContextObject) is not minidump.WOW64_CONTEXT)
        self.addr_mask = 0xFFFFFFFFFFFFFFFF if self._x64 else 0xFFFFFFFF

        if trace:
            self.trace = open(minidump_file + ".trace", "w")
        else:
            self.trace = None

        self.last_module: Optional[Module] = None

        self._uc = Uc(UC_ARCH_X86, UC_MODE_64)

        # TODO: multiple cs instances per segment
        mode = CS_MODE_64 if self._x64 else CS_MODE_32
        self.cs = Cs(CS_ARCH_X86, mode)
        self.cs.detail = True

        # Workaround for buggy implementation of https://github.com/unicorn-engine/unicorn/pull/1746
        def __ctl_w(ctl, nr):
            return ctl | (nr << 26) | (UC_CTL_IO_WRITE << 30)
        try:
            self._uc.ctl(__ctl_w(12, 1), 1)
        except UcError:
            pass

        self.regs = Registers(self._uc, self._x64)
        self._pages = LazyPageManager(UnicornPageManager(self._uc))
        self.memory = MemoryManager(self._pages)
        self.args = Arguments(self._uc, self._pages, self.regs, self._x64)
        self.modules = ModuleManager(self.memory)
        self._allocate_base = None
        self._allocate_size = 1024 * 1024 * 10  # NOTE: 10 megs
        self._allocate_ptr = None
        self._setup_memory()
        self.debug(f"total commit: {hex(self._pages.total_commit)}, pages: {self._pages.total_commit // PAGE_SIZE}")
        self._setup_modules()
        self.syscalls = []
        self.win32k_syscalls = []
        self._setup_syscalls()
        self._setup_emulator(thread)
        self.handles = HandleManager()
        self._setup_handles()
        self._setup_registry()
        self.stopped = False
        self.kill_exception = None
        self.exit_code = None
        self.exports = self._all_exports()
        self._exception = UnicornExceptionInfo()
        self._last_exception: Optional[UnicornExceptionInfo] = None
        self._exception_hook: Optional[Callable[[ExceptionInfo], Optional[int]]] = None
        if not self._quiet:
            print("Memory map:")
            self.print_memory()

    def print_memory(self):
        regions = self.memory.map()
        regions.pop()  # remove the last free region
        table: List[List[str]] = []
        header = ["Base", "Size", "State", "Protect", "Info"]
        table.append(header)
        for region in regions:
            entry = [""] * len(header)
            entry[0] = hex(region.base)
            entry[1] = hex(region.region_size)
            entry[2] = region.state.name
            if region.state != MemoryState.MEM_FREE:
                protect = region.protect
                if region.state == MemoryState.MEM_RESERVE:
                    protect = region.allocation_protect
                entry[3] = str(protect)
                def pretty_info(info: Any):
                    if isinstance(info, Module):
                        return f"{info.name}[{hex(info.size)}]"
                    else:
                        return str(info)
                entry[4] = ", ".join(map(pretty_info, region.info))
            table.append(entry)
        print(format_table(table))

    def _find_thread(self, thread_id):
        for i in range(0, len(self._minidump.threads.threads)):
            thread = self._minidump.threads.threads[i]
            if thread.ThreadId == thread_id:
                return thread
        raise Exception(f"Thread {hex(thread_id)} ({thread_id}) not found!")

    def debug(self, message: str):
        if self._debug:
            print(message)

    def info(self, message: str):
        if not self._quiet:
            print(message)

    @staticmethod
    def error(message: str):
        print(message)

    def _switch_segment(self, segment: SegmentRegisters, gs_base: Optional[int] = None, fs_base: Optional[int] = None):
        self.regs.cs = segment.cs
        self.regs.ss = segment.ss
        self.regs.ds = segment.ds
        self.regs.es = segment.es
        self.regs.fs = segment.fs
        self.regs.gs = segment.gs

        if gs_base is not None:
            self.regs.gs_base = gs_base
        if fs_base is not None:
            self.regs.fs_base = fs_base

    def _setup_gdt(self):
        # TODO: is the TSS actually necessary?
        self._pages.commit(TSS_BASE, PAGE_SIZE, MemoryProtect.PAGE_READWRITE)
        self._pages.commit(GDT_BASE, PAGE_SIZE, MemoryProtect.PAGE_READWRITE)
        for i in range(0, len(windows_gdt)):
            self.write(GDT_BASE + 8 * i, struct.pack("<Q", windows_gdt[i]))
        self.regs.gdtr = (0, GDT_BASE, 8 * len(windows_gdt) - 1, 0x0)

    def _setup_memory(self):
        info: minidump.MinidumpMemoryInfo
        regions: List[List[minidump.MinidumpMemoryInfo]] = []
        mask = 0xFFFFFFFFFFFFFFFF if self._x64 else 0xFFFFFFFF
        for info in self._minidump.memory_info.infos:
            info.AllocationBase &= mask
            info.BaseAddress &= mask
            if len(regions) == 0 or info.AllocationBase != regions[-1][0].AllocationBase or info.State == minidump.MemoryState.MEM_FREE:
                regions.append([])
            regions[-1].append(info)
        # NOTE: The HYPERVISOR_SHARED_DATA does not respect the allocation granularity
        potential_hv = []
        old_granularity = self.memory._granularity
        self.memory._granularity = PAGE_SIZE
        for i in range(len(regions)):
            region = regions[i]
            reserve_addr = None
            reserve_size = 0
            assert len(region) >= 1
            for j in range(len(region)):
                info = region[j]
                if reserve_addr is None:
                    reserve_addr = info.BaseAddress
                reserve_size += info.RegionSize
            info = region[0]
            if info.State == minidump.MemoryState.MEM_FREE:
                continue
            reserve_protect = MemoryProtect(info.AllocationProtect)
            reserve_type = MemoryType(info.Type.value)
            self.debug(f" reserved: {hex(reserve_addr)}, size: {hex(reserve_size)}, protect: {reserve_protect}, type: {reserve_type}")
            self.memory.reserve(reserve_addr, reserve_size, reserve_protect, reserve_type)
            if reserve_addr & (old_granularity - 1) != 0:
                potential_hv.append(reserve_addr)
            for info in region:
                emu_addr = info.BaseAddress & self.addr_mask
                if info.State == minidump.MemoryState.MEM_COMMIT:
                    protect = reserve_protect if info.Protect is None else MemoryProtect(info.Protect.value)
                    self.debug(f"committed: {hex(emu_addr)}, size: {hex(info.RegionSize)}, protect: {protect}")
                    self.memory.commit(info.BaseAddress, info.RegionSize, protect)
        self.memory._granularity = old_granularity
        memory = self._minidump.get_reader().get_buffered_reader()
        seg: minidump.MinidumpMemorySegment
        for seg in self._minidump.memory_segments_64.memory_segments:
            emu_addr = seg.start_virtual_address & self.addr_mask
            self.debug(f"initialize base: {hex(emu_addr)}, size: {hex(seg.size)}")
            memory.move(seg.start_virtual_address)
            assert memory.current_position == seg.start_virtual_address
            data = memory.read(seg.size)
            self._pages.write(emu_addr, data)
        self._pages.lazy = False

        self.memory.set_region_info(0x7ffe0000, "KUSER_SHARED_DATA")
        if len(potential_hv) == 1:
            self.memory.set_region_info(potential_hv[0], "HYPERVISOR_SHARED_DATA")
        elif len(potential_hv) > 1:
            self.debug(f"Unexpected unaligned addresses: {' '.join([hex(x) for x in potential_hv])}")

    def _setup_pebteb(self, thread):
        self.teb = thread.Teb & 0xFFFFFFFFFFFFF000

        # Handle WoW64 support
        ntdll = self.modules["ntdll.dll"]
        Wow64Transition = ntdll.find_export("Wow64Transition")
        ZwWow64ReadVirtualMemory64 = ntdll.find_export("ZwWow64ReadVirtualMemory64")
        if Wow64Transition:
            # This exists from Windows 10 1607 (Build: 14393)
            patch_addr = self.read_ptr(Wow64Transition.address)
            self.info(f"Patching Wow64Transition: [{hex(Wow64Transition.address)}] -> {hex(patch_addr)}")
            # See: https://opcode0x90.wordpress.com/2007/05/18/kifastsystemcall-hook/
            # sysenter; nop; nop; ret
            self.write(patch_addr, b"\x0F\x34\x90\x90\xC3")
            self.wow64 = True
        elif ZwWow64ReadVirtualMemory64:
            # This function exists since Windows XP
            # TODO: Implement by finding EA ???????? 3300 in wow64cpu.dll instead
            # Reference: https://github.com/x64dbg/ScyllaHide/blob/a727ac39/InjectorCLI/RemoteHook.cpp#L354-L434
            patch_addr = self.read_ptr(self.teb + 0xC0)
            self.error(f"Unsupported WoW64 OS version detected, trampoline: {hex(patch_addr)}")
            # sysenter; nop; nop; jmp [esp]
            self.write(patch_addr, b"\x0F\x34\x90\x90\xFF\x24\x24")
            self.wow64 = True
        else:
            self.wow64 = False

        # Get thread information
        for i in range(0, len(self._minidump.threads.threads)):
            thread = self._minidump.threads.threads[i]
            teb = thread.Teb & 0xFFFFFFFFFFFFF000
            tid = thread.ThreadId
            if self._x64:
                # https://www.vergiliusproject.com/kernels/x64/Windows%2011/21H2%20(RTM)/_NT_TIB
                stack_base = self.read_ptr(teb + 0x8)
                stack_limit = self.read_ptr(teb + 0x10)
                deallocation_stack = self.read_ptr(teb + 0x1478)
            else:
                # https://www.vergiliusproject.com/kernels/x86/Windows%2010/2110%2021H2%20(November%202021%20Update)/_NT_TIB
                stack_base = self.read_ptr(teb + 0x4)
                stack_limit = self.read_ptr(teb + 0x8)
                deallocation_stack = self.read_ptr(teb + 0xe0c)
            # The stack grows from base (the higher address) to limit (the lower address)
            self.memory.set_region_info(stack_base - 1, f"Stack (thread {tid})")

            teb_size = 2 * PAGE_SIZE
            self.memory.set_region_info(teb, f"TEB (thread {tid})", size=teb_size)
            if self.wow64:
                self.memory.set_region_info(teb - teb_size, f"WoW64 TEB (thread {tid})", size=teb_size)

        # https://en.wikipedia.org/wiki/Win32_Thread_Information_Block
        # Handle PEB
        # Retrieve console handle
        if self._x64:
            # https://www.vergiliusproject.com/kernels/x64/Windows%2011/21H2%20(RTM)/_TEB
            self.peb = self.read_ptr(self.teb + 0x60)
            # https://www.vergiliusproject.com/kernels/x64/Windows%2011/21H2%20(RTM)/_PEB
            process_parameters = self.read_ptr(self.peb + 0x20)
            # https://www.vergiliusproject.com/kernels/x64/Windows%2011/21H2%20(RTM)/_RTL_USER_PROCESS_PARAMETERS
            self.console_handle = self.read_ptr(process_parameters + 0x10)
            self.stdin_handle = self.read_ptr(process_parameters + 0x20)
            self.stdout_handle = self.read_ptr(process_parameters + 0x28)
            self.stderr_handle = self.read_ptr(process_parameters + 0x30)
            self.modules.main = self.read_ptr(self.peb + 0x10)
            number_of_heaps = self.read_ulong(self.peb + 0xe8)
            process_heaps_ptr = self.read_ptr(self.peb + 0xf0)
            api_set_map = self.read_ptr(self.peb + 0x68)
            csr_shared_memory = self.read_ptr(self.peb + 0x88)
            codepage_data = self.read_ptr(self.peb + 0xa0)
            gdi_handle_table = self.read_ptr(self.peb + 0xf8)
            shim_data = self.read_ptr(self.peb + 0x2d8)
            activation_context_data = self.read_ptr(self.peb + 0x2f8)
            default_activation_context_data = self.read_ptr(self.peb + 0x308)
            leap_second_data = self.read_ptr(self.peb + 0x7b8)
        else:
            # https://www.vergiliusproject.com/kernels/x86/Windows%2010/2110%2021H2%20(November%202021%20Update)/_TEB
            self.peb = self.read_ptr(self.teb + 0x30)
            # https://www.vergiliusproject.com/kernels/x86/Windows%2010/2110%2021H2%20(November%202021%20Update)/_PEB
            process_parameters = self.read_ptr(self.peb + 0x10)
            # https://www.vergiliusproject.com/kernels/x86/Windows%2010/2110%2021H2%20(November%202021%20Update)/_RTL_USER_PROCESS_PARAMETERS
            self.console_handle = self.read_ptr(process_parameters + 0x10)
            self.stdin_handle = self.read_ptr(process_parameters + 0x18)
            self.stdout_handle = self.read_ptr(process_parameters + 0x1c)
            self.stderr_handle = self.read_ptr(process_parameters + 0x20)
            self.modules.main = self.read_ptr(self.peb + 0x8)
            number_of_heaps = self.read_ulong(self.peb + 0x88)
            process_heaps_ptr = self.read_ptr(self.peb + 0x90)
            api_set_map = self.read_ptr(self.peb + 0x38)
            csr_shared_memory = self.read_ptr(self.peb + 0x4c)
            codepage_data = self.read_ptr(self.peb + 0x58)
            gdi_handle_table = self.read_ptr(self.peb + 0x94)
            shim_data = self.read_ptr(self.peb + 0x1e8)
            activation_context_data = self.read_ptr(self.peb + 0x1f8)
            default_activation_context_data = self.read_ptr(self.peb + 0x200)
            leap_second_data = self.read_ptr(self.peb + 0x470)

        self.memory.set_region_info(self.peb, "PEB", size=PAGE_SIZE)
        if self.wow64:
            self.memory.set_region_info(self.peb - PAGE_SIZE, "WoW64 PEB", size=PAGE_SIZE)

        self.info(f"TEB: {hex(self.teb)}, PEB: {hex(self.peb)}")
        self.info(f"  ConsoleHandle: {hex(self.console_handle)}")
        self.info(f"  StandardInput: {hex(self.stdin_handle)}")
        self.info(f"  StandardOutput: {hex(self.stdout_handle)}")
        self.info(f"  StandardError: {hex(self.stderr_handle)}")

        process_heaps = []
        for i in range(0, min(number_of_heaps, 0x1000)):
            heap_ptr = self.read_ptr(process_heaps_ptr + self.ptr_size() * i)
            process_heaps.append(heap_ptr)
            self.memory.set_region_info(heap_ptr, f"Heap (ID {i})")

        self.memory.set_region_info(api_set_map, "ApiSetMap")
        self.memory.set_region_info(csr_shared_memory, "CSR shared memory")
        self.memory.set_region_info(codepage_data, "CodePage data")
        self.memory.set_region_info(gdi_handle_table, "GDI shared handle table")
        self.memory.set_region_info(shim_data, "Shim data")
        self.memory.set_region_info(activation_context_data, "Activation context data")
        self.memory.set_region_info(default_activation_context_data, "Default activation context data")
        self.memory.set_region_info(leap_second_data, "Leap second data")

    def _setup_registry(self):
        self.handles.create_key(r"\Registry\Machine\System\CurrentControlSet\Control\Nls\Sorting\Versions", {
            "": "00060305",
            "000601xx": "SortWindows61.dll",
            "000602xx": "SortWindows62.dll",
            "000603xx": "kernel32.dll",
            "FF0000xx": "SortServer2003Compat.dll",
            "FF0406xx": "SortWindows6Compat.dll",
            "FF0502xx": "SortWindows6Compat.dll",
            "000604xx": "SortWindows64.dll",
        })

    def _setup_handles(self):
        import dumpulator.ntdevices as ntdevices
        self.console = ntdevices.ConsoleDeviceObject(R"\Device\ConDrv")
        self.stdin = ConsoleFileObject(ConsoleType.In)
        self.stdout = ConsoleFileObject(ConsoleType.Out)
        self.stderr = ConsoleFileObject(ConsoleType.Err)

        if self.console_handle != 0:
            self.handles.add(self.console_handle, self.console)
        if self.stdin_handle != 0:
            self.handles.add(self.stdin_handle, self.stdin)
        if self.stdout_handle != 0:
            self.handles.add(self.stdout_handle, self.stdout)
        if self.stderr_handle != 0:
            self.handles.add(self.stderr_handle, self.stderr)

        # TODO: attempt to extract handles from the dump stream and add them as UnknownObject
        if self._minidump.handles is not None:
            by_type: Dict[str, List[minidump.MinidumpHandleDescriptor]] = {}
            minidump_handle: minidump.MinidumpHandleDescriptor
            for minidump_handle in self._minidump.handles.handles:
                type_name = minidump_handle.TypeName
                if type_name is None:
                    type_name = "Unknown"
                if type_name not in by_type:
                    by_type[type_name] = []
                by_type[type_name].append(minidump_handle)
            def default_fn(o):
                if isinstance(o, bytes):
                    return o.hex()
                else:
                    return o.__dict__
            for type_name, handles in by_type.items():
                for minidump_handle in handles:
                    handle_value = minidump_handle.Handle
                    handle_data = self.handles.get(handle_value, None)
                    if handle_data is not None:
                        self.debug(f"handle already added: {hex(handle_value)} = {self.handles.get(handle_value, None)}")
                        continue

                    obj: AbstractObject
                    if type_name == "Unknown":
                        obj = UnknownObject()
                    elif type_name == "File":
                        path = minidump_handle.ObjectName
                        if path is None:
                            path = "???"
                        obj = AbstractFileObject(path)
                    elif type_name == "Event":
                        # TODO: parse the ObjectInfos when available
                        event_type = EVENT_TYPE.SynchronizationEvent
                        event_signalled = False
                        obj = EventObject(event_type, event_signalled)
                    elif type_name == "Key":
                        key = minidump_handle.ObjectName
                        if key is None:
                            key = "???"
                        obj = RegistryKeyObject(key)
                    else:
                        obj = UnsupportedObject(type_name)
                    self.handles.add(handle_value, obj)

    def _setup_emulator(self, thread):
        self._setup_pebteb(thread)
        # TODO: map these using self.memory instead
        # map in codecaves (TODO: can be mapped as UC_PROT_NONE unless used)
        self._pages.commit(USER_CAVE, PAGE_SIZE, MemoryProtect.PAGE_EXECUTE_WRITECOPY)
        self._pages.write(USER_CAVE, b"\xCC" * PAGE_SIZE)
        self._pages.commit(KERNEL_CAVE, PAGE_SIZE, MemoryProtect.PAGE_EXECUTE_WRITECOPY)
        kernel_code = bytearray(b"\xCC" * (PAGE_SIZE // 2) + b"\x00" * (PAGE_SIZE // 2))
        kernel_code[IRETQ_OFFSET] = 0x48
        kernel_code[IRETD_OFFSET] = 0xCF
        self._pages.write(KERNEL_CAVE, bytes(kernel_code))

        # Set up context
        self._setup_gdt()
        if self._x64:
            self.regs.cs = windows_user_segment.cs
            self.regs.ss = windows_user_segment.ss
            self.regs.ds = windows_user_segment.ds
            self.regs.es = windows_user_segment.es
            self.regs.fs = windows_user_segment.fs
            self.regs.gs = windows_user_segment.gs
            self.regs.gs_base = self.teb

            context: minidump.CONTEXT = thread.ContextObject
            self.regs.mxcsr = context.MxCsr
            self.regs.eflags = context.EFlags & ~0x100
            self.regs.dr0 = context.Dr0
            self.regs.dr1 = context.Dr1
            self.regs.dr2 = context.Dr2
            self.regs.dr3 = context.Dr3
            self.regs.dr6 = context.Dr6
            self.regs.dr7 = context.Dr7
            self.regs.rax = context.Rax
            self.regs.rcx = context.Rcx
            self.regs.rdx = context.Rdx
            self.regs.rbx = context.Rbx
            self.regs.rsp = context.Rsp
            self.regs.rbp = context.Rbp
            self.regs.rsi = context.Rsi
            self.regs.rdi = context.Rdi
            self.regs.r8 = context.R8
            self.regs.r9 = context.R9
            self.regs.r10 = context.R10
            self.regs.r11 = context.R11
            self.regs.r12 = context.R12
            self.regs.r13 = context.R13
            self.regs.r14 = context.R14
            self.regs.r15 = context.R15
            self.regs.rip = context.Rip
        else:
            # Switch segment by execution iretq in long mode
            def push64(value):
                rsp = self.regs.rsp - 8
                self.write(rsp, struct.pack("<Q", value))
                self.regs.rsp = rsp

            self.regs.cs = windows_kernel_segment.cs
            self.regs.ss = windows_kernel_segment.ss
            self.regs.rsp = KERNEL_CAVE + (PAGE_SIZE - 0x100)
            push64(windows_wow64_segment.ss)  # SS
            push64(self.regs.esp)  # RSP
            push64(self.regs.eflags)  # EFlags
            push64(windows_wow64_segment.cs)  # CS
            push64(USER_CAVE)  # RIP
            self._uc.emu_start(begin=KERNEL_CAVE + IRETQ_OFFSET, until=USER_CAVE)
            assert self.regs.cs == windows_wow64_segment.cs
            assert self.regs.ss == windows_wow64_segment.ss
            self.regs.ds = windows_wow64_segment.ds
            self.regs.es = windows_wow64_segment.es
            self.regs.fs = windows_wow64_segment.fs
            self.regs.gs = windows_wow64_segment.gs
            self.regs.fs_base = self.teb
            self.regs.gs_base = self.teb - 2 * PAGE_SIZE

            context: minidump.WOW64_CONTEXT = thread.ContextObject
            self.regs.eflags = context.EFlags & ~0x100
            self.regs.dr0 = context.Dr0
            self.regs.dr1 = context.Dr1
            self.regs.dr2 = context.Dr2
            self.regs.dr3 = context.Dr3
            self.regs.dr6 = context.Dr6
            self.regs.dr7 = context.Dr7
            self.regs.eax = context.Eax
            self.regs.ecx = context.Ecx
            self.regs.edx = context.Edx
            self.regs.ebx = context.Ebx
            self.regs.esp = context.Esp
            self.regs.ebp = context.Ebp
            self.regs.esi = context.Esi
            self.regs.edi = context.Edi
            self.regs.eip = context.Eip

        assert self.regs.cs == context.SegCs
        assert self.regs.ss == context.SegSs
        assert self.regs.ds == context.SegDs
        assert self.regs.es == context.SegEs
        assert self.regs.fs == context.SegFs
        assert self.regs.gs == context.SegGs

        # set up hooks
        self._uc.hook_add(UC_HOOK_INSN, _hook_syscall, user_data=self, arg1=UC_X86_INS_SYSCALL)
        self._uc.hook_add(UC_HOOK_INSN, _hook_syscall, user_data=self, arg1=UC_X86_INS_SYSENTER)
        self._uc.hook_add(UC_HOOK_MEM_INVALID, _hook_mem, user_data=self)
        self._uc.hook_add(UC_HOOK_INTR, _hook_interrupt, user_data=self)
        self._uc.hook_add(UC_HOOK_INSN_INVALID, _hook_invalid, user_data=self)
        if self.trace:
            self._uc.hook_add(UC_HOOK_CODE, _hook_code, user_data=self)

    def _all_exports(self):
        exports: Dict[int, str] = {}
        for module in self.modules:
            for export in module.exports:
                if export.name:
                    name = export.name
                else:
                    name = f"#{export.ordinal}"
                exports[export.address] = f"{module.name}:{name}"
        return exports

    def _parse_module_exports(self, module):
        try:
            module_data = self.read(module.baseaddress, module.size)
        except IndexError:
            self.error(f"Failed to read module data")
            return []
        pe = PE(data=module_data, fast_load=True)
        # Hack to adjust pefile to accept in-memory modules
        for section in pe.sections:
            # Potentially interesting members: Misc_PhysicalAddress, Misc_VirtualSize, SizeOfRawData
            section.PointerToRawData = section.VirtualAddress
            section.PointerToRawData_adj = section.VirtualAddress
        # Parser exports and find the syscall indices
        pe.parse_data_directories(directories=[DIRECTORY_ENTRY["IMAGE_DIRECTORY_ENTRY_EXPORT"]])
        return pe.DIRECTORY_ENTRY_EXPORT.symbols if hasattr(pe, "DIRECTORY_ENTRY_EXPORT") else []

    def _setup_modules(self):
        minidump_module: minidump.MinidumpModule
        for minidump_module in self._minidump.modules.modules:
            base = minidump_module.baseaddress
            size = minidump_module.size
            path = minidump_module.name

            # Read as much data from the module memory as possible
            try:
                mapped_data = self.read(base, size)
            except IndexError:
                # HACK: modules with holes between sections need to be read in chunks
                mapped_data = bytearray(size)
                ptr = base
                while ptr < base + size:
                    region = self.memory.query(ptr)
                    if region.state == MemoryState.MEM_COMMIT:
                        data = self.read(region.base, region.region_size)
                        index = region.base - base
                        mapped_data[index:index + len(data)] = data
                    ptr += region.region_size
                assert len(mapped_data) == size

            try:
                # Load the PE dumped from memory
                pe = PE(data=mapped_data, fast_load=True)
                section_alignment = pe.OPTIONAL_HEADER.SectionAlignment
                for section in pe.sections:
                    # Set the section in the memory region
                    name = section.Name.rstrip(b"\0").decode(encoding="ascii", errors="backslashreplace")
                    mask = section_alignment - 1
                    index = (section.VirtualAddress + mask) & ~mask
                    section_size = self.memory.align_page(section.Misc_VirtualSize)
                    va = base + index
                    for page in range(va, va + section_size, PAGE_SIZE):
                        region = self.memory.find_commit(page)
                        if region is not None:
                            region.info = name
                    # HACK: adjust pefile to accept in-memory modules
                    # Potentially interesting members: Misc_PhysicalAddress, Misc_VirtualSize, SizeOfRawData
                    section.PointerToRawData = section.VirtualAddress
                    section.PointerToRawData_adj = section.VirtualAddress
            except pefile.PEFormatError as e:
                self.error(f"Failed to parse module {hex(base)}[{hex(size)}]: {path}")

            # Do not trust these values from memory
            pe.OPTIONAL_HEADER.ImageBase = base
            pe.OPTIONAL_HEADER.SizeOfImage = size
            self.modules.add(pe, path)

    def _setup_syscalls(self):
        # Load the ntdll module from memory
        ntdll = self.modules["ntdll.dll"]
        self.KiUserExceptionDispatcher = ntdll.find_export("KiUserExceptionDispatcher").address
        self.LdrLoadDll = ntdll.find_export("LdrLoadDll").address

        nt_syscalls = []
        for export in ntdll.exports:
            if export.name and export.name.startswith("Zw"):
                nt_syscalls.append((export.address, export.name))

        def add_syscalls(syscalls, table):
            # The index when sorting by RVA is the syscall index
            syscalls.sort()
            for index, (rva, name) in enumerate(syscalls):
                cb = syscall_functions.get(name, None)
                argcount = 0
                if cb:
                    argspec = inspect.getfullargspec(cb)
                    argcount = len(argspec.args) - 1
                table.append((name, cb, argcount))

        add_syscalls(nt_syscalls, self.syscalls)

        # Get the syscalls for win32u
        win32u = self.modules.find("win32u.dll")
        if win32u is not None:
            win32k_syscalls = []
            for export in win32u.exports:
                if export.name and export.name.startswith("Nt"):
                    win32k_syscalls.append((export.address, export.name))

            add_syscalls(win32k_syscalls, self.win32k_syscalls)


    def push(self, value):
        csp = self.regs.csp - self.ptr_size()
        self.write_ptr(csp, value)
        self.regs.csp = csp

    def pop(self):
        csp = self.regs.csp
        value = self.read_ptr(csp)
        self.regs.csp = csp + self.ptr_size()
        return value

    def ret(self, imm=0):
        return_address = self.pop()
        self.regs.csp -= imm
        return return_address

    def read(self, addr, size):
        if not isinstance(addr, int):
            addr = int(addr)
        return self._pages.read(addr, size)

    def write(self, addr, data):
        if not isinstance(addr, int):
            addr = int(addr)
        self._pages.write(addr, bytes(data))

    def call(self, addr, args: List[int] = None, regs: dict = None, count=0):
        if args is None:
            args = []
        if regs is None:
            regs = {}

        if not isinstance(addr, int):
            addr = int(addr)
        # allow passing custom registers
        for name, value in regs.items():
            self.regs.__setattr__(name, value)

        # set up arguments
        if self._x64:
            for index, value in enumerate(args):
                self.args[index] = value
        else:
            for value in reversed(args):
                self.push(value)
        # push return address
        self.push(USER_CAVE)
        # start emulation
        self.start(addr, end=USER_CAVE, count=count)
        return self.regs.cax

    def allocate(self, size, page_align=False):
        if not self._allocate_ptr:
            self._allocate_base = self.memory.find_free(self._allocate_size)
            assert self._allocate_base is not None, "Failed to find free memory"
            self.memory.reserve(
                start=self._allocate_base,
                size=self._allocate_size,
                protect=MemoryProtect.PAGE_EXECUTE_READWRITE,
                memory_type=MemoryType.MEM_PRIVATE,
                info="allocated region"
            )
            self._allocate_ptr = self._allocate_base

        if page_align:
            self._allocate_ptr = round_to_pages(self._allocate_ptr)
            size = round_to_pages(size)

        if self._allocate_ptr + size > self._allocate_base + self._allocate_size:
            raise Exception("not enough room to allocate!")

        ptr = self._allocate_ptr
        self._allocate_ptr += size
        self.memory.commit(self.memory.align_page(ptr), self.memory.align_page(size))
        return ptr

    def set_exception_hook(self, exception_hook: Optional[Callable[[ExceptionInfo], Optional[int]]]):
        previous_hook = self._exception_hook
        self._exception_hook = exception_hook
        return previous_hook

    def handle_exception(self):
        assert not self._exception._handling
        self._exception._handling = True

        if self._exception_hook is not None:
            hook_result = self._exception_hook(self._exception)
            if self.stopped:
                return None
            if hook_result is not None:
                # Clear the pending exception
                self._last_exception = self._exception
                self._exception = UnicornExceptionInfo()
                return hook_result

        if self._exception.type == ExceptionType.ContextSwitch:
            self.info(f"context switch, cip: {hex(self.regs.cip)}")
            # Clear the pending exception
            self._last_exception = self._exception
            self._exception = UnicornExceptionInfo()
            # NOTE: the context has already been restored using context_restore in the caller
            return self.regs.cip

        self.info(f"handling exception...")

        if self._x64:
            # Stack layout (x64):
            # CONTEXT: 0x4d0 bytes (not all fields are overwritten)
            # CONTEXT_EX: 0x18 bytes (accessed by RtlpSanitizeContext)
            # Alignment: 0x8 bytes (not overwritten by KiUserExceptionDispatcher)
            # EXCEPTION_RECORD: 0x98 bytes
            # Unknown: 0x198 bytes (JustMagic: should be _MACHINE_FRAME?)
            # 0x4f0 bytes sizeof(CONTEXT) + 0x20 unclear
            """ JustMagic:
rsp in KiUserExceptionDispatcher:
      CONTEXT          @ rsp + 0   : 4d0
      CONTEXT_EX       @ rsp + 4d0 : 18
      alignment        @ rsp + 4e8 : 8
      EXCEPTION_RECORD @ rsp + 4f0 : 98
      alignment        @ rsp + 588 : 8
      MACHINE_FRAME    @ rsp + 590 : 28                       | alignas(16) from RSP in exception / xstate
      alignment        @ rsp + 5b8 : 8
      xstate           @ rsp + 5c0 : CONTEXT_EX.Xstate.Length | alignas(64) from RSP in exception
            """
            allocation_size = 0x720
            context_flags = 0x10005F
            record_type = EXCEPTION_RECORD64
            context_type = CONTEXT
        else:
            # Stack layout (x86):
            # EXCEPTION_RECORD*: 0x4 bytes
            # CONTEXT*: 0x4 bytes
            # EXCEPTION_RECORD: 0x50
            # CONTEXT: 0x2cc
            # CONTEXT_EX: 0x18
            # Unknown: 0x17C bytes
            allocation_size = 0x4b8
            context_flags = 0x1007F
            record_type = EXCEPTION_RECORD32
            context_type = WOW64_CONTEXT

        csp = self.regs.csp - allocation_size
        self.write(csp, allocation_size * b"\x69")  # fill stuff with 0x69 for debugging
        self.info(f"old csp: {hex(self.regs.csp)}, new csp: {hex(csp)}")
        context_size = ctypes.sizeof(context_type)
        context = context_type.from_buffer(self.read(csp, context_size))
        context.ContextFlags = context_flags
        context.from_regs(self.regs)
        context_ex = CONTEXT_EX()
        context_ex.All.Offset = -context_size & 0xFFFFFFFF
        context_ex.All.Length = allocation_size if self._x64 else 0x42C  # TODO: why this value?
        context_ex.Legacy.Offset = -context_size & 0xFFFFFFFF
        context_ex.Legacy.Length = context_size
        context_ex.XState.Offset = 0xF0 if self._x64 else 0x20
        context_ex.XState.Length = 0x160 if self._x64 else 0x140
        record = record_type()
        alignment_violations = [MemoryViolation.ReadUnaligned, MemoryViolation.WriteUnaligned, MemoryViolation.ExecuteUnaligned]
        if self._exception.type == ExceptionType.Memory and self._exception.memory_violation not in alignment_violations:
            record.ExceptionCode = STATUS_ACCESS_VIOLATION
            record.ExceptionFlags = 0
            record.ExceptionAddress = self.regs.cip
            record.NumberParameters = 2
            types = {
                MemoryViolation.ReadUnmapped: EXCEPTION_READ_FAULT,
                MemoryViolation.WriteUnmapped: EXCEPTION_WRITE_FAULT,
                MemoryViolation.ExecuteUnmapped: EXCEPTION_READ_FAULT,
                MemoryViolation.ReadProtect: EXCEPTION_READ_FAULT,
                MemoryViolation.WriteProtect: EXCEPTION_WRITE_FAULT,
                MemoryViolation.ExecuteProtect: EXCEPTION_EXECUTE_FAULT,
            }
            record.ExceptionInformation[0] = types[self._exception.memory_violation]
            record.ExceptionInformation[1] = self._exception.memory_address
        elif self._exception.type == ExceptionType.Interrupt and self._exception.interrupt_number == 3:
            if self._x64:
                context.Rip -= 1  # TODO: long int3 and prefixes
                record.ExceptionCode = 0x80000003
                record.ExceptionFlags = 0
                record.ExceptionAddress = context.Rip
                record.NumberParameters = 1
            else:
                context.Eip -= 1  # TODO: long int3 and prefixes
                record.ExceptionCode = 0x80000003
                record.ExceptionFlags = 0
                record.ExceptionAddress = context.Eip
                record.NumberParameters = 1
        else:
            raise NotImplementedError(f"{self._exception}")  # TODO: implement

        # Clear the pending exception
        self._last_exception = self._exception
        self._exception = UnicornExceptionInfo()

        def write_stack(cur_ptr: int, data: bytes):
            self.write(cur_ptr, data)
            return cur_ptr + len(data)

        ptr = csp
        if self._x64:
            ptr = write_stack(ptr, bytes(context))
            ptr = write_stack(ptr, bytes(context_ex))
            ptr += 8  # alignment TODO: check if aligned?
            ptr = write_stack(ptr, bytes(record))
            ptr += 8  # not set
            ptr = write_stack(ptr, struct.pack("<Q", record.ExceptionAddress))
            ptr += 16  # not set
            ptr = write_stack(ptr, struct.pack("<Q", context.Rsp))
            ptr += 16  # not set
            ptr = write_stack(ptr, struct.pack("<QIIQQQQQQ", 0, 4, 8, 0, 0, 0, 0, 0, 0))
        else:
            ptr += 4 * 2
            self.write_ulong(csp, ptr)
            ptr = write_stack(ptr, bytes(record))
            self.write_ulong(csp + 4, ptr)
            ptr = write_stack(ptr, bytes(context))
            ptr = write_stack(ptr, bytes(context_ex))
        self.regs.csp = csp
        return self.KiUserExceptionDispatcher

    def start(self, begin, end=0xffffffffffffffff, count=0) -> None:
        # Clear stop state
        self.stopped = False
        self.kill_exception = None
        self.exit_code = None
        # Clear exceptions before starting
        self._exception = UnicornExceptionInfo()
        emu_begin = begin
        emu_until = end
        emu_count = count
        while not self.stopped:
            try:
                if self._exception.type != ExceptionType.NoException:
                    if self._exception.final:
                        # Restore the context (unicorn might mess with it before stopping)
                        if self._exception.context is not None:
                            self._uc.context_restore(self._exception.context)

                        if self._exception.type == ExceptionType.Terminate:
                            if self.exit_code is not None:
                                self.info(f"exit code: {hex(self.exit_code)}")
                            break

                        try:
                            emu_begin = self.handle_exception()
                            if self.stopped:
                                break
                        except Exception:
                            traceback.print_exc()
                            self.error(f"exception during exception handling (stack overflow?)")
                            break
                        emu_until = end
                        emu_count = 0
                    else:
                        # If this happens there was an error restarting simulation
                        assert self._exception.step_count == 0

                        # Hook should be installed at this point
                        assert self._exception.code_hook_h is not None

                        # Restore the context (unicorn might mess with it before stopping)
                        assert self._exception.context is not None
                        self._uc.context_restore(self._exception.context)

                        # Restart emulation
                        self.info(f"restarting emulation to handle exception...")
                        emu_begin = self.regs.cip
                        emu_until = 0xffffffffffffffff
                        emu_count = self._exception.tb_icount + 1

                self.info(f"emu_start({hex(emu_begin)}, {hex(emu_until)}, {emu_count})")
                self._uc.emu_start(emu_begin, until=emu_until, count=emu_count)
                self.info(f'emulation finished, cip = {hex(self.regs.cip)}')
                if self.exit_code is not None:
                    self.info(f"exit code: {hex(self.exit_code)}")
                break
            except UcError as err:
                if self.kill_exception is not None and type(self.kill_exception) is not UcError:
                    raise self.kill_exception from None
                if self._exception.type != ExceptionType.NoException:
                    # Handle the exception outside of the except handler
                    continue
                else:
                    self.error(f'error: {err}, cip = {hex(self.regs.cip)}')
                    traceback.print_exc()
                break

    def stop(self, exit_code=None) -> None:
        try:
            self.exit_code = None
            if exit_code is not None:
                self.exit_code = int(exit_code)
        except Exception:
            traceback.print_exc()
            self.error("Invalid type passed to exit_code!")
        self.stopped = True
        self._uc.emu_stop()

    def raise_kill(self, exc=None):
        # HACK: You need to use this to exit from hooks (although it might not always work)
        self.regs.cip = FORCE_KILL_ADDR
        self.stop()
        if exc is None:
            exc = Exception()
        self.kill_exception = exc
        return exc

    def NtCurrentProcess(self):
        return 0xFFFFFFFFFFFFFFFF if self._x64 else 0xFFFFFFFF

    def NtCurrentThread(self):
        return 0xFFFFFFFFFFFFFFFE if self._x64 else 0xFFFFFFFE

    def map_module(self, file_data: bytes, file_path: str = "", requested_base: int = 0, resolve_imports=True):
        if not file_path:
            file_path = "<unnamed>"
        print(f"Mapping module {file_path}")
        pe = PE(name=None, data=bytearray(file_data))
        image_size = pe.OPTIONAL_HEADER.SizeOfImage
        section_alignment = pe.OPTIONAL_HEADER.SectionAlignment
        assert section_alignment == 0x1000, f"Unsupported section alignment {hex(section_alignment)}"
        bits = 64 if pe.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE_PLUS else 32
        assert bits == 8 * self.ptr_size(), f"PE architecture mismatch"

        if requested_base == 0:
            image_base = self.memory.find_free(image_size)
        else:
            image_base = requested_base
        self.memory.reserve(image_base, image_size, MemoryProtect.PAGE_EXECUTE_WRITECOPY, MemoryType.MEM_MAPPED)

        # Fix relocations, saves to pe.__data__ buffer
        pe.relocate_image(image_base)
        # NOTE: workaround for a bug in pefile where it doesn't set the image base if there are no relocations
        pe.OPTIONAL_HEADER.ImageBase = image_base

        # https://vtopan.wordpress.com/2019/04/12/patching-resolving-imports-in-a-pe-file-python-pefile/
        # manually resolve imports
        if resolve_imports and hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
            ordinal_flag = 2 ** (bits - 1)
            for iid in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = iid.dll.decode("utf-8").lower()
                dll = self.modules.find(dll_name)
                assert dll is not None, f"{dll_name} is not loaded"
                self.info(f"resolving imports for {dll_name}")
                ilt_rva = iid.struct.OriginalFirstThunk
                ilt = pe.get_import_table(ilt_rva)
                iat_rva = iid.struct.FirstThunk
                iat = pe.get_import_table(iat_rva)
                assert iat is not None, "iat is empty"
                assert ilt is not None, "ilt is empty"
                for idx in range(len(ilt)):
                    hint_rva = ilt[idx].AddressOfData
                    assert hint_rva is not None, "hint_rva is 0"
                    if hint_rva & ordinal_flag:
                        ordinal = f"#{hint_rva & 0xffff}"
                        export = self.modules.resolve_export(dll.name, ordinal)
                        assert export is not None, f"Ordinal #{ordinal} not in {dll_name}"
                        imp_va = export.address
                        self.info(f"\t#{ordinal} = {hex(imp_va)}")
                    else:
                        hint = pe.get_word_from_data(pe.get_data(hint_rva, 2), 0)
                        func_name = pe.get_string_at_rva(ilt[idx].AddressOfData + 2, MAX_IMPORT_NAME_LENGTH)
                        func_name = func_name.decode("utf-8")
                        export = self.modules.resolve_export(dll.name, func_name)
                        assert export is not None, f"Export {func_name} not in {dll_name}"
                        imp_va = export.address
                        self.info(f"\t{func_name} = {hex(imp_va)}")
                    file_offset = iat[idx].get_field_absolute_offset("AddressOfData")
                    if bits == 64:
                        pe.__data__[file_offset:file_offset + 8] = struct.pack("<Q", imp_va)
                    else:
                        pe.__data__[file_offset:file_offset + 4] = struct.pack("<L", imp_va)

        # HACK: apply the change to the ImageBase to the header bytes
        file_offset = pe.OPTIONAL_HEADER.get_field_absolute_offset("ImageBase")
        if bits == 64:
            pe.__data__[file_offset:file_offset + 8] = struct.pack("<Q", image_base)
        else:
            pe.__data__[file_offset:file_offset + 4] = struct.pack("<L", image_base)
        pe.header = pe.__data__[:len(pe.header)]
        # TODO: map the header properly (figure out how the system assigns the size)
        header_size = pe.sections[0].VirtualAddress_adj
        print(f"Mapping header {hex(image_base)}[{hex(header_size)}]")
        self.memory.commit(image_base, header_size, MemoryProtect.PAGE_READONLY)
        self.write(image_base, bytes(pe.header))

        for section in pe.sections:
            name = section.Name.rstrip(b"\0")
            mask = section_alignment - 1
            rva = (section.VirtualAddress_adj + mask) & ~mask
            va = image_base + rva
            size = self.memory.align_page(section.Misc_VirtualSize)
            flags = section.Characteristics
            data = bytes(section.get_data())
            assert flags & IMAGE_SCN_MEM_SHARED == 0, "Shared sections are not supported"
            assert flags & IMAGE_SCN_MEM_READ != 0, "Non-readable sections are not supported"
            execute = flags & IMAGE_SCN_MEM_EXECUTE
            write = flags & IMAGE_SCN_MEM_WRITE
            protect = MemoryProtect.PAGE_READONLY
            if write:
                protect = MemoryProtect.PAGE_READWRITE
            if execute:
                protect = MemoryProtect(protect.value << 4)
            print(f"Mapping section '{name.decode()}' {hex(rva)}[{hex(rva)}] -> {hex(va)} as {protect}")
            self.memory.commit(va, size, protect)
            self.write(va, data)

        # Add the module to the module manager
        return self.modules.add(pe, file_path)

    def load_dll(self, file_name: str, file_data: bytes):
        self.handles.map_file("\\??\\" + file_name, FileObject(file_name, file_data))
        argument_ptr = self.allocate(PAGE_SIZE)
        utf16 = file_name.encode("utf-16-le")
        if self._x64:
            argument_data = struct.pack("<IIQHHIQ", 0, 0, 0, len(utf16), len(utf16) + 2, 0, argument_ptr + 32)
            argument_data += utf16
            argument_data += b"\0"
            search_path = argument_ptr + len(argument_data)
            argument_data += b"Z:\\"
            image_type = argument_ptr
            image_base_address = image_type + 8
            image_file_name = image_base_address + 8
        else:
            assert False # TODO
        self.write(argument_ptr, argument_data)

        print(f"LdrLoadDll({file_name})")
        status = self.call(self.LdrLoadDll, [1, image_type, image_file_name, image_base_address])
        print(f"status = {hex(status)}")
        return self.read_ptr(image_base_address)

def _hook_code_exception(uc: Uc, address, size, dp: Dumpulator):
    try:
        dp.info(f"exception step: {hex(address)}[{size}]")
        ex = dp._exception
        ex.step_count += 1
        if ex.step_count >= ex.tb_icount:
            raise Exception("Stepped past the basic block without reaching exception")
    except UcError as err:
        dp.error(f"Exception during unicorn hook, please report this as a bug")
        raise err

def _hook_mem(uc: Uc, access, address, size, value, dp: Dumpulator):
    if dp._pages.handle_lazy_page(address, min(size, PAGE_SIZE)):
        dp.debug(f"committed lazy page {hex(address)}[{hex(size)}] (cip: {hex(dp.regs.cip)})")
        return True

    fetch_accesses = [UC_MEM_FETCH, UC_MEM_FETCH_PROT, UC_MEM_FETCH_UNMAPPED]
    if dp.stopped and access == UC_MEM_FETCH_UNMAPPED and FORCE_KILL_ADDR - 0x10 <= address <= FORCE_KILL_ADDR + 0x10:
        dp.error(f"force exit fetch of {hex(address)}[{hex(size)}]")
        return False
    if dp._exception.final and access in fetch_accesses:
        dp.info(f"fetch from {hex(address)}[{size}] already reported")
        return False
    # TODO: figure out why when you start executing at 0 this callback is triggered more than once
    try:
        violation = {
            UC_MEM_READ_UNMAPPED: MemoryViolation.ReadUnmapped,
            UC_MEM_WRITE_UNMAPPED: MemoryViolation.WriteUnmapped,
            UC_MEM_FETCH_UNMAPPED: MemoryViolation.ExecuteUnmapped,
            UC_MEM_READ_PROT: MemoryViolation.ReadProtect,
            UC_MEM_WRITE_PROT: MemoryViolation.WriteProtect,
            UC_MEM_FETCH_PROT: MemoryViolation.ExecuteProtect,
        }.get(access, MemoryViolation.Unknown)
        assert violation != MemoryViolation.Unknown, f"Unexpected memory access {access}"
        # Extract exception information
        exception = UnicornExceptionInfo()
        exception.type = ExceptionType.Memory
        exception.memory_violation = violation
        exception.memory_address = address
        exception.memory_size = size
        exception.memory_value = value
        exception.context = uc.context_save()
        if access not in fetch_accesses:
            tb = uc.ctl_request_cache(dp.regs.cip)
            exception.tb_start = tb.pc
            exception.tb_size = tb.size
            exception.tb_icount = tb.icount

        # Print exception info
        final = dp.trace or dp._exception.code_hook_h is not None
        info = "final" if final else "initial"
        if access == UC_MEM_READ_UNMAPPED:
            dp.error(f"{info} unmapped read from {hex(address)}[{hex(size)}], cip = {hex(dp.regs.cip)}, exception: {exception}")
        elif access == UC_MEM_WRITE_UNMAPPED:
            dp.error(f"{info} unmapped write to {hex(address)}[{hex(size)}] = {hex(value)}, cip = {hex(dp.regs.cip)}")
        elif access == UC_MEM_FETCH_UNMAPPED:
            dp.error(f"{info} unmapped fetch of {hex(address)}[{hex(size)}], cip = {hex(dp.regs.rip)}, cs = {hex(dp.regs.cs)}")
        else:
            names = {
                UC_MEM_READ: "UC_MEM_READ", # Memory is read from
                UC_MEM_WRITE: "UC_MEM_WRITE", # Memory is written to
                UC_MEM_FETCH: "UC_MEM_FETCH", # Memory is fetched
                UC_MEM_READ_UNMAPPED: "UC_MEM_READ_UNMAPPED", # Unmapped memory is read from
                UC_MEM_WRITE_UNMAPPED: "UC_MEM_WRITE_UNMAPPED", # Unmapped memory is written to
                UC_MEM_FETCH_UNMAPPED: "UC_MEM_FETCH_UNMAPPED", # Unmapped memory is fetched
                UC_MEM_WRITE_PROT: "UC_MEM_WRITE_PROT", # Write to write protected, but mapped, memory
                UC_MEM_READ_PROT: "UC_MEM_READ_PROT", # Read from read protected, but mapped, memory
                UC_MEM_FETCH_PROT: "UC_MEM_FETCH_PROT", # Fetch from non-executable, but mapped, memory
                UC_MEM_READ_AFTER: "UC_MEM_READ_AFTER", # Memory is read from (successful access)
            }
            dp.error(f"{info} unsupported access {names.get(access, str(access))} of {hex(address)}[{hex(size)}] = {hex(value)}, cip = {hex(dp.regs.cip)}")

        if final:
            # Make sure this is the same exception we expect
            if not dp.trace:
                assert violation == dp._exception.memory_violation
                assert address == dp._exception.memory_address
                assert size == dp._exception.memory_size
                assert value == dp._exception.memory_value

                # Delete the code hook
                uc.hook_del(dp._exception.code_hook_h)
                dp._exception.code_hook_h = None

            # At this point we know for sure the context is correct so we can report the exception
            dp._exception = exception
            dp._exception.final = True

            # Stop emulation (we resume it on KiUserExceptionDispatcher later)
            dp._uc.emu_stop()
            return False

        # There should not be an exception active
        assert dp._exception.type == ExceptionType.NoException

        # Remove the translation block cache for this block
        # Without doing this single stepping the block won't work
        if exception.tb_start != 0:
            uc.ctl_remove_cache(exception.tb_start, exception.tb_start + exception.tb_size)

        # Install the code hook to single step the basic block again.
        # This will prevent translation block caching and give us the correct cip
        exception.code_hook_h = uc.hook_add(UC_HOOK_CODE, _hook_code_exception, user_data=dp)

        # Store the exception info
        dp._exception = exception

        # Stop emulation (we resume execution later)
        dp._uc.emu_stop()
        return False
    except AssertionError as err:
        traceback.print_exc()
        raise err
    except UcError as err:
        dp.error(f"Exception during unicorn hook, please report this as a bug")
        raise err
    except Exception as err:
        raise err

def _get_regs(instr, include_write=False):
    regs = OrderedDict()
    operands = instr.operands
    if instr.id != X86_INS_NOP:
        for i in range(0, len(operands)):
            op = operands[i]
            if op.type == CS_OP_REG:
                is_write_op = (i == 0 and instr.id in [X86_INS_MOV, X86_INS_MOVZX, X86_INS_LEA])
                if not is_write_op and not include_write:
                    regs[instr.reg_name(op.value.reg)] = None
            elif op.type == CS_OP_MEM:
                if op.value.mem.base not in [0, X86_REG_RIP]:
                    regs[instr.reg_name(op.value.mem.base)] = None
                if op.value.mem.index not in [0, X86_REG_RIP]:
                    regs[instr.reg_name(op.value.mem.index)] = None
        for reg in instr.regs_read:
            regs[instr.reg_name(reg)] = None
        if include_write:
            for reg in instr.regs_write:
                regs[instr.reg_name(reg)] = None
    return regs

def _hook_code(uc: Uc, address, size, dp: Dumpulator):
    try:
        uc.ctl_remove_cache(address, address + 16)
        code = b""
        try:
            code = dp.read(address, min(size, 15))
            instr = next(dp.cs.disasm(code, address, 1))
        except StopIteration:
            instr = None  # Unsupported instruction
        except IndexError:
            instr = None  # Likely invalid memory
        address_name = dp.exports.get(address, "")

        module = ""
        if dp.last_module and address in dp.last_module:
            # same module again
            pass
        else:
            # new module
            dp.last_module = dp.modules.find(address)
            if dp.last_module:
                module = dp.last_module.name

        if address_name:
            address_name = " " + address_name
        elif module:
            address_name = " " + module

        line = f"{hex(address)}{address_name}|"
        if instr is not None:
            line += instr.mnemonic
            if instr.op_str:
                line += " "
                line += instr.op_str
            for reg in _get_regs(instr):
                line += f"|{reg}={hex(dp.regs.__getattr__(reg))}"
            if instr.mnemonic == "call":
                # print return address
                ret_address = address + instr.size
                line += f"|return_address={hex(ret_address)}"
            elif instr.mnemonic in {"syscall", "sysenter"}:
                line += f"|sequence_id=[{dp.sequence_id}]"
        else:
            line += f"??? (code: {code.hex()}, size: {hex(size)})"
        line += "\n"
        dp.trace.write(line)
    except (KeyboardInterrupt, SystemExit) as e:
        dp.stop()
        raise e

def _unicode_string_to_string(dp: Dumpulator, arg: P[UNICODE_STRING]):
    try:
        return arg[0].read_str()
    except IndexError:
        return None

def _object_attributes_to_string(dp: Dumpulator, arg: P[OBJECT_ATTRIBUTES]):
    try:
        return arg[0].ObjectName[0].read_str()
    except IndexError:
        pass
    return None

def _arg_to_string(dp: Dumpulator, arg):
    if isinstance(arg, Enum):
        return arg.name
    elif isinstance(arg, HANDLE):
        str = hex(arg)
        hstr = None
        if arg == dp.NtCurrentProcess():
            hstr = "NtCurrentProcess()"
        elif arg == dp.NtCurrentThread():
            hstr = "NtCurrentThread()"
        elif dp.handles.valid(arg):
            hstr = f"{dp.handles.get(arg, None)}"
        if hstr is not None:
            str += f" /* {hstr} */"
        return str
    elif P.is_ptr(arg):
        str = hex(arg.ptr)
        tstr = None
        if arg.type is OBJECT_ATTRIBUTES:
            tstr = _object_attributes_to_string(dp, arg)
        elif arg.type is UNICODE_STRING:
            tstr = f"\"{_unicode_string_to_string(dp, arg)}\""
        if tstr is not None:
            str += f" /* {tstr} */"
        return str
    elif isinstance(arg, Int):
        return arg.__str__()
    elif isinstance(arg, int):
        return hex(arg)
    raise NotImplemented()

def _arg_type_string(arg):
    if P.is_ptr(arg) and arg.type is not None:
        return arg.type.__name__ + "*"
    return type(arg).__name__

def _hook_interrupt(uc: Uc, number, dp: Dumpulator):
    if dp.trace:
        dp.trace.flush()
    try:
        # Extract exception information
        exception = UnicornExceptionInfo()
        exception.type = ExceptionType.Interrupt
        exception.interrupt_number = number
        exception.context = uc.context_save()
        # TODO: this might crash if cip is not valid memory
        tb = uc.ctl_request_cache(dp.regs.cip)
        exception.tb_start = tb.pc
        exception.tb_size = tb.size
        exception.tb_icount = tb.icount

        # Print exception info
        if number < len(interrupt_names):
            description = interrupt_names[number]
        else:
            description = f"IRQ {number - 32}"
        dp.error(f"interrupt {number} ({description}), cip = {hex(dp.regs.cip)}, cs = {hex(dp.regs.cs)}")

        # There should not be an exception active
        assert dp._exception.type == ExceptionType.NoException

        # At this point we know for sure the context is correct so we can report the exception
        dp._exception = exception
        dp._exception.final = True
    except AssertionError as err:
        traceback.print_exc()
        raise err
    except UcError as err:
        dp.error(f"Exception during unicorn hook, please report this as a bug")
        raise err
    except Exception as err:
        raise err

    # Stop emulation (we resume it on KiUserExceptionDispatcher later)
    raise UcError(UC_ERR_EXCEPTION)

def _hook_syscall(uc: Uc, dp: Dumpulator):
    # Flush the trace for easier debugging
    if dp.trace is not None:
        dp.trace.flush()

    # Extract the table and function number from eax
    service_number = dp.regs.cax & 0xffff
    table_number = (service_number >> 12) & 0xf  # 0: ntoskrnl, 1: win32k
    function_index = service_number & 0xfff
    if table_number == 0:
        table = dp.syscalls
        table_prefix = ""
    elif table_number == 1:
        table = dp.win32k_syscalls
        table_prefix = "win32k "
    else:
        table = []
        table_prefix = f"unknown:{table_number} "

    if function_index < len(table):
        name, syscall_impl, argcount = table[function_index]
        if syscall_impl:
            argspec = inspect.getfullargspec(syscall_impl)
            args = []

            def syscall_arg(index):
                # There is an extra call that adds a return address to the stack
                if dp.wow64:
                    index += 1
                if index == 0 and dp.ptr_size() == 8:
                    return dp.regs.r10
                return dp.args[index]

            dp.info(f"[{dp.sequence_id}] {table_prefix}syscall: {name}( /* index: {hex(service_number)} */")
            for i in range(0, argcount):
                argname = argspec.args[1 + i]
                argtype = argspec.annotations[argname]
                # Extract the type information from the annotation
                # Reference: https://github.com/python/cpython/issues/89543
                # It looks like the python designers did an oopsie, so we're going
                # the fully-undocumented route.
                sal = None
                if "Annotated" in type(argtype).__name__:
                    sal, = argtype.__metadata__
                    argtype = argtype.__origin__

                if sal is None:
                    sal_pretty = ""
                else:
                    sal_pretty = str(sal) + " "

                argvalue = syscall_arg(i)
                if P.is_ptr(argtype):
                    argvalue = argtype(dp, argvalue)
                elif issubclass(argtype, Enum):
                    try:
                        argvalue = argtype(argvalue & 0xFFFFFFFF)
                    except KeyError as x:
                        raise Exception(f"Unknown enum value {argvalue} for {type(argtype)}") from None
                else:
                    argvalue = argtype(argvalue)
                args.append(argvalue)

                comma = ","
                if i + 1 == argcount:
                    comma = ""

                dp.info(f"    {sal_pretty}{_arg_type_string(argvalue)} {argname} = {_arg_to_string(dp, argvalue)}{comma}")
            dp.info(")")
            try:
                status = syscall_impl(dp, *args)
                if isinstance(status, ExceptionInfo):
                    print("context switch, stopping emulation")
                    dp._exception = status
                    raise UcError(UC_ERR_EXCEPTION)
                else:
                    dp.info(f"status = {hex(status)}")
                    dp.regs.cax = status
                    if dp.x64:
                        dp.regs.rcx = dp.regs.cip + 2
                        dp.regs.r11 = dp.regs.eflags
                    else:
                        # HACK: there is a bug in unicorn that doesn't increment EIP
                        dp.regs.eip += 2
            except UcError as err:
                raise err
            except Exception as exc:
                dp.error(f"Exception thrown during syscall implementation, stopping emulation!")
                raise dp.raise_kill(exc) from None
            finally:
                dp.sequence_id += 1
        else:
            raise dp.raise_kill(NotImplementedError(f"{table_prefix}syscall {hex(service_number)} -> {name} not implemented!")) from None
    else:
        raise dp.raise_kill(IndexError(f"{table_prefix}syscall {hex(service_number)} (index: {hex(function_index)}) out of range")) from None

def _emulate_unsupported_instruction(dp: Dumpulator, instr: CsInsn):
    # Get address mask
    if dp.regs.cs == windows_user_segment.cs:
        address_mask = 0xFFFFFFFFFFFFFFFF
    else:
        address_mask = 0xFFFFFFFF

    def op_mem(op: X86Op, *, aligned: bool):
        mem_address = 0
        if op.mem.base == X86_REG_RIP:
            mem_address += instr.address + instr.size
        else:
            base = op.mem.base
            if base != X86_REG_INVALID:
                name = instr.reg_name(base)
                value = dp.regs[name]
                mem_address += value

            index = op.mem.index
            if index != X86_REG_INVALID:
                name = instr.reg_name(index)
                value = dp.regs[name]
                mem_address += value * op.mem.scale

        disp = op.mem.disp # TODO: negative value handling?
        mem_address += disp
        mem_address &= address_mask
        if aligned:
            alignment = op.size
            if mem_address & (alignment - 1) != 0:
                assert False, f"Address {hex(mem_address)} not aligned to {alignment}"
        return mem_address

    def op_read(index: int, *, aligned=False):
        op: X86Op = instr.operands[index]
        if op.type == CS_OP_REG:
            name = instr.reg_name(op.value.reg)
            return dp.regs[name]
        elif op.type == CS_OP_MEM:
            mem_address = op_mem(op, aligned=aligned)
            data = dp.read(mem_address, op.size)
            return int.from_bytes(data, "little")
        elif op.type == CS_OP_IMM:
            # TODO: sign extend?
            return op.value.imm
        else:
            raise NotImplementedError()

    def op_write(index: int, value: int, *, aligned=False):
        op: X86Op = instr.operands[index]
        size = op.size
        if op.type == CS_OP_REG:
            name = instr.reg_name(op.value.reg)
            if size == 4 and address_mask == 0xFFFFFFFFFFFFFFFF:
                # Extend the register
                assert name[0] == "e"
                name = "r" + name[1:]
            dp.regs[name] = value
        elif op.type == CS_OP_MEM:
            mem_address = op_mem(op, aligned=aligned)
            data = value.to_bytes(size, "little")
            # TODO: handle invalid memory access
            dp.write(mem_address, data)
        else:
            raise NotImplementedError()

    def op_bits(index: int):
        return instr.operands[index].size * 8

    def cip_next():
        dp.regs.cip += instr.size

    if instr.id == X86_INS_RDRAND:
        # TODO: PRNG based on dmp hash
        op_write(0, 42)
        cip_next()
    elif instr.id == X86_INS_RDTSCP:
        # TODO: properly implement
        dp.regs.rdx = 0
        dp.regs.rax = 0
        dp.regs.rcx = 0
        cip_next()
    elif instr.id == X86_INS_RDGSBASE:
        op_write(0, dp.regs.gs_base)
        cip_next()
    elif instr.id in [X86_INS_VMOVDQU, X86_INS_VMOVUPS]:
        src = op_read(1)
        op_write(0, src)
        cip_next()
    elif instr.id in [X86_INS_VMOVDQA, X86_INS_MOVNTDQ, X86_INS_VMOVAPS]:
        src = op_read(1, aligned=True)
        op_write(0, src, aligned=True)
        cip_next()
    elif instr.id == X86_INS_VINSERTF128:
        src = op_read(1)
        xmm1 = op_read(2)
        imm8 = op_read(3)
        if imm8 == 0:
            src = (src & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) | xmm1
        elif imm8 == 1:
            src = (src & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff) | (xmm1 << 128)
        op_write(0, src)
        cip_next()
    elif instr.id == X86_INS_VPBROADCASTQ:
        src = op_read(1) & 0xFFFFFFFFFFFFFFFF
        result = 0
        for _ in range(op_bits(0) // 64):
            result <<= 64
            result |= src
        op_write(0, result)
        cip_next()
    else:
        dp.error(f"unsupported: {hex(instr.address)}|{instr.mnemonic} {instr.op_str}")
        # Unsupported instruction
        return False
    dp.debug(f"emulated: {hex(instr.address)}|{instr.bytes.hex()}|{instr.mnemonic} {instr.op_str}")
    # Resume execution
    return True

def _hook_invalid(uc: Uc, dp: Dumpulator):
    address = dp.regs.cip
    if dp.trace:
        dp.trace.flush()
    # HACK: unicorn cannot gracefully exit in all contexts
    if dp.stopped:
        dp.error(f"terminating emulation...")
        return False
    try:
        code = dp.read(address, 15)
        instr = next(dp.cs.disasm(code, address, 1))
        dp.debug(f"invalid hook {hex(address)}|{code.hex()}|{instr.mnemonic} {instr.op_str}")
        # TODO: add a hook
        if _emulate_unsupported_instruction(dp, instr):
            # Resume execution with a context switch
            assert dp._exception.type == ExceptionType.NoException
            exception = UnicornExceptionInfo()
            exception.type = ExceptionType.ContextSwitch
            exception.final = True
            dp._exception = exception
            return False  # NOTE: returning True would stop emulation
    except StopIteration:
        pass  # Unsupported instruction
    except IndexError:
        pass  # Invalid memory access (NOTE: this should not be possible actually)
    except Exception as err:
        print(f"Unexpected exception {type(err)}")
        traceback.print_exc()
    dp.error(f"invalid instruction at {hex(address)}")
    raise NotImplementedError("TODO: throw invalid instruction exception")

```

`src/dumpulator/handles.py`:

```py
from typing import Any, Dict, Optional, Type, TypeVar, List
from pathlib import Path
from dataclasses import dataclass

from .native import *

T = TypeVar('T')

class AbstractObject:
    def pretty(self, *fields: str):
        d = self.__dict__
        name = type(self).__name__
        if len(d) == 0:
            return name
        else:
            values = []
            if fields:
                for key in fields:
                    values.append(f"{key}: {d[key]}")
            else:
                for key in d.keys():
                    if not key.startswith("_"):
                        values.append(f"{key}: {d[key]}")
                dd = d
            return f"{name}({', '.join(values)})"

    def __str__(self):
        return self.pretty()

class UnknownObject(AbstractObject):
    pass

@dataclass
class UnsupportedObject(AbstractObject):
    type_name: str

@dataclass
class AbstractFileObject(AbstractObject):
    path: str

    def read(self, size: Optional[int] = None) -> bytes:
        raise NotImplementedError()

    def write(self, buffer: bytes, size: Optional[int] = None):
        raise NotImplementedError()

@dataclass
class FileObject(AbstractFileObject):
    data: Optional[bytes] = None
    file_offset: int = 0

    def __str__(self):
        return self.pretty("path", "file_offset")

    def read(self, size: Optional[int] = None) -> bytes:
        # TODO: store file access flags to handle access violations

        if self.data is None:
            return b""

        if size is None:
            data = self.data[self.file_offset:]
            self.file_offset += len(data)
        else:
            data = self.data[self.file_offset:self.file_offset+size]
            self.file_offset += len(data)
        return bytes(data)

    def write(self, buffer: bytes, size: Optional[int] = None):
        # TODO: store file creation flags to correctly handle overwrites
        # TODO: store file access flags to handle access violations

        # currently overwrites data given offset and buffer size, does not overwrite with zeros with different
        # creation options
        # incase input size differs from actual buffer size
        if self.data is None:
            if size is not None:
                self.data = buffer[:size]
                self.file_offset += size
            else:
                self.data = buffer
                self.file_offset += len(buffer)
        else:
            if size is not None:
                self.data = self.data[:self.file_offset] + buffer[:size] + self.data[self.file_offset+size:]
                self.file_offset += size
            else:
                self.data = self.data[:self.file_offset] + buffer + self.data[self.file_offset + len(buffer):]
                self.file_offset += len(buffer)

class ConsoleType(Enum):
    In = 0
    Out = 1
    Err = 2

class ConsoleFileObject(AbstractFileObject):
    def __init__(self, console_type: ConsoleType, lines: Optional[List[str]] = None):
        self.type = console_type
        # Reference: https://learn.microsoft.com/en-us/windows/console/setconsolemode
        self.mode = 0x1F7 if console_type == ConsoleType.In else 0x7
        self.lines = [] if lines is None else lines
        self.current_line = 0
        console_files = {
            ConsoleType.In: "CONIN$",
            ConsoleType.Out: "CONOUT$",
            ConsoleType.Err: "CONERR$",
        }
        super().__init__(console_files[console_type])

    def __str__(self):
        return self.pretty("path")

    def read(self, size: Optional[int] = None) -> bytes:
        assert self.type == ConsoleType.In, "cannot read from stdin"
        if len(self.lines) == 0:
            text = input("stdin: ")
        else:
            assert self.current_line < len(self.lines), "no more data"
            text = self.lines[self.current_line]
            self.current_line += 1
        text += "\r\n"
        data = text.encode("utf-8")
        assert len(data) < size
        return data

    def write(self, buffer: bytes, size: Optional[int] = None):
        assert self.type != ConsoleType.In, "cannot write to stdin"
        print(f"std{'out' if self.type == ConsoleType.Out else 'err'}: {buffer}")

@dataclass
class SectionObject(AbstractObject):
    file: FileObject

@dataclass
class ProcessTokenObject(AbstractObject):
    process_handle: int

@dataclass
class DeviceControlData:
    dp: "Dumpulator"
    code: int
    data: bytes
    io_status: Optional[int] = None
    io_information: Optional[int] = None

    # Internal state
    _index: int = 0

    def read(self, size: int):
        assert self._index + size <= len(self.data)
        data = self.data[self._index:self._index + size]
        assert len(data) == size
        self._index += size
        return data

    def skip(self, size: int):
        assert self._index + size <= len(self.data)
        self._index += size

    def read_ptr(self):
        size = self.dp.ptr_size()
        data = self.read(size)
        return struct.unpack("<Q" if size == 8 else "<I", data)[0]

    def read_ulong(self):
        data = self.read(4)
        return struct.unpack("<I", data)[0]

    def read_ulonglong(self):
        data = self.read(8)
        return struct.unpack("<Q", data)[0]

@dataclass
class DeviceObject(AbstractObject):
    path: str

    def io_control(self, dp: "Dumpulator", control: DeviceControlData) -> Optional[bytes]:
        raise NotImplementedError()

@dataclass
class EventObject(AbstractObject):
    event_type: EVENT_TYPE
    signalled: bool

class RegistryKeyObject(AbstractObject):
    def __init__(self, key: str, values: Dict[str, Any] = None):
        if values is None:
            values = {}
        self.key = key
        self.values = values

    def __str__(self):
        return self.pretty("key")

@dataclass
class ThreadObject(AbstractObject):
    entry: int
    argument: int = 0

class HandleManager:
    def __init__(self):
        self._handles = {}
        self._free_handles = []
        self._base_handle = 0x100
        self._handle_id = 0
        self._mapped_files = {}

    def __find_free_handle(self) -> int:
        def helper():
            if not self._free_handles:
                key = self._base_handle + (0x4 * self._handle_id)
                self._handle_id += 1
                return key
            return self._free_handles.pop(0)
        # Make sure the handle isn't manually added by the user
        while True:
            free_handle = helper()
            if free_handle not in self._handles:
                return free_handle

    # create new handle object and returns handle value
    def new(self, handle_data: AbstractObject) -> int:
        handle_value = self.__find_free_handle()
        self._handles[handle_value] = handle_data
        return handle_value

    # used to add predefined known handles
    def add(self, handle_value: int, handle_data: AbstractObject):
        assert handle_value not in self._handles.keys()
        self._handles[handle_value] = handle_data

    # returns any object data held for the handle
    def get(self, handle_value: int, handle_type: Type[T]) -> T:
        handle_data = self._handles.get(handle_value & ~3, None)
        if handle_data is None:
            return None
        if handle_type is not None:
            assert issubclass(handle_type, AbstractObject)
            if not isinstance(handle_data, handle_type):
                raise TypeError(f"Expected {handle_type.__name__} got {type(handle_data).__name__}")
        return handle_data

    # replaces object data for a handle (make sure there are no dangling references)
    def replace(self, handle_value: int, handle_data: AbstractObject):
        handle_value &= ~3
        assert handle_value in self._handles
        self._handles[handle_value] = handle_data

    def valid(self, handle_value: int) -> bool:
        return handle_value in self._handles.keys()

    # decrements ref_count and removes the key from the dict
    def close(self, handle_value: int) -> bool:
        if handle_value in self._handles.keys():
            del self._handles[handle_value]
            # Make sure all handles are unique
            # self.free_handles.append(handle_value)
            return True
        return False

    # copies object ref to a new key (handle) and increments ref_count
    def duplicate(self, handle_value: int) -> int:
        assert handle_value in self._handles.keys()
        handle_object = self._handles[handle_value]
        new_handle_value = self.__find_free_handle()
        self._handles[new_handle_value] = handle_object
        return new_handle_value

    def map_file(self, filename: str, handle_data: Any):
        self._mapped_files[filename.lower()] = handle_data

    def open_file(self, filename: str):
        data = self._mapped_files.get(filename.lower(), None)
        if data is None:
            return None
        return self.new(data)

    def create_file(self, filename: str, options: int) -> bool:
        # TODO: this logic should be in ZwCreateFile
        # if file is already mapped just return true
        if filename.lower() in self._mapped_files:
            return True
        # if file exists open and store contents in FileObject
        elif options == FILE_OPEN or options == FILE_OVERWRITE:
            file = Path(filename)
            if file.exists():
                with file.open("rb") as f:
                    file_data = f.read()
                    self.map_file(filename, FileObject(filename, file_data))
                return True
        # if file does not exist create a new FileObject
        elif options == FILE_CREATE:
            file = Path(filename)
            if not file.exists():
                self.map_file(filename, FileObject(filename))
                return True
        # no matter what create a new FileObject
        elif options == FILE_SUPERSEDE:
            file = Path(filename)
            if not file.exists():
                self.map_file(filename, FileObject(filename))
                return True
        # if file exists open if it doesn't create a new one then store contents in FileObject
        elif options == FILE_OPEN_IF or options == FILE_OVERWRITE_IF:
            file = Path(filename)
            if file.exists():
                with file.open("rb") as f:
                    file_data = f.read()
                    self.map_file(filename, FileObject(filename, file_data))
                    return True
            else:
                self.map_file(filename, FileObject(filename))
                return True
        return False

    def create_key(self, key: str, values: Dict[str, Any] = None):
        if values is None:
            values = {}
        data = RegistryKeyObject(key, values)
        self._mapped_files[key.lower()] = data
        return data

```

`src/dumpulator/memory.py`:

```py
import bisect
from enum import Enum, Flag
from dataclasses import dataclass, field
from typing import Any, List, Dict, Union, Optional

PAGE_SIZE = 0x1000

class MemoryProtect(Flag):
    UNDEFINED = 0x0
    PAGE_EXECUTE = 0x10
    PAGE_EXECUTE_READ = 0x20
    PAGE_EXECUTE_READWRITE = 0x40
    PAGE_EXECUTE_WRITECOPY = 0x80
    PAGE_NOACCESS = 0x1
    PAGE_READONLY = 0x2
    PAGE_READWRITE = 0x4
    PAGE_WRITECOPY = 0x8
    # Only these can be combined
    PAGE_GUARD = 0x100
    PAGE_NOCACHE = 0x200
    PAGE_WRITECOMBINE = 0x400

    def __str__(self):
        result = self.name
        if result is None:
            result = super().__str__().replace(f"{self.__class__.__name__}.", "")
        return result

class MemoryType(Enum):
    UNDEFINED = 0
    MEM_IMAGE = 0x1000000
    MEM_MAPPED = 0x40000
    MEM_PRIVATE = 0x20000

class MemoryState(Enum):
    MEM_COMMIT = 0x1000
    MEM_RESERVE = 0x2000
    MEM_FREE = 0x10000

@dataclass
class MemoryRegion:
    start: int
    size: int
    protect: MemoryProtect = MemoryProtect.PAGE_NOACCESS
    type: MemoryType = MemoryType.MEM_PRIVATE
    info: Optional[Any] = None
    commit_count: int = 0

    def __post_init__(self):
        assert self.start & 0xFFF == 0
        assert self.size & 0xFFF == 0

    @property
    def end(self):
        return self.start + self.size

    def __lt__(self, other: Any):
        if isinstance(other, int):
            return self.start < other
        elif isinstance(other, MemoryRegion):
            return self.start < other.start
        raise TypeError()

    def __contains__(self, other: object) -> bool:
        if isinstance(other, int):
            return other >= self.start and other < self.end
        elif isinstance(other, MemoryRegion):
            if other.size == 0:
                return other.start >= self.start and other.end < self.end
            else:
                return other.start >= self.start and other.end <= self.end
        raise TypeError()

    def overlaps(self, other):
        if isinstance(other, MemoryRegion):
            if self.start <= other.start:
                return other.start < self.end
            else:
                return self.start < other.end
        raise TypeError()

    def __str__(self):
        result = f"{hex(self.start)}[{hex(self.size)}]"
        if self.info is not None:
            result += f" ({self.info})"
        return result

    def __repr__(self) -> str:
        return f"MemoryRegion({hex(self.start)}, {hex(self.size)}, {self.protect}, {self.type}, {repr(self.info)})"

    def pages(self):
        return range(self.start, self.end, PAGE_SIZE)

class PageManager:
    def commit(self, addr: int, size: int, protect: MemoryProtect) -> None:
        raise NotImplementedError()

    def decommit(self, addr: int, size: int) -> None:
        raise NotImplementedError()

    def protect(self, addr: int, size: int, protect: MemoryProtect) -> None:
        raise NotImplementedError()

    def read(self, addr: int, size: int) -> bytearray:
        raise NotImplementedError()

    def write(self, addr: int, data: bytes) -> None:
        raise NotImplementedError()

@dataclass
class MemoryBasicInformation:
    base: int
    allocation_base: int
    allocation_protect: MemoryProtect
    region_size: int = PAGE_SIZE
    state: Optional[MemoryState] = None
    protect: Optional[MemoryProtect] = None
    type: Optional[MemoryType] = None
    info: List[Any] = field(default_factory=list)

    def __str__(self):
        return f"MemoryBasicInformation(base: {hex(self.base)}, allocation_base: {hex(self.allocation_base)}, region_size: {hex(self.region_size)}, state: {self.state}, protect: {self.protect}, type: {self.type})"

@dataclass
class MemoryManager:
    _page_manager: PageManager
    _minimum: int = 0x10000
    _maximum: int = 0x7fffffff0000
    _granularity: int = 0x10000
    _regions: List[MemoryRegion] = field(default_factory=list)
    _committed: Dict[int, MemoryRegion] = field(default_factory=dict)

    def find_region(self, region: Union[MemoryRegion, int]) -> Optional[MemoryRegion]:
        if isinstance(region, int):
            region = MemoryRegion(self.containing_page(region), 0)
        index = bisect.bisect_right(self._regions, region)
        if index == 0:
            return None
        else:
            closest = self._regions[index - 1]
            if region in closest:
                return closest
            else:
                return None

    def find_commit(self, addr: int) -> Optional[MemoryRegion]:
        addr = self.containing_page(addr)
        return self._committed.get(addr, None)

    # Rounds down to the page containing this address
    @staticmethod
    def containing_page(addr: int) -> int:
        mask = PAGE_SIZE - 1
        return addr & ~mask

    # Rounds up to the nearest page size
    @staticmethod
    def align_page(addr: int) -> int:
        mask = PAGE_SIZE - 1
        return (addr + mask) & ~mask

    # Rounds up to the nearest allocation granularity
    def align_allocation(self, addr: int) -> int:
        mask = self._granularity - 1
        return (addr + mask) & ~mask

    def find_free(self, size: int, allocation_align=True) -> Optional[int]:
        assert size > 0 and self.align_page(size) == size
        base = self._minimum
        while base < self._maximum:
            info = self.query(base)
            assert info.base == base
            base += info.region_size
            if info.state == MemoryState.MEM_FREE:
                if allocation_align:
                    aligned_base = self.align_allocation(info.base)
                    diff = aligned_base - info.base
                    info.base = aligned_base
                    info.region_size -= diff
                if info.region_size >= size:
                    return info.base
        return None

    def reserve(self, start: int, size: int, protect: MemoryProtect, memory_type: MemoryType = MemoryType.MEM_PRIVATE, info: Any = None) -> MemoryRegion:
        assert isinstance(protect, MemoryProtect)
        assert isinstance(memory_type, MemoryType)
        assert size > 0 and self.align_page(size) == size
        assert self.align_allocation(start) == start
        region = MemoryRegion(start, size, protect, memory_type, info)
        if region.start < self._minimum or region.end > self._maximum:
            raise KeyError(f"Requested region {region} is out of bounds")

        def check_overlaps(idx):
            if 0 <= idx < len(self._regions):
                value = self._regions[idx]
                if region.overlaps(value):
                    raise KeyError(f"Requested region {region} overlaps with {value}")

        index = bisect.bisect_right(self._regions, region)
        if index == 0:
            check_overlaps(index)
        else:
            check_overlaps(index - 1)
            check_overlaps(index)
        self._regions.insert(index, region)
        return region

    def _decommit_region(self, parent_region: MemoryRegion, decommit_region: MemoryRegion):
        assert decommit_region in parent_region
        release_start = None
        release_count = 0
        for page in decommit_region.pages():
            if page in self._committed:
                release_count += 1
                if release_start is None:
                    release_start = page
            elif release_count > 0:
                self._page_manager.decommit(release_start, release_count * PAGE_SIZE)
                for i in range(release_count):
                    del self._committed[release_start + i * PAGE_SIZE]
                    parent_region.commit_count -= 1
                release_start = None
                release_count = 0

        if release_count > 0:
            self._page_manager.decommit(release_start, release_count * PAGE_SIZE)
            for i in range(release_count):
                del self._committed[release_start + i * PAGE_SIZE]
                parent_region.commit_count -= 1

    def release(self, start: int, size: int = 0) -> None:
        assert self.align_allocation(start) == start
        assert self.align_allocation(size) == size

        parent = self.find_region(start)
        if parent is None:
            raise KeyError(f"Could not find parent for {hex(start)}")

        if size == 0:
            size = parent.size
        if start + size > parent.start + parent.size:
            raise KeyError(f"You can only release part of the parent region")

        decommit = MemoryRegion(start, size)
        self._decommit_region(parent, decommit)
        self._regions.remove(parent)

        before = MemoryRegion(parent.start, decommit.start - parent.start)
        after = MemoryRegion(decommit.end, parent.end - decommit.end)

        if parent.size == decommit.size:
            # Make sure the whole region was freed
            assert parent.commit_count == 0

        if before.size > 0:
            before = self.reserve(before.start, before.size, parent.protect, parent.type, parent.info)
            for page in before.pages():
                if page in self._committed:
                    before.commit_count += 1
        if after.size > 0:
            after = self.reserve(after.start, after.size, parent.protect, parent.type, parent.info)
            for page in after.pages():
                if page in self._committed:
                    after.commit_count += 1

        assert before.commit_count + after.commit_count == parent.commit_count

    def commit(self, start: int, size: int, protect: MemoryProtect = MemoryProtect.UNDEFINED) -> None:
        assert isinstance(protect, MemoryProtect)
        assert size > 0 and self.align_page(size) == size
        assert self.containing_page(start) == start
        region = MemoryRegion(start, size)
        parent_region = self.find_region(region)
        if parent_region is None:
            raise KeyError(f"Could not find parent for {region}")

        if protect == MemoryProtect.UNDEFINED:
            protect = parent_region.protect

        if parent_region.commit_count == 0:
            assert all([page not in self._committed for page in region.pages()])
            self._page_manager.commit(region.start, region.size, protect)
            for page in region.pages():
                self._committed[page] = MemoryRegion(page, PAGE_SIZE, protect, parent_region.type)
                parent_region.commit_count += 1
        else:
            for page in region.pages():
                if page in self._committed:
                    page_region = self._committed[page]
                    if page_region.protect != protect:
                        self._page_manager.protect(page, PAGE_SIZE, protect)
                        page_region.protect = protect
                else:
                    self._page_manager.commit(page, PAGE_SIZE, protect)
                    self._committed[page] = MemoryRegion(page, PAGE_SIZE, protect, parent_region.type)
                    parent_region.commit_count += 1

    def decommit(self, start: int, size: int) -> None:
        assert size > 0 and self.align_page(size) == size
        assert self.containing_page(start) == start
        region = MemoryRegion(start, size)
        parent_region = self.find_region(region)
        if parent_region is None:
            raise KeyError(f"Could not find parent for {region}")

        self._decommit_region(parent_region, region)

    def protect(self, start: int, size: int, protect: MemoryProtect) -> MemoryProtect:
        assert isinstance(protect, MemoryProtect)
        assert size > 0 and self.align_page(size) == size
        assert self.containing_page(start) == start
        region = MemoryRegion(start, size)
        parent_region = self.find_region(region)
        if parent_region is None:
            raise KeyError(f"Could not find parent for {region}")

        # Make sure all pages in the region are committed
        for page in region.pages():
            if not self._committed[page]:
                raise KeyError(f"Could not protect uncommitted page {hex(page)}")

        # Change the protection
        old_protect = self._committed[region.start].protect
        self._page_manager.protect(region.start, region.size, protect)
        for page in region.pages():
            page_region = self._committed[page]
            if page_region.protect != protect:
                page_region.protect = protect

        return old_protect

    def query(self, start: int) -> MemoryBasicInformation:
        start = self.containing_page(start)

        region = MemoryRegion(start, 0)
        parent_region = self.find_region(region)
        if parent_region is None:
            index = bisect.bisect_right(self._regions, region)
            next_start = self._maximum
            if index < len(self._regions):
                next_start = self._regions[index].start
            result = MemoryBasicInformation(start, 0, MemoryProtect.UNDEFINED)
            result.region_size = next_start - start
            assert result.base + result.region_size == next_start
            result.state = MemoryState.MEM_FREE
            result.protect = MemoryProtect.UNDEFINED
            result.type = MemoryType.UNDEFINED
            return result

        # Reference: https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualquery#remarks
        result: MemoryBasicInformation = None
        result_info = {}
        def add_info(memory_region: MemoryRegion):
            if memory_region.info is None:
                return
            if memory_region.info in result_info:
                return
            result_info[memory_region.info] = memory_region.start
        for page in parent_region.pages():
            if page < start:
                continue
            elif result is None:
                result = MemoryBasicInformation(page, parent_region.start, parent_region.protect)
                add_info(parent_region)
                if page in self._committed:
                    result.state = MemoryState.MEM_COMMIT
                    committed_page = self._committed[page]
                    result.protect = committed_page.protect
                    result.type = committed_page.type
                    add_info(committed_page)
                    assert committed_page.type == parent_region.type
                else:
                    result.state = MemoryState.MEM_RESERVE
                    result.protect = MemoryProtect.UNDEFINED
                    result.type = parent_region.type
                    # If no pages are committed in this parent region we can bail early
                    if parent_region.commit_count == 0:
                        result.region_size = parent_region.size
                        break
            else:
                committed_page = self._committed.get(page, None)
                if result.state == MemoryState.MEM_RESERVE:
                    if committed_page is not None:
                        break
                    result.region_size += PAGE_SIZE
                elif result.state == MemoryState.MEM_COMMIT:
                    if committed_page is not None and committed_page.type == result.type and committed_page.protect == result.protect:
                        result.region_size += PAGE_SIZE
                        add_info(committed_page)
                    else:
                        break
                else:
                    assert False  # unreachable
        # Only keep information starting from the current page, or the parent page if none
        if result is not None:
            result.info = []
            for info, start_addr in result_info.items():
                if start_addr >= result.base:
                    result.info.append(info)
            if len(result.info) == 0 and len(result_info) > 0:
                result.info = list(result_info.keys())[:1]

        return result

    def map(self) -> List[MemoryBasicInformation]:
        addr = self._minimum
        regions: List[MemoryBasicInformation] = []
        while addr < self._maximum:
            info = self.query(addr)
            regions.append(info)
            addr += info.region_size
        return regions

    def read(self, addr: int, size: int) -> bytearray:
        return self._page_manager.read(addr, size)

    def write(self, addr: int, data: bytes):
        return self._page_manager.write(addr, data)

    def set_region_info(self, addr: int, info: Any, *, size=0):
        region = self.find_region(addr)
        if region is None:
            return False

        if size > 0:
            for page in region.pages():
                if page < addr:
                    continue
                if page >= addr + size:
                    break
                commit = self._committed.get(page)
                if commit is not None and commit.info is None:
                    commit.info = info
        else:
            if region.info is not None:
                return False
            region.info = info
        return True

    def __repr__(self):
        return f"MemoryManager(regions={len(self._regions)}, committed={len(self._committed)})"

```

`src/dumpulator/modules.py`:

```py
from dataclasses import dataclass, field
from typing import Dict, Optional, Union, List, Tuple

import pefile
from .memory import MemoryManager

# TODO: support forwarding to API sets
@dataclass
class ModuleExport:
    address: int
    ordinal: int
    name: str
    forward: Optional[Tuple[str, str]] = None

@dataclass
class Module:
    pe: pefile.PE
    path: str  # TODO(printup): use pathlib.Path
    name: str = field(init=False)
    exports: List[ModuleExport] = field(default_factory=list)
    _exports_by_address: Dict[int, int] = field(default_factory=dict)
    _exports_by_ordinal: Dict[int, int] = field(default_factory=dict)
    _exports_by_name: Dict[str, int] = field(default_factory=dict)
    base: int = field(init=False)
    size: int = field(init=False)
    entry: int = field(init=False)

    def __post_init__(self):
        self.path = self.path.replace("/", "\\")
        self.name = self.path.split("\\")[-1]
        self._parse_pe()

    def _parse_pe(self):
        self.base = self.pe.OPTIONAL_HEADER.ImageBase
        self.size = self.pe.OPTIONAL_HEADER.SizeOfImage
        self.entry = self.base + self.pe.OPTIONAL_HEADER.AddressOfEntryPoint
        self.pe.parse_data_directories(directories=[pefile.DIRECTORY_ENTRY["IMAGE_DIRECTORY_ENTRY_EXPORT"]])
        pe_exports = self.pe.DIRECTORY_ENTRY_EXPORT.symbols if hasattr(self.pe, "DIRECTORY_ENTRY_EXPORT") else []

        for pe_export in pe_exports:
            if pe_export.name:
                name = pe_export.name.decode("ascii")
            else:
                name = None

            if pe_export.forwarder is not None:
                va = 0
                forward = pe_export.forwarder.decode().split(".")
                forward = (f"{forward[0].lower()}.dll", str(forward[1]))
                export = ModuleExport(va, pe_export.ordinal, name, forward)
            else:
                va = self.base + pe_export.address
                export = ModuleExport(va, pe_export.ordinal, name)

            self._exports_by_address[export.address] = len(self.exports)
            self._exports_by_ordinal[export.ordinal] = len(self.exports)
            if name is not None:
                self._exports_by_name[name] = len(self.exports)
            self.exports.append(export)

    def find_export(self, key: Union[str, int]):
        if isinstance(key, int):
            index = self._exports_by_ordinal.get(key, None)
            if index is None:
                index = self._exports_by_address.get(key, None)
            if index is None:
                return None
            return self.exports[index]
        elif isinstance(key, str):
            index = self._exports_by_name.get(key)
            if index is None:
                return None
            return self.exports[index]
        raise TypeError()

    def __repr__(self):
        return f"Module({hex(self.base)}, {hex(self.size)}, {self.path})"

    def __hash__(self):
        return hash((self.base, self.size, self.path))

    def __contains__(self, addr: int):
        return self.base <= addr < self.base + self.size

@dataclass
class ModuleManager:
    _memory: MemoryManager
    _name_lookup: Dict[str, int] = field(default_factory=dict)
    _modules: Dict[int, Module] = field(default_factory=dict)
    main: int = 0

    def add(self, pe: pefile.PE, path: str):
        module = Module(pe, path)
        self._modules[module.base] = module
        region = self._memory.find_region(module.base)
        assert region.start == module.base
        assert region is not None
        region.info = module
        self._name_lookup[module.name] = module.base
        self._name_lookup[module.name.lower()] = module.base
        self._name_lookup[module.path] = module.base
        return module

    def find(self, key: Union[str, int]) -> Optional[Module]:
        if isinstance(key, int):
            region = self._memory.find_region(key)
            if region is not None and isinstance(region.info, Module):
                return region.info
            return None
        if isinstance(key, str):
            base = self._name_lookup.get(key, None)
            if base is None:
                base = self._name_lookup.get(key.lower(), None)
            if base is None:
                return None
            return self.find(base)
        raise TypeError()

    def resolve_export(self, module_key: Union[str, int], function_key: Union[str, int]):
        module = self.find(module_key)
        assert module is not None, f"Could not find module: {module_key}"
        export = module.find_export(function_key)
        assert export is not None, f"Could not find function: {module_key}:{function_key}"
        if export.forward is not None:
            return self.resolve_export(export.forward[0], export.forward[1])
        return export

    def __getitem__(self, key: Union[str, int]) -> Module:
        module = self.find(key)
        if module is None:
            raise KeyError()
        return module

    def __contains__(self, key: Union[str, int]):
        return self.find(key) is not None

    def __iter__(self):
        for base in self._modules:
            yield self._modules[base]

    def __repr__(self) -> str:
        return f"ModuleManager(main={hex(self.main)}, modules={len(self._modules)})"

```

`src/dumpulator/native.py`:

```py
import ctypes
import traceback

from .ntenums import *
from .ntprimitives import *
from .ntstructs import *

# NTSTATUS
STATUS_SUCCESS = 0
STATUS_NOT_IMPLEMENTED = 0xC0000002
STATUS_ACCESS_VIOLATION = 0xC0000005
STATUS_INVALID_HANDLE = 0xC0000008
STATUS_NO_SUCH_FILE = 0xC000000F
STATUS_ACCESS_DENIED = 0xC0000022
STATUS_PRIVILEGE_NOT_HELD = 0xC0000061
STATUS_SET_CONTEXT_DENIED = 0xC000060A  # Return from NtContinue to int 29
STATUS_INFO_LENGTH_MISMATCH = 0xC0000004
STATUS_INVALID_PARAMETER = 0xC000000D
STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034
STATUS_NOT_FOUND = 0xC0000225
STATUS_MEMORY_NOT_ALLOCATED = 0xC00000A0
STATUS_CONFLICTING_ADDRESSES = 0xC0000018
STATUS_PORT_NOT_SET = 0xC0000353

# Exceptions
DBG_PRINTEXCEPTION_C = 0x40010006

# Memory state
MEM_COMMIT = 0x1000
MEM_FREE = 0x10000
MEM_RESERVE = 0x2000
MEM_DECOMMIT = 0x4000
MEM_RELEASE = 0x8000
MEM_DIFFERENT_IMAGE_BASE_OK = 0x800000

# Memory type
MEM_IMAGE = 0x1000000
MEM_MAPPED = 0x40000
MEM_PRIVATE = 0x20000

# Memory protection
PAGE_EXECUTE = 0x10
PAGE_EXECUTE_READ = 0x20
PAGE_EXECUTE_READWRITE = 0x40
PAGE_EXECUTE_WRITECOPY = 0x80
PAGE_NOACCESS = 0x1
PAGE_READONLY = 0x2
PAGE_READWRITE = 0x4
PAGE_WRITECOPY = 0x8
PAGE_GUARD = 0x100
PAGE_NOCACHE = 0x200
PAGE_WRITECOMBINE = 0x400

# Region flags
REGION_PRIVATE = 1 << 0
REGION_MAPPED_DATA = 1 << 1
REGION_MAPPED_IMAGE = 1 << 2
REGION_MAPPED_PAGEFILE = 1 << 3
REGION_MAPPED_PHYSICAL = 1 << 4
REGION_DIRECT_MAPPED = 1 << 5

# ntioapi.h
# I/O status information values for NtCreateFile/NtOpenFile
FILE_SUPERSEDED = 0x00000000
FILE_OPENED = 0x00000001
FILE_CREATED = 0x00000002
FILE_OVERWRITTEN = 0x00000003
FILE_EXISTS = 0x00000004
FILE_DOES_NOT_EXIST = 0x00000005

# Create disposition
FILE_SUPERSEDE = 0x00000000
FILE_OPEN = 0x00000001
FILE_CREATE = 0x00000002
FILE_OPEN_IF = 0x00000003
FILE_OVERWRITE = 0x00000004
FILE_OVERWRITE_IF = 0x00000005
FILE_MAXIMUM_DISPOSITION = 0x00000005

# Section flags
IMAGE_SCN_MEM_SHARED = 0x10000000
IMAGE_SCN_MEM_EXECUTE = 0x20000000
IMAGE_SCN_MEM_READ = 0x40000000
IMAGE_SCN_MEM_WRITE = 0x80000000

# Registry value types
REG_NONE = 0  # No value type
REG_SZ = 1  # Unicode nul terminated string
REG_EXPAND_SZ = 2  # Unicode nul terminated string (with environment variable references)
REG_BINARY = 3  # Free form binary
REG_DWORD = 4  # 32-bit number
REG_DWORD_LITTLE_ENDIAN = 4  # 32-bit number (same as REG_DWORD)
REG_DWORD_BIG_ENDIAN = 5  # 32-bit number
REG_LINK = 6  # Symbolic Link (unicode)
REG_MULTI_SZ = 7  # Multiple Unicode strings
REG_RESOURCE_LIST = 8  # Resource list in the resource map
REG_FULL_RESOURCE_DESCRIPTOR = 9  # Resource list in the hardware description
REG_RESOURCE_REQUIREMENTS_LIST = 10  # Resource requirements list
REG_QWORD = 11  # 64-bit number
REG_QWORD_LITTLE_ENDIAN = 11  # 64-bit number (same as REG_QWORD)

def round_to_pages(size):
    return (size + 0xFFF) & 0xFFFFFFFFFFFFF000

EXCEPTION_READ_FAULT = 0  # exception caused by a read
EXCEPTION_WRITE_FAULT = 1  # exception caused by a write
EXCEPTION_EXECUTE_FAULT = 8  # exception caused by an instruction fetch

CONTEXT_AMD64 = 0x00100000

CONTEXT_CONTROL = (CONTEXT_AMD64 | 0x1)
CONTEXT_INTEGER = (CONTEXT_AMD64 | 0x2)
CONTEXT_SEGMENTS = (CONTEXT_AMD64 | 0x4)
CONTEXT_FLOATING_POINT = (CONTEXT_AMD64 | 0x8)
CONTEXT_DEBUG_REGISTERS = (CONTEXT_AMD64 | 0x10)

CONTEXT_MMX_REGISTERS = CONTEXT_FLOATING_POINT

CONTEXT_FULL = (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_FLOATING_POINT)

CONTEXT_ALL = (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS |
               CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS)

CONTEXT_EXCEPTION_ACTIVE = 0x8000000
CONTEXT_SERVICE_ACTIVE = 0x10000000
CONTEXT_EXCEPTION_REQUEST = 0x40000000
CONTEXT_EXCEPTION_REPORTING = 0x80000000

INITIAL_MXCSR = 0x1f80  # initial MXCSR value
INITIAL_FPCSR = 0x027f  # initial FPCSR value

class M128A(ctypes.Structure):
    _fields_ = [
        ("Low",     ctypes.c_uint64),
        ("High",    ctypes.c_int64),
    ]

class XSAVE_FORMAT(ctypes.Structure):
    _pack_ = 1
    _fields_ = [
        ("ControlWord", ctypes.c_uint16),
        ("StatusWord", ctypes.c_uint16),
        ("TagWord", ctypes.c_ubyte),
        ("Reserved1", ctypes.c_ubyte),
        ("ErrorOpcode", ctypes.c_uint16),
        ("ErrorOffset", ctypes.c_uint32),
        ("ErrorSelector", ctypes.c_uint16),
        ("Reserved2", ctypes.c_uint16),
        ("DataOffset", ctypes.c_uint32),
        ("DataSelector", ctypes.c_uint16),
        ("Reserved3", ctypes.c_uint16),
        ("MxCsr", ctypes.c_uint32),
        ("MxCsr_Mask", ctypes.c_uint32),
        ("FloatRegisters", M128A * 8),
        ("XmmRegisters", M128A * 16),
        ("Reserved4", ctypes.c_ubyte * 96),
    ]

class XMMSAVE_FORMAT(ctypes.Structure):
    _fields_ = [
        ("Header", M128A * 2),
        ("Legacy", M128A * 8),
        ("Xmm0", M128A),
        ("Xmm1", M128A),
        ("Xmm2", M128A),
        ("Xmm3", M128A),
        ("Xmm4", M128A),
        ("Xmm5", M128A),
        ("Xmm6", M128A),
        ("Xmm7", M128A),
        ("Xmm8", M128A),
        ("Xmm9", M128A),
        ("Xmm10", M128A),
        ("Xmm11", M128A),
        ("Xmm12", M128A),
        ("Xmm13", M128A),
        ("Xmm14", M128A),
        ("Xmm15", M128A),
    ]

class _CONTEXT_FLTSAVE_UNION(ctypes.Union):
    _fields_ = [
        ("Flt", XSAVE_FORMAT),
        ("Xmm", XMMSAVE_FORMAT),
    ]

class CONTEXT(ctypes.Structure):
    _pack_ = 16
    _fields_ = [
        ("P1Home", ctypes.c_uint64),
        ("P2Home", ctypes.c_uint64),
        ("P3Home", ctypes.c_uint64),
        ("P4Home", ctypes.c_uint64),
        ("P5Home", ctypes.c_uint64),
        ("P6Home", ctypes.c_uint64),
        ("ContextFlags", ctypes.c_uint32),
        ("MxCsr", ctypes.c_uint32),
        ("SegCs", ctypes.c_uint16),
        ("SegDs", ctypes.c_uint16),
        ("SegEs", ctypes.c_uint16),
        ("SegFs", ctypes.c_uint16),
        ("SegGs", ctypes.c_uint16),
        ("SegSs", ctypes.c_uint16),
        ("EFlags", ctypes.c_uint32),
        ("Dr0", ctypes.c_uint64),
        ("Dr1", ctypes.c_uint64),
        ("Dr2", ctypes.c_uint64),
        ("Dr3", ctypes.c_uint64),
        ("Dr6", ctypes.c_uint64),
        ("Dr7", ctypes.c_uint64),
        ("Rax", ctypes.c_uint64),
        ("Rcx", ctypes.c_uint64),
        ("Rdx", ctypes.c_uint64),
        ("Rbx", ctypes.c_uint64),
        ("Rsp", ctypes.c_uint64),
        ("Rbp", ctypes.c_uint64),
        ("Rsi", ctypes.c_uint64),
        ("Rdi", ctypes.c_uint64),
        ("R8", ctypes.c_uint64),
        ("R9", ctypes.c_uint64),
        ("R10", ctypes.c_uint64),
        ("R11", ctypes.c_uint64),
        ("R12", ctypes.c_uint64),
        ("R13", ctypes.c_uint64),
        ("R14", ctypes.c_uint64),
        ("R15", ctypes.c_uint64),
        ("Rip", ctypes.c_uint64),
        ("FltSave", _CONTEXT_FLTSAVE_UNION),
        ("VectorRegister", M128A * 26),
        ("VectorControl", ctypes.c_uint64),
        ("DebugControl", ctypes.c_uint64),
        ("LastBranchToRip", ctypes.c_uint64),
        ("LastBranchFromRip", ctypes.c_uint64),
        ("LastExceptionToRip", ctypes.c_uint64),
        ("LastExceptionFromRip", ctypes.c_uint64),
    ]

    _others = ("P1Home", "P2Home", "P3Home", "P4Home", "P5Home", "P6Home",
               "MxCsr", "VectorRegister", "VectorControl")
    _control = ("SegSs", "Rsp", "SegCs", "Rip", "EFlags")
    _integer = ("Rax", "Rcx", "Rdx", "Rbx", "Rsp", "Rbp", "Rsi", "Rdi",
                "R8", "R9", "R10", "R11", "R12", "R13", "R14", "R15")
    _segments = ("SegDs", "SegEs", "SegFs", "SegGs")
    _debug = ("Dr0", "Dr1", "Dr2", "Dr3", "Dr6", "Dr7",
              "DebugControl", "LastBranchToRip", "LastBranchFromRip",
              "LastExceptionToRip", "LastExceptionFromRip")
    _mmx = ("Xmm0", "Xmm1", "Xmm2", "Xmm3", "Xmm4", "Xmm5", "Xmm6", "Xmm7",
            "Xmm8", "Xmm9", "Xmm10", "Xmm11", "Xmm12", "Xmm13", "Xmm14", "Xmm15")

    # Based on: https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/win32/context_amd64.py#L424
    def from_regs(self, regs):
        setattr(self, "MxCsr", regs["mxcsr"])
        # TODO: implement high xmm support
        ContextFlags = self.ContextFlags
        if (ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL:
            for key in CONTEXT._control:
                try:
                    dpname = key.lower()
                    if key.startswith("Seg"):
                        dpname = key[3:].lower()
                    setattr(self, key, regs[dpname])
                except Exception:
                    traceback.print_exc()
        if (ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER:
            for key in CONTEXT._integer:
                try:
                    setattr(self, key, regs[key.lower()])
                except Exception:
                    traceback.print_exc()
        if (ContextFlags & CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS:
            for key in CONTEXT._segments:
                try:
                    dpname = key.lower()
                    if key.startswith("Seg"):
                        dpname = key[3:].lower()
                    setattr(self, key, regs[dpname])
                except Exception:
                    traceback.print_exc()
        if (ContextFlags & CONTEXT_DEBUG_REGISTERS) == CONTEXT_DEBUG_REGISTERS:
            for key in CONTEXT._debug:
                try:
                    value = regs[key.lower()] if key.startswith("Dr") else 0
                    setattr(self, key, value)
                except Exception:
                    traceback.print_exc()
        if (ContextFlags & CONTEXT_MMX_REGISTERS) == CONTEXT_MMX_REGISTERS:
            xmm = self.FltSave.Xmm
            for key in CONTEXT._mmx:
                x = regs[key.lower()]
                y = M128A()
                y.High = x >> 64
                y.Low = x - (x >> 64)
                try:
                    setattr(xmm, key, y)
                except Exception:
                    traceback.print_exc()

    def to_regs(self, regs):
        setattr(self, "MxCsr", regs["mxcsr"])
        # TODO: implement high xmm support
        ContextFlags = self.ContextFlags
        if (ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL:
            for key in CONTEXT._control:
                try:
                    dpname = key.lower()
                    if key.startswith("Seg"):
                        dpname = key[3:].lower()
                    setattr(regs, dpname, getattr(self, key))
                except Exception:
                    traceback.print_exc()
        if (ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER:
            for key in CONTEXT._integer:
                try:
                    setattr(regs, key.lower(), getattr(self, key))
                except Exception:
                    traceback.print_exc()
        if (ContextFlags & CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS:
            for key in CONTEXT._segments:
                try:
                    dpname = key.lower()
                    if key.startswith("Seg"):
                        dpname = key[3:].lower()
                    setattr(regs, dpname, getattr(self, key))
                except Exception:
                    traceback.print_exc()
        if (ContextFlags & CONTEXT_DEBUG_REGISTERS) == CONTEXT_DEBUG_REGISTERS:
            for key in CONTEXT._debug:
                try:
                    if key.startswith("Dr"):
                        setattr(regs, key.lower(), getattr(self, key))
                except Exception:
                    traceback.print_exc()
        if (ContextFlags & CONTEXT_MMX_REGISTERS) == CONTEXT_MMX_REGISTERS:
            # TODO implement
            pass
            """
            xmm = self.FltSave.Xmm
            for key in CONTEXT._mmx:
                x = regs[key.lower()]
                y = M128A()
                y.High = x >> 64
                y.Low = x - (x >> 64)
                try:
                    setattr(xmm, key, y)
                except Exception as x:
                    traceback.print_exc()
                    pass
            """
assert ctypes.sizeof(CONTEXT) == 0x4d0

class EXCEPTION_RECORD64(ctypes.Structure):
    _pack_ = 16
    _fields_ = [
        ("ExceptionCode", ctypes.c_int32),
        ("ExceptionFlags", ctypes.c_uint32),
        ("ExceptionRecord", ctypes.c_uint64),
        ("ExceptionAddress", ctypes.c_uint64),
        ("NumberParameters", ctypes.c_uint32),
        ("ExceptionInformation", ctypes.c_uint64 * 15),
    ]
assert ctypes.sizeof(EXCEPTION_RECORD64) == 0x98

class WOW64_FLOATING_SAVE_AREA(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("ControlWord", ctypes.c_uint32),
        ("StatusWord", ctypes.c_uint32),
        ("TagWord", ctypes.c_uint32),
        ("ErrorOffset", ctypes.c_uint32),
        ("ErrorSelector", ctypes.c_uint32),
        ("DataOffset", ctypes.c_uint32),
        ("DataSelector", ctypes.c_uint32),
        ("RegisterArea", ctypes.c_uint8 * 80),
        ("Cr0NpxState", ctypes.c_uint32),
    ]

class WOW64_CONTEXT(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("ControlWord", ctypes.c_uint32),
        ("Dr0", ctypes.c_uint32),
        ("Dr1", ctypes.c_uint32),
        ("Dr2", ctypes.c_uint32),
        ("Dr3", ctypes.c_uint32),
        ("Dr6", ctypes.c_uint32),
        ("Dr7", ctypes.c_uint32),
        ("FloatSave", WOW64_FLOATING_SAVE_AREA),
        ("SegGs", ctypes.c_uint32),
        ("SegFs", ctypes.c_uint32),
        ("SegEs", ctypes.c_uint32),
        ("SegDs", ctypes.c_uint32),
        ("Edi", ctypes.c_uint32),
        ("Esi", ctypes.c_uint32),
        ("Ebx", ctypes.c_uint32),
        ("Edx", ctypes.c_uint32),
        ("Ecx", ctypes.c_uint32),
        ("Eax", ctypes.c_uint32),
        ("Ebp", ctypes.c_uint32),
        ("Eip", ctypes.c_uint32),
        ("SegCs", ctypes.c_uint32),
        ("EFlags", ctypes.c_uint32),
        ("Esp", ctypes.c_uint32),
        ("SegSs", ctypes.c_uint32),
        ("ExtendedRegisters", ctypes.c_uint8 * 512),
    ]

    def from_regs(self, regs):
        # TODO: implement properly
        self.Dr0 = regs.dr0
        self.Dr1 = regs.dr1
        self.Dr2 = regs.dr2
        self.Dr3 = regs.dr3
        self.Dr6 = regs.dr6
        self.Dr7 = regs.dr7
        self.Edi = regs.edi
        self.Esi = regs.esi
        self.Ebx = regs.ebx
        self.Edx = regs.edx
        self.Ecx = regs.ecx
        self.Eax = regs.eax
        self.Ebp = regs.ebp
        self.Eip = regs.eip
        self.EFlags = regs.eflags
        self.Esp = regs.esp

        self.SegCs = regs.cs
        self.SegSs = regs.ss
        self.SegDs = regs.ds
        self.SegEs = regs.es
        self.SegFs = regs.fs
        self.SegGs = regs.gs

        # TODO: implement xmm

    def to_regs(self, regs):
        regs.dr0 = self.Dr0
        regs.dr1 = self.Dr1
        regs.dr2 = self.Dr2
        regs.dr3 = self.Dr3
        regs.dr6 = self.Dr6
        regs.dr7 = self.Dr7
        regs.edi = self.Edi
        regs.esi = self.Esi
        regs.ebx = self.Ebx
        regs.edx = self.Edx
        regs.ecx = self.Ecx
        regs.eax = self.Eax
        regs.ebp = self.Ebp
        regs.eip = self.Eip
        regs.eflags = self.EFlags
        regs.esp = self.Esp

        # TODO: implement segment switching
        # NOTE: if you update fs/gs the fs_base/gs_base will be set to 0
        assert regs.cs == self.SegCs & 0xFFFF
        assert regs.ss == self.SegSs & 0xFFFF
        assert regs.ds == self.SegDs & 0xFFFF
        assert regs.es == self.SegEs & 0xFFFF
        assert regs.fs == self.SegFs & 0xFFFF
        assert regs.gs == self.SegGs & 0xFFFF

        # TODO: implement xmm
assert ctypes.sizeof(WOW64_CONTEXT) == 0x2cc

class EXCEPTION_RECORD32(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("ExceptionCode", ctypes.c_int32),
        ("ExceptionFlags", ctypes.c_uint32),
        ("ExceptionRecord", ctypes.c_uint32),
        ("ExceptionAddress", ctypes.c_uint32),
        ("NumberParameters", ctypes.c_uint32),
        ("ExceptionInformation", ctypes.c_uint32 * 15),
    ]
assert ctypes.sizeof(EXCEPTION_RECORD32) == 0x50

# Reference: https://windows-internals.com/cet-on-windows/#7--context_ex--structure
class CONTEXT_CHUNK(ctypes.Structure):
    _fields_ = [
        ("Offset", ctypes.c_int32),
        ("Length", ctypes.c_uint32),
    ]

class CONTEXT_EX(ctypes.Structure):
    _fields_ = [
        ("All", CONTEXT_CHUNK),
        ("Legacy", CONTEXT_CHUNK),
        ("XState", CONTEXT_CHUNK),
    ]
assert ctypes.sizeof(CONTEXT_EX) == 0x18

def _RTL_PROCESS_MODULE_INFORMATION(arch: Architecture):
    class _RTL_PROCESS_MODULE_INFORMATION(ctypes.Structure):
        _alignment_ = arch.alignment()
        _fields_ = [
            ("Section", arch.ptr_type()),
            ("MappedBase", arch.ptr_type()),
            ("ImageBase", arch.ptr_type()),
            ("ImageSize", ctypes.c_uint32),
            ("Flags", ctypes.c_uint32),
            ("LoadOrderIndex", ctypes.c_uint16),
            ("InitOrderIndex", ctypes.c_uint16),
            ("LoadCount", ctypes.c_uint16),
            ("OffsetToFileName", ctypes.c_uint16),
            ("FullPathName", ctypes.c_ubyte * 256),
        ]
    return _RTL_PROCESS_MODULE_INFORMATION()

def _RTL_PROCESS_MODULES(arch: Architecture, count: int):
    class _RTL_PROCESS_MODULES(ctypes.Structure):
        _alignment_ = arch.alignment(),
        _fields_ = [
            ("NumberOfModules", ctypes.c_uint32),
            ("Modules", type(_RTL_PROCESS_MODULE_INFORMATION(arch)) * count)
        ]
    modules = _RTL_PROCESS_MODULES()
    modules.NumberOfModules = count
    return modules

class MEMORY_BASIC_INFORMATION32(ctypes.Structure):
    _alignment_ = 8
    _fields_ = [
        ("BaseAddress", ctypes.c_uint32),
        ("AllocationBase", ctypes.c_uint32),
        ("AllocationProtect", ctypes.c_uint32),
        ("RegionSize", ctypes.c_uint32),
        ("State", ctypes.c_uint32),
        ("Protect", ctypes.c_uint32),
        ("Type", ctypes.c_uint32),
    ]

class MEMORY_BASIC_INFORMATION64(ctypes.Structure):
    _alignment_ = 8
    _fields_ = [
        ("BaseAddress", ctypes.c_uint64),
        ("AllocationBase", ctypes.c_uint64),
        ("AllocationProtect", ctypes.c_uint32),
        ("PartitionId", ctypes.c_uint16),
        ("RegionSize", ctypes.c_uint64),
        ("State", ctypes.c_uint32),
        ("Protect", ctypes.c_uint32),
        ("Type", ctypes.c_uint32),
    ]

def MEMORY_BASIC_INFORMATION(arch: Architecture):
    if arch.ptr_size() == 8:
        return MEMORY_BASIC_INFORMATION64()
    else:
        return MEMORY_BASIC_INFORMATION32()

def MEMORY_REGION_INFORMATION(arch: Architecture):
    class MEMORY_REGION_INFORMATION(ctypes.Structure):
        _alignment_ = arch.alignment()
        _fields_ = [
            ("AllocationBase", arch.ptr_type()),
            ("AllocationProtect", ctypes.c_uint32),
            ("Flags", ctypes.c_uint32),
            ("RegionSize", arch.ptr_type()),
            ("CommitSize", arch.ptr_type()),
        ]
    return MEMORY_REGION_INFORMATION()

def FILE_BASIC_INFORMATION(arch: Architecture):
    class FILE_BASIC_INFORMATION(ctypes.Structure):
        _alignment_ = arch.alignment()
        _fields_ = [
            ("CreationTime", ctypes.c_uint64),
            ("LastAccessTime", ctypes.c_uint64),
            ("LastWriteTime", ctypes.c_uint64),
            ("ChangeTime", ctypes.c_uint64),
            ("Flags", ctypes.c_uint32),
        ]
    return FILE_BASIC_INFORMATION()

def SECTION_IMAGE_INFORMATION(arch: Architecture):
    class SECTION_IMAGE_INFORMATION(ctypes.Structure):
        _alignment_ = arch.alignment()
        _fields_ = [
            ("TransferAddress", arch.ptr_type()),
            ("ZeroBits", ctypes.c_uint32),
            ("MaximumStackSize", arch.ptr_type()),
            ("CommittedStackSize", arch.ptr_type()),
            ("SubSystemType", ctypes.c_uint32),
            ("SubSystemMinorVersion", ctypes.c_uint16),
            ("SubSystemMajorVersion", ctypes.c_uint16),
            ("MajorOperatingSystemVersion", ctypes.c_uint16),
            ("MinorOperatingSystemVersion", ctypes.c_uint16),
            ("ImageCharacteristics", ctypes.c_uint16),
            ("DllCharacteristics", ctypes.c_uint16),
            ("Machine", ctypes.c_uint16),
            ("ImageContainsCode", ctypes.c_uint8),
            ("ImageFlags", ctypes.c_uint8),
            ("LoaderFlags", ctypes.c_uint32),
            ("ImageFileSize", ctypes.c_uint32),
            ("CheckSum", ctypes.c_uint32),
        ]
    return SECTION_IMAGE_INFORMATION()

class PROCESS_BASIC_INFORMATION(Struct):
    ExitStatus: ULONG
    PebBaseAddress: PVOID
    AffinityMask: KAFFINITY
    BasePriority: KPRIORITY
    UniqueProcessId: ULONG_PTR
    InheritedFromUniqueProcessId: ULONG_PTR

class KEY_VALUE_FULL_INFORMATION(ctypes.Structure):
    _fields_ = [
        ("TitleIndex", ctypes.c_uint32),
        ("Type", ctypes.c_uint32),
        ("DataOffset", ctypes.c_uint32),
        ("DataLength", ctypes.c_uint32),
        ("NameLength", ctypes.c_uint32),
    ]

```

`src/dumpulator/ntdevices.py`:

```py
import struct
from typing import Optional

from dumpulator import Dumpulator
from dumpulator.handles import DeviceObject, DeviceControlData, ConsoleFileObject

# References:
# - https://github.com/dlunch/NewConsole/blob/245fca3b3e3ed469b231a9d8b6fda3282782bac1/NewConsole/ConsoleHost.cpp#L196-L306
# - https://www.unknowncheats.me/forum/c-and-c-/467307-using-console-via-ioctl.html
class ConsoleDeviceObject(DeviceObject):
    def io_control(self, dp: Dumpulator, control: DeviceControlData) -> Optional[bytes]:
        if control.code == 0x500016:  # ConsoleCallServerGeneric
            print(f"console: ConsoleCallServerGeneric(")
            # TODO: this changed in Windows 10, Windows 8.1/7 uses a different structure
            assert dp.ptr_size() == 8 or dp.wow64  # TODO: support 32-bit

            console_handle = control.read_ulonglong()
            console_file = dp.handles.get(console_handle, ConsoleFileObject)
            assert console_file is not None
            unk1 = control.read_ulong()
            unk2 = control.read_ulong()
            assert unk1 == unk2 and unk1 == 1  # TODO: which is which?
            unk3 = control.read_ulong()
            control.skip(4)  # padding
            data_ptr = control.read_ulonglong()
            result_size = control.read_ulong()
            control.skip(4)  # padding
            result_ptr = control.read_ulonglong()

            # TODO: refactor this into a generic call logger
            print(f"    ConsoleHandle = {hex(console_handle)} /* {console_file} */")
            print(f"    unk1 = {hex(unk1)}")
            print(f"    unk2 = {hex(unk2)}")
            print(f"    unk3 = {hex(unk3)}")
            print(f"    data_ptr = {hex(data_ptr)}")
            print(f"    result_size = {hex(result_size)}")
            print(f"    result_ptr = {hex(result_ptr)}")
            print(")")

            request_data = dp.read(data_ptr, unk1 * 8)
            request_code, request_unk_size = struct.unpack("<II", request_data)

            if request_code == 0x1000000:  # GetConsoleCP
                raise NotImplementedError()
            elif request_code == 0x1000001:  # GetConsoleMode
                assert result_size == 4
                dp.write_ulong(result_ptr, console_file.mode)
                return None
            elif request_code == 0x2000007:  # GetConsoleScreenBufferInfoEx
                raise NotImplementedError()
            elif request_code == 0x1000006:  # WriteConsole
                raise NotImplementedError()
            elif request_code == 0x1000005:  # ReadConsole
                raise NotImplementedError()
            elif request_code == 0x2000014:  # GetConsoleTitle
                raise NotImplementedError()
            elif request_code == 0x1000002:  # SetConsoleMode
                raise NotImplementedError()
            elif request_code == 0x1000008:  # SetTEBLangID
                raise NotImplementedError()
            elif request_code == 0x2000015:  # SetConsoleTitle
                raise NotImplementedError()
            elif request_code == 0x200000a:  # SetConsoleCursorPosition
                raise NotImplementedError()
            elif request_code == 0x200000d:  # SetConsoleTextAttribute
                raise NotImplementedError()
            elif request_code == 0x2000000:  # FillConsoleOutput
                raise NotImplementedError()
            elif request_code == 0x300001f:  # GetConsoleWindow
                raise NotImplementedError()
            elif request_code == 0x3000004:  # ?? Called by powershell
                raise NotImplementedError()
            else:
                raise NotImplementedError()
        elif control.code == 0x500037:  # ConsoleLaunchServerProcess (AllocConsole)
            raise NotImplementedError()
        else:
            raise NotImplementedError()

```

`src/dumpulator/ntenums.py`:

```py
# Automatically generated with parse_phnt.py, do not edit
from enum import Enum

class EVENT_TYPE(Enum):
    NotificationEvent = 0
    SynchronizationEvent = 1

class TIMER_TYPE(Enum):
    NotificationTimer = 0
    SynchronizationTimer = 1

class WAIT_TYPE(Enum):
    WaitAll = 0
    WaitAny = 1
    WaitNotification = 2

class NT_PRODUCT_TYPE(Enum):
    NtProductWinNt = 1
    NtProductLanManNt = 2
    NtProductServer = 3

class SUITE_TYPE(Enum):
    SmallBusiness = 0
    Enterprise = 1
    BackOffice = 2
    CommunicationServer = 3
    TerminalServer = 4
    SmallBusinessRestricted = 5
    EmbeddedNT = 6
    DataCenter = 7
    SingleUserTS = 8
    Personal = 9
    Blade = 10
    EmbeddedRestricted = 11
    SecurityAppliance = 12
    StorageServer = 13
    ComputeServer = 14
    WHServer = 15
    PhoneNT = 16
    MaxSuiteType = 17

class KTHREAD_STATE(Enum):
    Initialized = 0
    Ready = 1
    Running = 2
    Standby = 3
    Terminated = 4
    Waiting = 5
    Transition = 6
    DeferredReady = 7
    GateWaitObsolete = 8
    WaitingForProcessInSwap = 9
    MaximumThreadState = 10

class KHETERO_CPU_POLICY(Enum):
    KHeteroCpuPolicyAll = 0
    KHeteroCpuPolicyLarge = 1
    KHeteroCpuPolicyLargeOrIdle = 2
    KHeteroCpuPolicySmall = 3
    KHeteroCpuPolicySmallOrIdle = 4
    KHeteroCpuPolicyDynamic = 5
    KHeteroCpuPolicyStaticMax = 5  # valid
    KHeteroCpuPolicyBiasedSmall = 6
    KHeteroCpuPolicyBiasedLarge = 7
    KHeteroCpuPolicyDefault = 8
    KHeteroCpuPolicyMax = 9

class KWAIT_REASON(Enum):
    Executive = 0
    FreePage = 1
    PageIn = 2
    PoolAllocation = 3
    DelayExecution = 4
    Suspended = 5
    UserRequest = 6
    WrExecutive = 7
    WrFreePage = 8
    WrPageIn = 9
    WrPoolAllocation = 10
    WrDelayExecution = 11
    WrSuspended = 12
    WrUserRequest = 13
    WrEventPair = 14
    WrQueue = 15
    WrLpcReceive = 16
    WrLpcReply = 17
    WrVirtualMemory = 18
    WrPageOut = 19
    WrRendezvous = 20
    WrKeyedEvent = 21
    WrTerminated = 22
    WrProcessInSwap = 23
    WrCpuRateControl = 24
    WrCalloutStack = 25
    WrKernel = 26
    WrResource = 27
    WrPushLock = 28
    WrMutex = 29
    WrQuantumEnd = 30
    WrDispatchInt = 31
    WrPreempted = 32
    WrYieldExecution = 33
    WrFastMutex = 34
    WrGuardedMutex = 35
    WrRundown = 36
    WrAlertByThreadId = 37
    WrDeferredPreempt = 38
    WrPhysicalFault = 39
    WrIoRing = 40
    WrMdlCache = 41
    MaximumWaitReason = 42

class KPROFILE_SOURCE(Enum):
    ProfileTime = 0
    ProfileAlignmentFixup = 1
    ProfileTotalIssues = 2
    ProfilePipelineDry = 3
    ProfileLoadInstructions = 4
    ProfilePipelineFrozen = 5
    ProfileBranchInstructions = 6
    ProfileTotalNonissues = 7
    ProfileDcacheMisses = 8
    ProfileIcacheMisses = 9
    ProfileCacheMisses = 10
    ProfileBranchMispredictions = 11
    ProfileStoreInstructions = 12
    ProfileFpInstructions = 13
    ProfileIntegerInstructions = 14
    Profile2Issue = 15
    Profile3Issue = 16
    Profile4Issue = 17
    ProfileSpecialInstructions = 18
    ProfileTotalCycles = 19
    ProfileIcacheIssues = 20
    ProfileDcacheAccesses = 21
    ProfileMemoryBarrierCycles = 22
    ProfileLoadLinkedIssues = 23
    ProfileMaximum = 24

class LDR_DDAG_STATE(Enum):
    LdrModulesMerged = -5
    LdrModulesInitError = -4
    LdrModulesSnapError = -3
    LdrModulesUnloaded = -2
    LdrModulesUnloading = -1
    LdrModulesPlaceHolder = 0
    LdrModulesMapping = 1
    LdrModulesMapped = 2
    LdrModulesWaitingForDependencies = 3
    LdrModulesSnapping = 4
    LdrModulesSnapped = 5
    LdrModulesCondensed = 6
    LdrModulesReadyToInit = 7
    LdrModulesInitializing = 8
    LdrModulesReadyToRun = 9

class LDR_DLL_LOAD_REASON(Enum):
    LoadReasonStaticDependency = 0
    LoadReasonStaticForwarderDependency = 1
    LoadReasonDynamicForwarderDependency = 2
    LoadReasonDelayloadDependency = 3
    LoadReasonDynamicLoad = 4
    LoadReasonAsImageLoad = 5
    LoadReasonAsDataLoad = 6
    LoadReasonEnclavePrimary = 7  # since REDSTONE3
    LoadReasonEnclaveDependency = 8
    LoadReasonPatchImage = 9  # since WIN11
    LoadReasonUnknown = -1

class LDR_HOT_PATCH_STATE(Enum):
    LdrHotPatchBaseImage = 0
    LdrHotPatchNotApplied = 1
    LdrHotPatchAppliedReverse = 2
    LdrHotPatchAppliedForward = 3
    LdrHotPatchFailedToPatch = 4
    LdrHotPatchStateMax = 5

class SYSTEM_ENVIRONMENT_INFORMATION_CLASS(Enum):
    SystemEnvironmentNameInformation = 1  # q: VARIABLE_NAME
    SystemEnvironmentValueInformation = 2  # q: VARIABLE_NAME_AND_VALUE
    MaxSystemEnvironmentInfoClass = 3

class FILTER_BOOT_OPTION_OPERATION(Enum):
    FilterBootOptionOperationOpenSystemStore = 0
    FilterBootOptionOperationSetElement = 1
    FilterBootOptionOperationDeleteElement = 2
    FilterBootOptionOperationMax = 3

class EVENT_INFORMATION_CLASS(Enum):
    EventBasicInformation = 0

class MUTANT_INFORMATION_CLASS(Enum):
    MutantBasicInformation = 0  # MUTANT_BASIC_INFORMATION
    MutantOwnerInformation = 1  # MUTANT_OWNER_INFORMATION

class SEMAPHORE_INFORMATION_CLASS(Enum):
    SemaphoreBasicInformation = 0

class TIMER_INFORMATION_CLASS(Enum):
    TimerBasicInformation = 0  # TIMER_BASIC_INFORMATION

class TIMER_SET_INFORMATION_CLASS(Enum):
    TimerSetCoalescableTimer = 0  # TIMER_SET_COALESCABLE_TIMER_INFO
    MaxTimerInfoClass = 1

class WNF_STATE_NAME_LIFETIME(Enum):
    WnfWellKnownStateName = 0
    WnfPermanentStateName = 1
    WnfPersistentStateName = 2
    WnfTemporaryStateName = 3

class WNF_STATE_NAME_INFORMATION(Enum):
    WnfInfoStateNameExist = 0
    WnfInfoSubscribersPresent = 1
    WnfInfoIsQuiescent = 2

class WNF_DATA_SCOPE(Enum):
    WnfDataScopeSystem = 0
    WnfDataScopeSession = 1
    WnfDataScopeUser = 2
    WnfDataScopeProcess = 3
    WnfDataScopeMachine = 4  # REDSTONE3
    WnfDataScopePhysicalMachine = 5  # WIN11

class WORKERFACTORYINFOCLASS(Enum):
    WorkerFactoryTimeout = 0  # LARGE_INTEGER
    WorkerFactoryRetryTimeout = 1  # LARGE_INTEGER
    WorkerFactoryIdleTimeout = 2  # s: LARGE_INTEGER
    WorkerFactoryBindingCount = 3  # s: ULONG
    WorkerFactoryThreadMinimum = 4  # s: ULONG
    WorkerFactoryThreadMaximum = 5  # s: ULONG
    WorkerFactoryPaused = 6  # ULONG or BOOLEAN
    WorkerFactoryBasicInformation = 7  # q: WORKER_FACTORY_BASIC_INFORMATION
    WorkerFactoryAdjustThreadGoal = 8
    WorkerFactoryCallbackType = 9
    WorkerFactoryStackInformation = 10  # 10
    WorkerFactoryThreadBasePriority = 11  # s: ULONG
    WorkerFactoryTimeoutWaiters = 12  # s: ULONG, since THRESHOLD
    WorkerFactoryFlags = 13  # s: ULONG
    WorkerFactoryThreadSoftMaximum = 14  # s: ULONG
    WorkerFactoryThreadCpuSets = 15  # since REDSTONE5
    MaxWorkerFactoryInfoClass = 16

class SYSTEM_INFORMATION_CLASS(Enum):
    SystemBasicInformation = 0  # q: SYSTEM_BASIC_INFORMATION
    SystemProcessorInformation = 1  # q: SYSTEM_PROCESSOR_INFORMATION
    SystemPerformanceInformation = 2  # q: SYSTEM_PERFORMANCE_INFORMATION
    SystemTimeOfDayInformation = 3  # q: SYSTEM_TIMEOFDAY_INFORMATION
    SystemPathInformation = 4  # not implemented
    SystemProcessInformation = 5  # q: SYSTEM_PROCESS_INFORMATION
    SystemCallCountInformation = 6  # q: SYSTEM_CALL_COUNT_INFORMATION
    SystemDeviceInformation = 7  # q: SYSTEM_DEVICE_INFORMATION
    SystemProcessorPerformanceInformation = 8  # q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemFlagsInformation = 9  # q: SYSTEM_FLAGS_INFORMATION
    SystemCallTimeInformation = 10  # not implemented // SYSTEM_CALL_TIME_INFORMATION // 10
    SystemModuleInformation = 11  # q: RTL_PROCESS_MODULES
    SystemLocksInformation = 12  # q: RTL_PROCESS_LOCKS
    SystemStackTraceInformation = 13  # q: RTL_PROCESS_BACKTRACES
    SystemPagedPoolInformation = 14  # not implemented
    SystemNonPagedPoolInformation = 15  # not implemented
    SystemHandleInformation = 16  # q: SYSTEM_HANDLE_INFORMATION
    SystemObjectInformation = 17  # q: SYSTEM_OBJECTTYPE_INFORMATION mixed with SYSTEM_OBJECT_INFORMATION
    SystemPageFileInformation = 18  # q: SYSTEM_PAGEFILE_INFORMATION
    SystemVdmInstemulInformation = 19  # q: SYSTEM_VDM_INSTEMUL_INFO
    SystemVdmBopInformation = 20  # not implemented // 20
    SystemFileCacheInformation = 21  # q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemCache)
    SystemPoolTagInformation = 22  # q: SYSTEM_POOLTAG_INFORMATION
    SystemInterruptInformation = 23  # q: SYSTEM_INTERRUPT_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemDpcBehaviorInformation = 24  # q: SYSTEM_DPC_BEHAVIOR_INFORMATION; s: SYSTEM_DPC_BEHAVIOR_INFORMATION (requires SeLoadDriverPrivilege)
    SystemFullMemoryInformation = 25  # not implemented // SYSTEM_MEMORY_USAGE_INFORMATION
    SystemLoadGdiDriverInformation = 26  # s (kernel-mode only)
    SystemUnloadGdiDriverInformation = 27  # s (kernel-mode only)
    SystemTimeAdjustmentInformation = 28  # q: SYSTEM_QUERY_TIME_ADJUST_INFORMATION; s: SYSTEM_SET_TIME_ADJUST_INFORMATION (requires SeSystemtimePrivilege)
    SystemSummaryMemoryInformation = 29  # not implemented // SYSTEM_MEMORY_USAGE_INFORMATION
    SystemMirrorMemoryInformation = 30  # s (requires license value "Kernel-MemoryMirroringSupported") (requires SeShutdownPrivilege) // 30
    SystemPerformanceTraceInformation = 31  # q; s: (type depends on EVENT_TRACE_INFORMATION_CLASS)
    SystemObsolete0 = 32  # not implemented
    SystemExceptionInformation = 33  # q: SYSTEM_EXCEPTION_INFORMATION
    SystemCrashDumpStateInformation = 34  # s: SYSTEM_CRASH_DUMP_STATE_INFORMATION (requires SeDebugPrivilege)
    SystemKernelDebuggerInformation = 35  # q: SYSTEM_KERNEL_DEBUGGER_INFORMATION
    SystemContextSwitchInformation = 36  # q: SYSTEM_CONTEXT_SWITCH_INFORMATION
    SystemRegistryQuotaInformation = 37  # q: SYSTEM_REGISTRY_QUOTA_INFORMATION; s (requires SeIncreaseQuotaPrivilege)
    SystemExtendServiceTableInformation = 38  # s (requires SeLoadDriverPrivilege) // loads win32k only
    SystemPrioritySeperation = 39  # s (requires SeTcbPrivilege)
    SystemVerifierAddDriverInformation = 40  # s (requires SeDebugPrivilege) // 40
    SystemVerifierRemoveDriverInformation = 41  # s (requires SeDebugPrivilege)
    SystemProcessorIdleInformation = 42  # q: SYSTEM_PROCESSOR_IDLE_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemLegacyDriverInformation = 43  # q: SYSTEM_LEGACY_DRIVER_INFORMATION
    SystemCurrentTimeZoneInformation = 44  # q; s: RTL_TIME_ZONE_INFORMATION
    SystemLookasideInformation = 45  # q: SYSTEM_LOOKASIDE_INFORMATION
    SystemTimeSlipNotification = 46  # s: HANDLE (NtCreateEvent) (requires SeSystemtimePrivilege)
    SystemSessionCreate = 47  # not implemented
    SystemSessionDetach = 48  # not implemented
    SystemSessionInformation = 49  # not implemented (SYSTEM_SESSION_INFORMATION)
    SystemRangeStartInformation = 50  # q: SYSTEM_RANGE_START_INFORMATION // 50
    SystemVerifierInformation = 51  # q: SYSTEM_VERIFIER_INFORMATION; s (requires SeDebugPrivilege)
    SystemVerifierThunkExtend = 52  # s (kernel-mode only)
    SystemSessionProcessInformation = 53  # q: SYSTEM_SESSION_PROCESS_INFORMATION
    SystemLoadGdiDriverInSystemSpace = 54  # s: SYSTEM_GDI_DRIVER_INFORMATION (kernel-mode only) (same as SystemLoadGdiDriverInformation)
    SystemNumaProcessorMap = 55  # q: SYSTEM_NUMA_INFORMATION
    SystemPrefetcherInformation = 56  # q; s: PREFETCHER_INFORMATION // PfSnQueryPrefetcherInformation
    SystemExtendedProcessInformation = 57  # q: SYSTEM_PROCESS_INFORMATION
    SystemRecommendedSharedDataAlignment = 58  # q: ULONG // KeGetRecommendedSharedDataAlignment
    SystemComPlusPackage = 59  # q; s: ULONG
    SystemNumaAvailableMemory = 60  # q: SYSTEM_NUMA_INFORMATION // 60
    SystemProcessorPowerInformation = 61  # q: SYSTEM_PROCESSOR_POWER_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemEmulationBasicInformation = 62  # q: SYSTEM_BASIC_INFORMATION
    SystemEmulationProcessorInformation = 63  # q: SYSTEM_PROCESSOR_INFORMATION
    SystemExtendedHandleInformation = 64  # q: SYSTEM_HANDLE_INFORMATION_EX
    SystemLostDelayedWriteInformation = 65  # q: ULONG
    SystemBigPoolInformation = 66  # q: SYSTEM_BIGPOOL_INFORMATION
    SystemSessionPoolTagInformation = 67  # q: SYSTEM_SESSION_POOLTAG_INFORMATION
    SystemSessionMappedViewInformation = 68  # q: SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
    SystemHotpatchInformation = 69  # q; s: SYSTEM_HOTPATCH_CODE_INFORMATION
    SystemObjectSecurityMode = 70  # q: ULONG // 70
    SystemWatchdogTimerHandler = 71  # s: SYSTEM_WATCHDOG_HANDLER_INFORMATION // (kernel-mode only)
    SystemWatchdogTimerInformation = 72  # q: SYSTEM_WATCHDOG_TIMER_INFORMATION // (kernel-mode only)
    SystemLogicalProcessorInformation = 73  # q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemWow64SharedInformationObsolete = 74  # not implemented
    SystemRegisterFirmwareTableInformationHandler = 75  # s: SYSTEM_FIRMWARE_TABLE_HANDLER // (kernel-mode only)
    SystemFirmwareTableInformation = 76  # SYSTEM_FIRMWARE_TABLE_INFORMATION
    SystemModuleInformationEx = 77  # q: RTL_PROCESS_MODULE_INFORMATION_EX
    SystemVerifierTriageInformation = 78  # not implemented
    SystemSuperfetchInformation = 79  # q; s: SUPERFETCH_INFORMATION // PfQuerySuperfetchInformation
    SystemMemoryListInformation = 80  # q: SYSTEM_MEMORY_LIST_INFORMATION; s: SYSTEM_MEMORY_LIST_COMMAND (requires SeProfileSingleProcessPrivilege) // 80
    SystemFileCacheInformationEx = 81  # q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (same as SystemFileCacheInformation)
    SystemThreadPriorityClientIdInformation = 82  # s: SYSTEM_THREAD_CID_PRIORITY_INFORMATION (requires SeIncreaseBasePriorityPrivilege)
    SystemProcessorIdleCycleTimeInformation = 83  # q: SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION[] (EX in: USHORT ProcessorGroup)
    SystemVerifierCancellationInformation = 84  # SYSTEM_VERIFIER_CANCELLATION_INFORMATION // name:wow64:whNT32QuerySystemVerifierCancellationInformation
    SystemProcessorPowerInformationEx = 85  # not implemented
    SystemRefTraceInformation = 86  # q; s: SYSTEM_REF_TRACE_INFORMATION // ObQueryRefTraceInformation
    SystemSpecialPoolInformation = 87  # q; s: SYSTEM_SPECIAL_POOL_INFORMATION (requires SeDebugPrivilege) // MmSpecialPoolTag, then MmSpecialPoolCatchOverruns != 0
    SystemProcessIdInformation = 88  # q: SYSTEM_PROCESS_ID_INFORMATION
    SystemErrorPortInformation = 89  # s (requires SeTcbPrivilege)
    SystemBootEnvironmentInformation = 90  # q: SYSTEM_BOOT_ENVIRONMENT_INFORMATION // 90
    SystemHypervisorInformation = 91  # q: SYSTEM_HYPERVISOR_QUERY_INFORMATION
    SystemVerifierInformationEx = 92  # q; s: SYSTEM_VERIFIER_INFORMATION_EX
    SystemTimeZoneInformation = 93  # q; s: RTL_TIME_ZONE_INFORMATION (requires SeTimeZonePrivilege)
    SystemImageFileExecutionOptionsInformation = 94  # s: SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION (requires SeTcbPrivilege)
    SystemCoverageInformation = 95  # q: COVERAGE_MODULES s: COVERAGE_MODULE_REQUEST // ExpCovQueryInformation (requires SeDebugPrivilege)
    SystemPrefetchPatchInformation = 96  # SYSTEM_PREFETCH_PATCH_INFORMATION
    SystemVerifierFaultsInformation = 97  # s: SYSTEM_VERIFIER_FAULTS_INFORMATION (requires SeDebugPrivilege)
    SystemSystemPartitionInformation = 98  # q: SYSTEM_SYSTEM_PARTITION_INFORMATION
    SystemSystemDiskInformation = 99  # q: SYSTEM_SYSTEM_DISK_INFORMATION
    SystemProcessorPerformanceDistribution = 100  # q: SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION (EX in: USHORT ProcessorGroup) // 100
    SystemNumaProximityNodeInformation = 101  # q; s: SYSTEM_NUMA_PROXIMITY_MAP
    SystemDynamicTimeZoneInformation = 102  # q; s: RTL_DYNAMIC_TIME_ZONE_INFORMATION (requires SeTimeZonePrivilege)
    SystemCodeIntegrityInformation = 103  # q: SYSTEM_CODEINTEGRITY_INFORMATION // SeCodeIntegrityQueryInformation
    SystemProcessorMicrocodeUpdateInformation = 104  # s: SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION
    SystemProcessorBrandString = 105  # q: CHAR[] // HaliQuerySystemInformation -> HalpGetProcessorBrandString, info class 23
    SystemVirtualAddressInformation = 106  # q: SYSTEM_VA_LIST_INFORMATION[]; s: SYSTEM_VA_LIST_INFORMATION[] (requires SeIncreaseQuotaPrivilege) // MmQuerySystemVaInformation
    SystemLogicalProcessorAndGroupInformation = 107  # q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX (EX in: LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType) // since WIN7 // KeQueryLogicalProcessorRelationship
    SystemProcessorCycleTimeInformation = 108  # q: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION[] (EX in: USHORT ProcessorGroup)
    SystemStoreInformation = 109  # q; s: SYSTEM_STORE_INFORMATION (requires SeProfileSingleProcessPrivilege) // SmQueryStoreInformation
    SystemRegistryAppendString = 110  # s: SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS // 110
    SystemAitSamplingValue = 111  # s: ULONG (requires SeProfileSingleProcessPrivilege)
    SystemVhdBootInformation = 112  # q: SYSTEM_VHD_BOOT_INFORMATION
    SystemCpuQuotaInformation = 113  # q; s: PS_CPU_QUOTA_QUERY_INFORMATION
    SystemNativeBasicInformation = 114  # q: SYSTEM_BASIC_INFORMATION
    SystemErrorPortTimeouts = 115  # SYSTEM_ERROR_PORT_TIMEOUTS
    SystemLowPriorityIoInformation = 116  # q: SYSTEM_LOW_PRIORITY_IO_INFORMATION
    SystemTpmBootEntropyInformation = 117  # q: TPM_BOOT_ENTROPY_NT_RESULT // ExQueryTpmBootEntropyInformation
    SystemVerifierCountersInformation = 118  # q: SYSTEM_VERIFIER_COUNTERS_INFORMATION
    SystemPagedPoolInformationEx = 119  # q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypePagedPool)
    SystemSystemPtesInformationEx = 120  # q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemPtes) // 120
    SystemNodeDistanceInformation = 121  # q: USHORT[4*NumaNodes] // (EX in: USHORT NodeNumber)
    SystemAcpiAuditInformation = 122  # q: SYSTEM_ACPI_AUDIT_INFORMATION // HaliQuerySystemInformation -> HalpAuditQueryResults, info class 26
    SystemBasicPerformanceInformation = 123  # q: SYSTEM_BASIC_PERFORMANCE_INFORMATION // name:wow64:whNtQuerySystemInformation_SystemBasicPerformanceInformation
    SystemQueryPerformanceCounterInformation = 124  # q: SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION // since WIN7 SP1
    SystemSessionBigPoolInformation = 125  # q: SYSTEM_SESSION_POOLTAG_INFORMATION // since WIN8
    SystemBootGraphicsInformation = 126  # q; s: SYSTEM_BOOT_GRAPHICS_INFORMATION (kernel-mode only)
    SystemScrubPhysicalMemoryInformation = 127  # q; s: MEMORY_SCRUB_INFORMATION
    SystemBadPageInformation = 128
    SystemProcessorProfileControlArea = 129  # q; s: SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA
    SystemCombinePhysicalMemoryInformation = 130  # s: MEMORY_COMBINE_INFORMATION, MEMORY_COMBINE_INFORMATION_EX, MEMORY_COMBINE_INFORMATION_EX2 // 130
    SystemEntropyInterruptTimingInformation = 131  # q; s: SYSTEM_ENTROPY_TIMING_INFORMATION
    SystemConsoleInformation = 132  # q; s: SYSTEM_CONSOLE_INFORMATION
    SystemPlatformBinaryInformation = 133  # q: SYSTEM_PLATFORM_BINARY_INFORMATION (requires SeTcbPrivilege)
    SystemPolicyInformation = 134  # q: SYSTEM_POLICY_INFORMATION
    SystemHypervisorProcessorCountInformation = 135  # q: SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION
    SystemDeviceDataInformation = 136  # q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemDeviceDataEnumerationInformation = 137  # q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemMemoryTopologyInformation = 138  # q: SYSTEM_MEMORY_TOPOLOGY_INFORMATION
    SystemMemoryChannelInformation = 139  # q: SYSTEM_MEMORY_CHANNEL_INFORMATION
    SystemBootLogoInformation = 140  # q: SYSTEM_BOOT_LOGO_INFORMATION // 140
    SystemProcessorPerformanceInformationEx = 141  # q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX // (EX in: USHORT ProcessorGroup) // since WINBLUE
    SystemCriticalProcessErrorLogInformation = 142
    SystemSecureBootPolicyInformation = 143  # q: SYSTEM_SECUREBOOT_POLICY_INFORMATION
    SystemPageFileInformationEx = 144  # q: SYSTEM_PAGEFILE_INFORMATION_EX
    SystemSecureBootInformation = 145  # q: SYSTEM_SECUREBOOT_INFORMATION
    SystemEntropyInterruptTimingRawInformation = 146
    SystemPortableWorkspaceEfiLauncherInformation = 147  # q: SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION
    SystemFullProcessInformation = 148  # q: SYSTEM_PROCESS_INFORMATION with SYSTEM_PROCESS_INFORMATION_EXTENSION (requires admin)
    SystemKernelDebuggerInformationEx = 149  # q: SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
    SystemBootMetadataInformation = 150  # 150
    SystemSoftRebootInformation = 151  # q: ULONG
    SystemElamCertificateInformation = 152  # s: SYSTEM_ELAM_CERTIFICATE_INFORMATION
    SystemOfflineDumpConfigInformation = 153  # q: OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2
    SystemProcessorFeaturesInformation = 154  # q: SYSTEM_PROCESSOR_FEATURES_INFORMATION
    SystemRegistryReconciliationInformation = 155  # s: NULL (requires admin) (flushes registry hives)
    SystemEdidInformation = 156  # q: SYSTEM_EDID_INFORMATION
    SystemManufacturingInformation = 157  # q: SYSTEM_MANUFACTURING_INFORMATION // since THRESHOLD
    SystemEnergyEstimationConfigInformation = 158  # q: SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION
    SystemHypervisorDetailInformation = 159  # q: SYSTEM_HYPERVISOR_DETAIL_INFORMATION
    SystemProcessorCycleStatsInformation = 160  # q: SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION (EX in: USHORT ProcessorGroup) // 160
    SystemVmGenerationCountInformation = 161
    SystemTrustedPlatformModuleInformation = 162  # q: SYSTEM_TPM_INFORMATION
    SystemKernelDebuggerFlags = 163  # SYSTEM_KERNEL_DEBUGGER_FLAGS
    SystemCodeIntegrityPolicyInformation = 164  # q: SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
    SystemIsolatedUserModeInformation = 165  # q: SYSTEM_ISOLATED_USER_MODE_INFORMATION
    SystemHardwareSecurityTestInterfaceResultsInformation = 166
    SystemSingleModuleInformation = 167  # q: SYSTEM_SINGLE_MODULE_INFORMATION
    SystemAllowedCpuSetsInformation = 168
    SystemVsmProtectionInformation = 169  # q: SYSTEM_VSM_PROTECTION_INFORMATION (previously SystemDmaProtectionInformation)
    SystemInterruptCpuSetsInformation = 170  # q: SYSTEM_INTERRUPT_CPU_SET_INFORMATION // 170
    SystemSecureBootPolicyFullInformation = 171  # q: SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
    SystemCodeIntegrityPolicyFullInformation = 172
    SystemAffinitizedInterruptProcessorInformation = 173  # (requires SeIncreaseBasePriorityPrivilege)
    SystemRootSiloInformation = 174  # q: SYSTEM_ROOT_SILO_INFORMATION
    SystemCpuSetInformation = 175  # q: SYSTEM_CPU_SET_INFORMATION // since THRESHOLD2
    SystemCpuSetTagInformation = 176  # q: SYSTEM_CPU_SET_TAG_INFORMATION
    SystemWin32WerStartCallout = 177
    SystemSecureKernelProfileInformation = 178  # q: SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION
    SystemCodeIntegrityPlatformManifestInformation = 179  # q: SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION // since REDSTONE
    SystemInterruptSteeringInformation = 180  # SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT // 180
    SystemSupportedProcessorArchitectures = 181  # p: in opt: HANDLE, out: SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION[] // NtQuerySystemInformationEx
    SystemMemoryUsageInformation = 182  # q: SYSTEM_MEMORY_USAGE_INFORMATION
    SystemCodeIntegrityCertificateInformation = 183  # q: SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
    SystemPhysicalMemoryInformation = 184  # q: SYSTEM_PHYSICAL_MEMORY_INFORMATION // since REDSTONE2
    SystemControlFlowTransition = 185
    SystemKernelDebuggingAllowed = 186  # s: ULONG
    SystemActivityModerationExeState = 187  # SYSTEM_ACTIVITY_MODERATION_EXE_STATE
    SystemActivityModerationUserSettings = 188  # SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS
    SystemCodeIntegrityPoliciesFullInformation = 189
    SystemCodeIntegrityUnlockInformation = 190  # SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION // 190
    SystemIntegrityQuotaInformation = 191
    SystemFlushInformation = 192  # q: SYSTEM_FLUSH_INFORMATION
    SystemProcessorIdleMaskInformation = 193  # q: ULONG_PTR[ActiveGroupCount] // since REDSTONE3
    SystemSecureDumpEncryptionInformation = 194
    SystemWriteConstraintInformation = 195  # SYSTEM_WRITE_CONSTRAINT_INFORMATION
    SystemKernelVaShadowInformation = 196  # SYSTEM_KERNEL_VA_SHADOW_INFORMATION
    SystemHypervisorSharedPageInformation = 197  # SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION // since REDSTONE4
    SystemFirmwareBootPerformanceInformation = 198
    SystemCodeIntegrityVerificationInformation = 199  # SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION
    SystemFirmwarePartitionInformation = 200  # SYSTEM_FIRMWARE_PARTITION_INFORMATION // 200
    SystemSpeculationControlInformation = 201  # SYSTEM_SPECULATION_CONTROL_INFORMATION // (CVE-2017-5715) REDSTONE3 and above.
    SystemDmaGuardPolicyInformation = 202  # SYSTEM_DMA_GUARD_POLICY_INFORMATION
    SystemEnclaveLaunchControlInformation = 203  # SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION
    SystemWorkloadAllowedCpuSetsInformation = 204  # SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION // since REDSTONE5
    SystemCodeIntegrityUnlockModeInformation = 205
    SystemLeapSecondInformation = 206  # SYSTEM_LEAP_SECOND_INFORMATION
    SystemFlags2Information = 207  # q: SYSTEM_FLAGS_INFORMATION
    SystemSecurityModelInformation = 208  # SYSTEM_SECURITY_MODEL_INFORMATION // since 19H1
    SystemCodeIntegritySyntheticCacheInformation = 209
    SystemFeatureConfigurationInformation = 210  # SYSTEM_FEATURE_CONFIGURATION_INFORMATION // since 20H1 // 210
    SystemFeatureConfigurationSectionInformation = 211  # SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION
    SystemFeatureUsageSubscriptionInformation = 212  # SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS
    SystemSecureSpeculationControlInformation = 213  # SECURE_SPECULATION_CONTROL_INFORMATION
    SystemSpacesBootInformation = 214  # since 20H2
    SystemFwRamdiskInformation = 215  # SYSTEM_FIRMWARE_RAMDISK_INFORMATION
    SystemWheaIpmiHardwareInformation = 216
    SystemDifSetRuleClassInformation = 217
    SystemDifClearRuleClassInformation = 218
    SystemDifApplyPluginVerificationOnDriver = 219
    SystemDifRemovePluginVerificationOnDriver = 220  # 220
    SystemShadowStackInformation = 221  # SYSTEM_SHADOW_STACK_INFORMATION
    SystemBuildVersionInformation = 222  # SYSTEM_BUILD_VERSION_INFORMATION
    SystemPoolLimitInformation = 223  # SYSTEM_POOL_LIMIT_INFORMATION
    SystemCodeIntegrityAddDynamicStore = 224
    SystemCodeIntegrityClearDynamicStores = 225
    SystemDifPoolTrackingInformation = 226
    SystemPoolZeroingInformation = 227  # SYSTEM_POOL_ZEROING_INFORMATION
    SystemDpcWatchdogInformation = 228
    SystemDpcWatchdogInformation2 = 229
    SystemSupportedProcessorArchitectures2 = 230  # q: in opt: HANDLE, out: SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION[] // NtQuerySystemInformationEx  // 230
    SystemSingleProcessorRelationshipInformation = 231  # q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX // (EX in: PROCESSOR_NUMBER Processor)
    SystemXfgCheckFailureInformation = 232
    SystemIommuStateInformation = 233  # SYSTEM_IOMMU_STATE_INFORMATION // since 22H1
    SystemHypervisorMinrootInformation = 234  # SYSTEM_HYPERVISOR_MINROOT_INFORMATION
    SystemHypervisorBootPagesInformation = 235  # SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION
    SystemPointerAuthInformation = 236  # SYSTEM_POINTER_AUTH_INFORMATION
    SystemSecureKernelDebuggerInformation = 237
    SystemOriginalImageFeatureInformation = 238
    MaxSystemInfoClass = 239

class EVENT_TRACE_INFORMATION_CLASS(Enum):
    EventTraceKernelVersionInformation = 0  # EVENT_TRACE_VERSION_INFORMATION
    EventTraceGroupMaskInformation = 1  # EVENT_TRACE_GROUPMASK_INFORMATION
    EventTracePerformanceInformation = 2  # EVENT_TRACE_PERFORMANCE_INFORMATION
    EventTraceTimeProfileInformation = 3  # EVENT_TRACE_TIME_PROFILE_INFORMATION
    EventTraceSessionSecurityInformation = 4  # EVENT_TRACE_SESSION_SECURITY_INFORMATION
    EventTraceSpinlockInformation = 5  # EVENT_TRACE_SPINLOCK_INFORMATION
    EventTraceStackTracingInformation = 6  # EVENT_TRACE_SYSTEM_EVENT_INFORMATION
    EventTraceExecutiveResourceInformation = 7  # EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION
    EventTraceHeapTracingInformation = 8  # EVENT_TRACE_HEAP_TRACING_INFORMATION
    EventTraceHeapSummaryTracingInformation = 9  # EVENT_TRACE_HEAP_TRACING_INFORMATION
    EventTracePoolTagFilterInformation = 10  # EVENT_TRACE_TAG_FILTER_INFORMATION
    EventTracePebsTracingInformation = 11  # EVENT_TRACE_SYSTEM_EVENT_INFORMATION
    EventTraceProfileConfigInformation = 12  # EVENT_TRACE_PROFILE_COUNTER_INFORMATION
    EventTraceProfileSourceListInformation = 13  # EVENT_TRACE_PROFILE_LIST_INFORMATION
    EventTraceProfileEventListInformation = 14  # EVENT_TRACE_SYSTEM_EVENT_INFORMATION
    EventTraceProfileCounterListInformation = 15  # EVENT_TRACE_PROFILE_COUNTER_INFORMATION
    EventTraceStackCachingInformation = 16  # EVENT_TRACE_STACK_CACHING_INFORMATION
    EventTraceObjectTypeFilterInformation = 17  # EVENT_TRACE_TAG_FILTER_INFORMATION
    EventTraceSoftRestartInformation = 18  # EVENT_TRACE_SOFT_RESTART_INFORMATION
    EventTraceLastBranchConfigurationInformation = 19  # REDSTONE3
    EventTraceLastBranchEventListInformation = 20
    EventTraceProfileSourceAddInformation = 21  # EVENT_TRACE_PROFILE_ADD_INFORMATION // REDSTONE4
    EventTraceProfileSourceRemoveInformation = 22  # EVENT_TRACE_PROFILE_REMOVE_INFORMATION
    EventTraceProcessorTraceConfigurationInformation = 23
    EventTraceProcessorTraceEventListInformation = 24
    EventTraceCoverageSamplerInformation = 25  # EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION
    EventTraceUnifiedStackCachingInformation = 26  # sicne 21H1
    MaxEventTraceInfoClass = 27

class SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS(Enum):
    SystemCrashDumpDisable = 0
    SystemCrashDumpReconfigure = 1
    SystemCrashDumpInitializationComplete = 2

class WATCHDOG_HANDLER_ACTION(Enum):
    WdActionSetTimeoutValue = 0
    WdActionQueryTimeoutValue = 1
    WdActionResetTimer = 2
    WdActionStopTimer = 3
    WdActionStartTimer = 4
    WdActionSetTriggerAction = 5
    WdActionQueryTriggerAction = 6
    WdActionQueryState = 7

class WATCHDOG_INFORMATION_CLASS(Enum):
    WdInfoTimeoutValue = 0
    WdInfoResetTimer = 1
    WdInfoStopTimer = 2
    WdInfoStartTimer = 3
    WdInfoTriggerAction = 4
    WdInfoState = 5
    WdInfoTriggerReset = 6
    WdInfoNop = 7
    WdInfoGeneratedLastReset = 8
    WdInfoInvalid = 9

class SYSTEM_FIRMWARE_TABLE_ACTION(Enum):
    SystemFirmwareTableEnumerate = 0
    SystemFirmwareTableGet = 1
    SystemFirmwareTableMax = 2

class SYSTEM_MEMORY_LIST_COMMAND(Enum):
    MemoryCaptureAccessedBits = 0
    MemoryCaptureAndResetAccessedBits = 1
    MemoryEmptyWorkingSets = 2
    MemoryFlushModifiedList = 3
    MemoryPurgeStandbyList = 4
    MemoryPurgeLowPriorityStandbyList = 5
    MemoryCommandMax = 6

class COVERAGE_REQUEST_CODES(Enum):
    CoverageAllModules = 0
    CoverageSearchByHash = 1
    CoverageSearchByName = 2

class SYSTEM_VA_TYPE(Enum):
    SystemVaTypeAll = 0
    SystemVaTypeNonPagedPool = 1
    SystemVaTypePagedPool = 2
    SystemVaTypeSystemCache = 3
    SystemVaTypeSystemPtes = 4
    SystemVaTypeSessionSpace = 5
    SystemVaTypeMax = 6

class STORE_INFORMATION_CLASS(Enum):
    StorePageRequest = 1
    StoreStatsRequest = 2  # q: SM_STATS_REQUEST // SmProcessStatsRequest
    StoreCreateRequest = 3  # s: SM_CREATE_REQUEST (requires SeProfileSingleProcessPrivilege)
    StoreDeleteRequest = 4  # s: SM_DELETE_REQUEST (requires SeProfileSingleProcessPrivilege)
    StoreListRequest = 5  # q: SM_STORE_LIST_REQUEST / SM_STORE_LIST_REQUEST_EX // SmProcessListRequest
    Available1 = 6
    StoreEmptyRequest = 7
    CacheListRequest = 8  # q: SMC_CACHE_LIST_REQUEST // SmcProcessListRequest
    CacheCreateRequest = 9  # s: SMC_CACHE_CREATE_REQUEST (requires SeProfileSingleProcessPrivilege)
    CacheDeleteRequest = 10  # s: SMC_CACHE_DELETE_REQUEST (requires SeProfileSingleProcessPrivilege)
    CacheStoreCreateRequest = 11  # s: SMC_STORE_CREATE_REQUEST (requires SeProfileSingleProcessPrivilege)
    CacheStoreDeleteRequest = 12  # s: SMC_STORE_DELETE_REQUEST (requires SeProfileSingleProcessPrivilege)
    CacheStatsRequest = 13  # q: SMC_CACHE_STATS_REQUEST // SmcProcessStatsRequest
    Available2 = 14
    RegistrationRequest = 15  # q: SM_REGISTRATION_REQUEST (requires SeProfileSingleProcessPrivilege) // SmProcessRegistrationRequest
    GlobalCacheStatsRequest = 16
    StoreResizeRequest = 17  # s: SM_STORE_RESIZE_REQUEST (requires SeProfileSingleProcessPrivilege)
    CacheStoreResizeRequest = 18  # s: SMC_STORE_RESIZE_REQUEST (requires SeProfileSingleProcessPrivilege)
    SmConfigRequest = 19  # s: SM_CONFIG_REQUEST (requires SeProfileSingleProcessPrivilege)
    StoreHighMemoryPriorityRequest = 20  # s: SM_STORE_HIGH_MEM_PRIORITY_REQUEST (requires SeProfileSingleProcessPrivilege)
    SystemStoreTrimRequest = 21  # s: SM_SYSTEM_STORE_TRIM_REQUEST (requires SeProfileSingleProcessPrivilege)
    MemCompressionInfoRequest = 22  # q: SM_MEM_COMPRESSION_INFO_REQUEST // SmProcessCompressionInfoRequest
    ProcessStoreInfoRequest = 23  # SmProcessProcessStoreInfoRequest
    StoreInformationMax = 24

class ST_STATS_LEVEL(Enum):
    StStatsLevelBasic = 0
    StStatsLevelIoStats = 1
    StStatsLevelRegionSpace = 2  # requires SeProfileSingleProcessPrivilege
    StStatsLevelSpaceBitmap = 3  # requires SeProfileSingleProcessPrivilege
    StStatsLevelMax = 4

class SM_STORE_TYPE(Enum):
    StoreTypeInMemory = 0
    StoreTypeFile = 1
    StoreTypeMax = 2

class SM_STORE_MANAGER_TYPE(Enum):
    SmStoreManagerTypePhysical = 0
    SmStoreManagerTypeVirtual = 1
    SmStoreManagerTypeMax = 2

class SM_CONFIG_TYPE(Enum):
    SmConfigDirtyPageCompression = 0
    SmConfigAsyncInswap = 1
    SmConfigPrefetchSeekThreshold = 2
    SmConfigTypeMax = 3

class TPM_BOOT_ENTROPY_RESULT_CODE(Enum):
    TpmBootEntropyStructureUninitialized = 0
    TpmBootEntropyDisabledByPolicy = 1
    TpmBootEntropyNoTpmFound = 2
    TpmBootEntropyTpmError = 3
    TpmBootEntropySuccess = 4

class SYSTEM_PIXEL_FORMAT(Enum):
    SystemPixelFormatUnknown = 0
    SystemPixelFormatR8G8B8 = 1
    SystemPixelFormatR8G8B8X8 = 2
    SystemPixelFormatB8G8R8 = 3
    SystemPixelFormatB8G8R8X8 = 4

class SYSTEM_PROCESS_CLASSIFICATION(Enum):
    SystemProcessClassificationNormal = 0
    SystemProcessClassificationSystem = 1
    SystemProcessClassificationSecureSystem = 2
    SystemProcessClassificationMemCompression = 3
    SystemProcessClassificationRegistry = 4  # REDSTONE4
    SystemProcessClassificationMaximum = 5

class SYSTEM_ACTIVITY_MODERATION_STATE(Enum):
    SystemActivityModerationStateSystemManaged = 0
    SystemActivityModerationStateUserManagedAllowThrottling = 1
    SystemActivityModerationStateUserManagedDisableThrottling = 2
    MaxSystemActivityModerationState = 3

class SYSTEM_ACTIVITY_MODERATION_APP_TYPE(Enum):
    SystemActivityModerationAppTypeClassic = 0
    SystemActivityModerationAppTypePackaged = 1
    MaxSystemActivityModerationAppType = 2

class SYSTEM_IOMMU_STATE(Enum):
    IommuStateBlock = 0
    IommuStateUnblock = 1

class SYSDBG_COMMAND(Enum):
    SysDbgQueryModuleInformation = 0
    SysDbgQueryTraceInformation = 1
    SysDbgSetTracepoint = 2
    SysDbgSetSpecialCall = 3  # PVOID
    SysDbgClearSpecialCalls = 4  # void
    SysDbgQuerySpecialCalls = 5
    SysDbgBreakPoint = 6
    SysDbgQueryVersion = 7  # DBGKD_GET_VERSION64
    SysDbgReadVirtual = 8  # SYSDBG_VIRTUAL
    SysDbgWriteVirtual = 9  # SYSDBG_VIRTUAL
    SysDbgReadPhysical = 10  # SYSDBG_PHYSICAL // 10
    SysDbgWritePhysical = 11  # SYSDBG_PHYSICAL
    SysDbgReadControlSpace = 12  # SYSDBG_CONTROL_SPACE
    SysDbgWriteControlSpace = 13  # SYSDBG_CONTROL_SPACE
    SysDbgReadIoSpace = 14  # SYSDBG_IO_SPACE
    SysDbgWriteIoSpace = 15  # SYSDBG_IO_SPACE
    SysDbgReadMsr = 16  # SYSDBG_MSR
    SysDbgWriteMsr = 17  # SYSDBG_MSR
    SysDbgReadBusData = 18  # SYSDBG_BUS_DATA
    SysDbgWriteBusData = 19  # SYSDBG_BUS_DATA
    SysDbgCheckLowMemory = 20  # 20
    SysDbgEnableKernelDebugger = 21
    SysDbgDisableKernelDebugger = 22
    SysDbgGetAutoKdEnable = 23
    SysDbgSetAutoKdEnable = 24
    SysDbgGetPrintBufferSize = 25
    SysDbgSetPrintBufferSize = 26
    SysDbgGetKdUmExceptionEnable = 27
    SysDbgSetKdUmExceptionEnable = 28
    SysDbgGetTriageDump = 29  # SYSDBG_TRIAGE_DUMP
    SysDbgGetKdBlockEnable = 30  # 30
    SysDbgSetKdBlockEnable = 31
    SysDbgRegisterForUmBreakInfo = 32
    SysDbgGetUmBreakPid = 33
    SysDbgClearUmBreakPid = 34
    SysDbgGetUmAttachPid = 35
    SysDbgClearUmAttachPid = 36
    SysDbgGetLiveKernelDump = 37  # SYSDBG_LIVEDUMP_CONTROL
    SysDbgKdPullRemoteFile = 38  # SYSDBG_KD_PULL_REMOTE_FILE
    SysDbgMaxInfoClass = 39

class HARDERROR_RESPONSE_OPTION(Enum):
    OptionAbortRetryIgnore = 0
    OptionOk = 1
    OptionOkCancel = 2
    OptionRetryCancel = 3
    OptionYesNo = 4
    OptionYesNoCancel = 5
    OptionShutdownSystem = 6
    OptionOkNoWait = 7
    OptionCancelTryContinue = 8

class HARDERROR_RESPONSE(Enum):
    ResponseReturnToCaller = 0
    ResponseNotHandled = 1
    ResponseAbort = 2
    ResponseCancel = 3
    ResponseIgnore = 4
    ResponseNo = 5
    ResponseOk = 6
    ResponseRetry = 7
    ResponseYes = 8
    ResponseTryAgain = 9
    ResponseContinue = 10

class ALTERNATIVE_ARCHITECTURE_TYPE(Enum):
    StandardDesign = 0
    NEC98x86 = 1
    EndAlternatives = 2

class ATOM_INFORMATION_CLASS(Enum):
    AtomBasicInformation = 0
    AtomTableInformation = 1

class SHUTDOWN_ACTION(Enum):
    ShutdownNoReboot = 0
    ShutdownReboot = 1
    ShutdownPowerOff = 2
    ShutdownRebootForRecovery = 3  # since WIN11

class BCD_MESSAGE_TYPE(Enum):
    BCD_MESSAGE_TYPE_NONE = 0
    BCD_MESSAGE_TYPE_TRACE = 1
    BCD_MESSAGE_TYPE_INFORMATION = 2
    BCD_MESSAGE_TYPE_WARNING = 3
    BCD_MESSAGE_TYPE_ERROR = 4
    BCD_MESSAGE_TYPE_MAXIMUM = 5

class BCD_IMPORT_FLAGS(Enum):
    BCD_IMPORT_NONE = 0
    BCD_IMPORT_DELETE_FIRMWARE_OBJECTS = 1

class BCD_OPEN_FLAGS(Enum):
    BCD_OPEN_NONE = 0
    BCD_OPEN_OPEN_STORE_OFFLINE = 1
    BCD_OPEN_SYNC_FIRMWARE_ENTRIES = 2

class BCD_OBJECT_TYPE(Enum):
    BCD_OBJECT_TYPE_NONE = 0
    BCD_OBJECT_TYPE_APPLICATION = 1
    BCD_OBJECT_TYPE_INHERITED = 2
    BCD_OBJECT_TYPE_DEVICE = 3

class BCD_APPLICATION_OBJECT_TYPE(Enum):
    BCD_APPLICATION_OBJECT_NONE = 0
    BCD_APPLICATION_OBJECT_FIRMWARE_BOOT_MANAGER = 1
    BCD_APPLICATION_OBJECT_WINDOWS_BOOT_MANAGER = 2
    BCD_APPLICATION_OBJECT_WINDOWS_BOOT_LOADER = 3
    BCD_APPLICATION_OBJECT_WINDOWS_RESUME_APPLICATION = 4
    BCD_APPLICATION_OBJECT_MEMORY_TESTER = 5
    BCD_APPLICATION_OBJECT_LEGACY_NTLDR = 6
    BCD_APPLICATION_OBJECT_LEGACY_SETUPLDR = 7
    BCD_APPLICATION_OBJECT_BOOT_SECTOR = 8
    BCD_APPLICATION_OBJECT_STARTUP_MODULE = 9
    BCD_APPLICATION_OBJECT_GENERIC_APPLICATION = 10
    BCD_APPLICATION_OBJECT_RESERVED = 1048575

class BCD_APPLICATION_IMAGE_TYPE(Enum):
    BCD_APPLICATION_IMAGE_NONE = 0
    BCD_APPLICATION_IMAGE_FIRMWARE_APPLICATION = 1
    BCD_APPLICATION_IMAGE_BOOT_APPLICATION = 2
    BCD_APPLICATION_IMAGE_LEGACY_LOADER = 3
    BCD_APPLICATION_IMAGE_REALMODE_CODE = 4

class BCD_INHERITED_CLASS_TYPE(Enum):
    BCD_INHERITED_CLASS_NONE = 0
    BCD_INHERITED_CLASS_LIBRARY = 1
    BCD_INHERITED_CLASS_APPLICATION = 2
    BCD_INHERITED_CLASS_DEVICE = 3

class BCD_COPY_FLAGS(Enum):
    BCD_COPY_NONE = 0
    BCD_COPY_COPY_CREATE_NEW_OBJECT_IDENTIFIER = 1
    BCD_COPY_COPY_DELETE_EXISTING_OBJECT = 2
    BCD_COPY_COPY_UNKNOWN_FIRMWARE_APPLICATION = 4
    BCD_COPY_IGNORE_SETUP_TEMPLATE_ELEMENTS = 8
    BCD_COPY_RETAIN_ELEMENT_DATA = 16
    BCD_COPY_MIGRATE_ELEMENT_DATA = 32

class BCD_ELEMENT_DATATYPE_FORMAT(Enum):
    BCD_ELEMENT_DATATYPE_FORMAT_UNKNOWN = 0
    BCD_ELEMENT_DATATYPE_FORMAT_DEVICE = 1  # 0x01000000
    BCD_ELEMENT_DATATYPE_FORMAT_STRING = 2  # 0x02000000
    BCD_ELEMENT_DATATYPE_FORMAT_OBJECT = 3  # 0x03000000
    BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST = 4  # 0x04000000
    BCD_ELEMENT_DATATYPE_FORMAT_INTEGER = 5  # 0x05000000
    BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN = 6  # 0x06000000
    BCD_ELEMENT_DATATYPE_FORMAT_INTEGERLIST = 7  # 0x07000000
    BCD_ELEMENT_DATATYPE_FORMAT_BINARY = 8  # 0x08000000

class BCD_ELEMENT_DATATYPE_CLASS(Enum):
    BCD_ELEMENT_DATATYPE_CLASS_NONE = 0
    BCD_ELEMENT_DATATYPE_CLASS_LIBRARY = 1
    BCD_ELEMENT_DATATYPE_CLASS_APPLICATION = 2
    BCD_ELEMENT_DATATYPE_CLASS_DEVICE = 3
    BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE = 4
    BCD_ELEMENT_DATATYPE_CLASS_OEM = 5

class BCD_ELEMENT_DEVICE_TYPE(Enum):
    BCD_ELEMENT_DEVICE_TYPE_NONE = 0
    BCD_ELEMENT_DEVICE_TYPE_BOOT_DEVICE = 1
    BCD_ELEMENT_DEVICE_TYPE_PARTITION = 2
    BCD_ELEMENT_DEVICE_TYPE_FILE = 3
    BCD_ELEMENT_DEVICE_TYPE_RAMDISK = 4
    BCD_ELEMENT_DEVICE_TYPE_UNKNOWN = 5
    BCD_ELEMENT_DEVICE_TYPE_QUALIFIED_PARTITION = 6
    BCD_ELEMENT_DEVICE_TYPE_VMBUS = 7
    BCD_ELEMENT_DEVICE_TYPE_LOCATE_DEVICE = 8
    BCD_ELEMENT_DEVICE_TYPE_URI = 9
    BCD_ELEMENT_DEVICE_TYPE_COMPOSITE = 10

class BCD_FLAGS(Enum):
    BCD_FLAG_NONE = 0
    BCD_FLAG_QUALIFIED_PARTITION = 1
    BCD_FLAG_NO_DEVICE_TRANSLATION = 2
    BCD_FLAG_ENUMERATE_INHERITED_OBJECTS = 4
    BCD_FLAG_ENUMERATE_DEVICE_OPTIONS = 8
    BCD_FLAG_OBSERVE_PRECEDENCE = 16
    BCD_FLAG_DISABLE_VHD_NT_TRANSLATION = 32
    BCD_FLAG_DISABLE_VHD_DEVICE_DETECTION = 64
    BCD_FLAG_DISABLE_POLICY_CHECKS = 128

class BcdBootMgrElementTypes(Enum):
    BcdBootMgrObjectList_DisplayOrder = 603979777
    BcdBootMgrObjectList_BootSequence = 603979778
    BcdBootMgrObject_DefaultObject = 587202563
    BcdBootMgrInteger_Timeout = 620756996
    BcdBootMgrBoolean_AttemptResume = 637534213
    BcdBootMgrObject_ResumeObject = 587202566
    BcdBootMgrObjectList_StartupSequence = 603979783
    BcdBootMgrObjectList_ToolsDisplayOrder = 603979792
    BcdBootMgrBoolean_DisplayBootMenu = 637534240
    BcdBootMgrBoolean_NoErrorDisplay = 637534241
    BcdBootMgrDevice_BcdDevice = 553648162
    BcdBootMgrString_BcdFilePath = 570425379
    BcdBootMgrBoolean_HormEnabled = 637534244
    BcdBootMgrBoolean_HiberRoot = 637534245
    BcdBootMgrString_PasswordOverride = 570425382
    BcdBootMgrString_PinpassPhraseOverride = 570425383
    BcdBootMgrBoolean_ProcessCustomActionsFirst = 637534248
    BcdBootMgrIntegerList_CustomActionsList = 654311472
    BcdBootMgrBoolean_PersistBootSequence = 637534257
    BcdBootMgrBoolean_SkipStartupSequence = 637534258

class BcdLibrary_FirstMegabytePolicy(Enum):
    FirstMegabytePolicyUseNone = 0
    FirstMegabytePolicyUseAll = 1
    FirstMegabytePolicyUsePrivate = 2

class BcdLibrary_DebuggerType(Enum):
    DebuggerSerial = 0
    Debugger1394 = 1
    DebuggerUsb = 2
    DebuggerNet = 3
    DebuggerLocal = 4

class BcdLibrary_DebuggerStartPolicy(Enum):
    DebuggerStartActive = 0
    DebuggerStartAutoEnable = 1
    DebuggerStartDisable = 2

class BcdLibrary_ConfigAccessPolicy(Enum):
    ConfigAccessPolicyDefault = 0
    ConfigAccessPolicyDisallowMmConfig = 1

class BcdLibrary_UxDisplayMessageType(Enum):
    DisplayMessageTypeDefault = 0
    DisplayMessageTypeResume = 1
    DisplayMessageTypeHyperV = 2
    DisplayMessageTypeRecovery = 3
    DisplayMessageTypeStartupRepair = 4
    DisplayMessageTypeSystemImageRecovery = 5
    DisplayMessageTypeCommandPrompt = 6
    DisplayMessageTypeSystemRestore = 7
    DisplayMessageTypePushButtonReset = 8

class BcdLibrary_SafeBoot(Enum):
    SafemodeMinimal = 0
    SafemodeNetwork = 1
    SafemodeDsRepair = 2

class BcdLibraryElementTypes(Enum):
    BcdLibraryDevice_ApplicationDevice = 285212673
    BcdLibraryString_ApplicationPath = 301989890
    BcdLibraryString_Description = 301989892
    BcdLibraryString_PreferredLocale = 301989893
    BcdLibraryObjectList_InheritedObjects = 335544326
    BcdLibraryInteger_TruncatePhysicalMemory = 352321543
    BcdLibraryObjectList_RecoverySequence = 335544328
    BcdLibraryBoolean_AutoRecoveryEnabled = 369098761
    BcdLibraryIntegerList_BadMemoryList = 385875978
    BcdLibraryBoolean_AllowBadMemoryAccess = 369098763
    BcdLibraryInteger_FirstMegabytePolicy = 352321548
    BcdLibraryInteger_RelocatePhysicalMemory = 352321549
    BcdLibraryInteger_AvoidLowPhysicalMemory = 352321550
    BcdLibraryBoolean_TraditionalKsegMappings = 369098767
    BcdLibraryBoolean_DebuggerEnabled = 369098768
    BcdLibraryInteger_DebuggerType = 352321553
    BcdLibraryInteger_SerialDebuggerPortAddress = 352321554
    BcdLibraryInteger_SerialDebuggerPort = 352321555
    BcdLibraryInteger_SerialDebuggerBaudRate = 352321556
    BcdLibraryInteger_1394DebuggerChannel = 352321557
    BcdLibraryString_UsbDebuggerTargetName = 301989910
    BcdLibraryBoolean_DebuggerIgnoreUsermodeExceptions = 369098775
    BcdLibraryInteger_DebuggerStartPolicy = 352321560
    BcdLibraryString_DebuggerBusParameters = 301989913
    BcdLibraryInteger_DebuggerNetHostIP = 352321562
    BcdLibraryInteger_DebuggerNetPort = 352321563
    BcdLibraryBoolean_DebuggerNetDhcp = 369098780
    BcdLibraryString_DebuggerNetKey = 301989917
    BcdLibraryBoolean_DebuggerNetVM = 369098782
    BcdLibraryString_DebuggerNetHostIpv6 = 301989919
    BcdLibraryBoolean_EmsEnabled = 369098784
    BcdLibraryInteger_EmsPort = 352321570
    BcdLibraryInteger_EmsBaudRate = 352321571
    BcdLibraryString_LoadOptionsString = 301989936
    BcdLibraryBoolean_AttemptNonBcdStart = 369098801
    BcdLibraryBoolean_DisplayAdvancedOptions = 369098816
    BcdLibraryBoolean_DisplayOptionsEdit = 369098817
    BcdLibraryInteger_FVEKeyRingAddress = 352321602
    BcdLibraryDevice_BsdLogDevice = 285212739
    BcdLibraryString_BsdLogPath = 301989956
    BcdLibraryBoolean_BsdPreserveLog = 369098821
    BcdLibraryBoolean_GraphicsModeDisabled = 369098822
    BcdLibraryInteger_ConfigAccessPolicy = 352321607
    BcdLibraryBoolean_DisableIntegrityChecks = 369098824
    BcdLibraryBoolean_AllowPrereleaseSignatures = 369098825
    BcdLibraryString_FontPath = 301989962
    BcdLibraryInteger_SiPolicy = 352321611
    BcdLibraryInteger_FveBandId = 352321612
    BcdLibraryBoolean_ConsoleExtendedInput = 369098832
    BcdLibraryInteger_InitialConsoleInput = 352321617
    BcdLibraryInteger_GraphicsResolution = 352321618
    BcdLibraryBoolean_RestartOnFailure = 369098835
    BcdLibraryBoolean_GraphicsForceHighestMode = 369098836
    BcdLibraryBoolean_IsolatedExecutionContext = 369098848
    BcdLibraryInteger_BootUxDisplayMessage = 352321637
    BcdLibraryInteger_BootUxDisplayMessageOverride = 352321638
    BcdLibraryBoolean_BootUxLogoDisable = 369098855
    BcdLibraryBoolean_BootUxTextDisable = 369098856
    BcdLibraryBoolean_BootUxProgressDisable = 369098857
    BcdLibraryBoolean_BootUxFadeDisable = 369098858
    BcdLibraryBoolean_BootUxReservePoolDebug = 369098859
    BcdLibraryBoolean_BootUxDisable = 369098860
    BcdLibraryInteger_BootUxFadeFrames = 352321645
    BcdLibraryBoolean_BootUxDumpStats = 369098862
    BcdLibraryBoolean_BootUxShowStats = 369098863
    BcdLibraryBoolean_MultiBootSystem = 369098865
    BcdLibraryBoolean_ForceNoKeyboard = 369098866
    BcdLibraryInteger_AliasWindowsKey = 352321651
    BcdLibraryBoolean_BootShutdownDisabled = 369098868
    BcdLibraryInteger_PerformanceFrequency = 352321653
    BcdLibraryInteger_SecurebootRawPolicy = 352321654
    BcdLibraryIntegerList_AllowedInMemorySettings = 352321655
    BcdLibraryInteger_BootUxBitmapTransitionTime = 352321657
    BcdLibraryBoolean_TwoBootImages = 369098874
    BcdLibraryBoolean_ForceFipsCrypto = 369098875
    BcdLibraryInteger_BootErrorUx = 352321661
    BcdLibraryBoolean_AllowFlightSignatures = 369098878
    BcdLibraryInteger_BootMeasurementLogFormat = 352321663
    BcdLibraryInteger_DisplayRotation = 352321664
    BcdLibraryInteger_LogControl = 352321665
    BcdLibraryBoolean_NoFirmwareSync = 369098882
    BcdLibraryDevice_WindowsSystemDevice = 285212804
    BcdLibraryBoolean_NumLockOn = 369098887
    BcdLibraryString_AdditionalCiPolicy = 301990024

class BcdTemplateElementTypes(Enum):
    BcdSetupInteger_DeviceType = 1157627905
    BcdSetupString_ApplicationRelativePath = 1107296258
    BcdSetupString_RamdiskDeviceRelativePath = 1107296259
    BcdSetupBoolean_OmitOsLoaderElements = 1174405124
    BcdSetupIntegerList_ElementsToMigrateList = 1191182342
    BcdSetupBoolean_RecoveryOs = 1174405136

class BcdOSLoader_NxPolicy(Enum):
    NxPolicyOptIn = 0
    NxPolicyOptOut = 1
    NxPolicyAlwaysOff = 2
    NxPolicyAlwaysOn = 3

class BcdOSLoader_PAEPolicy(Enum):
    PaePolicyDefault = 0
    PaePolicyForceEnable = 1
    PaePolicyForceDisable = 2

class BcdOSLoader_BootStatusPolicy(Enum):
    BootStatusPolicyDisplayAllFailures = 0
    BootStatusPolicyIgnoreAllFailures = 1
    BootStatusPolicyIgnoreShutdownFailures = 2
    BootStatusPolicyIgnoreBootFailures = 3
    BootStatusPolicyIgnoreCheckpointFailures = 4
    BootStatusPolicyDisplayShutdownFailures = 5
    BootStatusPolicyDisplayBootFailures = 6
    BootStatusPolicyDisplayCheckpointFailures = 7

class BcdOSLoaderElementTypes(Enum):
    BcdOSLoaderDevice_OSDevice = 553648129
    BcdOSLoaderString_SystemRoot = 570425346
    BcdOSLoaderObject_AssociatedResumeObject = 587202563
    BcdOSLoaderBoolean_StampDisks = 637534212
    BcdOSLoaderBoolean_DetectKernelAndHal = 637534224
    BcdOSLoaderString_KernelPath = 570425361
    BcdOSLoaderString_HalPath = 570425362
    BcdOSLoaderString_DbgTransportPath = 570425363
    BcdOSLoaderInteger_NxPolicy = 620757024
    BcdOSLoaderInteger_PAEPolicy = 620757025
    BcdOSLoaderBoolean_WinPEMode = 637534242
    BcdOSLoaderBoolean_DisableCrashAutoReboot = 637534244
    BcdOSLoaderBoolean_UseLastGoodSettings = 637534245
    BcdOSLoaderBoolean_DisableCodeIntegrityChecks = 637534246
    BcdOSLoaderBoolean_AllowPrereleaseSignatures = 637534247
    BcdOSLoaderBoolean_NoLowMemory = 637534256
    BcdOSLoaderInteger_RemoveMemory = 620757041
    BcdOSLoaderInteger_IncreaseUserVa = 620757042
    BcdOSLoaderInteger_PerformaceDataMemory = 620757043
    BcdOSLoaderBoolean_UseVgaDriver = 637534272
    BcdOSLoaderBoolean_DisableBootDisplay = 637534273
    BcdOSLoaderBoolean_DisableVesaBios = 637534274
    BcdOSLoaderBoolean_DisableVgaMode = 637534275
    BcdOSLoaderInteger_ClusterModeAddressing = 620757072
    BcdOSLoaderBoolean_UsePhysicalDestination = 637534289
    BcdOSLoaderInteger_RestrictApicCluster = 620757074
    BcdOSLoaderString_OSLoaderTypeEVStore = 570425427
    BcdOSLoaderBoolean_UseLegacyApicMode = 637534292
    BcdOSLoaderInteger_X2ApicPolicy = 620757077
    BcdOSLoaderBoolean_UseBootProcessorOnly = 637534304
    BcdOSLoaderInteger_NumberOfProcessors = 620757089
    BcdOSLoaderBoolean_ForceMaximumProcessors = 637534306
    BcdOSLoaderBoolean_ProcessorConfigurationFlags = 620757091
    BcdOSLoaderBoolean_MaximizeGroupsCreated = 637534308
    BcdOSLoaderBoolean_ForceGroupAwareness = 637534309
    BcdOSLoaderInteger_GroupSize = 620757094
    BcdOSLoaderInteger_UseFirmwarePciSettings = 637534320
    BcdOSLoaderInteger_MsiPolicy = 620757105
    BcdOSLoaderInteger_PciExpressPolicy = 620757106
    BcdOSLoaderInteger_SafeBoot = 620757120
    BcdOSLoaderBoolean_SafeBootAlternateShell = 637534337
    BcdOSLoaderBoolean_BootLogInitialization = 637534352
    BcdOSLoaderBoolean_VerboseObjectLoadMode = 637534353
    BcdOSLoaderBoolean_KernelDebuggerEnabled = 637534368
    BcdOSLoaderBoolean_DebuggerHalBreakpoint = 637534369
    BcdOSLoaderBoolean_UsePlatformClock = 637534370
    BcdOSLoaderBoolean_ForceLegacyPlatform = 637534371
    BcdOSLoaderBoolean_UsePlatformTick = 637534372
    BcdOSLoaderBoolean_DisableDynamicTick = 637534373
    BcdOSLoaderInteger_TscSyncPolicy = 620757158
    BcdOSLoaderBoolean_EmsEnabled = 637534384
    BcdOSLoaderInteger_ForceFailure = 620757184
    BcdOSLoaderInteger_DriverLoadFailurePolicy = 620757185
    BcdOSLoaderInteger_BootMenuPolicy = 620757186
    BcdOSLoaderBoolean_AdvancedOptionsOneTime = 637534403
    BcdOSLoaderBoolean_OptionsEditOneTime = 637534404
    BcdOSLoaderInteger_BootStatusPolicy = 620757216
    BcdOSLoaderBoolean_DisableElamDrivers = 637534433
    BcdOSLoaderInteger_HypervisorLaunchType = 620757232
    BcdOSLoaderString_HypervisorPath = 620757233
    BcdOSLoaderBoolean_HypervisorDebuggerEnabled = 637534450
    BcdOSLoaderInteger_HypervisorDebuggerType = 620757235
    BcdOSLoaderInteger_HypervisorDebuggerPortNumber = 620757236
    BcdOSLoaderInteger_HypervisorDebuggerBaudrate = 620757237
    BcdOSLoaderInteger_HypervisorDebugger1394Channel = 620757238
    BcdOSLoaderInteger_BootUxPolicy = 620757239
    BcdOSLoaderInteger_HypervisorSlatDisabled = 570425592
    BcdOSLoaderString_HypervisorDebuggerBusParams = 570425593
    BcdOSLoaderInteger_HypervisorNumProc = 620757242
    BcdOSLoaderInteger_HypervisorRootProcPerNode = 620757243
    BcdOSLoaderBoolean_HypervisorUseLargeVTlb = 637534460
    BcdOSLoaderInteger_HypervisorDebuggerNetHostIp = 620757245
    BcdOSLoaderInteger_HypervisorDebuggerNetHostPort = 620757246
    BcdOSLoaderInteger_HypervisorDebuggerPages = 620757247
    BcdOSLoaderInteger_TpmBootEntropyPolicy = 620757248
    BcdOSLoaderString_HypervisorDebuggerNetKey = 570425616
    BcdOSLoaderString_HypervisorProductSkuType = 570425618
    BcdOSLoaderInteger_HypervisorRootProc = 570425619
    BcdOSLoaderBoolean_HypervisorDebuggerNetDhcp = 637534484
    BcdOSLoaderInteger_HypervisorIommuPolicy = 620757269
    BcdOSLoaderBoolean_HypervisorUseVApic = 637534486
    BcdOSLoaderString_HypervisorLoadOptions = 570425623
    BcdOSLoaderInteger_HypervisorMsrFilterPolicy = 620757272
    BcdOSLoaderInteger_HypervisorMmioNxPolicy = 620757273
    BcdOSLoaderInteger_HypervisorSchedulerType = 620757274
    BcdOSLoaderString_HypervisorRootProcNumaNodes = 570425627
    BcdOSLoaderInteger_HypervisorPerfmon = 620757276
    BcdOSLoaderInteger_HypervisorRootProcPerCore = 620757277
    BcdOSLoaderString_HypervisorRootProcNumaNodeLps = 570425630
    BcdOSLoaderInteger_XSavePolicy = 620757280
    BcdOSLoaderInteger_XSaveAddFeature0 = 620757281
    BcdOSLoaderInteger_XSaveAddFeature1 = 620757282
    BcdOSLoaderInteger_XSaveAddFeature2 = 620757283
    BcdOSLoaderInteger_XSaveAddFeature3 = 620757284
    BcdOSLoaderInteger_XSaveAddFeature4 = 620757285
    BcdOSLoaderInteger_XSaveAddFeature5 = 620757286
    BcdOSLoaderInteger_XSaveAddFeature6 = 620757287
    BcdOSLoaderInteger_XSaveAddFeature7 = 620757288
    BcdOSLoaderInteger_XSaveRemoveFeature = 620757289
    BcdOSLoaderInteger_XSaveProcessorsMask = 620757290
    BcdOSLoaderInteger_XSaveDisable = 620757291
    BcdOSLoaderInteger_KernelDebuggerType = 620757292
    BcdOSLoaderString_KernelDebuggerBusParameters = 570425645
    BcdOSLoaderInteger_KernelDebuggerPortAddress = 620757294
    BcdOSLoaderInteger_KernelDebuggerPortNumber = 620757295
    BcdOSLoaderInteger_ClaimedTpmCounter = 620757296
    BcdOSLoaderInteger_KernelDebugger1394Channel = 620757297
    BcdOSLoaderString_KernelDebuggerUsbTargetname = 570425650
    BcdOSLoaderInteger_KernelDebuggerNetHostIp = 620757299
    BcdOSLoaderInteger_KernelDebuggerNetHostPort = 620757300
    BcdOSLoaderBoolean_KernelDebuggerNetDhcp = 637534517
    BcdOSLoaderString_KernelDebuggerNetKey = 570425654
    BcdOSLoaderString_IMCHiveName = 570425655
    BcdOSLoaderDevice_IMCDevice = 553648440
    BcdOSLoaderInteger_KernelDebuggerBaudrate = 620757305
    BcdOSLoaderString_ManufacturingMode = 570425664
    BcdOSLoaderBoolean_EventLoggingEnabled = 637534529
    BcdOSLoaderInteger_VsmLaunchType = 620757314
    BcdOSLoaderInteger_HypervisorEnforcedCodeIntegrity = 620757316
    BcdOSLoaderBoolean_DtraceEnabled = 637534533
    BcdOSLoaderDevice_SystemDataDevice = 553648464
    BcdOSLoaderDevice_OsArcDevice = 553648465
    BcdOSLoaderDevice_OsDataDevice = 553648467
    BcdOSLoaderDevice_BspDevice = 553648468
    BcdOSLoaderDevice_BspFilepath = 553648469
    BcdOSLoaderString_KernelDebuggerNetHostIpv6 = 570425686
    BcdOSLoaderString_HypervisorDebuggerNetHostIpv6 = 570425697

class MEMORY_INFORMATION_CLASS(Enum):
    MemoryBasicInformation = 0  # MEMORY_BASIC_INFORMATION
    MemoryWorkingSetInformation = 1  # MEMORY_WORKING_SET_INFORMATION
    MemoryMappedFilenameInformation = 2  # UNICODE_STRING
    MemoryRegionInformation = 3  # MEMORY_REGION_INFORMATION
    MemoryWorkingSetExInformation = 4  # MEMORY_WORKING_SET_EX_INFORMATION // since VISTA
    MemorySharedCommitInformation = 5  # MEMORY_SHARED_COMMIT_INFORMATION // since WIN8
    MemoryImageInformation = 6  # MEMORY_IMAGE_INFORMATION
    MemoryRegionInformationEx = 7  # MEMORY_REGION_INFORMATION
    MemoryPrivilegedBasicInformation = 8
    MemoryEnclaveImageInformation = 9  # MEMORY_ENCLAVE_IMAGE_INFORMATION // since REDSTONE3
    MemoryBasicInformationCapped = 10  # 10
    MemoryPhysicalContiguityInformation = 11  # MEMORY_PHYSICAL_CONTIGUITY_INFORMATION // since 20H1
    MemoryBadInformation = 12  # since WIN11
    MemoryBadInformationAllProcesses = 13  # since 22H1
    MaxMemoryInfoClass = 14

class MEMORY_WORKING_SET_EX_LOCATION(Enum):
    MemoryLocationInvalid = 0
    MemoryLocationResident = 1
    MemoryLocationPagefile = 2
    MemoryLocationReserved = 3

class MEMORY_PHYSICAL_CONTIGUITY_UNIT_STATE(Enum):
    MemoryNotContiguous = 0
    MemoryAlignedAndContiguous = 1
    MemoryNotResident = 2
    MemoryNotEligibleToMakeContiguous = 3
    MemoryContiguityStateMax = 4

class SECTION_INFORMATION_CLASS(Enum):
    SectionBasicInformation = 0  # q; SECTION_BASIC_INFORMATION
    SectionImageInformation = 1  # q; SECTION_IMAGE_INFORMATION
    SectionRelocationInformation = 2  # q; PVOID RelocationAddress // name:wow64:whNtQuerySection_SectionRelocationInformation // since WIN7
    SectionOriginalBaseInformation = 3  # PVOID BaseAddress
    SectionInternalImageInformation = 4  # SECTION_INTERNAL_IMAGE_INFORMATION // since REDSTONE2
    MaxSectionInfoClass = 5

class SECTION_INHERIT(Enum):
    ViewShare = 1
    ViewUnmap = 2

class VIRTUAL_MEMORY_INFORMATION_CLASS(Enum):
    VmPrefetchInformation = 0  # ULONG
    VmPagePriorityInformation = 1  # OFFER_PRIORITY
    VmCfgCallTargetInformation = 2  # CFG_CALL_TARGET_LIST_INFORMATION // REDSTONE2
    VmPageDirtyStateInformation = 3  # REDSTONE3
    VmImageHotPatchInformation = 4  # 19H1
    VmPhysicalContiguityInformation = 5  # 20H1
    VmVirtualMachinePrepopulateInformation = 6
    VmRemoveFromWorkingSetInformation = 7
    MaxVmInfoClass = 8

class PARTITION_INFORMATION_CLASS(Enum):
    SystemMemoryPartitionInformation = 0  # q: MEMORY_PARTITION_CONFIGURATION_INFORMATION
    SystemMemoryPartitionMoveMemory = 1  # s: MEMORY_PARTITION_TRANSFER_INFORMATION
    SystemMemoryPartitionAddPagefile = 2  # s: MEMORY_PARTITION_PAGEFILE_INFORMATION
    SystemMemoryPartitionCombineMemory = 3  # q; s: MEMORY_PARTITION_PAGE_COMBINE_INFORMATION
    SystemMemoryPartitionInitialAddMemory = 4  # q; s: MEMORY_PARTITION_INITIAL_ADD_INFORMATION
    SystemMemoryPartitionGetMemoryEvents = 5  # MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION // since REDSTONE2
    SystemMemoryPartitionSetAttributes = 6
    SystemMemoryPartitionNodeInformation = 7
    SystemMemoryPartitionCreateLargePages = 8
    SystemMemoryPartitionDedicatedMemoryInformation = 9
    SystemMemoryPartitionOpenDedicatedMemory = 10  # 10
    SystemMemoryPartitionMemoryChargeAttributes = 11
    SystemMemoryPartitionClearAttributes = 12
    SystemMemoryPartitionSetMemoryThresholds = 13  # since WIN11
    SystemMemoryPartitionMax = 14

class OBJECT_INFORMATION_CLASS(Enum):
    ObjectBasicInformation = 0  # q: OBJECT_BASIC_INFORMATION
    ObjectNameInformation = 1  # q: OBJECT_NAME_INFORMATION
    ObjectTypeInformation = 2  # q: OBJECT_TYPE_INFORMATION
    ObjectTypesInformation = 3  # q: OBJECT_TYPES_INFORMATION
    ObjectHandleFlagInformation = 4  # qs: OBJECT_HANDLE_FLAG_INFORMATION
    ObjectSessionInformation = 5  # s: void // change object session // (requires SeTcbPrivilege)
    ObjectSessionObjectInformation = 6  # s: void // change object session // (requires SeTcbPrivilege)
    MaxObjectInfoClass = 7

class BOUNDARY_ENTRY_TYPE(Enum):
    OBNS_Invalid = 0
    OBNS_Name = 1
    OBNS_SID = 2
    OBNS_IL = 3

class SYMBOLIC_LINK_INFO_CLASS(Enum):
    SymbolicLinkGlobalInformation = 1  # s: ULONG
    SymbolicLinkAccessMask = 2  # s: ACCESS_MASK
    MaxnSymbolicLinkInfoClass = 3

class PROCESSINFOCLASS(Enum):
    ProcessBasicInformation = 0  # q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION
    ProcessQuotaLimits = 1  # qs: QUOTA_LIMITS, QUOTA_LIMITS_EX
    ProcessIoCounters = 2  # q: IO_COUNTERS
    ProcessVmCounters = 3  # q: VM_COUNTERS, VM_COUNTERS_EX, VM_COUNTERS_EX2
    ProcessTimes = 4  # q: KERNEL_USER_TIMES
    ProcessBasePriority = 5  # s: KPRIORITY
    ProcessRaisePriority = 6  # s: ULONG
    ProcessDebugPort = 7  # q: HANDLE
    ProcessExceptionPort = 8  # s: PROCESS_EXCEPTION_PORT (requires SeTcbPrivilege)
    ProcessAccessToken = 9  # s: PROCESS_ACCESS_TOKEN
    ProcessLdtInformation = 10  # qs: PROCESS_LDT_INFORMATION // 10
    ProcessLdtSize = 11  # s: PROCESS_LDT_SIZE
    ProcessDefaultHardErrorMode = 12  # qs: ULONG
    ProcessIoPortHandlers = 13  # (kernel-mode only) // PROCESS_IO_PORT_HANDLER_INFORMATION
    ProcessPooledUsageAndLimits = 14  # q: POOLED_USAGE_AND_LIMITS
    ProcessWorkingSetWatch = 15  # q: PROCESS_WS_WATCH_INFORMATION[]; s: void
    ProcessUserModeIOPL = 16  # qs: ULONG (requires SeTcbPrivilege)
    ProcessEnableAlignmentFaultFixup = 17  # s: BOOLEAN
    ProcessPriorityClass = 18  # qs: PROCESS_PRIORITY_CLASS
    ProcessWx86Information = 19  # qs: ULONG (requires SeTcbPrivilege) (VdmAllowed)
    ProcessHandleCount = 20  # q: ULONG, PROCESS_HANDLE_INFORMATION // 20
    ProcessAffinityMask = 21  # (q >WIN7)s: KAFFINITY, qs: GROUP_AFFINITY
    ProcessPriorityBoost = 22  # qs: ULONG
    ProcessDeviceMap = 23  # qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX
    ProcessSessionInformation = 24  # q: PROCESS_SESSION_INFORMATION
    ProcessForegroundInformation = 25  # s: PROCESS_FOREGROUND_BACKGROUND
    ProcessWow64Information = 26  # q: ULONG_PTR
    ProcessImageFileName = 27  # q: UNICODE_STRING
    ProcessLUIDDeviceMapsEnabled = 28  # q: ULONG
    ProcessBreakOnTermination = 29  # qs: ULONG
    ProcessDebugObjectHandle = 30  # q: HANDLE // 30
    ProcessDebugFlags = 31  # qs: ULONG
    ProcessHandleTracing = 32  # q: PROCESS_HANDLE_TRACING_QUERY; s: size 0 disables, otherwise enables
    ProcessIoPriority = 33  # qs: IO_PRIORITY_HINT
    ProcessExecuteFlags = 34  # qs: ULONG
    ProcessTlsInformation = 35  # PROCESS_TLS_INFORMATION // ProcessResourceManagement
    ProcessCookie = 36  # q: ULONG
    ProcessImageInformation = 37  # q: SECTION_IMAGE_INFORMATION
    ProcessCycleTime = 38  # q: PROCESS_CYCLE_TIME_INFORMATION // since VISTA
    ProcessPagePriority = 39  # qs: PAGE_PRIORITY_INFORMATION
    ProcessInstrumentationCallback = 40  # s: PVOID or PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION // 40
    ProcessThreadStackAllocation = 41  # s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX
    ProcessWorkingSetWatchEx = 42  # q: PROCESS_WS_WATCH_INFORMATION_EX[]
    ProcessImageFileNameWin32 = 43  # q: UNICODE_STRING
    ProcessImageFileMapping = 44  # q: HANDLE (input)
    ProcessAffinityUpdateMode = 45  # qs: PROCESS_AFFINITY_UPDATE_MODE
    ProcessMemoryAllocationMode = 46  # qs: PROCESS_MEMORY_ALLOCATION_MODE
    ProcessGroupInformation = 47  # q: USHORT[]
    ProcessTokenVirtualizationEnabled = 48  # s: ULONG
    ProcessConsoleHostProcess = 49  # q: ULONG_PTR // ProcessOwnerInformation
    ProcessWindowInformation = 50  # q: PROCESS_WINDOW_INFORMATION // 50
    ProcessHandleInformation = 51  # q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8
    ProcessMitigationPolicy = 52  # s: PROCESS_MITIGATION_POLICY_INFORMATION
    ProcessDynamicFunctionTableInformation = 53
    ProcessHandleCheckingMode = 54  # qs: ULONG; s: 0 disables, otherwise enables
    ProcessKeepAliveCount = 55  # q: PROCESS_KEEPALIVE_COUNT_INFORMATION
    ProcessRevokeFileHandles = 56  # s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION
    ProcessWorkingSetControl = 57  # s: PROCESS_WORKING_SET_CONTROL
    ProcessHandleTable = 58  # q: ULONG[] // since WINBLUE
    ProcessCheckStackExtentsMode = 59  # qs: ULONG // KPROCESS->CheckStackExtents (CFG)
    ProcessCommandLineInformation = 60  # q: UNICODE_STRING // 60
    ProcessProtectionInformation = 61  # q: PS_PROTECTION
    ProcessMemoryExhaustion = 62  # PROCESS_MEMORY_EXHAUSTION_INFO // since THRESHOLD
    ProcessFaultInformation = 63  # PROCESS_FAULT_INFORMATION
    ProcessTelemetryIdInformation = 64  # q: PROCESS_TELEMETRY_ID_INFORMATION
    ProcessCommitReleaseInformation = 65  # PROCESS_COMMIT_RELEASE_INFORMATION
    ProcessDefaultCpuSetsInformation = 66  # SYSTEM_CPU_SET_INFORMATION[5]
    ProcessAllowedCpuSetsInformation = 67  # SYSTEM_CPU_SET_INFORMATION[5]
    ProcessSubsystemProcess = 68
    ProcessJobMemoryInformation = 69  # q: PROCESS_JOB_MEMORY_INFO
    ProcessInPrivate = 70  # s: void // ETW // since THRESHOLD2 // 70
    ProcessRaiseUMExceptionOnInvalidHandleClose = 71  # qs: ULONG; s: 0 disables, otherwise enables
    ProcessIumChallengeResponse = 72
    ProcessChildProcessInformation = 73  # q: PROCESS_CHILD_PROCESS_INFORMATION
    ProcessHighGraphicsPriorityInformation = 74  # qs: BOOLEAN (requires SeTcbPrivilege)
    ProcessSubsystemInformation = 75  # q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
    ProcessEnergyValues = 76  # q: PROCESS_ENERGY_VALUES, PROCESS_EXTENDED_ENERGY_VALUES
    ProcessPowerThrottlingState = 77  # qs: POWER_THROTTLING_PROCESS_STATE
    ProcessReserved3Information = 78  # ProcessActivityThrottlePolicy // PROCESS_ACTIVITY_THROTTLE_POLICY
    ProcessWin32kSyscallFilterInformation = 79  # q: WIN32K_SYSCALL_FILTER
    ProcessDisableSystemAllowedCpuSets = 80  # 80
    ProcessWakeInformation = 81  # PROCESS_WAKE_INFORMATION
    ProcessEnergyTrackingState = 82  # PROCESS_ENERGY_TRACKING_STATE
    ProcessManageWritesToExecutableMemory = 83  # MANAGE_WRITES_TO_EXECUTABLE_MEMORY // since REDSTONE3
    ProcessCaptureTrustletLiveDump = 84
    ProcessTelemetryCoverage = 85
    ProcessEnclaveInformation = 86
    ProcessEnableReadWriteVmLogging = 87  # PROCESS_READWRITEVM_LOGGING_INFORMATION
    ProcessUptimeInformation = 88  # q: PROCESS_UPTIME_INFORMATION
    ProcessImageSection = 89  # q: HANDLE
    ProcessDebugAuthInformation = 90  # since REDSTONE4 // 90
    ProcessSystemResourceManagement = 91  # PROCESS_SYSTEM_RESOURCE_MANAGEMENT
    ProcessSequenceNumber = 92  # q: ULONGLONG
    ProcessLoaderDetour = 93  # since REDSTONE5
    ProcessSecurityDomainInformation = 94  # PROCESS_SECURITY_DOMAIN_INFORMATION
    ProcessCombineSecurityDomainsInformation = 95  # PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION
    ProcessEnableLogging = 96  # PROCESS_LOGGING_INFORMATION
    ProcessLeapSecondInformation = 97  # PROCESS_LEAP_SECOND_INFORMATION
    ProcessFiberShadowStackAllocation = 98  # PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION // since 19H1
    ProcessFreeFiberShadowStackAllocation = 99  # PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION
    ProcessAltSystemCallInformation = 100  # qs: BOOLEAN (kernel-mode only) // INT2E // since 20H1 // 100
    ProcessDynamicEHContinuationTargets = 101  # PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION
    ProcessDynamicEnforcedCetCompatibleRanges = 102  # PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE_INFORMATION // since 20H2
    ProcessCreateStateChange = 103  # since WIN11
    ProcessApplyStateChange = 104
    ProcessEnableOptionalXStateFeatures = 105
    ProcessAltPrefetchParam = 106  # since 22H1
    ProcessAssignCpuPartitions = 107
    ProcessPriorityClassEx = 108  # s: PROCESS_PRIORITY_CLASS_EX
    ProcessMembershipInformation = 109
    ProcessEffectiveIoPriority = 110  # q: IO_PRIORITY_HINT
    ProcessEffectivePagePriority = 111  # q: ULONG
    MaxProcessInfoClass = 112

class THREADINFOCLASS(Enum):
    ThreadBasicInformation = 0  # q: THREAD_BASIC_INFORMATION
    ThreadTimes = 1  # q: KERNEL_USER_TIMES
    ThreadPriority = 2  # s: KPRIORITY (requires SeIncreaseBasePriorityPrivilege)
    ThreadBasePriority = 3  # s: KPRIORITY
    ThreadAffinityMask = 4  # s: KAFFINITY
    ThreadImpersonationToken = 5  # s: HANDLE
    ThreadDescriptorTableEntry = 6  # q: DESCRIPTOR_TABLE_ENTRY (or WOW64_DESCRIPTOR_TABLE_ENTRY)
    ThreadEnableAlignmentFaultFixup = 7  # s: BOOLEAN
    ThreadEventPair = 8
    ThreadQuerySetWin32StartAddress = 9  # q: ULONG_PTR
    ThreadZeroTlsCell = 10  # s: ULONG // TlsIndex // 10
    ThreadPerformanceCount = 11  # q: LARGE_INTEGER
    ThreadAmILastThread = 12  # q: ULONG
    ThreadIdealProcessor = 13  # s: ULONG
    ThreadPriorityBoost = 14  # qs: ULONG
    ThreadSetTlsArrayAddress = 15  # s: ULONG_PTR
    ThreadIsIoPending = 16  # q: ULONG
    ThreadHideFromDebugger = 17  # q: BOOLEAN; s: void
    ThreadBreakOnTermination = 18  # qs: ULONG
    ThreadSwitchLegacyState = 19  # s: void // NtCurrentThread // NPX/FPU
    ThreadIsTerminated = 20  # q: ULONG // 20
    ThreadLastSystemCall = 21  # q: THREAD_LAST_SYSCALL_INFORMATION
    ThreadIoPriority = 22  # qs: IO_PRIORITY_HINT (requires SeIncreaseBasePriorityPrivilege)
    ThreadCycleTime = 23  # q: THREAD_CYCLE_TIME_INFORMATION
    ThreadPagePriority = 24  # qs: PAGE_PRIORITY_INFORMATION
    ThreadActualBasePriority = 25  # s: LONG (requires SeIncreaseBasePriorityPrivilege)
    ThreadTebInformation = 26  # q: THREAD_TEB_INFORMATION (requires THREAD_GET_CONTEXT + THREAD_SET_CONTEXT)
    ThreadCSwitchMon = 27
    ThreadCSwitchPmu = 28
    ThreadWow64Context = 29  # qs: WOW64_CONTEXT
    ThreadGroupInformation = 30  # qs: GROUP_AFFINITY // 30
    ThreadUmsInformation = 31  # q: THREAD_UMS_INFORMATION
    ThreadCounterProfiling = 32  # q: BOOLEAN; s: THREAD_PROFILING_INFORMATION?
    ThreadIdealProcessorEx = 33  # qs: PROCESSOR_NUMBER; s: previous PROCESSOR_NUMBER on return
    ThreadCpuAccountingInformation = 34  # q: BOOLEAN; s: HANDLE (NtOpenSession) // NtCurrentThread // since WIN8
    ThreadSuspendCount = 35  # q: ULONG // since WINBLUE
    ThreadHeterogeneousCpuPolicy = 36  # q: KHETERO_CPU_POLICY // since THRESHOLD
    ThreadContainerId = 37  # q: GUID
    ThreadNameInformation = 38  # qs: THREAD_NAME_INFORMATION
    ThreadSelectedCpuSets = 39
    ThreadSystemThreadInformation = 40  # q: SYSTEM_THREAD_INFORMATION // 40
    ThreadActualGroupAffinity = 41  # q: GROUP_AFFINITY // since THRESHOLD2
    ThreadDynamicCodePolicyInfo = 42  # q: ULONG; s: ULONG (NtCurrentThread)
    ThreadExplicitCaseSensitivity = 43  # qs: ULONG; s: 0 disables, otherwise enables
    ThreadWorkOnBehalfTicket = 44  # RTL_WORK_ON_BEHALF_TICKET_EX
    ThreadSubsystemInformation = 45  # q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
    ThreadDbgkWerReportActive = 46  # s: ULONG; s: 0 disables, otherwise enables
    ThreadAttachContainer = 47  # s: HANDLE (job object) // NtCurrentThread
    ThreadManageWritesToExecutableMemory = 48  # MANAGE_WRITES_TO_EXECUTABLE_MEMORY // since REDSTONE3
    ThreadPowerThrottlingState = 49  # POWER_THROTTLING_THREAD_STATE
    ThreadWorkloadClass = 50  # THREAD_WORKLOAD_CLASS // since REDSTONE5 // 50
    ThreadCreateStateChange = 51  # since WIN11
    ThreadApplyStateChange = 52
    ThreadStrongerBadHandleChecks = 53  # since 22H1
    ThreadEffectiveIoPriority = 54  # q: IO_PRIORITY_HINT
    ThreadEffectivePagePriority = 55  # q: ULONG
    MaxThreadInfoClass = 56

class PROCESS_TLS_INFORMATION_TYPE(Enum):
    ProcessTlsReplaceIndex = 0
    ProcessTlsReplaceVector = 1
    MaxProcessTlsOperation = 2

class PROCESS_WORKING_SET_OPERATION(Enum):
    ProcessWorkingSetSwap = 0
    ProcessWorkingSetEmpty = 1
    ProcessWorkingSetOperationMax = 2

class PS_PROTECTED_TYPE(Enum):
    PsProtectedTypeNone = 0
    PsProtectedTypeProtectedLight = 1
    PsProtectedTypeProtected = 2
    PsProtectedTypeMax = 3

class PS_PROTECTED_SIGNER(Enum):
    PsProtectedSignerNone = 0
    PsProtectedSignerAuthenticode = 1
    PsProtectedSignerCodeGen = 2
    PsProtectedSignerAntimalware = 3
    PsProtectedSignerLsa = 4
    PsProtectedSignerWindows = 5
    PsProtectedSignerWinTcb = 6
    PsProtectedSignerWinSystem = 7
    PsProtectedSignerApp = 8
    PsProtectedSignerMax = 9

class THREAD_UMS_INFORMATION_COMMAND(Enum):
    UmsInformationCommandInvalid = 0
    UmsInformationCommandAttach = 1
    UmsInformationCommandDetach = 2
    UmsInformationCommandQuery = 3

class SUBSYSTEM_INFORMATION_TYPE(Enum):
    SubsystemInformationTypeWin32 = 0
    SubsystemInformationTypeWSL = 1
    MaxSubsystemInformationType = 2

class THREAD_WORKLOAD_CLASS(Enum):
    ThreadWorkloadClassDefault = 0
    ThreadWorkloadClassGraphics = 1
    MaxThreadWorkloadClass = 2

class PROCESS_STATE_CHANGE_TYPE(Enum):
    ProcessStateChangeSuspend = 0
    ProcessStateChangeResume = 1
    ProcessStateChangeMax = 2

class THREAD_STATE_CHANGE_TYPE(Enum):
    ThreadStateChangeSuspend = 0
    ThreadStateChangeResume = 1
    ThreadStateChangeMax = 2

class SE_SAFE_OPEN_PROMPT_EXPERIENCE_RESULTS(Enum):
    SeSafeOpenExperienceNone = 0
    SeSafeOpenExperienceCalled = 1
    SeSafeOpenExperienceAppRepCalled = 2
    SeSafeOpenExperiencePromptDisplayed = 4
    SeSafeOpenExperienceUAC = 8
    SeSafeOpenExperienceUninstaller = 16
    SeSafeOpenExperienceIgnoreUnknownOrBad = 32
    SeSafeOpenExperienceDefenderTrustedInstaller = 64
    SeSafeOpenExperienceMOTWPresent = 128

class PS_ATTRIBUTE_NUM(Enum):
    PsAttributeParentProcess = 0  # in HANDLE
    PsAttributeDebugObject = 1  # in HANDLE
    PsAttributeToken = 2  # in HANDLE
    PsAttributeClientId = 3  # out PCLIENT_ID
    PsAttributeTebAddress = 4  # out PTEB *
    PsAttributeImageName = 5  # in PWSTR
    PsAttributeImageInfo = 6  # out PSECTION_IMAGE_INFORMATION
    PsAttributeMemoryReserve = 7  # in PPS_MEMORY_RESERVE
    PsAttributePriorityClass = 8  # in UCHAR
    PsAttributeErrorMode = 9  # in ULONG
    PsAttributeStdHandleInfo = 10  # 10, in PPS_STD_HANDLE_INFO
    PsAttributeHandleList = 11  # in HANDLE[]
    PsAttributeGroupAffinity = 12  # in PGROUP_AFFINITY
    PsAttributePreferredNode = 13  # in PUSHORT
    PsAttributeIdealProcessor = 14  # in PPROCESSOR_NUMBER
    PsAttributeUmsThread = 15  # ? in PUMS_CREATE_THREAD_ATTRIBUTES
    PsAttributeMitigationOptions = 16  # in PPS_MITIGATION_OPTIONS_MAP (PROCESS_CREATION_MITIGATION_POLICY_*) // since WIN8
    PsAttributeProtectionLevel = 17  # in PS_PROTECTION // since WINBLUE
    PsAttributeSecureProcess = 18  # in PPS_TRUSTLET_CREATE_ATTRIBUTES, since THRESHOLD
    PsAttributeJobList = 19  # in HANDLE[]
    PsAttributeChildProcessPolicy = 20  # 20, in PULONG (PROCESS_CREATION_CHILD_PROCESS_*) // since THRESHOLD2
    PsAttributeAllApplicationPackagesPolicy = 21  # in PULONG (PROCESS_CREATION_ALL_APPLICATION_PACKAGES_*) // since REDSTONE
    PsAttributeWin32kFilter = 22  # in PWIN32K_SYSCALL_FILTER
    PsAttributeSafeOpenPromptOriginClaim = 23  # in
    PsAttributeBnoIsolation = 24  # in PPS_BNO_ISOLATION_PARAMETERS // since REDSTONE2
    PsAttributeDesktopAppPolicy = 25  # in PULONG (PROCESS_CREATION_DESKTOP_APP_*)
    PsAttributeChpe = 26  # in BOOLEAN // since REDSTONE3
    PsAttributeMitigationAuditOptions = 27  # in PPS_MITIGATION_AUDIT_OPTIONS_MAP (PROCESS_CREATION_MITIGATION_AUDIT_POLICY_*) // since 21H1
    PsAttributeMachineType = 28  # in WORD // since 21H2
    PsAttributeComponentFilter = 29
    PsAttributeEnableOptionalXStateFeatures = 30  # since WIN11
    PsAttributeMax = 31

class PS_STD_HANDLE_STATE(Enum):
    PsNeverDuplicate = 0
    PsRequestDuplicate = 1  # duplicate standard handles specified by PseudoHandleMask, and only if StdHandleSubsystemType matches the image subsystem
    PsAlwaysDuplicate = 2  # always duplicate standard handles
    PsMaxStdHandleStates = 3

class PS_MITIGATION_OPTION(Enum):
    PS_MITIGATION_OPTION_NX = 0
    PS_MITIGATION_OPTION_SEHOP = 1
    PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES = 2
    PS_MITIGATION_OPTION_HEAP_TERMINATE = 3
    PS_MITIGATION_OPTION_BOTTOM_UP_ASLR = 4
    PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR = 5
    PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS = 6
    PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE = 7
    PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE = 8
    PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE = 9
    PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD = 10
    PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES = 11
    PS_MITIGATION_OPTION_FONT_DISABLE = 12
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE = 13
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL = 14
    PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32 = 15
    PS_MITIGATION_OPTION_RETURN_FLOW_GUARD = 16
    PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY = 17
    PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD = 18
    PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT = 19
    PS_MITIGATION_OPTION_ROP_STACKPIVOT = 20  # since REDSTONE3
    PS_MITIGATION_OPTION_ROP_CALLER_CHECK = 21
    PS_MITIGATION_OPTION_ROP_SIMEXEC = 22
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER = 23
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS = 24
    PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION = 25
    PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER = 26
    PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION = 27
    PS_MITIGATION_OPTION_RESTRICT_INDIRECT_BRANCH_PREDICTION = 28
    PS_MITIGATION_OPTION_SPECULATIVE_STORE_BYPASS_DISABLE = 29  # since REDSTONE5
    PS_MITIGATION_OPTION_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY = 30
    PS_MITIGATION_OPTION_CET_USER_SHADOW_STACKS = 31
    PS_MITIGATION_OPTION_USER_CET_SET_CONTEXT_IP_VALIDATION = 32  # since 21H1
    PS_MITIGATION_OPTION_BLOCK_NON_CET_BINARIES = 33
    PS_MITIGATION_OPTION_CET_DYNAMIC_APIS_OUT_OF_PROC_ONLY = 34
    PS_MITIGATION_OPTION_REDIRECTION_TRUST = 35  # since 22H1

class PS_CREATE_STATE(Enum):
    PsCreateInitialState = 0
    PsCreateFailOnFileOpen = 1
    PsCreateFailOnSectionCreate = 2
    PsCreateFailExeFormat = 3
    PsCreateFailMachineMismatch = 4
    PsCreateFailExeName = 5  # Debugger specified
    PsCreateSuccess = 6
    PsCreateMaximumStates = 7

class MEMORY_RESERVE_TYPE(Enum):
    MemoryReserveUserApc = 0
    MemoryReserveIoCompletion = 1
    MemoryReserveTypeMax = 2

class DBG_STATE(Enum):
    DbgIdle = 0
    DbgReplyPending = 1
    DbgCreateThreadStateChange = 2
    DbgCreateProcessStateChange = 3
    DbgExitThreadStateChange = 4
    DbgExitProcessStateChange = 5
    DbgExceptionStateChange = 6
    DbgBreakpointStateChange = 7
    DbgSingleStepStateChange = 8
    DbgLoadDllStateChange = 9
    DbgUnloadDllStateChange = 10

class DEBUGOBJECTINFOCLASS(Enum):
    DebugObjectUnusedInformation = 0
    DebugObjectKillProcessOnExitInformation = 1  # s: ULONG
    MaxDebugObjectInfoClass = 2

class FILE_INFORMATION_CLASS(Enum):
    FileDirectoryInformation = 1  # FILE_DIRECTORY_INFORMATION
    FileFullDirectoryInformation = 2  # FILE_FULL_DIR_INFORMATION
    FileBothDirectoryInformation = 3  # FILE_BOTH_DIR_INFORMATION
    FileBasicInformation = 4  # FILE_BASIC_INFORMATION
    FileStandardInformation = 5  # FILE_STANDARD_INFORMATION
    FileInternalInformation = 6  # FILE_INTERNAL_INFORMATION
    FileEaInformation = 7  # FILE_EA_INFORMATION
    FileAccessInformation = 8  # FILE_ACCESS_INFORMATION
    FileNameInformation = 9  # FILE_NAME_INFORMATION
    FileRenameInformation = 10  # FILE_RENAME_INFORMATION // 10
    FileLinkInformation = 11  # FILE_LINK_INFORMATION
    FileNamesInformation = 12  # FILE_NAMES_INFORMATION
    FileDispositionInformation = 13  # FILE_DISPOSITION_INFORMATION
    FilePositionInformation = 14  # FILE_POSITION_INFORMATION
    FileFullEaInformation = 15  # FILE_FULL_EA_INFORMATION
    FileModeInformation = 16  # FILE_MODE_INFORMATION
    FileAlignmentInformation = 17  # FILE_ALIGNMENT_INFORMATION
    FileAllInformation = 18  # FILE_ALL_INFORMATION
    FileAllocationInformation = 19  # FILE_ALLOCATION_INFORMATION
    FileEndOfFileInformation = 20  # FILE_END_OF_FILE_INFORMATION // 20
    FileAlternateNameInformation = 21  # FILE_NAME_INFORMATION
    FileStreamInformation = 22  # FILE_STREAM_INFORMATION
    FilePipeInformation = 23  # FILE_PIPE_INFORMATION
    FilePipeLocalInformation = 24  # FILE_PIPE_LOCAL_INFORMATION
    FilePipeRemoteInformation = 25  # FILE_PIPE_REMOTE_INFORMATION
    FileMailslotQueryInformation = 26  # FILE_MAILSLOT_QUERY_INFORMATION
    FileMailslotSetInformation = 27  # FILE_MAILSLOT_SET_INFORMATION
    FileCompressionInformation = 28  # FILE_COMPRESSION_INFORMATION
    FileObjectIdInformation = 29  # FILE_OBJECTID_INFORMATION
    FileCompletionInformation = 30  # FILE_COMPLETION_INFORMATION // 30
    FileMoveClusterInformation = 31  # FILE_MOVE_CLUSTER_INFORMATION
    FileQuotaInformation = 32  # FILE_QUOTA_INFORMATION
    FileReparsePointInformation = 33  # FILE_REPARSE_POINT_INFORMATION
    FileNetworkOpenInformation = 34  # FILE_NETWORK_OPEN_INFORMATION
    FileAttributeTagInformation = 35  # FILE_ATTRIBUTE_TAG_INFORMATION
    FileTrackingInformation = 36  # FILE_TRACKING_INFORMATION
    FileIdBothDirectoryInformation = 37  # FILE_ID_BOTH_DIR_INFORMATION
    FileIdFullDirectoryInformation = 38  # FILE_ID_FULL_DIR_INFORMATION
    FileValidDataLengthInformation = 39  # FILE_VALID_DATA_LENGTH_INFORMATION
    FileShortNameInformation = 40  # FILE_NAME_INFORMATION // 40
    FileIoCompletionNotificationInformation = 41  # FILE_IO_COMPLETION_NOTIFICATION_INFORMATION // since VISTA
    FileIoStatusBlockRangeInformation = 42  # FILE_IOSTATUSBLOCK_RANGE_INFORMATION
    FileIoPriorityHintInformation = 43  # FILE_IO_PRIORITY_HINT_INFORMATION, FILE_IO_PRIORITY_HINT_INFORMATION_EX
    FileSfioReserveInformation = 44  # FILE_SFIO_RESERVE_INFORMATION
    FileSfioVolumeInformation = 45  # FILE_SFIO_VOLUME_INFORMATION
    FileHardLinkInformation = 46  # FILE_LINKS_INFORMATION
    FileProcessIdsUsingFileInformation = 47  # FILE_PROCESS_IDS_USING_FILE_INFORMATION
    FileNormalizedNameInformation = 48  # FILE_NAME_INFORMATION
    FileNetworkPhysicalNameInformation = 49  # FILE_NETWORK_PHYSICAL_NAME_INFORMATION
    FileIdGlobalTxDirectoryInformation = 50  # FILE_ID_GLOBAL_TX_DIR_INFORMATION // since WIN7 // 50
    FileIsRemoteDeviceInformation = 51  # FILE_IS_REMOTE_DEVICE_INFORMATION
    FileUnusedInformation = 52
    FileNumaNodeInformation = 53  # FILE_NUMA_NODE_INFORMATION
    FileStandardLinkInformation = 54  # FILE_STANDARD_LINK_INFORMATION
    FileRemoteProtocolInformation = 55  # FILE_REMOTE_PROTOCOL_INFORMATION
    FileRenameInformationBypassAccessCheck = 56  # (kernel-mode only); FILE_RENAME_INFORMATION // since WIN8
    FileLinkInformationBypassAccessCheck = 57  # (kernel-mode only); FILE_LINK_INFORMATION
    FileVolumeNameInformation = 58  # FILE_VOLUME_NAME_INFORMATION
    FileIdInformation = 59  # FILE_ID_INFORMATION
    FileIdExtdDirectoryInformation = 60  # FILE_ID_EXTD_DIR_INFORMATION // 60
    FileReplaceCompletionInformation = 61  # FILE_COMPLETION_INFORMATION // since WINBLUE
    FileHardLinkFullIdInformation = 62  # FILE_LINK_ENTRY_FULL_ID_INFORMATION // FILE_LINKS_FULL_ID_INFORMATION
    FileIdExtdBothDirectoryInformation = 63  # FILE_ID_EXTD_BOTH_DIR_INFORMATION // since THRESHOLD
    FileDispositionInformationEx = 64  # FILE_DISPOSITION_INFO_EX // since REDSTONE
    FileRenameInformationEx = 65  # FILE_RENAME_INFORMATION_EX
    FileRenameInformationExBypassAccessCheck = 66  # (kernel-mode only); FILE_RENAME_INFORMATION_EX
    FileDesiredStorageClassInformation = 67  # FILE_DESIRED_STORAGE_CLASS_INFORMATION // since REDSTONE2
    FileStatInformation = 68  # FILE_STAT_INFORMATION
    FileMemoryPartitionInformation = 69  # FILE_MEMORY_PARTITION_INFORMATION // since REDSTONE3
    FileStatLxInformation = 70  # FILE_STAT_LX_INFORMATION // since REDSTONE4 // 70
    FileCaseSensitiveInformation = 71  # FILE_CASE_SENSITIVE_INFORMATION
    FileLinkInformationEx = 72  # FILE_LINK_INFORMATION_EX // since REDSTONE5
    FileLinkInformationExBypassAccessCheck = 73  # (kernel-mode only); FILE_LINK_INFORMATION_EX
    FileStorageReserveIdInformation = 74  # FILE_SET_STORAGE_RESERVE_ID_INFORMATION
    FileCaseSensitiveInformationForceAccessCheck = 75  # FILE_CASE_SENSITIVE_INFORMATION
    FileKnownFolderInformation = 76  # FILE_KNOWN_FOLDER_INFORMATION // since WIN11
    FileMaximumInformation = 77

class IO_PRIORITY_HINT(Enum):
    IoPriorityVeryLow = 0  # Defragging, content indexing and other background I/Os.
    IoPriorityLow = 1  # Prefetching for applications.
    IoPriorityNormal = 2  # Normal I/Os.
    IoPriorityHigh = 3  # Used by filesystems for checkpoint I/O.
    IoPriorityCritical = 4  # Used by memory manager. Not available for applications.
    MaxIoPriorityTypes = 5

class FILE_KNOWN_FOLDER_TYPE(Enum):
    KnownFolderNone = 0
    KnownFolderDesktop = 1
    KnownFolderDocuments = 2
    KnownFolderDownloads = 3
    KnownFolderMusic = 4
    KnownFolderPictures = 5
    KnownFolderVideos = 6
    KnownFolderOther = 7
    KnownFolderMax = 7

class FSINFOCLASS(Enum):
    FileFsVolumeInformation = 1  # FILE_FS_VOLUME_INFORMATION
    FileFsLabelInformation = 2  # FILE_FS_LABEL_INFORMATION
    FileFsSizeInformation = 3  # FILE_FS_SIZE_INFORMATION
    FileFsDeviceInformation = 4  # FILE_FS_DEVICE_INFORMATION
    FileFsAttributeInformation = 5  # FILE_FS_ATTRIBUTE_INFORMATION
    FileFsControlInformation = 6  # FILE_FS_CONTROL_INFORMATION
    FileFsFullSizeInformation = 7  # FILE_FS_FULL_SIZE_INFORMATION
    FileFsObjectIdInformation = 8  # FILE_FS_OBJECTID_INFORMATION
    FileFsDriverPathInformation = 9  # FILE_FS_DRIVER_PATH_INFORMATION
    FileFsVolumeFlagsInformation = 10  # FILE_FS_VOLUME_FLAGS_INFORMATION // 10
    FileFsSectorSizeInformation = 11  # FILE_FS_SECTOR_SIZE_INFORMATION // since WIN8
    FileFsDataCopyInformation = 12  # FILE_FS_DATA_COPY_INFORMATION
    FileFsMetadataSizeInformation = 13  # FILE_FS_METADATA_SIZE_INFORMATION // since THRESHOLD
    FileFsFullSizeInformationEx = 14  # FILE_FS_FULL_SIZE_INFORMATION_EX // since REDSTONE5
    FileFsMaximumInformation = 15

class DIRECTORY_NOTIFY_INFORMATION_CLASS(Enum):
    DirectoryNotifyInformation = 1  # FILE_NOTIFY_INFORMATION
    DirectoryNotifyExtendedInformation = 2  # FILE_NOTIFY_EXTENDED_INFORMATION
    DirectoryNotifyFullInformation = 3  # since 22H2
    DirectoryNotifyMaximumInformation = 4

class IO_COMPLETION_INFORMATION_CLASS(Enum):
    IoCompletionBasicInformation = 0

class IO_SESSION_EVENT(Enum):
    IoSessionEventIgnore = 0
    IoSessionEventCreated = 1
    IoSessionEventTerminated = 2
    IoSessionEventConnected = 3
    IoSessionEventDisconnected = 4
    IoSessionEventLogon = 5
    IoSessionEventLogoff = 6
    IoSessionEventMax = 7

class IO_SESSION_STATE(Enum):
    IoSessionStateCreated = 1
    IoSessionStateInitialized = 2
    IoSessionStateConnected = 3
    IoSessionStateDisconnected = 4
    IoSessionStateDisconnectedLoggedOn = 5
    IoSessionStateLoggedOn = 6
    IoSessionStateLoggedOff = 7
    IoSessionStateTerminated = 8
    IoSessionStateMax = 9

class INTERFACE_TYPE(Enum):
    InterfaceTypeUndefined = -1
    Internal = 0
    Isa = 1
    Eisa = 2
    MicroChannel = 3
    TurboChannel = 4
    PCIBus = 5
    VMEBus = 6
    NuBus = 7
    PCMCIABus = 8
    CBus = 9
    MPIBus = 10
    MPSABus = 11
    ProcessorInternal = 12
    InternalPowerBus = 13
    PNPISABus = 14
    PNPBus = 15
    Vmcs = 16
    ACPIBus = 17
    MaximumInterfaceType = 18

class DMA_WIDTH(Enum):
    Width8Bits = 0
    Width16Bits = 1
    Width32Bits = 2
    Width64Bits = 3
    WidthNoWrap = 4
    MaximumDmaWidth = 5

class DMA_SPEED(Enum):
    Compatible = 0
    TypeA = 1
    TypeB = 2
    TypeC = 3
    TypeF = 4
    MaximumDmaSpeed = 5

class BUS_DATA_TYPE(Enum):
    ConfigurationSpaceUndefined = -1
    Cmos = 0
    EisaConfiguration = 1
    Pos = 2
    CbusConfiguration = 3
    PCIConfiguration = 4
    VMEConfiguration = 5
    NuBusConfiguration = 6
    PCMCIAConfiguration = 7
    MPIConfiguration = 8
    MPSAConfiguration = 9
    PNPISAConfiguration = 10
    SgiInternalConfiguration = 11
    MaximumBusDataType = 12

class PORT_INFORMATION_CLASS(Enum):
    PortBasicInformation = 0
    PortDumpInformation = 1

class ALPC_PORT_INFORMATION_CLASS(Enum):
    AlpcBasicInformation = 0  # q: out ALPC_BASIC_INFORMATION
    AlpcPortInformation = 1  # s: in ALPC_PORT_ATTRIBUTES
    AlpcAssociateCompletionPortInformation = 2  # s: in ALPC_PORT_ASSOCIATE_COMPLETION_PORT
    AlpcConnectedSIDInformation = 3  # q: in SID
    AlpcServerInformation = 4  # q: inout ALPC_SERVER_INFORMATION
    AlpcMessageZoneInformation = 5  # s: in ALPC_PORT_MESSAGE_ZONE_INFORMATION
    AlpcRegisterCompletionListInformation = 6  # s: in ALPC_PORT_COMPLETION_LIST_INFORMATION
    AlpcUnregisterCompletionListInformation = 7  # s: VOID
    AlpcAdjustCompletionListConcurrencyCountInformation = 8  # s: in ULONG
    AlpcRegisterCallbackInformation = 9  # kernel-mode only
    AlpcCompletionListRundownInformation = 10  # s: VOID // 10
    AlpcWaitForPortReferences = 11
    AlpcServerSessionInformation = 12  # q: ALPC_SERVER_SESSION_INFORMATION // since 19H2

class ALPC_MESSAGE_INFORMATION_CLASS(Enum):
    AlpcMessageSidInformation = 0  # q: out SID
    AlpcMessageTokenModifiedIdInformation = 1  # q: out LUID
    AlpcMessageDirectStatusInformation = 2
    AlpcMessageHandleInformation = 3  # ALPC_MESSAGE_HANDLE_INFORMATION
    MaxAlpcMessageInfoClass = 4

class PF_BOOT_PHASE_ID(Enum):
    PfKernelInitPhase = 0
    PfBootDriverInitPhase = 90
    PfSystemDriverInitPhase = 120
    PfSessionManagerInitPhase = 150
    PfSMRegistryInitPhase = 180
    PfVideoInitPhase = 210
    PfPostVideoInitPhase = 240
    PfBootAcceptedRegistryInitPhase = 270
    PfUserShellReadyPhase = 300
    PfMaxBootPhaseId = 900

class PF_ENABLE_STATUS(Enum):
    PfSvNotSpecified = 0
    PfSvEnabled = 1
    PfSvDisabled = 2
    PfSvMaxEnableStatus = 3

class PREFETCHER_INFORMATION_CLASS(Enum):
    PrefetcherRetrieveTrace = 1  # q: CHAR[]
    PrefetcherSystemParameters = 2  # q: PF_SYSTEM_PREFETCH_PARAMETERS
    PrefetcherBootPhase = 3  # s: PF_BOOT_PHASE_ID
    PrefetcherSpare1 = 4  # PrefetcherRetrieveBootLoaderTrace // q: CHAR[]
    PrefetcherBootControl = 5  # s: PF_BOOT_CONTROL
    PrefetcherScenarioPolicyControl = 6
    PrefetcherSpare2 = 7
    PrefetcherAppLaunchScenarioControl = 8
    PrefetcherInformationMax = 9

class PFS_PRIVATE_PAGE_SOURCE_TYPE(Enum):
    PfsPrivateSourceKernel = 0
    PfsPrivateSourceSession = 1
    PfsPrivateSourceProcess = 2
    PfsPrivateSourceMax = 3

class PF_PHASED_SCENARIO_TYPE(Enum):
    PfScenarioTypeNone = 0
    PfScenarioTypeStandby = 1
    PfScenarioTypeHibernate = 2
    PfScenarioTypeFUS = 3
    PfScenarioTypeMax = 4

class SUPERFETCH_INFORMATION_CLASS(Enum):
    SuperfetchRetrieveTrace = 1  # q: CHAR[]
    SuperfetchSystemParameters = 2  # q: PF_SYSTEM_SUPERFETCH_PARAMETERS
    SuperfetchLogEvent = 3
    SuperfetchGenerateTrace = 4
    SuperfetchPrefetch = 5
    SuperfetchPfnQuery = 6  # q: PF_PFN_PRIO_REQUEST
    SuperfetchPfnSetPriority = 7
    SuperfetchPrivSourceQuery = 8  # q: PF_PRIVSOURCE_QUERY_REQUEST
    SuperfetchSequenceNumberQuery = 9  # q: ULONG
    SuperfetchScenarioPhase = 10  # 10
    SuperfetchWorkerPriority = 11
    SuperfetchScenarioQuery = 12  # q: PF_SCENARIO_PHASE_INFO
    SuperfetchScenarioPrefetch = 13
    SuperfetchRobustnessControl = 14
    SuperfetchTimeControl = 15
    SuperfetchMemoryListQuery = 16  # q: PF_MEMORY_LIST_INFO
    SuperfetchMemoryRangesQuery = 17  # q: PF_PHYSICAL_MEMORY_RANGE_INFO
    SuperfetchTracingControl = 18
    SuperfetchTrimWhileAgingControl = 19
    SuperfetchRepurposedByPrefetch = 20  # q: PF_REPURPOSED_BY_PREFETCH_INFO // rev
    SuperfetchChannelPowerRequest = 21
    SuperfetchMovePages = 22
    SuperfetchVirtualQuery = 23
    SuperfetchCombineStatsQuery = 24
    SuperfetchSetMinWsAgeRate = 25
    SuperfetchDeprioritizeOldPagesInWs = 26
    SuperfetchFileExtentsQuery = 27
    SuperfetchGpuUtilizationQuery = 28  # PF_GPU_UTILIZATION_INFO
    SuperfetchInformationMax = 29

class PLUGPLAY_EVENT_CATEGORY(Enum):
    HardwareProfileChangeEvent = 0
    TargetDeviceChangeEvent = 1
    DeviceClassChangeEvent = 2
    CustomDeviceEvent = 3
    DeviceInstallEvent = 4
    DeviceArrivalEvent = 5
    PowerEvent = 6
    VetoEvent = 7
    BlockedDriverEvent = 8
    InvalidIDEvent = 9
    MaxPlugEventCategory = 10

class PLUGPLAY_CONTROL_CLASS(Enum):
    PlugPlayControlEnumerateDevice = 0  # PLUGPLAY_CONTROL_ENUMERATE_DEVICE_DATA
    PlugPlayControlRegisterNewDevice = 1  # PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA
    PlugPlayControlDeregisterDevice = 2  # PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA
    PlugPlayControlInitializeDevice = 3  # PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA
    PlugPlayControlStartDevice = 4  # PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA
    PlugPlayControlUnlockDevice = 5  # PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA
    PlugPlayControlQueryAndRemoveDevice = 6  # PLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA
    PlugPlayControlUserResponse = 7  # PLUGPLAY_CONTROL_USER_RESPONSE_DATA
    PlugPlayControlGenerateLegacyDevice = 8  # PLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA
    PlugPlayControlGetInterfaceDeviceList = 9  # PLUGPLAY_CONTROL_INTERFACE_LIST_DATA
    PlugPlayControlProperty = 10  # PLUGPLAY_CONTROL_PROPERTY_DATA
    PlugPlayControlDeviceClassAssociation = 11  # PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA
    PlugPlayControlGetRelatedDevice = 12  # PLUGPLAY_CONTROL_RELATED_DEVICE_DATA
    PlugPlayControlGetInterfaceDeviceAlias = 13  # PLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA
    PlugPlayControlDeviceStatus = 14  # PLUGPLAY_CONTROL_STATUS_DATA
    PlugPlayControlGetDeviceDepth = 15  # PLUGPLAY_CONTROL_DEPTH_DATA
    PlugPlayControlQueryDeviceRelations = 16  # PLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA
    PlugPlayControlTargetDeviceRelation = 17  # PLUGPLAY_CONTROL_TARGET_RELATION_DATA
    PlugPlayControlQueryConflictList = 18  # PLUGPLAY_CONTROL_CONFLICT_LIST
    PlugPlayControlRetrieveDock = 19  # PLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA
    PlugPlayControlResetDevice = 20  # PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA
    PlugPlayControlHaltDevice = 21  # PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA
    PlugPlayControlGetBlockedDriverList = 22  # PLUGPLAY_CONTROL_BLOCKED_DRIVER_DATA
    PlugPlayControlGetDeviceInterfaceEnabled = 23  # PLUGPLAY_CONTROL_DEVICE_INTERFACE_ENABLED
    MaxPlugPlayControl = 24

class POWER_REQUEST_TYPE_INTERNAL(Enum):
    PowerRequestDisplayRequiredInternal = 0
    PowerRequestSystemRequiredInternal = 1
    PowerRequestAwayModeRequiredInternal = 2
    PowerRequestExecutionRequiredInternal = 3  # Windows 8+
    PowerRequestPerfBoostRequiredInternal = 4  # Windows 8+
    PowerRequestActiveLockScreenInternal = 5  # Windows 10 RS1+ (reserved on Windows 8)
    PowerRequestInternalInvalid = 6
    PowerRequestInternalUnknown = 7
    PowerRequestFullScreenVideoRequired = 8  # Windows 8 only

class POWER_STATE_TYPE(Enum):
    SystemPowerState = 0
    DevicePowerState = 1

class REQUESTER_TYPE(Enum):
    KernelRequester = 0
    UserProcessRequester = 1
    UserSharedServiceRequester = 2

class POWER_STATE_HANDLER_TYPE(Enum):
    PowerStateSleeping1 = 0
    PowerStateSleeping2 = 1
    PowerStateSleeping3 = 2
    PowerStateSleeping4 = 3
    PowerStateShutdownOff = 4
    PowerStateShutdownReset = 5
    PowerStateSleeping4Firmware = 6
    PowerStateMaximum = 7

class POWER_INFORMATION_LEVEL_INTERNAL(Enum):
    PowerInternalAcpiInterfaceRegister = 0
    PowerInternalS0LowPowerIdleInfo = 1  # POWER_S0_LOW_POWER_IDLE_INFO
    PowerInternalReapplyBrightnessSettings = 2
    PowerInternalUserAbsencePrediction = 3  # POWER_USER_ABSENCE_PREDICTION
    PowerInternalUserAbsencePredictionCapability = 4  # POWER_USER_ABSENCE_PREDICTION_CAPABILITY
    PowerInternalPoProcessorLatencyHint = 5  # POWER_PROCESSOR_LATENCY_HINT
    PowerInternalStandbyNetworkRequest = 6  # POWER_STANDBY_NETWORK_REQUEST
    PowerInternalDirtyTransitionInformation = 7
    PowerInternalSetBackgroundTaskState = 8  # POWER_SET_BACKGROUND_TASK_STATE
    PowerInternalTtmOpenTerminal = 9
    PowerInternalTtmCreateTerminal = 10  # 10
    PowerInternalTtmEvacuateDevices = 11
    PowerInternalTtmCreateTerminalEventQueue = 12
    PowerInternalTtmGetTerminalEvent = 13
    PowerInternalTtmSetDefaultDeviceAssignment = 14
    PowerInternalTtmAssignDevice = 15
    PowerInternalTtmSetDisplayState = 16
    PowerInternalTtmSetDisplayTimeouts = 17
    PowerInternalBootSessionStandbyActivationInformation = 18
    PowerInternalSessionPowerState = 19
    PowerInternalSessionTerminalInput = 20  # 20
    PowerInternalSetWatchdog = 21
    PowerInternalPhysicalPowerButtonPressInfoAtBoot = 22
    PowerInternalExternalMonitorConnected = 23
    PowerInternalHighPrecisionBrightnessSettings = 24
    PowerInternalWinrtScreenToggle = 25
    PowerInternalPpmQosDisable = 26
    PowerInternalTransitionCheckpoint = 27
    PowerInternalInputControllerState = 28
    PowerInternalFirmwareResetReason = 29
    PowerInternalPpmSchedulerQosSupport = 30  # 30
    PowerInternalBootStatGet = 31
    PowerInternalBootStatSet = 32
    PowerInternalCallHasNotReturnedWatchdog = 33
    PowerInternalBootStatCheckIntegrity = 34
    PowerInternalBootStatRestoreDefaults = 35  # in: void
    PowerInternalHostEsStateUpdate = 36
    PowerInternalGetPowerActionState = 37
    PowerInternalBootStatUnlock = 38
    PowerInternalWakeOnVoiceState = 39
    PowerInternalDeepSleepBlock = 40  # 40
    PowerInternalIsPoFxDevice = 41
    PowerInternalPowerTransitionExtensionAtBoot = 42
    PowerInternalProcessorBrandedFrequency = 43  # in: POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_INPUT, out: POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_OUTPUT
    PowerInternalTimeBrokerExpirationReason = 44
    PowerInternalNotifyUserShutdownStatus = 45
    PowerInternalPowerRequestTerminalCoreWindow = 46
    PowerInternalProcessorIdleVeto = 47
    PowerInternalPlatformIdleVeto = 48
    PowerInternalIsLongPowerButtonBugcheckEnabled = 49
    PowerInternalAutoChkCausedReboot = 50  # 50
    PowerInternalSetWakeAlarmOverride = 51
    PowerInternalDirectedFxAddTestDevice = 53
    PowerInternalDirectedFxRemoveTestDevice = 54
    PowerInternalDirectedFxSetMode = 56
    PowerInternalRegisterPowerPlane = 57
    PowerInternalSetDirectedDripsFlags = 58
    PowerInternalClearDirectedDripsFlags = 59
    PowerInternalRetrieveHiberFileResumeContext = 60  # 60
    PowerInternalReadHiberFilePage = 61
    PowerInternalLastBootSucceeded = 62  # out: BOOLEAN
    PowerInternalQuerySleepStudyHelperRoutineBlock = 63
    PowerInternalDirectedDripsQueryCapabilities = 64
    PowerInternalClearConstraints = 65
    PowerInternalSoftParkVelocityEnabled = 66
    PowerInternalQueryIntelPepCapabilities = 67
    PowerInternalGetSystemIdleLoopEnablement = 68  # since WIN11
    PowerInternalGetVmPerfControlSupport = 69
    PowerInternalGetVmPerfControlConfig = 70  # 70
    PowerInternalSleepDetailedDiagUpdate = 71
    PowerInternalProcessorClassFrequencyBandsStats = 72
    PowerInternalHostGlobalUserPresenceStateUpdate = 73
    PowerInternalCpuNodeIdleIntervalStats = 74
    PowerInternalClassIdleIntervalStats = 75
    PowerInternalCpuNodeConcurrencyStats = 76
    PowerInternalClassConcurrencyStats = 77
    PowerInternalQueryProcMeasurementCapabilities = 78
    PowerInternalQueryProcMeasurementValues = 79
    PowerInternalPrepareForSystemInitiatedReboot = 80  # 80
    PowerInternalGetAdaptiveSessionState = 81
    PowerInternalSetConsoleLockedState = 82
    PowerInternalOverrideSystemInitiatedRebootState = 83
    PowerInternalFanImpactStats = 84
    PowerInternalFanRpmBuckets = 85
    PowerInternalPowerBootAppDiagInfo = 86
    PowerInternalUnregisterShutdownNotification = 87  # since 22H1
    PowerInternalManageTransitionStateRecord = 88
    PowerInformationInternalMaximum = 89

class POWER_S0_DISCONNECTED_REASON(Enum):
    PoS0DisconnectedReasonNone = 0
    PoS0DisconnectedReasonNonCompliantNic = 1
    PoS0DisconnectedReasonSettingPolicy = 2
    PoS0DisconnectedReasonEnforceDsPolicy = 3
    PoS0DisconnectedReasonCsChecksFailed = 4
    PoS0DisconnectedReasonSmartStandby = 5
    PoS0DisconnectedReasonMaximum = 6

class KEY_INFORMATION_CLASS(Enum):
    KeyBasicInformation = 0  # KEY_BASIC_INFORMATION
    KeyNodeInformation = 1  # KEY_NODE_INFORMATION
    KeyFullInformation = 2  # KEY_FULL_INFORMATION
    KeyNameInformation = 3  # KEY_NAME_INFORMATION
    KeyCachedInformation = 4  # KEY_CACHED_INFORMATION
    KeyFlagsInformation = 5  # KEY_FLAGS_INFORMATION
    KeyVirtualizationInformation = 6  # KEY_VIRTUALIZATION_INFORMATION
    KeyHandleTagsInformation = 7  # KEY_HANDLE_TAGS_INFORMATION
    KeyTrustInformation = 8  # KEY_TRUST_INFORMATION
    KeyLayerInformation = 9  # KEY_LAYER_INFORMATION
    MaxKeyInfoClass = 10

class KEY_SET_INFORMATION_CLASS(Enum):
    KeyWriteTimeInformation = 0  # KEY_WRITE_TIME_INFORMATION
    KeyWow64FlagsInformation = 1  # KEY_WOW64_FLAGS_INFORMATION
    KeyControlFlagsInformation = 2  # KEY_CONTROL_FLAGS_INFORMATION
    KeySetVirtualizationInformation = 3  # KEY_SET_VIRTUALIZATION_INFORMATION
    KeySetDebugInformation = 4
    KeySetHandleTagsInformation = 5  # KEY_HANDLE_TAGS_INFORMATION
    KeySetLayerInformation = 6  # KEY_SET_LAYER_INFORMATION
    MaxKeySetInfoClass = 7

class KEY_VALUE_INFORMATION_CLASS(Enum):
    KeyValueBasicInformation = 0  # KEY_VALUE_BASIC_INFORMATION
    KeyValueFullInformation = 1  # KEY_VALUE_FULL_INFORMATION
    KeyValuePartialInformation = 2  # KEY_VALUE_PARTIAL_INFORMATION
    KeyValueFullInformationAlign64 = 3
    KeyValuePartialInformationAlign64 = 4  # KEY_VALUE_PARTIAL_INFORMATION_ALIGN64
    KeyValueLayerInformation = 5  # KEY_VALUE_LAYER_INFORMATION
    MaxKeyValueInfoClass = 6

class KEY_LOAD_ENTRY_TYPE(Enum):
    KeyLoadTrustClassKey = 1
    KeyLoadEvent = 2
    KeyLoadToken = 3

class REG_ACTION(Enum):
    KeyAdded = 0
    KeyRemoved = 1
    KeyModified = 2

class TABLE_SEARCH_RESULT(Enum):
    TableEmptyTree = 0
    TableFoundNode = 1
    TableInsertAsLeft = 2
    TableInsertAsRight = 3

class RTL_GENERIC_COMPARE_RESULTS(Enum):
    GenericLessThan = 0
    GenericGreaterThan = 1
    GenericEqual = 2

class RTL_NORM_FORM(Enum):
    NormOther = 0
    NormC = 1
    NormD = 2
    NormKC = 5
    NormKD = 6
    NormIdna = 13
    DisallowUnassigned = 256
    NormCDisallowUnassigned = 257
    NormDDisallowUnassigned = 258
    NormKCDisallowUnassigned = 261
    NormKDDisallowUnassigned = 262
    NormIdnaDisallowUnassigned = 269

class FUNCTION_TABLE_TYPE(Enum):
    RF_SORTED = 0
    RF_UNSORTED = 1
    RF_CALLBACK = 2
    RF_KERNEL_DYNAMIC = 3

class RTL_PATH_TYPE(Enum):
    RtlPathTypeUnknown = 0
    RtlPathTypeUncAbsolute = 1
    RtlPathTypeDriveAbsolute = 2
    RtlPathTypeDriveRelative = 3
    RtlPathTypeRooted = 4
    RtlPathTypeRelative = 5
    RtlPathTypeLocalDevice = 6
    RtlPathTypeRootLocalDevice = 7

class HEAP_COMPATIBILITY_MODE(Enum):
    HEAP_COMPATIBILITY_STANDARD = 0
    HEAP_COMPATIBILITY_LAL = 1
    HEAP_COMPATIBILITY_LFH = 2

class IMAGE_MITIGATION_POLICY(Enum):
    ImageDepPolicy = 0  # RTL_IMAGE_MITIGATION_DEP_POLICY
    ImageAslrPolicy = 1  # RTL_IMAGE_MITIGATION_ASLR_POLICY
    ImageDynamicCodePolicy = 2  # RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY
    ImageStrictHandleCheckPolicy = 3  # RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY
    ImageSystemCallDisablePolicy = 4  # RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY
    ImageMitigationOptionsMask = 5
    ImageExtensionPointDisablePolicy = 6  # RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY
    ImageControlFlowGuardPolicy = 7  # RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY
    ImageSignaturePolicy = 8  # RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY
    ImageFontDisablePolicy = 9  # RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY
    ImageImageLoadPolicy = 10  # RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY
    ImagePayloadRestrictionPolicy = 11  # RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY
    ImageChildProcessPolicy = 12  # RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY
    ImageSehopPolicy = 13  # RTL_IMAGE_MITIGATION_SEHOP_POLICY
    ImageHeapPolicy = 14  # RTL_IMAGE_MITIGATION_HEAP_POLICY
    ImageUserShadowStackPolicy = 15  # RTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY
    MaxImageMitigationPolicy = 16

class RTL_IMAGE_MITIGATION_OPTION_STATE(Enum):
    RtlMitigationOptionStateNotConfigured = 0
    RtlMitigationOptionStateOn = 1
    RtlMitigationOptionStateOff = 2
    RtlMitigationOptionStateForce = 3
    RtlMitigationOptionStateOption = 4

class APPCONTAINER_SID_TYPE(Enum):
    NotAppContainerSidType = 0
    ChildAppContainerSidType = 1
    ParentAppContainerSidType = 2
    InvalidAppContainerSidType = 3
    MaxAppContainerSidType = 4

class STATE_LOCATION_TYPE(Enum):
    LocationTypeRegistry = 0
    LocationTypeFileSystem = 1
    LocationTypeMaximum = 2

class RTL_BSD_ITEM_TYPE(Enum):
    RtlBsdItemVersionNumber = 0  # q; s: ULONG
    RtlBsdItemProductType = 1  # q; s: NT_PRODUCT_TYPE (ULONG)
    RtlBsdItemAabEnabled = 2  # q: s: BOOLEAN // AutoAdvancedBoot
    RtlBsdItemAabTimeout = 3  # q: s: UCHAR // AdvancedBootMenuTimeout
    RtlBsdItemBootGood = 4  # q: s: BOOLEAN // LastBootSucceeded
    RtlBsdItemBootShutdown = 5  # q: s: BOOLEAN // LastBootShutdown
    RtlBsdSleepInProgress = 6  # q: s: BOOLEAN // SleepInProgress
    RtlBsdPowerTransition = 7  # q: s: RTL_BSD_DATA_POWER_TRANSITION
    RtlBsdItemBootAttemptCount = 8  # q: s: UCHAR // BootAttemptCount
    RtlBsdItemBootCheckpoint = 9  # q: s: UCHAR // LastBootCheckpoint
    RtlBsdItemBootId = 10  # q; s: ULONG (USER_SHARED_DATA->BootId)
    RtlBsdItemShutdownBootId = 11  # q; s: ULONG
    RtlBsdItemReportedAbnormalShutdownBootId = 12  # q; s: ULONG
    RtlBsdItemErrorInfo = 13  # RTL_BSD_DATA_ERROR_INFO
    RtlBsdItemPowerButtonPressInfo = 14  # RTL_BSD_POWER_BUTTON_PRESS_INFO
    RtlBsdItemChecksum = 15  # q: s: UCHAR
    RtlBsdPowerTransitionExtension = 16
    RtlBsdItemFeatureConfigurationState = 17  # q; s: ULONG
    RtlBsdItemMax = 18

class TOKEN_SECURITY_ATTRIBUTE_OPERATION(Enum):
    TOKEN_SECURITY_ATTRIBUTE_OPERATION_NONE = 0
    TOKEN_SECURITY_ATTRIBUTE_OPERATION_REPLACE_ALL = 1
    TOKEN_SECURITY_ATTRIBUTE_OPERATION_ADD = 2
    TOKEN_SECURITY_ATTRIBUTE_OPERATION_DELETE = 3
    TOKEN_SECURITY_ATTRIBUTE_OPERATION_REPLACE = 4

class TP_TRACE_TYPE(Enum):
    TpTraceThreadPriority = 1
    TpTraceThreadAffinity = 2
    MaxTpTraceType = 3

class WOW64_SHARED_INFORMATION(Enum):
    SharedNtdll32LdrInitializeThunk = 0
    SharedNtdll32KiUserExceptionDispatcher = 1
    SharedNtdll32KiUserApcDispatcher = 2
    SharedNtdll32KiUserCallbackDispatcher = 3
    SharedNtdll32ExpInterlockedPopEntrySListFault = 4
    SharedNtdll32ExpInterlockedPopEntrySListResume = 5
    SharedNtdll32ExpInterlockedPopEntrySListEnd = 6
    SharedNtdll32RtlUserThreadStart = 7
    SharedNtdll32pQueryProcessDebugInformationRemote = 8
    SharedNtdll32BaseAddress = 9
    SharedNtdll32LdrSystemDllInitBlock = 10
    Wow64SharedPageEntriesCount = 11

class DOMAIN_INFORMATION_CLASS(Enum):
    DomainPasswordInformation = 1  # q; s: DOMAIN_PASSWORD_INFORMATION
    DomainGeneralInformation = 2  # q: DOMAIN_GENERAL_INFORMATION
    DomainLogoffInformation = 3  # q; s: DOMAIN_LOGOFF_INFORMATION
    DomainOemInformation = 4  # q; s: DOMAIN_OEM_INFORMATION
    DomainNameInformation = 5  # q: DOMAIN_NAME_INFORMATION
    DomainReplicationInformation = 6  # q; s: DOMAIN_REPLICATION_INFORMATION
    DomainServerRoleInformation = 7  # q; s: DOMAIN_SERVER_ROLE_INFORMATION
    DomainModifiedInformation = 8  # q: DOMAIN_MODIFIED_INFORMATION
    DomainStateInformation = 9  # q; s: DOMAIN_STATE_INFORMATION
    DomainUasInformation = 10  # q; s: DOMAIN_UAS_INFORMATION
    DomainGeneralInformation2 = 11  # q: DOMAIN_GENERAL_INFORMATION2
    DomainLockoutInformation = 12  # q; s: DOMAIN_LOCKOUT_INFORMATION
    DomainModifiedInformation2 = 13  # q: DOMAIN_MODIFIED_INFORMATION2

class DOMAIN_SERVER_ENABLE_STATE(Enum):
    DomainServerEnabled = 1
    DomainServerDisabled = 2

class DOMAIN_SERVER_ROLE(Enum):
    DomainServerRoleBackup = 2
    DomainServerRolePrimary = 3

class DOMAIN_PASSWORD_CONSTRUCTION(Enum):
    DomainPasswordSimple = 1
    DomainPasswordComplex = 2

class DOMAIN_DISPLAY_INFORMATION(Enum):
    DomainDisplayUser = 1  # DOMAIN_DISPLAY_USER
    DomainDisplayMachine = 2  # DOMAIN_DISPLAY_MACHINE
    DomainDisplayGroup = 3  # DOMAIN_DISPLAY_GROUP
    DomainDisplayOemUser = 4  # DOMAIN_DISPLAY_OEM_USER
    DomainDisplayOemGroup = 5  # DOMAIN_DISPLAY_OEM_GROUP
    DomainDisplayServer = 6

class DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION(Enum):
    DomainLocalizableAccountsBasic = 1

class GROUP_INFORMATION_CLASS(Enum):
    GroupGeneralInformation = 1  # q: GROUP_GENERAL_INFORMATION
    GroupNameInformation = 2  # q; s: GROUP_NAME_INFORMATION
    GroupAttributeInformation = 3  # q; s: GROUP_ATTRIBUTE_INFORMATION
    GroupAdminCommentInformation = 4  # q; s: GROUP_ADM_COMMENT_INFORMATION
    GroupReplicationInformation = 5

class ALIAS_INFORMATION_CLASS(Enum):
    AliasGeneralInformation = 1  # q: ALIAS_GENERAL_INFORMATION
    AliasNameInformation = 2  # q; s: ALIAS_NAME_INFORMATION
    AliasAdminCommentInformation = 3  # q; s: ALIAS_ADM_COMMENT_INFORMATION
    AliasReplicationInformation = 4
    AliasExtendedInformation = 5

class USER_INFORMATION_CLASS(Enum):
    UserGeneralInformation = 1  # q: USER_GENERAL_INFORMATION
    UserPreferencesInformation = 2  # q; s: USER_PREFERENCES_INFORMATION
    UserLogonInformation = 3  # q: USER_LOGON_INFORMATION
    UserLogonHoursInformation = 4  # q; s: USER_LOGON_HOURS_INFORMATION
    UserAccountInformation = 5  # q: USER_ACCOUNT_INFORMATION
    UserNameInformation = 6  # q; s: USER_NAME_INFORMATION
    UserAccountNameInformation = 7  # q; s: USER_ACCOUNT_NAME_INFORMATION
    UserFullNameInformation = 8  # q; s: USER_FULL_NAME_INFORMATION
    UserPrimaryGroupInformation = 9  # q; s: USER_PRIMARY_GROUP_INFORMATION
    UserHomeInformation = 10  # q; s: USER_HOME_INFORMATION // 10
    UserScriptInformation = 11  # q; s: USER_SCRIPT_INFORMATION
    UserProfileInformation = 12  # q; s: USER_PROFILE_INFORMATION
    UserAdminCommentInformation = 13  # q; s: USER_ADMIN_COMMENT_INFORMATION
    UserWorkStationsInformation = 14  # q; s: USER_WORKSTATIONS_INFORMATION
    UserSetPasswordInformation = 15  # s: USER_SET_PASSWORD_INFORMATION
    UserControlInformation = 16  # q; s: USER_CONTROL_INFORMATION
    UserExpiresInformation = 17  # q; s: USER_EXPIRES_INFORMATION
    UserInternal1Information = 18  # USER_INTERNAL1_INFORMATION
    UserInternal2Information = 19  # USER_INTERNAL2_INFORMATION
    UserParametersInformation = 20  # q; s: USER_PARAMETERS_INFORMATION // 20
    UserAllInformation = 21  # USER_ALL_INFORMATION
    UserInternal3Information = 22  # USER_INTERNAL3_INFORMATION
    UserInternal4Information = 23  # USER_INTERNAL4_INFORMATION
    UserInternal5Information = 24  # USER_INTERNAL5_INFORMATION
    UserInternal4InformationNew = 25  # USER_INTERNAL4_INFORMATION_NEW
    UserInternal5InformationNew = 26  # USER_INTERNAL5_INFORMATION_NEW
    UserInternal6Information = 27  # USER_INTERNAL6_INFORMATION
    UserExtendedInformation = 28  # USER_EXTENDED_INFORMATION
    UserLogonUIInformation = 29  # USER_LOGON_UI_INFORMATION
    UserUnknownTodoInformation = 30
    UserInternal7Information = 31  # USER_INTERNAL7_INFORMATION
    UserInternal8Information = 32  # USER_INTERNAL8_INFORMATION

class SECURITY_DB_DELTA_TYPE(Enum):
    SecurityDbNew = 1
    SecurityDbRename = 2
    SecurityDbDelete = 3
    SecurityDbChangeMemberAdd = 4
    SecurityDbChangeMemberSet = 5
    SecurityDbChangeMemberDel = 6
    SecurityDbChange = 7
    SecurityDbChangePassword = 8

class SECURITY_DB_OBJECT_TYPE(Enum):
    SecurityDbObjectSamDomain = 1
    SecurityDbObjectSamUser = 2
    SecurityDbObjectSamGroup = 3
    SecurityDbObjectSamAlias = 4
    SecurityDbObjectLsaPolicy = 5
    SecurityDbObjectLsaTDomain = 6
    SecurityDbObjectLsaAccount = 7
    SecurityDbObjectLsaSecret = 8

class SAM_ACCOUNT_TYPE(Enum):
    SamObjectUser = 1
    SamObjectGroup = 2
    SamObjectAlias = 3

class PASSWORD_POLICY_VALIDATION_TYPE(Enum):
    SamValidateAuthentication = 1
    SamValidatePasswordChange = 2
    SamValidatePasswordReset = 3

class SAM_VALIDATE_VALIDATION_STATUS(Enum):
    SamValidateSuccess = 0
    SamValidatePasswordMustChange = 1
    SamValidateAccountLockedOut = 2
    SamValidatePasswordExpired = 3
    SamValidatePasswordIncorrect = 4
    SamValidatePasswordIsInHistory = 5
    SamValidatePasswordTooShort = 6
    SamValidatePasswordTooLong = 7
    SamValidatePasswordNotComplexEnough = 8
    SamValidatePasswordTooRecent = 9
    SamValidatePasswordFilterError = 10

class SAM_GENERIC_OPERATION_TYPE(Enum):
    SamObjectChangeNotificationOperation = 0

class VDMSERVICECLASS(Enum):
    VdmStartExecution = 0
    VdmQueueInterrupt = 1
    VdmDelayInterrupt = 2
    VdmInitialize = 3
    VdmFeatures = 4
    VdmSetInt21Handler = 5
    VdmQueryDir = 6
    VdmPrinterDirectIoOpen = 7
    VdmPrinterDirectIoClose = 8
    VdmPrinterInitialize = 9
    VdmSetLdtEntries = 10
    VdmSetProcessLdtInfo = 11
    VdmAdlibEmulation = 12
    VdmPMCliControl = 13
    VdmQueryVdmProcess = 14
    VdmPreInitialize = 15

class TRACE_CONTROL_INFORMATION_CLASS(Enum):
    TraceControlStartLogger = 1  # inout WMI_LOGGER_INFORMATION
    TraceControlStopLogger = 2  # inout WMI_LOGGER_INFORMATION
    TraceControlQueryLogger = 3  # inout WMI_LOGGER_INFORMATION
    TraceControlUpdateLogger = 4  # inout WMI_LOGGER_INFORMATION
    TraceControlFlushLogger = 5  # inout WMI_LOGGER_INFORMATION
    TraceControlIncrementLoggerFile = 6  # inout WMI_LOGGER_INFORMATION
    TraceControlUnknown = 7
    TraceControlRealtimeConnect = 11
    TraceControlActivityIdCreate = 12
    TraceControlWdiDispatchControl = 13
    TraceControlRealtimeDisconnectConsumerByHandle = 14  # in HANDLE
    TraceControlRegisterGuidsCode = 15
    TraceControlReceiveNotification = 16
    TraceControlSendDataBlock = 17  # ETW_ENABLE_NOTIFICATION_PACKET
    TraceControlSendReplyDataBlock = 18
    TraceControlReceiveReplyDataBlock = 19
    TraceControlWdiUpdateSem = 20
    TraceControlEnumTraceGuidList = 21  # out GUID[]
    TraceControlGetTraceGuidInfo = 22  # in GUID, out TRACE_GUID_INFO
    TraceControlEnumerateTraceGuids = 23
    TraceControlRegisterSecurityProv = 24
    TraceControlQueryReferenceTime = 25
    TraceControlTrackProviderBinary = 26  # in HANDLE
    TraceControlAddNotificationEvent = 27
    TraceControlUpdateDisallowList = 28
    TraceControlSetEnableAllKeywordsCode = 29
    TraceControlSetProviderTraitsCode = 30
    TraceControlUseDescriptorTypeCode = 31
    TraceControlEnumTraceGroupList = 32
    TraceControlGetTraceGroupInfo = 33
    TraceControlTraceSetDisallowList = 34
    TraceControlSetCompressionSettings = 35
    TraceControlGetCompressionSettings = 36
    TraceControlUpdatePeriodicCaptureState = 37
    TraceControlGetPrivateSessionTraceHandle = 38
    TraceControlRegisterPrivateSession = 39
    TraceControlQuerySessionDemuxObject = 40
    TraceControlSetProviderBinaryTracking = 41
    TraceControlMaxLoggers = 42  # out ULONG
    TraceControlMaxPmcCounter = 43  # out ULONG
    TraceControlQueryUsedProcessorCount = 44  # ULONG // since WIN11
    TraceControlGetPmcOwnership = 45

class AUDIT_EVENT_TYPE(Enum):
    AuditEventObjectAccess = 0
    AuditEventDirectoryServiceAccess = 1

class TOKEN_TYPE(Enum):
    TokenPrimary = 1
    TokenImpersonation = 2

class KTMOBJECT_TYPE(Enum):
    KTMOBJECT_TRANSACTION = 0
    KTMOBJECT_TRANSACTION_MANAGER = 1
    KTMOBJECT_RESOURCE_MANAGER = 2
    KTMOBJECT_ENLISTMENT = 3
    KTMOBJECT_INVALID = 4

class DEVICE_POWER_STATE(Enum):
    PowerDeviceUnspecified = 0
    PowerDeviceD0 = 1
    PowerDeviceD1 = 2
    PowerDeviceD2 = 3
    PowerDeviceD3 = 4
    PowerDeviceMaximum = 5

class SYSTEM_POWER_STATE(Enum):
    PowerSystemUnspecified = 0
    PowerSystemWorking = 1
    PowerSystemSleeping1 = 2
    PowerSystemSleeping2 = 3
    PowerSystemSleeping3 = 4
    PowerSystemHibernate = 5
    PowerSystemShutdown = 6
    PowerSystemMaximum = 7

class ENLISTMENT_INFORMATION_CLASS(Enum):
    EnlistmentBasicInformation = 0
    EnlistmentRecoveryInformation = 1
    EnlistmentCrmInformation = 2

class JOBOBJECTINFOCLASS(Enum):
    JobObjectBasicAccountingInformation = 1
    JobObjectBasicLimitInformation = 2
    JobObjectBasicProcessIdList = 3
    JobObjectBasicUIRestrictions = 4
    JobObjectSecurityLimitInformation = 5  # deprecated
    JobObjectEndOfJobTimeInformation = 6
    JobObjectAssociateCompletionPortInformation = 7
    JobObjectBasicAndIoAccountingInformation = 8
    JobObjectExtendedLimitInformation = 9
    JobObjectJobSetInformation = 10
    JobObjectGroupInformation = 11
    JobObjectNotificationLimitInformation = 12
    JobObjectLimitViolationInformation = 13
    JobObjectGroupInformationEx = 14
    JobObjectCpuRateControlInformation = 15
    JobObjectCompletionFilter = 16
    JobObjectCompletionCounter = 17
    JobObjectReserved1Information = 18
    JobObjectReserved2Information = 19
    JobObjectReserved3Information = 20
    JobObjectReserved4Information = 21
    JobObjectReserved5Information = 22
    JobObjectReserved6Information = 23
    JobObjectReserved7Information = 24
    JobObjectReserved8Information = 25
    JobObjectReserved9Information = 26
    JobObjectReserved10Information = 27
    JobObjectReserved11Information = 28
    JobObjectReserved12Information = 29
    JobObjectReserved13Information = 30
    JobObjectReserved14Information = 31
    JobObjectNetRateControlInformation = 32
    JobObjectNotificationLimitInformation2 = 33
    JobObjectLimitViolationInformation2 = 34
    JobObjectCreateSilo = 35
    JobObjectSiloBasicInformation = 36
    JobObjectReserved15Information = 37
    JobObjectReserved16Information = 38
    JobObjectReserved17Information = 39
    JobObjectReserved18Information = 40
    JobObjectReserved19Information = 41
    JobObjectReserved20Information = 42
    JobObjectReserved21Information = 43
    JobObjectReserved22Information = 44
    JobObjectReserved23Information = 45
    JobObjectReserved24Information = 46
    JobObjectReserved25Information = 47
    JobObjectReserved26Information = 48
    JobObjectReserved27Information = 49
    MaxJobObjectInfoClass = 50

class RESOURCEMANAGER_INFORMATION_CLASS(Enum):
    ResourceManagerBasicInformation = 0
    ResourceManagerCompletionInformation = 1

class TOKEN_INFORMATION_CLASS(Enum):
    TokenUser = 1
    TokenGroups = 2
    TokenPrivileges = 3
    TokenOwner = 4
    TokenPrimaryGroup = 5
    TokenDefaultDacl = 6
    TokenSource = 7
    TokenType = 8
    TokenImpersonationLevel = 9
    TokenStatistics = 10
    TokenRestrictedSids = 11
    TokenSessionId = 12
    TokenGroupsAndPrivileges = 13
    TokenSessionReference = 14
    TokenSandBoxInert = 15
    TokenAuditPolicy = 16
    TokenOrigin = 17
    TokenElevationType = 18
    TokenLinkedToken = 19
    TokenElevation = 20
    TokenHasRestrictions = 21
    TokenAccessInformation = 22
    TokenVirtualizationAllowed = 23
    TokenVirtualizationEnabled = 24
    TokenIntegrityLevel = 25
    TokenUIAccess = 26
    TokenMandatoryPolicy = 27
    TokenLogonSid = 28
    TokenIsAppContainer = 29
    TokenCapabilities = 30
    TokenAppContainerSid = 31
    TokenAppContainerNumber = 32
    TokenUserClaimAttributes = 33
    TokenDeviceClaimAttributes = 34
    TokenRestrictedUserClaimAttributes = 35
    TokenRestrictedDeviceClaimAttributes = 36
    TokenDeviceGroups = 37
    TokenRestrictedDeviceGroups = 38
    TokenSecurityAttributes = 39
    TokenIsRestricted = 40
    TokenProcessTrustLevel = 41
    TokenPrivateNameSpace = 42
    TokenSingletonAttributes = 43
    TokenBnoIsolation = 44
    TokenChildProcessFlags = 45
    TokenIsLessPrivilegedAppContainer = 46
    TokenIsSandboxed = 47
    TokenIsAppSilo = 48
    MaxTokenInfoClass = 49  # MaxTokenInfoClass should always be the last enum

class TRANSACTION_INFORMATION_CLASS(Enum):
    TransactionBasicInformation = 0
    TransactionPropertiesInformation = 1
    TransactionEnlistmentInformation = 2
    TransactionSuperiorEnlistmentInformation = 3
    TransactionBindInformation = 4  # private and deprecated
    TransactionDTCPrivateInformation = 5  # private and deprecated

class TRANSACTIONMANAGER_INFORMATION_CLASS(Enum):
    TransactionManagerBasicInformation = 0
    TransactionManagerLogInformation = 1
    TransactionManagerLogPathInformation = 2
    TransactionManagerRecoveryInformation = 4
    TransactionManagerOnlineProbeInformation = 3
    TransactionManagerOldestTransactionInformation = 5


```

`src/dumpulator/ntprimitives.py`:

```py
import struct
import ctypes
import typing
from typing import Optional, Annotated, Generic, TypeVar, Type, Union, SupportsInt, SupportsBytes
from enum import Enum
from dataclasses import dataclass

class Architecture:
    def __init__(self, x64: bool):
        self._x64 = x64

    @property
    def x64(self):
        return self._x64

    def ptr_size(self):
        return 8 if self._x64 else 4

    def ptr_type(self):
        return ctypes.c_uint64 if self._x64 else ctypes.c_uint32

    def alignment(self):
        return 16 if self._x64 else 8

    def read(self, addr: SupportsInt, size: int) -> bytes:
        raise NotImplementedError()

    def write(self, addr: SupportsInt, data: Union[SupportsBytes, bytes]):
        raise NotImplementedError()

    def read_char(self, addr: SupportsInt) -> int:
        return struct.unpack("<b", self.read(addr, 1))[0]

    def read_short(self, addr: SupportsInt) -> int:
        return struct.unpack("<h", self.read(addr, 2))[0]

    def read_long(self, addr: SupportsInt) -> int:
        return struct.unpack("<i", self.read(addr, 4))[0]

    def read_byte(self, addr: SupportsInt) -> int:
        return struct.unpack("<B", self.read(addr, 1))[0]

    def read_ushort(self, addr: SupportsInt) -> int:
        return struct.unpack("<H", self.read(addr, 2))[0]

    def read_ulong(self, addr: SupportsInt) -> int:
        return struct.unpack("<I", self.read(addr, 4))[0]

    def read_ptr(self, addr: SupportsInt) -> int:
        return struct.unpack("<Q" if self._x64 else "<I", self.read(addr, self.ptr_size()))[0]

    def write_char(self, addr: SupportsInt, value: int):
        self.write(addr, struct.pack("<b", value))

    def write_short(self, addr: SupportsInt, value: int):
        self.write(addr, struct.pack("<h", value))

    def write_long(self, addr: SupportsInt, value: int):
        self.write(addr, struct.pack("<i", value))

    def write_byte(self, addr: SupportsInt, value: int):
        self.write(addr, struct.pack("<B", value))

    def write_ushort(self, addr: SupportsInt, value: int):
        self.write(addr, struct.pack("<H", value))

    def write_ulong(self, addr: SupportsInt, value: int):
        self.write(addr, struct.pack("<I", value))

    def write_ptr(self, addr: SupportsInt, value: int):
        self.write(addr, struct.pack("<Q" if self._x64 else "<I", value))

    def read_str(self, addr: SupportsInt, encoding="utf-8") -> str:
        # TODO: safely read the memory
        data = self.read(addr, 512)

        # Note: this is awful
        if "-16" in encoding:
            nullidx = data.find(b'\0\0')
            if nullidx != -1:
                nullidx += 1
        else:
            nullidx = data.find(b'\0')
        if nullidx != -1:
            data = data[:nullidx]

        return data.decode(encoding)

T = TypeVar("T")

class P(Generic[T]):
    _ptr_ = True

    def __init__(self, arch: Architecture, ptr: int = 0):
        self.arch = arch
        self.ptr = ptr

    @property
    def type(self) -> Type[T]:
        try:
            # https://github.com/Stewori/pytypes/blob/ff82bf5a6c9cc1159ac2bf817bae8aa4141e88fc/pytypes/type_util.py#L182
            args = object.__getattribute__(self, "__orig_class__")
        except AttributeError as e:
            return None
        t, = typing.get_args(args)
        if t is type(None):
            raise TypeError("P[None] is not allowed")
        return t

    @classmethod
    def is_ptr(cls, tv):
        return hasattr(tv, "_ptr_")

    def read(self, size: int) -> bytes:
        return self.arch.read(self.ptr, size)

    def write(self, data: Union[SupportsBytes, bytes]):
        self.arch.write(self.ptr, data)

    def __getitem__(self, index: int) -> T:
        ptype = self.type
        if ptype is None:
            raise TypeError(f"No type associated with pointer")

        if P.is_ptr(ptype):
            ptr = self.ptr + index * self.arch.ptr_size()
            return ptype(self.arch, self.arch.read_ptr(ptr))
        else:
            size = Struct.sizeof(ptype, self.arch)
            ptr = self.ptr + index * size
            if issubclass(ptype, Struct):
                return ptype(self.arch, ptr)
            else:
                ctype = Struct.translate_ctype(self.arch.ptr_type(), ptype)
                size = ctypes.sizeof(ctype)
                data = self.arch.read(ptr, size)
                value = ctype.from_buffer(data)
                return ptype(value)

    def __setitem__(self, index: int, value: T):
        ptype = self.type
        if ptype is None:
            raise TypeError(f"No type associated with pointer")
        if P.is_ptr(ptype):
            ptr = self.ptr + index * self.arch.ptr_size()
            self.arch.write_ptr(ptr, int(value))
        else:
            size = Struct.sizeof(ptype, self.arch)
            ptr = self.ptr + index * size
            if issubclass(ptype, Struct):
                if isinstance(value, ptype):
                    raise TypeError(f"Expected {ptype}, got {type(value)}")
                self.arch.write(ptr, value)
            else:
                # TODO: support bool/enum?
                if not isinstance(value, int):
                    raise TypeError(f"Expected int, got {type(value)}")
                ctype = Struct.translate_ctype(self.arch.ptr_type(), ptype)
                self.arch.write(ptr, ctype(int(value)))

    def deref(self) -> T:
        return self[0]

    def __int__(self):
        return self.ptr

    def __eq__(self, other):
        return self.ptr == other

    def __ne__(self, other):
        return self.ptr != other

    def __str__(self):
        return hex(self.ptr)

    def read_byte_str(self, size: int):
        return bytes(self.read(size))

    def read_str(self, size: int, encoding="utf8"):
        return self.read(size).decode(encoding)

    def read_unicode_str(self):
        length = self.arch.read_ushort(self.ptr)
        ptr = self.arch.read_ptr(self.ptr + self.arch.ptr_size())
        return self.arch.read(ptr, length).decode("utf-16")

    def read_ptr(self):
        return self.arch.read_ptr(self.ptr)

    def write_ptr(self, value: typing.SupportsInt):
        return self.arch.write_ptr(self.ptr, int(value))

    def write_ulong(self, value: typing.SupportsInt):
        return self.arch.write_ulong(self.ptr, int(value))

    def read_ulong(self):
        return self.arch.read_ulong(self.ptr)

class PVOID(P):
    pass

# TODO: find a way to show the fields in the PyCharm debugger (properties?)
class Struct:
    def __init__(self, arch: Architecture, ptr: int = 0):
        self._hints = typing.get_type_hints(self)
        # TODO: allow 'binding' the pointer
        self._ptr = ptr
        self._arch = arch
        fields = []
        for name, t in self._hints.items():
            ctype = Struct.translate_ctype(arch.ptr_type(), t)
            if ctype is None:
                raise TypeError(f"Unsupported native type {t.__name__} for member {self.__class__.__name__}{name}")
            fields.append((name, ctype))
        self._ctype = Struct._create_type(
            self.__class__.__name__ + "_ctype",
            ctypes.Structure,
            _fields_=fields,
            _alignment_=arch.alignment()
        )
        if ptr != 0:
            data = arch.read(ptr, Struct.sizeof(self))
            self._cself = self._ctype.from_buffer_copy(data)
        else:
            self._cself = self._ctype()
        # Add properties to visualize things in the debugger
        for name in self._hints:
            object.__setattr__(self, name, property(lambda s: getattr(s, name)))

    @classmethod
    def sizeof(cls, value, arch: Optional[Architecture] = None) -> int:
        if P.is_ptr(value):
            if arch is None:
                ctype = value.arch.ptr_type()
            else:
                ctype = arch.ptr_type()
        elif isinstance(value, Struct):
            ctype = value._ctype
        elif issubclass(value, Struct):
            if arch is None:
                raise TypeError("No architecture passed")
            ctype = value(arch)._ctype
        elif isinstance(value, Int):
            if arch is None:
                raise TypeError("No architecture passed")
            ctype = Struct.translate_ctype(arch.ptr_type(), type(value))
        elif issubclass(value, Int):
            if arch is None:
                raise TypeError("No architecture passed")
            ctype = Struct.translate_ctype(arch.ptr_type(), value)
        else:
            raise NotImplementedError()
        assert ctype is not None
        return ctypes.sizeof(ctype)

    @classmethod
    def bytes(cls, value: "Struct") -> bytes:
        assert isinstance(value, Struct)
        return bytes(value)

    def __bytes__(self) -> bytes:
        return bytes(self._cself)

    # https://stackoverflow.com/questions/28552433/dynamically-create-ctypes-in-python
    @staticmethod
    def _create_type(name, *bases, **attrs):
        return type(name, bases, attrs)

    @staticmethod
    def translate_ctype(ptr_type, t: type):
        if P.is_ptr(t):
            return ptr_type
        elif issubclass(t, Enum):
            return ctypes.c_uint32
        elif issubclass(t, UCHAR):
            return ctypes.c_uint8
        elif issubclass(t, CHAR):
            return ctypes.c_int8
        elif issubclass(t, USHORT):
            return ctypes.c_uint16
        elif issubclass(t, SHORT):
            return ctypes.c_int16
        elif issubclass(t, ULONG):
            return ctypes.c_uint32
        elif issubclass(t, LONG):
            return ctypes.c_int32
        elif issubclass(t, ULONG_PTR):
            return ptr_type
        else:
            return None

    def __getattribute__(self, name: str):
        if name.startswith("__"):
            return object.__getattribute__(self, name)
        elif name != "_hints" and name in self._hints:
            # Proxy the ctypes fields
            atype = self._hints[name]
            avalue = getattr(self._cself, name)
            if P.is_ptr(atype):
                return atype(self._arch, avalue)
            elif issubclass(atype, Enum):
                return atype(avalue)
            else:
                return atype(avalue)
        else:
            return object.__getattribute__(self, name)

    def __setattr__(self, name: str, value):
        if name.startswith("__"):
            object.__setattr__(self, name, value)
        elif name != "_hints" and name in self._hints:
            # TODO: support assigning pointers properly
            # TODO: support assigning enums properly
            setattr(self._cself, name, int(value))
        elif name.startswith("_") or name in self.__dict__:
            object.__setattr__(self, name, value)
        else:
            raise AttributeError(f"Unknown attribute {self.__class__.__name__}.{name}")

class Int(int):
    def __str__(self):
        return hex(self)

# Actual primitives
class UCHAR(Int):
    def __new__(cls, value):
        return Int.__new__(cls, value & 0xFF)

class CHAR(Int):
    def __new__(cls, value):
        value = value & 0xFF
        if value & 0x80 != 0:
            value = -((~value) & 0xFF)
        return Int.__new__(cls, value)

class USHORT(Int):
    def __new__(cls, value):
        return Int.__new__(cls, value & 0xFFFF)

class SHORT(Int):
    def __new__(cls, value):
        value = value & 0xFFFF
        if value & 0x8000 != 0:
            value = -((~value) & 0xFFFF)
        return Int.__new__(cls, value)

class ULONG(Int):
    def __new__(cls, value):
        return Int.__new__(cls, value & 0xFFFFFFFF)

class LONG(Int):
    def __new__(cls, value):
        value = value & 0xFFFFFFFF
        if value & 0x80000000 != 0:
            value = -((~value) & 0xFFFFFFFF)
        return Int.__new__(cls, value)


class ULONG_PTR(Int):
    def __new__(cls, value):
        return Int.__new__(cls, value & 0xFFFFFFFFFFFFFFFF)

# TODO: how does this work in 32 bit?
class ULONG64(Int):
    pass

# Alias types
class HANDLE(ULONG_PTR):  # TODO: probably shouldn't be an alias
    pass

class SIZE_T(ULONG_PTR):
    pass

class ULONGLONG(ULONG64):
    pass

class BYTE(UCHAR):
    pass

class RTL_ATOM(USHORT):
    pass

class NTSTATUS(ULONG):
    pass

class LANGID(USHORT):
    pass

class ALPC_HANDLE(HANDLE):
    pass

class NOTIFICATION_MASK(ULONG):
    pass

class SECURITY_INFORMATION(ULONG):
    pass

class EXECUTION_STATE(ULONG):
    pass

class SE_SIGNING_LEVEL(BYTE):
    pass

class ACCESS_MASK(ULONG):
    pass

class WNF_CHANGE_STAMP(ULONG):
    pass

class KAFFINITY(ULONG_PTR):
    pass

class KPRIORITY(ULONG_PTR):
    pass

class KIRQL(UCHAR):
    pass

# TODO: should probably be bool
class BOOLEAN(BYTE):
    pass

class LOGICAL(ULONG):
    pass

class LCID(ULONG):
    pass

class PSID(PVOID):
    pass

class PWSTR(PVOID):
    pass

class CCHAR(CHAR):
    pass

class CSHORT(SHORT):
    pass

class CLONG(ULONG):
    pass

# Some unsupported enum
class LATENCY_TIME(Enum):
    LT_DONT_CARE = 0
    LT_LOWEST_LATENCY = 1

@dataclass
class SAL:
    annotation: str
    comment: str = ""

    def __str__(self):
        return self.annotation.split(" ")[0]

```

`src/dumpulator/ntstructs.py`:

```py
from .ntprimitives import *

class IO_STATUS_BLOCK(Struct):
    Pointer: PVOID
    Information: ULONG_PTR

    @staticmethod
    def write(ptr: PVOID, Status: int, Information: int):
        # https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_status_block
        pointer_data = ptr.read_ptr()
        pointer_data &= 0xFFFFFFFF00000000
        pointer_data |= Status
        ptr.write_ptr(pointer_data)
        ptr.arch.write_ptr(ptr.ptr + ptr.arch.ptr_size(), Information)

class UNICODE_STRING(Struct):
    Length: USHORT
    MaximumLength: USHORT
    Buffer: P[USHORT]

    def read_str(self):
        return self.Buffer.read(self.Length).decode("utf-16")

    @staticmethod
    def create_buffer(s: str, ptr: PVOID) -> bytes:
        encoded = s.encode("utf-16-le") + b"\0\0"
        if ptr.arch.x64:
            data = struct.pack("<HHIQ", len(encoded) - 2, len(encoded), 0, int(ptr) + 16)
        else:
            data = struct.pack("<HHI", len(encoded) - 2, len(encoded), int(ptr) + 8)
        return data + encoded

class SECURITY_DESCRIPTOR:
    pass

class SECURITY_QUALITY_OF_SERVICE:
    pass

class OBJECT_ATTRIBUTES(Struct):
    Length: ULONG
    RootDirectory: HANDLE
    ObjectName: P[UNICODE_STRING]
    Attributes: ULONG
    SecurityDescriptor: P[SECURITY_DESCRIPTOR]
    SecurityQualityOfService: P[SECURITY_QUALITY_OF_SERVICE]

class ALPC_CONTEXT_ATTR:
    pass

class ALPC_DATA_VIEW_ATTR:
    pass

class ALPC_MESSAGE_ATTRIBUTES:
    pass

class ALPC_PORT_ATTRIBUTES:
    pass

class ALPC_SECURITY_ATTR:
    pass

class BOOT_ENTRY:
    pass

class BOOT_OPTIONS:
    pass

class CLIENT_ID:
    pass

class CRM_PROTOCOL_ID:
    pass

class CWNF_STATE_NAME:
    pass

class CWNF_TYPE_ID:
    pass

class DBGUI_WAIT_STATE_CHANGE:
    pass

class EFI_DRIVER_ENTRY:
    pass

class ENCLAVE_ROUTINE:
    pass

class EXCEPTION_RECORD:
    pass

class FILE_BASIC_INFORMATION:
    pass

class FILE_IO_COMPLETION_INFORMATION:
    pass

class FILE_NETWORK_OPEN_INFORMATION:
    pass

class FILE_PATH:
    pass

class FILE_SEGMENT_ELEMENT:
    pass

class GENERIC_MAPPING:
    pass

class GROUP_AFFINITY:
    pass

class GUID:
    pass

class INITIAL_TEB:
    pass

class IO_APC_ROUTINE:
    pass

class JOB_SET_ARRAY:
    pass

class KEY_LOAD_ENTRY:
    pass

class KEY_VALUE_ENTRY:
    pass

class KTMOBJECT_CURSOR:
    pass

class LARGE_INTEGER:
    pass

class LUID:
    pass

class MEMORY_RANGE_ENTRY:
    pass

class MEM_EXTENDED_PARAMETER:
    pass

class OBJECT_BOUNDARY_DESCRIPTOR:
    pass

class OBJECT_TYPE_LIST:
    pass

class OWER_ACTION:
    pass

class OWER_INFORMATION_LEVEL:
    pass

class PLUGPLAY_EVENT_BLOCK:
    pass

class PORT_MESSAGE:
    pass

class PORT_VIEW:
    pass

class PRIVILEGE_SET:
    pass

class PROCESSOR_NUMBER:
    pass

class PS_APC_ROUTINE:
    pass

class PS_ATTRIBUTE_LIST:
    pass

class PS_CREATE_INFO:
    pass

class REMOTE_PORT_VIEW:
    pass

class SID_AND_ATTRIBUTES:
    pass

class T2_CANCEL_PARAMETERS:
    pass

class T2_SET_PARAMETERS:
    pass

class TIMER_APC_ROUTINE:
    pass

class TOKEN_DEFAULT_DACL:
    pass

class TOKEN_GROUPS:
    pass

class TOKEN_MANDATORY_POLICY:
    pass

class TOKEN_OWNER:
    pass

class TOKEN_PRIMARY_GROUP:
    pass

class TOKEN_PRIVILEGES:
    pass

class TOKEN_SECURITY_ATTRIBUTES_INFORMATION:
    pass

class TOKEN_SOURCE:
    pass

class TOKEN_USER:
    pass

class TRANSACTION_NOTIFICATION:
    pass

class ULARGE_INTEGER:
    pass

class WNF_DELIVERY_DESCRIPTOR:
    pass

class WNF_STATE_NAME:
    pass

class WORKER_FACTORY_DEFERRED_WORK:
    pass

```

`src/dumpulator/ntsyscalls.py`:

```py
import ctypes
import struct
import unicorn

from .dumpulator import Dumpulator
from .native import *
from .handles import *
from .memory import *
from pathlib import Path

def syscall(func):
    name: str = func.__name__
    if name[:2] not in ["Zw", "Nt"]:
        raise Exception(f"All syscalls have to be prefixed with 'Zw' or 'Nt'")
    # Add the function with both prefixes to avoid name bugs
    from .dumpulator import syscall_functions
    syscall_functions["Zw" + name[2:]] = func
    syscall_functions["Nt" + name[2:]] = func
    return func

@syscall
def ZwAcceptConnectPort(dp: Dumpulator,
                        PortHandle: Annotated[P[HANDLE], SAL("_Out_")],
                        PortContext: Annotated[PVOID, SAL("_In_opt_")],
                        ConnectionRequest: Annotated[P[PORT_MESSAGE], SAL("_In_")],
                        AcceptConnection: Annotated[BOOLEAN, SAL("_In_")],
                        ServerView: Annotated[P[PORT_VIEW], SAL("_Inout_opt_")],
                        ClientView: Annotated[P[REMOTE_PORT_VIEW], SAL("_Out_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwAccessCheck(dp: Dumpulator,
                  SecurityDescriptor: Annotated[P[SECURITY_DESCRIPTOR], SAL("_In_")],
                  ClientToken: Annotated[HANDLE, SAL("_In_")],
                  DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                  GenericMapping: Annotated[P[GENERIC_MAPPING], SAL("_In_")],
                  PrivilegeSet: Annotated[P[PRIVILEGE_SET], SAL("_Out_writes_bytes_(*PrivilegeSetLength)")],
                  PrivilegeSetLength: Annotated[P[ULONG], SAL("_Inout_")],
                  GrantedAccess: Annotated[P[ACCESS_MASK], SAL("_Out_")],
                  AccessStatus: Annotated[P[NTSTATUS], SAL("_Out_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwAccessCheckAndAuditAlarm(dp: Dumpulator,
                               SubsystemName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                               HandleId: Annotated[PVOID, SAL("_In_opt_")],
                               ObjectTypeName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                               ObjectName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                               SecurityDescriptor: Annotated[P[SECURITY_DESCRIPTOR], SAL("_In_")],
                               DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                               GenericMapping: Annotated[P[GENERIC_MAPPING], SAL("_In_")],
                               ObjectCreation: Annotated[BOOLEAN, SAL("_In_")],
                               GrantedAccess: Annotated[P[ACCESS_MASK], SAL("_Out_")],
                               AccessStatus: Annotated[P[NTSTATUS], SAL("_Out_")],
                               GenerateOnClose: Annotated[P[BOOLEAN], SAL("_Out_")]
                               ):
    raise NotImplementedError()

@syscall
def ZwAccessCheckByType(dp: Dumpulator,
                        SecurityDescriptor: Annotated[P[SECURITY_DESCRIPTOR], SAL("_In_")],
                        PrincipalSelfSid: Annotated[PSID, SAL("_In_opt_")],
                        ClientToken: Annotated[HANDLE, SAL("_In_")],
                        DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                        ObjectTypeList: Annotated[P[OBJECT_TYPE_LIST], SAL("_In_reads_(ObjectTypeListLength)")],
                        ObjectTypeListLength: Annotated[ULONG, SAL("_In_")],
                        GenericMapping: Annotated[P[GENERIC_MAPPING], SAL("_In_")],
                        PrivilegeSet: Annotated[P[PRIVILEGE_SET], SAL("_Out_writes_bytes_(*PrivilegeSetLength)")],
                        PrivilegeSetLength: Annotated[P[ULONG], SAL("_Inout_")],
                        GrantedAccess: Annotated[P[ACCESS_MASK], SAL("_Out_")],
                        AccessStatus: Annotated[P[NTSTATUS], SAL("_Out_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwAccessCheckByTypeAndAuditAlarm(dp: Dumpulator,
                                     SubsystemName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                     HandleId: Annotated[PVOID, SAL("_In_opt_")],
                                     ObjectTypeName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                     ObjectName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                     SecurityDescriptor: Annotated[P[SECURITY_DESCRIPTOR], SAL("_In_")],
                                     PrincipalSelfSid: Annotated[PSID, SAL("_In_opt_")],
                                     DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                                     AuditType: Annotated[AUDIT_EVENT_TYPE, SAL("_In_")],
                                     Flags: Annotated[ULONG, SAL("_In_")],
                                     ObjectTypeList: Annotated[P[OBJECT_TYPE_LIST], SAL("_In_reads_opt_(ObjectTypeListLength)")],
                                     ObjectTypeListLength: Annotated[ULONG, SAL("_In_")],
                                     GenericMapping: Annotated[P[GENERIC_MAPPING], SAL("_In_")],
                                     ObjectCreation: Annotated[BOOLEAN, SAL("_In_")],
                                     GrantedAccess: Annotated[P[ACCESS_MASK], SAL("_Out_")],
                                     AccessStatus: Annotated[P[NTSTATUS], SAL("_Out_")],
                                     GenerateOnClose: Annotated[P[BOOLEAN], SAL("_Out_")]
                                     ):
    raise NotImplementedError()

@syscall
def ZwAccessCheckByTypeResultList(dp: Dumpulator,
                                  SecurityDescriptor: Annotated[P[SECURITY_DESCRIPTOR], SAL("_In_")],
                                  PrincipalSelfSid: Annotated[PSID, SAL("_In_opt_")],
                                  ClientToken: Annotated[HANDLE, SAL("_In_")],
                                  DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                                  ObjectTypeList: Annotated[P[OBJECT_TYPE_LIST], SAL("_In_reads_(ObjectTypeListLength)")],
                                  ObjectTypeListLength: Annotated[ULONG, SAL("_In_")],
                                  GenericMapping: Annotated[P[GENERIC_MAPPING], SAL("_In_")],
                                  PrivilegeSet: Annotated[P[PRIVILEGE_SET], SAL("_Out_writes_bytes_(*PrivilegeSetLength)")],
                                  PrivilegeSetLength: Annotated[P[ULONG], SAL("_Inout_")],
                                  GrantedAccess: Annotated[P[ACCESS_MASK], SAL("_Out_writes_(ObjectTypeListLength)")],
                                  AccessStatus: Annotated[P[NTSTATUS], SAL("_Out_writes_(ObjectTypeListLength)")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwAccessCheckByTypeResultListAndAuditAlarm(dp: Dumpulator,
                                               SubsystemName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                               HandleId: Annotated[PVOID, SAL("_In_opt_")],
                                               ObjectTypeName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                               ObjectName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                               SecurityDescriptor: Annotated[P[SECURITY_DESCRIPTOR], SAL("_In_")],
                                               PrincipalSelfSid: Annotated[PSID, SAL("_In_opt_")],
                                               DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                                               AuditType: Annotated[AUDIT_EVENT_TYPE, SAL("_In_")],
                                               Flags: Annotated[ULONG, SAL("_In_")],
                                               ObjectTypeList: Annotated[P[OBJECT_TYPE_LIST], SAL("_In_reads_opt_(ObjectTypeListLength)")],
                                               ObjectTypeListLength: Annotated[ULONG, SAL("_In_")],
                                               GenericMapping: Annotated[P[GENERIC_MAPPING], SAL("_In_")],
                                               ObjectCreation: Annotated[BOOLEAN, SAL("_In_")],
                                               GrantedAccess: Annotated[P[ACCESS_MASK], SAL("_Out_writes_(ObjectTypeListLength)")],
                                               AccessStatus: Annotated[P[NTSTATUS], SAL("_Out_writes_(ObjectTypeListLength)")],
                                               GenerateOnClose: Annotated[P[BOOLEAN], SAL("_Out_")]
                                               ):
    raise NotImplementedError()

@syscall
def ZwAccessCheckByTypeResultListAndAuditAlarmByHandle(dp: Dumpulator,
                                                       SubsystemName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                                       HandleId: Annotated[PVOID, SAL("_In_opt_")],
                                                       ClientToken: Annotated[HANDLE, SAL("_In_")],
                                                       ObjectTypeName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                                       ObjectName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                                       SecurityDescriptor: Annotated[P[SECURITY_DESCRIPTOR], SAL("_In_")],
                                                       PrincipalSelfSid: Annotated[PSID, SAL("_In_opt_")],
                                                       DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                                                       AuditType: Annotated[AUDIT_EVENT_TYPE, SAL("_In_")],
                                                       Flags: Annotated[ULONG, SAL("_In_")],
                                                       ObjectTypeList: Annotated[P[OBJECT_TYPE_LIST], SAL("_In_reads_opt_(ObjectTypeListLength)")],
                                                       ObjectTypeListLength: Annotated[ULONG, SAL("_In_")],
                                                       GenericMapping: Annotated[P[GENERIC_MAPPING], SAL("_In_")],
                                                       ObjectCreation: Annotated[BOOLEAN, SAL("_In_")],
                                                       GrantedAccess: Annotated[P[ACCESS_MASK], SAL("_Out_writes_(ObjectTypeListLength)")],
                                                       AccessStatus: Annotated[P[NTSTATUS], SAL("_Out_writes_(ObjectTypeListLength)")],
                                                       GenerateOnClose: Annotated[P[BOOLEAN], SAL("_Out_")]
                                                       ):
    raise NotImplementedError()

@syscall
def ZwAcquireCMFViewOwnership(dp: Dumpulator,
                              TimeStamp: Annotated[P[ULONGLONG], SAL("_Out_")],
                              tokenTaken: Annotated[P[BOOLEAN], SAL("_Out_")],
                              replaceExisting: Annotated[BOOLEAN, SAL("_In_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwAddAtom(dp: Dumpulator,
              AtomName: Annotated[PWSTR, SAL("_In_reads_bytes_opt_(Length)")],
              Length: Annotated[ULONG, SAL("_In_")],
              Atom: Annotated[P[RTL_ATOM], SAL("_Out_opt_")]
              ):
    raise NotImplementedError()

@syscall
def ZwAddAtomEx(dp: Dumpulator,
                AtomName: Annotated[PWSTR, SAL("_In_reads_bytes_opt_(Length)")],
                Length: Annotated[ULONG, SAL("_In_")],
                Atom: Annotated[P[RTL_ATOM], SAL("_Out_opt_")],
                Flags: Annotated[ULONG, SAL("_In_")]
                ):
    raise NotImplementedError()

@syscall
def ZwAddBootEntry(dp: Dumpulator,
                   BootEntry: Annotated[P[BOOT_ENTRY], SAL("_In_")],
                   Id: Annotated[P[ULONG], SAL("_Out_opt_")]
                   ):
    raise NotImplementedError()

@syscall
def ZwAddDriverEntry(dp: Dumpulator,
                     DriverEntry: Annotated[P[EFI_DRIVER_ENTRY], SAL("_In_")],
                     Id: Annotated[P[ULONG], SAL("_Out_opt_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwAdjustGroupsToken(dp: Dumpulator,
                        TokenHandle: Annotated[HANDLE, SAL("_In_")],
                        ResetToDefault: Annotated[BOOLEAN, SAL("_In_")],
                        NewState: Annotated[P[TOKEN_GROUPS], SAL("_In_opt_")],
                        BufferLength: Annotated[ULONG, SAL("_In_opt_")],
                        PreviousState: Annotated[P[TOKEN_GROUPS], SAL("_Out_writes_bytes_to_opt_(BufferLength, *ReturnLength)")],
                        ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwAdjustPrivilegesToken(dp: Dumpulator,
                            TokenHandle: Annotated[HANDLE, SAL("_In_")],
                            DisableAllPrivileges: Annotated[BOOLEAN, SAL("_In_")],
                            NewState: Annotated[P[TOKEN_PRIVILEGES], SAL("_In_opt_")],
                            BufferLength: Annotated[ULONG, SAL("_In_")],
                            PreviousState: Annotated[P[TOKEN_PRIVILEGES], SAL("_Out_writes_bytes_to_opt_(BufferLength, *ReturnLength)")],
                            ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwAdjustTokenClaimsAndDeviceGroups(dp: Dumpulator,
                                       TokenHandle: Annotated[HANDLE, SAL("_In_")],
                                       UserResetToDefault: Annotated[BOOLEAN, SAL("_In_")],
                                       DeviceResetToDefault: Annotated[BOOLEAN, SAL("_In_")],
                                       DeviceGroupsResetToDefault: Annotated[BOOLEAN, SAL("_In_")],
                                       NewUserState: Annotated[P[TOKEN_SECURITY_ATTRIBUTES_INFORMATION], SAL("_In_opt_")],
                                       NewDeviceState: Annotated[P[TOKEN_SECURITY_ATTRIBUTES_INFORMATION], SAL("_In_opt_")],
                                       NewDeviceGroupsState: Annotated[P[TOKEN_GROUPS], SAL("_In_opt_")],
                                       UserBufferLength: Annotated[ULONG, SAL("_In_")],
                                       PreviousUserState: Annotated[P[TOKEN_SECURITY_ATTRIBUTES_INFORMATION], SAL("_Out_writes_bytes_to_opt_(UserBufferLength, *UserReturnLength)")],
                                       DeviceBufferLength: Annotated[ULONG, SAL("_In_")],
                                       PreviousDeviceState: Annotated[P[TOKEN_SECURITY_ATTRIBUTES_INFORMATION], SAL("_Out_writes_bytes_to_opt_(DeviceBufferLength, *DeviceReturnLength)")],
                                       DeviceGroupsBufferLength: Annotated[ULONG, SAL("_In_")],
                                       PreviousDeviceGroups: Annotated[P[TOKEN_GROUPS], SAL("_Out_writes_bytes_to_opt_(DeviceGroupsBufferLength, *DeviceGroupsReturnBufferLength)")],
                                       UserReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")],
                                       DeviceReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")],
                                       DeviceGroupsReturnBufferLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                                       ):
    raise NotImplementedError()

@syscall
def ZwAlertResumeThread(dp: Dumpulator,
                        ThreadHandle: Annotated[HANDLE, SAL("_In_")],
                        PreviousSuspendCount: Annotated[P[ULONG], SAL("_Out_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwAlertThread(dp: Dumpulator,
                  ThreadHandle: Annotated[HANDLE, SAL("_In_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwAlertThreadByThreadId(dp: Dumpulator,
                            ThreadId: Annotated[HANDLE, SAL("_In_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwAllocateLocallyUniqueId(dp: Dumpulator,
                              Luid: Annotated[P[LUID], SAL("_Out_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwAllocateReserveObject(dp: Dumpulator,
                            MemoryReserveHandle: Annotated[P[HANDLE], SAL("_Out_")],
                            ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                            Type: Annotated[MEMORY_RESERVE_TYPE, SAL("_In_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwAllocateUserPhysicalPages(dp: Dumpulator,
                                ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                                NumberOfPages: Annotated[P[ULONG_PTR], SAL("_Inout_")],
                                UserPfnArray: Annotated[P[ULONG_PTR], SAL("_Out_writes_(*NumberOfPages)")]
                                ):
    raise NotImplementedError()

@syscall
def ZwAllocateUserPhysicalPagesEx(dp: Dumpulator,
                                  ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                                  NumberOfPages: Annotated[P[ULONG_PTR], SAL("_Inout_")],
                                  UserPfnArray: Annotated[P[ULONG_PTR], SAL("_Out_writes_(*NumberOfPages)")],
                                  ExtendedParameters: Annotated[P[MEM_EXTENDED_PARAMETER], SAL("_Inout_updates_opt_(ParameterCount)")],
                                  ExtendedParameterCount: Annotated[ULONG, SAL("_In_")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwAllocateUuids(dp: Dumpulator,
                    Time: Annotated[P[ULARGE_INTEGER], SAL("_Out_")],
                    Range: Annotated[P[ULONG], SAL("_Out_")],
                    Sequence: Annotated[P[ULONG], SAL("_Out_")],
                    Seed: Annotated[P[CHAR], SAL("_Out_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwAllocateVirtualMemory(dp: Dumpulator,
                            ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                            BaseAddress: Annotated[P[PVOID], SAL("_Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize))")],
                            ZeroBits: Annotated[ULONG_PTR, SAL("_In_")],
                            RegionSize: Annotated[P[SIZE_T], SAL("_Inout_")],
                            AllocationType: Annotated[ULONG, SAL("_In_")],
                            Protect: Annotated[ULONG, SAL("_In_")]
                            ):
    assert ZeroBits == 0
    assert ProcessHandle == dp.NtCurrentProcess()
    base = dp.read_ptr(BaseAddress.ptr)
    assert base & 0xFFF == 0
    size = round_to_pages(dp.read_ptr(RegionSize.ptr))
    assert size != 0
    protect = MemoryProtect(Protect)
    if AllocationType == MEM_COMMIT:
        if base == 0:
            base = dp.memory.find_free(size)
            dp.memory.reserve(base, size, protect)
            BaseAddress.write_ptr(base)
            RegionSize.write_ptr(size)
        print(f"commit({hex(base)}[{hex(size)}], {protect})")
        dp.memory.commit(base, size, protect)
    elif AllocationType == MEM_RESERVE:
        if base == 0:
            base = dp.memory.find_free(size)
            BaseAddress.write_ptr(base)
            RegionSize.write_ptr(size)
        print(f"reserve({hex(base)}[{hex(size)}], {protect})")
        dp.memory.reserve(base, size, protect)
    elif AllocationType == MEM_COMMIT | MEM_RESERVE:
        if base == 0:
            base = dp.memory.find_free(size)
            BaseAddress.write_ptr(base)
            RegionSize.write_ptr(size)
        print(f"reserve+commit({hex(base)}[{hex(size)}], {protect})")
        dp.memory.reserve(base, size, protect)
        dp.memory.commit(base, size)
    else:
        raise NotImplementedError()
    return STATUS_SUCCESS

@syscall
def ZwAlpcAcceptConnectPort(dp: Dumpulator,
                            PortHandle: Annotated[P[HANDLE], SAL("_Out_")],
                            ConnectionPortHandle: Annotated[HANDLE, SAL("_In_")],
                            Flags: Annotated[ULONG, SAL("_In_")],
                            ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                            PortAttributes: Annotated[P[ALPC_PORT_ATTRIBUTES], SAL("_In_opt_")],
                            PortContext: Annotated[PVOID, SAL("_In_opt_")],
                            ConnectionRequest: Annotated[P[PORT_MESSAGE], SAL("_In_reads_bytes_(ConnectionRequest->u1.s1.TotalLength)")],
                            ConnectionMessageAttributes: Annotated[P[ALPC_MESSAGE_ATTRIBUTES], SAL("_Inout_opt_")],
                            AcceptConnection: Annotated[BOOLEAN, SAL("_In_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwAlpcCancelMessage(dp: Dumpulator,
                        PortHandle: Annotated[HANDLE, SAL("_In_")],
                        Flags: Annotated[ULONG, SAL("_In_")],
                        MessageContext: Annotated[P[ALPC_CONTEXT_ATTR], SAL("_In_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwAlpcConnectPort(dp: Dumpulator,
                      PortHandle: Annotated[P[HANDLE], SAL("_Out_")],
                      PortName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                      ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                      PortAttributes: Annotated[P[ALPC_PORT_ATTRIBUTES], SAL("_In_opt_")],
                      Flags: Annotated[ULONG, SAL("_In_")],
                      RequiredServerSid: Annotated[PSID, SAL("_In_opt_")],
                      ConnectionMessage: Annotated[P[PORT_MESSAGE], SAL("_Inout_updates_bytes_to_opt_(*BufferLength, *BufferLength)")],
                      BufferLength: Annotated[P[ULONG], SAL("_Inout_opt_")],
                      OutMessageAttributes: Annotated[P[ALPC_MESSAGE_ATTRIBUTES], SAL("_Inout_opt_")],
                      InMessageAttributes: Annotated[P[ALPC_MESSAGE_ATTRIBUTES], SAL("_Inout_opt_")],
                      Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwAlpcConnectPortEx(dp: Dumpulator,
                        PortHandle: Annotated[P[HANDLE], SAL("_Out_")],
                        ConnectionPortObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                        ClientPortObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                        PortAttributes: Annotated[P[ALPC_PORT_ATTRIBUTES], SAL("_In_opt_")],
                        Flags: Annotated[ULONG, SAL("_In_")],
                        ServerSecurityRequirements: Annotated[P[SECURITY_DESCRIPTOR], SAL("_In_opt_")],
                        ConnectionMessage: Annotated[P[PORT_MESSAGE], SAL("_Inout_updates_bytes_to_opt_(*BufferLength, *BufferLength)")],
                        BufferLength: Annotated[P[SIZE_T], SAL("_Inout_opt_")],
                        OutMessageAttributes: Annotated[P[ALPC_MESSAGE_ATTRIBUTES], SAL("_Inout_opt_")],
                        InMessageAttributes: Annotated[P[ALPC_MESSAGE_ATTRIBUTES], SAL("_Inout_opt_")],
                        Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwAlpcCreatePort(dp: Dumpulator,
                     PortHandle: Annotated[P[HANDLE], SAL("_Out_")],
                     ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                     PortAttributes: Annotated[P[ALPC_PORT_ATTRIBUTES], SAL("_In_opt_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwAlpcCreatePortSection(dp: Dumpulator,
                            PortHandle: Annotated[HANDLE, SAL("_In_")],
                            Flags: Annotated[ULONG, SAL("_In_")],
                            SectionHandle: Annotated[HANDLE, SAL("_In_opt_")],
                            SectionSize: Annotated[SIZE_T, SAL("_In_")],
                            AlpcSectionHandle: Annotated[P[ALPC_HANDLE], SAL("_Out_")],
                            ActualSectionSize: Annotated[P[SIZE_T], SAL("_Out_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwAlpcCreateResourceReserve(dp: Dumpulator,
                                PortHandle: Annotated[HANDLE, SAL("_In_")],
                                Flags: Annotated[ULONG, SAL("_Reserved_")],
                                MessageSize: Annotated[SIZE_T, SAL("_In_")],
                                ResourceId: Annotated[P[ALPC_HANDLE], SAL("_Out_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwAlpcCreateSectionView(dp: Dumpulator,
                            PortHandle: Annotated[HANDLE, SAL("_In_")],
                            Flags: Annotated[ULONG, SAL("_Reserved_")],
                            ViewAttributes: Annotated[P[ALPC_DATA_VIEW_ATTR], SAL("_Inout_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwAlpcCreateSecurityContext(dp: Dumpulator,
                                PortHandle: Annotated[HANDLE, SAL("_In_")],
                                Flags: Annotated[ULONG, SAL("_Reserved_")],
                                SecurityAttribute: Annotated[P[ALPC_SECURITY_ATTR], SAL("_Inout_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwAlpcDeletePortSection(dp: Dumpulator,
                            PortHandle: Annotated[HANDLE, SAL("_In_")],
                            Flags: Annotated[ULONG, SAL("_Reserved_")],
                            SectionHandle: Annotated[ALPC_HANDLE, SAL("_In_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwAlpcDeleteResourceReserve(dp: Dumpulator,
                                PortHandle: Annotated[HANDLE, SAL("_In_")],
                                Flags: Annotated[ULONG, SAL("_Reserved_")],
                                ResourceId: Annotated[ALPC_HANDLE, SAL("_In_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwAlpcDeleteSectionView(dp: Dumpulator,
                            PortHandle: Annotated[HANDLE, SAL("_In_")],
                            Flags: Annotated[ULONG, SAL("_Reserved_")],
                            ViewBase: Annotated[PVOID, SAL("_In_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwAlpcDeleteSecurityContext(dp: Dumpulator,
                                PortHandle: Annotated[HANDLE, SAL("_In_")],
                                Flags: Annotated[ULONG, SAL("_Reserved_")],
                                ContextHandle: Annotated[ALPC_HANDLE, SAL("_In_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwAlpcDisconnectPort(dp: Dumpulator,
                         PortHandle: Annotated[HANDLE, SAL("_In_")],
                         Flags: Annotated[ULONG, SAL("_In_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwAlpcImpersonateClientContainerOfPort(dp: Dumpulator,
                                           PortHandle: Annotated[HANDLE, SAL("_In_")],
                                           Message: Annotated[P[PORT_MESSAGE], SAL("_In_")],
                                           Flags: Annotated[ULONG, SAL("_In_")]
                                           ):
    raise NotImplementedError()

@syscall
def ZwAlpcImpersonateClientOfPort(dp: Dumpulator,
                                  PortHandle: Annotated[HANDLE, SAL("_In_")],
                                  Message: Annotated[P[PORT_MESSAGE], SAL("_In_")],
                                  Flags: Annotated[PVOID, SAL("_In_")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwAlpcOpenSenderProcess(dp: Dumpulator,
                            ProcessHandle: Annotated[P[HANDLE], SAL("_Out_")],
                            PortHandle: Annotated[HANDLE, SAL("_In_")],
                            PortMessage: Annotated[P[PORT_MESSAGE], SAL("_In_")],
                            Flags: Annotated[ULONG, SAL("_In_")],
                            DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                            ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwAlpcOpenSenderThread(dp: Dumpulator,
                           ThreadHandle: Annotated[P[HANDLE], SAL("_Out_")],
                           PortHandle: Annotated[HANDLE, SAL("_In_")],
                           PortMessage: Annotated[P[PORT_MESSAGE], SAL("_In_")],
                           Flags: Annotated[ULONG, SAL("_In_")],
                           DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                           ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwAlpcQueryInformation(dp: Dumpulator,
                           PortHandle: Annotated[HANDLE, SAL("_In_opt_")],
                           PortInformationClass: Annotated[ALPC_PORT_INFORMATION_CLASS, SAL("_In_")],
                           PortInformation: Annotated[PVOID, SAL("_Inout_updates_bytes_to_(Length, *ReturnLength)")],
                           Length: Annotated[ULONG, SAL("_In_")],
                           ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwAlpcQueryInformationMessage(dp: Dumpulator,
                                  PortHandle: Annotated[HANDLE, SAL("_In_")],
                                  PortMessage: Annotated[P[PORT_MESSAGE], SAL("_In_")],
                                  MessageInformationClass: Annotated[ALPC_MESSAGE_INFORMATION_CLASS, SAL("_In_")],
                                  MessageInformation: Annotated[PVOID, SAL("_Out_writes_bytes_to_opt_(Length, *ReturnLength)")],
                                  Length: Annotated[ULONG, SAL("_In_")],
                                  ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwAlpcRevokeSecurityContext(dp: Dumpulator,
                                PortHandle: Annotated[HANDLE, SAL("_In_")],
                                Flags: Annotated[ULONG, SAL("_Reserved_")],
                                ContextHandle: Annotated[ALPC_HANDLE, SAL("_In_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwAlpcSendWaitReceivePort(dp: Dumpulator,
                              PortHandle: Annotated[HANDLE, SAL("_In_")],
                              Flags: Annotated[ULONG, SAL("_In_")],
                              SendMessageA: Annotated[P[PORT_MESSAGE], SAL("_In_reads_bytes_opt_(SendMessage->u1.s1.TotalLength)")],
                              SendMessageAttributes: Annotated[P[ALPC_MESSAGE_ATTRIBUTES], SAL("_Inout_opt_")],
                              ReceiveMessage: Annotated[P[PORT_MESSAGE], SAL("_Out_writes_bytes_to_opt_(*BufferLength, *BufferLength)")],
                              BufferLength: Annotated[P[SIZE_T], SAL("_Inout_opt_")],
                              ReceiveMessageAttributes: Annotated[P[ALPC_MESSAGE_ATTRIBUTES], SAL("_Inout_opt_")],
                              Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwAlpcSetInformation(dp: Dumpulator,
                         PortHandle: Annotated[HANDLE, SAL("_In_")],
                         PortInformationClass: Annotated[ALPC_PORT_INFORMATION_CLASS, SAL("_In_")],
                         PortInformation: Annotated[PVOID, SAL("_In_reads_bytes_opt_(Length)")],
                         Length: Annotated[ULONG, SAL("_In_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwAreMappedFilesTheSame(dp: Dumpulator,
                            File1MappedAsAnImage: Annotated[PVOID, SAL("_In_")],
                            File2MappedAsFile: Annotated[PVOID, SAL("_In_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwAssignProcessToJobObject(dp: Dumpulator,
                               JobHandle: Annotated[HANDLE, SAL("_In_")],
                               ProcessHandle: Annotated[HANDLE, SAL("_In_")]
                               ):
    raise NotImplementedError()

@syscall
def ZwAssociateWaitCompletionPacket(dp: Dumpulator,
                                    WaitCompletionPacketHandle: Annotated[HANDLE, SAL("_In_")],
                                    IoCompletionHandle: Annotated[HANDLE, SAL("_In_")],
                                    TargetObjectHandle: Annotated[HANDLE, SAL("_In_")],
                                    KeyContext: Annotated[PVOID, SAL("_In_opt_")],
                                    ApcContext: Annotated[PVOID, SAL("_In_opt_")],
                                    IoStatus: Annotated[NTSTATUS, SAL("_In_")],
                                    IoStatusInformation: Annotated[ULONG_PTR, SAL("_In_")],
                                    AlreadySignaled: Annotated[P[BOOLEAN], SAL("_Out_opt_")]
                                    ):
    raise NotImplementedError()

@syscall
def ZwCallbackReturn(dp: Dumpulator,
                     OutputBuffer: Annotated[PVOID, SAL("_In_reads_bytes_opt_(OutputLength)")],
                     OutputLength: Annotated[ULONG, SAL("_In_")],
                     Status: Annotated[NTSTATUS, SAL("_In_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwCallEnclave(dp: Dumpulator,
                  Routine: Annotated[P[ENCLAVE_ROUTINE], SAL("_In_")],
                  Parameter: Annotated[PVOID, SAL("_In_")],
                  WaitForThread: Annotated[BOOLEAN, SAL("_In_")],
                  ReturnValue: Annotated[P[PVOID], SAL("_Out_opt_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwCancelIoFile(dp: Dumpulator,
                   FileHandle: Annotated[HANDLE, SAL("_In_")],
                   IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")]
                   ):
    raise NotImplementedError()

@syscall
def ZwCancelIoFileEx(dp: Dumpulator,
                     FileHandle: Annotated[HANDLE, SAL("_In_")],
                     IoRequestToCancel: Annotated[P[IO_STATUS_BLOCK], SAL("_In_opt_")],
                     IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwCancelSynchronousIoFile(dp: Dumpulator,
                              ThreadHandle: Annotated[HANDLE, SAL("_In_")],
                              IoRequestToCancel: Annotated[P[IO_STATUS_BLOCK], SAL("_In_opt_")],
                              IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwCancelTimer(dp: Dumpulator,
                  TimerHandle: Annotated[HANDLE, SAL("_In_")],
                  CurrentState: Annotated[P[BOOLEAN], SAL("_Out_opt_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwCancelTimer2(dp: Dumpulator,
                   TimerHandle: Annotated[HANDLE, SAL("_In_")],
                   Parameters: Annotated[P[T2_CANCEL_PARAMETERS], SAL("_In_")]
                   ):
    raise NotImplementedError()

@syscall
def ZwCancelWaitCompletionPacket(dp: Dumpulator,
                                 WaitCompletionPacketHandle: Annotated[HANDLE, SAL("_In_")],
                                 RemoveSignaledPacket: Annotated[BOOLEAN, SAL("_In_")]
                                 ):
    raise NotImplementedError()

@syscall
def ZwChangeProcessState(dp: Dumpulator,
                         ProcessStateChangeHandle: Annotated[HANDLE, SAL("_In_")],
                         ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                         StateChangeType: Annotated[PROCESS_STATE_CHANGE_TYPE, SAL("_In_")],
                         ExtendedInformation: Annotated[PVOID, SAL("_In_opt_")],
                         ExtendedInformationLength: Annotated[SIZE_T, SAL("_In_opt_")],
                         Reserved: Annotated[ULONG64, SAL("_In_opt_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwChangeThreadState(dp: Dumpulator,
                        ThreadStateChangeHandle: Annotated[HANDLE, SAL("_In_")],
                        ThreadHandle: Annotated[HANDLE, SAL("_In_")],
                        StateChangeType: Annotated[THREAD_STATE_CHANGE_TYPE, SAL("_In_")],
                        ExtendedInformation: Annotated[PVOID, SAL("_In_opt_")],
                        ExtendedInformationLength: Annotated[SIZE_T, SAL("_In_opt_")],
                        Reserved: Annotated[ULONG64, SAL("_In_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwClearEvent(dp: Dumpulator,
                 EventHandle: Annotated[HANDLE, SAL("_In_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwClose(dp: Dumpulator,
            Handle: Annotated[HANDLE, SAL("_In_ _Post_ptr_invalid_")]
            ):
    if dp.handles.valid(Handle):
        dp.handles.close(Handle)
        return STATUS_SUCCESS
    return STATUS_INVALID_HANDLE

@syscall
def ZwCloseObjectAuditAlarm(dp: Dumpulator,
                            SubsystemName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                            HandleId: Annotated[PVOID, SAL("_In_opt_")],
                            GenerateOnClose: Annotated[BOOLEAN, SAL("_In_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwCommitComplete(dp: Dumpulator,
                     EnlistmentHandle: Annotated[HANDLE, SAL("_In_")],
                     TmVirtualClock: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwCommitEnlistment(dp: Dumpulator,
                       EnlistmentHandle: Annotated[HANDLE, SAL("_In_")],
                       TmVirtualClock: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwCommitTransaction(dp: Dumpulator,
                        TransactionHandle: Annotated[HANDLE, SAL("_In_")],
                        Wait: Annotated[BOOLEAN, SAL("_In_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwCompactKeys(dp: Dumpulator,
                  Count: Annotated[ULONG, SAL("_In_")],
                  KeyArray: Annotated[P[HANDLE], SAL("_In_reads_(Count)")]
                  ):
    raise NotImplementedError()

@syscall
def ZwCompareObjects(dp: Dumpulator,
                     FirstObjectHandle: Annotated[HANDLE, SAL("_In_")],
                     SecondObjectHandle: Annotated[HANDLE, SAL("_In_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwCompareSigningLevels(dp: Dumpulator,
                           FirstSigningLevel: Annotated[SE_SIGNING_LEVEL, SAL("_In_")],
                           SecondSigningLevel: Annotated[SE_SIGNING_LEVEL, SAL("_In_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwCompareTokens(dp: Dumpulator,
                    FirstTokenHandle: Annotated[HANDLE, SAL("_In_")],
                    SecondTokenHandle: Annotated[HANDLE, SAL("_In_")],
                    Equal: Annotated[P[BOOLEAN], SAL("_Out_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwCompleteConnectPort(dp: Dumpulator,
                          PortHandle: Annotated[HANDLE, SAL("_In_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwCompressKey(dp: Dumpulator,
                  Key: Annotated[HANDLE, SAL("_In_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwConnectPort(dp: Dumpulator,
                  PortHandle: Annotated[P[HANDLE], SAL("_Out_")],
                  PortName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                  SecurityQos: Annotated[P[SECURITY_QUALITY_OF_SERVICE], SAL("_In_")],
                  ClientView: Annotated[P[PORT_VIEW], SAL("_Inout_opt_")],
                  ServerView: Annotated[P[REMOTE_PORT_VIEW], SAL("_Inout_opt_")],
                  MaxMessageLength: Annotated[P[ULONG], SAL("_Out_opt_")],
                  ConnectionInformation: Annotated[PVOID, SAL("_Inout_updates_bytes_to_opt_(*ConnectionInformationLength, *ConnectionInformationLength)")],
                  ConnectionInformationLength: Annotated[P[ULONG], SAL("_Inout_opt_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwContinue(dp: Dumpulator,
               ContextRecord: Annotated[P[CONTEXT], SAL("_In_")],
               TestAlert: Annotated[BOOLEAN, SAL("_In_")]
               ):
    # Trigger a context switch
    assert not TestAlert

    # TODO: move this to a dedicated helper method
    from .dumpulator import UnicornExceptionInfo, ExceptionType
    exception = UnicornExceptionInfo()
    exception.type = ExceptionType.ContextSwitch
    exception.final = True
    context_type = CONTEXT if dp.ptr_size() == 8 else WOW64_CONTEXT
    context_size = ctypes.sizeof(context_type)
    data = dp.read(ContextRecord.ptr, context_size)
    context = context_type.from_buffer(data)
    context.to_regs(dp.regs)
    # Modifying fs/gs also appears to reset fs_base/gs_base
    if dp.x64:
        dp.regs.gs_base = dp.teb
    else:
        dp.regs.fs_base = dp.teb
        dp.regs.gs_base = dp.teb - 2 * PAGE_SIZE
    exception.context = dp._uc.context_save()
    return exception

@syscall
def ZwContinueEx(dp: Dumpulator,
                 ContextRecord: Annotated[P[CONTEXT], SAL("_In_")],
                 ContinueArgument: Annotated[PVOID, SAL("_In_", "PKCONTINUE_ARGUMENT and BOOLEAN are valid")]
                 ):
    raise NotImplementedError()

@syscall
def ZwCreateDebugObject(dp: Dumpulator,
                        DebugObjectHandle: Annotated[P[HANDLE], SAL("_Out_")],
                        DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                        ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                        Flags: Annotated[ULONG, SAL("_In_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwCreateDirectoryObject(dp: Dumpulator,
                            DirectoryHandle: Annotated[P[HANDLE], SAL("_Out_")],
                            DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                            ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwCreateDirectoryObjectEx(dp: Dumpulator,
                              DirectoryHandle: Annotated[P[HANDLE], SAL("_Out_")],
                              DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                              ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                              ShadowDirectoryHandle: Annotated[HANDLE, SAL("_In_")],
                              Flags: Annotated[ULONG, SAL("_In_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwCreateEnclave(dp: Dumpulator,
                    ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                    BaseAddress: Annotated[P[PVOID], SAL("_Inout_")],
                    ZeroBits: Annotated[ULONG_PTR, SAL("_In_")],
                    Size: Annotated[SIZE_T, SAL("_In_")],
                    InitialCommitment: Annotated[SIZE_T, SAL("_In_")],
                    EnclaveType: Annotated[ULONG, SAL("_In_")],
                    EnclaveInformation: Annotated[PVOID, SAL("_In_reads_bytes_(EnclaveInformationLength)")],
                    EnclaveInformationLength: Annotated[ULONG, SAL("_In_")],
                    EnclaveError: Annotated[P[ULONG], SAL("_Out_opt_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwCreateEnlistment(dp: Dumpulator,
                       EnlistmentHandle: Annotated[P[HANDLE], SAL("_Out_")],
                       DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                       ResourceManagerHandle: Annotated[HANDLE, SAL("_In_")],
                       TransactionHandle: Annotated[HANDLE, SAL("_In_")],
                       ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                       CreateOptions: Annotated[ULONG, SAL("_In_opt_")],
                       NotificationMask: Annotated[NOTIFICATION_MASK, SAL("_In_")],
                       EnlistmentKey: Annotated[PVOID, SAL("_In_opt_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwCreateEvent(dp: Dumpulator,
                  EventHandle: Annotated[P[HANDLE], SAL("_Out_")],
                  DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                  ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                  EventType: Annotated[EVENT_TYPE, SAL("_In_")],
                  InitialState: Annotated[BOOLEAN, SAL("_In_")]
                  ):
    assert DesiredAccess == 0x1f0003
    if ObjectAttributes != 0:
        attributes = ObjectAttributes[0]
        assert attributes.ObjectName == 0
        assert attributes.RootDirectory == 0
        assert attributes.SecurityDescriptor == 0
        assert attributes.SecurityQualityOfService == 0
        assert attributes.Attributes == 2  # OBJ_INHERIT
    event = EventObject(EventType, InitialState != 0)
    handle = dp.handles.new(event)
    EventHandle.write_ptr(handle)
    return STATUS_SUCCESS

@syscall
def ZwCreateEventPair(dp: Dumpulator,
                      EventPairHandle: Annotated[P[HANDLE], SAL("_Out_")],
                      DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                      ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwCreateFile(dp: Dumpulator,
                 FileHandle: Annotated[P[HANDLE], SAL("_Out_")],
                 DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                 ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                 IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                 AllocationSize: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")],
                 FileAttributes: Annotated[ULONG, SAL("_In_")],
                 ShareAccess: Annotated[ULONG, SAL("_In_")],
                 CreateDisposition: Annotated[ULONG, SAL("_In_")],
                 CreateOptions: Annotated[ULONG, SAL("_In_")],
                 EaBuffer: Annotated[PVOID, SAL("_In_reads_bytes_opt_(EaLength)")],
                 EaLength: Annotated[ULONG, SAL("_In_")]
                 ):
    assert ObjectAttributes.ptr != 0
    file_name = ObjectAttributes[0].ObjectName[0].read_str()
    print(f"create/open {file_name}")
    assert FileHandle.ptr != 0
    assert IoStatusBlock.ptr != 0
    #assert EaBuffer.ptr == 0
    #assert EaLength == 0

    if file_name == "\\Device\\ConDrv\\Server":
        assert DesiredAccess == 0x12019f
        assert AllocationSize.ptr == 0x0
        assert FileAttributes == 0x0
        assert ShareAccess == 0x7
        assert CreateDisposition == 0x2
        assert CreateOptions == 0
        handle = dp.console_handle
        if handle == 0:
            handle = dp.handles.new(None)
            dp.console_handle = handle
        elif not dp.handles.valid(handle):
            dp.handles.add(handle, None)
        FileHandle.write_ptr(handle)
        IO_STATUS_BLOCK.write(IoStatusBlock, STATUS_SUCCESS, FILE_OPENED)
        return STATUS_SUCCESS
    elif file_name == "\\Reference":
        handle = dp.handles.new(FileHandle(file_name))
        FileHandle.write_ptr(handle)
        IO_STATUS_BLOCK.write(IoStatusBlock, STATUS_SUCCESS, FILE_OPENED)
        return STATUS_SUCCESS
    elif file_name == "\\Connect":
        handle = dp.handles.new(FileHandle(file_name))
        FileHandle.write_ptr(handle)
        IO_STATUS_BLOCK.write(IoStatusBlock, STATUS_SUCCESS, FILE_OPENED)
        return STATUS_SUCCESS
    elif file_name == "\\Input":
        handle = dp.console_handle
        if handle == 0:
            handle = dp.handles.new(None)
            dp.stdin_handle = handle
        elif not dp.handles.valid(handle):
            dp.handles.add(handle, None)
        FileHandle.write_ptr(handle)
        IO_STATUS_BLOCK.write(IoStatusBlock, STATUS_SUCCESS, FILE_OPENED)
        return STATUS_SUCCESS
    elif file_name == "\\Output":
        handle = dp.console_handle
        if handle == 0:
            handle = dp.handles.new(None)
            dp.stdout_handle = handle
        elif not dp.handles.valid(handle):
            dp.handles.add(handle, None)
        FileHandle.write_ptr(handle)
        IO_STATUS_BLOCK.write(IoStatusBlock, STATUS_SUCCESS, FILE_OPENED)
        return STATUS_SUCCESS
    else:
        handle = dp.handles.open_file(file_name)
        if handle is None:
            return STATUS_NO_SUCH_FILE
        print(f"Created handle {hex(handle)}")
        FileHandle.write_ptr(handle)
        IO_STATUS_BLOCK.write(IoStatusBlock, STATUS_SUCCESS, FILE_OPENED)
        return STATUS_SUCCESS

@syscall
def ZwCreateIoCompletion(dp: Dumpulator,
                         IoCompletionHandle: Annotated[P[HANDLE], SAL("_Out_")],
                         DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                         ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                         Count: Annotated[ULONG, SAL("_In_opt_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwCreateIRTimer(dp: Dumpulator,
                    TimerHandle: Annotated[P[HANDLE], SAL("_Out_")],
                    DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwCreateJobObject(dp: Dumpulator,
                      JobHandle: Annotated[P[HANDLE], SAL("_Out_")],
                      DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                      ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwCreateJobSet(dp: Dumpulator,
                   NumJob: Annotated[ULONG, SAL("_In_")],
                   UserJobSet: Annotated[P[JOB_SET_ARRAY], SAL("_In_reads_(NumJob)")],
                   Flags: Annotated[ULONG, SAL("_In_")]
                   ):
    raise NotImplementedError()

@syscall
def ZwCreateKey(dp: Dumpulator,
                KeyHandle: Annotated[P[HANDLE], SAL("_Out_")],
                DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                TitleIndex: Annotated[ULONG, SAL("_Reserved_")],
                Class: Annotated[P[UNICODE_STRING], SAL("_In_opt_")],
                CreateOptions: Annotated[ULONG, SAL("_In_")],
                Disposition: Annotated[P[ULONG], SAL("_Out_opt_")]
                ):
    raise NotImplementedError()

@syscall
def ZwCreateKeyedEvent(dp: Dumpulator,
                       KeyedEventHandle: Annotated[P[HANDLE], SAL("_Out_")],
                       DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                       ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                       Flags: Annotated[ULONG, SAL("_In_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwCreateKeyTransacted(dp: Dumpulator,
                          KeyHandle: Annotated[P[HANDLE], SAL("_Out_")],
                          DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                          ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                          TitleIndex: Annotated[ULONG, SAL("_Reserved_")],
                          Class: Annotated[P[UNICODE_STRING], SAL("_In_opt_")],
                          CreateOptions: Annotated[ULONG, SAL("_In_")],
                          TransactionHandle: Annotated[HANDLE, SAL("_In_")],
                          Disposition: Annotated[P[ULONG], SAL("_Out_opt_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwCreateLowBoxToken(dp: Dumpulator,
                        TokenHandle: Annotated[P[HANDLE], SAL("_Out_")],
                        ExistingTokenHandle: Annotated[HANDLE, SAL("_In_")],
                        DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                        ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                        PackageSid: Annotated[PSID, SAL("_In_")],
                        CapabilityCount: Annotated[ULONG, SAL("_In_")],
                        Capabilities: Annotated[P[SID_AND_ATTRIBUTES], SAL("_In_reads_opt_(CapabilityCount)")],
                        HandleCount: Annotated[ULONG, SAL("_In_")],
                        Handles: Annotated[P[HANDLE], SAL("_In_reads_opt_(HandleCount)")]
                        ):
    raise NotImplementedError()

@syscall
def ZwCreateMailslotFile(dp: Dumpulator,
                         FileHandle: Annotated[P[HANDLE], SAL("_Out_")],
                         DesiredAccess: Annotated[ULONG, SAL("_In_")],
                         ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                         IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                         CreateOptions: Annotated[ULONG, SAL("_In_")],
                         MailslotQuota: Annotated[ULONG, SAL("_In_")],
                         MaximumMessageSize: Annotated[ULONG, SAL("_In_")],
                         ReadTimeout: Annotated[P[LARGE_INTEGER], SAL("_In_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwCreateMutant(dp: Dumpulator,
                   MutantHandle: Annotated[P[HANDLE], SAL("_Out_")],
                   DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                   ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                   InitialOwner: Annotated[BOOLEAN, SAL("_In_")]
                   ):
    raise NotImplementedError()

@syscall
def ZwCreateNamedPipeFile(dp: Dumpulator,
                          FileHandle: Annotated[P[HANDLE], SAL("_Out_")],
                          DesiredAccess: Annotated[ULONG, SAL("_In_")],
                          ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                          IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                          ShareAccess: Annotated[ULONG, SAL("_In_")],
                          CreateDisposition: Annotated[ULONG, SAL("_In_")],
                          CreateOptions: Annotated[ULONG, SAL("_In_")],
                          NamedPipeType: Annotated[ULONG, SAL("_In_")],
                          ReadMode: Annotated[ULONG, SAL("_In_")],
                          CompletionMode: Annotated[ULONG, SAL("_In_")],
                          MaximumInstances: Annotated[ULONG, SAL("_In_")],
                          InboundQuota: Annotated[ULONG, SAL("_In_")],
                          OutboundQuota: Annotated[ULONG, SAL("_In_")],
                          DefaultTimeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwCreatePagingFile(dp: Dumpulator,
                       PageFileName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                       MinimumSize: Annotated[P[LARGE_INTEGER], SAL("_In_")],
                       MaximumSize: Annotated[P[LARGE_INTEGER], SAL("_In_")],
                       Priority: Annotated[ULONG, SAL("_In_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwCreatePartition(dp: Dumpulator,
                      ParentPartitionHandle: Annotated[HANDLE, SAL("_In_")],
                      PartitionHandle: Annotated[P[HANDLE], SAL("_Out_")],
                      DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                      ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                      PreferredNode: Annotated[ULONG, SAL("_In_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwCreatePort(dp: Dumpulator,
                 PortHandle: Annotated[P[HANDLE], SAL("_Out_")],
                 ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                 MaxConnectionInfoLength: Annotated[ULONG, SAL("_In_")],
                 MaxMessageLength: Annotated[ULONG, SAL("_In_")],
                 MaxPoolUsage: Annotated[ULONG, SAL("_In_opt_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwCreatePrivateNamespace(dp: Dumpulator,
                             NamespaceHandle: Annotated[P[HANDLE], SAL("_Out_")],
                             DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                             ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                             BoundaryDescriptor: Annotated[P[OBJECT_BOUNDARY_DESCRIPTOR], SAL("_In_")]
                             ):
    raise NotImplementedError()

@syscall
def ZwCreateProcess(dp: Dumpulator,
                    ProcessHandle: Annotated[P[HANDLE], SAL("_Out_")],
                    DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                    ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                    ParentProcess: Annotated[HANDLE, SAL("_In_")],
                    InheritObjectTable: Annotated[BOOLEAN, SAL("_In_")],
                    SectionHandle: Annotated[HANDLE, SAL("_In_opt_")],
                    DebugPort: Annotated[HANDLE, SAL("_In_opt_")],
                    TokenHandle: Annotated[HANDLE, SAL("_In_opt_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwCreateProcessEx(dp: Dumpulator,
                      ProcessHandle: Annotated[P[HANDLE], SAL("_Out_")],
                      DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                      ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                      ParentProcess: Annotated[HANDLE, SAL("_In_")],
                      Flags: Annotated[ULONG, SAL("_In_", "PROCESS_CREATE_FLAGS_*")],
                      SectionHandle: Annotated[HANDLE, SAL("_In_opt_")],
                      DebugPort: Annotated[HANDLE, SAL("_In_opt_")],
                      TokenHandle: Annotated[HANDLE, SAL("_In_opt_")],
                      Reserved: Annotated[ULONG, SAL("_Reserved_", "JobMemberLevel")]
                      ):
    raise NotImplementedError()

@syscall
def ZwCreateProcessStateChange(dp: Dumpulator,
                               ProcessStateChangeHandle: Annotated[P[HANDLE], SAL("_Out_")],
                               DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                               ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                               ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                               Reserved: Annotated[ULONG64, SAL("_In_opt_")]
                               ):
    raise NotImplementedError()

@syscall
def ZwCreateProfile(dp: Dumpulator,
                    ProfileHandle: Annotated[P[HANDLE], SAL("_Out_")],
                    Process: Annotated[HANDLE, SAL("_In_opt_")],
                    ProfileBase: Annotated[PVOID, SAL("_In_")],
                    ProfileSize: Annotated[SIZE_T, SAL("_In_")],
                    BucketSize: Annotated[ULONG, SAL("_In_")],
                    Buffer: Annotated[P[ULONG], SAL("_In_reads_bytes_(BufferSize)")],
                    BufferSize: Annotated[ULONG, SAL("_In_")],
                    ProfileSource: Annotated[KPROFILE_SOURCE, SAL("_In_")],
                    Affinity: Annotated[KAFFINITY, SAL("_In_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwCreateProfileEx(dp: Dumpulator,
                      ProfileHandle: Annotated[P[HANDLE], SAL("_Out_")],
                      Process: Annotated[HANDLE, SAL("_In_opt_")],
                      ProfileBase: Annotated[PVOID, SAL("_In_")],
                      ProfileSize: Annotated[SIZE_T, SAL("_In_")],
                      BucketSize: Annotated[ULONG, SAL("_In_")],
                      Buffer: Annotated[P[ULONG], SAL("_In_reads_bytes_(BufferSize)")],
                      BufferSize: Annotated[ULONG, SAL("_In_")],
                      ProfileSource: Annotated[KPROFILE_SOURCE, SAL("_In_")],
                      GroupCount: Annotated[USHORT, SAL("_In_")],
                      GroupAffinity: Annotated[P[GROUP_AFFINITY], SAL("_In_reads_(GroupCount)")]
                      ):
    raise NotImplementedError()

@syscall
def ZwCreateResourceManager(dp: Dumpulator,
                            ResourceManagerHandle: Annotated[P[HANDLE], SAL("_Out_")],
                            DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                            TmHandle: Annotated[HANDLE, SAL("_In_")],
                            RmGuid: Annotated[P[GUID], SAL("_In_")],
                            ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                            CreateOptions: Annotated[ULONG, SAL("_In_opt_")],
                            Description: Annotated[P[UNICODE_STRING], SAL("_In_opt_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwCreateSection(dp: Dumpulator,
                    SectionHandle: Annotated[P[HANDLE], SAL("_Out_")],
                    DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                    ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                    MaximumSize: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")],
                    SectionPageProtection: Annotated[ULONG, SAL("_In_")],
                    AllocationAttributes: Annotated[ULONG, SAL("_In_")],
                    FileHandle: Annotated[HANDLE, SAL("_In_opt_")]
                    ):
    assert SectionHandle != 0
    assert DesiredAccess == 0xd
    assert ObjectAttributes == 0
    assert MaximumSize == 0
    assert SectionPageProtection == PAGE_EXECUTE
    assert AllocationAttributes == MEM_IMAGE
    file = dp.handles.get(FileHandle, AbstractFileObject)
    assert file is not None
    section_handle = dp.handles.new(SectionObject(file))
    SectionHandle.write_ptr(section_handle)
    return STATUS_SUCCESS

@syscall
def ZwCreateSectionEx(dp: Dumpulator,
                      SectionHandle: Annotated[P[HANDLE], SAL("_Out_")],
                      DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                      ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                      MaximumSize: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")],
                      SectionPageProtection: Annotated[ULONG, SAL("_In_")],
                      AllocationAttributes: Annotated[ULONG, SAL("_In_")],
                      FileHandle: Annotated[HANDLE, SAL("_In_opt_")],
                      ExtendedParameters: Annotated[P[MEM_EXTENDED_PARAMETER], SAL("_Inout_updates_opt_(ExtendedParameterCount)")],
                      ExtendedParameterCount: Annotated[ULONG, SAL("_In_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwCreateSemaphore(dp: Dumpulator,
                      SemaphoreHandle: Annotated[P[HANDLE], SAL("_Out_")],
                      DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                      ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                      InitialCount: Annotated[LONG, SAL("_In_")],
                      MaximumCount: Annotated[LONG, SAL("_In_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwCreateSymbolicLinkObject(dp: Dumpulator,
                               LinkHandle: Annotated[P[HANDLE], SAL("_Out_")],
                               DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                               ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                               LinkTarget: Annotated[P[UNICODE_STRING], SAL("_In_")]
                               ):
    raise NotImplementedError()

@syscall
def ZwCreateThread(dp: Dumpulator,
                   ThreadHandle: Annotated[P[HANDLE], SAL("_Out_")],
                   DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                   ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                   ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                   ClientId: Annotated[P[CLIENT_ID], SAL("_Out_")],
                   ThreadContext: Annotated[P[CONTEXT], SAL("_In_")],
                   InitialTeb: Annotated[P[INITIAL_TEB], SAL("_In_")],
                   CreateSuspended: Annotated[BOOLEAN, SAL("_In_")]
                   ):
    raise NotImplementedError()

@syscall
def ZwCreateThreadEx(dp: Dumpulator,
                     ThreadHandle: Annotated[P[HANDLE], SAL("_Out_")],
                     DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                     ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                     ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                     StartRoutine: Annotated[PVOID, SAL("_In_", "PUSER_THREAD_START_ROUTINE")],
                     Argument: Annotated[PVOID, SAL("_In_opt_")],
                     CreateFlags: Annotated[ULONG, SAL("_In_", "THREAD_CREATE_FLAGS_*")],
                     ZeroBits: Annotated[SIZE_T, SAL("_In_")],
                     StackSize: Annotated[SIZE_T, SAL("_In_")],
                     MaximumStackSize: Annotated[SIZE_T, SAL("_In_")],
                     AttributeList: Annotated[P[PS_ATTRIBUTE_LIST], SAL("_In_opt_")]
                     ):
    assert DesiredAccess == 0x1fffff
    assert ObjectAttributes == 0
    assert ProcessHandle == dp.NtCurrentProcess()
    assert CreateFlags == 0
    assert ZeroBits == 0
    assert StackSize == 0
    assert MaximumStackSize == 0
    # TODO: sanity check AttributeList
    thread = ThreadObject(StartRoutine.ptr, Argument.ptr)
    handle = dp.handles.new(thread)
    print(f"Started new thread {thread}, handle: {hex(handle)}")
    dp.write_ptr(ThreadHandle, handle)
    return STATUS_SUCCESS

@syscall
def ZwCreateThreadStateChange(dp: Dumpulator,
                              ThreadStateChangeHandle: Annotated[P[HANDLE], SAL("_Out_")],
                              DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                              ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                              ThreadHandle: Annotated[HANDLE, SAL("_In_")],
                              Reserved: Annotated[ULONG64, SAL("_In_opt_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwCreateTimer(dp: Dumpulator,
                  TimerHandle: Annotated[P[HANDLE], SAL("_Out_")],
                  DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                  ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                  TimerType: Annotated[TIMER_TYPE, SAL("_In_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwCreateTimer2(dp: Dumpulator,
                   TimerHandle: Annotated[P[HANDLE], SAL("_Out_")],
                   Reserved1: Annotated[PVOID, SAL("_In_opt_")],
                   ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                   Attributes: Annotated[ULONG, SAL("_In_")],
                   DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")]
                   ):
    raise NotImplementedError()

@syscall
def ZwCreateToken(dp: Dumpulator,
                  TokenHandle: Annotated[P[HANDLE], SAL("_Out_")],
                  DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                  ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                  Type: Annotated[TOKEN_TYPE, SAL("_In_")],
                  AuthenticationId: Annotated[P[LUID], SAL("_In_")],
                  ExpirationTime: Annotated[P[LARGE_INTEGER], SAL("_In_")],
                  User: Annotated[P[TOKEN_USER], SAL("_In_")],
                  Groups: Annotated[P[TOKEN_GROUPS], SAL("_In_")],
                  Privileges: Annotated[P[TOKEN_PRIVILEGES], SAL("_In_")],
                  Owner: Annotated[P[TOKEN_OWNER], SAL("_In_opt_")],
                  PrimaryGroup: Annotated[P[TOKEN_PRIMARY_GROUP], SAL("_In_")],
                  DefaultDacl: Annotated[P[TOKEN_DEFAULT_DACL], SAL("_In_opt_")],
                  Source: Annotated[P[TOKEN_SOURCE], SAL("_In_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwCreateTokenEx(dp: Dumpulator,
                    TokenHandle: Annotated[P[HANDLE], SAL("_Out_")],
                    DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                    ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                    Type: Annotated[TOKEN_TYPE, SAL("_In_")],
                    AuthenticationId: Annotated[P[LUID], SAL("_In_")],
                    ExpirationTime: Annotated[P[LARGE_INTEGER], SAL("_In_")],
                    User: Annotated[P[TOKEN_USER], SAL("_In_")],
                    Groups: Annotated[P[TOKEN_GROUPS], SAL("_In_")],
                    Privileges: Annotated[P[TOKEN_PRIVILEGES], SAL("_In_")],
                    UserAttributes: Annotated[P[TOKEN_SECURITY_ATTRIBUTES_INFORMATION], SAL("_In_opt_")],
                    DeviceAttributes: Annotated[P[TOKEN_SECURITY_ATTRIBUTES_INFORMATION], SAL("_In_opt_")],
                    DeviceGroups: Annotated[P[TOKEN_GROUPS], SAL("_In_opt_")],
                    MandatoryPolicy: Annotated[P[TOKEN_MANDATORY_POLICY], SAL("_In_opt_")],
                    Owner: Annotated[P[TOKEN_OWNER], SAL("_In_opt_")],
                    PrimaryGroup: Annotated[P[TOKEN_PRIMARY_GROUP], SAL("_In_")],
                    DefaultDacl: Annotated[P[TOKEN_DEFAULT_DACL], SAL("_In_opt_")],
                    Source: Annotated[P[TOKEN_SOURCE], SAL("_In_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwCreateTransaction(dp: Dumpulator,
                        TransactionHandle: Annotated[P[HANDLE], SAL("_Out_")],
                        DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                        ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                        Uow: Annotated[P[GUID], SAL("_In_opt_")],
                        TmHandle: Annotated[HANDLE, SAL("_In_opt_")],
                        CreateOptions: Annotated[ULONG, SAL("_In_opt_")],
                        IsolationLevel: Annotated[ULONG, SAL("_In_opt_")],
                        IsolationFlags: Annotated[ULONG, SAL("_In_opt_")],
                        Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")],
                        Description: Annotated[P[UNICODE_STRING], SAL("_In_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwCreateTransactionManager(dp: Dumpulator,
                               TmHandle: Annotated[P[HANDLE], SAL("_Out_")],
                               DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                               ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                               LogFileName: Annotated[P[UNICODE_STRING], SAL("_In_opt_")],
                               CreateOptions: Annotated[ULONG, SAL("_In_opt_")],
                               CommitStrength: Annotated[ULONG, SAL("_In_opt_")]
                               ):
    raise NotImplementedError()

@syscall
def ZwCreateUserProcess(dp: Dumpulator,
                        ProcessHandle: Annotated[P[HANDLE], SAL("_Out_")],
                        ThreadHandle: Annotated[P[HANDLE], SAL("_Out_")],
                        ProcessDesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                        ThreadDesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                        ProcessObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                        ThreadObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                        ProcessFlags: Annotated[ULONG, SAL("_In_", "PROCESS_CREATE_FLAGS_*")],
                        ThreadFlags: Annotated[ULONG, SAL("_In_", "THREAD_CREATE_FLAGS_*")],
                        ProcessParameters: Annotated[PVOID, SAL("_In_opt_", "PRTL_USER_PROCESS_PARAMETERS")],
                        CreateInfo: Annotated[P[PS_CREATE_INFO], SAL("_Inout_")],
                        AttributeList: Annotated[P[PS_ATTRIBUTE_LIST], SAL("_In_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwCreateWaitablePort(dp: Dumpulator,
                         PortHandle: Annotated[P[HANDLE], SAL("_Out_")],
                         ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                         MaxConnectionInfoLength: Annotated[ULONG, SAL("_In_")],
                         MaxMessageLength: Annotated[ULONG, SAL("_In_")],
                         MaxPoolUsage: Annotated[ULONG, SAL("_In_opt_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwCreateWaitCompletionPacket(dp: Dumpulator,
                                 WaitCompletionPacketHandle: Annotated[P[HANDLE], SAL("_Out_")],
                                 DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                                 ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")]
                                 ):
    raise NotImplementedError()

@syscall
def ZwCreateWnfStateName(dp: Dumpulator,
                         StateName: Annotated[P[WNF_STATE_NAME], SAL("_Out_")],
                         NameLifetime: Annotated[WNF_STATE_NAME_LIFETIME, SAL("_In_")],
                         DataScope: Annotated[WNF_DATA_SCOPE, SAL("_In_")],
                         PersistData: Annotated[BOOLEAN, SAL("_In_")],
                         TypeId: Annotated[P[CWNF_TYPE_ID], SAL("_In_opt_")],
                         MaximumStateSize: Annotated[ULONG, SAL("_In_")],
                         SecurityDescriptor: Annotated[P[SECURITY_DESCRIPTOR], SAL("_In_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwCreateWorkerFactory(dp: Dumpulator,
                          WorkerFactoryHandleReturn: Annotated[P[HANDLE], SAL("_Out_")],
                          DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                          ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                          CompletionPortHandle: Annotated[HANDLE, SAL("_In_")],
                          WorkerProcessHandle: Annotated[HANDLE, SAL("_In_")],
                          StartRoutine: Annotated[PVOID, SAL("_In_")],
                          StartParameter: Annotated[PVOID, SAL("_In_opt_")],
                          MaxThreadCount: Annotated[ULONG, SAL("_In_opt_")],
                          StackReserve: Annotated[SIZE_T, SAL("_In_opt_")],
                          StackCommit: Annotated[SIZE_T, SAL("_In_opt_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwDebugActiveProcess(dp: Dumpulator,
                         ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                         DebugObjectHandle: Annotated[HANDLE, SAL("_In_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwDebugContinue(dp: Dumpulator,
                    DebugObjectHandle: Annotated[HANDLE, SAL("_In_")],
                    ClientId: Annotated[P[CLIENT_ID], SAL("_In_")],
                    ContinueStatus: Annotated[NTSTATUS, SAL("_In_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwDelayExecution(dp: Dumpulator,
                     Alertable: Annotated[BOOLEAN, SAL("_In_")],
                     DelayInterval: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                     ):
    return STATUS_SUCCESS

@syscall
def ZwDeleteAtom(dp: Dumpulator,
                 Atom: Annotated[RTL_ATOM, SAL("_In_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwDeleteBootEntry(dp: Dumpulator,
                      Id: Annotated[ULONG, SAL("_In_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwDeleteDriverEntry(dp: Dumpulator,
                        Id: Annotated[ULONG, SAL("_In_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwDeleteFile(dp: Dumpulator,
                 ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwDeleteKey(dp: Dumpulator,
                KeyHandle: Annotated[HANDLE, SAL("_In_")]
                ):
    raise NotImplementedError()

@syscall
def ZwDeleteObjectAuditAlarm(dp: Dumpulator,
                             SubsystemName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                             HandleId: Annotated[PVOID, SAL("_In_opt_")],
                             GenerateOnClose: Annotated[BOOLEAN, SAL("_In_")]
                             ):
    raise NotImplementedError()

@syscall
def ZwDeletePrivateNamespace(dp: Dumpulator,
                             NamespaceHandle: Annotated[HANDLE, SAL("_In_")]
                             ):
    raise NotImplementedError()

@syscall
def ZwDeleteValueKey(dp: Dumpulator,
                     KeyHandle: Annotated[HANDLE, SAL("_In_")],
                     ValueName: Annotated[P[UNICODE_STRING], SAL("_In_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwDeleteWnfStateData(dp: Dumpulator,
                         StateName: Annotated[P[CWNF_STATE_NAME], SAL("_In_")],
                         ExplicitScope: Annotated[PVOID, SAL("_In_opt_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwDeleteWnfStateName(dp: Dumpulator,
                         StateName: Annotated[P[CWNF_STATE_NAME], SAL("_In_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwDeviceIoControlFile(dp: Dumpulator,
                          FileHandle: Annotated[HANDLE, SAL("_In_")],
                          Event: Annotated[HANDLE, SAL("_In_opt_")],
                          ApcRoutine: Annotated[P[IO_APC_ROUTINE], SAL("_In_opt_")],
                          ApcContext: Annotated[PVOID, SAL("_In_opt_")],
                          IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                          IoControlCode: Annotated[ULONG, SAL("_In_")],
                          InputBuffer: Annotated[PVOID, SAL("_In_reads_bytes_opt_(InputBufferLength)")],
                          InputBufferLength: Annotated[ULONG, SAL("_In_")],
                          OutputBuffer: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(OutputBufferLength)")],
                          OutputBufferLength: Annotated[ULONG, SAL("_In_")]
                          ):
    assert Event == 0
    assert ApcRoutine == 0
    assert ApcContext == 0
    assert OutputBufferLength == 0
    if dp.handles.valid(FileHandle):
        device = dp.handles.get(FileHandle, DeviceObject)
        in_data = bytes(dp.read(InputBuffer.ptr, InputBufferLength))
        control = DeviceControlData(dp, IoControlCode, in_data)
        out_data = device.io_control(dp, control)  # TODO: allow changing the status code
        if out_data is not None:
            written = len(out_data)
            raise NotImplementedError()
        else:
            written = 0
            assert OutputBuffer == 0

        # Construct the status block
        io_status = control.io_status
        if io_status is None:
            io_status = STATUS_SUCCESS
        io_information = control.io_information
        if io_information is None:
            io_information = written
        IO_STATUS_BLOCK.write(IoStatusBlock, io_status, io_information)
        return STATUS_SUCCESS  # TODO: figure out if the control implementation can make this fail

    raise NotImplementedError()  # TODO: INVALID_HANDLE_VALUE

@syscall
def ZwDisableLastKnownGood(dp: Dumpulator
                           ):
    raise NotImplementedError()

@syscall
def ZwDisplayString(dp: Dumpulator,
                    String: Annotated[P[UNICODE_STRING], SAL("_In_")]
                    ):
    print("debug: " + String.read_unicode_str())
    return STATUS_PRIVILEGE_NOT_HELD

@syscall
def ZwDrawText(dp: Dumpulator,
               Text: Annotated[P[UNICODE_STRING], SAL("_In_")]
               ):
    raise NotImplementedError()

@syscall
def ZwDuplicateObject(dp: Dumpulator,
                      SourceProcessHandle: Annotated[HANDLE, SAL("_In_")],
                      SourceHandle: Annotated[HANDLE, SAL("_In_")],
                      TargetProcessHandle: Annotated[HANDLE, SAL("_In_opt_")],
                      TargetHandle: Annotated[P[HANDLE], SAL("_Out_opt_")],
                      DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                      HandleAttributes: Annotated[ULONG, SAL("_In_")],
                      Options: Annotated[ULONG, SAL("_In_")]
                      ):
    assert SourceProcessHandle == dp.NtCurrentProcess()
    assert TargetProcessHandle == dp.NtCurrentProcess()
    if not dp.handles.valid(SourceHandle):
        return STATUS_INVALID_HANDLE
    dup_handle = dp.handles.duplicate(SourceHandle)
    TargetHandle.write_ptr(dup_handle)
    return STATUS_SUCCESS

@syscall
def ZwDuplicateToken(dp: Dumpulator,
                     ExistingTokenHandle: Annotated[HANDLE, SAL("_In_")],
                     DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                     ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                     EffectiveOnly: Annotated[BOOLEAN, SAL("_In_")],
                     Type: Annotated[TOKEN_TYPE, SAL("_In_")],
                     NewTokenHandle: Annotated[P[HANDLE], SAL("_Out_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwEnableLastKnownGood(dp: Dumpulator
                          ):
    raise NotImplementedError()

@syscall
def ZwEnumerateBootEntries(dp: Dumpulator,
                           Buffer: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(*BufferLength)")],
                           BufferLength: Annotated[P[ULONG], SAL("_Inout_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwEnumerateDriverEntries(dp: Dumpulator,
                             Buffer: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(*BufferLength)")],
                             BufferLength: Annotated[P[ULONG], SAL("_Inout_")]
                             ):
    raise NotImplementedError()

@syscall
def ZwEnumerateKey(dp: Dumpulator,
                   KeyHandle: Annotated[HANDLE, SAL("_In_")],
                   Index: Annotated[ULONG, SAL("_In_")],
                   KeyInformationClass: Annotated[KEY_INFORMATION_CLASS, SAL("_In_")],
                   KeyInformation: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(Length)")],
                   Length: Annotated[ULONG, SAL("_In_")],
                   ResultLength: Annotated[P[ULONG], SAL("_Out_")]
                   ):
    raise NotImplementedError()

@syscall
def ZwEnumerateSystemEnvironmentValuesEx(dp: Dumpulator,
                                         InformationClass: Annotated[ULONG, SAL("_In_", "SYSTEM_ENVIRONMENT_INFORMATION_CLASS")],
                                         Buffer: Annotated[PVOID, SAL("_Out_")],
                                         BufferLength: Annotated[P[ULONG], SAL("_Inout_")]
                                         ):
    raise NotImplementedError()

@syscall
def ZwEnumerateTransactionObject(dp: Dumpulator,
                                 RootObjectHandle: Annotated[HANDLE, SAL("_In_opt_")],
                                 QueryType: Annotated[KTMOBJECT_TYPE, SAL("_In_")],
                                 ObjectCursor: Annotated[P[KTMOBJECT_CURSOR], SAL("_Inout_updates_bytes_(ObjectCursorLength)")],
                                 ObjectCursorLength: Annotated[ULONG, SAL("_In_")],
                                 ReturnLength: Annotated[P[ULONG], SAL("_Out_")]
                                 ):
    raise NotImplementedError()

@syscall
def ZwEnumerateValueKey(dp: Dumpulator,
                        KeyHandle: Annotated[HANDLE, SAL("_In_")],
                        Index: Annotated[ULONG, SAL("_In_")],
                        KeyValueInformationClass: Annotated[KEY_VALUE_INFORMATION_CLASS, SAL("_In_")],
                        KeyValueInformation: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(Length)")],
                        Length: Annotated[ULONG, SAL("_In_")],
                        ResultLength: Annotated[P[ULONG], SAL("_Out_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwExtendSection(dp: Dumpulator,
                    SectionHandle: Annotated[HANDLE, SAL("_In_")],
                    NewSectionSize: Annotated[P[LARGE_INTEGER], SAL("_Inout_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwFilterBootOption(dp: Dumpulator,
                       FilterOperation: Annotated[FILTER_BOOT_OPTION_OPERATION, SAL("_In_")],
                       ObjectType: Annotated[ULONG, SAL("_In_")],
                       ElementType: Annotated[ULONG, SAL("_In_")],
                       Data: Annotated[PVOID, SAL("_In_reads_bytes_opt_(DataSize)")],
                       DataSize: Annotated[ULONG, SAL("_In_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwFilterToken(dp: Dumpulator,
                  ExistingTokenHandle: Annotated[HANDLE, SAL("_In_")],
                  Flags: Annotated[ULONG, SAL("_In_")],
                  SidsToDisable: Annotated[P[TOKEN_GROUPS], SAL("_In_opt_")],
                  PrivilegesToDelete: Annotated[P[TOKEN_PRIVILEGES], SAL("_In_opt_")],
                  RestrictedSids: Annotated[P[TOKEN_GROUPS], SAL("_In_opt_")],
                  NewTokenHandle: Annotated[P[HANDLE], SAL("_Out_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwFilterTokenEx(dp: Dumpulator,
                    ExistingTokenHandle: Annotated[HANDLE, SAL("_In_")],
                    Flags: Annotated[ULONG, SAL("_In_")],
                    SidsToDisable: Annotated[P[TOKEN_GROUPS], SAL("_In_opt_")],
                    PrivilegesToDelete: Annotated[P[TOKEN_PRIVILEGES], SAL("_In_opt_")],
                    RestrictedSids: Annotated[P[TOKEN_GROUPS], SAL("_In_opt_")],
                    DisableUserClaimsCount: Annotated[ULONG, SAL("_In_")],
                    UserClaimsToDisable: Annotated[P[UNICODE_STRING], SAL("_In_opt_")],
                    DisableDeviceClaimsCount: Annotated[ULONG, SAL("_In_")],
                    DeviceClaimsToDisable: Annotated[P[UNICODE_STRING], SAL("_In_opt_")],
                    DeviceGroupsToDisable: Annotated[P[TOKEN_GROUPS], SAL("_In_opt_")],
                    RestrictedUserAttributes: Annotated[P[TOKEN_SECURITY_ATTRIBUTES_INFORMATION], SAL("_In_opt_")],
                    RestrictedDeviceAttributes: Annotated[P[TOKEN_SECURITY_ATTRIBUTES_INFORMATION], SAL("_In_opt_")],
                    RestrictedDeviceGroups: Annotated[P[TOKEN_GROUPS], SAL("_In_opt_")],
                    NewTokenHandle: Annotated[P[HANDLE], SAL("_Out_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwFindAtom(dp: Dumpulator,
               AtomName: Annotated[PWSTR, SAL("_In_reads_bytes_opt_(Length)")],
               Length: Annotated[ULONG, SAL("_In_")],
               Atom: Annotated[P[RTL_ATOM], SAL("_Out_opt_")]
               ):
    raise NotImplementedError()

@syscall
def ZwFlushBuffersFile(dp: Dumpulator,
                       FileHandle: Annotated[HANDLE, SAL("_In_")],
                       IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwFlushBuffersFileEx(dp: Dumpulator,
                         FileHandle: Annotated[HANDLE, SAL("_In_")],
                         Flags: Annotated[ULONG, SAL("_In_")],
                         Parameters: Annotated[PVOID, SAL("_In_reads_bytes_(ParametersSize)")],
                         ParametersSize: Annotated[ULONG, SAL("_In_")],
                         IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwFlushInstallUILanguage(dp: Dumpulator,
                             InstallUILanguage: Annotated[LANGID, SAL("_In_")],
                             SetComittedFlag: Annotated[ULONG, SAL("_In_")]
                             ):
    raise NotImplementedError()

@syscall
def ZwFlushInstructionCache(dp: Dumpulator,
                            ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                            BaseAddress: Annotated[PVOID, SAL("_In_opt_")],
                            Length: Annotated[SIZE_T, SAL("_In_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwFlushKey(dp: Dumpulator,
               KeyHandle: Annotated[HANDLE, SAL("_In_")]
               ):
    raise NotImplementedError()

@syscall
def ZwFlushProcessWriteBuffers(dp: Dumpulator
                               ):
    raise NotImplementedError()

@syscall
def ZwFlushVirtualMemory(dp: Dumpulator,
                         ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                         BaseAddress: Annotated[P[PVOID], SAL("_Inout_")],
                         RegionSize: Annotated[P[SIZE_T], SAL("_Inout_")],
                         IoStatus: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwFlushWriteBuffer(dp: Dumpulator
                       ):
    raise NotImplementedError()

@syscall
def ZwFreeUserPhysicalPages(dp: Dumpulator,
                            ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                            NumberOfPages: Annotated[P[ULONG_PTR], SAL("_Inout_")],
                            UserPfnArray: Annotated[P[ULONG_PTR], SAL("_In_reads_(*NumberOfPages)")]
                            ):
    raise NotImplementedError()

@syscall
def ZwFreeVirtualMemory(dp: Dumpulator,
                        ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                        BaseAddress: Annotated[P[PVOID], SAL("_Inout_")],
                        RegionSize: Annotated[P[SIZE_T], SAL("_Inout_")],
                        FreeType: Annotated[ULONG, SAL("_In_")]
                        ):
    base = BaseAddress.read_ptr()
    size = RegionSize.read_ptr()
    if FreeType == MEM_RELEASE:
        print(f"release {hex(base)}[{hex(size)}]")
        region = dp.memory.find_region(base)
        if region is None:
            return STATUS_MEMORY_NOT_ALLOCATED
        dp.memory.release(base, size)
        return STATUS_SUCCESS
    elif FreeType == MEM_DECOMMIT:
        print(f"decommit {hex(base)}[{hex(size)}]")
        region = dp.memory.find_region(base)
        if region is None:
            return STATUS_MEMORY_NOT_ALLOCATED
        dp.memory.decommit(base, size)
        return STATUS_SUCCESS
    else:
        raise NotImplementedError()

@syscall
def ZwFreezeRegistry(dp: Dumpulator,
                     TimeOutInSeconds: Annotated[ULONG, SAL("_In_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwFreezeTransactions(dp: Dumpulator,
                         FreezeTimeout: Annotated[P[LARGE_INTEGER], SAL("_In_")],
                         ThawTimeout: Annotated[P[LARGE_INTEGER], SAL("_In_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwFsControlFile(dp: Dumpulator,
                    FileHandle: Annotated[HANDLE, SAL("_In_")],
                    Event: Annotated[HANDLE, SAL("_In_opt_")],
                    ApcRoutine: Annotated[P[IO_APC_ROUTINE], SAL("_In_opt_")],
                    ApcContext: Annotated[PVOID, SAL("_In_opt_")],
                    IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                    FsControlCode: Annotated[ULONG, SAL("_In_")],
                    InputBuffer: Annotated[PVOID, SAL("_In_reads_bytes_opt_(InputBufferLength)")],
                    InputBufferLength: Annotated[ULONG, SAL("_In_")],
                    OutputBuffer: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(OutputBufferLength)")],
                    OutputBufferLength: Annotated[ULONG, SAL("_In_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwGetCachedSigningLevel(dp: Dumpulator,
                            File: Annotated[HANDLE, SAL("_In_")],
                            Flags: Annotated[P[ULONG], SAL("_Out_")],
                            SigningLevel: Annotated[P[SE_SIGNING_LEVEL], SAL("_Out_")],
                            Thumbprint: Annotated[P[UCHAR], SAL("_Out_writes_bytes_to_opt_(*ThumbprintSize, *ThumbprintSize)")],
                            ThumbprintSize: Annotated[P[ULONG], SAL("_Inout_opt_")],
                            ThumbprintAlgorithm: Annotated[P[ULONG], SAL("_Out_opt_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwGetCompleteWnfStateSubscription(dp: Dumpulator,
                                      OldDescriptorStateName: Annotated[P[WNF_STATE_NAME], SAL("_In_opt_")],
                                      OldSubscriptionId: Annotated[P[ULONG64], SAL("_In_opt_")],
                                      OldDescriptorEventMask: Annotated[ULONG, SAL("_In_opt_")],
                                      OldDescriptorStatus: Annotated[ULONG, SAL("_In_opt_")],
                                      NewDeliveryDescriptor: Annotated[P[WNF_DELIVERY_DESCRIPTOR], SAL("_Out_writes_bytes_(DescriptorSize)")],
                                      DescriptorSize: Annotated[ULONG, SAL("_In_")]
                                      ):
    raise NotImplementedError()

@syscall
def ZwGetContextThread(dp: Dumpulator,
                       ThreadHandle: Annotated[HANDLE, SAL("_In_")],
                       ThreadContext: Annotated[P[CONTEXT], SAL("_Inout_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwGetCurrentProcessorNumber(dp: Dumpulator
                                ):
    raise NotImplementedError()

@syscall
def ZwGetCurrentProcessorNumberEx(dp: Dumpulator,
                                  ProcessorNumber: Annotated[P[PROCESSOR_NUMBER], SAL("_Out_opt_")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwGetDevicePowerState(dp: Dumpulator,
                          Device: Annotated[HANDLE, SAL("_In_")],
                          State: Annotated[P[DEVICE_POWER_STATE], SAL("_Out_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwGetMUIRegistryInfo(dp: Dumpulator,
                         Flags: Annotated[ULONG, SAL("_In_")],
                         DataSize: Annotated[P[ULONG], SAL("_Inout_")],
                         Data: Annotated[PVOID, SAL("_Out_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwGetNextProcess(dp: Dumpulator,
                     ProcessHandle: Annotated[HANDLE, SAL("_In_opt_")],
                     DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                     HandleAttributes: Annotated[ULONG, SAL("_In_")],
                     Flags: Annotated[ULONG, SAL("_In_")],
                     NewProcessHandle: Annotated[P[HANDLE], SAL("_Out_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwGetNextThread(dp: Dumpulator,
                    ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                    ThreadHandle: Annotated[HANDLE, SAL("_In_opt_")],
                    DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                    HandleAttributes: Annotated[ULONG, SAL("_In_")],
                    Flags: Annotated[ULONG, SAL("_In_")],
                    NewThreadHandle: Annotated[P[HANDLE], SAL("_Out_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwGetNlsSectionPtr(dp: Dumpulator,
                       SectionType: Annotated[ULONG, SAL("_In_")],
                       SectionData: Annotated[ULONG, SAL("_In_")],
                       ContextData: Annotated[PVOID, SAL("_In_")],
                       SectionPointer: Annotated[P[PVOID], SAL("_Out_")],
                       SectionSize: Annotated[P[ULONG], SAL("_Out_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwGetNotificationResourceManager(dp: Dumpulator,
                                     ResourceManagerHandle: Annotated[HANDLE, SAL("_In_")],
                                     TransactionNotification: Annotated[P[TRANSACTION_NOTIFICATION], SAL("_Out_")],
                                     NotificationLength: Annotated[ULONG, SAL("_In_")],
                                     Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")],
                                     ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")],
                                     Asynchronous: Annotated[ULONG, SAL("_In_")],
                                     AsynchronousContext: Annotated[ULONG_PTR, SAL("_In_opt_")]
                                     ):
    raise NotImplementedError()

@syscall
def ZwGetPlugPlayEvent(dp: Dumpulator,
                       EventHandle: Annotated[HANDLE, SAL("_In_")],
                       Context: Annotated[PVOID, SAL("_In_opt_")],
                       EventBlock: Annotated[P[PLUGPLAY_EVENT_BLOCK], SAL("_Out_writes_bytes_(EventBufferSize)")],
                       EventBufferSize: Annotated[ULONG, SAL("_In_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwGetWriteWatch(dp: Dumpulator,
                    ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                    Flags: Annotated[ULONG, SAL("_In_")],
                    BaseAddress: Annotated[PVOID, SAL("_In_")],
                    RegionSize: Annotated[SIZE_T, SAL("_In_")],
                    UserAddressArray: Annotated[P[PVOID], SAL("_Out_writes_(*EntriesInUserAddressArray)")],
                    EntriesInUserAddressArray: Annotated[P[ULONG_PTR], SAL("_Inout_")],
                    Granularity: Annotated[P[ULONG], SAL("_Out_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwImpersonateAnonymousToken(dp: Dumpulator,
                                ThreadHandle: Annotated[HANDLE, SAL("_In_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwImpersonateClientOfPort(dp: Dumpulator,
                              PortHandle: Annotated[HANDLE, SAL("_In_")],
                              Message: Annotated[P[PORT_MESSAGE], SAL("_In_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwImpersonateThread(dp: Dumpulator,
                        ServerThreadHandle: Annotated[HANDLE, SAL("_In_")],
                        ClientThreadHandle: Annotated[HANDLE, SAL("_In_")],
                        SecurityQos: Annotated[P[SECURITY_QUALITY_OF_SERVICE], SAL("_In_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwInitializeEnclave(dp: Dumpulator,
                        ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                        BaseAddress: Annotated[PVOID, SAL("_In_")],
                        EnclaveInformation: Annotated[PVOID, SAL("_In_reads_bytes_(EnclaveInformationLength)")],
                        EnclaveInformationLength: Annotated[ULONG, SAL("_In_")],
                        EnclaveError: Annotated[P[ULONG], SAL("_Out_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwInitializeNlsFiles(dp: Dumpulator,
                         BaseAddress: Annotated[P[PVOID], SAL("_Out_")],
                         DefaultLocaleId: Annotated[P[LCID], SAL("_Out_")],
                         DefaultCasingTableSize: Annotated[P[LARGE_INTEGER], SAL("_Out_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwInitializeRegistry(dp: Dumpulator,
                         BootCondition: Annotated[USHORT, SAL("_In_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwInitiatePowerAction(dp: Dumpulator,
                          SystemAction: Annotated[P[OWER_ACTION], SAL("_In_")],
                          LightestSystemState: Annotated[SYSTEM_POWER_STATE, SAL("_In_")],
                          Flags: Annotated[ULONG, SAL("_In_", "POWER_ACTION_* flags")],
                          Asynchronous: Annotated[BOOLEAN, SAL("_In_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwIsProcessInJob(dp: Dumpulator,
                     ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                     JobHandle: Annotated[HANDLE, SAL("_In_opt_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwIsSystemResumeAutomatic(dp: Dumpulator
                              ):
    raise NotImplementedError()

@syscall
def ZwIsUILanguageComitted(dp: Dumpulator
                           ):
    raise NotImplementedError()

@syscall
def ZwListenPort(dp: Dumpulator,
                 PortHandle: Annotated[HANDLE, SAL("_In_")],
                 ConnectionRequest: Annotated[P[PORT_MESSAGE], SAL("_Out_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwLoadDriver(dp: Dumpulator,
                 DriverServiceName: Annotated[P[UNICODE_STRING], SAL("_In_")]
                 ):
    print(f"Starting service: {DriverServiceName[0].read_str()}")
    return STATUS_SUCCESS

@syscall
def ZwLoadEnclaveData(dp: Dumpulator,
                      ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                      BaseAddress: Annotated[PVOID, SAL("_In_")],
                      Buffer: Annotated[PVOID, SAL("_In_reads_bytes_(BufferSize)")],
                      BufferSize: Annotated[SIZE_T, SAL("_In_")],
                      Protect: Annotated[ULONG, SAL("_In_")],
                      PageInformation: Annotated[PVOID, SAL("_In_reads_bytes_(PageInformationLength)")],
                      PageInformationLength: Annotated[ULONG, SAL("_In_")],
                      NumberOfBytesWritten: Annotated[P[SIZE_T], SAL("_Out_opt_")],
                      EnclaveError: Annotated[P[ULONG], SAL("_Out_opt_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwLoadKey(dp: Dumpulator,
              TargetKey: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
              SourceFile: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
              ):
    raise NotImplementedError()

@syscall
def ZwLoadKey2(dp: Dumpulator,
               TargetKey: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
               SourceFile: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
               Flags: Annotated[ULONG, SAL("_In_")]
               ):
    raise NotImplementedError()

@syscall
def ZwLoadKey3(dp: Dumpulator,
               TargetKey: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
               SourceFile: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
               Flags: Annotated[ULONG, SAL("_In_")],
               LoadEntries: Annotated[P[KEY_LOAD_ENTRY], SAL("_In_reads_(LoadEntryCount)")],
               LoadEntryCount: Annotated[ULONG, SAL("_In_")],
               DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_opt_")],
               RootHandle: Annotated[P[HANDLE], SAL("_Out_opt_")],
               Reserved: Annotated[PVOID, SAL("_Reserved_")]
               ):
    raise NotImplementedError()

@syscall
def ZwLoadKeyEx(dp: Dumpulator,
                TargetKey: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                SourceFile: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                Flags: Annotated[ULONG, SAL("_In_")],
                TrustClassKey: Annotated[HANDLE, SAL("_In_opt_", "this and below were added on Win10")],
                Event: Annotated[HANDLE, SAL("_In_opt_")],
                DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_opt_")],
                RootHandle: Annotated[P[HANDLE], SAL("_Out_opt_")],
                Reserved: Annotated[PVOID, SAL("_Reserved_", "previously PIO_STATUS_BLOCK")]
                ):
    raise NotImplementedError()

@syscall
def ZwLockFile(dp: Dumpulator,
               FileHandle: Annotated[HANDLE, SAL("_In_")],
               Event: Annotated[HANDLE, SAL("_In_opt_")],
               ApcRoutine: Annotated[P[IO_APC_ROUTINE], SAL("_In_opt_")],
               ApcContext: Annotated[PVOID, SAL("_In_opt_")],
               IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
               ByteOffset: Annotated[P[LARGE_INTEGER], SAL("_In_")],
               Length: Annotated[P[LARGE_INTEGER], SAL("_In_")],
               Key: Annotated[ULONG, SAL("_In_")],
               FailImmediately: Annotated[BOOLEAN, SAL("_In_")],
               ExclusiveLock: Annotated[BOOLEAN, SAL("_In_")]
               ):
    raise NotImplementedError()

@syscall
def ZwLockProductActivationKeys(dp: Dumpulator,
                                pPrivateVer: Annotated[P[ULONG], SAL("_Inout_opt_")],
                                pSafeMode: Annotated[P[ULONG], SAL("_Out_opt_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwLockRegistryKey(dp: Dumpulator,
                      KeyHandle: Annotated[HANDLE, SAL("_In_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwLockVirtualMemory(dp: Dumpulator,
                        ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                        BaseAddress: Annotated[P[PVOID], SAL("_Inout_")],
                        RegionSize: Annotated[P[SIZE_T], SAL("_Inout_")],
                        MapType: Annotated[ULONG, SAL("_In_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwMakePermanentObject(dp: Dumpulator,
                          Handle: Annotated[HANDLE, SAL("_In_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwMakeTemporaryObject(dp: Dumpulator,
                          Handle: Annotated[HANDLE, SAL("_In_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwManagePartition(dp: Dumpulator,
                      TargetHandle: Annotated[HANDLE, SAL("_In_")],
                      SourceHandle: Annotated[HANDLE, SAL("_In_opt_")],
                      PartitionInformationClass: Annotated[PARTITION_INFORMATION_CLASS, SAL("_In_")],
                      PartitionInformation: Annotated[PVOID, SAL("_Inout_updates_bytes_(PartitionInformationLength)")],
                      PartitionInformationLength: Annotated[ULONG, SAL("_In_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwMapCMFModule(dp: Dumpulator,
                   What: Annotated[ULONG, SAL("_In_")],
                   Index: Annotated[ULONG, SAL("_In_")],
                   CacheIndexOut: Annotated[P[ULONG], SAL("_Out_opt_")],
                   CacheFlagsOut: Annotated[P[ULONG], SAL("_Out_opt_")],
                   ViewSizeOut: Annotated[P[ULONG], SAL("_Out_opt_")],
                   BaseAddress: Annotated[P[PVOID], SAL("_Out_opt_")]
                   ):
    raise NotImplementedError()

@syscall
def ZwMapUserPhysicalPages(dp: Dumpulator,
                           VirtualAddress: Annotated[PVOID, SAL("_In_")],
                           NumberOfPages: Annotated[ULONG_PTR, SAL("_In_")],
                           UserPfnArray: Annotated[P[ULONG_PTR], SAL("_In_reads_opt_(NumberOfPages)")]
                           ):
    raise NotImplementedError()

@syscall
def ZwMapUserPhysicalPagesScatter(dp: Dumpulator,
                                  VirtualAddresses: Annotated[P[PVOID], SAL("_In_reads_(NumberOfPages)")],
                                  NumberOfPages: Annotated[ULONG_PTR, SAL("_In_")],
                                  UserPfnArray: Annotated[P[ULONG_PTR], SAL("_In_reads_opt_(NumberOfPages)")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwMapViewOfSection(dp: Dumpulator,
                       SectionHandle: Annotated[HANDLE, SAL("_In_")],
                       ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                       BaseAddress: Annotated[P[PVOID], SAL("_Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize))")],
                       ZeroBits: Annotated[ULONG_PTR, SAL("_In_")],
                       CommitSize: Annotated[SIZE_T, SAL("_In_")],
                       SectionOffset: Annotated[P[LARGE_INTEGER], SAL("_Inout_opt_")],
                       ViewSize: Annotated[P[SIZE_T], SAL("_Inout_")],
                       InheritDisposition: Annotated[SECTION_INHERIT, SAL("_In_")],
                       AllocationType: Annotated[ULONG, SAL("_In_")],
                       Win32Protect: Annotated[ULONG, SAL("_In_")]
                       ):
    assert ProcessHandle == dp.NtCurrentProcess()
    assert ZeroBits == 0
    assert CommitSize == 0
    assert SectionOffset == 0
    assert InheritDisposition == SECTION_INHERIT.ViewShare
    assert AllocationType == MEM_DIFFERENT_IMAGE_BASE_OK
    assert Win32Protect == PAGE_EXECUTE_WRITECOPY
    requested_base = BaseAddress.read_ptr()
    assert requested_base == 0
    section = dp.handles.get(SectionHandle, SectionObject)
    data = section.file.read()
    module = dp.map_module(data, section.file.path, requested_base, False)

    # Handle out parameters
    BaseAddress.write_ptr(module.base)
    ViewSize.write_ptr(module.size)
    return STATUS_SUCCESS

@syscall
def ZwModifyBootEntry(dp: Dumpulator,
                      BootEntry: Annotated[P[BOOT_ENTRY], SAL("_In_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwModifyDriverEntry(dp: Dumpulator,
                        DriverEntry: Annotated[P[EFI_DRIVER_ENTRY], SAL("_In_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwNotifyChangeDirectoryFile(dp: Dumpulator,
                                FileHandle: Annotated[HANDLE, SAL("_In_")],
                                Event: Annotated[HANDLE, SAL("_In_opt_")],
                                ApcRoutine: Annotated[P[IO_APC_ROUTINE], SAL("_In_opt_")],
                                ApcContext: Annotated[PVOID, SAL("_In_opt_")],
                                IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                                Buffer: Annotated[PVOID, SAL("_Out_writes_bytes_(Length)", "FILE_NOTIFY_INFORMATION")],
                                Length: Annotated[ULONG, SAL("_In_")],
                                CompletionFilter: Annotated[ULONG, SAL("_In_")],
                                WatchTree: Annotated[BOOLEAN, SAL("_In_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwNotifyChangeDirectoryFileEx(dp: Dumpulator,
                                  FileHandle: Annotated[HANDLE, SAL("_In_")],
                                  Event: Annotated[HANDLE, SAL("_In_opt_")],
                                  ApcRoutine: Annotated[P[IO_APC_ROUTINE], SAL("_In_opt_")],
                                  ApcContext: Annotated[PVOID, SAL("_In_opt_")],
                                  IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                                  Buffer: Annotated[PVOID, SAL("_Out_writes_bytes_(Length)")],
                                  Length: Annotated[ULONG, SAL("_In_")],
                                  CompletionFilter: Annotated[ULONG, SAL("_In_")],
                                  WatchTree: Annotated[BOOLEAN, SAL("_In_")],
                                  DirectoryNotifyInformationClass: Annotated[DIRECTORY_NOTIFY_INFORMATION_CLASS, SAL("_In_opt_")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwNotifyChangeKey(dp: Dumpulator,
                      KeyHandle: Annotated[HANDLE, SAL("_In_")],
                      Event: Annotated[HANDLE, SAL("_In_opt_")],
                      ApcRoutine: Annotated[P[IO_APC_ROUTINE], SAL("_In_opt_")],
                      ApcContext: Annotated[PVOID, SAL("_In_opt_")],
                      IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                      CompletionFilter: Annotated[ULONG, SAL("_In_")],
                      WatchTree: Annotated[BOOLEAN, SAL("_In_")],
                      Buffer: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(BufferSize)")],
                      BufferSize: Annotated[ULONG, SAL("_In_")],
                      Asynchronous: Annotated[BOOLEAN, SAL("_In_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwNotifyChangeMultipleKeys(dp: Dumpulator,
                               MasterKeyHandle: Annotated[HANDLE, SAL("_In_")],
                               Count: Annotated[ULONG, SAL("_In_opt_")],
                               SubordinateObjects: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_reads_opt_(Count)")],
                               Event: Annotated[HANDLE, SAL("_In_opt_")],
                               ApcRoutine: Annotated[P[IO_APC_ROUTINE], SAL("_In_opt_")],
                               ApcContext: Annotated[PVOID, SAL("_In_opt_")],
                               IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                               CompletionFilter: Annotated[ULONG, SAL("_In_")],
                               WatchTree: Annotated[BOOLEAN, SAL("_In_")],
                               Buffer: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(BufferSize)")],
                               BufferSize: Annotated[ULONG, SAL("_In_")],
                               Asynchronous: Annotated[BOOLEAN, SAL("_In_")]
                               ):
    raise NotImplementedError()

@syscall
def ZwNotifyChangeSession(dp: Dumpulator,
                          SessionHandle: Annotated[HANDLE, SAL("_In_")],
                          ChangeSequenceNumber: Annotated[ULONG, SAL("_In_")],
                          ChangeTimeStamp: Annotated[P[LARGE_INTEGER], SAL("_In_")],
                          Event: Annotated[IO_SESSION_EVENT, SAL("_In_")],
                          NewState: Annotated[IO_SESSION_STATE, SAL("_In_")],
                          PreviousState: Annotated[IO_SESSION_STATE, SAL("_In_")],
                          Payload: Annotated[PVOID, SAL("_In_reads_bytes_opt_(PayloadSize)")],
                          PayloadSize: Annotated[ULONG, SAL("_In_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwOpenDirectoryObject(dp: Dumpulator,
                          DirectoryHandle: Annotated[P[HANDLE], SAL("_Out_")],
                          DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                          ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwOpenEnlistment(dp: Dumpulator,
                     EnlistmentHandle: Annotated[P[HANDLE], SAL("_Out_")],
                     DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                     ResourceManagerHandle: Annotated[HANDLE, SAL("_In_")],
                     EnlistmentGuid: Annotated[P[GUID], SAL("_In_")],
                     ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwOpenEvent(dp: Dumpulator,
                EventHandle: Annotated[P[HANDLE], SAL("_Out_")],
                DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                ):
    raise NotImplementedError()

@syscall
def ZwOpenEventPair(dp: Dumpulator,
                    EventPairHandle: Annotated[P[HANDLE], SAL("_Out_")],
                    DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                    ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwOpenFile(dp: Dumpulator,
               FileHandle: Annotated[P[HANDLE], SAL("_Out_")],
               DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
               ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
               IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
               ShareAccess: Annotated[ULONG, SAL("_In_")],
               OpenOptions: Annotated[ULONG, SAL("_In_")]
               ):
    assert FileHandle.ptr != 0
    assert ObjectAttributes.ptr != 0
    file_name = ObjectAttributes[0].ObjectName[0].read_str()
    handle = dp.handles.open_file(file_name)
    assert handle is not None
    FileHandle.write_ptr(handle)
    IO_STATUS_BLOCK.write(IoStatusBlock, STATUS_SUCCESS, FILE_OPENED)
    return STATUS_SUCCESS

@syscall
def ZwOpenIoCompletion(dp: Dumpulator,
                       IoCompletionHandle: Annotated[P[HANDLE], SAL("_Out_")],
                       DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                       ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwOpenJobObject(dp: Dumpulator,
                    JobHandle: Annotated[P[HANDLE], SAL("_Out_")],
                    DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                    ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwOpenKey(dp: Dumpulator,
              KeyHandle: Annotated[P[HANDLE], SAL("_Out_")],
              DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
              ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
              ):
    key_name = ObjectAttributes[0].ObjectName[0].read_str()
    assert DesiredAccess == 0x20019
    handle = dp.handles.open_file(key_name)
    assert handle is not None
    KeyHandle.write_ptr(handle)
    return STATUS_SUCCESS

@syscall
def ZwOpenKeyedEvent(dp: Dumpulator,
                     KeyedEventHandle: Annotated[P[HANDLE], SAL("_Out_")],
                     DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                     ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwOpenKeyEx(dp: Dumpulator,
                KeyHandle: Annotated[P[HANDLE], SAL("_Out_")],
                DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                OpenOptions: Annotated[ULONG, SAL("_In_")]
                ):
    raise NotImplementedError()

@syscall
def ZwOpenKeyTransacted(dp: Dumpulator,
                        KeyHandle: Annotated[P[HANDLE], SAL("_Out_")],
                        DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                        ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                        TransactionHandle: Annotated[HANDLE, SAL("_In_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwOpenKeyTransactedEx(dp: Dumpulator,
                          KeyHandle: Annotated[P[HANDLE], SAL("_Out_")],
                          DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                          ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                          OpenOptions: Annotated[ULONG, SAL("_In_")],
                          TransactionHandle: Annotated[HANDLE, SAL("_In_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwOpenMutant(dp: Dumpulator,
                 MutantHandle: Annotated[P[HANDLE], SAL("_Out_")],
                 DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                 ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwOpenObjectAuditAlarm(dp: Dumpulator,
                           SubsystemName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                           HandleId: Annotated[PVOID, SAL("_In_opt_")],
                           ObjectTypeName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                           ObjectName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                           SecurityDescriptor: Annotated[P[SECURITY_DESCRIPTOR], SAL("_In_opt_")],
                           ClientToken: Annotated[HANDLE, SAL("_In_")],
                           DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                           GrantedAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                           Privileges: Annotated[P[PRIVILEGE_SET], SAL("_In_opt_")],
                           ObjectCreation: Annotated[BOOLEAN, SAL("_In_")],
                           AccessGranted: Annotated[BOOLEAN, SAL("_In_")],
                           GenerateOnClose: Annotated[P[BOOLEAN], SAL("_Out_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwOpenPartition(dp: Dumpulator,
                    PartitionHandle: Annotated[P[HANDLE], SAL("_Out_")],
                    DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                    ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwOpenPrivateNamespace(dp: Dumpulator,
                           NamespaceHandle: Annotated[P[HANDLE], SAL("_Out_")],
                           DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                           ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                           BoundaryDescriptor: Annotated[P[OBJECT_BOUNDARY_DESCRIPTOR], SAL("_In_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwOpenProcess(dp: Dumpulator,
                  ProcessHandle: Annotated[P[HANDLE], SAL("_Out_")],
                  DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                  ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                  ClientId: Annotated[P[CLIENT_ID], SAL("_In_opt_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwOpenProcessToken(dp: Dumpulator,
                       ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                       DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                       TokenHandle: Annotated[P[HANDLE], SAL("_Out_")]
                       ):
    assert ProcessHandle == dp.NtCurrentProcess()
    assert DesiredAccess == 0x20
    # TODO: TokenHandle should be -6 or something
    handle = dp.handles.new(ProcessTokenObject(ProcessHandle))
    print(f"process token: {hex(handle)}")
    TokenHandle.write_ptr(handle)
    return STATUS_SUCCESS

@syscall
def ZwOpenProcessTokenEx(dp: Dumpulator,
                         ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                         DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                         HandleAttributes: Annotated[ULONG, SAL("_In_")],
                         TokenHandle: Annotated[P[HANDLE], SAL("_Out_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwOpenResourceManager(dp: Dumpulator,
                          ResourceManagerHandle: Annotated[P[HANDLE], SAL("_Out_")],
                          DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                          TmHandle: Annotated[HANDLE, SAL("_In_")],
                          ResourceManagerGuid: Annotated[P[GUID], SAL("_In_opt_")],
                          ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwOpenSection(dp: Dumpulator,
                  SectionHandle: Annotated[P[HANDLE], SAL("_Out_")],
                  DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                  ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwOpenSemaphore(dp: Dumpulator,
                    SemaphoreHandle: Annotated[P[HANDLE], SAL("_Out_")],
                    DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                    ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwOpenSession(dp: Dumpulator,
                  SessionHandle: Annotated[P[HANDLE], SAL("_Out_")],
                  DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                  ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwOpenSymbolicLinkObject(dp: Dumpulator,
                             LinkHandle: Annotated[P[HANDLE], SAL("_Out_")],
                             DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                             ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                             ):
    raise NotImplementedError()

@syscall
def ZwOpenThread(dp: Dumpulator,
                 ThreadHandle: Annotated[P[HANDLE], SAL("_Out_")],
                 DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                 ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                 ClientId: Annotated[P[CLIENT_ID], SAL("_In_opt_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwOpenThreadToken(dp: Dumpulator,
                      ThreadHandle: Annotated[HANDLE, SAL("_In_")],
                      DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                      OpenAsSelf: Annotated[BOOLEAN, SAL("_In_")],
                      TokenHandle: Annotated[P[HANDLE], SAL("_Out_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwOpenThreadTokenEx(dp: Dumpulator,
                        ThreadHandle: Annotated[HANDLE, SAL("_In_")],
                        DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                        OpenAsSelf: Annotated[BOOLEAN, SAL("_In_")],
                        HandleAttributes: Annotated[ULONG, SAL("_In_")],
                        TokenHandle: Annotated[P[HANDLE], SAL("_Out_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwOpenTimer(dp: Dumpulator,
                TimerHandle: Annotated[P[HANDLE], SAL("_Out_")],
                DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                ):
    raise NotImplementedError()

@syscall
def ZwOpenTransaction(dp: Dumpulator,
                      TransactionHandle: Annotated[P[HANDLE], SAL("_Out_")],
                      DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                      ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                      Uow: Annotated[P[GUID], SAL("_In_opt_")],
                      TmHandle: Annotated[HANDLE, SAL("_In_opt_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwOpenTransactionManager(dp: Dumpulator,
                             TmHandle: Annotated[P[HANDLE], SAL("_Out_")],
                             DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                             ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_opt_")],
                             LogFileName: Annotated[P[UNICODE_STRING], SAL("_In_opt_")],
                             TmIdentity: Annotated[P[GUID], SAL("_In_opt_")],
                             OpenOptions: Annotated[ULONG, SAL("_In_opt_")]
                             ):
    raise NotImplementedError()

@syscall
def ZwPlugPlayControl(dp: Dumpulator,
                      PnPControlClass: Annotated[PLUGPLAY_CONTROL_CLASS, SAL("_In_")],
                      PnPControlData: Annotated[PVOID, SAL("_Inout_updates_bytes_(PnPControlDataLength)")],
                      PnPControlDataLength: Annotated[ULONG, SAL("_In_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwPowerInformation(dp: Dumpulator,
                       InformationLevel: Annotated[P[OWER_INFORMATION_LEVEL], SAL("_In_")],
                       InputBuffer: Annotated[PVOID, SAL("_In_reads_bytes_opt_(InputBufferLength)")],
                       InputBufferLength: Annotated[ULONG, SAL("_In_")],
                       OutputBuffer: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(OutputBufferLength)")],
                       OutputBufferLength: Annotated[ULONG, SAL("_In_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwPrepareComplete(dp: Dumpulator,
                      EnlistmentHandle: Annotated[HANDLE, SAL("_In_")],
                      TmVirtualClock: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwPrepareEnlistment(dp: Dumpulator,
                        EnlistmentHandle: Annotated[HANDLE, SAL("_In_")],
                        TmVirtualClock: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwPrePrepareComplete(dp: Dumpulator,
                         EnlistmentHandle: Annotated[HANDLE, SAL("_In_")],
                         TmVirtualClock: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwPrePrepareEnlistment(dp: Dumpulator,
                           EnlistmentHandle: Annotated[HANDLE, SAL("_In_")],
                           TmVirtualClock: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwPrivilegeCheck(dp: Dumpulator,
                     ClientToken: Annotated[HANDLE, SAL("_In_")],
                     RequiredPrivileges: Annotated[P[PRIVILEGE_SET], SAL("_Inout_")],
                     Result: Annotated[P[BOOLEAN], SAL("_Out_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwPrivilegedServiceAuditAlarm(dp: Dumpulator,
                                  SubsystemName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                  ServiceName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                  ClientToken: Annotated[HANDLE, SAL("_In_")],
                                  Privileges: Annotated[P[PRIVILEGE_SET], SAL("_In_")],
                                  AccessGranted: Annotated[BOOLEAN, SAL("_In_")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwPrivilegeObjectAuditAlarm(dp: Dumpulator,
                                SubsystemName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                HandleId: Annotated[PVOID, SAL("_In_opt_")],
                                ClientToken: Annotated[HANDLE, SAL("_In_")],
                                DesiredAccess: Annotated[ACCESS_MASK, SAL("_In_")],
                                Privileges: Annotated[P[PRIVILEGE_SET], SAL("_In_")],
                                AccessGranted: Annotated[BOOLEAN, SAL("_In_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwPropagationComplete(dp: Dumpulator,
                          ResourceManagerHandle: Annotated[HANDLE, SAL("_In_")],
                          RequestCookie: Annotated[ULONG, SAL("_In_")],
                          BufferLength: Annotated[ULONG, SAL("_In_")],
                          Buffer: Annotated[PVOID, SAL("_In_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwPropagationFailed(dp: Dumpulator,
                        ResourceManagerHandle: Annotated[HANDLE, SAL("_In_")],
                        RequestCookie: Annotated[ULONG, SAL("_In_")],
                        PropStatus: Annotated[NTSTATUS, SAL("_In_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwProtectVirtualMemory(dp: Dumpulator,
                           ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                           BaseAddress: Annotated[P[PVOID], SAL("_Inout_")],
                           RegionSize: Annotated[P[SIZE_T], SAL("_Inout_")],
                           NewProtect: Annotated[ULONG, SAL("_In_")],
                           OldProtect: Annotated[P[ULONG], SAL("_Out_")]
                           ):
    base = BaseAddress.read_ptr() & 0xFFFFFFFFFFFFF000
    size = round_to_pages(RegionSize.read_ptr())
    protect = MemoryProtect(NewProtect)

    print(f"protect {hex(base)}[{hex(size)}] = {protect}")
    old_protect = dp.memory.protect(base, size, protect)
    OldProtect.write_ulong(old_protect.value)
    return STATUS_SUCCESS

@syscall
def ZwPulseEvent(dp: Dumpulator,
                 EventHandle: Annotated[HANDLE, SAL("_In_")],
                 PreviousState: Annotated[P[LONG], SAL("_Out_opt_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwQueryAttributesFile(dp: Dumpulator,
                          ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                          FileInformation: Annotated[P[FILE_BASIC_INFORMATION], SAL("_Out_")]
                          ):
    assert ObjectAttributes.ptr != 0
    file_name = ObjectAttributes[0].ObjectName[0].read_str()
    print(f"query attributes {file_name}")
    handle = dp.handles.open_file(file_name)
    assert handle is not None
    file_data = dp.handles.get(handle, AbstractFileObject)
    attr = FILE_BASIC_INFORMATION(dp)
    attr.CreationTime = 0
    attr.LastAccessTime = 0
    attr.LastWriteTime = 0
    attr.ChangeTime = 0
    attr.FileAttributes = 0x80  # FILE_ATTRIBUTE_NORMAL
    dp.write(FileInformation.ptr, bytes(attr))
    dp.handles.close(handle)
    return STATUS_SUCCESS

@syscall
def ZwQueryBootEntryOrder(dp: Dumpulator,
                          Ids: Annotated[P[ULONG], SAL("_Out_writes_opt_(*Count)")],
                          Count: Annotated[P[ULONG], SAL("_Inout_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwQueryBootOptions(dp: Dumpulator,
                       BootOptions: Annotated[P[BOOT_OPTIONS], SAL("_Out_writes_bytes_opt_(*BootOptionsLength)")],
                       BootOptionsLength: Annotated[P[ULONG], SAL("_Inout_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwQueryDebugFilterState(dp: Dumpulator,
                            ComponentId: Annotated[ULONG, SAL("_In_")],
                            Level: Annotated[ULONG, SAL("_In_")]
                            ):
    # STATUS_SUCCESS will print debug messages with RaiseException
    return STATUS_NOT_IMPLEMENTED

@syscall
def ZwQueryDefaultLocale(dp: Dumpulator,
                         UserProfile: Annotated[BOOLEAN, SAL("_In_")],
                         DefaultLocaleId: Annotated[P[LCID], SAL("_Out_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwQueryDefaultUILanguage(dp: Dumpulator,
                             DefaultUILanguageId: Annotated[P[LANGID], SAL("_Out_")]
                             ):
    raise NotImplementedError()

@syscall
def ZwQueryDirectoryFile(dp: Dumpulator,
                         FileHandle: Annotated[HANDLE, SAL("_In_")],
                         Event: Annotated[HANDLE, SAL("_In_opt_")],
                         ApcRoutine: Annotated[P[IO_APC_ROUTINE], SAL("_In_opt_")],
                         ApcContext: Annotated[PVOID, SAL("_In_opt_")],
                         IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                         FileInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(Length)")],
                         Length: Annotated[ULONG, SAL("_In_")],
                         FileInformationClass: Annotated[FILE_INFORMATION_CLASS, SAL("_In_")],
                         ReturnSingleEntry: Annotated[BOOLEAN, SAL("_In_")],
                         FileName: Annotated[P[UNICODE_STRING], SAL("_In_opt_")],
                         RestartScan: Annotated[BOOLEAN, SAL("_In_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwQueryDirectoryFileEx(dp: Dumpulator,
                           FileHandle: Annotated[HANDLE, SAL("_In_")],
                           Event: Annotated[HANDLE, SAL("_In_opt_")],
                           ApcRoutine: Annotated[P[IO_APC_ROUTINE], SAL("_In_opt_")],
                           ApcContext: Annotated[PVOID, SAL("_In_opt_")],
                           IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                           FileInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(Length)")],
                           Length: Annotated[ULONG, SAL("_In_")],
                           FileInformationClass: Annotated[FILE_INFORMATION_CLASS, SAL("_In_")],
                           QueryFlags: Annotated[ULONG, SAL("_In_")],
                           FileName: Annotated[P[UNICODE_STRING], SAL("_In_opt_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwQueryDirectoryObject(dp: Dumpulator,
                           DirectoryHandle: Annotated[HANDLE, SAL("_In_")],
                           Buffer: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(Length)")],
                           Length: Annotated[ULONG, SAL("_In_")],
                           ReturnSingleEntry: Annotated[BOOLEAN, SAL("_In_")],
                           RestartScan: Annotated[BOOLEAN, SAL("_In_")],
                           Context: Annotated[P[ULONG], SAL("_Inout_")],
                           ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwQueryDriverEntryOrder(dp: Dumpulator,
                            Ids: Annotated[P[ULONG], SAL("_Out_writes_opt_(*Count)")],
                            Count: Annotated[P[ULONG], SAL("_Inout_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwQueryEaFile(dp: Dumpulator,
                  FileHandle: Annotated[HANDLE, SAL("_In_")],
                  IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                  Buffer: Annotated[PVOID, SAL("_Out_writes_bytes_(Length)")],
                  Length: Annotated[ULONG, SAL("_In_")],
                  ReturnSingleEntry: Annotated[BOOLEAN, SAL("_In_")],
                  EaList: Annotated[PVOID, SAL("_In_reads_bytes_opt_(EaListLength)")],
                  EaListLength: Annotated[ULONG, SAL("_In_")],
                  EaIndex: Annotated[P[ULONG], SAL("_In_opt_")],
                  RestartScan: Annotated[BOOLEAN, SAL("_In_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwQueryEvent(dp: Dumpulator,
                 EventHandle: Annotated[HANDLE, SAL("_In_")],
                 EventInformationClass: Annotated[EVENT_INFORMATION_CLASS, SAL("_In_")],
                 EventInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(EventInformationLength)")],
                 EventInformationLength: Annotated[ULONG, SAL("_In_")],
                 ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwQueryFullAttributesFile(dp: Dumpulator,
                              ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                              FileInformation: Annotated[P[FILE_NETWORK_OPEN_INFORMATION], SAL("_Out_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationAtom(dp: Dumpulator,
                           Atom: Annotated[RTL_ATOM, SAL("_In_")],
                           AtomInformationClass: Annotated[ATOM_INFORMATION_CLASS, SAL("_In_")],
                           AtomInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(AtomInformationLength)")],
                           AtomInformationLength: Annotated[ULONG, SAL("_In_")],
                           ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationByName(dp: Dumpulator,
                             ObjectAttributes: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                             IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                             FileInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(Length)")],
                             Length: Annotated[ULONG, SAL("_In_")],
                             FileInformationClass: Annotated[FILE_INFORMATION_CLASS, SAL("_In_")]
                             ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationEnlistment(dp: Dumpulator,
                                 EnlistmentHandle: Annotated[HANDLE, SAL("_In_")],
                                 EnlistmentInformationClass: Annotated[ENLISTMENT_INFORMATION_CLASS, SAL("_In_")],
                                 EnlistmentInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(EnlistmentInformationLength)")],
                                 EnlistmentInformationLength: Annotated[ULONG, SAL("_In_")],
                                 ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                                 ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationFile(dp: Dumpulator,
                           FileHandle: Annotated[HANDLE, SAL("_In_")],
                           IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                           FileInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(Length)")],
                           Length: Annotated[ULONG, SAL("_In_")],
                           FileInformationClass: Annotated[FILE_INFORMATION_CLASS, SAL("_In_")]
                           ):
    if dp.handles.valid(FileHandle):
        if FileInformationClass == FILE_INFORMATION_CLASS.FileStandardInformation:
            assert Length == 0x18
            assert FileInformation != 0
            assert IoStatusBlock != 0

            file = dp.handles.get(FileHandle, AbstractFileObject)

            # https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/5afa7f66-619c-48f3-955f-68c4ece704ae
            # return FILE_STANDARD_INFORMATION
            end_of_file = 0 if file.data is None else len(file.data)
            alloc_size = end_of_file + (end_of_file % 0x1000)
            number_of_links = 1
            delete_pending = 0
            directory = 0
            reserved = 0

            info = struct.pack("<QQLBBH", alloc_size, end_of_file, number_of_links, delete_pending, directory, reserved)
            FileInformation.write(info)

            # Put the number of bytes written in the status block
            IO_STATUS_BLOCK.write(IoStatusBlock, STATUS_SUCCESS, len(info))
            return STATUS_SUCCESS
        elif FileInformationClass == FILE_INFORMATION_CLASS.FilePositionInformation:
            assert Length == 0x8
            assert FileInformation != 0
            assert IoStatusBlock != 0

            file_handle_data = dp.handles.get(FileHandle, AbstractFileObject)

            # https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/e3ce4a39-327e-495c-99b6-6b61606b6f16
            # return FILE_POSITION_INFORMATION
            info = struct.pack("<Q", file_handle_data.file_offset)
            FileInformation.write(info)

            # Put the number of bytes written in the status block
            IO_STATUS_BLOCK.write(IoStatusBlock, STATUS_SUCCESS, len(info))
            return STATUS_SUCCESS

    if FileInformationClass == FILE_INFORMATION_CLASS.FileAttributeTagInformation:
        assert Length == 8
        assert FileInformation != 0
        assert IoStatusBlock != 0
        assert dp.ptr_size() == 8  # TODO: implement 32-bit

        # Return file attributes
        FileAttributes = 0x80  # FILE_ATTRIBUTE_NORMAL
        ReparseTag = 0
        info = struct.pack("<II", FileAttributes, ReparseTag)
        FileInformation.write(info)

        # Put the number of bytes written in the status block
        IO_STATUS_BLOCK.write(IoStatusBlock, STATUS_SUCCESS, len(info))
        return STATUS_SUCCESS
    raise NotImplementedError()

@syscall
def ZwQueryInformationJobObject(dp: Dumpulator,
                                JobHandle: Annotated[HANDLE, SAL("_In_opt_")],
                                JobObjectInformationClass: Annotated[JOBOBJECTINFOCLASS, SAL("_In_")],
                                JobObjectInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(JobObjectInformationLength)")],
                                JobObjectInformationLength: Annotated[ULONG, SAL("_In_")],
                                ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationPort(dp: Dumpulator,
                           PortHandle: Annotated[HANDLE, SAL("_In_")],
                           PortInformationClass: Annotated[PORT_INFORMATION_CLASS, SAL("_In_")],
                           PortInformation: Annotated[PVOID, SAL("_Out_writes_bytes_to_(Length, *ReturnLength)")],
                           Length: Annotated[ULONG, SAL("_In_")],
                           ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationProcess(dp: Dumpulator,
                              ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                              ProcessInformationClass: Annotated[PROCESSINFOCLASS, SAL("_In_")],
                              ProcessInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(ProcessInformationLength)")],
                              ProcessInformationLength: Annotated[ULONG, SAL("_In_")],
                              ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                              ):
    assert ProcessHandle == dp.NtCurrentProcess()
    if ProcessInformationClass == PROCESSINFOCLASS.ProcessDebugPort:
        assert ProcessInformationLength == dp.ptr_size()
        dp.write_ptr(ProcessInformation.ptr, 0)
        if ReturnLength != 0:
            dp.write_ulong(ReturnLength.ptr, dp.ptr_size())
        return STATUS_SUCCESS
    elif ProcessInformationClass == PROCESSINFOCLASS.ProcessDebugObjectHandle:
        assert ProcessInformationLength == dp.ptr_size()
        dp.write_ptr(ProcessInformation.ptr, 0)
        if ReturnLength != 0:
            dp.write_ulong(ReturnLength.ptr, dp.ptr_size())
        return STATUS_PORT_NOT_SET
    elif ProcessInformationClass == PROCESSINFOCLASS.ProcessDefaultHardErrorMode:
        assert ProcessInformationLength == 4
        dp.write_ulong(ProcessInformation.ptr, 1)
        if ReturnLength.ptr:
            dp.write_ulong(ReturnLength.ptr, 4)
        return STATUS_SUCCESS
    elif ProcessInformationClass == PROCESSINFOCLASS.ProcessExecuteFlags:
        assert ProcessInformationLength == 4
        dp.write_ulong(ProcessInformation.ptr, 0xD)
        if ReturnLength.ptr:
            dp.write_ulong(ReturnLength.ptr, 4)
        return STATUS_SUCCESS
    elif ProcessInformationClass == PROCESSINFOCLASS.ProcessImageInformation:
        sii = SECTION_IMAGE_INFORMATION(dp)
        assert ProcessInformationLength == ctypes.sizeof(sii)
        module = dp.modules[dp.modules.main]
        pe = module.pe
        opt = pe.OPTIONAL_HEADER
        sii.TransferAddress = module.entry
        sii.ZeroBits = 0
        sii.MaximumStackSize = opt.SizeOfStackReserve
        sii.CommittedStackSize = opt.SizeOfStackCommit  # TODO: more might be committed, check PEB
        sii.SubSystemType = opt.Subsystem
        sii.SubSystemMinorVersion = opt.MinorSubsystemVersion
        sii.SubSystemMajorVersion = opt.MajorSubsystemVersion
        sii.MinorOperatingSystemVersion = opt.MinorOperatingSystemVersion
        sii.MajorOperatingSystemVersion = opt.MajorOperatingSystemVersion
        sii.ImageCharacteristics = pe.FILE_HEADER.Characteristics  # TODO
        sii.DllCharacteristics = opt.DllCharacteristics  # TODO
        sii.Machine = pe.FILE_HEADER.Machine
        sii.ImageContainsCode = 1
        sii.ImageFlags = 1  # TODO
        sii.LoaderFlags = 0  # TODO
        sii.ImageFileSize = module.size  # TODO: best we can do?
        sii.CheckSum = opt.CheckSum
        ProcessInformation.write(bytes(sii))
        if ReturnLength.ptr:
            dp.write_ulong(ReturnLength.ptr, ctypes.sizeof(sii))
        return STATUS_SUCCESS
    elif ProcessInformationClass == PROCESSINFOCLASS.ProcessBasicInformation:
        pbi = PROCESS_BASIC_INFORMATION(dp)
        assert ProcessInformationLength == Struct.sizeof(pbi)
        pbi.ExitStatus = 259  # STILL_ACTIVE
        pbi.PebBaseAddress = dp.peb
        pbi.AffinityMask = 0xFFFF
        pbi.BasePriority = 8
        pbi.UniqueProcessId = dp.process_id
        pbi.InheritedFromUniqueProcessId = dp.parent_process_id
        ProcessInformation.write(bytes(pbi))
        if ReturnLength.ptr:
            dp.write_ulong(ReturnLength.ptr, Struct.sizeof(pbi))
        return STATUS_SUCCESS
    elif ProcessInformationClass == PROCESSINFOCLASS.ProcessImageFileNameWin32:
        main_module = dp.modules[dp.modules.main]
        buffer = UNICODE_STRING.create_buffer(main_module.path, ProcessInformation)
        assert ProcessInformationLength >= len(buffer)
        if ReturnLength.ptr:
            dp.write_ulong(ReturnLength.ptr, len(buffer))
        ProcessInformation.write(buffer)
        return STATUS_SUCCESS
    raise NotImplementedError()

@syscall
def ZwQueryInformationResourceManager(dp: Dumpulator,
                                      ResourceManagerHandle: Annotated[HANDLE, SAL("_In_")],
                                      ResourceManagerInformationClass: Annotated[RESOURCEMANAGER_INFORMATION_CLASS, SAL("_In_")],
                                      ResourceManagerInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(ResourceManagerInformationLength)")],
                                      ResourceManagerInformationLength: Annotated[ULONG, SAL("_In_")],
                                      ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                                      ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationThread(dp: Dumpulator,
                             ThreadHandle: Annotated[HANDLE, SAL("_In_")],
                             ThreadInformationClass: Annotated[THREADINFOCLASS, SAL("_In_")],
                             ThreadInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(ThreadInformationLength)")],
                             ThreadInformationLength: Annotated[ULONG, SAL("_In_")],
                             ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                             ):
    if ThreadInformationClass == THREADINFOCLASS.ThreadDynamicCodePolicyInfo:
        assert ThreadInformationLength == 4
        assert ReturnLength == 0
        dp.write_ulong(ThreadInformation, 0)
        return STATUS_SUCCESS
    raise Exception()

@syscall
def ZwQueryInformationToken(dp: Dumpulator,
                            TokenHandle: Annotated[HANDLE, SAL("_In_")],
                            TokenInformationClass: Annotated[TOKEN_INFORMATION_CLASS, SAL("_In_")],
                            TokenInformation: Annotated[PVOID, SAL("_Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength)")],
                            TokenInformationLength: Annotated[ULONG, SAL("_In_")],
                            ReturnLength: Annotated[P[ULONG], SAL("_Out_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationTransaction(dp: Dumpulator,
                                  TransactionHandle: Annotated[HANDLE, SAL("_In_")],
                                  TransactionInformationClass: Annotated[TRANSACTION_INFORMATION_CLASS, SAL("_In_")],
                                  TransactionInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(TransactionInformationLength)")],
                                  TransactionInformationLength: Annotated[ULONG, SAL("_In_")],
                                  ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationTransactionManager(dp: Dumpulator,
                                         TransactionManagerHandle: Annotated[HANDLE, SAL("_In_")],
                                         TransactionManagerInformationClass: Annotated[TRANSACTIONMANAGER_INFORMATION_CLASS, SAL("_In_")],
                                         TransactionManagerInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(TransactionManagerInformationLength)")],
                                         TransactionManagerInformationLength: Annotated[ULONG, SAL("_In_")],
                                         ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                                         ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationWorkerFactory(dp: Dumpulator,
                                    WorkerFactoryHandle: Annotated[HANDLE, SAL("_In_")],
                                    WorkerFactoryInformationClass: Annotated[WORKERFACTORYINFOCLASS, SAL("_In_")],
                                    WorkerFactoryInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(WorkerFactoryInformationLength)")],
                                    WorkerFactoryInformationLength: Annotated[ULONG, SAL("_In_")],
                                    ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                                    ):
    raise NotImplementedError()

@syscall
def ZwQueryInstallUILanguage(dp: Dumpulator,
                             InstallUILanguageId: Annotated[P[LANGID], SAL("_Out_")]
                             ):
    raise NotImplementedError()

@syscall
def ZwQueryIntervalProfile(dp: Dumpulator,
                           ProfileSource: Annotated[KPROFILE_SOURCE, SAL("_In_")],
                           Interval: Annotated[P[ULONG], SAL("_Out_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwQueryIoCompletion(dp: Dumpulator,
                        IoCompletionHandle: Annotated[HANDLE, SAL("_In_")],
                        IoCompletionInformationClass: Annotated[IO_COMPLETION_INFORMATION_CLASS, SAL("_In_")],
                        IoCompletionInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(IoCompletionInformationLength)")],
                        IoCompletionInformationLength: Annotated[ULONG, SAL("_In_")],
                        ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwQueryKey(dp: Dumpulator,
               KeyHandle: Annotated[HANDLE, SAL("_In_")],
               KeyInformationClass: Annotated[KEY_INFORMATION_CLASS, SAL("_In_")],
               KeyInformation: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(Length)")],
               Length: Annotated[ULONG, SAL("_In_")],
               ResultLength: Annotated[P[ULONG], SAL("_Out_")]
               ):
    raise NotImplementedError()

@syscall
def ZwQueryLicenseValue(dp: Dumpulator,
                        ValueName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                        Type: Annotated[P[ULONG], SAL("_Out_opt_")],
                        Data: Annotated[PVOID, SAL("_Out_writes_bytes_to_opt_(DataSize, *ResultDataSize)")],
                        DataSize: Annotated[ULONG, SAL("_In_")],
                        ResultDataSize: Annotated[P[ULONG], SAL("_Out_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwQueryMultipleValueKey(dp: Dumpulator,
                            KeyHandle: Annotated[HANDLE, SAL("_In_")],
                            ValueEntries: Annotated[P[KEY_VALUE_ENTRY], SAL("_Inout_updates_(EntryCount)")],
                            EntryCount: Annotated[ULONG, SAL("_In_")],
                            ValueBuffer: Annotated[PVOID, SAL("_Out_writes_bytes_(*BufferLength)")],
                            BufferLength: Annotated[P[ULONG], SAL("_Inout_")],
                            RequiredBufferLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwQueryMutant(dp: Dumpulator,
                  MutantHandle: Annotated[HANDLE, SAL("_In_")],
                  MutantInformationClass: Annotated[MUTANT_INFORMATION_CLASS, SAL("_In_")],
                  MutantInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(MutantInformationLength)")],
                  MutantInformationLength: Annotated[ULONG, SAL("_In_")],
                  ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwQueryObject(dp: Dumpulator,
                  Handle: Annotated[HANDLE, SAL("_In_opt_")],
                  ObjectInformationClass: Annotated[OBJECT_INFORMATION_CLASS, SAL("_In_")],
                  ObjectInformation: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(ObjectInformationLength)")],
                  ObjectInformationLength: Annotated[ULONG, SAL("_In_")],
                  ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                  ):
    if ObjectInformationClass == OBJECT_INFORMATION_CLASS.ObjectHandleFlagInformation:
        assert ObjectInformationLength == 2
        ObjectInformation.write(b'\0\0')
        return STATUS_SUCCESS
    raise NotImplementedError()

@syscall
def ZwQueryOpenSubKeys(dp: Dumpulator,
                       TargetKey: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                       HandleCount: Annotated[P[ULONG], SAL("_Out_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwQueryOpenSubKeysEx(dp: Dumpulator,
                         TargetKey: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                         BufferLength: Annotated[ULONG, SAL("_In_")],
                         Buffer: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(BufferLength)")],
                         RequiredSize: Annotated[P[ULONG], SAL("_Out_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwQueryPerformanceCounter(dp: Dumpulator
                              ):
    raise NotImplementedError()

@syscall
def ZwQueryPortInformationProcess(dp: Dumpulator,
                                  PerformanceCounter: Annotated[P[LARGE_INTEGER], SAL("_Out_")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwQueryQuotaInformationFile(dp: Dumpulator,
                                FileHandle: Annotated[HANDLE, SAL("_In_")],
                                IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                                Buffer: Annotated[PVOID, SAL("_Out_writes_bytes_(Length)")],
                                Length: Annotated[ULONG, SAL("_In_")],
                                ReturnSingleEntry: Annotated[BOOLEAN, SAL("_In_")],
                                SidList: Annotated[PVOID, SAL("_In_reads_bytes_opt_(SidListLength)")],
                                SidListLength: Annotated[ULONG, SAL("_In_")],
                                StartSid: Annotated[PSID, SAL("_In_opt_")],
                                RestartScan: Annotated[BOOLEAN, SAL("_In_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwQuerySection(dp: Dumpulator,
                   SectionHandle: Annotated[HANDLE, SAL("_In_")],
                   SectionInformationClass: Annotated[SECTION_INFORMATION_CLASS, SAL("_In_")],
                   SectionInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(SectionInformationLength)")],
                   SectionInformationLength: Annotated[SIZE_T, SAL("_In_")],
                   ReturnLength: Annotated[P[SIZE_T], SAL("_Out_opt_")]
                   ):
    raise NotImplementedError()

@syscall
def ZwQuerySecurityAttributesToken(dp: Dumpulator,
                                   TokenHandle: Annotated[HANDLE, SAL("_In_")],
                                   Attributes: Annotated[P[UNICODE_STRING], SAL("_In_reads_opt_(NumberOfAttributes)")],
                                   NumberOfAttributes: Annotated[ULONG, SAL("_In_")],
                                   Buffer: Annotated[PVOID, SAL("_Out_writes_bytes_(Length)", "PTOKEN_SECURITY_ATTRIBUTES_INFORMATION")],
                                   Length: Annotated[ULONG, SAL("_In_")],
                                   ReturnLength: Annotated[P[ULONG], SAL("_Out_")]
                                   ):
    raise NotImplementedError()

@syscall
def ZwQuerySecurityObject(dp: Dumpulator,
                          Handle: Annotated[HANDLE, SAL("_In_")],
                          SecurityInformation: Annotated[SECURITY_INFORMATION, SAL("_In_")],
                          SecurityDescriptor: Annotated[P[SECURITY_DESCRIPTOR], SAL("_Out_writes_bytes_opt_(Length)")],
                          Length: Annotated[ULONG, SAL("_In_")],
                          LengthNeeded: Annotated[P[ULONG], SAL("_Out_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwQuerySemaphore(dp: Dumpulator,
                     SemaphoreHandle: Annotated[HANDLE, SAL("_In_")],
                     SemaphoreInformationClass: Annotated[SEMAPHORE_INFORMATION_CLASS, SAL("_In_")],
                     SemaphoreInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(SemaphoreInformationLength)")],
                     SemaphoreInformationLength: Annotated[ULONG, SAL("_In_")],
                     ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwQuerySymbolicLinkObject(dp: Dumpulator,
                              LinkHandle: Annotated[HANDLE, SAL("_In_")],
                              LinkTarget: Annotated[P[UNICODE_STRING], SAL("_Inout_")],
                              ReturnedLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwQuerySystemEnvironmentValue(dp: Dumpulator,
                                  VariableName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                  VariableValue: Annotated[PWSTR, SAL("_Out_writes_bytes_(ValueLength)")],
                                  ValueLength: Annotated[USHORT, SAL("_In_")],
                                  ReturnLength: Annotated[P[USHORT], SAL("_Out_opt_")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwQuerySystemEnvironmentValueEx(dp: Dumpulator,
                                    VariableName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                    VendorGuid: Annotated[P[GUID], SAL("_In_")],
                                    Value: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(*ValueLength)")],
                                    ValueLength: Annotated[P[ULONG], SAL("_Inout_")],
                                    Attributes: Annotated[P[ULONG], SAL("_Out_opt_", "EFI_VARIABLE_*")]
                                    ):
    raise NotImplementedError()

@syscall
def ZwQuerySystemInformation(dp: Dumpulator,
                             SystemInformationClass: Annotated[SYSTEM_INFORMATION_CLASS, SAL("_In_")],
                             SystemInformation: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(SystemInformationLength)")],
                             SystemInformationLength: Annotated[ULONG, SAL("_In_")],
                             ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                             ):
    raise NotImplementedError()

@syscall
def ZwQuerySystemInformationEx(dp: Dumpulator,
                               SystemInformationClass: Annotated[SYSTEM_INFORMATION_CLASS, SAL("_In_")],
                               InputBuffer: Annotated[PVOID, SAL("_In_reads_bytes_(InputBufferLength)")],
                               InputBufferLength: Annotated[ULONG, SAL("_In_")],
                               SystemInformation: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(SystemInformationLength)")],
                               SystemInformationLength: Annotated[ULONG, SAL("_In_")],
                               ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                               ):
    raise NotImplementedError()

@syscall
def ZwQuerySystemTime(dp: Dumpulator,
                      SystemTime: Annotated[P[LARGE_INTEGER], SAL("_Out_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwQueryTimer(dp: Dumpulator,
                 TimerHandle: Annotated[HANDLE, SAL("_In_")],
                 TimerInformationClass: Annotated[TIMER_INFORMATION_CLASS, SAL("_In_")],
                 TimerInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(TimerInformationLength)")],
                 TimerInformationLength: Annotated[ULONG, SAL("_In_")],
                 ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwQueryTimerResolution(dp: Dumpulator,
                           MaximumTime: Annotated[P[ULONG], SAL("_Out_")],
                           MinimumTime: Annotated[P[ULONG], SAL("_Out_")],
                           CurrentTime: Annotated[P[ULONG], SAL("_Out_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwQueryValueKey(dp: Dumpulator,
                    KeyHandle: Annotated[HANDLE, SAL("_In_")],
                    ValueName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                    KeyValueInformationClass: Annotated[KEY_VALUE_INFORMATION_CLASS, SAL("_In_")],
                    KeyValueInformation: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(Length)")],
                    Length: Annotated[ULONG, SAL("_In_")],
                    ResultLength: Annotated[P[ULONG], SAL("_Out_")]
                    ):
    key = dp.handles.get(KeyHandle, RegistryKeyObject)
    name = ValueName[0].read_str()
    if KeyValueInformationClass == KEY_VALUE_INFORMATION_CLASS.KeyValueFullInformation:
        value = key.values.get(name.lower(), None)
        assert value is not None, "value not found"
        info = KEY_VALUE_FULL_INFORMATION()
        info.TitleIndex = 0

        if len(name) == 0:
            info.NameLength = 0
            appended_data = b""
        else:
            name_data = name.encode("utf-16-le")
            info.NameLength = len(name_data)
            appended_data = name_data

        # Align to 4 bytes
        remain = 4 - len(appended_data) % 4
        if remain > 0:
            appended_data += b"\0" * remain
            assert (len(appended_data) % 4) == 0

        if isinstance(value, str):
            info.Type = REG_SZ
            value_data = value.encode("utf-16-le") + b"\0\0"
        elif isinstance(value, int):
            info.Type = REG_DWORD
            value_data = struct.pack("<I", value)
        else:
            raise NotImplementedError()

        info.DataLength = len(value_data)
        info.DataOffset = ctypes.sizeof(info) + len(appended_data)
        appended_data += value_data

        final_data = bytes(info) + appended_data
        assert len(final_data) <= Length
        if ResultLength != 0:
            dp.write_ulong(ResultLength, len(final_data))
        KeyValueInformation.write(final_data)

        return STATUS_SUCCESS

    raise NotImplementedError()

@syscall
def ZwQueryVirtualMemory(dp: Dumpulator,
                         ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                         BaseAddress: Annotated[PVOID, SAL("_In_opt_")],
                         MemoryInformationClass: Annotated[MEMORY_INFORMATION_CLASS, SAL("_In_")],
                         MemoryInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(MemoryInformationLength)")],
                         MemoryInformationLength: Annotated[SIZE_T, SAL("_In_")],
                         ReturnLength: Annotated[P[SIZE_T], SAL("_Out_opt_")]
                         ):
    assert ProcessHandle == dp.NtCurrentProcess()
    if MemoryInformationClass == MEMORY_INFORMATION_CLASS.MemoryBasicInformation:
        info = dp.memory.query(BaseAddress.ptr)
        mbi = MEMORY_BASIC_INFORMATION(dp)
        assert MemoryInformationLength == ctypes.sizeof(mbi)
        mbi.BaseAddress = info.base
        mbi.AllocationBase = info.allocation_base
        mbi.AllocationProtect = info.allocation_protect.value
        mbi.RegionSize = info.region_size
        mbi.State = info.state.value
        mbi.Protect = info.protect.value
        mbi.Type = info.type.value
        MemoryInformation.write(bytes(mbi))
        if ReturnLength.ptr:
            ReturnLength.write_ulong(ctypes.sizeof(mbi))
        return STATUS_SUCCESS
    elif MemoryInformationClass == MEMORY_INFORMATION_CLASS.MemoryRegionInformation:
        parent_region = dp.memory.find_region(BaseAddress.ptr)
        mri = MEMORY_REGION_INFORMATION(dp)
        mri.AllocationBase = parent_region.start
        mri.AllocationProtect = parent_region.protect.value
        mri.Flags = REGION_MAPPED_IMAGE if parent_region.type == MemoryType.MEM_IMAGE else REGION_PRIVATE
        mri.RegionSize = parent_region.size
        mri.CommitSize = parent_region.size  # TODO
        assert MemoryInformationLength >= ctypes.sizeof(mri)
        MemoryInformation.write(bytes(mri))
        extra_size = MemoryInformationLength - ctypes.sizeof(mri)
        if extra_size > 0:
            dp.write(MemoryInformation.ptr + ctypes.sizeof(mri), b"\x69" * extra_size)
        if ReturnLength.ptr:
            ReturnLength.write_ulong(MemoryInformationLength)
        return STATUS_SUCCESS
    elif MemoryInformationClass == MEMORY_INFORMATION_CLASS.MemoryMappedFilenameInformation:
        # TODO: implement proper UNICODE_STRING type support
        if dp.ptr_size() == 8:
            name = "\\Device\\HarddiskVolume8\\CodeBlocks\\dumpulator\\tests\\ExceptionTest\\x64\\Release\\ExceptionTest.exe"
            ptr = MemoryInformation.ptr + 0x10
            ustr = struct.pack("<HHIQ", len(name) * 2, len(name) * 2 + 1, 0, ptr)
        else:
            name = "\\Device\\HarddiskVolume8\\CodeBlocks\\dumpulator\\tests\\ExceptionTest\\Release\\ExceptionTest.exe"
            ptr = MemoryInformation.ptr + 0x8
            ustr = struct.pack("<HHI", len(name) * 2, len(name) * 2 + 1, ptr)
        data = ustr + name.encode("utf-16-le")
        assert MemoryInformationLength >= len(data)
        MemoryInformation.write(data)
        if ReturnLength.ptr:
            ReturnLength.write_ulong(len(data))
        return STATUS_SUCCESS
    return STATUS_NOT_IMPLEMENTED

@syscall
def ZwQueryVolumeInformationFile(dp: Dumpulator,
                                 FileHandle: Annotated[HANDLE, SAL("_In_")],
                                 IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                                 FsInformation: Annotated[PVOID, SAL("_Out_writes_bytes_(Length)")],
                                 Length: Annotated[ULONG, SAL("_In_")],
                                 FsInformationClass: Annotated[FSINFOCLASS, SAL("_In_")]
                                 ):
    if FsInformationClass == FSINFOCLASS.FileFsDeviceInformation:
        assert Length == 8
        data = dp.handles.get(FileHandle, AbstractFileObject)
        if isinstance(data, ConsoleFileObject):
            # https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/616b66d5-b335-4e1c-8f87-b4a55e8d3e4a
            # FILE_DEVICE_DISK, FILE_CHARACTERISTIC_TS_DEVICE
            result = struct.pack('<II', 0x7, 0x1000)
            FsInformation.write(result)
            IO_STATUS_BLOCK.write(IoStatusBlock, STATUS_SUCCESS, len(result))
            return STATUS_SUCCESS

    raise NotImplementedError()

@syscall
def ZwQueryWnfStateData(dp: Dumpulator,
                        StateName: Annotated[P[CWNF_STATE_NAME], SAL("_In_")],
                        TypeId: Annotated[P[CWNF_TYPE_ID], SAL("_In_opt_")],
                        ExplicitScope: Annotated[PVOID, SAL("_In_opt_")],
                        ChangeStamp: Annotated[P[WNF_CHANGE_STAMP], SAL("_Out_")],
                        Buffer: Annotated[PVOID, SAL("_Out_writes_bytes_to_opt_(*BufferSize, *BufferSize)")],
                        BufferSize: Annotated[P[ULONG], SAL("_Inout_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwQueryWnfStateNameInformation(dp: Dumpulator,
                                   StateName: Annotated[P[CWNF_STATE_NAME], SAL("_In_")],
                                   NameInfoClass: Annotated[WNF_STATE_NAME_INFORMATION, SAL("_In_")],
                                   ExplicitScope: Annotated[PVOID, SAL("_In_opt_")],
                                   InfoBuffer: Annotated[PVOID, SAL("_Out_writes_bytes_(InfoBufferSize)")],
                                   InfoBufferSize: Annotated[ULONG, SAL("_In_")]
                                   ):
    raise NotImplementedError()

@syscall
def ZwQueueApcThread(dp: Dumpulator,
                     ThreadHandle: Annotated[HANDLE, SAL("_In_")],
                     ApcRoutine: Annotated[P[PS_APC_ROUTINE], SAL("_In_")],
                     ApcArgument1: Annotated[PVOID, SAL("_In_opt_")],
                     ApcArgument2: Annotated[PVOID, SAL("_In_opt_")],
                     ApcArgument3: Annotated[PVOID, SAL("_In_opt_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwQueueApcThreadEx(dp: Dumpulator,
                       ThreadHandle: Annotated[HANDLE, SAL("_In_")],
                       ReserveHandle: Annotated[HANDLE, SAL("_In_opt_", "NtAllocateReserveObject")],
                       ApcRoutine: Annotated[P[PS_APC_ROUTINE], SAL("_In_")],
                       ApcArgument1: Annotated[PVOID, SAL("_In_opt_")],
                       ApcArgument2: Annotated[PVOID, SAL("_In_opt_")],
                       ApcArgument3: Annotated[PVOID, SAL("_In_opt_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwQueueApcThreadEx2(dp: Dumpulator,
                        ThreadHandle: Annotated[HANDLE, SAL("_In_")],
                        ReserveHandle: Annotated[HANDLE, SAL("_In_opt_", "NtAllocateReserveObject")],
                        ApcFlags: Annotated[ULONG, SAL("_In_", "QUEUE_USER_APC_FLAGS")],
                        ApcRoutine: Annotated[P[PS_APC_ROUTINE], SAL("_In_")],
                        ApcArgument1: Annotated[PVOID, SAL("_In_opt_")],
                        ApcArgument2: Annotated[PVOID, SAL("_In_opt_")],
                        ApcArgument3: Annotated[PVOID, SAL("_In_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwRaiseException(dp: Dumpulator,
                     ExceptionRecord: Annotated[P[EXCEPTION_RECORD], SAL("_In_")],
                     ContextRecord: Annotated[P[CONTEXT], SAL("_In_")],
                     FirstChance: Annotated[BOOLEAN, SAL("_In_")]
                     ):
    if not FirstChance:
        # Terminate process (RaiseFailFastException)
        exception_code = ExceptionRecord.read_ulong()
        dp.stop(exception_code)
        return STATUS_SUCCESS
    else:
        # TODO: implement raising an exception
        raise NotImplementedError()

@syscall
def ZwRaiseHardError(dp: Dumpulator,
                     ErrorStatus: Annotated[NTSTATUS, SAL("_In_")],
                     NumberOfParameters: Annotated[ULONG, SAL("_In_")],
                     UnicodeStringParameterMask: Annotated[ULONG, SAL("_In_")],
                     Parameters: Annotated[P[ULONG_PTR], SAL("_In_reads_(NumberOfParameters)")],
                     ValidResponseOptions: Annotated[ULONG, SAL("_In_")],
                     Response: Annotated[P[ULONG], SAL("_Out_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwReadFile(dp: Dumpulator,
               FileHandle: Annotated[HANDLE, SAL("_In_")],
               Event: Annotated[HANDLE, SAL("_In_opt_")],
               ApcRoutine: Annotated[P[IO_APC_ROUTINE], SAL("_In_opt_")],
               ApcContext: Annotated[PVOID, SAL("_In_opt_")],
               IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
               Buffer: Annotated[PVOID, SAL("_Out_writes_bytes_(Length)")],
               Length: Annotated[ULONG, SAL("_In_")],
               ByteOffset: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")],
               Key: Annotated[P[ULONG], SAL("_In_opt_")]
               ):
    assert Event == 0
    assert ApcRoutine == 0
    assert ApcContext == 0
    assert ByteOffset == 0
    assert Key == 0
    if dp.handles.valid(FileHandle):
        assert Buffer != 0

        file = dp.handles.get(FileHandle, AbstractFileObject)
        buffer = file.read(Length)

        print(f"reading {file.path}: {buffer}")

        assert len(buffer) <= Length

        Buffer.write(buffer)

        dp.write_ptr(IoStatusBlock.ptr, STATUS_SUCCESS)
        dp.write_ptr(IoStatusBlock.ptr + dp.ptr_size(), len(buffer))

        return STATUS_SUCCESS

    raise NotImplementedError()

@syscall
def ZwReadFileScatter(dp: Dumpulator,
                      FileHandle: Annotated[HANDLE, SAL("_In_")],
                      Event: Annotated[HANDLE, SAL("_In_opt_")],
                      ApcRoutine: Annotated[P[IO_APC_ROUTINE], SAL("_In_opt_")],
                      ApcContext: Annotated[PVOID, SAL("_In_opt_")],
                      IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                      SegmentArray: Annotated[P[FILE_SEGMENT_ELEMENT], SAL("_In_")],
                      Length: Annotated[ULONG, SAL("_In_")],
                      ByteOffset: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")],
                      Key: Annotated[P[ULONG], SAL("_In_opt_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwReadOnlyEnlistment(dp: Dumpulator,
                         EnlistmentHandle: Annotated[HANDLE, SAL("_In_")],
                         TmVirtualClock: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwReadRequestData(dp: Dumpulator,
                      PortHandle: Annotated[HANDLE, SAL("_In_")],
                      Message: Annotated[P[PORT_MESSAGE], SAL("_In_")],
                      DataEntryIndex: Annotated[ULONG, SAL("_In_")],
                      Buffer: Annotated[PVOID, SAL("_Out_writes_bytes_to_(BufferSize, *NumberOfBytesRead)")],
                      BufferSize: Annotated[SIZE_T, SAL("_In_")],
                      NumberOfBytesRead: Annotated[P[SIZE_T], SAL("_Out_opt_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwReadVirtualMemory(dp: Dumpulator,
                        ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                        BaseAddress: Annotated[PVOID, SAL("_In_opt_")],
                        Buffer: Annotated[PVOID, SAL("_Out_writes_bytes_(BufferSize)")],
                        BufferSize: Annotated[SIZE_T, SAL("_In_")],
                        NumberOfBytesRead: Annotated[P[SIZE_T], SAL("_Out_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwRecoverEnlistment(dp: Dumpulator,
                        EnlistmentHandle: Annotated[HANDLE, SAL("_In_")],
                        EnlistmentKey: Annotated[PVOID, SAL("_In_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwRecoverResourceManager(dp: Dumpulator,
                             ResourceManagerHandle: Annotated[HANDLE, SAL("_In_")]
                             ):
    raise NotImplementedError()

@syscall
def ZwRecoverTransactionManager(dp: Dumpulator,
                                TransactionManagerHandle: Annotated[HANDLE, SAL("_In_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwRegisterProtocolAddressInformation(dp: Dumpulator,
                                         ResourceManager: Annotated[HANDLE, SAL("_In_")],
                                         ProtocolId: Annotated[P[CRM_PROTOCOL_ID], SAL("_In_")],
                                         ProtocolInformationSize: Annotated[ULONG, SAL("_In_")],
                                         ProtocolInformation: Annotated[PVOID, SAL("_In_")],
                                         CreateOptions: Annotated[ULONG, SAL("_In_opt_")]
                                         ):
    raise NotImplementedError()

@syscall
def ZwRegisterThreadTerminatePort(dp: Dumpulator,
                                  PortHandle: Annotated[HANDLE, SAL("_In_")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwReleaseCMFViewOwnership(dp: Dumpulator
                              ):
    raise NotImplementedError()

@syscall
def ZwReleaseKeyedEvent(dp: Dumpulator,
                        KeyedEventHandle: Annotated[HANDLE, SAL("_In_")],
                        KeyValue: Annotated[PVOID, SAL("_In_")],
                        Alertable: Annotated[BOOLEAN, SAL("_In_")],
                        Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwReleaseMutant(dp: Dumpulator,
                    MutantHandle: Annotated[HANDLE, SAL("_In_")],
                    PreviousCount: Annotated[P[LONG], SAL("_Out_opt_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwReleaseSemaphore(dp: Dumpulator,
                       SemaphoreHandle: Annotated[HANDLE, SAL("_In_")],
                       ReleaseCount: Annotated[LONG, SAL("_In_")],
                       PreviousCount: Annotated[P[LONG], SAL("_Out_opt_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwReleaseWorkerFactoryWorker(dp: Dumpulator,
                                 WorkerFactoryHandle: Annotated[HANDLE, SAL("_In_")]
                                 ):
    raise NotImplementedError()

@syscall
def ZwRemoveIoCompletion(dp: Dumpulator,
                         IoCompletionHandle: Annotated[HANDLE, SAL("_In_")],
                         KeyContext: Annotated[P[PVOID], SAL("_Out_")],
                         ApcContext: Annotated[P[PVOID], SAL("_Out_")],
                         IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                         Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwRemoveIoCompletionEx(dp: Dumpulator,
                           IoCompletionHandle: Annotated[HANDLE, SAL("_In_")],
                           IoCompletionInformation: Annotated[P[FILE_IO_COMPLETION_INFORMATION], SAL("_Out_writes_to_(Count, *NumEntriesRemoved)")],
                           Count: Annotated[ULONG, SAL("_In_")],
                           NumEntriesRemoved: Annotated[P[ULONG], SAL("_Out_")],
                           Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")],
                           Alertable: Annotated[BOOLEAN, SAL("_In_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwRemoveProcessDebug(dp: Dumpulator,
                         ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                         DebugObjectHandle: Annotated[HANDLE, SAL("_In_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwRenameKey(dp: Dumpulator,
                KeyHandle: Annotated[HANDLE, SAL("_In_")],
                NewName: Annotated[P[UNICODE_STRING], SAL("_In_")]
                ):
    raise NotImplementedError()

@syscall
def ZwRenameTransactionManager(dp: Dumpulator,
                               LogFileName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                               ExistingTransactionManagerGuid: Annotated[P[GUID], SAL("_In_")]
                               ):
    raise NotImplementedError()

@syscall
def ZwReplaceKey(dp: Dumpulator,
                 NewFile: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                 TargetHandle: Annotated[HANDLE, SAL("_In_")],
                 OldFile: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwReplacePartitionUnit(dp: Dumpulator,
                           TargetInstancePath: Annotated[P[UNICODE_STRING], SAL("_In_")],
                           SpareInstancePath: Annotated[P[UNICODE_STRING], SAL("_In_")],
                           Flags: Annotated[ULONG, SAL("_In_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwReplyPort(dp: Dumpulator,
                PortHandle: Annotated[HANDLE, SAL("_In_")],
                ReplyMessage: Annotated[P[PORT_MESSAGE], SAL("_In_reads_bytes_(ReplyMessage->u1.s1.TotalLength)")]
                ):
    raise NotImplementedError()

@syscall
def ZwReplyWaitReceivePort(dp: Dumpulator,
                           PortHandle: Annotated[HANDLE, SAL("_In_")],
                           PortContext: Annotated[P[PVOID], SAL("_Out_opt_")],
                           ReplyMessage: Annotated[P[PORT_MESSAGE], SAL("_In_reads_bytes_opt_(ReplyMessage->u1.s1.TotalLength)")],
                           ReceiveMessage: Annotated[P[PORT_MESSAGE], SAL("_Out_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwReplyWaitReceivePortEx(dp: Dumpulator,
                             PortHandle: Annotated[HANDLE, SAL("_In_")],
                             PortContext: Annotated[P[PVOID], SAL("_Out_opt_")],
                             ReplyMessage: Annotated[P[PORT_MESSAGE], SAL("_In_reads_bytes_opt_(ReplyMessage->u1.s1.TotalLength)")],
                             ReceiveMessage: Annotated[P[PORT_MESSAGE], SAL("_Out_")],
                             Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                             ):
    raise NotImplementedError()

@syscall
def ZwReplyWaitReplyPort(dp: Dumpulator,
                         PortHandle: Annotated[HANDLE, SAL("_In_")],
                         ReplyMessage: Annotated[P[PORT_MESSAGE], SAL("_Inout_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwRequestPort(dp: Dumpulator,
                  PortHandle: Annotated[HANDLE, SAL("_In_")],
                  RequestMessage: Annotated[P[PORT_MESSAGE], SAL("_In_reads_bytes_(RequestMessage->u1.s1.TotalLength)")]
                  ):
    raise NotImplementedError()

@syscall
def ZwRequestWaitReplyPort(dp: Dumpulator,
                           PortHandle: Annotated[HANDLE, SAL("_In_")],
                           RequestMessage: Annotated[P[PORT_MESSAGE], SAL("_In_reads_bytes_(RequestMessage->u1.s1.TotalLength)")],
                           ReplyMessage: Annotated[P[PORT_MESSAGE], SAL("_Out_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwRequestWakeupLatency(dp: Dumpulator,
                           latency: Annotated[LATENCY_TIME, SAL("_In_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwResetEvent(dp: Dumpulator,
                 EventHandle: Annotated[HANDLE, SAL("_In_")],
                 PreviousState: Annotated[P[LONG], SAL("_Out_opt_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwResetWriteWatch(dp: Dumpulator,
                      ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                      BaseAddress: Annotated[PVOID, SAL("_In_")],
                      RegionSize: Annotated[SIZE_T, SAL("_In_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwRestoreKey(dp: Dumpulator,
                 KeyHandle: Annotated[HANDLE, SAL("_In_")],
                 FileHandle: Annotated[HANDLE, SAL("_In_")],
                 Flags: Annotated[ULONG, SAL("_In_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwResumeProcess(dp: Dumpulator,
                    ProcessHandle: Annotated[HANDLE, SAL("_In_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwResumeThread(dp: Dumpulator,
                   ThreadHandle: Annotated[HANDLE, SAL("_In_")],
                   PreviousSuspendCount: Annotated[P[ULONG], SAL("_Out_opt_")]
                   ):
    raise NotImplementedError()

@syscall
def ZwRevertContainerImpersonation(dp: Dumpulator
                                   ):
    raise NotImplementedError()

@syscall
def ZwRollbackComplete(dp: Dumpulator,
                       EnlistmentHandle: Annotated[HANDLE, SAL("_In_")],
                       TmVirtualClock: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwRollbackEnlistment(dp: Dumpulator,
                         EnlistmentHandle: Annotated[HANDLE, SAL("_In_")],
                         TmVirtualClock: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwRollbackTransaction(dp: Dumpulator,
                          TransactionHandle: Annotated[HANDLE, SAL("_In_")],
                          Wait: Annotated[BOOLEAN, SAL("_In_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwRollforwardTransactionManager(dp: Dumpulator,
                                    TransactionManagerHandle: Annotated[HANDLE, SAL("_In_")],
                                    TmVirtualClock: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                                    ):
    raise NotImplementedError()

@syscall
def ZwSaveKey(dp: Dumpulator,
              KeyHandle: Annotated[HANDLE, SAL("_In_")],
              FileHandle: Annotated[HANDLE, SAL("_In_")]
              ):
    raise NotImplementedError()

@syscall
def ZwSaveKeyEx(dp: Dumpulator,
                KeyHandle: Annotated[HANDLE, SAL("_In_")],
                FileHandle: Annotated[HANDLE, SAL("_In_")],
                Format: Annotated[ULONG, SAL("_In_")]
                ):
    raise NotImplementedError()

@syscall
def ZwSaveMergedKeys(dp: Dumpulator,
                     HighPrecedenceKeyHandle: Annotated[HANDLE, SAL("_In_")],
                     LowPrecedenceKeyHandle: Annotated[HANDLE, SAL("_In_")],
                     FileHandle: Annotated[HANDLE, SAL("_In_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwSecureConnectPort(dp: Dumpulator,
                        PortHandle: Annotated[P[HANDLE], SAL("_Out_")],
                        PortName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                        SecurityQos: Annotated[P[SECURITY_QUALITY_OF_SERVICE], SAL("_In_")],
                        ClientView: Annotated[P[PORT_VIEW], SAL("_Inout_opt_")],
                        RequiredServerSid: Annotated[PSID, SAL("_In_opt_")],
                        ServerView: Annotated[P[REMOTE_PORT_VIEW], SAL("_Inout_opt_")],
                        MaxMessageLength: Annotated[P[ULONG], SAL("_Out_opt_")],
                        ConnectionInformation: Annotated[PVOID, SAL("_Inout_updates_bytes_to_opt_(*ConnectionInformationLength, *ConnectionInformationLength)")],
                        ConnectionInformationLength: Annotated[P[ULONG], SAL("_Inout_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwSerializeBoot(dp: Dumpulator
                    ):
    raise NotImplementedError()

@syscall
def ZwSetBootEntryOrder(dp: Dumpulator,
                        Ids: Annotated[P[ULONG], SAL("_In_reads_(Count)")],
                        Count: Annotated[ULONG, SAL("_In_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwSetBootOptions(dp: Dumpulator,
                     BootOptions: Annotated[P[BOOT_OPTIONS], SAL("_In_")],
                     FieldsToChange: Annotated[ULONG, SAL("_In_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwSetCachedSigningLevel(dp: Dumpulator,
                            Flags: Annotated[ULONG, SAL("_In_")],
                            InputSigningLevel: Annotated[SE_SIGNING_LEVEL, SAL("_In_")],
                            SourceFiles: Annotated[P[HANDLE], SAL("_In_reads_(SourceFileCount)")],
                            SourceFileCount: Annotated[ULONG, SAL("_In_")],
                            TargetFile: Annotated[HANDLE, SAL("_In_opt_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwSetContextThread(dp: Dumpulator,
                       ThreadHandle: Annotated[HANDLE, SAL("_In_")],
                       ThreadContext: Annotated[P[CONTEXT], SAL("_In_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwSetDebugFilterState(dp: Dumpulator,
                          ComponentId: Annotated[ULONG, SAL("_In_")],
                          Level: Annotated[ULONG, SAL("_In_")],
                          State: Annotated[BOOLEAN, SAL("_In_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwSetDefaultHardErrorPort(dp: Dumpulator,
                              DefaultHardErrorPort: Annotated[HANDLE, SAL("_In_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwSetDefaultLocale(dp: Dumpulator,
                       UserProfile: Annotated[BOOLEAN, SAL("_In_")],
                       DefaultLocaleId: Annotated[LCID, SAL("_In_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwSetDefaultUILanguage(dp: Dumpulator,
                           DefaultUILanguageId: Annotated[LANGID, SAL("_In_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwSetDriverEntryOrder(dp: Dumpulator,
                          Ids: Annotated[P[ULONG], SAL("_In_reads_(Count)")],
                          Count: Annotated[ULONG, SAL("_In_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwSetEaFile(dp: Dumpulator,
                FileHandle: Annotated[HANDLE, SAL("_In_")],
                IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                Buffer: Annotated[PVOID, SAL("_In_reads_bytes_(Length)")],
                Length: Annotated[ULONG, SAL("_In_")]
                ):
    raise NotImplementedError()

@syscall
def ZwSetEvent(dp: Dumpulator,
               EventHandle: Annotated[HANDLE, SAL("_In_")],
               PreviousState: Annotated[P[LONG], SAL("_Out_opt_")]
               ):
    return STATUS_SUCCESS

@syscall
def ZwSetEventBoostPriority(dp: Dumpulator,
                            EventHandle: Annotated[HANDLE, SAL("_In_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwSetHighEventPair(dp: Dumpulator,
                       EventPairHandle: Annotated[HANDLE, SAL("_In_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwSetHighWaitLowEventPair(dp: Dumpulator,
                              EventPairHandle: Annotated[HANDLE, SAL("_In_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwSetInformationDebugObject(dp: Dumpulator,
                                DebugObjectHandle: Annotated[HANDLE, SAL("_In_")],
                                DebugObjectInformationClass: Annotated[DEBUGOBJECTINFOCLASS, SAL("_In_")],
                                DebugInformation: Annotated[PVOID, SAL("_In_")],
                                DebugInformationLength: Annotated[ULONG, SAL("_In_")],
                                ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwSetInformationEnlistment(dp: Dumpulator,
                               EnlistmentHandle: Annotated[HANDLE, SAL("_In_opt_")],
                               EnlistmentInformationClass: Annotated[ENLISTMENT_INFORMATION_CLASS, SAL("_In_")],
                               EnlistmentInformation: Annotated[PVOID, SAL("_In_reads_bytes_(EnlistmentInformationLength)")],
                               EnlistmentInformationLength: Annotated[ULONG, SAL("_In_")]
                               ):
    raise NotImplementedError()

@syscall
def ZwSetInformationFile(dp: Dumpulator,
                         FileHandle: Annotated[HANDLE, SAL("_In_")],
                         IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                         FileInformation: Annotated[PVOID, SAL("_In_reads_bytes_(Length)")],
                         Length: Annotated[ULONG, SAL("_In_")],
                         FileInformationClass: Annotated[FILE_INFORMATION_CLASS, SAL("_In_")]
                         ):
    if dp.handles.valid(FileHandle):
        if FileInformationClass == FILE_INFORMATION_CLASS.FilePositionInformation:
            assert IoStatusBlock.ptr != 0
            assert FileInformation.ptr != 0
            assert Length == 8

            handle_data = dp.handles.get(FileHandle, AbstractFileObject)

            # https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/e3ce4a39-327e-495c-99b6-6b61606b6f16
            info = FileInformation.read(Length)
            file_offset = struct.unpack("<Q", info)[0]
            print(f"setting file pos of {handle_data.path} to {file_offset}")
            handle_data.file_offset = file_offset

            return STATUS_SUCCESS

    if FileInformationClass == FILE_INFORMATION_CLASS.FileDispositionInformationEx:
        print(f"Delete file {hex(FileHandle)}")
        assert IoStatusBlock.ptr != 0
        assert FileInformation.ptr != 0
        assert Length == 4
        return STATUS_SUCCESS
    elif FileInformationClass == FILE_INFORMATION_CLASS.FileDispositionInformation:
        print(f"Delete file {hex(FileHandle)}")
        assert IoStatusBlock.ptr != 0
        assert FileInformation.ptr != 0
        assert Length == 1
        return STATUS_SUCCESS
    raise NotImplementedError()

@syscall
def ZwSetInformationJobObject(dp: Dumpulator,
                              JobHandle: Annotated[HANDLE, SAL("_In_")],
                              JobObjectInformationClass: Annotated[JOBOBJECTINFOCLASS, SAL("_In_")],
                              JobObjectInformation: Annotated[PVOID, SAL("_In_reads_bytes_(JobObjectInformationLength)")],
                              JobObjectInformationLength: Annotated[ULONG, SAL("_In_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwSetInformationKey(dp: Dumpulator,
                        KeyHandle: Annotated[HANDLE, SAL("_In_")],
                        KeySetInformationClass: Annotated[KEY_SET_INFORMATION_CLASS, SAL("_In_")],
                        KeySetInformation: Annotated[PVOID, SAL("_In_reads_bytes_(KeySetInformationLength)")],
                        KeySetInformationLength: Annotated[ULONG, SAL("_In_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwSetInformationObject(dp: Dumpulator,
                           Handle: Annotated[HANDLE, SAL("_In_")],
                           ObjectInformationClass: Annotated[OBJECT_INFORMATION_CLASS, SAL("_In_")],
                           ObjectInformation: Annotated[PVOID, SAL("_In_reads_bytes_(ObjectInformationLength)")],
                           ObjectInformationLength: Annotated[ULONG, SAL("_In_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwSetInformationProcess(dp: Dumpulator,
                            ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                            ProcessInformationClass: Annotated[PROCESSINFOCLASS, SAL("_In_")],
                            ProcessInformation: Annotated[PVOID, SAL("_In_reads_bytes_(ProcessInformationLength)")],
                            ProcessInformationLength: Annotated[ULONG, SAL("_In_")]
                            ):
    assert ProcessHandle == dp.NtCurrentProcess()
    if ProcessInformationClass == PROCESSINFOCLASS.ProcessConsoleHostProcess:
        return STATUS_SUCCESS
    elif ProcessInformationClass == PROCESSINFOCLASS.ProcessRaiseUMExceptionOnInvalidHandleClose:
        return STATUS_SUCCESS
    elif ProcessInformationClass == PROCESSINFOCLASS.ProcessFaultInformation:
        assert ProcessInformationLength == 8
        # https://github.com/blackhatethicalhacking/sandbox-attacksurface-analysis-tools/blob/946912f55770522ed4a2c957d5f57a6a2e2845df/NtApiDotNet/NtProcessNative.cs#L403
        fault_flags = dp.read_ulong(ProcessInformation.ptr)
        additional_info = dp.read_ulong(ProcessInformation.ptr + 4)
        return STATUS_SUCCESS
    elif ProcessInformationClass == PROCESSINFOCLASS.ProcessLoaderDetour:
        assert ProcessInformationLength == 4
        dp.write_ulong(ProcessInformation, 0)
        return STATUS_SUCCESS
    raise NotImplementedError()

@syscall
def ZwSetInformationResourceManager(dp: Dumpulator,
                                    ResourceManagerHandle: Annotated[HANDLE, SAL("_In_")],
                                    ResourceManagerInformationClass: Annotated[RESOURCEMANAGER_INFORMATION_CLASS, SAL("_In_")],
                                    ResourceManagerInformation: Annotated[PVOID, SAL("_In_reads_bytes_(ResourceManagerInformationLength)")],
                                    ResourceManagerInformationLength: Annotated[ULONG, SAL("_In_")]
                                    ):
    raise NotImplementedError()

@syscall
def ZwSetInformationSymbolicLink(dp: Dumpulator,
                                 LinkHandle: Annotated[HANDLE, SAL("_In_")],
                                 SymbolicLinkInformationClass: Annotated[SYMBOLIC_LINK_INFO_CLASS, SAL("_In_")],
                                 SymbolicLinkInformation: Annotated[PVOID, SAL("_In_reads_bytes_(SymbolicLinkInformationLength)")],
                                 SymbolicLinkInformationLength: Annotated[ULONG, SAL("_In_")]
                                 ):
    raise NotImplementedError()

@syscall
def ZwSetInformationThread(dp: Dumpulator,
                           ThreadHandle: Annotated[HANDLE, SAL("_In_")],
                           ThreadInformationClass: Annotated[THREADINFOCLASS, SAL("_In_")],
                           ThreadInformation: Annotated[PVOID, SAL("_In_reads_bytes_(ThreadInformationLength)")],
                           ThreadInformationLength: Annotated[ULONG, SAL("_In_")]
                           ):
    if ThreadInformationClass == THREADINFOCLASS.ThreadHideFromDebugger:
        assert ThreadInformation == 0
        assert ThreadInformationLength == 0
        assert ThreadHandle == dp.NtCurrentThread()
        return STATUS_SUCCESS
    raise NotImplementedError()

@syscall
def ZwSetInformationToken(dp: Dumpulator,
                          TokenHandle: Annotated[HANDLE, SAL("_In_")],
                          TokenInformationClass: Annotated[TOKEN_INFORMATION_CLASS, SAL("_In_")],
                          TokenInformation: Annotated[PVOID, SAL("_In_reads_bytes_(TokenInformationLength)")],
                          TokenInformationLength: Annotated[ULONG, SAL("_In_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwSetInformationTransaction(dp: Dumpulator,
                                TransactionHandle: Annotated[HANDLE, SAL("_In_")],
                                TransactionInformationClass: Annotated[TRANSACTION_INFORMATION_CLASS, SAL("_In_")],
                                TransactionInformation: Annotated[PVOID, SAL("_In_reads_bytes_(TransactionInformationLength)")],
                                TransactionInformationLength: Annotated[ULONG, SAL("_In_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwSetInformationTransactionManager(dp: Dumpulator,
                                       TmHandle: Annotated[HANDLE, SAL("_In_opt_")],
                                       TransactionManagerInformationClass: Annotated[TRANSACTIONMANAGER_INFORMATION_CLASS, SAL("_In_")],
                                       TransactionManagerInformation: Annotated[PVOID, SAL("_In_reads_bytes_(TransactionManagerInformationLength)")],
                                       TransactionManagerInformationLength: Annotated[ULONG, SAL("_In_")]
                                       ):
    raise NotImplementedError()

@syscall
def ZwSetInformationVirtualMemory(dp: Dumpulator,
                                  ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                                  VmInformationClass: Annotated[VIRTUAL_MEMORY_INFORMATION_CLASS, SAL("_In_")],
                                  NumberOfEntries: Annotated[ULONG_PTR, SAL("_In_")],
                                  VirtualAddresses: Annotated[P[MEMORY_RANGE_ENTRY], SAL("_In_reads_ (NumberOfEntries)")],
                                  VmInformation: Annotated[PVOID, SAL("_In_reads_bytes_ (VmInformationLength)")],
                                  VmInformationLength: Annotated[ULONG, SAL("_In_")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwSetInformationWorkerFactory(dp: Dumpulator,
                                  WorkerFactoryHandle: Annotated[HANDLE, SAL("_In_")],
                                  WorkerFactoryInformationClass: Annotated[WORKERFACTORYINFOCLASS, SAL("_In_")],
                                  WorkerFactoryInformation: Annotated[PVOID, SAL("_In_reads_bytes_(WorkerFactoryInformationLength)")],
                                  WorkerFactoryInformationLength: Annotated[ULONG, SAL("_In_")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwSetIntervalProfile(dp: Dumpulator,
                         Interval: Annotated[ULONG, SAL("_In_")],
                         Source: Annotated[KPROFILE_SOURCE, SAL("_In_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwSetIoCompletion(dp: Dumpulator,
                      IoCompletionHandle: Annotated[HANDLE, SAL("_In_")],
                      KeyContext: Annotated[PVOID, SAL("_In_opt_")],
                      ApcContext: Annotated[PVOID, SAL("_In_opt_")],
                      IoStatus: Annotated[NTSTATUS, SAL("_In_")],
                      IoStatusInformation: Annotated[ULONG_PTR, SAL("_In_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwSetIoCompletionEx(dp: Dumpulator,
                        IoCompletionHandle: Annotated[HANDLE, SAL("_In_")],
                        IoCompletionPacketHandle: Annotated[HANDLE, SAL("_In_")],
                        KeyContext: Annotated[PVOID, SAL("_In_opt_")],
                        ApcContext: Annotated[PVOID, SAL("_In_opt_")],
                        IoStatus: Annotated[NTSTATUS, SAL("_In_")],
                        IoStatusInformation: Annotated[ULONG_PTR, SAL("_In_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwSetIRTimer(dp: Dumpulator,
                 TimerHandle: Annotated[HANDLE, SAL("_In_")],
                 DueTime: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwSetLdtEntries(dp: Dumpulator,
                    Selector0: Annotated[ULONG, SAL("_In_")],
                    Entry0Low: Annotated[ULONG, SAL("_In_")],
                    Entry0Hi: Annotated[ULONG, SAL("_In_")],
                    Selector1: Annotated[ULONG, SAL("_In_")],
                    Entry1Low: Annotated[ULONG, SAL("_In_")],
                    Entry1Hi: Annotated[ULONG, SAL("_In_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwSetLowEventPair(dp: Dumpulator,
                      EventPairHandle: Annotated[HANDLE, SAL("_In_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwSetLowWaitHighEventPair(dp: Dumpulator,
                              EventPairHandle: Annotated[HANDLE, SAL("_In_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwSetQuotaInformationFile(dp: Dumpulator,
                              FileHandle: Annotated[HANDLE, SAL("_In_")],
                              IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                              Buffer: Annotated[PVOID, SAL("_In_reads_bytes_(Length)")],
                              Length: Annotated[ULONG, SAL("_In_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwSetSecurityObject(dp: Dumpulator,
                        Handle: Annotated[HANDLE, SAL("_In_")],
                        SecurityInformation: Annotated[SECURITY_INFORMATION, SAL("_In_")],
                        SecurityDescriptor: Annotated[P[SECURITY_DESCRIPTOR], SAL("_In_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwSetSystemEnvironmentValue(dp: Dumpulator,
                                VariableName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                VariableValue: Annotated[P[UNICODE_STRING], SAL("_In_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwSetSystemEnvironmentValueEx(dp: Dumpulator,
                                  VariableName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                                  VendorGuid: Annotated[P[GUID], SAL("_In_")],
                                  Value: Annotated[PVOID, SAL("_In_reads_bytes_opt_(ValueLength)")],
                                  ValueLength: Annotated[ULONG, SAL("_In_", "0 = delete variable")],
                                  Attributes: Annotated[ULONG, SAL("_In_", "EFI_VARIABLE_*")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwSetSystemInformation(dp: Dumpulator,
                           SystemInformationClass: Annotated[SYSTEM_INFORMATION_CLASS, SAL("_In_")],
                           SystemInformation: Annotated[PVOID, SAL("_In_reads_bytes_opt_(SystemInformationLength)")],
                           SystemInformationLength: Annotated[ULONG, SAL("_In_")]
                           ):
    if SystemInformationClass == SYSTEM_INFORMATION_CLASS.SystemWin32WerStartCallout:
        return STATUS_SUCCESS
    raise NotImplementedError()

@syscall
def ZwSetSystemPowerState(dp: Dumpulator,
                          SystemAction: Annotated[P[OWER_ACTION], SAL("_In_")],
                          LightestSystemState: Annotated[SYSTEM_POWER_STATE, SAL("_In_")],
                          Flags: Annotated[ULONG, SAL("_In_", "POWER_ACTION_* flags")]
                          ):
    raise NotImplementedError()

@syscall
def ZwSetSystemTime(dp: Dumpulator,
                    SystemTime: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")],
                    PreviousTime: Annotated[P[LARGE_INTEGER], SAL("_Out_opt_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwSetThreadExecutionState(dp: Dumpulator,
                              NewFlags: Annotated[EXECUTION_STATE, SAL("_In_", "ES_* flags")],
                              PreviousFlags: Annotated[P[EXECUTION_STATE], SAL("_Out_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwSetTimer(dp: Dumpulator,
               TimerHandle: Annotated[HANDLE, SAL("_In_")],
               DueTime: Annotated[P[LARGE_INTEGER], SAL("_In_")],
               TimerApcRoutine: Annotated[P[TIMER_APC_ROUTINE], SAL("_In_opt_")],
               TimerContext: Annotated[PVOID, SAL("_In_opt_")],
               ResumeTimer: Annotated[BOOLEAN, SAL("_In_")],
               Period: Annotated[LONG, SAL("_In_opt_")],
               PreviousState: Annotated[P[BOOLEAN], SAL("_Out_opt_")]
               ):
    raise NotImplementedError()

@syscall
def ZwSetTimer2(dp: Dumpulator,
                TimerHandle: Annotated[HANDLE, SAL("_In_")],
                DueTime: Annotated[P[LARGE_INTEGER], SAL("_In_")],
                Period: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")],
                Parameters: Annotated[P[T2_SET_PARAMETERS], SAL("_In_")]
                ):
    raise NotImplementedError()

@syscall
def ZwSetTimerEx(dp: Dumpulator,
                 TimerHandle: Annotated[HANDLE, SAL("_In_")],
                 TimerSetInformationClass: Annotated[TIMER_SET_INFORMATION_CLASS, SAL("_In_")],
                 TimerSetInformation: Annotated[PVOID, SAL("_Inout_updates_bytes_opt_(TimerSetInformationLength)")],
                 TimerSetInformationLength: Annotated[ULONG, SAL("_In_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwSetTimerResolution(dp: Dumpulator,
                         DesiredTime: Annotated[ULONG, SAL("_In_")],
                         SetResolution: Annotated[BOOLEAN, SAL("_In_")],
                         ActualTime: Annotated[P[ULONG], SAL("_Out_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwSetUuidSeed(dp: Dumpulator,
                  Seed: Annotated[P[CHAR], SAL("_In_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwSetValueKey(dp: Dumpulator,
                  KeyHandle: Annotated[HANDLE, SAL("_In_")],
                  ValueName: Annotated[P[UNICODE_STRING], SAL("_In_")],
                  TitleIndex: Annotated[ULONG, SAL("_In_opt_")],
                  Type: Annotated[ULONG, SAL("_In_")],
                  Data: Annotated[PVOID, SAL("_In_reads_bytes_opt_(DataSize)")],
                  DataSize: Annotated[ULONG, SAL("_In_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwSetVolumeInformationFile(dp: Dumpulator,
                               FileHandle: Annotated[HANDLE, SAL("_In_")],
                               IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                               FsInformation: Annotated[PVOID, SAL("_In_reads_bytes_(Length)")],
                               Length: Annotated[ULONG, SAL("_In_")],
                               FsInformationClass: Annotated[FSINFOCLASS, SAL("_In_")]
                               ):
    raise NotImplementedError()

@syscall
def ZwSetWnfProcessNotificationEvent(dp: Dumpulator,
                                     NotificationEvent: Annotated[HANDLE, SAL("_In_")]
                                     ):
    raise NotImplementedError()

@syscall
def ZwShutdownSystem(dp: Dumpulator,
                     Action: Annotated[SHUTDOWN_ACTION, SAL("_In_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwShutdownWorkerFactory(dp: Dumpulator,
                            WorkerFactoryHandle: Annotated[HANDLE, SAL("_In_")],
                            PendingWorkerCount: Annotated[P[LONG], SAL("_Inout_")]
                            ):
    raise NotImplementedError()

@syscall
def ZwSignalAndWaitForSingleObject(dp: Dumpulator,
                                   SignalHandle: Annotated[HANDLE, SAL("_In_")],
                                   WaitHandle: Annotated[HANDLE, SAL("_In_")],
                                   Alertable: Annotated[BOOLEAN, SAL("_In_")],
                                   Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                                   ):
    raise NotImplementedError()

@syscall
def ZwSinglePhaseReject(dp: Dumpulator,
                        EnlistmentHandle: Annotated[HANDLE, SAL("_In_")],
                        TmVirtualClock: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwStartProfile(dp: Dumpulator,
                   ProfileHandle: Annotated[HANDLE, SAL("_In_")]
                   ):
    raise NotImplementedError()

@syscall
def ZwStopProfile(dp: Dumpulator,
                  ProfileHandle: Annotated[HANDLE, SAL("_In_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwSubscribeWnfStateChange(dp: Dumpulator,
                              StateName: Annotated[P[CWNF_STATE_NAME], SAL("_In_")],
                              ChangeStamp: Annotated[WNF_CHANGE_STAMP, SAL("_In_opt_")],
                              EventMask: Annotated[ULONG, SAL("_In_")],
                              SubscriptionId: Annotated[P[ULONG64], SAL("_Out_opt_")]
                              ):
    raise NotImplementedError()

@syscall
def ZwSuspendProcess(dp: Dumpulator,
                     ProcessHandle: Annotated[HANDLE, SAL("_In_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwSuspendThread(dp: Dumpulator,
                    ThreadHandle: Annotated[HANDLE, SAL("_In_")],
                    PreviousSuspendCount: Annotated[P[ULONG], SAL("_Out_opt_")]
                    ):
    raise NotImplementedError()

@syscall
def ZwSystemDebugControl(dp: Dumpulator,
                         Command: Annotated[SYSDBG_COMMAND, SAL("_In_")],
                         InputBuffer: Annotated[PVOID, SAL("_Inout_updates_bytes_opt_(InputBufferLength)")],
                         InputBufferLength: Annotated[ULONG, SAL("_In_")],
                         OutputBuffer: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(OutputBufferLength)")],
                         OutputBufferLength: Annotated[ULONG, SAL("_In_")],
                         ReturnLength: Annotated[P[ULONG], SAL("_Out_opt_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwTerminateEnclave(dp: Dumpulator,
                       BaseAddress: Annotated[PVOID, SAL("_In_")],
                       WaitForThread: Annotated[BOOLEAN, SAL("_In_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwTerminateJobObject(dp: Dumpulator,
                         JobHandle: Annotated[HANDLE, SAL("_In_")],
                         ExitStatus: Annotated[NTSTATUS, SAL("_In_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwTerminateProcess(dp: Dumpulator,
                       ProcessHandle: Annotated[HANDLE, SAL("_In_opt_")],
                       ExitStatus: Annotated[NTSTATUS, SAL("_In_")]
                       ):
    assert ProcessHandle == 0 or ProcessHandle == dp.NtCurrentProcess()
    dp.stop(ExitStatus)

    # TODO: move this to a dedicated helper method
    from .dumpulator import UnicornExceptionInfo, ExceptionType
    exception = UnicornExceptionInfo()
    exception.type = ExceptionType.Terminate
    exception.final = True
    exception.context = dp._uc.context_save()
    return exception

@syscall
def ZwTerminateThread(dp: Dumpulator,
                      ThreadHandle: Annotated[HANDLE, SAL("_In_opt_")],
                      ExitStatus: Annotated[NTSTATUS, SAL("_In_")]
                      ):
    assert ThreadHandle == dp.NtCurrentThread()
    raise NotImplementedError()

@syscall
def ZwTestAlert(dp: Dumpulator
                ):
    raise NotImplementedError()

@syscall
def ZwThawRegistry(dp: Dumpulator
                   ):
    raise NotImplementedError()

@syscall
def ZwThawTransactions(dp: Dumpulator
                       ):
    raise NotImplementedError()

@syscall
def ZwTraceControl(dp: Dumpulator,
                   TraceInformationClass: Annotated[TRACE_CONTROL_INFORMATION_CLASS, SAL("_In_")],
                   InputBuffer: Annotated[PVOID, SAL("_In_reads_bytes_opt_(InputBufferLength)")],
                   InputBufferLength: Annotated[ULONG, SAL("_In_")],
                   TraceInformation: Annotated[PVOID, SAL("_Out_writes_bytes_opt_(TraceInformationLength)")],
                   TraceInformationLength: Annotated[ULONG, SAL("_In_")],
                   ReturnLength: Annotated[P[ULONG], SAL("_Out_")]
                   ):
    raise NotImplementedError()

@syscall
def ZwTraceEvent(dp: Dumpulator,
                 TraceHandle: Annotated[HANDLE, SAL("_In_")],
                 Flags: Annotated[ULONG, SAL("_In_")],
                 FieldSize: Annotated[ULONG, SAL("_In_")],
                 Fields: Annotated[PVOID, SAL("_In_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwTranslateFilePath(dp: Dumpulator,
                        InputFilePath: Annotated[P[FILE_PATH], SAL("_In_")],
                        OutputType: Annotated[ULONG, SAL("_In_")],
                        OutputFilePath: Annotated[P[FILE_PATH], SAL("_Out_writes_bytes_opt_(*OutputFilePathLength)")],
                        OutputFilePathLength: Annotated[P[ULONG], SAL("_Inout_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwUmsThreadYield(dp: Dumpulator,
                     SchedulerParam: Annotated[PVOID, SAL("_In_")]
                     ):
    raise NotImplementedError()

@syscall
def ZwUnloadDriver(dp: Dumpulator,
                   DriverServiceName: Annotated[P[UNICODE_STRING], SAL("_In_")]
                   ):
    raise NotImplementedError()

@syscall
def ZwUnloadKey(dp: Dumpulator,
                TargetKey: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")]
                ):
    raise NotImplementedError()

@syscall
def ZwUnloadKey2(dp: Dumpulator,
                 TargetKey: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                 Flags: Annotated[ULONG, SAL("_In_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwUnloadKeyEx(dp: Dumpulator,
                  TargetKey: Annotated[P[OBJECT_ATTRIBUTES], SAL("_In_")],
                  Event: Annotated[HANDLE, SAL("_In_opt_")]
                  ):
    raise NotImplementedError()

@syscall
def ZwUnlockFile(dp: Dumpulator,
                 FileHandle: Annotated[HANDLE, SAL("_In_")],
                 IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                 ByteOffset: Annotated[P[LARGE_INTEGER], SAL("_In_")],
                 Length: Annotated[P[LARGE_INTEGER], SAL("_In_")],
                 Key: Annotated[ULONG, SAL("_In_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwUnlockVirtualMemory(dp: Dumpulator,
                          ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                          BaseAddress: Annotated[P[PVOID], SAL("_Inout_")],
                          RegionSize: Annotated[P[SIZE_T], SAL("_Inout_")],
                          MapType: Annotated[ULONG, SAL("_In_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwUnmapViewOfSection(dp: Dumpulator,
                         ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                         BaseAddress: Annotated[PVOID, SAL("_In_opt_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwUnmapViewOfSectionEx(dp: Dumpulator,
                           ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                           BaseAddress: Annotated[PVOID, SAL("_In_opt_")],
                           Flags: Annotated[ULONG, SAL("_In_")]
                           ):
    raise NotImplementedError()

@syscall
def ZwUnsubscribeWnfStateChange(dp: Dumpulator,
                                StateName: Annotated[P[CWNF_STATE_NAME], SAL("_In_")]
                                ):
    raise NotImplementedError()

@syscall
def ZwUpdateWnfStateData(dp: Dumpulator,
                         StateName: Annotated[P[CWNF_STATE_NAME], SAL("_In_")],
                         Buffer: Annotated[PVOID, SAL("_In_reads_bytes_opt_(Length)")],
                         Length: Annotated[ULONG, SAL("_In_opt_")],
                         TypeId: Annotated[P[CWNF_TYPE_ID], SAL("_In_opt_")],
                         ExplicitScope: Annotated[PVOID, SAL("_In_opt_")],
                         MatchingChangeStamp: Annotated[WNF_CHANGE_STAMP, SAL("_In_")],
                         CheckStamp: Annotated[LOGICAL, SAL("_In_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwVdmControl(dp: Dumpulator,
                 Service: Annotated[VDMSERVICECLASS, SAL("_In_")],
                 ServiceData: Annotated[PVOID, SAL("_Inout_")]
                 ):
    raise NotImplementedError()

@syscall
def ZwWaitForAlertByThreadId(dp: Dumpulator,
                             Address: Annotated[PVOID, SAL("_In_")],
                             Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                             ):
    raise NotImplementedError()

@syscall
def ZwWaitForDebugEvent(dp: Dumpulator,
                        DebugObjectHandle: Annotated[HANDLE, SAL("_In_")],
                        Alertable: Annotated[BOOLEAN, SAL("_In_")],
                        Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")],
                        WaitStateChange: Annotated[P[DBGUI_WAIT_STATE_CHANGE], SAL("_Out_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwWaitForKeyedEvent(dp: Dumpulator,
                        KeyedEventHandle: Annotated[HANDLE, SAL("_In_")],
                        KeyValue: Annotated[PVOID, SAL("_In_")],
                        Alertable: Annotated[BOOLEAN, SAL("_In_")],
                        Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwWaitForMultipleObjects(dp: Dumpulator,
                             Count: Annotated[ULONG, SAL("_In_")],
                             Handles: Annotated[P[HANDLE], SAL("_In_reads_(Count)")],
                             WaitType: Annotated[WAIT_TYPE, SAL("_In_")],
                             Alertable: Annotated[BOOLEAN, SAL("_In_")],
                             Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                             ):
    raise NotImplementedError()

@syscall
def ZwWaitForMultipleObjects32(dp: Dumpulator,
                               Count: Annotated[ULONG, SAL("_In_")],
                               Handles: Annotated[P[LONG], SAL("_In_reads_(Count)")],
                               WaitType: Annotated[WAIT_TYPE, SAL("_In_")],
                               Alertable: Annotated[BOOLEAN, SAL("_In_")],
                               Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                               ):
    raise NotImplementedError()

@syscall
def ZwWaitForSingleObject(dp: Dumpulator,
                          Handle: Annotated[HANDLE, SAL("_In_")],
                          Alertable: Annotated[BOOLEAN, SAL("_In_")],
                          Timeout: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")]
                          ):
    raise NotImplementedError()

@syscall
def ZwWaitForWorkViaWorkerFactory(dp: Dumpulator,
                                  WorkerFactoryHandle: Annotated[HANDLE, SAL("_In_")],
                                  MiniPackets: Annotated[P[FILE_IO_COMPLETION_INFORMATION], SAL("_Out_writes_to_(Count, *PacketsReturned)")],
                                  Count: Annotated[ULONG, SAL("_In_")],
                                  PacketsReturned: Annotated[P[ULONG], SAL("_Out_")],
                                  DeferredWork: Annotated[P[WORKER_FACTORY_DEFERRED_WORK], SAL("_In_")]
                                  ):
    raise NotImplementedError()

@syscall
def ZwWaitHighEventPair(dp: Dumpulator,
                        EventPairHandle: Annotated[HANDLE, SAL("_In_")]
                        ):
    raise NotImplementedError()

@syscall
def ZwWaitLowEventPair(dp: Dumpulator,
                       EventPairHandle: Annotated[HANDLE, SAL("_In_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwWorkerFactoryWorkerReady(dp: Dumpulator,
                               WorkerFactoryHandle: Annotated[HANDLE, SAL("_In_")]
                               ):
    raise NotImplementedError()

# NOTE: this is not present in phnt
@syscall
def ZwWow64IsProcessorFeaturePresent(dp: Dumpulator,
                                     ProcessorFeature: ULONG
                                     ):
    return 1

@syscall
def ZwWriteFile(dp: Dumpulator,
                FileHandle: Annotated[HANDLE, SAL("_In_")],
                Event: Annotated[HANDLE, SAL("_In_opt_")],
                ApcRoutine: Annotated[P[IO_APC_ROUTINE], SAL("_In_opt_")],
                ApcContext: Annotated[PVOID, SAL("_In_opt_")],
                IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                Buffer: Annotated[PVOID, SAL("_In_reads_bytes_(Length)")],
                Length: Annotated[ULONG, SAL("_In_")],
                ByteOffset: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")],
                Key: Annotated[P[ULONG], SAL("_In_opt_")]
                ):
    assert Event == 0
    assert ApcRoutine == 0
    assert ApcContext == 0
    assert ByteOffset == 0
    assert Key == 0
    if dp.handles.valid(FileHandle):
        assert Buffer != 0

        file = dp.handles.get(FileHandle, AbstractFileObject)
        buffer = bytes(Buffer.read(Length))

        print(f"writing {file.path}: {buffer}")
        file.write(buffer, Length)

        dp.write_ptr(IoStatusBlock.ptr, STATUS_SUCCESS)
        dp.write_ptr(IoStatusBlock.ptr + dp.ptr_size(), len(buffer))

        return STATUS_SUCCESS

    raise NotImplementedError()

@syscall
def ZwWriteFileGather(dp: Dumpulator,
                      FileHandle: Annotated[HANDLE, SAL("_In_")],
                      Event: Annotated[HANDLE, SAL("_In_opt_")],
                      ApcRoutine: Annotated[P[IO_APC_ROUTINE], SAL("_In_opt_")],
                      ApcContext: Annotated[PVOID, SAL("_In_opt_")],
                      IoStatusBlock: Annotated[P[IO_STATUS_BLOCK], SAL("_Out_")],
                      SegmentArray: Annotated[P[FILE_SEGMENT_ELEMENT], SAL("_In_")],
                      Length: Annotated[ULONG, SAL("_In_")],
                      ByteOffset: Annotated[P[LARGE_INTEGER], SAL("_In_opt_")],
                      Key: Annotated[P[ULONG], SAL("_In_opt_")]
                      ):
    raise NotImplementedError()

@syscall
def ZwWriteRequestData(dp: Dumpulator,
                       PortHandle: Annotated[HANDLE, SAL("_In_")],
                       Message: Annotated[P[PORT_MESSAGE], SAL("_In_")],
                       DataEntryIndex: Annotated[ULONG, SAL("_In_")],
                       Buffer: Annotated[PVOID, SAL("_In_reads_bytes_(BufferSize)")],
                       BufferSize: Annotated[SIZE_T, SAL("_In_")],
                       NumberOfBytesWritten: Annotated[P[SIZE_T], SAL("_Out_opt_")]
                       ):
    raise NotImplementedError()

@syscall
def ZwWriteVirtualMemory(dp: Dumpulator,
                         ProcessHandle: Annotated[HANDLE, SAL("_In_")],
                         BaseAddress: Annotated[PVOID, SAL("_In_opt_")],
                         Buffer: Annotated[PVOID, SAL("_In_reads_bytes_(BufferSize)")],
                         BufferSize: Annotated[SIZE_T, SAL("_In_")],
                         NumberOfBytesWritten: Annotated[P[SIZE_T], SAL("_Out_opt_")]
                         ):
    raise NotImplementedError()

@syscall
def ZwYieldExecution(dp: Dumpulator
                     ):
    raise NotImplementedError()


```

`src/minidump/README.md`:

```md
Patched version, see: https://github.com/skelsec/minidump/pull/28
```

`src/minidump/__amain__.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

import logging
import asyncio
from minidump.aminidumpfile import AMinidumpFile
from minidump.common_structs import hexdump
from minidump._version import __banner__

async def run():
	import argparse

	parser = argparse.ArgumentParser(description='A parser for minidumnp files')
	parser.add_argument('minidumpfile', help='path to the minidump file of lsass.exe')
	parser.add_argument('-v', '--verbose', action='count', default=0)
	parser.add_argument('--header', action='store_true', help='File header info')
	parser.add_argument('--modules', action='store_true', help='List modules')
	parser.add_argument('--threads', action='store_true', help='List threads')
	parser.add_argument('--memory', action='store_true', help='List memory')
	parser.add_argument('--sysinfo', action='store_true', help='Show sysinfo')
	parser.add_argument('--comments', action='store_true', help='Show comments')
	parser.add_argument('--exception', action='store_true', help='Show exception records')
	parser.add_argument('--handles', action='store_true', help='List handles')
	parser.add_argument('--misc', action='store_true', help='Show misc info')
	parser.add_argument('--all', action='store_true', help='Show all info')
	parser.add_argument('-r', '--read-addr', type=lambda x: int(x,0), help='Dump a memory region from the process\'s addres space')
	parser.add_argument('-s', '--read-size', type=lambda x: int(x,0), default = 0x20, help='Dump a memory region from the process\'s addres space')
	
	args = parser.parse_args()
	if args.verbose == 0:
		logging.basicConfig(level=logging.INFO)
	elif args.verbose == 1:
		logging.basicConfig(level=logging.DEBUG)
	else:
		logging.basicConfig(level=1)

	print(__banner__)
	

	mf = await AMinidumpFile.parse(args.minidumpfile)
	reader = mf.get_reader()
		
	if args.all or args.threads:
		if mf.threads is not None:
			print(str(mf.threads))
		if mf.threads_ex is not None:
			print(str(mf.threads_ex))
		if mf.thread_info is not None:
			print(str(mf.thread_info))
	if args.all or args.modules:
		if mf.modules is not None:
			print(str(mf.modules))
		if mf.unloaded_modules is not None:
			print(str(mf.unloaded_modules))
	if args.all or args.memory:
		if mf.memory_segments is not None:
			print(str(mf.memory_segments))
		if mf.memory_segments_64 is not None:
			print(str(mf.memory_segments_64))
		if mf.memory_info is not None:
			print(str(mf.memory_info))
	if args.all or args.sysinfo:
		if mf.sysinfo is not None:
			print(str(mf.sysinfo))
	if args.all or args.exception:
		if mf.exception is not None:
			print(str(mf.exception))
	if args.all or args.comments:
		if mf.comment_a is not None:
			print(str(mf.comment_a))
		if mf.comment_w is not None:
			print(str(mf.comment_w))
	if args.all or args.handles:
		if mf.handles is not None:
			print(str(mf.handles))
	if args.all or args.misc:
		if mf.misc_info is not None:
			print(str(mf.misc_info))
	if args.all or args.header:
		print(str(mf.header))
			
	if args.read_addr:
		buff_reader = reader.get_buffered_reader()
		await buff_reader.move(args.read_addr)
		data = await buff_reader.peek(args.read_size)
		print(hexdump(data, start = args.read_addr))

def main():
	asyncio.run(run())

if __name__ == '__main__':
	main()
```

`src/minidump/__init__.py`:

```py
name = "minidump"
```

`src/minidump/__main__.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

import logging
from minidump.minidumpfile import MinidumpFile
from minidump.common_structs import hexdump
from minidump.minidumpshell import MinidumpShell
from minidump._version import __banner__


def run():
	import argparse

	parser = argparse.ArgumentParser(description='A parser for minidumnp files')
	parser.add_argument('minidumpfile', help='path to the minidump file of lsass.exe')
	parser.add_argument('-v', '--verbose', action='count', default=0)
	parser.add_argument('-i', '--interactive', action='store_true', help='Interactive minidump shell')
	parser.add_argument('--header', action='store_true', help='File header info')
	parser.add_argument('--modules', action='store_true', help='List modules')
	parser.add_argument('--threads', action='store_true', help='List threads')
	parser.add_argument('--memory', action='store_true', help='List memory')
	parser.add_argument('--sysinfo', action='store_true', help='Show sysinfo')
	parser.add_argument('--comments', action='store_true', help='Show comments')
	parser.add_argument('--exception', action='store_true', help='Show exception records')
	parser.add_argument('--handles', action='store_true', help='List handles')
	parser.add_argument('--misc', action='store_true', help='Show misc info')
	parser.add_argument('--all', action='store_true', help='Show all info')
	parser.add_argument('-r', '--read-addr', type=lambda x: int(x,0), help='Dump a memory region from the process\'s addres space')
	parser.add_argument('-s', '--read-size', type=lambda x: int(x,0), default = 0x20, help='Dump a memory region from the process\'s addres space')
	
	args = parser.parse_args()
	if args.verbose == 0:
		logging.basicConfig(level=logging.INFO)
	elif args.verbose == 1:
		logging.basicConfig(level=logging.DEBUG)
	else:
		logging.basicConfig(level=1)

	print(__banner__)
	
	if args.interactive:
		shell = MinidumpShell()
		shell.do_open(args.minidumpfile)
		shell.cmdloop()

	else:
		
		mf = MinidumpFile.parse(args.minidumpfile)
		reader = mf.get_reader()
		
		if args.all or args.threads:
			if mf.threads is not None:
				print(str(mf.threads))
			if mf.threads_ex is not None:
				print(str(mf.threads_ex))
			if mf.thread_info is not None:
				print(str(mf.thread_info))
		if args.all or args.modules:
			if mf.modules is not None:
				print(str(mf.modules))
			if mf.unloaded_modules is not None:
				print(str(mf.unloaded_modules))
		if args.all or args.memory:
			if mf.memory_segments is not None:
				print(str(mf.memory_segments))
			if mf.memory_segments_64 is not None:
				print(str(mf.memory_segments_64))
			if mf.memory_info is not None:
				print(str(mf.memory_info))
		if args.all or args.sysinfo:
			if mf.sysinfo is not None:
				print(str(mf.sysinfo))
		if args.all or args.exception:
			if mf.exception is not None:
				print(str(mf.exception))
		if args.all or args.comments:
			if mf.comment_a is not None:
				print(str(mf.comment_a))
			if mf.comment_w is not None:
				print(str(mf.comment_w))
		if args.all or args.handles:
			if mf.handles is not None:
				print(str(mf.handles))
		if args.all or args.misc:
			if mf.misc_info is not None:
				print(str(mf.misc_info))
		if args.all or args.header:
			print(str(mf.header))
				
		if args.read_addr:
			buff_reader = reader.get_buffered_reader()
			buff_reader.move(args.read_addr)
			data = buff_reader.peek(args.read_size)
			print(hexdump(data, start = args.read_addr))


if __name__ == '__main__':
	run()
```

`src/minidump/_version.py`:

```py

__version__ = "0.0.21"
__banner__ = \
"""
# minidump %s 
# Author: Tamas Jos @skelsec (skelsecprojects@gmail.com)
""" % __version__
```

`src/minidump/aminidumpfile.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

import io
import sys
import enum
import struct
import logging

from minidump.header import MinidumpHeader
from minidump.aminidumpreader import AMinidumpFileReader
from minidump.streams import *
from minidump.common_structs import *
from minidump.constants import MINIDUMP_STREAM_TYPE
from minidump.directory import MINIDUMP_DIRECTORY


class AsyncFile:
	def __init__(self, filename):
		self.filename = filename
		self.fhandle = open(filename, 'rb')
	
	async def read(self, n = -1):
		return self.fhandle.read(n)

	async def seek(self, n, beg = 0):
		return self.fhandle.seek(n, beg)

	def tell(self):
		return self.fhandle.tell()

class AMinidumpFile:
	def __init__(self):
		self.filename = None
		self.file_handle = None
		self.header = None
		self.directories = []

		self.threads_ex = None
		self.threads = None
		self.modules = None
		self.memory_segments = None
		self.memory_segments_64 = None
		self.sysinfo = None
		self.comment_a = None
		self.comment_w = None
		self.exception = None
		self.handles = None
		self.unloaded_modules = None
		self.misc_info = None
		self.memory_info = None
		self.thread_info = None

	@staticmethod
	async def parse(filename):
		mf = AMinidumpFile()
		mf.filename = filename
		mf.file_handle = AsyncFile(filename)
		await mf._parse()
		return mf

	@staticmethod
	async def parse_external(file_handle, filename = ''):
		"""
		External file handle must be an object that exposes basic file IO functionality
		that you'd get by python's file buffer (read, seek, tell etc.)
		"""
		mf = AMinidumpFile()
		mf.filename = filename
		mf.file_handle = file_handle
		await mf._parse()
		return mf

	@staticmethod
	async def parse_bytes(data):
		return await AMinidumpFile.parse_buff(io.BytesIO(data))

	@staticmethod
	def parse_buff(buffer):
		mf = AMinidumpFile()
		mf.file_handle = buffer
		mf._parse()
		return mf

	def get_reader(self):
		return AMinidumpFileReader(self)

	async def _parse(self):
		await self.__parse_header()
		await self.__parse_directories()

	async def __parse_header(self):
		self.header = await MinidumpHeader.aparse(self.file_handle)
		for i in range(0, self.header.NumberOfStreams):
			await self.file_handle.seek(self.header.StreamDirectoryRva + i * 12, 0 )
			minidump_dir = await MINIDUMP_DIRECTORY.aparse(self.file_handle)
			
			if minidump_dir:
				self.directories.append(minidump_dir)
			else:
				await self.file_handle.seek(self.header.StreamDirectoryRva + i * 12, 0 )
				t = await self.file_handle.read(4)
				user_stream_type_value = int.from_bytes(t, byteorder = 'little', signed = False)
				logging.debug('Found Unknown UserStream directory Type: %x' % (user_stream_type_value))

	async def __parse_directories(self):

		for dir in self.directories:
			if dir.StreamType == MINIDUMP_STREAM_TYPE.UnusedStream:
				logging.debug('Found UnusedStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				continue # Reserved. Do not use this enumeration value.
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ReservedStream0:
				logging.debug('Found ReservedStream0 @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				continue # Reserved. Do not use this enumeration value.
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ReservedStream1:
				logging.debug('Found ReservedStream1 @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				continue # Reserved. Do not use this enumeration value.
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ThreadListStream:
				logging.debug('Found ThreadListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.threads = await MinidumpThreadList.aparse(dir, self.file_handle)
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ModuleListStream:
				logging.debug('Found ModuleListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.modules = await MinidumpModuleList.aparse(dir, self.file_handle)
				#logging.debug(str(modules_list))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.MemoryListStream:
				logging.debug('Found MemoryListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.memory_segments = await MinidumpMemoryList.aparse(dir, self.file_handle)
				#logging.debug(str(self.memory_segments))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.SystemInfoStream:
				logging.debug('Found SystemInfoStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.sysinfo = await MinidumpSystemInfo.aparse(dir, self.file_handle)
				#logging.debug(str(self.sysinfo))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ThreadExListStream:
				logging.debug('Found ThreadExListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.threads_ex = await MinidumpThreadExList.aparse(dir, self.file_handle)
				#logging.debug(str(self.threads_ex))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.Memory64ListStream:
				logging.debug('Found Memory64ListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.memory_segments_64 = await MinidumpMemory64List.aparse(dir, self.file_handle)
				#logging.debug(str(self.memory_segments_64))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.CommentStreamA:
				logging.debug('Found CommentStreamA @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.comment_a = await CommentStreamA.aparse(dir, self.file_handle)
				#logging.debug(str(self.comment_a))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.CommentStreamW:
				logging.debug('Found CommentStreamW @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.comment_w = await CommentStreamW.aparse(dir, self.file_handle)
				#logging.debug(str(self.comment_w))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ExceptionStream:
				logging.debug('Found ExceptionStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.exception = await ExceptionList.aparse(dir, self.file_handle)
				#logging.debug(str(self.comment_w))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.HandleDataStream:
				logging.debug('Found HandleDataStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.handles = await MinidumpHandleDataStream.aparse(dir, self.file_handle)
				#logging.debug(str(self.handles))
				continue

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.FunctionTableStream:
				logging.debug('Found FunctionTableStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('Parsing of this stream type is not yet implemented!')
				continue

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.UnloadedModuleListStream:
				logging.debug('Found UnloadedModuleListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.unloaded_modules = await MinidumpUnloadedModuleList.aparse(dir, self.file_handle)
				#logging.debug(str(self.unloaded_modules))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.MiscInfoStream:
				logging.debug('Found MiscInfoStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.misc_info = await MinidumpMiscInfo.aparse(dir, self.file_handle)
				#logging.debug(str(self.misc_info))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.MemoryInfoListStream:
				logging.debug('Found MemoryInfoListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.memory_info = await MinidumpMemoryInfoList.aparse(dir, self.file_handle)
				#logging.debug(str(self.memory_info))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ThreadInfoListStream:
				logging.debug('Found ThreadInfoListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.thread_info = await MinidumpThreadInfoList.aparse(dir, self.file_handle)
				logging.debug(str(self.thread_info))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.SystemMemoryInfoStream:
				logging.debug('Found SystemMemoryInfoStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('SystemMemoryInfoStream parsing is not implemented (Missing documentation)')
				continue

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.JavaScriptDataStream:
				logging.debug('Found JavaScriptDataStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('JavaScriptDataStream parsing is not implemented (Missing documentation)')

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ProcessVmCountersStream:
				logging.debug('Found ProcessVmCountersStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('ProcessVmCountersStream parsing is not implemented (Missing documentation)')

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.TokenStream:
				logging.debug('Found TokenStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('TokenStream parsing is not implemented (Missing documentation)')

			else:
				logging.debug('Found Unknown Stream! Type: %s @%x Size: %d' % (dir.StreamType.name, dir.Location.Rva, dir.Location.DataSize))

			"""
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.HandleOperationListStream:
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.LastReservedStream:
			
			"""

	def __str__(self):
		t = '== Minidump File ==\n'
		t += str(self.header)
		t += str(self.sysinfo)
		for dir in self.directories:
			t += str(dir) + '\n'
		for mod in self.modules:
			t += str(mod) + '\n'
		if self.memory_segments is not None:
			for segment in self.memory_segments:
				t+= str(segment) + '\n'

		if self.memory_segments_64 is not None:
			for segment in self.memory_segments_64:
				t+= str(segment) + '\n'

		return t

```

`src/minidump/aminidumpreader.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import struct
import ntpath
from .common_structs import *
from .streams.SystemInfoStream import PROCESSOR_ARCHITECTURE


class VirtualSegment:
	def __init__(self, start, end, start_file_address):
		self.start = start
		self.end = end
		self.start_file_address = start_file_address

		self.data = None
	
	def inrange(self, start, end):
		return self.start <= start and end<= self.end

class AMinidumpBufferedMemorySegment:
	def __init__(self, memory_segment, chunksize = 10*1024):
		self.start_address = memory_segment.start_virtual_address
		self.end_address = memory_segment.end_virtual_address
		self.total_size = memory_segment.end_virtual_address - memory_segment.start_virtual_address
		self.start_file_address = memory_segment.start_file_address
		self.chunksize = chunksize
		self.chunks = []

	def inrange(self, position):
		return self.start_address <= position < self.end_address

	def remaining_len(self, position):
		if not self.inrange(position):
			return None
		return self.end_address - position

	async def find(self, file_handle, pattern, startpos):
		data = await self.read(file_handle, 0, -1)
		return data.find(pattern, startpos)

	async def read(self, file_handle, start, end):
		if end is None:
			await file_handle.seek(self.start_file_address + start)
			return await file_handle.read(self.end_address - (self.start_file_address + start))
		
		for chunk in self.chunks:
			if chunk.inrange(start, end):
				return chunk.data[start - chunk.start: end - chunk.start]
		
		if self.total_size <= 2*self.chunksize:
			chunksize = self.total_size
			vs = VirtualSegment(0, chunksize, self.start_file_address)
			await file_handle.seek(self.start_file_address)
			vs.data = await file_handle.read(chunksize)
			self.chunks.append(vs)
			return vs.data[start - vs.start: end - vs.start]

		chunksize = max((end-start), self.chunksize)
		if start + chunksize > self.end_address:
			chunksize = self.end_address - start
		
		vs = VirtualSegment(start, start+chunksize, self.start_file_address + start)
		await file_handle.seek(vs.start_file_address)
		vs.data = await file_handle.read(chunksize)
		self.chunks.append(vs)
		
		return vs.data[start - vs.start: end - vs.start]

class AMinidumpBufferedReader:
	def __init__(self, reader, segment_chunk_size = 10*1024):
		self.reader = reader
		self.memory_segments = []
		self.segment_chunk_size = segment_chunk_size

		self.current_segment = None
		self.current_position = None

	async def _select_segment(self, requested_position):
		"""

		"""
		# check if we have semgnet for requested address in cache
		for memory_segment in self.memory_segments:
			if memory_segment.inrange(requested_position):
				self.current_segment = memory_segment
				self.current_position = requested_position
				return

		# not in cache, check if it's present in memory space. if yes then create a new buffered memeory object, and copy data
		for memory_segment in self.reader.memory_segments:
			if memory_segment.inrange(requested_position):
				newsegment = AMinidumpBufferedMemorySegment(memory_segment, chunksize=self.segment_chunk_size)
				self.memory_segments.append(newsegment)
				self.current_segment = newsegment
				self.current_position = requested_position
				return

		raise Exception('Memory address 0x%08x is not in process memory space' % requested_position)

	async def seek(self, offset, whence = 0):
		"""
		Changes the current address to an offset of offset. The whence parameter controls from which position should we count the offsets.
		0: beginning of the current memory segment
		1: from current position
		2: from the end of the current memory segment
		If you wish to move out from the segment, use the 'move' function
		"""
		if whence == 0:
			t = self.current_segment.start_address + offset
		elif whence == 1:
			t = self.current_position + offset
		elif whence == 2:
			t = self.current_segment.end_address - offset
		else:
			raise Exception('Seek function whence value must be between 0-2')

		if not self.current_segment.inrange(t):
			raise Exception('Seek would cross memory segment boundaries (use move)')

		self.current_position = t
		return

	async def move(self, address):
		"""
		Moves the buffer to a virtual address specified by address
		"""
		await self._select_segment(address)
		return

	async def align(self, alignment = None):
		"""
		Repositions the current reader to match architecture alignment
		"""
		if alignment is None:
			if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
				alignment = 8
			else:
				alignment = 4
		offset = self.current_position % alignment
		if offset == 0:
			return
		offset_to_aligned = (alignment - offset) % alignment
		await self.seek(offset_to_aligned, 1)
		return

	def tell(self):
		"""
		Returns the current virtual address
		"""
		return self.current_position

	async def peek(self, length):
		"""
		Returns up to length bytes from the current memory segment
		"""
		t = self.current_position + length
		if not self.current_segment.inrange(t):
			raise Exception('Would read over segment boundaries!')
		return await self.current_segment.read(self.reader.file_handle, self.current_position - self.current_segment.start_address , t - self.current_segment.start_address)

	async def read(self, size = -1):
		"""
		Returns data bytes of size size from the current segment. If size is -1 it returns all the remaining data bytes from memory segment
		"""
		if size < -1:
			raise Exception('You shouldnt be doing this')
		if size == -1:
			t = self.current_segment.remaining_len(self.current_position)
			if not t:
				return None

			old_new_pos = self.current_position
			self.current_position = self.current_segment.end_address
			return await self.current_segment.read(self.reader.file_handle, old_new_pos - self.current_segment.start_address, None)

		t = self.current_position + size
		if not self.current_segment.inrange(t):
			raise Exception('Would read over segment boundaries!')

		old_new_pos = self.current_position
		self.current_position = t
		return await self.current_segment.read(self.reader.file_handle, old_new_pos - self.current_segment.start_address, t - self.current_segment.start_address)

	async def read_int(self):
		"""
		Reads an integer. The size depends on the architecture.
		Reads a 4 byte small-endian singed int on 32 bit arch
		Reads an 8 byte small-endian singed int on 64 bit arch
		"""
		if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
			t = await self.read(8)
			return int.from_bytes(t, byteorder = 'little', signed = True)
		else:
			t = t = await self.read(4)
			return int.from_bytes(t, byteorder = 'little', signed = True)

	async def read_uint(self):
		"""
		Reads an integer. The size depends on the architecture.
		Reads a 4 byte small-endian unsinged int on 32 bit arch
		Reads an 8 byte small-endian unsinged int on 64 bit arch
		"""
		if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
			t = await self.read(8)
			return int.from_bytes(t, byteorder = 'little', signed = False)
		else:
			t = await self.read(4)
			return int.from_bytes(t, byteorder = 'little', signed = False)

	async def find(self, pattern):
		"""
		Searches for a pattern in the current memory segment
		"""
		pos = await self.current_segment.find(self.reader.file_handle, pattern)
		if pos == -1:
			return -1
		return pos + self.current_position

	async def find_all(self, pattern):
		"""
		Searches for all occurrences of a pattern in the current memory segment, returns all occurrences as a list
		"""
		pos = []
		last_found = -1
		while True:
			last_found = await self.current_segment.find(self.reader.file_handle, pattern, last_found + 1)
			if last_found == -1:
				break
			pos.append(last_found + self.current_segment.start_address)

		return pos

	async def find_global(self, pattern):
		"""
		Searches for the pattern in the whole process memory space and returns the first occurrence.
		This is exhaustive!
		"""
		pos_s = await self.reader.search(pattern)
		if len(pos_s) == 0:
			return -1

		return pos_s[0]

	async def find_all_global(self, pattern):
		"""
		Searches for the pattern in the whole process memory space and returns a list of addresses where the pattern begins.
		This is exhaustive!
		"""
		return await self.reader.search(pattern)

	async def get_ptr(self, pos):
		await self.move(pos)
		return await self.read_uint()
		#raw_data = self.read(pos, self.sizeof_ptr)
		#return struct.unpack(self.unpack_ptr, raw_data)[0]

	async def get_ptr_with_offset(self, pos):
		if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
			await self.move(pos)
			t = await self.read(4)
			ptr = int.from_bytes(t, byteorder = 'little', signed = True)
			return pos + 4 + ptr
		else:
			await self.move(pos)
			return await self.read_uint()

	async def find_in_module(self, module_name, pattern, find_first = False, reverse_order = False):
		t = await self.reader.search_module(module_name, pattern, find_first = find_first, reverse_order = reverse_order,chunksize = self.segment_chunk_size)
		return t




class AMinidumpFileReader:
	def __init__(self, minidumpfile):
		self.modules = minidumpfile.modules.modules
		self.sysinfo = minidumpfile.sysinfo

		if minidumpfile.memory_segments_64:
			self.memory_segments = minidumpfile.memory_segments_64.memory_segments
			self.is_fulldump = True

		else:
			self.memory_segments = minidumpfile.memory_segments.memory_segments
			self.is_fulldump = False

		self.filename = minidumpfile.filename
		self.file_handle = minidumpfile.file_handle

		#reader params
		self.sizeof_long = 4
		self.unpack_long = '<L'
		if minidumpfile.sysinfo.ProcessorArchitecture in [PROCESSOR_ARCHITECTURE.AMD64, PROCESSOR_ARCHITECTURE.AARCH64]:
			self.sizeof_ptr = 8
			self.unpack_ptr = '<Q'
		elif self.sysinfo.ProcessorArchitecture in [PROCESSOR_ARCHITECTURE.INTEL,
				PROCESSOR_ARCHITECTURE.ARM]:
			self.sizeof_ptr = 4
			self.unpack_ptr = '<L'
		else:
			raise Exception('Unknown processor architecture %s! Please fix and submit PR!' % self.sysinfo.ProcessorArchitecture)

	def get_buffered_reader(self, segment_chunk_size = 10*1024):
		return AMinidumpBufferedReader(self, segment_chunk_size = segment_chunk_size)

	def get_module_by_name(self, module_name):
		for mod in self.modules:
			if ntpath.basename(mod.name).lower().find(module_name.lower()) != -1:
				return mod
		return None

	async def search_module(self, module_name, pattern, find_first = False, reverse_order = False, chunksize = 10*1024):
		mod = self.get_module_by_name(module_name)
		if mod is None:
			raise Exception('Could not find module! %s' % module_name)
		needles = []
		for ms in self.memory_segments:
			if mod.baseaddress <= ms.start_virtual_address < mod.endaddress:
				needles += await ms.asearch(pattern, self.file_handle, find_first = find_first, chunksize = chunksize)
				if len(needles) > 0 and find_first is True:
					return needles

		return needles

	async def search(self, pattern, find_first = False, chunksize = 10*1024):
		t = []
		for ms in self.memory_segments:
			t += await ms.asearch(pattern, self.file_handle, find_first = find_first, chunksize = chunksize)

		return t

	async def read(self, virt_addr, size):
		for segment in self.memory_segments:
			if segment.inrange(virt_addr):
				return await segment.aread(virt_addr, size, self.file_handle)
		raise Exception('Address not in memory range! %s' % hex(virt_addr))


```

`src/minidump/common_structs.py`:

```py

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680383(v=vs.85).aspx	
class MINIDUMP_LOCATION_DESCRIPTOR:
	def __init__(self):
		self.DataSize = None
		self.Rva = None

	def get_size(self):
		return 8

	def to_bytes(self):
		t = self.DataSize.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Rva.to_bytes(4, byteorder = 'little', signed = False)
		return t
	
	@staticmethod
	def parse(buff):
		mld = MINIDUMP_LOCATION_DESCRIPTOR()
		mld.DataSize = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mld.Rva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		return mld

	@staticmethod
	async def aparse(buff):
		mld = MINIDUMP_LOCATION_DESCRIPTOR()
		t = await buff.read(4)
		mld.DataSize = int.from_bytes(t, byteorder = 'little', signed = False)
		t = await buff.read(4)
		mld.Rva = int.from_bytes(t, byteorder = 'little', signed = False)
		return mld
	
	def __str__(self):
		t = 'Size: %s File offset: %s' % (self.DataSize, self.Rva)
		return t
		
class MINIDUMP_LOCATION_DESCRIPTOR64:
	def __init__(self):
		self.DataSize = None
		self.Rva = None

	def get_size(self):
		return 16

	def to_bytes(self):
		t = self.DataSize.to_bytes(8, byteorder = 'little', signed = False)
		t += self.Rva.to_bytes(8, byteorder = 'little', signed = False)
		return t
	
	@staticmethod
	def parse(buff):
		mld = MINIDUMP_LOCATION_DESCRIPTOR64()
		mld.DataSize = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mld.Rva = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		return mld
	
	def __str__(self):
		t = 'Size: %s File offset: %s' % (self.DataSize, self.Rva)
		return t
		
class MINIDUMP_STRING:
	def __init__(self):
		self.Length = None
		self.Buffer = None
	
	@staticmethod
	def parse(buff):
		ms = MINIDUMP_STRING()
		ms.Length = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		ms.Buffer = buff.read(ms.Length)
		return ms

	@staticmethod
	async def aparse(buff):
		ms = MINIDUMP_STRING()
		t = await buff.read(4)
		ms.Length = int.from_bytes(t, byteorder = 'little', signed = False)
		ms.Buffer = await buff.read(ms.Length)
		return ms
		
	@staticmethod
	def get_from_rva(rva, buff):
		pos = buff.tell()
		buff.seek(rva, 0)
		ms = MINIDUMP_STRING.parse(buff)
		buff.seek(pos, 0)
		return ms.Buffer.decode('utf-16-le')
	
	@staticmethod
	async def aget_from_rva(rva, buff):
		pos = buff.tell()
		await buff.seek(rva, 0)
		ms = await MINIDUMP_STRING.aparse(buff)
		await buff.seek(pos, 0)
		return ms.Buffer.decode('utf-16-le')
		
class MinidumpMemorySegment:
	def __init__(self):
		self.start_virtual_address = None
		self.size = None
		self.end_virtual_address = None
		self.start_file_address = None
	
	@staticmethod
	def parse_mini(memory_decriptor, buff):
		"""
		memory_descriptor: MINIDUMP_MEMORY_DESCRIPTOR
		buff: file_handle
		"""
		mms = MinidumpMemorySegment()
		mms.start_virtual_address = memory_decriptor.StartOfMemoryRange
		mms.size = memory_decriptor.DataSize
		mms.start_file_address = memory_decriptor.Rva
		mms.end_virtual_address = mms.start_virtual_address + mms.size
		return mms
	
	@staticmethod
	def parse_full(memory_decriptor, rva):
		mms = MinidumpMemorySegment()
		mms.start_virtual_address = memory_decriptor.StartOfMemoryRange
		mms.size = memory_decriptor.DataSize
		mms.start_file_address = rva
		mms.end_virtual_address = mms.start_virtual_address + mms.size
		return mms		
		
	def inrange(self, virt_addr):
		if self.start_virtual_address <= virt_addr < self.end_virtual_address:
			return True
		return False
	
	def read(self, virtual_address, size, file_handler):
		if virtual_address > self.end_virtual_address or virtual_address < self.start_virtual_address:
			raise Exception('Reading from wrong segment!')
		
		if virtual_address+size > self.end_virtual_address:
			raise Exception('Read would cross boundaries!')
		
		pos = file_handler.tell()
		offset = virtual_address - self.start_virtual_address
		file_handler.seek(self.start_file_address + offset, 0)
		data = file_handler.read(size)
		file_handler.seek(pos, 0)
		return data

	async def aread(self, virtual_address, size, file_handler):
		if virtual_address > self.end_virtual_address or virtual_address < self.start_virtual_address:
			raise Exception('Reading from wrong segment!')
		
		if virtual_address+size > self.end_virtual_address:
			raise Exception('Read would cross boundaries!')
		
		pos = file_handler.tell()
		offset = virtual_address - self.start_virtual_address
		await file_handler.seek(self.start_file_address + offset, 0)
		data = await file_handler.read(size)
		await file_handler.seek(pos, 0)
		return data
		
	def search(self, pattern, file_handler, find_first = False, chunksize = 50*1024):
		if len(pattern) > self.size:
			return []
		pos = file_handler.tell()
		file_handler.seek(self.start_file_address, 0)
		fl = []
		if find_first is True:
			chunksize = min(chunksize, self.size)
			data = b''
			i = 0
			while len(data) < self.size:
				i += 1
				if chunksize > (self.size - len(data)):
					chunksize = (self.size - len(data))
				data += file_handler.read(chunksize)
				marker = data.find(pattern)
				if marker != -1:
					#print('FOUND! size: %s i: %s read: %s perc: %s' % (self.size, i, i*chunksize, 100*((i*chunksize)/self.size)))
					file_handler.seek(pos, 0)
					return [self.start_virtual_address + marker]
			
			
			#print('NOTFOUND! size: %s i: %s read: %s perc %s' % (self.size, i, len(data), 100*(len(data)/self.size) ))
			
		else:
			data = file_handler.read(self.size)
			file_handler.seek(pos, 0)
			
			offset = 0
			while len(data) > len(pattern):
				marker = data.find(pattern)
				if marker == -1:
					return fl
				fl.append(marker + offset + self.start_virtual_address)
				data = data[marker+1:]
				offset += marker + 1
				if find_first is True:
					return fl
		
		file_handler.seek(pos, 0)
		return fl

	async def asearch(self, pattern, file_handler, find_first = False, chunksize = 50*1024):
		if len(pattern) > self.size:
			return []
		pos = file_handler.tell()
		await file_handler.seek(self.start_file_address, 0)
		fl = []
		
		if find_first is True:
			chunksize = min(chunksize, self.size)
			data = b''
			i = 0
			while len(data) < self.size:
				i += 1
				if chunksize > (self.size - len(data)):
					chunksize = (self.size - len(data))
				data += await file_handler.read(chunksize)
				marker = data.find(pattern)
				if marker != -1:
					#print('FOUND! size: %s i: %s read: %s perc: %s' % (self.size, i, i*chunksize, 100*((i*chunksize)/self.size)))
					await file_handler.seek(pos, 0)
					return [self.start_virtual_address + marker]
			
			
			#print('NOTFOUND! size: %s i: %s read: %s perc %s' % (self.size, i, len(data), 100*(len(data)/self.size) ))
		
		else:
			offset = 0
			data = await file_handler.read(self.size)
			await file_handler.seek(pos, 0)
			while len(data) > len(pattern):
				marker = data.find(pattern)
				if marker == -1:
					return fl
				fl.append(marker + offset + self.start_virtual_address)
				data = data[marker+1:]
				offset += marker + 1
				if find_first is True:
					return fl
		
		await file_handler.seek(pos, 0)
		return fl
	
	
	@staticmethod
	def get_header():
		t = [
			'VA Start',
			'RVA',
			'Size',
		]
		return t
	
	def to_row(self):
		t = [
			hex(self.start_virtual_address),
			hex(self.start_file_address),
			hex(self.size)
		]
		return t
		
	def __str__(self):
		t = 'VA Start: %s, RVA: %s, Size: %s' % (hex(self.start_virtual_address), hex(self.start_file_address), hex(self.size))
		return t
		
		

def hexdump( src, length=16, sep='.', start = 0):
	'''
	@brief Return {src} in hex dump.
	@param[in] length	{Int} Nb Bytes by row.
	@param[in] sep		{Char} For the text part, {sep} will be used for non ASCII char.
	@return {Str} The hexdump

	@note Full support for python2 and python3 !
	'''
	result = [];

	# Python3 support
	try:
		xrange(0,1);
	except NameError:
		xrange = range;

	for i in xrange(0, len(src), length):
		subSrc = src[i:i+length];
		hexa = '';
		isMiddle = False;
		for h in xrange(0,len(subSrc)):
			if h == length/2:
				hexa += ' ';
			h = subSrc[h];
			if not isinstance(h, int):
				h = ord(h);
			h = hex(h).replace('0x','');
			if len(h) == 1:
				h = '0'+h;
			hexa += h+' ';
		hexa = hexa.strip(' ');
		text = '';
		for c in subSrc:
			if not isinstance(c, int):
				c = ord(c);
			if 0x20 <= c < 0x7F:
				text += chr(c);
			else:
				text += sep;
		if start == 0:
			result.append(('%08x:  %-'+str(length*(2+1)+1)+'s  |%s|') % (i, hexa, text));
		else:
			result.append(('%08x(+%04x):  %-'+str(length*(2+1)+1)+'s  |%s|') % (start+i, i, hexa, text));
	return '\n'.join(result);
	
def construct_table(lines, separate_head=True):
	"""Prints a formatted table given a 2 dimensional array"""
	#Count the column width
	widths = []
	for line in lines:
			for i,size in enumerate([len(x) for x in line]):
					while i >= len(widths):
							widths.append(0)
					if size > widths[i]:
							widths[i] = size
       
	#Generate the format string to pad the columns
	print_string = ""
	for i,width in enumerate(widths):
			print_string += "{" + str(i) + ":" + str(width) + "} | "
	if (len(print_string) == 0):
			return
	print_string = print_string[:-3]
       
	#Print the actual data
	t = ''
	for i,line in enumerate(lines):
			t += print_string.format(*line) + '\n'
			if (i == 0 and separate_head):
					t += "-"*(sum(widths)+3*(len(widths)-1)) + '\n'
					
	return t

```

`src/minidump/constants.py`:

```py
import enum

class MINIDUMP_STREAM_TYPE(enum.Enum):
	UnusedStream			   	= 0
	ReservedStream0				= 1
	ReservedStream1				= 2
	ThreadListStream		   	= 3
	ModuleListStream		   	= 4
	MemoryListStream		   	= 5
	ExceptionStream				= 6
	SystemInfoStream		   	= 7
	ThreadExListStream		 	= 8
	Memory64ListStream		 	= 9
	CommentStreamA			 	= 10
	CommentStreamW			 	= 11
	HandleDataStream		   	= 12
	FunctionTableStream			= 13
	UnloadedModuleListStream   	= 14
	MiscInfoStream			 	= 15
	MemoryInfoListStream	   	= 16
	ThreadInfoListStream	   	= 17
	HandleOperationListStream  	= 18
	TokenStream 				= 19
	JavaScriptDataStream 		= 20
	SystemMemoryInfoStream 		= 21
	ProcessVmCountersStream 	= 22
	ThreadNamesStream 			= 24
	ceStreamNull 				= 25
	ceStreamSystemInfo 			= 26
	ceStreamException 			= 27
	ceStreamModuleList 			= 28
	ceStreamProcessList 		= 29
	ceStreamThreadList 			= 30
	ceStreamThreadContextList 	= 31
	ceStreamThreadCallStackList = 32
	ceStreamMemoryVirtualList 	= 33
	ceStreamMemoryPhysicalList 	= 34
	ceStreamBucketParameters 	= 35
	ceStreamProcessModuleMap 	= 36
	ceStreamDiagnosisList 		= 37
	LastReservedStream		 	= 0xffff

class MINIDUMP_TYPE(enum.IntFlag):
	MiniDumpNormal                         = 0x00000000
	MiniDumpWithDataSegs                   = 0x00000001
	MiniDumpWithFullMemory                 = 0x00000002
	MiniDumpWithHandleData                 = 0x00000004
	MiniDumpFilterMemory                   = 0x00000008
	MiniDumpScanMemory                     = 0x00000010
	MiniDumpWithUnloadedModules            = 0x00000020
	MiniDumpWithIndirectlyReferencedMemory = 0x00000040
	MiniDumpFilterModulePaths              = 0x00000080
	MiniDumpWithProcessThreadData          = 0x00000100
	MiniDumpWithPrivateReadWriteMemory     = 0x00000200
	MiniDumpWithoutOptionalData            = 0x00000400
	MiniDumpWithFullMemoryInfo             = 0x00000800
	MiniDumpWithThreadInfo                 = 0x00001000
	MiniDumpWithCodeSegs                   = 0x00002000
	MiniDumpWithoutAuxiliaryState          = 0x00004000
	MiniDumpWithFullAuxiliaryState         = 0x00008000
	MiniDumpWithPrivateWriteCopyMemory     = 0x00010000
	MiniDumpIgnoreInaccessibleMemory       = 0x00020000
	MiniDumpWithTokenInformation           = 0x00040000
	MiniDumpWithModuleHeaders              = 0x00080000
	MiniDumpFilterTriage                   = 0x00100000
	MiniDumpValidTypeFlags                 = 0x001fffff
```

`src/minidump/directory.py`:

```py

from minidump.constants import MINIDUMP_STREAM_TYPE
from minidump.common_structs import MINIDUMP_LOCATION_DESCRIPTOR

class MINIDUMP_DIRECTORY:
	def __init__(self):
		self.StreamType = None
		self.Location = None

	def to_bytes(self):
		t = self.StreamType.value.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Location.to_bytes()
		return t

	@staticmethod
	def get_stream_type_value(buff, peek=False):
		return int.from_bytes(buff.read(4), byteorder = 'little', signed = False)

	@staticmethod
	def parse(buff):

		raw_stream_type_value = MINIDUMP_DIRECTORY.get_stream_type_value(buff)

		# StreamType value that are over 0xffff are considered MINIDUMP_USER_STREAM streams
		# and their format depends on the client used to create the minidump.
		# As per the documentation, this stream should be ignored : https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidumminidump_dirp_stream_type#remarks
		is_user_stream = raw_stream_type_value > MINIDUMP_STREAM_TYPE.LastReservedStream.value
		is_stream_supported = raw_stream_type_value in MINIDUMP_STREAM_TYPE._value2member_map_
		if is_user_stream and not is_stream_supported:
			return None

		md = MINIDUMP_DIRECTORY()
		md.StreamType = MINIDUMP_STREAM_TYPE(raw_stream_type_value)
		md.Location = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		return md

	@staticmethod
	async def aparse(buff):
		
		t = await buff.read(4)
		raw_stream_type_value = int.from_bytes(t, byteorder = 'little', signed = False)

		# StreamType value that are over 0xffff are considered MINIDUMP_USER_STREAM streams
		# and their format depends on the client used to create the minidump.
		# As per the documentation, this stream should be ignored : https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidumminidump_dirp_stream_type#remarks
		is_user_stream = raw_stream_type_value > MINIDUMP_STREAM_TYPE.LastReservedStream.value
		is_stream_supported = raw_stream_type_value in MINIDUMP_STREAM_TYPE._value2member_map_
		if is_user_stream and not is_stream_supported:
			return None

		md = MINIDUMP_DIRECTORY()
		md.StreamType = MINIDUMP_STREAM_TYPE(raw_stream_type_value)
		md.Location = await MINIDUMP_LOCATION_DESCRIPTOR.aparse(buff)
		return md

	def __str__(self):
		t = 'StreamType: %s %s' % (self.StreamType, self.Location)
		return t
```

`src/minidump/exceptions.py`:

```py

class MinidumpException(Exception):
	"""Generic Exception from minidump module"""
	pass
		
class MinidumpHeaderSignatureMismatchException(Exception):
	"""Header signature was not correct"""
	pass
	
class MinidumpHeaderFlagsException(Exception):
	"""Header flags value was not correct"""
	pass
```

`src/minidump/header.py`:

```py
from minidump.constants import MINIDUMP_TYPE
from minidump.exceptions import MinidumpHeaderFlagsException, MinidumpHeaderSignatureMismatchException
import io

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680378(v=vs.85).aspx
class MinidumpHeader:
	def __init__(self):
		self.Signature = 'PMDM'
		self.Version = None
		self.ImplementationVersion = None
		self.NumberOfStreams = None
		self.StreamDirectoryRva = None
		self.CheckSum = 0
		self.Reserved = 0
		self.TimeDateStamp = 0
		self.Flags = None

	def to_bytes(self):
		t = self.Signature.encode('ascii')
		t += self.Version.to_bytes(2, byteorder = 'little', signed = False)
		t += self.ImplementationVersion.to_bytes(2, byteorder = 'little', signed = False)
		t += self.NumberOfStreams.to_bytes(4, byteorder = 'little', signed = False)
		t += self.StreamDirectoryRva.to_bytes(4, byteorder = 'little', signed = False)
		t += self.CheckSum.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Reserved.to_bytes(4, byteorder = 'little', signed = False)
		t += self.TimeDateStamp.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Flags.value.to_bytes(4, byteorder = 'little', signed = False)

		return t

	@staticmethod
	def parse(buff):
		mh = MinidumpHeader()
		mh.Signature = buff.read(4).decode()[::-1]
		if mh.Signature != 'PMDM':
			raise MinidumpHeaderSignatureMismatchException(mh.Signature)
		mh.Version = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
		mh.ImplementationVersion = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
		mh.NumberOfStreams = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mh.StreamDirectoryRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mh.CheckSum = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mh.Reserved = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mh.TimeDateStamp = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		try:
			mh.Flags = MINIDUMP_TYPE(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		except Exception as e:
			raise MinidumpHeaderFlagsException('Could not parse header flags!')

		return mh

	@staticmethod
	async def aparse(abuff):
		adata = await abuff.read(32)
		buff = io.BytesIO(adata)
		return MinidumpHeader.parse(buff)

	def __str__(self):
		t = '== MinidumpHeader ==\n'
		t+= 'Signature: %s\n' % self.Signature
		t+= 'Version: %s\n' % self.Version
		t+= 'ImplementationVersion: %s\n' % self.ImplementationVersion
		t+= 'NumberOfStreams: %s\n' % self.NumberOfStreams
		t+= 'StreamDirectoryRva: %s\n' % self.StreamDirectoryRva
		t+= 'CheckSum: %s\n' % self.CheckSum
		t+= 'Reserved: %s\n' % self.Reserved
		t+= 'TimeDateStamp: %s\n' % self.TimeDateStamp
		t+= 'Flags: %s\n' % self.Flags
		return t
```

`src/minidump/minidumpfile.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

import io
import sys
import enum
import struct
import logging

from minidump.header import MinidumpHeader
from minidump.minidumpreader import MinidumpFileReader
from minidump.streams import *
from minidump.common_structs import *
from minidump.constants import MINIDUMP_STREAM_TYPE
from minidump.directory import MINIDUMP_DIRECTORY
from minidump.streams.SystemInfoStream import PROCESSOR_ARCHITECTURE


class MinidumpFile:
	def __init__(self):
		self.filename = None
		self.file_handle = None
		self.header = None
		self.directories = []

		self.threads_ex = None
		self.threads = None
		self.modules = None
		self.memory_segments = None
		self.memory_segments_64 = None
		self.sysinfo = None
		self.comment_a = None
		self.comment_w = None
		self.exception = None
		self.handles = None
		self.unloaded_modules = None
		self.misc_info = None
		self.memory_info = None
		self.thread_info = None

	@staticmethod
	def parse(filename):
		mf = MinidumpFile()
		mf.filename = filename
		mf.file_handle = open(filename, 'rb')
		mf._parse()
		return mf

	@staticmethod
	def parse_external(file_handle, filename = ''):
		"""
		External file handle must be an object that exposes basic file IO functionality
		that you'd get by python's file buffer (read, seek, tell etc.)
		"""
		mf = MinidumpFile()
		mf.filename = filename
		mf.file_handle = file_handle
		mf._parse()
		return mf

	@staticmethod
	def parse_bytes(data):
		return MinidumpFile.parse_buff(io.BytesIO(data))

	@staticmethod
	def parse_buff(buffer):
		mf = MinidumpFile()
		mf.file_handle = buffer
		mf._parse()
		return mf

	def get_reader(self):
		return MinidumpFileReader(self)

	def _parse(self):
		self.__parse_header()
		self.__parse_directories()

	def __parse_header(self):
		self.header = MinidumpHeader.parse(self.file_handle)
		for i in range(0, self.header.NumberOfStreams):
			self.file_handle.seek(self.header.StreamDirectoryRva + i * 12, 0 )
			minidump_dir = MINIDUMP_DIRECTORY.parse(self.file_handle)
			
			if minidump_dir:
				self.directories.append(minidump_dir)
			else:
				self.file_handle.seek(self.header.StreamDirectoryRva + i * 12, 0 )
				user_stream_type_value = MINIDUMP_DIRECTORY.get_stream_type_value(self.file_handle)
				logging.debug('Found Unknown UserStream directory Type: %x' % (user_stream_type_value))

	def __parse_directories(self):

		for dir in self.directories:
			if dir.StreamType == MINIDUMP_STREAM_TYPE.UnusedStream:
				logging.debug('Found UnusedStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				continue # Reserved. Do not use this enumeration value.
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ReservedStream0:
				logging.debug('Found ReservedStream0 @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				continue # Reserved. Do not use this enumeration value.
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ReservedStream1:
				logging.debug('Found ReservedStream1 @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				continue # Reserved. Do not use this enumeration value.
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ThreadListStream:
				logging.debug('Found ThreadListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.threads = MinidumpThreadList.parse(dir, self.file_handle)
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ModuleListStream:
				logging.debug('Found ModuleListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.modules = MinidumpModuleList.parse(dir, self.file_handle)
				#logging.debug(str(modules_list))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.MemoryListStream:
				logging.debug('Found MemoryListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.memory_segments = MinidumpMemoryList.parse(dir, self.file_handle)
				#logging.debug(str(self.memory_segments))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.SystemInfoStream:
				logging.debug('Found SystemInfoStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.sysinfo = MinidumpSystemInfo.parse(dir, self.file_handle)
				#logging.debug(str(self.sysinfo))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ThreadExListStream:
				logging.debug('Found ThreadExListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.threads_ex = MinidumpThreadExList.parse(dir, self.file_handle)
				#logging.debug(str(self.threads_ex))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.Memory64ListStream:
				logging.debug('Found Memory64ListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.memory_segments_64 = MinidumpMemory64List.parse(dir, self.file_handle)
				#logging.debug(str(self.memory_segments_64))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.CommentStreamA:
				logging.debug('Found CommentStreamA @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.comment_a = CommentStreamA.parse(dir, self.file_handle)
				#logging.debug(str(self.comment_a))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.CommentStreamW:
				logging.debug('Found CommentStreamW @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.comment_w = CommentStreamW.parse(dir, self.file_handle)
				#logging.debug(str(self.comment_w))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ExceptionStream:
				logging.debug('Found ExceptionStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.exception = ExceptionList.parse(dir, self.file_handle)
				#logging.debug(str(self.comment_w))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.HandleDataStream:
				logging.debug('Found HandleDataStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.handles = MinidumpHandleDataStream.parse(dir, self.file_handle)
				#logging.debug(str(self.handles))
				continue

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.FunctionTableStream:
				logging.debug('Found FunctionTableStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('Parsing of this stream type is not yet implemented!')
				continue

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.UnloadedModuleListStream:
				logging.debug('Found UnloadedModuleListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.unloaded_modules = MinidumpUnloadedModuleList.parse(dir, self.file_handle)
				#logging.debug(str(self.unloaded_modules))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.MiscInfoStream:
				logging.debug('Found MiscInfoStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.misc_info = MinidumpMiscInfo.parse(dir, self.file_handle)
				#logging.debug(str(self.misc_info))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.MemoryInfoListStream:
				logging.debug('Found MemoryInfoListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.memory_info = MinidumpMemoryInfoList.parse(dir, self.file_handle)
				#logging.debug(str(self.memory_info))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ThreadInfoListStream:
				logging.debug('Found ThreadInfoListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.thread_info = MinidumpThreadInfoList.parse(dir, self.file_handle)
				logging.debug(str(self.thread_info))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.SystemMemoryInfoStream:
				logging.debug('Found SystemMemoryInfoStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('SystemMemoryInfoStream parsing is not implemented (Missing documentation)')
				continue

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.JavaScriptDataStream:
				logging.debug('Found JavaScriptDataStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('JavaScriptDataStream parsing is not implemented (Missing documentation)')

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ProcessVmCountersStream:
				logging.debug('Found ProcessVmCountersStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('ProcessVmCountersStream parsing is not implemented (Missing documentation)')

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.TokenStream:
				logging.debug('Found TokenStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('TokenStream parsing is not implemented (Missing documentation)')

			else:
				logging.debug('Found Unknown Stream! Type: %s @%x Size: %d' % (dir.StreamType.name, dir.Location.Rva, dir.Location.DataSize))

			"""
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.HandleOperationListStream:
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.LastReservedStream:
			
			"""
		try:
			self.__parse_thread_context()
		except Exception as e:
			logging.exception('Thread context parsing error!')

	def __parse_thread_context(self):
		if not self.sysinfo or not self.threads:
			return
		for thread in self.threads.threads:
			rva = thread.ThreadContext.Rva
			self.file_handle.seek(rva)
			if self.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
				thread.ContextObject = CONTEXT.parse(self.file_handle)
			elif self.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.INTEL:
				thread.ContextObject = WOW64_CONTEXT.parse(self.file_handle)
			

	def __str__(self):
		t = '== Minidump File ==\n'
		t += str(self.header)
		t += str(self.sysinfo)
		for dir in self.directories:
			t += str(dir) + '\n'
		for mod in self.modules:
			t += str(mod) + '\n'
		if self.memory_segments is not None:
			for segment in self.memory_segments:
				t+= str(segment) + '\n'

		if self.memory_segments_64 is not None:
			for segment in self.memory_segments_64:
				t+= str(segment) + '\n'

		return t

```

`src/minidump/minidumpreader.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import struct
import ntpath
from .common_structs import *
from .streams.SystemInfoStream import PROCESSOR_ARCHITECTURE

class VirtualSegment:
	def __init__(self, start, end, start_file_address):
		self.start = start
		self.end = end
		self.start_file_address = start_file_address

		

		self.data = None
	
	def inrange(self, start, end):
		return self.start <= start and end<= self.end

class MinidumpBufferedMemorySegment:
	def __init__(self, memory_segment, file_handle, chunksize = 10*1024):
		self.start_address = memory_segment.start_virtual_address
		self.end_address = memory_segment.end_virtual_address
		self.total_size = memory_segment.end_virtual_address - memory_segment.start_virtual_address
		self.start_file_address = memory_segment.start_file_address
		self.chunksize = chunksize
		self.chunks = []

	def inrange(self, position):
		return self.start_address <= position < self.end_address

	def remaining_len(self, position):
		if not self.inrange(position):
			return None
		return self.end_address - position

	def find(self, file_handle, pattern, startpos):
		data = self.read(file_handle, 0, -1)
		return data.find(pattern, startpos)

	def read(self, file_handle, start, end):
		if end is None:
			file_handle.seek(self.start_file_address + start)
			return file_handle.read(self.end_address - (self.start_file_address + start))
		
		for chunk in self.chunks:
			if chunk.inrange(start, end):
				return chunk.data[start - chunk.start: end - chunk.start]
		
		if self.total_size <= 2*self.chunksize:
			chunksize = self.total_size
			vs = VirtualSegment(0, chunksize, self.start_file_address)
			file_handle.seek(self.start_file_address)
			vs.data = file_handle.read(chunksize)
			self.chunks.append(vs)
			return vs.data[start - vs.start: end - vs.start]

		chunksize = max((end-start), self.chunksize)
		if start + chunksize > self.end_address:
			chunksize = self.end_address - start
		
		vs = VirtualSegment(start, start+chunksize, self.start_file_address + start)
		file_handle.seek(vs.start_file_address)
		vs.data = file_handle.read(chunksize)
		self.chunks.append(vs)
		
		return vs.data[start - vs.start: end - vs.start]



class MinidumpBufferedReader:
	def __init__(self, reader, segment_chunk_size = 10*1024):
		self.reader = reader
		self.segment_chunk_size = segment_chunk_size
		self.memory_segments = []

		self.current_segment = None
		self.current_position = None

	def _select_segment(self, requested_position):
		"""

		"""
		# check if we have semgnet for requested address in cache
		for memory_segment in self.memory_segments:
			if memory_segment.inrange(requested_position):
				self.current_segment = memory_segment
				self.current_position = requested_position
				return

		# not in cache, check if it's present in memory space. if yes then create a new buffered memeory object, and copy data
		for memory_segment in self.reader.memory_segments:
			if memory_segment.inrange(requested_position):
				newsegment = MinidumpBufferedMemorySegment(memory_segment, self.reader.file_handle, chunksize=self.segment_chunk_size)
				self.memory_segments.append(newsegment)
				self.current_segment = newsegment
				self.current_position = requested_position
				return

		raise Exception('Memory address 0x%08x is not in process memory space' % requested_position)

	def get_reader(self):
		return self.reader

	def seek(self, offset, whence = 0):
		"""
		Changes the current address to an offset of offset. The whence parameter controls from which position should we count the offsets.
		0: beginning of the current memory segment
		1: from current position
		2: from the end of the current memory segment
		If you wish to move out from the segment, use the 'move' function
		"""
		if whence == 0:
			t = self.current_segment.start_address + offset
		elif whence == 1:
			t = self.current_position + offset
		elif whence == 2:
			t = self.current_segment.end_address - offset
		else:
			raise Exception('Seek function whence value must be between 0-2')

		if not self.current_segment.inrange(t):
			raise Exception('Seek would cross memory segment boundaries (use move)')

		self.current_position = t
		return

	def move(self, address):
		"""
		Moves the buffer to a virtual address specified by address
		"""
		self._select_segment(address)
		return

	def align(self, alignment = None):
		"""
		Repositions the current reader to match architecture alignment
		"""
		if alignment is None:
			if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
				alignment = 8
			else:
				alignment = 4
		offset = self.current_position % alignment
		if offset == 0:
			return
		offset_to_aligned = (alignment - offset) % alignment
		self.seek(offset_to_aligned, 1)
		return

	def tell(self):
		"""
		Returns the current virtual address
		"""
		return self.current_position

	def peek(self, length):
		"""
		Returns up to length bytes from the current memory segment
		"""
		t = self.current_position + length
		if not self.current_segment.inrange(t):
			raise Exception('Would read over segment boundaries!')
		return self.current_segment.read(self.reader.file_handle, self.current_position - self.current_segment.start_address , t - self.current_segment.start_address)

	def read(self, size = -1):
		"""
		Returns data bytes of size size from the current segment. If size is -1 it returns all the remaining data bytes from memory segment
		"""
		if size < -1:
			raise Exception('You shouldnt be doing this')
		if size == -1:
			t = self.current_segment.remaining_len(self.current_position)
			if not t:
				return None

			old_new_pos = self.current_position
			self.current_position = self.current_segment.end_address
			return self.current_segment.read(self.reader.file_handle, old_new_pos - self.current_segment.start_address, None)

		t = self.current_position + size
		if not self.current_segment.inrange(t - 1):
			raise Exception('Would read over segment boundaries!')

		old_new_pos = self.current_position
		self.current_position = t
		return self.current_segment.read(self.reader.file_handle, old_new_pos - self.current_segment.start_address, t - self.current_segment.start_address)

	def read_int(self):
		"""
		Reads an integer. The size depends on the architecture.
		Reads a 4 byte small-endian singed int on 32 bit arch
		Reads an 8 byte small-endian singed int on 64 bit arch
		"""
		if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
			return int.from_bytes(self.read(8), byteorder = 'little', signed = True)
		else:
			return int.from_bytes(self.read(4), byteorder = 'little', signed = True)

	def read_uint(self):
		"""
		Reads an integer. The size depends on the architecture.
		Reads a 4 byte small-endian unsinged int on 32 bit arch
		Reads an 8 byte small-endian unsinged int on 64 bit arch
		"""
		if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
			return int.from_bytes(self.read(8), byteorder = 'little', signed = False)
		else:
			return int.from_bytes(self.read(4), byteorder = 'little', signed = False)

	def find(self, pattern):
		"""
		Searches for a pattern in the current memory segment
		"""
		pos = self.current_segment.find(self.reader.file_handle, pattern)
		if pos == -1:
			return -1
		return pos + self.current_position

	def find_all(self, pattern):
		"""
		Searches for all occurrences of a pattern in the current memory segment, returns all occurrences as a list
		"""
		pos = []
		last_found = -1
		while True:
			last_found = self.current_segment.find(self.reader.file_handle, pattern, last_found + 1)
			if last_found == -1:
				break
			pos.append(last_found + self.current_segment.start_address)

		return pos

	def find_global(self, pattern):
		"""
		Searches for the pattern in the whole process memory space and returns the first occurrence.
		This is exhaustive!
		"""
		pos_s = self.reader.search(pattern)
		if len(pos_s) == 0:
			return -1

		return pos_s[0]

	def find_all_global(self, pattern):
		"""
		Searches for the pattern in the whole process memory space and returns a list of addresses where the pattern begins.
		This is exhaustive!
		"""
		return self.reader.search(pattern)

	def get_ptr(self, pos):
		self.move(pos)
		return self.read_uint()
		#raw_data = self.read(pos, self.sizeof_ptr)
		#return struct.unpack(self.unpack_ptr, raw_data)[0]

	def get_ptr_with_offset(self, pos):
		if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
			self.move(pos)
			ptr = int.from_bytes(self.read(4), byteorder = 'little', signed = True)
			return pos + 4 + ptr
		else:
			self.move(pos)
			return self.read_uint()

	def find_in_module(self, module_name, pattern, find_first = False, reverse_order = False):
		t = self.reader.search_module(module_name, pattern, find_first = find_first, reverse_order = reverse_order, chunksize = self.segment_chunk_size)
		return t




class MinidumpFileReader:
	def __init__(self, minidumpfile):
		self.modules = minidumpfile.modules.modules
		self.unloaded_modules = []
		if minidumpfile.unloaded_modules is not None:
			self.unloaded_modules = minidumpfile.unloaded_modules.modules

		self.sysinfo = minidumpfile.sysinfo

		if minidumpfile.memory_segments_64:
			self.memory_segments = minidumpfile.memory_segments_64.memory_segments
			self.is_fulldump = True

		else:
			self.memory_segments = minidumpfile.memory_segments.memory_segments
			self.is_fulldump = False

		self.filename = minidumpfile.filename
		self.file_handle = minidumpfile.file_handle

		#reader params
		self.sizeof_long = 4
		self.unpack_long = '<L'
		if minidumpfile.sysinfo.ProcessorArchitecture in [PROCESSOR_ARCHITECTURE.AMD64, PROCESSOR_ARCHITECTURE.AARCH64]:
			self.sizeof_ptr = 8
			self.unpack_ptr = '<Q'
		elif self.sysinfo.ProcessorArchitecture in [PROCESSOR_ARCHITECTURE.INTEL,
				PROCESSOR_ARCHITECTURE.ARM]:
			self.sizeof_ptr = 4
			self.unpack_ptr = '<L'
		else:
			raise Exception('Unknown processor architecture %s! Please fix and submit PR!' % self.sysinfo.ProcessorArchitecture)

	def get_handler(self):
		return self.file_handle

	def get_memory(self):
		return self.memory_segments

	def get_buffered_reader(self, segment_chunk_size = 10*1024):
		return MinidumpBufferedReader(self, segment_chunk_size = segment_chunk_size)

	def get_module_by_name(self, module_name):
		for mod in self.modules:
			if ntpath.basename(mod.name).lower().find(module_name.lower()) != -1:
				return mod
		return None

	def get_unloaded_by_name(self, module_name):
		for mod in self.unloaded_modules:
			if ntpath.basename(mod.name).find(module_name) != -1:
				return mod
		return None

	def search_module(self, module_name, pattern, find_first = False, reverse_order = False, chunksize = 10*1024):
		mod = self.get_module_by_name(module_name)
		if mod is None:
			mod = self.get_unloaded_by_name(module_name)
			if mod is None:
				raise Exception('Could not find module! %s' % module_name)
		
		needles = []
		for ms in self.memory_segments:
			if mod.baseaddress <= ms.start_virtual_address < mod.endaddress:
				needles+= ms.search(pattern, self.file_handle, find_first = find_first, chunksize = chunksize)
				if len(needles) > 0 and find_first is True:
					return needles


		return needles

	def search(self, pattern, find_first = False, chunksize = 10*1024):
		t = []
		for ms in self.memory_segments:
			t+= ms.search(pattern, self.file_handle, find_first = find_first, chunksize = chunksize)

		return t

	def read(self, virt_addr, size):
		for segment in self.memory_segments:
			if segment.inrange(virt_addr):
				return segment.read(virt_addr, size, self.file_handle)
		raise Exception('Address not in memory range! %s' % hex(virt_addr))


```

`src/minidump/minidumpshell.py`:

```py

import cmd
from minidump.minidumpfile import *
from minidump.common_structs import hexdump

def args2int(x):
	if isinstance(x, int):
		return x
	elif isinstance(x, str):
		if x[:2].lower() == '0x':
			return int(x[2:], 16)
		elif x[:2].lower() == '0b':
			return int(x[2:], 2)
		else:
			return int(x)

	else:
		raise Exception('Unknown integer format! %s' % type(x))

class MinidumpShell(cmd.Cmd):
	intro  = 'Welcome to the minidump shell.   Type help or ? to list commands.\n'
	prompt = '[minidump] '
	mini   = None
	reader = None
	hexdump_size = 16

	def do_open(self, filename):
		"""Opens minidump file"""
		self.mini = MinidumpFile.parse(filename)
		self.reader = self.mini.get_reader().get_buffered_reader()

	def do_threads(self, args):
		"""Lists all thread information (if available)"""
		if self.mini.threads is not None:
			print(str(self.mini.threads))
		if self.mini.threads_ex is not None:
			print(str(self.mini.threads_ex))
		if self.mini.thread_info is not None:
			print(str(self.mini.thread_info))

	def do_memory(self, args):
		"""Lists all memory segments"""
		if self.mini.memory_segments is not None:
			print(str(self.mini.memory_segments))
		if self.mini.memory_segments_64 is not None:
			print(str(self.mini.memory_segments_64))
		if self.mini.memory_info is not None:
			print(str(self.mini.memory_info))

	def do_modules(self, args):
		"""Lists all loaded and unloaded module information (if available)"""
		if self.mini.modules is not None:
			print(str(self.mini.modules))
		if self.mini.unloaded_modules is not None:
			print(str(self.mini.unloaded_modules))

	def do_sysinfo(self, args):
		"""Shows sysinfo (if available)"""
		if self.mini.sysinfo is not None:
			print(str(self.mini.sysinfo))

	def do_exception(self, args):
		"""Shows exception information (if available)"""
		if self.mini.exception is not None:
			print(str(self.mini.exception))

	def do_comments(self, args):
		"""Lists all comments (if any)"""
		if self.mini.comment_a is not None:
			print(str(self.mini.comment_a))
		if self.mini.comment_w is not None:
			print(str(self.mini.comment_w))

	def do_handles(self, args):
		"""Lists all handles (if available)"""
		if self.mini.handles is not None:
			print(str(self.mini.handles))

	def do_misc(self, args):
		"""Lists all miscellaneous info (if available)"""
		if self.mini.misc_info is not None:
			print(str(self.mini.misc_info))

	#### Exit aliases
	def do_quit(self, args):
		"""Quit"""
		return True
	def do_exit(self, args):
		"""Quit"""
		return self.do_quit(None)
	def do_q(self, args):
		"""Quit"""
		return self.do_quit(None)

	###### READER
	def do_printsize(self, printsize):
		"""Changes the hexdump print size to the given bytes/line size (default: 16)"""
		self.hexdump_size = args2int(printsize)

	def update_prompt(self, args):
		pos = self.reader.tell()
		current_segment_start = self.reader.current_segment.start_address
		segment_relative_position = pos - current_segment_start
		self.prompt = "[%s %s+%s] " % (hex(pos), hex(current_segment_start), hex(segment_relative_position))

	def do_tell(self, args):
		"""Shows/refreshes the current position in the process' virtual memory space"""
		x = self.reader.tell()
		if x is None:
			print('Reader not yet positioned! Issue a "move" command with the desired memory address!')
		print(hex(x))
	
	def do_move(self, position):
		"""Sets the current position in the process' virtual memory space"""
		pos = args2int(position)
		self.reader.move(pos)
		self.update_prompt(None)

	def do_read(self, count):
		"""Performs a read of 'count' bytes from the current position and updates the cursor with the bytes read"""
		count = args2int(count)
		pos_before = self.reader.tell()
		data = self.reader.read(count)
		print(hexdump( data, length=self.hexdump_size, sep='.', start = pos_before))
		self.update_prompt(None)

	def do_readi(self, args):
		"""Reads a signed integer starting the current position and updates the cursor with the bytes read. The integer size is determined automatically by the processor architecture information from the dump file"""
		data = self.reader.read_int()
		print('D: %s' % data)
		print('H: %s' % hex(data))
		self.update_prompt(None)

	def do_readui(self, args):
		"""Reads an unsigned integer starting the current position and updates the cursor with the bytes read. The integer size is determined automatically by the processor architecture information from the dump file"""
		data = self.reader.read_uint()
		print('D: %s' % data)
		print('H: %s' % hex(data))
		self.update_prompt(None)

	def do_peek(self, count):
		"""Performs a read of 'count' bytes from the current position but doesn't update the cursor."""
		count = args2int(count)
		pos_before = self.reader.tell()
		data = self.reader.peek(count)
		print(hexdump( data, length=self.hexdump_size, sep='.', start = pos_before))
		self.update_prompt(None)
	

def main():
	import argparse

	parser = argparse.ArgumentParser(description='A parser for minidumnp files')
	parser.add_argument('-f', '--minidumpfile', help='path to the minidump file of lsass.exe')	
	args = parser.parse_args()

	shell = MinidumpShell()
	if args.minidumpfile:
		shell.do_open(args.minidumpfile)
	shell.cmdloop()

if __name__ == '__main__':
	main()
```

`src/minidump/streams/CommentStreamA.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
class CommentStreamA:
	def __init__(self):
		self.data = None

	def to_bytes(self):
		return self.data.encode('ascii')
	
	@staticmethod
	def parse(dir, buff):
		csa = CommentStreamA()
		buff.seek(dir.Location.Rva)
		csa.data = buff.read(dir.Location.DataSize).decode()
		return csa

	@staticmethod
	async def aparse(dir, buff):
		csa = CommentStreamA()
		await buff.seek(dir.Location.Rva)
		csdata = await buff.read(dir.Location.DataSize)
		csa.data = csdata.decode()
		return csa
	
	def __str__(self):
		return 'CommentA: %s' % self.data
```

`src/minidump/streams/CommentStreamW.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
class CommentStreamW:
	def __init__(self):
		self.data = None

	def to_bytes(self):
		return self.data.encode('utf-16-le')
	
	@staticmethod
	def parse(dir, buff):
		csa = CommentStreamW()
		buff.seek(dir.Location.Rva)
		csa.data = buff.read(dir.Location.DataSize).decode('utf-16-le')
		return csa
	
	@staticmethod
	async def aparse(dir, buff):
		csa = CommentStreamW()
		await buff.seek(dir.Location.Rva)
		csdata = await buff.read(dir.Location.DataSize)
		csa.data = csdata.decode('utf-16-le')
		return csa
		
	def __str__(self):
		return 'CommentW: %s' % self.data
```

`src/minidump/streams/ContextStream.py`:

```py
#!/usr/bin/env python3

# https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/1507%20Threshold%201/_M128A
class M128A:
    def __init__(self):
        self.Low = 0                                        # 0x0 ULONGLONG
        self.High = 0                                       # 0x8 LONGLONG

    @classmethod
    def parse(cls, buff):
        m128a = cls()

        m128a.Low = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
        m128a.High = int.from_bytes(buff.read(8), byteorder = 'little', signed = True)

        return m128a

    @classmethod
    def parse_array(cls, buff, length):
        arr = []
        for i in range(length):
            arr.append(cls.parse(buff))
        return arr

    def __str__(self):
        s = ""
        s += "Low: %x (%d)" % (self.Low, self.Low)
        s += "High: %x (%d)\n" % (self.High, self.High)
        return s


# https://doxygen.reactos.org/df/d06/sdk_2include_2xdk_2arm_2ke_8h_source.html#l00229
class NEON128(M128A):
    # looks to be the same as M128A
    pass


# https://www.vergiliusproject.com/kernels/x64/Windows%20Vista%20%7C%202008/SP2/_XMM_SAVE_AREA32
class XMM_SAVE_AREA32:
    def __init__(self):
        self.ControlWord = 0                               # 0x0 USHORT 
        self.StatusWord = 0                                # 0x2 USHORT 
        self.TagWord = 0                                   # 0x4 UCHAR 
        self.Reserved1 = 0                                 # 0x5 UCHAR 
        self.ErrorOpcode = 0                               # 0x6 USHORT
        self.ErrorOffset = 0                               # 0x8 ULONG
        self.ErrorSelector = 0                             # 0xc USHORT 
        self.Reserved2 = 0                                 # 0xe USHORT 
        self.DataOffset = 0                                # 0x10 ULONG
        self.DataSelector = 0                              # 0x14 USHORT 
        self.Reserved3 = 0                                 # 0x16 USHORT 
        self.MxCsr = 0                                     # 0x18 ULONG
        self.MxCsr_Mask = 0                                # 0x1c ULONG
        self.FloatRegisters = []                           # 0x20 struct M128A[8]
        self.XmmRegisters = []                             # 0xa0 struct M128A[16]
        self.Reserved4 = []                                # 0x1a0 UCHAR[96]

    @classmethod
    def parse(cls, buff):
        xmm = cls()

        xmm.ControlWord = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
        xmm.StatusWord = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
        xmm.TagWord = chr(int.from_bytes(buff.read(1), byteorder = 'little', signed = False))
        xmm.Reserved1 = chr(int.from_bytes(buff.read(1), byteorder = 'little', signed = False))
        xmm.ErrorOpcode = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
        xmm.ErrorOffset = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        xmm.ErrorSelector = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
        xmm.Reserved2 = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
        xmm.DataOffset = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        xmm.DataSelector = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
        xmm.Reserved3 = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
        xmm.MxCsr = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        xmm.MxCsr_Mask = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        xmm.FloatRegisters = M128A.parse_array(buff, 8)
        xmm.XmmRegisters = M128A.parse_array(buff, 16)
        xmm.Reserved4 = [
            chr(int.from_bytes(buff.read(1), byteorder = 'little', signed = False))
            for i in range(96)
        ]

        return xmm

    def __str__(self):
        s = ""
        s += "%s: %x (%d)\n" % ("ControlWord", self.ControlWord, self.ControlWord)
        s += "%s: %x (%d)\n" % ("StatusWord", self.StatusWord, self.StatusWord)
        s += "%s: %s\n" % ("TagWord", self.TagWord)
        s += "%s: %s\n" % ("Reserved1", self.Reserved1)
        s += "%s: %x (%d)\n" % ("ErrorOpcode", self.ErrorOpcode, self.ErrorOpcode)
        s += "%s: %x (%d)\n" % ("ErrorOffset", self.ErrorOffset, self.ErrorOffset)
        s += "%s: %x (%d)\n" % ("ErrorSelector", self.ErrorSelector, self.ErrorSelector)
        s += "%s: %x (%d)\n" % ("Reserved2", self.Reserved2, self.Reserved2)
        s += "%s: %x (%d)\n" % ("DataOffset", self.DataOffset, self.DataOffset)
        s += "%s: %x (%d)\n" % ("DataSelector", self.DataSelector, self.DataSelector)
        s += "%s: %x (%d)\n" % ("Reserved3", self.Reserved3, self.Reserved3)
        s += "%s: %x (%d)\n" % ("MxCsr", self.MxCsr, self.MxCsr)
        s += "%s: %x (%d)\n" % ("MxCsr_Mask", self.MxCsr_Mask, self.MxCsr_Mask)
        s += "%s:\n" % ("FloatRegisters:")
        for freg in self.FloatRegisters:
            s += "\t%s" % (freg)
        s += "%s:\n" % ("XmmRegisters")
        for xreg in self.XmmRegisters:
            s += "\t%s" % (xreg)
        s += "%s: %s\n" % ("Reserved4", "".join(self.Reserved4))

        return s


class CTX_DUMMYSTRUCTNAME:
    def __init__(self):
        # all are M128A
        self.Header = []                # [2]
        self.Legacy = []                # [8]
        self.Xmm0 = 0
        self.Xmm1 = 0
        self.Xmm2 = 0
        self.Xmm3 = 0
        self.Xmm4 = 0
        self.Xmm5 = 0
        self.Xmm6 = 0
        self.Xmm7 = 0
        self.Xmm8 = 0
        self.Xmm9 = 0
        self.Xmm10 = 0
        self.Xmm11 = 0
        self.Xmm12 = 0
        self.Xmm13 = 0
        self.Xmm14 = 0
        self.Xmm15 = 0
    
    @classmethod
    def parse(cls, buff):
        dsn = cls()

        dsn.Header = M128A.parse_array(buff, 2)
        dsn.Legacy = M128A.parse_array(buff, 8)
        dsn.Xmm0 = M128A.parse(buff)
        dsn.Xmm1 = M128A.parse(buff)
        dsn.Xmm2 = M128A.parse(buff)
        dsn.Xmm3 = M128A.parse(buff)
        dsn.Xmm4 = M128A.parse(buff)
        dsn.Xmm5 = M128A.parse(buff)
        dsn.Xmm6 = M128A.parse(buff)
        dsn.Xmm7 = M128A.parse(buff)
        dsn.Xmm8 = M128A.parse(buff)
        dsn.Xmm9 = M128A.parse(buff)
        dsn.Xmm10 = M128A.parse(buff)
        dsn.Xmm11 = M128A.parse(buff)
        dsn.Xmm12 = M128A.parse(buff)
        dsn.Xmm13 = M128A.parse(buff)
        dsn.Xmm14 = M128A.parse(buff)
        dsn.Xmm15 = M128A.parse(buff)

        return dsn

    def __str__(self):
        s = ""
        s += "%s:\n" % ("Header")
        for head in self.Header:
            s += "\t%s" % (head)
        s += "%s:\n" % ("Legacy")
        for leg in self.Legacy:
            s += "\t%s" % (leg)
        s += "%s: %s" % ("Xmm0", self.Xmm0)
        s += "%s: %s" % ("Xmm1", self.Xmm1)
        s += "%s: %s" % ("Xmm2", self.Xmm2)
        s += "%s: %s" % ("Xmm3", self.Xmm3)
        s += "%s: %s" % ("Xmm4", self.Xmm4)
        s += "%s: %s" % ("Xmm5", self.Xmm5)
        s += "%s: %s" % ("Xmm6", self.Xmm6)
        s += "%s: %s" % ("Xmm7", self.Xmm7)
        s += "%s: %s" % ("Xmm8", self.Xmm8)
        s += "%s: %s" % ("Xmm9", self.Xmm9)
        s += "%s: %s" % ("Xmm10", self.Xmm10)
        s += "%s: %s" % ("Xmm11", self.Xmm11)
        s += "%s: %s" % ("Xmm12", self.Xmm12)
        s += "%s: %s" % ("Xmm13", self.Xmm13)
        s += "%s: %s" % ("Xmm14", self.Xmm14)
        s += "%s: %s" % ("Xmm15", self.Xmm15)

        return s


class CTX_DUMMYUNIONNAME:
    def __init__(self):
        self.FltSave = []                  # XMM_SAVE_AREA32
        self.Q = []                        # NEON128 [16]
        self.D = []                        # ULONGLONG [32]
        self.DUMMYSTRUCTNAME = []
        self.S = []                        # DWORD [32]
    
    @classmethod
    def parse(cls, buff):
        dun = cls()

        dun.FltSave = XMM_SAVE_AREA32.parse(buff)
        dun.Q = NEON128.parse_array(buff, 16)
        dun.D = [
            int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
            for i in range(32)
        ]
        dun.DUMMYSTRUCTNAME = CTX_DUMMYSTRUCTNAME.parse(buff)
        dun.S = [
            int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
            for i in range(32)
        ]
        return dun

    def __str__(self):
        s = ""
        s += "%s: %s\n" % ("FltSave", self.FltSave)
        s += "%s:\n" % ("Q")
        for q in self.Q:
            s += "\t%s" % (q.__str__())
        for d in self.D:
            s += "\t%d" % (d)
        s += "%s: %s" % ("DUMMYSTRUCTNAME", self.DUMMYSTRUCTNAME)
        s += "%s:\n" %("S")
        for e in self.S:
            s += "\t%d" % (e)

        return s
        

# https:# docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context
class CONTEXT:
    def __init__(self):
        self.P1Home = 0   # DWORD64
        self.P2Home = 0   # DWORD64
        self.P3Home = 0   # DWORD64
        self.P4Home = 0   # DWORD64
        self.P5Home = 0   # DWORD64
        self.P6Home = 0   # DWORD64
        self.ContextFlags = 0   # DWORD
        self.MxCsr = 0   # DWORD
        self.SegCs = 0   # WORD
        self.SegDs = 0   # WORD
        self.SegEs = 0   # WORD
        self.SegFs = 0   # WORD
        self.SegGs = 0   # WORD
        self.SegSs = 0   # WORD
        self.EFlags = 0   # DWORD
        self.Dr0 = 0   # DWORD64
        self.Dr1 = 0   # DWORD64
        self.Dr2 = 0   # DWORD64
        self.Dr3 = 0   # DWORD64
        self.Dr6 = 0   # DWORD64
        self.Dr7 = 0   # DWORD64
        self.Rax = 0   # DWORD64
        self.Rcx = 0   # DWORD64
        self.Rdx = 0   # DWORD64
        self.Rbx = 0   # DWORD64
        self.Rsp = 0   # DWORD64
        self.Rbp = 0   # DWORD64
        self.Rsi = 0   # DWORD64
        self.Rdi = 0   # DWORD64
        self.R8 = 0    # DWORD64
        self.R9 = 0    # DWORD64
        self.R10 = 0   # DWORD64
        self.R11 = 0   # DWORD64
        self.R12 = 0   # DWORD64
        self.R13 = 0   # DWORD64
        self.R14 = 0   # DWORD64
        self.R15 = 0   # DWORD64
        self.Rip = 0   # DWORD64
        self.DUMMYUNIONNAME = None
        
        self.VectorRegister = []         # M128A   [26]
        self.VectorControl = 0           # DWORD64
        self.DebugControl = 0            # DWORD64
        self.LastBranchToRip = 0         # DWORD64
        self.LastBranchFromRip = 0       # DWORD64
        self.LastExceptionToRip = 0      # DWORD64
        self.LastExceptionFromRip = 0    # DWORD64

    @classmethod
    def parse(cls, buff):
        ctx = cls()
        
        ctx.P1Home = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.P2Home = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.P3Home = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.P4Home = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.P5Home = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.P6Home = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.ContextFlags = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)   # DWORD
        ctx.MxCsr = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)   # DWORD
        ctx.SegCs = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)   # WORD
        ctx.SegDs = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)   # WORD
        ctx.SegEs = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)   # WORD
        ctx.SegFs = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)   # WORD
        ctx.SegGs = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)   # WORD
        ctx.SegSs = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)   # WORD
        ctx.EFlags = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)   # DWORD
        ctx.Dr0 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Dr1 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Dr2 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Dr3 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Dr6 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Dr7 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rax = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rcx = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rdx = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rbx = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rsp = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rbp = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rsi = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rdi = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R8 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R9 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R10 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R11 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R12 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R13 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R14 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R15 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rip = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.DUMMYUNIONNAME = CTX_DUMMYUNIONNAME.parse(buff)
        
        ctx.VectorRegister = M128A.parse_array(buff, 26)         # M128A   [26]
        ctx.VectorControl =  int.from_bytes(buff.read(8), byteorder = 'little', signed = False)       # DWORD64
        ctx.DebugControl = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)         # DWORD64
        ctx.LastBranchToRip = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)      # DWORD64
        ctx.LastBranchFromRip = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)    # DWORD64
        ctx.LastExceptionToRip = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.LastExceptionFromRip = int.from_bytes(buff.read(8), byteorder = 'little', signed = False) # DWORD64

        return ctx

    def __str__(self):
        s = "" 
        s += "%s: 0x%x (%d)\n" % ("P1Home",self.P1Home,self.P1Home)
        s += "%s: 0x%x (%d)\n" % ("P2Home",self.P2Home,self.P2Home)
        s += "%s: 0x%x (%d)\n" % ("P3Home",self.P3Home,self.P3Home)
        s += "%s: 0x%x (%d)\n" % ("P4Home",self.P4Home,self.P4Home)
        s += "%s: 0x%x (%d)\n" % ("P5Home",self.P5Home,self.P5Home)
        s += "%s: 0x%x (%d)\n" % ("P6Home",self.P6Home,self.P6Home)
        s += "%s: 0x%x (%d)\n" % ("ContextFlags",self.ContextFlags,self.ContextFlags)
        s += "%s: 0x%x (%d)\n" % ("MxCsr",self.MxCsr,self.MxCsr)
        s += "%s: 0x%x (%d)\n" % ("SegCs",self.SegCs,self.SegCs)
        s += "%s: 0x%x (%d)\n" % ("SegDs",self.SegDs,self.SegDs)
        s += "%s: 0x%x (%d)\n" % ("SegEs",self.SegEs,self.SegEs)
        s += "%s: 0x%x (%d)\n" % ("SegFs",self.SegFs,self.SegFs)
        s += "%s: 0x%x (%d)\n" % ("SegGs",self.SegGs,self.SegGs)
        s += "%s: 0x%x (%d)\n" % ("SegSs",self.SegSs,self.SegSs)
        s += "%s: 0x%x (%d)\n" % ("EFlags",self.EFlags,self.EFlags)
        s += "%s: 0x%x (%d)\n" % ("Dr0",self.Dr0,self.Dr0)
        s += "%s: 0x%x (%d)\n" % ("Dr1",self.Dr1,self.Dr1)
        s += "%s: 0x%x (%d)\n" % ("Dr2",self.Dr2,self.Dr2)
        s += "%s: 0x%x (%d)\n" % ("Dr3",self.Dr3,self.Dr3)
        s += "%s: 0x%x (%d)\n" % ("Dr6",self.Dr6,self.Dr6)
        s += "%s: 0x%x (%d)\n" % ("Dr7",self.Dr7,self.Dr7)
        s += "%s: 0x%x (%d)\n" % ("Rax",self.Rax,self.Rax)
        s += "%s: 0x%x (%d)\n" % ("Rcx",self.Rcx,self.Rcx)
        s += "%s: 0x%x (%d)\n" % ("Rdx",self.Rdx,self.Rdx)
        s += "%s: 0x%x (%d)\n" % ("Rbx",self.Rbx,self.Rbx)
        s += "%s: 0x%x (%d)\n" % ("Rsp",self.Rsp,self.Rsp)
        s += "%s: 0x%x (%d)\n" % ("Rbp",self.Rbp,self.Rbp)
        s += "%s: 0x%x (%d)\n" % ("Rsi",self.Rsi,self.Rsi)
        s += "%s: 0x%x (%d)\n" % ("Rdi",self.Rdi,self.Rdi)
        s += "%s: 0x%x (%d)\n" % ("R8",self.R8,self.R8)
        s += "%s: 0x%x (%d)\n" % ("R9",self.R9,self.R9)
        s += "%s: 0x%x (%d)\n" % ("R10",self.R10,self.R10)
        s += "%s: 0x%x (%d)\n" % ("R11",self.R11,self.R11)
        s += "%s: 0x%x (%d)\n" % ("R12",self.R12,self.R12)
        s += "%s: 0x%x (%d)\n" % ("R13",self.R13,self.R13)
        s += "%s: 0x%x (%d)\n" % ("R14",self.R14,self.R14)
        s += "%s: 0x%x (%d)\n" % ("R15",self.R15,self.R15)
        s += "%s: 0x%x (%d)\n" % ("Rip",self.Rip,self.Rip)
        s += "%s:" % ("DUMMYUNIONNAME")
        s += self.DUMMYUNIONNAME.__str__()

        return s


# https:# docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-wow64_floating_save_area
class WOW64_FLOATING_SAVE_AREA:
    def __init__(self):
        self.ControlWord = 0  # DWORD
        self.StatusWord = 0   # DWORD
        self.TagWord = 0      # DWORD
        self.ErrorOffset = 0  # DWORD
        self.ErrorSelector = 0  # DWORD
        self.DataOffset = 0  # DWORD
        self.DataSelector = 0 # DWORD
        self.RegisterArea = []  # BYTE
        self.Cr0NpxState = 0  # DWORD
    
    @classmethod
    def parse(cls, buff):
        ctx = cls()
        ctx.ControlWord = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.StatusWord = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.TagWord = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.ErrorOffset = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.ErrorSelector = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.DataOffset = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.DataSelector = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.RegisterArea = int.from_bytes(buff.read(80), byteorder = 'little', signed = False)
        ctx.Cr0NpxState = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        return ctx
        
    def __str__(self):
        s = ''
        s += "ControlWord: %x (%d)\n" % (self.ControlWord, self.ControlWord)
        s += "StatusWord: %x (%d)\n" % (self.StatusWord, self.StatusWord)
        s += "TagWord: %x (%d)\n" % (self.TagWord, self.TagWord)
        s += "ErrorOffset: %x (%d)\n" % (self.ErrorOffset, self.ErrorOffset)
        s += "ErrorSelector: %x (%d)\n" % (self.ErrorSelector, self.ErrorSelector)
        s += "DataOffset: %x (%d)\n" % (self.DataOffset, self.DataOffset)
        s += "DataSelector: %x (%d)\n" % (self.DataSelector, self.DataSelector)
        s += "RegisterArea: %s\n" % str(self.RegisterArea)
        s += "Cr0NpxState: %x (%d)" % (self.Cr0NpxState, self.Cr0NpxState)
        return s

# https:# docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-wow64_context
class WOW64_CONTEXT:
    def __init__(self):
        self.ContextFlags = 0   # DWORD
        self.Dr0 = 0   # DWORD
        self.Dr1 = 0   # DWORD
        self.Dr2 = 0   # DWORD
        self.Dr3 = 0   # DWORD
        self.Dr6 = 0   # DWORD
        self.Dr7 = 0   # DWORD
        self.FloatSave = 0   # WOW64_FLOATING_SAVE_AREA
        self.SegGs = 0   # DWORD
        self.SegFs = 0   # DWORD
        self.SegEs = 0   # DWORD
        self.SegDs = 0   # DWORD
        self.Edi = 0   # DWORD
        self.Esi = 0   # DWORD
        self.Ebx = 0   # DWORD
        self.Edx = 0   # DWORD
        self.Ecx = 0   # DWORD
        self.Eax = 0   # DWORD
        self.Ebp = 0   # DWORD
        self.Eip = 0   # DWORD
        self.SegCs = 0   # DWORD
        self.EFlags = 0   # DWORD
        self.Esp = 0   # DWORD
        self.SegSs = 0   # DWORD
        self.ExtendedRegisters = []   # BYTE

    @classmethod
    def parse(cls, buff):
        ctx = cls()

        ctx.ContextFlags = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Dr0 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Dr1 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Dr2 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Dr3 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Dr6 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Dr7 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.FloatSave = WOW64_FLOATING_SAVE_AREA.parse(buff)
        ctx.SegGs = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.SegFs = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.SegEs = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.SegDs = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Edi = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Esi = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Ebx = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Edx = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Ecx = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Eax = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Ebp = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Eip = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.SegCs = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.EFlags = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Esp = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.SegSs = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.ExtendedRegisters = [
            int.from_bytes(buff.read(1), byteorder = 'little', signed = False)
            for i in range(512)
        ]
        return ctx

    def __str__(self):
        s = ''
        s += "%s: %x (%d)\n" % ("ContextFlags", self.ContextFlags, self.ContextFlags)
        s += "%s: %x (%d)\n" % ("Dr0", self.Dr0, self.Dr0)
        s += "%s: %x (%d)\n" % ("Dr1", self.Dr1, self.Dr1)
        s += "%s: %x (%d)\n" % ("Dr2", self.Dr2, self.Dr2)
        s += "%s: %x (%d)\n" % ("Dr3", self.Dr3, self.Dr3)
        s += "%s: %x (%d)\n" % ("Dr6", self.Dr6, self.Dr6)
        s += "%s: %x (%d)\n" % ("Dr7", self.Dr7, self.Dr7)
        s += "%s: %s\n" % ("FloatSave", self.FloatSave.__str__())
        s += "%s: %x (%d)\n" % ("SegGs", self.SegGs, self.SegGs)
        s += "%s: %x (%d)\n" % ("SegFs", self.SegFs, self.SegFs)
        s += "%s: %x (%d)\n" % ("SegEs", self.SegEs, self.SegEs)
        s += "%s: %x (%d)\n" % ("SegDs", self.SegDs, self.SegDs)
        s += "%s: %x (%d)\n" % ("Edi", self.Edi, self.Edi)
        s += "%s: %x (%d)\n" % ("Esi", self.Esi, self.Esi)
        s += "%s: %x (%d)\n" % ("Ebx", self.Ebx, self.Ebx)
        s += "%s: %x (%d)\n" % ("Edx", self.Edx, self.Edx)
        s += "%s: %x (%d)\n" % ("Ecx", self.Ecx, self.Ecx)
        s += "%s: %x (%d)\n" % ("Eax", self.Eax, self.Eax)
        s += "%s: %x (%d)\n" % ("Ebp", self.Ebp, self.Ebp)
        s += "%s: %x (%d)\n" % ("Eip", self.Eip, self.Eip)
        s += "%s: %x (%d)\n" % ("SegCs", self.SegCs, self.SegCs)
        s += "%s: %x (%d)\n" % ("EFlags", self.EFlags, self.EFlags)
        s += "%s: %x (%d)\n" % ("Esp", self.Esp, self.Esp)
        s += "%s: %x (%d)\n" % ("SegSs", self.SegSs, self.SegSs)
        s += "%s: %s\n" % ("ExtendedRegisters", str(self.ExtendedRegisters))

        return s

```

`src/minidump/streams/ExceptionStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
# TODO: implement this better, the ExceptionInformation definition is missing on msdn :(

import io
import enum
from minidump.common_structs import * 

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680368(v=vs.85).aspx
class MINIDUMP_EXCEPTION_STREAM:
	def __init__(self):
		self.ThreadId = None
		self.alignment = None
		self.ExceptionRecord = None
		self.ThreadContext = None
	
	@staticmethod
	def parse(buff):
		mes = MINIDUMP_EXCEPTION_STREAM()
		mes.ThreadId = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mes.alignment = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mes.ExceptionRecord = MINIDUMP_EXCEPTION.parse(buff)
		mes.ThreadContext = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		return mes

	def __str__(self):
		t  = '== MINIDUMP_EXCEPTION_STREAM ==\n'
		t += 'ThreadId: %s\n' % self.ThreadId
		# t += 'alignment: %s\n' % self.alignment
		t += 'ExceptionRecord:\n %s\n' % str(self.ExceptionRecord)
		t += 'ThreadContext: %s\n' % str(self.ThreadContext)
		return t
	
	@staticmethod
	def get_header():
		return [
			'ThreadId',
			*MINIDUMP_EXCEPTION.get_header()
		]
		

	def to_row(self):
		return [
			'0x%08x' % self.ThreadId,
			*self.ExceptionRecord.to_row()
		]

		
class ExceptionCode(enum.Enum):
	# Not a real exception code, it's just a placeholder to prevent the parser from raising an error
	EXCEPTION_UNKNOWN               = 'EXCEPTION_UNKNOWN_CHECK_RAW'
	EXCEPTION_NONE 					= 0x00

	# Linux SIG values (for crashpad generated dumps)
	EXCEPTION_SIGHUP    			= 0x00000001    # Hangup (POSIX)
	EXCEPTION_SIGINT    			= 0x00000002    # Terminal interrupt (ANSI)
	EXCEPTION_SIGQUIT   			= 0x00000003    # Terminal quit (POSIX)
	EXCEPTION_SIGILL    			= 0x00000004    # Illegal instruction (ANSI)
	EXCEPTION_SIGTRAP   			= 0x00000005    # Trace trap (POSIX)
	EXCEPTION_SIGIOT    			= 0x00000006    # IOT Trap (4.2 BSD)
	EXCEPTION_SIGBUS    			= 0x00000007    # BUS error (4.2 BSD)
	EXCEPTION_SIGFPE    			= 0x00000008    # Floating point exception (ANSI)
	EXCEPTION_SIGKILL   			= 0x00000009    # Kill(can't be caught or ignored) (POSIX)
	EXCEPTION_SIGUSR1   			= 0x0000000A   # User defined signal 1 (POSIX)
	EXCEPTION_SIGSEGV   			= 0x0000000B   # Invalid memory segment access (ANSI)
	EXCEPTION_SIGUSR2   			= 0x0000000C   # User defined signal 2 (POSIX)
	EXCEPTION_SIGPIPE   			= 0x0000000D   # Write on a pipe with no reader, Broken pipe (POSIX)
	EXCEPTION_SIGALRM   			= 0x0000000E   # Alarm clock (POSIX)
	EXCEPTION_SIGTERM   			= 0x0000000F   # Termination (ANSI)
	EXCEPTION_SIGSTKFLT 			= 0x00000010   # Stack fault
	EXCEPTION_SIGCHLD   			= 0x00000011   # Child process has stopped or exited, changed (POSIX)
	EXCEPTION_SIGCONTV  			= 0x00000012   # Continue executing, if stopped (POSIX)
	EXCEPTION_SIGSTOP   			= 0x00000013   # Stop executing(can't be caught or ignored) (POSIX)
	EXCEPTION_SIGTSTP   			= 0x00000014   # Terminal stop signal (POSIX)
	EXCEPTION_SIGTTIN   			= 0x00000015   # Background process trying to read, from TTY (POSIX)
	EXCEPTION_SIGTTOU   			= 0x00000016   # Background process trying to write, to TTY (POSIX)
	EXCEPTION_SIGURG    			= 0x00000017   # Urgent condition on socket (4.2 BSD)
	EXCEPTION_SIGXCPU   			= 0x00000018   # CPU limit exceeded (4.2 BSD)
	EXCEPTION_SIGXFSZ   			= 0x00000019   # File size limit exceeded (4.2 BSD)
	EXCEPTION_SIGVTALRM 			= 0x0000001A   # Virtual alarm clock (4.2 BSD)
	EXCEPTION_SIGPROF   			= 0x0000001B   # Profiling alarm clock (4.2 BSD)
	EXCEPTION_SIGWINCH  			= 0x0000001C   # Window size change (4.3 BSD, Sun)
	EXCEPTION_SIGIO     			= 0x0000001D   # I/O now possible (4.2 BSD)
	EXCEPTION_SIGPWR    			= 0x0000001E   # Power failure restart (System V)

	# Standard Windows exception values
	EXCEPTION_ACCESS_VIOLATION 		= 0xC0000005 	# The thread tried to read from or write to a virtual address for which it does not have the appropriate access.
	EXCEPTION_ARRAY_BOUNDS_EXCEEDED = 0xC000008C 	# The thread tried to access an array element that is out of bounds and the underlying hardware supports bounds checking.
	EXCEPTION_BREAKPOINT 			= 0x80000003 	# A breakpoint was encountered.
	EXCEPTION_DATATYPE_MISALIGNMENT = 0x80000002 	# The thread tried to read or write data that is misaligned on hardware that does not provide alignment. For example, 16-bit values must be aligned on 2-byte boundaries; 32-bit values on 4-byte boundaries, and so on.
	EXCEPTION_FLT_DENORMAL_OPERAND 	= 0xC000008D 	# One of the operands in a floating-point operation is denormal. A denormal value is one that is too small to represent as a standard floating-point value.
	EXCEPTION_FLT_DIVIDE_BY_ZERO 	= 0xC000008E	# The thread tried to divide a floating-point value by a floating-point divisor of zero.
	EXCEPTION_FLT_INEXACT_RESULT 	= 0xC000008F	# The result of a floating-point operation cannot be represented exactly as a decimal fraction.
	EXCEPTION_FLT_INVALID_OPERATION = 0xC0000090	# This exception represents any floating-point exception not included in this list.
	EXCEPTION_FLT_OVERFLOW 			= 0xC0000091 	# The exponent of a floating-point operation is greater than the magnitude allowed by the corresponding type.
	EXCEPTION_FLT_STACK_CHECK 		= 0xC0000092	# The stack overflowed or underflowed as the result of a floating-point operation.
	EXCEPTION_FLT_UNDERFLOW 		= 0xC0000093	# The exponent of a floating-point operation is less than the magnitude allowed by the corresponding type.
	EXCEPTION_ILLEGAL_INSTRUCTION 	= 0xC000001D	# The thread tried to execute an invalid instruction.
	EXCEPTION_IN_PAGE_ERROR 		= 0xC0000006	# The thread tried to access a page that was not present, and the system was unable to load the page. For example, this exception might occur if a network connection is lost while running a program over the network.
	EXCEPTION_INT_DIVIDE_BY_ZERO 	= 0xC0000094	# The thread tried to divide an integer value by an integer divisor of zero.
	EXCEPTION_INT_OVERFLOW 			= 0xC0000095	# The result of an integer operation caused a carry out of the most significant bit of the result.
	EXCEPTION_INVALID_DISPOSITION 	= 0xC0000026	# An exception handler returned an invalid disposition to the exception dispatcher. Programmers using a high-level language such as C should never encounter this exception.
	EXCEPTION_NONCONTINUABLE_EXCEPTION =0xC0000025  # The thread tried to continue execution after a noncontinuable exception occurred.
	EXCEPTION_PRIV_INSTRUCTION 		= 0xC0000096	# The thread tried to execute an instruction whose operation is not allowed in the current machine mode.
	EXCEPTION_SINGLE_STEP 			= 0x80000004	# A trace trap or other single-instruction mechanism signaled that one instruction has been executed.
	EXCEPTION_STACK_OVERFLOW 		= 0xC00000FD	# The thread used up its stack.
		
#https://msdn.microsoft.com/en-us/library/windows/desktop/ms680367(v=vs.85).aspx
class MINIDUMP_EXCEPTION:
	def __init__(self):
		self.ExceptionCode = None
		self.ExceptionFlags = None
		self.ExceptionRecord = None
		self.ExceptionAddress = None
		self.NumberParameters = None
		self.__unusedAlignment = None
		self.ExceptionInformation = []
		self.ExceptionCode_raw = None
	
	@staticmethod
	def parse(buff):
		me = MINIDUMP_EXCEPTION()
		me.ExceptionCode_raw = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		try:
			me.ExceptionCode = ExceptionCode(me.ExceptionCode_raw)
		except:
			me.ExceptionCode = ExceptionCode.EXCEPTION_UNKNOWN

		me.ExceptionFlags = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		me.ExceptionRecord = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		me.ExceptionAddress = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		me.NumberParameters = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		me.__unusedAlignment = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		for _ in range(me.NumberParameters):
			me.ExceptionInformation.append(int.from_bytes(buff.read(8), byteorder = 'little', signed = False))
			
		return me

	def __str__(self):
		t  = '== MINIDUExceptionInformationMP_EXCEPTION ==\n'
		t += "ExceptionCode : %s\n" % self.ExceptionCode 
		t += "ExceptionFlags : %s\n" % self.ExceptionFlags 
		t += "ExceptionRecord : %s\n" % self.ExceptionRecord
		t += "ExceptionAddress : 0x%x\n" % self.ExceptionAddress
		t += "NumberParameters : %s\n" % self.NumberParameters
		# t += "__unusedAlignment : %s\n" % self.__unusedAlignment
		t += "ExceptionInformation : %s\n" % ";".join("0x%x" % info for info in self.ExceptionInformation)
		return t

	@staticmethod
	def get_header():
		return [
			'ExceptionCode',
			'ExceptionFlags',
			'ExceptionRecord',
			'ExceptionAddress',
			'ExceptionInformation'
		]
		

	def to_row(self):
		return [
			str(self.ExceptionCode),
			'0x%08x' % self.ExceptionFlags,
			'0x%08x' % self.ExceptionRecord,
			'0x%08x' % self.ExceptionAddress,
			str(self.ExceptionInformation)
		]


class ExceptionList:
	def __init__(self):
		self.exception_records = []
	
	@staticmethod
	def parse(dir, buff):
		t = ExceptionList()
	
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))

		# Unfortunately, we don't have a certain way to figure out how many exception records
		# there is in the stream, so we have to fallback on heuristics (EOF or bad data read)
		#
		# NB : 	some tool only read one exception record : https://github.com/GregTheDev/MinidumpExplorer/blob/a6dd974757c16142eefcfff7d99be10b14f87eaf/MinidumpExplorer/MinidumpExplorer/MainForm.cs#L257
		#		but it's incorrect since we can have an exception chain (double fault, exception catched and re-raised, etc.)
		while chunk.tell() < dir.Location.DataSize:
			mes = MINIDUMP_EXCEPTION_STREAM.parse(chunk)

			# a minidump exception stream is usally padded with zeroes
			# so whenever we parse an exception record with the code EXCEPTION_NONE
			# we can stop.
			if mes.ExceptionRecord.ExceptionCode == ExceptionCode.EXCEPTION_NONE:
				break

			t.exception_records.append(mes)
			
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = ExceptionList()
	
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)

		# Unfortunately, we don't have a certain way to figure out how many exception records
		# there is in the stream, so we have to fallback on heuristics (EOF or bad data read)
		#
		# NB : 	some tool only read one exception record : https://github.com/GregTheDev/MinidumpExplorer/blob/a6dd974757c16142eefcfff7d99be10b14f87eaf/MinidumpExplorer/MinidumpExplorer/MainForm.cs#L257
		#		but it's incorrect since we can have an exception chain (double fault, exception catched and re-raised, etc.)
		while chunk.tell() < dir.Location.DataSize:
			mes = MINIDUMP_EXCEPTION_STREAM.parse(chunk)

			# a minidump exception stream is usally padded with zeroes
			# so whenever we parse an exception record with the code EXCEPTION_NONE
			# we can stop.
			if mes.ExceptionRecord.ExceptionCode == ExceptionCode.EXCEPTION_NONE:
				break

			t.exception_records.append(mes)
			
		return t
	
	def to_table(self):
		t = []
		t.append(MINIDUMP_EXCEPTION_STREAM.get_header())
		for ex_record in self.exception_records:
			t.append(ex_record.to_row())
		return t

	def __str__(self):
		return '== ExceptionList ==\n' + construct_table(self.to_table())
	
```

`src/minidump/streams/FunctionTableStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
class MINIDUMP_FUNCTION_TABLE_STREAM:
	def __init__(self):
		self.SizeOfHeader = None
		self.SizeOfDescriptor = None
		self.SizeOfNativeDescriptor = None
		self.SizeOfFunctionEntry = None
		self.NumberOfDescriptors = None
		self.SizeOfAlignPad = None
	
	@staticmethod
	def parse(dir, buff):
		mfts = MINIDUMP_FUNCTION_TABLE_STREAM()
		mfts.SizeOfHeader = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mfts.SizeOfDescriptor = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mfts.SizeOfNativeDescriptor = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mfts.SizeOfFunctionEntry = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mfts.NumberOfDescriptors = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mfts.SizeOfAlignPad = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			
		return mfts
```

`src/minidump/streams/HandleDataStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
import enum
from minidump.common_structs import * 

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680372(v=vs.85).aspx
class MINIDUMP_HANDLE_DATA_STREAM:
	def __init__(self):
		self.SizeOfHeader = None
		self.SizeOfDescriptor = None
		self.NumberOfDescriptors = None
		self.Reserved = None
	
	@staticmethod
	def parse(buff):
		mhds = MINIDUMP_HANDLE_DATA_STREAM()
		mhds.SizeOfHeader = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.SizeOfDescriptor = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.NumberOfDescriptors = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.Reserved = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			
		return mhds
	
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680374(v=vs.85).aspx
class MINIDUMP_HANDLE_DESCRIPTOR:
	size = 32
	def __init__(self):
		self.Handle = None
		self.TypeNameRva = None
		self.ObjectNameRva = None
		self.Attributes = None
		self.GrantedAccess = None
		self.HandleCount = None
		self.PointerCount = None
	
	@staticmethod
	def parse(buff):
		mhd = MINIDUMP_HANDLE_DESCRIPTOR()
		mhd.Handle = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mhd.TypeNameRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.ObjectNameRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.Attributes = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.GrantedAccess = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.HandleCount = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.PointerCount = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		
		return mhd
		
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680373(v=vs.85).aspx
class MINIDUMP_HANDLE_DESCRIPTOR_2:	
	def __init__(self):
		self.Handle = None
		self.TypeNameRva = None
		self.ObjectNameRva = None
		self.Attributes = None
		self.GrantedAccess = None
		self.HandleCount = None
		self.PointerCount = None
		self.ObjectInfoRva = None
		self.Reserved0 = None
	
	@staticmethod
	def parse(buff):
		mhd = MINIDUMP_HANDLE_DESCRIPTOR_2()
		mhd.Handle = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mhd.TypeNameRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.ObjectNameRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.Attributes = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.GrantedAccess = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.HandleCount = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.PointerCount = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.ObjectInfoRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.Reserved0 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		return mhd

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680376(v=vs.85).aspx
class MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE(enum.Enum): 
	MiniHandleObjectInformationNone = 0
	MiniThreadInformation1 = 1
	MiniMutantInformation1 = 2
	MiniMutantInformation2 = 3
	MiniProcessInformation1 = 4
	MiniProcessInformation2 = 5
	

class MINIDUMP_HANDLE_OBJECT_INFORMATION:
	def __init__(self):
		self.NextInfoRva = None
		self.InfoType = None
		self.SizeOfInfo = None
		
		#high-level, delete this when documentation becomes available!
		self.info_bytes = None
	
	@staticmethod
	def parse(buff):
		mhoi = MINIDUMP_HANDLE_OBJECT_INFORMATION()
		mhoi.NextInfoRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhoi.InfoType = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhoi.SizeOfInfo = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhoi.info_bytes = buff.read(mhoi.SizeOfInfo)
		return mhoi

	@staticmethod
	async def aparse(buff):
		mhoi = MINIDUMP_HANDLE_OBJECT_INFORMATION()
		t = await buff.read(4)
		mhoi.NextInfoRva = int.from_bytes(t, byteorder = 'little', signed = False)
		t = await buff.read(4)
		mhoi.InfoType = int.from_bytes(t, byteorder = 'little', signed = False)
		t = await buff.read(4)
		mhoi.SizeOfInfo = int.from_bytes(t, byteorder = 'little', signed = False)
		mhoi.info_bytes = await buff.read(mhoi.SizeOfInfo)
		return mhoi
		
class MinidumpHandleObjectInformation:
	def __init__(self):
		self.NextInfo = None
		self.InfoType = None
		self.SizeOfInfo = None
		self.info_bytes = None
	
	@staticmethod
	def parse(mhoi):
		t = MinidumpHandleObjectInformation()
		t.InfoType = mhoi.InfoType
		t.SizeOfInfo = mhoi.SizeOfInfo
		t.info_bytes = mhoi.info_bytes
		return t
	
	def __str__(self):
		return self.info_bytes.hex()
	
	
		
class MinidumpHandleDescriptor:
	def __init__(self):
		self.Handle = None
		self.TypeName = None
		self.ObjectName = None
		self.Attributes = None
		self.GrantedAccess = None
		self.HandleCount = None
		self.PointerCount = None
		self.ObjectInfos = []
	
	@staticmethod
	def parse(t, buff):
		mhd = MinidumpHandleDescriptor()
		mhd.Handle = t.Handle
		if t.TypeNameRva != 0:
			mhd.TypeName = MINIDUMP_STRING.get_from_rva(t.TypeNameRva, buff)
		if t.ObjectNameRva != 0:
			mhd.ObjectName = MINIDUMP_STRING.get_from_rva(t.ObjectNameRva, buff)
		mhd.Attributes = t.Attributes
		mhd.GrantedAccess = t.GrantedAccess
		mhd.HandleCount = t.HandleCount
		mhd.PointerCount = t.PointerCount
		if isinstance(t, MINIDUMP_HANDLE_DESCRIPTOR_2):
			if t.ObjectInfoRva is not None and t.ObjectInfoRva != 0:
				MinidumpHandleDescriptor.walk_objectinfo(mhd, t.ObjectInfoRva, buff)
		return mhd

	@staticmethod
	async def aparse(t, buff):
		mhd = MinidumpHandleDescriptor()
		mhd.Handle = t.Handle
		if t.TypeNameRva != 0:
			mhd.TypeName = await MINIDUMP_STRING.aget_from_rva(t.TypeNameRva, buff)
		if t.ObjectNameRva != 0:
			mhd.ObjectName = await MINIDUMP_STRING.aget_from_rva(t.ObjectNameRva, buff)
		mhd.Attributes = t.Attributes
		mhd.GrantedAccess = t.GrantedAccess
		mhd.HandleCount = t.HandleCount
		mhd.PointerCount = t.PointerCount
		if isinstance(t, MINIDUMP_HANDLE_DESCRIPTOR_2):
			if t.ObjectInfoRva is not None and t.ObjectInfoRva != 0:
				await MinidumpHandleDescriptor.awalk_objectinfo(mhd, t.ObjectInfoRva, buff)
		return mhd
	
	@staticmethod
	def walk_objectinfo(mhd, start, buff):
		while start is not None and start != 0:
			buff.seek(start)
			mhoi = MINIDUMP_HANDLE_OBJECT_INFORMATION.parse(buff)
			t = MinidumpHandleObjectInformation.parse(mhoi)
			mhd.ObjectInfos.append(t)
			start = t.NextInfo

	@staticmethod
	async def awalk_objectinfo(mhd, start, buff):
		while start is not None and start != 0:
			await buff.seek(start)
			mhoi = await MINIDUMP_HANDLE_OBJECT_INFORMATION.aparse(buff)
			t = MinidumpHandleObjectInformation.parse(mhoi)
			mhd.ObjectInfos.append(t)
			start = t.NextInfo
		
		
	def __str__(self):
		t = '== MinidumpHandleDescriptor == \n'
		t += 'Handle 0x%08x ' % self.Handle
		t += 'TypeName %s ' % self.TypeName
		t += 'ObjectName %s ' % self.ObjectName
		t += 'Attributes %s ' % self.Attributes
		t += 'GrantedAccess %s ' % self.GrantedAccess
		t += 'HandleCount %s ' % self.HandleCount
		t += 'PointerCount %s ' % self.PointerCount
		for oi in self.ObjectInfos:
			t += str(oi)
		return t
		
class MinidumpHandleDataStream:
	def __init__(self):
		self.header = None
		self.handles = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpHandleDataStream()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		t.header = MINIDUMP_HANDLE_DATA_STREAM.parse(chunk)
		for _ in range(t.header.NumberOfDescriptors):
			if t.header.SizeOfDescriptor == MINIDUMP_HANDLE_DESCRIPTOR.size:
				mhd = MINIDUMP_HANDLE_DESCRIPTOR.parse(chunk)
				t.handles.append(MinidumpHandleDescriptor.parse(mhd, buff))
			else:
				mhd = MINIDUMP_HANDLE_DESCRIPTOR_2.parse(chunk)
				t.handles.append(MinidumpHandleDescriptor.parse(mhd, buff))
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpHandleDataStream()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		t.header = MINIDUMP_HANDLE_DATA_STREAM.parse(chunk)
		for _ in range(t.header.NumberOfDescriptors):
			if t.header.SizeOfDescriptor == MINIDUMP_HANDLE_DESCRIPTOR.size:
				mhd = MINIDUMP_HANDLE_DESCRIPTOR.parse(chunk)
				r = await MinidumpHandleDescriptor.aparse(mhd, buff)
				t.handles.append(r)
			else:
				mhd = MINIDUMP_HANDLE_DESCRIPTOR_2.parse(chunk)
				r = await MinidumpHandleDescriptor.aparse(mhd, buff)
				t.handles.append(r)
		return t
		
	def __str__(self):
		t  = '== MinidumpHandleDataStream ==\n'
		for handle in self.handles:
			t += str(handle)
		return t
```

`src/minidump/streams/HandleOperationListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
class MINIDUMP_HANDLE_OPERATION_LIST:
	def __init__(self):
		self.SizeOfHeader = None
		self.SizeOfEntry = None
		self.NumberOfEntries = None
		self.Reserved = None
	
	@staticmethod
	def parse(dir, buff):
		mhds = MINIDUMP_HANDLE_OPERATION_LIST()
		mhds.SizeOfHeader = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.SizeOfEntry = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.NumberOfEntries = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.Reserved = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			
		return mhds
		
```

`src/minidump/streams/JavaScriptDataStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
#TODO: MSDN gives no info
```

`src/minidump/streams/LastReservedStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
class MINIDUMP_USER_STREAM:
	def __init__(self):
		self.Type = None
		self.BufferSize = None
		self.Buffer = None
	
	@staticmethod
	def parse(buff):
		mus = MINIDUMP_USER_STREAM()
		mus.Type = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mus.BufferSize = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		#this type is PVOID, not sure on the size
		mus.Buffer = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			
		return mus
```

`src/minidump/streams/Memory64ListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
from minidump.common_structs import * 

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680387(v=vs.85).aspx
class MINIDUMP_MEMORY64_LIST:
	def __init__(self):
		self.NumberOfMemoryRanges = None
		self.BaseRva = None
		self.MemoryRanges = []

	def get_size(self):
		return 8 + 8 + len(self.MemoryRanges) * MINIDUMP_MEMORY_DESCRIPTOR64().get_size()

	def to_bytes(self):
		t = len(self.MemoryRanges).to_bytes(8, byteorder = 'little', signed = False)
		t += self.BaseRva.to_bytes(8, byteorder = 'little', signed = False)
		for memrange in self.MemoryRanges:
			t += memrange.to_bytes()
		return t
	
	@staticmethod
	def parse(buff):
		mml = MINIDUMP_MEMORY64_LIST()
		mml.NumberOfMemoryRanges = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mml.BaseRva = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		for _ in range(mml.NumberOfMemoryRanges):
			mml.MemoryRanges.append(MINIDUMP_MEMORY_DESCRIPTOR64.parse(buff))
		
		return mml
		
	def __str__(self):
		t  = '== MINIDUMP_MEMORY64_LIST ==\n'
		t += 'NumberOfMemoryRanges: %s\n' % self.NumberOfMemoryRanges
		t += 'BaseRva: %s\n' % self.BaseRva
		for i in range(self.NumberOfMemoryRanges):
			t += str(self.MemoryRanges[i]) + '\n'
		return t


# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680384(v=vs.85).aspx
class MINIDUMP_MEMORY_DESCRIPTOR64:
	def __init__(self):
		self.StartOfMemoryRange = None
		self.DataSize = None

	def get_size(self):
		return 16

	def to_bytes(self):
		t = self.StartOfMemoryRange.to_bytes(8, byteorder = 'little', signed = False)
		t += self.DataSize.to_bytes(8, byteorder = 'little', signed = False)
		return t
		
	@staticmethod
	def parse(buff):
		md = MINIDUMP_MEMORY_DESCRIPTOR64()
		md.StartOfMemoryRange = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		md.DataSize = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		return md
		
	def __str__(self):
		t = 'Start: %s' % hex(self.StartOfMemoryRange)
		t += 'Size: %s' % self.DataSize
		return t

class MinidumpMemory64List:
	def __init__(self):
		self.memory_segments = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpMemory64List()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		mtl = MINIDUMP_MEMORY64_LIST.parse(chunk)
		rva = mtl.BaseRva
		for mod in mtl.MemoryRanges:
			t.memory_segments.append(MinidumpMemorySegment.parse_full(mod, rva))
			rva += mod.DataSize
		return t

	@staticmethod
	async def aparse(dir, buff):
		mml = MinidumpMemory64List()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		mtl = MINIDUMP_MEMORY64_LIST.parse(chunk)
		rva = mtl.BaseRva
		for mod in mtl.MemoryRanges:
			ms = MinidumpMemorySegment.parse_full(mod, rva)
			mml.memory_segments.append(ms)
			rva += mod.DataSize
		return mml
		
	def to_table(self):
		t = []
		t.append(MinidumpMemorySegment.get_header())
		for mod in self.memory_segments:
			t.append(mod.to_row())
		return t
		
	def __str__(self):
		return '== MinidumpMemory64List ==\n' + construct_table(self.to_table())
	
```

`src/minidump/streams/MemoryInfoListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
import enum
from minidump.common_structs import *

class AllocationProtect(enum.Flag):
	NONE = 0
	PAGE_EXECUTE = 0x10 #Enables execute access to the committed region of pages. An attempt to write to the committed region results in an access violation.
						#This flag is not supported by the CreateFileMapping function.

	PAGE_EXECUTE_READ = 0x20 #Enables execute or read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation.
							 #Windows Server 2003 and Windows XP:  This attribute is not supported by the CreateFileMapping function until Windows XP with SP2 and Windows Server 2003 with SP1.

	PAGE_EXECUTE_READWRITE = 0x40 #Enables execute, read-only, or read/write access to the committed region of pages.#Windows Server 2003 and Windows XP:  This attribute is not supported by the CreateFileMapping function until Windows XP with SP2 and Windows Server 2003 with SP1.
	PAGE_EXECUTE_WRITECOPY = 0x80 #Enables execute, read-only, or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write page results in a private copy of the page being made for the process. The private page is marked as PAGE_EXECUTE_READWRITE, and the change is written to the new page.
	#This flag is not supported by the VirtualAlloc or VirtualAllocEx functions.
	#Windows Vista, Windows Server 2003 and Windows XP:  This attribute is not supported by the CreateFileMapping function until Windows Vista with SP1 and Windows Server 2008.

	PAGE_NOACCESS = 0x01 #Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an access violation.
	#This flag is not supported by the CreateFileMapping function.

	PAGE_READONLY = 0x02 #Enables read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation. If Data Execution Prevention is enabled, an attempt to execute code in the committed region results in an access violation.
	PAGE_READWRITE = 0x04 #Enables read-only or read/write access to the committed region of pages. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access violation.
	PAGE_WRITECOPY = 0x08 #Enables read-only or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write page results in a private copy of the page being made for the process. The private page is marked as PAGE_READWRITE, and the change is written to the new page. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access violation.
							#This flag is not supported by the VirtualAlloc or VirtualAllocEx functions.

	PAGE_TARGETS_INVALID = 0x40000000
	#Sets all locations in the pages as invalid targets for CFG. Used along with any execute page protection like PAGE_EXECUTE, PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE and PAGE_EXECUTE_WRITECOPY. Any indirect call to locations in those pages will fail CFG checks and the process will be terminated. The default behavior for executable pages allocated is to be marked valid call targets for CFG.
	#This flag is not supported by the VirtualProtect or CreateFileMapping functions.

	PAGE_TARGETS_NO_UPDATE = 0x40000000 #Pages in the region will not have their CFG information updated while the protection changes for VirtualProtect. For example, if the pages in the region was allocated using PAGE_TARGETS_INVALID, then the invalid information will be maintained while the page protection changes. This flag is only valid when the protection changes to an executable type like PAGE_EXECUTE, PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE and PAGE_EXECUTE_WRITECOPY. The default behavior for VirtualProtect protection change to executable is to mark all locations as valid call targets for CFG.
	#The following are modifiers that can be used in addition to the options provided in the previous table, except as noted.
	#Constant/value	Description

	PAGE_GUARD = 0x100 #Pages in the region become guard pages. Any attempt to access a guard page causes the system to raise a STATUS_GUARD_PAGE_VIOLATION exception and turn off the guard page status. Guard pages thus act as a one-time access alarm. For more information, see Creating Guard Pages.
	#When an access attempt leads the system to turn off guard page status, the underlying page protection takes over.
	#If a guard page exception occurs during a system service, the service typically returns a failure status indicator.
	#This value cannot be used with PAGE_NOACCESS.
	#This flag is not supported by the CreateFileMapping function.

	PAGE_NOCACHE = 0x200
	#Sets all pages to be non-cachable. Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.
	#The PAGE_NOCACHE flag cannot be used with the PAGE_GUARD, PAGE_NOACCESS, or PAGE_WRITECOMBINE flags.
	#The PAGE_NOCACHE flag can be used only when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable non-cached memory access for shared memory, specify the SEC_NOCACHE flag when calling the CreateFileMapping function.
	PAGE_WRITECOMBINE = 0x400 #Sets all pages to be write-combined.
	#Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped as write-combined can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.
	#The PAGE_WRITECOMBINE flag cannot be specified with the PAGE_NOACCESS, PAGE_GUARD, and PAGE_NOCACHE flags.
	#The PAGE_WRITECOMBINE flag can be used only when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable write-combined memory access for shared memory, specify the SEC_WRITECOMBINE flag when calling the CreateFileMapping function.
	#Windows Server 2003 and Windows XP:  This flag is not supported until Windows Server 2003 with SP1.

class MemoryType(enum.Enum):
	MEM_IMAGE = 0x1000000 #Indicates that the memory pages within the region are mapped into the view of an image section.
	MEM_MAPPED = 0x40000 #Indicates that the memory pages within the region are mapped into the view of a section.
	MEM_PRIVATE = 0x20000 #Indicates that the memory pages within the region are private (that is, not shared by other processes).
class MemoryState(enum.Enum):
	MEM_COMMIT = 0x1000 #Indicates committed pages for which physical storage has been allocated, either in memory or in the paging file on disk.
	MEM_FREE = 0x10000 #Indicates free pages not accessible to the calling process and available to be allocated. For free pages, the information in the AllocationBase, AllocationProtect, Protect, and Type members is undefined.
	MEM_RESERVE = 0x2000 #Indicates reserved pages where a range of the process's virtual address space is reserved without any physical storage being allocated. For reserved pages, the information in the Protect member is undefined.


# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680385(v=vs.85).aspx
class MINIDUMP_MEMORY_INFO_LIST:
	def __init__(self):
		self.SizeOfHeader = 16
		self.SizeOfEntry = 48
		self.NumberOfEntries = None
		self.entries = []

	def get_size(self):
		return self.SizeOfHeader + len(self.entries)*MINIDUMP_MEMORY_INFO().get_size()

	def to_bytes(self):
		t  = self.SizeOfHeader.to_bytes(4, byteorder = 'little', signed = False)
		t += self.SizeOfEntry.to_bytes(4, byteorder = 'little', signed = False)
		t += len(self.entries).to_bytes(8, byteorder = 'little', signed = False)
		return t

	@staticmethod
	def parse(buff):
		mhds = MINIDUMP_MEMORY_INFO_LIST()
		mhds.SizeOfHeader = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.SizeOfEntry = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.NumberOfEntries = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)

		return mhds

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680386(v=vs.85).aspx
class MINIDUMP_MEMORY_INFO:
	def __init__(self):
		self.BaseAddress = None
		self.AllocationBase = None
		self.AllocationProtect = None
		self.__alignment1 = 0
		self.RegionSize = None
		self.State = None
		self.Protect = None
		self.Type = None
		self.__alignment2 = 0

	def get_size(self):
		return 8+8+4+4+8+4+4+4+4

	def __str__(self):
		t = ''
		for k in self.__dict__:
			t += '%s : %s\r\n' % (k, str(self.__dict__[k]))
		return t

	def to_bytes(self):
		t = self.BaseAddress.to_bytes(8, byteorder = 'little', signed = False)
		t += self.AllocationBase.to_bytes(8, byteorder = 'little', signed = False)
		t += self.AllocationProtect.to_bytes(4, byteorder = 'little', signed = False)
		t += self.__alignment1.to_bytes(4, byteorder = 'little', signed = False)
		t += self.RegionSize.to_bytes(8, byteorder = 'little', signed = False)
		t += self.State.value.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Protect.value.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Type.value.to_bytes(4, byteorder = 'little', signed = False)
		t += self.__alignment2.to_bytes(4, byteorder = 'little', signed = False)
		return t

	@staticmethod
	def parse(buff):
		mmi = MINIDUMP_MEMORY_INFO()
		mmi.BaseAddress = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mmi.AllocationBase = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mmi.AllocationProtect = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mmi.__alignment1 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mmi.RegionSize = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		try:
			mmi.State = MemoryState(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		except:
			pass
		try:
			mmi.Protect = AllocationProtect(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		except:
			pass
		try:
			mmi.Type = MemoryType(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		except:
			pass
		mmi.__alignment2 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)

		return mmi

class MinidumpMemoryInfo:
	def __init__(self):
		self.BaseAddress = None
		self.AllocationBase = None
		self.AllocationProtect = None
		self.RegionSize = None
		self.State = None
		self.Protect = None
		self.Type = None

	@staticmethod
	def parse(t, buff):
		mmi = MinidumpMemoryInfo()
		mmi.BaseAddress = t.BaseAddress
		mmi.AllocationBase = t.AllocationBase
		mmi.AllocationProtect = t.AllocationProtect
		mmi.RegionSize = t.RegionSize
		mmi.State = t.State
		mmi.Protect = t.Protect
		mmi.Type = t.Type
		return mmi

	@staticmethod
	def get_header():
		t = [
			'BaseAddress',
			'AllocationBase',
			'AllocationProtect',
			'RegionSize',
			'State',
			'Protect',
			'Type',
		]
		return t

	def to_row(self):
		t = [
			hex(self.BaseAddress),
			hex(self.AllocationBase),
			str(self.AllocationProtect),
			hex(self.RegionSize),
			self.State.name if self.State else 'N/A',
			self.Protect.name if self.Protect else 'N/A',
			self.Type.name if self.Type else 'N/A',
		]
		return t


class MinidumpMemoryInfoList:
	def __init__(self):
		self.header = None
		self.infos = []

	@staticmethod
	def parse(dir, buff):
		t = MinidumpMemoryInfoList()
		buff.seek(dir.Location.Rva)
		data = buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(data)
		t.header = MINIDUMP_MEMORY_INFO_LIST.parse(chunk)
		for _ in range(t.header.NumberOfEntries):
			mi = MINIDUMP_MEMORY_INFO.parse(chunk)
			t.infos.append(MinidumpMemoryInfo.parse(mi, buff))

		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpMemoryInfoList()
		await buff.seek(dir.Location.Rva)
		data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(data)
		t.header = MINIDUMP_MEMORY_INFO_LIST.parse(chunk)
		for _ in range(t.header.NumberOfEntries):
			mi = MINIDUMP_MEMORY_INFO.parse(chunk)
			t.infos.append(MinidumpMemoryInfo.parse(mi, None))

		return t

	def to_table(self):
		t = []
		t.append(MinidumpMemoryInfo.get_header())
		for info in self.infos:
			t.append(info.to_row())
		return t

	def __str__(self):
		return '== MinidumpMemoryInfoList ==\n' + construct_table(self.to_table())
```

`src/minidump/streams/MemoryListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
from minidump.common_structs import * 

# https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_memory_list
class MINIDUMP_MEMORY_LIST:
	def __init__(self):
		self.NumberOfMemoryRanges = None
		self.MemoryRanges = []

	def to_bytes(self):
		t = len(self.MemoryRanges).to_bytes(4, byteorder = 'little', signed = False)
		for memrange in self.MemoryRanges:
			t += memrange.to_bytes()
		return t
		
	@staticmethod
	def parse(buff):
		mml = MINIDUMP_MEMORY_LIST()
		mml.NumberOfMemoryRanges = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		for _ in range(mml.NumberOfMemoryRanges):
			mml.MemoryRanges.append(MINIDUMP_MEMORY_DESCRIPTOR.parse(buff))
		
		return mml
		
	def __str__(self):
		t  = '== MINIDUMP_MEMORY_LIST ==\n'
		t += 'NumberOfMemoryRanges: %s\n' % self.NumberOfMemoryRanges
		for range in self.MemoryRanges:
			t+= str(range)
		return t

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680384(v=vs.85).aspx		
class MINIDUMP_MEMORY_DESCRIPTOR:
	def __init__(self):
		self.StartOfMemoryRange = None
		self.MemoryLocation = None
		
		#we do not use MemoryLocation but immediately store its fields in this object for easy access
		self.DataSize = None
		self.Rva = None

	def to_bytes(self):
		t = self.StartOfMemoryRange.to_bytes(4, byteorder = 'little', signed = False)
		t += self.MemoryLocation.to_bytes()
		return t
		
	@staticmethod
	def parse(buff):
		md = MINIDUMP_MEMORY_DESCRIPTOR()
		md.StartOfMemoryRange = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		
		#TODO: figure out what the documentation says, the person writign it was probably high...
		# The deal is: RVA sizes differ on where in the file the memory data is stored. but it's not possible to know it up front if we need to read 32 or 64 bytes...
		#
		#if md.StartOfMemoryRange < 0x100000000:
		#	md.MemoryLocation = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		#else:
		#	md.MemoryLocation = MINIDUMP_LOCATION_DESCRIPTOR64.parse(buff)
		
		md.MemoryLocation = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		md.DataSize = md.MemoryLocation.DataSize
		md.Rva = md.MemoryLocation.Rva
		return md
		
	def __str__(self):
		t =  'Start: %s' % hex(self.StartOfMemoryRange)
		t += 'Size: %s' % self.DataSize
		t += 'Rva: %s' % self.Rva
		return t
		
class MinidumpMemoryList:
	def __init__(self):
		self.memory_segments = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpMemoryList()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		mtl = MINIDUMP_MEMORY_LIST.parse(chunk)
		for mod in mtl.MemoryRanges:
			t.memory_segments.append(MinidumpMemorySegment.parse_mini(mod, buff))
		return t
	
	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpMemoryList()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		mtl = MINIDUMP_MEMORY_LIST.parse(chunk)
		for mod in mtl.MemoryRanges:
			t.memory_segments.append(MinidumpMemorySegment.parse_mini(mod, buff))
		return t
		
	def __str__(self):
		t  = '== MinidumpMemoryList ==\n'
		for mod in self.memory_segments:
			t+= str(mod) + '\n'
		return t
```

`src/minidump/streams/MiscInfoStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
import enum

#https://msdn.microsoft.com/en-us/library/windows/desktop/ms680388(v=vs.85).aspx	
class MinidumpMiscInfo2Flags1(enum.IntFlag):
	MINIDUMP_MISC1_PROCESS_ID = 0x00000001 #ProcessId is used.
	MINIDUMP_MISC1_PROCESS_TIMES = 0x00000002 #ProcessCreateTime, ProcessKernelTime, and ProcessUserTime are used.
	MINIDUMP_MISC1_PROCESSOR_POWER_INFO = 0x00000004 #ProcessorMaxMhz, ProcessorCurrentMhz, ProcessorMhzLimit, ProcessorMaxIdleState, and ProcessorCurrentIdleState are used.

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680389(v=vs.85).aspx
class MinidumpMiscInfoFlags1(enum.IntFlag):
	MINIDUMP_MISC1_PROCESS_ID = 0x00000001 #ProcessId is used.
	MINIDUMP_MISC1_PROCESS_TIMES = 0x00000002 #ProcessCreateTime, ProcessKernelTime, and ProcessUserTime are used.

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680389(v=vs.85).aspx
class MINIDUMP_MISC_INFO:
	size = 24
	def __init__(self):
		self.SizeOfInfo = None
		self.Flags1 = None
		self.ProcessId = None
		self.ProcessCreateTime = None
		self.ProcessUserTime = None
		self.ProcessKernelTime = None
	
	@staticmethod
	def parse(buff):
		mmi = MINIDUMP_MISC_INFO()
		mmi.SizeOfInfo = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mmi.Flags1 = MinidumpMiscInfoFlags1(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		if mmi.Flags1 & MinidumpMiscInfoFlags1.MINIDUMP_MISC1_PROCESS_ID:
			mmi.ProcessId = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		else:
			buff.read(4)
		if mmi.Flags1 & MinidumpMiscInfoFlags1.MINIDUMP_MISC1_PROCESS_TIMES:
			mmi.ProcessCreateTime = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessUserTime = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessKernelTime = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		else:
			buff.read(12)
			
		return mmi

#https://msdn.microsoft.com/en-us/library/windows/desktop/ms680388(v=vs.85).aspx		
class MINIDUMP_MISC_INFO_2:
	size = 44
	def __init__(self):
		self.SizeOfInfo = None
		self.Flags1 = None
		self.ProcessId = None
		self.ProcessCreateTime = None
		self.ProcessUserTime = None
		self.ProcessKernelTime = None
		self.ProcessorMaxMhz = None
		self.ProcessorCurrentMhz = None
		self.ProcessorMhzLimit = None
		self.ProcessorMaxIdleState = None
		self.ProcessorCurrentIdleState = None
	
	@staticmethod
	def parse(buff):
		mmi = MINIDUMP_MISC_INFO_2()
		mmi.SizeOfInfo = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mmi.Flags1 = MinidumpMiscInfo2Flags1(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		if mmi.Flags1 & MinidumpMiscInfo2Flags1.MINIDUMP_MISC1_PROCESS_ID:
			mmi.ProcessId = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		else:
			buff.read(4)
		if mmi.Flags1 & MinidumpMiscInfo2Flags1.MINIDUMP_MISC1_PROCESS_TIMES:
			mmi.ProcessCreateTime = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessUserTime = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessKernelTime = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		else:
			buff.read(12)
		if mmi.Flags1 & MinidumpMiscInfo2Flags1.MINIDUMP_MISC1_PROCESSOR_POWER_INFO:
			mmi.ProcessorMaxMhz = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessorCurrentMhz = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessorMhzLimit = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessorMaxIdleState = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessorCurrentIdleState = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		else:
			buff.read(20)
		
		return mmi
		
class MinidumpMiscInfo:
	def __init__(self):
		self.ProcessId = None
		self.ProcessCreateTime = None
		self.ProcessUserTime = None
		self.ProcessKernelTime = None
		self.ProcessorMaxMhz = None
		self.ProcessorCurrentMhz = None
		self.ProcessorMhzLimit = None
		self.ProcessorMaxIdleState = None
		self.ProcessorCurrentIdleState = None
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpMiscInfo()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		if dir.Location.DataSize == MINIDUMP_MISC_INFO.size:
			misc = MINIDUMP_MISC_INFO.parse(chunk)
			t.ProcessId = misc.ProcessId
			t.ProcessCreateTime = misc.ProcessCreateTime
			t.ProcessUserTime = misc.ProcessUserTime
			t.ProcessKernelTime = misc.ProcessKernelTime
		else:
			misc = MINIDUMP_MISC_INFO_2.parse(chunk)
			t.ProcessId = misc.ProcessId
			t.ProcessCreateTime = misc.ProcessCreateTime
			t.ProcessUserTime = misc.ProcessUserTime
			t.ProcessKernelTime = misc.ProcessKernelTime
			t.ProcessorMaxMhz = misc.ProcessorMaxMhz
			t.ProcessorCurrentMhz = misc.ProcessorCurrentMhz
			t.ProcessorMhzLimit = misc.ProcessorMhzLimit
			t.ProcessorMaxIdleState = misc.ProcessorMaxIdleState
			t.ProcessorCurrentIdleState = misc.ProcessorCurrentIdleState
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpMiscInfo()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		if dir.Location.DataSize == MINIDUMP_MISC_INFO.size:
			misc = MINIDUMP_MISC_INFO.parse(chunk)
			t.ProcessId = misc.ProcessId
			t.ProcessCreateTime = misc.ProcessCreateTime
			t.ProcessUserTime = misc.ProcessUserTime
			t.ProcessKernelTime = misc.ProcessKernelTime
		else:
			misc = MINIDUMP_MISC_INFO_2.parse(chunk)
			t.ProcessId = misc.ProcessId
			t.ProcessCreateTime = misc.ProcessCreateTime
			t.ProcessUserTime = misc.ProcessUserTime
			t.ProcessKernelTime = misc.ProcessKernelTime
			t.ProcessorMaxMhz = misc.ProcessorMaxMhz
			t.ProcessorCurrentMhz = misc.ProcessorCurrentMhz
			t.ProcessorMhzLimit = misc.ProcessorMhzLimit
			t.ProcessorMaxIdleState = misc.ProcessorMaxIdleState
			t.ProcessorCurrentIdleState = misc.ProcessorCurrentIdleState
		return t
		
	def __str__(self):
		t  = '== MinidumpMiscInfo ==\n'
		t += 'ProcessId %s\n' % self.ProcessId
		t += 'ProcessCreateTime %s\n' % self.ProcessCreateTime
		t += 'ProcessUserTime %s\n' % self.ProcessUserTime
		t += 'ProcessKernelTime %s\n' % self.ProcessKernelTime
		t += 'ProcessorMaxMhz %s\n' % self.ProcessorMaxMhz
		t += 'ProcessorCurrentMhz %s\n' % self.ProcessorCurrentMhz
		t += 'ProcessorMhzLimit %s\n' % self.ProcessorMhzLimit
		t += 'ProcessorMaxIdleState %s\n' % self.ProcessorMaxIdleState
		t += 'ProcessorCurrentIdleState %s\n' % self.ProcessorCurrentIdleState
		return t
```

`src/minidump/streams/ModuleListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
from minidump.common_structs import * 

class MinidumpModule:
	def __init__(self):
		self.name = None
		self.baseaddress = None
		self.size = None
		self.endaddress = None
		
		self.versioninfo = None
		self.checksum = None
		self.timestamp = None
		
	@staticmethod
	def parse(mod, buff):
		"""
		mod: MINIDUMP_MODULE
		buff: file handle
		"""
		mm = MinidumpModule()
		mm.baseaddress = mod.BaseOfImage
		mm.size = mod.SizeOfImage
		mm.checksum = mod.CheckSum
		mm.timestamp = mod.TimeDateStamp
		mm.name = MINIDUMP_STRING.get_from_rva(mod.ModuleNameRva, buff)
		mm.versioninfo = mod.VersionInfo
		mm.endaddress = mm.baseaddress + mm.size
		return mm

	@staticmethod
	async def aparse(mod, buff):
		"""
		mod: MINIDUMP_MODULE
		buff: file handle
		"""
		mm = MinidumpModule()
		mm.baseaddress = mod.BaseOfImage
		mm.size = mod.SizeOfImage
		mm.checksum = mod.CheckSum
		mm.timestamp = mod.TimeDateStamp
		mm.name = await MINIDUMP_STRING.aget_from_rva(mod.ModuleNameRva, buff)
		mm.versioninfo = mod.VersionInfo
		mm.endaddress = mm.baseaddress + mm.size
		return mm
		
	def inrange(self, memory_loc):
		return self.baseaddress <= memory_loc < self.endaddress
	
	@staticmethod
	def get_header():
		return [
			'Module name',
			'BaseAddress',
			'Size',
			'Endaddress',
			'Timestamp',
		]
	
	def to_row(self):
		return [
			str(self.name),
			'0x%08x' % self.baseaddress,
			hex(self.size),
			'0x%08x' % self.endaddress,
			'0x%08x' % self.timestamp,
		]
		
		
	def __str__(self):
		return 'Module name: %s BaseAddress: 0x%08x Size: 0x%x Endaddress: 0x%08x' % (self.name, self.baseaddress, self.size, self.endaddress)
		
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms646997(v=vs.85).aspx
class VS_FIXEDFILEINFO:
	def __init__(self):
		self.dwSignature = None
		self.dwStrucVersion = None
		self.dwFileVersionMS = None
		self.dwFileVersionLS = None
		self.dwProductVersionMS = None
		self.dwProductVersionLS = None
		self.dwFileFlagsMask = None
		self.dwFileFlags = None
		self.dwFileOS = None
		self.dwFileType = None
		self.dwFileSubtype = None
		self.dwFileDateMS = None
		self.dwFileDateLS = None

	def get_size(self):
		return 13*4

	def to_bytes(self):
		t = self.dwSignature.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwStrucVersion.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileVersionMS.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileVersionLS.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwProductVersionMS.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwProductVersionLS.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileFlagsMask.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileFlags.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileOS.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileType.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileSubtype.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileDateMS.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileDateLS.to_bytes(4, byteorder = 'little', signed = False)
		return t
	
	@staticmethod
	def from_bytes(data):
		return VS_FIXEDFILEINFO.parse(io.BytesIO(data))

	@staticmethod
	def parse(buff):
		vf = VS_FIXEDFILEINFO()
		vf.dwSignature = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwStrucVersion = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileVersionMS = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileVersionLS = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwProductVersionMS = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwProductVersionLS = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileFlagsMask = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileFlags = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileOS = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileType = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileSubtype = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileDateMS = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileDateLS = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		return vf

	def __str__(self):
		t = ''
		for k in self.__dict__:
			t += '%s : %s\r\n' % (k, str(self.__dict__[k]))
		return t

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680392(v=vs.85).aspx
class MINIDUMP_MODULE:
	def __init__(self):
		self.BaseOfImage = None
		self.SizeOfImage = None
		self.CheckSum = 0
		self.TimeDateStamp = None
		self.ModuleNameRva = None
		self.VersionInfo = None
		self.CvRecord = None
		self.MiscRecord = None
		self.Reserved0 = 0
		self.Reserved1 = 0

		#for writer
		self.ModuleName = None

	def get_size(self):
		return 8+4+4+4+4+8+8+VS_FIXEDFILEINFO().get_size() + 2 * MINIDUMP_LOCATION_DESCRIPTOR().get_size()

	def to_bytes(self):
		t = self.BaseOfImage.to_bytes(8, byteorder = 'little', signed = False)
		t += self.SizeOfImage.to_bytes(4, byteorder = 'little', signed = False)
		t += self.CheckSum.to_bytes(4, byteorder = 'little', signed = False)
		t += self.TimeDateStamp.to_bytes(4, byteorder = 'little', signed = False)
		t += self.ModuleNameRva.to_bytes(4, byteorder = 'little', signed = False)
		t += self.VersionInfo.to_bytes()
		t += self.CvRecord.to_bytes()
		t += self.MiscRecord.to_bytes()
		t += self.Reserved0.to_bytes(8, byteorder = 'little', signed = False)
		t += self.Reserved1.to_bytes(8, byteorder = 'little', signed = False)
		return t
		
	@staticmethod
	def parse(buff):
		mm = MINIDUMP_MODULE()
		mm.BaseOfImage = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mm.SizeOfImage = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mm.CheckSum = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mm.TimeDateStamp = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mm.ModuleNameRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mm.VersionInfo = VS_FIXEDFILEINFO.parse(buff)
		mm.CvRecord = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		mm.MiscRecord = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		mm.Reserved0 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mm.Reserved1 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		return mm

	def __str__(self):
		t = ''
		for k in self.__dict__:
			t += '%s : %s\r\n' % (k, str(self.__dict__[k]))
		return t
  
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680391(v=vs.85).aspx
class MINIDUMP_MODULE_LIST:
	def __init__(self):
		self.NumberOfModules = None
		self.Modules = []

	def get_size(self):
		return 4 + len(self.Modules) * MINIDUMP_MODULE().get_size()

	def to_bytes(self):
		t = len(self.Modules).to_bytes(4, byteorder = 'little', signed = False)
		for module in self.Modules:
			t += module.to_bytes()
		return t
	
	@staticmethod
	def parse(buff):
		mml = MINIDUMP_MODULE_LIST()
		mml.NumberOfModules = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		for _ in range(mml.NumberOfModules):
			mml.Modules.append(MINIDUMP_MODULE.parse(buff))
			
		return mml
		
class MinidumpModuleList:
	def __init__(self):
		self.modules = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpModuleList()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		mtl = MINIDUMP_MODULE_LIST.parse(chunk)
		for mod in mtl.Modules:
			t.modules.append(MinidumpModule.parse(mod, buff))
		return t
	
	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpModuleList()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		mtl = MINIDUMP_MODULE_LIST.parse(chunk)
		for mod in mtl.Modules:
			x = await MinidumpModule.aparse(mod, buff)
			t.modules.append(x)
		return t
		
	def to_table(self):
		t = []
		t.append(MinidumpModule.get_header())
		for mod in self.modules:
			t.append(mod.to_row())
		return t
		
	def __str__(self):
		t  = '== ModuleList ==\n' + construct_table(self.to_table())
		return t
		
```

`src/minidump/streams/ProcessVmCountersStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
# TODO: MSD article is missing on this stream :(
```

`src/minidump/streams/SystemInfoStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

import io
import enum
import logging
from minidump.common_structs import *

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680396(v=vs.85).aspx
class PROCESSOR_ARCHITECTURE(enum.Enum):
	AMD64 = 9 #x64 (AMD or Intel)
	ARM = 5 #ARM
	IA64 = 6 #Intel Itanium
	INTEL = 0 #x86
	AARCH64 = 0x8003 #ARM64
	UNKNOWN = 0xffff #Unknown processor
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680396(v=vs.85).aspx
class PROCESSOR_LEVEL(enum.Enum):
	INTEL_80386 = 3
	INTEL_80486 = 4
	INTEL_PENTIUM = 5
	INTEL_PENTIUM_PRO = 6 #or Pentium II
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680396(v=vs.85).aspx
class PRODUCT_TYPE(enum.Enum):
	VER_UNIDENTIFIED_PRODUCT 	= 0x0000000 # Crashpad des not set ProductType value on non-Windows systems
	VER_NT_WORKSTATION 			= 0x0000001 # The system is running Windows XP, Windows Vista, Windows 7, or Windows 8.
	VER_NT_DOMAIN_CONTROLLER 	= 0x0000002 # The system is a domain controller.
	VER_NT_SERVER 				= 0x0000003 # The system is a server.

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680396(v=vs.85).aspx
class PLATFORM_ID(enum.Enum):
	VER_PLATFORM_WIN32s = 0 #Not supported
	VER_PLATFORM_WIN32_WINDOWS = 1 #Not supported.
	VER_PLATFORM_WIN32_NT = 2 #The operating system platform is Windows.

	# source : https://github.com/chromium/crashpad/blob/4b05be4265c0ffacfce26d7db7644ffbf9037696/minidump/minidump_extensions.h#L239
	VER_PLATFORM_CRASHPAD_MAC       = 0x8101
	VER_PLATFORM_CRASHPAD_IOS       = 0x8102
	VER_PLATFORM_CRASHPAD_LINUX 	= 0x8201
	VER_PLATFORM_CRASHPAD_SOLARIS 	= 0x8202
	VER_PLATFORM_CRASHPAD_ANDROID 	= 0x8203
	VER_PLATFORM_CRASHPAD_PS3       = 0x8204
	VER_PLATFORM_CRASHPAD_NACL      = 0x8205
	VER_PLATFORM_CRASHPAD_FUSCHIA 	= 0x8206
	VER_PLATFORM_CRASHPAD_UNKNOWN 	= 0xffffffff

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680396(v=vs.85).aspx
class SUITE_MASK(enum.IntFlag):
	VER_SUITE_BACKOFFICE = 0x00000004 #Microsoft BackOffice components are installed.
	VER_SUITE_BLADE = 0x00000400 #Windows Server 2003, Web Edition is installed.
	VER_SUITE_COMPUTE_SERVER = 0x00004000 #Windows Server 2003, Compute Cluster Edition is installed.
	VER_SUITE_DATACENTER = 0x00000080 #Windows Server 2008 R2 Datacenter, Windows Server 2008 Datacenter, or Windows Server 2003, Datacenter Edition is installed.
	VER_SUITE_ENTERPRISE = 0x00000002 #Windows Server 2008 R2 Enterprise, Windows Server 2008 Enterprise, or Windows Server 2003, Enterprise Edition is installed.
	VER_SUITE_EMBEDDEDNT = 0x00000040 #Windows Embedded is installed.
	VER_SUITE_PERSONAL = 0x00000200 #Windows XP Home Edition is installed.
	VER_SUITE_SINGLEUSERTS = 0x00000100 #Remote Desktop is supported, but only one interactive session is supported. This value is set unless the system is running in application server mode.
	VER_SUITE_SMALLBUSINESS = 0x00000001 #Microsoft Small Business Server was once installed on the system, but may have been upgraded to another version of Windows.
	VER_SUITE_SMALLBUSINESS_RESTRICTED = 0x00000020 #Microsoft Small Business Server is installed with the restrictive client license in force.
	VER_SUITE_STORAGE_SERVER = 0x00002000 #Windows Storage Server is installed.
	VER_SUITE_TERMINAL = 0x00000010 # Terminal Services is installed. This value is always set. If VER_SUITE_TERMINAL is set but VER_SUITE_SINGLEUSERTS is not set, the system is running in application server mode.


# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680396(v=vs.85).aspx
class MINIDUMP_SYSTEM_INFO:
	def __init__(self):
		self.ProcessorArchitecture = None
		self.ProcessorLevel = None
		self.ProcessorRevision = None
		self.Reserved0 = None
		self.NumberOfProcessors = None
		self.ProductType = None
		self.MajorVersion = None
		self.MinorVersion = None
		self.BuildNumber = None
		self.PlatformId = None
		self.CSDVersionRva = None
		self.Reserved1 = 0
		self.SuiteMask = None
		self.Reserved2 = 0
		self.VendorId = []
		self.VersionInformation = None
		self.FeatureInformation = None
		self.AMDExtendedCpuFeatures = None
		self.ProcessorFeatures = []

		#for wrtier
		self.CSDVersion = None

	def get_size(self):
		# here we cannot tell upfront what the size will be :(
		return len(self.to_bytes())

	def to_bytes(self, data_buffer = None):
		t = self.ProcessorArchitecture.value.to_bytes(2, byteorder = 'little', signed = False)
		t += self.ProcessorLevel.to_bytes(2, byteorder = 'little', signed = False)
		t += self.ProcessorRevision.to_bytes(2, byteorder = 'little', signed = False)
		#missing filed here?
		t += self.NumberOfProcessors.to_bytes(1, byteorder = 'little', signed = False)
		t += self.ProductType.value.to_bytes(1, byteorder = 'little', signed = False)
		t += self.MajorVersion.to_bytes(4, byteorder = 'little', signed = False)
		t += self.MinorVersion.to_bytes(4, byteorder = 'little', signed = False)
		t += self.BuildNumber.to_bytes(4, byteorder = 'little', signed = False)
		t += self.PlatformId.to_bytes(4, byteorder = 'little', signed = False)
		if data_buffer is None:
			t += self.CSDVersionRva.to_bytes(4, byteorder = 'little', signed = False)
		else:
			pos = data_buffer.tell()
			data_buffer.write(100*b'\x00')
			self.CSDVersionRva = data_buffer.tell()
			data_buffer.write(self.CSDVersion.encode('ascii') + b'\x00')
			pos_end = data_buffer.tell()
			data_buffer.seek(pos,0)
			t += self.CSDVersionRva.to_bytes(4, byteorder = 'little', signed = False)
		#missing filed here?
		t += self.SuiteMask.to_bytes(2, byteorder = 'little', signed = False)
		t += self.Reserved2.to_bytes(2, byteorder = 'little', signed = False)
		if self.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.INTEL:
			for vid in self.VendorId:
				t += vid.to_bytes(4, byteorder = 'little', signed = False)
			t += self.VersionInformation.value.to_bytes(4, byteorder = 'little', signed = False)
			t += self.FeatureInformation.value.to_bytes(4, byteorder = 'little', signed = False)
			t += self.AMDExtendedCpuFeatures.value.to_bytes(4, byteorder = 'little', signed = False)
		else:
			for pf in self.ProcessorFeatures:
				t += pf.to_bytes(8, byteorder = 'little', signed = False)

		if data_buffer is None:
			return t
		else:
			data_buffer.write(t)

	@staticmethod
	def parse(buff):
		msi = MINIDUMP_SYSTEM_INFO()
		msi.ProcessorArchitecture = PROCESSOR_ARCHITECTURE(int.from_bytes(buff.read(2), byteorder = 'little', signed = False))
		msi.ProcessorLevel = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
		msi.ProcessorRevision = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
		#the below field is present in the documentation from MSDN, however is not present in the actual dump
		#msi.Reserved0 = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
		msi.NumberOfProcessors = int.from_bytes(buff.read(1), byteorder = 'little', signed = False)
		msi.ProductType = PRODUCT_TYPE(int.from_bytes(buff.read(1), byteorder = 'little', signed = False))
		msi.MajorVersion = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		msi.MinorVersion = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		msi.BuildNumber = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		msi.PlatformId = PLATFORM_ID(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		msi.CSDVersionRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		#msi.Reserved1 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		msi.SuiteMask = SUITE_MASK(int.from_bytes(buff.read(2), byteorder = 'little', signed = False))
		msi.Reserved2 = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
		if msi.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.INTEL:
			for _ in range(3):
				msi.VendorId.append(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
			msi.VersionInformation = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			msi.FeatureInformation = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			msi.AMDExtendedCpuFeatures = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		else:
			for _ in range(2):
				msi.ProcessorFeatures.append(int.from_bytes(buff.read(8), byteorder = 'little', signed = False))

		return msi

	def __str__(self):
		t = ''
		for k in self.__dict__:
			t += '%s : %s\r\n' % (k, str(self.__dict__[k]))
		return t

class MinidumpSystemInfo:
	def __init__(self):
		self.ProcessorArchitecture = None
		self.ProcessorLevel = None
		self.ProcessorRevision = None
		self.NumberOfProcessors = None
		self.ProductType = None
		self.MajorVersion = None
		self.MinorVersion = None
		self.BuildNumber = None
		self.PlatformId = None
		self.CSDVersion = None
		self.SuiteMask = None
		self.VendorId = None
		self.VersionInformation = None
		self.FeatureInformation = None
		self.AMDExtendedCpuFeatures = None
		self.ProcessorFeatures = None

		#extra
		self.OperatingSystem = None

	def guess_os(self):
		if self.MajorVersion == 10 and self.MinorVersion == 0 and self.ProductType == PRODUCT_TYPE.VER_NT_WORKSTATION:
			self.OperatingSystem = "Windows 10"
		elif self.MajorVersion == 10 and self.MinorVersion == 0 and self.ProductType != self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows Server 2016 Technical Preview"
		elif self.MajorVersion == 6 and self.MinorVersion == 3 and self.ProductType == self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows 8.1"
		elif self.MajorVersion == 6 and self.MinorVersion == 3 and self.ProductType != self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows Server 2012 R2"
		elif self.MajorVersion == 6 and self.MinorVersion == 2 and self.ProductType == self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows 8"
		elif self.MajorVersion == 6 and self.MinorVersion == 2 and self.ProductType != self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows Server 2012"
		elif self.MajorVersion == 6 and self.MinorVersion == 1 and self.ProductType == self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows 7"
		elif self.MajorVersion == 6 and self.MinorVersion == 1 and self.ProductType != self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows Server 2008 R2"
		elif self.MajorVersion == 6 and self.MinorVersion == 0 and self.ProductType == self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows Vista"
		elif self.MajorVersion == 6 and self.MinorVersion == 0 and self.ProductType != self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows Server 2008"
		# Can't accurately report on Windows Server 2003/R2
		# elif (MajorVersion == 5 and MinorVersion == 2 and ProductType == self.ProductType.VER_NT_WORKSTATION)
		#	self.OperatingSystem =  "Windows Vista"
		#elif (MajorVersion == 5 and MinorVersion == 2 and ProductType != self.ProductType.VER_NT_WORKSTATION)
		#	self.OperatingSystem =  "Windows Server 2008"
		elif self.MajorVersion == 5 and self.MinorVersion == 1:
			self.OperatingSystem =  "Windows XP"
		elif self.MajorVersion == 5 and self.MinorVersion == 0:
			self.OperatingSystem =  "Windows 2000"

	@staticmethod
	def parse(dir, buff):
		t = MinidumpSystemInfo()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		si = MINIDUMP_SYSTEM_INFO.parse(chunk)
		t.ProcessorArchitecture = si.ProcessorArchitecture
		t.ProcessorLevel = si.ProcessorLevel
		t.ProcessorRevision = si.ProcessorRevision
		t.NumberOfProcessors = si.NumberOfProcessors
		t.ProductType = si.ProductType
		t.MajorVersion = si.MajorVersion
		t.MinorVersion = si.MinorVersion
		t.BuildNumber = si.BuildNumber
		t.PlatformId = si.PlatformId
		t.CSDVersion = MINIDUMP_STRING.get_from_rva(si.CSDVersionRva, buff)
		t.SuiteMask = si.SuiteMask
		t.VendorId = si.VendorId
		t.VersionInformation = si.VersionInformation
		t.FeatureInformation = si.FeatureInformation
		t.AMDExtendedCpuFeatures = si.AMDExtendedCpuFeatures
		t.ProcessorFeatures = si.ProcessorFeatures
		try:
			t.guess_os()
		except Exception as e:
			logging.log(1, 'Failed to guess OS! MajorVersion: %s MinorVersion %s BuildNumber %s ProductType: %s' % (t.MajorVersion, t.MinorVersion, t.BuildNumber, t.ProductType ))
			t.OperatingSystem = None
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpSystemInfo()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		si = MINIDUMP_SYSTEM_INFO.parse(chunk)
		t.ProcessorArchitecture = si.ProcessorArchitecture
		t.ProcessorLevel = si.ProcessorLevel
		t.ProcessorRevision = si.ProcessorRevision
		t.NumberOfProcessors = si.NumberOfProcessors
		t.ProductType = si.ProductType
		t.MajorVersion = si.MajorVersion
		t.MinorVersion = si.MinorVersion
		t.BuildNumber = si.BuildNumber
		t.PlatformId = si.PlatformId
		t.CSDVersion = await MINIDUMP_STRING.aget_from_rva(si.CSDVersionRva, buff)
		t.SuiteMask = si.SuiteMask
		t.VendorId = si.VendorId
		t.VersionInformation = si.VersionInformation
		t.FeatureInformation = si.FeatureInformation
		t.AMDExtendedCpuFeatures = si.AMDExtendedCpuFeatures
		t.ProcessorFeatures = si.ProcessorFeatures
		try:
			t.guess_os()
		except Exception as e:
			logging.log(1, 'Failed to guess OS! MajorVersion: %s MinorVersion %s BuildNumber %s ProductType: %s' % (t.MajorVersion, t.MinorVersion, t.BuildNumber, t.ProductType ))
			t.OperatingSystem = None
		return t


	def __str__(self):
		t = '== System Info ==\n'
		t += 'ProcessorArchitecture %s\n' % self.ProcessorArchitecture
		t += 'OperatingSystem -guess- %s\n' % self.OperatingSystem
		t += 'ProcessorLevel %s\n' % self.ProcessorLevel
		t += 'ProcessorRevision %s\n' % hex(self.ProcessorRevision)
		t += 'NumberOfProcessors %s\n' % self.NumberOfProcessors
		t += 'ProductType %s\n' % self.ProductType
		t += 'MajorVersion %s\n' % self.MajorVersion
		t += 'MinorVersion %s\n' % self.MinorVersion
		t += 'BuildNumber %s\n' % self.BuildNumber
		t += 'PlatformId %s\n' % self.PlatformId
		t += 'CSDVersion: %s\n' % self.CSDVersion
		t += 'SuiteMask %s\n' % self.SuiteMask
		t += 'VendorId %s\n' % ' '.join( [hex(x) for x in self.VendorId] )
		t += 'VersionInformation %s\n' % self.VersionInformation
		t += 'FeatureInformation %s\n' % self.FeatureInformation
		t += 'AMDExtendedCpuFeatures %s\n' % self.AMDExtendedCpuFeatures
		t += 'ProcessorFeatures %s\n' % ' '.join( [hex(x) for x in self.ProcessorFeatures] )

		return t

```

`src/minidump/streams/SystemMemoryInfoStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
# TODO: Not documented in MSDN :(
```

`src/minidump/streams/ThreadExListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

import io
from minidump.common_structs import * 
from minidump.streams.MemoryListStream import MINIDUMP_MEMORY_DESCRIPTOR

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680399(v=vs.85).aspx
class MINIDUMP_THREAD_EX_LIST:
	def __init__(self):
		self.NumberOfThreads = None
		self.Threads = []
	
	@staticmethod
	def parse(buff):
		mtel = MINIDUMP_THREAD_EX_LIST()
		mtel.NumberOfThreads = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		for _ in range(mtel.NumberOfThreads):
			mtel.Threads.append(MINIDUMP_THREAD_EX.parse(buff))
		
		return mtel
		
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680400(v=vs.85).aspx
class MINIDUMP_THREAD_EX:
	def __init__(self):
		self.ThreadId = None
		self.SuspendCount = None
		self.PriorityClass = None
		self.Priority = None
		self.Teb = None
		self.Stack = None
		self.ThreadContext = None
		self.BackingStore = None
	
	@staticmethod
	def parse(buff):
		mte = MINIDUMP_THREAD_EX()
		mte.ThreadId = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mte.SuspendCount = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mte.PriorityClass = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mte.Priority = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mte.Teb = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mte.Stack = MINIDUMP_MEMORY_DESCRIPTOR.parse(buff)
		mte.ThreadContext = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		mte.BackingStore = MINIDUMP_MEMORY_DESCRIPTOR.parse(buff)
		return mte
	
	@staticmethod
	def get_header():
		return [
			'ThreadId',
			'SuspendCount',
			'PriorityClass',
			'Priority',
			'Teb',
			#'Stack',
			#'ThreadContext',
		]
	
	def to_row(self):
		return [
			hex(self.ThreadId),
			str(self.SuspendCount),
			str(self.PriorityClass),
			str(self.Priority),
			hex(self.Teb),
			#self.Stack,
			#self.ThreadContext,
		]
		
		
class MinidumpThreadExList:
	def __init__(self):
		self.threads = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpThreadExList()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		mtl = MINIDUMP_THREAD_EX_LIST.parse(chunk)
		t.threads = mtl.Threads
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpThreadExList()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		mtl = MINIDUMP_THREAD_EX_LIST.parse(chunk)
		t.threads = mtl.Threads
		return t
	
	def to_table(self):
		t = []
		t.append(MINIDUMP_THREAD_EX.get_header())
		for thread in self.threads:
			t.append(thread.to_row())
		return t
		
	def __str__(self):
		return '== ThreadExList ==\n' + construct_table(self.to_table())	
	
```

`src/minidump/streams/ThreadInfoListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
import enum
from minidump.common_structs import * 

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680510(v=vs.85).aspx
class DumpFlags(enum.Enum):
	MINIDUMP_THREAD_INFO_ERROR_THREAD = 0x00000001 #A placeholder thread due to an error accessing the thread. No thread information exists beyond the thread identifier.
	MINIDUMP_THREAD_INFO_EXITED_THREAD = 0x00000004 #The thread has exited (not running any code) at the time of the dump.
	MINIDUMP_THREAD_INFO_INVALID_CONTEXT = 0x00000010 #Thread context could not be retrieved.
	MINIDUMP_THREAD_INFO_INVALID_INFO = 0x00000008 #Thread information could not be retrieved.
	MINIDUMP_THREAD_INFO_INVALID_TEB = 0x00000020 #TEB information could not be retrieved.
	MINIDUMP_THREAD_INFO_WRITING_THREAD = 0x00000002 #This is the thread that called MiniDumpWriteDump.

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680506(v=vs.85).aspx
class MINIDUMP_THREAD_INFO_LIST:
	def __init__(self):
		self.SizeOfHeader = None
		self.SizeOfEntry = None
		self.NumberOfEntries = None
	
	def to_bytes(self):
		t = self.SizeOfHeader.value.to_bytes(4, byteorder = 'little', signed = False)
		t += self.SizeOfEntry.to_bytes(4, byteorder = 'little', signed = False)
		t += self.NumberOfEntries.to_bytes(4, byteorder = 'little', signed = False)
		return t

	@staticmethod
	def parse(buff):
		mtil = MINIDUMP_THREAD_INFO_LIST()
		mtil.SizeOfHeader = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mtil.SizeOfEntry = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mtil.NumberOfEntries = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		
		return mtil
		
	
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680510(v=vs.85).aspx
class MINIDUMP_THREAD_INFO:
	def __init__(self):
		self.ThreadId = None
		self.DumpFlags = None
		self.DumpError = None
		self.ExitStatus = None
		self.CreateTime = None
		self.ExitTime = None
		self.KernelTime = None
		self.UserTime = None
		self.StartAddress = None
		self.Affinity = None

	def to_bytes(self):
		t = self.ThreadId.value.to_bytes(4, byteorder = 'little', signed = False)
		if self.DumpFlags:
			t += self.DumpFlags.value.to_bytes(4, byteorder = 'little', signed = False)
		else:
			t += b'\x00'*4
		t += self.DumpError.to_bytes(4, byteorder = 'little', signed = False)
		t += self.ExitStatus.to_bytes(4, byteorder = 'little', signed = False)
		t += self.CreateTime.to_bytes(8, byteorder = 'little', signed = False)
		t += self.ExitTime.to_bytes(8, byteorder = 'little', signed = False)
		t += self.KernelTime.to_bytes(8, byteorder = 'little', signed = False)
		t += self.UserTime.to_bytes(8, byteorder = 'little', signed = False)
		t += self.StartAddress.to_bytes(8, byteorder = 'little', signed = False)
		t += self.Affinity.to_bytes(8, byteorder = 'little', signed = False)
		return t
	
	@staticmethod
	def parse(buff):
		mti = MINIDUMP_THREAD_INFO()
		mti.ThreadId = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		try:
			mti.DumpFlags = DumpFlags(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		except:
			pass
		mti.DumpError = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mti.ExitStatus = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mti.CreateTime = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mti.ExitTime = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mti.KernelTime = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mti.UserTime = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mti.StartAddress = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mti.Affinity = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		return mti
		
class MinidumpThreadInfo:
	def __init__(self):
		self.ThreadId = None
		self.DumpFlags = None
		self.DumpError = None
		self.ExitStatus = None
		self.CreateTime = None
		self.ExitTime = None
		self.KernelTime = None
		self.UserTime = None
		self.StartAddress = None
		self.Affinity = None
	
	@staticmethod
	def parse(t, buff):
		mti = MinidumpThreadInfo()
		mti.ThreadId = t.ThreadId
		mti.DumpFlags = t.DumpFlags
		mti.DumpError = t.DumpError
		mti.ExitStatus = t.ExitStatus
		mti.CreateTime = t.CreateTime
		mti.ExitTime = t.ExitTime
		mti.KernelTime = t.KernelTime
		mti.UserTime = t.UserTime
		mti.StartAddress = t.StartAddress
		mti.Affinity = t.Affinity
		return mti
	
	@staticmethod
	def get_header():
		return [
			'ThreadId',
			'DumpFlags',
			'DumpError',
			'ExitStatus',
			'CreateTime',
			'ExitTime',
			'KernelTime',
			'UserTime',
			'StartAddress',
			'Affinity',
		]
	
	def to_row(self):
		return [
			hex(self.ThreadId),
			str(self.DumpFlags),
			str(self.DumpError),
			hex(self.ExitStatus),
			str(self.CreateTime),
			str(self.ExitTime),
			str(self.KernelTime),
			str(self.UserTime),
			hex(self.StartAddress),
			str(self.Affinity),
		]
		
	def __str__(self):
		return 'ThreadId: %x DumpFlags: %s DumpError: %s ExitStatus: %x CreateTime: %s ExitTime: %s KernelTime: %s UserTime: %s StartAddress: %x Affinity: %d' % \
			(self.ThreadId, self.DumpFlags, self.DumpError, self.ExitStatus, self.CreateTime, self.ExitTime, self.KernelTime, self.UserTime, self.StartAddress, self.Affinity)
		
class MinidumpThreadInfoList:
	def __init__(self):
		self.header = None
		self.infos = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpThreadInfoList()
		buff.seek(dir.Location.Rva)
		data = buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(data)
		t.header = MINIDUMP_THREAD_INFO_LIST.parse(chunk)
		for _ in range(t.header.NumberOfEntries):
			mi = MINIDUMP_THREAD_INFO.parse(chunk)
			t.infos.append(MinidumpThreadInfo.parse(mi, buff))
		
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpThreadInfoList()
		await buff.seek(dir.Location.Rva)
		data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(data)
		t.header = MINIDUMP_THREAD_INFO_LIST.parse(chunk)
		for _ in range(t.header.NumberOfEntries):
			mi = MINIDUMP_THREAD_INFO.parse(chunk)
			t.infos.append(MinidumpThreadInfo.parse(mi, None))
		
		return t
		
	def to_table(self):
		t = []
		t.append(MinidumpThreadInfo.get_header())
		for info in self.infos:
			t.append(info.to_row())
		return t
		
	def __str__(self):
		return '== ThreadInfoList ==\n' + construct_table(self.to_table())	
	
```

`src/minidump/streams/ThreadListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
from minidump.common_structs import * 
from minidump.streams.MemoryListStream import MINIDUMP_MEMORY_DESCRIPTOR

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680515(v=vs.85).aspx
class MINIDUMP_THREAD_LIST:
	def __init__(self):
		self.NumberOfThreads = None
		self.Threads = []

	def to_bytes(self):
		t = len(self.Threads).to_bytes(4, byteorder = 'little', signed = False)
		for th in self.Threads:
			t += th.to_bytes()
		return t
	
	@staticmethod
	def parse(buff):
		mtl = MINIDUMP_THREAD_LIST()
		mtl.NumberOfThreads = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		for _ in range(mtl.NumberOfThreads):
			mtl.Threads.append(MINIDUMP_THREAD.parse(buff))
		return mtl
	
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680517(v=vs.85).aspx	
class MINIDUMP_THREAD:
	def __init__(self):
		self.ThreadId = None
		self.SuspendCount = None
		self.PriorityClass = None
		self.Priority = None
		self.Teb = None
		self.Stack = None
		self.ThreadContext = None

	def to_bytes(self):
		t  = self.ThreadId.value.to_bytes(4, byteorder = 'little', signed = False)
		t += self.SuspendCount.to_bytes(4, byteorder = 'little', signed = False)
		t += self.PriorityClass.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Priority.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Teb.to_bytes(8, byteorder = 'little', signed = False)
		t += self.Stack.to_bytes()
		t += self.ThreadContext.to_bytes()
		return t
	
	@staticmethod
	def parse(buff):
		mt = MINIDUMP_THREAD()
		mt.ThreadId = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mt.SuspendCount = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mt.PriorityClass = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mt.Priority = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mt.Teb = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mt.Stack = MINIDUMP_MEMORY_DESCRIPTOR.parse(buff)
		mt.ThreadContext = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		
		return mt
	
	@staticmethod
	def get_header():
		return [
			'ThreadId',
			'SuspendCount',
			'PriorityClass',
			'Priority',
			'Teb',
			#'Stack',
			#'ThreadContext',
		]
	
	def to_row(self):
		return [
			hex(self.ThreadId),
			str(self.SuspendCount),
			str(self.PriorityClass),
			str(self.Priority),
			hex(self.Teb),
			#self.Stack,
			#self.ThreadContext,
		]
		
class MinidumpThreadList:
	def __init__(self):
		self.threads = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpThreadList()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		mtl = MINIDUMP_THREAD_LIST.parse(chunk)
		t.threads = mtl.Threads
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpThreadList()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		mtl = MINIDUMP_THREAD_LIST.parse(chunk)
		t.threads = mtl.Threads
		return t
		
	def to_table(self):
		t = []
		t.append(MINIDUMP_THREAD.get_header())
		for thread in self.threads:
			t.append(thread.to_row())
		return t
		
	def __str__(self):
		return 'ThreadList\n' + construct_table(self.to_table())
```

`src/minidump/streams/TokenStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
# TODO: implement this, no MSDN aricle
```

`src/minidump/streams/UnloadedModuleListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

import io
from minidump.common_structs import * 

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680521(v=vs.85).aspx
class MINIDUMP_UNLOADED_MODULE_LIST:
	def __init__(self):
		self.SizeOfHeader = None
		self.SizeOfEntry = None
		self.NumberOfEntries = None

	def to_bytes(self):
		t  = self.SizeOfHeader.value.to_bytes(4, byteorder = 'little', signed = False)
		t += self.SizeOfEntry.to_bytes(4, byteorder = 'little', signed = False)
		t += self.NumberOfEntries.to_bytes(4, byteorder = 'little', signed = False)
		return t
	
	@staticmethod
	def parse(buff):
		muml = MINIDUMP_UNLOADED_MODULE_LIST()
		muml.SizeOfHeader = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		muml.SizeOfEntry = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		muml.NumberOfEntries = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		return muml
	
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680523(v=vs.85).aspx
class MINIDUMP_UNLOADED_MODULE:
	def __init__(self):
		self.BaseOfImage = None
		self.SizeOfImage = None
		self.CheckSum = None
		self.TimeDateStamp = None
		self.ModuleNameRva = None

	def to_bytes(self):
		t  = self.BaseOfImage.value.to_bytes(8, byteorder = 'little', signed = False)
		t += self.SizeOfImage.to_bytes(4, byteorder = 'little', signed = False)
		t += self.CheckSum.to_bytes(4, byteorder = 'little', signed = False)
		t += self.TimeDateStamp.to_bytes(4, byteorder = 'little', signed = False)
		t += self.ModuleNameRva.to_bytes(4, byteorder = 'little', signed = False)
		return t
	
	@staticmethod
	def parse(buff):
		mum = MINIDUMP_UNLOADED_MODULE()
		mum.BaseOfImage = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mum.SizeOfImage = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mum.CheckSum = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mum.TimeDateStamp = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mum.ModuleNameRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		return mum

class MinidumpUnloadedModule:
	def __init__(self):
		self.name = None
		self.baseaddress = None
		self.size = None
		self.endaddress = None
		self.memorysegments = [] #list of memory segments the module takes place in
		
		self.checksum = None
		self.timestamp = None
	
	@staticmethod
	def parse(mod, buff):
		"""
		mod: MINIDUMP_MODULE
		buff: file handle
		"""
		mm = MinidumpUnloadedModule()
		mm.baseaddress = mod.BaseOfImage
		mm.size = mod.SizeOfImage
		mm.checksum = mod.CheckSum
		mm.timestamp = mod.TimeDateStamp
		mm.name = MINIDUMP_STRING.get_from_rva(mod.ModuleNameRva, buff)
		mm.endaddress = mm.baseaddress + mm.size
		return mm

	@staticmethod
	async def aparse(mod, buff):
		"""
		mod: MINIDUMP_MODULE
		buff: file handle
		"""
		mm = MinidumpUnloadedModule()
		mm.baseaddress = mod.BaseOfImage
		mm.size = mod.SizeOfImage
		mm.checksum = mod.CheckSum
		mm.timestamp = mod.TimeDateStamp
		mm.name = await MINIDUMP_STRING.aget_from_rva(mod.ModuleNameRva, buff)
		mm.endaddress = mm.baseaddress + mm.size
		return mm
		
	def assign_memory_regions(self, segments):
		for segment in segments:
			if self.baseaddress <= segment.start_virtual_address < self.endaddress:
				self.memorysegments.append(segment)
		
	def __str__(self):
		return 'Unloaded Module name: %s Size: %s BaseAddress: %s' % (self.name, hex(self.size), hex(self.baseaddress))	

	@staticmethod
	def get_header():
		return [
			'Module name',
			'BaseAddress',
			'Size',
			'Endaddress',
		]
	
	def to_row(self):
		return [
			str(self.name),
			'0x%08x' % self.baseaddress,
			hex(self.size),
			'0x%08x' % self.endaddress,
		]
		
	
class MinidumpUnloadedModuleList:
	def __init__(self):
		self.modules = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpUnloadedModuleList()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		muml = MINIDUMP_UNLOADED_MODULE_LIST.parse(chunk)
		for _ in range(muml.NumberOfEntries):
			mod = MINIDUMP_UNLOADED_MODULE.parse(chunk)
			t.modules.append(MinidumpUnloadedModule.parse(mod, buff))
		
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpUnloadedModuleList()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		muml = MINIDUMP_UNLOADED_MODULE_LIST.parse(chunk)
		for _ in range(muml.NumberOfEntries):
			mod = MINIDUMP_UNLOADED_MODULE.parse(chunk)
			dr = await MinidumpUnloadedModule.aparse(mod, buff)
			t.modules.append(dr)
		
		return t
		
	def to_table(self):
		t = []
		t.append(MinidumpUnloadedModule.get_header())
		for mod in self.modules:
			t.append(mod.to_row())
		return t
		
	def __str__(self):
		t  = '== UnloadedModuleList ==\n' + construct_table(self.to_table())
		return t
```

`src/minidump/streams/__init__.py`:

```py
from .CommentStreamA import *
from .CommentStreamW import *
from .ContextStream import *
from .ExceptionStream import *
from .FunctionTableStream import *
from .HandleDataStream import *
from .HandleOperationListStream import *
from .JavaScriptDataStream import *
from .LastReservedStream import *
from .Memory64ListStream import *
from .MemoryInfoListStream import *
from .MemoryListStream import *
from .MiscInfoStream import *
from .ModuleListStream import *
from .ProcessVmCountersStream import *
from .SystemInfoStream import *
from .SystemMemoryInfoStream import *
from .ThreadExListStream import *
from .ThreadInfoListStream import *
from .ThreadListStream import *
from .TokenStream import *
from .UnloadedModuleListStream import *



__CommentStreamA__ = ['CommentStreamA']
__CommentStreamW__ = ['CommentStreamW']
__ContextStream__ = ['CONTEXT', 'CTX_DUMMYSTRUCTNAME', 'CTX_DUMMYUNIONNAME', 'M128A', 'NEON128', 'WOW64_CONTEXT', 'WOW64_FLOATING_SAVE_AREA', 'XMM_SAVE_AREA32']
__ExceptionStream__ = ['ExceptionList']
__FunctionTableStream__ = ['MINIDUMP_FUNCTION_TABLE_STREAM']
__HandleDataStream__ = ['MinidumpHandleDataStream','MINIDUMP_HANDLE_DATA_STREAM']
__HandleOperationListStream__ = ['MINIDUMP_HANDLE_OPERATION_LIST']
__JavaScriptDataStream__ = []
__LastReservedStream__ = ['MINIDUMP_USER_STREAM']
__Memory64ListStream__ = ['MinidumpMemory64List','MINIDUMP_MEMORY_DESCRIPTOR64','MINIDUMP_MEMORY64_LIST',]
__MemoryInfoListStream__ = ['MinidumpMemoryInfoList','MINIDUMP_MEMORY_INFO','MINIDUMP_MEMORY_INFO_LIST','MemoryState','MemoryType','AllocationProtect']
__MemoryListStream__ = ['MinidumpMemoryList', 'MINIDUMP_MEMORY_DESCRIPTOR','MINIDUMP_MEMORY_LIST']
__MiscInfoStream__ = ['MinidumpMiscInfo','MINIDUMP_MISC_INFO_2','MINIDUMP_MISC_INFO','MinidumpMiscInfoFlags1','MinidumpMiscInfo2Flags1']
__ModuleListStream__ = ['MinidumpModule','MinidumpModuleList','VS_FIXEDFILEINFO','MINIDUMP_MODULE','MINIDUMP_MODULE_LIST']
__ProcessVmCountersStream__ = []
__SystemInfoStream__ = ['MinidumpSystemInfo','PROCESSOR_ARCHITECTURE','PROCESSOR_LEVEL', 'PRODUCT_TYPE', 'PLATFORM_ID','SUITE_MASK','MINIDUMP_SYSTEM_INFO']
__SystemMemoryInfoStream__ = []
__ThreadExListStream__ = ['MinidumpThreadExList', 'MINIDUMP_THREAD_EX', 'MINIDUMP_THREAD_EX_LIST']
__ThreadInfoListStream__ = ['MinidumpThreadInfoList','MINIDUMP_THREAD_INFO_LIST', 'MINIDUMP_THREAD_INFO', 'DumpFlags']
__ThreadListStream__ = ['MinidumpThreadList','MINIDUMP_THREAD', 'MINIDUMP_THREAD_LIST']
__TokenStream__ = []
__UnloadedModuleListStream__ = ['MinidumpUnloadedModuleList', 'MINIDUMP_UNLOADED_MODULE', 'MINIDUMP_UNLOADED_MODULE_LIST']

__all__ = __CommentStreamA__ + __CommentStreamW__ + __ContextStream__ + __ExceptionStream__ + __FunctionTableStream__ + __HandleDataStream__ + __HandleOperationListStream__ + __JavaScriptDataStream__ + __LastReservedStream__ + __Memory64ListStream__ + __MemoryInfoListStream__ + __MemoryListStream__ + __MiscInfoStream__ + __ModuleListStream__ + __ProcessVmCountersStream__ + __SystemInfoStream__ + __SystemMemoryInfoStream__ + __ThreadExListStream__ + __ThreadInfoListStream__ + __ThreadListStream__ + __TokenStream__ + __UnloadedModuleListStream__
```

`src/minidump/utils/createminidump.py`:

```py
import os
import sys
import ctypes
import enum
import platform
import logging
import struct

from ctypes.wintypes import HANDLE, BOOL, DWORD, HWND, HINSTANCE, HKEY, LPVOID, LPWSTR, PBOOL
from ctypes import c_ulong, c_char_p, c_int, c_void_p, WinError, get_last_error, windll

from minidump.utils.privileges import enable_debug_privilege

if platform.system() != 'Windows':
	raise Exception('This script will ovbiously only work on Windows')

# https://stackoverflow.com/questions/1405913/how-do-i-determine-if-my-python-shell-is-executing-in-32bit-or-64bit-mode-on-os
IS_PYTHON_64 = False if (8 * struct.calcsize("P")) == 32 else True

class MINIDUMP_TYPE(enum.IntFlag): 
	MiniDumpNormal						  = 0x00000000
	MiniDumpWithDataSegs					= 0x00000001
	MiniDumpWithFullMemory				  = 0x00000002
	MiniDumpWithHandleData				  = 0x00000004
	MiniDumpFilterMemory					= 0x00000008
	MiniDumpScanMemory					  = 0x00000010
	MiniDumpWithUnloadedModules			 = 0x00000020
	MiniDumpWithIndirectlyReferencedMemory  = 0x00000040
	MiniDumpFilterModulePaths			   = 0x00000080
	MiniDumpWithProcessThreadData		   = 0x00000100
	MiniDumpWithPrivateReadWriteMemory	  = 0x00000200
	MiniDumpWithoutOptionalData			 = 0x00000400
	MiniDumpWithFullMemoryInfo			  = 0x00000800
	MiniDumpWithThreadInfo				  = 0x00001000
	MiniDumpWithCodeSegs					= 0x00002000
	MiniDumpWithoutAuxiliaryState		   = 0x00004000
	MiniDumpWithFullAuxiliaryState		  = 0x00008000
	MiniDumpWithPrivateWriteCopyMemory	  = 0x00010000
	MiniDumpIgnoreInaccessibleMemory		= 0x00020000
	MiniDumpWithTokenInformation			= 0x00040000
	MiniDumpWithModuleHeaders			   = 0x00080000
	MiniDumpFilterTriage					= 0x00100000
	MiniDumpValidTypeFlags				  = 0x001fffff
	
class WindowsBuild(enum.Enum):
	WIN_XP  = 2600
	WIN_2K3 = 3790
	WIN_VISTA = 6000
	WIN_7 = 7600
	WIN_8 = 9200
	WIN_BLUE = 9600
	WIN_10_1507 = 10240
	WIN_10_1511 = 10586
	WIN_10_1607 = 14393
	WIN_10_1707 = 15063
	
class WindowsMinBuild(enum.Enum):
	WIN_XP = 2500
	WIN_2K3 = 3000
	WIN_VISTA = 5000
	WIN_7 = 7000
	WIN_8 = 8000
	WIN_BLUE = 9400
	WIN_10 = 9800
	
#utter microsoft bullshit commencing..
def getWindowsBuild():   
    class OSVersionInfo(ctypes.Structure):
        _fields_ = [
            ("dwOSVersionInfoSize" , ctypes.c_int),
            ("dwMajorVersion"      , ctypes.c_int),
            ("dwMinorVersion"      , ctypes.c_int),
            ("dwBuildNumber"       , ctypes.c_int),
            ("dwPlatformId"        , ctypes.c_int),
            ("szCSDVersion"        , ctypes.c_char*128)];
    GetVersionEx = getattr( ctypes.windll.kernel32 , "GetVersionExA")
    version  = OSVersionInfo()
    version.dwOSVersionInfoSize = ctypes.sizeof(OSVersionInfo)
    GetVersionEx( ctypes.byref(version) )    
    return version.dwBuildNumber
	
DELETE = 0x00010000
READ_CONTROL = 0x00020000
WRITE_DAC = 0x00040000
WRITE_OWNER = 0x00080000

SYNCHRONIZE = 0x00100000

STANDARD_RIGHTS_REQUIRED = DELETE | READ_CONTROL | WRITE_DAC | WRITE_OWNER
STANDARD_RIGHTS_ALL = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE

if getWindowsBuild() >= WindowsMinBuild.WIN_VISTA.value:
	PROCESS_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFFF
else:
	PROCESS_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFF
	
FILE_SHARE_READ = 1
FILE_SHARE_WRITE = 2
FILE_SHARE_DELETE = 4
FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000
FILE_FLAG_BACKUP_SEMANTICS = 0x2000000

FILE_CREATE_NEW = 1
FILE_CREATE_ALWAYS = 2
FILE_OPEN_EXISTING = 3
FILE_OPEN_ALWAYS = 4
FILE_TRUNCATE_EXISTING = 5

FILE_GENERIC_READ = 0x80000000
FILE_GENERIC_WRITE = 0x40000000
FILE_GENERIC_EXECUTE = 0x20000000
FILE_GENERIC_ALL = 0x10000000


FILE_ATTRIBUTE_READONLY = 0x1
FILE_ATTRIBUTE_HIDDEN = 0x2
FILE_ATTRIBUTE_DIRECTORY = 0x10
FILE_ATTRIBUTE_NORMAL = 0x80
FILE_ATTRIBUTE_REPARSE_POINT = 0x400
GENERIC_READ = 0x80000000
FILE_READ_ATTRIBUTES = 0x80

PROCESS_QUERY_INFORMATION = 0x0400
PROCESS_VM_READ = 0x0010

MAX_PATH = 260


"""
class SECURITY_ATTRIBUTES(ctypes.Structure):
    _fields_ = (
        ('length', ctypes.wintypes.DWORD),
        ('p_security_descriptor', ctypes.wintypes.LPVOID),
        ('inherit_handle', ctypes.wintypes.BOOLEAN),
        )
LPSECURITY_ATTRIBUTES = ctypes.POINTER(SECURITY_ATTRIBUTES)	
"""
Psapi = windll.psapi
GetProcessImageFileName = Psapi.GetProcessImageFileNameA
GetProcessImageFileName.restype = ctypes.wintypes.DWORD
QueryFullProcessImageName = ctypes.windll.kernel32.QueryFullProcessImageNameA
QueryFullProcessImageName.restype = ctypes.wintypes.DWORD
EnumProcesses = Psapi.EnumProcesses
EnumProcesses.restype = ctypes.wintypes.DWORD

LPSECURITY_ATTRIBUTES = LPVOID #we dont pass this for now
# https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx
CreateFile = ctypes.windll.kernel32.CreateFileW
CreateFile.argtypes = (
	LPWSTR,
	DWORD,
	DWORD,
    LPSECURITY_ATTRIBUTES,
	DWORD,
	DWORD,
	HANDLE,
    )
CreateFile.restype = ctypes.wintypes.HANDLE

PHANDLE = ctypes.POINTER(HANDLE)
PDWORD = ctypes.POINTER(DWORD)

GetCurrentProcess = ctypes.windll.kernel32.GetCurrentProcess
GetCurrentProcess.argtypes = ()
GetCurrentProcess.restype = HANDLE

# https://msdn.microsoft.com/en-us/library/ms684139.aspx
IsWow64Process  = ctypes.windll.kernel32.IsWow64Process 
IsWow64Process.argtypes = (HANDLE, PBOOL)
IsWow64Process.restype = BOOL

CloseHandle = ctypes.windll.kernel32.CloseHandle
CloseHandle.argtypes = (HANDLE, )
CloseHandle.restype = BOOL

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms684320(v=vs.85).aspx
OpenProcess = ctypes.windll.kernel32.OpenProcess
OpenProcess.argtypes = (DWORD, BOOL, DWORD )
OpenProcess.restype = HANDLE

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680360(v=vs.85).aspx
MiniDumpWriteDump = ctypes.windll.DbgHelp.MiniDumpWriteDump
MiniDumpWriteDump.argtypes = (HANDLE , DWORD , HANDLE, DWORD, DWORD, DWORD, DWORD)
MiniDumpWriteDump.restype = BOOL

def is64bitProc(process_handle):
	is64 = BOOL()
	res = IsWow64Process(process_handle, ctypes.byref(is64))
	if res == 0:
		logging.warning('Failed to get process version info!')
		WinError(get_last_error())
	return not bool(is64.value)
	
# https://waitfordebug.wordpress.com/2012/01/27/pid-enumeration-on-windows-with-pure-python-ctypes/
def enum_pids():
	
	max_array = c_ulong * 4096 # define long array to capture all the processes
	pProcessIds = max_array() # array to store the list of processes
	pBytesReturned = c_ulong() # the number of bytes returned in the array
	#EnumProcess 
	res = EnumProcesses(
		ctypes.byref(pProcessIds),
		ctypes.sizeof(pProcessIds),
		ctypes.byref(pBytesReturned)
	)
	if res == 0:
		logging.error(WinError(get_last_error()))
		return []
  
	# get the number of returned processes
	nReturned = int(pBytesReturned.value/ctypes.sizeof(c_ulong()))
	return [i for i in pProcessIds[:nReturned]]
	
#https://msdn.microsoft.com/en-us/library/windows/desktop/ms683217(v=vs.85).aspx
def enum_process_names():
	pid_to_name = {}
	
	for pid in enum_pids():
		pid_to_name[pid] = 'Not found'
		process_handle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, False, pid)
		if process_handle is None:
			logging.debug('[Enum Processes]Failed to open process PID: %d Reason: %s ' % (pid, WinError(get_last_error())))
			continue
		
		image_name = (ctypes.c_char*MAX_PATH)()
		max_path = DWORD(4096)
		#res = GetProcessImageFileName(process_handle, image_name, MAX_PATH)
		res = QueryFullProcessImageName(process_handle, 0 ,image_name, ctypes.byref(max_path))
		if res == 0:
			logging.debug('[Enum Proceses]Failed GetProcessImageFileName on PID: %d Reason: %s ' % (pid, WinError(get_last_error())))
			continue
		
		pid_to_name[pid] = image_name.value.decode()
	return pid_to_name

def create_dump(pid, output_filename, mindumptype, with_debug = False):
	if with_debug:
		logging.debug('Enabling SeDebugPrivilege')
		assigned = enable_debug_privilege()
		msg = ['failure', 'success'][assigned]
		logging.debug('SeDebugPrivilege assignment %s' % msg)
	
	logging.debug('Opening process PID: %d' % pid)
	process_handle = OpenProcess(PROCESS_ALL_ACCESS, False, pid)
	if process_handle is None:
		logging.warning('Failed to open process PID: %d' % pid)
		logging.error(WinError(get_last_error()))
		return
	logging.debug('Process handle: 0x%04x' % process_handle)
	is64 = is64bitProc(process_handle)
	if is64 != IS_PYTHON_64:
		logging.warning('process architecture mismatch! This could case error! Python arch: %s Target process arch: %s' % ('x86' if not IS_PYTHON_64 else 'x64', 'x86' if not is64 else 'x64'))
	
	logging.debug('Creating file handle for output file')
	file_handle = CreateFile(output_filename, FILE_GENERIC_READ | FILE_GENERIC_WRITE, 0, None,  FILE_CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, None)
	if file_handle == -1:
		logging.warning('Failed to create file')
		logging.error(WinError(get_last_error()))
		return
	logging.debug('Dumping process to file')
	res = MiniDumpWriteDump(process_handle, pid, file_handle, mindumptype, 0,0,0)
	if not bool(res):
		logging.warning('Failed to dump process to file')
		logging.error(WinError(get_last_error()))
	logging.info('Dump file created succsessfully')
	CloseHandle(file_handle)
	CloseHandle(process_handle)
	
def main():
	import argparse

	parser = argparse.ArgumentParser(description='Tool to create process dumps using windows API')
	parser.add_argument('-d', '--with-debug', action='store_true', help='enable SeDebugPrivilege, use this if target process is not in the same user context as your script')
	parser.add_argument('-v', '--verbose', action='count', default=0, help = 'verbosity, add more - see more')
	
	subparsers = parser.add_subparsers(help = 'commands')
	subparsers.required = True
	subparsers.dest = 'command'
	enumerate_group = subparsers.add_parser('enum', help='Enumerate running processes')
	dump_group = subparsers.add_parser('dump', help = 'Dump running process')
	target_group = dump_group.add_mutually_exclusive_group(required=True)
	target_group.add_argument('-p', '--pid', type=int, help='PID of process to dump')
	target_group.add_argument('-n', '--name', help='Name of process to dump')
	dump_group.add_argument('-o', '--outfile', help='Output .dmp file name', required = True)
	
	args = parser.parse_args()
	
	if args.verbose == 0:
		logging.basicConfig(level=logging.INFO)
	elif args.verbose == 1:
		logging.basicConfig(level=logging.DEBUG)
	else:
		logging.basicConfig(level=1)
		
	mindumptype = MINIDUMP_TYPE.MiniDumpNormal | MINIDUMP_TYPE.MiniDumpWithFullMemory
		
	if args.with_debug:
		logging.debug('Enabling SeDebugPrivilege')
		assigned = enable_debug_privilege()
		msg = ['failure', 'success'][assigned]
		logging.debug('SeDebugPrivilege assignment %s' % msg)
	
	if args.command == 'enum':
		pid_to_name = enum_process_names()
		t = [p for p in pid_to_name]
		t.sort()
		for pid in t:
			logging.info('PID: %d Name: %s' % (pid, pid_to_name[pid]))
		return
		
	if args.command == 'dump':
		if args.pid:
			logging.info('Dumpig process PID %d' % args.pid)
			create_dump(args.pid, args.outfile, mindumptype, with_debug = args.with_debug)
		
		if args.name:
			pid_to_name = enum_process_names()
			for pid in pid_to_name:
				if pid_to_name[pid].find(args.name) != -1:
					logging.info('Dumpig process PID %d' % pid)
					create_dump(pid, args.outfile, mindumptype, with_debug = args.with_debug)
					return
			logging.info('Failed to find process by name!')
			
if __name__=='__main__':
	main()

	
```

`src/minidump/utils/privileges.py`:

```py
"""
A module built to test if the current process has the privilege to
create symlinks on Windows.
"""
# https://svn.python.org/projects/python/branches/pep-0384/Lib/test/symlink_support.py

# allow script to run natively under python 2.6+
from __future__ import print_function

import ctypes
from ctypes import wintypes

GetCurrentProcess = ctypes.windll.kernel32.GetCurrentProcess
GetCurrentProcess.restype = wintypes.HANDLE
OpenProcessToken = ctypes.windll.advapi32.OpenProcessToken
OpenProcessToken.argtypes = (wintypes.HANDLE, wintypes.DWORD,
                             ctypes.POINTER(wintypes.HANDLE))
OpenProcessToken.restype = wintypes.BOOL

class LUID(ctypes.Structure):
    _fields_ = [
            ('low_part', wintypes.DWORD),
            ('high_part', wintypes.LONG),
            ]

    def __eq__(self, other):
        return (
                self.high_part == other.high_part and
                self.low_part == other.low_part
                )

    def __ne__(self, other):
        return not (self==other)

LookupPrivilegeValue = ctypes.windll.advapi32.LookupPrivilegeValueW
LookupPrivilegeValue.argtypes = (
        wintypes.LPWSTR, # system name
        wintypes.LPWSTR, # name
        ctypes.POINTER(LUID),
        )
LookupPrivilegeValue.restype = wintypes.BOOL

class TOKEN_INFORMATION_CLASS:
    TokenUser = 1
    TokenGroups = 2
    TokenPrivileges = 3
    # ... see http://msdn.microsoft.com/en-us/library/aa379626%28VS.85%29.aspx

SE_PRIVILEGE_ENABLED_BY_DEFAULT = (0x00000001)
SE_PRIVILEGE_ENABLED            = (0x00000002)
SE_PRIVILEGE_REMOVED            = (0x00000004)
SE_PRIVILEGE_USED_FOR_ACCESS    = (0x80000000)

class LUID_AND_ATTRIBUTES(ctypes.Structure):
    _fields_ = [
            ('LUID', LUID),
            ('attributes', wintypes.DWORD),
            ]

    def is_enabled(self):
        return bool(self.attributes & SE_PRIVILEGE_ENABLED)

    def enable(self):
        self.attributes |= SE_PRIVILEGE_ENABLED

    def get_name(self):
        size = wintypes.DWORD(10240)
        buf = ctypes.create_unicode_buffer(size.value)
        res = LookupPrivilegeName(None, self.LUID, buf, size)
        if res == 0:
            raise RuntimeError
        return buf[:size.value]

    def __str__(self):
        name = self.name
        fmt = ['{name}', '{name} (enabled)'][self.is_enabled()]
        return fmt.format(**vars())

LookupPrivilegeName = ctypes.windll.advapi32.LookupPrivilegeNameW
LookupPrivilegeName.argtypes = (
        wintypes.LPWSTR, # lpSystemName
        ctypes.POINTER(LUID), # lpLuid
        wintypes.LPWSTR, # lpName
        ctypes.POINTER(wintypes.DWORD), #cchName
        )
LookupPrivilegeName.restype = wintypes.BOOL

class TOKEN_PRIVILEGES(ctypes.Structure):
    _fields_ = [
            ('count', wintypes.DWORD),
            ('privileges', LUID_AND_ATTRIBUTES*0),
            ]

    def get_array(self):
        array_type = LUID_AND_ATTRIBUTES*self.count
        privileges = ctypes.cast(self.privileges,
                                 ctypes.POINTER(array_type)).contents
        return privileges

    def __iter__(self):
        return iter(self.get_array())

PTOKEN_PRIVILEGES = ctypes.POINTER(TOKEN_PRIVILEGES)

GetTokenInformation = ctypes.windll.advapi32.GetTokenInformation
GetTokenInformation.argtypes = [
        wintypes.HANDLE, # TokenHandle
        ctypes.c_uint, # TOKEN_INFORMATION_CLASS value
        ctypes.c_void_p, # TokenInformation
        wintypes.DWORD, # TokenInformationLength
        ctypes.POINTER(wintypes.DWORD), # ReturnLength
        ]
GetTokenInformation.restype = wintypes.BOOL

# http://msdn.microsoft.com/en-us/library/aa375202%28VS.85%29.aspx
AdjustTokenPrivileges = ctypes.windll.advapi32.AdjustTokenPrivileges
AdjustTokenPrivileges.restype = wintypes.BOOL
AdjustTokenPrivileges.argtypes = [
        wintypes.HANDLE,                # TokenHandle
        wintypes.BOOL,                  # DisableAllPrivileges
        PTOKEN_PRIVILEGES,              # NewState (optional)
        wintypes.DWORD,                 # BufferLength of PreviousState
        PTOKEN_PRIVILEGES,              # PreviousState (out, optional)
        ctypes.POINTER(wintypes.DWORD), # ReturnLength
        ]

def get_process_token():
    "Get the current process token"
    token = wintypes.HANDLE()
    TOKEN_ALL_ACCESS = 0xf01ff
    res = OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, token)
    if not res > 0:
        raise RuntimeError("Couldn't get process token")
    return token

def get_debug_luid():
    symlink_luid = LUID()
    res = LookupPrivilegeValue(None, "SeDebugPrivilege",
                               symlink_luid)
    if not res > 0:
        raise RuntimeError("Couldn't lookup privilege value")
    return symlink_luid

def get_privilege_information():
    "Get all privileges associated with the current process."
    # first call with zero length to determine what size buffer we need

    return_length = wintypes.DWORD()
    params = [
            get_process_token(),
            TOKEN_INFORMATION_CLASS.TokenPrivileges,
            None,
            0,
            return_length,
            ]

    res = GetTokenInformation(*params)

    # assume we now have the necessary length in return_length

    buffer = ctypes.create_string_buffer(return_length.value)
    params[2] = buffer
    params[3] = return_length.value

    res = GetTokenInformation(*params)
    assert res > 0, "Error in second GetTokenInformation (%d)" % res

    privileges = ctypes.cast(buffer, ctypes.POINTER(TOKEN_PRIVILEGES)).contents
    return privileges

def report_privilege_information():
    "Report all privilege information assigned to the current process."
    privileges = get_privilege_information()
    print("found {0} privileges".format(privileges.count))
    tuple(map(print, privileges))

def enable_debug_privilege():
    """
    Try to assign the symlink privilege to the current process token.
    Return True if the assignment is successful.
    """
    # create a space in memory for a TOKEN_PRIVILEGES structure
    #  with one element
    size = ctypes.sizeof(TOKEN_PRIVILEGES)
    size += ctypes.sizeof(LUID_AND_ATTRIBUTES)
    buffer = ctypes.create_string_buffer(size)
    tp = ctypes.cast(buffer, ctypes.POINTER(TOKEN_PRIVILEGES)).contents
    tp.count = 1
    tp.get_array()[0].enable()
    tp.get_array()[0].LUID = get_debug_luid()
    token = get_process_token()
    res = AdjustTokenPrivileges(token, False, tp, 0, None, None)
    if res == 0:
        raise RuntimeError("Error in AdjustTokenPrivileges")

    ERROR_NOT_ALL_ASSIGNED = 1300
    return ctypes.windll.kernel32.GetLastError() != ERROR_NOT_ALL_ASSIGNED

```

`src/minidump/utils/privileges_types.py`:

```py
import enum

class Privileges(enum.Enum):
	SE_ASSIGNPRIMARYTOKEN_NAME = "SeAssignPrimaryTokenPrivilege" #Required to assign the primary token of a process.
																 #User Right: Replace a process-level token.

	SE_AUDIT_NAME = "SeAuditPrivilege" #Required to generate audit-log entries. Give this privilege to secure servers.
										#User Right: Generate security audits.

	SE_BACKUP_NAME = "SeBackupPrivilege" #Required to perform backup operations. This privilege causes the system to grant all read access control to any file, regardless of the access control list (ACL) specified for the file. Any access request other than read is still evaluated with the ACL. This privilege is required by the RegSaveKey and RegSaveKeyExfunctions. The following access rights are granted if this privilege is held:
	SE_CHANGE_NOTIFY_NAME = "SeChangeNotifyPrivilege" #Required to receive notifications of changes to files or directories. This privilege also causes the system to skip all traversal access checks. It is enabled by default for all users.
	SE_CREATE_GLOBAL_NAME = "SeCreateGlobalPrivilege" #Required to create named file mapping objects in the global namespace during Terminal Services sessions. This privilege is enabled by default for administrators, services, and the local system account.
														#User Right: Create global objects.

	SE_CREATE_PAGEFILE_NAME = "SeCreatePagefilePrivilege" # Required to create a paging file. #User Right: Create a pagefile.
	SE_CREATE_PERMANENT_NAME = "SeCreatePermanentPrivilege" #Required to create a permanent object.
															#User Right: Create permanent shared objects.
	SE_CREATE_SYMBOLIC_LINK_NAME = "SeCreateSymbolicLinkPrivilege" #Required to create a symbolic link.
																		#User Right: Create symbolic links.

	SE_CREATE_TOKEN_NAME = "SeCreateTokenPrivilege" #Required to create a primary token.
													#User Right: Create a token object.
													#You cannot add this privilege to a user account with the "Create a token object" policy. Additionally, you cannot add this privilege to an owned process using Windows APIs.
													#Windows Server 2003 and Windows XP with SP1 and earlier:  Windows APIs can add this privilege to an owned process.

	SE_DEBUG_NAME = "SeDebugPrivilege" #Required to debug and adjust the memory of a process owned by another account.
										#User Right: Debug programs.

	SE_ENABLE_DELEGATION_NAME = "SeEnableDelegationPrivilege" #Required to mark user and computer accounts as trusted for delegation.
															  #User Right: Enable computer and user accounts to be trusted for delegation.
	SE_IMPERSONATE_NAME = "SeImpersonatePrivilege" #Required to impersonate.
													#User Right: Impersonate a client after authentication.

	SE_INC_BASE_PRIORITY_NAME = "SeIncreaseBasePriorityPrivilege" #Required to increase the base priority of a process.
																  #User Right: Increase scheduling priority.
	SE_INCREASE_QUOTA_NAME = "SeIncreaseQuotaPrivilege" #Required to increase the quota assigned to a process.
														#User Right: Adjust memory quotas for a process.

	SE_INC_WORKING_SET_NAME = "SeIncreaseWorkingSetPrivilege" #Required to allocate more memory for applications that run in the context of users.
																#User Right: Increase a process working set.
	SE_LOAD_DRIVER_NAME = "SeLoadDriverPrivilege" #Required to load or unload a device driver.
												  #User Right: Load and unload device drivers.
	SE_LOCK_MEMORY_NAME = "SeLockMemoryPrivilege" #Required to lock physical pages in memory.
													#User Right: Lock pages in memory.
	SE_MACHINE_ACCOUNT_NAME = "SeMachineAccountPrivilege" #Required to create a computer account.
														#User Right: Add workstations to domain.
	SE_MANAGE_VOLUME_NAME = "SeManageVolumePrivilege" #Required to enable volume management privileges.
													  #User Right: Manage the files on a volume.
	SE_PROF_SINGLE_PROCESS_NAME = "SeProfileSingleProcessPrivilege" #Required to gather profiling information for a single process.
																	#User Right: Profile single process.
	SE_RELABEL_NAME = "SeRelabelPrivilege" #Required to modify the mandatory integrity level of an object.
	#User Right: Modify an object label.

	SE_REMOTE_SHUTDOWN_NAME = "SeRemoteShutdownPrivilege"# Required to shut down a system using a network request.
	#User Right: Force shutdown from a remote system.

	SE_RESTORE_NAME = "SeRestorePrivilege" #Required to perform restore operations. This privilege causes the system to grant all write access control to any file, regardless of the ACL specified for the file. Any access request other than write is still evaluated with the ACL. Additionally, this privilege enables you to set any valid user or group SID as the owner of a file. This privilege is required by the RegLoadKey function. The following access rights are granted if this privilege is held:
	SE_SECURITY_NAME = "SeSecurityPrivilege" #Required to perform a number of security-related functions, such as controlling and viewing audit messages. This privilege identifies its holder as a security operator.
	#User Right: Manage auditing and security log.
	SE_SHUTDOWN_NAME = "SeShutdownPrivilege" #Required to shut down a local system.
	#User Right: Shut down the system.
	SE_SYNC_AGENT_NAME = "SeSyncAgentPrivilege" #Required for a domain controller to use the Lightweight Directory Access Protocol directory synchronization services. This privilege enables the holder to read all objects and properties in the directory, regardless of the protection on the objects and properties. By default, it is assigned to the Administrator and LocalSystem accounts on domain controllers.
	#User Right: Synchronize directory service data.
	SE_SYSTEM_ENVIRONMENT_NAME = "SeSystemEnvironmentPrivilege" #Required to modify the nonvolatile RAM of systems that use this type of memory to store configuration information.
	#User Right: Modify firmware environment values.
	SE_SYSTEM_PROFILE_NAME = "SeSystemProfilePrivilege" #Required to gather profiling information for the entire system.
	#User Right: Profile system performance.
	SE_SYSTEMTIME_NAME = "SeSystemtimePrivilege" #Required to modify the system time.
	#User Right: Change the system time.
	SE_TAKE_OWNERSHIP_NAME = "SeTakeOwnershipPrivilege" #Required to take ownership of an object without being granted discretionary access. This privilege allows the owner value to be set only to those values that the holder may legitimately assign as the owner of an object.
	#User Right: Take ownership of files or other objects.
	SE_TCB_NAME = "SeTcbPrivilege" #This privilege identifies its holder as part of the trusted computer base. Some trusted protected subsystems are granted this privilege.
	#User Right: Act as part of the operating system.
	SE_TIME_ZONE_NAME = "SeTimeZonePrivilege" #Required to adjust the time zone associated with the computer's internal clock.
	#User Right: Change the time zone.
	SE_TRUSTED_CREDMAN_ACCESS_NAME = "SeTrustedCredManAccessPrivilege"#Required to access Credential Manager as a trusted caller.
	#User Right: Access Credential Manager as a trusted caller.
	SE_UNDOCK_NAME = "SeUndockPrivilege" #Required to undock a laptop.
	#User Right: Remove computer from docking station.
	SE_UNSOLICITED_INPUT_NAME = "SeUnsolicitedInputPrivilege"
```

`src/minidump/utils/winapi/defines.py`:

```py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright (c) 2009-2018, Mario Vilas
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice,this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""
Common definitions.
"""

# TODO
# + add TCHAR and related types?

import ctypes
import functools

#==============================================================================
# This is used later on to calculate the list of exported symbols.
_all = None
_all = set(vars().keys())
#==============================================================================

# Cygwin compatibility.
try:
    WindowsError
except NameError:
    _gle = None
    class WindowsError(OSError):
        def __init__(self, *args, **kwargs):
            OSError.__init__(self, *args, **kwargs)
            global _gle
            if _gle is None:
                from kernel32 import GetLastError as _gle
            self.winerror = _gle()

    from os import getenv as _real_getenv
    def getenv(key, default=None):
        value = _real_getenv(key, None)
        if value is None:
            value = _real_getenv(key.upper(), default)
        return value

#------------------------------------------------------------------------------

# Some stuff from ctypes we'll be using very frequently.
addressof   = ctypes.addressof
sizeof      = ctypes.sizeof
SIZEOF      = ctypes.sizeof
POINTER     = ctypes.POINTER
WINFUNCTYPE = ctypes.WINFUNCTYPE
windll      = ctypes.windll

# Automatically disable padding of structs and unions on 32 bits.
class Structure(ctypes.Structure):
    if sizeof(ctypes.c_void_p) == 4:
        _pack_ = 1
class Union(ctypes.Union):
    if sizeof(ctypes.c_void_p) == 4:
        _pack_ = 1

# The IronPython implementation of byref() was giving some problems,
# so it's best to replace it with the slower pointer() function.
try:
    ctypes.c_void_p(ctypes.byref(ctypes.c_char()))  # this fails in IronPython
    byref = ctypes.byref
except TypeError:
    byref = ctypes.pointer

# XXX DEBUG
# The following code can be enabled to make the Win32 API wrappers log to
# standard output the dll and function names, the parameter values and the
# return value for each call.

##WIN32_VERBOSE_MODE = True
WIN32_VERBOSE_MODE = False

if WIN32_VERBOSE_MODE:

    class WinDllHook(object):
        def __getattr__(self, name):
            if name.startswith('_'):
                return object.__getattr__(self, name)
            return WinFuncHook(name)

    class WinFuncHook(object):
        def __init__(self, name):
            self.__name = name

        def __getattr__(self, name):
            if name.startswith('_'):
                return object.__getattr__(self, name)
            return WinCallHook(self.__name, name)

    class WinCallHook(object):
        def __init__(self, dllname, funcname):
            self.__dllname = dllname
            self.__funcname = funcname
            self.__func = getattr(getattr(ctypes.windll, dllname), funcname)

        def __copy_attribute(self, attribute):
            try:
                value = getattr(self, attribute)
                setattr(self.__func, attribute, value)
            except AttributeError:
                try:
                    delattr(self.__func, attribute)
                except AttributeError:
                    pass

        def __call__(self, *argv):
            self.__copy_attribute('argtypes')
            self.__copy_attribute('restype')
            self.__copy_attribute('errcheck')
            print("-"*10)
            print("%s ! %s %r" % (self.__dllname, self.__funcname, argv))
            retval = self.__func(*argv)
            print("== %r" % (retval,))
            return retval

    windll = WinDllHook()

#------------------------------------------------------------------------------

def RaiseIfZero(result, func = None, arguments = ()):
    """
    Error checking for most Win32 API calls.

    The function is assumed to return an integer, which is C{0} on error.
    In that case the C{WindowsError} exception is raised.
    """
    if not result:
        raise ctypes.WinError()
    return result

def RaiseIfNotZero(result, func = None, arguments = ()):
    """
    Error checking for some odd Win32 API calls.

    The function is assumed to return an integer, which is zero on success.
    If the return value is nonzero the C{WindowsError} exception is raised.

    This is mostly useful for free() like functions, where the return value is
    the pointer to the memory block on failure or a C{NULL} pointer on success.
    """
    if result:
        raise ctypes.WinError()
    return result

def RaiseIfNotErrorSuccess(result, func = None, arguments = ()):
    """
    Error checking for Win32 Registry API calls.

    The function is assumed to return a Win32 error code. If the code is not
    C{ERROR_SUCCESS} then a C{WindowsError} exception is raised.
    """
    if result != ERROR_SUCCESS:
        raise ctypes.WinError(result)
    return result

class GuessStringType(object):
    """
    Decorator that guesses the correct version (A or W) to call
    based on the types of the strings passed as parameters.

    Calls the B{ANSI} version if the only string types are ANSI.

    Calls the B{Unicode} version if Unicode or mixed string types are passed.

    The default if no string arguments are passed depends on the value of the
    L{t_default} class variable.

    @type fn_ansi: function
    @ivar fn_ansi: ANSI version of the API function to call.
    @type fn_unicode: function
    @ivar fn_unicode: Unicode (wide) version of the API function to call.

    @type t_default: type
    @cvar t_default: Default string type to use.
        Possible values are:
         - type('') for ANSI
         - type(u'') for Unicode
    """

    # ANSI and Unicode types
    t_ansi    = type('')
    t_unicode = type(u'')

    # Default is ANSI for Python 2.x
    t_default = t_ansi

    def __init__(self, fn_ansi, fn_unicode):
        """
        @type  fn_ansi: function
        @param fn_ansi: ANSI version of the API function to call.
        @type  fn_unicode: function
        @param fn_unicode: Unicode (wide) version of the API function to call.
        """
        self.fn_ansi    = fn_ansi
        self.fn_unicode = fn_unicode

        # Copy the wrapped function attributes.
        try:
            self.__name__ = self.fn_ansi.__name__[:-1]  # remove the A or W
        except AttributeError:
            pass
        try:
            self.__module__ = self.fn_ansi.__module__
        except AttributeError:
            pass
        try:
            self.__doc__ = self.fn_ansi.__doc__
        except AttributeError:
            pass

    def __call__(self, *argv, **argd):

        # Shortcut to self.t_ansi
        t_ansi    = self.t_ansi

        # Get the types of all arguments for the function
        v_types   = [ type(item) for item in argv ]
        v_types.extend( [ type(value) for (key, value) in argd.iteritems() ] )

        # Get the appropriate function for the default type
        if self.t_default == t_ansi:
            fn = self.fn_ansi
        else:
            fn = self.fn_unicode

        # If at least one argument is a Unicode string...
        if self.t_unicode in v_types:

            # If al least one argument is an ANSI string,
            # convert all ANSI strings to Unicode
            if t_ansi in v_types:
                argv = list(argv)
                for index in xrange(len(argv)):
                    if v_types[index] == t_ansi:
                        argv[index] = unicode(argv[index])
                for (key, value) in argd.items():
                    if type(value) == t_ansi:
                        argd[key] = unicode(value)

            # Use the W version
            fn = self.fn_unicode

        # If at least one argument is an ANSI string,
        # but there are no Unicode strings...
        elif t_ansi in v_types:

            # Use the A version
            fn = self.fn_ansi

        # Call the function and return the result
        return fn(*argv, **argd)

class DefaultStringType(object):
    """
    Decorator that uses the default version (A or W) to call
    based on the configuration of the L{GuessStringType} decorator.

    @see: L{GuessStringType.t_default}

    @type fn_ansi: function
    @ivar fn_ansi: ANSI version of the API function to call.
    @type fn_unicode: function
    @ivar fn_unicode: Unicode (wide) version of the API function to call.
    """

    def __init__(self, fn_ansi, fn_unicode):
        """
        @type  fn_ansi: function
        @param fn_ansi: ANSI version of the API function to call.
        @type  fn_unicode: function
        @param fn_unicode: Unicode (wide) version of the API function to call.
        """
        self.fn_ansi    = fn_ansi
        self.fn_unicode = fn_unicode

        # Copy the wrapped function attributes.
        try:
            self.__name__ = self.fn_ansi.__name__[:-1]  # remove the A or W
        except AttributeError:
            pass
        try:
            self.__module__ = self.fn_ansi.__module__
        except AttributeError:
            pass
        try:
            self.__doc__ = self.fn_ansi.__doc__
        except AttributeError:
            pass

    def __call__(self, *argv, **argd):

        # Get the appropriate function based on the default.
        if GuessStringType.t_default == GuessStringType.t_ansi:
            fn = self.fn_ansi
        else:
            fn = self.fn_unicode

        # Call the function and return the result
        return fn(*argv, **argd)

def MakeANSIVersion(fn):
    """
    Decorator that generates an ANSI version of a Unicode (wide) only API call.

    @type  fn: callable
    @param fn: Unicode (wide) version of the API function to call.
    """
    @functools.wraps(fn)
    def wrapper(*argv, **argd):
        t_ansi    = GuessStringType.t_ansi
        t_unicode = GuessStringType.t_unicode
        v_types   = [ type(item) for item in argv ]
        v_types.extend( [ type(value) for (key, value) in argd.iteritems() ] )
        if t_ansi in v_types:
            argv = list(argv)
            for index in range(len(argv)):
                if v_types[index] == t_ansi:
                    argv[index] = t_unicode(argv[index])
            for key, value in argd.items():
                if type(value) == t_ansi:
                    argd[key] = t_unicode(value)
        return fn(*argv, **argd)
    return wrapper

def MakeWideVersion(fn):
    """
    Decorator that generates a Unicode (wide) version of an ANSI only API call.

    @type  fn: callable
    @param fn: ANSI version of the API function to call.
    """
    @functools.wraps(fn)
    def wrapper(*argv, **argd):
        t_ansi    = GuessStringType.t_ansi
        t_unicode = GuessStringType.t_unicode
        v_types   = [ type(item) for item in argv ]
        v_types.extend( [ type(value) for (key, value) in argd.iteritems() ] )
        if t_unicode in v_types:
            argv = list(argv)
            for index in range(len(argv)):
                if v_types[index] == t_unicode:
                    argv[index] = t_ansi(argv[index])
            for key, value in argd.items():
                if type(value) == t_unicode:
                    argd[key] = t_ansi(value)
        return fn(*argv, **argd)
    return wrapper

#--- Types --------------------------------------------------------------------
# http://msdn.microsoft.com/en-us/library/aa383751(v=vs.85).aspx

# Map of basic C types to Win32 types
LPVOID      = ctypes.c_void_p
CHAR        = ctypes.c_char
WCHAR       = ctypes.c_wchar
BYTE        = ctypes.c_ubyte
SBYTE       = ctypes.c_byte
WORD        = ctypes.c_uint16
SWORD       = ctypes.c_int16
DWORD       = ctypes.c_uint32
SDWORD      = ctypes.c_int32
QWORD       = ctypes.c_uint64
SQWORD      = ctypes.c_int64
SHORT       = ctypes.c_int16
USHORT      = ctypes.c_uint16
INT         = ctypes.c_int32
UINT        = ctypes.c_uint32
LONG        = ctypes.c_int32
ULONG       = ctypes.c_uint32
LONGLONG    = ctypes.c_int64        # c_longlong
ULONGLONG   = ctypes.c_uint64       # c_ulonglong
LPSTR       = ctypes.c_char_p
LPWSTR      = ctypes.c_wchar_p
INT8        = ctypes.c_int8
INT16       = ctypes.c_int16
INT32       = ctypes.c_int32
INT64       = ctypes.c_int64
UINT8       = ctypes.c_uint8
UINT16      = ctypes.c_uint16
UINT32      = ctypes.c_uint32
UINT64      = ctypes.c_uint64
LONG32      = ctypes.c_int32
LONG64      = ctypes.c_int64
ULONG32     = ctypes.c_uint32
ULONG64     = ctypes.c_uint64
DWORD32     = ctypes.c_uint32
DWORD64     = ctypes.c_uint64
BOOL        = ctypes.c_int32
FLOAT       = ctypes.c_float        # not sure on cygwin
DOUBLE      = ctypes.c_double       # not sure on cygwin

# Map size_t to SIZE_T
try:
    SIZE_T  = ctypes.c_size_t
    SSIZE_T = ctypes.c_ssize_t
except AttributeError:
    # Size of a pointer
    SIZE_T  = {1:BYTE, 2:WORD, 4:DWORD, 8:QWORD}[sizeof(LPVOID)]
    SSIZE_T = {1:SBYTE, 2:SWORD, 4:SDWORD, 8:SQWORD}[sizeof(LPVOID)]
PSIZE_T     = POINTER(SIZE_T)

# Not really pointers but pointer-sized integers
DWORD_PTR   = SIZE_T
ULONG_PTR   = SIZE_T
LONG_PTR    = SIZE_T

# Other Win32 types, more may be added as needed
PVOID       = LPVOID
PPVOID      = POINTER(PVOID)
PSTR        = LPSTR
PWSTR       = LPWSTR
PCHAR       = LPSTR
PWCHAR      = LPWSTR
LPBYTE      = POINTER(BYTE)
LPSBYTE     = POINTER(SBYTE)
LPWORD      = POINTER(WORD)
LPSWORD     = POINTER(SWORD)
LPDWORD     = POINTER(DWORD)
LPSDWORD    = POINTER(SDWORD)
LPULONG     = POINTER(ULONG)
LPLONG      = POINTER(LONG)
PDWORD      = LPDWORD
PDWORD_PTR  = POINTER(DWORD_PTR)
PULONG      = LPULONG
PLONG       = LPLONG
CCHAR       = CHAR
BOOLEAN     = BYTE
PBOOL       = POINTER(BOOL)
LPBOOL      = PBOOL
TCHAR       = CHAR      # XXX ANSI by default?
UCHAR       = BYTE
DWORDLONG   = ULONGLONG
LPDWORD32   = POINTER(DWORD32)
LPULONG32   = POINTER(ULONG32)
LPDWORD64   = POINTER(DWORD64)
LPULONG64   = POINTER(ULONG64)
PDWORD32    = LPDWORD32
PULONG32    = LPULONG32
PDWORD64    = LPDWORD64
PULONG64    = LPULONG64
ATOM        = WORD
HANDLE      = LPVOID
PHANDLE     = POINTER(HANDLE)
LPHANDLE    = PHANDLE
HMODULE     = HANDLE
HINSTANCE   = HANDLE
HTASK       = HANDLE
HKEY        = HANDLE
PHKEY       = POINTER(HKEY)
HDESK       = HANDLE
HRSRC       = HANDLE
HSTR        = HANDLE
HWINSTA     = HANDLE
HKL         = HANDLE
HDWP        = HANDLE
HFILE       = HANDLE
HRESULT     = LONG
HGLOBAL     = HANDLE
HLOCAL      = HANDLE
HGDIOBJ     = HANDLE
HDC         = HGDIOBJ
HRGN        = HGDIOBJ
HBITMAP     = HGDIOBJ
HPALETTE    = HGDIOBJ
HPEN        = HGDIOBJ
HBRUSH      = HGDIOBJ
HMF         = HGDIOBJ
HEMF        = HGDIOBJ
HENHMETAFILE = HGDIOBJ
HMETAFILE   = HGDIOBJ
HMETAFILEPICT = HGDIOBJ
HWND        = HANDLE
NTSTATUS    = LONG
PNTSTATUS   = POINTER(NTSTATUS)
KAFFINITY   = ULONG_PTR
RVA         = DWORD
RVA64       = QWORD
WPARAM      = DWORD
LPARAM      = LPVOID
LRESULT     = LPVOID
ACCESS_MASK = DWORD
REGSAM      = ACCESS_MASK
PACCESS_MASK = POINTER(ACCESS_MASK)
PREGSAM     = POINTER(REGSAM)

# Since the SID is an opaque structure, let's treat its pointers as void*
PSID = PVOID

# typedef union _LARGE_INTEGER {
#   struct {
#     DWORD LowPart;
#     LONG HighPart;
#   } ;
#   struct {
#     DWORD LowPart;
#     LONG HighPart;
#   } u;
#   LONGLONG QuadPart;
# } LARGE_INTEGER,
#  *PLARGE_INTEGER;

# XXX TODO

# typedef struct _FLOAT128 {
#     __int64 LowPart;
#     __int64 HighPart;
# } FLOAT128;
class FLOAT128 (Structure):
    _fields_ = [
        ("LowPart",     QWORD),
        ("HighPart",    QWORD),
    ]
PFLOAT128 = POINTER(FLOAT128)

# typedef struct DECLSPEC_ALIGN(16) _M128A {
#     ULONGLONG Low;
#     LONGLONG High;
# } M128A, *PM128A;
class M128A(Structure):
    _fields_ = [
        ("Low",     ULONGLONG),
        ("High",    LONGLONG),
    ]
PM128A = POINTER(M128A)

#--- Constants ----------------------------------------------------------------

NULL        = None
INFINITE    = -1
TRUE        = 1
FALSE       = 0

# http://blogs.msdn.com/oldnewthing/archive/2004/08/26/220873.aspx
ANYSIZE_ARRAY = 1

# Invalid handle value is -1 casted to void pointer.
try:
    INVALID_HANDLE_VALUE = ctypes.c_void_p(-1).value #-1 #0xFFFFFFFF
except TypeError:
    if sizeof(ctypes.c_void_p) == 4:
        INVALID_HANDLE_VALUE = 0xFFFFFFFF
    elif sizeof(ctypes.c_void_p) == 8:
        INVALID_HANDLE_VALUE = 0xFFFFFFFFFFFFFFFF
    else:
        raise

MAX_MODULE_NAME32   = 255
MAX_PATH            = 260

# Error codes
# TODO maybe add more error codes?
# if they're too many they could be pickled instead,
# or at the very least put in a new file
ERROR_SUCCESS                       = 0
ERROR_INVALID_FUNCTION              = 1
ERROR_FILE_NOT_FOUND                = 2
ERROR_PATH_NOT_FOUND                = 3
ERROR_ACCESS_DENIED                 = 5
ERROR_INVALID_HANDLE                = 6
ERROR_NOT_ENOUGH_MEMORY             = 8
ERROR_INVALID_DRIVE                 = 15
ERROR_NO_MORE_FILES                 = 18
ERROR_BAD_LENGTH                    = 24
ERROR_HANDLE_EOF                    = 38
ERROR_HANDLE_DISK_FULL              = 39
ERROR_NOT_SUPPORTED                 = 50
ERROR_FILE_EXISTS                   = 80
ERROR_INVALID_PARAMETER             = 87
ERROR_BUFFER_OVERFLOW               = 111
ERROR_DISK_FULL                     = 112
ERROR_CALL_NOT_IMPLEMENTED          = 120
ERROR_SEM_TIMEOUT                   = 121
ERROR_INSUFFICIENT_BUFFER           = 122
ERROR_INVALID_NAME                  = 123
ERROR_MOD_NOT_FOUND                 = 126
ERROR_PROC_NOT_FOUND                = 127
ERROR_DIR_NOT_EMPTY                 = 145
ERROR_BAD_THREADID_ADDR             = 159
ERROR_BAD_ARGUMENTS                 = 160
ERROR_BAD_PATHNAME                  = 161
ERROR_ALREADY_EXISTS                = 183
ERROR_INVALID_FLAG_NUMBER           = 186
ERROR_ENVVAR_NOT_FOUND              = 203
ERROR_FILENAME_EXCED_RANGE          = 206
ERROR_MORE_DATA                     = 234

WAIT_TIMEOUT                        = 258

ERROR_NO_MORE_ITEMS                 = 259
ERROR_PARTIAL_COPY                  = 299
ERROR_INVALID_ADDRESS               = 487
ERROR_THREAD_NOT_IN_PROCESS         = 566
ERROR_CONTROL_C_EXIT                = 572
ERROR_UNHANDLED_EXCEPTION           = 574
ERROR_ASSERTION_FAILURE             = 668
ERROR_WOW_ASSERTION                 = 670

ERROR_DBG_EXCEPTION_NOT_HANDLED     = 688
ERROR_DBG_REPLY_LATER               = 689
ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE  = 690
ERROR_DBG_TERMINATE_THREAD          = 691
ERROR_DBG_TERMINATE_PROCESS         = 692
ERROR_DBG_CONTROL_C                 = 693
ERROR_DBG_PRINTEXCEPTION_C          = 694
ERROR_DBG_RIPEXCEPTION              = 695
ERROR_DBG_CONTROL_BREAK             = 696
ERROR_DBG_COMMAND_EXCEPTION         = 697
ERROR_DBG_EXCEPTION_HANDLED         = 766
ERROR_DBG_CONTINUE                  = 767

ERROR_ELEVATION_REQUIRED            = 740
ERROR_NOACCESS                      = 998

ERROR_CIRCULAR_DEPENDENCY           = 1059
ERROR_SERVICE_DOES_NOT_EXIST        = 1060
ERROR_SERVICE_CANNOT_ACCEPT_CTRL    = 1061
ERROR_SERVICE_NOT_ACTIVE            = 1062
ERROR_FAILED_SERVICE_CONTROLLER_CONNECT = 1063
ERROR_EXCEPTION_IN_SERVICE          = 1064
ERROR_DATABASE_DOES_NOT_EXIST       = 1065
ERROR_SERVICE_SPECIFIC_ERROR        = 1066
ERROR_PROCESS_ABORTED               = 1067
ERROR_SERVICE_DEPENDENCY_FAIL       = 1068
ERROR_SERVICE_LOGON_FAILED          = 1069
ERROR_SERVICE_START_HANG            = 1070
ERROR_INVALID_SERVICE_LOCK          = 1071
ERROR_SERVICE_MARKED_FOR_DELETE     = 1072
ERROR_SERVICE_EXISTS                = 1073
ERROR_ALREADY_RUNNING_LKG           = 1074
ERROR_SERVICE_DEPENDENCY_DELETED    = 1075
ERROR_BOOT_ALREADY_ACCEPTED         = 1076
ERROR_SERVICE_NEVER_STARTED         = 1077
ERROR_DUPLICATE_SERVICE_NAME        = 1078
ERROR_DIFFERENT_SERVICE_ACCOUNT     = 1079
ERROR_CANNOT_DETECT_DRIVER_FAILURE  = 1080
ERROR_CANNOT_DETECT_PROCESS_ABORT   = 1081
ERROR_NO_RECOVERY_PROGRAM           = 1082
ERROR_SERVICE_NOT_IN_EXE            = 1083
ERROR_NOT_SAFEBOOT_SERVICE          = 1084

ERROR_DEBUGGER_INACTIVE             = 1284

ERROR_PRIVILEGE_NOT_HELD            = 1314

ERROR_NONE_MAPPED                   = 1332

RPC_S_SERVER_UNAVAILABLE            = 1722

# Standard access rights
DELETE                           = 0x00010000
READ_CONTROL                     = 0x00020000
WRITE_DAC                        = 0x00040000
WRITE_OWNER                      = 0x00080000
SYNCHRONIZE                      = 0x00100000
STANDARD_RIGHTS_REQUIRED         = 0x000F0000
STANDARD_RIGHTS_READ             = READ_CONTROL
STANDARD_RIGHTS_WRITE            = READ_CONTROL
STANDARD_RIGHTS_EXECUTE          = READ_CONTROL
STANDARD_RIGHTS_ALL              = 0x001F0000
SPECIFIC_RIGHTS_ALL              = 0x0000FFFF

#--- Structures ---------------------------------------------------------------

# typedef struct _LSA_UNICODE_STRING {
#   USHORT Length;
#   USHORT MaximumLength;
#   PWSTR Buffer;
# } LSA_UNICODE_STRING,
#  *PLSA_UNICODE_STRING,
#  UNICODE_STRING,
#  *PUNICODE_STRING;
class UNICODE_STRING(Structure):
    _fields_ = [
        ("Length",          USHORT),
        ("MaximumLength",   USHORT),
        ("Buffer",          PVOID),
    ]

# From MSDN:
#
# typedef struct _GUID {
#   DWORD Data1;
#   WORD Data2;
#   WORD Data3;
#   BYTE Data4[8];
# } GUID;
class GUID(Structure):
    _fields_ = [
        ("Data1",   DWORD),
        ("Data2",   WORD),
        ("Data3",   WORD),
        ("Data4",   BYTE * 8),
]

# From MSDN:
#
# typedef struct _LIST_ENTRY {
#     struct _LIST_ENTRY *Flink;
#     struct _LIST_ENTRY *Blink;
# } LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;
class LIST_ENTRY(Structure):
    _fields_ = [
        ("Flink",   PVOID),     # POINTER(LIST_ENTRY)
        ("Blink",   PVOID),     # POINTER(LIST_ENTRY)
]

#==============================================================================
# This calculates the list of exported symbols.
_all = set(vars().keys()).difference(_all)
##__all__ = [_x for _x in _all if not _x.startswith('_')]
##__all__.sort()
#==============================================================================

```

`src/minidump/utils/winapi/kernel32.py`:

```py
from minidump.utils.winapi.defines import *
import enum


# DWORD WINAPI GetLastError(void);
def GetLastError():
    _GetLastError = windll.kernel32.GetLastError
    _GetLastError.argtypes = []
    _GetLastError.restype  = DWORD
    return _GetLastError()

class WindowsMinBuild(enum.Enum):
	WIN_XP = 2500
	WIN_2K3 = 3000
	WIN_VISTA = 5000
	WIN_7 = 7000
	WIN_8 = 8000
	WIN_BLUE = 9400
	WIN_10 = 9800

#utter microsoft bullshit commencing..
def getWindowsBuild():   
    class OSVersionInfo(ctypes.Structure):
        _fields_ = [
            ("dwOSVersionInfoSize" , ctypes.c_int),
            ("dwMajorVersion"      , ctypes.c_int),
            ("dwMinorVersion"      , ctypes.c_int),
            ("dwBuildNumber"       , ctypes.c_int),
            ("dwPlatformId"        , ctypes.c_int),
            ("szCSDVersion"        , ctypes.c_char*128)];
    GetVersionEx = getattr( ctypes.windll.kernel32 , "GetVersionExA")
    version  = OSVersionInfo()
    version.dwOSVersionInfoSize = ctypes.sizeof(OSVersionInfo)
    GetVersionEx( ctypes.byref(version) )    
    return version.dwBuildNumber

def get_all_access_flags():
    DELETE = 0x00010000
    READ_CONTROL = 0x00020000
    WRITE_DAC = 0x00040000
    WRITE_OWNER = 0x00080000

    SYNCHRONIZE = 0x00100000

    STANDARD_RIGHTS_REQUIRED = DELETE | READ_CONTROL | WRITE_DAC | WRITE_OWNER
    STANDARD_RIGHTS_ALL = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE

    if getWindowsBuild() >= WindowsMinBuild.WIN_VISTA.value:
        return STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFFF
    else:
        return STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFF

PROCESS_ALL_ACCESS = get_all_access_flags()

# Process access rights for OpenProcess
PROCESS_TERMINATE                 = 0x0001
PROCESS_CREATE_THREAD             = 0x0002
PROCESS_SET_SESSIONID             = 0x0004
PROCESS_VM_OPERATION              = 0x0008
PROCESS_VM_READ                   = 0x0010
PROCESS_VM_WRITE                  = 0x0020
PROCESS_DUP_HANDLE                = 0x0040
PROCESS_CREATE_PROCESS            = 0x0080
PROCESS_SET_QUOTA                 = 0x0100
PROCESS_SET_INFORMATION           = 0x0200
PROCESS_QUERY_INFORMATION         = 0x0400
PROCESS_SUSPEND_RESUME            = 0x0800
PROCESS_QUERY_LIMITED_INFORMATION = 0x1000

# Thread access rights for OpenThread
THREAD_TERMINATE                 = 0x0001
THREAD_SUSPEND_RESUME            = 0x0002
THREAD_ALERT                     = 0x0004
THREAD_GET_CONTEXT               = 0x0008
THREAD_SET_CONTEXT               = 0x0010
THREAD_SET_INFORMATION           = 0x0020
THREAD_QUERY_INFORMATION         = 0x0040
THREAD_SET_THREAD_TOKEN          = 0x0080
THREAD_IMPERSONATE               = 0x0100
THREAD_DIRECT_IMPERSONATION      = 0x0200
THREAD_SET_LIMITED_INFORMATION   = 0x0400
THREAD_QUERY_LIMITED_INFORMATION = 0x0800

# typedef struct DECLSPEC_ALIGN(16) _MEMORY_BASIC_INFORMATION64 {
#     ULONGLONG BaseAddress;
#     ULONGLONG AllocationBase;
#     DWORD     AllocationProtect;
#     DWORD     __alignment1;
#     ULONGLONG RegionSize;
#     DWORD     State;
#     DWORD     Protect;
#     DWORD     Type;
#     DWORD     __alignment2;
# } MEMORY_BASIC_INFORMATION64, *PMEMORY_BASIC_INFORMATION64;
class MEMORY_BASIC_INFORMATION64(Structure):
    _fields_ = [
        ('BaseAddress',         ULONGLONG),     # remote pointer
        ('AllocationBase',      ULONGLONG),     # remote pointer
        ('AllocationProtect',   DWORD),
        ('__alignment1',        DWORD),
        ('RegionSize',          ULONGLONG),
        ('State',               DWORD),
        ('Protect',             DWORD),
        ('Type',                DWORD),
        ('__alignment2',        DWORD),
    ]

# typedef struct _MEMORY_BASIC_INFORMATION {
#     PVOID BaseAddress;
#     PVOID AllocationBase;
#     DWORD AllocationProtect;
#     SIZE_T RegionSize;
#     DWORD State;
#     DWORD Protect;
#     DWORD Type;
# } MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
class MEMORY_BASIC_INFORMATION(Structure):
    _fields_ = [
        ('BaseAddress',         SIZE_T),    # remote pointer
        ('AllocationBase',      SIZE_T),    # remote pointer
        ('AllocationProtect',   DWORD),
        ('RegionSize',          SIZE_T),
        ('State',               DWORD),
        ('Protect',             DWORD),
        ('Type',                DWORD),
    ]
PMEMORY_BASIC_INFORMATION = POINTER(MEMORY_BASIC_INFORMATION)


# HANDLE WINAPI OpenProcess(
#   __in  DWORD dwDesiredAccess,
#   __in  BOOL bInheritHandle,
#   __in  DWORD dwProcessId
# );
def OpenProcess(dwDesiredAccess, bInheritHandle, dwProcessId):
    _OpenProcess = windll.kernel32.OpenProcess
    _OpenProcess.argtypes = [DWORD, BOOL, DWORD]
    _OpenProcess.restype  = HANDLE

    hProcess = _OpenProcess(dwDesiredAccess, bool(bInheritHandle), dwProcessId)
    if hProcess == NULL:
        raise ctypes.WinError()
    return hProcess

# SIZE_T WINAPI VirtualQueryEx(
#   __in      HANDLE hProcess,
#   __in_opt  LPCVOID lpAddress,
#   __out     PMEMORY_BASIC_INFORMATION lpBuffer,
#   __in      SIZE_T dwLength
# );
def VirtualQueryEx(hProcess, lpAddress):
    _VirtualQueryEx = windll.kernel32.VirtualQueryEx
    _VirtualQueryEx.argtypes = [HANDLE, LPVOID, PMEMORY_BASIC_INFORMATION, SIZE_T]
    _VirtualQueryEx.restype  = SIZE_T

    lpBuffer  = MEMORY_BASIC_INFORMATION()
    dwLength  = sizeof(MEMORY_BASIC_INFORMATION)
    success   = _VirtualQueryEx(hProcess, lpAddress, byref(lpBuffer), dwLength)
    if success == 0:
        raise ctypes.WinError()
    return lpBuffer


# BOOL WINAPI ReadProcessMemory(
#   __in   HANDLE hProcess,
#   __in   LPCVOID lpBaseAddress,
#   __out  LPVOID lpBuffer,
#   __in   SIZE_T nSize,
#   __out  SIZE_T* lpNumberOfBytesRead
# );
def ReadProcessMemory(hProcess, lpBaseAddress, nSize):
    _ReadProcessMemory = windll.kernel32.ReadProcessMemory
    _ReadProcessMemory.argtypes = [HANDLE, LPVOID, LPVOID, SIZE_T, POINTER(SIZE_T)]
    _ReadProcessMemory.restype  = bool

    lpBuffer            = ctypes.create_string_buffer(b'', nSize)
    lpNumberOfBytesRead = SIZE_T(0)
    success = _ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, byref(lpNumberOfBytesRead))
    if not success and GetLastError() != ERROR_PARTIAL_COPY:
        raise ctypes.WinError()
    return str(lpBuffer.raw)[:lpNumberOfBytesRead.value]
```

`src/minidump/utils/winapi/psapi.py`:

```py

from minidump.utils.winapi.defines import *


# typedef struct _MODULEINFO {
#   LPVOID lpBaseOfDll;
#   DWORD  SizeOfImage;
#   LPVOID EntryPoint;
# } MODULEINFO, *LPMODULEINFO;
class MODULEINFO(Structure):
    _fields_ = [
        ("lpBaseOfDll",     LPVOID),    # remote pointer
        ("SizeOfImage",     DWORD),
        ("EntryPoint",      LPVOID),    # remote pointer
]
LPMODULEINFO = POINTER(MODULEINFO)

# BOOL WINAPI EnumProcessModules(
#   __in   HANDLE hProcess,
#   __out  HMODULE *lphModule,
#   __in   DWORD cb,
#   __out  LPDWORD lpcbNeeded
# );
def EnumProcessModules(hProcess):
    _EnumProcessModules = windll.psapi.EnumProcessModules
    _EnumProcessModules.argtypes = [HANDLE, LPVOID, DWORD, LPDWORD]
    _EnumProcessModules.restype = bool
    _EnumProcessModules.errcheck = RaiseIfZero

    size = 0x1000
    lpcbNeeded = DWORD(size)
    unit = sizeof(HMODULE)
    while 1:
        lphModule = (HMODULE * (size // unit))()
        _EnumProcessModules(hProcess, byref(lphModule), lpcbNeeded, byref(lpcbNeeded))
        needed = lpcbNeeded.value
        if needed <= size:
            break
        size = needed
    return [ lphModule[index] for index in range(0, int(needed // unit)) ]

def GetModuleFileNameExW(hProcess, hModule = None):
    _GetModuleFileNameExW = ctypes.windll.psapi.GetModuleFileNameExW
    _GetModuleFileNameExW.argtypes = [HANDLE, HMODULE, LPWSTR, DWORD]
    _GetModuleFileNameExW.restype = DWORD

    nSize = MAX_PATH
    while 1:
        lpFilename = ctypes.create_unicode_buffer(u"", nSize)
        nCopied = _GetModuleFileNameExW(hProcess, hModule, lpFilename, nSize)
        if nCopied == 0:
            raise ctypes.WinError()
        if nCopied < (nSize - 1):
            break
        nSize = nSize + MAX_PATH
    return lpFilename.value

# BOOL WINAPI GetModuleInformation(
#   __in   HANDLE hProcess,
#   __in   HMODULE hModule,
#   __out  LPMODULEINFO lpmodinfo,
#   __in   DWORD cb
# );
def GetModuleInformation(hProcess, hModule, lpmodinfo = None):
    _GetModuleInformation = windll.psapi.GetModuleInformation
    _GetModuleInformation.argtypes = [HANDLE, HMODULE, LPMODULEINFO, DWORD]
    _GetModuleInformation.restype = bool
    _GetModuleInformation.errcheck = RaiseIfZero

    if lpmodinfo is None:
        lpmodinfo = MODULEINFO()
    _GetModuleInformation(hProcess, hModule, byref(lpmodinfo), sizeof(lpmodinfo))
    return lpmodinfo
```

`src/minidump/utils/winapi/version.py`:

```py
from minidump.utils.winapi.defines import *
import ctypes
from ctypes import windll, byref, Structure

class _SYSTEM_INFO_OEM_ID_STRUCT(Structure):
    _fields_ = [
        ("wProcessorArchitecture",  WORD),
        ("wReserved",               WORD),
]

class _SYSTEM_INFO_OEM_ID(Union):
    _fields_ = [
        ("dwOemId",  DWORD),
        ("w",        _SYSTEM_INFO_OEM_ID_STRUCT),
]


class SYSTEM_INFO(Structure):
    _fields_ = [
        ("id",                              _SYSTEM_INFO_OEM_ID),
        ("dwPageSize",                      DWORD),
        ("lpMinimumApplicationAddress",     LPVOID),
        ("lpMaximumApplicationAddress",     LPVOID),
        ("dwActiveProcessorMask",           DWORD_PTR),
        ("dwNumberOfProcessors",            DWORD),
        ("dwProcessorType",                 DWORD),
        ("dwAllocationGranularity",         DWORD),
        ("wProcessorLevel",                 WORD),
        ("wProcessorRevision",              WORD),
    ]

    def __get_dwOemId(self):
        return self.id.dwOemId
    def __set_dwOemId(self, value):
        self.id.dwOemId = value
    dwOemId = property(__get_dwOemId, __set_dwOemId)

    def __get_wProcessorArchitecture(self):
        return self.id.w.wProcessorArchitecture
    def __set_wProcessorArchitecture(self, value):
        self.id.w.wProcessorArchitecture = value
    wProcessorArchitecture = property(__get_wProcessorArchitecture, __set_wProcessorArchitecture)

LPSYSTEM_INFO = ctypes.POINTER(SYSTEM_INFO)

class OSVERSIONINFOW(Structure):
    _fields_ = [
        ("dwOSVersionInfoSize", DWORD),
        ("dwMajorVersion",      DWORD),
        ("dwMinorVersion",      DWORD),
        ("dwBuildNumber",       DWORD),
        ("dwPlatformId",        DWORD),
        ("szCSDVersion",        WCHAR * 128),
    ]

class OSVERSIONINFOEXW(Structure):
    _fields_ = [
        ("dwOSVersionInfoSize", DWORD),
        ("dwMajorVersion",      DWORD),
        ("dwMinorVersion",      DWORD),
        ("dwBuildNumber",       DWORD),
        ("dwPlatformId",        DWORD),
        ("szCSDVersion",        WCHAR * 128),
        ("wServicePackMajor",   WORD),
        ("wServicePackMinor",   WORD),
        ("wSuiteMask",          WORD),
        ("wProductType",        BYTE),
        ("wReserved",           BYTE),
    ]


def GetSystemInfo():
    _GetSystemInfo = windll.kernel32.GetSystemInfo
    _GetSystemInfo.argtypes = [LPSYSTEM_INFO]
    _GetSystemInfo.restype  = None

    sysinfo = SYSTEM_INFO()
    _GetSystemInfo(byref(sysinfo))
    return sysinfo

def GetVersionExW():
    _GetVersionExW = windll.kernel32.GetVersionExW
    _GetVersionExW.argtypes = [POINTER(OSVERSIONINFOEXW)]
    _GetVersionExW.restype  = bool
    _GetVersionExW.errcheck = RaiseIfZero

    osi = OSVERSIONINFOEXW()
    osi.dwOSVersionInfoSize = sizeof(osi)
    try:
        _GetVersionExW(byref(osi))
    except WindowsError:
        osi = OSVERSIONINFOW()
        osi.dwOSVersionInfoSize = sizeof(osi)
        _GetVersionExW.argtypes = [POINTER(OSVERSIONINFOW)]
        _GetVersionExW(byref(osi))
    return osi

def GetFileVersionInfoW(lptstrFilename):
    _GetFileVersionInfoW = windll.version.GetFileVersionInfoW
    _GetFileVersionInfoW.argtypes = [LPWSTR, DWORD, DWORD, LPVOID]
    _GetFileVersionInfoW.restype  = bool
    _GetFileVersionInfoW.errcheck = RaiseIfZero

    _GetFileVersionInfoSizeW = windll.version.GetFileVersionInfoSizeW
    _GetFileVersionInfoSizeW.argtypes = [LPWSTR, LPVOID]
    _GetFileVersionInfoSizeW.restype  = DWORD
    _GetFileVersionInfoSizeW.errcheck = RaiseIfZero

    dwLen = _GetFileVersionInfoSizeW(lptstrFilename, None)
    lpData = ctypes.create_string_buffer(dwLen)  # not a string!
    _GetFileVersionInfoW(lptstrFilename, 0, dwLen, byref(lpData))
    return lpData
```

`src/minidump/win_datatypes.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

# https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx

class POINTER:
	def __init__(self, reader, finaltype):
		self.location = reader.tell()
		self.value = reader.read_uint()
		self.finaltype = finaltype
		
	def read(self, reader, override_finaltype = None):
		if self.value == 0:
			return None
		pos = reader.tell()
		reader.move(self.value)
		if override_finaltype:
			data = override_finaltype(reader)
		else:
			data = self.finaltype(reader)
		reader.move(pos)
		return data
	
	def read_raw(self, reader, size ):
		#we do not know the finaltype, just want the data
		if self.value == 0:
			return None
		pos = reader.tell()
		reader.move(self.value)
		data = reader.read(size)
		reader.move(pos)
		return data
		
class PVOID(POINTER):
	def __init__(self, reader):
		super().__init__(reader, None) #with void we cannot determine the final type
		
class BOOL:
	def __init__(self, reader):
		self.value = bool(reader.read_uint())
		
class BOOLEAN:
	def __init__(self, reader):
		self.value = reader.read(1)
		
class BYTE:
	def __init__(self, reader):
		self.value = reader.read(1)
		
class PBYTE(POINTER):
	def __init__(self, reader):
		super().__init__(reader, BYTE)

class CCHAR:
	def __init__(self, reader):
		self.value = reader.read(1).decode('ascii')
		
class CHAR:
	def __init__(self, reader):
		self.value = reader.read(1).decode('ascii')
		
class UCHAR:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(1), byteorder = 'little', signed = False)

class WORD:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(2), byteorder = 'little', signed = False)		

class DWORD:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(4), byteorder = 'little', signed = False)
		
class DWORDLONG:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = False)
		
class DWORD_PTR(POINTER):
	def __init__(self, reader):
		super().__init__(reader, DWORD)
		
class DWORD32:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(4), byteorder = 'little', signed = False)

class DWORD64:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = False)		

	
class HANDLE:
	def __init__(self, reader):
		self.value = reader.read_uint()
		
class HFILE:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(4), byteorder = 'little', signed = False)
		
class HINSTANCE:
	def __init__(self, reader):
		self.value = reader.read_uint()		
		

class HKEY:
	def __init__(self, reader):
		self.value = reader.read_uint()


class HKL:
	def __init__(self, reader):
		self.value = reader.read_uint()
		
class HLOCAL:
	def __init__(self, reader):
		self.value = reader.read_uint()

class INT:
	def __init__(self, reader):
		self.value = reader.read_int()

class INT_PTR(POINTER):
	def __init__(self, reader):
		super().__init__(reader, INT)

class UINT8:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(1), byteorder = 'little', signed = False)

class INT8:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(1), byteorder = 'little', signed = True)

class INT16:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(2), byteorder = 'little', signed = True)

class INT32:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(4), byteorder = 'little', signed = True)

class INT64:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = True)

class LONG:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(4), byteorder = 'little', signed = True)

class LONGLONG:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = True)

class LONG_PTR(POINTER):
	def __init__(self, reader):
		super().__init__(reader, LONG)

class LONG32:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = True)

class LONG64():
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = True)

class LPARAM(POINTER):
	def __init__(self, reader):
		super().__init__(reader, LONG)

class LPBOOL(POINTER):
	def __init__(self, reader):
		super().__init__(reader, BOOL)

class LPBYTE(POINTER):
	def __init__(self, reader):
		super().__init__(reader, BYTE)

class ULONG:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(4), byteorder = 'little', signed = False)
		
class ULONGLONG:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = False)

class ULONG32:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(4), byteorder = 'little', signed = False)
		
class ULONG64:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = False)
		
class PWSTR(POINTER):
	def __init__(self, reader):
		super().__init__(reader, None)
		
class PCHAR(POINTER):
	def __init__(self, reader):
		super().__init__(reader, CHAR)
		
class USHORT:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(2), byteorder = 'little', signed = False)
		
class SHORT:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(2), byteorder = 'little', signed = True)
		
#https://msdn.microsoft.com/en-us/library/windows/hardware/ff554296(v=vs.85).aspx
class LIST_ENTRY:
	def __init__(self, reader, finaltype = None):
		self.Flink = POINTER(reader, finaltype)
		self.Blink = POINTER(reader, finaltype)
		
class FILETIME:
	def __init__(self, reader):
		self.dwLowDateTime = DWORD(reader)
		self.dwHighDateTime = DWORD(reader)
		self.value = (self.dwHighDateTime.value << 32) + self.dwLowDateTime.value
		
class PUCHAR(POINTER):
	def __init__(self, reader):
		super().__init__(reader, UCHAR)
		
class PCWSTR(POINTER):
	def __init__(self, reader):
		super().__init__(reader, None)
		
class SIZE_T:
	def __init__(self, reader):
		self.value = reader.read_uint()
		
		

		
```

`src/minidump/writer.py`:

```py
from minidump.constants import MINIDUMP_STREAM_TYPE, MINIDUMP_TYPE
from minidump.header import MinidumpHeader
from minidump.common_structs import MINIDUMP_LOCATION_DESCRIPTOR

from minidump.utils.winapi.version import GetSystemInfo, GetVersionExW
from minidump.utils.winapi.kernel32 import OpenProcess, PROCESS_ALL_ACCESS, VirtualQueryEx, ReadProcessMemory
from minidump.utils.winapi.psapi import EnumProcessModules, GetModuleInformation, GetModuleFileNameExW
from minidump.utils.winapi.version import GetFileVersionInfoW
from minidump.streams import MINIDUMP_SYSTEM_INFO, PROCESSOR_ARCHITECTURE, MINIDUMP_MODULE_LIST, \
	MINIDUMP_MODULE, VS_FIXEDFILEINFO, MINIDUMP_MEMORY_INFO_LIST, MINIDUMP_MEMORY_INFO, \
	AllocationProtect, MemoryType, MemoryState, \
	MINIDUMP_MEMORY64_LIST, MINIDUMP_MEMORY_DESCRIPTOR64

from minidump.streams.SystemInfoStream import PROCESSOR_ARCHITECTURE, PRODUCT_TYPE

from minidump.directory import MINIDUMP_DIRECTORY

import io

class MinidumpSystemReader:
	def __init__(self):
		pass

	def setup(self):
		pass

	def get_sysinfo(self):
		pass

	def get_modules(self):
		pass

	def get_sections(self):
		pass

	def get_memory(self):
		pass

	def get_threads(self):
		pass

	def get_exceptions(self):
		pass

class LiveSystemReader(MinidumpSystemReader):
	def __init__(self, pid):
		MinidumpSystemReader.__init__(self)
		self.pid = pid
		self.process_handle = None
		self.sysinfo = None
		self.meminfolist = None
		self.setup()

	def open_process(self):
		self.process_handle = OpenProcess(PROCESS_ALL_ACCESS, False, self.pid)

	def setup(self):
		self.open_process()

	def get_sysinfo(self):
		#https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsysteminfo
		sysinfo_raw = GetSystemInfo()
		version_raw = GetVersionExW()

		sysinfo = MINIDUMP_SYSTEM_INFO()
		sysinfo.ProcessorArchitecture = PROCESSOR_ARCHITECTURE(sysinfo_raw.id.w.wProcessorArchitecture)
		sysinfo.ProcessorLevel = sysinfo_raw.wProcessorLevel
		sysinfo.ProcessorRevision = sysinfo_raw.wProcessorRevision
		#sysinfo.Reserved0 = None
		sysinfo.NumberOfProcessors = sysinfo_raw.dwNumberOfProcessors
		sysinfo.ProductType = PRODUCT_TYPE(version_raw.wProductType)
		sysinfo.MajorVersion = version_raw.dwMajorVersion
		sysinfo.MinorVersion = version_raw.dwMinorVersion
		sysinfo.BuildNumber = version_raw.dwBuildNumber
		sysinfo.PlatformId = version_raw.dwPlatformId
		sysinfo.CSDVersionRva = 0
		#sysinfo.Reserved1 = None
		sysinfo.SuiteMask = version_raw.wSuiteMask
		#sysinfo.Reserved2 = None

		sysinfo.CSDVersion = version_raw.szCSDVersion

		#below todo, keeping all zeroes for now..
		if sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.INTEL:
			sysinfo.VendorId = [0,0,0]
			sysinfo.VersionInformation = 0
			sysinfo.FeatureInformation = 0
			sysinfo.AMDExtendedCpuFeatures = 0
		else:
			sysinfo.ProcessorFeatures = [0,0]

		self.sysinfo_raw = sysinfo_raw

		return sysinfo


	def get_modules(self):
		#https://docs.microsoft.com/en-us/windows/win32/psapi/enumerating-all-modules-for-a-process
		#https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocessmodules
		#
		module_list = MINIDUMP_MODULE_LIST()
		for module in EnumProcessModules(self.process_handle):
			print(module)
			modinfo = GetModuleInformation(self.process_handle,module)
			modname = GetModuleFileNameExW(self.process_handle,module)
			fileversion_raw = GetFileVersionInfoW(modname)
			fileversion = VS_FIXEDFILEINFO.from_bytes(fileversion_raw)
			print(modname)
			mmod = MINIDUMP_MODULE()
			mmod.BaseOfImage = modinfo.lpBaseOfDll
			mmod.SizeOfImage = modinfo.SizeOfImage
			mmod.TimeDateStamp = fileversion.dwFileDateMS << 32 + fileversion.dwFileDateLS
			mmod.ModuleNameRva = None
			mmod.VersionInfo = fileversion
			mmod.CvRecord = 0 # TODO?
			mmod.MiscRecord = 0 # TODO?

			mmod.ModuleName = modname

			module_list.Modules.append(mmod)
		
		return module_list

	def get_sections(self):
		#https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualqueryex
		if self.sysinfo_raw is None:
			self.get_sysinfo()
		meminfolist = MINIDUMP_MEMORY_INFO_LIST()
		i = self.sysinfo_raw.lpMinimumApplicationAddress
		while i < self.sysinfo_raw.lpMaximumApplicationAddress:
			mi_raw = VirtualQueryEx(self.process_handle, i)
			mi = MINIDUMP_MEMORY_INFO()
			mi.BaseAddress = mi_raw.BaseAddress
			mi.AllocationBase = mi_raw.AllocationBase
			mi.AllocationProtect = mi_raw.AllocationProtect
			mi.RegionSize = mi_raw.RegionSize
			try:
				mi.State = MemoryState(mi_raw.State)
			except:
				mi.State = mi_raw.State
			try:
				mi.Protect = AllocationProtect(mi_raw.Protect)
			except:
				mi.Protect = mi_raw.Protect
			try:
				mi.Type = MemoryType(mi_raw.Type)
			except:
				mi.Type = mi_raw.Type

			meminfolist.entries.append(mi)
			print(str(mi))
			
			i += mi_raw.RegionSize
		self.meminfolist = meminfolist
		return meminfolist
	
	def get_threads(self):
		pass

	def get_exceptions(self):
		pass

	def get_memory(self):
		read_flags = [AllocationProtect.PAGE_EXECUTE_READ,
				AllocationProtect.PAGE_EXECUTE_READWRITE,
				AllocationProtect.PAGE_READONLY,
				AllocationProtect.PAGE_EXECUTE,
				AllocationProtect.PAGE_READWRITE,
				AllocationProtect.PAGE_WRITECOPY
		]
		memlist = MINIDUMP_MEMORY64_LIST()
		for section in self.meminfolist.entries:
			if section.Protect in read_flags:
				memdesc = MINIDUMP_MEMORY_DESCRIPTOR64()
				memdesc.StartOfMemoryRange = section.BaseAddress
				memdesc.DataSize = section.RegionSize
				print(section.Protect)
				data = ReadProcessMemory(self.process_handle, section.BaseAddress, section.RegionSize)
				input(data)
				memlist.MemoryRanges.append(memdesc)

		return memlist


class MinidumpWriter:
	def __init__(self,sysreader):
		self.sysreader = sysreader
		self.output_file = None

		self.streams = {} #stream type -> list of stream objects

		self.header = None
		self.directory_list = []
		self.directory_rva = 28
		self.header_size = None

		self.header_buffer = io.BytesIO()
		self.data_buffer = io.BytesIO()

	def prepare_header(self):
		self.header = MinidumpHeader()
		self.header.Version = 1
		self.header.ImplementationVersion = 1
		self.header.NumberOfStreams = len(self.streams) +1 # +1 is fot he memory info stream
		self.header.StreamDirectoryRva = self.directory_rva
		#self.header.CheckSum = None
		#self.header.Reserved = None
		#self.header.TimeDateStamp = None
		self.header.Flags = MINIDUMP_TYPE.MiniDumpWithFullMemory
		self.header_buffer.write(self.header.to_bytes())

	def prepare_directory(self):
		curr_pos = self.header_size
		for streamtype in self.streams:
			self.streams[streamtype].to_bytes(self.data_buffer)
			directory = MINIDUMP_DIRECTORY()
			directory.StreamType = streamtype
			directory.Location = curr_pos
			self.header_buffer.write(directory.to_bytes())

	def finalize_header(self):
		# currently only using the 32 bit MINIDUMP_LOCATION_DESCRIPTOR, this is because we expect that the header 
		# and any data in the header (including all streams data except memory stream) will not be bigger than 4GB
		# memory stream is a special case, as it cvan be longer than 4GB but the RVA to the beginning of the memory stream 
		# is not expected to be bigger than 4G max.
		# if this becomes the case then this all will fail :)
		header_size = 28
		header_size += len(self.streams) * 8 #this is for the dictionary itself, not the streams
		for stream in self.streams:
			header_size += self.streams[stream].get_size()
		
		header_size += 10 * 1024 #allocating 10k for the memory info

		self.prepare_header()
		self.prepare_directory()

		
		
		

	def create_streams(self):
		sysinfo = self.sysreader.get_sysinfo()
		self.streams[MINIDUMP_STREAM_TYPE.SystemInfoStream] = sysinfo

		print(str(sysinfo))
		moduleinfo = self.sysreader.get_modules()
		self.streams[MINIDUMP_STREAM_TYPE.ModuleListStream] = moduleinfo
		
		sections = self.sysreader.get_sections()
		self.streams[MINIDUMP_STREAM_TYPE.MemoryInfoListStream] = sections
		
		self.finalize_header()

		memory = self.sysreader.get_memory()
		
		
	#def get_total_streams_cnt(self):
	#	total = 0
	#	for t in self.streams:
	#		total += len(t)
	#	return total

	

		

	#def construct_directory(self):
	#
	#	total_streams = self.get_total_streams_cnt()
	#
	#	for stype in self.streams:			
	#		for stream in self.streams[stype]:
	#			
	#			stream
	#
	#			loc = MINIDUMP_LOCATION_DESCRIPTOR()
	#			loc.DataSize = 0
	#			loc.Rva = 0
	#			directory = MINIDUMP_DIRECTORY()
	#			directory.StreamType = stream
	#			self.directory.append()


	def write_header(self):
		hdr_pos = self.hdr_buff.tell()
		self.hdr_buff.seek(0,0)
		self.hdr_buff.write(self.construct_header())
		self.hdr_buff.seek(hdr_pos, 0)
		return


	def construct_directory(self):
		self.sysreader.get_sysinfo(self.hdr_buff, self.data_buff)
		self.stream_cnt += 1
		#modules
		#self.sysreader.get_modules(self.hdr_buff, self.data_buff)
		#self.stream_cnt += 1
		
		#write header
		self.write_header()
		

		#append datastream for memory, with correct rva
		
		#dump memory

	def run(self):
		self.create_streams()


if __name__ == '__main__':
	pid = 9600
	sysreader = LiveSystemReader(pid)
	writer = MinidumpWriter(sysreader)
	writer.run()

```

`tests/DumpulatorTests/DumpulatorTests.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32922.545
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Loader", "Loader\Loader.vcxproj", "{8F7621EE-2179-4E66-B058-B11C5908CF3E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Tests", "Tests\Tests.vcxproj", "{F33082EB-B49F-4630-B919-B9B18C86E358}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HarnessMinimal", "HarnessMinimal\HarnessMinimal.vcxproj", "{CBD65637-B773-430B-AF11-A0AFEB699D8F}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HarnessFull", "HarnessFull\HarnessFull.vcxproj", "{1FD2D0B5-53E2-4E9E-AA4B-2E822ABD2D49}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ExceptionTest", "ExceptionTest\ExceptionTest.vcxproj", "{8D02ACE7-0361-45F7-B173-3188B235F2DC}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{8F7621EE-2179-4E66-B058-B11C5908CF3E}.Release|Win32.ActiveCfg = Release|Win32
		{8F7621EE-2179-4E66-B058-B11C5908CF3E}.Release|Win32.Build.0 = Release|Win32
		{8F7621EE-2179-4E66-B058-B11C5908CF3E}.Release|x64.ActiveCfg = Release|x64
		{8F7621EE-2179-4E66-B058-B11C5908CF3E}.Release|x64.Build.0 = Release|x64
		{F33082EB-B49F-4630-B919-B9B18C86E358}.Release|Win32.ActiveCfg = Release|Win32
		{F33082EB-B49F-4630-B919-B9B18C86E358}.Release|Win32.Build.0 = Release|Win32
		{F33082EB-B49F-4630-B919-B9B18C86E358}.Release|x64.ActiveCfg = Release|x64
		{F33082EB-B49F-4630-B919-B9B18C86E358}.Release|x64.Build.0 = Release|x64
		{CBD65637-B773-430B-AF11-A0AFEB699D8F}.Release|Win32.ActiveCfg = Release|Win32
		{CBD65637-B773-430B-AF11-A0AFEB699D8F}.Release|Win32.Build.0 = Release|Win32
		{CBD65637-B773-430B-AF11-A0AFEB699D8F}.Release|x64.ActiveCfg = Release|x64
		{CBD65637-B773-430B-AF11-A0AFEB699D8F}.Release|x64.Build.0 = Release|x64
		{1FD2D0B5-53E2-4E9E-AA4B-2E822ABD2D49}.Release|Win32.ActiveCfg = Release|Win32
		{1FD2D0B5-53E2-4E9E-AA4B-2E822ABD2D49}.Release|Win32.Build.0 = Release|Win32
		{1FD2D0B5-53E2-4E9E-AA4B-2E822ABD2D49}.Release|x64.ActiveCfg = Release|x64
		{1FD2D0B5-53E2-4E9E-AA4B-2E822ABD2D49}.Release|x64.Build.0 = Release|x64
		{8D02ACE7-0361-45F7-B173-3188B235F2DC}.Release|Win32.ActiveCfg = Release|Win32
		{8D02ACE7-0361-45F7-B173-3188B235F2DC}.Release|Win32.Build.0 = Release|Win32
		{8D02ACE7-0361-45F7-B173-3188B235F2DC}.Release|x64.ActiveCfg = Release|x64
		{8D02ACE7-0361-45F7-B173-3188B235F2DC}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B2416A67-4257-41D9-AD43-263D0467D10D}
	EndGlobalSection
EndGlobal

```

`tests/DumpulatorTests/ExceptionTest/ExceptionTest.cpp`:

```cpp
#include "../Tests/debug.h"
#include <cstdlib>

static LONG WINAPI VectoredHandler(struct _EXCEPTION_POINTERS* ExceptionInfo)
{
	DebugPrint(WIDEN(__FUNCTION__));
	return EXCEPTION_CONTINUE_SEARCH;
}

static LONG WINAPI ContinueHandler(struct _EXCEPTION_POINTERS* ExceptionInfo)
{
	DebugPrint(WIDEN(__FUNCTION__));
	return EXCEPTION_CONTINUE_SEARCH;
}

static LPTOP_LEVEL_EXCEPTION_FILTER previousFilter;

static LONG WINAPI ExceptionFilter(struct _EXCEPTION_POINTERS* ExceptionInfo)
{
	DebugPrint(WIDEN(__FUNCTION__));
	if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT)
	{
#ifdef _WIN64
		ExceptionInfo->ContextRecord->Rip++;
#else
		ExceptionInfo->ContextRecord->Eip++;
#endif // _WIN64
		return EXCEPTION_CONTINUE_EXECUTION;
	}
	return previousFilter(ExceptionInfo);
}

static int __try_filter(unsigned int code, struct _EXCEPTION_POINTERS* ExceptionInfo)
{
	DebugPrint(WIDEN(__FUNCTION__));
	const auto& er = *ExceptionInfo->ExceptionRecord;
	if (er.ExceptionCode == EXCEPTION_ACCESS_VIOLATION && er.ExceptionInformation[1] == 0xDEADF00D)
	{
		return EXCEPTION_EXECUTE_HANDLER;
	}
	return EXCEPTION_CONTINUE_SEARCH;
}

extern "C" __declspec(dllexport) bool Exception_Test()
{
	DebugPrint(WIDEN(__FUNCTION__));
	DebugPrint(L"Test VEH, SEH, VCH");
	AddVectoredExceptionHandler(1, VectoredHandler);
	AddVectoredContinueHandler(1, ContinueHandler);

	__try
	{
		*((size_t*)(uintptr_t)0xDEADF00D) = 0;
	}
	__except (__try_filter(GetExceptionCode(), GetExceptionInformation()))
	{
		DebugPrint(L"__except handler");
	}

	DebugPrint(L"Test SetUnhandledExceptionFilter");
	previousFilter = SetUnhandledExceptionFilter(ExceptionFilter);
	__debugbreak();
	DebugPrint(L"Finished!");
	return true;
}


int main(int argc, char** argv)
{
    auto exitCode = Exception_Test() ? EXIT_SUCCESS : EXIT_FAILURE;
    ExitProcess(exitCode);
}
```

`tests/DumpulatorTests/ExceptionTest/ExceptionTest.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{8D02ACE7-0361-45F7-B173-3188B235F2DC}</ProjectGuid>
    <RootNamespace>ExceptionTest</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)_obj\$(Platform)\$(ProjectName)\</IntDir>
    <TargetName>$(ProjectName)_x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)_obj\$(Platform)\$(ProjectName)\</IntDir>
    <TargetName>$(ProjectName)_x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>ntdll.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>ntdll.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="ExceptionTest.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`tests/DumpulatorTests/ExceptionTest/ExceptionTest.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ExceptionTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`tests/DumpulatorTests/HarnessFull/HarnessFull.cpp`:

```cpp

#include <winsock2.h>
#include <ws2tcpip.h>
#include <Windows.h>
#include <CommCtrl.h>

int EntryPoint(void* peb)
{
	WSADATA wsa;
	WSAStartup(0, &wsa);
	CoInitialize(0);
	ShellExecuteW(0, L"open", L".", nullptr, nullptr, SW_SHOWNORMAL);
	MessageBeep(MB_ICONERROR);
	InitCommonControls();
	HKEY key;
	RegOpenKeyW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", &key);
	BCRYPT_ALG_HANDLE alg;
	BCryptOpenAlgorithmProvider(&alg, BCRYPT_RC4_ALGORITHM, nullptr, 0);
	HCRYPTPROV prov;
	CryptAcquireContextW(&prov, nullptr, nullptr, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
	__debugbreak(); // Dump here
	return 0;
}
```

`tests/DumpulatorTests/HarnessFull/HarnessFull.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1fd2d0b5-53e2-4e9e-aa4b-2e822abd2d49}</ProjectGuid>
    <RootNamespace>HarnessFull</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)_obj\$(Platform)\$(ProjectName)\</IntDir>
    <TargetName>$(ProjectName)_x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)_obj\$(Platform)\$(ProjectName)\</IntDir>
    <TargetName>$(ProjectName)_x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <Optimization>Disabled</Optimization>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <CallingConvention>StdCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>EntryPoint</EntryPointSymbol>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>bcrypt.lib;ws2_32.lib;Comctl32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <BaseAddress>0x300000</BaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <Optimization>Disabled</Optimization>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <CallingConvention>StdCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>EntryPoint</EntryPointSymbol>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>bcrypt.lib;ws2_32.lib;Comctl32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <BaseAddress>0x130000000</BaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="HarnessFull.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`tests/DumpulatorTests/HarnessFull/HarnessFull.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HarnessFull.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`tests/DumpulatorTests/HarnessMinimal/HarnessMinimal.cpp`:

```cpp
#include <Windows.h>

//extern "C" uintptr_t __cdecl _threadhandle(void);

int EntryPoint(void* peb)
{
#ifndef _WIN64
    __threadhandle();
#endif // _WIN64
    return 0;
}
```

`tests/DumpulatorTests/HarnessMinimal/HarnessMinimal.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{cbd65637-b773-430b-af11-a0afeb699d8f}</ProjectGuid>
    <RootNamespace>HarnessMinimal</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)_obj\$(Platform)\$(ProjectName)\</IntDir>
    <TargetName>$(ProjectName)_x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)_obj\$(Platform)\$(ProjectName)\</IntDir>
    <TargetName>$(ProjectName)_x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExceptionHandling>Sync</ExceptionHandling>
      <CallingConvention>StdCall</CallingConvention>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>EntryPoint</EntryPointSymbol>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>msvcrt_x86.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <BaseAddress>0x300000</BaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExceptionHandling>Sync</ExceptionHandling>
      <CallingConvention>StdCall</CallingConvention>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>EntryPoint</EntryPointSymbol>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <BaseAddress>0x130000000</BaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="HarnessMinimal.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`tests/DumpulatorTests/HarnessMinimal/HarnessMinimal.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HarnessMinimal.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`tests/DumpulatorTests/HarnessMinimal/msvcrt_x86.def`:

```def
LIBRARY msvcrt.dll
EXPORTS
    __threadhandle
```

`tests/DumpulatorTests/Loader/Loader.cpp`:

```cpp
#include "../Tests/debug.h"
#include <cstdio>
#include <cstdlib>

int main(int argc, char** argv)
{
#ifdef _WIN64
    auto dll = "Tests_x64.dll";
#else
    auto dll = "Tests_x86.dll";
#endif // _WIN64
    auto hLib = LoadLibraryA(dll);
    auto p_DebugPrintf = (void**)GetProcAddress(hLib, "DebugPrintf");
    if (p_DebugPrintf != nullptr)
        *p_DebugPrintf = printf;
    if (argc < 2)
    {
        // TODO: implement enumerating all exports and running them
        puts("Usage: Loader TestFunction");
        return EXIT_FAILURE;
    }
    auto TestFunction = (int(*)())GetProcAddress(hLib, argv[1]);
    if (TestFunction == nullptr)
    {
        printf("Could not find function: %s\n", argv[1]);
        return EXIT_FAILURE;
    }
    // Trigger a breakpoint to allow the debugger to dump
    if (argc > 2)
        __debugbreak();
    auto exitCode = TestFunction() ? EXIT_SUCCESS : EXIT_FAILURE;
    ExitProcess(exitCode);
}
```

`tests/DumpulatorTests/Loader/Loader.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{8F7621EE-2179-4E66-B058-B11C5908CF3E}</ProjectGuid>
    <RootNamespace>Loader</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)_obj\$(Platform)\$(ProjectName)\</IntDir>
    <TargetName>$(ProjectName)_x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)_obj\$(Platform)\$(ProjectName)\</IntDir>
    <TargetName>$(ProjectName)_x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Loader.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`tests/DumpulatorTests/Loader/Loader.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Loader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`tests/DumpulatorTests/README.md`:

```md
# DumpulatorTests

## Creating a dump

The harness dumps were created as follows:

- Start a clean Windows Sandbox install
- Put x64dbg in there
- Install the [DisableParallelLoader](https://github.com/mrexodia/DisableParallelLoader) plugin and enable it
- Load the harness executable
- Execute the `dbh` command to hide the debugger from the PEB
- Run until the entry point
- Use the `minidump` command to create the dump

## Adding a new test

Add a new `mytest.cpp` file to the `Tests` project. The tests are exported as `bool <Prefix>_<description>Test();` and the result indicates whether the test was successful or not. If you need a custom environment add the following in `tests/run-tests.py`:

```python
class <Prefix>Environment(TestEnvironment):
    def setup(self, dp: Dumpulator):
        # TODO: use the dp class to initialize your environment
        pass
```
```

`tests/DumpulatorTests/Tests/DllMain.cpp`:

```cpp
#include "debug.h"

inline ULONG
STDAPIVCALLTYPE
DbgPrintNop(
	_In_z_ _Printf_format_string_ PCSTR Format,
	...
)
{
	return 0;
}

#ifdef _WIN64
#pragma comment(linker, "/EXPORT:DebugPrintf=DebugPrintf")
#else
#pragma comment(linker, "/EXPORT:DebugPrintf=_DebugPrintf")
#endif // _WIN64

extern "C" decltype(&DbgPrint) DebugPrintf = DbgPrintNop;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    return TRUE;
}
```

`tests/DumpulatorTests/Tests/HandleTest.cpp`:

```cpp
#include "debug.h"

extern "C" __declspec(dllexport) bool Handle_WriteAndCreateFileTest()
{
	DebugPrint(WIDEN(__FUNCTION__));

	char data_buffer[] = "Lorem ipsum dolor sit amet, consectetur adipiscing elit.";
	DWORD data_buffer_len = sizeof(data_buffer);
	DWORD bytes_written = 0;
	BOOL ret_value = FALSE;

	HANDLE file_handle = CreateFile(
		L"nonexistent_file.txt",
		GENERIC_WRITE,
		0,
		NULL,
		CREATE_NEW,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);

	if (file_handle == INVALID_HANDLE_VALUE)
	{
		DebugPrint(L"Failed to create file");
		return ret_value;
	}

	ret_value = WriteFile(
		file_handle,
		data_buffer,
		data_buffer_len,
		&bytes_written,
		NULL
	);

	CloseHandle(file_handle);

	return ret_value;
}

extern "C" __declspec(dllexport) bool Handle_ReadFileTest()
{
	DebugPrint(WIDEN(__FUNCTION__));

	DWORD bytes_written = 0;
	BOOL ret_value = FALSE;
	char read_buffer[1000];

	HANDLE file_handle = CreateFile(
		L"test_file.txt",
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);

	if (file_handle == INVALID_HANDLE_VALUE)
	{
		DebugPrint(L"Failed to open file");
		return false;
	}

	ret_value = ReadFile(
		file_handle,
		read_buffer,
		sizeof(read_buffer),
		&bytes_written,
		FALSE
	);


	CloseHandle(file_handle);

	return ret_value && memcmp(read_buffer, "Lorem ipsum", 11) == 0;
}

```

`tests/DumpulatorTests/Tests/MemoryTest.cpp`:

```cpp
#include "debug.h"

extern "C" __declspec(dllexport) bool Memory_PartialReleaseTest()
{
	PVOID Base = 0;
	SIZE_T RegionSize = 0x1c0000;
	auto status = NtAllocateVirtualMemory(NtCurrentProcess(), &Base, 0, &RegionSize, MEM_RESERVE, PAGE_READWRITE);
	DebugPrintf("status: 0x%08X, base: %p, size: %p\n", status, Base, RegionSize);
	if (!NT_SUCCESS(status))
		return false;
	
	SIZE_T PartialSize = RegionSize - 0x10000;
	status = NtFreeVirtualMemory(NtCurrentProcess(), &Base, &PartialSize, MEM_RELEASE);
	DebugPrintf("status: 0x%08X, base: %p, size: %p\n", status, Base, PartialSize);
	if (!NT_SUCCESS(status))
		return false;
	
	SIZE_T PageSize = 0x1000;
	PVOID PartialBase = (char*)Base + PartialSize;
	status = NtAllocateVirtualMemory(NtCurrentProcess(), &PartialBase, 0, &PageSize, MEM_COMMIT, PAGE_READWRITE);
	DebugPrintf("status: 0x%08X, base: %p, size: %p\n", status, PartialBase, PageSize);
	if (!NT_SUCCESS(status))
		return false;
	return true;
}

extern "C" __declspec(dllexport) bool Memory_MiddleReleaseTest()
{
	PVOID Base = 0;
	SIZE_T RegionSize = 0x30000;
	auto status = NtAllocateVirtualMemory(NtCurrentProcess(), &Base, 0, &RegionSize, MEM_RESERVE, PAGE_READWRITE);
	DebugPrintf("status: 0x%08X, base: %p, size: %p\n", status, Base, RegionSize);
	if (!NT_SUCCESS(status))
		return false;
	
	SIZE_T MiddleSize = 0x10000;
	PVOID MiddleBase = (char*)Base + 0x10000;
	status = NtFreeVirtualMemory(NtCurrentProcess(), &MiddleBase, &MiddleSize, MEM_RELEASE);
	DebugPrintf("status: 0x%08X, base: %p, size: %p\n", status, MiddleBase, MiddleSize);
	if (!NT_SUCCESS(status))
		return false;
	return true;
}
```

`tests/DumpulatorTests/Tests/Tests.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DllMain.cpp" />
    <ClCompile Include="HandleTest.cpp" />
    <ClCompile Include="MemoryTest.cpp" />
    <ClCompile Include="ntstatusdb.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="debug.h" />
    <ClInclude Include="ntstatusdb.h" />
    <ClInclude Include="phnt.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{f33082eb-b49f-4630-b919-b9b18c86e358}</ProjectGuid>
    <RootNamespace>ExceptionTest</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)_obj\$(Platform)\$(ProjectName)\</IntDir>
    <TargetName>$(ProjectName)_x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)_obj\$(Platform)\$(ProjectName)\</IntDir>
    <TargetName>$(ProjectName)_x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <WholeProgramOptimization>false</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <AdditionalOptions>/DYNAMICBASE:NO %(AdditionalOptions)</AdditionalOptions>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>exception_handler_x86.lib;ntdll.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <WholeProgramOptimization>false</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <AdditionalOptions>/DYNAMICBASE:NO %(AdditionalOptions)</AdditionalOptions>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>exception_handler_x64.lib;ntdll.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`tests/DumpulatorTests/Tests/Tests.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HandleTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DllMain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MemoryTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ntstatusdb.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="debug.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="phnt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ntstatusdb.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`tests/DumpulatorTests/Tests/debug.h`:

```h
#pragma once

#include "phnt.h"

#define WIDEN_EXPAND(str) L ## str
#define WIDEN(str) WIDEN_EXPAND(str)

#ifdef __cplusplus
// Helper function to directly call NtDisplayString with a string
// This simplifies the trace output of Dumpulator
template<size_t Count>
void DebugPrint(const wchar_t(&str)[Count])
{
	UNICODE_STRING ustr{ (Count - 1) * 2, Count * 2, (PWSTR)str };
	NtDisplayString(&ustr);
}
#else
static void DebugPrint(const wchar_t* str)
{
	int len = 0;
	while (str[len] != L'\0')
		len++;
	UNICODE_STRING ustr;
	ustr.Length = len * 2;
	ustr.MaximumLength = (len + 1) * 2;
	ustr.Buffer = (PWSTR)str;
	NtDisplayString(&ustr);
}
#endif // __cplusplus

extern "C" decltype(&DbgPrint) DebugPrintf;
```

`tests/DumpulatorTests/Tests/exception_handler_x64.def`:

```def
LIBRARY ntdll.dll
EXPORTS
    __C_specific_handler
```

`tests/DumpulatorTests/Tests/exception_handler_x86.def`:

```def
LIBRARY msvcrt.dll
EXPORTS
    _except_handler2
    _except_handler3
    _except_handler4_common
```

`tests/DumpulatorTests/Tests/ntstatusdb.cpp`:

```cpp
#include "ntstatusdb.h"

struct Status
{
	uint32_t value;
	const char* name;
};

static Status g_statusNames[] = {
{ 0x00000000, "STATUS_SUCCESS" },
{ 0x00000001, "STATUS_WAIT_1" },
{ 0x00000002, "STATUS_WAIT_2" },
{ 0x00000003, "STATUS_WAIT_3" },
{ 0x0000003F, "STATUS_WAIT_63" },
{ 0x00000080, "STATUS_ABANDONED" },
{ 0x000000BF, "STATUS_ABANDONED_WAIT_63" },
{ 0x000000C0, "STATUS_USER_APC" },
{ 0x000000FF, "STATUS_ALREADY_COMPLETE" },
{ 0x00000100, "STATUS_KERNEL_APC" },
{ 0x00000101, "STATUS_ALERTED" },
{ 0x00000102, "STATUS_TIMEOUT" },
{ 0x00000103, "STATUS_PENDING" },
{ 0x00000104, "STATUS_REPARSE" },
{ 0x00000105, "STATUS_MORE_ENTRIES" },
{ 0x00000106, "STATUS_NOT_ALL_ASSIGNED" },
{ 0x00000107, "STATUS_SOME_NOT_MAPPED" },
{ 0x00000108, "STATUS_OPLOCK_BREAK_IN_PROGRESS" },
{ 0x00000109, "STATUS_VOLUME_MOUNTED" },
{ 0x0000010A, "STATUS_RXACT_COMMITTED" },
{ 0x0000010B, "STATUS_NOTIFY_CLEANUP" },
{ 0x0000010C, "STATUS_NOTIFY_ENUM_DIR" },
{ 0x0000010D, "STATUS_NO_QUOTAS_FOR_ACCOUNT" },
{ 0x0000010E, "STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED" },
{ 0x00000110, "STATUS_PAGE_FAULT_TRANSITION" },
{ 0x00000111, "STATUS_PAGE_FAULT_DEMAND_ZERO" },
{ 0x00000112, "STATUS_PAGE_FAULT_COPY_ON_WRITE" },
{ 0x00000113, "STATUS_PAGE_FAULT_GUARD_PAGE" },
{ 0x00000114, "STATUS_PAGE_FAULT_PAGING_FILE" },
{ 0x00000115, "STATUS_CACHE_PAGE_LOCKED" },
{ 0x00000116, "STATUS_CRASH_DUMP" },
{ 0x00000117, "STATUS_BUFFER_ALL_ZEROS" },
{ 0x00000118, "STATUS_REPARSE_OBJECT" },
{ 0x00000119, "STATUS_RESOURCE_REQUIREMENTS_CHANGED" },
{ 0x00000120, "STATUS_TRANSLATION_COMPLETE" },
{ 0x00000121, "STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY" },
{ 0x00000122, "STATUS_NOTHING_TO_TERMINATE" },
{ 0x00000123, "STATUS_PROCESS_NOT_IN_JOB" },
{ 0x00000124, "STATUS_PROCESS_IN_JOB" },
{ 0x00000125, "STATUS_VOLSNAP_HIBERNATE_READY" },
{ 0x00000126, "STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY" },
{ 0x00000127, "STATUS_INTERRUPT_VECTOR_ALREADY_CONNECTED" },
{ 0x00000128, "STATUS_INTERRUPT_STILL_CONNECTED" },
{ 0x00000129, "STATUS_PROCESS_CLONED" },
{ 0x0000012A, "STATUS_FILE_LOCKED_WITH_ONLY_READERS" },
{ 0x0000012B, "STATUS_FILE_LOCKED_WITH_WRITERS" },
{ 0x0000012C, "STATUS_VALID_IMAGE_HASH" },
{ 0x0000012D, "STATUS_VALID_CATALOG_HASH" },
{ 0x0000012E, "STATUS_VALID_STRONG_CODE_HASH" },
{ 0x0000012F, "STATUS_GHOSTED" },
{ 0x00000202, "STATUS_RESOURCEMANAGER_READ_ONLY" },
{ 0x00000210, "STATUS_RING_PREVIOUSLY_EMPTY" },
{ 0x00000211, "STATUS_RING_PREVIOUSLY_FULL" },
{ 0x00000212, "STATUS_RING_PREVIOUSLY_ABOVE_QUOTA" },
{ 0x00000213, "STATUS_RING_NEWLY_EMPTY" },
{ 0x00000214, "STATUS_RING_SIGNAL_OPPOSITE_ENDPOINT" },
{ 0x00000215, "STATUS_OPLOCK_SWITCHED_TO_NEW_HANDLE" },
{ 0x00000216, "STATUS_OPLOCK_HANDLE_CLOSED" },
{ 0x00000367, "STATUS_WAIT_FOR_OPLOCK" },
{ 0x00000368, "STATUS_REPARSE_GLOBAL" },
{ 0x00010001, "DBG_EXCEPTION_HANDLED" },
{ 0x00010002, "DBG_CONTINUE" },
{ 0x001C0001, "STATUS_FLT_IO_COMPLETE" },
{ 0x00293000, "STATUS_RTPM_CONTEXT_CONTINUE" },
{ 0x00293001, "STATUS_RTPM_CONTEXT_COMPLETE" },
{ 0x00350059, "STATUS_HV_PENDING_PAGE_REQUESTS" },
{ 0x00E70000, "STATUS_SPACES_REPAIRED" },
{ 0x00E70001, "STATUS_SPACES_PAUSE" },
{ 0x00E70002, "STATUS_SPACES_COMPLETE" },
{ 0x00E70003, "STATUS_SPACES_REDIRECT" },
{ 0x40000000, "STATUS_OBJECT_NAME_EXISTS" },
{ 0x40000001, "STATUS_THREAD_WAS_SUSPENDED" },
{ 0x40000002, "STATUS_WORKING_SET_LIMIT_RANGE" },
{ 0x40000003, "STATUS_IMAGE_NOT_AT_BASE" },
{ 0x40000004, "STATUS_RXACT_STATE_CREATED" },
{ 0x40000005, "STATUS_SEGMENT_NOTIFICATION" },
{ 0x40000006, "STATUS_LOCAL_USER_SESSION_KEY" },
{ 0x40000007, "STATUS_BAD_CURRENT_DIRECTORY" },
{ 0x40000008, "STATUS_SERIAL_MORE_WRITES" },
{ 0x40000009, "STATUS_REGISTRY_RECOVERED" },
{ 0x4000000A, "STATUS_FT_READ_RECOVERY_FROM_BACKUP" },
{ 0x4000000B, "STATUS_FT_WRITE_RECOVERY" },
{ 0x4000000C, "STATUS_SERIAL_COUNTER_TIMEOUT" },
{ 0x4000000D, "STATUS_NULL_LM_PASSWORD" },
{ 0x4000000E, "STATUS_IMAGE_MACHINE_TYPE_MISMATCH" },
{ 0x4000000F, "STATUS_RECEIVE_PARTIAL" },
{ 0x40000010, "STATUS_RECEIVE_EXPEDITED" },
{ 0x40000011, "STATUS_RECEIVE_PARTIAL_EXPEDITED" },
{ 0x40000012, "STATUS_EVENT_DONE" },
{ 0x40000013, "STATUS_EVENT_PENDING" },
{ 0x40000014, "STATUS_CHECKING_FILE_SYSTEM" },
{ 0x40000015, "STATUS_FATAL_APP_EXIT" },
{ 0x40000016, "STATUS_PREDEFINED_HANDLE" },
{ 0x40000017, "STATUS_WAS_UNLOCKED" },
{ 0x40000018, "STATUS_SERVICE_NOTIFICATION" },
{ 0x40000019, "STATUS_WAS_LOCKED" },
{ 0x4000001A, "STATUS_LOG_HARD_ERROR" },
{ 0x4000001B, "STATUS_ALREADY_WIN32" },
{ 0x4000001C, "STATUS_WX86_UNSIMULATE" },
{ 0x4000001D, "STATUS_WX86_CONTINUE" },
{ 0x4000001E, "STATUS_WX86_SINGLE_STEP" },
{ 0x4000001F, "STATUS_WX86_BREAKPOINT" },
{ 0x40000020, "STATUS_WX86_EXCEPTION_CONTINUE" },
{ 0x40000021, "STATUS_WX86_EXCEPTION_LASTCHANCE" },
{ 0x40000022, "STATUS_WX86_EXCEPTION_CHAIN" },
{ 0x40000023, "STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE" },
{ 0x40000024, "STATUS_NO_YIELD_PERFORMED" },
{ 0x40000025, "STATUS_TIMER_RESUME_IGNORED" },
{ 0x40000026, "STATUS_ARBITRATION_UNHANDLED" },
{ 0x40000027, "STATUS_CARDBUS_NOT_SUPPORTED" },
{ 0x40000028, "STATUS_WX86_CREATEWX86TIB" },
{ 0x40000029, "STATUS_MP_PROCESSOR_MISMATCH" },
{ 0x4000002A, "STATUS_HIBERNATED" },
{ 0x4000002B, "STATUS_RESUME_HIBERNATION" },
{ 0x4000002C, "STATUS_FIRMWARE_UPDATED" },
{ 0x4000002D, "STATUS_DRIVERS_LEAKING_LOCKED_PAGES" },
{ 0x4000002E, "STATUS_MESSAGE_RETRIEVED" },
{ 0x4000002F, "STATUS_SYSTEM_POWERSTATE_TRANSITION" },
{ 0x40000030, "STATUS_ALPC_CHECK_COMPLETION_LIST" },
{ 0x40000031, "STATUS_SYSTEM_POWERSTATE_COMPLEX_TRANSITION" },
{ 0x40000032, "STATUS_ACCESS_AUDIT_BY_POLICY" },
{ 0x40000033, "STATUS_ABANDON_HIBERFILE" },
{ 0x40000034, "STATUS_BIZRULES_NOT_ENABLED" },
{ 0x40000035, "STATUS_FT_READ_FROM_COPY" },
{ 0x40000036, "STATUS_IMAGE_AT_DIFFERENT_BASE" },
{ 0x40000294, "STATUS_WAKE_SYSTEM" },
{ 0x40000370, "STATUS_DS_SHUTTING_DOWN" },
{ 0x40000807, "STATUS_DISK_REPAIR_REDIRECTED" },
{ 0x4000A144, "STATUS_SERVICES_FAILED_AUTOSTART" },
{ 0x40010001, "DBG_REPLY_LATER" },
{ 0x40010002, "DBG_UNABLE_TO_PROVIDE_HANDLE" },
{ 0x40010003, "DBG_TERMINATE_THREAD" },
{ 0x40010004, "DBG_TERMINATE_PROCESS" },
{ 0x40010005, "DBG_CONTROL_C" },
{ 0x40010006, "DBG_PRINTEXCEPTION_C" },
{ 0x40010007, "DBG_RIPEXCEPTION" },
{ 0x40010008, "DBG_CONTROL_BREAK" },
{ 0x40010009, "DBG_COMMAND_EXCEPTION" },
{ 0x4001000A, "DBG_PRINTEXCEPTION_WIDE_C" },
{ 0x40020056, "RPC_NT_UUID_LOCAL_ONLY" },
{ 0x400200AF, "RPC_NT_SEND_INCOMPLETE" },
{ 0x400A0004, "STATUS_CTX_CDM_CONNECT" },
{ 0x400A0005, "STATUS_CTX_CDM_DISCONNECT" },
{ 0x4015000D, "STATUS_SXS_RELEASE_ACTIVATION_CONTEXT" },
{ 0x40190001, "STATUS_HEURISTIC_DAMAGE_POSSIBLE" },
{ 0x40190034, "STATUS_RECOVERY_NOT_NEEDED" },
{ 0x40190035, "STATUS_RM_ALREADY_STARTED" },
{ 0x401A000C, "STATUS_LOG_NO_RESTART" },
{ 0x401B00EC, "STATUS_VIDEO_DRIVER_DEBUG_REPORT_REQUEST" },
{ 0x401E000A, "STATUS_GRAPHICS_PARTIAL_DATA_POPULATED" },
{ 0x401E0201, "STATUS_GRAPHICS_SKIP_ALLOCATION_PREPARATION" },
{ 0x401E0307, "STATUS_GRAPHICS_MODE_NOT_PINNED" },
{ 0x401E031E, "STATUS_GRAPHICS_NO_PREFERRED_MODE" },
{ 0x401E034B, "STATUS_GRAPHICS_DATASET_IS_EMPTY" },
{ 0x401E034C, "STATUS_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET" },
{ 0x401E0351, "STATUS_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED" },
{ 0x401E042F, "STATUS_GRAPHICS_UNKNOWN_CHILD_STATUS" },
{ 0x401E0437, "STATUS_GRAPHICS_LEADLINK_START_DEFERRED" },
{ 0x401E0439, "STATUS_GRAPHICS_POLLING_TOO_FREQUENTLY" },
{ 0x401E043A, "STATUS_GRAPHICS_START_DEFERRED" },
{ 0x401E043C, "STATUS_GRAPHICS_DEPENDABLE_CHILD_STATUS" },
{ 0x40230001, "STATUS_NDIS_INDICATION_REQUIRED" },
{ 0x80000001, "STATUS_GUARD_PAGE_VIOLATION" },
{ 0x80000002, "STATUS_DATATYPE_MISALIGNMENT" },
{ 0x80000003, "STATUS_BREAKPOINT" },
{ 0x80000004, "STATUS_SINGLE_STEP" },
{ 0x80000005, "STATUS_BUFFER_OVERFLOW" },
{ 0x80000006, "STATUS_NO_MORE_FILES" },
{ 0x80000007, "STATUS_WAKE_SYSTEM_DEBUGGER" },
{ 0x8000000A, "STATUS_HANDLES_CLOSED" },
{ 0x8000000B, "STATUS_NO_INHERITANCE" },
{ 0x8000000C, "STATUS_GUID_SUBSTITUTION_MADE" },
{ 0x8000000D, "STATUS_PARTIAL_COPY" },
{ 0x8000000E, "STATUS_DEVICE_PAPER_EMPTY" },
{ 0x8000000F, "STATUS_DEVICE_POWERED_OFF" },
{ 0x80000010, "STATUS_DEVICE_OFF_LINE" },
{ 0x80000011, "STATUS_DEVICE_BUSY" },
{ 0x80000012, "STATUS_NO_MORE_EAS" },
{ 0x80000013, "STATUS_INVALID_EA_NAME" },
{ 0x80000014, "STATUS_EA_LIST_INCONSISTENT" },
{ 0x80000015, "STATUS_INVALID_EA_FLAG" },
{ 0x80000016, "STATUS_VERIFY_REQUIRED" },
{ 0x80000017, "STATUS_EXTRANEOUS_INFORMATION" },
{ 0x80000018, "STATUS_RXACT_COMMIT_NECESSARY" },
{ 0x8000001A, "STATUS_NO_MORE_ENTRIES" },
{ 0x8000001B, "STATUS_FILEMARK_DETECTED" },
{ 0x8000001C, "STATUS_MEDIA_CHANGED" },
{ 0x8000001D, "STATUS_BUS_RESET" },
{ 0x8000001E, "STATUS_END_OF_MEDIA" },
{ 0x8000001F, "STATUS_BEGINNING_OF_MEDIA" },
{ 0x80000020, "STATUS_MEDIA_CHECK" },
{ 0x80000021, "STATUS_SETMARK_DETECTED" },
{ 0x80000022, "STATUS_NO_DATA_DETECTED" },
{ 0x80000023, "STATUS_REDIRECTOR_HAS_OPEN_HANDLES" },
{ 0x80000024, "STATUS_SERVER_HAS_OPEN_HANDLES" },
{ 0x80000025, "STATUS_ALREADY_DISCONNECTED" },
{ 0x80000026, "STATUS_LONGJUMP" },
{ 0x80000027, "STATUS_CLEANER_CARTRIDGE_INSTALLED" },
{ 0x80000028, "STATUS_PLUGPLAY_QUERY_VETOED" },
{ 0x80000029, "STATUS_UNWIND_CONSOLIDATE" },
{ 0x8000002A, "STATUS_REGISTRY_HIVE_RECOVERED" },
{ 0x8000002B, "STATUS_DLL_MIGHT_BE_INSECURE" },
{ 0x8000002C, "STATUS_DLL_MIGHT_BE_INCOMPATIBLE" },
{ 0x8000002D, "STATUS_STOPPED_ON_SYMLINK" },
{ 0x8000002E, "STATUS_CANNOT_GRANT_REQUESTED_OPLOCK" },
{ 0x8000002F, "STATUS_NO_ACE_CONDITION" },
{ 0x80000030, "STATUS_DEVICE_SUPPORT_IN_PROGRESS" },
{ 0x80000031, "STATUS_DEVICE_POWER_CYCLE_REQUIRED" },
{ 0x80000032, "STATUS_NO_WORK_DONE" },
{ 0x80000288, "STATUS_DEVICE_REQUIRES_CLEANING" },
{ 0x80000289, "STATUS_DEVICE_DOOR_OPEN" },
{ 0x80000803, "STATUS_DATA_LOST_REPAIR" },
{ 0x8000A127, "STATUS_GPIO_INTERRUPT_ALREADY_UNMASKED" },
{ 0x8000CF00, "STATUS_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH" },
{ 0x8000CF04, "STATUS_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE" },
{ 0x8000CF05, "STATUS_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS" },
{ 0x80010001, "DBG_EXCEPTION_NOT_HANDLED" },
{ 0x80130001, "STATUS_CLUSTER_NODE_ALREADY_UP" },
{ 0x80130002, "STATUS_CLUSTER_NODE_ALREADY_DOWN" },
{ 0x80130003, "STATUS_CLUSTER_NETWORK_ALREADY_ONLINE" },
{ 0x80130004, "STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE" },
{ 0x80130005, "STATUS_CLUSTER_NODE_ALREADY_MEMBER" },
{ 0x80190009, "STATUS_COULD_NOT_RESIZE_LOG" },
{ 0x80190029, "STATUS_NO_TXF_METADATA" },
{ 0x80190031, "STATUS_CANT_RECOVER_WITH_HANDLE_OPEN" },
{ 0x80190041, "STATUS_TXF_METADATA_ALREADY_PRESENT" },
{ 0x80190042, "STATUS_TRANSACTION_SCOPE_CALLBACKS_NOT_SET" },
{ 0x801B00EB, "STATUS_VIDEO_HUNG_DISPLAY_DRIVER_THREAD_RECOVERED" },
{ 0x801C0001, "STATUS_FLT_BUFFER_TOO_SMALL" },
{ 0x80210001, "STATUS_FVE_PARTIAL_METADATA" },
{ 0x80210002, "STATUS_FVE_TRANSIENT_STATE" },
{ 0x80370001, "STATUS_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED" },
{ 0x80380001, "STATUS_VOLMGR_INCOMPLETE_REGENERATION" },
{ 0x80380002, "STATUS_VOLMGR_INCOMPLETE_DISK_MIGRATION" },
{ 0x80390001, "STATUS_BCD_NOT_ALL_ENTRIES_IMPORTED" },
{ 0x80390003, "STATUS_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED" },
{ 0x803A0001, "STATUS_QUERY_STORAGE_ERROR" },
{ 0x803F0001, "STATUS_GDI_HANDLE_LEAK" },
{ 0x80430006, "STATUS_SECUREBOOT_NOT_ENABLED" },
{ 0xC0000001, "STATUS_UNSUCCESSFUL" },
{ 0xC0000002, "STATUS_NOT_IMPLEMENTED" },
{ 0xC0000003, "STATUS_INVALID_INFO_CLASS" },
{ 0xC0000004, "STATUS_INFO_LENGTH_MISMATCH" },
{ 0xC0000005, "STATUS_ACCESS_VIOLATION" },
{ 0xC0000006, "STATUS_IN_PAGE_ERROR" },
{ 0xC0000007, "STATUS_PAGEFILE_QUOTA" },
{ 0xC0000008, "STATUS_INVALID_HANDLE" },
{ 0xC0000009, "STATUS_BAD_INITIAL_STACK" },
{ 0xC000000A, "STATUS_BAD_INITIAL_PC" },
{ 0xC000000B, "STATUS_INVALID_CID" },
{ 0xC000000C, "STATUS_TIMER_NOT_CANCELED" },
{ 0xC000000D, "STATUS_INVALID_PARAMETER" },
{ 0xC000000E, "STATUS_NO_SUCH_DEVICE" },
{ 0xC000000F, "STATUS_NO_SUCH_FILE" },
{ 0xC0000010, "STATUS_INVALID_DEVICE_REQUEST" },
{ 0xC0000011, "STATUS_END_OF_FILE" },
{ 0xC0000012, "STATUS_WRONG_VOLUME" },
{ 0xC0000013, "STATUS_NO_MEDIA_IN_DEVICE" },
{ 0xC0000014, "STATUS_UNRECOGNIZED_MEDIA" },
{ 0xC0000015, "STATUS_NONEXISTENT_SECTOR" },
{ 0xC0000016, "STATUS_MORE_PROCESSING_REQUIRED" },
{ 0xC0000017, "STATUS_NO_MEMORY" },
{ 0xC0000018, "STATUS_CONFLICTING_ADDRESSES" },
{ 0xC0000019, "STATUS_NOT_MAPPED_VIEW" },
{ 0xC000001A, "STATUS_UNABLE_TO_FREE_VM" },
{ 0xC000001B, "STATUS_UNABLE_TO_DELETE_SECTION" },
{ 0xC000001C, "STATUS_INVALID_SYSTEM_SERVICE" },
{ 0xC000001D, "STATUS_ILLEGAL_INSTRUCTION" },
{ 0xC000001E, "STATUS_INVALID_LOCK_SEQUENCE" },
{ 0xC000001F, "STATUS_INVALID_VIEW_SIZE" },
{ 0xC0000020, "STATUS_INVALID_FILE_FOR_SECTION" },
{ 0xC0000021, "STATUS_ALREADY_COMMITTED" },
{ 0xC0000022, "STATUS_ACCESS_DENIED" },
{ 0xC0000023, "STATUS_BUFFER_TOO_SMALL" },
{ 0xC0000024, "STATUS_OBJECT_TYPE_MISMATCH" },
{ 0xC0000025, "STATUS_NONCONTINUABLE_EXCEPTION" },
{ 0xC0000026, "STATUS_INVALID_DISPOSITION" },
{ 0xC0000027, "STATUS_UNWIND" },
{ 0xC0000028, "STATUS_BAD_STACK" },
{ 0xC0000029, "STATUS_INVALID_UNWIND_TARGET" },
{ 0xC000002A, "STATUS_NOT_LOCKED" },
{ 0xC000002B, "STATUS_PARITY_ERROR" },
{ 0xC000002C, "STATUS_UNABLE_TO_DECOMMIT_VM" },
{ 0xC000002D, "STATUS_NOT_COMMITTED" },
{ 0xC000002E, "STATUS_INVALID_PORT_ATTRIBUTES" },
{ 0xC000002F, "STATUS_PORT_MESSAGE_TOO_LONG" },
{ 0xC0000030, "STATUS_INVALID_PARAMETER_MIX" },
{ 0xC0000031, "STATUS_INVALID_QUOTA_LOWER" },
{ 0xC0000032, "STATUS_DISK_CORRUPT_ERROR" },
{ 0xC0000033, "STATUS_OBJECT_NAME_INVALID" },
{ 0xC0000034, "STATUS_OBJECT_NAME_NOT_FOUND" },
{ 0xC0000035, "STATUS_OBJECT_NAME_COLLISION" },
{ 0xC0000036, "STATUS_PORT_DO_NOT_DISTURB" },
{ 0xC0000037, "STATUS_PORT_DISCONNECTED" },
{ 0xC0000038, "STATUS_DEVICE_ALREADY_ATTACHED" },
{ 0xC0000039, "STATUS_OBJECT_PATH_INVALID" },
{ 0xC000003A, "STATUS_OBJECT_PATH_NOT_FOUND" },
{ 0xC000003B, "STATUS_OBJECT_PATH_SYNTAX_BAD" },
{ 0xC000003C, "STATUS_DATA_OVERRUN" },
{ 0xC000003D, "STATUS_DATA_LATE_ERROR" },
{ 0xC000003E, "STATUS_DATA_ERROR" },
{ 0xC000003F, "STATUS_CRC_ERROR" },
{ 0xC0000040, "STATUS_SECTION_TOO_BIG" },
{ 0xC0000041, "STATUS_PORT_CONNECTION_REFUSED" },
{ 0xC0000042, "STATUS_INVALID_PORT_HANDLE" },
{ 0xC0000043, "STATUS_SHARING_VIOLATION" },
{ 0xC0000044, "STATUS_QUOTA_EXCEEDED" },
{ 0xC0000045, "STATUS_INVALID_PAGE_PROTECTION" },
{ 0xC0000046, "STATUS_MUTANT_NOT_OWNED" },
{ 0xC0000047, "STATUS_SEMAPHORE_LIMIT_EXCEEDED" },
{ 0xC0000048, "STATUS_PORT_ALREADY_SET" },
{ 0xC0000049, "STATUS_SECTION_NOT_IMAGE" },
{ 0xC000004A, "STATUS_SUSPEND_COUNT_EXCEEDED" },
{ 0xC000004B, "STATUS_THREAD_IS_TERMINATING" },
{ 0xC000004C, "STATUS_BAD_WORKING_SET_LIMIT" },
{ 0xC000004D, "STATUS_INCOMPATIBLE_FILE_MAP" },
{ 0xC000004E, "STATUS_SECTION_PROTECTION" },
{ 0xC000004F, "STATUS_EAS_NOT_SUPPORTED" },
{ 0xC0000050, "STATUS_EA_TOO_LARGE" },
{ 0xC0000051, "STATUS_NONEXISTENT_EA_ENTRY" },
{ 0xC0000052, "STATUS_NO_EAS_ON_FILE" },
{ 0xC0000053, "STATUS_EA_CORRUPT_ERROR" },
{ 0xC0000054, "STATUS_FILE_LOCK_CONFLICT" },
{ 0xC0000055, "STATUS_LOCK_NOT_GRANTED" },
{ 0xC0000056, "STATUS_DELETE_PENDING" },
{ 0xC0000057, "STATUS_CTL_FILE_NOT_SUPPORTED" },
{ 0xC0000058, "STATUS_UNKNOWN_REVISION" },
{ 0xC0000059, "STATUS_REVISION_MISMATCH" },
{ 0xC000005A, "STATUS_INVALID_OWNER" },
{ 0xC000005B, "STATUS_INVALID_PRIMARY_GROUP" },
{ 0xC000005C, "STATUS_NO_IMPERSONATION_TOKEN" },
{ 0xC000005D, "STATUS_CANT_DISABLE_MANDATORY" },
{ 0xC000005E, "STATUS_NO_LOGON_SERVERS" },
{ 0xC000005F, "STATUS_NO_SUCH_LOGON_SESSION" },
{ 0xC0000060, "STATUS_NO_SUCH_PRIVILEGE" },
{ 0xC0000061, "STATUS_PRIVILEGE_NOT_HELD" },
{ 0xC0000062, "STATUS_INVALID_ACCOUNT_NAME" },
{ 0xC0000063, "STATUS_USER_EXISTS" },
{ 0xC0000064, "STATUS_NO_SUCH_USER" },
{ 0xC0000065, "STATUS_GROUP_EXISTS" },
{ 0xC0000066, "STATUS_NO_SUCH_GROUP" },
{ 0xC0000067, "STATUS_MEMBER_IN_GROUP" },
{ 0xC0000068, "STATUS_MEMBER_NOT_IN_GROUP" },
{ 0xC0000069, "STATUS_LAST_ADMIN" },
{ 0xC000006A, "STATUS_WRONG_PASSWORD" },
{ 0xC000006B, "STATUS_ILL_FORMED_PASSWORD" },
{ 0xC000006C, "STATUS_PASSWORD_RESTRICTION" },
{ 0xC000006D, "STATUS_LOGON_FAILURE" },
{ 0xC000006E, "STATUS_ACCOUNT_RESTRICTION" },
{ 0xC000006F, "STATUS_INVALID_LOGON_HOURS" },
{ 0xC0000070, "STATUS_INVALID_WORKSTATION" },
{ 0xC0000071, "STATUS_PASSWORD_EXPIRED" },
{ 0xC0000072, "STATUS_ACCOUNT_DISABLED" },
{ 0xC0000073, "STATUS_NONE_MAPPED" },
{ 0xC0000074, "STATUS_TOO_MANY_LUIDS_REQUESTED" },
{ 0xC0000075, "STATUS_LUIDS_EXHAUSTED" },
{ 0xC0000076, "STATUS_INVALID_SUB_AUTHORITY" },
{ 0xC0000077, "STATUS_INVALID_ACL" },
{ 0xC0000078, "STATUS_INVALID_SID" },
{ 0xC0000079, "STATUS_INVALID_SECURITY_DESCR" },
{ 0xC000007A, "STATUS_PROCEDURE_NOT_FOUND" },
{ 0xC000007B, "STATUS_INVALID_IMAGE_FORMAT" },
{ 0xC000007C, "STATUS_NO_TOKEN" },
{ 0xC000007D, "STATUS_BAD_INHERITANCE_ACL" },
{ 0xC000007E, "STATUS_RANGE_NOT_LOCKED" },
{ 0xC000007F, "STATUS_DISK_FULL" },
{ 0xC0000080, "STATUS_SERVER_DISABLED" },
{ 0xC0000081, "STATUS_SERVER_NOT_DISABLED" },
{ 0xC0000082, "STATUS_TOO_MANY_GUIDS_REQUESTED" },
{ 0xC0000083, "STATUS_GUIDS_EXHAUSTED" },
{ 0xC0000084, "STATUS_INVALID_ID_AUTHORITY" },
{ 0xC0000085, "STATUS_AGENTS_EXHAUSTED" },
{ 0xC0000086, "STATUS_INVALID_VOLUME_LABEL" },
{ 0xC0000087, "STATUS_SECTION_NOT_EXTENDED" },
{ 0xC0000088, "STATUS_NOT_MAPPED_DATA" },
{ 0xC0000089, "STATUS_RESOURCE_DATA_NOT_FOUND" },
{ 0xC000008A, "STATUS_RESOURCE_TYPE_NOT_FOUND" },
{ 0xC000008B, "STATUS_RESOURCE_NAME_NOT_FOUND" },
{ 0xC000008C, "STATUS_ARRAY_BOUNDS_EXCEEDED" },
{ 0xC000008D, "STATUS_FLOAT_DENORMAL_OPERAND" },
{ 0xC000008E, "STATUS_FLOAT_DIVIDE_BY_ZERO" },
{ 0xC000008F, "STATUS_FLOAT_INEXACT_RESULT" },
{ 0xC0000090, "STATUS_FLOAT_INVALID_OPERATION" },
{ 0xC0000091, "STATUS_FLOAT_OVERFLOW" },
{ 0xC0000092, "STATUS_FLOAT_STACK_CHECK" },
{ 0xC0000093, "STATUS_FLOAT_UNDERFLOW" },
{ 0xC0000094, "STATUS_INTEGER_DIVIDE_BY_ZERO" },
{ 0xC0000095, "STATUS_INTEGER_OVERFLOW" },
{ 0xC0000096, "STATUS_PRIVILEGED_INSTRUCTION" },
{ 0xC0000097, "STATUS_TOO_MANY_PAGING_FILES" },
{ 0xC0000098, "STATUS_FILE_INVALID" },
{ 0xC0000099, "STATUS_ALLOTTED_SPACE_EXCEEDED" },
{ 0xC000009A, "STATUS_INSUFFICIENT_RESOURCES" },
{ 0xC000009B, "STATUS_DFS_EXIT_PATH_FOUND" },
{ 0xC000009C, "STATUS_DEVICE_DATA_ERROR" },
{ 0xC000009D, "STATUS_DEVICE_NOT_CONNECTED" },
{ 0xC000009E, "STATUS_DEVICE_POWER_FAILURE" },
{ 0xC000009F, "STATUS_FREE_VM_NOT_AT_BASE" },
{ 0xC00000A0, "STATUS_MEMORY_NOT_ALLOCATED" },
{ 0xC00000A1, "STATUS_WORKING_SET_QUOTA" },
{ 0xC00000A2, "STATUS_MEDIA_WRITE_PROTECTED" },
{ 0xC00000A3, "STATUS_DEVICE_NOT_READY" },
{ 0xC00000A4, "STATUS_INVALID_GROUP_ATTRIBUTES" },
{ 0xC00000A5, "STATUS_BAD_IMPERSONATION_LEVEL" },
{ 0xC00000A6, "STATUS_CANT_OPEN_ANONYMOUS" },
{ 0xC00000A7, "STATUS_BAD_VALIDATION_CLASS" },
{ 0xC00000A8, "STATUS_BAD_TOKEN_TYPE" },
{ 0xC00000A9, "STATUS_BAD_MASTER_BOOT_RECORD" },
{ 0xC00000AA, "STATUS_INSTRUCTION_MISALIGNMENT" },
{ 0xC00000AB, "STATUS_INSTANCE_NOT_AVAILABLE" },
{ 0xC00000AC, "STATUS_PIPE_NOT_AVAILABLE" },
{ 0xC00000AD, "STATUS_INVALID_PIPE_STATE" },
{ 0xC00000AE, "STATUS_PIPE_BUSY" },
{ 0xC00000AF, "STATUS_ILLEGAL_FUNCTION" },
{ 0xC00000B0, "STATUS_PIPE_DISCONNECTED" },
{ 0xC00000B1, "STATUS_PIPE_CLOSING" },
{ 0xC00000B2, "STATUS_PIPE_CONNECTED" },
{ 0xC00000B3, "STATUS_PIPE_LISTENING" },
{ 0xC00000B4, "STATUS_INVALID_READ_MODE" },
{ 0xC00000B5, "STATUS_IO_TIMEOUT" },
{ 0xC00000B6, "STATUS_FILE_FORCED_CLOSED" },
{ 0xC00000B7, "STATUS_PROFILING_NOT_STARTED" },
{ 0xC00000B8, "STATUS_PROFILING_NOT_STOPPED" },
{ 0xC00000B9, "STATUS_COULD_NOT_INTERPRET" },
{ 0xC00000BA, "STATUS_FILE_IS_A_DIRECTORY" },
{ 0xC00000BB, "STATUS_NOT_SUPPORTED" },
{ 0xC00000BC, "STATUS_REMOTE_NOT_LISTENING" },
{ 0xC00000BD, "STATUS_DUPLICATE_NAME" },
{ 0xC00000BE, "STATUS_BAD_NETWORK_PATH" },
{ 0xC00000BF, "STATUS_NETWORK_BUSY" },
{ 0xC00000C0, "STATUS_DEVICE_DOES_NOT_EXIST" },
{ 0xC00000C1, "STATUS_TOO_MANY_COMMANDS" },
{ 0xC00000C2, "STATUS_ADAPTER_HARDWARE_ERROR" },
{ 0xC00000C3, "STATUS_INVALID_NETWORK_RESPONSE" },
{ 0xC00000C4, "STATUS_UNEXPECTED_NETWORK_ERROR" },
{ 0xC00000C5, "STATUS_BAD_REMOTE_ADAPTER" },
{ 0xC00000C6, "STATUS_PRINT_QUEUE_FULL" },
{ 0xC00000C7, "STATUS_NO_SPOOL_SPACE" },
{ 0xC00000C8, "STATUS_PRINT_CANCELLED" },
{ 0xC00000C9, "STATUS_NETWORK_NAME_DELETED" },
{ 0xC00000CA, "STATUS_NETWORK_ACCESS_DENIED" },
{ 0xC00000CB, "STATUS_BAD_DEVICE_TYPE" },
{ 0xC00000CC, "STATUS_BAD_NETWORK_NAME" },
{ 0xC00000CD, "STATUS_TOO_MANY_NAMES" },
{ 0xC00000CE, "STATUS_TOO_MANY_SESSIONS" },
{ 0xC00000CF, "STATUS_SHARING_PAUSED" },
{ 0xC00000D0, "STATUS_REQUEST_NOT_ACCEPTED" },
{ 0xC00000D1, "STATUS_REDIRECTOR_PAUSED" },
{ 0xC00000D2, "STATUS_NET_WRITE_FAULT" },
{ 0xC00000D3, "STATUS_PROFILING_AT_LIMIT" },
{ 0xC00000D4, "STATUS_NOT_SAME_DEVICE" },
{ 0xC00000D5, "STATUS_FILE_RENAMED" },
{ 0xC00000D6, "STATUS_VIRTUAL_CIRCUIT_CLOSED" },
{ 0xC00000D7, "STATUS_NO_SECURITY_ON_OBJECT" },
{ 0xC00000D8, "STATUS_CANT_WAIT" },
{ 0xC00000D9, "STATUS_PIPE_EMPTY" },
{ 0xC00000DA, "STATUS_CANT_ACCESS_DOMAIN_INFO" },
{ 0xC00000DB, "STATUS_CANT_TERMINATE_SELF" },
{ 0xC00000DC, "STATUS_INVALID_SERVER_STATE" },
{ 0xC00000DD, "STATUS_INVALID_DOMAIN_STATE" },
{ 0xC00000DE, "STATUS_INVALID_DOMAIN_ROLE" },
{ 0xC00000DF, "STATUS_NO_SUCH_DOMAIN" },
{ 0xC00000E0, "STATUS_DOMAIN_EXISTS" },
{ 0xC00000E1, "STATUS_DOMAIN_LIMIT_EXCEEDED" },
{ 0xC00000E2, "STATUS_OPLOCK_NOT_GRANTED" },
{ 0xC00000E3, "STATUS_INVALID_OPLOCK_PROTOCOL" },
{ 0xC00000E4, "STATUS_INTERNAL_DB_CORRUPTION" },
{ 0xC00000E5, "STATUS_INTERNAL_ERROR" },
{ 0xC00000E6, "STATUS_GENERIC_NOT_MAPPED" },
{ 0xC00000E7, "STATUS_BAD_DESCRIPTOR_FORMAT" },
{ 0xC00000E8, "STATUS_INVALID_USER_BUFFER" },
{ 0xC00000E9, "STATUS_UNEXPECTED_IO_ERROR" },
{ 0xC00000EA, "STATUS_UNEXPECTED_MM_CREATE_ERR" },
{ 0xC00000EB, "STATUS_UNEXPECTED_MM_MAP_ERROR" },
{ 0xC00000EC, "STATUS_UNEXPECTED_MM_EXTEND_ERR" },
{ 0xC00000ED, "STATUS_NOT_LOGON_PROCESS" },
{ 0xC00000EE, "STATUS_LOGON_SESSION_EXISTS" },
{ 0xC00000EF, "STATUS_INVALID_PARAMETER_1" },
{ 0xC00000F0, "STATUS_INVALID_PARAMETER_2" },
{ 0xC00000F1, "STATUS_INVALID_PARAMETER_3" },
{ 0xC00000F2, "STATUS_INVALID_PARAMETER_4" },
{ 0xC00000F3, "STATUS_INVALID_PARAMETER_5" },
{ 0xC00000F4, "STATUS_INVALID_PARAMETER_6" },
{ 0xC00000F5, "STATUS_INVALID_PARAMETER_7" },
{ 0xC00000F6, "STATUS_INVALID_PARAMETER_8" },
{ 0xC00000F7, "STATUS_INVALID_PARAMETER_9" },
{ 0xC00000F8, "STATUS_INVALID_PARAMETER_10" },
{ 0xC00000F9, "STATUS_INVALID_PARAMETER_11" },
{ 0xC00000FA, "STATUS_INVALID_PARAMETER_12" },
{ 0xC00000FB, "STATUS_REDIRECTOR_NOT_STARTED" },
{ 0xC00000FC, "STATUS_REDIRECTOR_STARTED" },
{ 0xC00000FD, "STATUS_STACK_OVERFLOW" },
{ 0xC00000FE, "STATUS_NO_SUCH_PACKAGE" },
{ 0xC00000FF, "STATUS_BAD_FUNCTION_TABLE" },
{ 0xC0000100, "STATUS_VARIABLE_NOT_FOUND" },
{ 0xC0000101, "STATUS_DIRECTORY_NOT_EMPTY" },
{ 0xC0000102, "STATUS_FILE_CORRUPT_ERROR" },
{ 0xC0000103, "STATUS_NOT_A_DIRECTORY" },
{ 0xC0000104, "STATUS_BAD_LOGON_SESSION_STATE" },
{ 0xC0000105, "STATUS_LOGON_SESSION_COLLISION" },
{ 0xC0000106, "STATUS_NAME_TOO_LONG" },
{ 0xC0000107, "STATUS_FILES_OPEN" },
{ 0xC0000108, "STATUS_CONNECTION_IN_USE" },
{ 0xC0000109, "STATUS_MESSAGE_NOT_FOUND" },
{ 0xC000010A, "STATUS_PROCESS_IS_TERMINATING" },
{ 0xC000010B, "STATUS_INVALID_LOGON_TYPE" },
{ 0xC000010C, "STATUS_NO_GUID_TRANSLATION" },
{ 0xC000010D, "STATUS_CANNOT_IMPERSONATE" },
{ 0xC000010E, "STATUS_IMAGE_ALREADY_LOADED" },
{ 0xC000010F, "STATUS_ABIOS_NOT_PRESENT" },
{ 0xC0000110, "STATUS_ABIOS_LID_NOT_EXIST" },
{ 0xC0000111, "STATUS_ABIOS_LID_ALREADY_OWNED" },
{ 0xC0000112, "STATUS_ABIOS_NOT_LID_OWNER" },
{ 0xC0000113, "STATUS_ABIOS_INVALID_COMMAND" },
{ 0xC0000114, "STATUS_ABIOS_INVALID_LID" },
{ 0xC0000115, "STATUS_ABIOS_SELECTOR_NOT_AVAILABLE" },
{ 0xC0000116, "STATUS_ABIOS_INVALID_SELECTOR" },
{ 0xC0000117, "STATUS_NO_LDT" },
{ 0xC0000118, "STATUS_INVALID_LDT_SIZE" },
{ 0xC0000119, "STATUS_INVALID_LDT_OFFSET" },
{ 0xC000011A, "STATUS_INVALID_LDT_DESCRIPTOR" },
{ 0xC000011B, "STATUS_INVALID_IMAGE_NE_FORMAT" },
{ 0xC000011C, "STATUS_RXACT_INVALID_STATE" },
{ 0xC000011D, "STATUS_RXACT_COMMIT_FAILURE" },
{ 0xC000011E, "STATUS_MAPPED_FILE_SIZE_ZERO" },
{ 0xC000011F, "STATUS_TOO_MANY_OPENED_FILES" },
{ 0xC0000120, "STATUS_CANCELLED" },
{ 0xC0000121, "STATUS_CANNOT_DELETE" },
{ 0xC0000122, "STATUS_INVALID_COMPUTER_NAME" },
{ 0xC0000123, "STATUS_FILE_DELETED" },
{ 0xC0000124, "STATUS_SPECIAL_ACCOUNT" },
{ 0xC0000125, "STATUS_SPECIAL_GROUP" },
{ 0xC0000126, "STATUS_SPECIAL_USER" },
{ 0xC0000127, "STATUS_MEMBERS_PRIMARY_GROUP" },
{ 0xC0000128, "STATUS_FILE_CLOSED" },
{ 0xC0000129, "STATUS_TOO_MANY_THREADS" },
{ 0xC000012A, "STATUS_THREAD_NOT_IN_PROCESS" },
{ 0xC000012B, "STATUS_TOKEN_ALREADY_IN_USE" },
{ 0xC000012C, "STATUS_PAGEFILE_QUOTA_EXCEEDED" },
{ 0xC000012D, "STATUS_COMMITMENT_LIMIT" },
{ 0xC000012E, "STATUS_INVALID_IMAGE_LE_FORMAT" },
{ 0xC000012F, "STATUS_INVALID_IMAGE_NOT_MZ" },
{ 0xC0000130, "STATUS_INVALID_IMAGE_PROTECT" },
{ 0xC0000131, "STATUS_INVALID_IMAGE_WIN_16" },
{ 0xC0000132, "STATUS_LOGON_SERVER_CONFLICT" },
{ 0xC0000133, "STATUS_TIME_DIFFERENCE_AT_DC" },
{ 0xC0000134, "STATUS_SYNCHRONIZATION_REQUIRED" },
{ 0xC0000135, "STATUS_DLL_NOT_FOUND" },
{ 0xC0000136, "STATUS_OPEN_FAILED" },
{ 0xC0000137, "STATUS_IO_PRIVILEGE_FAILED" },
{ 0xC0000138, "STATUS_ORDINAL_NOT_FOUND" },
{ 0xC0000139, "STATUS_ENTRYPOINT_NOT_FOUND" },
{ 0xC000013A, "STATUS_CONTROL_C_EXIT" },
{ 0xC000013B, "STATUS_LOCAL_DISCONNECT" },
{ 0xC000013C, "STATUS_REMOTE_DISCONNECT" },
{ 0xC000013D, "STATUS_REMOTE_RESOURCES" },
{ 0xC000013E, "STATUS_LINK_FAILED" },
{ 0xC000013F, "STATUS_LINK_TIMEOUT" },
{ 0xC0000140, "STATUS_INVALID_CONNECTION" },
{ 0xC0000141, "STATUS_INVALID_ADDRESS" },
{ 0xC0000142, "STATUS_DLL_INIT_FAILED" },
{ 0xC0000143, "STATUS_MISSING_SYSTEMFILE" },
{ 0xC0000144, "STATUS_UNHANDLED_EXCEPTION" },
{ 0xC0000145, "STATUS_APP_INIT_FAILURE" },
{ 0xC0000146, "STATUS_PAGEFILE_CREATE_FAILED" },
{ 0xC0000147, "STATUS_NO_PAGEFILE" },
{ 0xC0000148, "STATUS_INVALID_LEVEL" },
{ 0xC0000149, "STATUS_WRONG_PASSWORD_CORE" },
{ 0xC000014A, "STATUS_ILLEGAL_FLOAT_CONTEXT" },
{ 0xC000014B, "STATUS_PIPE_BROKEN" },
{ 0xC000014C, "STATUS_REGISTRY_CORRUPT" },
{ 0xC000014D, "STATUS_REGISTRY_IO_FAILED" },
{ 0xC000014E, "STATUS_NO_EVENT_PAIR" },
{ 0xC000014F, "STATUS_UNRECOGNIZED_VOLUME" },
{ 0xC0000150, "STATUS_SERIAL_NO_DEVICE_INITED" },
{ 0xC0000151, "STATUS_NO_SUCH_ALIAS" },
{ 0xC0000152, "STATUS_MEMBER_NOT_IN_ALIAS" },
{ 0xC0000153, "STATUS_MEMBER_IN_ALIAS" },
{ 0xC0000154, "STATUS_ALIAS_EXISTS" },
{ 0xC0000155, "STATUS_LOGON_NOT_GRANTED" },
{ 0xC0000156, "STATUS_TOO_MANY_SECRETS" },
{ 0xC0000157, "STATUS_SECRET_TOO_LONG" },
{ 0xC0000158, "STATUS_INTERNAL_DB_ERROR" },
{ 0xC0000159, "STATUS_FULLSCREEN_MODE" },
{ 0xC000015A, "STATUS_TOO_MANY_CONTEXT_IDS" },
{ 0xC000015B, "STATUS_LOGON_TYPE_NOT_GRANTED" },
{ 0xC000015C, "STATUS_NOT_REGISTRY_FILE" },
{ 0xC000015D, "STATUS_NT_CROSS_ENCRYPTION_REQUIRED" },
{ 0xC000015E, "STATUS_DOMAIN_CTRLR_CONFIG_ERROR" },
{ 0xC000015F, "STATUS_FT_MISSING_MEMBER" },
{ 0xC0000160, "STATUS_ILL_FORMED_SERVICE_ENTRY" },
{ 0xC0000161, "STATUS_ILLEGAL_CHARACTER" },
{ 0xC0000162, "STATUS_UNMAPPABLE_CHARACTER" },
{ 0xC0000163, "STATUS_UNDEFINED_CHARACTER" },
{ 0xC0000164, "STATUS_FLOPPY_VOLUME" },
{ 0xC0000165, "STATUS_FLOPPY_ID_MARK_NOT_FOUND" },
{ 0xC0000166, "STATUS_FLOPPY_WRONG_CYLINDER" },
{ 0xC0000167, "STATUS_FLOPPY_UNKNOWN_ERROR" },
{ 0xC0000168, "STATUS_FLOPPY_BAD_REGISTERS" },
{ 0xC0000169, "STATUS_DISK_RECALIBRATE_FAILED" },
{ 0xC000016A, "STATUS_DISK_OPERATION_FAILED" },
{ 0xC000016B, "STATUS_DISK_RESET_FAILED" },
{ 0xC000016C, "STATUS_SHARED_IRQ_BUSY" },
{ 0xC000016D, "STATUS_FT_ORPHANING" },
{ 0xC000016E, "STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT" },
{ 0xC0000172, "STATUS_PARTITION_FAILURE" },
{ 0xC0000173, "STATUS_INVALID_BLOCK_LENGTH" },
{ 0xC0000174, "STATUS_DEVICE_NOT_PARTITIONED" },
{ 0xC0000175, "STATUS_UNABLE_TO_LOCK_MEDIA" },
{ 0xC0000176, "STATUS_UNABLE_TO_UNLOAD_MEDIA" },
{ 0xC0000177, "STATUS_EOM_OVERFLOW" },
{ 0xC0000178, "STATUS_NO_MEDIA" },
{ 0xC000017A, "STATUS_NO_SUCH_MEMBER" },
{ 0xC000017B, "STATUS_INVALID_MEMBER" },
{ 0xC000017C, "STATUS_KEY_DELETED" },
{ 0xC000017D, "STATUS_NO_LOG_SPACE" },
{ 0xC000017E, "STATUS_TOO_MANY_SIDS" },
{ 0xC000017F, "STATUS_LM_CROSS_ENCRYPTION_REQUIRED" },
{ 0xC0000180, "STATUS_KEY_HAS_CHILDREN" },
{ 0xC0000181, "STATUS_CHILD_MUST_BE_VOLATILE" },
{ 0xC0000182, "STATUS_DEVICE_CONFIGURATION_ERROR" },
{ 0xC0000183, "STATUS_DRIVER_INTERNAL_ERROR" },
{ 0xC0000184, "STATUS_INVALID_DEVICE_STATE" },
{ 0xC0000185, "STATUS_IO_DEVICE_ERROR" },
{ 0xC0000186, "STATUS_DEVICE_PROTOCOL_ERROR" },
{ 0xC0000187, "STATUS_BACKUP_CONTROLLER" },
{ 0xC0000188, "STATUS_LOG_FILE_FULL" },
{ 0xC0000189, "STATUS_TOO_LATE" },
{ 0xC000018A, "STATUS_NO_TRUST_LSA_SECRET" },
{ 0xC000018B, "STATUS_NO_TRUST_SAM_ACCOUNT" },
{ 0xC000018C, "STATUS_TRUSTED_DOMAIN_FAILURE" },
{ 0xC000018D, "STATUS_TRUSTED_RELATIONSHIP_FAILURE" },
{ 0xC000018E, "STATUS_EVENTLOG_FILE_CORRUPT" },
{ 0xC000018F, "STATUS_EVENTLOG_CANT_START" },
{ 0xC0000190, "STATUS_TRUST_FAILURE" },
{ 0xC0000191, "STATUS_MUTANT_LIMIT_EXCEEDED" },
{ 0xC0000192, "STATUS_NETLOGON_NOT_STARTED" },
{ 0xC0000193, "STATUS_ACCOUNT_EXPIRED" },
{ 0xC0000194, "STATUS_POSSIBLE_DEADLOCK" },
{ 0xC0000195, "STATUS_NETWORK_CREDENTIAL_CONFLICT" },
{ 0xC0000196, "STATUS_REMOTE_SESSION_LIMIT" },
{ 0xC0000197, "STATUS_EVENTLOG_FILE_CHANGED" },
{ 0xC0000198, "STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT" },
{ 0xC0000199, "STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT" },
{ 0xC000019A, "STATUS_NOLOGON_SERVER_TRUST_ACCOUNT" },
{ 0xC000019B, "STATUS_DOMAIN_TRUST_INCONSISTENT" },
{ 0xC000019C, "STATUS_FS_DRIVER_REQUIRED" },
{ 0xC000019D, "STATUS_IMAGE_ALREADY_LOADED_AS_DLL" },
{ 0xC000019E, "STATUS_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING" },
{ 0xC000019F, "STATUS_SHORT_NAMES_NOT_ENABLED_ON_VOLUME" },
{ 0xC00001A0, "STATUS_SECURITY_STREAM_IS_INCONSISTENT" },
{ 0xC00001A1, "STATUS_INVALID_LOCK_RANGE" },
{ 0xC00001A2, "STATUS_INVALID_ACE_CONDITION" },
{ 0xC00001A3, "STATUS_IMAGE_SUBSYSTEM_NOT_PRESENT" },
{ 0xC00001A4, "STATUS_NOTIFICATION_GUID_ALREADY_DEFINED" },
{ 0xC00001A5, "STATUS_INVALID_EXCEPTION_HANDLER" },
{ 0xC00001A6, "STATUS_DUPLICATE_PRIVILEGES" },
{ 0xC00001A7, "STATUS_NOT_ALLOWED_ON_SYSTEM_FILE" },
{ 0xC00001A8, "STATUS_REPAIR_NEEDED" },
{ 0xC00001A9, "STATUS_QUOTA_NOT_ENABLED" },
{ 0xC00001AA, "STATUS_NO_APPLICATION_PACKAGE" },
{ 0xC00001AB, "STATUS_FILE_METADATA_OPTIMIZATION_IN_PROGRESS" },
{ 0xC00001AC, "STATUS_NOT_SAME_OBJECT" },
{ 0xC00001AD, "STATUS_FATAL_MEMORY_EXHAUSTION" },
{ 0xC00001AE, "STATUS_ERROR_PROCESS_NOT_IN_JOB" },
{ 0xC00001AF, "STATUS_CPU_SET_INVALID" },
{ 0xC0000201, "STATUS_NETWORK_OPEN_RESTRICTION" },
{ 0xC0000202, "STATUS_NO_USER_SESSION_KEY" },
{ 0xC0000203, "STATUS_USER_SESSION_DELETED" },
{ 0xC0000204, "STATUS_RESOURCE_LANG_NOT_FOUND" },
{ 0xC0000205, "STATUS_INSUFF_SERVER_RESOURCES" },
{ 0xC0000206, "STATUS_INVALID_BUFFER_SIZE" },
{ 0xC0000207, "STATUS_INVALID_ADDRESS_COMPONENT" },
{ 0xC0000208, "STATUS_INVALID_ADDRESS_WILDCARD" },
{ 0xC0000209, "STATUS_TOO_MANY_ADDRESSES" },
{ 0xC000020A, "STATUS_ADDRESS_ALREADY_EXISTS" },
{ 0xC000020B, "STATUS_ADDRESS_CLOSED" },
{ 0xC000020C, "STATUS_CONNECTION_DISCONNECTED" },
{ 0xC000020D, "STATUS_CONNECTION_RESET" },
{ 0xC000020E, "STATUS_TOO_MANY_NODES" },
{ 0xC000020F, "STATUS_TRANSACTION_ABORTED" },
{ 0xC0000210, "STATUS_TRANSACTION_TIMED_OUT" },
{ 0xC0000211, "STATUS_TRANSACTION_NO_RELEASE" },
{ 0xC0000212, "STATUS_TRANSACTION_NO_MATCH" },
{ 0xC0000213, "STATUS_TRANSACTION_RESPONDED" },
{ 0xC0000214, "STATUS_TRANSACTION_INVALID_ID" },
{ 0xC0000215, "STATUS_TRANSACTION_INVALID_TYPE" },
{ 0xC0000216, "STATUS_NOT_SERVER_SESSION" },
{ 0xC0000217, "STATUS_NOT_CLIENT_SESSION" },
{ 0xC0000218, "STATUS_CANNOT_LOAD_REGISTRY_FILE" },
{ 0xC0000219, "STATUS_DEBUG_ATTACH_FAILED" },
{ 0xC000021A, "STATUS_SYSTEM_PROCESS_TERMINATED" },
{ 0xC000021B, "STATUS_DATA_NOT_ACCEPTED" },
{ 0xC000021C, "STATUS_NO_BROWSER_SERVERS_FOUND" },
{ 0xC000021D, "STATUS_VDM_HARD_ERROR" },
{ 0xC000021E, "STATUS_DRIVER_CANCEL_TIMEOUT" },
{ 0xC000021F, "STATUS_REPLY_MESSAGE_MISMATCH" },
{ 0xC0000220, "STATUS_MAPPED_ALIGNMENT" },
{ 0xC0000221, "STATUS_IMAGE_CHECKSUM_MISMATCH" },
{ 0xC0000222, "STATUS_LOST_WRITEBEHIND_DATA" },
{ 0xC0000223, "STATUS_CLIENT_SERVER_PARAMETERS_INVALID" },
{ 0xC0000224, "STATUS_PASSWORD_MUST_CHANGE" },
{ 0xC0000225, "STATUS_NOT_FOUND" },
{ 0xC0000226, "STATUS_NOT_TINY_STREAM" },
{ 0xC0000227, "STATUS_RECOVERY_FAILURE" },
{ 0xC0000228, "STATUS_STACK_OVERFLOW_READ" },
{ 0xC0000229, "STATUS_FAIL_CHECK" },
{ 0xC000022A, "STATUS_DUPLICATE_OBJECTID" },
{ 0xC000022B, "STATUS_OBJECTID_EXISTS" },
{ 0xC000022C, "STATUS_CONVERT_TO_LARGE" },
{ 0xC000022D, "STATUS_RETRY" },
{ 0xC000022E, "STATUS_FOUND_OUT_OF_SCOPE" },
{ 0xC000022F, "STATUS_ALLOCATE_BUCKET" },
{ 0xC0000230, "STATUS_PROPSET_NOT_FOUND" },
{ 0xC0000231, "STATUS_MARSHALL_OVERFLOW" },
{ 0xC0000232, "STATUS_INVALID_VARIANT" },
{ 0xC0000233, "STATUS_DOMAIN_CONTROLLER_NOT_FOUND" },
{ 0xC0000234, "STATUS_ACCOUNT_LOCKED_OUT" },
{ 0xC0000235, "STATUS_HANDLE_NOT_CLOSABLE" },
{ 0xC0000236, "STATUS_CONNECTION_REFUSED" },
{ 0xC0000237, "STATUS_GRACEFUL_DISCONNECT" },
{ 0xC0000238, "STATUS_ADDRESS_ALREADY_ASSOCIATED" },
{ 0xC0000239, "STATUS_ADDRESS_NOT_ASSOCIATED" },
{ 0xC000023A, "STATUS_CONNECTION_INVALID" },
{ 0xC000023B, "STATUS_CONNECTION_ACTIVE" },
{ 0xC000023C, "STATUS_NETWORK_UNREACHABLE" },
{ 0xC000023D, "STATUS_HOST_UNREACHABLE" },
{ 0xC000023E, "STATUS_PROTOCOL_UNREACHABLE" },
{ 0xC000023F, "STATUS_PORT_UNREACHABLE" },
{ 0xC0000240, "STATUS_REQUEST_ABORTED" },
{ 0xC0000241, "STATUS_CONNECTION_ABORTED" },
{ 0xC0000242, "STATUS_BAD_COMPRESSION_BUFFER" },
{ 0xC0000243, "STATUS_USER_MAPPED_FILE" },
{ 0xC0000244, "STATUS_AUDIT_FAILED" },
{ 0xC0000245, "STATUS_TIMER_RESOLUTION_NOT_SET" },
{ 0xC0000246, "STATUS_CONNECTION_COUNT_LIMIT" },
{ 0xC0000247, "STATUS_LOGIN_TIME_RESTRICTION" },
{ 0xC0000248, "STATUS_LOGIN_WKSTA_RESTRICTION" },
{ 0xC0000249, "STATUS_IMAGE_MP_UP_MISMATCH" },
{ 0xC0000250, "STATUS_INSUFFICIENT_LOGON_INFO" },
{ 0xC0000251, "STATUS_BAD_DLL_ENTRYPOINT" },
{ 0xC0000252, "STATUS_BAD_SERVICE_ENTRYPOINT" },
{ 0xC0000253, "STATUS_LPC_REPLY_LOST" },
{ 0xC0000254, "STATUS_IP_ADDRESS_CONFLICT1" },
{ 0xC0000255, "STATUS_IP_ADDRESS_CONFLICT2" },
{ 0xC0000256, "STATUS_REGISTRY_QUOTA_LIMIT" },
{ 0xC0000257, "STATUS_PATH_NOT_COVERED" },
{ 0xC0000258, "STATUS_NO_CALLBACK_ACTIVE" },
{ 0xC0000259, "STATUS_LICENSE_QUOTA_EXCEEDED" },
{ 0xC000025A, "STATUS_PWD_TOO_SHORT" },
{ 0xC000025B, "STATUS_PWD_TOO_RECENT" },
{ 0xC000025C, "STATUS_PWD_HISTORY_CONFLICT" },
{ 0xC000025E, "STATUS_PLUGPLAY_NO_DEVICE" },
{ 0xC000025F, "STATUS_UNSUPPORTED_COMPRESSION" },
{ 0xC0000260, "STATUS_INVALID_HW_PROFILE" },
{ 0xC0000261, "STATUS_INVALID_PLUGPLAY_DEVICE_PATH" },
{ 0xC0000262, "STATUS_DRIVER_ORDINAL_NOT_FOUND" },
{ 0xC0000263, "STATUS_DRIVER_ENTRYPOINT_NOT_FOUND" },
{ 0xC0000264, "STATUS_RESOURCE_NOT_OWNED" },
{ 0xC0000265, "STATUS_TOO_MANY_LINKS" },
{ 0xC0000266, "STATUS_QUOTA_LIST_INCONSISTENT" },
{ 0xC0000267, "STATUS_FILE_IS_OFFLINE" },
{ 0xC0000268, "STATUS_EVALUATION_EXPIRATION" },
{ 0xC0000269, "STATUS_ILLEGAL_DLL_RELOCATION" },
{ 0xC000026A, "STATUS_LICENSE_VIOLATION" },
{ 0xC000026B, "STATUS_DLL_INIT_FAILED_LOGOFF" },
{ 0xC000026C, "STATUS_DRIVER_UNABLE_TO_LOAD" },
{ 0xC000026D, "STATUS_DFS_UNAVAILABLE" },
{ 0xC000026E, "STATUS_VOLUME_DISMOUNTED" },
{ 0xC000026F, "STATUS_WX86_INTERNAL_ERROR" },
{ 0xC0000270, "STATUS_WX86_FLOAT_STACK_CHECK" },
{ 0xC0000271, "STATUS_VALIDATE_CONTINUE" },
{ 0xC0000272, "STATUS_NO_MATCH" },
{ 0xC0000273, "STATUS_NO_MORE_MATCHES" },
{ 0xC0000275, "STATUS_NOT_A_REPARSE_POINT" },
{ 0xC0000276, "STATUS_IO_REPARSE_TAG_INVALID" },
{ 0xC0000277, "STATUS_IO_REPARSE_TAG_MISMATCH" },
{ 0xC0000278, "STATUS_IO_REPARSE_DATA_INVALID" },
{ 0xC0000279, "STATUS_IO_REPARSE_TAG_NOT_HANDLED" },
{ 0xC000027A, "STATUS_PWD_TOO_LONG" },
{ 0xC000027B, "STATUS_STOWED_EXCEPTION" },
{ 0xC000027C, "STATUS_CONTEXT_STOWED_EXCEPTION" },
{ 0xC0000280, "STATUS_REPARSE_POINT_NOT_RESOLVED" },
{ 0xC0000281, "STATUS_DIRECTORY_IS_A_REPARSE_POINT" },
{ 0xC0000282, "STATUS_RANGE_LIST_CONFLICT" },
{ 0xC0000283, "STATUS_SOURCE_ELEMENT_EMPTY" },
{ 0xC0000284, "STATUS_DESTINATION_ELEMENT_FULL" },
{ 0xC0000285, "STATUS_ILLEGAL_ELEMENT_ADDRESS" },
{ 0xC0000286, "STATUS_MAGAZINE_NOT_PRESENT" },
{ 0xC0000287, "STATUS_REINITIALIZATION_NEEDED" },
{ 0xC000028A, "STATUS_ENCRYPTION_FAILED" },
{ 0xC000028B, "STATUS_DECRYPTION_FAILED" },
{ 0xC000028C, "STATUS_RANGE_NOT_FOUND" },
{ 0xC000028D, "STATUS_NO_RECOVERY_POLICY" },
{ 0xC000028E, "STATUS_NO_EFS" },
{ 0xC000028F, "STATUS_WRONG_EFS" },
{ 0xC0000290, "STATUS_NO_USER_KEYS" },
{ 0xC0000291, "STATUS_FILE_NOT_ENCRYPTED" },
{ 0xC0000292, "STATUS_NOT_EXPORT_FORMAT" },
{ 0xC0000293, "STATUS_FILE_ENCRYPTED" },
{ 0xC0000295, "STATUS_WMI_GUID_NOT_FOUND" },
{ 0xC0000296, "STATUS_WMI_INSTANCE_NOT_FOUND" },
{ 0xC0000297, "STATUS_WMI_ITEMID_NOT_FOUND" },
{ 0xC0000298, "STATUS_WMI_TRY_AGAIN" },
{ 0xC0000299, "STATUS_SHARED_POLICY" },
{ 0xC000029A, "STATUS_POLICY_OBJECT_NOT_FOUND" },
{ 0xC000029B, "STATUS_POLICY_ONLY_IN_DS" },
{ 0xC000029C, "STATUS_VOLUME_NOT_UPGRADED" },
{ 0xC000029D, "STATUS_REMOTE_STORAGE_NOT_ACTIVE" },
{ 0xC000029E, "STATUS_REMOTE_STORAGE_MEDIA_ERROR" },
{ 0xC000029F, "STATUS_NO_TRACKING_SERVICE" },
{ 0xC00002A0, "STATUS_SERVER_SID_MISMATCH" },
{ 0xC00002A1, "STATUS_DS_NO_ATTRIBUTE_OR_VALUE" },
{ 0xC00002A2, "STATUS_DS_INVALID_ATTRIBUTE_SYNTAX" },
{ 0xC00002A3, "STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED" },
{ 0xC00002A4, "STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS" },
{ 0xC00002A5, "STATUS_DS_BUSY" },
{ 0xC00002A6, "STATUS_DS_UNAVAILABLE" },
{ 0xC00002A7, "STATUS_DS_NO_RIDS_ALLOCATED" },
{ 0xC00002A8, "STATUS_DS_NO_MORE_RIDS" },
{ 0xC00002A9, "STATUS_DS_INCORRECT_ROLE_OWNER" },
{ 0xC00002AA, "STATUS_DS_RIDMGR_INIT_ERROR" },
{ 0xC00002AB, "STATUS_DS_OBJ_CLASS_VIOLATION" },
{ 0xC00002AC, "STATUS_DS_CANT_ON_NON_LEAF" },
{ 0xC00002AD, "STATUS_DS_CANT_ON_RDN" },
{ 0xC00002AE, "STATUS_DS_CANT_MOD_OBJ_CLASS" },
{ 0xC00002AF, "STATUS_DS_CROSS_DOM_MOVE_FAILED" },
{ 0xC00002B0, "STATUS_DS_GC_NOT_AVAILABLE" },
{ 0xC00002B1, "STATUS_DIRECTORY_SERVICE_REQUIRED" },
{ 0xC00002B2, "STATUS_REPARSE_ATTRIBUTE_CONFLICT" },
{ 0xC00002B3, "STATUS_CANT_ENABLE_DENY_ONLY" },
{ 0xC00002B4, "STATUS_FLOAT_MULTIPLE_FAULTS" },
{ 0xC00002B5, "STATUS_FLOAT_MULTIPLE_TRAPS" },
{ 0xC00002B6, "STATUS_DEVICE_REMOVED" },
{ 0xC00002B7, "STATUS_JOURNAL_DELETE_IN_PROGRESS" },
{ 0xC00002B8, "STATUS_JOURNAL_NOT_ACTIVE" },
{ 0xC00002B9, "STATUS_NOINTERFACE" },
{ 0xC00002BA, "STATUS_DS_RIDMGR_DISABLED" },
{ 0xC00002C1, "STATUS_DS_ADMIN_LIMIT_EXCEEDED" },
{ 0xC00002C2, "STATUS_DRIVER_FAILED_SLEEP" },
{ 0xC00002C3, "STATUS_MUTUAL_AUTHENTICATION_FAILED" },
{ 0xC00002C4, "STATUS_CORRUPT_SYSTEM_FILE" },
{ 0xC00002C5, "STATUS_DATATYPE_MISALIGNMENT_ERROR" },
{ 0xC00002C6, "STATUS_WMI_READ_ONLY" },
{ 0xC00002C7, "STATUS_WMI_SET_FAILURE" },
{ 0xC00002C8, "STATUS_COMMITMENT_MINIMUM" },
{ 0xC00002C9, "STATUS_REG_NAT_CONSUMPTION" },
{ 0xC00002CA, "STATUS_TRANSPORT_FULL" },
{ 0xC00002CB, "STATUS_DS_SAM_INIT_FAILURE" },
{ 0xC00002CC, "STATUS_ONLY_IF_CONNECTED" },
{ 0xC00002CD, "STATUS_DS_SENSITIVE_GROUP_VIOLATION" },
{ 0xC00002CE, "STATUS_PNP_RESTART_ENUMERATION" },
{ 0xC00002CF, "STATUS_JOURNAL_ENTRY_DELETED" },
{ 0xC00002D0, "STATUS_DS_CANT_MOD_PRIMARYGROUPID" },
{ 0xC00002D1, "STATUS_SYSTEM_IMAGE_BAD_SIGNATURE" },
{ 0xC00002D2, "STATUS_PNP_REBOOT_REQUIRED" },
{ 0xC00002D3, "STATUS_POWER_STATE_INVALID" },
{ 0xC00002D4, "STATUS_DS_INVALID_GROUP_TYPE" },
{ 0xC00002D5, "STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN" },
{ 0xC00002D6, "STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN" },
{ 0xC00002D7, "STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER" },
{ 0xC00002D8, "STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER" },
{ 0xC00002D9, "STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER" },
{ 0xC00002DA, "STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER" },
{ 0xC00002DB, "STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER" },
{ 0xC00002DC, "STATUS_DS_HAVE_PRIMARY_MEMBERS" },
{ 0xC00002DD, "STATUS_WMI_NOT_SUPPORTED" },
{ 0xC00002DE, "STATUS_INSUFFICIENT_POWER" },
{ 0xC00002DF, "STATUS_SAM_NEED_BOOTKEY_PASSWORD" },
{ 0xC00002E0, "STATUS_SAM_NEED_BOOTKEY_FLOPPY" },
{ 0xC00002E1, "STATUS_DS_CANT_START" },
{ 0xC00002E2, "STATUS_DS_INIT_FAILURE" },
{ 0xC00002E3, "STATUS_SAM_INIT_FAILURE" },
{ 0xC00002E4, "STATUS_DS_GC_REQUIRED" },
{ 0xC00002E5, "STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY" },
{ 0xC00002E6, "STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS" },
{ 0xC00002E7, "STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED" },
{ 0xC00002E8, "STATUS_MULTIPLE_FAULT_VIOLATION" },
{ 0xC00002E9, "STATUS_CURRENT_DOMAIN_NOT_ALLOWED" },
{ 0xC00002EA, "STATUS_CANNOT_MAKE" },
{ 0xC00002EB, "STATUS_SYSTEM_SHUTDOWN" },
{ 0xC00002EC, "STATUS_DS_INIT_FAILURE_CONSOLE" },
{ 0xC00002ED, "STATUS_DS_SAM_INIT_FAILURE_CONSOLE" },
{ 0xC00002EE, "STATUS_UNFINISHED_CONTEXT_DELETED" },
{ 0xC00002EF, "STATUS_NO_TGT_REPLY" },
{ 0xC00002F0, "STATUS_OBJECTID_NOT_FOUND" },
{ 0xC00002F1, "STATUS_NO_IP_ADDRESSES" },
{ 0xC00002F2, "STATUS_WRONG_CREDENTIAL_HANDLE" },
{ 0xC00002F3, "STATUS_CRYPTO_SYSTEM_INVALID" },
{ 0xC00002F4, "STATUS_MAX_REFERRALS_EXCEEDED" },
{ 0xC00002F5, "STATUS_MUST_BE_KDC" },
{ 0xC00002F6, "STATUS_STRONG_CRYPTO_NOT_SUPPORTED" },
{ 0xC00002F7, "STATUS_TOO_MANY_PRINCIPALS" },
{ 0xC00002F8, "STATUS_NO_PA_DATA" },
{ 0xC00002F9, "STATUS_PKINIT_NAME_MISMATCH" },
{ 0xC00002FA, "STATUS_SMARTCARD_LOGON_REQUIRED" },
{ 0xC00002FB, "STATUS_KDC_INVALID_REQUEST" },
{ 0xC00002FC, "STATUS_KDC_UNABLE_TO_REFER" },
{ 0xC00002FD, "STATUS_KDC_UNKNOWN_ETYPE" },
{ 0xC00002FE, "STATUS_SHUTDOWN_IN_PROGRESS" },
{ 0xC00002FF, "STATUS_SERVER_SHUTDOWN_IN_PROGRESS" },
{ 0xC0000300, "STATUS_NOT_SUPPORTED_ON_SBS" },
{ 0xC0000301, "STATUS_WMI_GUID_DISCONNECTED" },
{ 0xC0000302, "STATUS_WMI_ALREADY_DISABLED" },
{ 0xC0000303, "STATUS_WMI_ALREADY_ENABLED" },
{ 0xC0000304, "STATUS_MFT_TOO_FRAGMENTED" },
{ 0xC0000305, "STATUS_COPY_PROTECTION_FAILURE" },
{ 0xC0000306, "STATUS_CSS_AUTHENTICATION_FAILURE" },
{ 0xC0000307, "STATUS_CSS_KEY_NOT_PRESENT" },
{ 0xC0000308, "STATUS_CSS_KEY_NOT_ESTABLISHED" },
{ 0xC0000309, "STATUS_CSS_SCRAMBLED_SECTOR" },
{ 0xC000030A, "STATUS_CSS_REGION_MISMATCH" },
{ 0xC000030B, "STATUS_CSS_RESETS_EXHAUSTED" },
{ 0xC000030C, "STATUS_PASSWORD_CHANGE_REQUIRED" },
{ 0xC000030D, "STATUS_LOST_MODE_LOGON_RESTRICTION" },
{ 0xC0000320, "STATUS_PKINIT_FAILURE" },
{ 0xC0000321, "STATUS_SMARTCARD_SUBSYSTEM_FAILURE" },
{ 0xC0000322, "STATUS_NO_KERB_KEY" },
{ 0xC0000350, "STATUS_HOST_DOWN" },
{ 0xC0000351, "STATUS_UNSUPPORTED_PREAUTH" },
{ 0xC0000352, "STATUS_EFS_ALG_BLOB_TOO_BIG" },
{ 0xC0000353, "STATUS_PORT_NOT_SET" },
{ 0xC0000354, "STATUS_DEBUGGER_INACTIVE" },
{ 0xC0000355, "STATUS_DS_VERSION_CHECK_FAILURE" },
{ 0xC0000356, "STATUS_AUDITING_DISABLED" },
{ 0xC0000357, "STATUS_PRENT4_MACHINE_ACCOUNT" },
{ 0xC0000358, "STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER" },
{ 0xC0000359, "STATUS_INVALID_IMAGE_WIN_32" },
{ 0xC000035A, "STATUS_INVALID_IMAGE_WIN_64" },
{ 0xC000035B, "STATUS_BAD_BINDINGS" },
{ 0xC000035C, "STATUS_NETWORK_SESSION_EXPIRED" },
{ 0xC000035D, "STATUS_APPHELP_BLOCK" },
{ 0xC000035E, "STATUS_ALL_SIDS_FILTERED" },
{ 0xC000035F, "STATUS_NOT_SAFE_MODE_DRIVER" },
{ 0xC0000361, "STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT" },
{ 0xC0000362, "STATUS_ACCESS_DISABLED_BY_POLICY_PATH" },
{ 0xC0000363, "STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER" },
{ 0xC0000364, "STATUS_ACCESS_DISABLED_BY_POLICY_OTHER" },
{ 0xC0000365, "STATUS_FAILED_DRIVER_ENTRY" },
{ 0xC0000366, "STATUS_DEVICE_ENUMERATION_ERROR" },
{ 0xC0000368, "STATUS_MOUNT_POINT_NOT_RESOLVED" },
{ 0xC0000369, "STATUS_INVALID_DEVICE_OBJECT_PARAMETER" },
{ 0xC000036A, "STATUS_MCA_OCCURED" },
{ 0xC000036B, "STATUS_DRIVER_BLOCKED_CRITICAL" },
{ 0xC000036C, "STATUS_DRIVER_BLOCKED" },
{ 0xC000036D, "STATUS_DRIVER_DATABASE_ERROR" },
{ 0xC000036E, "STATUS_SYSTEM_HIVE_TOO_LARGE" },
{ 0xC000036F, "STATUS_INVALID_IMPORT_OF_NON_DLL" },
{ 0xC0000371, "STATUS_NO_SECRETS" },
{ 0xC0000372, "STATUS_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY" },
{ 0xC0000373, "STATUS_FAILED_STACK_SWITCH" },
{ 0xC0000374, "STATUS_HEAP_CORRUPTION" },
{ 0xC0000380, "STATUS_SMARTCARD_WRONG_PIN" },
{ 0xC0000381, "STATUS_SMARTCARD_CARD_BLOCKED" },
{ 0xC0000382, "STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED" },
{ 0xC0000383, "STATUS_SMARTCARD_NO_CARD" },
{ 0xC0000384, "STATUS_SMARTCARD_NO_KEY_CONTAINER" },
{ 0xC0000385, "STATUS_SMARTCARD_NO_CERTIFICATE" },
{ 0xC0000386, "STATUS_SMARTCARD_NO_KEYSET" },
{ 0xC0000387, "STATUS_SMARTCARD_IO_ERROR" },
{ 0xC0000388, "STATUS_DOWNGRADE_DETECTED" },
{ 0xC0000389, "STATUS_SMARTCARD_CERT_REVOKED" },
{ 0xC000038A, "STATUS_ISSUING_CA_UNTRUSTED" },
{ 0xC000038B, "STATUS_REVOCATION_OFFLINE_C" },
{ 0xC000038C, "STATUS_PKINIT_CLIENT_FAILURE" },
{ 0xC000038D, "STATUS_SMARTCARD_CERT_EXPIRED" },
{ 0xC000038E, "STATUS_DRIVER_FAILED_PRIOR_UNLOAD" },
{ 0xC000038F, "STATUS_SMARTCARD_SILENT_CONTEXT" },
{ 0xC0000401, "STATUS_PER_USER_TRUST_QUOTA_EXCEEDED" },
{ 0xC0000402, "STATUS_ALL_USER_TRUST_QUOTA_EXCEEDED" },
{ 0xC0000403, "STATUS_USER_DELETE_TRUST_QUOTA_EXCEEDED" },
{ 0xC0000404, "STATUS_DS_NAME_NOT_UNIQUE" },
{ 0xC0000405, "STATUS_DS_DUPLICATE_ID_FOUND" },
{ 0xC0000406, "STATUS_DS_GROUP_CONVERSION_ERROR" },
{ 0xC0000407, "STATUS_VOLSNAP_PREPARE_HIBERNATE" },
{ 0xC0000408, "STATUS_USER2USER_REQUIRED" },
{ 0xC0000409, "STATUS_STACK_BUFFER_OVERRUN" },
{ 0xC000040A, "STATUS_NO_S4U_PROT_SUPPORT" },
{ 0xC000040B, "STATUS_CROSSREALM_DELEGATION_FAILURE" },
{ 0xC000040C, "STATUS_REVOCATION_OFFLINE_KDC" },
{ 0xC000040D, "STATUS_ISSUING_CA_UNTRUSTED_KDC" },
{ 0xC000040E, "STATUS_KDC_CERT_EXPIRED" },
{ 0xC000040F, "STATUS_KDC_CERT_REVOKED" },
{ 0xC0000410, "STATUS_PARAMETER_QUOTA_EXCEEDED" },
{ 0xC0000411, "STATUS_HIBERNATION_FAILURE" },
{ 0xC0000412, "STATUS_DELAY_LOAD_FAILED" },
{ 0xC0000413, "STATUS_AUTHENTICATION_FIREWALL_FAILED" },
{ 0xC0000414, "STATUS_VDM_DISALLOWED" },
{ 0xC0000415, "STATUS_HUNG_DISPLAY_DRIVER_THREAD" },
{ 0xC0000416, "STATUS_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE" },
{ 0xC0000417, "STATUS_INVALID_CRUNTIME_PARAMETER" },
{ 0xC0000418, "STATUS_NTLM_BLOCKED" },
{ 0xC0000419, "STATUS_DS_SRC_SID_EXISTS_IN_FOREST" },
{ 0xC000041A, "STATUS_DS_DOMAIN_NAME_EXISTS_IN_FOREST" },
{ 0xC000041B, "STATUS_DS_FLAT_NAME_EXISTS_IN_FOREST" },
{ 0xC000041C, "STATUS_INVALID_USER_PRINCIPAL_NAME" },
{ 0xC000041D, "STATUS_FATAL_USER_CALLBACK_EXCEPTION" },
{ 0xC0000420, "STATUS_ASSERTION_FAILURE" },
{ 0xC0000421, "STATUS_VERIFIER_STOP" },
{ 0xC0000423, "STATUS_CALLBACK_POP_STACK" },
{ 0xC0000424, "STATUS_INCOMPATIBLE_DRIVER_BLOCKED" },
{ 0xC0000425, "STATUS_HIVE_UNLOADED" },
{ 0xC0000426, "STATUS_COMPRESSION_DISABLED" },
{ 0xC0000427, "STATUS_FILE_SYSTEM_LIMITATION" },
{ 0xC0000428, "STATUS_INVALID_IMAGE_HASH" },
{ 0xC0000429, "STATUS_NOT_CAPABLE" },
{ 0xC000042A, "STATUS_REQUEST_OUT_OF_SEQUENCE" },
{ 0xC000042B, "STATUS_IMPLEMENTATION_LIMIT" },
{ 0xC000042C, "STATUS_ELEVATION_REQUIRED" },
{ 0xC000042D, "STATUS_NO_SECURITY_CONTEXT" },
{ 0xC000042F, "STATUS_PKU2U_CERT_FAILURE" },
{ 0xC0000432, "STATUS_BEYOND_VDL" },
{ 0xC0000433, "STATUS_ENCOUNTERED_WRITE_IN_PROGRESS" },
{ 0xC0000434, "STATUS_PTE_CHANGED" },
{ 0xC0000435, "STATUS_PURGE_FAILED" },
{ 0xC0000440, "STATUS_CRED_REQUIRES_CONFIRMATION" },
{ 0xC0000441, "STATUS_CS_ENCRYPTION_INVALID_SERVER_RESPONSE" },
{ 0xC0000442, "STATUS_CS_ENCRYPTION_UNSUPPORTED_SERVER" },
{ 0xC0000443, "STATUS_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE" },
{ 0xC0000444, "STATUS_CS_ENCRYPTION_NEW_ENCRYPTED_FILE" },
{ 0xC0000445, "STATUS_CS_ENCRYPTION_FILE_NOT_CSE" },
{ 0xC0000446, "STATUS_INVALID_LABEL" },
{ 0xC0000450, "STATUS_DRIVER_PROCESS_TERMINATED" },
{ 0xC0000451, "STATUS_AMBIGUOUS_SYSTEM_DEVICE" },
{ 0xC0000452, "STATUS_SYSTEM_DEVICE_NOT_FOUND" },
{ 0xC0000453, "STATUS_RESTART_BOOT_APPLICATION" },
{ 0xC0000454, "STATUS_INSUFFICIENT_NVRAM_RESOURCES" },
{ 0xC0000455, "STATUS_INVALID_SESSION" },
{ 0xC0000456, "STATUS_THREAD_ALREADY_IN_SESSION" },
{ 0xC0000457, "STATUS_THREAD_NOT_IN_SESSION" },
{ 0xC0000458, "STATUS_INVALID_WEIGHT" },
{ 0xC0000459, "STATUS_REQUEST_PAUSED" },
{ 0xC0000460, "STATUS_NO_RANGES_PROCESSED" },
{ 0xC0000461, "STATUS_DISK_RESOURCES_EXHAUSTED" },
{ 0xC0000462, "STATUS_NEEDS_REMEDIATION" },
{ 0xC0000463, "STATUS_DEVICE_FEATURE_NOT_SUPPORTED" },
{ 0xC0000464, "STATUS_DEVICE_UNREACHABLE" },
{ 0xC0000465, "STATUS_INVALID_TOKEN" },
{ 0xC0000466, "STATUS_SERVER_UNAVAILABLE" },
{ 0xC0000467, "STATUS_FILE_NOT_AVAILABLE" },
{ 0xC0000468, "STATUS_DEVICE_INSUFFICIENT_RESOURCES" },
{ 0xC0000469, "STATUS_PACKAGE_UPDATING" },
{ 0xC000046A, "STATUS_NOT_READ_FROM_COPY" },
{ 0xC000046B, "STATUS_FT_WRITE_FAILURE" },
{ 0xC000046C, "STATUS_FT_DI_SCAN_REQUIRED" },
{ 0xC000046D, "STATUS_OBJECT_NOT_EXTERNALLY_BACKED" },
{ 0xC000046E, "STATUS_EXTERNAL_BACKING_PROVIDER_UNKNOWN" },
{ 0xC000046F, "STATUS_COMPRESSION_NOT_BENEFICIAL" },
{ 0xC0000470, "STATUS_DATA_CHECKSUM_ERROR" },
{ 0xC0000471, "STATUS_INTERMIXED_KERNEL_EA_OPERATION" },
{ 0xC0000472, "STATUS_TRIM_READ_ZERO_NOT_SUPPORTED" },
{ 0xC0000473, "STATUS_TOO_MANY_SEGMENT_DESCRIPTORS" },
{ 0xC0000474, "STATUS_INVALID_OFFSET_ALIGNMENT" },
{ 0xC0000475, "STATUS_INVALID_FIELD_IN_PARAMETER_LIST" },
{ 0xC0000476, "STATUS_OPERATION_IN_PROGRESS" },
{ 0xC0000477, "STATUS_INVALID_INITIATOR_TARGET_PATH" },
{ 0xC0000478, "STATUS_SCRUB_DATA_DISABLED" },
{ 0xC0000479, "STATUS_NOT_REDUNDANT_STORAGE" },
{ 0xC000047A, "STATUS_RESIDENT_FILE_NOT_SUPPORTED" },
{ 0xC000047B, "STATUS_COMPRESSED_FILE_NOT_SUPPORTED" },
{ 0xC000047C, "STATUS_DIRECTORY_NOT_SUPPORTED" },
{ 0xC000047D, "STATUS_IO_OPERATION_TIMEOUT" },
{ 0xC000047E, "STATUS_SYSTEM_NEEDS_REMEDIATION" },
{ 0xC000047F, "STATUS_APPX_INTEGRITY_FAILURE_CLR_NGEN" },
{ 0xC0000480, "STATUS_SHARE_UNAVAILABLE" },
{ 0xC0000481, "STATUS_APISET_NOT_HOSTED" },
{ 0xC0000482, "STATUS_APISET_NOT_PRESENT" },
{ 0xC0000483, "STATUS_DEVICE_HARDWARE_ERROR" },
{ 0xC0000484, "STATUS_FIRMWARE_SLOT_INVALID" },
{ 0xC0000485, "STATUS_FIRMWARE_IMAGE_INVALID" },
{ 0xC0000486, "STATUS_STORAGE_TOPOLOGY_ID_MISMATCH" },
{ 0xC0000487, "STATUS_WIM_NOT_BOOTABLE" },
{ 0xC0000488, "STATUS_BLOCKED_BY_PARENTAL_CONTROLS" },
{ 0xC0000489, "STATUS_NEEDS_REGISTRATION" },
{ 0xC000048A, "STATUS_QUOTA_ACTIVITY" },
{ 0xC000048B, "STATUS_CALLBACK_INVOKE_INLINE" },
{ 0xC000048C, "STATUS_BLOCK_TOO_MANY_REFERENCES" },
{ 0xC000048D, "STATUS_MARKED_TO_DISALLOW_WRITES" },
{ 0xC000048E, "STATUS_NETWORK_ACCESS_DENIED_EDP" },
{ 0xC000048F, "STATUS_ENCLAVE_FAILURE" },
{ 0xC0000490, "STATUS_PNP_NO_COMPAT_DRIVERS" },
{ 0xC0000491, "STATUS_PNP_DRIVER_PACKAGE_NOT_FOUND" },
{ 0xC0000492, "STATUS_PNP_DRIVER_CONFIGURATION_NOT_FOUND" },
{ 0xC0000493, "STATUS_PNP_DRIVER_CONFIGURATION_INCOMPLETE" },
{ 0xC0000494, "STATUS_PNP_FUNCTION_DRIVER_REQUIRED" },
{ 0xC0000495, "STATUS_PNP_DEVICE_CONFIGURATION_PENDING" },
{ 0xC0000496, "STATUS_DEVICE_HINT_NAME_BUFFER_TOO_SMALL" },
{ 0xC0000497, "STATUS_PACKAGE_NOT_AVAILABLE" },
{ 0xC0000499, "STATUS_DEVICE_IN_MAINTENANCE" },
{ 0xC000049A, "STATUS_NOT_SUPPORTED_ON_DAX" },
{ 0xC000049B, "STATUS_FREE_SPACE_TOO_FRAGMENTED" },
{ 0xC000049C, "STATUS_DAX_MAPPING_EXISTS" },
{ 0xC000049D, "STATUS_CHILD_PROCESS_BLOCKED" },
{ 0xC000049E, "STATUS_STORAGE_LOST_DATA_PERSISTENCE" },
{ 0xC000049F, "STATUS_VRF_CFG_ENABLED" },
{ 0xC00004A0, "STATUS_PARTITION_TERMINATING" },
{ 0xC00004A1, "STATUS_EXTERNAL_SYSKEY_NOT_SUPPORTED" },
{ 0xC0000500, "STATUS_INVALID_TASK_NAME" },
{ 0xC0000501, "STATUS_INVALID_TASK_INDEX" },
{ 0xC0000502, "STATUS_THREAD_ALREADY_IN_TASK" },
{ 0xC0000503, "STATUS_CALLBACK_BYPASS" },
{ 0xC0000504, "STATUS_UNDEFINED_SCOPE" },
{ 0xC0000505, "STATUS_INVALID_CAP" },
{ 0xC0000506, "STATUS_NOT_GUI_PROCESS" },
{ 0xC0000507, "STATUS_DEVICE_HUNG" },
{ 0xC0000508, "STATUS_CONTAINER_ASSIGNED" },
{ 0xC0000509, "STATUS_JOB_NO_CONTAINER" },
{ 0xC000050A, "STATUS_DEVICE_UNRESPONSIVE" },
{ 0xC000050B, "STATUS_REPARSE_POINT_ENCOUNTERED" },
{ 0xC000050C, "STATUS_ATTRIBUTE_NOT_PRESENT" },
{ 0xC000050D, "STATUS_NOT_A_TIERED_VOLUME" },
{ 0xC000050E, "STATUS_ALREADY_HAS_STREAM_ID" },
{ 0xC000050F, "STATUS_JOB_NOT_EMPTY" },
{ 0xC0000510, "STATUS_ALREADY_INITIALIZED" },
{ 0xC0000511, "STATUS_ENCLAVE_NOT_TERMINATED" },
{ 0xC0000512, "STATUS_ENCLAVE_IS_TERMINATING" },
{ 0xC0000513, "STATUS_SMB1_NOT_AVAILABLE" },
{ 0xC0000514, "STATUS_SMR_GARBAGE_COLLECTION_REQUIRED" },
{ 0xC0000602, "STATUS_FAIL_FAST_EXCEPTION" },
{ 0xC0000603, "STATUS_IMAGE_CERT_REVOKED" },
{ 0xC0000604, "STATUS_DYNAMIC_CODE_BLOCKED" },
{ 0xC0000605, "STATUS_IMAGE_CERT_EXPIRED" },
{ 0xC0000606, "STATUS_STRICT_CFG_VIOLATION" },
{ 0xC000060A, "STATUS_SET_CONTEXT_DENIED" },
{ 0xC000060B, "STATUS_CROSS_PARTITION_VIOLATION" },
{ 0xC0000700, "STATUS_PORT_CLOSED" },
{ 0xC0000701, "STATUS_MESSAGE_LOST" },
{ 0xC0000702, "STATUS_INVALID_MESSAGE" },
{ 0xC0000703, "STATUS_REQUEST_CANCELED" },
{ 0xC0000704, "STATUS_RECURSIVE_DISPATCH" },
{ 0xC0000705, "STATUS_LPC_RECEIVE_BUFFER_EXPECTED" },
{ 0xC0000706, "STATUS_LPC_INVALID_CONNECTION_USAGE" },
{ 0xC0000707, "STATUS_LPC_REQUESTS_NOT_ALLOWED" },
{ 0xC0000708, "STATUS_RESOURCE_IN_USE" },
{ 0xC0000709, "STATUS_HARDWARE_MEMORY_ERROR" },
{ 0xC000070A, "STATUS_THREADPOOL_HANDLE_EXCEPTION" },
{ 0xC000070B, "STATUS_THREADPOOL_SET_EVENT_ON_COMPLETION_FAILED" },
{ 0xC000070C, "STATUS_THREADPOOL_RELEASE_SEMAPHORE_ON_COMPLETION_FAILED" },
{ 0xC000070D, "STATUS_THREADPOOL_RELEASE_MUTEX_ON_COMPLETION_FAILED" },
{ 0xC000070E, "STATUS_THREADPOOL_FREE_LIBRARY_ON_COMPLETION_FAILED" },
{ 0xC000070F, "STATUS_THREADPOOL_RELEASED_DURING_OPERATION" },
{ 0xC0000710, "STATUS_CALLBACK_RETURNED_WHILE_IMPERSONATING" },
{ 0xC0000711, "STATUS_APC_RETURNED_WHILE_IMPERSONATING" },
{ 0xC0000712, "STATUS_PROCESS_IS_PROTECTED" },
{ 0xC0000713, "STATUS_MCA_EXCEPTION" },
{ 0xC0000714, "STATUS_CERTIFICATE_MAPPING_NOT_UNIQUE" },
{ 0xC0000715, "STATUS_SYMLINK_CLASS_DISABLED" },
{ 0xC0000716, "STATUS_INVALID_IDN_NORMALIZATION" },
{ 0xC0000717, "STATUS_NO_UNICODE_TRANSLATION" },
{ 0xC0000718, "STATUS_ALREADY_REGISTERED" },
{ 0xC0000719, "STATUS_CONTEXT_MISMATCH" },
{ 0xC000071A, "STATUS_PORT_ALREADY_HAS_COMPLETION_LIST" },
{ 0xC000071B, "STATUS_CALLBACK_RETURNED_THREAD_PRIORITY" },
{ 0xC000071C, "STATUS_INVALID_THREAD" },
{ 0xC000071D, "STATUS_CALLBACK_RETURNED_TRANSACTION" },
{ 0xC000071E, "STATUS_CALLBACK_RETURNED_LDR_LOCK" },
{ 0xC000071F, "STATUS_CALLBACK_RETURNED_LANG" },
{ 0xC0000720, "STATUS_CALLBACK_RETURNED_PRI_BACK" },
{ 0xC0000721, "STATUS_CALLBACK_RETURNED_THREAD_AFFINITY" },
{ 0xC0000722, "STATUS_LPC_HANDLE_COUNT_EXCEEDED" },
{ 0xC0000723, "STATUS_EXECUTABLE_MEMORY_WRITE" },
{ 0xC0000724, "STATUS_KERNEL_EXECUTABLE_MEMORY_WRITE" },
{ 0xC0000725, "STATUS_ATTACHED_EXECUTABLE_MEMORY_WRITE" },
{ 0xC0000726, "STATUS_TRIGGERED_EXECUTABLE_MEMORY_WRITE" },
{ 0xC0000800, "STATUS_DISK_REPAIR_DISABLED" },
{ 0xC0000801, "STATUS_DS_DOMAIN_RENAME_IN_PROGRESS" },
{ 0xC0000802, "STATUS_DISK_QUOTA_EXCEEDED" },
{ 0xC0000804, "STATUS_CONTENT_BLOCKED" },
{ 0xC0000805, "STATUS_BAD_CLUSTERS" },
{ 0xC0000806, "STATUS_VOLUME_DIRTY" },
{ 0xC0000808, "STATUS_DISK_REPAIR_UNSUCCESSFUL" },
{ 0xC0000809, "STATUS_CORRUPT_LOG_OVERFULL" },
{ 0xC000080A, "STATUS_CORRUPT_LOG_CORRUPTED" },
{ 0xC000080B, "STATUS_CORRUPT_LOG_UNAVAILABLE" },
{ 0xC000080C, "STATUS_CORRUPT_LOG_DELETED_FULL" },
{ 0xC000080D, "STATUS_CORRUPT_LOG_CLEARED" },
{ 0xC000080E, "STATUS_ORPHAN_NAME_EXHAUSTED" },
{ 0xC000080F, "STATUS_PROACTIVE_SCAN_IN_PROGRESS" },
{ 0xC0000810, "STATUS_ENCRYPTED_IO_NOT_POSSIBLE" },
{ 0xC0000811, "STATUS_CORRUPT_LOG_UPLEVEL_RECORDS" },
{ 0xC0000901, "STATUS_FILE_CHECKED_OUT" },
{ 0xC0000902, "STATUS_CHECKOUT_REQUIRED" },
{ 0xC0000903, "STATUS_BAD_FILE_TYPE" },
{ 0xC0000904, "STATUS_FILE_TOO_LARGE" },
{ 0xC0000905, "STATUS_FORMS_AUTH_REQUIRED" },
{ 0xC0000906, "STATUS_VIRUS_INFECTED" },
{ 0xC0000907, "STATUS_VIRUS_DELETED" },
{ 0xC0000908, "STATUS_BAD_MCFG_TABLE" },
{ 0xC0000909, "STATUS_CANNOT_BREAK_OPLOCK" },
{ 0xC000090A, "STATUS_BAD_KEY" },
{ 0xC000090B, "STATUS_BAD_DATA" },
{ 0xC000090C, "STATUS_NO_KEY" },
{ 0xC0000910, "STATUS_FILE_HANDLE_REVOKED" },
{ 0xC0009898, "STATUS_WOW_ASSERTION" },
{ 0xC000A000, "STATUS_INVALID_SIGNATURE" },
{ 0xC000A001, "STATUS_HMAC_NOT_SUPPORTED" },
{ 0xC000A002, "STATUS_AUTH_TAG_MISMATCH" },
{ 0xC000A003, "STATUS_INVALID_STATE_TRANSITION" },
{ 0xC000A004, "STATUS_INVALID_KERNEL_INFO_VERSION" },
{ 0xC000A005, "STATUS_INVALID_PEP_INFO_VERSION" },
{ 0xC000A006, "STATUS_HANDLE_REVOKED" },
{ 0xC000A007, "STATUS_EOF_ON_GHOSTED_RANGE" },
{ 0xC000A010, "STATUS_IPSEC_QUEUE_OVERFLOW" },
{ 0xC000A011, "STATUS_ND_QUEUE_OVERFLOW" },
{ 0xC000A012, "STATUS_HOPLIMIT_EXCEEDED" },
{ 0xC000A013, "STATUS_PROTOCOL_NOT_SUPPORTED" },
{ 0xC000A014, "STATUS_FASTPATH_REJECTED" },
{ 0xC000A080, "STATUS_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED" },
{ 0xC000A081, "STATUS_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR" },
{ 0xC000A082, "STATUS_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR" },
{ 0xC000A083, "STATUS_XML_PARSE_ERROR" },
{ 0xC000A084, "STATUS_XMLDSIG_ERROR" },
{ 0xC000A085, "STATUS_WRONG_COMPARTMENT" },
{ 0xC000A086, "STATUS_AUTHIP_FAILURE" },
{ 0xC000A087, "STATUS_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS" },
{ 0xC000A088, "STATUS_DS_OID_NOT_FOUND" },
{ 0xC000A089, "STATUS_INCORRECT_ACCOUNT_TYPE" },
{ 0xC000A100, "STATUS_HASH_NOT_SUPPORTED" },
{ 0xC000A101, "STATUS_HASH_NOT_PRESENT" },
{ 0xC000A121, "STATUS_SECONDARY_IC_PROVIDER_NOT_REGISTERED" },
{ 0xC000A122, "STATUS_GPIO_CLIENT_INFORMATION_INVALID" },
{ 0xC000A123, "STATUS_GPIO_VERSION_NOT_SUPPORTED" },
{ 0xC000A124, "STATUS_GPIO_INVALID_REGISTRATION_PACKET" },
{ 0xC000A125, "STATUS_GPIO_OPERATION_DENIED" },
{ 0xC000A126, "STATUS_GPIO_INCOMPATIBLE_CONNECT_MODE" },
{ 0xC000A141, "STATUS_CANNOT_SWITCH_RUNLEVEL" },
{ 0xC000A142, "STATUS_INVALID_RUNLEVEL_SETTING" },
{ 0xC000A143, "STATUS_RUNLEVEL_SWITCH_TIMEOUT" },
{ 0xC000A145, "STATUS_RUNLEVEL_SWITCH_AGENT_TIMEOUT" },
{ 0xC000A146, "STATUS_RUNLEVEL_SWITCH_IN_PROGRESS" },
{ 0xC000A200, "STATUS_NOT_APPCONTAINER" },
{ 0xC000A201, "STATUS_NOT_SUPPORTED_IN_APPCONTAINER" },
{ 0xC000A202, "STATUS_INVALID_PACKAGE_SID_LENGTH" },
{ 0xC000A203, "STATUS_LPAC_ACCESS_DENIED" },
{ 0xC000A281, "STATUS_APP_DATA_NOT_FOUND" },
{ 0xC000A282, "STATUS_APP_DATA_EXPIRED" },
{ 0xC000A283, "STATUS_APP_DATA_CORRUPT" },
{ 0xC000A284, "STATUS_APP_DATA_LIMIT_EXCEEDED" },
{ 0xC000A285, "STATUS_APP_DATA_REBOOT_REQUIRED" },
{ 0xC000A2A1, "STATUS_OFFLOAD_READ_FLT_NOT_SUPPORTED" },
{ 0xC000A2A2, "STATUS_OFFLOAD_WRITE_FLT_NOT_SUPPORTED" },
{ 0xC000A2A3, "STATUS_OFFLOAD_READ_FILE_NOT_SUPPORTED" },
{ 0xC000A2A4, "STATUS_OFFLOAD_WRITE_FILE_NOT_SUPPORTED" },
{ 0xC000CE01, "STATUS_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE" },
{ 0xC000CE02, "STATUS_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT" },
{ 0xC000CE03, "STATUS_FILE_SYSTEM_VIRTUALIZATION_BUSY" },
{ 0xC000CE04, "STATUS_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN" },
{ 0xC000CE05, "STATUS_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION" },
{ 0xC000CF00, "STATUS_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT" },
{ 0xC000CF01, "STATUS_CLOUD_FILE_PROVIDER_NOT_RUNNING" },
{ 0xC000CF02, "STATUS_CLOUD_FILE_METADATA_CORRUPT" },
{ 0xC000CF03, "STATUS_CLOUD_FILE_METADATA_TOO_LARGE" },
{ 0xC000CF06, "STATUS_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED" },
{ 0xC000CF07, "STATUS_NOT_A_CLOUD_FILE" },
{ 0xC000CF08, "STATUS_CLOUD_FILE_NOT_IN_SYNC" },
{ 0xC000CF09, "STATUS_CLOUD_FILE_ALREADY_CONNECTED" },
{ 0xC000CF0A, "STATUS_CLOUD_FILE_NOT_SUPPORTED" },
{ 0xC000CF0B, "STATUS_CLOUD_FILE_INVALID_REQUEST" },
{ 0xC000CF0C, "STATUS_CLOUD_FILE_READ_ONLY_VOLUME" },
{ 0xC000CF0D, "STATUS_CLOUD_FILE_CONNECTED_PROVIDER_ONLY" },
{ 0xC000CF0E, "STATUS_CLOUD_FILE_VALIDATION_FAILED" },
{ 0xC000CF0F, "STATUS_CLOUD_FILE_AUTHENTICATION_FAILED" },
{ 0xC000CF10, "STATUS_CLOUD_FILE_INSUFFICIENT_RESOURCES" },
{ 0xC000CF11, "STATUS_CLOUD_FILE_NETWORK_UNAVAILABLE" },
{ 0xC000CF12, "STATUS_CLOUD_FILE_UNSUCCESSFUL" },
{ 0xC000CF13, "STATUS_CLOUD_FILE_NOT_UNDER_SYNC_ROOT" },
{ 0xC000CF14, "STATUS_CLOUD_FILE_IN_USE" },
{ 0xC000CF15, "STATUS_CLOUD_FILE_PINNED" },
{ 0xC000CF16, "STATUS_CLOUD_FILE_REQUEST_ABORTED" },
{ 0xC000CF17, "STATUS_CLOUD_FILE_PROPERTY_CORRUPT" },
{ 0xC000CF18, "STATUS_CLOUD_FILE_ACCESS_DENIED" },
{ 0xC000CF19, "STATUS_CLOUD_FILE_INCOMPATIBLE_HARDLINKS" },
{ 0xC000CF1A, "STATUS_CLOUD_FILE_PROPERTY_LOCK_CONFLICT" },
{ 0xC000CF1B, "STATUS_CLOUD_FILE_REQUEST_CANCELED" },
{ 0xC0010001, "DBG_NO_STATE_CHANGE" },
{ 0xC0010002, "DBG_APP_NOT_IDLE" },
{ 0xC0020001, "RPC_NT_INVALID_STRING_BINDING" },
{ 0xC0020002, "RPC_NT_WRONG_KIND_OF_BINDING" },
{ 0xC0020003, "RPC_NT_INVALID_BINDING" },
{ 0xC0020004, "RPC_NT_PROTSEQ_NOT_SUPPORTED" },
{ 0xC0020005, "RPC_NT_INVALID_RPC_PROTSEQ" },
{ 0xC0020006, "RPC_NT_INVALID_STRING_UUID" },
{ 0xC0020007, "RPC_NT_INVALID_ENDPOINT_FORMAT" },
{ 0xC0020008, "RPC_NT_INVALID_NET_ADDR" },
{ 0xC0020009, "RPC_NT_NO_ENDPOINT_FOUND" },
{ 0xC002000A, "RPC_NT_INVALID_TIMEOUT" },
{ 0xC002000B, "RPC_NT_OBJECT_NOT_FOUND" },
{ 0xC002000C, "RPC_NT_ALREADY_REGISTERED" },
{ 0xC002000D, "RPC_NT_TYPE_ALREADY_REGISTERED" },
{ 0xC002000E, "RPC_NT_ALREADY_LISTENING" },
{ 0xC002000F, "RPC_NT_NO_PROTSEQS_REGISTERED" },
{ 0xC0020010, "RPC_NT_NOT_LISTENING" },
{ 0xC0020011, "RPC_NT_UNKNOWN_MGR_TYPE" },
{ 0xC0020012, "RPC_NT_UNKNOWN_IF" },
{ 0xC0020013, "RPC_NT_NO_BINDINGS" },
{ 0xC0020014, "RPC_NT_NO_PROTSEQS" },
{ 0xC0020015, "RPC_NT_CANT_CREATE_ENDPOINT" },
{ 0xC0020016, "RPC_NT_OUT_OF_RESOURCES" },
{ 0xC0020017, "RPC_NT_SERVER_UNAVAILABLE" },
{ 0xC0020018, "RPC_NT_SERVER_TOO_BUSY" },
{ 0xC0020019, "RPC_NT_INVALID_NETWORK_OPTIONS" },
{ 0xC002001A, "RPC_NT_NO_CALL_ACTIVE" },
{ 0xC002001B, "RPC_NT_CALL_FAILED" },
{ 0xC002001C, "RPC_NT_CALL_FAILED_DNE" },
{ 0xC002001D, "RPC_NT_PROTOCOL_ERROR" },
{ 0xC002001F, "RPC_NT_UNSUPPORTED_TRANS_SYN" },
{ 0xC0020021, "RPC_NT_UNSUPPORTED_TYPE" },
{ 0xC0020022, "RPC_NT_INVALID_TAG" },
{ 0xC0020023, "RPC_NT_INVALID_BOUND" },
{ 0xC0020024, "RPC_NT_NO_ENTRY_NAME" },
{ 0xC0020025, "RPC_NT_INVALID_NAME_SYNTAX" },
{ 0xC0020026, "RPC_NT_UNSUPPORTED_NAME_SYNTAX" },
{ 0xC0020028, "RPC_NT_UUID_NO_ADDRESS" },
{ 0xC0020029, "RPC_NT_DUPLICATE_ENDPOINT" },
{ 0xC002002A, "RPC_NT_UNKNOWN_AUTHN_TYPE" },
{ 0xC002002B, "RPC_NT_MAX_CALLS_TOO_SMALL" },
{ 0xC002002C, "RPC_NT_STRING_TOO_LONG" },
{ 0xC002002D, "RPC_NT_PROTSEQ_NOT_FOUND" },
{ 0xC002002E, "RPC_NT_PROCNUM_OUT_OF_RANGE" },
{ 0xC002002F, "RPC_NT_BINDING_HAS_NO_AUTH" },
{ 0xC0020030, "RPC_NT_UNKNOWN_AUTHN_SERVICE" },
{ 0xC0020031, "RPC_NT_UNKNOWN_AUTHN_LEVEL" },
{ 0xC0020032, "RPC_NT_INVALID_AUTH_IDENTITY" },
{ 0xC0020033, "RPC_NT_UNKNOWN_AUTHZ_SERVICE" },
{ 0xC0020034, "EPT_NT_INVALID_ENTRY" },
{ 0xC0020035, "EPT_NT_CANT_PERFORM_OP" },
{ 0xC0020036, "EPT_NT_NOT_REGISTERED" },
{ 0xC0020037, "RPC_NT_NOTHING_TO_EXPORT" },
{ 0xC0020038, "RPC_NT_INCOMPLETE_NAME" },
{ 0xC0020039, "RPC_NT_INVALID_VERS_OPTION" },
{ 0xC002003A, "RPC_NT_NO_MORE_MEMBERS" },
{ 0xC002003B, "RPC_NT_NOT_ALL_OBJS_UNEXPORTED" },
{ 0xC002003C, "RPC_NT_INTERFACE_NOT_FOUND" },
{ 0xC002003D, "RPC_NT_ENTRY_ALREADY_EXISTS" },
{ 0xC002003E, "RPC_NT_ENTRY_NOT_FOUND" },
{ 0xC002003F, "RPC_NT_NAME_SERVICE_UNAVAILABLE" },
{ 0xC0020040, "RPC_NT_INVALID_NAF_ID" },
{ 0xC0020041, "RPC_NT_CANNOT_SUPPORT" },
{ 0xC0020042, "RPC_NT_NO_CONTEXT_AVAILABLE" },
{ 0xC0020043, "RPC_NT_INTERNAL_ERROR" },
{ 0xC0020044, "RPC_NT_ZERO_DIVIDE" },
{ 0xC0020045, "RPC_NT_ADDRESS_ERROR" },
{ 0xC0020046, "RPC_NT_FP_DIV_ZERO" },
{ 0xC0020047, "RPC_NT_FP_UNDERFLOW" },
{ 0xC0020048, "RPC_NT_FP_OVERFLOW" },
{ 0xC0020049, "RPC_NT_CALL_IN_PROGRESS" },
{ 0xC002004A, "RPC_NT_NO_MORE_BINDINGS" },
{ 0xC002004B, "RPC_NT_GROUP_MEMBER_NOT_FOUND" },
{ 0xC002004C, "EPT_NT_CANT_CREATE" },
{ 0xC002004D, "RPC_NT_INVALID_OBJECT" },
{ 0xC002004F, "RPC_NT_NO_INTERFACES" },
{ 0xC0020050, "RPC_NT_CALL_CANCELLED" },
{ 0xC0020051, "RPC_NT_BINDING_INCOMPLETE" },
{ 0xC0020052, "RPC_NT_COMM_FAILURE" },
{ 0xC0020053, "RPC_NT_UNSUPPORTED_AUTHN_LEVEL" },
{ 0xC0020054, "RPC_NT_NO_PRINC_NAME" },
{ 0xC0020055, "RPC_NT_NOT_RPC_ERROR" },
{ 0xC0020057, "RPC_NT_SEC_PKG_ERROR" },
{ 0xC0020058, "RPC_NT_NOT_CANCELLED" },
{ 0xC0020062, "RPC_NT_INVALID_ASYNC_HANDLE" },
{ 0xC0020063, "RPC_NT_INVALID_ASYNC_CALL" },
{ 0xC0020064, "RPC_NT_PROXY_ACCESS_DENIED" },
{ 0xC0020065, "RPC_NT_COOKIE_AUTH_FAILED" },
{ 0xC0030001, "RPC_NT_NO_MORE_ENTRIES" },
{ 0xC0030002, "RPC_NT_SS_CHAR_TRANS_OPEN_FAIL" },
{ 0xC0030003, "RPC_NT_SS_CHAR_TRANS_SHORT_FILE" },
{ 0xC0030004, "RPC_NT_SS_IN_NULL_CONTEXT" },
{ 0xC0030005, "RPC_NT_SS_CONTEXT_MISMATCH" },
{ 0xC0030006, "RPC_NT_SS_CONTEXT_DAMAGED" },
{ 0xC0030007, "RPC_NT_SS_HANDLES_MISMATCH" },
{ 0xC0030008, "RPC_NT_SS_CANNOT_GET_CALL_HANDLE" },
{ 0xC0030009, "RPC_NT_NULL_REF_POINTER" },
{ 0xC003000A, "RPC_NT_ENUM_VALUE_OUT_OF_RANGE" },
{ 0xC003000B, "RPC_NT_BYTE_COUNT_TOO_SMALL" },
{ 0xC003000C, "RPC_NT_BAD_STUB_DATA" },
{ 0xC0030059, "RPC_NT_INVALID_ES_ACTION" },
{ 0xC003005A, "RPC_NT_WRONG_ES_VERSION" },
{ 0xC003005B, "RPC_NT_WRONG_STUB_VERSION" },
{ 0xC003005C, "RPC_NT_INVALID_PIPE_OBJECT" },
{ 0xC003005D, "RPC_NT_INVALID_PIPE_OPERATION" },
{ 0xC003005E, "RPC_NT_WRONG_PIPE_VERSION" },
{ 0xC003005F, "RPC_NT_PIPE_CLOSED" },
{ 0xC0030060, "RPC_NT_PIPE_DISCIPLINE_ERROR" },
{ 0xC0030061, "RPC_NT_PIPE_EMPTY" },
{ 0xC0040035, "STATUS_PNP_BAD_MPS_TABLE" },
{ 0xC0040036, "STATUS_PNP_TRANSLATION_FAILED" },
{ 0xC0040037, "STATUS_PNP_IRQ_TRANSLATION_FAILED" },
{ 0xC0040038, "STATUS_PNP_INVALID_ID" },
{ 0xC0040039, "STATUS_IO_REISSUE_AS_CACHED" },
{ 0xC00A0001, "STATUS_CTX_WINSTATION_NAME_INVALID" },
{ 0xC00A0002, "STATUS_CTX_INVALID_PD" },
{ 0xC00A0003, "STATUS_CTX_PD_NOT_FOUND" },
{ 0xC00A0006, "STATUS_CTX_CLOSE_PENDING" },
{ 0xC00A0007, "STATUS_CTX_NO_OUTBUF" },
{ 0xC00A0008, "STATUS_CTX_MODEM_INF_NOT_FOUND" },
{ 0xC00A0009, "STATUS_CTX_INVALID_MODEMNAME" },
{ 0xC00A000A, "STATUS_CTX_RESPONSE_ERROR" },
{ 0xC00A000B, "STATUS_CTX_MODEM_RESPONSE_TIMEOUT" },
{ 0xC00A000C, "STATUS_CTX_MODEM_RESPONSE_NO_CARRIER" },
{ 0xC00A000D, "STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE" },
{ 0xC00A000E, "STATUS_CTX_MODEM_RESPONSE_BUSY" },
{ 0xC00A000F, "STATUS_CTX_MODEM_RESPONSE_VOICE" },
{ 0xC00A0010, "STATUS_CTX_TD_ERROR" },
{ 0xC00A0012, "STATUS_CTX_LICENSE_CLIENT_INVALID" },
{ 0xC00A0013, "STATUS_CTX_LICENSE_NOT_AVAILABLE" },
{ 0xC00A0014, "STATUS_CTX_LICENSE_EXPIRED" },
{ 0xC00A0015, "STATUS_CTX_WINSTATION_NOT_FOUND" },
{ 0xC00A0016, "STATUS_CTX_WINSTATION_NAME_COLLISION" },
{ 0xC00A0017, "STATUS_CTX_WINSTATION_BUSY" },
{ 0xC00A0018, "STATUS_CTX_BAD_VIDEO_MODE" },
{ 0xC00A0022, "STATUS_CTX_GRAPHICS_INVALID" },
{ 0xC00A0024, "STATUS_CTX_NOT_CONSOLE" },
{ 0xC00A0026, "STATUS_CTX_CLIENT_QUERY_TIMEOUT" },
{ 0xC00A0027, "STATUS_CTX_CONSOLE_DISCONNECT" },
{ 0xC00A0028, "STATUS_CTX_CONSOLE_CONNECT" },
{ 0xC00A002A, "STATUS_CTX_SHADOW_DENIED" },
{ 0xC00A002B, "STATUS_CTX_WINSTATION_ACCESS_DENIED" },
{ 0xC00A002E, "STATUS_CTX_INVALID_WD" },
{ 0xC00A002F, "STATUS_CTX_WD_NOT_FOUND" },
{ 0xC00A0030, "STATUS_CTX_SHADOW_INVALID" },
{ 0xC00A0031, "STATUS_CTX_SHADOW_DISABLED" },
{ 0xC00A0032, "STATUS_RDP_PROTOCOL_ERROR" },
{ 0xC00A0033, "STATUS_CTX_CLIENT_LICENSE_NOT_SET" },
{ 0xC00A0034, "STATUS_CTX_CLIENT_LICENSE_IN_USE" },
{ 0xC00A0035, "STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE" },
{ 0xC00A0036, "STATUS_CTX_SHADOW_NOT_RUNNING" },
{ 0xC00A0037, "STATUS_CTX_LOGON_DISABLED" },
{ 0xC00A0038, "STATUS_CTX_SECURITY_LAYER_ERROR" },
{ 0xC00A0039, "STATUS_TS_INCOMPATIBLE_SESSIONS" },
{ 0xC00A003A, "STATUS_TS_VIDEO_SUBSYSTEM_ERROR" },
{ 0xC00B0001, "STATUS_MUI_FILE_NOT_FOUND" },
{ 0xC00B0002, "STATUS_MUI_INVALID_FILE" },
{ 0xC00B0003, "STATUS_MUI_INVALID_RC_CONFIG" },
{ 0xC00B0004, "STATUS_MUI_INVALID_LOCALE_NAME" },
{ 0xC00B0005, "STATUS_MUI_INVALID_ULTIMATEFALLBACK_NAME" },
{ 0xC00B0006, "STATUS_MUI_FILE_NOT_LOADED" },
{ 0xC00B0007, "STATUS_RESOURCE_ENUM_USER_STOP" },
{ 0xC0130001, "STATUS_CLUSTER_INVALID_NODE" },
{ 0xC0130002, "STATUS_CLUSTER_NODE_EXISTS" },
{ 0xC0130003, "STATUS_CLUSTER_JOIN_IN_PROGRESS" },
{ 0xC0130004, "STATUS_CLUSTER_NODE_NOT_FOUND" },
{ 0xC0130005, "STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND" },
{ 0xC0130006, "STATUS_CLUSTER_NETWORK_EXISTS" },
{ 0xC0130007, "STATUS_CLUSTER_NETWORK_NOT_FOUND" },
{ 0xC0130008, "STATUS_CLUSTER_NETINTERFACE_EXISTS" },
{ 0xC0130009, "STATUS_CLUSTER_NETINTERFACE_NOT_FOUND" },
{ 0xC013000A, "STATUS_CLUSTER_INVALID_REQUEST" },
{ 0xC013000B, "STATUS_CLUSTER_INVALID_NETWORK_PROVIDER" },
{ 0xC013000C, "STATUS_CLUSTER_NODE_DOWN" },
{ 0xC013000D, "STATUS_CLUSTER_NODE_UNREACHABLE" },
{ 0xC013000E, "STATUS_CLUSTER_NODE_NOT_MEMBER" },
{ 0xC013000F, "STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS" },
{ 0xC0130010, "STATUS_CLUSTER_INVALID_NETWORK" },
{ 0xC0130011, "STATUS_CLUSTER_NO_NET_ADAPTERS" },
{ 0xC0130012, "STATUS_CLUSTER_NODE_UP" },
{ 0xC0130013, "STATUS_CLUSTER_NODE_PAUSED" },
{ 0xC0130014, "STATUS_CLUSTER_NODE_NOT_PAUSED" },
{ 0xC0130015, "STATUS_CLUSTER_NO_SECURITY_CONTEXT" },
{ 0xC0130016, "STATUS_CLUSTER_NETWORK_NOT_INTERNAL" },
{ 0xC0130017, "STATUS_CLUSTER_POISONED" },
{ 0xC0130018, "STATUS_CLUSTER_NON_CSV_PATH" },
{ 0xC0130019, "STATUS_CLUSTER_CSV_VOLUME_NOT_LOCAL" },
{ 0xC0130020, "STATUS_CLUSTER_CSV_READ_OPLOCK_BREAK_IN_PROGRESS" },
{ 0xC0130021, "STATUS_CLUSTER_CSV_AUTO_PAUSE_ERROR" },
{ 0xC0130022, "STATUS_CLUSTER_CSV_REDIRECTED" },
{ 0xC0130023, "STATUS_CLUSTER_CSV_NOT_REDIRECTED" },
{ 0xC0130024, "STATUS_CLUSTER_CSV_VOLUME_DRAINING" },
{ 0xC0130025, "STATUS_CLUSTER_CSV_SNAPSHOT_CREATION_IN_PROGRESS" },
{ 0xC0130026, "STATUS_CLUSTER_CSV_VOLUME_DRAINING_SUCCEEDED_DOWNLEVEL" },
{ 0xC0130027, "STATUS_CLUSTER_CSV_NO_SNAPSHOTS" },
{ 0xC0130028, "STATUS_CSV_IO_PAUSE_TIMEOUT" },
{ 0xC0130029, "STATUS_CLUSTER_CSV_INVALID_HANDLE" },
{ 0xC0130030, "STATUS_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR" },
{ 0xC0130031, "STATUS_CLUSTER_CAM_TICKET_REPLAY_DETECTED" },
{ 0xC0140001, "STATUS_ACPI_INVALID_OPCODE" },
{ 0xC0140002, "STATUS_ACPI_STACK_OVERFLOW" },
{ 0xC0140003, "STATUS_ACPI_ASSERT_FAILED" },
{ 0xC0140004, "STATUS_ACPI_INVALID_INDEX" },
{ 0xC0140005, "STATUS_ACPI_INVALID_ARGUMENT" },
{ 0xC0140006, "STATUS_ACPI_FATAL" },
{ 0xC0140007, "STATUS_ACPI_INVALID_SUPERNAME" },
{ 0xC0140008, "STATUS_ACPI_INVALID_ARGTYPE" },
{ 0xC0140009, "STATUS_ACPI_INVALID_OBJTYPE" },
{ 0xC014000A, "STATUS_ACPI_INVALID_TARGETTYPE" },
{ 0xC014000B, "STATUS_ACPI_INCORRECT_ARGUMENT_COUNT" },
{ 0xC014000C, "STATUS_ACPI_ADDRESS_NOT_MAPPED" },
{ 0xC014000D, "STATUS_ACPI_INVALID_EVENTTYPE" },
{ 0xC014000E, "STATUS_ACPI_HANDLER_COLLISION" },
{ 0xC014000F, "STATUS_ACPI_INVALID_DATA" },
{ 0xC0140010, "STATUS_ACPI_INVALID_REGION" },
{ 0xC0140011, "STATUS_ACPI_INVALID_ACCESS_SIZE" },
{ 0xC0140012, "STATUS_ACPI_ACQUIRE_GLOBAL_LOCK" },
{ 0xC0140013, "STATUS_ACPI_ALREADY_INITIALIZED" },
{ 0xC0140014, "STATUS_ACPI_NOT_INITIALIZED" },
{ 0xC0140015, "STATUS_ACPI_INVALID_MUTEX_LEVEL" },
{ 0xC0140016, "STATUS_ACPI_MUTEX_NOT_OWNED" },
{ 0xC0140017, "STATUS_ACPI_MUTEX_NOT_OWNER" },
{ 0xC0140018, "STATUS_ACPI_RS_ACCESS" },
{ 0xC0140019, "STATUS_ACPI_INVALID_TABLE" },
{ 0xC0140020, "STATUS_ACPI_REG_HANDLER_FAILED" },
{ 0xC0140021, "STATUS_ACPI_POWER_REQUEST_FAILED" },
{ 0xC0150001, "STATUS_SXS_SECTION_NOT_FOUND" },
{ 0xC0150002, "STATUS_SXS_CANT_GEN_ACTCTX" },
{ 0xC0150003, "STATUS_SXS_INVALID_ACTCTXDATA_FORMAT" },
{ 0xC0150004, "STATUS_SXS_ASSEMBLY_NOT_FOUND" },
{ 0xC0150005, "STATUS_SXS_MANIFEST_FORMAT_ERROR" },
{ 0xC0150006, "STATUS_SXS_MANIFEST_PARSE_ERROR" },
{ 0xC0150007, "STATUS_SXS_ACTIVATION_CONTEXT_DISABLED" },
{ 0xC0150008, "STATUS_SXS_KEY_NOT_FOUND" },
{ 0xC0150009, "STATUS_SXS_VERSION_CONFLICT" },
{ 0xC015000A, "STATUS_SXS_WRONG_SECTION_TYPE" },
{ 0xC015000B, "STATUS_SXS_THREAD_QUERIES_DISABLED" },
{ 0xC015000C, "STATUS_SXS_ASSEMBLY_MISSING" },
{ 0xC015000E, "STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET" },
{ 0xC015000F, "STATUS_SXS_EARLY_DEACTIVATION" },
{ 0xC0150010, "STATUS_SXS_INVALID_DEACTIVATION" },
{ 0xC0150011, "STATUS_SXS_MULTIPLE_DEACTIVATION" },
{ 0xC0150012, "STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY" },
{ 0xC0150013, "STATUS_SXS_PROCESS_TERMINATION_REQUESTED" },
{ 0xC0150014, "STATUS_SXS_CORRUPT_ACTIVATION_STACK" },
{ 0xC0150015, "STATUS_SXS_CORRUPTION" },
{ 0xC0150016, "STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE" },
{ 0xC0150017, "STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME" },
{ 0xC0150018, "STATUS_SXS_IDENTITY_DUPLICATE_ATTRIBUTE" },
{ 0xC0150019, "STATUS_SXS_IDENTITY_PARSE_ERROR" },
{ 0xC015001A, "STATUS_SXS_COMPONENT_STORE_CORRUPT" },
{ 0xC015001B, "STATUS_SXS_FILE_HASH_MISMATCH" },
{ 0xC015001C, "STATUS_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT" },
{ 0xC015001D, "STATUS_SXS_IDENTITIES_DIFFERENT" },
{ 0xC015001E, "STATUS_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT" },
{ 0xC015001F, "STATUS_SXS_FILE_NOT_PART_OF_ASSEMBLY" },
{ 0xC0150020, "STATUS_ADVANCED_INSTALLER_FAILED" },
{ 0xC0150021, "STATUS_XML_ENCODING_MISMATCH" },
{ 0xC0150022, "STATUS_SXS_MANIFEST_TOO_BIG" },
{ 0xC0150023, "STATUS_SXS_SETTING_NOT_REGISTERED" },
{ 0xC0150024, "STATUS_SXS_TRANSACTION_CLOSURE_INCOMPLETE" },
{ 0xC0150025, "STATUS_SMI_PRIMITIVE_INSTALLER_FAILED" },
{ 0xC0150026, "STATUS_GENERIC_COMMAND_FAILED" },
{ 0xC0150027, "STATUS_SXS_FILE_HASH_MISSING" },
{ 0xC0190001, "STATUS_TRANSACTIONAL_CONFLICT" },
{ 0xC0190002, "STATUS_INVALID_TRANSACTION" },
{ 0xC0190003, "STATUS_TRANSACTION_NOT_ACTIVE" },
{ 0xC0190004, "STATUS_TM_INITIALIZATION_FAILED" },
{ 0xC0190005, "STATUS_RM_NOT_ACTIVE" },
{ 0xC0190006, "STATUS_RM_METADATA_CORRUPT" },
{ 0xC0190007, "STATUS_TRANSACTION_NOT_JOINED" },
{ 0xC0190008, "STATUS_DIRECTORY_NOT_RM" },
{ 0xC019000A, "STATUS_TRANSACTIONS_UNSUPPORTED_REMOTE" },
{ 0xC019000B, "STATUS_LOG_RESIZE_INVALID_SIZE" },
{ 0xC019000C, "STATUS_REMOTE_FILE_VERSION_MISMATCH" },
{ 0xC019000F, "STATUS_CRM_PROTOCOL_ALREADY_EXISTS" },
{ 0xC0190010, "STATUS_TRANSACTION_PROPAGATION_FAILED" },
{ 0xC0190011, "STATUS_CRM_PROTOCOL_NOT_FOUND" },
{ 0xC0190012, "STATUS_TRANSACTION_SUPERIOR_EXISTS" },
{ 0xC0190013, "STATUS_TRANSACTION_REQUEST_NOT_VALID" },
{ 0xC0190014, "STATUS_TRANSACTION_NOT_REQUESTED" },
{ 0xC0190015, "STATUS_TRANSACTION_ALREADY_ABORTED" },
{ 0xC0190016, "STATUS_TRANSACTION_ALREADY_COMMITTED" },
{ 0xC0190017, "STATUS_TRANSACTION_INVALID_MARSHALL_BUFFER" },
{ 0xC0190018, "STATUS_CURRENT_TRANSACTION_NOT_VALID" },
{ 0xC0190019, "STATUS_LOG_GROWTH_FAILED" },
{ 0xC0190021, "STATUS_OBJECT_NO_LONGER_EXISTS" },
{ 0xC0190022, "STATUS_STREAM_MINIVERSION_NOT_FOUND" },
{ 0xC0190023, "STATUS_STREAM_MINIVERSION_NOT_VALID" },
{ 0xC0190024, "STATUS_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION" },
{ 0xC0190025, "STATUS_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT" },
{ 0xC0190026, "STATUS_CANT_CREATE_MORE_STREAM_MINIVERSIONS" },
{ 0xC0190028, "STATUS_HANDLE_NO_LONGER_VALID" },
{ 0xC0190030, "STATUS_LOG_CORRUPTION_DETECTED" },
{ 0xC0190032, "STATUS_RM_DISCONNECTED" },
{ 0xC0190033, "STATUS_ENLISTMENT_NOT_SUPERIOR" },
{ 0xC0190036, "STATUS_FILE_IDENTITY_NOT_PERSISTENT" },
{ 0xC0190037, "STATUS_CANT_BREAK_TRANSACTIONAL_DEPENDENCY" },
{ 0xC0190038, "STATUS_CANT_CROSS_RM_BOUNDARY" },
{ 0xC0190039, "STATUS_TXF_DIR_NOT_EMPTY" },
{ 0xC019003A, "STATUS_INDOUBT_TRANSACTIONS_EXIST" },
{ 0xC019003B, "STATUS_TM_VOLATILE" },
{ 0xC019003C, "STATUS_ROLLBACK_TIMER_EXPIRED" },
{ 0xC019003D, "STATUS_TXF_ATTRIBUTE_CORRUPT" },
{ 0xC019003E, "STATUS_EFS_NOT_ALLOWED_IN_TRANSACTION" },
{ 0xC019003F, "STATUS_TRANSACTIONAL_OPEN_NOT_ALLOWED" },
{ 0xC0190040, "STATUS_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE" },
{ 0xC0190043, "STATUS_TRANSACTION_REQUIRED_PROMOTION" },
{ 0xC0190044, "STATUS_CANNOT_EXECUTE_FILE_IN_TRANSACTION" },
{ 0xC0190045, "STATUS_TRANSACTIONS_NOT_FROZEN" },
{ 0xC0190046, "STATUS_TRANSACTION_FREEZE_IN_PROGRESS" },
{ 0xC0190047, "STATUS_NOT_SNAPSHOT_VOLUME" },
{ 0xC0190048, "STATUS_NO_SAVEPOINT_WITH_OPEN_FILES" },
{ 0xC0190049, "STATUS_SPARSE_NOT_ALLOWED_IN_TRANSACTION" },
{ 0xC019004A, "STATUS_TM_IDENTITY_MISMATCH" },
{ 0xC019004B, "STATUS_FLOATED_SECTION" },
{ 0xC019004C, "STATUS_CANNOT_ACCEPT_TRANSACTED_WORK" },
{ 0xC019004D, "STATUS_CANNOT_ABORT_TRANSACTIONS" },
{ 0xC019004E, "STATUS_TRANSACTION_NOT_FOUND" },
{ 0xC019004F, "STATUS_RESOURCEMANAGER_NOT_FOUND" },
{ 0xC0190050, "STATUS_ENLISTMENT_NOT_FOUND" },
{ 0xC0190051, "STATUS_TRANSACTIONMANAGER_NOT_FOUND" },
{ 0xC0190052, "STATUS_TRANSACTIONMANAGER_NOT_ONLINE" },
{ 0xC0190053, "STATUS_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION" },
{ 0xC0190054, "STATUS_TRANSACTION_NOT_ROOT" },
{ 0xC0190055, "STATUS_TRANSACTION_OBJECT_EXPIRED" },
{ 0xC0190056, "STATUS_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION" },
{ 0xC0190057, "STATUS_TRANSACTION_RESPONSE_NOT_ENLISTED" },
{ 0xC0190058, "STATUS_TRANSACTION_RECORD_TOO_LONG" },
{ 0xC0190059, "STATUS_NO_LINK_TRACKING_IN_TRANSACTION" },
{ 0xC019005A, "STATUS_OPERATION_NOT_SUPPORTED_IN_TRANSACTION" },
{ 0xC019005B, "STATUS_TRANSACTION_INTEGRITY_VIOLATED" },
{ 0xC019005C, "STATUS_TRANSACTIONMANAGER_IDENTITY_MISMATCH" },
{ 0xC019005D, "STATUS_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT" },
{ 0xC019005E, "STATUS_TRANSACTION_MUST_WRITETHROUGH" },
{ 0xC019005F, "STATUS_TRANSACTION_NO_SUPERIOR" },
{ 0xC0190060, "STATUS_EXPIRED_HANDLE" },
{ 0xC0190061, "STATUS_TRANSACTION_NOT_ENLISTED" },
{ 0xC01A0001, "STATUS_LOG_SECTOR_INVALID" },
{ 0xC01A0002, "STATUS_LOG_SECTOR_PARITY_INVALID" },
{ 0xC01A0003, "STATUS_LOG_SECTOR_REMAPPED" },
{ 0xC01A0004, "STATUS_LOG_BLOCK_INCOMPLETE" },
{ 0xC01A0005, "STATUS_LOG_INVALID_RANGE" },
{ 0xC01A0006, "STATUS_LOG_BLOCKS_EXHAUSTED" },
{ 0xC01A0007, "STATUS_LOG_READ_CONTEXT_INVALID" },
{ 0xC01A0008, "STATUS_LOG_RESTART_INVALID" },
{ 0xC01A0009, "STATUS_LOG_BLOCK_VERSION" },
{ 0xC01A000A, "STATUS_LOG_BLOCK_INVALID" },
{ 0xC01A000B, "STATUS_LOG_READ_MODE_INVALID" },
{ 0xC01A000D, "STATUS_LOG_METADATA_CORRUPT" },
{ 0xC01A000E, "STATUS_LOG_METADATA_INVALID" },
{ 0xC01A000F, "STATUS_LOG_METADATA_INCONSISTENT" },
{ 0xC01A0010, "STATUS_LOG_RESERVATION_INVALID" },
{ 0xC01A0011, "STATUS_LOG_CANT_DELETE" },
{ 0xC01A0012, "STATUS_LOG_CONTAINER_LIMIT_EXCEEDED" },
{ 0xC01A0013, "STATUS_LOG_START_OF_LOG" },
{ 0xC01A0014, "STATUS_LOG_POLICY_ALREADY_INSTALLED" },
{ 0xC01A0015, "STATUS_LOG_POLICY_NOT_INSTALLED" },
{ 0xC01A0016, "STATUS_LOG_POLICY_INVALID" },
{ 0xC01A0017, "STATUS_LOG_POLICY_CONFLICT" },
{ 0xC01A0018, "STATUS_LOG_PINNED_ARCHIVE_TAIL" },
{ 0xC01A0019, "STATUS_LOG_RECORD_NONEXISTENT" },
{ 0xC01A001A, "STATUS_LOG_RECORDS_RESERVED_INVALID" },
{ 0xC01A001B, "STATUS_LOG_SPACE_RESERVED_INVALID" },
{ 0xC01A001C, "STATUS_LOG_TAIL_INVALID" },
{ 0xC01A001D, "STATUS_LOG_FULL" },
{ 0xC01A001E, "STATUS_LOG_MULTIPLEXED" },
{ 0xC01A001F, "STATUS_LOG_DEDICATED" },
{ 0xC01A0020, "STATUS_LOG_ARCHIVE_NOT_IN_PROGRESS" },
{ 0xC01A0021, "STATUS_LOG_ARCHIVE_IN_PROGRESS" },
{ 0xC01A0022, "STATUS_LOG_EPHEMERAL" },
{ 0xC01A0023, "STATUS_LOG_NOT_ENOUGH_CONTAINERS" },
{ 0xC01A0024, "STATUS_LOG_CLIENT_ALREADY_REGISTERED" },
{ 0xC01A0025, "STATUS_LOG_CLIENT_NOT_REGISTERED" },
{ 0xC01A0026, "STATUS_LOG_FULL_HANDLER_IN_PROGRESS" },
{ 0xC01A0027, "STATUS_LOG_CONTAINER_READ_FAILED" },
{ 0xC01A0028, "STATUS_LOG_CONTAINER_WRITE_FAILED" },
{ 0xC01A0029, "STATUS_LOG_CONTAINER_OPEN_FAILED" },
{ 0xC01A002A, "STATUS_LOG_CONTAINER_STATE_INVALID" },
{ 0xC01A002B, "STATUS_LOG_STATE_INVALID" },
{ 0xC01A002C, "STATUS_LOG_PINNED" },
{ 0xC01A002D, "STATUS_LOG_METADATA_FLUSH_FAILED" },
{ 0xC01A002E, "STATUS_LOG_INCONSISTENT_SECURITY" },
{ 0xC01A002F, "STATUS_LOG_APPENDED_FLUSH_FAILED" },
{ 0xC01A0030, "STATUS_LOG_PINNED_RESERVATION" },
{ 0xC01B00EA, "STATUS_VIDEO_HUNG_DISPLAY_DRIVER_THREAD" },
{ 0xC01C0001, "STATUS_FLT_NO_HANDLER_DEFINED" },
{ 0xC01C0002, "STATUS_FLT_CONTEXT_ALREADY_DEFINED" },
{ 0xC01C0003, "STATUS_FLT_INVALID_ASYNCHRONOUS_REQUEST" },
{ 0xC01C0004, "STATUS_FLT_DISALLOW_FAST_IO" },
{ 0xC01C0005, "STATUS_FLT_INVALID_NAME_REQUEST" },
{ 0xC01C0006, "STATUS_FLT_NOT_SAFE_TO_POST_OPERATION" },
{ 0xC01C0007, "STATUS_FLT_NOT_INITIALIZED" },
{ 0xC01C0008, "STATUS_FLT_FILTER_NOT_READY" },
{ 0xC01C0009, "STATUS_FLT_POST_OPERATION_CLEANUP" },
{ 0xC01C000A, "STATUS_FLT_INTERNAL_ERROR" },
{ 0xC01C000B, "STATUS_FLT_DELETING_OBJECT" },
{ 0xC01C000C, "STATUS_FLT_MUST_BE_NONPAGED_POOL" },
{ 0xC01C000D, "STATUS_FLT_DUPLICATE_ENTRY" },
{ 0xC01C000E, "STATUS_FLT_CBDQ_DISABLED" },
{ 0xC01C000F, "STATUS_FLT_DO_NOT_ATTACH" },
{ 0xC01C0010, "STATUS_FLT_DO_NOT_DETACH" },
{ 0xC01C0011, "STATUS_FLT_INSTANCE_ALTITUDE_COLLISION" },
{ 0xC01C0012, "STATUS_FLT_INSTANCE_NAME_COLLISION" },
{ 0xC01C0013, "STATUS_FLT_FILTER_NOT_FOUND" },
{ 0xC01C0014, "STATUS_FLT_VOLUME_NOT_FOUND" },
{ 0xC01C0015, "STATUS_FLT_INSTANCE_NOT_FOUND" },
{ 0xC01C0016, "STATUS_FLT_CONTEXT_ALLOCATION_NOT_FOUND" },
{ 0xC01C0017, "STATUS_FLT_INVALID_CONTEXT_REGISTRATION" },
{ 0xC01C0018, "STATUS_FLT_NAME_CACHE_MISS" },
{ 0xC01C0019, "STATUS_FLT_NO_DEVICE_OBJECT" },
{ 0xC01C001A, "STATUS_FLT_VOLUME_ALREADY_MOUNTED" },
{ 0xC01C001B, "STATUS_FLT_ALREADY_ENLISTED" },
{ 0xC01C001C, "STATUS_FLT_CONTEXT_ALREADY_LINKED" },
{ 0xC01C0020, "STATUS_FLT_NO_WAITER_FOR_REPLY" },
{ 0xC01C0023, "STATUS_FLT_REGISTRATION_BUSY" },
{ 0xC01D0001, "STATUS_MONITOR_NO_DESCRIPTOR" },
{ 0xC01D0002, "STATUS_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT" },
{ 0xC01D0003, "STATUS_MONITOR_INVALID_DESCRIPTOR_CHECKSUM" },
{ 0xC01D0004, "STATUS_MONITOR_INVALID_STANDARD_TIMING_BLOCK" },
{ 0xC01D0005, "STATUS_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED" },
{ 0xC01D0006, "STATUS_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK" },
{ 0xC01D0007, "STATUS_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK" },
{ 0xC01D0008, "STATUS_MONITOR_NO_MORE_DESCRIPTOR_DATA" },
{ 0xC01D0009, "STATUS_MONITOR_INVALID_DETAILED_TIMING_BLOCK" },
{ 0xC01D000A, "STATUS_MONITOR_INVALID_MANUFACTURE_DATE" },
{ 0xC01E0000, "STATUS_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER" },
{ 0xC01E0001, "STATUS_GRAPHICS_INSUFFICIENT_DMA_BUFFER" },
{ 0xC01E0002, "STATUS_GRAPHICS_INVALID_DISPLAY_ADAPTER" },
{ 0xC01E0003, "STATUS_GRAPHICS_ADAPTER_WAS_RESET" },
{ 0xC01E0004, "STATUS_GRAPHICS_INVALID_DRIVER_MODEL" },
{ 0xC01E0005, "STATUS_GRAPHICS_PRESENT_MODE_CHANGED" },
{ 0xC01E0006, "STATUS_GRAPHICS_PRESENT_OCCLUDED" },
{ 0xC01E0007, "STATUS_GRAPHICS_PRESENT_DENIED" },
{ 0xC01E0008, "STATUS_GRAPHICS_CANNOTCOLORCONVERT" },
{ 0xC01E0009, "STATUS_GRAPHICS_DRIVER_MISMATCH" },
{ 0xC01E000B, "STATUS_GRAPHICS_PRESENT_REDIRECTION_DISABLED" },
{ 0xC01E000C, "STATUS_GRAPHICS_PRESENT_UNOCCLUDED" },
{ 0xC01E000D, "STATUS_GRAPHICS_WINDOWDC_NOT_AVAILABLE" },
{ 0xC01E000E, "STATUS_GRAPHICS_WINDOWLESS_PRESENT_DISABLED" },
{ 0xC01E0100, "STATUS_GRAPHICS_NO_VIDEO_MEMORY" },
{ 0xC01E0101, "STATUS_GRAPHICS_CANT_LOCK_MEMORY" },
{ 0xC01E0102, "STATUS_GRAPHICS_ALLOCATION_BUSY" },
{ 0xC01E0103, "STATUS_GRAPHICS_TOO_MANY_REFERENCES" },
{ 0xC01E0104, "STATUS_GRAPHICS_TRY_AGAIN_LATER" },
{ 0xC01E0105, "STATUS_GRAPHICS_TRY_AGAIN_NOW" },
{ 0xC01E0106, "STATUS_GRAPHICS_ALLOCATION_INVALID" },
{ 0xC01E0107, "STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE" },
{ 0xC01E0108, "STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED" },
{ 0xC01E0109, "STATUS_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION" },
{ 0xC01E0110, "STATUS_GRAPHICS_INVALID_ALLOCATION_USAGE" },
{ 0xC01E0111, "STATUS_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION" },
{ 0xC01E0112, "STATUS_GRAPHICS_ALLOCATION_CLOSED" },
{ 0xC01E0113, "STATUS_GRAPHICS_INVALID_ALLOCATION_INSTANCE" },
{ 0xC01E0114, "STATUS_GRAPHICS_INVALID_ALLOCATION_HANDLE" },
{ 0xC01E0115, "STATUS_GRAPHICS_WRONG_ALLOCATION_DEVICE" },
{ 0xC01E0116, "STATUS_GRAPHICS_ALLOCATION_CONTENT_LOST" },
{ 0xC01E0200, "STATUS_GRAPHICS_GPU_EXCEPTION_ON_DEVICE" },
{ 0xC01E0300, "STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY" },
{ 0xC01E0301, "STATUS_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED" },
{ 0xC01E0302, "STATUS_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED" },
{ 0xC01E0303, "STATUS_GRAPHICS_INVALID_VIDPN" },
{ 0xC01E0304, "STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE" },
{ 0xC01E0305, "STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET" },
{ 0xC01E0306, "STATUS_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED" },
{ 0xC01E0308, "STATUS_GRAPHICS_INVALID_VIDPN_SOURCEMODESET" },
{ 0xC01E0309, "STATUS_GRAPHICS_INVALID_VIDPN_TARGETMODESET" },
{ 0xC01E030A, "STATUS_GRAPHICS_INVALID_FREQUENCY" },
{ 0xC01E030B, "STATUS_GRAPHICS_INVALID_ACTIVE_REGION" },
{ 0xC01E030C, "STATUS_GRAPHICS_INVALID_TOTAL_REGION" },
{ 0xC01E0310, "STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE" },
{ 0xC01E0311, "STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE" },
{ 0xC01E0312, "STATUS_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET" },
{ 0xC01E0313, "STATUS_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY" },
{ 0xC01E0314, "STATUS_GRAPHICS_MODE_ALREADY_IN_MODESET" },
{ 0xC01E0315, "STATUS_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET" },
{ 0xC01E0316, "STATUS_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET" },
{ 0xC01E0317, "STATUS_GRAPHICS_SOURCE_ALREADY_IN_SET" },
{ 0xC01E0318, "STATUS_GRAPHICS_TARGET_ALREADY_IN_SET" },
{ 0xC01E0319, "STATUS_GRAPHICS_INVALID_VIDPN_PRESENT_PATH" },
{ 0xC01E031A, "STATUS_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY" },
{ 0xC01E031B, "STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET" },
{ 0xC01E031C, "STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE" },
{ 0xC01E031D, "STATUS_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET" },
{ 0xC01E031F, "STATUS_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET" },
{ 0xC01E0320, "STATUS_GRAPHICS_STALE_MODESET" },
{ 0xC01E0321, "STATUS_GRAPHICS_INVALID_MONITOR_SOURCEMODESET" },
{ 0xC01E0322, "STATUS_GRAPHICS_INVALID_MONITOR_SOURCE_MODE" },
{ 0xC01E0323, "STATUS_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN" },
{ 0xC01E0324, "STATUS_GRAPHICS_MODE_ID_MUST_BE_UNIQUE" },
{ 0xC01E0325, "STATUS_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION" },
{ 0xC01E0326, "STATUS_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES" },
{ 0xC01E0327, "STATUS_GRAPHICS_PATH_NOT_IN_TOPOLOGY" },
{ 0xC01E0328, "STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE" },
{ 0xC01E0329, "STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET" },
{ 0xC01E032A, "STATUS_GRAPHICS_INVALID_MONITORDESCRIPTORSET" },
{ 0xC01E032B, "STATUS_GRAPHICS_INVALID_MONITORDESCRIPTOR" },
{ 0xC01E032C, "STATUS_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET" },
{ 0xC01E032D, "STATUS_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET" },
{ 0xC01E032E, "STATUS_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE" },
{ 0xC01E032F, "STATUS_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE" },
{ 0xC01E0330, "STATUS_GRAPHICS_RESOURCES_NOT_RELATED" },
{ 0xC01E0331, "STATUS_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE" },
{ 0xC01E0332, "STATUS_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE" },
{ 0xC01E0333, "STATUS_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET" },
{ 0xC01E0334, "STATUS_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER" },
{ 0xC01E0335, "STATUS_GRAPHICS_NO_VIDPNMGR" },
{ 0xC01E0336, "STATUS_GRAPHICS_NO_ACTIVE_VIDPN" },
{ 0xC01E0337, "STATUS_GRAPHICS_STALE_VIDPN_TOPOLOGY" },
{ 0xC01E0338, "STATUS_GRAPHICS_MONITOR_NOT_CONNECTED" },
{ 0xC01E0339, "STATUS_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY" },
{ 0xC01E033A, "STATUS_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE" },
{ 0xC01E033B, "STATUS_GRAPHICS_INVALID_VISIBLEREGION_SIZE" },
{ 0xC01E033C, "STATUS_GRAPHICS_INVALID_STRIDE" },
{ 0xC01E033D, "STATUS_GRAPHICS_INVALID_PIXELFORMAT" },
{ 0xC01E033E, "STATUS_GRAPHICS_INVALID_COLORBASIS" },
{ 0xC01E033F, "STATUS_GRAPHICS_INVALID_PIXELVALUEACCESSMODE" },
{ 0xC01E0340, "STATUS_GRAPHICS_TARGET_NOT_IN_TOPOLOGY" },
{ 0xC01E0341, "STATUS_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT" },
{ 0xC01E0342, "STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE" },
{ 0xC01E0343, "STATUS_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN" },
{ 0xC01E0344, "STATUS_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL" },
{ 0xC01E0345, "STATUS_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION" },
{ 0xC01E0346, "STATUS_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED" },
{ 0xC01E0347, "STATUS_GRAPHICS_INVALID_GAMMA_RAMP" },
{ 0xC01E0348, "STATUS_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED" },
{ 0xC01E0349, "STATUS_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED" },
{ 0xC01E034A, "STATUS_GRAPHICS_MODE_NOT_IN_MODESET" },
{ 0xC01E034D, "STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON" },
{ 0xC01E034E, "STATUS_GRAPHICS_INVALID_PATH_CONTENT_TYPE" },
{ 0xC01E034F, "STATUS_GRAPHICS_INVALID_COPYPROTECTION_TYPE" },
{ 0xC01E0350, "STATUS_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS" },
{ 0xC01E0352, "STATUS_GRAPHICS_INVALID_SCANLINE_ORDERING" },
{ 0xC01E0353, "STATUS_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED" },
{ 0xC01E0354, "STATUS_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS" },
{ 0xC01E0355, "STATUS_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT" },
{ 0xC01E0356, "STATUS_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM" },
{ 0xC01E0357, "STATUS_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN" },
{ 0xC01E0358, "STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT" },
{ 0xC01E0359, "STATUS_GRAPHICS_MAX_NUM_PATHS_REACHED" },
{ 0xC01E035A, "STATUS_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION" },
{ 0xC01E035B, "STATUS_GRAPHICS_INVALID_CLIENT_TYPE" },
{ 0xC01E035C, "STATUS_GRAPHICS_CLIENTVIDPN_NOT_SET" },
{ 0xC01E0400, "STATUS_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED" },
{ 0xC01E0401, "STATUS_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED" },
{ 0xC01E0430, "STATUS_GRAPHICS_NOT_A_LINKED_ADAPTER" },
{ 0xC01E0431, "STATUS_GRAPHICS_LEADLINK_NOT_ENUMERATED" },
{ 0xC01E0432, "STATUS_GRAPHICS_CHAINLINKS_NOT_ENUMERATED" },
{ 0xC01E0433, "STATUS_GRAPHICS_ADAPTER_CHAIN_NOT_READY" },
{ 0xC01E0434, "STATUS_GRAPHICS_CHAINLINKS_NOT_STARTED" },
{ 0xC01E0435, "STATUS_GRAPHICS_CHAINLINKS_NOT_POWERED_ON" },
{ 0xC01E0436, "STATUS_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE" },
{ 0xC01E0438, "STATUS_GRAPHICS_NOT_POST_DEVICE_DRIVER" },
{ 0xC01E043B, "STATUS_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED" },
{ 0xC01E0500, "STATUS_GRAPHICS_OPM_NOT_SUPPORTED" },
{ 0xC01E0501, "STATUS_GRAPHICS_COPP_NOT_SUPPORTED" },
{ 0xC01E0502, "STATUS_GRAPHICS_UAB_NOT_SUPPORTED" },
{ 0xC01E0503, "STATUS_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS" },
{ 0xC01E0505, "STATUS_GRAPHICS_OPM_NO_PROTECTED_OUTPUTS_EXIST" },
{ 0xC01E050B, "STATUS_GRAPHICS_OPM_INTERNAL_ERROR" },
{ 0xC01E050C, "STATUS_GRAPHICS_OPM_INVALID_HANDLE" },
{ 0xC01E050E, "STATUS_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH" },
{ 0xC01E050F, "STATUS_GRAPHICS_OPM_SPANNING_MODE_ENABLED" },
{ 0xC01E0510, "STATUS_GRAPHICS_OPM_THEATER_MODE_ENABLED" },
{ 0xC01E0511, "STATUS_GRAPHICS_PVP_HFS_FAILED" },
{ 0xC01E0512, "STATUS_GRAPHICS_OPM_INVALID_SRM" },
{ 0xC01E0513, "STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP" },
{ 0xC01E0514, "STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP" },
{ 0xC01E0515, "STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA" },
{ 0xC01E0516, "STATUS_GRAPHICS_OPM_HDCP_SRM_NEVER_SET" },
{ 0xC01E0517, "STATUS_GRAPHICS_OPM_RESOLUTION_TOO_HIGH" },
{ 0xC01E0518, "STATUS_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE" },
{ 0xC01E051A, "STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_NO_LONGER_EXISTS" },
{ 0xC01E051C, "STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS" },
{ 0xC01E051D, "STATUS_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST" },
{ 0xC01E051E, "STATUS_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR" },
{ 0xC01E051F, "STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS" },
{ 0xC01E0520, "STATUS_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED" },
{ 0xC01E0521, "STATUS_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST" },
{ 0xC01E0580, "STATUS_GRAPHICS_I2C_NOT_SUPPORTED" },
{ 0xC01E0581, "STATUS_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST" },
{ 0xC01E0582, "STATUS_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA" },
{ 0xC01E0583, "STATUS_GRAPHICS_I2C_ERROR_RECEIVING_DATA" },
{ 0xC01E0584, "STATUS_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED" },
{ 0xC01E0585, "STATUS_GRAPHICS_DDCCI_INVALID_DATA" },
{ 0xC01E0586, "STATUS_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE" },
{ 0xC01E0587, "STATUS_GRAPHICS_DDCCI_INVALID_CAPABILITIES_STRING" },
{ 0xC01E0588, "STATUS_GRAPHICS_MCA_INTERNAL_ERROR" },
{ 0xC01E0589, "STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND" },
{ 0xC01E058A, "STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH" },
{ 0xC01E058B, "STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM" },
{ 0xC01E058C, "STATUS_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE" },
{ 0xC01E058D, "STATUS_GRAPHICS_MONITOR_NO_LONGER_EXISTS" },
{ 0xC01E05E0, "STATUS_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED" },
{ 0xC01E05E1, "STATUS_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME" },
{ 0xC01E05E2, "STATUS_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP" },
{ 0xC01E05E3, "STATUS_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED" },
{ 0xC01E05E4, "STATUS_GRAPHICS_INVALID_POINTER" },
{ 0xC01E05E5, "STATUS_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE" },
{ 0xC01E05E6, "STATUS_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL" },
{ 0xC01E05E7, "STATUS_GRAPHICS_INTERNAL_ERROR" },
{ 0xC01E05E8, "STATUS_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS" },
{ 0xC0210000, "STATUS_FVE_LOCKED_VOLUME" },
{ 0xC0210001, "STATUS_FVE_NOT_ENCRYPTED" },
{ 0xC0210002, "STATUS_FVE_BAD_INFORMATION" },
{ 0xC0210003, "STATUS_FVE_TOO_SMALL" },
{ 0xC0210004, "STATUS_FVE_FAILED_WRONG_FS" },
{ 0xC0210005, "STATUS_FVE_BAD_PARTITION_SIZE" },
{ 0xC0210006, "STATUS_FVE_FS_NOT_EXTENDED" },
{ 0xC0210007, "STATUS_FVE_FS_MOUNTED" },
{ 0xC0210008, "STATUS_FVE_NO_LICENSE" },
{ 0xC0210009, "STATUS_FVE_ACTION_NOT_ALLOWED" },
{ 0xC021000A, "STATUS_FVE_BAD_DATA" },
{ 0xC021000B, "STATUS_FVE_VOLUME_NOT_BOUND" },
{ 0xC021000C, "STATUS_FVE_NOT_DATA_VOLUME" },
{ 0xC021000D, "STATUS_FVE_CONV_READ_ERROR" },
{ 0xC021000E, "STATUS_FVE_CONV_WRITE_ERROR" },
{ 0xC021000F, "STATUS_FVE_OVERLAPPED_UPDATE" },
{ 0xC0210010, "STATUS_FVE_FAILED_SECTOR_SIZE" },
{ 0xC0210011, "STATUS_FVE_FAILED_AUTHENTICATION" },
{ 0xC0210012, "STATUS_FVE_NOT_OS_VOLUME" },
{ 0xC0210013, "STATUS_FVE_KEYFILE_NOT_FOUND" },
{ 0xC0210014, "STATUS_FVE_KEYFILE_INVALID" },
{ 0xC0210015, "STATUS_FVE_KEYFILE_NO_VMK" },
{ 0xC0210016, "STATUS_FVE_TPM_DISABLED" },
{ 0xC0210017, "STATUS_FVE_TPM_SRK_AUTH_NOT_ZERO" },
{ 0xC0210018, "STATUS_FVE_TPM_INVALID_PCR" },
{ 0xC0210019, "STATUS_FVE_TPM_NO_VMK" },
{ 0xC021001A, "STATUS_FVE_PIN_INVALID" },
{ 0xC021001B, "STATUS_FVE_AUTH_INVALID_APPLICATION" },
{ 0xC021001C, "STATUS_FVE_AUTH_INVALID_CONFIG" },
{ 0xC021001D, "STATUS_FVE_DEBUGGER_ENABLED" },
{ 0xC021001E, "STATUS_FVE_DRY_RUN_FAILED" },
{ 0xC021001F, "STATUS_FVE_BAD_METADATA_POINTER" },
{ 0xC0210020, "STATUS_FVE_OLD_METADATA_COPY" },
{ 0xC0210021, "STATUS_FVE_REBOOT_REQUIRED" },
{ 0xC0210022, "STATUS_FVE_RAW_ACCESS" },
{ 0xC0210023, "STATUS_FVE_RAW_BLOCKED" },
{ 0xC0210024, "STATUS_FVE_NO_AUTOUNLOCK_MASTER_KEY" },
{ 0xC0210025, "STATUS_FVE_MOR_FAILED" },
{ 0xC0210026, "STATUS_FVE_NO_FEATURE_LICENSE" },
{ 0xC0210027, "STATUS_FVE_POLICY_USER_DISABLE_RDV_NOT_ALLOWED" },
{ 0xC0210028, "STATUS_FVE_CONV_RECOVERY_FAILED" },
{ 0xC0210029, "STATUS_FVE_VIRTUALIZED_SPACE_TOO_BIG" },
{ 0xC021002A, "STATUS_FVE_INVALID_DATUM_TYPE" },
{ 0xC0210030, "STATUS_FVE_VOLUME_TOO_SMALL" },
{ 0xC0210031, "STATUS_FVE_ENH_PIN_INVALID" },
{ 0xC0210032, "STATUS_FVE_FULL_ENCRYPTION_NOT_ALLOWED_ON_TP_STORAGE" },
{ 0xC0210033, "STATUS_FVE_WIPE_NOT_ALLOWED_ON_TP_STORAGE" },
{ 0xC0210034, "STATUS_FVE_NOT_ALLOWED_ON_CSV_STACK" },
{ 0xC0210035, "STATUS_FVE_NOT_ALLOWED_ON_CLUSTER" },
{ 0xC0210036, "STATUS_FVE_NOT_ALLOWED_TO_UPGRADE_WHILE_CONVERTING" },
{ 0xC0210037, "STATUS_FVE_WIPE_CANCEL_NOT_APPLICABLE" },
{ 0xC0210038, "STATUS_FVE_EDRIVE_DRY_RUN_FAILED" },
{ 0xC0210039, "STATUS_FVE_SECUREBOOT_DISABLED" },
{ 0xC021003A, "STATUS_FVE_SECUREBOOT_CONFIG_CHANGE" },
{ 0xC021003B, "STATUS_FVE_DEVICE_LOCKEDOUT" },
{ 0xC021003C, "STATUS_FVE_VOLUME_EXTEND_PREVENTS_EOW_DECRYPT" },
{ 0xC021003D, "STATUS_FVE_NOT_DE_VOLUME" },
{ 0xC021003E, "STATUS_FVE_PROTECTION_DISABLED" },
{ 0xC021003F, "STATUS_FVE_PROTECTION_CANNOT_BE_DISABLED" },
{ 0xC0210040, "STATUS_FVE_OSV_KSR_NOT_ALLOWED" },
{ 0xC0220001, "STATUS_FWP_CALLOUT_NOT_FOUND" },
{ 0xC0220002, "STATUS_FWP_CONDITION_NOT_FOUND" },
{ 0xC0220003, "STATUS_FWP_FILTER_NOT_FOUND" },
{ 0xC0220004, "STATUS_FWP_LAYER_NOT_FOUND" },
{ 0xC0220005, "STATUS_FWP_PROVIDER_NOT_FOUND" },
{ 0xC0220006, "STATUS_FWP_PROVIDER_CONTEXT_NOT_FOUND" },
{ 0xC0220007, "STATUS_FWP_SUBLAYER_NOT_FOUND" },
{ 0xC0220008, "STATUS_FWP_NOT_FOUND" },
{ 0xC0220009, "STATUS_FWP_ALREADY_EXISTS" },
{ 0xC022000A, "STATUS_FWP_IN_USE" },
{ 0xC022000B, "STATUS_FWP_DYNAMIC_SESSION_IN_PROGRESS" },
{ 0xC022000C, "STATUS_FWP_WRONG_SESSION" },
{ 0xC022000D, "STATUS_FWP_NO_TXN_IN_PROGRESS" },
{ 0xC022000E, "STATUS_FWP_TXN_IN_PROGRESS" },
{ 0xC022000F, "STATUS_FWP_TXN_ABORTED" },
{ 0xC0220010, "STATUS_FWP_SESSION_ABORTED" },
{ 0xC0220011, "STATUS_FWP_INCOMPATIBLE_TXN" },
{ 0xC0220012, "STATUS_FWP_TIMEOUT" },
{ 0xC0220013, "STATUS_FWP_NET_EVENTS_DISABLED" },
{ 0xC0220014, "STATUS_FWP_INCOMPATIBLE_LAYER" },
{ 0xC0220015, "STATUS_FWP_KM_CLIENTS_ONLY" },
{ 0xC0220016, "STATUS_FWP_LIFETIME_MISMATCH" },
{ 0xC0220017, "STATUS_FWP_BUILTIN_OBJECT" },
{ 0xC0220018, "STATUS_FWP_TOO_MANY_CALLOUTS" },
{ 0xC0220019, "STATUS_FWP_NOTIFICATION_DROPPED" },
{ 0xC022001A, "STATUS_FWP_TRAFFIC_MISMATCH" },
{ 0xC022001B, "STATUS_FWP_INCOMPATIBLE_SA_STATE" },
{ 0xC022001C, "STATUS_FWP_NULL_POINTER" },
{ 0xC022001D, "STATUS_FWP_INVALID_ENUMERATOR" },
{ 0xC022001E, "STATUS_FWP_INVALID_FLAGS" },
{ 0xC022001F, "STATUS_FWP_INVALID_NET_MASK" },
{ 0xC0220020, "STATUS_FWP_INVALID_RANGE" },
{ 0xC0220021, "STATUS_FWP_INVALID_INTERVAL" },
{ 0xC0220022, "STATUS_FWP_ZERO_LENGTH_ARRAY" },
{ 0xC0220023, "STATUS_FWP_NULL_DISPLAY_NAME" },
{ 0xC0220024, "STATUS_FWP_INVALID_ACTION_TYPE" },
{ 0xC0220025, "STATUS_FWP_INVALID_WEIGHT" },
{ 0xC0220026, "STATUS_FWP_MATCH_TYPE_MISMATCH" },
{ 0xC0220027, "STATUS_FWP_TYPE_MISMATCH" },
{ 0xC0220028, "STATUS_FWP_OUT_OF_BOUNDS" },
{ 0xC0220029, "STATUS_FWP_RESERVED" },
{ 0xC022002A, "STATUS_FWP_DUPLICATE_CONDITION" },
{ 0xC022002B, "STATUS_FWP_DUPLICATE_KEYMOD" },
{ 0xC022002C, "STATUS_FWP_ACTION_INCOMPATIBLE_WITH_LAYER" },
{ 0xC022002D, "STATUS_FWP_ACTION_INCOMPATIBLE_WITH_SUBLAYER" },
{ 0xC022002E, "STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_LAYER" },
{ 0xC022002F, "STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_CALLOUT" },
{ 0xC0220030, "STATUS_FWP_INCOMPATIBLE_AUTH_METHOD" },
{ 0xC0220031, "STATUS_FWP_INCOMPATIBLE_DH_GROUP" },
{ 0xC0220032, "STATUS_FWP_EM_NOT_SUPPORTED" },
{ 0xC0220033, "STATUS_FWP_NEVER_MATCH" },
{ 0xC0220034, "STATUS_FWP_PROVIDER_CONTEXT_MISMATCH" },
{ 0xC0220035, "STATUS_FWP_INVALID_PARAMETER" },
{ 0xC0220036, "STATUS_FWP_TOO_MANY_SUBLAYERS" },
{ 0xC0220037, "STATUS_FWP_CALLOUT_NOTIFICATION_FAILED" },
{ 0xC0220038, "STATUS_FWP_INVALID_AUTH_TRANSFORM" },
{ 0xC0220039, "STATUS_FWP_INVALID_CIPHER_TRANSFORM" },
{ 0xC022003A, "STATUS_FWP_INCOMPATIBLE_CIPHER_TRANSFORM" },
{ 0xC022003B, "STATUS_FWP_INVALID_TRANSFORM_COMBINATION" },
{ 0xC022003C, "STATUS_FWP_DUPLICATE_AUTH_METHOD" },
{ 0xC022003D, "STATUS_FWP_INVALID_TUNNEL_ENDPOINT" },
{ 0xC022003E, "STATUS_FWP_L2_DRIVER_NOT_READY" },
{ 0xC022003F, "STATUS_FWP_KEY_DICTATOR_ALREADY_REGISTERED" },
{ 0xC0220040, "STATUS_FWP_KEY_DICTATION_INVALID_KEYING_MATERIAL" },
{ 0xC0220041, "STATUS_FWP_CONNECTIONS_DISABLED" },
{ 0xC0220042, "STATUS_FWP_INVALID_DNS_NAME" },
{ 0xC0220043, "STATUS_FWP_STILL_ON" },
{ 0xC0220044, "STATUS_FWP_IKEEXT_NOT_RUNNING" },
{ 0xC0220100, "STATUS_FWP_TCPIP_NOT_READY" },
{ 0xC0220101, "STATUS_FWP_INJECT_HANDLE_CLOSING" },
{ 0xC0220102, "STATUS_FWP_INJECT_HANDLE_STALE" },
{ 0xC0220103, "STATUS_FWP_CANNOT_PEND" },
{ 0xC0220104, "STATUS_FWP_DROP_NOICMP" },
{ 0xC0230002, "STATUS_NDIS_CLOSING" },
{ 0xC0230004, "STATUS_NDIS_BAD_VERSION" },
{ 0xC0230005, "STATUS_NDIS_BAD_CHARACTERISTICS" },
{ 0xC0230006, "STATUS_NDIS_ADAPTER_NOT_FOUND" },
{ 0xC0230007, "STATUS_NDIS_OPEN_FAILED" },
{ 0xC0230008, "STATUS_NDIS_DEVICE_FAILED" },
{ 0xC0230009, "STATUS_NDIS_MULTICAST_FULL" },
{ 0xC023000A, "STATUS_NDIS_MULTICAST_EXISTS" },
{ 0xC023000B, "STATUS_NDIS_MULTICAST_NOT_FOUND" },
{ 0xC023000C, "STATUS_NDIS_REQUEST_ABORTED" },
{ 0xC023000D, "STATUS_NDIS_RESET_IN_PROGRESS" },
{ 0xC023000F, "STATUS_NDIS_INVALID_PACKET" },
{ 0xC0230010, "STATUS_NDIS_INVALID_DEVICE_REQUEST" },
{ 0xC0230011, "STATUS_NDIS_ADAPTER_NOT_READY" },
{ 0xC0230014, "STATUS_NDIS_INVALID_LENGTH" },
{ 0xC0230015, "STATUS_NDIS_INVALID_DATA" },
{ 0xC0230016, "STATUS_NDIS_BUFFER_TOO_SHORT" },
{ 0xC0230017, "STATUS_NDIS_INVALID_OID" },
{ 0xC0230018, "STATUS_NDIS_ADAPTER_REMOVED" },
{ 0xC0230019, "STATUS_NDIS_UNSUPPORTED_MEDIA" },
{ 0xC023001A, "STATUS_NDIS_GROUP_ADDRESS_IN_USE" },
{ 0xC023001B, "STATUS_NDIS_FILE_NOT_FOUND" },
{ 0xC023001C, "STATUS_NDIS_ERROR_READING_FILE" },
{ 0xC023001D, "STATUS_NDIS_ALREADY_MAPPED" },
{ 0xC023001E, "STATUS_NDIS_RESOURCE_CONFLICT" },
{ 0xC023001F, "STATUS_NDIS_MEDIA_DISCONNECTED" },
{ 0xC0230022, "STATUS_NDIS_INVALID_ADDRESS" },
{ 0xC023002A, "STATUS_NDIS_PAUSED" },
{ 0xC023002B, "STATUS_NDIS_INTERFACE_NOT_FOUND" },
{ 0xC023002C, "STATUS_NDIS_UNSUPPORTED_REVISION" },
{ 0xC023002D, "STATUS_NDIS_INVALID_PORT" },
{ 0xC023002E, "STATUS_NDIS_INVALID_PORT_STATE" },
{ 0xC023002F, "STATUS_NDIS_LOW_POWER_STATE" },
{ 0xC0230030, "STATUS_NDIS_REINIT_REQUIRED" },
{ 0xC02300BB, "STATUS_NDIS_NOT_SUPPORTED" },
{ 0xC023100F, "STATUS_NDIS_OFFLOAD_POLICY" },
{ 0xC0231012, "STATUS_NDIS_OFFLOAD_CONNECTION_REJECTED" },
{ 0xC0231013, "STATUS_NDIS_OFFLOAD_PATH_REJECTED" },
{ 0xC0232000, "STATUS_NDIS_DOT11_AUTO_CONFIG_ENABLED" },
{ 0xC0232001, "STATUS_NDIS_DOT11_MEDIA_IN_USE" },
{ 0xC0232002, "STATUS_NDIS_DOT11_POWER_STATE_INVALID" },
{ 0xC0232003, "STATUS_NDIS_PM_WOL_PATTERN_LIST_FULL" },
{ 0xC0232004, "STATUS_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL" },
{ 0xC0232005, "STATUS_NDIS_DOT11_AP_CHANNEL_CURRENTLY_NOT_AVAILABLE" },
{ 0xC0232006, "STATUS_NDIS_DOT11_AP_BAND_CURRENTLY_NOT_AVAILABLE" },
{ 0xC0232007, "STATUS_NDIS_DOT11_AP_CHANNEL_NOT_ALLOWED" },
{ 0xC0232008, "STATUS_NDIS_DOT11_AP_BAND_NOT_ALLOWED" },
{ 0xC0290000, "STATUS_TPM_ERROR_MASK" },
{ 0xC0290001, "STATUS_TPM_AUTHFAIL" },
{ 0xC0290002, "STATUS_TPM_BADINDEX" },
{ 0xC0290003, "STATUS_TPM_BAD_PARAMETER" },
{ 0xC0290004, "STATUS_TPM_AUDITFAILURE" },
{ 0xC0290005, "STATUS_TPM_CLEAR_DISABLED" },
{ 0xC0290006, "STATUS_TPM_DEACTIVATED" },
{ 0xC0290007, "STATUS_TPM_DISABLED" },
{ 0xC0290008, "STATUS_TPM_DISABLED_CMD" },
{ 0xC0290009, "STATUS_TPM_FAIL" },
{ 0xC029000A, "STATUS_TPM_BAD_ORDINAL" },
{ 0xC029000B, "STATUS_TPM_INSTALL_DISABLED" },
{ 0xC029000C, "STATUS_TPM_INVALID_KEYHANDLE" },
{ 0xC029000D, "STATUS_TPM_KEYNOTFOUND" },
{ 0xC029000E, "STATUS_TPM_INAPPROPRIATE_ENC" },
{ 0xC029000F, "STATUS_TPM_MIGRATEFAIL" },
{ 0xC0290010, "STATUS_TPM_INVALID_PCR_INFO" },
{ 0xC0290011, "STATUS_TPM_NOSPACE" },
{ 0xC0290012, "STATUS_TPM_NOSRK" },
{ 0xC0290013, "STATUS_TPM_NOTSEALED_BLOB" },
{ 0xC0290014, "STATUS_TPM_OWNER_SET" },
{ 0xC0290015, "STATUS_TPM_RESOURCES" },
{ 0xC0290016, "STATUS_TPM_SHORTRANDOM" },
{ 0xC0290017, "STATUS_TPM_SIZE" },
{ 0xC0290018, "STATUS_TPM_WRONGPCRVAL" },
{ 0xC0290019, "STATUS_TPM_BAD_PARAM_SIZE" },
{ 0xC029001A, "STATUS_TPM_SHA_THREAD" },
{ 0xC029001B, "STATUS_TPM_SHA_ERROR" },
{ 0xC029001C, "STATUS_TPM_FAILEDSELFTEST" },
{ 0xC029001D, "STATUS_TPM_AUTH2FAIL" },
{ 0xC029001E, "STATUS_TPM_BADTAG" },
{ 0xC029001F, "STATUS_TPM_IOERROR" },
{ 0xC0290020, "STATUS_TPM_ENCRYPT_ERROR" },
{ 0xC0290021, "STATUS_TPM_DECRYPT_ERROR" },
{ 0xC0290022, "STATUS_TPM_INVALID_AUTHHANDLE" },
{ 0xC0290023, "STATUS_TPM_NO_ENDORSEMENT" },
{ 0xC0290024, "STATUS_TPM_INVALID_KEYUSAGE" },
{ 0xC0290025, "STATUS_TPM_WRONG_ENTITYTYPE" },
{ 0xC0290026, "STATUS_TPM_INVALID_POSTINIT" },
{ 0xC0290027, "STATUS_TPM_INAPPROPRIATE_SIG" },
{ 0xC0290028, "STATUS_TPM_BAD_KEY_PROPERTY" },
{ 0xC0290029, "STATUS_TPM_BAD_MIGRATION" },
{ 0xC029002A, "STATUS_TPM_BAD_SCHEME" },
{ 0xC029002B, "STATUS_TPM_BAD_DATASIZE" },
{ 0xC029002C, "STATUS_TPM_BAD_MODE" },
{ 0xC029002D, "STATUS_TPM_BAD_PRESENCE" },
{ 0xC029002E, "STATUS_TPM_BAD_VERSION" },
{ 0xC029002F, "STATUS_TPM_NO_WRAP_TRANSPORT" },
{ 0xC0290030, "STATUS_TPM_AUDITFAIL_UNSUCCESSFUL" },
{ 0xC0290031, "STATUS_TPM_AUDITFAIL_SUCCESSFUL" },
{ 0xC0290032, "STATUS_TPM_NOTRESETABLE" },
{ 0xC0290033, "STATUS_TPM_NOTLOCAL" },
{ 0xC0290034, "STATUS_TPM_BAD_TYPE" },
{ 0xC0290035, "STATUS_TPM_INVALID_RESOURCE" },
{ 0xC0290036, "STATUS_TPM_NOTFIPS" },
{ 0xC0290037, "STATUS_TPM_INVALID_FAMILY" },
{ 0xC0290038, "STATUS_TPM_NO_NV_PERMISSION" },
{ 0xC0290039, "STATUS_TPM_REQUIRES_SIGN" },
{ 0xC029003A, "STATUS_TPM_KEY_NOTSUPPORTED" },
{ 0xC029003B, "STATUS_TPM_AUTH_CONFLICT" },
{ 0xC029003C, "STATUS_TPM_AREA_LOCKED" },
{ 0xC029003D, "STATUS_TPM_BAD_LOCALITY" },
{ 0xC029003E, "STATUS_TPM_READ_ONLY" },
{ 0xC029003F, "STATUS_TPM_PER_NOWRITE" },
{ 0xC0290040, "STATUS_TPM_FAMILYCOUNT" },
{ 0xC0290041, "STATUS_TPM_WRITE_LOCKED" },
{ 0xC0290042, "STATUS_TPM_BAD_ATTRIBUTES" },
{ 0xC0290043, "STATUS_TPM_INVALID_STRUCTURE" },
{ 0xC0290044, "STATUS_TPM_KEY_OWNER_CONTROL" },
{ 0xC0290045, "STATUS_TPM_BAD_COUNTER" },
{ 0xC0290046, "STATUS_TPM_NOT_FULLWRITE" },
{ 0xC0290047, "STATUS_TPM_CONTEXT_GAP" },
{ 0xC0290048, "STATUS_TPM_MAXNVWRITES" },
{ 0xC0290049, "STATUS_TPM_NOOPERATOR" },
{ 0xC029004A, "STATUS_TPM_RESOURCEMISSING" },
{ 0xC029004B, "STATUS_TPM_DELEGATE_LOCK" },
{ 0xC029004C, "STATUS_TPM_DELEGATE_FAMILY" },
{ 0xC029004D, "STATUS_TPM_DELEGATE_ADMIN" },
{ 0xC029004E, "STATUS_TPM_TRANSPORT_NOTEXCLUSIVE" },
{ 0xC029004F, "STATUS_TPM_OWNER_CONTROL" },
{ 0xC0290050, "STATUS_TPM_DAA_RESOURCES" },
{ 0xC0290051, "STATUS_TPM_DAA_INPUT_DATA0" },
{ 0xC0290052, "STATUS_TPM_DAA_INPUT_DATA1" },
{ 0xC0290053, "STATUS_TPM_DAA_ISSUER_SETTINGS" },
{ 0xC0290054, "STATUS_TPM_DAA_TPM_SETTINGS" },
{ 0xC0290055, "STATUS_TPM_DAA_STAGE" },
{ 0xC0290056, "STATUS_TPM_DAA_ISSUER_VALIDITY" },
{ 0xC0290057, "STATUS_TPM_DAA_WRONG_W" },
{ 0xC0290058, "STATUS_TPM_BAD_HANDLE" },
{ 0xC0290059, "STATUS_TPM_BAD_DELEGATE" },
{ 0xC029005A, "STATUS_TPM_BADCONTEXT" },
{ 0xC029005B, "STATUS_TPM_TOOMANYCONTEXTS" },
{ 0xC029005C, "STATUS_TPM_MA_TICKET_SIGNATURE" },
{ 0xC029005D, "STATUS_TPM_MA_DESTINATION" },
{ 0xC029005E, "STATUS_TPM_MA_SOURCE" },
{ 0xC029005F, "STATUS_TPM_MA_AUTHORITY" },
{ 0xC0290061, "STATUS_TPM_PERMANENTEK" },
{ 0xC0290062, "STATUS_TPM_BAD_SIGNATURE" },
{ 0xC0290063, "STATUS_TPM_NOCONTEXTSPACE" },
{ 0xC0290400, "STATUS_TPM_COMMAND_BLOCKED" },
{ 0xC0290401, "STATUS_TPM_INVALID_HANDLE" },
{ 0xC0290402, "STATUS_TPM_DUPLICATE_VHANDLE" },
{ 0xC0290403, "STATUS_TPM_EMBEDDED_COMMAND_BLOCKED" },
{ 0xC0290404, "STATUS_TPM_EMBEDDED_COMMAND_UNSUPPORTED" },
{ 0xC0290800, "STATUS_TPM_RETRY" },
{ 0xC0290801, "STATUS_TPM_NEEDS_SELFTEST" },
{ 0xC0290802, "STATUS_TPM_DOING_SELFTEST" },
{ 0xC0290803, "STATUS_TPM_DEFEND_LOCK_RUNNING" },
{ 0xC0291001, "STATUS_TPM_COMMAND_CANCELED" },
{ 0xC0291002, "STATUS_TPM_TOO_MANY_CONTEXTS" },
{ 0xC0291003, "STATUS_TPM_NOT_FOUND" },
{ 0xC0291004, "STATUS_TPM_ACCESS_DENIED" },
{ 0xC0291005, "STATUS_TPM_INSUFFICIENT_BUFFER" },
{ 0xC0291006, "STATUS_TPM_PPI_FUNCTION_UNSUPPORTED" },
{ 0xC0292000, "STATUS_PCP_ERROR_MASK" },
{ 0xC0292001, "STATUS_PCP_DEVICE_NOT_READY" },
{ 0xC0292002, "STATUS_PCP_INVALID_HANDLE" },
{ 0xC0292003, "STATUS_PCP_INVALID_PARAMETER" },
{ 0xC0292004, "STATUS_PCP_FLAG_NOT_SUPPORTED" },
{ 0xC0292005, "STATUS_PCP_NOT_SUPPORTED" },
{ 0xC0292006, "STATUS_PCP_BUFFER_TOO_SMALL" },
{ 0xC0292007, "STATUS_PCP_INTERNAL_ERROR" },
{ 0xC0292008, "STATUS_PCP_AUTHENTICATION_FAILED" },
{ 0xC0292009, "STATUS_PCP_AUTHENTICATION_IGNORED" },
{ 0xC029200A, "STATUS_PCP_POLICY_NOT_FOUND" },
{ 0xC029200B, "STATUS_PCP_PROFILE_NOT_FOUND" },
{ 0xC029200C, "STATUS_PCP_VALIDATION_FAILED" },
{ 0xC029200D, "STATUS_PCP_DEVICE_NOT_FOUND" },
{ 0xC029200E, "STATUS_PCP_WRONG_PARENT" },
{ 0xC029200F, "STATUS_PCP_KEY_NOT_LOADED" },
{ 0xC0292010, "STATUS_PCP_NO_KEY_CERTIFICATION" },
{ 0xC0292011, "STATUS_PCP_KEY_NOT_FINALIZED" },
{ 0xC0292012, "STATUS_PCP_ATTESTATION_CHALLENGE_NOT_SET" },
{ 0xC0292013, "STATUS_PCP_NOT_PCR_BOUND" },
{ 0xC0292014, "STATUS_PCP_KEY_ALREADY_FINALIZED" },
{ 0xC0292015, "STATUS_PCP_KEY_USAGE_POLICY_NOT_SUPPORTED" },
{ 0xC0292016, "STATUS_PCP_KEY_USAGE_POLICY_INVALID" },
{ 0xC0292017, "STATUS_PCP_SOFT_KEY_ERROR" },
{ 0xC0292018, "STATUS_PCP_KEY_NOT_AUTHENTICATED" },
{ 0xC0292019, "STATUS_PCP_KEY_NOT_AIK" },
{ 0xC029201A, "STATUS_PCP_KEY_NOT_SIGNING_KEY" },
{ 0xC029201B, "STATUS_PCP_LOCKED_OUT" },
{ 0xC029201C, "STATUS_PCP_CLAIM_TYPE_NOT_SUPPORTED" },
{ 0xC029201D, "STATUS_PCP_TPM_VERSION_NOT_SUPPORTED" },
{ 0xC029201E, "STATUS_PCP_BUFFER_LENGTH_MISMATCH" },
{ 0xC029201F, "STATUS_PCP_IFX_RSA_KEY_CREATION_BLOCKED" },
{ 0xC0293002, "STATUS_RTPM_NO_RESULT" },
{ 0xC0293003, "STATUS_RTPM_PCR_READ_INCOMPLETE" },
{ 0xC0293004, "STATUS_RTPM_INVALID_CONTEXT" },
{ 0xC0293005, "STATUS_RTPM_UNSUPPORTED_CMD" },
{ 0xC0294000, "STATUS_TPM_ZERO_EXHAUST_ENABLED" },
{ 0xC0350002, "STATUS_HV_INVALID_HYPERCALL_CODE" },
{ 0xC0350003, "STATUS_HV_INVALID_HYPERCALL_INPUT" },
{ 0xC0350004, "STATUS_HV_INVALID_ALIGNMENT" },
{ 0xC0350005, "STATUS_HV_INVALID_PARAMETER" },
{ 0xC0350006, "STATUS_HV_ACCESS_DENIED" },
{ 0xC0350007, "STATUS_HV_INVALID_PARTITION_STATE" },
{ 0xC0350008, "STATUS_HV_OPERATION_DENIED" },
{ 0xC0350009, "STATUS_HV_UNKNOWN_PROPERTY" },
{ 0xC035000A, "STATUS_HV_PROPERTY_VALUE_OUT_OF_RANGE" },
{ 0xC035000B, "STATUS_HV_INSUFFICIENT_MEMORY" },
{ 0xC035000C, "STATUS_HV_PARTITION_TOO_DEEP" },
{ 0xC035000D, "STATUS_HV_INVALID_PARTITION_ID" },
{ 0xC035000E, "STATUS_HV_INVALID_VP_INDEX" },
{ 0xC0350011, "STATUS_HV_INVALID_PORT_ID" },
{ 0xC0350012, "STATUS_HV_INVALID_CONNECTION_ID" },
{ 0xC0350013, "STATUS_HV_INSUFFICIENT_BUFFERS" },
{ 0xC0350014, "STATUS_HV_NOT_ACKNOWLEDGED" },
{ 0xC0350015, "STATUS_HV_INVALID_VP_STATE" },
{ 0xC0350016, "STATUS_HV_ACKNOWLEDGED" },
{ 0xC0350017, "STATUS_HV_INVALID_SAVE_RESTORE_STATE" },
{ 0xC0350018, "STATUS_HV_INVALID_SYNIC_STATE" },
{ 0xC0350019, "STATUS_HV_OBJECT_IN_USE" },
{ 0xC035001A, "STATUS_HV_INVALID_PROXIMITY_DOMAIN_INFO" },
{ 0xC035001B, "STATUS_HV_NO_DATA" },
{ 0xC035001C, "STATUS_HV_INACTIVE" },
{ 0xC035001D, "STATUS_HV_NO_RESOURCES" },
{ 0xC035001E, "STATUS_HV_FEATURE_UNAVAILABLE" },
{ 0xC0350033, "STATUS_HV_INSUFFICIENT_BUFFER" },
{ 0xC0350038, "STATUS_HV_INSUFFICIENT_DEVICE_DOMAINS" },
{ 0xC035003C, "STATUS_HV_CPUID_FEATURE_VALIDATION_ERROR" },
{ 0xC035003D, "STATUS_HV_CPUID_XSAVE_FEATURE_VALIDATION_ERROR" },
{ 0xC035003E, "STATUS_HV_PROCESSOR_STARTUP_TIMEOUT" },
{ 0xC035003F, "STATUS_HV_SMX_ENABLED" },
{ 0xC0350041, "STATUS_HV_INVALID_LP_INDEX" },
{ 0xC0350050, "STATUS_HV_INVALID_REGISTER_VALUE" },
{ 0xC0350051, "STATUS_HV_INVALID_VTL_STATE" },
{ 0xC0350055, "STATUS_HV_NX_NOT_DETECTED" },
{ 0xC0350057, "STATUS_HV_INVALID_DEVICE_ID" },
{ 0xC0350058, "STATUS_HV_INVALID_DEVICE_STATE" },
{ 0xC0350060, "STATUS_HV_PAGE_REQUEST_INVALID" },
{ 0xC035006F, "STATUS_HV_INVALID_CPU_GROUP_ID" },
{ 0xC0350070, "STATUS_HV_INVALID_CPU_GROUP_STATE" },
{ 0xC0350071, "STATUS_HV_OPERATION_FAILED" },
{ 0xC0350072, "STATUS_HV_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE" },
{ 0xC0351000, "STATUS_HV_NOT_PRESENT" },
{ 0xC0360001, "STATUS_IPSEC_BAD_SPI" },
{ 0xC0360002, "STATUS_IPSEC_SA_LIFETIME_EXPIRED" },
{ 0xC0360003, "STATUS_IPSEC_WRONG_SA" },
{ 0xC0360004, "STATUS_IPSEC_REPLAY_CHECK_FAILED" },
{ 0xC0360005, "STATUS_IPSEC_INVALID_PACKET" },
{ 0xC0360006, "STATUS_IPSEC_INTEGRITY_CHECK_FAILED" },
{ 0xC0360007, "STATUS_IPSEC_CLEAR_TEXT_DROP" },
{ 0xC0360008, "STATUS_IPSEC_AUTH_FIREWALL_DROP" },
{ 0xC0360009, "STATUS_IPSEC_THROTTLE_DROP" },
{ 0xC0368000, "STATUS_IPSEC_DOSP_BLOCK" },
{ 0xC0368001, "STATUS_IPSEC_DOSP_RECEIVED_MULTICAST" },
{ 0xC0368002, "STATUS_IPSEC_DOSP_INVALID_PACKET" },
{ 0xC0368003, "STATUS_IPSEC_DOSP_STATE_LOOKUP_FAILED" },
{ 0xC0368004, "STATUS_IPSEC_DOSP_MAX_ENTRIES" },
{ 0xC0368005, "STATUS_IPSEC_DOSP_KEYMOD_NOT_ALLOWED" },
{ 0xC0368006, "STATUS_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES" },
{ 0xC0370001, "STATUS_VID_DUPLICATE_HANDLER" },
{ 0xC0370002, "STATUS_VID_TOO_MANY_HANDLERS" },
{ 0xC0370003, "STATUS_VID_QUEUE_FULL" },
{ 0xC0370004, "STATUS_VID_HANDLER_NOT_PRESENT" },
{ 0xC0370005, "STATUS_VID_INVALID_OBJECT_NAME" },
{ 0xC0370006, "STATUS_VID_PARTITION_NAME_TOO_LONG" },
{ 0xC0370007, "STATUS_VID_MESSAGE_QUEUE_NAME_TOO_LONG" },
{ 0xC0370008, "STATUS_VID_PARTITION_ALREADY_EXISTS" },
{ 0xC0370009, "STATUS_VID_PARTITION_DOES_NOT_EXIST" },
{ 0xC037000A, "STATUS_VID_PARTITION_NAME_NOT_FOUND" },
{ 0xC037000B, "STATUS_VID_MESSAGE_QUEUE_ALREADY_EXISTS" },
{ 0xC037000C, "STATUS_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT" },
{ 0xC037000D, "STATUS_VID_MB_STILL_REFERENCED" },
{ 0xC037000E, "STATUS_VID_CHILD_GPA_PAGE_SET_CORRUPTED" },
{ 0xC037000F, "STATUS_VID_INVALID_NUMA_SETTINGS" },
{ 0xC0370010, "STATUS_VID_INVALID_NUMA_NODE_INDEX" },
{ 0xC0370011, "STATUS_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED" },
{ 0xC0370012, "STATUS_VID_INVALID_MEMORY_BLOCK_HANDLE" },
{ 0xC0370013, "STATUS_VID_PAGE_RANGE_OVERFLOW" },
{ 0xC0370014, "STATUS_VID_INVALID_MESSAGE_QUEUE_HANDLE" },
{ 0xC0370015, "STATUS_VID_INVALID_GPA_RANGE_HANDLE" },
{ 0xC0370016, "STATUS_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE" },
{ 0xC0370017, "STATUS_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED" },
{ 0xC0370018, "STATUS_VID_INVALID_PPM_HANDLE" },
{ 0xC0370019, "STATUS_VID_MBPS_ARE_LOCKED" },
{ 0xC037001A, "STATUS_VID_MESSAGE_QUEUE_CLOSED" },
{ 0xC037001B, "STATUS_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED" },
{ 0xC037001C, "STATUS_VID_STOP_PENDING" },
{ 0xC037001D, "STATUS_VID_INVALID_PROCESSOR_STATE" },
{ 0xC037001E, "STATUS_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT" },
{ 0xC037001F, "STATUS_VID_KM_INTERFACE_ALREADY_INITIALIZED" },
{ 0xC0370020, "STATUS_VID_MB_PROPERTY_ALREADY_SET_RESET" },
{ 0xC0370021, "STATUS_VID_MMIO_RANGE_DESTROYED" },
{ 0xC0370022, "STATUS_VID_INVALID_CHILD_GPA_PAGE_SET" },
{ 0xC0370023, "STATUS_VID_RESERVE_PAGE_SET_IS_BEING_USED" },
{ 0xC0370024, "STATUS_VID_RESERVE_PAGE_SET_TOO_SMALL" },
{ 0xC0370025, "STATUS_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE" },
{ 0xC0370026, "STATUS_VID_MBP_COUNT_EXCEEDED_LIMIT" },
{ 0xC0370027, "STATUS_VID_SAVED_STATE_CORRUPT" },
{ 0xC0370028, "STATUS_VID_SAVED_STATE_UNRECOGNIZED_ITEM" },
{ 0xC0370029, "STATUS_VID_SAVED_STATE_INCOMPATIBLE" },
{ 0xC037002A, "STATUS_VID_VTL_ACCESS_DENIED" },
{ 0xC0380001, "STATUS_VOLMGR_DATABASE_FULL" },
{ 0xC0380002, "STATUS_VOLMGR_DISK_CONFIGURATION_CORRUPTED" },
{ 0xC0380003, "STATUS_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC" },
{ 0xC0380004, "STATUS_VOLMGR_PACK_CONFIG_UPDATE_FAILED" },
{ 0xC0380005, "STATUS_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME" },
{ 0xC0380006, "STATUS_VOLMGR_DISK_DUPLICATE" },
{ 0xC0380007, "STATUS_VOLMGR_DISK_DYNAMIC" },
{ 0xC0380008, "STATUS_VOLMGR_DISK_ID_INVALID" },
{ 0xC0380009, "STATUS_VOLMGR_DISK_INVALID" },
{ 0xC038000A, "STATUS_VOLMGR_DISK_LAST_VOTER" },
{ 0xC038000B, "STATUS_VOLMGR_DISK_LAYOUT_INVALID" },
{ 0xC038000C, "STATUS_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS" },
{ 0xC038000D, "STATUS_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED" },
{ 0xC038000E, "STATUS_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL" },
{ 0xC038000F, "STATUS_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS" },
{ 0xC0380010, "STATUS_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS" },
{ 0xC0380011, "STATUS_VOLMGR_DISK_MISSING" },
{ 0xC0380012, "STATUS_VOLMGR_DISK_NOT_EMPTY" },
{ 0xC0380013, "STATUS_VOLMGR_DISK_NOT_ENOUGH_SPACE" },
{ 0xC0380014, "STATUS_VOLMGR_DISK_REVECTORING_FAILED" },
{ 0xC0380015, "STATUS_VOLMGR_DISK_SECTOR_SIZE_INVALID" },
{ 0xC0380016, "STATUS_VOLMGR_DISK_SET_NOT_CONTAINED" },
{ 0xC0380017, "STATUS_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS" },
{ 0xC0380018, "STATUS_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES" },
{ 0xC0380019, "STATUS_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED" },
{ 0xC038001A, "STATUS_VOLMGR_EXTENT_ALREADY_USED" },
{ 0xC038001B, "STATUS_VOLMGR_EXTENT_NOT_CONTIGUOUS" },
{ 0xC038001C, "STATUS_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION" },
{ 0xC038001D, "STATUS_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED" },
{ 0xC038001E, "STATUS_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION" },
{ 0xC038001F, "STATUS_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH" },
{ 0xC0380020, "STATUS_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED" },
{ 0xC0380021, "STATUS_VOLMGR_INTERLEAVE_LENGTH_INVALID" },
{ 0xC0380022, "STATUS_VOLMGR_MAXIMUM_REGISTERED_USERS" },
{ 0xC0380023, "STATUS_VOLMGR_MEMBER_IN_SYNC" },
{ 0xC0380024, "STATUS_VOLMGR_MEMBER_INDEX_DUPLICATE" },
{ 0xC0380025, "STATUS_VOLMGR_MEMBER_INDEX_INVALID" },
{ 0xC0380026, "STATUS_VOLMGR_MEMBER_MISSING" },
{ 0xC0380027, "STATUS_VOLMGR_MEMBER_NOT_DETACHED" },
{ 0xC0380028, "STATUS_VOLMGR_MEMBER_REGENERATING" },
{ 0xC0380029, "STATUS_VOLMGR_ALL_DISKS_FAILED" },
{ 0xC038002A, "STATUS_VOLMGR_NO_REGISTERED_USERS" },
{ 0xC038002B, "STATUS_VOLMGR_NO_SUCH_USER" },
{ 0xC038002C, "STATUS_VOLMGR_NOTIFICATION_RESET" },
{ 0xC038002D, "STATUS_VOLMGR_NUMBER_OF_MEMBERS_INVALID" },
{ 0xC038002E, "STATUS_VOLMGR_NUMBER_OF_PLEXES_INVALID" },
{ 0xC038002F, "STATUS_VOLMGR_PACK_DUPLICATE" },
{ 0xC0380030, "STATUS_VOLMGR_PACK_ID_INVALID" },
{ 0xC0380031, "STATUS_VOLMGR_PACK_INVALID" },
{ 0xC0380032, "STATUS_VOLMGR_PACK_NAME_INVALID" },
{ 0xC0380033, "STATUS_VOLMGR_PACK_OFFLINE" },
{ 0xC0380034, "STATUS_VOLMGR_PACK_HAS_QUORUM" },
{ 0xC0380035, "STATUS_VOLMGR_PACK_WITHOUT_QUORUM" },
{ 0xC0380036, "STATUS_VOLMGR_PARTITION_STYLE_INVALID" },
{ 0xC0380037, "STATUS_VOLMGR_PARTITION_UPDATE_FAILED" },
{ 0xC0380038, "STATUS_VOLMGR_PLEX_IN_SYNC" },
{ 0xC0380039, "STATUS_VOLMGR_PLEX_INDEX_DUPLICATE" },
{ 0xC038003A, "STATUS_VOLMGR_PLEX_INDEX_INVALID" },
{ 0xC038003B, "STATUS_VOLMGR_PLEX_LAST_ACTIVE" },
{ 0xC038003C, "STATUS_VOLMGR_PLEX_MISSING" },
{ 0xC038003D, "STATUS_VOLMGR_PLEX_REGENERATING" },
{ 0xC038003E, "STATUS_VOLMGR_PLEX_TYPE_INVALID" },
{ 0xC038003F, "STATUS_VOLMGR_PLEX_NOT_RAID5" },
{ 0xC0380040, "STATUS_VOLMGR_PLEX_NOT_SIMPLE" },
{ 0xC0380041, "STATUS_VOLMGR_STRUCTURE_SIZE_INVALID" },
{ 0xC0380042, "STATUS_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS" },
{ 0xC0380043, "STATUS_VOLMGR_TRANSACTION_IN_PROGRESS" },
{ 0xC0380044, "STATUS_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE" },
{ 0xC0380045, "STATUS_VOLMGR_VOLUME_CONTAINS_MISSING_DISK" },
{ 0xC0380046, "STATUS_VOLMGR_VOLUME_ID_INVALID" },
{ 0xC0380047, "STATUS_VOLMGR_VOLUME_LENGTH_INVALID" },
{ 0xC0380048, "STATUS_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE" },
{ 0xC0380049, "STATUS_VOLMGR_VOLUME_NOT_MIRRORED" },
{ 0xC038004A, "STATUS_VOLMGR_VOLUME_NOT_RETAINED" },
{ 0xC038004B, "STATUS_VOLMGR_VOLUME_OFFLINE" },
{ 0xC038004C, "STATUS_VOLMGR_VOLUME_RETAINED" },
{ 0xC038004D, "STATUS_VOLMGR_NUMBER_OF_EXTENTS_INVALID" },
{ 0xC038004E, "STATUS_VOLMGR_DIFFERENT_SECTOR_SIZE" },
{ 0xC038004F, "STATUS_VOLMGR_BAD_BOOT_DISK" },
{ 0xC0380050, "STATUS_VOLMGR_PACK_CONFIG_OFFLINE" },
{ 0xC0380051, "STATUS_VOLMGR_PACK_CONFIG_ONLINE" },
{ 0xC0380052, "STATUS_VOLMGR_NOT_PRIMARY_PACK" },
{ 0xC0380053, "STATUS_VOLMGR_PACK_LOG_UPDATE_FAILED" },
{ 0xC0380054, "STATUS_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID" },
{ 0xC0380055, "STATUS_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID" },
{ 0xC0380056, "STATUS_VOLMGR_VOLUME_MIRRORED" },
{ 0xC0380057, "STATUS_VOLMGR_PLEX_NOT_SIMPLE_SPANNED" },
{ 0xC0380058, "STATUS_VOLMGR_NO_VALID_LOG_COPIES" },
{ 0xC0380059, "STATUS_VOLMGR_PRIMARY_PACK_PRESENT" },
{ 0xC038005A, "STATUS_VOLMGR_NUMBER_OF_DISKS_INVALID" },
{ 0xC038005B, "STATUS_VOLMGR_MIRROR_NOT_SUPPORTED" },
{ 0xC038005C, "STATUS_VOLMGR_RAID5_NOT_SUPPORTED" },
{ 0xC0390002, "STATUS_BCD_TOO_MANY_ELEMENTS" },
{ 0xC03A0001, "STATUS_VHD_DRIVE_FOOTER_MISSING" },
{ 0xC03A0002, "STATUS_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH" },
{ 0xC03A0003, "STATUS_VHD_DRIVE_FOOTER_CORRUPT" },
{ 0xC03A0004, "STATUS_VHD_FORMAT_UNKNOWN" },
{ 0xC03A0005, "STATUS_VHD_FORMAT_UNSUPPORTED_VERSION" },
{ 0xC03A0006, "STATUS_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH" },
{ 0xC03A0007, "STATUS_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION" },
{ 0xC03A0008, "STATUS_VHD_SPARSE_HEADER_CORRUPT" },
{ 0xC03A0009, "STATUS_VHD_BLOCK_ALLOCATION_FAILURE" },
{ 0xC03A000A, "STATUS_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT" },
{ 0xC03A000B, "STATUS_VHD_INVALID_BLOCK_SIZE" },
{ 0xC03A000C, "STATUS_VHD_BITMAP_MISMATCH" },
{ 0xC03A000D, "STATUS_VHD_PARENT_VHD_NOT_FOUND" },
{ 0xC03A000E, "STATUS_VHD_CHILD_PARENT_ID_MISMATCH" },
{ 0xC03A000F, "STATUS_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH" },
{ 0xC03A0010, "STATUS_VHD_METADATA_READ_FAILURE" },
{ 0xC03A0011, "STATUS_VHD_METADATA_WRITE_FAILURE" },
{ 0xC03A0012, "STATUS_VHD_INVALID_SIZE" },
{ 0xC03A0013, "STATUS_VHD_INVALID_FILE_SIZE" },
{ 0xC03A0014, "STATUS_VIRTDISK_PROVIDER_NOT_FOUND" },
{ 0xC03A0015, "STATUS_VIRTDISK_NOT_VIRTUAL_DISK" },
{ 0xC03A0016, "STATUS_VHD_PARENT_VHD_ACCESS_DENIED" },
{ 0xC03A0017, "STATUS_VHD_CHILD_PARENT_SIZE_MISMATCH" },
{ 0xC03A0018, "STATUS_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED" },
{ 0xC03A0019, "STATUS_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT" },
{ 0xC03A001A, "STATUS_VIRTUAL_DISK_LIMITATION" },
{ 0xC03A001B, "STATUS_VHD_INVALID_TYPE" },
{ 0xC03A001C, "STATUS_VHD_INVALID_STATE" },
{ 0xC03A001D, "STATUS_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE" },
{ 0xC03A001E, "STATUS_VIRTDISK_DISK_ALREADY_OWNED" },
{ 0xC03A001F, "STATUS_VIRTDISK_DISK_ONLINE_AND_WRITABLE" },
{ 0xC03A0020, "STATUS_CTLOG_TRACKING_NOT_INITIALIZED" },
{ 0xC03A0021, "STATUS_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE" },
{ 0xC03A0022, "STATUS_CTLOG_VHD_CHANGED_OFFLINE" },
{ 0xC03A0023, "STATUS_CTLOG_INVALID_TRACKING_STATE" },
{ 0xC03A0024, "STATUS_CTLOG_INCONSISTENT_TRACKING_FILE" },
{ 0xC03A0028, "STATUS_VHD_METADATA_FULL" },
{ 0xC03A0029, "STATUS_VHD_INVALID_CHANGE_TRACKING_ID" },
{ 0xC03A002A, "STATUS_VHD_CHANGE_TRACKING_DISABLED" },
{ 0xC03A0030, "STATUS_VHD_MISSING_CHANGE_TRACKING_INFORMATION" },
{ 0xC03A0031, "STATUS_VHD_RESIZE_WOULD_TRUNCATE_DATA" },
{ 0xC03A0032, "STATUS_VHD_COULD_NOT_COMPUTE_MINIMUM_VIRTUAL_SIZE" },
{ 0xC03A0033, "STATUS_VHD_ALREADY_AT_OR_BELOW_MINIMUM_VIRTUAL_SIZE" },
{ 0xC0400001, "STATUS_RKF_KEY_NOT_FOUND" },
{ 0xC0400002, "STATUS_RKF_DUPLICATE_KEY" },
{ 0xC0400003, "STATUS_RKF_BLOB_FULL" },
{ 0xC0400004, "STATUS_RKF_STORE_FULL" },
{ 0xC0400005, "STATUS_RKF_FILE_BLOCKED" },
{ 0xC0400006, "STATUS_RKF_ACTIVE_KEY" },
{ 0xC0410001, "STATUS_RDBSS_RESTART_OPERATION" },
{ 0xC0410002, "STATUS_RDBSS_CONTINUE_OPERATION" },
{ 0xC0410003, "STATUS_RDBSS_POST_OPERATION" },
{ 0xC0420001, "STATUS_BTH_ATT_INVALID_HANDLE" },
{ 0xC0420002, "STATUS_BTH_ATT_READ_NOT_PERMITTED" },
{ 0xC0420003, "STATUS_BTH_ATT_WRITE_NOT_PERMITTED" },
{ 0xC0420004, "STATUS_BTH_ATT_INVALID_PDU" },
{ 0xC0420005, "STATUS_BTH_ATT_INSUFFICIENT_AUTHENTICATION" },
{ 0xC0420006, "STATUS_BTH_ATT_REQUEST_NOT_SUPPORTED" },
{ 0xC0420007, "STATUS_BTH_ATT_INVALID_OFFSET" },
{ 0xC0420008, "STATUS_BTH_ATT_INSUFFICIENT_AUTHORIZATION" },
{ 0xC0420009, "STATUS_BTH_ATT_PREPARE_QUEUE_FULL" },
{ 0xC042000A, "STATUS_BTH_ATT_ATTRIBUTE_NOT_FOUND" },
{ 0xC042000B, "STATUS_BTH_ATT_ATTRIBUTE_NOT_LONG" },
{ 0xC042000C, "STATUS_BTH_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE" },
{ 0xC042000D, "STATUS_BTH_ATT_INVALID_ATTRIBUTE_VALUE_LENGTH" },
{ 0xC042000E, "STATUS_BTH_ATT_UNLIKELY" },
{ 0xC042000F, "STATUS_BTH_ATT_INSUFFICIENT_ENCRYPTION" },
{ 0xC0420010, "STATUS_BTH_ATT_UNSUPPORTED_GROUP_TYPE" },
{ 0xC0420011, "STATUS_BTH_ATT_INSUFFICIENT_RESOURCES" },
{ 0xC0421000, "STATUS_BTH_ATT_UNKNOWN_ERROR" },
{ 0xC0430001, "STATUS_SECUREBOOT_ROLLBACK_DETECTED" },
{ 0xC0430002, "STATUS_SECUREBOOT_POLICY_VIOLATION" },
{ 0xC0430003, "STATUS_SECUREBOOT_INVALID_POLICY" },
{ 0xC0430004, "STATUS_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND" },
{ 0xC0430005, "STATUS_SECUREBOOT_POLICY_NOT_SIGNED" },
{ 0xC0430007, "STATUS_SECUREBOOT_FILE_REPLACED" },
{ 0xC0430008, "STATUS_SECUREBOOT_POLICY_NOT_AUTHORIZED" },
{ 0xC0430009, "STATUS_SECUREBOOT_POLICY_UNKNOWN" },
{ 0xC043000A, "STATUS_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION" },
{ 0xC043000B, "STATUS_SECUREBOOT_PLATFORM_ID_MISMATCH" },
{ 0xC043000C, "STATUS_SECUREBOOT_POLICY_ROLLBACK_DETECTED" },
{ 0xC043000D, "STATUS_SECUREBOOT_POLICY_UPGRADE_MISMATCH" },
{ 0xC043000E, "STATUS_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING" },
{ 0xC043000F, "STATUS_SECUREBOOT_NOT_BASE_POLICY" },
{ 0xC0430010, "STATUS_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY" },
{ 0xC0440001, "STATUS_AUDIO_ENGINE_NODE_NOT_FOUND" },
{ 0xC0440002, "STATUS_HDAUDIO_EMPTY_CONNECTION_LIST" },
{ 0xC0440003, "STATUS_HDAUDIO_CONNECTION_LIST_NOT_SUPPORTED" },
{ 0xC0440004, "STATUS_HDAUDIO_NO_LOGICAL_DEVICES_CREATED" },
{ 0xC0440005, "STATUS_HDAUDIO_NULL_LINKED_LIST_ENTRY" },
{ 0xC0450000, "STATUS_VSM_NOT_INITIALIZED" },
{ 0xC0450001, "STATUS_VSM_DMA_PROTECTION_NOT_IN_USE" },
{ 0xC0500003, "STATUS_VOLSNAP_BOOTFILE_NOT_VALID" },
{ 0xC0500004, "STATUS_VOLSNAP_ACTIVATION_TIMEOUT" },
{ 0xC0510001, "STATUS_IO_PREEMPTED" },
{ 0xC05C0000, "STATUS_SVHDX_ERROR_STORED" },
{ 0xC05CFF00, "STATUS_SVHDX_ERROR_NOT_AVAILABLE" },
{ 0xC05CFF01, "STATUS_SVHDX_UNIT_ATTENTION_AVAILABLE" },
{ 0xC05CFF02, "STATUS_SVHDX_UNIT_ATTENTION_CAPACITY_DATA_CHANGED" },
{ 0xC05CFF03, "STATUS_SVHDX_UNIT_ATTENTION_RESERVATIONS_PREEMPTED" },
{ 0xC05CFF04, "STATUS_SVHDX_UNIT_ATTENTION_RESERVATIONS_RELEASED" },
{ 0xC05CFF05, "STATUS_SVHDX_UNIT_ATTENTION_REGISTRATIONS_PREEMPTED" },
{ 0xC05CFF06, "STATUS_SVHDX_UNIT_ATTENTION_OPERATING_DEFINITION_CHANGED" },
{ 0xC05CFF07, "STATUS_SVHDX_RESERVATION_CONFLICT" },
{ 0xC05CFF08, "STATUS_SVHDX_WRONG_FILE_TYPE" },
{ 0xC05CFF09, "STATUS_SVHDX_VERSION_MISMATCH" },
{ 0xC05CFF0A, "STATUS_VHD_SHARED" },
{ 0xC05CFF0B, "STATUS_SVHDX_NO_INITIATOR" },
{ 0xC05CFF0C, "STATUS_VHDSET_BACKING_STORAGE_NOT_FOUND" },
{ 0xC05D0000, "STATUS_SMB_NO_PREAUTH_INTEGRITY_HASH_OVERLAP" },
{ 0xC05D0001, "STATUS_SMB_BAD_CLUSTER_DIALECT" },
{ 0xC05D0002, "STATUS_SMB_GUEST_LOGON_BLOCKED" },
{ 0xC0E70001, "STATUS_SPACES_FAULT_DOMAIN_TYPE_INVALID" },
{ 0xC0E70003, "STATUS_SPACES_RESILIENCY_TYPE_INVALID" },
{ 0xC0E70004, "STATUS_SPACES_DRIVE_SECTOR_SIZE_INVALID" },
{ 0xC0E70006, "STATUS_SPACES_DRIVE_REDUNDANCY_INVALID" },
{ 0xC0E70007, "STATUS_SPACES_NUMBER_OF_DATA_COPIES_INVALID" },
{ 0xC0E70009, "STATUS_SPACES_INTERLEAVE_LENGTH_INVALID" },
{ 0xC0E7000A, "STATUS_SPACES_NUMBER_OF_COLUMNS_INVALID" },
{ 0xC0E7000B, "STATUS_SPACES_NOT_ENOUGH_DRIVES" },
{ 0xC0E7000C, "STATUS_SPACES_EXTENDED_ERROR" },
{ 0xC0E7000D, "STATUS_SPACES_PROVISIONING_TYPE_INVALID" },
{ 0xC0E7000E, "STATUS_SPACES_ALLOCATION_SIZE_INVALID" },
{ 0xC0E7000F, "STATUS_SPACES_ENCLOSURE_AWARE_INVALID" },
{ 0xC0E70010, "STATUS_SPACES_WRITE_CACHE_SIZE_INVALID" },
{ 0xC0E70011, "STATUS_SPACES_NUMBER_OF_GROUPS_INVALID" },
{ 0xC0E70012, "STATUS_SPACES_DRIVE_OPERATIONAL_STATE_INVALID" },
{ 0xC0E70013, "STATUS_SPACES_UPDATE_COLUMN_STATE" },
{ 0xC0E70014, "STATUS_SPACES_MAP_REQUIRED" },
{ 0xC0E70015, "STATUS_SPACES_UNSUPPORTED_VERSION" },
{ 0xC0E70016, "STATUS_SPACES_CORRUPT_METADATA" },
{ 0xC0E70017, "STATUS_SPACES_DRT_FULL" },
{ 0xC0E70018, "STATUS_SPACES_INCONSISTENCY" },
{ 0xC0E70019, "STATUS_SPACES_LOG_NOT_READY" },
{ 0xC0E7001A, "STATUS_SPACES_NO_REDUNDANCY" },
{ 0xC0E7001B, "STATUS_SPACES_DRIVE_NOT_READY" },
{ 0xC0E7001C, "STATUS_SPACES_DRIVE_SPLIT" },
{ 0xC0E7001D, "STATUS_SPACES_DRIVE_LOST_DATA" },
{ 0xC0E80000, "STATUS_SECCORE_INVALID_COMMAND" },
{ 0xC0E90001, "STATUS_SYSTEM_INTEGRITY_ROLLBACK_DETECTED" },
{ 0xC0E90002, "STATUS_SYSTEM_INTEGRITY_POLICY_VIOLATION" },
{ 0xC0E90003, "STATUS_SYSTEM_INTEGRITY_INVALID_POLICY" },
{ 0xC0E90004, "STATUS_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED" },
{ 0xC0EA0001, "STATUS_NO_APPLICABLE_APP_LICENSES_FOUND" },
{ 0xC0EA0002, "STATUS_CLIP_LICENSE_NOT_FOUND" },
{ 0xC0EA0003, "STATUS_CLIP_DEVICE_LICENSE_MISSING" },
{ 0xC0EA0004, "STATUS_CLIP_LICENSE_INVALID_SIGNATURE" },
{ 0xC0EA0005, "STATUS_CLIP_KEYHOLDER_LICENSE_MISSING_OR_INVALID" },
{ 0xC0EA0006, "STATUS_CLIP_LICENSE_EXPIRED" },
{ 0xC0EA0007, "STATUS_CLIP_LICENSE_SIGNED_BY_UNKNOWN_SOURCE" },
{ 0xC0EA0008, "STATUS_CLIP_LICENSE_NOT_SIGNED" },
{ 0xC0EA0009, "STATUS_CLIP_LICENSE_HARDWARE_ID_OUT_OF_TOLERANCE" },
{ 0xC0EA000A, "STATUS_CLIP_LICENSE_DEVICE_ID_MISMATCH" },
{ 0xC0EB0001, "STATUS_PLATFORM_MANIFEST_NOT_AUTHORIZED" },
{ 0xC0EB0002, "STATUS_PLATFORM_MANIFEST_INVALID" },
{ 0xC0EB0003, "STATUS_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED" },
{ 0xC0EB0004, "STATUS_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED" },
{ 0xC0EB0005, "STATUS_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND" },
{ 0xC0EB0006, "STATUS_PLATFORM_MANIFEST_NOT_ACTIVE" },
{ 0xC0EB0007, "STATUS_PLATFORM_MANIFEST_NOT_SIGNED" },
};

const char* status2str(uint32_t status)
{
	for (const auto& info : g_statusNames)
	{
		if (info.value == status)
			return info.name;
	}
	return "<UNKNOWN STATUS>";
}
```

`tests/DumpulatorTests/Tests/ntstatusdb.h`:

```h
#pragma once

#include <cstdint>

const char* status2str(uint32_t status);
```

`tests/DumpulatorTests/Tests/phnt.h`:

```h
// cpp-amalgamate.exe -d . phnt_windows.h phnt.h -o ../phnt_amalgamated.h

/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _PHNT_WINDOWS_H
#define _PHNT_WINDOWS_H

// This header file provides access to Win32, plus NTSTATUS values and some access mask values.

#ifndef __cplusplus
#ifndef CINTERFACE
#define CINTERFACE
#endif

#ifndef COBJMACROS
#define COBJMACROS
#endif
#endif

#ifndef INITGUID
#define INITGUID
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef WIN32_NO_STATUS
#define WIN32_NO_STATUS
#endif

#ifndef __cplusplus
// This is needed to workaround C17 preprocessor errors when using legacy versions of the Windows SDK. (dmex)
#ifndef MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS
#define MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS 0
#endif
#endif

#include <windows.h>
#include <windowsx.h>
#undef WIN32_NO_STATUS
#include <ntstatus.h>
#include <winioctl.h>

typedef double DOUBLE;
typedef GUID *PGUID;

// Desktop access rights
#define DESKTOP_ALL_ACCESS \
    (DESKTOP_CREATEMENU | DESKTOP_CREATEWINDOW | DESKTOP_ENUMERATE | \
    DESKTOP_HOOKCONTROL | DESKTOP_JOURNALPLAYBACK | DESKTOP_JOURNALRECORD | \
    DESKTOP_READOBJECTS | DESKTOP_SWITCHDESKTOP | DESKTOP_WRITEOBJECTS | \
    STANDARD_RIGHTS_REQUIRED)
#define DESKTOP_GENERIC_READ \
    (DESKTOP_ENUMERATE | DESKTOP_READOBJECTS | STANDARD_RIGHTS_READ)
#define DESKTOP_GENERIC_WRITE \
    (DESKTOP_CREATEMENU | DESKTOP_CREATEWINDOW | DESKTOP_HOOKCONTROL | \
    DESKTOP_JOURNALPLAYBACK | DESKTOP_JOURNALRECORD | DESKTOP_WRITEOBJECTS | \
    STANDARD_RIGHTS_WRITE)
#define DESKTOP_GENERIC_EXECUTE \
    (DESKTOP_SWITCHDESKTOP | STANDARD_RIGHTS_EXECUTE)

// Window station access rights
#define WINSTA_GENERIC_READ \
    (WINSTA_ENUMDESKTOPS | WINSTA_ENUMERATE | WINSTA_READATTRIBUTES | \
    WINSTA_READSCREEN | STANDARD_RIGHTS_READ)
#define WINSTA_GENERIC_WRITE \
    (WINSTA_ACCESSCLIPBOARD | WINSTA_CREATEDESKTOP | WINSTA_WRITEATTRIBUTES | \
    STANDARD_RIGHTS_WRITE)
#define WINSTA_GENERIC_EXECUTE \
    (WINSTA_ACCESSGLOBALATOMS | WINSTA_EXITWINDOWS | STANDARD_RIGHTS_EXECUTE)

// WMI access rights
#define WMIGUID_GENERIC_READ \
    (WMIGUID_QUERY | WMIGUID_NOTIFICATION | WMIGUID_READ_DESCRIPTION | \
    STANDARD_RIGHTS_READ)
#define WMIGUID_GENERIC_WRITE \
    (WMIGUID_SET | TRACELOG_CREATE_REALTIME | TRACELOG_CREATE_ONDISK | \
    STANDARD_RIGHTS_WRITE)
#define WMIGUID_GENERIC_EXECUTE \
    (WMIGUID_EXECUTE | TRACELOG_GUID_ENABLE | TRACELOG_LOG_EVENT | \
    TRACELOG_ACCESS_REALTIME | TRACELOG_REGISTER_GUIDS | \
    STANDARD_RIGHTS_EXECUTE)

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _PHNT_H
#define _PHNT_H

// This header file provides access to NT APIs.

// Definitions are annotated to indicate their source. If a definition is not annotated, it has been
// retrieved from an official Microsoft source (NT headers, DDK headers, winnt.h).

// * "winbase" indicates that a definition has been reconstructed from a Win32-ized NT definition in
//   winbase.h.
// * "rev" indicates that a definition has been reverse-engineered.
// * "dbg" indicates that a definition has been obtained from a debug message or assertion in a
//   checked build of the kernel or file.

// Reliability:
// 1. No annotation.
// 2. dbg.
// 3. symbols, private. Types may be incorrect.
// 4. winbase. Names and types may be incorrect.
// 5. rev.

// Mode
#define PHNT_MODE_KERNEL 0
#define PHNT_MODE_USER 1

// Version
#define PHNT_WIN2K 50
#define PHNT_WINXP 51
#define PHNT_WS03 52
#define PHNT_VISTA 60
#define PHNT_WIN7 61
#define PHNT_WIN8 62
#define PHNT_WINBLUE 63
#define PHNT_THRESHOLD 100
#define PHNT_THRESHOLD2 101
#define PHNT_REDSTONE 102
#define PHNT_REDSTONE2 103
#define PHNT_REDSTONE3 104
#define PHNT_REDSTONE4 105
#define PHNT_REDSTONE5 106
#define PHNT_19H1 107
#define PHNT_19H2 108
#define PHNT_20H1 109
#define PHNT_20H2 110
#define PHNT_21H1 111
#define PHNT_21H2 112
#define PHNT_WIN11 113
#define PHNT_WIN11_22H2 114

#ifndef PHNT_MODE
#define PHNT_MODE PHNT_MODE_USER
#endif

#ifndef PHNT_VERSION
#define PHNT_VERSION PHNT_WIN7
#endif

// Options

//#define PHNT_NO_INLINE_INIT_STRING

#ifdef __cplusplus
extern "C" {
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _PHNT_NTDEF_H
#define _PHNT_NTDEF_H

#ifndef _NTDEF_
#define _NTDEF_

// This header file provides basic NT types not included in Win32. If you have included winnt.h
// (perhaps indirectly), you must use this file instead of ntdef.h.

#ifndef NOTHING
#define NOTHING
#endif

// Basic types

typedef struct _QUAD
{
    union
    {
        __int64 UseThisFieldToCopy;
        double DoNotUseThisField;
    };
} QUAD, *PQUAD;

// This isn't in NT, but it's useful.
typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _QUAD_PTR
{
    ULONG_PTR DoNotUseThisField1;
    ULONG_PTR DoNotUseThisField2;
} QUAD_PTR, *PQUAD_PTR;

typedef ULONG LOGICAL;
typedef ULONG *PLOGICAL;

typedef _Return_type_success_(return >= 0) LONG NTSTATUS;
typedef NTSTATUS *PNTSTATUS;

// Cardinal types

typedef char CCHAR;
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;

typedef PCSTR PCSZ;

// Specific

typedef UCHAR KIRQL, *PKIRQL;
typedef LONG KPRIORITY, *PKPRIORITY;
typedef USHORT RTL_ATOM, *PRTL_ATOM;

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

typedef struct _LARGE_INTEGER_128
{
    LONGLONG QuadPart[2];
} LARGE_INTEGER_128, *PLARGE_INTEGER_128;

// NT status macros

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define NT_INFORMATION(Status) ((((ULONG)(Status)) >> 30) == 1)
#define NT_WARNING(Status) ((((ULONG)(Status)) >> 30) == 2)
#define NT_ERROR(Status) ((((ULONG)(Status)) >> 30) == 3)

#define NT_FACILITY_MASK 0xfff
#define NT_FACILITY_SHIFT 16
#define NT_FACILITY(Status) ((((ULONG)(Status)) >> NT_FACILITY_SHIFT) & NT_FACILITY_MASK)

#define NT_NTWIN32(Status) (NT_FACILITY(Status) == FACILITY_NTWIN32)
#define WIN32_FROM_NTSTATUS(Status) (((ULONG)(Status)) & 0xffff)

// Functions

#ifndef _WIN64
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif

// Synchronization enumerations

typedef enum _EVENT_TYPE
{
    NotificationEvent,
    SynchronizationEvent
} EVENT_TYPE;

typedef enum _TIMER_TYPE
{
    NotificationTimer,
    SynchronizationTimer
} TIMER_TYPE;

typedef enum _WAIT_TYPE
{
    WaitAll,
    WaitAny,
    WaitNotification
} WAIT_TYPE;

// Strings

typedef struct _STRING
{
    USHORT Length;
    USHORT MaximumLength;
    _Field_size_bytes_part_opt_(MaximumLength, Length) PCHAR Buffer;
} STRING, *PSTRING, ANSI_STRING, *PANSI_STRING, OEM_STRING, *POEM_STRING;

typedef STRING UTF8_STRING;
typedef PSTRING PUTF8_STRING;

typedef const STRING *PCSTRING;
typedef const ANSI_STRING *PCANSI_STRING;
typedef const OEM_STRING *PCOEM_STRING;

typedef struct _UNICODE_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    _Field_size_bytes_part_(MaximumLength, Length) PWCH Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef const UNICODE_STRING *PCUNICODE_STRING;

#define RTL_CONSTANT_STRING(s) { sizeof(s) - sizeof((s)[0]), sizeof(s), s }

// Balanced tree node

#define RTL_BALANCED_NODE_RESERVED_PARENT_MASK 3

typedef struct _RTL_BALANCED_NODE
{
    union
    {
        struct _RTL_BALANCED_NODE *Children[2];
        struct
        {
            struct _RTL_BALANCED_NODE *Left;
            struct _RTL_BALANCED_NODE *Right;
        };
    };
    union
    {
        UCHAR Red : 1;
        UCHAR Balance : 2;
        ULONG_PTR ParentValue;
    };
} RTL_BALANCED_NODE, *PRTL_BALANCED_NODE;

#define RTL_BALANCED_NODE_GET_PARENT_POINTER(Node) \
    ((PRTL_BALANCED_NODE)((Node)->ParentValue & ~RTL_BALANCED_NODE_RESERVED_PARENT_MASK))

// Portability

typedef struct _SINGLE_LIST_ENTRY32
{
    ULONG Next;
} SINGLE_LIST_ENTRY32, *PSINGLE_LIST_ENTRY32;

typedef struct _STRING32
{
    USHORT Length;
    USHORT MaximumLength;
    ULONG Buffer;
} STRING32, *PSTRING32;

typedef STRING32 UNICODE_STRING32, *PUNICODE_STRING32;
typedef STRING32 ANSI_STRING32, *PANSI_STRING32;

typedef struct _STRING64
{
    USHORT Length;
    USHORT MaximumLength;
    ULONGLONG Buffer;
} STRING64, *PSTRING64;

typedef STRING64 UNICODE_STRING64, *PUNICODE_STRING64;
typedef STRING64 ANSI_STRING64, *PANSI_STRING64;

// Object attributes

#define OBJ_PROTECT_CLOSE 0x00000001
#define OBJ_INHERIT 0x00000002
#define OBJ_AUDIT_OBJECT_CLOSE 0x00000004
#define OBJ_PERMANENT 0x00000010
#define OBJ_EXCLUSIVE 0x00000020
#define OBJ_CASE_INSENSITIVE 0x00000040
#define OBJ_OPENIF 0x00000080
#define OBJ_OPENLINK 0x00000100
#define OBJ_KERNEL_HANDLE 0x00000200
#define OBJ_FORCE_ACCESS_CHECK 0x00000400
#define OBJ_IGNORE_IMPERSONATED_DEVICEMAP 0x00000800
#define OBJ_DONT_REPARSE 0x00001000
#define OBJ_VALID_ATTRIBUTES 0x00001ff2

typedef struct _OBJECT_ATTRIBUTES
{
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;
    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

typedef const OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;

#define InitializeObjectAttributes(p, n, a, r, s) { \
    (p)->Length = sizeof(OBJECT_ATTRIBUTES); \
    (p)->RootDirectory = r; \
    (p)->Attributes = a; \
    (p)->ObjectName = n; \
    (p)->SecurityDescriptor = s; \
    (p)->SecurityQualityOfService = NULL; \
    }

#define RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a) { sizeof(OBJECT_ATTRIBUTES), NULL, n, a, NULL, NULL }
#define RTL_INIT_OBJECT_ATTRIBUTES(n, a) RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a)

#define OBJ_NAME_PATH_SEPARATOR ((WCHAR)L'\\')
#define OBJ_NAME_ALTPATH_SEPARATOR ((WCHAR)L'/')

// Portability

typedef struct _OBJECT_ATTRIBUTES64
{
    ULONG Length;
    ULONG64 RootDirectory;
    ULONG64 ObjectName;
    ULONG Attributes;
    ULONG64 SecurityDescriptor;
    ULONG64 SecurityQualityOfService;
} OBJECT_ATTRIBUTES64, *POBJECT_ATTRIBUTES64;

typedef const OBJECT_ATTRIBUTES64 *PCOBJECT_ATTRIBUTES64;

typedef struct _OBJECT_ATTRIBUTES32
{
    ULONG Length;
    ULONG RootDirectory;
    ULONG ObjectName;
    ULONG Attributes;
    ULONG SecurityDescriptor;
    ULONG SecurityQualityOfService;
} OBJECT_ATTRIBUTES32, *POBJECT_ATTRIBUTES32;

typedef const OBJECT_ATTRIBUTES32 *PCOBJECT_ATTRIBUTES32;

// Product types

typedef enum _NT_PRODUCT_TYPE
{
    NtProductWinNt = 1,
    NtProductLanManNt,
    NtProductServer
} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;

typedef enum _SUITE_TYPE
{
    SmallBusiness,
    Enterprise,
    BackOffice,
    CommunicationServer,
    TerminalServer,
    SmallBusinessRestricted,
    EmbeddedNT,
    DataCenter,
    SingleUserTS,
    Personal,
    Blade,
    EmbeddedRestricted,
    SecurityAppliance,
    StorageServer,
    ComputeServer,
    WHServer,
    PhoneNT,
    MaxSuiteType
} SUITE_TYPE;

// Specific

typedef struct _CLIENT_ID
{
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _CLIENT_ID32
{
    ULONG UniqueProcess;
    ULONG UniqueThread;
} CLIENT_ID32, *PCLIENT_ID32;

typedef struct _CLIENT_ID64
{
    ULONGLONG UniqueProcess;
    ULONGLONG UniqueThread;
} CLIENT_ID64, *PCLIENT_ID64;

#include <pshpack4.h>

typedef struct _KSYSTEM_TIME
{
    ULONG LowPart;
    LONG High1Time;
    LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;

#include <poppack.h>

// NT macros used to test, set and clear flags
#ifndef FlagOn
#define FlagOn(_F, _SF) ((_F) & (_SF))
#endif
#ifndef BooleanFlagOn
#define BooleanFlagOn(F, SF) ((BOOLEAN)(((F) & (SF)) != 0))
#endif
#ifndef SetFlag
#define SetFlag(_F, _SF) ((_F) |= (_SF))
#endif
#ifndef ClearFlag
#define ClearFlag(_F, _SF) ((_F) &= ~(_SF))
#endif

#endif

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTNLS_H
#define _NTNLS_H

#define MAXIMUM_LEADBYTES 12

typedef struct _CPTABLEINFO
{
    USHORT CodePage;
    USHORT MaximumCharacterSize;
    USHORT DefaultChar;
    USHORT UniDefaultChar;
    USHORT TransDefaultChar;
    USHORT TransUniDefaultChar;
    USHORT DBCSCodePage;
    UCHAR LeadByte[MAXIMUM_LEADBYTES];
    PUSHORT MultiByteTable;
    PVOID WideCharTable;
    PUSHORT DBCSRanges;
    PUSHORT DBCSOffsets;
} CPTABLEINFO, *PCPTABLEINFO;

typedef struct _NLSTABLEINFO
{
    CPTABLEINFO OemTableInfo;
    CPTABLEINFO AnsiTableInfo;
    PUSHORT UpperCaseTable;
    PUSHORT LowerCaseTable;
} NLSTABLEINFO, *PNLSTABLEINFO;

#if (PHNT_MODE != PHNT_MODE_KERNEL)
NTSYSAPI USHORT NlsAnsiCodePage;
NTSYSAPI BOOLEAN NlsMbCodePageTag;
NTSYSAPI BOOLEAN NlsMbOemCodePageTag;
#endif

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTKEAPI_H
#define _NTKEAPI_H

#if (PHNT_MODE != PHNT_MODE_KERNEL)
#define LOW_PRIORITY 0 // Lowest thread priority level
#define LOW_REALTIME_PRIORITY 16 // Lowest realtime priority level
#define HIGH_PRIORITY 31 // Highest thread priority level
#define MAXIMUM_PRIORITY 32 // Number of thread priority levels
#endif

typedef enum _KTHREAD_STATE
{
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition,
    DeferredReady,
    GateWaitObsolete,
    WaitingForProcessInSwap,
    MaximumThreadState
} KTHREAD_STATE, *PKTHREAD_STATE;

// private
typedef enum _KHETERO_CPU_POLICY
{
    KHeteroCpuPolicyAll = 0,
    KHeteroCpuPolicyLarge = 1,
    KHeteroCpuPolicyLargeOrIdle = 2,
    KHeteroCpuPolicySmall = 3,
    KHeteroCpuPolicySmallOrIdle = 4,
    KHeteroCpuPolicyDynamic = 5,
    KHeteroCpuPolicyStaticMax = 5, // valid
    KHeteroCpuPolicyBiasedSmall = 6,
    KHeteroCpuPolicyBiasedLarge = 7,
    KHeteroCpuPolicyDefault = 8,
    KHeteroCpuPolicyMax = 9
} KHETERO_CPU_POLICY, *PKHETERO_CPU_POLICY;

#if (PHNT_MODE != PHNT_MODE_KERNEL)

typedef enum _KWAIT_REASON
{
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    WrKeyedEvent,
    WrTerminated,
    WrProcessInSwap,
    WrCpuRateControl,
    WrCalloutStack,
    WrKernel,
    WrResource,
    WrPushLock,
    WrMutex,
    WrQuantumEnd,
    WrDispatchInt,
    WrPreempted,
    WrYieldExecution,
    WrFastMutex,
    WrGuardedMutex,
    WrRundown,
    WrAlertByThreadId,
    WrDeferredPreempt,
    WrPhysicalFault,
    WrIoRing,
    WrMdlCache,
    MaximumWaitReason
} KWAIT_REASON, *PKWAIT_REASON;

typedef enum _KPROFILE_SOURCE
{
    ProfileTime,
    ProfileAlignmentFixup,
    ProfileTotalIssues,
    ProfilePipelineDry,
    ProfileLoadInstructions,
    ProfilePipelineFrozen,
    ProfileBranchInstructions,
    ProfileTotalNonissues,
    ProfileDcacheMisses,
    ProfileIcacheMisses,
    ProfileCacheMisses,
    ProfileBranchMispredictions,
    ProfileStoreInstructions,
    ProfileFpInstructions,
    ProfileIntegerInstructions,
    Profile2Issue,
    Profile3Issue,
    Profile4Issue,
    ProfileSpecialInstructions,
    ProfileTotalCycles,
    ProfileIcacheIssues,
    ProfileDcacheAccesses,
    ProfileMemoryBarrierCycles,
    ProfileLoadLinkedIssues,
    ProfileMaximum
} KPROFILE_SOURCE;

#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCallbackReturn(
    _In_reads_bytes_opt_(OutputLength) PVOID OutputBuffer,
    _In_ ULONG OutputLength,
    _In_ NTSTATUS Status
    );

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
VOID
NTAPI
NtFlushProcessWriteBuffers(
    VOID
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_ BOOLEAN State
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtYieldExecution(
    VOID
    );

#endif

#endif
#endif

/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTLDR_H
#define _NTLDR_H

// DLLs

typedef BOOLEAN (NTAPI *PLDR_INIT_ROUTINE)(
    _In_ PVOID DllHandle,
    _In_ ULONG Reason,
    _In_opt_ PVOID Context
    );

// symbols
typedef struct _LDR_SERVICE_TAG_RECORD
{
    struct _LDR_SERVICE_TAG_RECORD *Next;
    ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD, *PLDR_SERVICE_TAG_RECORD;

// symbols
typedef struct _LDRP_CSLIST
{
    PSINGLE_LIST_ENTRY Tail;
} LDRP_CSLIST, *PLDRP_CSLIST;

// symbols
typedef enum _LDR_DDAG_STATE
{
    LdrModulesMerged = -5,
    LdrModulesInitError = -4,
    LdrModulesSnapError = -3,
    LdrModulesUnloaded = -2,
    LdrModulesUnloading = -1,
    LdrModulesPlaceHolder = 0,
    LdrModulesMapping = 1,
    LdrModulesMapped = 2,
    LdrModulesWaitingForDependencies = 3,
    LdrModulesSnapping = 4,
    LdrModulesSnapped = 5,
    LdrModulesCondensed = 6,
    LdrModulesReadyToInit = 7,
    LdrModulesInitializing = 8,
    LdrModulesReadyToRun = 9
} LDR_DDAG_STATE;

// symbols
typedef struct _LDR_DDAG_NODE
{
    LIST_ENTRY Modules;
    PLDR_SERVICE_TAG_RECORD ServiceTagList;
    ULONG LoadCount;
    ULONG LoadWhileUnloadingCount;
    ULONG LowestLink;
    union
    {
        LDRP_CSLIST Dependencies;
        SINGLE_LIST_ENTRY RemovalLink;
    };
    LDRP_CSLIST IncomingDependencies;
    LDR_DDAG_STATE State;
    SINGLE_LIST_ENTRY CondenseLink;
    ULONG PreorderNumber;
} LDR_DDAG_NODE, *PLDR_DDAG_NODE;

// rev
typedef struct _LDR_DEPENDENCY_RECORD
{
    SINGLE_LIST_ENTRY DependencyLink;
    PLDR_DDAG_NODE DependencyNode;
    SINGLE_LIST_ENTRY IncomingDependencyLink;
    PLDR_DDAG_NODE IncomingDependencyNode;
} LDR_DEPENDENCY_RECORD, *PLDR_DEPENDENCY_RECORD;

// symbols
typedef enum _LDR_DLL_LOAD_REASON
{
    LoadReasonStaticDependency,
    LoadReasonStaticForwarderDependency,
    LoadReasonDynamicForwarderDependency,
    LoadReasonDelayloadDependency,
    LoadReasonDynamicLoad,
    LoadReasonAsImageLoad,
    LoadReasonAsDataLoad,
    LoadReasonEnclavePrimary, // since REDSTONE3
    LoadReasonEnclaveDependency,
    LoadReasonPatchImage, // since WIN11
    LoadReasonUnknown = -1
} LDR_DLL_LOAD_REASON, *PLDR_DLL_LOAD_REASON;

typedef enum _LDR_HOT_PATCH_STATE
{
    LdrHotPatchBaseImage,
    LdrHotPatchNotApplied,
    LdrHotPatchAppliedReverse,
    LdrHotPatchAppliedForward,
    LdrHotPatchFailedToPatch,
    LdrHotPatchStateMax,
} LDR_HOT_PATCH_STATE, *PLDR_HOT_PATCH_STATE;

// LDR_DATA_TABLE_ENTRY->Flags
#define LDRP_PACKAGED_BINARY 0x00000001
#define LDRP_MARKED_FOR_REMOVAL 0x00000002
#define LDRP_IMAGE_DLL 0x00000004
#define LDRP_LOAD_NOTIFICATIONS_SENT 0x00000008
#define LDRP_TELEMETRY_ENTRY_PROCESSED 0x00000010
#define LDRP_PROCESS_STATIC_IMPORT 0x00000020
#define LDRP_IN_LEGACY_LISTS 0x00000040
#define LDRP_IN_INDEXES 0x00000080
#define LDRP_SHIM_DLL 0x00000100
#define LDRP_IN_EXCEPTION_TABLE 0x00000200
#define LDRP_LOAD_IN_PROGRESS 0x00001000
#define LDRP_LOAD_CONFIG_PROCESSED 0x00002000
#define LDRP_ENTRY_PROCESSED 0x00004000
#define LDRP_PROTECT_DELAY_LOAD 0x00008000
#define LDRP_DONT_CALL_FOR_THREADS 0x00040000
#define LDRP_PROCESS_ATTACH_CALLED 0x00080000
#define LDRP_PROCESS_ATTACH_FAILED 0x00100000
#define LDRP_COR_DEFERRED_VALIDATE 0x00200000
#define LDRP_COR_IMAGE 0x00400000
#define LDRP_DONT_RELOCATE 0x00800000
#define LDRP_COR_IL_ONLY 0x01000000
#define LDRP_CHPE_IMAGE 0x02000000
#define LDRP_CHPE_EMULATOR_IMAGE 0x04000000
#define LDRP_REDIRECTED 0x10000000
#define LDRP_COMPAT_DATABASE_PROCESSED 0x80000000

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, DdagNode)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN7 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, BaseNameHashValue)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN8 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, ImplicitPathOptions)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN10 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, SigningLevel)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN11 sizeof(LDR_DATA_TABLE_ENTRY)

// symbols
typedef struct _LDR_DATA_TABLE_ENTRY
{
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    union
    {
        LIST_ENTRY InInitializationOrderLinks;
        LIST_ENTRY InProgressLinks;
    };
    PVOID DllBase;
    PLDR_INIT_ROUTINE EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    union
    {
        UCHAR FlagGroup[4];
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1;
            ULONG MarkedForRemoval : 1;
            ULONG ImageDll : 1;
            ULONG LoadNotificationsSent : 1;
            ULONG TelemetryEntryProcessed : 1;
            ULONG ProcessStaticImport : 1;
            ULONG InLegacyLists : 1;
            ULONG InIndexes : 1;
            ULONG ShimDll : 1;
            ULONG InExceptionTable : 1;
            ULONG ReservedFlags1 : 2;
            ULONG LoadInProgress : 1;
            ULONG LoadConfigProcessed : 1;
            ULONG EntryProcessed : 1;
            ULONG ProtectDelayLoad : 1;
            ULONG ReservedFlags3 : 2;
            ULONG DontCallForThreads : 1;
            ULONG ProcessAttachCalled : 1;
            ULONG ProcessAttachFailed : 1;
            ULONG CorDeferredValidate : 1;
            ULONG CorImage : 1;
            ULONG DontRelocate : 1;
            ULONG CorILOnly : 1;
            ULONG ChpeImage : 1;
            ULONG ChpeEmulatorImage : 1;
            ULONG ReservedFlags5 : 1;
            ULONG Redirected : 1;
            ULONG ReservedFlags6 : 2;
            ULONG CompatDatabaseProcessed : 1;
        };
    };
    USHORT ObsoleteLoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    ULONG TimeDateStamp;
    struct _ACTIVATION_CONTEXT *EntryPointActivationContext;
    PVOID Lock; // RtlAcquireSRWLockExclusive
    PLDR_DDAG_NODE DdagNode;
    LIST_ENTRY NodeModuleLink;
    struct _LDRP_LOAD_CONTEXT *LoadContext;
    PVOID ParentDllBase;
    PVOID SwitchBackContext;
    RTL_BALANCED_NODE BaseAddressIndexNode;
    RTL_BALANCED_NODE MappingInfoIndexNode;
    ULONG_PTR OriginalBase;
    LARGE_INTEGER LoadTime;
    ULONG BaseNameHashValue;
    LDR_DLL_LOAD_REASON LoadReason; // since WIN8
    ULONG ImplicitPathOptions;
    ULONG ReferenceCount; // since WIN10
    ULONG DependentLoadFlags;
    UCHAR SigningLevel; // since REDSTONE2
    ULONG CheckSum; // since 22H1
    PVOID ActivePatchImageBase;
    LDR_HOT_PATCH_STATE HotPatchState;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

#define LDR_IS_DATAFILE(DllHandle) (((ULONG_PTR)(DllHandle)) & (ULONG_PTR)1)
#define LDR_IS_IMAGEMAPPING(DllHandle) (((ULONG_PTR)(DllHandle)) & (ULONG_PTR)2)
#define LDR_MAPPEDVIEW_TO_DATAFILE(BaseAddress) ((PVOID)(((ULONG_PTR)(BaseAddress)) | (ULONG_PTR)1))
#define LDR_MAPPEDVIEW_TO_IMAGEMAPPING(BaseAddress) ((PVOID)(((ULONG_PTR)(BaseAddress)) | (ULONG_PTR)2))
#define LDR_DATAFILE_TO_MAPPEDVIEW(DllHandle) ((PVOID)(((ULONG_PTR)(DllHandle)) & ~(ULONG_PTR)1))
#define LDR_IMAGEMAPPING_TO_MAPPEDVIEW(DllHandle) ((PVOID)(((ULONG_PTR)(DllHandle)) & ~(ULONG_PTR)2))
#define LDR_IS_RESOURCE(DllHandle) (LDR_IS_IMAGEMAPPING(DllHandle) || LDR_IS_DATAFILE(DllHandle))

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSAPI
NTSTATUS
NTAPI
LdrLoadDll(
    _In_opt_ PWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PUNICODE_STRING DllName,
    _Out_ PVOID *DllHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrUnloadDll(
    _In_ PVOID DllHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandle(
    _In_opt_ PWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PUNICODE_STRING DllName,
    _Out_ PVOID *DllHandle
    );

#define LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT 0x00000001
#define LDR_GET_DLL_HANDLE_EX_PIN 0x00000002

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleEx(
    _In_ ULONG Flags,
    _In_opt_ PWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PUNICODE_STRING DllName,
    _Out_ PVOID *DllHandle
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByMapping(
    _In_ PVOID BaseAddress,
    _Out_ PVOID *DllHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByName(
    _In_opt_ PUNICODE_STRING BaseDllName,
    _In_opt_ PUNICODE_STRING FullDllName,
    _Out_ PVOID *DllHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8)
// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllFullName(
    _In_ PVOID DllHandle,
    _Out_ PUNICODE_STRING FullDllName
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllDirectory(
    _Out_ PUNICODE_STRING DllDirectory
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrSetDllDirectory(
    _In_ PUNICODE_STRING DllDirectory
    );
#endif

#define LDR_ADDREF_DLL_PIN 0x00000001

NTSYSAPI
NTSTATUS
NTAPI
LdrAddRefDll(
    _In_ ULONG Flags,
    _In_ PVOID DllHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddress(
    _In_ PVOID DllHandle,
    _In_opt_ PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress
    );

// rev
#define LDR_GET_PROCEDURE_ADDRESS_DONT_RECORD_FORWARDER 0x00000001

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddressEx(
    _In_ PVOID DllHandle,
    _In_opt_ PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress,
    _In_ ULONG Flags
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
LdrGetKnownDllSectionHandle(
    _In_ PCWSTR DllName,
    _In_ BOOLEAN KnownDlls32,
    _Out_ PHANDLE Section
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)
// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddressForCaller(
    _In_ PVOID DllHandle,
    _In_opt_ PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress,
    _In_ ULONG Flags,
    _In_ PVOID *Callback
    );
#endif

#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY 0x00000002

#define LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID 0
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED 1
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED 2

NTSYSAPI
NTSTATUS
NTAPI
LdrLockLoaderLock(
    _In_ ULONG Flags,
    _Out_opt_ ULONG *Disposition,
    _Out_ PVOID *Cookie
    );

#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001

NTSYSAPI
NTSTATUS
NTAPI
LdrUnlockLoaderLock(
    _In_ ULONG Flags,
    _Inout_ PVOID Cookie
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrRelocateImage(
    _In_ PVOID NewBase,
    _In_opt_ PSTR LoaderName,
    _In_ NTSTATUS Success,
    _In_ NTSTATUS Conflict,
    _In_ NTSTATUS Invalid
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrRelocateImageWithBias(
    _In_ PVOID NewBase,
    _In_opt_ LONGLONG Bias,
    _In_opt_ PSTR LoaderName,
    _In_ NTSTATUS Success,
    _In_ NTSTATUS Conflict,
    _In_ NTSTATUS Invalid
    );

NTSYSAPI
PIMAGE_BASE_RELOCATION
NTAPI
LdrProcessRelocationBlock(
    _In_ ULONG_PTR VA,
    _In_ ULONG SizeOfBlock,
    _In_ PUSHORT NextOffset,
    _In_ LONG_PTR Diff
    );

NTSYSAPI
BOOLEAN
NTAPI
LdrVerifyMappedImageMatchesChecksum(
    _In_ PVOID BaseAddress,
    _In_ SIZE_T NumberOfBytes,
    _In_ ULONG FileLength
    );

typedef VOID (NTAPI *PLDR_IMPORT_MODULE_CALLBACK)(
    _In_ PVOID Parameter,
    _In_ PSTR ModuleName
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrVerifyImageMatchesChecksum(
    _In_ HANDLE ImageFileHandle,
    _In_opt_ PLDR_IMPORT_MODULE_CALLBACK ImportCallbackRoutine,
    _In_ PVOID ImportCallbackParameter,
    _Out_opt_ PUSHORT ImageCharacteristics
    );

// private
typedef struct _LDR_IMPORT_CALLBACK_INFO
{
    PLDR_IMPORT_MODULE_CALLBACK ImportCallbackRoutine;
    PVOID ImportCallbackParameter;
} LDR_IMPORT_CALLBACK_INFO, *PLDR_IMPORT_CALLBACK_INFO;

// private
typedef struct _LDR_SECTION_INFO
{
    HANDLE SectionHandle;
    ACCESS_MASK DesiredAccess;
    POBJECT_ATTRIBUTES ObjA;
    ULONG SectionPageProtection;
    ULONG AllocationAttributes;
} LDR_SECTION_INFO, *PLDR_SECTION_INFO;

// private
typedef struct _LDR_VERIFY_IMAGE_INFO
{
    ULONG Size;
    ULONG Flags;
    LDR_IMPORT_CALLBACK_INFO CallbackInfo;
    LDR_SECTION_INFO SectionInfo;
    USHORT ImageCharacteristics;
} LDR_VERIFY_IMAGE_INFO, *PLDR_VERIFY_IMAGE_INFO;

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
LdrVerifyImageMatchesChecksumEx(
    _In_ HANDLE ImageFileHandle,
    _Inout_ PLDR_VERIFY_IMAGE_INFO VerifyInfo
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
LdrQueryModuleServiceTags(
    _In_ PVOID DllHandle,
    _Out_writes_(*BufferSize) PULONG ServiceTagBuffer,
    _Inout_ PULONG BufferSize
    );
#endif

// begin_msdn:"DLL Load Notification"

#define LDR_DLL_NOTIFICATION_REASON_LOADED 1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2

typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA
{
    ULONG Flags;
    PUNICODE_STRING FullDllName;
    PUNICODE_STRING BaseDllName;
    PVOID DllBase;
    ULONG SizeOfImage;
} LDR_DLL_LOADED_NOTIFICATION_DATA, *PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA
{
    ULONG Flags;
    PCUNICODE_STRING FullDllName;
    PCUNICODE_STRING BaseDllName;
    PVOID DllBase;
    ULONG SizeOfImage;
} LDR_DLL_UNLOADED_NOTIFICATION_DATA, *PLDR_DLL_UNLOADED_NOTIFICATION_DATA;

typedef union _LDR_DLL_NOTIFICATION_DATA
{
    LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
    LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;

typedef VOID (NTAPI *PLDR_DLL_NOTIFICATION_FUNCTION)(
    _In_ ULONG NotificationReason,
    _In_ PLDR_DLL_NOTIFICATION_DATA NotificationData,
    _In_opt_ PVOID Context
    );

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
NTSTATUS
NTAPI
LdrRegisterDllNotification(
    _In_ ULONG Flags,
    _In_ PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
    _In_opt_ PVOID Context,
    _Out_ PVOID *Cookie
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrUnregisterDllNotification(
    _In_ PVOID Cookie
    );

#endif

// end_msdn

// rev
NTSYSAPI
PUNICODE_STRING
NTAPI
LdrStandardizeSystemPath(
    _In_ PUNICODE_STRING SystemPath
    );

#if (PHNT_VERSION >= PHNT_WINBLUE)
typedef struct _LDR_FAILURE_DATA
{
    NTSTATUS Status;
    WCHAR DllName[0x20];
    WCHAR AdditionalInfo[0x20];
} LDR_FAILURE_DATA, *PLDR_FAILURE_DATA;

NTSYSAPI
PLDR_FAILURE_DATA
NTAPI
LdrGetFailureData(
    VOID
    );
#endif

// private
typedef struct _PS_MITIGATION_OPTIONS_MAP
{
    ULONG_PTR Map[3]; // 2 < 20H1
} PS_MITIGATION_OPTIONS_MAP, *PPS_MITIGATION_OPTIONS_MAP;

// private
typedef struct _PS_MITIGATION_AUDIT_OPTIONS_MAP
{
    ULONG_PTR Map[3]; // 2 < 20H1
} PS_MITIGATION_AUDIT_OPTIONS_MAP, *PPS_MITIGATION_AUDIT_OPTIONS_MAP;

// private
typedef struct _PS_SYSTEM_DLL_INIT_BLOCK
{
    ULONG Size;
    ULONG_PTR SystemDllWowRelocation;
    ULONG_PTR SystemDllNativeRelocation;
    ULONG_PTR Wow64SharedInformation[16]; // use WOW64_SHARED_INFORMATION as index
    ULONG RngData;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG CfgOverride : 1;
            ULONG Reserved : 31;
        };
    };
    PS_MITIGATION_OPTIONS_MAP MitigationOptionsMap;
    ULONG_PTR CfgBitMap;
    ULONG_PTR CfgBitMapSize;
    ULONG_PTR Wow64CfgBitMap;
    ULONG_PTR Wow64CfgBitMapSize;
    PS_MITIGATION_AUDIT_OPTIONS_MAP MitigationAuditOptionsMap; // REDSTONE3
} PS_SYSTEM_DLL_INIT_BLOCK, *PPS_SYSTEM_DLL_INIT_BLOCK;

#if (PHNT_VERSION >= PHNT_THRESHOLD)
// rev
NTSYSAPI PS_SYSTEM_DLL_INIT_BLOCK LdrSystemDllInitBlock;
#endif

// Load as data table

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
LdrAddLoadAsDataTable(
    _In_ PVOID Module,
    _In_ PWSTR FilePath,
    _In_ SIZE_T Size,
    _In_ HANDLE Handle,
    _In_opt_ HANDLE ActCtx
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
LdrRemoveLoadAsDataTable(
    _In_ PVOID InitModule,
    _Out_opt_ PVOID *BaseModule,
    _Out_opt_ PSIZE_T Size,
    _In_ ULONG Flags
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
LdrGetFileNameFromLoadAsDataTable(
    _In_ PVOID Module,
    _Out_ PVOID *pFileNamePrt
    );

#endif

NTSYSAPI
NTSTATUS
NTAPI
LdrDisableThreadCalloutsForDll(
    _In_ PVOID DllImageBase
    );

// Resources

NTSYSAPI
NTSTATUS
NTAPI
LdrAccessResource(
    _In_ PVOID DllHandle,
    _In_ PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry,
    _Out_opt_ PVOID *ResourceBuffer,
    _Out_opt_ ULONG *ResourceLength
    );

typedef struct _LDR_RESOURCE_INFO
{
    ULONG_PTR Type;
    ULONG_PTR Name;
    ULONG_PTR Language;
} LDR_RESOURCE_INFO, *PLDR_RESOURCE_INFO;

#define RESOURCE_TYPE_LEVEL 0
#define RESOURCE_NAME_LEVEL 1
#define RESOURCE_LANGUAGE_LEVEL 2
#define RESOURCE_DATA_LEVEL 3

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResource_U(
    _In_ PVOID DllHandle,
    _In_ PLDR_RESOURCE_INFO ResourceInfo,
    _In_ ULONG Level,
    _Out_ PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResourceEx_U(
    _In_ ULONG Flags,
    _In_ PVOID DllHandle,
    _In_ PLDR_RESOURCE_INFO ResourceInfo,
    _In_ ULONG Level,
    _Out_ PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResourceDirectory_U(
    _In_ PVOID DllHandle,
    _In_ PLDR_RESOURCE_INFO ResourceInfo,
    _In_ ULONG Level,
    _Out_ PIMAGE_RESOURCE_DIRECTORY *ResourceDirectory
    );

// private
typedef struct _LDR_ENUM_RESOURCE_ENTRY
{
    union
    {
        ULONG_PTR NameOrId;
        PIMAGE_RESOURCE_DIRECTORY_STRING Name;
        struct
        {
            USHORT Id;
            USHORT NameIsPresent;
        };
    } Path[3];
    PVOID Data;
    ULONG Size;
    ULONG Reserved;
} LDR_ENUM_RESOURCE_ENTRY, *PLDR_ENUM_RESOURCE_ENTRY;

#define NAME_FROM_RESOURCE_ENTRY(RootDirectory, Entry) \
    ((Entry)->NameIsString ? (ULONG_PTR)PTR_ADD_OFFSET((RootDirectory), (Entry)->NameOffset) : (Entry)->Id)

NTSYSAPI
NTSTATUS
NTAPI
LdrEnumResources(
    _In_ PVOID DllHandle,
    _In_ PLDR_RESOURCE_INFO ResourceInfo,
    _In_ ULONG Level,
    _Inout_ ULONG *ResourceCount,
    _Out_writes_to_opt_(*ResourceCount, *ResourceCount) PLDR_ENUM_RESOURCE_ENTRY Resources
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrFindEntryForAddress(
    _In_ PVOID DllHandle,
    _Out_ PLDR_DATA_TABLE_ENTRY *Entry
    );

// rev - Win10 type
NTSYSAPI
NTSTATUS
NTAPI
LdrLoadAlternateResourceModule(
    _In_ PVOID DllHandle,
    _Out_ PVOID *ResourceDllBase,
    _Out_opt_ ULONG_PTR *ResourceOffset,
    _In_ ULONG Flags
    );

// rev - Win10 type
NTSYSAPI
NTSTATUS
NTAPI
LdrLoadAlternateResourceModuleEx(
    _In_ PVOID DllHandle,
    _In_ LANGID LanguageId,
    _Out_ PVOID *ResourceDllBase,
    _Out_opt_ ULONG_PTR *ResourceOffset,
    _In_ ULONG Flags
    );

#endif // (PHNT_MODE != PHNT_MODE_KERNEL)

// Module information

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

// private
typedef struct _RTL_PROCESS_MODULE_INFORMATION_EX
{
    USHORT NextOffset;
    RTL_PROCESS_MODULE_INFORMATION BaseInfo;
    ULONG ImageChecksum;
    ULONG TimeDateStamp;
    PVOID DefaultBase;
} RTL_PROCESS_MODULE_INFORMATION_EX, *PRTL_PROCESS_MODULE_INFORMATION_EX;

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryProcessModuleInformation(
    _In_opt_ PRTL_PROCESS_MODULES ModuleInformation,
    _In_opt_ ULONG Size,
    _Out_ PULONG ReturnedSize
    );

typedef VOID (NTAPI *PLDR_ENUM_CALLBACK)(
    _In_ PLDR_DATA_TABLE_ENTRY ModuleInformation,
    _In_ PVOID Parameter,
    _Out_ BOOLEAN *Stop
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrEnumerateLoadedModules(
    _In_ BOOLEAN ReservedFlag,
    _In_ PLDR_ENUM_CALLBACK EnumProc,
    _In_ PVOID Context
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrOpenImageFileOptionsKey(
    _In_ PUNICODE_STRING SubKey,
    _In_ BOOLEAN Wow64,
    _Out_ PHANDLE NewKeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileKeyOption(
    _In_ HANDLE KeyHandle,
    _In_ PCWSTR ValueName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ReturnedLength
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileExecutionOptions(
    _In_ PUNICODE_STRING SubKey,
    _In_ PCWSTR ValueName,
    _In_ ULONG ValueSize,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ReturnedLength
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileExecutionOptionsEx(
    _In_ PUNICODE_STRING SubKey,
    _In_ PCWSTR ValueName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ReturnedLength,
    _In_ BOOLEAN Wow64
    );

// private
typedef struct _DELAYLOAD_PROC_DESCRIPTOR
{
    ULONG ImportDescribedByName;
    union
    {
        PCSTR Name;
        ULONG Ordinal;
    } Description;
} DELAYLOAD_PROC_DESCRIPTOR, *PDELAYLOAD_PROC_DESCRIPTOR;

// private
typedef struct _DELAYLOAD_INFO
{
    ULONG Size;
    PCIMAGE_DELAYLOAD_DESCRIPTOR DelayloadDescriptor;
    PIMAGE_THUNK_DATA ThunkAddress;
    PCSTR TargetDllName;
    DELAYLOAD_PROC_DESCRIPTOR TargetApiDescriptor;
    PVOID TargetModuleBase;
    PVOID Unused;
    ULONG LastError;
} DELAYLOAD_INFO, *PDELAYLOAD_INFO;

// private
typedef PVOID (NTAPI *PDELAYLOAD_FAILURE_DLL_CALLBACK)(
    _In_ ULONG NotificationReason,
    _In_ PDELAYLOAD_INFO DelayloadInfo
    );

// rev
typedef PVOID (NTAPI *PDELAYLOAD_FAILURE_SYSTEM_ROUTINE)(
    _In_ PCSTR DllName,
    _In_ PCSTR ProcName
    );

#if (PHNT_VERSION >= PHNT_WIN8)
// rev
NTSYSAPI
PVOID
NTAPI
LdrResolveDelayLoadedAPI(
    _In_ PVOID ParentModuleBase,
    _In_ PCIMAGE_DELAYLOAD_DESCRIPTOR DelayloadDescriptor,
    _In_opt_ PDELAYLOAD_FAILURE_DLL_CALLBACK FailureDllHook,
    _In_opt_ PDELAYLOAD_FAILURE_SYSTEM_ROUTINE FailureSystemHook, // kernel32.DelayLoadFailureHook
    _Out_ PIMAGE_THUNK_DATA ThunkAddress,
    _Reserved_ ULONG Flags
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrResolveDelayLoadsFromDll(
    _In_ PVOID ParentBase,
    _In_ PCSTR TargetDllName,
    _Reserved_ ULONG Flags
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrSetDefaultDllDirectories(
    _In_ ULONG DirectoryFlags
    );
#endif

// rev
DECLSPEC_NORETURN
NTSYSAPI
VOID
NTAPI
LdrShutdownProcess(
    VOID
    );

// rev
DECLSPEC_NORETURN
NTSYSAPI
VOID
NTAPI
LdrShutdownThread(
    VOID
    );

#if (PHNT_VERSION >= PHNT_WINBLUE)
// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrSetImplicitPathOptions(
    _In_ ULONG ImplicitPathOptions
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
LdrControlFlowGuardEnforced(
    VOID
    );
#endif

#if (PHNT_VERSION >= PHNT_19H1)
// rev
NTSYSAPI
BOOLEAN
NTAPI
LdrIsModuleSxsRedirected(
    _In_ PVOID DllHandle
    );
#endif

#endif // (PHNT_MODE != PHNT_MODE_KERNEL)

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTEXAPI_H
#define _NTEXAPI_H


#if (PHNT_MODE != PHNT_MODE_KERNEL)

// Thread execution

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDelayExecution(
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER DelayInterval
    );

// Environment values

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemEnvironmentValue(
    _In_ PUNICODE_STRING VariableName,
    _Out_writes_bytes_(ValueLength) PWSTR VariableValue,
    _In_ USHORT ValueLength,
    _Out_opt_ PUSHORT ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemEnvironmentValue(
    _In_ PUNICODE_STRING VariableName,
    _In_ PUNICODE_STRING VariableValue
    );

#define EFI_VARIABLE_NON_VOLATILE 0x00000001
#define EFI_VARIABLE_BOOTSERVICE_ACCESS 0x00000002
#define EFI_VARIABLE_RUNTIME_ACCESS 0x00000004
#define EFI_VARIABLE_HARDWARE_ERROR_RECORD 0x00000008
#define EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS 0x00000010
#define EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS 0x00000020
#define EFI_VARIABLE_APPEND_WRITE 0x00000040
#define EFI_VARIABLE_ENHANCED_AUTHENTICATED_ACCESS 0x00000080

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemEnvironmentValueEx(
    _In_ PUNICODE_STRING VariableName,
    _In_ PGUID VendorGuid,
    _Out_writes_bytes_opt_(*ValueLength) PVOID Value,
    _Inout_ PULONG ValueLength,
    _Out_opt_ PULONG Attributes // EFI_VARIABLE_*
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemEnvironmentValueEx(
    _In_ PUNICODE_STRING VariableName,
    _In_ PGUID VendorGuid,
    _In_reads_bytes_opt_(ValueLength) PVOID Value,
    _In_ ULONG ValueLength, // 0 = delete variable
    _In_ ULONG Attributes // EFI_VARIABLE_*
    );

typedef enum _SYSTEM_ENVIRONMENT_INFORMATION_CLASS
{
    SystemEnvironmentNameInformation = 1, // q: VARIABLE_NAME
    SystemEnvironmentValueInformation = 2, // q: VARIABLE_NAME_AND_VALUE
    MaxSystemEnvironmentInfoClass
} SYSTEM_ENVIRONMENT_INFORMATION_CLASS;

typedef struct _VARIABLE_NAME
{
    ULONG NextEntryOffset;
    GUID VendorGuid;
    WCHAR Name[ANYSIZE_ARRAY];
} VARIABLE_NAME, *PVARIABLE_NAME;

typedef struct _VARIABLE_NAME_AND_VALUE
{
    ULONG NextEntryOffset;
    ULONG ValueOffset;
    ULONG ValueLength;
    ULONG Attributes;
    GUID VendorGuid;
    WCHAR Name[ANYSIZE_ARRAY];
    //BYTE Value[ANYSIZE_ARRAY];
} VARIABLE_NAME_AND_VALUE, *PVARIABLE_NAME_AND_VALUE;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateSystemEnvironmentValuesEx(
    _In_ ULONG InformationClass, // SYSTEM_ENVIRONMENT_INFORMATION_CLASS
    _Out_ PVOID Buffer,
    _Inout_ PULONG BufferLength
    );

// EFI

// private
typedef struct _BOOT_ENTRY
{
    ULONG Version;
    ULONG Length;
    ULONG Id;
    ULONG Attributes;
    ULONG FriendlyNameOffset;
    ULONG BootFilePathOffset;
    ULONG OsOptionsLength;
    UCHAR OsOptions[1];
} BOOT_ENTRY, *PBOOT_ENTRY;

// private
typedef struct _BOOT_ENTRY_LIST
{
    ULONG NextEntryOffset;
    BOOT_ENTRY BootEntry;
} BOOT_ENTRY_LIST, *PBOOT_ENTRY_LIST;

// private
typedef struct _BOOT_OPTIONS
{
    ULONG Version;
    ULONG Length;
    ULONG Timeout;
    ULONG CurrentBootEntryId;
    ULONG NextBootEntryId;
    WCHAR HeadlessRedirection[1];
} BOOT_OPTIONS, *PBOOT_OPTIONS;

// private
typedef struct _FILE_PATH
{
    ULONG Version;
    ULONG Length;
    ULONG Type;
    UCHAR FilePath[1];
} FILE_PATH, *PFILE_PATH;

// private
typedef struct _EFI_DRIVER_ENTRY
{
    ULONG Version;
    ULONG Length;
    ULONG Id;
    ULONG FriendlyNameOffset;
    ULONG DriverFilePathOffset;
} EFI_DRIVER_ENTRY, *PEFI_DRIVER_ENTRY;

// private
typedef struct _EFI_DRIVER_ENTRY_LIST
{
    ULONG NextEntryOffset;
    EFI_DRIVER_ENTRY DriverEntry;
} EFI_DRIVER_ENTRY_LIST, *PEFI_DRIVER_ENTRY_LIST;

#if (PHNT_VERSION >= PHNT_WINXP)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAddBootEntry(
    _In_ PBOOT_ENTRY BootEntry,
    _Out_opt_ PULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteBootEntry(
    _In_ ULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtModifyBootEntry(
    _In_ PBOOT_ENTRY BootEntry
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateBootEntries(
    _Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
    _Inout_ PULONG BufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryBootEntryOrder(
    _Out_writes_opt_(*Count) PULONG Ids,
    _Inout_ PULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetBootEntryOrder(
    _In_reads_(Count) PULONG Ids,
    _In_ ULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryBootOptions(
    _Out_writes_bytes_opt_(*BootOptionsLength) PBOOT_OPTIONS BootOptions,
    _Inout_ PULONG BootOptionsLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetBootOptions(
    _In_ PBOOT_OPTIONS BootOptions,
    _In_ ULONG FieldsToChange
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTranslateFilePath(
    _In_ PFILE_PATH InputFilePath,
    _In_ ULONG OutputType,
    _Out_writes_bytes_opt_(*OutputFilePathLength) PFILE_PATH OutputFilePath,
    _Inout_opt_ PULONG OutputFilePathLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAddDriverEntry(
    _In_ PEFI_DRIVER_ENTRY DriverEntry,
    _Out_opt_ PULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteDriverEntry(
    _In_ ULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtModifyDriverEntry(
    _In_ PEFI_DRIVER_ENTRY DriverEntry
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateDriverEntries(
    _Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
    _Inout_ PULONG BufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDriverEntryOrder(
    _Out_writes_opt_(*Count) PULONG Ids,
    _Inout_ PULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetDriverEntryOrder(
    _In_reads_(Count) PULONG Ids,
    _In_ ULONG Count
    );

#endif

typedef enum _FILTER_BOOT_OPTION_OPERATION
{
    FilterBootOptionOperationOpenSystemStore,
    FilterBootOptionOperationSetElement,
    FilterBootOptionOperationDeleteElement,
    FilterBootOptionOperationMax
} FILTER_BOOT_OPTION_OPERATION;

#if (PHNT_VERSION >= PHNT_WIN8)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFilterBootOption(
    _In_ FILTER_BOOT_OPTION_OPERATION FilterOperation,
    _In_ ULONG ObjectType,
    _In_ ULONG ElementType,
    _In_reads_bytes_opt_(DataSize) PVOID Data,
    _In_ ULONG DataSize
    );

#endif

// Event

#ifndef EVENT_QUERY_STATE
#define EVENT_QUERY_STATE 0x0001
#endif

#ifndef EVENT_MODIFY_STATE
#define EVENT_MODIFY_STATE 0x0002
#endif

#ifndef EVENT_ALL_ACCESS
#define EVENT_ALL_ACCESS (EVENT_QUERY_STATE|EVENT_MODIFY_STATE|STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE)
#endif

typedef enum _EVENT_INFORMATION_CLASS
{
    EventBasicInformation
} EVENT_INFORMATION_CLASS;

typedef struct _EVENT_BASIC_INFORMATION
{
    EVENT_TYPE EventType;
    LONG EventState;
} EVENT_BASIC_INFORMATION, *PEVENT_BASIC_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ EVENT_TYPE EventType,
    _In_ BOOLEAN InitialState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetEventBoostPriority(
    _In_ HANDLE EventHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtClearEvent(
    _In_ HANDLE EventHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtResetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPulseEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryEvent(
    _In_ HANDLE EventHandle,
    _In_ EVENT_INFORMATION_CLASS EventInformationClass,
    _Out_writes_bytes_(EventInformationLength) PVOID EventInformation,
    _In_ ULONG EventInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

// Event Pair

#define EVENT_PAIR_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetLowEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetHighEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitLowEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitHighEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetLowWaitHighEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetHighWaitLowEventPair(
    _In_ HANDLE EventPairHandle
    );

// Mutant

#ifndef MUTANT_QUERY_STATE
#define MUTANT_QUERY_STATE 0x0001
#endif

#ifndef MUTANT_ALL_ACCESS
#define MUTANT_ALL_ACCESS (MUTANT_QUERY_STATE|STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE)
#endif

typedef enum _MUTANT_INFORMATION_CLASS
{
    MutantBasicInformation, // MUTANT_BASIC_INFORMATION
    MutantOwnerInformation // MUTANT_OWNER_INFORMATION
} MUTANT_INFORMATION_CLASS;

typedef struct _MUTANT_BASIC_INFORMATION
{
    LONG CurrentCount;
    BOOLEAN OwnedByCaller;
    BOOLEAN AbandonedState;
} MUTANT_BASIC_INFORMATION, *PMUTANT_BASIC_INFORMATION;

typedef struct _MUTANT_OWNER_INFORMATION
{
    CLIENT_ID ClientId;
} MUTANT_OWNER_INFORMATION, *PMUTANT_OWNER_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN InitialOwner
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseMutant(
    _In_ HANDLE MutantHandle,
    _Out_opt_ PLONG PreviousCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryMutant(
    _In_ HANDLE MutantHandle,
    _In_ MUTANT_INFORMATION_CLASS MutantInformationClass,
    _Out_writes_bytes_(MutantInformationLength) PVOID MutantInformation,
    _In_ ULONG MutantInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

// Semaphore

#ifndef SEMAPHORE_QUERY_STATE
#define SEMAPHORE_QUERY_STATE 0x0001
#endif

#ifndef SEMAPHORE_MODIFY_STATE
#define SEMAPHORE_MODIFY_STATE 0x0002
#endif

#ifndef SEMAPHORE_ALL_ACCESS
#define SEMAPHORE_ALL_ACCESS (SEMAPHORE_QUERY_STATE|SEMAPHORE_MODIFY_STATE|STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE)
#endif

typedef enum _SEMAPHORE_INFORMATION_CLASS
{
    SemaphoreBasicInformation
} SEMAPHORE_INFORMATION_CLASS;

typedef struct _SEMAPHORE_BASIC_INFORMATION
{
    LONG CurrentCount;
    LONG MaximumCount;
} SEMAPHORE_BASIC_INFORMATION, *PSEMAPHORE_BASIC_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ LONG InitialCount,
    _In_ LONG MaximumCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseSemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ LONG ReleaseCount,
    _Out_opt_ PLONG PreviousCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    _Out_writes_bytes_(SemaphoreInformationLength) PVOID SemaphoreInformation,
    _In_ ULONG SemaphoreInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

// Timer

#ifndef TIMER_QUERY_STATE
#define TIMER_QUERY_STATE 0x0001
#endif

#ifndef TIMER_MODIFY_STATE
#define TIMER_MODIFY_STATE 0x0002
#endif

#ifndef TIMER_ALL_ACCESS
#define TIMER_ALL_ACCESS (TIMER_QUERY_STATE|TIMER_MODIFY_STATE|STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE)
#endif

typedef enum _TIMER_INFORMATION_CLASS
{
    TimerBasicInformation // TIMER_BASIC_INFORMATION
} TIMER_INFORMATION_CLASS;

typedef struct _TIMER_BASIC_INFORMATION
{
    LARGE_INTEGER RemainingTime;
    BOOLEAN TimerState;
} TIMER_BASIC_INFORMATION, *PTIMER_BASIC_INFORMATION;

typedef VOID (NTAPI *PTIMER_APC_ROUTINE)(
    _In_ PVOID TimerContext,
    _In_ ULONG TimerLowValue,
    _In_ LONG TimerHighValue
    );

typedef enum _TIMER_SET_INFORMATION_CLASS
{
    TimerSetCoalescableTimer, // TIMER_SET_COALESCABLE_TIMER_INFO
    MaxTimerInfoClass
} TIMER_SET_INFORMATION_CLASS;

#if (PHNT_VERSION >= PHNT_WIN7)
struct _COUNTED_REASON_CONTEXT;

typedef struct _TIMER_SET_COALESCABLE_TIMER_INFO
{
    _In_ LARGE_INTEGER DueTime;
    _In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine;
    _In_opt_ PVOID TimerContext;
    _In_opt_ struct _COUNTED_REASON_CONTEXT *WakeContext;
    _In_opt_ ULONG Period;
    _In_ ULONG TolerableDelay;
    _Out_opt_ PBOOLEAN PreviousState;
} TIMER_SET_COALESCABLE_TIMER_INFO, *PTIMER_SET_COALESCABLE_TIMER_INFO;
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TIMER_TYPE TimerType
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetTimer(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine,
    _In_opt_ PVOID TimerContext,
    _In_ BOOLEAN ResumeTimer,
    _In_opt_ LONG Period,
    _Out_opt_ PBOOLEAN PreviousState
    );

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetTimerEx(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_SET_INFORMATION_CLASS TimerSetInformationClass,
    _Inout_updates_bytes_opt_(TimerSetInformationLength) PVOID TimerSetInformation,
    _In_ ULONG TimerSetInformationLength
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelTimer(
    _In_ HANDLE TimerHandle,
    _Out_opt_ PBOOLEAN CurrentState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryTimer(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_INFORMATION_CLASS TimerInformationClass,
    _Out_writes_bytes_(TimerInformationLength) PVOID TimerInformation,
    _In_ ULONG TimerInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

#if (PHNT_VERSION >= PHNT_WIN8)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateIRTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetIRTimer(
    _In_ HANDLE TimerHandle,
    _In_opt_ PLARGE_INTEGER DueTime
    );

#endif

typedef struct _T2_SET_PARAMETERS_V0
{
    ULONG Version;
    ULONG Reserved;
    LONGLONG NoWakeTolerance;
} T2_SET_PARAMETERS, *PT2_SET_PARAMETERS;

typedef PVOID PT2_CANCEL_PARAMETERS;

#if (PHNT_VERSION >= PHNT_THRESHOLD)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTimer2(
    _Out_ PHANDLE TimerHandle,
    _In_opt_ PVOID Reserved1,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Attributes,
    _In_ ACCESS_MASK DesiredAccess
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetTimer2(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PLARGE_INTEGER Period,
    _In_ PT2_SET_PARAMETERS Parameters
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelTimer2(
    _In_ HANDLE TimerHandle,
    _In_ PT2_CANCEL_PARAMETERS Parameters
    );

#endif

// Profile

#define PROFILE_CONTROL 0x0001
#define PROFILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | PROFILE_CONTROL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateProfile(
    _Out_ PHANDLE ProfileHandle,
    _In_opt_ HANDLE Process,
    _In_ PVOID ProfileBase,
    _In_ SIZE_T ProfileSize,
    _In_ ULONG BucketSize,
    _In_reads_bytes_(BufferSize) PULONG Buffer,
    _In_ ULONG BufferSize,
    _In_ KPROFILE_SOURCE ProfileSource,
    _In_ KAFFINITY Affinity
    );

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateProfileEx(
    _Out_ PHANDLE ProfileHandle,
    _In_opt_ HANDLE Process,
    _In_ PVOID ProfileBase,
    _In_ SIZE_T ProfileSize,
    _In_ ULONG BucketSize,
    _In_reads_bytes_(BufferSize) PULONG Buffer,
    _In_ ULONG BufferSize,
    _In_ KPROFILE_SOURCE ProfileSource,
    _In_ USHORT GroupCount,
    _In_reads_(GroupCount) PGROUP_AFFINITY GroupAffinity
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtStartProfile(
    _In_ HANDLE ProfileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtStopProfile(
    _In_ HANDLE ProfileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryIntervalProfile(
    _In_ KPROFILE_SOURCE ProfileSource,
    _Out_ PULONG Interval
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetIntervalProfile(
    _In_ ULONG Interval,
    _In_ KPROFILE_SOURCE Source
    );

// Keyed Event

#define KEYEDEVENT_WAIT 0x0001
#define KEYEDEVENT_WAKE 0x0002
#define KEYEDEVENT_ALL_ACCESS \
    (STANDARD_RIGHTS_REQUIRED | KEYEDEVENT_WAIT | KEYEDEVENT_WAKE)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateKeyedEvent(
    _Out_ PHANDLE KeyedEventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyedEvent(
    _Out_ PHANDLE KeyedEventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseKeyedEvent(
    _In_ HANDLE KeyedEventHandle,
    _In_ PVOID KeyValue,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForKeyedEvent(
    _In_ HANDLE KeyedEventHandle,
    _In_ PVOID KeyValue,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

// UMS

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtUmsThreadYield(
    _In_ PVOID SchedulerParam
    );
#endif

// WNF

// begin_private

typedef struct _WNF_STATE_NAME
{
    ULONG Data[2];
} WNF_STATE_NAME, *PWNF_STATE_NAME;

typedef const WNF_STATE_NAME *PCWNF_STATE_NAME;

typedef enum _WNF_STATE_NAME_LIFETIME
{
    WnfWellKnownStateName,
    WnfPermanentStateName,
    WnfPersistentStateName,
    WnfTemporaryStateName
} WNF_STATE_NAME_LIFETIME;

typedef enum _WNF_STATE_NAME_INFORMATION
{
    WnfInfoStateNameExist,
    WnfInfoSubscribersPresent,
    WnfInfoIsQuiescent
} WNF_STATE_NAME_INFORMATION;

typedef enum _WNF_DATA_SCOPE
{
    WnfDataScopeSystem,
    WnfDataScopeSession,
    WnfDataScopeUser,
    WnfDataScopeProcess,
    WnfDataScopeMachine, // REDSTONE3
    WnfDataScopePhysicalMachine, // WIN11
} WNF_DATA_SCOPE;

typedef struct _WNF_TYPE_ID
{
    GUID TypeId;
} WNF_TYPE_ID, *PWNF_TYPE_ID;

typedef const WNF_TYPE_ID *PCWNF_TYPE_ID;

// rev
typedef ULONG WNF_CHANGE_STAMP, *PWNF_CHANGE_STAMP;

typedef struct _WNF_DELIVERY_DESCRIPTOR
{
    ULONGLONG SubscriptionId;
    WNF_STATE_NAME StateName;
    WNF_CHANGE_STAMP ChangeStamp;
    ULONG StateDataSize;
    ULONG EventMask;
    WNF_TYPE_ID TypeId;
    ULONG StateDataOffset;
} WNF_DELIVERY_DESCRIPTOR, *PWNF_DELIVERY_DESCRIPTOR;

// end_private

#if (PHNT_VERSION >= PHNT_WIN8)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateWnfStateName(
    _Out_ PWNF_STATE_NAME StateName,
    _In_ WNF_STATE_NAME_LIFETIME NameLifetime,
    _In_ WNF_DATA_SCOPE DataScope,
    _In_ BOOLEAN PersistData,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_ ULONG MaximumStateSize,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteWnfStateName(
    _In_ PCWNF_STATE_NAME StateName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUpdateWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_reads_bytes_opt_(Length) const VOID *Buffer,
    _In_opt_ ULONG Length,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const VOID *ExplicitScope,
    _In_ WNF_CHANGE_STAMP MatchingChangeStamp,
    _In_ LOGICAL CheckStamp
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ const VOID *ExplicitScope
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const VOID *ExplicitScope,
    _Out_ PWNF_CHANGE_STAMP ChangeStamp,
    _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer,
    _Inout_ PULONG BufferSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryWnfStateNameInformation(
    _In_ PCWNF_STATE_NAME StateName,
    _In_ WNF_STATE_NAME_INFORMATION NameInfoClass,
    _In_opt_ const VOID *ExplicitScope,
    _Out_writes_bytes_(InfoBufferSize) PVOID InfoBuffer,
    _In_ ULONG InfoBufferSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSubscribeWnfStateChange(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ WNF_CHANGE_STAMP ChangeStamp,
    _In_ ULONG EventMask,
    _Out_opt_ PULONG64 SubscriptionId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnsubscribeWnfStateChange(
    _In_ PCWNF_STATE_NAME StateName
    );

#endif

#if (PHNT_VERSION >= PHNT_THRESHOLD)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetCompleteWnfStateSubscription(
    _In_opt_ PWNF_STATE_NAME OldDescriptorStateName,
    _In_opt_ ULONG64 *OldSubscriptionId,
    _In_opt_ ULONG OldDescriptorEventMask,
    _In_opt_ ULONG OldDescriptorStatus,
    _Out_writes_bytes_(DescriptorSize) PWNF_DELIVERY_DESCRIPTOR NewDeliveryDescriptor,
    _In_ ULONG DescriptorSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetWnfProcessNotificationEvent(
    _In_ HANDLE NotificationEvent
    );

#endif

// Worker factory

// begin_rev

#define WORKER_FACTORY_RELEASE_WORKER 0x0001
#define WORKER_FACTORY_WAIT 0x0002
#define WORKER_FACTORY_SET_INFORMATION 0x0004
#define WORKER_FACTORY_QUERY_INFORMATION 0x0008
#define WORKER_FACTORY_READY_WORKER 0x0010
#define WORKER_FACTORY_SHUTDOWN 0x0020

#define WORKER_FACTORY_ALL_ACCESS ( \
    STANDARD_RIGHTS_REQUIRED | \
    WORKER_FACTORY_RELEASE_WORKER | \
    WORKER_FACTORY_WAIT | \
    WORKER_FACTORY_SET_INFORMATION | \
    WORKER_FACTORY_QUERY_INFORMATION | \
    WORKER_FACTORY_READY_WORKER | \
    WORKER_FACTORY_SHUTDOWN \
    )

// end_rev

// begin_private

typedef enum _WORKERFACTORYINFOCLASS
{
    WorkerFactoryTimeout, // LARGE_INTEGER
    WorkerFactoryRetryTimeout, // LARGE_INTEGER
    WorkerFactoryIdleTimeout, // s: LARGE_INTEGER
    WorkerFactoryBindingCount, // s: ULONG
    WorkerFactoryThreadMinimum, // s: ULONG
    WorkerFactoryThreadMaximum, // s: ULONG
    WorkerFactoryPaused, // ULONG or BOOLEAN
    WorkerFactoryBasicInformation, // q: WORKER_FACTORY_BASIC_INFORMATION
    WorkerFactoryAdjustThreadGoal,
    WorkerFactoryCallbackType,
    WorkerFactoryStackInformation, // 10
    WorkerFactoryThreadBasePriority, // s: ULONG
    WorkerFactoryTimeoutWaiters, // s: ULONG, since THRESHOLD
    WorkerFactoryFlags, // s: ULONG
    WorkerFactoryThreadSoftMaximum, // s: ULONG
    WorkerFactoryThreadCpuSets, // since REDSTONE5
    MaxWorkerFactoryInfoClass
} WORKERFACTORYINFOCLASS, *PWORKERFACTORYINFOCLASS;

typedef struct _WORKER_FACTORY_BASIC_INFORMATION
{
    LARGE_INTEGER Timeout;
    LARGE_INTEGER RetryTimeout;
    LARGE_INTEGER IdleTimeout;
    BOOLEAN Paused;
    BOOLEAN TimerSet;
    BOOLEAN QueuedToExWorker;
    BOOLEAN MayCreate;
    BOOLEAN CreateInProgress;
    BOOLEAN InsertedIntoQueue;
    BOOLEAN Shutdown;
    ULONG BindingCount;
    ULONG ThreadMinimum;
    ULONG ThreadMaximum;
    ULONG PendingWorkerCount;
    ULONG WaitingWorkerCount;
    ULONG TotalWorkerCount;
    ULONG ReleaseCount;
    LONGLONG InfiniteWaitGoal;
    PVOID StartRoutine;
    PVOID StartParameter;
    HANDLE ProcessId;
    SIZE_T StackReserve;
    SIZE_T StackCommit;
    NTSTATUS LastThreadCreationStatus;
} WORKER_FACTORY_BASIC_INFORMATION, *PWORKER_FACTORY_BASIC_INFORMATION;

// end_private

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateWorkerFactory(
    _Out_ PHANDLE WorkerFactoryHandleReturn,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE CompletionPortHandle,
    _In_ HANDLE WorkerProcessHandle,
    _In_ PVOID StartRoutine,
    _In_opt_ PVOID StartParameter,
    _In_opt_ ULONG MaxThreadCount,
    _In_opt_ SIZE_T StackReserve,
    _In_opt_ SIZE_T StackCommit
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
    _Out_writes_bytes_(WorkerFactoryInformationLength) PVOID WorkerFactoryInformation,
    _In_ ULONG WorkerFactoryInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
    _In_reads_bytes_(WorkerFactoryInformationLength) PVOID WorkerFactoryInformation,
    _In_ ULONG WorkerFactoryInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtShutdownWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Inout_ volatile LONG *PendingWorkerCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseWorkerFactoryWorker(
    _In_ HANDLE WorkerFactoryHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWorkerFactoryWorkerReady(
    _In_ HANDLE WorkerFactoryHandle
    );

struct _FILE_IO_COMPLETION_INFORMATION;

#if (PHNT_VERSION >= PHNT_WIN8)

typedef struct _WORKER_FACTORY_DEFERRED_WORK
{
    struct _PORT_MESSAGE *AlpcSendMessage;
    PVOID AlpcSendMessagePort;
    ULONG AlpcSendMessageFlags;
    ULONG Flags;
} WORKER_FACTORY_DEFERRED_WORK, *PWORKER_FACTORY_DEFERRED_WORK;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForWorkViaWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Out_writes_to_(Count, *PacketsReturned) struct _FILE_IO_COMPLETION_INFORMATION *MiniPackets,
    _In_ ULONG Count,
    _Out_ PULONG PacketsReturned,
    _In_ struct _WORKER_FACTORY_DEFERRED_WORK* DeferredWork
    );

#else

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForWorkViaWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Out_ struct _FILE_IO_COMPLETION_INFORMATION *MiniPacket
    );

#endif

#endif

// Time

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemTime(
    _Out_ PLARGE_INTEGER SystemTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemTime(
    _In_opt_ PLARGE_INTEGER SystemTime,
    _Out_opt_ PLARGE_INTEGER PreviousTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryTimerResolution(
    _Out_ PULONG MaximumTime,
    _Out_ PULONG MinimumTime,
    _Out_ PULONG CurrentTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetTimerResolution(
    _In_ ULONG DesiredTime,
    _In_ BOOLEAN SetResolution,
    _Out_ PULONG ActualTime
    );

// Performance Counter

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryPerformanceCounter(
    _Out_ PLARGE_INTEGER PerformanceCounter,
    _Out_opt_ PLARGE_INTEGER PerformanceFrequency
    );

// LUIDs

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateLocallyUniqueId(
    _Out_ PLUID Luid
    );

// UUIDs

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetUuidSeed(
    _In_ PCHAR Seed
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateUuids(
    _Out_ PULARGE_INTEGER Time,
    _Out_ PULONG Range,
    _Out_ PULONG Sequence,
    _Out_ PCHAR Seed
    );

// System Information

#endif // (PHNT_MODE != PHNT_MODE_KERNEL)

// rev
// private
typedef enum _SYSTEM_INFORMATION_CLASS
{
    SystemBasicInformation, // q: SYSTEM_BASIC_INFORMATION
    SystemProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION
    SystemPerformanceInformation, // q: SYSTEM_PERFORMANCE_INFORMATION
    SystemTimeOfDayInformation, // q: SYSTEM_TIMEOFDAY_INFORMATION
    SystemPathInformation, // not implemented
    SystemProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
    SystemCallCountInformation, // q: SYSTEM_CALL_COUNT_INFORMATION
    SystemDeviceInformation, // q: SYSTEM_DEVICE_INFORMATION
    SystemProcessorPerformanceInformation, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemFlagsInformation, // q: SYSTEM_FLAGS_INFORMATION
    SystemCallTimeInformation, // not implemented // SYSTEM_CALL_TIME_INFORMATION // 10
    SystemModuleInformation, // q: RTL_PROCESS_MODULES
    SystemLocksInformation, // q: RTL_PROCESS_LOCKS
    SystemStackTraceInformation, // q: RTL_PROCESS_BACKTRACES
    SystemPagedPoolInformation, // not implemented
    SystemNonPagedPoolInformation, // not implemented
    SystemHandleInformation, // q: SYSTEM_HANDLE_INFORMATION
    SystemObjectInformation, // q: SYSTEM_OBJECTTYPE_INFORMATION mixed with SYSTEM_OBJECT_INFORMATION
    SystemPageFileInformation, // q: SYSTEM_PAGEFILE_INFORMATION
    SystemVdmInstemulInformation, // q: SYSTEM_VDM_INSTEMUL_INFO
    SystemVdmBopInformation, // not implemented // 20
    SystemFileCacheInformation, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemCache)
    SystemPoolTagInformation, // q: SYSTEM_POOLTAG_INFORMATION
    SystemInterruptInformation, // q: SYSTEM_INTERRUPT_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemDpcBehaviorInformation, // q: SYSTEM_DPC_BEHAVIOR_INFORMATION; s: SYSTEM_DPC_BEHAVIOR_INFORMATION (requires SeLoadDriverPrivilege)
    SystemFullMemoryInformation, // not implemented // SYSTEM_MEMORY_USAGE_INFORMATION
    SystemLoadGdiDriverInformation, // s (kernel-mode only)
    SystemUnloadGdiDriverInformation, // s (kernel-mode only)
    SystemTimeAdjustmentInformation, // q: SYSTEM_QUERY_TIME_ADJUST_INFORMATION; s: SYSTEM_SET_TIME_ADJUST_INFORMATION (requires SeSystemtimePrivilege)
    SystemSummaryMemoryInformation, // not implemented // SYSTEM_MEMORY_USAGE_INFORMATION
    SystemMirrorMemoryInformation, // s (requires license value "Kernel-MemoryMirroringSupported") (requires SeShutdownPrivilege) // 30
    SystemPerformanceTraceInformation, // q; s: (type depends on EVENT_TRACE_INFORMATION_CLASS)
    SystemObsolete0, // not implemented
    SystemExceptionInformation, // q: SYSTEM_EXCEPTION_INFORMATION
    SystemCrashDumpStateInformation, // s: SYSTEM_CRASH_DUMP_STATE_INFORMATION (requires SeDebugPrivilege)
    SystemKernelDebuggerInformation, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION
    SystemContextSwitchInformation, // q: SYSTEM_CONTEXT_SWITCH_INFORMATION
    SystemRegistryQuotaInformation, // q: SYSTEM_REGISTRY_QUOTA_INFORMATION; s (requires SeIncreaseQuotaPrivilege)
    SystemExtendServiceTableInformation, // s (requires SeLoadDriverPrivilege) // loads win32k only
    SystemPrioritySeperation, // s (requires SeTcbPrivilege)
    SystemVerifierAddDriverInformation, // s (requires SeDebugPrivilege) // 40
    SystemVerifierRemoveDriverInformation, // s (requires SeDebugPrivilege)
    SystemProcessorIdleInformation, // q: SYSTEM_PROCESSOR_IDLE_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemLegacyDriverInformation, // q: SYSTEM_LEGACY_DRIVER_INFORMATION
    SystemCurrentTimeZoneInformation, // q; s: RTL_TIME_ZONE_INFORMATION
    SystemLookasideInformation, // q: SYSTEM_LOOKASIDE_INFORMATION
    SystemTimeSlipNotification, // s: HANDLE (NtCreateEvent) (requires SeSystemtimePrivilege)
    SystemSessionCreate, // not implemented
    SystemSessionDetach, // not implemented
    SystemSessionInformation, // not implemented (SYSTEM_SESSION_INFORMATION)
    SystemRangeStartInformation, // q: SYSTEM_RANGE_START_INFORMATION // 50
    SystemVerifierInformation, // q: SYSTEM_VERIFIER_INFORMATION; s (requires SeDebugPrivilege)
    SystemVerifierThunkExtend, // s (kernel-mode only)
    SystemSessionProcessInformation, // q: SYSTEM_SESSION_PROCESS_INFORMATION
    SystemLoadGdiDriverInSystemSpace, // s: SYSTEM_GDI_DRIVER_INFORMATION (kernel-mode only) (same as SystemLoadGdiDriverInformation)
    SystemNumaProcessorMap, // q: SYSTEM_NUMA_INFORMATION
    SystemPrefetcherInformation, // q; s: PREFETCHER_INFORMATION // PfSnQueryPrefetcherInformation
    SystemExtendedProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
    SystemRecommendedSharedDataAlignment, // q: ULONG // KeGetRecommendedSharedDataAlignment
    SystemComPlusPackage, // q; s: ULONG
    SystemNumaAvailableMemory, // q: SYSTEM_NUMA_INFORMATION // 60
    SystemProcessorPowerInformation, // q: SYSTEM_PROCESSOR_POWER_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemEmulationBasicInformation, // q: SYSTEM_BASIC_INFORMATION
    SystemEmulationProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION
    SystemExtendedHandleInformation, // q: SYSTEM_HANDLE_INFORMATION_EX
    SystemLostDelayedWriteInformation, // q: ULONG
    SystemBigPoolInformation, // q: SYSTEM_BIGPOOL_INFORMATION
    SystemSessionPoolTagInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION
    SystemSessionMappedViewInformation, // q: SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
    SystemHotpatchInformation, // q; s: SYSTEM_HOTPATCH_CODE_INFORMATION
    SystemObjectSecurityMode, // q: ULONG // 70
    SystemWatchdogTimerHandler, // s: SYSTEM_WATCHDOG_HANDLER_INFORMATION // (kernel-mode only)
    SystemWatchdogTimerInformation, // q: SYSTEM_WATCHDOG_TIMER_INFORMATION // (kernel-mode only)
    SystemLogicalProcessorInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemWow64SharedInformationObsolete, // not implemented
    SystemRegisterFirmwareTableInformationHandler, // s: SYSTEM_FIRMWARE_TABLE_HANDLER // (kernel-mode only)
    SystemFirmwareTableInformation, // SYSTEM_FIRMWARE_TABLE_INFORMATION
    SystemModuleInformationEx, // q: RTL_PROCESS_MODULE_INFORMATION_EX
    SystemVerifierTriageInformation, // not implemented
    SystemSuperfetchInformation, // q; s: SUPERFETCH_INFORMATION // PfQuerySuperfetchInformation
    SystemMemoryListInformation, // q: SYSTEM_MEMORY_LIST_INFORMATION; s: SYSTEM_MEMORY_LIST_COMMAND (requires SeProfileSingleProcessPrivilege) // 80
    SystemFileCacheInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (same as SystemFileCacheInformation)
    SystemThreadPriorityClientIdInformation, // s: SYSTEM_THREAD_CID_PRIORITY_INFORMATION (requires SeIncreaseBasePriorityPrivilege)
    SystemProcessorIdleCycleTimeInformation, // q: SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION[] (EX in: USHORT ProcessorGroup)
    SystemVerifierCancellationInformation, // SYSTEM_VERIFIER_CANCELLATION_INFORMATION // name:wow64:whNT32QuerySystemVerifierCancellationInformation
    SystemProcessorPowerInformationEx, // not implemented
    SystemRefTraceInformation, // q; s: SYSTEM_REF_TRACE_INFORMATION // ObQueryRefTraceInformation
    SystemSpecialPoolInformation, // q; s: SYSTEM_SPECIAL_POOL_INFORMATION (requires SeDebugPrivilege) // MmSpecialPoolTag, then MmSpecialPoolCatchOverruns != 0
    SystemProcessIdInformation, // q: SYSTEM_PROCESS_ID_INFORMATION
    SystemErrorPortInformation, // s (requires SeTcbPrivilege)
    SystemBootEnvironmentInformation, // q: SYSTEM_BOOT_ENVIRONMENT_INFORMATION // 90
    SystemHypervisorInformation, // q: SYSTEM_HYPERVISOR_QUERY_INFORMATION
    SystemVerifierInformationEx, // q; s: SYSTEM_VERIFIER_INFORMATION_EX
    SystemTimeZoneInformation, // q; s: RTL_TIME_ZONE_INFORMATION (requires SeTimeZonePrivilege)
    SystemImageFileExecutionOptionsInformation, // s: SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION (requires SeTcbPrivilege)
    SystemCoverageInformation, // q: COVERAGE_MODULES s: COVERAGE_MODULE_REQUEST // ExpCovQueryInformation (requires SeDebugPrivilege)
    SystemPrefetchPatchInformation, // SYSTEM_PREFETCH_PATCH_INFORMATION
    SystemVerifierFaultsInformation, // s: SYSTEM_VERIFIER_FAULTS_INFORMATION (requires SeDebugPrivilege)
    SystemSystemPartitionInformation, // q: SYSTEM_SYSTEM_PARTITION_INFORMATION
    SystemSystemDiskInformation, // q: SYSTEM_SYSTEM_DISK_INFORMATION
    SystemProcessorPerformanceDistribution, // q: SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION (EX in: USHORT ProcessorGroup) // 100
    SystemNumaProximityNodeInformation, // q; s: SYSTEM_NUMA_PROXIMITY_MAP
    SystemDynamicTimeZoneInformation, // q; s: RTL_DYNAMIC_TIME_ZONE_INFORMATION (requires SeTimeZonePrivilege)
    SystemCodeIntegrityInformation, // q: SYSTEM_CODEINTEGRITY_INFORMATION // SeCodeIntegrityQueryInformation
    SystemProcessorMicrocodeUpdateInformation, // s: SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION
    SystemProcessorBrandString, // q: CHAR[] // HaliQuerySystemInformation -> HalpGetProcessorBrandString, info class 23
    SystemVirtualAddressInformation, // q: SYSTEM_VA_LIST_INFORMATION[]; s: SYSTEM_VA_LIST_INFORMATION[] (requires SeIncreaseQuotaPrivilege) // MmQuerySystemVaInformation
    SystemLogicalProcessorAndGroupInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX (EX in: LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType) // since WIN7 // KeQueryLogicalProcessorRelationship
    SystemProcessorCycleTimeInformation, // q: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION[] (EX in: USHORT ProcessorGroup)
    SystemStoreInformation, // q; s: SYSTEM_STORE_INFORMATION (requires SeProfileSingleProcessPrivilege) // SmQueryStoreInformation
    SystemRegistryAppendString, // s: SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS // 110
    SystemAitSamplingValue, // s: ULONG (requires SeProfileSingleProcessPrivilege)
    SystemVhdBootInformation, // q: SYSTEM_VHD_BOOT_INFORMATION
    SystemCpuQuotaInformation, // q; s: PS_CPU_QUOTA_QUERY_INFORMATION
    SystemNativeBasicInformation, // q: SYSTEM_BASIC_INFORMATION
    SystemErrorPortTimeouts, // SYSTEM_ERROR_PORT_TIMEOUTS
    SystemLowPriorityIoInformation, // q: SYSTEM_LOW_PRIORITY_IO_INFORMATION
    SystemTpmBootEntropyInformation, // q: TPM_BOOT_ENTROPY_NT_RESULT // ExQueryTpmBootEntropyInformation
    SystemVerifierCountersInformation, // q: SYSTEM_VERIFIER_COUNTERS_INFORMATION
    SystemPagedPoolInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypePagedPool)
    SystemSystemPtesInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemPtes) // 120
    SystemNodeDistanceInformation, // q: USHORT[4*NumaNodes] // (EX in: USHORT NodeNumber)
    SystemAcpiAuditInformation, // q: SYSTEM_ACPI_AUDIT_INFORMATION // HaliQuerySystemInformation -> HalpAuditQueryResults, info class 26
    SystemBasicPerformanceInformation, // q: SYSTEM_BASIC_PERFORMANCE_INFORMATION // name:wow64:whNtQuerySystemInformation_SystemBasicPerformanceInformation
    SystemQueryPerformanceCounterInformation, // q: SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION // since WIN7 SP1
    SystemSessionBigPoolInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION // since WIN8
    SystemBootGraphicsInformation, // q; s: SYSTEM_BOOT_GRAPHICS_INFORMATION (kernel-mode only)
    SystemScrubPhysicalMemoryInformation, // q; s: MEMORY_SCRUB_INFORMATION
    SystemBadPageInformation,
    SystemProcessorProfileControlArea, // q; s: SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA
    SystemCombinePhysicalMemoryInformation, // s: MEMORY_COMBINE_INFORMATION, MEMORY_COMBINE_INFORMATION_EX, MEMORY_COMBINE_INFORMATION_EX2 // 130
    SystemEntropyInterruptTimingInformation, // q; s: SYSTEM_ENTROPY_TIMING_INFORMATION
    SystemConsoleInformation, // q; s: SYSTEM_CONSOLE_INFORMATION
    SystemPlatformBinaryInformation, // q: SYSTEM_PLATFORM_BINARY_INFORMATION (requires SeTcbPrivilege)
    SystemPolicyInformation, // q: SYSTEM_POLICY_INFORMATION
    SystemHypervisorProcessorCountInformation, // q: SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION
    SystemDeviceDataInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemDeviceDataEnumerationInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemMemoryTopologyInformation, // q: SYSTEM_MEMORY_TOPOLOGY_INFORMATION
    SystemMemoryChannelInformation, // q: SYSTEM_MEMORY_CHANNEL_INFORMATION
    SystemBootLogoInformation, // q: SYSTEM_BOOT_LOGO_INFORMATION // 140
    SystemProcessorPerformanceInformationEx, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX // (EX in: USHORT ProcessorGroup) // since WINBLUE
    SystemCriticalProcessErrorLogInformation,
    SystemSecureBootPolicyInformation, // q: SYSTEM_SECUREBOOT_POLICY_INFORMATION
    SystemPageFileInformationEx, // q: SYSTEM_PAGEFILE_INFORMATION_EX
    SystemSecureBootInformation, // q: SYSTEM_SECUREBOOT_INFORMATION
    SystemEntropyInterruptTimingRawInformation,
    SystemPortableWorkspaceEfiLauncherInformation, // q: SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION
    SystemFullProcessInformation, // q: SYSTEM_PROCESS_INFORMATION with SYSTEM_PROCESS_INFORMATION_EXTENSION (requires admin)
    SystemKernelDebuggerInformationEx, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
    SystemBootMetadataInformation, // 150
    SystemSoftRebootInformation, // q: ULONG
    SystemElamCertificateInformation, // s: SYSTEM_ELAM_CERTIFICATE_INFORMATION
    SystemOfflineDumpConfigInformation, // q: OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2
    SystemProcessorFeaturesInformation, // q: SYSTEM_PROCESSOR_FEATURES_INFORMATION
    SystemRegistryReconciliationInformation, // s: NULL (requires admin) (flushes registry hives)
    SystemEdidInformation, // q: SYSTEM_EDID_INFORMATION
    SystemManufacturingInformation, // q: SYSTEM_MANUFACTURING_INFORMATION // since THRESHOLD
    SystemEnergyEstimationConfigInformation, // q: SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION
    SystemHypervisorDetailInformation, // q: SYSTEM_HYPERVISOR_DETAIL_INFORMATION
    SystemProcessorCycleStatsInformation, // q: SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION (EX in: USHORT ProcessorGroup) // 160
    SystemVmGenerationCountInformation,
    SystemTrustedPlatformModuleInformation, // q: SYSTEM_TPM_INFORMATION
    SystemKernelDebuggerFlags, // SYSTEM_KERNEL_DEBUGGER_FLAGS
    SystemCodeIntegrityPolicyInformation, // q: SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
    SystemIsolatedUserModeInformation, // q: SYSTEM_ISOLATED_USER_MODE_INFORMATION
    SystemHardwareSecurityTestInterfaceResultsInformation,
    SystemSingleModuleInformation, // q: SYSTEM_SINGLE_MODULE_INFORMATION
    SystemAllowedCpuSetsInformation,
    SystemVsmProtectionInformation, // q: SYSTEM_VSM_PROTECTION_INFORMATION (previously SystemDmaProtectionInformation)
    SystemInterruptCpuSetsInformation, // q: SYSTEM_INTERRUPT_CPU_SET_INFORMATION // 170
    SystemSecureBootPolicyFullInformation, // q: SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
    SystemCodeIntegrityPolicyFullInformation,
    SystemAffinitizedInterruptProcessorInformation, // (requires SeIncreaseBasePriorityPrivilege)
    SystemRootSiloInformation, // q: SYSTEM_ROOT_SILO_INFORMATION
    SystemCpuSetInformation, // q: SYSTEM_CPU_SET_INFORMATION // since THRESHOLD2
    SystemCpuSetTagInformation, // q: SYSTEM_CPU_SET_TAG_INFORMATION
    SystemWin32WerStartCallout,
    SystemSecureKernelProfileInformation, // q: SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION
    SystemCodeIntegrityPlatformManifestInformation, // q: SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION // since REDSTONE
    SystemInterruptSteeringInformation, // SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT // 180
    SystemSupportedProcessorArchitectures, // p: in opt: HANDLE, out: SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION[] // NtQuerySystemInformationEx
    SystemMemoryUsageInformation, // q: SYSTEM_MEMORY_USAGE_INFORMATION
    SystemCodeIntegrityCertificateInformation, // q: SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
    SystemPhysicalMemoryInformation, // q: SYSTEM_PHYSICAL_MEMORY_INFORMATION // since REDSTONE2
    SystemControlFlowTransition,
    SystemKernelDebuggingAllowed, // s: ULONG
    SystemActivityModerationExeState, // SYSTEM_ACTIVITY_MODERATION_EXE_STATE
    SystemActivityModerationUserSettings, // SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS
    SystemCodeIntegrityPoliciesFullInformation,
    SystemCodeIntegrityUnlockInformation, // SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION // 190
    SystemIntegrityQuotaInformation,
    SystemFlushInformation, // q: SYSTEM_FLUSH_INFORMATION
    SystemProcessorIdleMaskInformation, // q: ULONG_PTR[ActiveGroupCount] // since REDSTONE3
    SystemSecureDumpEncryptionInformation,
    SystemWriteConstraintInformation, // SYSTEM_WRITE_CONSTRAINT_INFORMATION
    SystemKernelVaShadowInformation, // SYSTEM_KERNEL_VA_SHADOW_INFORMATION
    SystemHypervisorSharedPageInformation, // SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION // since REDSTONE4
    SystemFirmwareBootPerformanceInformation,
    SystemCodeIntegrityVerificationInformation, // SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION
    SystemFirmwarePartitionInformation, // SYSTEM_FIRMWARE_PARTITION_INFORMATION // 200
    SystemSpeculationControlInformation, // SYSTEM_SPECULATION_CONTROL_INFORMATION // (CVE-2017-5715) REDSTONE3 and above.
    SystemDmaGuardPolicyInformation, // SYSTEM_DMA_GUARD_POLICY_INFORMATION
    SystemEnclaveLaunchControlInformation, // SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION
    SystemWorkloadAllowedCpuSetsInformation, // SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION // since REDSTONE5
    SystemCodeIntegrityUnlockModeInformation,
    SystemLeapSecondInformation, // SYSTEM_LEAP_SECOND_INFORMATION
    SystemFlags2Information, // q: SYSTEM_FLAGS_INFORMATION
    SystemSecurityModelInformation, // SYSTEM_SECURITY_MODEL_INFORMATION // since 19H1
    SystemCodeIntegritySyntheticCacheInformation,
    SystemFeatureConfigurationInformation, // SYSTEM_FEATURE_CONFIGURATION_INFORMATION // since 20H1 // 210
    SystemFeatureConfigurationSectionInformation, // SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION
    SystemFeatureUsageSubscriptionInformation, // SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS
    SystemSecureSpeculationControlInformation, // SECURE_SPECULATION_CONTROL_INFORMATION
    SystemSpacesBootInformation, // since 20H2
    SystemFwRamdiskInformation, // SYSTEM_FIRMWARE_RAMDISK_INFORMATION
    SystemWheaIpmiHardwareInformation,
    SystemDifSetRuleClassInformation,
    SystemDifClearRuleClassInformation,
    SystemDifApplyPluginVerificationOnDriver,
    SystemDifRemovePluginVerificationOnDriver, // 220
    SystemShadowStackInformation, // SYSTEM_SHADOW_STACK_INFORMATION
    SystemBuildVersionInformation, // SYSTEM_BUILD_VERSION_INFORMATION
    SystemPoolLimitInformation, // SYSTEM_POOL_LIMIT_INFORMATION
    SystemCodeIntegrityAddDynamicStore,
    SystemCodeIntegrityClearDynamicStores,
    SystemDifPoolTrackingInformation,
    SystemPoolZeroingInformation, // SYSTEM_POOL_ZEROING_INFORMATION
    SystemDpcWatchdogInformation,
    SystemDpcWatchdogInformation2,
    SystemSupportedProcessorArchitectures2, // q: in opt: HANDLE, out: SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION[] // NtQuerySystemInformationEx  // 230
    SystemSingleProcessorRelationshipInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX // (EX in: PROCESSOR_NUMBER Processor)
    SystemXfgCheckFailureInformation,
    SystemIommuStateInformation, // SYSTEM_IOMMU_STATE_INFORMATION // since 22H1
    SystemHypervisorMinrootInformation, // SYSTEM_HYPERVISOR_MINROOT_INFORMATION
    SystemHypervisorBootPagesInformation, // SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION
    SystemPointerAuthInformation, // SYSTEM_POINTER_AUTH_INFORMATION
    SystemSecureKernelDebuggerInformation,
    SystemOriginalImageFeatureInformation,
    MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_BASIC_INFORMATION
{
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG_PTR MinimumUserModeAddress;
    ULONG_PTR MaximumUserModeAddress;
    KAFFINITY ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_INFORMATION
{
    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;
    USHORT MaximumProcessors;
    ULONG ProcessorFeatureBits;
} SYSTEM_PROCESSOR_INFORMATION, *PSYSTEM_PROCESSOR_INFORMATION;

typedef struct _SYSTEM_PERFORMANCE_INFORMATION
{
    LARGE_INTEGER IdleProcessTime;
    LARGE_INTEGER IoReadTransferCount;
    LARGE_INTEGER IoWriteTransferCount;
    LARGE_INTEGER IoOtherTransferCount;
    ULONG IoReadOperationCount;
    ULONG IoWriteOperationCount;
    ULONG IoOtherOperationCount;
    ULONG AvailablePages;
    ULONG CommittedPages;
    ULONG CommitLimit;
    ULONG PeakCommitment;
    ULONG PageFaultCount;
    ULONG CopyOnWriteCount;
    ULONG TransitionCount;
    ULONG CacheTransitionCount;
    ULONG DemandZeroCount;
    ULONG PageReadCount;
    ULONG PageReadIoCount;
    ULONG CacheReadCount;
    ULONG CacheIoCount;
    ULONG DirtyPagesWriteCount;
    ULONG DirtyWriteIoCount;
    ULONG MappedPagesWriteCount;
    ULONG MappedWriteIoCount;
    ULONG PagedPoolPages;
    ULONG NonPagedPoolPages;
    ULONG PagedPoolAllocs;
    ULONG PagedPoolFrees;
    ULONG NonPagedPoolAllocs;
    ULONG NonPagedPoolFrees;
    ULONG FreeSystemPtes;
    ULONG ResidentSystemCodePage;
    ULONG TotalSystemDriverPages;
    ULONG TotalSystemCodePages;
    ULONG NonPagedPoolLookasideHits;
    ULONG PagedPoolLookasideHits;
    ULONG AvailablePagedPoolPages;
    ULONG ResidentSystemCachePage;
    ULONG ResidentPagedPoolPage;
    ULONG ResidentSystemDriverPage;
    ULONG CcFastReadNoWait;
    ULONG CcFastReadWait;
    ULONG CcFastReadResourceMiss;
    ULONG CcFastReadNotPossible;
    ULONG CcFastMdlReadNoWait;
    ULONG CcFastMdlReadWait;
    ULONG CcFastMdlReadResourceMiss;
    ULONG CcFastMdlReadNotPossible;
    ULONG CcMapDataNoWait;
    ULONG CcMapDataWait;
    ULONG CcMapDataNoWaitMiss;
    ULONG CcMapDataWaitMiss;
    ULONG CcPinMappedDataCount;
    ULONG CcPinReadNoWait;
    ULONG CcPinReadWait;
    ULONG CcPinReadNoWaitMiss;
    ULONG CcPinReadWaitMiss;
    ULONG CcCopyReadNoWait;
    ULONG CcCopyReadWait;
    ULONG CcCopyReadNoWaitMiss;
    ULONG CcCopyReadWaitMiss;
    ULONG CcMdlReadNoWait;
    ULONG CcMdlReadWait;
    ULONG CcMdlReadNoWaitMiss;
    ULONG CcMdlReadWaitMiss;
    ULONG CcReadAheadIos;
    ULONG CcLazyWriteIos;
    ULONG CcLazyWritePages;
    ULONG CcDataFlushes;
    ULONG CcDataPages;
    ULONG ContextSwitches;
    ULONG FirstLevelTbFills;
    ULONG SecondLevelTbFills;
    ULONG SystemCalls;
    ULONGLONG CcTotalDirtyPages; // since THRESHOLD
    ULONGLONG CcDirtyPageThreshold; // since THRESHOLD
    LONGLONG ResidentAvailablePages; // since THRESHOLD
    ULONGLONG SharedCommittedPages; // since THRESHOLD
} SYSTEM_PERFORMANCE_INFORMATION, *PSYSTEM_PERFORMANCE_INFORMATION;

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION
{
    LARGE_INTEGER BootTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeZoneBias;
    ULONG TimeZoneId;
    ULONG Reserved;
    ULONGLONG BootTimeBias;
    ULONGLONG SleepTimeBias;
} SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;

typedef struct _SYSTEM_THREAD_INFORMATION
{
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    KPRIORITY BasePriority;
    ULONG ContextSwitches;
    KTHREAD_STATE ThreadState;
    KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _TEB *PTEB;

// private
typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION
{
    SYSTEM_THREAD_INFORMATION ThreadInfo;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID Win32StartAddress;
    PTEB TebBase; // since VISTA
    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;
} SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER WorkingSetPrivateSize; // since VISTA
    ULONG HardFaultCount; // since WIN7
    ULONG NumberOfThreadsHighWatermark; // since WIN7
    ULONGLONG CycleTime; // since WIN7
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR UniqueProcessKey; // since VISTA (requires SystemExtendedProcessInformation)
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
    SYSTEM_THREAD_INFORMATION Threads[1]; // SystemProcessInformation
    // SYSTEM_EXTENDED_THREAD_INFORMATION Threads[1]; // SystemExtendedProcessinformation
    // SYSTEM_EXTENDED_THREAD_INFORMATION + SYSTEM_PROCESS_INFORMATION_EXTENSION // SystemFullProcessInformation
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef struct _SYSTEM_CALL_COUNT_INFORMATION
{
    ULONG Length;
    ULONG NumberOfTables;
} SYSTEM_CALL_COUNT_INFORMATION, *PSYSTEM_CALL_COUNT_INFORMATION;

typedef struct _SYSTEM_DEVICE_INFORMATION
{
    ULONG NumberOfDisks;
    ULONG NumberOfFloppies;
    ULONG NumberOfCdRoms;
    ULONG NumberOfTapes;
    ULONG NumberOfSerialPorts;
    ULONG NumberOfParallelPorts;
} SYSTEM_DEVICE_INFORMATION, *PSYSTEM_DEVICE_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
{
    LARGE_INTEGER IdleTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER DpcTime;
    LARGE_INTEGER InterruptTime;
    ULONG InterruptCount;
} SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION, *PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;

typedef struct _SYSTEM_FLAGS_INFORMATION
{
    ULONG Flags; // NtGlobalFlag
} SYSTEM_FLAGS_INFORMATION, *PSYSTEM_FLAGS_INFORMATION;

// private
typedef struct _SYSTEM_CALL_TIME_INFORMATION
{
    ULONG Length;
    ULONG TotalCalls;
    LARGE_INTEGER TimeOfCalls[1];
} SYSTEM_CALL_TIME_INFORMATION, *PSYSTEM_CALL_TIME_INFORMATION;

// private
typedef struct _RTL_PROCESS_LOCK_INFORMATION
{
    PVOID Address;
    USHORT Type;
    USHORT CreatorBackTraceIndex;
    HANDLE OwningThread;
    LONG LockCount;
    ULONG ContentionCount;
    ULONG EntryCount;
    LONG RecursionCount;
    ULONG NumberOfWaitingShared;
    ULONG NumberOfWaitingExclusive;
} RTL_PROCESS_LOCK_INFORMATION, *PRTL_PROCESS_LOCK_INFORMATION;

// private
typedef struct _RTL_PROCESS_LOCKS
{
    ULONG NumberOfLocks;
    RTL_PROCESS_LOCK_INFORMATION Locks[1];
} RTL_PROCESS_LOCKS, *PRTL_PROCESS_LOCKS;

// private
typedef struct _RTL_PROCESS_BACKTRACE_INFORMATION
{
    PCHAR SymbolicBackTrace;
    ULONG TraceCount;
    USHORT Index;
    USHORT Depth;
    PVOID BackTrace[32];
} RTL_PROCESS_BACKTRACE_INFORMATION, *PRTL_PROCESS_BACKTRACE_INFORMATION;

// private
typedef struct _RTL_PROCESS_BACKTRACES
{
    ULONG CommittedMemory;
    ULONG ReservedMemory;
    ULONG NumberOfBackTraceLookups;
    ULONG NumberOfBackTraces;
    RTL_PROCESS_BACKTRACE_INFORMATION BackTraces[1];
} RTL_PROCESS_BACKTRACES, *PRTL_PROCESS_BACKTRACES;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_OBJECTTYPE_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG NumberOfObjects;
    ULONG NumberOfHandles;
    ULONG TypeIndex;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG PoolType;
    BOOLEAN SecurityRequired;
    BOOLEAN WaitableObject;
    UNICODE_STRING TypeName;
} SYSTEM_OBJECTTYPE_INFORMATION, *PSYSTEM_OBJECTTYPE_INFORMATION;

typedef struct _SYSTEM_OBJECT_INFORMATION
{
    ULONG NextEntryOffset;
    PVOID Object;
    HANDLE CreatorUniqueProcess;
    USHORT CreatorBackTraceIndex;
    USHORT Flags;
    LONG PointerCount;
    LONG HandleCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    HANDLE ExclusiveProcessId;
    PVOID SecurityDescriptor;
    UNICODE_STRING NameInfo;
} SYSTEM_OBJECT_INFORMATION, *PSYSTEM_OBJECT_INFORMATION;

typedef struct _SYSTEM_PAGEFILE_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG TotalSize;
    ULONG TotalInUse;
    ULONG PeakUsage;
    UNICODE_STRING PageFileName;
} SYSTEM_PAGEFILE_INFORMATION, *PSYSTEM_PAGEFILE_INFORMATION;

typedef struct _SYSTEM_VDM_INSTEMUL_INFO
{
    ULONG SegmentNotPresent;
    ULONG VdmOpcode0F;
    ULONG OpcodeESPrefix;
    ULONG OpcodeCSPrefix;
    ULONG OpcodeSSPrefix;
    ULONG OpcodeDSPrefix;
    ULONG OpcodeFSPrefix;
    ULONG OpcodeGSPrefix;
    ULONG OpcodeOPER32Prefix;
    ULONG OpcodeADDR32Prefix;
    ULONG OpcodeINSB;
    ULONG OpcodeINSW;
    ULONG OpcodeOUTSB;
    ULONG OpcodeOUTSW;
    ULONG OpcodePUSHF;
    ULONG OpcodePOPF;
    ULONG OpcodeINTnn;
    ULONG OpcodeINTO;
    ULONG OpcodeIRET;
    ULONG OpcodeINBimm;
    ULONG OpcodeINWimm;
    ULONG OpcodeOUTBimm;
    ULONG OpcodeOUTWimm;
    ULONG OpcodeINB;
    ULONG OpcodeINW;
    ULONG OpcodeOUTB;
    ULONG OpcodeOUTW;
    ULONG OpcodeLOCKPrefix;
    ULONG OpcodeREPNEPrefix;
    ULONG OpcodeREPPrefix;
    ULONG OpcodeHLT;
    ULONG OpcodeCLI;
    ULONG OpcodeSTI;
    ULONG BopCount;
} SYSTEM_VDM_INSTEMUL_INFO, *PSYSTEM_VDM_INSTEMUL_INFO;

#define MM_WORKING_SET_MAX_HARD_ENABLE 0x1
#define MM_WORKING_SET_MAX_HARD_DISABLE 0x2
#define MM_WORKING_SET_MIN_HARD_ENABLE 0x4
#define MM_WORKING_SET_MIN_HARD_DISABLE 0x8

typedef struct _SYSTEM_FILECACHE_INFORMATION
{
    SIZE_T CurrentSize;
    SIZE_T PeakSize;
    ULONG PageFaultCount;
    SIZE_T MinimumWorkingSet;
    SIZE_T MaximumWorkingSet;
    SIZE_T CurrentSizeIncludingTransitionInPages;
    SIZE_T PeakSizeIncludingTransitionInPages;
    ULONG TransitionRePurposeCount;
    ULONG Flags;
} SYSTEM_FILECACHE_INFORMATION, *PSYSTEM_FILECACHE_INFORMATION;

// Can be used instead of SYSTEM_FILECACHE_INFORMATION
typedef struct _SYSTEM_BASIC_WORKING_SET_INFORMATION
{
    SIZE_T CurrentSize;
    SIZE_T PeakSize;
    ULONG PageFaultCount;
} SYSTEM_BASIC_WORKING_SET_INFORMATION, *PSYSTEM_BASIC_WORKING_SET_INFORMATION;

typedef struct _SYSTEM_POOLTAG
{
    union
    {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    ULONG PagedAllocs;
    ULONG PagedFrees;
    SIZE_T PagedUsed;
    ULONG NonPagedAllocs;
    ULONG NonPagedFrees;
    SIZE_T NonPagedUsed;
} SYSTEM_POOLTAG, *PSYSTEM_POOLTAG;

typedef struct _SYSTEM_POOLTAG_INFORMATION
{
    ULONG Count;
    SYSTEM_POOLTAG TagInfo[1];
} SYSTEM_POOLTAG_INFORMATION, *PSYSTEM_POOLTAG_INFORMATION;

typedef struct _SYSTEM_INTERRUPT_INFORMATION
{
    ULONG ContextSwitches;
    ULONG DpcCount;
    ULONG DpcRate;
    ULONG TimeIncrement;
    ULONG DpcBypassCount;
    ULONG ApcBypassCount;
} SYSTEM_INTERRUPT_INFORMATION, *PSYSTEM_INTERRUPT_INFORMATION;

typedef struct _SYSTEM_DPC_BEHAVIOR_INFORMATION
{
    ULONG Spare;
    ULONG DpcQueueDepth;
    ULONG MinimumDpcRate;
    ULONG AdjustDpcThreshold;
    ULONG IdealDpcRate;
} SYSTEM_DPC_BEHAVIOR_INFORMATION, *PSYSTEM_DPC_BEHAVIOR_INFORMATION;

typedef struct _SYSTEM_QUERY_TIME_ADJUST_INFORMATION
{
    ULONG TimeAdjustment;
    ULONG TimeIncrement;
    BOOLEAN Enable;
} SYSTEM_QUERY_TIME_ADJUST_INFORMATION, *PSYSTEM_QUERY_TIME_ADJUST_INFORMATION;

typedef struct _SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE
{
    ULONGLONG TimeAdjustment;
    ULONGLONG TimeIncrement;
    BOOLEAN Enable;
} SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE, *PSYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE;

typedef struct _SYSTEM_SET_TIME_ADJUST_INFORMATION
{
    ULONG TimeAdjustment;
    BOOLEAN Enable;
} SYSTEM_SET_TIME_ADJUST_INFORMATION, *PSYSTEM_SET_TIME_ADJUST_INFORMATION;

typedef struct _SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE
{
    ULONGLONG TimeAdjustment;
    BOOLEAN Enable;
} SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE, *PSYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE;

#ifndef _TRACEHANDLE_DEFINED
#define _TRACEHANDLE_DEFINED
typedef ULONG64 TRACEHANDLE, *PTRACEHANDLE;
#endif

typedef enum _EVENT_TRACE_INFORMATION_CLASS
{
    EventTraceKernelVersionInformation, // EVENT_TRACE_VERSION_INFORMATION
    EventTraceGroupMaskInformation, // EVENT_TRACE_GROUPMASK_INFORMATION
    EventTracePerformanceInformation, // EVENT_TRACE_PERFORMANCE_INFORMATION
    EventTraceTimeProfileInformation, // EVENT_TRACE_TIME_PROFILE_INFORMATION
    EventTraceSessionSecurityInformation, // EVENT_TRACE_SESSION_SECURITY_INFORMATION
    EventTraceSpinlockInformation, // EVENT_TRACE_SPINLOCK_INFORMATION
    EventTraceStackTracingInformation, // EVENT_TRACE_SYSTEM_EVENT_INFORMATION
    EventTraceExecutiveResourceInformation, // EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION
    EventTraceHeapTracingInformation, // EVENT_TRACE_HEAP_TRACING_INFORMATION
    EventTraceHeapSummaryTracingInformation, // EVENT_TRACE_HEAP_TRACING_INFORMATION
    EventTracePoolTagFilterInformation, // EVENT_TRACE_TAG_FILTER_INFORMATION
    EventTracePebsTracingInformation, // EVENT_TRACE_SYSTEM_EVENT_INFORMATION
    EventTraceProfileConfigInformation, // EVENT_TRACE_PROFILE_COUNTER_INFORMATION
    EventTraceProfileSourceListInformation, // EVENT_TRACE_PROFILE_LIST_INFORMATION
    EventTraceProfileEventListInformation, // EVENT_TRACE_SYSTEM_EVENT_INFORMATION
    EventTraceProfileCounterListInformation, // EVENT_TRACE_PROFILE_COUNTER_INFORMATION
    EventTraceStackCachingInformation, // EVENT_TRACE_STACK_CACHING_INFORMATION
    EventTraceObjectTypeFilterInformation, // EVENT_TRACE_TAG_FILTER_INFORMATION
    EventTraceSoftRestartInformation, // EVENT_TRACE_SOFT_RESTART_INFORMATION
    EventTraceLastBranchConfigurationInformation, // REDSTONE3
    EventTraceLastBranchEventListInformation,
    EventTraceProfileSourceAddInformation, // EVENT_TRACE_PROFILE_ADD_INFORMATION // REDSTONE4
    EventTraceProfileSourceRemoveInformation, // EVENT_TRACE_PROFILE_REMOVE_INFORMATION
    EventTraceProcessorTraceConfigurationInformation,
    EventTraceProcessorTraceEventListInformation,
    EventTraceCoverageSamplerInformation, // EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION
    EventTraceUnifiedStackCachingInformation, // sicne 21H1
    MaxEventTraceInfoClass
} EVENT_TRACE_INFORMATION_CLASS;

typedef struct _EVENT_TRACE_VERSION_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    ULONG EventTraceKernelVersion;
} EVENT_TRACE_VERSION_INFORMATION, *PEVENT_TRACE_VERSION_INFORMATION;

typedef struct _TRACE_ENABLE_FLAG_EXTENSION
{
    USHORT Offset; // Offset to the flag array in structure
    UCHAR Length; // Length of flag array in ULONGs
    UCHAR Flag; // Must be set to EVENT_TRACE_FLAG_EXTENSION
} TRACE_ENABLE_FLAG_EXTENSION, *PTRACE_ENABLE_FLAG_EXTENSION;

typedef struct _TRACE_ENABLE_FLAG_EXT_HEADER
{
    USHORT Length; // Length in ULONGs
    USHORT Items; // # of items
} TRACE_ENABLE_FLAG_EXT_HEADER, *PTRACE_ENABLE_FLAG_EXT_HEADER;

typedef struct _TRACE_ENABLE_FLAG_EXT_ITEM
{
    USHORT Offset; // Offset to the next block
    USHORT Type; // Extension type
} TRACE_ENABLE_FLAG_EXT_ITEM, *PTRACE_ENABLE_FLAG_EXT_ITEM;

#define EVENT_TRACE_FLAG_EXT_ITEMS 0x80FF0000    // New extension structure
#define EVENT_TRACE_FLAG_EXT_LEN_NEW_STRUCT 0xFF // Pseudo length to denote new struct format

#define ETW_MINIMUM_CACHED_STACK_LENGTH 4
#define ETW_SW_ARRAY_SIZE          256     // Frame Count allocated in lookaside list
#define ETW_STACK_SW_ARRAY_SIZE    192     // Frame Count allocated in stack
#define ETW_MAX_STACKWALK_FILTER   256 // Max number of HookId's
#define ETW_MAX_TAG_FILTER         4
#define ETW_MAX_POOLTAG_FILTER     ETW_MAX_TAG_FILTER

#define ETW_EXT_ENABLE_FLAGS       0x0001
#define ETW_EXT_PIDS               0x0002
#define ETW_EXT_STACKWALK_FILTER   0x0003
#define ETW_EXT_POOLTAG_FILTER     0x0004
#define ETW_EXT_STACK_CACHING      0x0005

// Extended item for configuring stack caching.
typedef struct _ETW_STACK_CACHING_CONFIG
{
    ULONG CacheSize;
    ULONG BucketCount;
} ETW_STACK_CACHING_CONFIG, *PETW_STACK_CACHING_CONFIG;

// The second bit is set if the trace is used by PM & CP (fixed headers)
// If not, the data block is used by for finer data for performance analysis
//
#define TRACE_HEADER_EVENT_TRACE 0x40000000
//
// If set, the data block is SYSTEM_TRACE_HEADER
//
#define TRACE_HEADER_ENUM_MASK 0x00FF0000

#define PERF_MASK_INDEX (0xe0000000)
#define PERF_MASK_GROUP (~PERF_MASK_INDEX)
#define PERF_NUM_MASKS 8

#define PERF_GET_MASK_INDEX(GM) (((GM) & PERF_MASK_INDEX) >> 29)
#define PERF_GET_MASK_GROUP(GM) ((GM) & PERF_MASK_GROUP)
#define PERFINFO_OR_GROUP_WITH_GROUPMASK(Group, pGroupMask) \
    (pGroupMask)->Masks[PERF_GET_MASK_INDEX(Group)] |= PERF_GET_MASK_GROUP(Group);

// Masks[0]
#define PERF_PROCESS            EVENT_TRACE_FLAG_PROCESS
#define PERF_THREAD             EVENT_TRACE_FLAG_THREAD
#define PERF_PROC_THREAD        EVENT_TRACE_FLAG_PROCESS | EVENT_TRACE_FLAG_THREAD
#define PERF_LOADER             EVENT_TRACE_FLAG_IMAGE_LOAD
#define PERF_PERF_COUNTER       EVENT_TRACE_FLAG_PROCESS_COUNTERS
#define PERF_FILENAME           EVENT_TRACE_FLAG_DISK_FILE_IO
#define PERF_DISK_IO            EVENT_TRACE_FLAG_DISK_FILE_IO | EVENT_TRACE_FLAG_DISK_IO
#define PERF_DISK_IO_INIT       EVENT_TRACE_FLAG_DISK_IO_INIT
#define PERF_ALL_FAULTS         EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS
#define PERF_HARD_FAULTS        EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS
#define PERF_VAMAP              EVENT_TRACE_FLAG_VAMAP
#define PERF_NETWORK            EVENT_TRACE_FLAG_NETWORK_TCPIP
#define PERF_REGISTRY           EVENT_TRACE_FLAG_REGISTRY
#define PERF_DBGPRINT           EVENT_TRACE_FLAG_DBGPRINT
#define PERF_JOB                EVENT_TRACE_FLAG_JOB
#define PERF_ALPC               EVENT_TRACE_FLAG_ALPC
#define PERF_SPLIT_IO           EVENT_TRACE_FLAG_SPLIT_IO
#define PERF_DEBUG_EVENTS       EVENT_TRACE_FLAG_DEBUG_EVENTS
#define PERF_FILE_IO            EVENT_TRACE_FLAG_FILE_IO
#define PERF_FILE_IO_INIT       EVENT_TRACE_FLAG_FILE_IO_INIT
#define PERF_NO_SYSCONFIG       EVENT_TRACE_FLAG_NO_SYSCONFIG

// Masks[1]
#define PERF_MEMORY             0x20000001
#define PERF_PROFILE            0x20000002  // equivalent to EVENT_TRACE_FLAG_PROFILE
#define PERF_CONTEXT_SWITCH     0x20000004  // equivalent to EVENT_TRACE_FLAG_CSWITCH
#define PERF_FOOTPRINT          0x20000008
#define PERF_DRIVERS            0x20000010  // equivalent to EVENT_TRACE_FLAG_DRIVER
#define PERF_REFSET             0x20000020
#define PERF_POOL               0x20000040
#define PERF_POOLTRACE          0x20000041
#define PERF_DPC                0x20000080  // equivalent to EVENT_TRACE_FLAG_DPC
#define PERF_COMPACT_CSWITCH    0x20000100
#define PERF_DISPATCHER         0x20000200  // equivalent to EVENT_TRACE_FLAG_DISPATCHER
#define PERF_PMC_PROFILE        0x20000400
#define PERF_PROFILING          0x20000402
#define PERF_PROCESS_INSWAP     0x20000800
#define PERF_AFFINITY           0x20001000
#define PERF_PRIORITY           0x20002000
#define PERF_INTERRUPT          0x20004000  // equivalent to EVENT_TRACE_FLAG_INTERRUPT
#define PERF_VIRTUAL_ALLOC      0x20008000  // equivalent to EVENT_TRACE_FLAG_VIRTUAL_ALLOC
#define PERF_SPINLOCK           0x20010000
#define PERF_SYNC_OBJECTS       0x20020000
#define PERF_DPC_QUEUE          0x20040000
#define PERF_MEMINFO            0x20080000
#define PERF_CONTMEM_GEN        0x20100000
#define PERF_SPINLOCK_CNTRS     0x20200000
#define PERF_SPININSTR          0x20210000
#define PERF_SESSION            0x20400000
#define PERF_PFSECTION          0x20400000
#define PERF_MEMINFO_WS         0x20800000
#define PERF_KERNEL_QUEUE       0x21000000
#define PERF_INTERRUPT_STEER    0x22000000
#define PERF_SHOULD_YIELD       0x24000000
#define PERF_WS                 0x28000000
//#define PERF_POOLTRACE (PERF_MEMORY | PERF_POOL)
//#define PERF_PROFILING (PERF_PROFILE | PERF_PMC_PROFILE)
//#define PERF_SPININSTR (PERF_SPINLOCK | PERF_SPINLOCK_CNTRS)

// Masks[2]
#define PERF_ANTI_STARVATION    0x40000001
#define PERF_PROCESS_FREEZE     0x40000002
#define PERF_PFN_LIST           0x40000004
#define PERF_WS_DETAIL          0x40000008
#define PERF_WS_ENTRY           0x40000010
#define PERF_HEAP               0x40000020
#define PERF_SYSCALL            0x40000040  // equivalent to EVENT_TRACE_FLAG_SYSTEMCALL
#define PERF_UMS                0x40000080
#define PERF_BACKTRACE          0x40000100
#define PERF_VULCAN             0x40000200
#define PERF_OBJECTS            0x40000400
#define PERF_EVENTS             0x40000800
#define PERF_FULLTRACE          0x40001000
#define PERF_DFSS               0x40002000
#define PERF_PREFETCH           0x40004000
#define PERF_PROCESSOR_IDLE     0x40008000
#define PERF_CPU_CONFIG         0x40010000
#define PERF_TIMER              0x40020000
#define PERF_CLOCK_INTERRUPT    0x40040000
#define PERF_LOAD_BALANCER      0x40080000
#define PERF_CLOCK_TIMER        0x40100000
#define PERF_IDLE_SELECTION     0x40200000
#define PERF_IPI                0x40400000
#define PERF_IO_TIMER           0x40800000
#define PERF_REG_HIVE           0x41000000
#define PERF_REG_NOTIF          0x42000000
#define PERF_PPM_EXIT_LATENCY   0x44000000
#define PERF_WORKER_THREAD      0x48000000

// Masks[4]
#define PERF_OPTICAL_IO         0x80000001
#define PERF_OPTICAL_IO_INIT    0x80000002
// Reserved                     0x80000004
#define PERF_DLL_INFO           0x80000008
#define PERF_DLL_FLUSH_WS       0x80000010
// Reserved                     0x80000020
#define PERF_OB_HANDLE          0x80000040
#define PERF_OB_OBJECT          0x80000080
// Reserved                     0x80000100
#define PERF_WAKE_DROP          0x80000200
#define PERF_WAKE_EVENT         0x80000400
#define PERF_DEBUGGER           0x80000800
#define PERF_PROC_ATTACH        0x80001000
#define PERF_WAKE_COUNTER       0x80002000
// Reserved                     0x80004000
#define PERF_POWER              0x80008000
#define PERF_SOFT_TRIM          0x80010000
#define PERF_CC                 0x80020000
// Reserved                     0x80040000
#define PERF_FLT_IO_INIT        0x80080000
#define PERF_FLT_IO             0x80100000
#define PERF_FLT_FASTIO         0x80200000
#define PERF_FLT_IO_FAILURE     0x80400000
#define PERF_HV_PROFILE         0x80800000
#define PERF_WDF_DPC            0x81000000
#define PERF_WDF_INTERRUPT      0x82000000
#define PERF_CACHE_FLUSH        0x84000000

// Masks[5]
#define PERF_HIBER_RUNDOWN      0xA0000001

// Masks[6]
#define PERF_SYSCFG_SYSTEM      0xC0000001
#define PERF_SYSCFG_GRAPHICS    0xC0000002
#define PERF_SYSCFG_STORAGE     0xC0000004
#define PERF_SYSCFG_NETWORK     0xC0000008
#define PERF_SYSCFG_SERVICES    0xC0000010
#define PERF_SYSCFG_PNP         0xC0000020
#define PERF_SYSCFG_OPTICAL     0xC0000040
#define PERF_SYSCFG_ALL         0xDFFFFFFF

// Masks[7] - Control Mask. All flags that change system behavior go here.
#define PERF_CLUSTER_OFF        0xE0000001
#define PERF_MEMORY_CONTROL     0xE0000002

// The predefined event groups or families for NT subsystems
#define EVENT_TRACE_GROUP_HEADER               0x0000
#define EVENT_TRACE_GROUP_IO                   0x0100
#define EVENT_TRACE_GROUP_MEMORY               0x0200
#define EVENT_TRACE_GROUP_PROCESS              0x0300
#define EVENT_TRACE_GROUP_FILE                 0x0400
#define EVENT_TRACE_GROUP_THREAD               0x0500
#define EVENT_TRACE_GROUP_TCPIP                0x0600
#define EVENT_TRACE_GROUP_JOB                  0x0700
#define EVENT_TRACE_GROUP_UDPIP                0x0800
#define EVENT_TRACE_GROUP_REGISTRY             0x0900
#define EVENT_TRACE_GROUP_DBGPRINT             0x0A00
#define EVENT_TRACE_GROUP_CONFIG               0x0B00
#define EVENT_TRACE_GROUP_SPARE1               0x0C00   // Spare1
#define EVENT_TRACE_GROUP_WNF                  0x0D00
#define EVENT_TRACE_GROUP_POOL                 0x0E00
#define EVENT_TRACE_GROUP_PERFINFO             0x0F00
#define EVENT_TRACE_GROUP_HEAP                 0x1000
#define EVENT_TRACE_GROUP_OBJECT               0x1100
#define EVENT_TRACE_GROUP_POWER                0x1200
#define EVENT_TRACE_GROUP_MODBOUND             0x1300
#define EVENT_TRACE_GROUP_IMAGE                0x1400
#define EVENT_TRACE_GROUP_DPC                  0x1500
#define EVENT_TRACE_GROUP_CC                   0x1600
#define EVENT_TRACE_GROUP_CRITSEC              0x1700
#define EVENT_TRACE_GROUP_STACKWALK            0x1800
#define EVENT_TRACE_GROUP_UMS                  0x1900
#define EVENT_TRACE_GROUP_ALPC                 0x1A00
#define EVENT_TRACE_GROUP_SPLITIO              0x1B00
#define EVENT_TRACE_GROUP_THREAD_POOL          0x1C00
#define EVENT_TRACE_GROUP_HYPERVISOR           0x1D00
#define EVENT_TRACE_GROUP_HYPERVISORX          0x1E00

//
// Event for header
//
#define WMI_LOG_TYPE_HEADER                       (EVENT_TRACE_GROUP_HEADER | EVENT_TRACE_TYPE_INFO)
#define WMI_LOG_TYPE_HEADER_EXTENSION             (EVENT_TRACE_GROUP_HEADER | EVENT_TRACE_TYPE_EXTENSION)
#define WMI_LOG_TYPE_RUNDOWN_COMPLETE             (EVENT_TRACE_GROUP_HEADER | EVENT_TRACE_TYPE_CHECKPOINT)
#define WMI_LOG_TYPE_GROUP_MASKS_END              (EVENT_TRACE_GROUP_HEADER | 0x20)
#define WMI_LOG_TYPE_RUNDOWN_BEGIN                (EVENT_TRACE_GROUP_HEADER | 0x30)
#define WMI_LOG_TYPE_RUNDOWN_END                  (EVENT_TRACE_GROUP_HEADER | 0x31)
#define WMI_LOG_TYPE_DBGID_RSDS                   (EVENT_TRACE_GROUP_HEADER | EVENT_TRACE_TYPE_DBGID_RSDS)
#define WMI_LOG_TYPE_DBGID_NB10                   (EVENT_TRACE_GROUP_HEADER | 0x41)
#define WMI_LOG_TYPE_BUILD_LAB                    (EVENT_TRACE_GROUP_HEADER | 0x42)
#define WMI_LOG_TYPE_BINARY_PATH                  (EVENT_TRACE_GROUP_HEADER | 0x43)

//
// Event for system config
//
#define WMI_LOG_TYPE_CONFIG_CPU                   (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_CPU)
#define WMI_LOG_TYPE_CONFIG_PHYSICALDISK          (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_PHYSICALDISK)
#define WMI_LOG_TYPE_CONFIG_LOGICALDISK           (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_LOGICALDISK)
#define WMI_LOG_TYPE_CONFIG_OPTICALMEDIA          (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_OPTICALMEDIA)
#define WMI_LOG_TYPE_CONFIG_NIC                   (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_NIC)
#define WMI_LOG_TYPE_CONFIG_VIDEO                 (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_VIDEO)
#define WMI_LOG_TYPE_CONFIG_SERVICES              (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_SERVICES)
#define WMI_LOG_TYPE_CONFIG_POWER                 (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_POWER)
#define WMI_LOG_TYPE_CONFIG_OSVERSION             (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_OSVERSION)
#define WMI_LOG_TYPE_CONFIG_VISUALTHEME           (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_VISUALTHEME)
#define WMI_LOG_TYPE_CONFIG_SYSTEMRANGE           (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_SYSTEMRANGE)
#define WMI_LOG_TYPE_CONFIG_SYSDLLINFO            (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_SYSDLLINFO)
#define WMI_LOG_TYPE_CONFIG_IRQ                   (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_IRQ)
#define WMI_LOG_TYPE_CONFIG_PNP                   (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_PNP)
#define WMI_LOG_TYPE_CONFIG_IDECHANNEL            (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_IDECHANNEL)
#define WMI_LOG_TYPE_CONFIG_NUMANODE              (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_NUMANODE)
#define WMI_LOG_TYPE_CONFIG_PLATFORM              (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_PLATFORM)
#define WMI_LOG_TYPE_CONFIG_PROCESSORGROUP        (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_PROCESSORGROUP)
#define WMI_LOG_TYPE_CONFIG_PROCESSORNUMBER       (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_PROCESSORNUMBER)
#define WMI_LOG_TYPE_CONFIG_DPI                   (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_DPI)
#define WMI_LOG_TYPE_CONFIG_CODEINTEGRITY         (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_CI_INFO)
#define WMI_LOG_TYPE_CONFIG_MACHINEID             (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_MACHINEID)

//
// Event for Image and File Name
//
#define PERFINFO_LOG_TYPE_FILENAME                  (EVENT_TRACE_GROUP_FILE | EVENT_TRACE_TYPE_INFO)
#define PERFINFO_LOG_TYPE_FILENAME_CREATE           (EVENT_TRACE_GROUP_FILE | 0x20)
#define PERFINFO_LOG_TYPE_FILENAME_SAME             (EVENT_TRACE_GROUP_FILE | 0x21)
#define PERFINFO_LOG_TYPE_FILENAME_NULL             (EVENT_TRACE_GROUP_FILE | 0x22)
#define PERFINFO_LOG_TYPE_FILENAME_DELETE           (EVENT_TRACE_GROUP_FILE | 0x23)
#define PERFINFO_LOG_TYPE_FILENAME_RUNDOWN          (EVENT_TRACE_GROUP_FILE | 0x24)

#define PERFINFO_LOG_TYPE_MAPFILE                   (EVENT_TRACE_GROUP_FILE | 0x25)
#define PERFINFO_LOG_TYPE_UNMAPFILE                 (EVENT_TRACE_GROUP_FILE | 0x26)
#define PERFINFO_LOG_TYPE_MAPFILE_DC_START          (EVENT_TRACE_GROUP_FILE | 0x27)
#define PERFINFO_LOG_TYPE_MAPFILE_DC_END            (EVENT_TRACE_GROUP_FILE | 0x28)

#define PERFINFO_LOG_TYPE_FILE_IO_CREATE            (EVENT_TRACE_GROUP_FILE | 0x40)
#define PERFINFO_LOG_TYPE_FILE_IO_CLEANUP           (EVENT_TRACE_GROUP_FILE | 0x41)
#define PERFINFO_LOG_TYPE_FILE_IO_CLOSE             (EVENT_TRACE_GROUP_FILE | 0x42)
#define PERFINFO_LOG_TYPE_FILE_IO_READ              (EVENT_TRACE_GROUP_FILE | 0x43)
#define PERFINFO_LOG_TYPE_FILE_IO_WRITE             (EVENT_TRACE_GROUP_FILE | 0x44)
#define PERFINFO_LOG_TYPE_FILE_IO_SET_INFORMATION   (EVENT_TRACE_GROUP_FILE | 0x45)
#define PERFINFO_LOG_TYPE_FILE_IO_DELETE            (EVENT_TRACE_GROUP_FILE | 0x46)
#define PERFINFO_LOG_TYPE_FILE_IO_RENAME            (EVENT_TRACE_GROUP_FILE | 0x47)
#define PERFINFO_LOG_TYPE_FILE_IO_DIRENUM           (EVENT_TRACE_GROUP_FILE | 0x48)
#define PERFINFO_LOG_TYPE_FILE_IO_FLUSH             (EVENT_TRACE_GROUP_FILE | 0x49)
#define PERFINFO_LOG_TYPE_FILE_IO_QUERY_INFORMATION (EVENT_TRACE_GROUP_FILE | 0x4A)
#define PERFINFO_LOG_TYPE_FILE_IO_FS_CONTROL        (EVENT_TRACE_GROUP_FILE | 0x4B)
#define PERFINFO_LOG_TYPE_FILE_IO_OPERATION_END     (EVENT_TRACE_GROUP_FILE | 0x4C)
#define PERFINFO_LOG_TYPE_FILE_IO_DIRNOTIFY         (EVENT_TRACE_GROUP_FILE | 0x4D)
#define PERFINFO_LOG_TYPE_FILE_IO_CREATE_NEW        (EVENT_TRACE_GROUP_FILE | 0x4E)
#define PERFINFO_LOG_TYPE_FILE_IO_DELETE_PATH       (EVENT_TRACE_GROUP_FILE | 0x4F)
#define PERFINFO_LOG_TYPE_FILE_IO_RENAME_PATH       (EVENT_TRACE_GROUP_FILE | 0x50)
#define PERFINFO_LOG_TYPE_FILE_IO_SETLINK_PATH      (EVENT_TRACE_GROUP_FILE | 0x51)
#define PERFINFO_LOG_TYPE_FILE_IO_SETLINK           (EVENT_TRACE_GROUP_FILE | 0x52)

//
//  Event types for minifilter callbacks
//

#define PERFINFO_LOG_TYPE_FLT_PREOP_INIT        (EVENT_TRACE_GROUP_FILE | EVENT_TRACE_TYPE_FLT_PREOP_INIT)
#define PERFINFO_LOG_TYPE_FLT_POSTOP_INIT       (EVENT_TRACE_GROUP_FILE | EVENT_TRACE_TYPE_FLT_POSTOP_INIT)
#define PERFINFO_LOG_TYPE_FLT_PREOP_COMPLETION  (EVENT_TRACE_GROUP_FILE | EVENT_TRACE_TYPE_FLT_PREOP_COMPLETION)
#define PERFINFO_LOG_TYPE_FLT_POSTOP_COMPLETION (EVENT_TRACE_GROUP_FILE | EVENT_TRACE_TYPE_FLT_POSTOP_COMPLETION)
#define PERFINFO_LOG_TYPE_FLT_PREOP_FAILURE     (EVENT_TRACE_GROUP_FILE | EVENT_TRACE_TYPE_FLT_PREOP_FAILURE)
#define PERFINFO_LOG_TYPE_FLT_POSTOP_FAILURE    (EVENT_TRACE_GROUP_FILE | EVENT_TRACE_TYPE_FLT_POSTOP_FAILURE)

//
// Event types for Job
//

#define WMI_LOG_TYPE_JOB_CREATE                     (EVENT_TRACE_GROUP_JOB | 0x20)
#define WMI_LOG_TYPE_JOB_TERMINATE                  (EVENT_TRACE_GROUP_JOB | 0x21)
#define WMI_LOG_TYPE_JOB_OPEN                       (EVENT_TRACE_GROUP_JOB | 0x22)
#define WMI_LOG_TYPE_JOB_ASSIGN_PROCESS             (EVENT_TRACE_GROUP_JOB | 0x23)
#define WMI_LOG_TYPE_JOB_REMOVE_PROCESS             (EVENT_TRACE_GROUP_JOB | 0x24)
#define WMI_LOG_TYPE_JOB_SET                        (EVENT_TRACE_GROUP_JOB | 0x25)
#define WMI_LOG_TYPE_JOB_QUERY                      (EVENT_TRACE_GROUP_JOB | 0x26)
#define WMI_LOG_TYPE_JOB_SET_FAILED                 (EVENT_TRACE_GROUP_JOB | 0x27)
#define WMI_LOG_TYPE_JOB_QUERY_FAILED               (EVENT_TRACE_GROUP_JOB | 0x28)
#define WMI_LOG_TYPE_JOB_SET_NOTIFICATION           (EVENT_TRACE_GROUP_JOB | 0x29)
#define WMI_LOG_TYPE_JOB_SEND_NOTIFICATION          (EVENT_TRACE_GROUP_JOB | 0x2A)
#define WMI_LOG_TYPE_JOB_QUERY_VIOLATION            (EVENT_TRACE_GROUP_JOB | 0x2B)
#define WMI_LOG_TYPE_JOB_SET_CPU_RATE               (EVENT_TRACE_GROUP_JOB | 0x2C)
#define WMI_LOG_TYPE_JOB_SET_NET_RATE               (EVENT_TRACE_GROUP_JOB | 0x2D)

//
// Event types for Process
//

#define WMI_LOG_TYPE_PROCESS_CREATE                 (EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_START)
#define WMI_LOG_TYPE_PROCESS_DELETE                 (EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_END)
#define WMI_LOG_TYPE_PROCESS_DC_START               (EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_DC_START)
#define WMI_LOG_TYPE_PROCESS_DC_END                 (EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_DC_END)
#define WMI_LOG_TYPE_PROCESS_LOAD_IMAGE             (EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_LOAD)
#define WMI_LOG_TYPE_PROCESS_TERMINATE              (EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_TERMINATE)

#define PERFINFO_LOG_TYPE_PROCESS_PERFCTR_END       (EVENT_TRACE_GROUP_PROCESS | 0x20)
#define PERFINFO_LOG_TYPE_PROCESS_PERFCTR_RD        (EVENT_TRACE_GROUP_PROCESS | 0x21)
// Reserved                                         (EVENT_TRACE_GROUP_PROCESS | 0x22)
#define PERFINFO_LOG_TYPE_INSWAPPROCESS             (EVENT_TRACE_GROUP_PROCESS | 0x23)
#define PERFINFO_LOG_TYPE_PROCESS_FREEZE            (EVENT_TRACE_GROUP_PROCESS | 0x24)
#define PERFINFO_LOG_TYPE_PROCESS_THAW              (EVENT_TRACE_GROUP_PROCESS | 0x25)
#define PERFINFO_LOG_TYPE_BOOT_PHASE_START          (EVENT_TRACE_GROUP_PROCESS | 0x26)
#define PERFINFO_LOG_TYPE_ZOMBIE_PROCESS            (EVENT_TRACE_GROUP_PROCESS | 0x27)
#define PERFINFO_LOG_TYPE_PROCESS_SET_AFFINITY      (EVENT_TRACE_GROUP_PROCESS | 0x28)

#define PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_USER             (EVENT_TRACE_GROUP_PROCESS | 0x30)
#define PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_EXECUTION        (EVENT_TRACE_GROUP_PROCESS | 0x31)
#define PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_KERNEL           (EVENT_TRACE_GROUP_PROCESS | 0x32)
#define PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_INSTRUMENTATION  (EVENT_TRACE_GROUP_PROCESS | 0x33)
#define PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_PRESERVE_PROCESS (EVENT_TRACE_GROUP_PROCESS | 0x34)

#define PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_USER            (EVENT_TRACE_GROUP_PROCESS | 0x40)
#define PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_EXECUTION       (EVENT_TRACE_GROUP_PROCESS | 0x41)
#define PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_KERNEL          (EVENT_TRACE_GROUP_PROCESS | 0x42)
#define PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_INSTRUMENTATION (EVENT_TRACE_GROUP_PROCESS | 0x43)
#define PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_PRESERVE_PROCESS (EVENT_TRACE_GROUP_PROCESS | 0x44)

#define PERFINFO_LOG_TYPE_WAKE_DROP_USER                       (EVENT_TRACE_GROUP_PROCESS | 0x50)
#define PERFINFO_LOG_TYPE_WAKE_DROP_EXECUTION                  (EVENT_TRACE_GROUP_PROCESS | 0x51)
#define PERFINFO_LOG_TYPE_WAKE_DROP_KERNEL                     (EVENT_TRACE_GROUP_PROCESS | 0x52)
#define PERFINFO_LOG_TYPE_WAKE_DROP_INSTRUMENTATION            (EVENT_TRACE_GROUP_PROCESS | 0x53)
#define PERFINFO_LOG_TYPE_WAKE_DROP_PRESERVE_PROCESS           (EVENT_TRACE_GROUP_PROCESS | 0x54)

#define PERFINFO_LOG_TYPE_WAKE_EVENT_USER                      (EVENT_TRACE_GROUP_PROCESS | 0x60)
#define PERFINFO_LOG_TYPE_WAKE_EVENT_EXECUTION                 (EVENT_TRACE_GROUP_PROCESS | 0x61)
#define PERFINFO_LOG_TYPE_WAKE_EVENT_KERNEL                    (EVENT_TRACE_GROUP_PROCESS | 0x62)
#define PERFINFO_LOG_TYPE_WAKE_EVENT_INSTRUMENTATION           (EVENT_TRACE_GROUP_PROCESS | 0x63)
#define PERFINFO_LOG_TYPE_WAKE_EVENT_PRESERVE_PROCESS          (EVENT_TRACE_GROUP_PROCESS | 0x64)

#define PERFINFO_LOG_TYPE_DEBUG_EVENT                          (EVENT_TRACE_GROUP_PROCESS | 0x70)

//
// Event types for Image and Library Loader
//

#define WMI_LOG_TYPE_IMAGE_LOAD                     (EVENT_TRACE_GROUP_IMAGE | EVENT_TRACE_TYPE_START) // reserved for future
#define WMI_LOG_TYPE_IMAGE_UNLOAD                   (EVENT_TRACE_GROUP_IMAGE | EVENT_TRACE_TYPE_END)
#define WMI_LOG_TYPE_IMAGE_DC_START                 (EVENT_TRACE_GROUP_IMAGE | EVENT_TRACE_TYPE_DC_START)
#define WMI_LOG_TYPE_IMAGE_DC_END                   (EVENT_TRACE_GROUP_IMAGE | EVENT_TRACE_TYPE_DC_END)
#define WMI_LOG_TYPE_IMAGE_RELOCATION               (EVENT_TRACE_GROUP_IMAGE | 0x20)
#define WMI_LOG_TYPE_IMAGE_KERNEL_BASE              (EVENT_TRACE_GROUP_IMAGE | 0x21)
#define WMI_LOG_TYPE_IMAGE_HYPERCALL_PAGE           (EVENT_TRACE_GROUP_IMAGE | 0x22)

#define PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_ATTEMPT          (EVENT_TRACE_GROUP_IMAGE | 0x80) // 128
#define PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_SUCCESS          (EVENT_TRACE_GROUP_IMAGE | 0x81)
#define PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_FAIL             (EVENT_TRACE_GROUP_IMAGE | 0x82)
#define PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_WAIT             (EVENT_TRACE_GROUP_IMAGE | 0x83)
#define PERFINFO_LOG_TYPE_LDR_PROC_INIT_DONE                (EVENT_TRACE_GROUP_IMAGE | 0x84) // 132
#define PERFINFO_LOG_TYPE_LDR_CREATE_SECTION                (EVENT_TRACE_GROUP_IMAGE | 0x85)
#define PERFINFO_LOG_TYPE_LDR_SECTION_CREATED               (EVENT_TRACE_GROUP_IMAGE | 0x86)
#define PERFINFO_LOG_TYPE_LDR_MAP_VIEW                      (EVENT_TRACE_GROUP_IMAGE | 0x87)

#define PERFINFO_LOG_TYPE_LDR_RELOCATE_IMAGE                (EVENT_TRACE_GROUP_IMAGE | 0x90) // 144
#define PERFINFO_LOG_TYPE_LDR_IMAGE_RELOCATED               (EVENT_TRACE_GROUP_IMAGE | 0x91)
#define PERFINFO_LOG_TYPE_LDR_HANDLE_OLD_DESCRIPTORS        (EVENT_TRACE_GROUP_IMAGE | 0x92)
#define PERFINFO_LOG_TYPE_LDR_OLD_DESCRIPTORS_HANDLED       (EVENT_TRACE_GROUP_IMAGE | 0x93)
#define PERFINFO_LOG_TYPE_LDR_HANDLE_NEW_DESCRIPTORS        (EVENT_TRACE_GROUP_IMAGE | 0x94) // 148
#define PERFINFO_LOG_TYPE_LDR_NEW_DESCRIPTORS_HANDLED       (EVENT_TRACE_GROUP_IMAGE | 0x95)
#define PERFINFO_LOG_TYPE_LDR_DLLMAIN_EXIT                  (EVENT_TRACE_GROUP_IMAGE | 0x96)

#define PERFINFO_LOG_TYPE_LDR_FIND_DLL                      (EVENT_TRACE_GROUP_IMAGE | 0xA0) // 160
#define PERFINFO_LOG_TYPE_LDR_VIEW_MAPPED                   (EVENT_TRACE_GROUP_IMAGE | 0xA1)
#define PERFINFO_LOG_TYPE_LDR_LOCK_RELEASE                  (EVENT_TRACE_GROUP_IMAGE | 0xA2)
#define PERFINFO_LOG_TYPE_LDR_DLLMAIN_ENTER                 (EVENT_TRACE_GROUP_IMAGE | 0xA3)
#define PERFINFO_LOG_TYPE_LDR_ERROR                         (EVENT_TRACE_GROUP_IMAGE | 0xA4) // 164

#define PERFINFO_LOG_TYPE_LDR_VIEW_MAPPING                  (EVENT_TRACE_GROUP_IMAGE | 0xA5) // 165
#define PERFINFO_LOG_TYPE_LDR_SNAPPING                      (EVENT_TRACE_GROUP_IMAGE | 0xA6)
#define PERFINFO_LOG_TYPE_LDR_SNAPPED                       (EVENT_TRACE_GROUP_IMAGE | 0xA7)
#define PERFINFO_LOG_TYPE_LDR_LOADING                       (EVENT_TRACE_GROUP_IMAGE | 0xA8)
#define PERFINFO_LOG_TYPE_LDR_LOADED                        (EVENT_TRACE_GROUP_IMAGE | 0xA9)
#define PERFINFO_LOG_TYPE_LDR_FOUND_KNOWN_DLL               (EVENT_TRACE_GROUP_IMAGE | 0xAA) // 170
#define PERFINFO_LOG_TYPE_LDR_ABNORMAL                      (EVENT_TRACE_GROUP_IMAGE | 0xAB)
#define PERFINFO_LOG_TYPE_LDR_PLACEHOLDER                   (EVENT_TRACE_GROUP_IMAGE | 0xAC)
#define PERFINFO_LOG_TYPE_LDR_RDY_TO_INIT                   (EVENT_TRACE_GROUP_IMAGE | 0xAD)
#define PERFINFO_LOG_TYPE_LDR_RDY_TO_RUN                    (EVENT_TRACE_GROUP_IMAGE | 0xAE) // 174


#define PERFINFO_LOG_TYPE_LDR_NEW_DLL_LOAD                  (EVENT_TRACE_GROUP_IMAGE | 0xB0) // 176
#define PERFINFO_LOG_TYPE_LDR_NEW_DLL_AS_DATA               (EVENT_TRACE_GROUP_IMAGE | 0xB1) // 177

#define PERFINFO_LOG_TYPE_LDR_EXTERNAL_PATH                 (EVENT_TRACE_GROUP_IMAGE | 0xC0) // 192
#define PERFINFO_LOG_TYPE_LDR_GENERATED_PATH                (EVENT_TRACE_GROUP_IMAGE | 0xC1)

#define PERFINFO_LOG_TYPE_LDR_APISET_RESOLVING              (EVENT_TRACE_GROUP_IMAGE | 0xD0) // 208
#define PERFINFO_LOG_TYPE_LDR_APISET_HOSTED                 (EVENT_TRACE_GROUP_IMAGE | 0xD1) // 209
#define PERFINFO_LOG_TYPE_LDR_APISET_UNHOSTED               (EVENT_TRACE_GROUP_IMAGE | 0xD2) // 210
#define PERFINFO_LOG_TYPE_LDR_APISET_UNRESOLVED             (EVENT_TRACE_GROUP_IMAGE | 0xD3) // 211

#define PERFINFO_LOG_TYPE_LDR_SEARCH_SECURITY               (EVENT_TRACE_GROUP_IMAGE | 0xD4) // 212
#define PERFINFO_LOG_TYPE_LDR_SEARCH_PATH_SECURITY          (EVENT_TRACE_GROUP_IMAGE | 0xD5) // 213

//
// Event types for Thread
//

#define WMI_LOG_TYPE_THREAD_CREATE                  (EVENT_TRACE_GROUP_THREAD | EVENT_TRACE_TYPE_START)
#define WMI_LOG_TYPE_THREAD_DELETE                  (EVENT_TRACE_GROUP_THREAD | EVENT_TRACE_TYPE_END)
#define WMI_LOG_TYPE_THREAD_DC_START                (EVENT_TRACE_GROUP_THREAD | EVENT_TRACE_TYPE_DC_START)
#define WMI_LOG_TYPE_THREAD_DC_END                  (EVENT_TRACE_GROUP_THREAD | EVENT_TRACE_TYPE_DC_END)

// Reserved                                         (EVENT_TRACE_GROUP_THREAD | 0x20)
// Reserved                                         (EVENT_TRACE_GROUP_THREAD | 0x21)
// Reserved                                         (EVENT_TRACE_GROUP_THREAD | 0x22)
// Reserved                                         (EVENT_TRACE_GROUP_THREAD | 0x23)
#define PERFINFO_LOG_TYPE_CONTEXTSWAP               (EVENT_TRACE_GROUP_THREAD | 0x24)
#define PERFINFO_LOG_TYPE_CONTEXTSWAP_BATCH         (EVENT_TRACE_GROUP_THREAD | 0x25)
// Reserved                                         (EVENT_TRACE_GROUP_THREAD | 0x26)
// Reserved                                         (EVENT_TRACE_GROUP_THREAD | 0x27)
// Reserved                                         (EVENT_TRACE_GROUP_THREAD | 0x28)
#define PERFINFO_LOG_TYPE_SPINLOCK                  (EVENT_TRACE_GROUP_THREAD | 0x29)
#define PERFINFO_LOG_TYPE_QUEUE                     (EVENT_TRACE_GROUP_THREAD | 0x2A)
#define PERFINFO_LOG_TYPE_RESOURCE                  (EVENT_TRACE_GROUP_THREAD | 0x2B)
#define PERFINFO_LOG_TYPE_PUSHLOCK                  (EVENT_TRACE_GROUP_THREAD | 0x2C)
#define PERFINFO_LOG_TYPE_WAIT_SINGLE               (EVENT_TRACE_GROUP_THREAD | 0x2D)
#define PERFINFO_LOG_TYPE_WAIT_MULTIPLE             (EVENT_TRACE_GROUP_THREAD | 0x2E)
#define PERFINFO_LOG_TYPE_DELAY_EXECUTION           (EVENT_TRACE_GROUP_THREAD | 0x2F)
#define PERFINFO_LOG_TYPE_THREAD_SET_PRIORITY       (EVENT_TRACE_GROUP_THREAD | 0x30)
#define PERFINFO_LOT_TYPE_THREAD_SET_BASE_PRIORITY  (EVENT_TRACE_GROUP_THREAD | 0x31)
#define PERFINFO_LOG_TYPE_THREAD_SET_BASE_PRIORITY  (EVENT_TRACE_GROUP_THREAD | 0x31)
#define PERFINFO_LOG_TYPE_READY_THREAD              (EVENT_TRACE_GROUP_THREAD | 0x32)
#define PERFINFO_LOG_TYPE_THREAD_SET_PAGE_PRIORITY  (EVENT_TRACE_GROUP_THREAD | 0x33)
#define PERFINFO_LOG_TYPE_THREAD_SET_IO_PRIORITY    (EVENT_TRACE_GROUP_THREAD | 0x34)
#define PERFINFO_LOG_TYPE_THREAD_SET_AFFINITY       (EVENT_TRACE_GROUP_THREAD | 0x35)
#define PERFINFO_LOG_TYPE_WORKER_THREAD_ITEM        (EVENT_TRACE_GROUP_THREAD | 0x39)
#define PERFINFO_LOG_TYPE_DFSS_START_NEW_INTERVAL   (EVENT_TRACE_GROUP_THREAD | 0x3A)
#define PERFINFO_LOG_TYPE_DFSS_PROCESS_IDLE_ONLY_QUEUE (EVENT_TRACE_GROUP_THREAD | 0x3B)
#define PERFINFO_LOG_TYPE_ANTI_STARVATION_BOOST     (EVENT_TRACE_GROUP_THREAD | 0x3C)
#define PERFINFO_LOG_TYPE_THREAD_MIGRATION          (EVENT_TRACE_GROUP_THREAD | 0x3D)
#define PERFINFO_LOG_TYPE_KQUEUE_ENQUEUE            (EVENT_TRACE_GROUP_THREAD | 0x3E)
#define PERFINFO_LOG_TYPE_KQUEUE_DEQUEUE            (EVENT_TRACE_GROUP_THREAD | 0x3F)
#define PERFINFO_LOG_TYPE_WORKER_THREAD_ITEM_START  (EVENT_TRACE_GROUP_THREAD | 0x40)
#define PERFINFO_LOG_TYPE_WORKER_THREAD_ITEM_END    (EVENT_TRACE_GROUP_THREAD | 0x41)
#define PERFINFO_LOG_TYPE_AUTO_BOOST_SET_FLOOR      (EVENT_TRACE_GROUP_THREAD | 0x42)
#define PERFINFO_LOG_TYPE_AUTO_BOOST_CLEAR_FLOOR    (EVENT_TRACE_GROUP_THREAD | 0x43)
#define PERFINFO_LOG_TYPE_AUTO_BOOST_NO_ENTRIES     (EVENT_TRACE_GROUP_THREAD | 0x44)
#define PERFINFO_LOG_TYPE_THREAD_SUBPROCESSTAG_CHANGED (EVENT_TRACE_GROUP_THREAD | 0x45)

//
// Event types for Network subsystem (TCPIP/UDPIP)
//

#define WMI_LOG_TYPE_TCPIP_SEND                     (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_SEND)
#define WMI_LOG_TYPE_TCPIP_RECEIVE                  (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_RECEIVE)
#define WMI_LOG_TYPE_TCPIP_CONNECT                  (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_CONNECT)
#define WMI_LOG_TYPE_TCPIP_DISCONNECT               (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_DISCONNECT)
#define WMI_LOG_TYPE_TCPIP_RETRANSMIT               (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_RETRANSMIT)
#define WMI_LOG_TYPE_TCPIP_ACCEPT                   (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_ACCEPT)
#define WMI_LOG_TYPE_TCPIP_RECONNECT                (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_RECONNECT)
#define WMI_LOG_TYPE_TCPIP_FAIL                     (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_CONNFAIL)
#define WMI_LOG_TYPE_TCPIP_TCPCOPY                  (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_COPY_TCP)
#define WMI_LOG_TYPE_TCPIP_ARPCOPY                  (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_COPY_ARP)
#define WMI_LOG_TYPE_TCPIP_FULLACK                  (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_ACKFULL)
#define WMI_LOG_TYPE_TCPIP_PARTACK                  (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_ACKPART)
#define WMI_LOG_TYPE_TCPIP_DUPACK                   (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_ACKDUP)

#define WMI_LOG_TYPE_UDP_SEND                       (EVENT_TRACE_GROUP_UDPIP | EVENT_TRACE_TYPE_SEND)
#define WMI_LOG_TYPE_UDP_RECEIVE                    (EVENT_TRACE_GROUP_UDPIP | EVENT_TRACE_TYPE_RECEIVE)
#define WMI_LOG_TYPE_UDP_FAIL                       (EVENT_TRACE_GROUP_UDPIP | EVENT_TRACE_TYPE_CONNFAIL)

//
// Netowrk events with IPV6
//
#define WMI_LOG_TYPE_TCPIP_SEND_IPV6                (EVENT_TRACE_GROUP_TCPIP | 0x1A)
#define WMI_LOG_TYPE_TCPIP_RECEIVE_IPV6             (EVENT_TRACE_GROUP_TCPIP | 0x1B)
#define WMI_LOG_TYPE_TCPIP_CONNECT_IPV6             (EVENT_TRACE_GROUP_TCPIP | 0x1C)
#define WMI_LOG_TYPE_TCPIP_DISCONNECT_IPV6          (EVENT_TRACE_GROUP_TCPIP | 0x1D)
#define WMI_LOG_TYPE_TCPIP_RETRANSMIT_IPV6          (EVENT_TRACE_GROUP_TCPIP | 0x1E)
#define WMI_LOG_TYPE_TCPIP_ACCEPT_IPV6              (EVENT_TRACE_GROUP_TCPIP | 0x1F)
#define WMI_LOG_TYPE_TCPIP_RECONNECT_IPV6           (EVENT_TRACE_GROUP_TCPIP | 0x20)
#define WMI_LOG_TYPE_TCPIP_FAIL_IPV6                (EVENT_TRACE_GROUP_TCPIP | 0x21)
#define WMI_LOG_TYPE_TCPIP_TCPCOPY_IPV6             (EVENT_TRACE_GROUP_TCPIP | 0x22)
#define WMI_LOG_TYPE_TCPIP_ARPCOPY_IPV6             (EVENT_TRACE_GROUP_TCPIP | 0x23)
#define WMI_LOG_TYPE_TCPIP_FULLACK_IPV6             (EVENT_TRACE_GROUP_TCPIP | 0x24)
#define WMI_LOG_TYPE_TCPIP_PARTACK_IPV6             (EVENT_TRACE_GROUP_TCPIP | 0x25)
#define WMI_LOG_TYPE_TCPIP_DUPACK_IPV6              (EVENT_TRACE_GROUP_TCPIP | 0x26)

#define WMI_LOG_TYPE_UDP_SEND_IPV6                  (EVENT_TRACE_GROUP_UDPIP | 0x1A)
#define WMI_LOG_TYPE_UDP_RECEIVE_IPV6               (EVENT_TRACE_GROUP_UDPIP | 0x1B)

//
// Event types for IO subsystem
//

#define WMI_LOG_TYPE_IO_READ                        (EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_READ)
#define WMI_LOG_TYPE_IO_WRITE                       (EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_WRITE)
#define WMI_LOG_TYPE_IO_READ_INIT                   (EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_READ_INIT)
#define WMI_LOG_TYPE_IO_WRITE_INIT                  (EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_WRITE_INIT)
#define WMI_LOG_TYPE_IO_FLUSH                       (EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_FLUSH)
#define WMI_LOG_TYPE_IO_FLUSH_INIT                  (EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_FLUSH_INIT)
#define WMI_LOG_TYPE_IO_REDIRECTED_INIT             (EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_REDIRECTED_INIT)

#define PERFINFO_LOG_TYPE_DRIVER_INIT                       (EVENT_TRACE_GROUP_IO | 0x20)
#define PERFINFO_LOG_TYPE_DRIVER_INIT_COMPLETE              (EVENT_TRACE_GROUP_IO | 0x21)
#define PERFINFO_LOG_TYPE_DRIVER_MAJORFUNCTION_CALL         (EVENT_TRACE_GROUP_IO | 0x22)
#define PERFINFO_LOG_TYPE_DRIVER_MAJORFUNCTION_RETURN       (EVENT_TRACE_GROUP_IO | 0x23)
#define PERFINFO_LOG_TYPE_DRIVER_COMPLETIONROUTINE_CALL     (EVENT_TRACE_GROUP_IO | 0x24)
#define PERFINFO_LOG_TYPE_DRIVER_COMPLETIONROUTINE_RETURN   (EVENT_TRACE_GROUP_IO | 0x25)
#define PERFINFO_LOG_TYPE_DRIVER_ADD_DEVICE_CALL            (EVENT_TRACE_GROUP_IO | 0x26)
#define PERFINFO_LOG_TYPE_DRIVER_ADD_DEVICE_RETURN          (EVENT_TRACE_GROUP_IO | 0x27)
#define PERFINFO_LOG_TYPE_DRIVER_STARTIO_CALL               (EVENT_TRACE_GROUP_IO | 0x28)
#define PERFINFO_LOG_TYPE_DRIVER_STARTIO_RETURN             (EVENT_TRACE_GROUP_IO | 0x29)
// Reserved                                                 (EVENT_TRACE_GROUP_IO | 0x2a)
// Reserved                                                 (EVENT_TRACE_GROUP_IO | 0x2b)
// Reserved                                                 (EVENT_TRACE_GROUP_IO | 0x2c)
// Reserved                                                 (EVENT_TRACE_GROUP_IO | 0x2d)
// Reserved                                                 (EVENT_TRACE_GROUP_IO | 0x2e)
// Reserved                                                 (EVENT_TRACE_GROUP_IO | 0x2f)
#define PERFINFO_LOG_TYPE_PREFETCH_ACTION                   (EVENT_TRACE_GROUP_IO | 0x30)
#define PERFINFO_LOG_TYPE_PREFETCH_REQUEST                  (EVENT_TRACE_GROUP_IO | 0x31)
#define PERFINFO_LOG_TYPE_PREFETCH_READLIST                 (EVENT_TRACE_GROUP_IO | 0x32)
#define PERFINFO_LOG_TYPE_PREFETCH_READ                     (EVENT_TRACE_GROUP_IO | 0x33)
#define PERFINFO_LOG_TYPE_DRIVER_COMPLETE_REQUEST           (EVENT_TRACE_GROUP_IO | 0x34)
#define PERFINFO_LOG_TYPE_DRIVER_COMPLETE_REQUEST_RETURN    (EVENT_TRACE_GROUP_IO | 0x35)
#define PERFINFO_LOG_TYPE_BOOT_PREFETCH_INFORMATION         (EVENT_TRACE_GROUP_IO | 0x36)
#define PERFINFO_LOG_TYPE_OPTICAL_IO_READ                   (EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_OPTICAL_IO_READ)
#define PERFINFO_LOG_TYPE_OPTICAL_IO_WRITE                  (EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_OPTICAL_IO_WRITE)
#define PERFINFO_LOG_TYPE_OPTICAL_IO_FLUSH                  (EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_OPTICAL_IO_FLUSH)
#define PERFINFO_LOG_TYPE_OPTICAL_IO_READ_INIT              (EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_OPTICAL_IO_READ_INIT)
#define PERFINFO_LOG_TYPE_OPTICAL_IO_WRITE_INIT             (EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_OPTICAL_IO_WRITE_INIT)
#define PERFINFO_LOG_TYPE_OPTICAL_IO_FLUSH_INIT             (EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_OPTICAL_IO_FLUSH_INIT)

//
// Event types for Memory subsystem
//
#define WMI_LOG_TYPE_PAGE_FAULT_TRANSITION         (EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_TF)
#define WMI_LOG_TYPE_PAGE_FAULT_DEMAND_ZERO        (EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_DZF)
#define WMI_LOG_TYPE_PAGE_FAULT_COPY_ON_WRITE      (EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_COW)
#define WMI_LOG_TYPE_PAGE_FAULT_GUARD_PAGE         (EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_GPF)
#define WMI_LOG_TYPE_PAGE_FAULT_HARD_PAGE_FAULT    (EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_HPF)
#define WMI_LOG_TYPE_PAGE_FAULT_ACCESS_VIOLATION   (EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_AV)

#define PERFINFO_LOG_TYPE_HARDFAULT                (EVENT_TRACE_GROUP_MEMORY | 0x20)
#define PERFINFO_LOG_TYPE_REMOVEPAGEBYCOLOR        (EVENT_TRACE_GROUP_MEMORY | 0x21)
#define PERFINFO_LOG_TYPE_REMOVEPAGEFROMLIST       (EVENT_TRACE_GROUP_MEMORY | 0x22)
#define PERFINFO_LOG_TYPE_PAGEINMEMORY             (EVENT_TRACE_GROUP_MEMORY | 0x23)
#define PERFINFO_LOG_TYPE_INSERTINFREELIST         (EVENT_TRACE_GROUP_MEMORY | 0x24)
#define PERFINFO_LOG_TYPE_INSERTINMODIFIEDLIST     (EVENT_TRACE_GROUP_MEMORY | 0x25)
#define PERFINFO_LOG_TYPE_INSERTINLIST             (EVENT_TRACE_GROUP_MEMORY | 0x26)
#define PERFINFO_LOG_TYPE_INSERTATFRONT            (EVENT_TRACE_GROUP_MEMORY | 0x28)
#define PERFINFO_LOG_TYPE_UNLINKFROMSTANDBY        (EVENT_TRACE_GROUP_MEMORY | 0x29)
#define PERFINFO_LOG_TYPE_UNLINKFFREEORZERO        (EVENT_TRACE_GROUP_MEMORY | 0x2a)
#define PERFINFO_LOG_TYPE_WORKINGSETMANAGER        (EVENT_TRACE_GROUP_MEMORY | 0x2b)
#define PERFINFO_LOG_TYPE_TRIMPROCESS              (EVENT_TRACE_GROUP_MEMORY | 0x2c)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x2d)
#define PERFINFO_LOG_TYPE_ZEROSHARECOUNT           (EVENT_TRACE_GROUP_MEMORY | 0x2e)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x2f)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x30)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x31)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x32)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x33)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x34)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x35)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x36)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x37)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x38)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x39)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x3a)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x3b)
#define PERFINFO_LOG_TYPE_WSINFOPROCESS            (EVENT_TRACE_GROUP_MEMORY | 0x3c)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x3d)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x3e)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x3f)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x40)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x41)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x42)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x43)
// Reserved                                        (EVENT_TRACE_GROUP_MEMORY | 0x44)
#define PERFINFO_LOG_TYPE_FAULTADDR_WITH_IP        (EVENT_TRACE_GROUP_MEMORY | 0x45)
#define PERFINFO_LOG_TYPE_TRIMSESSION              (EVENT_TRACE_GROUP_MEMORY | 0x46)
#define PERFINFO_LOG_TYPE_MEMORYSNAPLITE           (EVENT_TRACE_GROUP_MEMORY | 0x47)
#define PERFINFO_LOG_TYPE_PFMAPPED_SECTION_RUNDOWN (EVENT_TRACE_GROUP_MEMORY | 0x48)
#define PERFINFO_LOG_TYPE_PFMAPPED_SECTION_CREATE  (EVENT_TRACE_GROUP_MEMORY | 0x49)
#define PERFINFO_LOG_TYPE_WSINFOSESSION            (EVENT_TRACE_GROUP_MEMORY | 0x4a)
#define PERFINFO_LOG_TYPE_CREATE_SESSION           (EVENT_TRACE_GROUP_MEMORY | 0x4b)
#define PERFINFO_LOG_TYPE_SESSION_RUNDOWN_DC_END   (EVENT_TRACE_GROUP_MEMORY | 0x4c)
#define PERFINFO_LOG_TYPE_SESSION_RUNDOWN_DC_START (EVENT_TRACE_GROUP_MEMORY | 0x4d)
#define PERFINFO_LOG_TYPE_SESSION_DELETE           (EVENT_TRACE_GROUP_MEMORY | 0x4e)
#define PERFINFO_LOG_TYPE_PFMAPPED_SECTION_DELETE  (EVENT_TRACE_GROUP_MEMORY | 0x4f)

#define PERFINFO_LOG_TYPE_VIRTUAL_ALLOC            (EVENT_TRACE_GROUP_MEMORY | 0x62)
#define PERFINFO_LOG_TYPE_VIRTUAL_FREE             (EVENT_TRACE_GROUP_MEMORY | 0x63)
#define PERFINFO_LOG_TYPE_HEAP_RANGE_RUNDOWN       (EVENT_TRACE_GROUP_MEMORY | 0x64)
#define PERFINFO_LOG_TYPE_HEAP_RANGE_CREATE        (EVENT_TRACE_GROUP_MEMORY | 0x65)
#define PERFINFO_LOG_TYPE_HEAP_RANGE_RESERVE       (EVENT_TRACE_GROUP_MEMORY | 0x66)
#define PERFINFO_LOG_TYPE_HEAP_RANGE_RELEASE       (EVENT_TRACE_GROUP_MEMORY | 0x67)
#define PERFINFO_LOG_TYPE_HEAP_RANGE_DESTROY       (EVENT_TRACE_GROUP_MEMORY | 0x68)

#define PERFINFO_LOG_TYPE_PAGEFILE_BACK            (EVENT_TRACE_GROUP_MEMORY | 0x69)
#define PERFINFO_LOG_TYPE_MEMINFO                  (EVENT_TRACE_GROUP_MEMORY | 0x70)
#define PERFINFO_LOG_TYPE_CONTMEM_GENERATE         (EVENT_TRACE_GROUP_MEMORY | 0x71)
#define PERFINFO_LOG_TYPE_FILE_STORE_FAULT         (EVENT_TRACE_GROUP_MEMORY | 0x72)
#define PERFINFO_LOG_TYPE_INMEMORY_STORE_FAULT     (EVENT_TRACE_GROUP_MEMORY | 0x73)
#define PERFINFO_LOG_TYPE_COMPRESSED_PAGE          (EVENT_TRACE_GROUP_MEMORY | 0x74)
#define PERFINFO_LOG_TYPE_PAGEINMEMORY_ACTIVE      (EVENT_TRACE_GROUP_MEMORY | 0x75)
#define PERFINFO_LOG_TYPE_PAGE_ACCESS              (EVENT_TRACE_GROUP_MEMORY | 0x76)
#define PERFINFO_LOG_TYPE_PAGE_RELEASE             (EVENT_TRACE_GROUP_MEMORY | 0x77)
#define PERFINFO_LOG_TYPE_PAGE_RANGE_ACCESS        (EVENT_TRACE_GROUP_MEMORY | 0x78)
#define PERFINFO_LOG_TYPE_PAGE_RANGE_RELEASE       (EVENT_TRACE_GROUP_MEMORY | 0x79)
#define PERFINFO_LOG_TYPE_PAGE_COMBINE             (EVENT_TRACE_GROUP_MEMORY | 0x7a)
#define PERFINFO_LOG_TYPE_KERNEL_MEMUSAGE          (EVENT_TRACE_GROUP_MEMORY | 0x7b)
#define PERFINFO_LOG_TYPE_MM_STATS                 (EVENT_TRACE_GROUP_MEMORY | 0x7c)
#define PERFINFO_LOG_TYPE_MEMINFOEX_WS             (EVENT_TRACE_GROUP_MEMORY | 0x7d)
#define PERFINFO_LOG_TYPE_MEMINFOEX_SESSIONWS      (EVENT_TRACE_GROUP_MEMORY | 0x7e)

#define PERFINFO_LOG_TYPE_VIRTUAL_ROTATE           (EVENT_TRACE_GROUP_MEMORY | 0x7f)
#define PERFINFO_LOG_TYPE_VIRTUAL_ALLOC_DC_START   (EVENT_TRACE_GROUP_MEMORY | 0x80)
#define PERFINFO_LOG_TYPE_VIRTUAL_ALLOC_DC_END     (EVENT_TRACE_GROUP_MEMORY | 0x81)

#define PERFINFO_LOG_TYPE_PAGE_ACCESS_EX           (EVENT_TRACE_GROUP_MEMORY | 0x82)
#define PERFINFO_LOG_TYPE_REMOVEFROMWS             (EVENT_TRACE_GROUP_MEMORY | 0x83)
#define PERFINFO_LOG_TYPE_WSSHAREABLE_RUNDOWN      (EVENT_TRACE_GROUP_MEMORY | 0x84)
#define PERFINFO_LOG_TYPE_INMEMORYACTIVE_RUNDOWN   (EVENT_TRACE_GROUP_MEMORY | 0x85)

#define PERFINFO_LOG_TYPE_MEM_RESET_INFO           (EVENT_TRACE_GROUP_MEMORY | 0x86)
#define PERFINFO_LOG_TYPE_PFMAPPED_SECTION_OBJECT_CREATE  (EVENT_TRACE_GROUP_MEMORY | 0x87)
#define PERFINFO_LOG_TYPE_PFMAPPED_SECTION_OBJECT_DELETE  (EVENT_TRACE_GROUP_MEMORY | 0x88)

//
//
// Event types for Registry subsystem
//
#define WMI_LOG_TYPE_REG_RUNDOWNBEGIN      (EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGKCBRUNDOWNBEGIN)
#define WMI_LOG_TYPE_REG_RUNDOWNEND        (EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGKCBRUNDOWNEND)

#define PERFINFO_LOG_TYPE_CMCELLREFERRED            (EVENT_TRACE_GROUP_REGISTRY | 0x20)
#define PERFINFO_LOG_TYPE_REG_SET_VALUE             (EVENT_TRACE_GROUP_REGISTRY | 0x21)
#define PERFINFO_LOG_TYPE_REG_COUNTERS              (EVENT_TRACE_GROUP_REGISTRY | 0x22)
#define PERFINFO_LOG_TYPE_REG_CONFIG                (EVENT_TRACE_GROUP_REGISTRY | 0x23)
#define PERFINFO_LOG_TYPE_REG_HIVE_INITIALIZE       (EVENT_TRACE_GROUP_REGISTRY | 0x24)
#define PERFINFO_LOG_TYPE_REG_HIVE_DESTROY          (EVENT_TRACE_GROUP_REGISTRY | 0x25)
#define PERFINFO_LOG_TYPE_REG_HIVE_LINK             (EVENT_TRACE_GROUP_REGISTRY | 0x26)
#define PERFINFO_LOG_TYPE_REG_HIVE_RUNDOWN_DC_END   (EVENT_TRACE_GROUP_REGISTRY | 0x27)
#define PERFINFO_LOG_TYPE_REG_HIVE_DIRTY            (EVENT_TRACE_GROUP_REGISTRY | 0x28)
// Reserved
#define PERFINFO_LOG_TYPE_REG_NOTIF_REGISTER        (EVENT_TRACE_GROUP_REGISTRY | 0x30)
#define PERFINFO_LOG_TYPE_REG_NOTIF_DELIVER         (EVENT_TRACE_GROUP_REGISTRY | 0x31)

//
// Event types for PERF tracing specific subsystem
//
#define PERFINFO_LOG_TYPE_RUNDOWN_CHECKPOINT           (EVENT_TRACE_GROUP_PERFINFO | 0x20)
// Reserved                                            (EVENT_TRACE_GROUP_PERFINFO | 0x21)
#define PERFINFO_LOG_TYPE_MARK                         (EVENT_TRACE_GROUP_PERFINFO | 0x22)
// Reserved                                            (EVENT_TRACE_GROUP_PERFINFO | 0x23)
#define PERFINFO_LOG_TYPE_ASYNCMARK                    (EVENT_TRACE_GROUP_PERFINFO | 0x24)
// Reserved                                            (EVENT_TRACE_GROUP_PERFINFO | 0x25)
#define PERFINFO_LOG_TYPE_IMAGENAME                    (EVENT_TRACE_GROUP_PERFINFO | 0x26)
#define PERFINFO_LOG_TYPE_DELAYS_CC_CAN_I_WRITE        (EVENT_TRACE_GROUP_PERFINFO | 0x27)
// Reserved                                            (EVENT_TRACE_GROUP_PERFINFO | 0x28)
// Reserved                                            (EVENT_TRACE_GROUP_PERFINFO | 0x29)
// Reserved                                            (EVENT_TRACE_GROUP_PERFINFO | 0x2a)
// Reserved                                            (EVENT_TRACE_GROUP_PERFINFO | 0x2b)
// Reserved                                            (EVENT_TRACE_GROUP_PERFINFO | 0x2c)
// Reserved                                            (EVENT_TRACE_GROUP_PERFINFO | 0x2d)
#define PERFINFO_LOG_TYPE_SAMPLED_PROFILE              (EVENT_TRACE_GROUP_PERFINFO | 0x2e)
#define PERFINFO_LOG_TYPE_PMC_INTERRUPT                (EVENT_TRACE_GROUP_PERFINFO | 0x2f)
#define PERFINFO_LOG_TYPE_PMC_CONFIG                   (EVENT_TRACE_GROUP_PERFINFO | 0x30)
// Reserved                                            (EVENT_TRACE_GROUP_PERFINFO | 0x31)
#define PERFINFO_LOG_TYPE_MSI_INTERRUPT                (EVENT_TRACE_GROUP_PERFINFO | 0x32)
#define PERFINFO_LOG_TYPE_SYSCALL_ENTER                (EVENT_TRACE_GROUP_PERFINFO | 0x33)
#define PERFINFO_LOG_TYPE_SYSCALL_EXIT                 (EVENT_TRACE_GROUP_PERFINFO | 0x34)
#define PERFINFO_LOG_TYPE_BACKTRACE                    (EVENT_TRACE_GROUP_PERFINFO | 0x35)
#define PERFINFO_LOG_TYPE_BACKTRACE_USERSTACK          (EVENT_TRACE_GROUP_PERFINFO | 0x36)
#define PERFINFO_LOG_TYPE_SAMPLED_PROFILE_CACHE        (EVENT_TRACE_GROUP_PERFINFO | 0x37)
#define PERFINFO_LOG_TYPE_EXCEPTION_STACK              (EVENT_TRACE_GROUP_PERFINFO | 0x38)
#define PERFINFO_LOG_TYPE_BRANCH_TRACE                 (EVENT_TRACE_GROUP_PERFINFO | 0x39)
#define PERFINFO_LOG_TYPE_DEBUGGER_ENABLED             (EVENT_TRACE_GROUP_PERFINFO | 0x3a)
#define PERFINFO_LOG_TYPE_DEBUGGER_EXIT                (EVENT_TRACE_GROUP_PERFINFO | 0x3b)
#define PERFINFO_LOG_TYPE_BRANCH_TRACE_DEBUG           (EVENT_TRACE_GROUP_PERFINFO | 0x40)
#define PERFINFO_LOG_TYPE_BRANCH_ADDRESS_DEBUG         (EVENT_TRACE_GROUP_PERFINFO | 0x41)
#define PERFINFO_LOG_TYPE_THREADED_DPC                 (EVENT_TRACE_GROUP_PERFINFO | 0x42)
#define PERFINFO_LOG_TYPE_INTERRUPT                    (EVENT_TRACE_GROUP_PERFINFO | 0x43)
#define PERFINFO_LOG_TYPE_DPC                          (EVENT_TRACE_GROUP_PERFINFO | 0x44)
#define PERFINFO_LOG_TYPE_TIMERDPC                     (EVENT_TRACE_GROUP_PERFINFO | 0x45)
#define PERFINFO_LOG_TYPE_IOTIMER_EXPIRATION           (EVENT_TRACE_GROUP_PERFINFO | 0x46)
#define PERFINFO_LOG_TYPE_SAMPLED_PROFILE_NMI          (EVENT_TRACE_GROUP_PERFINFO | 0x47)
#define PERFINFO_LOG_TYPE_SAMPLED_PROFILE_SET_INTERVAL (EVENT_TRACE_GROUP_PERFINFO | 0x48)
#define PERFINFO_LOG_TYPE_SAMPLED_PROFILE_DC_START     (EVENT_TRACE_GROUP_PERFINFO | 0x49)
#define PERFINFO_LOG_TYPE_SAMPLED_PROFILE_DC_END       (EVENT_TRACE_GROUP_PERFINFO | 0x4a)
#define PERFINFO_LOG_TYPE_SPINLOCK_DC_START            (EVENT_TRACE_GROUP_PERFINFO | 0x4b)
#define PERFINFO_LOG_TYPE_SPINLOCK_DC_END              (EVENT_TRACE_GROUP_PERFINFO | 0x4c)
#define PERFINFO_LOG_TYPE_ERESOURCE_DC_START           (EVENT_TRACE_GROUP_PERFINFO | 0x4d)
#define PERFINFO_LOG_TYPE_ERESOURCE_DC_END             (EVENT_TRACE_GROUP_PERFINFO | 0x4e)
#define PERFINFO_LOG_TYPE_CLOCK_INTERRUPT              (EVENT_TRACE_GROUP_PERFINFO | 0x4f)
#define PERFINFO_LOG_TYPE_TIMER_EXPIRATION_START       (EVENT_TRACE_GROUP_PERFINFO | 0x50)
#define PERFINFO_LOG_TYPE_TIMER_EXPIRATION             (EVENT_TRACE_GROUP_PERFINFO | 0x51)
#define PERFINFO_LOG_TYPE_TIMER_SET_PERIODIC           (EVENT_TRACE_GROUP_PERFINFO | 0x52)
#define PERFINFO_LOG_TYPE_TIMER_SET_ONE_SHOT           (EVENT_TRACE_GROUP_PERFINFO | 0x53)
#define PERFINFO_LOG_TYPE_TIMER_SET_THREAD             (EVENT_TRACE_GROUP_PERFINFO | 0x54)
#define PERFINFO_LOG_TYPE_TIMER_CANCEL                 (EVENT_TRACE_GROUP_PERFINFO | 0x55)
#define PERFINFO_LOG_TYPE_TIME_ADJUSTMENT              (EVENT_TRACE_GROUP_PERFINFO | 0x56)
#define PERFINFO_LOG_TYPE_CLOCK_MODE_SWITCH            (EVENT_TRACE_GROUP_PERFINFO | 0x57)
#define PERFINFO_LOG_TYPE_CLOCK_TIME_UPDATE            (EVENT_TRACE_GROUP_PERFINFO | 0x58)
#define PERFINFO_LOG_TYPE_CLOCK_DYNAMIC_TICK_VETO      (EVENT_TRACE_GROUP_PERFINFO | 0x59)
#define PERFINFO_LOG_TYPE_CLOCK_CONFIGURATION          (EVENT_TRACE_GROUP_PERFINFO | 0x5a)
#define PERFINFO_LOG_TYPE_IPI                          (EVENT_TRACE_GROUP_PERFINFO | 0x5b)
#define PERFINFO_LOG_TYPE_UNEXPECTED_INTERRUPT         (EVENT_TRACE_GROUP_PERFINFO | 0x5c)
#define PERFINFO_LOG_TYPE_IOTIMER_START                (EVENT_TRACE_GROUP_PERFINFO | 0x5d)
#define PERFINFO_LOG_TYPE_IOTIMER_STOP                 (EVENT_TRACE_GROUP_PERFINFO | 0x5e)
#define PERFINFO_LOG_TYPE_PASSIVE_INTERRUPT            (EVENT_TRACE_GROUP_PERFINFO | 0x5f)
#define PERFINFO_LOG_TYPE_WDF_INTERRUPT                (EVENT_TRACE_GROUP_PERFINFO | 0x60)
#define PERFINFO_LOG_TYPE_WDF_PASSIVE_INTERRUPT        (EVENT_TRACE_GROUP_PERFINFO | 0x61)
#define PERFINFO_LOG_TYPE_WDF_DPC                      (EVENT_TRACE_GROUP_PERFINFO | 0x62)
#define PERFINFO_LOG_TYPE_CPU_CACHE_FLUSH              (EVENT_TRACE_GROUP_PERFINFO | 0x63)
#define PERFINFO_LOG_TYPE_DPC_ENQUEUE                  (EVENT_TRACE_GROUP_PERFINFO | 0x64)
#define PERFINFO_LOG_TYPE_DPC_EXECUTION                (EVENT_TRACE_GROUP_PERFINFO | 0x65)
#define PERFINFO_LOG_TYPE_INTERRUPT_STEERING           (EVENT_TRACE_GROUP_PERFINFO | 0x66)
#define PERFINFO_LOG_TYPE_WDF_WORK_ITEM                (EVENT_TRACE_GROUP_PERFINFO | 0x67)
#define PERFINFO_LOG_TYPE_KTIMER2_SET                  (EVENT_TRACE_GROUP_PERFINFO | 0x68)
#define PERFINFO_LOG_TYPE_KTIMER2_EXPIRATION           (EVENT_TRACE_GROUP_PERFINFO | 0x69)
#define PERFINFO_LOG_TYPE_KTIMER2_CANCEL               (EVENT_TRACE_GROUP_PERFINFO | 0x6a)
#define PERFINFO_LOG_TYPE_KTIMER2_DISABLE              (EVENT_TRACE_GROUP_PERFINFO | 0x6b)
#define PERFINFO_LOG_TYPE_KTIMER2_FINALIZATION         (EVENT_TRACE_GROUP_PERFINFO | 0x6c)
#define PERFINFO_LOG_TYPE_SHOULD_YIELD_PROCESSOR       (EVENT_TRACE_GROUP_PERFINFO | 0x6d)

//
// Event types for ICE.
//

#define PERFINFO_LOG_TYPE_FUNCTION_CALL                (EVENT_TRACE_GROUP_PERFINFO | 0x80)
#define PERFINFO_LOG_TYPE_FUNCTION_RETURN              (EVENT_TRACE_GROUP_PERFINFO | 0x81)
#define PERFINFO_LOG_TYPE_FUNCTION_ENTER               (EVENT_TRACE_GROUP_PERFINFO | 0x82)
#define PERFINFO_LOG_TYPE_FUNCTION_EXIT                (EVENT_TRACE_GROUP_PERFINFO | 0x83)
#define PERFINFO_LOG_TYPE_TAILCALL                     (EVENT_TRACE_GROUP_PERFINFO | 0x84)
#define PERFINFO_LOG_TYPE_TRAP                         (EVENT_TRACE_GROUP_PERFINFO | 0x85)
#define PERFINFO_LOG_TYPE_SPINLOCK_ACQUIRE             (EVENT_TRACE_GROUP_PERFINFO | 0x86)
#define PERFINFO_LOG_TYPE_SPINLOCK_RELEASE             (EVENT_TRACE_GROUP_PERFINFO | 0x87)
#define PERFINFO_LOG_TYPE_CAP_COMMENT                  (EVENT_TRACE_GROUP_PERFINFO | 0x88)
#define PERFINFO_LOG_TYPE_CAP_RUNDOWN                  (EVENT_TRACE_GROUP_PERFINFO | 0x89)

//
// Event types for Debugger subsystem.
//

#define PERFINFO_LOG_TYPE_DEBUG_PRINT                  (EVENT_TRACE_GROUP_DBGPRINT | 0x20)

//
// Event types for WNF facility
//

#define PERFINFO_LOG_TYPE_WNF_SUBSCRIBE                (EVENT_TRACE_GROUP_WNF | 0x20)
#define PERFINFO_LOG_TYPE_WNF_UNSUBSCRIBE              (EVENT_TRACE_GROUP_WNF | 0x21)
#define PERFINFO_LOG_TYPE_WNF_CALLBACK                 (EVENT_TRACE_GROUP_WNF | 0x22)
#define PERFINFO_LOG_TYPE_WNF_PUBLISH                  (EVENT_TRACE_GROUP_WNF | 0x23)
#define PERFINFO_LOG_TYPE_WNF_NAME_SUB_RUNDOWN         (EVENT_TRACE_GROUP_WNF | 0x24)

//
// Event types for Pool subsystem.
//

#define PERFINFO_LOG_TYPE_ALLOCATEPOOL                 (EVENT_TRACE_GROUP_POOL | 0x20)
#define PERFINFO_LOG_TYPE_ALLOCATEPOOL_SESSION         (EVENT_TRACE_GROUP_POOL | 0x21)
#define PERFINFO_LOG_TYPE_FREEPOOL                     (EVENT_TRACE_GROUP_POOL | 0x22)
#define PERFINFO_LOG_TYPE_FREEPOOL_SESSION             (EVENT_TRACE_GROUP_POOL | 0x23)
#define PERFINFO_LOG_TYPE_ADDPOOLPAGE                  (EVENT_TRACE_GROUP_POOL | 0x24)
#define PERFINFO_LOG_TYPE_ADDPOOLPAGE_SESSION          (EVENT_TRACE_GROUP_POOL | 0x25)
#define PERFINFO_LOG_TYPE_BIGPOOLPAGE                  (EVENT_TRACE_GROUP_POOL | 0x26)
#define PERFINFO_LOG_TYPE_BIGPOOLPAGE_SESSION          (EVENT_TRACE_GROUP_POOL | 0x27)
#define PERFINFO_LOG_TYPE_POOLSNAP_DC_START            (EVENT_TRACE_GROUP_POOL | 0x28)
#define PERFINFO_LOG_TYPE_POOLSNAP_DC_END              (EVENT_TRACE_GROUP_POOL | 0x29)
#define PERFINFO_LOG_TYPE_BIGPOOLSNAP_DC_START         (EVENT_TRACE_GROUP_POOL | 0x2a)
#define PERFINFO_LOG_TYPE_BIGPOOLSNAP_DC_END           (EVENT_TRACE_GROUP_POOL | 0x2b)
#define PERFINFO_LOG_TYPE_POOLSNAP_SESSION_DC_START    (EVENT_TRACE_GROUP_POOL | 0x2c)
#define PERFINFO_LOG_TYPE_POOLSNAP_SESSION_DC_END      (EVENT_TRACE_GROUP_POOL | 0x2d)
#define PERFINFO_LOG_TYPE_SESSIONBIGPOOLSNAP_DC_START  (EVENT_TRACE_GROUP_POOL | 0x2e)
#define PERFINFO_LOG_TYPE_SESSIONBIGPOOLSNAP_DC_END    (EVENT_TRACE_GROUP_POOL | 0x2f)

//
// Event types for Heap subsystem
//
#define PERFINFO_LOG_TYPE_HEAP_CREATE                  (EVENT_TRACE_GROUP_HEAP | 0x20)
#define PERFINFO_LOG_TYPE_HEAP_ALLOC                   (EVENT_TRACE_GROUP_HEAP | 0x21)
#define PERFINFO_LOG_TYPE_HEAP_REALLOC                 (EVENT_TRACE_GROUP_HEAP | 0x22)
#define PERFINFO_LOG_TYPE_HEAP_DESTROY                 (EVENT_TRACE_GROUP_HEAP | 0x23)
#define PERFINFO_LOG_TYPE_HEAP_FREE                    (EVENT_TRACE_GROUP_HEAP | 0x24)
#define PERFINFO_LOG_TYPE_HEAP_EXTEND                  (EVENT_TRACE_GROUP_HEAP | 0x25)
#define PERFINFO_LOG_TYPE_HEAP_SNAPSHOT                (EVENT_TRACE_GROUP_HEAP | 0x26)
#define PERFINFO_LOG_TYPE_HEAP_CREATE_SNAPSHOT         (EVENT_TRACE_GROUP_HEAP | 0x27)
#define PERFINFO_LOG_TYPE_HEAP_DESTROY_SNAPSHOT        (EVENT_TRACE_GROUP_HEAP | 0x28)
#define PERFINFO_LOG_TYPE_HEAP_EXTEND_SNAPSHOT         (EVENT_TRACE_GROUP_HEAP | 0x29)
#define PERFINFO_LOG_TYPE_HEAP_CONTRACT                (EVENT_TRACE_GROUP_HEAP | 0x2a)
#define PERFINFO_LOG_TYPE_HEAP_LOCK                    (EVENT_TRACE_GROUP_HEAP | 0x2b)
#define PERFINFO_LOG_TYPE_HEAP_UNLOCK                  (EVENT_TRACE_GROUP_HEAP | 0x2c)
#define PERFINFO_LOG_TYPE_HEAP_VALIDATE                (EVENT_TRACE_GROUP_HEAP | 0x2d)
#define PERFINFO_LOG_TYPE_HEAP_WALK                    (EVENT_TRACE_GROUP_HEAP | 0x2e)

#define PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_ALLOC          (EVENT_TRACE_GROUP_HEAP | 0x2f)
#define PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_FREE           (EVENT_TRACE_GROUP_HEAP | 0x30)
#define PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_ALLOC_CACHE    (EVENT_TRACE_GROUP_HEAP | 0x31)
#define PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_FREE_CACHE     (EVENT_TRACE_GROUP_HEAP | 0x32)
#define PERFINFO_LOG_TYPE_HEAP_COMMIT                    (EVENT_TRACE_GROUP_HEAP | 0x33)
#define PERFINFO_LOG_TYPE_HEAP_DECOMMIT                  (EVENT_TRACE_GROUP_HEAP | 0x34)
#define PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_INIT           (EVENT_TRACE_GROUP_HEAP | 0x35)
#define PERFINFO_LOG_TYPE_HEAP_AFFINITY_ENABLE           (EVENT_TRACE_GROUP_HEAP | 0x36)
//Reserved                                               (EVENT_TRACE_GROUP_HEAP | 0x37)
#define PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_ACTIVATED      (EVENT_TRACE_GROUP_HEAP | 0x38)
#define PERFINFO_LOG_TYPE_HEAP_AFFINITY_ASSIGN           (EVENT_TRACE_GROUP_HEAP | 0x39)
#define PERFINFO_LOG_TYPE_HEAP_REUSE_THRESHOLD_ACTIVATED (EVENT_TRACE_GROUP_HEAP | 0x3a)

//
// Event Types for Critical Section Subsystem
//

#define PERFINFO_LOG_TYPE_CRITSEC_ENTER                (EVENT_TRACE_GROUP_CRITSEC | 0x20)
#define PERFINFO_LOG_TYPE_CRITSEC_LEAVE                (EVENT_TRACE_GROUP_CRITSEC | 0x21)
#define PERFINFO_LOG_TYPE_CRITSEC_COLLISION            (EVENT_TRACE_GROUP_CRITSEC | 0x22)
#define PERFINFO_LOG_TYPE_CRITSEC_INITIALIZE           (EVENT_TRACE_GROUP_CRITSEC | 0x23)

//
// Event types for Stackwalk subsystem
//

#define PERFINFO_LOG_TYPE_STACKWALK                    (EVENT_TRACE_GROUP_STACKWALK | 0x20)
//Reserved                                             (EVENT_TRACE_GROUP_STACKWALK | 0x21)
#define PERFINFO_LOG_TYPE_STACKTRACE_CREATE            (EVENT_TRACE_GROUP_STACKWALK | 0x22)
#define PERFINFO_LOG_TYPE_STACKTRACE_DELETE            (EVENT_TRACE_GROUP_STACKWALK | 0x23)
#define PERFINFO_LOG_TYPE_STACKTRACE_RUNDOWN           (EVENT_TRACE_GROUP_STACKWALK | 0x24)
#define PERFINFO_LOG_TYPE_STACKTRACE_KEY_KERNEL        (EVENT_TRACE_GROUP_STACKWALK | 0x25)
#define PERFINFO_LOG_TYPE_STACKTRACE_KEY_USER          (EVENT_TRACE_GROUP_STACKWALK | 0x26)

//
// Event types for ALPC
//

#define WMI_LOG_TYPE_ALPC_SEND_MESSAGE                  (EVENT_TRACE_GROUP_ALPC | 0x21)
#define WMI_LOG_TYPE_ALPC_RECEIVE_MESSAGE               (EVENT_TRACE_GROUP_ALPC | 0x22)
#define WMI_LOG_TYPE_ALPC_WAIT_FOR_REPLY                (EVENT_TRACE_GROUP_ALPC | 0x23)
#define WMI_LOG_TYPE_ALPC_WAIT_FOR_NEW_MESSAGE          (EVENT_TRACE_GROUP_ALPC | 0x24)
#define WMI_LOG_TYPE_ALPC_UNWAIT                        (EVENT_TRACE_GROUP_ALPC | 0x25)
#define WMI_LOG_TYPE_ALPC_CONNECT_REQUEST               (EVENT_TRACE_GROUP_ALPC | 0x26)
#define WMI_LOG_TYPE_ALPC_CONNECT_SUCCESS               (EVENT_TRACE_GROUP_ALPC | 0x27)
#define WMI_LOG_TYPE_ALPC_CONNECT_FAIL                  (EVENT_TRACE_GROUP_ALPC | 0x28)
#define WMI_LOG_TYPE_ALPC_CLOSE_PORT                    (EVENT_TRACE_GROUP_ALPC | 0x29)


//
// Event types for Object Manager subsystem
//

#define PERFINFO_LOG_TYPE_CREATE_HANDLE                (EVENT_TRACE_GROUP_OBJECT | 0x20)
#define PERFINFO_LOG_TYPE_CLOSE_HANDLE                 (EVENT_TRACE_GROUP_OBJECT | 0x21)
#define PERFINFO_LOG_TYPE_DUPLICATE_HANDLE             (EVENT_TRACE_GROUP_OBJECT | 0x22)
//Reserved                                             (EVENT_TRACE_GROUP_OBJECT | 0x23)
#define PERFINFO_LOG_TYPE_OBJECT_TYPE_DC_START         (EVENT_TRACE_GROUP_OBJECT | 0x24)
#define PERFINFO_LOG_TYPE_OBJECT_TYPE_DC_END           (EVENT_TRACE_GROUP_OBJECT | 0x25)
#define PERFINFO_LOG_TYPE_OBJECT_HANDLE_DC_START       (EVENT_TRACE_GROUP_OBJECT | 0x26)
#define PERFINFO_LOG_TYPE_OBJECT_HANDLE_DC_END         (EVENT_TRACE_GROUP_OBJECT | 0x27)
//Reserved                                             (EVENT_TRACE_GROUP_OBJECT | 0x28)
//Reserved                                             (EVENT_TRACE_GROUP_OBJECT | 0x29)
//Reserved                                             (EVENT_TRACE_GROUP_OBJECT | 0x2a)
//Reserved                                             (EVENT_TRACE_GROUP_OBJECT | 0x2b)
//Reserved                                             (EVENT_TRACE_GROUP_OBJECT | 0x2c)
//Reserved                                             (EVENT_TRACE_GROUP_OBJECT | 0x2d)
//Reserved                                             (EVENT_TRACE_GROUP_OBJECT | 0x2e)
//Reserved                                             (EVENT_TRACE_GROUP_OBJECT | 0x2f)
#define PERFINFO_LOG_TYPE_CREATE_OBJECT                (EVENT_TRACE_GROUP_OBJECT | 0x30)
#define PERFINFO_LOG_TYPE_DELETE_OBJECT                (EVENT_TRACE_GROUP_OBJECT | 0x31)
#define PERFINFO_LOG_TYPE_REFERENCE_OBJECT             (EVENT_TRACE_GROUP_OBJECT | 0x32)
#define PERFINFO_LOG_TYPE_DEREFERENCE_OBJECT           (EVENT_TRACE_GROUP_OBJECT | 0x33)

//
// Event types for Power subsystem
//

#define PERFINFO_LOG_TYPE_BATTERY_LIFE_INFO            (EVENT_TRACE_GROUP_POWER | 0x20)
#define PERFINFO_LOG_TYPE_IDLE_STATE_CHANGE            (EVENT_TRACE_GROUP_POWER | 0x21)
#define PERFINFO_LOG_TYPE_SET_POWER_ACTION             (EVENT_TRACE_GROUP_POWER | 0x22)
#define PERFINFO_LOG_TYPE_SET_POWER_ACTION_RET         (EVENT_TRACE_GROUP_POWER | 0x23)
#define PERFINFO_LOG_TYPE_SET_DEVICES_STATE            (EVENT_TRACE_GROUP_POWER | 0x24)
#define PERFINFO_LOG_TYPE_SET_DEVICES_STATE_RET        (EVENT_TRACE_GROUP_POWER | 0x25)
#define PERFINFO_LOG_TYPE_PO_NOTIFY_DEVICE             (EVENT_TRACE_GROUP_POWER | 0x26)
#define PERFINFO_LOG_TYPE_PO_NOTIFY_DEVICE_COMPLETE    (EVENT_TRACE_GROUP_POWER | 0x27)
#define PERFINFO_LOG_TYPE_PO_SESSION_CALLOUT           (EVENT_TRACE_GROUP_POWER | 0x28)
#define PERFINFO_LOG_TYPE_PO_SESSION_CALLOUT_RET       (EVENT_TRACE_GROUP_POWER | 0x29)
#define PERFINFO_LOG_TYPE_PO_PRESLEEP                  (EVENT_TRACE_GROUP_POWER | 0x30)
#define PERFINFO_LOG_TYPE_PO_POSTSLEEP                 (EVENT_TRACE_GROUP_POWER | 0x31)
#define PERFINFO_LOG_TYPE_PO_CALIBRATED_PERFCOUNTER    (EVENT_TRACE_GROUP_POWER | 0x32)
#define PERFINFO_LOG_TYPE_PPM_PERF_STATE_CHANGE        (EVENT_TRACE_GROUP_POWER | 0x33)
#define PERFINFO_LOG_TYPE_PPM_THROTTLE_STATE_CHANGE    (EVENT_TRACE_GROUP_POWER | 0x34)
#define PERFINFO_LOG_TYPE_PPM_IDLE_STATE_CHANGE        (EVENT_TRACE_GROUP_POWER | 0x35)
#define PERFINFO_LOG_TYPE_PPM_THERMAL_CONSTRAINT       (EVENT_TRACE_GROUP_POWER | 0x36)
#define PERFINFO_LOG_TYPE_PO_SIGNAL_RESUME_UI          (EVENT_TRACE_GROUP_POWER | 0x37)
#define PERFINFO_LOG_TYPE_PO_SIGNAL_VIDEO_ON           (EVENT_TRACE_GROUP_POWER | 0x38)
#define PERFINFO_LOG_TYPE_PPM_IDLE_STATE_ENTER         (EVENT_TRACE_GROUP_POWER | 0x39)
#define PERFINFO_LOG_TYPE_PPM_IDLE_STATE_EXIT          (EVENT_TRACE_GROUP_POWER | 0x3a)
#define PERFINFO_LOG_TYPE_PPM_PLATFORM_IDLE_STATE_ENTER (EVENT_TRACE_GROUP_POWER | 0x3b)
#define PERFINFO_LOG_TYPE_PPM_IDLE_EXIT_LATENCY        (EVENT_TRACE_GROUP_POWER | 0x3c)
#define PERFINFO_LOG_TYPE_PPM_IDLE_PROCESSOR_SELECTION (EVENT_TRACE_GROUP_POWER | 0x3d)
#define PERFINFO_LOG_TYPE_PPM_IDLE_PLATFORM_SELECTION  (EVENT_TRACE_GROUP_POWER | 0x3e)
#define PERFINFO_LOG_TYPE_PPM_COORDINATED_IDLE_ENTER   (EVENT_TRACE_GROUP_POWER | 0x3f)
#define PERFINFO_LOG_TYPE_PPM_COORDINATED_IDLE_EXIT    (EVENT_TRACE_GROUP_POWER | 0x40)

//
// Event types for MODBound subsystem
//
#define PERFINFO_LOG_TYPE_COWHEADER                    (EVENT_TRACE_GROUP_MODBOUND | 0x18)
#define PERFINFO_LOG_TYPE_COWBLOB                      (EVENT_TRACE_GROUP_MODBOUND | 0x19)
#define PERFINFO_LOG_TYPE_COWBLOB_CLOSED               (EVENT_TRACE_GROUP_MODBOUND | 0x1a)
#define PERFINFO_LOG_TYPE_MODULEBOUND_ENT              (EVENT_TRACE_GROUP_MODBOUND | 0x20)
#define PERFINFO_LOG_TYPE_MODULEBOUND_JUMP             (EVENT_TRACE_GROUP_MODBOUND | 0x21)
#define PERFINFO_LOG_TYPE_MODULEBOUND_RET              (EVENT_TRACE_GROUP_MODBOUND | 0x22)
#define PERFINFO_LOG_TYPE_MODULEBOUND_CALL             (EVENT_TRACE_GROUP_MODBOUND | 0x23)
#define PERFINFO_LOG_TYPE_MODULEBOUND_CALLRET          (EVENT_TRACE_GROUP_MODBOUND | 0x24)
#define PERFINFO_LOG_TYPE_MODULEBOUND_INT2E            (EVENT_TRACE_GROUP_MODBOUND | 0x25)
#define PERFINFO_LOG_TYPE_MODULEBOUND_INT2B            (EVENT_TRACE_GROUP_MODBOUND | 0x26)
#define PERFINFO_LOG_TYPE_MODULEBOUND_FULLTRACE        (EVENT_TRACE_GROUP_MODBOUND | 0x27)

//
// Event types for the thread class scheduler
//
// TODO: Because MMCSS is a DLL it doesn't need to use UMGL.
//
#define PERFINFO_LOG_TYPE_MMCSS_START                  (0x20)
#define PERFINFO_LOG_TYPE_MMCSS_STOP                   (0x21)
#define PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_EVENT        (0x22)
#define PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_WAKEUP       (0x23)
#define PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_SLEEP        (0x24)
#define PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_SLEEP_RESP   (0x25)


//
// Event types for SplitIo
//

#define PERFINFO_LOG_TYPE_SPLITIO_VOLMGR                    (EVENT_TRACE_GROUP_SPLITIO | 0x20)

// Event types for ThreadPool
#define PERFINFO_LOG_TYPE_TP_CALLBACK_ENQUEUE               (EVENT_TRACE_GROUP_THREAD_POOL | 0x20)
#define PERFINFO_LOG_TYPE_TP_CALLBACK_DEQUEUE               (EVENT_TRACE_GROUP_THREAD_POOL | 0x21)
#define PERFINFO_LOG_TYPE_TP_CALLBACK_START                 (EVENT_TRACE_GROUP_THREAD_POOL | 0x22)
#define PERFINFO_LOG_TYPE_TP_CALLBACK_STOP                  (EVENT_TRACE_GROUP_THREAD_POOL | 0x23)
#define PERFINFO_LOG_TYPE_TP_CALLBACK_CANCEL                (EVENT_TRACE_GROUP_THREAD_POOL | 0x24)
#define PERFINFO_LOG_TYPE_TP_POOL_CREATE                    (EVENT_TRACE_GROUP_THREAD_POOL | 0x25)
#define PERFINFO_LOG_TYPE_TP_POOL_CLOSE                     (EVENT_TRACE_GROUP_THREAD_POOL | 0x26)
#define PERFINFO_LOG_TYPE_TP_POOL_TH_MIN_SET                (EVENT_TRACE_GROUP_THREAD_POOL | 0x27)
#define PERFINFO_LOG_TYPE_TP_POOL_TH_MAX_SET                (EVENT_TRACE_GROUP_THREAD_POOL | 0x28)
#define PERFINFO_LOG_TYPE_TP_WORKER_NUMANODE_SWITCH         (EVENT_TRACE_GROUP_THREAD_POOL | 0x29)
#define PERFINFO_LOG_TYPE_TP_TIMER_SET                      (EVENT_TRACE_GROUP_THREAD_POOL | 0x2a)
#define PERFINFO_LOG_TYPE_TP_TIMER_CANCELLED                (EVENT_TRACE_GROUP_THREAD_POOL | 0x2b)
#define PERFINFO_LOG_TYPE_TP_TIMER_SET_NTTIMER              (EVENT_TRACE_GROUP_THREAD_POOL | 0x2c)
#define PERFINFO_LOG_TYPE_TP_TIMER_CANCEL_NTTIMER           (EVENT_TRACE_GROUP_THREAD_POOL | 0x2d)
#define PERFINFO_LOG_TYPE_TP_TIMER_EXPIRATION_BEGIN         (EVENT_TRACE_GROUP_THREAD_POOL | 0x2e)
#define PERFINFO_LOG_TYPE_TP_TIMER_EXPIRATION_END           (EVENT_TRACE_GROUP_THREAD_POOL | 0x2f)
#define PERFINFO_LOG_TYPE_TP_TIMER_EXPIRATION               (EVENT_TRACE_GROUP_THREAD_POOL | 0x30)

// Event types for UMS
#define PERFINFO_LOG_TYPE_UMS_DIRECTED_SWITCH_START         (EVENT_TRACE_GROUP_UMS | 0x20)
#define PERFINFO_LOG_TYPE_UMS_DIRECTED_SWITCH_END           (EVENT_TRACE_GROUP_UMS | 0x21)
#define PERFINFO_LOG_TYPE_UMS_PARK                          (EVENT_TRACE_GROUP_UMS | 0x22)
#define PERFINFO_LOG_TYPE_UMS_DISASSOCIATE                  (EVENT_TRACE_GROUP_UMS | 0x23)
#define PERFINFO_LOG_TYPE_UMS_CONTEXT_SWITCH                (EVENT_TRACE_GROUP_UMS | 0x24)

// Event types for Cache manager
#define PERFINFO_LOG_TYPE_CC_WORKITEM_ENQUEUE               (EVENT_TRACE_GROUP_CC | 0x00)
#define PERFINFO_LOG_TYPE_CC_WORKITEM_DEQUEUE               (EVENT_TRACE_GROUP_CC | 0x01)
#define PERFINFO_LOG_TYPE_CC_WORKITEM_COMPLETE              (EVENT_TRACE_GROUP_CC | 0x02)
#define PERFINFO_LOG_TYPE_CC_READ_AHEAD                     (EVENT_TRACE_GROUP_CC | 0x03)
#define PERFINFO_LOG_TYPE_CC_WRITE_BEHIND                   (EVENT_TRACE_GROUP_CC | 0x04)
#define PERFINFO_LOG_TYPE_CC_LAZY_WRITE_SCAN                (EVENT_TRACE_GROUP_CC | 0x05)
#define PERFINFO_LOG_TYPE_CC_CAN_I_WRITE_FAIL               (EVENT_TRACE_GROUP_CC | 0x06)
//#define PERFINFO_LOG_TYPE_CC_MAP_VIEW                       (EVENT_TRACE_GROUP_CC | 0x07)
//#define PERFINFO_LOG_TYPE_CC_UNMAP_VIEW                     (EVENT_TRACE_GROUP_CC | 0x08)
#define PERFINFO_LOG_TYPE_CC_FLUSH_CACHE                    (EVENT_TRACE_GROUP_CC | 0x09)
#define PERFINFO_LOG_TYPE_CC_FLUSH_SECTION                  (EVENT_TRACE_GROUP_CC | 0x0a)
#define PERFINFO_LOG_TYPE_CC_READ_AHEAD_PREFETCH            (EVENT_TRACE_GROUP_CC | 0x0b)
#define PERFINFO_LOG_TYPE_CC_SCHEDULE_READ_AHEAD            (EVENT_TRACE_GROUP_CC | 0x0c)
#define PERFINFO_LOG_TYPE_CC_LOGGED_STREAM_INFO             (EVENT_TRACE_GROUP_CC | 0x0d)
#define PERFINFO_LOG_TYPE_CC_EXTRA_WRITEBEHIND_THREAD       (EVENT_TRACE_GROUP_CC | 0x0e)

typedef ULONG PERFINFO_MASK;

typedef struct _PERFINFO_GROUPMASK
{
    ULONG Masks[PERF_NUM_MASKS];
} PERFINFO_GROUPMASK, *PPERFINFO_GROUPMASK;

typedef struct _EVENT_TRACE_GROUPMASK_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    TRACEHANDLE TraceHandle;
    PERFINFO_GROUPMASK EventTraceGroupMasks;
} EVENT_TRACE_GROUPMASK_INFORMATION, *PEVENT_TRACE_GROUPMASK_INFORMATION;

typedef struct _EVENT_TRACE_PERFORMANCE_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    LARGE_INTEGER LogfileBytesWritten;
} EVENT_TRACE_PERFORMANCE_INFORMATION, *PEVENT_TRACE_PERFORMANCE_INFORMATION;

typedef struct _EVENT_TRACE_TIME_PROFILE_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    ULONG ProfileInterval;
} EVENT_TRACE_TIME_PROFILE_INFORMATION, *PEVENT_TRACE_TIME_PROFILE_INFORMATION;

typedef struct _EVENT_TRACE_SESSION_SECURITY_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    ULONG SecurityInformation;
    TRACEHANDLE TraceHandle;
    UCHAR SecurityDescriptor[1];
} EVENT_TRACE_SESSION_SECURITY_INFORMATION, *PEVENT_TRACE_SESSION_SECURITY_INFORMATION;

typedef struct _EVENT_TRACE_SPINLOCK_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    ULONG SpinLockSpinThreshold;
    ULONG SpinLockAcquireSampleRate;
    ULONG SpinLockContentionSampleRate;
    ULONG SpinLockHoldThreshold;
} EVENT_TRACE_SPINLOCK_INFORMATION, *PEVENT_TRACE_SPINLOCK_INFORMATION;

typedef struct _EVENT_TRACE_SYSTEM_EVENT_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    TRACEHANDLE TraceHandle;
    ULONG HookId[1];
} EVENT_TRACE_SYSTEM_EVENT_INFORMATION, *PEVENT_TRACE_SYSTEM_EVENT_INFORMATION;

typedef struct _EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    ULONG ReleaseSamplingRate;
    ULONG ContentionSamplingRate;
    ULONG NumberOfExcessiveTimeouts;
} EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION, *PEVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION;

typedef struct _EVENT_TRACE_HEAP_TRACING_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    ULONG ProcessId[1];
} EVENT_TRACE_HEAP_TRACING_INFORMATION, *PEVENT_TRACE_HEAP_TRACING_INFORMATION;

typedef struct _EVENT_TRACE_TAG_FILTER_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    TRACEHANDLE TraceHandle;
    ULONG Filter[1];
} EVENT_TRACE_TAG_FILTER_INFORMATION, *PEVENT_TRACE_TAG_FILTER_INFORMATION;

typedef struct _EVENT_TRACE_PROFILE_COUNTER_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    TRACEHANDLE TraceHandle;
    ULONG ProfileSource[1];
} EVENT_TRACE_PROFILE_COUNTER_INFORMATION, *PEVENT_TRACE_PROFILE_COUNTER_INFORMATION;

//typedef struct _PROFILE_SOURCE_INFO
//{
//    ULONG NextEntryOffset;
//    ULONG Source;
//    ULONG MinInterval;
//    ULONG MaxInterval;
//    PVOID Reserved;
//    WCHAR Description[1];
//} PROFILE_SOURCE_INFO, *PPROFILE_SOURCE_INFO;

typedef struct _EVENT_TRACE_PROFILE_LIST_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    ULONG Spare;
    struct _PROFILE_SOURCE_INFO* Profile[1];
} EVENT_TRACE_PROFILE_LIST_INFORMATION, *PEVENT_TRACE_PROFILE_LIST_INFORMATION;

typedef struct _EVENT_TRACE_STACK_CACHING_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    TRACEHANDLE TraceHandle;
    BOOLEAN Enabled;
    UCHAR Reserved[3];
    ULONG CacheSize;
    ULONG BucketCount;
} EVENT_TRACE_STACK_CACHING_INFORMATION, *PEVENT_TRACE_STACK_CACHING_INFORMATION;

typedef struct _EVENT_TRACE_SOFT_RESTART_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    TRACEHANDLE TraceHandle;
    BOOLEAN PersistTraceBuffers;
    WCHAR FileName[1];
} EVENT_TRACE_SOFT_RESTART_INFORMATION, *PEVENT_TRACE_SOFT_RESTART_INFORMATION;

typedef struct _EVENT_TRACE_PROFILE_ADD_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    BOOLEAN PerfEvtEventSelect;
    BOOLEAN PerfEvtUnitSelect;
    ULONG PerfEvtType;
    ULONG CpuInfoHierarchy[0x3];
    ULONG InitialInterval;
    BOOLEAN AllowsHalt;
    BOOLEAN Persist;
    WCHAR ProfileSourceDescription[0x1];
} EVENT_TRACE_PROFILE_ADD_INFORMATION, *PEVENT_TRACE_PROFILE_ADD_INFORMATION;

typedef struct _EVENT_TRACE_PROFILE_REMOVE_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    KPROFILE_SOURCE ProfileSource;
    ULONG CpuInfoHierarchy[0x3];
} EVENT_TRACE_PROFILE_REMOVE_INFORMATION, *PEVENT_TRACE_PROFILE_REMOVE_INFORMATION;

typedef struct _EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    BOOLEAN CoverageSamplerInformationClass;
    UCHAR MajorVersion;
    UCHAR MinorVersion;
    UCHAR Reserved;
    HANDLE SamplerHandle;
} EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION, *PEVENT_TRACE_COVERAGE_SAMPLER_INFORMATION;

typedef struct _SYSTEM_EXCEPTION_INFORMATION
{
    ULONG AlignmentFixupCount;
    ULONG ExceptionDispatchCount;
    ULONG FloatingEmulationCount;
    ULONG ByteWordEmulationCount;
} SYSTEM_EXCEPTION_INFORMATION, *PSYSTEM_EXCEPTION_INFORMATION;

typedef enum _SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS
{
    SystemCrashDumpDisable,
    SystemCrashDumpReconfigure,
    SystemCrashDumpInitializationComplete
} SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS, *PSYSTEM_CRASH_DUMP_CONFIGURATION_CLASS;

typedef struct _SYSTEM_CRASH_DUMP_STATE_INFORMATION
{
    SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS CrashDumpConfigurationClass;
} SYSTEM_CRASH_DUMP_STATE_INFORMATION, *PSYSTEM_CRASH_DUMP_STATE_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION
{
    BOOLEAN KernelDebuggerEnabled;
    BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _SYSTEM_CONTEXT_SWITCH_INFORMATION
{
    ULONG ContextSwitches;
    ULONG FindAny;
    ULONG FindLast;
    ULONG FindIdeal;
    ULONG IdleAny;
    ULONG IdleCurrent;
    ULONG IdleLast;
    ULONG IdleIdeal;
    ULONG PreemptAny;
    ULONG PreemptCurrent;
    ULONG PreemptLast;
    ULONG SwitchToIdle;
} SYSTEM_CONTEXT_SWITCH_INFORMATION, *PSYSTEM_CONTEXT_SWITCH_INFORMATION;

typedef struct _SYSTEM_REGISTRY_QUOTA_INFORMATION
{
    ULONG RegistryQuotaAllowed;
    ULONG RegistryQuotaUsed;
    SIZE_T PagedPoolSize;
} SYSTEM_REGISTRY_QUOTA_INFORMATION, *PSYSTEM_REGISTRY_QUOTA_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_IDLE_INFORMATION
{
    ULONGLONG IdleTime;
    ULONGLONG C1Time;
    ULONGLONG C2Time;
    ULONGLONG C3Time;
    ULONG C1Transitions;
    ULONG C2Transitions;
    ULONG C3Transitions;
    ULONG Padding;
} SYSTEM_PROCESSOR_IDLE_INFORMATION, *PSYSTEM_PROCESSOR_IDLE_INFORMATION;

typedef struct _SYSTEM_LEGACY_DRIVER_INFORMATION
{
    ULONG VetoType;
    UNICODE_STRING VetoList;
} SYSTEM_LEGACY_DRIVER_INFORMATION, *PSYSTEM_LEGACY_DRIVER_INFORMATION;

typedef struct _SYSTEM_LOOKASIDE_INFORMATION
{
    USHORT CurrentDepth;
    USHORT MaximumDepth;
    ULONG TotalAllocates;
    ULONG AllocateMisses;
    ULONG TotalFrees;
    ULONG FreeMisses;
    ULONG Type;
    ULONG Tag;
    ULONG Size;
} SYSTEM_LOOKASIDE_INFORMATION, *PSYSTEM_LOOKASIDE_INFORMATION;

// private
typedef struct _SYSTEM_RANGE_START_INFORMATION
{
    ULONG_PTR SystemRangeStart;
} SYSTEM_RANGE_START_INFORMATION, *PSYSTEM_RANGE_START_INFORMATION;

typedef struct _SYSTEM_VERIFIER_INFORMATION_LEGACY // pre-19H1
{
    ULONG NextEntryOffset;
    ULONG Level;
    UNICODE_STRING DriverName;

    ULONG RaiseIrqls;
    ULONG AcquireSpinLocks;
    ULONG SynchronizeExecutions;
    ULONG AllocationsAttempted;

    ULONG AllocationsSucceeded;
    ULONG AllocationsSucceededSpecialPool;
    ULONG AllocationsWithNoTag;
    ULONG TrimRequests;

    ULONG Trims;
    ULONG AllocationsFailed;
    ULONG AllocationsFailedDeliberately;
    ULONG Loads;

    ULONG Unloads;
    ULONG UnTrackedPool;
    ULONG CurrentPagedPoolAllocations;
    ULONG CurrentNonPagedPoolAllocations;

    ULONG PeakPagedPoolAllocations;
    ULONG PeakNonPagedPoolAllocations;

    SIZE_T PagedPoolUsageInBytes;
    SIZE_T NonPagedPoolUsageInBytes;
    SIZE_T PeakPagedPoolUsageInBytes;
    SIZE_T PeakNonPagedPoolUsageInBytes;
} SYSTEM_VERIFIER_INFORMATION_LEGACY, *PSYSTEM_VERIFIER_INFORMATION_LEGACY;

typedef struct _SYSTEM_VERIFIER_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG Level;
    ULONG RuleClasses[2];
    ULONG TriageContext;
    ULONG AreAllDriversBeingVerified;

    UNICODE_STRING DriverName;

    ULONG RaiseIrqls;
    ULONG AcquireSpinLocks;
    ULONG SynchronizeExecutions;
    ULONG AllocationsAttempted;

    ULONG AllocationsSucceeded;
    ULONG AllocationsSucceededSpecialPool;
    ULONG AllocationsWithNoTag;
    ULONG TrimRequests;

    ULONG Trims;
    ULONG AllocationsFailed;
    ULONG AllocationsFailedDeliberately;
    ULONG Loads;

    ULONG Unloads;
    ULONG UnTrackedPool;
    ULONG CurrentPagedPoolAllocations;
    ULONG CurrentNonPagedPoolAllocations;

    ULONG PeakPagedPoolAllocations;
    ULONG PeakNonPagedPoolAllocations;

    SIZE_T PagedPoolUsageInBytes;
    SIZE_T NonPagedPoolUsageInBytes;
    SIZE_T PeakPagedPoolUsageInBytes;
    SIZE_T PeakNonPagedPoolUsageInBytes;
} SYSTEM_VERIFIER_INFORMATION, *PSYSTEM_VERIFIER_INFORMATION;

// private
typedef struct _SYSTEM_SESSION_PROCESS_INFORMATION
{
    ULONG SessionId;
    ULONG SizeOfBuf;
    PVOID Buffer;
} SYSTEM_SESSION_PROCESS_INFORMATION, *PSYSTEM_SESSION_PROCESS_INFORMATION;

#if (PHNT_MODE != PHNT_MODE_KERNEL)
// private
typedef struct _SYSTEM_GDI_DRIVER_INFORMATION
{
    UNICODE_STRING DriverName;
    PVOID ImageAddress;
    PVOID SectionPointer;
    PVOID EntryPoint;
    struct _IMAGE_EXPORT_DIRECTORY* ExportSectionPointer;
    ULONG ImageLength;
} SYSTEM_GDI_DRIVER_INFORMATION, *PSYSTEM_GDI_DRIVER_INFORMATION;
#endif

// geoffchappell
#ifdef _WIN64
#define MAXIMUM_NODE_COUNT 0x40
#else
#define MAXIMUM_NODE_COUNT 0x10
#endif

// private
typedef struct _SYSTEM_NUMA_INFORMATION
{
    ULONG HighestNodeNumber;
    ULONG Reserved;
    union
    {
        GROUP_AFFINITY ActiveProcessorsGroupAffinity[MAXIMUM_NODE_COUNT];
        ULONGLONG AvailableMemory[MAXIMUM_NODE_COUNT];
        ULONGLONG Pad[MAXIMUM_NODE_COUNT * 2];
    };
} SYSTEM_NUMA_INFORMATION, *PSYSTEM_NUMA_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_POWER_INFORMATION
{
    UCHAR CurrentFrequency;
    UCHAR ThermalLimitFrequency;
    UCHAR ConstantThrottleFrequency;
    UCHAR DegradedThrottleFrequency;
    UCHAR LastBusyFrequency;
    UCHAR LastC3Frequency;
    UCHAR LastAdjustedBusyFrequency;
    UCHAR ProcessorMinThrottle;
    UCHAR ProcessorMaxThrottle;
    ULONG NumberOfFrequencies;
    ULONG PromotionCount;
    ULONG DemotionCount;
    ULONG ErrorCount;
    ULONG RetryCount;
    ULONGLONG CurrentFrequencyTime;
    ULONGLONG CurrentProcessorTime;
    ULONGLONG CurrentProcessorIdleTime;
    ULONGLONG LastProcessorTime;
    ULONGLONG LastProcessorIdleTime;
    ULONGLONG Energy;
} SYSTEM_PROCESSOR_POWER_INFORMATION, *PSYSTEM_PROCESSOR_POWER_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
{
    PVOID Object;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

typedef struct _SYSTEM_BIGPOOL_ENTRY
{
    union
    {
        PVOID VirtualAddress;
        ULONG_PTR NonPaged : 1;
    };
    SIZE_T SizeInBytes;
    union
    {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
} SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_BIGPOOL_INFORMATION
{
    ULONG Count;
    SYSTEM_BIGPOOL_ENTRY AllocatedInfo[1];
} SYSTEM_BIGPOOL_INFORMATION, *PSYSTEM_BIGPOOL_INFORMATION;

typedef struct _SYSTEM_POOL_ENTRY
{
    BOOLEAN Allocated;
    BOOLEAN Spare0;
    USHORT AllocatorBackTraceIndex;
    ULONG Size;
    union
    {
        UCHAR Tag[4];
        ULONG TagUlong;
        PVOID ProcessChargedQuota;
    };
} SYSTEM_POOL_ENTRY, *PSYSTEM_POOL_ENTRY;

typedef struct _SYSTEM_POOL_INFORMATION
{
    SIZE_T TotalSize;
    PVOID FirstEntry;
    USHORT EntryOverhead;
    BOOLEAN PoolTagPresent;
    BOOLEAN Spare0;
    ULONG NumberOfEntries;
    SYSTEM_POOL_ENTRY Entries[1];
} SYSTEM_POOL_INFORMATION, *PSYSTEM_POOL_INFORMATION;

typedef struct _SYSTEM_SESSION_POOLTAG_INFORMATION
{
    SIZE_T NextEntryOffset;
    ULONG SessionId;
    ULONG Count;
    SYSTEM_POOLTAG TagInfo[1];
} SYSTEM_SESSION_POOLTAG_INFORMATION, *PSYSTEM_SESSION_POOLTAG_INFORMATION;

typedef struct _SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
{
    SIZE_T NextEntryOffset;
    ULONG SessionId;
    ULONG ViewFailures;
    SIZE_T NumberOfBytesAvailable;
    SIZE_T NumberOfBytesAvailableContiguous;
} SYSTEM_SESSION_MAPPED_VIEW_INFORMATION, *PSYSTEM_SESSION_MAPPED_VIEW_INFORMATION;

typedef enum _WATCHDOG_HANDLER_ACTION
{
    WdActionSetTimeoutValue,
    WdActionQueryTimeoutValue,
    WdActionResetTimer,
    WdActionStopTimer,
    WdActionStartTimer,
    WdActionSetTriggerAction,
    WdActionQueryTriggerAction,
    WdActionQueryState
} WATCHDOG_HANDLER_ACTION;

typedef NTSTATUS (*PSYSTEM_WATCHDOG_HANDLER)(_In_ WATCHDOG_HANDLER_ACTION Action, _In_ PVOID Context, _Inout_ PULONG DataValue, _In_ BOOLEAN NoLocks);

// private
typedef struct _SYSTEM_WATCHDOG_HANDLER_INFORMATION
{
    PSYSTEM_WATCHDOG_HANDLER WdHandler;
    PVOID Context;
} SYSTEM_WATCHDOG_HANDLER_INFORMATION, *PSYSTEM_WATCHDOG_HANDLER_INFORMATION;

typedef enum _WATCHDOG_INFORMATION_CLASS
{
    WdInfoTimeoutValue = 0,
    WdInfoResetTimer = 1,
    WdInfoStopTimer = 2,
    WdInfoStartTimer = 3,
    WdInfoTriggerAction = 4,
    WdInfoState = 5,
    WdInfoTriggerReset = 6,
    WdInfoNop = 7,
    WdInfoGeneratedLastReset = 8,
    WdInfoInvalid = 9,
} WATCHDOG_INFORMATION_CLASS;

// private
typedef struct _SYSTEM_WATCHDOG_TIMER_INFORMATION
{
    WATCHDOG_INFORMATION_CLASS WdInfoClass;
    ULONG DataValue;
} SYSTEM_WATCHDOG_TIMER_INFORMATION, PSYSTEM_WATCHDOG_TIMER_INFORMATION;

#if (PHNT_MODE != PHNT_MODE_KERNEL)
// private
typedef enum _SYSTEM_FIRMWARE_TABLE_ACTION
{
    SystemFirmwareTableEnumerate,
    SystemFirmwareTableGet,
    SystemFirmwareTableMax
} SYSTEM_FIRMWARE_TABLE_ACTION;

// private
typedef struct _SYSTEM_FIRMWARE_TABLE_INFORMATION
{
    ULONG ProviderSignature; // (same as the GetSystemFirmwareTable function)
    SYSTEM_FIRMWARE_TABLE_ACTION Action;
    ULONG TableID;
    ULONG TableBufferLength;
    UCHAR TableBuffer[1];
} SYSTEM_FIRMWARE_TABLE_INFORMATION, *PSYSTEM_FIRMWARE_TABLE_INFORMATION;
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
// private
typedef NTSTATUS (__cdecl* PFNFTH)(
    _Inout_ PSYSTEM_FIRMWARE_TABLE_INFORMATION SystemFirmwareTableInfo
    );

// private
typedef struct _SYSTEM_FIRMWARE_TABLE_HANDLER
{
    ULONG ProviderSignature;
    BOOLEAN Register;
    PFNFTH FirmwareTableHandler;
    PVOID DriverObject;
} SYSTEM_FIRMWARE_TABLE_HANDLER, *PSYSTEM_FIRMWARE_TABLE_HANDLER;
#endif

// private
typedef struct _SYSTEM_MEMORY_LIST_INFORMATION
{
    ULONG_PTR ZeroPageCount;
    ULONG_PTR FreePageCount;
    ULONG_PTR ModifiedPageCount;
    ULONG_PTR ModifiedNoWritePageCount;
    ULONG_PTR BadPageCount;
    ULONG_PTR PageCountByPriority[8];
    ULONG_PTR RepurposedPagesByPriority[8];
    ULONG_PTR ModifiedPageCountPageFile;
} SYSTEM_MEMORY_LIST_INFORMATION, *PSYSTEM_MEMORY_LIST_INFORMATION;

// private
typedef enum _SYSTEM_MEMORY_LIST_COMMAND
{
    MemoryCaptureAccessedBits,
    MemoryCaptureAndResetAccessedBits,
    MemoryEmptyWorkingSets,
    MemoryFlushModifiedList,
    MemoryPurgeStandbyList,
    MemoryPurgeLowPriorityStandbyList,
    MemoryCommandMax
} SYSTEM_MEMORY_LIST_COMMAND;

// private
typedef struct _SYSTEM_THREAD_CID_PRIORITY_INFORMATION
{
    CLIENT_ID ClientId;
    KPRIORITY Priority;
} SYSTEM_THREAD_CID_PRIORITY_INFORMATION, *PSYSTEM_THREAD_CID_PRIORITY_INFORMATION;

// private
typedef struct _SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION
{
    ULONGLONG CycleTime;
} SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION, *PSYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION;

// private
typedef struct _SYSTEM_VERIFIER_ISSUE
{
    ULONGLONG IssueType;
    PVOID Address;
    ULONGLONG Parameters[2];
} SYSTEM_VERIFIER_ISSUE, *PSYSTEM_VERIFIER_ISSUE;

// private
typedef struct _SYSTEM_VERIFIER_CANCELLATION_INFORMATION
{
    ULONG CancelProbability;
    ULONG CancelThreshold;
    ULONG CompletionThreshold;
    ULONG CancellationVerifierDisabled;
    ULONG AvailableIssues;
    SYSTEM_VERIFIER_ISSUE Issues[128];
} SYSTEM_VERIFIER_CANCELLATION_INFORMATION, *PSYSTEM_VERIFIER_CANCELLATION_INFORMATION;

// private
typedef struct _SYSTEM_REF_TRACE_INFORMATION
{
    BOOLEAN TraceEnable;
    BOOLEAN TracePermanent;
    UNICODE_STRING TraceProcessName;
    UNICODE_STRING TracePoolTags;
} SYSTEM_REF_TRACE_INFORMATION, *PSYSTEM_REF_TRACE_INFORMATION;

// private
typedef struct _SYSTEM_SPECIAL_POOL_INFORMATION
{
    ULONG PoolTag;
    ULONG Flags;
} SYSTEM_SPECIAL_POOL_INFORMATION, *PSYSTEM_SPECIAL_POOL_INFORMATION;

// private
typedef struct _SYSTEM_PROCESS_ID_INFORMATION
{
    HANDLE ProcessId;
    UNICODE_STRING ImageName;
} SYSTEM_PROCESS_ID_INFORMATION, *PSYSTEM_PROCESS_ID_INFORMATION;

// private
typedef struct _SYSTEM_HYPERVISOR_QUERY_INFORMATION
{
    BOOLEAN HypervisorConnected;
    BOOLEAN HypervisorDebuggingEnabled;
    BOOLEAN HypervisorPresent;
    BOOLEAN Spare0[5];
    ULONGLONG EnabledEnlightenments;
} SYSTEM_HYPERVISOR_QUERY_INFORMATION, *PSYSTEM_HYPERVISOR_QUERY_INFORMATION;

// private
typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION
{
    GUID BootIdentifier;
    FIRMWARE_TYPE FirmwareType;
    union
    {
        ULONGLONG BootFlags;
        struct
        {
            ULONGLONG DbgMenuOsSelection : 1; // REDSTONE4
            ULONGLONG DbgHiberBoot : 1;
            ULONGLONG DbgSoftBoot : 1;
            ULONGLONG DbgMeasuredLaunch : 1;
            ULONGLONG DbgMeasuredLaunchCapable : 1; // 19H1
            ULONGLONG DbgSystemHiveReplace : 1;
            ULONGLONG DbgMeasuredLaunchSmmProtections : 1;
            ULONGLONG DbgMeasuredLaunchSmmLevel : 7; // 20H1
        };
    };
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION;

// private
typedef struct _SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION
{
    ULONG FlagsToEnable;
    ULONG FlagsToDisable;
} SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION, *PSYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION;

// private
typedef enum _COVERAGE_REQUEST_CODES
{
    CoverageAllModules = 0,
    CoverageSearchByHash = 1,
    CoverageSearchByName = 2
} COVERAGE_REQUEST_CODES;

// private
typedef struct _COVERAGE_MODULE_REQUEST
{
    COVERAGE_REQUEST_CODES RequestType;
    union
    {
        UCHAR MD5Hash[16];
        UNICODE_STRING ModuleName;
    } SearchInfo;
} COVERAGE_MODULE_REQUEST, *PCOVERAGE_MODULE_REQUEST;

// private
typedef struct _COVERAGE_MODULE_INFO
{
    ULONG ModuleInfoSize;
    ULONG IsBinaryLoaded;
    UNICODE_STRING ModulePathName;
    ULONG CoverageSectionSize;
    UCHAR CoverageSection[1];
} COVERAGE_MODULE_INFO, *PCOVERAGE_MODULE_INFO;

// private
typedef struct _COVERAGE_MODULES
{
    ULONG ListAndReset;
    ULONG NumberOfModules;
    COVERAGE_MODULE_REQUEST ModuleRequestInfo;
    COVERAGE_MODULE_INFO Modules[1];
} COVERAGE_MODULES, *PCOVERAGE_MODULES;

// private
typedef struct _SYSTEM_PREFETCH_PATCH_INFORMATION
{
    ULONG PrefetchPatchCount;
} SYSTEM_PREFETCH_PATCH_INFORMATION, *PSYSTEM_PREFETCH_PATCH_INFORMATION;

// private
typedef struct _SYSTEM_VERIFIER_FAULTS_INFORMATION
{
    ULONG Probability;
    ULONG MaxProbability;
    UNICODE_STRING PoolTags;
    UNICODE_STRING Applications;
} SYSTEM_VERIFIER_FAULTS_INFORMATION, *PSYSTEM_VERIFIER_FAULTS_INFORMATION;

// private
typedef struct _SYSTEM_VERIFIER_INFORMATION_EX
{
    ULONG VerifyMode;
    ULONG OptionChanges;
    UNICODE_STRING PreviousBucketName;
    ULONG IrpCancelTimeoutMsec;
    ULONG VerifierExtensionEnabled;
#ifdef _WIN64
    ULONG Reserved[1];
#else
    ULONG Reserved[3];
#endif
} SYSTEM_VERIFIER_INFORMATION_EX, *PSYSTEM_VERIFIER_INFORMATION_EX;

// private
typedef struct _SYSTEM_SYSTEM_PARTITION_INFORMATION
{
    UNICODE_STRING SystemPartition;
} SYSTEM_SYSTEM_PARTITION_INFORMATION, *PSYSTEM_SYSTEM_PARTITION_INFORMATION;

// private
typedef struct _SYSTEM_SYSTEM_DISK_INFORMATION
{
    UNICODE_STRING SystemDisk;
} SYSTEM_SYSTEM_DISK_INFORMATION, *PSYSTEM_SYSTEM_DISK_INFORMATION;

// private
typedef struct _SYSTEM_NUMA_PROXIMITY_MAP
{
    ULONG NodeProximityId;
    USHORT NodeNumber;
} SYSTEM_NUMA_PROXIMITY_MAP, *PSYSTEM_NUMA_PROXIMITY_MAP;

// private (Windows 8.1 and above)
typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT
{
    ULONGLONG Hits;
    UCHAR PercentFrequency;
} SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT, *PSYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT;

// private (Windows 7 and Windows 8)
typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8
{
    ULONG Hits;
    UCHAR PercentFrequency;
} SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8, *PSYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8;

// private
typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION
{
    ULONG ProcessorNumber;
    ULONG StateCount;
    SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT States[1];
} SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION, *PSYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION;

// private
typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION
{
    ULONG ProcessorCount;
    ULONG Offsets[1];
} SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION, *PSYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION;

#define CODEINTEGRITY_OPTION_ENABLED 0x01
#define CODEINTEGRITY_OPTION_TESTSIGN 0x02
#define CODEINTEGRITY_OPTION_UMCI_ENABLED 0x04
#define CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED 0x08
#define CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED 0x10
#define CODEINTEGRITY_OPTION_TEST_BUILD 0x20
#define CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD 0x40
#define CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED 0x80
#define CODEINTEGRITY_OPTION_FLIGHT_BUILD 0x100
#define CODEINTEGRITY_OPTION_FLIGHTING_ENABLED 0x200
#define CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED 0x400
#define CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED 0x800
#define CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED 0x1000
#define CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED 0x2000
#define CODEINTEGRITY_OPTION_WHQL_ENFORCEMENT_ENABLED 0x4000
#define CODEINTEGRITY_OPTION_WHQL_AUDITMODE_ENABLED 0x8000

// private
typedef struct _SYSTEM_CODEINTEGRITY_INFORMATION
{
    ULONG Length;
    ULONG CodeIntegrityOptions;
} SYSTEM_CODEINTEGRITY_INFORMATION, *PSYSTEM_CODEINTEGRITY_INFORMATION;

// private
typedef struct _SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION
{
    ULONG Operation;
} SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION, *PSYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION;

// private
typedef enum _SYSTEM_VA_TYPE
{
    SystemVaTypeAll,
    SystemVaTypeNonPagedPool,
    SystemVaTypePagedPool,
    SystemVaTypeSystemCache,
    SystemVaTypeSystemPtes,
    SystemVaTypeSessionSpace,
    SystemVaTypeMax
} SYSTEM_VA_TYPE, *PSYSTEM_VA_TYPE;

// private
typedef struct _SYSTEM_VA_LIST_INFORMATION
{
    SIZE_T VirtualSize;
    SIZE_T VirtualPeak;
    SIZE_T VirtualLimit;
    SIZE_T AllocationFailures;
} SYSTEM_VA_LIST_INFORMATION, *PSYSTEM_VA_LIST_INFORMATION;

// rev
typedef enum _STORE_INFORMATION_CLASS
{
    StorePageRequest = 1,
    StoreStatsRequest = 2, // q: SM_STATS_REQUEST // SmProcessStatsRequest
    StoreCreateRequest = 3, // s: SM_CREATE_REQUEST (requires SeProfileSingleProcessPrivilege)
    StoreDeleteRequest = 4, // s: SM_DELETE_REQUEST (requires SeProfileSingleProcessPrivilege)
    StoreListRequest = 5, // q: SM_STORE_LIST_REQUEST / SM_STORE_LIST_REQUEST_EX // SmProcessListRequest
    Available1 = 6,
    StoreEmptyRequest = 7,
    CacheListRequest = 8, // q: SMC_CACHE_LIST_REQUEST // SmcProcessListRequest
    CacheCreateRequest = 9, // s: SMC_CACHE_CREATE_REQUEST (requires SeProfileSingleProcessPrivilege)
    CacheDeleteRequest = 10, // s: SMC_CACHE_DELETE_REQUEST (requires SeProfileSingleProcessPrivilege)
    CacheStoreCreateRequest = 11, // s: SMC_STORE_CREATE_REQUEST (requires SeProfileSingleProcessPrivilege)
    CacheStoreDeleteRequest = 12, // s: SMC_STORE_DELETE_REQUEST (requires SeProfileSingleProcessPrivilege)
    CacheStatsRequest = 13, // q: SMC_CACHE_STATS_REQUEST // SmcProcessStatsRequest
    Available2 = 14,
    RegistrationRequest = 15, // q: SM_REGISTRATION_REQUEST (requires SeProfileSingleProcessPrivilege) // SmProcessRegistrationRequest
    GlobalCacheStatsRequest = 16,
    StoreResizeRequest = 17, // s: SM_STORE_RESIZE_REQUEST (requires SeProfileSingleProcessPrivilege)
    CacheStoreResizeRequest = 18, // s: SMC_STORE_RESIZE_REQUEST (requires SeProfileSingleProcessPrivilege)
    SmConfigRequest = 19, // s: SM_CONFIG_REQUEST (requires SeProfileSingleProcessPrivilege)
    StoreHighMemoryPriorityRequest = 20, // s: SM_STORE_HIGH_MEM_PRIORITY_REQUEST (requires SeProfileSingleProcessPrivilege)
    SystemStoreTrimRequest = 21, // s: SM_SYSTEM_STORE_TRIM_REQUEST (requires SeProfileSingleProcessPrivilege)
    MemCompressionInfoRequest = 22,  // q: SM_MEM_COMPRESSION_INFO_REQUEST // SmProcessCompressionInfoRequest
    ProcessStoreInfoRequest = 23, // SmProcessProcessStoreInfoRequest
    StoreInformationMax
} STORE_INFORMATION_CLASS;

// rev
#define SYSTEM_STORE_INFORMATION_VERSION 1

// rev
typedef struct _SYSTEM_STORE_INFORMATION
{
    _In_ ULONG Version;
    _In_ STORE_INFORMATION_CLASS StoreInformationClass;
    _Inout_ PVOID Data;
    _Inout_ ULONG Length;
} SYSTEM_STORE_INFORMATION, *PSYSTEM_STORE_INFORMATION;

#define SYSTEM_STORE_STATS_INFORMATION_VERSION 2

typedef enum _ST_STATS_LEVEL
{
    StStatsLevelBasic = 0,
    StStatsLevelIoStats = 1,
    StStatsLevelRegionSpace = 2, // requires SeProfileSingleProcessPrivilege
    StStatsLevelSpaceBitmap = 3, // requires SeProfileSingleProcessPrivilege
    StStatsLevelMax = 4
} ST_STATS_LEVEL;

typedef struct _SM_STATS_REQUEST
{
    ULONG Version : 8; // SYSTEM_STORE_STATS_INFORMATION_VERSION
    ULONG DetailLevel : 8; // ST_STATS_LEVEL
    ULONG StoreId : 16;
    ULONG BufferSize;
    PVOID Buffer; // PST_STATS
} SM_STATS_REQUEST, *PSM_STATS_REQUEST;

typedef struct _ST_DATA_MGR_STATS
{
    ULONG RegionCount;
    ULONG PagesStored;
    ULONG UniquePagesStored;
    ULONG LazyCleanupRegionCount;
    struct {
        ULONG RegionsInUse;
        ULONG SpaceUsed;
    } Space[8];
} ST_DATA_MGR_STATS, *PST_DATA_MGR_STATS;

typedef struct _ST_IO_STATS_PERIOD
{
    ULONG PageCounts[5];
} ST_IO_STATS_PERIOD, *PST_IO_STATS_PERIOD;

typedef struct _ST_IO_STATS
{
    ULONG PeriodCount;
    ST_IO_STATS_PERIOD Periods[64];
} ST_IO_STATS, *PST_IO_STATS;

typedef struct _ST_READ_LATENCY_BUCKET
{
    ULONG LatencyUs;
    ULONG Count;
} ST_READ_LATENCY_BUCKET, *PST_READ_LATENCY_BUCKET;

typedef struct _ST_READ_LATENCY_STATS
{
    ST_READ_LATENCY_BUCKET Buckets[8];
} ST_READ_LATENCY_STATS, *PST_READ_LATENCY_STATS;

// rev
typedef struct _ST_STATS_REGION_INFO
{
    USHORT SpaceUsed;
    UCHAR Priority;
    UCHAR Spare;
} ST_STATS_REGION_INFO, *PST_STATS_REGION_INFO;

// rev
typedef struct _ST_STATS_SPACE_BITMAP
{
    SIZE_T CompressedBytes;
    ULONG BytesPerBit;
    UCHAR StoreBitmap[1];
} ST_STATS_SPACE_BITMAP, PST_STATS_SPACE_BITMAP;

// rev
typedef struct _ST_STATS
{
    ULONG Version : 8;
    ULONG Level : 4;
    ULONG StoreType : 4;
    ULONG NoDuplication : 1;
    ULONG NoCompression : 1;
    ULONG EncryptionStrength : 12;
    ULONG VirtualRegions : 1;
    ULONG Spare0 : 1;
    ULONG Size;
    USHORT CompressionFormat;
    USHORT Spare;

    struct
    {
        ULONG RegionSize;
        ULONG RegionCount;
        ULONG RegionCountMax;
        ULONG Granularity;
        ST_DATA_MGR_STATS UserData;
        ST_DATA_MGR_STATS Metadata;
    } Basic;

    struct
    {
        ST_IO_STATS IoStats;
        ST_READ_LATENCY_STATS ReadLatencyStats;
    } Io;

    // ST_STATS_REGION_INFO[RegionCountMax]
    // ST_STATS_SPACE_BITMAP
} ST_STATS, *PST_STATS;

#define SYSTEM_STORE_CREATE_INFORMATION_VERSION 6

typedef enum _SM_STORE_TYPE
{
    StoreTypeInMemory=0,
    StoreTypeFile=1,
    StoreTypeMax=2
} SM_STORE_TYPE;

typedef struct _SM_STORE_BASIC_PARAMS
{
    union
    {
        struct
        {
            ULONG StoreType : 8; // SM_STORE_TYPE
            ULONG NoDuplication : 1;
            ULONG FailNoCompression : 1;
            ULONG NoCompression : 1 ;
            ULONG NoEncryption : 1;
            ULONG NoEvictOnAdd : 1;
            ULONG PerformsFileIo : 1;
            ULONG VdlNotSet : 1 ;
            ULONG UseIntermediateAddBuffer : 1;
            ULONG CompressNoHuff : 1;
            ULONG LockActiveRegions : 1;
            ULONG VirtualRegions : 1;
            ULONG Spare : 13;
        };
        ULONG StoreFlags;
    };
    ULONG Granularity;
    ULONG RegionSize;
    ULONG RegionCountMax;
} SM_STORE_BASIC_PARAMS, *PSM_STORE_BASIC_PARAMS;

typedef struct _SMKM_REGION_EXTENT
{
    ULONG RegionCount;
    SIZE_T ByteOffset;
} SMKM_REGION_EXTENT, *PSMKM_REGION_EXTENT;

typedef struct _SMKM_FILE_INFO
{
    HANDLE FileHandle;
    struct _FILE_OBJECT *FileObject;
    struct _FILE_OBJECT *VolumeFileObject;
    struct _DEVICE_OBJECT *VolumeDeviceObject;
    HANDLE VolumePnpHandle;
    struct _IRP *UsageNotificationIrp;
    PSMKM_REGION_EXTENT Extents;
    ULONG ExtentCount;
} SMKM_FILE_INFO, *PSMKM_FILE_INFO;

typedef struct _SM_STORE_CACHE_BACKED_PARAMS
{
    ULONG SectorSize;
    PCHAR EncryptionKey;
    ULONG EncryptionKeySize;
    PSMKM_FILE_INFO FileInfo;
    PVOID EtaContext;
    struct _RTL_BITMAP *StoreRegionBitmap;
} SM_STORE_CACHE_BACKED_PARAMS, *PSM_STORE_CACHE_BACKED_PARAMS;

typedef struct _SM_STORE_PARAMETERS
{
    SM_STORE_BASIC_PARAMS Store;
    ULONG Priority;
    ULONG Flags;
    SM_STORE_CACHE_BACKED_PARAMS CacheBacked;
} SM_STORE_PARAMETERS, *PSM_STORE_PARAMETERS;

typedef struct _SM_CREATE_REQUEST
{
    ULONG Version : 8; // SYSTEM_STORE_CREATE_INFORMATION_VERSION
    ULONG AcquireReference : 1;
    ULONG KeyedStore : 1;
    ULONG Spare : 22;
    SM_STORE_PARAMETERS Params;
    ULONG StoreId;
} SM_CREATE_REQUEST, *PSM_CREATE_REQUEST;

#define SYSTEM_STORE_DELETE_INFORMATION_VERSION 1

typedef struct _SM_DELETE_REQUEST
{
    ULONG Version : 8; // SYSTEM_STORE_DELETE_INFORMATION_VERSION
    ULONG Spare : 24;
    ULONG StoreId;
} SM_DELETE_REQUEST, *PSM_DELETE_REQUEST;

#define SYSTEM_STORE_LIST_INFORMATION_VERSION 2

typedef struct _SM_STORE_LIST_REQUEST
{
    ULONG Version : 8; // SYSTEM_STORE_LIST_INFORMATION_VERSION
    ULONG StoreCount : 8; // = 0
    ULONG ExtendedRequest : 1; // SM_STORE_LIST_REQUEST_EX if set
    ULONG Spare : 15;
    ULONG StoreId[32];
} SM_STORE_LIST_REQUEST, *PSM_STORE_LIST_REQUEST;

typedef struct _SM_STORE_LIST_REQUEST_EX
{
    SM_STORE_LIST_REQUEST Request;
    WCHAR NameBuffer[32][64];
} SM_STORE_LIST_REQUEST_EX, *PSM_STORE_LIST_REQUEST_EX;

#define SYSTEM_CACHE_LIST_INFORMATION_VERSION 2

typedef struct _SMC_CACHE_LIST_REQUEST
{
    ULONG Version : 8; // SYSTEM_CACHE_LIST_INFORMATION_VERSION
    ULONG CacheCount : 8; // = 0
    ULONG Spare : 16;
    ULONG CacheId[16];
} SMC_CACHE_LIST_REQUEST, *PSMC_CACHE_LIST_REQUEST;

#define SYSTEM_CACHE_CREATE_INFORMATION_VERSION 3

typedef struct _SMC_CACHE_PARAMETERS
{
    SIZE_T CacheFileSize;
    ULONG StoreAlignment;
    ULONG PerformsFileIo : 1;
    ULONG VdlNotSet : 1;
    ULONG Spare : 30;
    ULONG CacheFlags;
    ULONG Priority;
} SMC_CACHE_PARAMETERS, *PSMC_CACHE_PARAMETERS;

typedef struct _SMC_CACHE_CREATE_PARAMETERS
{
    SMC_CACHE_PARAMETERS CacheParameters;
    WCHAR TemplateFilePath[512];
} SMC_CACHE_CREATE_PARAMETERS, *PSMC_CACHE_CREATE_PARAMETERS;

typedef struct _SMC_CACHE_CREATE_REQUEST
{
    ULONG Version : 8; // SYSTEM_CACHE_CREATE_INFORMATION_VERSION
    ULONG Spare : 24;
    ULONG CacheId;
    SMC_CACHE_CREATE_PARAMETERS CacheCreateParams;
} SMC_CACHE_CREATE_REQUEST, *PSMC_CACHE_CREATE_REQUEST;

#define SYSTEM_CACHE_DELETE_INFORMATION_VERSION 1

typedef struct _SMC_CACHE_DELETE_REQUEST
{
    ULONG Version : 8; // SYSTEM_CACHE_DELETE_INFORMATION_VERSION
    ULONG Spare : 24;
    ULONG CacheId;
} SMC_CACHE_DELETE_REQUEST, *PSMC_CACHE_DELETE_REQUEST;

#define SYSTEM_CACHE_STORE_CREATE_INFORMATION_VERSION 2

typedef enum _SM_STORE_MANAGER_TYPE
{
    SmStoreManagerTypePhysical=0,
    SmStoreManagerTypeVirtual=1,
    SmStoreManagerTypeMax=2
} SM_STORE_MANAGER_TYPE;

typedef struct _SMC_STORE_CREATE_REQUEST
{
    ULONG Version : 8; // SYSTEM_CACHE_STORE_CREATE_INFORMATION_VERSION
    ULONG Spare : 24;
    SM_STORE_BASIC_PARAMS StoreParams;
    ULONG CacheId;
    SM_STORE_MANAGER_TYPE StoreManagerType;
    ULONG StoreId;
} SMC_STORE_CREATE_REQUEST, *PSMC_STORE_CREATE_REQUEST;

#define SYSTEM_CACHE_STORE_DELETE_INFORMATION_VERSION 1

typedef struct _SMC_STORE_DELETE_REQUEST
{
    ULONG Version : 8; // SYSTEM_CACHE_STORE_DELETE_INFORMATION_VERSION
    ULONG Spare : 24;
    ULONG CacheId;
    SM_STORE_MANAGER_TYPE StoreManagerType;
    ULONG StoreId;
} SMC_STORE_DELETE_REQUEST, *PSMC_STORE_DELETE_REQUEST;

#define SYSTEM_CACHE_STATS_INFORMATION_VERSION 3

typedef struct _SMC_CACHE_STATS
{
    SIZE_T TotalFileSize;
    ULONG StoreCount;
    ULONG RegionCount;
    ULONG RegionSizeBytes;
    ULONG FileCount : 6;
    ULONG PerformsFileIo : 1;
    ULONG Spare : 25;
    ULONG StoreIds[16];
    ULONG PhysicalStoreBitmap;
    ULONG Priority;
    WCHAR TemplateFilePath[512];
} SMC_CACHE_STATS, *PSMC_CACHE_STATS;

typedef struct _SMC_CACHE_STATS_REQUEST
{
    ULONG Version : 8; // SYSTEM_CACHE_STATS_INFORMATION_VERSION
    ULONG NoFilePath : 1;
    ULONG Spare : 23;
    ULONG CacheId;
    SMC_CACHE_STATS CacheStats;
} SMC_CACHE_STATS_REQUEST, *PSMC_CACHE_STATS_REQUEST;

#define SYSTEM_STORE_REGISTRATION_INFORMATION_VERSION 2

typedef struct _SM_REGISTRATION_INFO
{
    HANDLE CachesUpdatedEvent;
} SM_REGISTRATION_INFO, PSM_REGISTRATION_INFO;

typedef struct _SM_REGISTRATION_REQUEST
{
    ULONG Version : 8; // SYSTEM_STORE_REGISTRATION_INFORMATION_VERSION
    ULONG Spare : 24;
    SM_REGISTRATION_INFO RegInfo;
} SM_REGISTRATION_REQUEST, *PSM_REGISTRATION_REQUEST;

#define SYSTEM_STORE_RESIZE_INFORMATION_VERSION 6

typedef struct _SM_STORE_RESIZE_REQUEST
{
    ULONG Version : 8; // SYSTEM_STORE_RESIZE_INFORMATION_VERSION
    ULONG AddRegions : 1;
    ULONG Spare : 23;
    ULONG StoreId;
    ULONG NumberOfRegions;
    struct _RTL_BITMAP *RegionBitmap;
} SM_STORE_RESIZE_REQUEST, *PSM_STORE_RESIZE_REQUEST;

#define SYSTEM_CACHE_STORE_RESIZE_INFORMATION_VERSION 1

typedef struct _SMC_STORE_RESIZE_REQUEST
{
    ULONG Version : 8; // SYSTEM_CACHE_STORE_RESIZE_INFORMATION_VERSION
    ULONG AddRegions : 1;
    ULONG Spare : 23;
    ULONG CacheId;
    ULONG StoreId;
    SM_STORE_MANAGER_TYPE StoreManagerType;
    ULONG RegionCount;
} SMC_STORE_RESIZE_REQUEST, *PSMC_STORE_RESIZE_REQUEST;

#define SYSTEM_STORE_CONFIG_INFORMATION_VERSION 4

typedef enum _SM_CONFIG_TYPE
{
    SmConfigDirtyPageCompression = 0,
    SmConfigAsyncInswap = 1,
    SmConfigPrefetchSeekThreshold = 2,
    SmConfigTypeMax = 3
} SM_CONFIG_TYPE;

typedef struct _SM_CONFIG_REQUEST
{
    ULONG Version : 8; // SYSTEM_STORE_CONFIG_INFORMATION_VERSION
    ULONG Spare : 16;
    ULONG ConfigType : 8; // SM_CONFIG_TYPE
    ULONG ConfigValue;
} SM_CONFIG_REQUEST, *PSM_CONFIG_REQUEST;

#define SYSTEM_STORE_HIGH_MEM_PRIORITY_INFORMATION_VERSION 1

// rev
typedef struct _SM_STORE_HIGH_MEM_PRIORITY_REQUEST
{
    ULONG Version : 8; // SYSTEM_STORE_HIGH_MEM_PRIORITY_INFORMATION_VERSION
    ULONG SetHighMemoryPriority : 1;
    ULONG Spare : 23;
    HANDLE ProcessHandle;
} SM_STORE_HIGH_MEM_PRIORITY_REQUEST, *PSM_STORE_HIGH_MEM_PRIORITY_REQUEST;

#define SYSTEM_STORE_TRIM_INFORMATION_VERSION 1

// rev
typedef struct _SM_SYSTEM_STORE_TRIM_REQUEST
{
    ULONG Version : 8; // SYSTEM_STORE_TRIM_INFORMATION_VERSION
    ULONG Spare : 24;
    SIZE_T PagesToTrim; // ULONG?
} SM_SYSTEM_STORE_TRIM_REQUEST, *PSM_SYSTEM_STORE_TRIM_REQUEST;

// rev
#define SYSTEM_STORE_COMPRESSION_INFORMATION_VERSION 3

// rev
typedef struct _SM_MEM_COMPRESSION_INFO_REQUEST
{
    ULONG Version : 8; // SYSTEM_STORE_COMPRESSION_INFORMATION_VERSION
    ULONG Spare : 24;
    ULONG CompressionPid;
    ULONG WorkingSetSize;
    SIZE_T TotalDataCompressed;
    SIZE_T TotalCompressedSize;
    SIZE_T TotalUniqueDataCompressed;
} SM_MEM_COMPRESSION_INFO_REQUEST, *PSM_MEM_COMPRESSION_INFO_REQUEST;

// private
typedef struct _SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS
{
    HANDLE KeyHandle;
    PUNICODE_STRING ValueNamePointer;
    PULONG RequiredLengthPointer;
    PUCHAR Buffer;
    ULONG BufferLength;
    ULONG Type;
    PUCHAR AppendBuffer;
    ULONG AppendBufferLength;
    BOOLEAN CreateIfDoesntExist;
    BOOLEAN TruncateExistingValue;
} SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS, *PSYSTEM_REGISTRY_APPEND_STRING_PARAMETERS;

// msdn
typedef struct _SYSTEM_VHD_BOOT_INFORMATION
{
    BOOLEAN OsDiskIsVhd;
    ULONG OsVhdFilePathOffset;
    WCHAR OsVhdParentVolume[1];
} SYSTEM_VHD_BOOT_INFORMATION, *PSYSTEM_VHD_BOOT_INFORMATION;

// private
typedef struct _PS_CPU_QUOTA_QUERY_ENTRY
{
    ULONG SessionId;
    ULONG Weight;
} PS_CPU_QUOTA_QUERY_ENTRY, *PPS_CPU_QUOTA_QUERY_ENTRY;

// private
typedef struct _PS_CPU_QUOTA_QUERY_INFORMATION
{
    ULONG SessionCount;
    PS_CPU_QUOTA_QUERY_ENTRY SessionInformation[1];
} PS_CPU_QUOTA_QUERY_INFORMATION, *PPS_CPU_QUOTA_QUERY_INFORMATION;

// private
typedef struct _SYSTEM_ERROR_PORT_TIMEOUTS
{
    ULONG StartTimeout;
    ULONG CommTimeout;
} SYSTEM_ERROR_PORT_TIMEOUTS, *PSYSTEM_ERROR_PORT_TIMEOUTS;

// private
typedef struct _SYSTEM_LOW_PRIORITY_IO_INFORMATION
{
    ULONG LowPriReadOperations;
    ULONG LowPriWriteOperations;
    ULONG KernelBumpedToNormalOperations;
    ULONG LowPriPagingReadOperations;
    ULONG KernelPagingReadsBumpedToNormal;
    ULONG LowPriPagingWriteOperations;
    ULONG KernelPagingWritesBumpedToNormal;
    ULONG BoostedIrpCount;
    ULONG BoostedPagingIrpCount;
    ULONG BlanketBoostCount;
} SYSTEM_LOW_PRIORITY_IO_INFORMATION, *PSYSTEM_LOW_PRIORITY_IO_INFORMATION;

// symbols
typedef enum _TPM_BOOT_ENTROPY_RESULT_CODE
{
    TpmBootEntropyStructureUninitialized,
    TpmBootEntropyDisabledByPolicy,
    TpmBootEntropyNoTpmFound,
    TpmBootEntropyTpmError,
    TpmBootEntropySuccess
} TPM_BOOT_ENTROPY_RESULT_CODE;

// Contents of KeLoaderBlock->Extension->TpmBootEntropyResult (TPM_BOOT_ENTROPY_LDR_RESULT).
// EntropyData is truncated to 40 bytes.

// private
typedef struct _TPM_BOOT_ENTROPY_NT_RESULT
{
    ULONGLONG Policy;
    TPM_BOOT_ENTROPY_RESULT_CODE ResultCode;
    NTSTATUS ResultStatus;
    ULONGLONG Time;
    ULONG EntropyLength;
    UCHAR EntropyData[40];
} TPM_BOOT_ENTROPY_NT_RESULT, *PTPM_BOOT_ENTROPY_NT_RESULT;

// private
typedef struct _SYSTEM_VERIFIER_COUNTERS_INFORMATION
{
    SYSTEM_VERIFIER_INFORMATION Legacy;
    ULONG RaiseIrqls;
    ULONG AcquireSpinLocks;
    ULONG SynchronizeExecutions;
    ULONG AllocationsWithNoTag;
    ULONG AllocationsFailed;
    ULONG AllocationsFailedDeliberately;
    SIZE_T LockedBytes;
    SIZE_T PeakLockedBytes;
    SIZE_T MappedLockedBytes;
    SIZE_T PeakMappedLockedBytes;
    SIZE_T MappedIoSpaceBytes;
    SIZE_T PeakMappedIoSpaceBytes;
    SIZE_T PagesForMdlBytes;
    SIZE_T PeakPagesForMdlBytes;
    SIZE_T ContiguousMemoryBytes;
    SIZE_T PeakContiguousMemoryBytes;
    ULONG ExecutePoolTypes; // REDSTONE2
    ULONG ExecutePageProtections;
    ULONG ExecutePageMappings;
    ULONG ExecuteWriteSections;
    ULONG SectionAlignmentFailures;
    ULONG UnsupportedRelocs;
    ULONG IATInExecutableSection;
} SYSTEM_VERIFIER_COUNTERS_INFORMATION, *PSYSTEM_VERIFIER_COUNTERS_INFORMATION;

// private
typedef struct _SYSTEM_ACPI_AUDIT_INFORMATION
{
    ULONG RsdpCount;
    ULONG SameRsdt : 1;
    ULONG SlicPresent : 1;
    ULONG SlicDifferent : 1;
} SYSTEM_ACPI_AUDIT_INFORMATION, *PSYSTEM_ACPI_AUDIT_INFORMATION;

// private
typedef struct _SYSTEM_BASIC_PERFORMANCE_INFORMATION
{
    SIZE_T AvailablePages;
    SIZE_T CommittedPages;
    SIZE_T CommitLimit;
    SIZE_T PeakCommitment;
} SYSTEM_BASIC_PERFORMANCE_INFORMATION, *PSYSTEM_BASIC_PERFORMANCE_INFORMATION;

// begin_msdn

typedef struct _QUERY_PERFORMANCE_COUNTER_FLAGS
{
    union
    {
        struct
        {
            ULONG KernelTransition : 1;
            ULONG Reserved : 31;
        };
        ULONG ul;
    };
} QUERY_PERFORMANCE_COUNTER_FLAGS;

typedef struct _SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION
{
    ULONG Version;
    QUERY_PERFORMANCE_COUNTER_FLAGS Flags;
    QUERY_PERFORMANCE_COUNTER_FLAGS ValidFlags;
} SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION, *PSYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION;

// end_msdn

// private
typedef enum _SYSTEM_PIXEL_FORMAT
{
    SystemPixelFormatUnknown,
    SystemPixelFormatR8G8B8,
    SystemPixelFormatR8G8B8X8,
    SystemPixelFormatB8G8R8,
    SystemPixelFormatB8G8R8X8
} SYSTEM_PIXEL_FORMAT;

// private
typedef struct _SYSTEM_BOOT_GRAPHICS_INFORMATION
{
    LARGE_INTEGER FrameBuffer;
    ULONG Width;
    ULONG Height;
    ULONG PixelStride;
    ULONG Flags;
    SYSTEM_PIXEL_FORMAT Format;
    ULONG DisplayRotation;
} SYSTEM_BOOT_GRAPHICS_INFORMATION, *PSYSTEM_BOOT_GRAPHICS_INFORMATION;

// private
typedef struct _MEMORY_SCRUB_INFORMATION
{
    HANDLE Handle;
    ULONG PagesScrubbed;
} MEMORY_SCRUB_INFORMATION, *PMEMORY_SCRUB_INFORMATION;

// private
typedef struct _PEBS_DS_SAVE_AREA32
{
    ULONG BtsBufferBase;
    ULONG BtsIndex;
    ULONG BtsAbsoluteMaximum;
    ULONG BtsInterruptThreshold;
    ULONG PebsBufferBase;
    ULONG PebsIndex;
    ULONG PebsAbsoluteMaximum;
    ULONG PebsInterruptThreshold;
    ULONG PebsGpCounterReset[8];
    ULONG PebsFixedCounterReset[4];
} PEBS_DS_SAVE_AREA32, *PPEBS_DS_SAVE_AREA32;

// private
typedef struct _PEBS_DS_SAVE_AREA64
{
    ULONGLONG BtsBufferBase;
    ULONGLONG BtsIndex;
    ULONGLONG BtsAbsoluteMaximum;
    ULONGLONG BtsInterruptThreshold;
    ULONGLONG PebsBufferBase;
    ULONGLONG PebsIndex;
    ULONGLONG PebsAbsoluteMaximum;
    ULONGLONG PebsInterruptThreshold;
    ULONGLONG PebsGpCounterReset[8];
    ULONGLONG PebsFixedCounterReset[4];
} PEBS_DS_SAVE_AREA64, *PPEBS_DS_SAVE_AREA64;

// private
typedef union _PEBS_DS_SAVE_AREA
{
    PEBS_DS_SAVE_AREA32 As32Bit;
    PEBS_DS_SAVE_AREA64 As64Bit;
} PEBS_DS_SAVE_AREA, *PPEBS_DS_SAVE_AREA;

// private
typedef struct _PROCESSOR_PROFILE_CONTROL_AREA
{
    PEBS_DS_SAVE_AREA PebsDsSaveArea;
} PROCESSOR_PROFILE_CONTROL_AREA, *PPROCESSOR_PROFILE_CONTROL_AREA;

// private
typedef struct _SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA
{
    PROCESSOR_PROFILE_CONTROL_AREA ProcessorProfileControlArea;
    BOOLEAN Allocate;
} SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA, *PSYSTEM_PROCESSOR_PROFILE_CONTROL_AREA;

// private
typedef struct _MEMORY_COMBINE_INFORMATION
{
    HANDLE Handle;
    ULONG_PTR PagesCombined;
} MEMORY_COMBINE_INFORMATION, *PMEMORY_COMBINE_INFORMATION;

// rev
#define MEMORY_COMBINE_FLAGS_COMMON_PAGES_ONLY 0x4

// private
typedef struct _MEMORY_COMBINE_INFORMATION_EX
{
    HANDLE Handle;
    ULONG_PTR PagesCombined;
    ULONG Flags;
} MEMORY_COMBINE_INFORMATION_EX, *PMEMORY_COMBINE_INFORMATION_EX;

// private
typedef struct _MEMORY_COMBINE_INFORMATION_EX2
{
    HANDLE Handle;
    ULONG_PTR PagesCombined;
    ULONG Flags;
    HANDLE ProcessHandle;
} MEMORY_COMBINE_INFORMATION_EX2, *PMEMORY_COMBINE_INFORMATION_EX2;

// private
typedef struct _SYSTEM_ENTROPY_TIMING_INFORMATION
{
    VOID (NTAPI *EntropyRoutine)(PVOID, ULONG);
    VOID (NTAPI *InitializationRoutine)(PVOID, ULONG, PVOID);
    PVOID InitializationContext;
} SYSTEM_ENTROPY_TIMING_INFORMATION, *PSYSTEM_ENTROPY_TIMING_INFORMATION;

// private
typedef struct _SYSTEM_CONSOLE_INFORMATION
{
    ULONG DriverLoaded : 1;
    ULONG Spare : 31;
} SYSTEM_CONSOLE_INFORMATION, *PSYSTEM_CONSOLE_INFORMATION;

// private
typedef struct _SYSTEM_PLATFORM_BINARY_INFORMATION
{
    ULONG64 PhysicalAddress;
    PVOID HandoffBuffer;
    PVOID CommandLineBuffer;
    ULONG HandoffBufferSize;
    ULONG CommandLineBufferSize;
} SYSTEM_PLATFORM_BINARY_INFORMATION, *PSYSTEM_PLATFORM_BINARY_INFORMATION;

// private
typedef struct _SYSTEM_POLICY_INFORMATION
{
    PVOID InputData;
    PVOID OutputData;
    ULONG InputDataSize;
    ULONG OutputDataSize;
    ULONG Version;
} SYSTEM_POLICY_INFORMATION, *PSYSTEM_POLICY_INFORMATION;

// private
typedef struct _SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION
{
    ULONG NumberOfLogicalProcessors;
    ULONG NumberOfCores;
} SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION, *PSYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION;

// private
typedef struct _SYSTEM_DEVICE_DATA_INFORMATION
{
    UNICODE_STRING DeviceId;
    UNICODE_STRING DataName;
    ULONG DataType;
    ULONG DataBufferLength;
    PVOID DataBuffer;
} SYSTEM_DEVICE_DATA_INFORMATION, *PSYSTEM_DEVICE_DATA_INFORMATION;

// private
typedef struct _PHYSICAL_CHANNEL_RUN
{
    ULONG NodeNumber;
    ULONG ChannelNumber;
    ULONGLONG BasePage;
    ULONGLONG PageCount;
    ULONG Flags;
} PHYSICAL_CHANNEL_RUN, *PPHYSICAL_CHANNEL_RUN;

// private
typedef struct _SYSTEM_MEMORY_TOPOLOGY_INFORMATION
{
    ULONGLONG NumberOfRuns;
    ULONG NumberOfNodes;
    ULONG NumberOfChannels;
    PHYSICAL_CHANNEL_RUN Run[1];
} SYSTEM_MEMORY_TOPOLOGY_INFORMATION, *PSYSTEM_MEMORY_TOPOLOGY_INFORMATION;

// private
typedef struct _SYSTEM_MEMORY_CHANNEL_INFORMATION
{
    ULONG ChannelNumber;
    ULONG ChannelHeatIndex;
    ULONGLONG TotalPageCount;
    ULONGLONG ZeroPageCount;
    ULONGLONG FreePageCount;
    ULONGLONG StandbyPageCount;
} SYSTEM_MEMORY_CHANNEL_INFORMATION, *PSYSTEM_MEMORY_CHANNEL_INFORMATION;

// private
typedef struct _SYSTEM_BOOT_LOGO_INFORMATION
{
    ULONG Flags;
    ULONG BitmapOffset;
} SYSTEM_BOOT_LOGO_INFORMATION, *PSYSTEM_BOOT_LOGO_INFORMATION;

// private
typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX
{
    LARGE_INTEGER IdleTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER DpcTime;
    LARGE_INTEGER InterruptTime;
    ULONG InterruptCount;
    ULONG Spare0;
    LARGE_INTEGER AvailableTime;
    LARGE_INTEGER Spare1;
    LARGE_INTEGER Spare2;
} SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX, *PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX;

// private
typedef struct _SYSTEM_SECUREBOOT_POLICY_INFORMATION
{
    GUID PolicyPublisher;
    ULONG PolicyVersion;
    ULONG PolicyOptions;
} SYSTEM_SECUREBOOT_POLICY_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_INFORMATION;

// private
typedef struct _SYSTEM_PAGEFILE_INFORMATION_EX
{
    union // HACK union declaration for convenience (dmex)
    {
        SYSTEM_PAGEFILE_INFORMATION Info;
        struct
        {
            ULONG NextEntryOffset;
            ULONG TotalSize;
            ULONG TotalInUse;
            ULONG PeakUsage;
            UNICODE_STRING PageFileName;
        };
    };

    ULONG MinimumSize;
    ULONG MaximumSize;
} SYSTEM_PAGEFILE_INFORMATION_EX, *PSYSTEM_PAGEFILE_INFORMATION_EX;

// private
typedef struct _SYSTEM_SECUREBOOT_INFORMATION
{
    BOOLEAN SecureBootEnabled;
    BOOLEAN SecureBootCapable;
} SYSTEM_SECUREBOOT_INFORMATION, *PSYSTEM_SECUREBOOT_INFORMATION;

// private
typedef struct _PROCESS_DISK_COUNTERS
{
    ULONGLONG BytesRead;
    ULONGLONG BytesWritten;
    ULONGLONG ReadOperationCount;
    ULONGLONG WriteOperationCount;
    ULONGLONG FlushOperationCount;
} PROCESS_DISK_COUNTERS, *PPROCESS_DISK_COUNTERS;

// private
typedef union _ENERGY_STATE_DURATION
{
    ULONGLONG Value;
    struct
    {
        ULONG LastChangeTime;
        ULONG Duration : 31;
        ULONG IsInState : 1;
    };
} ENERGY_STATE_DURATION, *PENERGY_STATE_DURATION;

typedef struct _PROCESS_ENERGY_VALUES
{
    ULONGLONG Cycles[4][2];
    ULONGLONG DiskEnergy;
    ULONGLONG NetworkTailEnergy;
    ULONGLONG MBBTailEnergy;
    ULONGLONG NetworkTxRxBytes;
    ULONGLONG MBBTxRxBytes;
    union
    {
        ENERGY_STATE_DURATION Durations[3];
        struct
        {
            ENERGY_STATE_DURATION ForegroundDuration;
            ENERGY_STATE_DURATION DesktopVisibleDuration;
            ENERGY_STATE_DURATION PSMForegroundDuration;
        };
    };
    ULONG CompositionRendered;
    ULONG CompositionDirtyGenerated;
    ULONG CompositionDirtyPropagated;
    ULONG Reserved1;
    ULONGLONG AttributedCycles[4][2];
    ULONGLONG WorkOnBehalfCycles[4][2];
} PROCESS_ENERGY_VALUES, *PPROCESS_ENERGY_VALUES;

typedef union _TIMELINE_BITMAP
{
    ULONGLONG Value;
    struct
    {
        ULONG EndTime;
        ULONG Bitmap;
    };
} TIMELINE_BITMAP, *PTIMELINE_BITMAP;

typedef struct _PROCESS_ENERGY_VALUES_EXTENSION
{
    union
    {
        TIMELINE_BITMAP Timelines[14]; // 9 for REDSTONE2, 14 for REDSTONE3/4/5
        struct
        {
            TIMELINE_BITMAP CpuTimeline;
            TIMELINE_BITMAP DiskTimeline;
            TIMELINE_BITMAP NetworkTimeline;
            TIMELINE_BITMAP MBBTimeline;
            TIMELINE_BITMAP ForegroundTimeline;
            TIMELINE_BITMAP DesktopVisibleTimeline;
            TIMELINE_BITMAP CompositionRenderedTimeline;
            TIMELINE_BITMAP CompositionDirtyGeneratedTimeline;
            TIMELINE_BITMAP CompositionDirtyPropagatedTimeline;
            TIMELINE_BITMAP InputTimeline; // REDSTONE3
            TIMELINE_BITMAP AudioInTimeline;
            TIMELINE_BITMAP AudioOutTimeline;
            TIMELINE_BITMAP DisplayRequiredTimeline;
            TIMELINE_BITMAP KeyboardInputTimeline;
        };
    };

    union // REDSTONE3
    {
        ENERGY_STATE_DURATION Durations[5];
        struct
        {
            ENERGY_STATE_DURATION InputDuration;
            ENERGY_STATE_DURATION AudioInDuration;
            ENERGY_STATE_DURATION AudioOutDuration;
            ENERGY_STATE_DURATION DisplayRequiredDuration;
            ENERGY_STATE_DURATION PSMBackgroundDuration;
        };
    };

    ULONG KeyboardInput;
    ULONG MouseInput;
} PROCESS_ENERGY_VALUES_EXTENSION, *PPROCESS_ENERGY_VALUES_EXTENSION;

typedef struct _PROCESS_EXTENDED_ENERGY_VALUES
{
    PROCESS_ENERGY_VALUES Base;
    PROCESS_ENERGY_VALUES_EXTENSION Extension;
} PROCESS_EXTENDED_ENERGY_VALUES, *PPROCESS_EXTENDED_ENERGY_VALUES;

// private
typedef enum _SYSTEM_PROCESS_CLASSIFICATION
{
    SystemProcessClassificationNormal,
    SystemProcessClassificationSystem,
    SystemProcessClassificationSecureSystem,
    SystemProcessClassificationMemCompression,
    SystemProcessClassificationRegistry, // REDSTONE4
    SystemProcessClassificationMaximum
} SYSTEM_PROCESS_CLASSIFICATION;

// private
typedef struct _SYSTEM_PROCESS_INFORMATION_EXTENSION
{
    PROCESS_DISK_COUNTERS DiskCounters;
    ULONGLONG ContextSwitches;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG HasStrongId : 1;
            ULONG Classification : 4; // SYSTEM_PROCESS_CLASSIFICATION
            ULONG BackgroundActivityModerated : 1;
            ULONG Spare : 26;
        };
    };
    ULONG UserSidOffset;
    ULONG PackageFullNameOffset; // since THRESHOLD
    PROCESS_ENERGY_VALUES EnergyValues; // since THRESHOLD
    ULONG AppIdOffset; // since THRESHOLD
    SIZE_T SharedCommitCharge; // since THRESHOLD2
    ULONG JobObjectId; // since REDSTONE
    ULONG SpareUlong; // since REDSTONE
    ULONGLONG ProcessSequenceNumber;
} SYSTEM_PROCESS_INFORMATION_EXTENSION, *PSYSTEM_PROCESS_INFORMATION_EXTENSION;

// private
typedef struct _SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION
{
    BOOLEAN EfiLauncherEnabled;
} SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION, *PSYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION;

// private
typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
{
    BOOLEAN DebuggerAllowed;
    BOOLEAN DebuggerEnabled;
    BOOLEAN DebuggerPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;

// private
typedef struct _SYSTEM_ELAM_CERTIFICATE_INFORMATION
{
    HANDLE ElamDriverFile;
} SYSTEM_ELAM_CERTIFICATE_INFORMATION, *PSYSTEM_ELAM_CERTIFICATE_INFORMATION;

// private
typedef struct _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2
{
    ULONG Version;
    ULONG AbnormalResetOccurred;
    ULONG OfflineMemoryDumpCapable;
    LARGE_INTEGER ResetDataAddress;
    ULONG ResetDataSize;
} OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2, *POFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2;

// private
typedef struct _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1
{
    ULONG Version;
    ULONG AbnormalResetOccurred;
    ULONG OfflineMemoryDumpCapable;
} OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1, *POFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1;

// private
typedef struct _SYSTEM_PROCESSOR_FEATURES_INFORMATION
{
    ULONGLONG ProcessorFeatureBits;
    ULONGLONG Reserved[3];
} SYSTEM_PROCESSOR_FEATURES_INFORMATION, *PSYSTEM_PROCESSOR_FEATURES_INFORMATION;

// EDID v1.4 standard data format
typedef struct _SYSTEM_EDID_INFORMATION
{
    UCHAR Edid[128];
} SYSTEM_EDID_INFORMATION, *PSYSTEM_EDID_INFORMATION;

// private
typedef struct _SYSTEM_MANUFACTURING_INFORMATION
{
    ULONG Options;
    UNICODE_STRING ProfileName;
} SYSTEM_MANUFACTURING_INFORMATION, *PSYSTEM_MANUFACTURING_INFORMATION;

// private
typedef struct _SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION
{
    BOOLEAN Enabled;
} SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION, *PSYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION;

// private
typedef struct _HV_DETAILS
{
    ULONG Data[4];
} HV_DETAILS, *PHV_DETAILS;

// private
typedef struct _SYSTEM_HYPERVISOR_DETAIL_INFORMATION
{
    HV_DETAILS HvVendorAndMaxFunction;
    HV_DETAILS HypervisorInterface;
    HV_DETAILS HypervisorVersion;
    HV_DETAILS HvFeatures;
    HV_DETAILS HwFeatures;
    HV_DETAILS EnlightenmentInfo;
    HV_DETAILS ImplementationLimits;
} SYSTEM_HYPERVISOR_DETAIL_INFORMATION, *PSYSTEM_HYPERVISOR_DETAIL_INFORMATION;

// private
typedef struct _SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION
{
    ULONGLONG Cycles[4][2];
} SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION, *PSYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION;

// private
typedef struct _SYSTEM_TPM_INFORMATION
{
    ULONG Flags;
} SYSTEM_TPM_INFORMATION, *PSYSTEM_TPM_INFORMATION;

// private
typedef struct _SYSTEM_VSM_PROTECTION_INFORMATION
{
    BOOLEAN DmaProtectionsAvailable;
    BOOLEAN DmaProtectionsInUse;
    BOOLEAN HardwareMbecAvailable; // REDSTONE4 (CVE-2018-3639)
    BOOLEAN ApicVirtualizationAvailable; // 20H1
} SYSTEM_VSM_PROTECTION_INFORMATION, *PSYSTEM_VSM_PROTECTION_INFORMATION;

// private
typedef struct _SYSTEM_KERNEL_DEBUGGER_FLAGS
{
    BOOLEAN KernelDebuggerIgnoreUmExceptions;
} SYSTEM_KERNEL_DEBUGGER_FLAGS, *PSYSTEM_KERNEL_DEBUGGER_FLAGS;

// private
typedef struct _SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
{
    ULONG Options;
    ULONG HVCIOptions;
    ULONGLONG Version;
    GUID PolicyGuid;
} SYSTEM_CODEINTEGRITYPOLICY_INFORMATION, *PSYSTEM_CODEINTEGRITYPOLICY_INFORMATION;

// private
typedef struct _SYSTEM_ISOLATED_USER_MODE_INFORMATION
{
    BOOLEAN SecureKernelRunning : 1;
    BOOLEAN HvciEnabled : 1;
    BOOLEAN HvciStrictMode : 1;
    BOOLEAN DebugEnabled : 1;
    BOOLEAN FirmwarePageProtection : 1;
    BOOLEAN EncryptionKeyAvailable : 1;
    BOOLEAN SpareFlags : 2;
    BOOLEAN TrustletRunning : 1;
    BOOLEAN HvciDisableAllowed : 1;
    BOOLEAN SpareFlags2 : 6;
    BOOLEAN Spare0[6];
    ULONGLONG Spare1;
} SYSTEM_ISOLATED_USER_MODE_INFORMATION, *PSYSTEM_ISOLATED_USER_MODE_INFORMATION;

// private
typedef struct _SYSTEM_SINGLE_MODULE_INFORMATION
{
    PVOID TargetModuleAddress;
    RTL_PROCESS_MODULE_INFORMATION_EX ExInfo;
} SYSTEM_SINGLE_MODULE_INFORMATION, *PSYSTEM_SINGLE_MODULE_INFORMATION;

// private
typedef struct _SYSTEM_INTERRUPT_CPU_SET_INFORMATION
{
    ULONG Gsiv;
    USHORT Group;
    ULONGLONG CpuSets;
} SYSTEM_INTERRUPT_CPU_SET_INFORMATION, *PSYSTEM_INTERRUPT_CPU_SET_INFORMATION;

// private
typedef struct _SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
{
    SYSTEM_SECUREBOOT_POLICY_INFORMATION PolicyInformation;
    ULONG PolicySize;
    UCHAR Policy[1];
} SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION;

// private
typedef struct _SYSTEM_ROOT_SILO_INFORMATION
{
    ULONG NumberOfSilos;
    ULONG SiloIdList[1];
} SYSTEM_ROOT_SILO_INFORMATION, *PSYSTEM_ROOT_SILO_INFORMATION;

// private
typedef struct _SYSTEM_CPU_SET_TAG_INFORMATION
{
    ULONGLONG Tag;
    ULONGLONG CpuSets[1];
} SYSTEM_CPU_SET_TAG_INFORMATION, *PSYSTEM_CPU_SET_TAG_INFORMATION;

// private
typedef struct _SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION
{
    ULONG ExtentCount;
    ULONG ValidStructureSize;
    ULONG NextExtentIndex;
    ULONG ExtentRestart;
    ULONG CycleCount;
    ULONG TimeoutCount;
    ULONGLONG CycleTime;
    ULONGLONG CycleTimeMax;
    ULONGLONG ExtentTime;
    ULONG ExtentTimeIndex;
    ULONG ExtentTimeMaxIndex;
    ULONGLONG ExtentTimeMax;
    ULONGLONG HyperFlushTimeMax;
    ULONGLONG TranslateVaTimeMax;
    ULONGLONG DebugExemptionCount;
    ULONGLONG TbHitCount;
    ULONGLONG TbMissCount;
    ULONGLONG VinaPendingYield;
    ULONGLONG HashCycles;
    ULONG HistogramOffset;
    ULONG HistogramBuckets;
    ULONG HistogramShift;
    ULONG Reserved1;
    ULONGLONG PageNotPresentCount;
} SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION, *PSYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION;

// private
typedef struct _SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION
{
    ULONG PlatformManifestSize;
    UCHAR PlatformManifest[1];
} SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION, *PSYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION;

// private
typedef struct _SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT
{
    ULONG Gsiv;
    UCHAR ControllerInterrupt;
    UCHAR EdgeInterrupt;
    UCHAR IsPrimaryInterrupt;
    GROUP_AFFINITY TargetAffinity;
} SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT, *PSYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT;

typedef union _SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT
{
    ULONG AsULONG;
    struct
    {
        ULONG Enabled : 1;
        ULONG Reserved : 31;
    };
} SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT, *PSYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT;

#if !defined(NTDDI_WIN10_CO) || (NTDDI_VERSION < NTDDI_WIN10_CO)
// private
typedef struct _SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION
{
    ULONG Machine : 16;
    ULONG KernelMode : 1;
    ULONG UserMode : 1;
    ULONG Native : 1;
    ULONG Process : 1;
    ULONG WoW64Container : 1;
    ULONG ReservedZero0 : 11;
} SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION;
#endif

// private
typedef struct _SYSTEM_MEMORY_USAGE_INFORMATION
{
    ULONGLONG TotalPhysicalBytes;
    ULONGLONG AvailableBytes;
    LONGLONG ResidentAvailableBytes;
    ULONGLONG CommittedBytes;
    ULONGLONG SharedCommittedBytes;
    ULONGLONG CommitLimitBytes;
    ULONGLONG PeakCommitmentBytes;
} SYSTEM_MEMORY_USAGE_INFORMATION, *PSYSTEM_MEMORY_USAGE_INFORMATION;

// private
typedef struct _SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
{
    HANDLE ImageFile;
    ULONG Type; // REDSTONE4
} SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION, *PSYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION;

// private
typedef struct _SYSTEM_PHYSICAL_MEMORY_INFORMATION
{
    ULONGLONG TotalPhysicalBytes;
    ULONGLONG LowestPhysicalAddress;
    ULONGLONG HighestPhysicalAddress;
} SYSTEM_PHYSICAL_MEMORY_INFORMATION, *PSYSTEM_PHYSICAL_MEMORY_INFORMATION;

// private
typedef enum _SYSTEM_ACTIVITY_MODERATION_STATE
{
    SystemActivityModerationStateSystemManaged,
    SystemActivityModerationStateUserManagedAllowThrottling,
    SystemActivityModerationStateUserManagedDisableThrottling,
    MaxSystemActivityModerationState
} SYSTEM_ACTIVITY_MODERATION_STATE;

// private - REDSTONE2
typedef struct _SYSTEM_ACTIVITY_MODERATION_EXE_STATE // REDSTONE3: Renamed SYSTEM_ACTIVITY_MODERATION_INFO
{
    UNICODE_STRING ExePathNt;
    SYSTEM_ACTIVITY_MODERATION_STATE ModerationState;
} SYSTEM_ACTIVITY_MODERATION_EXE_STATE, *PSYSTEM_ACTIVITY_MODERATION_EXE_STATE;

typedef enum _SYSTEM_ACTIVITY_MODERATION_APP_TYPE
{
    SystemActivityModerationAppTypeClassic,
    SystemActivityModerationAppTypePackaged,
    MaxSystemActivityModerationAppType
} SYSTEM_ACTIVITY_MODERATION_APP_TYPE;

// private - REDSTONE3
typedef struct _SYSTEM_ACTIVITY_MODERATION_INFO
{
    UNICODE_STRING Identifier;
    SYSTEM_ACTIVITY_MODERATION_STATE ModerationState;
    SYSTEM_ACTIVITY_MODERATION_APP_TYPE AppType;
} SYSTEM_ACTIVITY_MODERATION_INFO, *PSYSTEM_ACTIVITY_MODERATION_INFO;

// private
typedef struct _SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS
{
    HANDLE UserKeyHandle;
} SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS, *PSYSTEM_ACTIVITY_MODERATION_USER_SETTINGS;

// private
typedef struct _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION
{
    union
    {
        ULONG Flags;
        struct
        {
            ULONG Locked : 1;
            ULONG UnlockApplied : 1; // Unlockable field removed 19H1
            ULONG UnlockIdValid : 1;
            ULONG Reserved : 29;
        };
    };
    UCHAR UnlockId[32]; // REDSTONE4
} SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION, *PSYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION;

// private
typedef struct _SYSTEM_FLUSH_INFORMATION
{
    ULONG SupportedFlushMethods;
    ULONG ProcessorCacheFlushSize;
    ULONGLONG SystemFlushCapabilities;
    ULONGLONG Reserved[2];
} SYSTEM_FLUSH_INFORMATION, *PSYSTEM_FLUSH_INFORMATION;

// private
typedef struct _SYSTEM_WRITE_CONSTRAINT_INFORMATION
{
    ULONG WriteConstraintPolicy;
    ULONG Reserved;
} SYSTEM_WRITE_CONSTRAINT_INFORMATION, *PSYSTEM_WRITE_CONSTRAINT_INFORMATION;

// private
typedef struct _SYSTEM_KERNEL_VA_SHADOW_INFORMATION
{
    union
    {
        ULONG KvaShadowFlags;
        struct
        {
            ULONG KvaShadowEnabled : 1;
            ULONG KvaShadowUserGlobal : 1;
            ULONG KvaShadowPcid : 1;
            ULONG KvaShadowInvpcid : 1;
            ULONG KvaShadowRequired : 1; // REDSTONE4
            ULONG KvaShadowRequiredAvailable : 1;
            ULONG InvalidPteBit : 6;
            ULONG L1DataCacheFlushSupported : 1;
            ULONG L1TerminalFaultMitigationPresent : 1;
            ULONG Reserved : 18;
        };
    };
} SYSTEM_KERNEL_VA_SHADOW_INFORMATION, *PSYSTEM_KERNEL_VA_SHADOW_INFORMATION;

// private
typedef struct _SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION
{
    HANDLE FileHandle;
    ULONG ImageSize;
    PVOID Image;
} SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION, *PSYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION;

// private
typedef struct _SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION
{
    PVOID HypervisorSharedUserVa;
} SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION, *PSYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION;

// private
typedef struct _SYSTEM_FIRMWARE_PARTITION_INFORMATION
{
    UNICODE_STRING FirmwarePartition;
} SYSTEM_FIRMWARE_PARTITION_INFORMATION, *PSYSTEM_FIRMWARE_PARTITION_INFORMATION;

// private
typedef struct _SYSTEM_SPECULATION_CONTROL_INFORMATION
{
    union
    {
        ULONG Flags;
        struct
        {
            ULONG BpbEnabled : 1;
            ULONG BpbDisabledSystemPolicy : 1;
            ULONG BpbDisabledNoHardwareSupport : 1;
            ULONG SpecCtrlEnumerated : 1;
            ULONG SpecCmdEnumerated : 1;
            ULONG IbrsPresent : 1;
            ULONG StibpPresent : 1;
            ULONG SmepPresent : 1;
            ULONG SpeculativeStoreBypassDisableAvailable : 1; // REDSTONE4 (CVE-2018-3639)
            ULONG SpeculativeStoreBypassDisableSupported : 1;
            ULONG SpeculativeStoreBypassDisabledSystemWide : 1;
            ULONG SpeculativeStoreBypassDisabledKernel : 1;
            ULONG SpeculativeStoreBypassDisableRequired : 1;
            ULONG BpbDisabledKernelToUser : 1;
            ULONG SpecCtrlRetpolineEnabled : 1;
            ULONG SpecCtrlImportOptimizationEnabled : 1;
            ULONG EnhancedIbrs : 1; // since 19H1
            ULONG HvL1tfStatusAvailable : 1;
            ULONG HvL1tfProcessorNotAffected : 1;
            ULONG HvL1tfMigitationEnabled : 1;
            ULONG HvL1tfMigitationNotEnabled_Hardware : 1;
            ULONG HvL1tfMigitationNotEnabled_LoadOption : 1;
            ULONG HvL1tfMigitationNotEnabled_CoreScheduler : 1;
            ULONG EnhancedIbrsReported : 1;
            ULONG MdsHardwareProtected : 1; // since 19H2
            ULONG MbClearEnabled : 1;
            ULONG MbClearReported : 1;
            ULONG Reserved : 5;
        };
    };
} SYSTEM_SPECULATION_CONTROL_INFORMATION, *PSYSTEM_SPECULATION_CONTROL_INFORMATION;

// private
typedef struct _SYSTEM_DMA_GUARD_POLICY_INFORMATION
{
    BOOLEAN DmaGuardPolicyEnabled;
} SYSTEM_DMA_GUARD_POLICY_INFORMATION, *PSYSTEM_DMA_GUARD_POLICY_INFORMATION;

// private
typedef struct _SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION
{
    UCHAR EnclaveLaunchSigner[32];
} SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION, *PSYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION;

// private
typedef struct _SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION
{
    ULONGLONG WorkloadClass;
    ULONGLONG CpuSets[1];
} SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION, *PSYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION;

// private
typedef struct _SYSTEM_SECURITY_MODEL_INFORMATION
{
    union
    {
        ULONG SecurityModelFlags;
        struct
        {
            ULONG SModeAdminlessEnabled : 1;
            ULONG AllowDeviceOwnerProtectionDowngrade : 1;
            ULONG Reserved : 30;
        };
    };
} SYSTEM_SECURITY_MODEL_INFORMATION, *PSYSTEM_SECURITY_MODEL_INFORMATION;

// private
typedef struct _SYSTEM_FEATURE_CONFIGURATION_INFORMATION
{
    ULONGLONG ChangeStamp;
    struct _RTL_FEATURE_CONFIGURATION* Configuration; // see ntrtl.h for types
} SYSTEM_FEATURE_CONFIGURATION_INFORMATION, *PSYSTEM_FEATURE_CONFIGURATION_INFORMATION;

// private
typedef struct _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY
{
    ULONGLONG ChangeStamp;
    PVOID Section;
    ULONGLONG Size;
} SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY, *PSYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY;

// private
typedef struct _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION
{
    ULONGLONG OverallChangeStamp;
    SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY Descriptors[3];
} SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION, *PSYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION;

// private
typedef struct _RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET
{
    ULONG Data[2];
} RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET, *PRTL_FEATURE_USAGE_SUBSCRIPTION_TARGET;

// private
typedef struct _SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS
{
    ULONG FeatureId;
    USHORT ReportingKind;
    USHORT ReportingOptions;
    RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET ReportingTarget;
} SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS, *PSYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS;

// private
typedef union _SECURE_SPECULATION_CONTROL_INFORMATION
{
    ULONG KvaShadowSupported : 1;
    ULONG KvaShadowEnabled : 1;
    ULONG KvaShadowUserGlobal : 1;
    ULONG KvaShadowPcid : 1;
    ULONG MbClearEnabled : 1;
    ULONG L1TFMitigated : 1; // since 20H2
    ULONG BpbEnabled : 1;
    ULONG IbrsPresent : 1;
    ULONG EnhancedIbrs : 1;
    ULONG StibpPresent : 1;
    ULONG SsbdSupported : 1;
    ULONG SsbdRequired : 1;
    ULONG BpbKernelToUser : 1;
    ULONG BpbUserToKernel : 1;
    ULONG Reserved : 18;
} SECURE_SPECULATION_CONTROL_INFORMATION, *PSECURE_SPECULATION_CONTROL_INFORMATION;

// private
typedef struct _SYSTEM_FIRMWARE_RAMDISK_INFORMATION
{
    ULONG Version;
    ULONG BlockSize;
    ULONG_PTR BaseAddress;
    SIZE_T Size;
} SYSTEM_FIRMWARE_RAMDISK_INFORMATION, *PSYSTEM_FIRMWARE_RAMDISK_INFORMATION;

// private
typedef struct _SYSTEM_SHADOW_STACK_INFORMATION
{
    union
    {
        ULONG Flags;
        struct
        {
            ULONG CetCapable : 1;
            ULONG UserCetAllowed : 1;
            ULONG ReservedForUserCet : 6;
            ULONG KernelCetEnabled : 1;
            ULONG KernelCetAuditModeEnabled : 1;
            ULONG ReservedForKernelCet : 6; // since Windows 10 build 21387
            ULONG Reserved : 16;
        };
    };
} SYSTEM_SHADOW_STACK_INFORMATION, *PSYSTEM_SHADOW_STACK_INFORMATION;

// private
typedef union _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS
{
    ULONG Value32;
    struct
    {
        ULONG IsTopLevel : 1;
        ULONG IsChecked : 1;
    };
} SYSTEM_BUILD_VERSION_INFORMATION_FLAGS, *PSYSTEM_BUILD_VERSION_INFORMATION_FLAGS;

// private
typedef struct _SYSTEM_BUILD_VERSION_INFORMATION
{
    USHORT LayerNumber;
    USHORT LayerCount;
    ULONG OsMajorVersion;
    ULONG OsMinorVersion;
    ULONG NtBuildNumber;
    ULONG NtBuildQfe;
    UCHAR LayerName[128];
    UCHAR NtBuildBranch[128];
    UCHAR NtBuildLab[128];
    UCHAR NtBuildLabEx[128];
    UCHAR NtBuildStamp[26];
    UCHAR NtBuildArch[16];
    SYSTEM_BUILD_VERSION_INFORMATION_FLAGS Flags;
} SYSTEM_BUILD_VERSION_INFORMATION, *PSYSTEM_BUILD_VERSION_INFORMATION;

// private
typedef struct _SYSTEM_POOL_LIMIT_MEM_INFO
{
    ULONGLONG MemoryLimit;
    ULONGLONG NotificationLimit;
} SYSTEM_POOL_LIMIT_MEM_INFO, *PSYSTEM_POOL_LIMIT_MEM_INFO;

// private
typedef struct _SYSTEM_POOL_LIMIT_INFO
{
    ULONG PoolTag;
    SYSTEM_POOL_LIMIT_MEM_INFO MemLimits[2];
    WNF_STATE_NAME NotificationHandle;
} SYSTEM_POOL_LIMIT_INFO, *PSYSTEM_POOL_LIMIT_INFO;

// private
typedef struct _SYSTEM_POOL_LIMIT_INFORMATION
{
    ULONG Version;
    ULONG EntryCount;
    SYSTEM_POOL_LIMIT_INFO LimitEntries[1];
} SYSTEM_POOL_LIMIT_INFORMATION, *PSYSTEM_POOL_LIMIT_INFORMATION;

// private
//typedef struct _SYSTEM_POOL_ZEROING_INFORMATION
//{
//    BOOLEAN PoolZeroingSupportPresent;
//} SYSTEM_POOL_ZEROING_INFORMATION, *PSYSTEM_POOL_ZEROING_INFORMATION;

// private
typedef struct _HV_MINROOT_NUMA_LPS
{
    ULONG NodeIndex;
    ULONG_PTR Mask[16];
} HV_MINROOT_NUMA_LPS, *PHV_MINROOT_NUMA_LPS;

// private
typedef enum _SYSTEM_IOMMU_STATE
{
    IommuStateBlock,
    IommuStateUnblock
} SYSTEM_IOMMU_STATE;

// private
typedef struct _SYSTEM_IOMMU_STATE_INFORMATION
{
    SYSTEM_IOMMU_STATE State;
    PVOID Pdo;
} SYSTEM_IOMMU_STATE_INFORMATION, *PSYSTEM_IOMMU_STATE_INFORMATION;

// private
typedef struct _SYSTEM_HYPERVISOR_MINROOT_INFORMATION
{
    ULONG NumProc;
    ULONG RootProc;
    ULONG RootProcNumaNodesSpecified;
    USHORT RootProcNumaNodes[64];
    ULONG RootProcPerCore;
    ULONG RootProcPerNode;
    ULONG RootProcNumaNodesLpsSpecified;
    HV_MINROOT_NUMA_LPS RootProcNumaNodeLps[64];
} SYSTEM_HYPERVISOR_MINROOT_INFORMATION, *PSYSTEM_HYPERVISOR_MINROOT_INFORMATION;

// private
typedef struct _SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION
{
    ULONG RangeCount;
    ULONG_PTR RangeArray[1];
} SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION, *PSYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION;

// private
typedef struct _SYSTEM_POINTER_AUTH_INFORMATION
{
    union
    {
        USHORT SupportedFlags;
        struct
        {
            USHORT AddressAuthSupported : 1;
            USHORT AddressAuthQarma : 1;
            USHORT GenericAuthSupported : 1;
            USHORT GenericAuthQarma : 1;
            USHORT SupportedReserved : 12;
        };
    };
    union
    {
        USHORT EnabledFlags;
        struct
        {
            USHORT UserPerProcessIpAuthEnabled : 1;
            USHORT UserGlobalIpAuthEnabled : 1;
            USHORT UserEnabledReserved : 6;
            USHORT KernelIpAuthEnabled : 1;
            USHORT KernelEnabledReserved : 7;
        };
    };
} SYSTEM_POINTER_AUTH_INFORMATION, *PSYSTEM_POINTER_AUTH_INFORMATION;

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemInformationEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength
    );

// SysDbg APIs

// private
typedef enum _SYSDBG_COMMAND
{
    SysDbgQueryModuleInformation,
    SysDbgQueryTraceInformation,
    SysDbgSetTracepoint,
    SysDbgSetSpecialCall, // PVOID
    SysDbgClearSpecialCalls, // void
    SysDbgQuerySpecialCalls,
    SysDbgBreakPoint,
    SysDbgQueryVersion, // DBGKD_GET_VERSION64
    SysDbgReadVirtual, // SYSDBG_VIRTUAL
    SysDbgWriteVirtual, // SYSDBG_VIRTUAL
    SysDbgReadPhysical, // SYSDBG_PHYSICAL // 10
    SysDbgWritePhysical, // SYSDBG_PHYSICAL
    SysDbgReadControlSpace, // SYSDBG_CONTROL_SPACE
    SysDbgWriteControlSpace, // SYSDBG_CONTROL_SPACE
    SysDbgReadIoSpace, // SYSDBG_IO_SPACE
    SysDbgWriteIoSpace, // SYSDBG_IO_SPACE
    SysDbgReadMsr, // SYSDBG_MSR
    SysDbgWriteMsr, // SYSDBG_MSR
    SysDbgReadBusData, // SYSDBG_BUS_DATA
    SysDbgWriteBusData, // SYSDBG_BUS_DATA
    SysDbgCheckLowMemory, // 20
    SysDbgEnableKernelDebugger,
    SysDbgDisableKernelDebugger,
    SysDbgGetAutoKdEnable,
    SysDbgSetAutoKdEnable,
    SysDbgGetPrintBufferSize,
    SysDbgSetPrintBufferSize,
    SysDbgGetKdUmExceptionEnable,
    SysDbgSetKdUmExceptionEnable,
    SysDbgGetTriageDump, // SYSDBG_TRIAGE_DUMP
    SysDbgGetKdBlockEnable, // 30
    SysDbgSetKdBlockEnable,
    SysDbgRegisterForUmBreakInfo,
    SysDbgGetUmBreakPid,
    SysDbgClearUmBreakPid,
    SysDbgGetUmAttachPid,
    SysDbgClearUmAttachPid,
    SysDbgGetLiveKernelDump, // SYSDBG_LIVEDUMP_CONTROL
    SysDbgKdPullRemoteFile, // SYSDBG_KD_PULL_REMOTE_FILE
    SysDbgMaxInfoClass
} SYSDBG_COMMAND, *PSYSDBG_COMMAND;

typedef struct _SYSDBG_VIRTUAL
{
    PVOID Address;
    PVOID Buffer;
    ULONG Request;
} SYSDBG_VIRTUAL, *PSYSDBG_VIRTUAL;

typedef struct _SYSDBG_PHYSICAL
{
    PHYSICAL_ADDRESS Address;
    PVOID Buffer;
    ULONG Request;
} SYSDBG_PHYSICAL, *PSYSDBG_PHYSICAL;

typedef struct _SYSDBG_CONTROL_SPACE
{
    ULONG64 Address;
    PVOID Buffer;
    ULONG Request;
    ULONG Processor;
} SYSDBG_CONTROL_SPACE, *PSYSDBG_CONTROL_SPACE;

enum _INTERFACE_TYPE;

typedef struct _SYSDBG_IO_SPACE
{
    ULONG64 Address;
    PVOID Buffer;
    ULONG Request;
    enum _INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;
    ULONG AddressSpace;
} SYSDBG_IO_SPACE, *PSYSDBG_IO_SPACE;

typedef struct _SYSDBG_MSR
{
    ULONG Msr;
    ULONG64 Data;
} SYSDBG_MSR, *PSYSDBG_MSR;

enum _BUS_DATA_TYPE;

typedef struct _SYSDBG_BUS_DATA
{
    ULONG Address;
    PVOID Buffer;
    ULONG Request;
    enum _BUS_DATA_TYPE BusDataType;
    ULONG BusNumber;
    ULONG SlotNumber;
} SYSDBG_BUS_DATA, *PSYSDBG_BUS_DATA;

// private
typedef struct _SYSDBG_TRIAGE_DUMP
{
    ULONG Flags;
    ULONG BugCheckCode;
    ULONG_PTR BugCheckParam1;
    ULONG_PTR BugCheckParam2;
    ULONG_PTR BugCheckParam3;
    ULONG_PTR BugCheckParam4;
    ULONG ProcessHandles;
    ULONG ThreadHandles;
    PHANDLE Handles;
} SYSDBG_TRIAGE_DUMP, *PSYSDBG_TRIAGE_DUMP;

// private
typedef union _SYSDBG_LIVEDUMP_CONTROL_FLAGS
{
    struct
    {
        ULONG UseDumpStorageStack : 1;
        ULONG CompressMemoryPagesData : 1;
        ULONG IncludeUserSpaceMemoryPages : 1;
        ULONG AbortIfMemoryPressure : 1; // REDSTONE4
        ULONG SelectiveDump : 1; // WIN11
        ULONG Reserved : 27;
    };
    ULONG AsUlong;
} SYSDBG_LIVEDUMP_CONTROL_FLAGS, *PSYSDBG_LIVEDUMP_CONTROL_FLAGS;

// private
typedef union _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES
{
    struct
    {
        ULONG HypervisorPages : 1;
        ULONG NonEssentialHypervisorPages : 1; // since WIN11
        ULONG Reserved : 30;
    };
    ULONG AsUlong;
} SYSDBG_LIVEDUMP_CONTROL_ADDPAGES, *PSYSDBG_LIVEDUMP_CONTROL_ADDPAGES;

#define SYSDBG_LIVEDUMP_SELECTIVE_CONTROL_VERSION 1

// rev
typedef struct _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL
{
    ULONG Version;
    ULONG Size;
    union
    {
        ULONGLONG Flags;
        struct
        {
            ULONGLONG ThreadKernelStacks : 1;
            ULONGLONG ReservedFlags : 63;
        };
    };
    ULONGLONG Reserved[4];
} SYSDBG_LIVEDUMP_SELECTIVE_CONTROL, *PSYSDBG_LIVEDUMP_SELECTIVE_CONTROL;

#define SYSDBG_LIVEDUMP_CONTROL_VERSION 1
#define SYSDBG_LIVEDUMP_CONTROL_VERSION_WIN11 2

// private
typedef struct _SYSDBG_LIVEDUMP_CONTROL
{
    ULONG Version;
    ULONG BugCheckCode;
    ULONG_PTR BugCheckParam1;
    ULONG_PTR BugCheckParam2;
    ULONG_PTR BugCheckParam3;
    ULONG_PTR BugCheckParam4;
    HANDLE DumpFileHandle;
    HANDLE CancelEventHandle;
    SYSDBG_LIVEDUMP_CONTROL_FLAGS Flags;
    SYSDBG_LIVEDUMP_CONTROL_ADDPAGES AddPagesControl;
    PSYSDBG_LIVEDUMP_SELECTIVE_CONTROL SelectiveControl; // since WIN11
} SYSDBG_LIVEDUMP_CONTROL, *PSYSDBG_LIVEDUMP_CONTROL;

#define SYSDBG_LIVEDUMP_CONTROL_SIZE RTL_SIZEOF_THROUGH_FIELD(SYSDBG_LIVEDUMP_CONTROL, AddPagesControl)
#define SYSDBG_LIVEDUMP_CONTROL_SIZE_WIN11 sizeof(SYSDBG_LIVEDUMP_CONTROL)

// private
typedef struct _SYSDBG_KD_PULL_REMOTE_FILE
{
    UNICODE_STRING ImageFileName;
} SYSDBG_KD_PULL_REMOTE_FILE, *PSYSDBG_KD_PULL_REMOTE_FILE;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSystemDebugControl(
    _In_ SYSDBG_COMMAND Command,
    _Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _Out_opt_ PULONG ReturnLength
    );

// Hard errors

typedef enum _HARDERROR_RESPONSE_OPTION
{
    OptionAbortRetryIgnore,
    OptionOk,
    OptionOkCancel,
    OptionRetryCancel,
    OptionYesNo,
    OptionYesNoCancel,
    OptionShutdownSystem,
    OptionOkNoWait,
    OptionCancelTryContinue
} HARDERROR_RESPONSE_OPTION;

typedef enum _HARDERROR_RESPONSE
{
    ResponseReturnToCaller,
    ResponseNotHandled,
    ResponseAbort,
    ResponseCancel,
    ResponseIgnore,
    ResponseNo,
    ResponseOk,
    ResponseRetry,
    ResponseYes,
    ResponseTryAgain,
    ResponseContinue
} HARDERROR_RESPONSE;

#define HARDERROR_OVERRIDE_ERRORMODE 0x10000000

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRaiseHardError(
    _In_ NTSTATUS ErrorStatus,
    _In_ ULONG NumberOfParameters,
    _In_ ULONG UnicodeStringParameterMask,
    _In_reads_(NumberOfParameters) PULONG_PTR Parameters,
    _In_ ULONG ValidResponseOptions,
    _Out_ PULONG Response
    );

// Kernel-user shared data

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE
{
    StandardDesign,
    NEC98x86,
    EndAlternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

#define PROCESSOR_FEATURE_MAX 64

#define MAX_WOW64_SHARED_ENTRIES 16

#define NX_SUPPORT_POLICY_ALWAYSOFF 0
#define NX_SUPPORT_POLICY_ALWAYSON 1
#define NX_SUPPORT_POLICY_OPTIN 2
#define NX_SUPPORT_POLICY_OPTOUT 3

#include <pshpack4.h>
typedef struct _KUSER_SHARED_DATA
{
    ULONG TickCountLowDeprecated;
    ULONG TickCountMultiplier;

    volatile KSYSTEM_TIME InterruptTime;
    volatile KSYSTEM_TIME SystemTime;
    volatile KSYSTEM_TIME TimeZoneBias;

    USHORT ImageNumberLow;
    USHORT ImageNumberHigh;

    WCHAR NtSystemRoot[260];

    ULONG MaxStackTraceDepth;

    ULONG CryptoExponent;

    ULONG TimeZoneId;
    ULONG LargePageMinimum;
    ULONG AitSamplingValue;
    ULONG AppCompatFlag;
    ULONGLONG RNGSeedVersion;
    ULONG GlobalValidationRunlevel;
    LONG TimeZoneBiasStamp;

    ULONG NtBuildNumber;
    NT_PRODUCT_TYPE NtProductType;
    BOOLEAN ProductTypeIsValid;
    UCHAR Reserved0[1];
    USHORT NativeProcessorArchitecture;

    ULONG NtMajorVersion;
    ULONG NtMinorVersion;

    BOOLEAN ProcessorFeatures[PROCESSOR_FEATURE_MAX];

    ULONG Reserved1;
    ULONG Reserved3;

    volatile ULONG TimeSlip;

    ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;
    ULONG BootId;

    LARGE_INTEGER SystemExpirationDate;

    ULONG SuiteMask;

    BOOLEAN KdDebuggerEnabled;
    union
    {
        UCHAR MitigationPolicies;
        struct
        {
            UCHAR NXSupportPolicy : 2;
            UCHAR SEHValidationPolicy : 2;
            UCHAR CurDirDevicesSkippedForDlls : 2;
            UCHAR Reserved : 2;
        };
    };

    USHORT CyclesPerYield;

    volatile ULONG ActiveConsoleId;

    volatile ULONG DismountCount;

    ULONG ComPlusPackage;

    ULONG LastSystemRITEventTickCount;

    ULONG NumberOfPhysicalPages;

    BOOLEAN SafeBootMode;

    union
    {
        UCHAR VirtualizationFlags;
#if defined(_ARM64_)
        struct
        {
            UCHAR ArchStartedInEl2 : 1;
            UCHAR QcSlIsSupported : 1;
            UCHAR : 6;
        };
#endif
    };

    UCHAR Reserved12[2];

    union
    {
        ULONG SharedDataFlags;
        struct
        {
            ULONG DbgErrorPortPresent : 1;
            ULONG DbgElevationEnabled : 1;
            ULONG DbgVirtEnabled : 1;
            ULONG DbgInstallerDetectEnabled : 1;
            ULONG DbgLkgEnabled : 1;
            ULONG DbgDynProcessorEnabled : 1;
            ULONG DbgConsoleBrokerEnabled : 1;
            ULONG DbgSecureBootEnabled : 1;
            ULONG DbgMultiSessionSku : 1;
            ULONG DbgMultiUsersInSessionSku : 1;
            ULONG DbgStateSeparationEnabled : 1;
            ULONG SpareBits : 21;
        };
    };
    ULONG DataFlagsPad[1];

    ULONGLONG TestRetInstruction;
    LONGLONG QpcFrequency;

    ULONG SystemCall;

    union
    {
        ULONG AllFlags;
        struct
        {
            ULONG Win32Process : 1;
            ULONG Sgx2Enclave : 1;
            ULONG VbsBasicEnclave : 1;
            ULONG SpareBits : 29;
        };
    } UserCetAvailableEnvironments;

    ULONGLONG SystemCallPad[2];

    union
    {
        volatile KSYSTEM_TIME TickCount;
        volatile ULONG64 TickCountQuad;
        struct
        {
            ULONG ReservedTickCountOverlay[3];
            ULONG TickCountPad[1];
        };
    };

    ULONG Cookie;
    ULONG CookiePad[1];

    LONGLONG ConsoleSessionForegroundProcessId;
    ULONGLONG TimeUpdateLock;
    ULONGLONG BaselineSystemTimeQpc;
    ULONGLONG BaselineInterruptTimeQpc;
    ULONGLONG QpcSystemTimeIncrement;
    ULONGLONG QpcInterruptTimeIncrement;
    UCHAR QpcSystemTimeIncrementShift;
    UCHAR QpcInterruptTimeIncrementShift;

    USHORT UnparkedProcessorCount;
    ULONG EnclaveFeatureMask[4];

    ULONG TelemetryCoverageRound;

    USHORT UserModeGlobalLogger[16];
    ULONG ImageFileExecutionOptions;

    ULONG LangGenerationCount;
    ULONGLONG Reserved4;
    volatile ULONG64 InterruptTimeBias;
    volatile ULONG64 QpcBias;

    ULONG ActiveProcessorCount;
    volatile UCHAR ActiveGroupCount;
    UCHAR Reserved9;
    union
    {
        USHORT QpcData;
        struct
        {
            volatile UCHAR QpcBypassEnabled : 1;
            UCHAR QpcShift : 1;
        };
    };

    LARGE_INTEGER TimeZoneBiasEffectiveStart;
    LARGE_INTEGER TimeZoneBiasEffectiveEnd;
    XSTATE_CONFIGURATION XState;
    KSYSTEM_TIME FeatureConfigurationChangeStamp;
    ULONG Spare;
    ULONG64 UserPointerAuthMask;
} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;
#include <poppack.h>

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountMultiplier) == 0x4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTime) == 0x8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemTime) == 0x14);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBias) == 0x20);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtSystemRoot) == 0x30);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ProcessorFeatures) == 0x274);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCount) == 0x320);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountQuad) == 0x320);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveProcessorCount) == 0x3c0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveGroupCount) == 0x3c4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, XState) == 0x3d8);

#define USER_SHARED_DATA ((KUSER_SHARED_DATA * const)0x7ffe0000)

#if (PHNT_VERSION >= PHNT_WS03)

FORCEINLINE
ULONGLONG
NtGetTickCount64(
    VOID
    )
{
    ULARGE_INTEGER tickCount;

#ifdef _WIN64

    tickCount.QuadPart = USER_SHARED_DATA->TickCountQuad;

#else

    while (TRUE)
    {
        tickCount.HighPart = (ULONG)USER_SHARED_DATA->TickCount.High1Time;
        tickCount.LowPart = USER_SHARED_DATA->TickCount.LowPart;

        if (tickCount.HighPart == (ULONG)USER_SHARED_DATA->TickCount.High2Time)
            break;

        YieldProcessor();
    }

#endif

    return (UInt32x32To64(tickCount.LowPart, USER_SHARED_DATA->TickCountMultiplier) >> 24) +
        (UInt32x32To64(tickCount.HighPart, USER_SHARED_DATA->TickCountMultiplier) << 8);
}

FORCEINLINE
ULONG
NtGetTickCount(
    VOID
    )
{
#ifdef _WIN64

    return (ULONG)((USER_SHARED_DATA->TickCountQuad * USER_SHARED_DATA->TickCountMultiplier) >> 24);

#else

    ULARGE_INTEGER tickCount;

    while (TRUE)
    {
        tickCount.HighPart = (ULONG)USER_SHARED_DATA->TickCount.High1Time;
        tickCount.LowPart = USER_SHARED_DATA->TickCount.LowPart;

        if (tickCount.HighPart == (ULONG)USER_SHARED_DATA->TickCount.High2Time)
            break;

        YieldProcessor();
    }

    return (ULONG)((UInt32x32To64(tickCount.LowPart, USER_SHARED_DATA->TickCountMultiplier) >> 24) +
        UInt32x32To64((tickCount.HighPart << 8) & 0xffffffff, USER_SHARED_DATA->TickCountMultiplier));

#endif
}

#else

FORCEINLINE
ULONGLONG
NtGetTickCount64(
    VOID
    )
{
    return GetTickCount(); // pre PHNT_WS03 support (dmex)
}

FORCEINLINE
ULONG
NtGetTickCount(
    VOID
    )
{
    return GetTickCount();
}

#endif

// Locale

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDefaultLocale(
    _In_ BOOLEAN UserProfile,
    _Out_ PLCID DefaultLocaleId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetDefaultLocale(
    _In_ BOOLEAN UserProfile,
    _In_ LCID DefaultLocaleId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInstallUILanguage(
    _Out_ LANGID *InstallUILanguageId
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushInstallUILanguage(
    _In_ LANGID InstallUILanguage,
    _In_ ULONG SetComittedFlag
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDefaultUILanguage(
    _Out_ LANGID *DefaultUILanguageId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetDefaultUILanguage(
    _In_ LANGID DefaultUILanguageId
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSCALLAPI
NTSTATUS
NTAPI
NtIsUILanguageComitted(
    VOID
    );
#endif

// NLS

// begin_private

#if (PHNT_VERSION >= PHNT_VISTA)

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtInitializeNlsFiles(
    _Out_ PVOID *BaseAddress,
    _Out_ PLCID DefaultLocaleId,
    _Out_ PLARGE_INTEGER DefaultCasingTableSize
    );
#else
NTSYSCALLAPI
NTSTATUS
NTAPI
NtInitializeNlsFiles(
    _Out_ PVOID *BaseAddress,
    _Out_ PLCID DefaultLocaleId,
    _Out_ PLARGE_INTEGER DefaultCasingTableSize,
    _Out_opt_ PULONG CurrentNLSVersion
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNlsSectionPtr(
    _In_ ULONG SectionType,
    _In_ ULONG SectionData,
    _In_ PVOID ContextData,
    _Out_ PVOID *SectionPointer,
    _Out_ PULONG SectionSize
    );

#if (PHNT_VERSION < PHNT_WIN7)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAcquireCMFViewOwnership(
    _Out_ PULONGLONG TimeStamp,
    _Out_ PBOOLEAN tokenTaken,
    _In_ BOOLEAN replaceExisting
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseCMFViewOwnership(
    VOID
    );

#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMapCMFModule(
    _In_ ULONG What,
    _In_ ULONG Index,
    _Out_opt_ PULONG CacheIndexOut,
    _Out_opt_ PULONG CacheFlagsOut,
    _Out_opt_ PULONG ViewSizeOut,
    _Out_opt_ PVOID *BaseAddress
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetMUIRegistryInfo(
    _In_ ULONG Flags,
    _Inout_ PULONG DataSize,
    _Out_ PVOID Data
    );

#endif

// end_private

// Global atoms

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAddAtom(
    _In_reads_bytes_opt_(Length) PWSTR AtomName,
    _In_ ULONG Length,
    _Out_opt_ PRTL_ATOM Atom
    );

#if (PHNT_VERSION >= PHNT_WIN8)

#define ATOM_FLAG_GLOBAL 0x2

// rev
NTSYSCALLAPI
NTSTATUS
NTAPI
NtAddAtomEx(
    _In_reads_bytes_opt_(Length) PWSTR AtomName,
    _In_ ULONG Length,
    _Out_opt_ PRTL_ATOM Atom,
    _In_ ULONG Flags
    );

#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFindAtom(
    _In_reads_bytes_opt_(Length) PWSTR AtomName,
    _In_ ULONG Length,
    _Out_opt_ PRTL_ATOM Atom
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteAtom(
    _In_ RTL_ATOM Atom
    );

typedef enum _ATOM_INFORMATION_CLASS
{
    AtomBasicInformation,
    AtomTableInformation
} ATOM_INFORMATION_CLASS;

typedef struct _ATOM_BASIC_INFORMATION
{
    USHORT UsageCount;
    USHORT Flags;
    USHORT NameLength;
    WCHAR Name[1];
} ATOM_BASIC_INFORMATION, *PATOM_BASIC_INFORMATION;

typedef struct _ATOM_TABLE_INFORMATION
{
    ULONG NumberOfAtoms;
    RTL_ATOM Atoms[1];
} ATOM_TABLE_INFORMATION, *PATOM_TABLE_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationAtom(
    _In_ RTL_ATOM Atom,
    _In_ ATOM_INFORMATION_CLASS AtomInformationClass,
    _Out_writes_bytes_(AtomInformationLength) PVOID AtomInformation,
    _In_ ULONG AtomInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

// Global flags

#define FLG_STOP_ON_EXCEPTION 0x00000001 // uk
#define FLG_SHOW_LDR_SNAPS 0x00000002 // uk
#define FLG_DEBUG_INITIAL_COMMAND 0x00000004 // k
#define FLG_STOP_ON_HUNG_GUI 0x00000008 // k

#define FLG_HEAP_ENABLE_TAIL_CHECK 0x00000010 // u
#define FLG_HEAP_ENABLE_FREE_CHECK 0x00000020 // u
#define FLG_HEAP_VALIDATE_PARAMETERS 0x00000040 // u
#define FLG_HEAP_VALIDATE_ALL 0x00000080 // u

#define FLG_APPLICATION_VERIFIER 0x00000100 // u
#define FLG_MONITOR_SILENT_PROCESS_EXIT 0x00000200 // uk
#define FLG_POOL_ENABLE_TAGGING 0x00000400 // k
#define FLG_HEAP_ENABLE_TAGGING 0x00000800 // u

#define FLG_USER_STACK_TRACE_DB 0x00001000 // u,32
#define FLG_KERNEL_STACK_TRACE_DB 0x00002000 // k,32
#define FLG_MAINTAIN_OBJECT_TYPELIST 0x00004000 // k
#define FLG_HEAP_ENABLE_TAG_BY_DLL 0x00008000 // u

#define FLG_DISABLE_STACK_EXTENSION 0x00010000 // u
#define FLG_ENABLE_CSRDEBUG 0x00020000 // k
#define FLG_ENABLE_KDEBUG_SYMBOL_LOAD 0x00040000 // k
#define FLG_DISABLE_PAGE_KERNEL_STACKS 0x00080000 // k

#define FLG_ENABLE_SYSTEM_CRIT_BREAKS 0x00100000 // u
#define FLG_HEAP_DISABLE_COALESCING 0x00200000 // u
#define FLG_ENABLE_CLOSE_EXCEPTIONS 0x00400000 // k
#define FLG_ENABLE_EXCEPTION_LOGGING 0x00800000 // k

#define FLG_ENABLE_HANDLE_TYPE_TAGGING 0x01000000 // k
#define FLG_HEAP_PAGE_ALLOCS 0x02000000 // u
#define FLG_DEBUG_INITIAL_COMMAND_EX 0x04000000 // k
#define FLG_DISABLE_DBGPRINT 0x08000000 // k

#define FLG_CRITSEC_EVENT_CREATION 0x10000000 // u
#define FLG_STOP_ON_UNHANDLED_EXCEPTION 0x20000000 // u,64
#define FLG_ENABLE_HANDLE_EXCEPTIONS 0x40000000 // k
#define FLG_DISABLE_PROTDLLS 0x80000000 // u

#define FLG_VALID_BITS 0xfffffdff

#define FLG_USERMODE_VALID_BITS (FLG_STOP_ON_EXCEPTION | \
    FLG_SHOW_LDR_SNAPS | \
    FLG_HEAP_ENABLE_TAIL_CHECK | \
    FLG_HEAP_ENABLE_FREE_CHECK | \
    FLG_HEAP_VALIDATE_PARAMETERS | \
    FLG_HEAP_VALIDATE_ALL | \
    FLG_APPLICATION_VERIFIER | \
    FLG_HEAP_ENABLE_TAGGING | \
    FLG_USER_STACK_TRACE_DB | \
    FLG_HEAP_ENABLE_TAG_BY_DLL | \
    FLG_DISABLE_STACK_EXTENSION | \
    FLG_ENABLE_SYSTEM_CRIT_BREAKS | \
    FLG_HEAP_DISABLE_COALESCING | \
    FLG_DISABLE_PROTDLLS | \
    FLG_HEAP_PAGE_ALLOCS | \
    FLG_CRITSEC_EVENT_CREATION | \
    FLG_LDR_TOP_DOWN)

#define FLG_BOOTONLY_VALID_BITS (FLG_KERNEL_STACK_TRACE_DB | \
    FLG_MAINTAIN_OBJECT_TYPELIST | \
    FLG_ENABLE_CSRDEBUG | \
    FLG_DEBUG_INITIAL_COMMAND | \
    FLG_DEBUG_INITIAL_COMMAND_EX | \
    FLG_DISABLE_PAGE_KERNEL_STACKS)

#define FLG_KERNELMODE_VALID_BITS (FLG_STOP_ON_EXCEPTION | \
    FLG_SHOW_LDR_SNAPS | \
    FLG_STOP_ON_HUNG_GUI | \
    FLG_POOL_ENABLE_TAGGING | \
    FLG_ENABLE_KDEBUG_SYMBOL_LOAD | \
    FLG_ENABLE_CLOSE_EXCEPTIONS | \
    FLG_ENABLE_EXCEPTION_LOGGING | \
    FLG_ENABLE_HANDLE_TYPE_TAGGING | \
    FLG_DISABLE_DBGPRINT | \
    FLG_ENABLE_HANDLE_EXCEPTIONS)

// Licensing

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryLicenseValue(
    _In_ PUNICODE_STRING ValueName,
    _Out_opt_ PULONG Type,
    _Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,
    _In_ ULONG DataSize,
    _Out_ PULONG ResultDataSize
    );

// Misc.

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetDefaultHardErrorPort(
    _In_ HANDLE DefaultHardErrorPort
    );

typedef enum _SHUTDOWN_ACTION
{
    ShutdownNoReboot,
    ShutdownReboot,
    ShutdownPowerOff,
    ShutdownRebootForRecovery // since WIN11
} SHUTDOWN_ACTION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtShutdownSystem(
    _In_ SHUTDOWN_ACTION Action
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDisplayString(
    _In_ PUNICODE_STRING String
    );

// Boot graphics

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSCALLAPI
NTSTATUS
NTAPI
NtDrawText(
    _In_ PUNICODE_STRING Text
    );
#endif

#endif // (PHNT_MODE != PHNT_MODE_KERNEL)

#endif

/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTBCD_H
#define _NTBCD_H

#ifndef PHNT_INLINE_BCD_GUIDS
// 5189B25C-5558-4BF2-BCA4-289B11BD29E2 // {badmemory}
GUID DECLSPEC_SELECTANY GUID_BAD_MEMORY_GROUP = { 0x5189B25C, 0x5558, 0x4BF2, { 0xBC, 0xA4, 0x28, 0x9B, 0x11, 0xBD, 0x29, 0xE2 } };
// 6EFB52BF-1766-41DB-A6B3-0EE5EFF72BD7 // {bootloadersettings}
GUID DECLSPEC_SELECTANY GUID_BOOT_LOADER_SETTINGS_GROUP = { 0x6EFB52BF, 0x1766, 0x41DB, { 0xA6, 0xB3, 0x0E, 0xE5, 0xEF, 0xF7, 0x2B, 0xD7 } };
// FA926493-6F1C-4193-A414-58F0B2456D1E // {current}
GUID DECLSPEC_SELECTANY GUID_CURRENT_BOOT_ENTRY = { 0xFA926493, 0x6F1C, 0x4193, { 0xA4, 0x14, 0x58, 0xF0, 0xB2, 0x45, 0x6D, 0x1E } };
// 4636856E-540F-4170-A130-A84776F4C654 // {eventsettings} {dbgsettings}
GUID DECLSPEC_SELECTANY GUID_DEBUGGER_SETTINGS_GROUP = { 0x4636856E, 0x540F, 0x4170, { 0xA1, 0x30, 0xA8, 0x47, 0x76, 0xF4, 0xC6, 0x54 } };
// 1CAE1EB7-A0DF-4D4D-9851-4860E34EF535 // {default}
GUID DECLSPEC_SELECTANY GUID_DEFAULT_BOOT_ENTRY = { 0x1CAE1EB7, 0xA0DF, 0x4D4D, { 0x98, 0x51, 0x48, 0x60, 0xE3, 0x4E, 0xF5, 0x35 } };
// 0CE4991B-E6B3-4B16-B23C-5E0D9250E5D9 // {emssettings}
GUID DECLSPEC_SELECTANY GUID_EMS_SETTINGS_GROUP = { 0x0CE4991B, 0xE6B3, 0x4B16, { 0xB2, 0x3C, 0x5E, 0x0D, 0x92, 0x50, 0xE5, 0xD9 } };
// A5A30FA2-3D06-4E9F-B5F4-A01DF9D1FCBA // {fwbootmgr}
GUID DECLSPEC_SELECTANY GUID_FIRMWARE_BOOTMGR = { 0xA5A30FA2, 0x3D06, 0x4E9F, { 0xB5, 0xF4, 0xA0, 0x1D, 0xF9, 0xD1, 0xFC, 0xBA } };
// 7EA2E1AC-2E61-4728-AAA3-896D9D0A9F0E // {globalsettings}
GUID DECLSPEC_SELECTANY GUID_GLOBAL_SETTINGS_GROUP = { 0x7EA2E1AC, 0x2E61, 0x4728, { 0xAA, 0xA3, 0x89, 0x6D, 0x9D, 0x0A, 0x9F, 0x0E } };
// 7FF607E0-4395-11DB-B0DE-0800200C9A66 // {hypervisorsettings}
GUID DECLSPEC_SELECTANY GUID_HYPERVISOR_SETTINGS_GROUP = { 0x7FF607E0, 0x4395, 0x11DB, { 0xB0, 0xDE, 0x08, 0x00, 0x20, 0x0C, 0x9A, 0x66 } };
// 313E8EED-7098-4586-A9BF-309C61F8D449 // {kerneldbgsettings}
GUID DECLSPEC_SELECTANY GUID_KERNEL_DEBUGGER_SETTINGS_GROUP = { 0x313E8EED, 0x7098, 0x4586, { 0xA9, 0xBF, 0x30, 0x9C, 0x61, 0xF8, 0xD4, 0x49 } };
// 1AFA9C49-16AB-4A5C-4A90-212802DA9460 // {resumeloadersettings}
GUID DECLSPEC_SELECTANY GUID_RESUME_LOADER_SETTINGS_GROUP = { 0x1AFA9C49, 0x16AB, 0x4A5C, { 0x4A, 0x90, 0x21, 0x28, 0x02, 0xDA, 0x94, 0x60 } };
// 9DEA862C-5CDD-4E70-ACC1-F32B344D4795 // {bootmgr}
GUID DECLSPEC_SELECTANY GUID_WINDOWS_BOOTMGR = { 0x9DEA862C, 0x5CDD, 0x4E70, { 0xAC, 0xC1, 0xF3, 0x2B, 0x34, 0x4D, 0x47, 0x95 } };
// 466F5A88-0AF2-4F76-9038-095B170DC21C // {ntldr} {legacy}
GUID DECLSPEC_SELECTANY GUID_WINDOWS_LEGACY_NTLDR = { 0x466F5A88, 0x0AF2, 0x4F76, { 0x90, 0x38, 0x09, 0x5B, 0x17, 0x0D, 0xC2, 0x1C } };
// B2721D73-1DB4-4C62-BF78-C548A880142D // {memdiag}
GUID DECLSPEC_SELECTANY GUID_WINDOWS_MEMORY_TESTER = { 0xB2721D73, 0x1DB4, 0x4C62, { 0xBF, 0x78, 0xC5, 0x48, 0xA8, 0x80, 0x14, 0x2D } };
// B012B84D-C47C-4ED5-B722-C0C42163E569
GUID DECLSPEC_SELECTANY GUID_WINDOWS_OS_TARGET_TEMPLATE_EFI = { 0xB012B84D, 0xC47C, 0x4ED5, { 0xB7, 0x22, 0xC0, 0xC4, 0x21, 0x63, 0xE5, 0x69 } };
// A1943BBC-EA85-487C-97C7-C9EDE908A38A
GUID DECLSPEC_SELECTANY GUID_WINDOWS_OS_TARGET_TEMPLATE_PCAT = { 0xA1943BBC, 0xEA85, 0x487C, { 0x97, 0xC7, 0xC9, 0xED, 0xE9, 0x08, 0xA3, 0x8A } };
// {0C334284-9A41-4DE1-99B3-A7E87E8FF07E}
GUID DECLSPEC_SELECTANY GUID_WINDOWS_RESUME_TARGET_TEMPLATE_EFI = { 0x0C334284, 0x9A41, 0x4DE1, { 0x99, 0xB3, 0xA7, 0xE8, 0x7E, 0x8F, 0xF0, 0x7E } };
// {98B02A23-0674-4CE7-BDAD-E0A15A8FF97B}
GUID DECLSPEC_SELECTANY GUID_WINDOWS_RESUME_TARGET_TEMPLATE_PCAT = { 0x98B02A23, 0x0674, 0x4CE7, { 0xBD, 0xAD, 0xE0, 0xA1, 0x5A, 0x8F, 0xF9, 0x7B } };
// A1943BBC-EA85-487C-97C7-C9EDE908A38A
GUID DECLSPEC_SELECTANY GUID_WINDOWS_SETUP_EFI = { 0x7254A080, 0x1510, 0x4E85, { 0xAC, 0x0F, 0xE7, 0xFB, 0x3D, 0x44, 0x47, 0x36 } };
// CBD971BF-B7B8-4885-951A-FA03044F5D71
GUID DECLSPEC_SELECTANY GUID_WINDOWS_SETUP_PCAT = { 0xCBD971BF, 0xB7B8, 0x4885, { 0x95, 0x1A, 0xFA, 0x03, 0x04, 0x4F, 0x5D, 0x71 } };
// AE5534E0-A924-466C-B836-758539A3EE3A // {ramdiskoptions}
GUID DECLSPEC_SELECTANY GUID_WINDOWS_SETUP_RAMDISK_OPTIONS = { 0xAE5534E0, 0xA924, 0x466C, { 0xB8, 0x36, 0x75, 0x85, 0x39, 0xA3, 0xEE, 0x3A } };
#else
NTSYSAPI GUID GUID_BAD_MEMORY_GROUP; // {badmemory}
NTSYSAPI GUID GUID_BOOT_LOADER_SETTINGS_GROUP; // {bootloadersettings}
NTSYSAPI GUID GUID_CURRENT_BOOT_ENTRY; // {current}
NTSYSAPI GUID GUID_DEBUGGER_SETTINGS_GROUP; // {eventsettings} {dbgsettings}
NTSYSAPI GUID GUID_DEFAULT_BOOT_ENTRY; // {default}
NTSYSAPI GUID GUID_EMS_SETTINGS_GROUP; // {emssettings}
NTSYSAPI GUID GUID_FIRMWARE_BOOTMGR; // {fwbootmgr}
NTSYSAPI GUID GUID_GLOBAL_SETTINGS_GROUP; // {globalsettings}
NTSYSAPI GUID GUID_HYPERVISOR_SETTINGS_GROUP; // {hypervisorsettings}
NTSYSAPI GUID GUID_KERNEL_DEBUGGER_SETTINGS_GROUP; // {kerneldbgsettings}
NTSYSAPI GUID GUID_RESUME_LOADER_SETTINGS_GROUP; // {resumeloadersettings}
NTSYSAPI GUID GUID_WINDOWS_BOOTMGR; // {bootmgr}
NTSYSAPI GUID GUID_WINDOWS_LEGACY_NTLDR; // {ntldr} {legacy}
NTSYSAPI GUID GUID_WINDOWS_MEMORY_TESTER; // {memdiag}
NTSYSAPI GUID GUID_WINDOWS_OS_TARGET_TEMPLATE_EFI;
NTSYSAPI GUID GUID_WINDOWS_OS_TARGET_TEMPLATE_PCAT;
NTSYSAPI GUID GUID_WINDOWS_RESUME_TARGET_TEMPLATE_EFI;
NTSYSAPI GUID GUID_WINDOWS_RESUME_TARGET_TEMPLATE_PCAT;
NTSYSAPI GUID GUID_WINDOWS_SETUP_EFI;
NTSYSAPI GUID GUID_WINDOWS_SETUP_PCAT;
NTSYSAPI GUID GUID_WINDOWS_SETUP_RAMDISK_OPTIONS; // {ramdiskoptions}
#endif

typedef enum _BCD_MESSAGE_TYPE
{
    BCD_MESSAGE_TYPE_NONE,
    BCD_MESSAGE_TYPE_TRACE,
    BCD_MESSAGE_TYPE_INFORMATION,
    BCD_MESSAGE_TYPE_WARNING,
    BCD_MESSAGE_TYPE_ERROR,
    BCD_MESSAGE_TYPE_MAXIMUM
} BCD_MESSAGE_TYPE;

typedef VOID (NTAPI* BCD_MESSAGE_CALLBACK)(
    _In_ BCD_MESSAGE_TYPE type,
    _In_ PWSTR Message
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdSetLogging(
    _In_ BCD_MESSAGE_TYPE BcdLoggingLevel,
    _In_ BCD_MESSAGE_CALLBACK BcdMessageCallbackRoutine
    );

NTSYSAPI
VOID
NTAPI
BcdInitializeBcdSyncMutant(
    VOID
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdGetSystemStorePath(
    _Out_ PWSTR* BcdSystemStorePath // RtlFreeHeap(RtlProcessHeap(), 0, BcdSystemStorePath);
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdSetSystemStoreDevice(
    _In_ UNICODE_STRING SystemPartition
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdOpenSystemStore(
    _Out_ PHANDLE BcdStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdOpenStoreFromFile(
    _In_ UNICODE_STRING BcdFilePath,
    _Out_ PHANDLE BcdStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdCreateStore(
    _In_ UNICODE_STRING BcdFilePath,
    _Out_ PHANDLE BcdStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdExportStore(
    _In_ UNICODE_STRING BcdFilePath
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdExportStoreEx(
    _In_ HANDLE BcdStoreHandle,
    _In_ ULONG Flags,
    _In_ UNICODE_STRING BcdFilePath
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdImportStore(
    _In_ UNICODE_STRING BcdFilePath
    );

typedef enum _BCD_IMPORT_FLAGS
{
    BCD_IMPORT_NONE,
    BCD_IMPORT_DELETE_FIRMWARE_OBJECTS
} BCD_IMPORT_FLAGS;

NTSYSAPI
NTSTATUS
NTAPI
BcdImportStoreWithFlags(
    _In_ UNICODE_STRING BcdFilePath,
    _In_ BCD_IMPORT_FLAGS BcdImportFlags
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdDeleteObjectReferences(
    _In_ HANDLE BcdStoreHandle,
    _In_ PGUID Identifier
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdDeleteSystemStore(
    VOID
    );

typedef enum _BCD_OPEN_FLAGS
{
    BCD_OPEN_NONE,
    BCD_OPEN_OPEN_STORE_OFFLINE,
    BCD_OPEN_SYNC_FIRMWARE_ENTRIES
} BCD_OPEN_FLAGS;

NTSYSAPI
NTSTATUS
NTAPI
BcdOpenStore(
    _In_ UNICODE_STRING BcdFilePath,
    _In_ BCD_OPEN_FLAGS BcdOpenFlags,
    _Out_ PHANDLE BcdStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdCloseStore(
    _In_ HANDLE BcdStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdFlushStore(
    _In_ HANDLE BcdStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdForciblyUnloadStore(
    _In_ HANDLE BcdStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdMarkAsSystemStore(
    _In_ HANDLE BcdStoreHandle
    );

typedef enum _BCD_OBJECT_TYPE
{
    BCD_OBJECT_TYPE_NONE,
    BCD_OBJECT_TYPE_APPLICATION,
    BCD_OBJECT_TYPE_INHERITED,
    BCD_OBJECT_TYPE_DEVICE
} BCD_OBJECT_TYPE;

typedef enum _BCD_APPLICATION_OBJECT_TYPE
{
    BCD_APPLICATION_OBJECT_NONE = 0,
    BCD_APPLICATION_OBJECT_FIRMWARE_BOOT_MANAGER = 1,
    BCD_APPLICATION_OBJECT_WINDOWS_BOOT_MANAGER = 2,
    BCD_APPLICATION_OBJECT_WINDOWS_BOOT_LOADER = 3,
    BCD_APPLICATION_OBJECT_WINDOWS_RESUME_APPLICATION = 4,
    BCD_APPLICATION_OBJECT_MEMORY_TESTER = 5,
    BCD_APPLICATION_OBJECT_LEGACY_NTLDR = 6,
    BCD_APPLICATION_OBJECT_LEGACY_SETUPLDR = 7,
    BCD_APPLICATION_OBJECT_BOOT_SECTOR = 8,
    BCD_APPLICATION_OBJECT_STARTUP_MODULE = 9,
    BCD_APPLICATION_OBJECT_GENERIC_APPLICATION = 10,
    BCD_APPLICATION_OBJECT_RESERVED = 0xFFFFF
} BCD_APPLICATION_OBJECT_TYPE;

typedef enum _BCD_APPLICATION_IMAGE_TYPE
{
    BCD_APPLICATION_IMAGE_NONE,
    BCD_APPLICATION_IMAGE_FIRMWARE_APPLICATION,
    BCD_APPLICATION_IMAGE_BOOT_APPLICATION,
    BCD_APPLICATION_IMAGE_LEGACY_LOADER,
    BCD_APPLICATION_IMAGE_REALMODE_CODE
} BCD_APPLICATION_IMAGE_TYPE;

typedef enum _BCD_INHERITED_CLASS_TYPE
{
    BCD_INHERITED_CLASS_NONE,
    BCD_INHERITED_CLASS_LIBRARY,
    BCD_INHERITED_CLASS_APPLICATION,
    BCD_INHERITED_CLASS_DEVICE
} BCD_INHERITED_CLASS_TYPE;

#define MAKE_BCD_OBJECT(ObjectType, ImageType, ApplicationType) \
    (((ULONG)(ObjectType) << 28) | \
    (((ULONG)(ImageType) & 0xF) << 20) | \
    ((ULONG)(ApplicationType) & 0xFFFFF))

#define MAKE_BCD_APPLICATION_OBJECT(ImageType, ApplicationType) \
    MAKE_BCD_OBJECT(BCD_OBJECT_TYPE_APPLICATION, (ULONG)(ImageType), (ULONG)(ApplicationType))

#define GET_BCD_OBJECT_TYPE(DataType) \
    ((BCD_OBJECT_TYPE)(((((ULONG)DataType)) >> 28) & 0xF))
#define GET_BCD_APPLICATION_IMAGE(DataType) \
    ((BCD_APPLICATION_IMAGE_TYPE)(((((ULONG)DataType)) >> 20) & 0xF))
#define GET_BCD_APPLICATION_OBJECT(DataType) \
    ((BCD_APPLICATION_OBJECT_TYPE)((((ULONG)DataType)) & 0xFFFFF))

#define BCD_OBJECT_OSLOADER_TYPE \
    MAKE_BCD_APPLICATION_OBJECT(BCD_APPLICATION_IMAGE_BOOT_APPLICATION, BCD_APPLICATION_OBJECT_WINDOWS_BOOT_LOADER)

typedef union _BCD_OBJECT_DATATYPE
{
    ULONG PackedValue;
    union
    {
        struct
        {
            ULONG Reserved : 28;
            BCD_OBJECT_TYPE ObjectType : 4;
        };
        struct
        {
            BCD_APPLICATION_OBJECT_TYPE ApplicationType : 20;
            BCD_APPLICATION_IMAGE_TYPE ImageType : 4;
            ULONG Reserved : 4;
            BCD_OBJECT_TYPE ObjectType : 4;
        } Application;
        struct
        {
            ULONG Value : 20;
            BCD_INHERITED_CLASS_TYPE Class : 4;
            ULONG Reserved : 4;
            BCD_OBJECT_TYPE ObjectType : 4;
        } Inherit;
        struct
        {
            ULONG Reserved : 28;
            BCD_OBJECT_TYPE ObjectType : 4;
        } Device;
    };
} BCD_OBJECT_DATATYPE, *PBCD_OBJECT_DATATYPE;

#define BCD_OBJECT_DESCRIPTION_VERSION 0x1

typedef struct _BCD_OBJECT_DESCRIPTION
{
    ULONG Version; // BCD_OBJECT_DESCRIPTION_VERSION
    ULONG Type; // BCD_OBJECT_DATATYPE
} BCD_OBJECT_DESCRIPTION, *PBCD_OBJECT_DESCRIPTION;

typedef struct _BCD_OBJECT
{
    GUID Identifer;
    PBCD_OBJECT_DESCRIPTION Description;
} BCD_OBJECT, *PBCD_OBJECT;

NTSYSAPI
NTSTATUS
NTAPI
BcdEnumerateObjects(
    _In_ HANDLE BcdStoreHandle,
    _In_ PBCD_OBJECT_DESCRIPTION BcdEnumDescriptor,
    _Out_writes_bytes_opt_(*BufferSize) PVOID Buffer, // BCD_OBJECT[]
    _Inout_ PULONG BufferSize,
    _Out_ PULONG ObjectCount
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdOpenObject(
    _In_ HANDLE BcdStoreHandle,
    _In_ PGUID Identifier,
    _Out_ PHANDLE BcdObjectHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdCreateObject(
    _In_ HANDLE BcdStoreHandle,
    _In_ PGUID Identifier,
    _In_ PBCD_OBJECT_DESCRIPTION Description,
    _Out_ PHANDLE BcdObjectHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdDeleteObject(
    _In_ HANDLE BcdObjectHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdCloseObject(
    _In_ HANDLE BcdObjectHandle
    );

typedef enum _BCD_COPY_FLAGS
{
    BCD_COPY_NONE = 0x0,
    BCD_COPY_COPY_CREATE_NEW_OBJECT_IDENTIFIER = 0x1,
    BCD_COPY_COPY_DELETE_EXISTING_OBJECT = 0x2,
    BCD_COPY_COPY_UNKNOWN_FIRMWARE_APPLICATION = 0x4,
    BCD_COPY_IGNORE_SETUP_TEMPLATE_ELEMENTS = 0x8,
    BCD_COPY_RETAIN_ELEMENT_DATA = 0x10,
    BCD_COPY_MIGRATE_ELEMENT_DATA = 0x20
} BCD_COPY_FLAGS;

NTSYSAPI
NTSTATUS
NTAPI
BcdCopyObject(
    _In_ HANDLE BcdStoreHandle,
    _In_ HANDLE BcdObjectHandle,
    _In_ BCD_COPY_FLAGS BcdCopyFlags,
    _In_ HANDLE TargetStoreHandle,
    _Out_ PHANDLE TargetHandleOut
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdCopyObjectEx(
    _In_ HANDLE BcdStoreHandle,
    _In_ HANDLE BcdObjectHandle,
    _In_ BCD_COPY_FLAGS BcdCopyFlags,
    _In_ HANDLE TargetStoreHandle,
    _In_ PGUID TargetObjectId,
    _Out_ PHANDLE TargetHandleOut
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdCopyObjects(
    _In_ HANDLE BcdStoreHandle,
    _In_ BCD_OBJECT_DESCRIPTION Characteristics,
    _In_ BCD_COPY_FLAGS BcdCopyFlags,
    _In_ HANDLE TargetStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdMigrateObjectElementValues(
    _In_ HANDLE TemplateObjectHandle,
    _In_ HANDLE SourceObjectHandle,
    _In_ HANDLE TargetObjectHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdQueryObject(
    _In_ HANDLE BcdObjectHandle,
    _In_ ULONG BcdVersion, // BCD_OBJECT_DESCRIPTION_VERSION
    _Out_ BCD_OBJECT_DESCRIPTION Description,
    _Out_ PGUID Identifier
    );

typedef enum _BCD_ELEMENT_DATATYPE_FORMAT
{
    BCD_ELEMENT_DATATYPE_FORMAT_UNKNOWN,
    BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, // 0x01000000
    BCD_ELEMENT_DATATYPE_FORMAT_STRING, // 0x02000000
    BCD_ELEMENT_DATATYPE_FORMAT_OBJECT, // 0x03000000
    BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST, // 0x04000000
    BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, // 0x05000000
    BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, // 0x06000000
    BCD_ELEMENT_DATATYPE_FORMAT_INTEGERLIST, // 0x07000000
    BCD_ELEMENT_DATATYPE_FORMAT_BINARY // 0x08000000
} BCD_ELEMENT_DATATYPE_FORMAT;

typedef enum _BCD_ELEMENT_DATATYPE_CLASS
{
    BCD_ELEMENT_DATATYPE_CLASS_NONE,
    BCD_ELEMENT_DATATYPE_CLASS_LIBRARY,
    BCD_ELEMENT_DATATYPE_CLASS_APPLICATION,
    BCD_ELEMENT_DATATYPE_CLASS_DEVICE,
    BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE,
    BCD_ELEMENT_DATATYPE_CLASS_OEM
} BCD_ELEMENT_DATATYPE_CLASS;

typedef enum _BCD_ELEMENT_DEVICE_TYPE
{
    BCD_ELEMENT_DEVICE_TYPE_NONE,
    BCD_ELEMENT_DEVICE_TYPE_BOOT_DEVICE,
    BCD_ELEMENT_DEVICE_TYPE_PARTITION,
    BCD_ELEMENT_DEVICE_TYPE_FILE,
    BCD_ELEMENT_DEVICE_TYPE_RAMDISK,
    BCD_ELEMENT_DEVICE_TYPE_UNKNOWN,
    BCD_ELEMENT_DEVICE_TYPE_QUALIFIED_PARTITION,
    BCD_ELEMENT_DEVICE_TYPE_VMBUS,
    BCD_ELEMENT_DEVICE_TYPE_LOCATE_DEVICE,
    BCD_ELEMENT_DEVICE_TYPE_URI,
    BCD_ELEMENT_DEVICE_TYPE_COMPOSITE
} BCD_ELEMENT_DEVICE_TYPE;

#define MAKE_BCDE_DATA_TYPE(Class, Format, Subtype) \
    (((((ULONG)Class) & 0xF) << 28) | ((((ULONG)Format) & 0xF) << 24) | (((ULONG)Subtype) & 0x00FFFFFF))

#define GET_BCDE_DATA_CLASS(DataType) \
    ((BCD_ELEMENT_DATATYPE_CLASS)(((((ULONG)DataType)) >> 28) & 0xF))
#define GET_BCDE_DATA_FORMAT(DataType) \
    ((BCD_ELEMENT_DATATYPE_FORMAT)(((((ULONG)DataType)) >> 24) & 0xF))
#define GET_BCDE_DATA_SUBTYPE(DataType) \
    ((ULONG)((((ULONG)DataType)) & 0x00FFFFFF))

typedef union _BCD_ELEMENT_DATATYPE
{
    ULONG PackedValue;
    struct
    {
        ULONG SubType : 24;
        BCD_ELEMENT_DATATYPE_FORMAT Format : 4;
        BCD_ELEMENT_DATATYPE_CLASS Class : 4;
    };
} BCD_ELEMENT_DATATYPE, *PBCD_ELEMENT_DATATYPE;

NTSYSAPI
NTSTATUS
NTAPI
BcdEnumerateElementTypes(
    _In_ HANDLE BcdObjectHandle,
    _Out_writes_bytes_opt_(*BufferSize) PVOID Buffer, // BCD_ELEMENT_DATATYPE[]
    _Inout_ PULONG BufferSize,
    _Out_ PULONG ElementCount
    );

typedef struct _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION
{
    ULONG PartitionStyle;
    ULONG Reserved;
    struct
    {
        union
        {
            ULONG DiskSignature;
            ULONG64 PartitionOffset;
        } Mbr;
        union
        {
            GUID DiskSignature;
            GUID PartitionSignature;
        } Gpt;
    };
} BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION, *PBCD_ELEMENT_DEVICE_QUALIFIED_PARTITION;

typedef struct _BCD_ELEMENT_DEVICE
{
    ULONG DeviceType;
    GUID AdditionalOptions;
    struct
    {
        union
        {
            ULONG ParentOffset;
            WCHAR Path[ANYSIZE_ARRAY];
        } File;
        union
        {
            WCHAR Path[ANYSIZE_ARRAY];
        } Partition;
        union
        {
            ULONG Type;
            ULONG ParentOffset;
            ULONG ElementType;
            WCHAR Path[ANYSIZE_ARRAY];
        } Locate;
        union
        {
            GUID InterfaceInstance;
        } Vmbus;
        union
        {
            ULONG Data[ANYSIZE_ARRAY];
        } Unknown;
        BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION QualifiedPartition;
    };
} BCD_ELEMENT_DEVICE, *PBCD_ELEMENT_DEVICE;

typedef struct _BCD_ELEMENT_STRING
{
    WCHAR Value[ANYSIZE_ARRAY];
} BCD_ELEMENT_STRING, *PBCD_ELEMENT_STRING;

typedef struct _BCD_ELEMENT_OBJECT
{
    GUID Object;
} BCD_ELEMENT_OBJECT, *PBCD_ELEMENT_OBJECT;

typedef struct _BCD_ELEMENT_OBJECT_LIST
{
    GUID ObjectList[ANYSIZE_ARRAY];
} BCD_ELEMENT_OBJECT_LIST, *PBCD_ELEMENT_OBJECT_LIST;

typedef struct _BCD_ELEMENT_INTEGER
{
    ULONG64 Value;
} BCD_ELEMENT_INTEGER, *PBCD_ELEMENT_INTEGER;

typedef struct _BCD_ELEMENT_INTEGER_LIST
{
    ULONG64 Value[ANYSIZE_ARRAY];
} BCD_ELEMENT_INTEGER_LIST, *PBCD_ELEMENT_INTEGER_LIST;

typedef struct _BCD_ELEMENT_BOOLEAN
{
    BOOLEAN Value;
    //BOOLEAN Pad; // sym
} BCD_ELEMENT_BOOLEAN, *PBCD_ELEMENT_BOOLEAN;

#define BCD_ELEMENT_DESCRIPTION_VERSION 0x1

typedef struct BCD_ELEMENT_DESCRIPTION
{
    ULONG Version; // BCD_ELEMENT_DESCRIPTION_VERSION
    ULONG Type;
    ULONG DataSize;
} BCD_ELEMENT_DESCRIPTION, *PBCD_ELEMENT_DESCRIPTION;

typedef struct _BCD_ELEMENT
{
    PBCD_ELEMENT_DESCRIPTION Description;
    PVOID Data;
} BCD_ELEMENT, *PBCD_ELEMENT;

NTSYSAPI
NTSTATUS
NTAPI
BcdEnumerateElements(
    _In_ HANDLE BcdObjectHandle,
    _Out_writes_bytes_opt_(*BufferSize) PVOID Buffer, // BCD_ELEMENT[]
    _Inout_ PULONG BufferSize,
    _Out_ PULONG ElementCount
    );

typedef enum _BCD_FLAGS
{
    BCD_FLAG_NONE = 0x0,
    BCD_FLAG_QUALIFIED_PARTITION = 0x1,
    BCD_FLAG_NO_DEVICE_TRANSLATION = 0x2,
    BCD_FLAG_ENUMERATE_INHERITED_OBJECTS = 0x4,
    BCD_FLAG_ENUMERATE_DEVICE_OPTIONS = 0x8,
    BCD_FLAG_OBSERVE_PRECEDENCE = 0x10,
    BCD_FLAG_DISABLE_VHD_NT_TRANSLATION = 0x20,
    BCD_FLAG_DISABLE_VHD_DEVICE_DETECTION = 0x40,
    BCD_FLAG_DISABLE_POLICY_CHECKS = 0x80
} BCD_FLAGS;

NTSYSAPI
NTSTATUS
NTAPI
BcdEnumerateElementsWithFlags(
    _In_ HANDLE BcdObjectHandle,
    _In_ BCD_FLAGS BcdFlags,
    _Out_writes_bytes_opt_(*BufferSize) PVOID Buffer, // BCD_ELEMENT[]
    _Inout_ PULONG BufferSize,
    _Out_ PULONG ElementCount
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdEnumerateAndUnpackElements(
    _In_ HANDLE BcdStoreHandle,
    _In_ HANDLE BcdObjectHandle,
    _In_ BCD_FLAGS BcdFlags,
    _Out_writes_bytes_opt_(*BufferSize) PVOID Buffer, // BCD_ELEMENT[]
    _Inout_ PULONG BufferSize,
    _Out_ PULONG ElementCount
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdGetElementData(
    _In_ HANDLE BcdObjectHandle,
    _In_ ULONG BcdElement, // BCD_ELEMENT_DATATYPE
    _Out_writes_bytes_opt_(*BufferSize) PVOID Buffer,
    _Inout_ PULONG BufferSize
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdGetElementDataWithFlags(
    _In_ HANDLE BcdObjectHandle,
    _In_ ULONG BcdElement, // BCD_ELEMENT_DATATYPE
    _In_ BCD_FLAGS BcdFlags,
    _Out_writes_bytes_opt_(*BufferSize) PVOID Buffer,
    _Inout_ PULONG BufferSize
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdSetElementData(
    _In_ HANDLE BcdObjectHandle,
    _In_ ULONG BcdElement, // BCD_ELEMENT_DATATYPE
    _In_reads_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdSetElementDataWithFlags(
    _In_ HANDLE BcdObjectHandle,
    _In_ ULONG BcdElement, // BCD_ELEMENT_DATATYPE
    _In_ BCD_FLAGS BcdFlags,
    _In_reads_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdDeleteElement(
    _In_ HANDLE BcdObjectHandle,
    _In_ ULONG BcdElement // BCD_ELEMENT_DATATYPE
    );

// Element types

typedef enum _BcdBootMgrElementTypes
{
    /// <summary>
    /// The order in which BCD objects should be displayed.
    /// Objects are displayed using the string specified by the BcdLibraryString_Description element.
    /// </summary>
    /// <remarks>0x24000001</remarks>
    BcdBootMgrObjectList_DisplayOrder = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST, 1),
    /// <summary>
    /// List of boot environment applications the boot manager should execute.
    /// The applications are executed in the order they appear in this list.
    /// If the firmware boot manager does not support loading multiple applications, this list cannot contain more than one entry.
    /// </summary>
    /// <remarks>0x24000002</remarks>
    BcdBootMgrObjectList_BootSequence = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST, 2),
    /// <summary>
    /// The default boot environment application to load if the user does not select one.
    /// </summary>
    /// <remarks>0x23000003</remarks>
    BcdBootMgrObject_DefaultObject = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_OBJECT, 3),
    /// <summary>
    /// The maximum number of seconds a boot selection menu is to be displayed to the user.
    /// The menu is displayed until the user selects an option or the time-out expires.
    /// If this value is not specified, the boot manager waits for the user to make a selection.
    /// </summary>
    /// <remarks>0x25000004</remarks>
    BcdBootMgrInteger_Timeout = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 4),
    /// <summary>
    /// Indicates that a resume operation should be attempted during a system restart.
    /// </summary>
    /// <remarks>0x26000005</remarks>
    BcdBootMgrBoolean_AttemptResume = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 5),
    /// <summary>
    /// The resume application object.
    /// </summary>
    /// <remarks>0x23000006</remarks>
    BcdBootMgrObject_ResumeObject = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_OBJECT, 6),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x24000007</remarks>
    BcdBootMgrObjectList_StartupSequence = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST, 7),
    /// <summary>
    /// The boot manager tools display order list.
    /// </summary>
    /// <remarks>0x24000010</remarks>
    BcdBootMgrObjectList_ToolsDisplayOrder = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST, 16),
    /// <summary>
    /// Forces the display of the legacy boot menu, regardless of the number of OS entries in the BCD store and their BcdOSLoaderInteger_BootMenuPolicy.
    /// </summary>
    /// <remarks>0x26000020</remarks>
    BcdBootMgrBoolean_DisplayBootMenu = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 32),
    /// <summary>
    /// Indicates whether the display of errors should be suppressed.
    /// If this setting is enabled, the boot manager exits to the multi-OS menu on OS launch error.
    /// </summary>
    /// <remarks>0x26000021</remarks>
    BcdBootMgrBoolean_NoErrorDisplay = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 33),
    /// <summary>
    /// The device on which the boot application resides.
    /// </summary>
    /// <remarks>0x21000022</remarks>
    BcdBootMgrDevice_BcdDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 34),
    /// <summary>
    /// The boot application.
    /// </summary>
    /// <remarks>0x22000023</remarks>
    BcdBootMgrString_BcdFilePath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 35),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000024</remarks>
    BcdBootMgrBoolean_HormEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 36),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000025</remarks>
    BcdBootMgrBoolean_HiberRoot = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 37),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000026</remarks>
    BcdBootMgrString_PasswordOverride = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 38),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000027</remarks>
    BcdBootMgrString_PinpassPhraseOverride = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 39),
    /// <summary>
    /// Controls whether custom actions are processed before a boot sequence.
    /// Note This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x26000028</remarks>
    BcdBootMgrBoolean_ProcessCustomActionsFirst = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 40),
    /// <summary>
    /// Custom Bootstrap Actions.
    /// </summary>
    /// <remarks>0x27000030</remarks>
    BcdBootMgrIntegerList_CustomActionsList = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGERLIST, 48),
    /// <summary>
    /// Controls whether a boot sequence persists across multiple boots.
    /// Note This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x26000031</remarks>
    BcdBootMgrBoolean_PersistBootSequence = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 49),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000032</remarks>
    BcdBootMgrBoolean_SkipStartupSequence = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 50),
} BcdBootMgrElementTypes;

typedef enum _BcdLibrary_FirstMegabytePolicy
{
    /// <summary>
    /// Use none of the first megabyte of memory.
    /// </summary>
    FirstMegabytePolicyUseNone,
    /// <summary>
    /// Use all of the first megabyte of memory.
    /// </summary>
    FirstMegabytePolicyUseAll,
    /// <summary>
    /// Reserved for future use.
    /// </summary>
    FirstMegabytePolicyUsePrivate
} BcdLibrary_FirstMegabytePolicy;

typedef enum _BcdLibrary_DebuggerType
{
    DebuggerSerial = 0,
    Debugger1394 = 1,
    DebuggerUsb = 2,
    DebuggerNet = 3,
    DebuggerLocal = 4
} BcdLibrary_DebuggerType;

typedef enum _BcdLibrary_DebuggerStartPolicy
{
    /// <summary>
    /// The debugger will start active.
    /// </summary>
    DebuggerStartActive,
    /// <summary>
    /// The debugger will start in the auto-enabled state.
    /// If a debugger is attached it will be used; otherwise the debugger port will be available for other applications.
    /// </summary>
    DebuggerStartAutoEnable,
    /// <summary>
    /// The debugger will not start.
    /// </summary>
    DebuggerStartDisable
} BcdLibrary_DebuggerStartPolicy;

typedef enum _BcdLibrary_ConfigAccessPolicy
{
    /// <summary>
    /// Access to PCI configuration space through the memory-mapped region is allowed.
    /// </summary>
    ConfigAccessPolicyDefault,
    /// <summary>
    /// Access to PCI configuration space through the memory-mapped region is not allowed.
    /// This setting is used for platforms that implement memory-mapped configuration space incorrectly.
    /// The CFC/CF8 access mechanism can be used to access configuration space on these platforms.
    /// </summary>
    ConfigAccessPolicyDisallowMmConfig
} BcdLibrary_ConfigAccessPolicy;

typedef enum _BcdLibrary_UxDisplayMessageType
{
    DisplayMessageTypeDefault = 0,
    DisplayMessageTypeResume = 1,
    DisplayMessageTypeHyperV = 2,
    DisplayMessageTypeRecovery = 3,
    DisplayMessageTypeStartupRepair = 4,
    DisplayMessageTypeSystemImageRecovery = 5,
    DisplayMessageTypeCommandPrompt = 6,
    DisplayMessageTypeSystemRestore = 7,
    DisplayMessageTypePushButtonReset = 8,
} BcdLibrary_UxDisplayMessageType;

typedef enum BcdLibrary_SafeBoot
{
    /// <summary>
    /// Load the drivers and services specified by name or group under the following registry key:
    /// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SafeBoot\Minimal.
    /// </summary>
    SafemodeMinimal = 0,
    /// <summary>
    /// Load the drivers and services specified by name or group under the following registry key:
    /// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SafeBoot\Network
    /// </summary>
    SafemodeNetwork = 1,
    /// <summary>
    /// Boot the system into a repair mode that restores the Active Directory service from backup medium.
    /// </summary>
    SafemodeDsRepair = 2
} BcdLibrary_SafeBoot;

// BcdLibraryElementTypes based on geoffchappell: https://www.geoffchappell.com/notes/windows/boot/bcd/elements.htm (dmex)
typedef enum _BcdLibraryElementTypes
{
    /// <summary>
    /// Device on which a boot environment application resides.
    /// </summary>
    /// <remarks>0x11000001</remarks>
    BcdLibraryDevice_ApplicationDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 1),
    /// <summary>
    /// Path to a boot environment application.
    /// </summary>
    /// <remarks>0x12000002</remarks>
    BcdLibraryString_ApplicationPath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 2),
    /// <summary>
    /// Display name of the boot environment application.
    /// </summary>
    /// <remarks>0x12000004</remarks>
    BcdLibraryString_Description = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 4),
    /// <summary>
    /// Preferred locale, in RFC 3066 format.
    /// </summary>
    /// <remarks>0x12000005</remarks>
    BcdLibraryString_PreferredLocale = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 5),
    /// <summary>
    /// List of BCD objects from which the current object should inherit elements.
    /// </summary>
    /// <remarks>0x14000006</remarks>
    BcdLibraryObjectList_InheritedObjects = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST, 6),
    /// <summary>
    /// Maximum physical address a boot environment application should recognize. All memory above this address is ignored.
    /// </summary>
    /// <remarks>0x15000007</remarks>
    BcdLibraryInteger_TruncatePhysicalMemory = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 7),
    /// <summary>
    /// List of boot environment applications to be executed if the associated application fails. The applications are executed in the order they appear in this list.
    /// </summary>
    /// <remarks>0x14000008</remarks>
    BcdLibraryObjectList_RecoverySequence = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST, 8),
    /// <summary>
    /// Indicates whether the recovery sequence executes automatically if the boot application fails. Otherwise, the recovery sequence only runs on demand.
    /// </summary>
    /// <remarks>0x16000009</remarks>
    BcdLibraryBoolean_AutoRecoveryEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 9),
    /// <summary>
    /// List of page frame numbers describing faulty memory in the system.
    /// </summary>
    /// <remarks>0x1700000A</remarks>
    BcdLibraryIntegerList_BadMemoryList = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGERLIST, 10),
    /// <summary>
    /// If TRUE, indicates that a boot application can use memory listed in the BcdLibraryIntegerList_BadMemoryList.
    /// </summary>
    /// <remarks>0x1600000B</remarks>
    BcdLibraryBoolean_AllowBadMemoryAccess = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 11),
    /// <summary>
    /// Indicates how the first megabyte of memory is to be used. The Integer property is one of the values from the BcdLibrary_FirstMegabytePolicy enumeration.
    /// </summary>
    /// <remarks>0x1500000C</remarks>
    BcdLibraryInteger_FirstMegabytePolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 12),
    /// <summary>
    /// Relocates physical memory on certain AMD processors.
    /// This value is not used in Windows 8 or Windows Server 2012.
    /// </summary>
    /// <remarks>0x1500000D</remarks>
    BcdLibraryInteger_RelocatePhysicalMemory = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 13),
    /// <summary>
    /// Specifies a minimum physical address to use in the boot environment.
    /// </summary>
    /// <remarks>0x1500000E</remarks>
    BcdLibraryInteger_AvoidLowPhysicalMemory = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 14),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x1600000F</remarks>
    BcdLibraryBoolean_TraditionalKsegMappings = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 15),
    /// <summary>
    /// Indicates whether the boot debugger should be enabled.
    /// </summary>
    /// <remarks>0x16000010</remarks>
    BcdLibraryBoolean_DebuggerEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 16),
    /// <summary>
    /// Debugger type. The Integer property is one of the values from the BcdLibrary_DebuggerType enumeration.
    /// </summary>
    /// <remarks>0x15000011</remarks>
    BcdLibraryInteger_DebuggerType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 17),
    /// <summary>
    /// I/O port address for the serial debugger.
    /// </summary>
    /// <remarks>0x15000012</remarks>
    BcdLibraryInteger_SerialDebuggerPortAddress = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 18),
    /// <summary>
    /// Serial port number for serial debugging.
    /// If this value is not specified, the default is specified by the DBGP ACPI table settings.
    /// </summary>
    /// <remarks>0x15000013</remarks>
    BcdLibraryInteger_SerialDebuggerPort = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 19),
    /// <summary>
    /// Baud rate for serial debugging.
    /// </summary>
    /// <remarks>0x15000014</remarks>
    BcdLibraryInteger_SerialDebuggerBaudRate = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 20),
    /// <summary>
    /// Channel number for 1394 debugging.
    /// </summary>
    /// <remarks>0x15000015</remarks>
    BcdLibraryInteger_1394DebuggerChannel = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 21),
    /// <summary>
    /// The target name for the USB debugger. The target name is arbitrary but must match between the debugger and the debug target.
    /// </summary>
    /// <remarks>0x12000016</remarks>
    BcdLibraryString_UsbDebuggerTargetName = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 22),
    /// <summary>
    /// If TRUE, the debugger will ignore user mode exceptions and only stop for kernel mode exceptions.
    /// </summary>
    /// <remarks>0x16000017</remarks>
    BcdLibraryBoolean_DebuggerIgnoreUsermodeExceptions = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 23),
    /// <summary>
    /// Indicates the debugger start policy. The Integer property is one of the values from the BcdLibrary_DebuggerStartPolicy enumeration.
    /// </summary>
    /// <remarks>0x15000018</remarks>
    BcdLibraryInteger_DebuggerStartPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 24),
    /// <summary>
    /// Defines the PCI bus, device, and function numbers of the debugging device. For example, 1.5.0 describes the debugging device on bus 1, device 5, function 0.
    /// </summary>
    /// <remarks>0x12000019</remarks>
    BcdLibraryString_DebuggerBusParameters = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 25),
    /// <summary>
    /// Defines the host IP address for the network debugger.
    /// </summary>
    /// <remarks>0x1500001A</remarks>
    BcdLibraryInteger_DebuggerNetHostIP = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 26),
    /// <summary>
    /// Defines the network port for the network debugger.
    /// </summary>
    /// <remarks>0x1500001B</remarks>
    BcdLibraryInteger_DebuggerNetPort = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 27),
    /// <summary>
    /// Controls the use of DHCP by the network debugger. Setting this to false causes the OS to only use link-local addresses.
    /// This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x1600001C</remarks>
    BcdLibraryBoolean_DebuggerNetDhcp = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 28),
    /// <summary>
    /// Holds the key used to encrypt the network debug connection.
    /// This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x1200001D</remarks>
    BcdLibraryString_DebuggerNetKey = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 29),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x1600001E</remarks>
    BcdLibraryBoolean_DebuggerNetVM = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 30),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x1200001F</remarks>
    BcdLibraryString_DebuggerNetHostIpv6 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 31),
    /// <summary>
    /// Indicates whether EMS redirection should be enabled.
    /// </summary>
    /// <remarks>0x16000020</remarks>
    BcdLibraryBoolean_EmsEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 32),
    /// <summary>
    /// COM port number for EMS redirection.
    /// </summary>
    /// <remarks>0x15000022</remarks>
    BcdLibraryInteger_EmsPort = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 34),
    /// <summary>
    /// Baud rate for EMS redirection.
    /// </summary>
    /// <remarks>0x15000023</remarks>
    BcdLibraryInteger_EmsBaudRate = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 35),
    /// <summary>
    /// String that is appended to the load options string passed to the kernel to be consumed by kernel-mode components.
    /// This is useful for communicating with kernel-mode components that are not BCD-aware.
    /// </summary>
    /// <remarks>0x12000030</remarks>
    BcdLibraryString_LoadOptionsString = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 48),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x16000031</remarks>
    BcdLibraryBoolean_AttemptNonBcdStart = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 49),
    /// <summary>
    /// Indicates whether the advanced options boot menu (F8) is displayed.
    /// </summary>
    /// <remarks>0x16000040</remarks>
    BcdLibraryBoolean_DisplayAdvancedOptions = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 64),
    /// <summary>
    /// Indicates whether the boot options editor is enabled.
    /// </summary>
    /// <remarks>0x16000041</remarks>
    BcdLibraryBoolean_DisplayOptionsEdit = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 65),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x15000042</remarks>
    BcdLibraryInteger_FVEKeyRingAddress = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 66),
    /// <summary>
    /// Allows a device override for the bootstat.dat log in the boot manager and winload.exe.
    /// </summary>
    /// <remarks>0x11000043</remarks>
    BcdLibraryDevice_BsdLogDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 67),
    /// <summary>
    /// Allows a path override for the bootstat.dat log file in the boot manager and winload.exe.
    /// </summary>
    /// <remarks>0x12000044</remarks>
    BcdLibraryString_BsdLogPath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 68),
    /// <summary>
    /// Indicates whether graphics mode is disabled and boot applications must use text mode display.
    /// </summary>
    /// <remarks>0x16000045</remarks>
    BcdLibraryBoolean_BsdPreserveLog = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 69),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x16000046</remarks>
    BcdLibraryBoolean_GraphicsModeDisabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 70),
    /// <summary>
    /// Indicates the access policy for PCI configuration space.
    /// </summary>
    /// <remarks>0x15000047</remarks>
    BcdLibraryInteger_ConfigAccessPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 71),
    /// <summary>
    /// Disables integrity checks.
    /// Cannot be set when secure boot is enabled.
    /// This value is ignored by Windows 7 and Windows 8.
    /// </summary>
    /// <remarks>0x16000048</remarks>
    BcdLibraryBoolean_DisableIntegrityChecks = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 72),
    /// <summary>
    /// Indicates whether the test code signing certificate is supported.
    /// </summary>
    /// <remarks>0x16000049</remarks>
    BcdLibraryBoolean_AllowPrereleaseSignatures = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 73),
    /// <summary>
    /// Overrides the default location of the boot fonts.
    /// </summary>
    /// <remarks>0x1200004A</remarks>
    BcdLibraryString_FontPath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 74),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x1500004B</remarks>
    BcdLibraryInteger_SiPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 75),
    /// <summary>
    /// This value (if present) should not be modified.
    /// </summary>
    /// <remarks>0x1500004C</remarks>
    BcdLibraryInteger_FveBandId = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 76),
    /// <summary>
    /// Specifies that legacy BIOS systems should use INT 16h Function 10h for console input instead of INT 16h Function 0h.
    /// </summary>
    /// <remarks>0x16000050</remarks>
    BcdLibraryBoolean_ConsoleExtendedInput = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 80),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x15000051</remarks>
    BcdLibraryInteger_InitialConsoleInput = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 81),
    /// <summary>
    /// Forces a specific graphics resolution at boot.
    /// Possible values include GraphicsResolution1024x768 (0), GraphicsResolution800x600 (1), and GraphicsResolution1024x600 (2).
    /// </summary>
    /// <remarks>0x15000052</remarks>
    BcdLibraryInteger_GraphicsResolution = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 82),
    /// <summary>
    /// If enabled, specifies that boot error screens are not shown when OS launch errors occur, and the system is reset rather than exiting directly back to the firmware.
    /// </summary>
    /// <remarks>0x16000053</remarks>
    BcdLibraryBoolean_RestartOnFailure = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 83),
    /// <summary>
    /// Forces highest available graphics resolution at boot.
    /// This value can only be used on UEFI systems.
    /// This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x16000054</remarks>
    BcdLibraryBoolean_GraphicsForceHighestMode = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 84),
    /// <summary>
    /// This setting is used to differentiate between the Windows 7 and Windows 8 implementations of UEFI.
    /// Do not modify this setting.
    /// If this setting is removed from a Windows 8 installation, it will not boot.
    /// If this setting is added to a Windows 7 installation, it will not boot.
    /// </summary>
    /// <remarks>0x16000060</remarks>
    BcdLibraryBoolean_IsolatedExecutionContext = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 96),
    /// <summary>
    /// This setting disables the progress bar and default Windows logo. If a custom text string has been defined, it is also disabled by this setting.
    /// The Integer property is one of the values from the BcdLibrary_UxDisplayMessageType enumeration.
    /// </summary>
    /// <remarks>0x15000065</remarks>
    BcdLibraryInteger_BootUxDisplayMessage = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 101),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x15000066</remarks>
    BcdLibraryInteger_BootUxDisplayMessageOverride = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 102),
    /// <summary>
    /// This setting disables the boot logo.
    /// </summary>
    /// <remarks>0x16000067</remarks>
    BcdLibraryBoolean_BootUxLogoDisable = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 103),
    /// <summary>
    /// This setting disables the boot status text.
    /// </summary>
    /// <remarks>0x16000068</remarks>
    BcdLibraryBoolean_BootUxTextDisable = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 104),
    /// <summary>
    /// This setting disables the boot progress bar.
    /// </summary>
    /// <remarks>0x16000069</remarks>
    BcdLibraryBoolean_BootUxProgressDisable = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 105),
    /// <summary>
    /// This setting disables the boot transition fading.
    /// </summary>
    /// <remarks>0x1600006A</remarks>
    BcdLibraryBoolean_BootUxFadeDisable = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 106),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x1600006B</remarks>
    BcdLibraryBoolean_BootUxReservePoolDebug = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 107),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x1600006C</remarks>
    BcdLibraryBoolean_BootUxDisable = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 108),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x1500006D</remarks>
    BcdLibraryInteger_BootUxFadeFrames = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 109),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x1600006E</remarks>
    BcdLibraryBoolean_BootUxDumpStats = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 110),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x1600006F</remarks>
    BcdLibraryBoolean_BootUxShowStats = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 111),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x16000071</remarks>
    BcdLibraryBoolean_MultiBootSystem = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 113),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x16000072</remarks>
    BcdLibraryBoolean_ForceNoKeyboard = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 114),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x15000073</remarks>
    BcdLibraryInteger_AliasWindowsKey = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 115),
    /// <summary>
    /// Disables the 1-minute timer that triggers shutdown on boot error screens, and the F8 menu, on UEFI systems.
    /// </summary>
    /// <remarks>0x16000074</remarks>
    BcdLibraryBoolean_BootShutdownDisabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 116),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x15000075</remarks>
    BcdLibraryInteger_PerformanceFrequency = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 117),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x15000076</remarks>
    BcdLibraryInteger_SecurebootRawPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 118),
    /// <summary>
    /// Indicates whether or not an in-memory BCD setting passed between boot apps will trigger BitLocker recovery.
    /// This value should not be modified as it could trigger a BitLocker recovery action.
    /// </summary>
    /// <remarks>0x17000077</remarks>
    BcdLibraryIntegerList_AllowedInMemorySettings = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 119),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x15000079</remarks>
    BcdLibraryInteger_BootUxBitmapTransitionTime = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 121),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x1600007A</remarks>
    BcdLibraryBoolean_TwoBootImages = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 122),
    /// <summary>
    /// Force the use of FIPS cryptography checks on boot applications.
    /// BcdLibraryBoolean_ForceFipsCrypto is documented with wrong value 0x16000079
    /// </summary>
    /// <remarks>0x1600007B</remarks>
    BcdLibraryBoolean_ForceFipsCrypto = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 123),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x1500007D</remarks>
    BcdLibraryInteger_BootErrorUx = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 125),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x1600007E</remarks>
    BcdLibraryBoolean_AllowFlightSignatures = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 126),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x1500007F</remarks>
    BcdLibraryInteger_BootMeasurementLogFormat = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 127),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x15000080</remarks>
    BcdLibraryInteger_DisplayRotation = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 128),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x15000081</remarks>
    BcdLibraryInteger_LogControl = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 129),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x16000082</remarks>
    BcdLibraryBoolean_NoFirmwareSync = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 130),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x11000084</remarks>
    BcdLibraryDevice_WindowsSystemDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 132),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x16000087</remarks>
    BcdLibraryBoolean_NumLockOn = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 135),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x12000088</remarks>
    BcdLibraryString_AdditionalCiPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 136),
} BcdLibraryElementTypes;

typedef enum _BcdTemplateElementTypes
{
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x45000001</remarks>
    BcdSetupInteger_DeviceType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 1),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x42000002</remarks>
    BcdSetupString_ApplicationRelativePath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 2),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x42000003</remarks>
    BcdSetupString_RamdiskDeviceRelativePath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 3),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x46000004</remarks>
    BcdSetupBoolean_OmitOsLoaderElements = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 4),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x47000006</remarks>
    BcdSetupIntegerList_ElementsToMigrateList = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE, BCD_ELEMENT_DATATYPE_FORMAT_INTEGERLIST, 6),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x46000010</remarks>
    BcdSetupBoolean_RecoveryOs = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 16),
} BcdTemplateElementTypes;

/// <summary>
/// Specifies the no-execute page protection policies.
/// </summary>
typedef enum _BcdOSLoader_NxPolicy
{
    /// <summary>
    /// The no-execute page protection is off by default.
    /// </summary>
    NxPolicyOptIn = 0,
    /// <summary>
    /// The no-execute page protection is on by default.
    /// </summary>
    NxPolicyOptOut = 1,
    /// <summary>
    /// The no-execute page protection is always off.
    /// </summary>
    NxPolicyAlwaysOff = 2,
    /// <summary>
    /// The no-execute page protection is always on.
    /// </summary>
    NxPolicyAlwaysOn = 3
} BcdOSLoader_NxPolicy;

/// <summary>
/// Specifies the Physical Address Extension (PAE) policies.
/// </summary>
typedef enum _BcdOSLoader_PAEPolicy
{
    /// <summary>
    /// Enable PAE if hot-pluggable memory is defined above 4GB.
    /// </summary>
    PaePolicyDefault = 0,
    /// <summary>
    /// PAE is enabled.
    /// </summary>
    PaePolicyForceEnable = 1,
    /// <summary>
    /// PAE is disabled.
    /// </summary>
    PaePolicyForceDisable = 2
} BcdOSLoader_PAEPolicy;

typedef enum _BcdOSLoader_BootStatusPolicy
{
    /// <summary>
    /// Display all boot failures.
    /// </summary>
    BootStatusPolicyDisplayAllFailures = 0,
    /// <summary>
    /// Ignore all boot failures.
    /// </summary>
    BootStatusPolicyIgnoreAllFailures = 1,
    /// <summary>
    /// Ignore all shutdown failures.
    /// </summary>
    BootStatusPolicyIgnoreShutdownFailures = 2,
    /// <summary>
    /// Ignore all boot failures.
    /// </summary>
    BootStatusPolicyIgnoreBootFailures = 3,
    /// <summary>
    /// Ignore checkpoint failures.
    /// </summary>
    BootStatusPolicyIgnoreCheckpointFailures = 4,
    /// <summary>
    /// Display shutdown failures.
    /// </summary>
    BootStatusPolicyDisplayShutdownFailures = 5,
    /// <summary>
    /// Display boot failures.
    /// </summary>
    BootStatusPolicyDisplayBootFailures = 6,
    /// <summary>
    /// Display checkpoint failures.
    /// </summary>
    BootStatusPolicyDisplayCheckpointFailures = 7
} BcdOSLoaderBootStatusPolicy;

// BcdOSLoaderElementTypes based on geoffchappell: https://www.geoffchappell.com/notes/windows/boot/bcd/elements.htm (dmex)
typedef enum _BcdOSLoaderElementTypes
{
    /// <summary>
    /// The device on which the operating system resides.
    /// </summary>
    /// <remarks>0x21000001</remarks>
    BcdOSLoaderDevice_OSDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 1),
    /// <summary>
    /// The file path to the operating system (%SystemRoot% minus the volume).
    /// </summary>
    /// <remarks>0x22000002</remarks>
    BcdOSLoaderString_SystemRoot = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 2),
    /// <summary>
    /// The resume application associated with the operating system.
    /// </summary>
    /// <remarks>0x23000003</remarks>
    BcdOSLoaderObject_AssociatedResumeObject = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_OBJECT, 3),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000004</remarks>
    BcdOSLoaderBoolean_StampDisks = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 4),
    /// <summary>
    /// Indicates whether the operating system loader should determine the kernel and HAL to load based on the platform features.
    /// </summary>
    /// <remarks>0x26000010</remarks>
    BcdOSLoaderBoolean_DetectKernelAndHal = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 16),
    /// <summary>
    /// The kernel to be loaded by the operating system loader. This value overrides the default kernel.
    /// </summary>
    /// <remarks>0x22000011</remarks>
    BcdOSLoaderString_KernelPath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 17),
    /// <summary>
    /// The HAL to be loaded by the operating system loader. This value overrides the default HAL.
    /// </summary>
    /// <remarks>0x22000012</remarks>
    BcdOSLoaderString_HalPath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 18),
    /// <summary>
    /// The transport DLL to be loaded by the operating system loader. This value overrides the default Kdcom.dll.
    /// </summary>
    /// <remarks>0x22000013</remarks>
    BcdOSLoaderString_DbgTransportPath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 19),
    /// <summary>
    /// The no-execute page protection policy. The Integer property is one of the values from the BcdOSLoader_NxPolicy enumeration.
    /// </summary>
    /// <remarks>0x25000020</remarks>
    BcdOSLoaderInteger_NxPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 32),
    /// <summary>
    /// The Physical Address Extension (PAE) policy. The Integer property is one of the values from the BcdOSLoader_PAEPolicy enumeration.
    /// </summary>
    /// <remarks>0x25000021</remarks>
    BcdOSLoaderInteger_PAEPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 33),
    /// <summary>
    /// Indicates that the system should be started in Windows Preinstallation Environment (Windows PE) mode.
    /// </summary>
    /// <remarks>0x26000022</remarks>
    BcdOSLoaderBoolean_WinPEMode = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 34),
    /// <summary>
    /// Indicates that the system should not automatically reboot when it crashes.
    /// </summary>
    /// <remarks>0x26000024</remarks>
    BcdOSLoaderBoolean_DisableCrashAutoReboot = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 36),
    /// <summary>
    /// Indicates that the system should use the last-known good settings.
    /// </summary>
    /// <remarks>0x26000025</remarks>
    BcdOSLoaderBoolean_UseLastGoodSettings = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 37),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000026</remarks>
    BcdOSLoaderBoolean_DisableCodeIntegrityChecks = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 38),
    /// <summary>
    /// Indicates whether the test code signing certificate is supported.
    /// </summary>
    /// <remarks>0x26000027</remarks>
    BcdOSLoaderBoolean_AllowPrereleaseSignatures = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 39),
    /// <summary>
    /// Indicates whether the system should utilize the first 4GB of physical memory.
    /// This option requires 5GB of physical memory, and on x86 systems it requires PAE to be enabled.
    /// </summary>
    /// <remarks>0x26000030</remarks>
    BcdOSLoaderBoolean_NoLowMemory = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 48),
    /// <summary>
    /// The amount of memory the system should ignore.
    /// </summary>
    /// <remarks>0x25000031</remarks>
    BcdOSLoaderInteger_RemoveMemory = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 49),
    /// <summary>
    /// The amount of memory that should be utilized by the process address space, in bytes.
    /// This value should be between 2GB and 3GB.
    /// Increasing this value from the default 2GB decreases the amount of virtual address space available to the system and device drivers.
    /// </summary>
    /// <remarks>0x25000032</remarks>
    BcdOSLoaderInteger_IncreaseUserVa = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 50),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000033</remarks>
    BcdOSLoaderInteger_PerformaceDataMemory = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 51),
    /// <summary>
    /// Indicates whether the system should use the standard VGA display driver instead of a high-performance display driver.
    /// </summary>
    /// <remarks>0x26000040</remarks>
    BcdOSLoaderBoolean_UseVgaDriver = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 64),
    /// <summary>
    /// Indicates whether the system should initialize the VGA driver responsible for displaying simple graphics during the boot process.
    /// If not, there is no display is presented during the boot process.
    /// </summary>
    /// <remarks>0x26000041</remarks>
    BcdOSLoaderBoolean_DisableBootDisplay = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 65),
    /// <summary>
    /// Indicates whether the VGA driver should avoid VESA BIOS calls.
    /// Note This value is ignored by Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x26000042</remarks>
    BcdOSLoaderBoolean_DisableVesaBios = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 66),
    /// <summary>
    /// Disables the use of VGA modes in the OS.
    /// </summary>
    /// <remarks>0x26000043</remarks>
    BcdOSLoaderBoolean_DisableVgaMode = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 67),
    /// <summary>
    /// Indicates that cluster-mode APIC addressing should be utilized, and the value is the maximum number of processors per cluster.
    /// </summary>
    /// <remarks>0x25000050</remarks>
    BcdOSLoaderInteger_ClusterModeAddressing = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 80),
    /// <summary>
    /// Indicates whether to enable physical-destination mode for all APIC messages.
    /// </summary>
    /// <remarks>0x26000051</remarks>
    BcdOSLoaderBoolean_UsePhysicalDestination = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 81),
    /// <summary>
    /// The maximum number of APIC clusters that should be used by cluster-mode addressing.
    /// </summary>
    /// <remarks>0x25000052</remarks>
    BcdOSLoaderInteger_RestrictApicCluster = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 82),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000053</remarks>
    BcdOSLoaderString_OSLoaderTypeEVStore = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 83),
    /// <summary>
    /// Used to force legacy APIC mode, even if the processors and chipset support extended APIC mode.
    /// </summary>
    /// <remarks>0x26000054</remarks>
    BcdOSLoaderBoolean_UseLegacyApicMode = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 84),
    /// <summary>
    /// Enables the use of extended APIC mode, if supported.
    /// Zero (0) indicates default behavior, one (1) indicates that extended APIC mode is disabled, and two (2) indicates that extended APIC mode is enabled.
    /// The system defaults to using extended APIC mode if available.
    /// </summary>
    /// <remarks>0x25000055</remarks>
    BcdOSLoaderInteger_X2ApicPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 85),
    /// <summary>
    /// Indicates whether the operating system should initialize or start non-boot processors.
    /// </summary>
    /// <remarks>0x26000060</remarks>
    BcdOSLoaderBoolean_UseBootProcessorOnly = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 96),
    /// <summary>
    /// The maximum number of processors that can be utilized by the system; all other processors are ignored.
    /// </summary>
    /// <remarks>0x25000061</remarks>
    BcdOSLoaderInteger_NumberOfProcessors = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 97),
    /// <summary>
    /// Indicates whether the system should use the maximum number of processors.
    /// </summary>
    /// <remarks>0x26000062</remarks>
    BcdOSLoaderBoolean_ForceMaximumProcessors = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 98),
    /// <summary>
    /// Indicates whether processor specific configuration flags are to be used.
    /// </summary>
    /// <remarks>0x25000063</remarks>
    BcdOSLoaderBoolean_ProcessorConfigurationFlags = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 99),
    /// <summary>
    /// Maximizes the number of groups created when assigning nodes to processor groups.
    /// </summary>
    /// <remarks>0x26000064</remarks>
    BcdOSLoaderBoolean_MaximizeGroupsCreated = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 100),
    /// <summary>
    /// This setting makes drivers group aware and can be used to determine improper group usage.
    /// </summary>
    /// <remarks>0x26000065</remarks>
    BcdOSLoaderBoolean_ForceGroupAwareness = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 101),
    /// <summary>
    /// Specifies the size of all processor groups. Must be set to a power of 2.
    /// </summary>
    /// <remarks>0x25000066</remarks>
    BcdOSLoaderInteger_GroupSize = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 102),
    /// <summary>
    /// Indicates whether the system should use I/O and IRQ resources created by the system firmware instead of using dynamically configured resources.
    /// </summary>
    /// <remarks>0x26000070</remarks>
    BcdOSLoaderInteger_UseFirmwarePciSettings = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 112),
    /// <summary>
    /// The PCI Message Signaled Interrupt (MSI) policy. Zero (0) indicates default, and one (1) indicates that MSI interrupts are disabled.
    /// </summary>
    /// <remarks>0x25000071</remarks>
    BcdOSLoaderInteger_MsiPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 113),
    /// <summary>
    /// Undocumented. Zero (0) indicates default, and one (1) indicates that PCI Express is forcefully disabled.
    /// </summary>
    /// <remarks>0x25000072</remarks>
    BcdOSLoaderInteger_PciExpressPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 114),
    /// <summary>
    /// The Integer property is one of the values from the BcdLibrary_SafeBoot enumeration.
    /// </summary>
    /// <remarks>0x25000080</remarks>
    BcdOSLoaderInteger_SafeBoot = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 128),
    /// <summary>
    /// Indicates whether the system should use the shell specified under the following registry key instead of the default shell:
    /// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SafeBoot\AlternateShell.
    /// </summary>
    /// <remarks>0x26000081</remarks>
    BcdOSLoaderBoolean_SafeBootAlternateShell = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 129),
    /// <summary>
    /// Indicates whether the system should write logging information to %SystemRoot%\Ntbtlog.txt during initialization.
    /// </summary>
    /// <remarks>0x26000090</remarks>
    BcdOSLoaderBoolean_BootLogInitialization = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 144),
    /// <summary>
    /// Indicates whether the system should display verbose information.
    /// </summary>
    /// <remarks>0x26000091</remarks>
    BcdOSLoaderBoolean_VerboseObjectLoadMode = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 145),
    /// <summary>
    /// Indicates whether the kernel debugger should be enabled using the settings in the inherited debugger object.
    /// </summary>
    /// <remarks>0x260000A0</remarks>
    BcdOSLoaderBoolean_KernelDebuggerEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 160),
    /// <summary>
    /// Indicates whether the HAL should call DbgBreakPoint at the start of HalInitSystem for phase 0 initialization of the kernel.
    /// </summary>
    /// <remarks>0x260000A1</remarks>
    BcdOSLoaderBoolean_DebuggerHalBreakpoint = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 161),
    /// <summary>
    /// Forces the use of the platform clock as the system's performance counter.
    /// </summary>
    /// <remarks>0x260000A2</remarks>
    BcdOSLoaderBoolean_UsePlatformClock = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 162),
    /// <summary>
    /// Forces the OS to assume the presence of legacy PC devices like CMOS and keyboard controllers.
    /// This value should only be used for debugging.
    /// </summary>
    /// <remarks>0x260000A3</remarks>
    BcdOSLoaderBoolean_ForceLegacyPlatform = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 163),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x260000A4</remarks>
    BcdOSLoaderBoolean_UsePlatformTick = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 164),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x260000A5</remarks>
    BcdOSLoaderBoolean_DisableDynamicTick = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 165),
    /// <summary>
    /// Controls the TSC synchronization policy. Possible values include default (0), legacy (1), or enhanced (2).
    /// This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x250000A6</remarks>
    BcdOSLoaderInteger_TscSyncPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 166),
    /// <summary>
    /// Indicates whether EMS should be enabled in the kernel.
    /// </summary>
    /// <remarks>0x260000B0</remarks>
    BcdOSLoaderBoolean_EmsEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 176),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x250000C0</remarks>
    BcdOSLoaderInteger_ForceFailure = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 192),
    /// <summary>
    /// Indicates the driver load failure policy. Zero (0) indicates that a failed driver load is fatal and the boot will not continue,
    /// one (1) indicates that the standard error control is used.
    /// </summary>
    /// <remarks>0x250000C1</remarks>
    BcdOSLoaderInteger_DriverLoadFailurePolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 193),
    /// <summary>
    /// Defines the type of boot menus the system will use. Possible values include menupolicylegacy (0) or menupolicystandard (1).
    /// The default value is menupolicylegacy (0).
    /// </summary>
    /// <remarks>0x250000C2</remarks>
    BcdOSLoaderInteger_BootMenuPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 194),
    /// <summary>
    /// Controls whether the system boots to the legacy menu (F8 menu) on the next boot.
    /// Note This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x260000C3</remarks>
    BcdOSLoaderBoolean_AdvancedOptionsOneTime = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 195),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x260000C4</remarks>
    BcdOSLoaderBoolean_OptionsEditOneTime = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 196),
    /// <summary>
    /// The boot status policy. The Integer property is one of the values from the BcdOSLoaderBootStatusPolicy enumeration
    /// </summary>
    /// <remarks>0x250000E0</remarks>
    BcdOSLoaderInteger_BootStatusPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 224),
    /// <summary>
    /// The OS loader removes this entry for security reasons. This option can only be triggered by using the F8 menu; a user must be physically present to trigger this option.
    /// This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x260000E1</remarks>
    BcdOSLoaderBoolean_DisableElamDrivers = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 225),
    /// <summary>
    /// Controls the hypervisor launch type. Options are HyperVisorLaunchOff (0) and HypervisorLaunchAuto (1).
    /// </summary>
    /// <remarks>0x250000F0</remarks>
    BcdOSLoaderInteger_HypervisorLaunchType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 240),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x250000F1</remarks>
    BcdOSLoaderString_HypervisorPath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 241),
    /// <summary>
    /// Controls whether the hypervisor debugger is enabled.
    /// </summary>
    /// <remarks>0x260000F2</remarks>
    BcdOSLoaderBoolean_HypervisorDebuggerEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 242),
    /// <summary>
    /// Controls the hypervisor debugger type. Can be set to SERIAL (0), 1394 (1), or NET (2).
    /// </summary>
    /// <remarks>0x250000F3</remarks>
    BcdOSLoaderInteger_HypervisorDebuggerType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 243),
    /// <summary>
    /// Specifies the serial port number for serial debugging.
    /// </summary>
    /// <remarks>0x250000F4</remarks>
    BcdOSLoaderInteger_HypervisorDebuggerPortNumber = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 244),
    /// <summary>
    /// Specifies the baud rate for serial debugging.
    /// </summary>
    /// <remarks>0x250000F5</remarks>
    BcdOSLoaderInteger_HypervisorDebuggerBaudrate = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 245),
    /// <summary>
    /// Specifies the channel number for 1394 debugging.
    /// </summary>
    /// <remarks>0x250000F6</remarks>
    BcdOSLoaderInteger_HypervisorDebugger1394Channel = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 246),
    /// <summary>
    /// Values are Disabled (0), Basic (1), and Standard (2).
    /// </summary>
    /// <remarks>0x250000F7</remarks>
    BcdOSLoaderInteger_BootUxPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 247),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x220000F8</remarks>
    BcdOSLoaderInteger_HypervisorSlatDisabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 248),
    /// <summary>
    /// Defines the PCI bus, device, and function numbers of the debugging device used with the hypervisor.
    /// For example, 1.5.0 describes the debugging device on bus 1, device 5, function 0.
    /// </summary>
    /// <remarks>0x220000F9</remarks>
    BcdOSLoaderString_HypervisorDebuggerBusParams = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 249),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x250000FA</remarks>
    BcdOSLoaderInteger_HypervisorNumProc = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 250),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x250000FB</remarks>
    BcdOSLoaderInteger_HypervisorRootProcPerNode = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 251),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x260000FC</remarks>
    BcdOSLoaderBoolean_HypervisorUseLargeVTlb = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 252),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x250000FD</remarks>
    BcdOSLoaderInteger_HypervisorDebuggerNetHostIp = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 253),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x250000FE</remarks>
    BcdOSLoaderInteger_HypervisorDebuggerNetHostPort = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 254),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x250000FF</remarks>
    BcdOSLoaderInteger_HypervisorDebuggerPages = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 255),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000100</remarks>
    BcdOSLoaderInteger_TpmBootEntropyPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 256),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000110</remarks>
    BcdOSLoaderString_HypervisorDebuggerNetKey = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 272),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000112</remarks>
    BcdOSLoaderString_HypervisorProductSkuType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 274),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000113</remarks>
    BcdOSLoaderInteger_HypervisorRootProc = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 275),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000114</remarks>
    BcdOSLoaderBoolean_HypervisorDebuggerNetDhcp = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 276),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000115</remarks>
    BcdOSLoaderInteger_HypervisorIommuPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 277),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000116</remarks>
    BcdOSLoaderBoolean_HypervisorUseVApic = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 278),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000117</remarks>
    BcdOSLoaderString_HypervisorLoadOptions = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 279),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000118</remarks>
    BcdOSLoaderInteger_HypervisorMsrFilterPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 280),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000119</remarks>
    BcdOSLoaderInteger_HypervisorMmioNxPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 281),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500011A</remarks>
    BcdOSLoaderInteger_HypervisorSchedulerType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 282),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2200011B</remarks>
    BcdOSLoaderString_HypervisorRootProcNumaNodes = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 283),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500011C</remarks>
    BcdOSLoaderInteger_HypervisorPerfmon = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 284),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500011D</remarks>
    BcdOSLoaderInteger_HypervisorRootProcPerCore = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 285),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2200011E</remarks>
    BcdOSLoaderString_HypervisorRootProcNumaNodeLps = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 286),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000120</remarks>
    BcdOSLoaderInteger_XSavePolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 288),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000121</remarks>
    BcdOSLoaderInteger_XSaveAddFeature0 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 289),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000122</remarks>
    BcdOSLoaderInteger_XSaveAddFeature1 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 290),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000123</remarks>
    BcdOSLoaderInteger_XSaveAddFeature2 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 291),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000124</remarks>
    BcdOSLoaderInteger_XSaveAddFeature3 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 292),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000125</remarks>
    BcdOSLoaderInteger_XSaveAddFeature4 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 293),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000126</remarks>
    BcdOSLoaderInteger_XSaveAddFeature5 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 294),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000127</remarks>
    BcdOSLoaderInteger_XSaveAddFeature6 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 295),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000128</remarks>
    BcdOSLoaderInteger_XSaveAddFeature7 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 296),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000129</remarks>
    BcdOSLoaderInteger_XSaveRemoveFeature = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 297),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500012A</remarks>
    BcdOSLoaderInteger_XSaveProcessorsMask = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 298),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500012B</remarks>
    BcdOSLoaderInteger_XSaveDisable = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 299),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500012C</remarks>
    BcdOSLoaderInteger_KernelDebuggerType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 300),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2200012D</remarks>
    BcdOSLoaderString_KernelDebuggerBusParameters = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 301),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500012E</remarks>
    BcdOSLoaderInteger_KernelDebuggerPortAddress = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 302),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500012F</remarks>
    BcdOSLoaderInteger_KernelDebuggerPortNumber = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 303),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000130</remarks>
    BcdOSLoaderInteger_ClaimedTpmCounter = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 304),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000131</remarks>
    BcdOSLoaderInteger_KernelDebugger1394Channel = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 305),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000132</remarks>
    BcdOSLoaderString_KernelDebuggerUsbTargetname = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 306),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000133</remarks>
    BcdOSLoaderInteger_KernelDebuggerNetHostIp = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 307),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000134</remarks>
    BcdOSLoaderInteger_KernelDebuggerNetHostPort = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 308),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000135</remarks>
    BcdOSLoaderBoolean_KernelDebuggerNetDhcp = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 309),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000136</remarks>
    BcdOSLoaderString_KernelDebuggerNetKey = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 310),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000137</remarks>
    BcdOSLoaderString_IMCHiveName = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 311),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x21000138</remarks>
    BcdOSLoaderDevice_IMCDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 312),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000139</remarks>
    BcdOSLoaderInteger_KernelDebuggerBaudrate = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 313),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000140</remarks>
    BcdOSLoaderString_ManufacturingMode = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 320),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000141</remarks>
    BcdOSLoaderBoolean_EventLoggingEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 321),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000142</remarks>
    BcdOSLoaderInteger_VsmLaunchType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 322),
    /// <summary>
    /// Undocumented. Zero (0) indicates default, one (1) indicates that disabled and two (2) indicates strict mode.
    /// </summary>
    /// <remarks>0x25000144</remarks>
    BcdOSLoaderInteger_HypervisorEnforcedCodeIntegrity = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 324),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000145</remarks>
    BcdOSLoaderBoolean_DtraceEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 325),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x21000150</remarks>
    BcdOSLoaderDevice_SystemDataDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 336),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x21000151</remarks>
    BcdOSLoaderDevice_OsArcDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 337),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x21000153</remarks>
    BcdOSLoaderDevice_OsDataDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 339),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x21000154</remarks>
    BcdOSLoaderDevice_BspDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 340),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x21000155</remarks>
    BcdOSLoaderDevice_BspFilepath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 341),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000156</remarks>
    BcdOSLoaderString_KernelDebuggerNetHostIpv6 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 342),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000161</remarks>
    BcdOSLoaderString_HypervisorDebuggerNetHostIpv6 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 353),
} BcdOSLoaderElementTypes;

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTMMAPI_H
#define _NTMMAPI_H

// Protection constants

#define PAGE_NOACCESS 0x01
#define PAGE_READONLY 0x02
#define PAGE_READWRITE 0x04
#define PAGE_WRITECOPY 0x08
#define PAGE_EXECUTE 0x10
#define PAGE_EXECUTE_READ 0x20
#define PAGE_EXECUTE_READWRITE 0x40
#define PAGE_EXECUTE_WRITECOPY 0x80
#define PAGE_GUARD 0x100
#define PAGE_NOCACHE 0x200
#define PAGE_WRITECOMBINE 0x400

#define PAGE_REVERT_TO_FILE_MAP     0x80000000
#define PAGE_ENCLAVE_THREAD_CONTROL 0x80000000
#define PAGE_TARGETS_NO_UPDATE      0x40000000
#define PAGE_TARGETS_INVALID        0x40000000
#define PAGE_ENCLAVE_UNVALIDATED    0x20000000
#define PAGE_ENCLAVE_NO_CHANGE      0x20000000
#define PAGE_ENCLAVE_MASK           0x10000000
#define PAGE_ENCLAVE_DECOMMIT       (PAGE_ENCLAVE_MASK | 0)
#define PAGE_ENCLAVE_SS_FIRST       (PAGE_ENCLAVE_MASK | 1)
#define PAGE_ENCLAVE_SS_REST        (PAGE_ENCLAVE_MASK | 2)

// Region and section constants

#define MEM_COMMIT 0x00001000
#define MEM_RESERVE 0x00002000
#define MEM_DECOMMIT 0x00004000
#define MEM_RELEASE 0x00008000
#define MEM_FREE 0x00010000
#define MEM_PRIVATE 0x00020000
#define MEM_MAPPED 0x00040000
#define MEM_RESET 0x00080000
#define MEM_TOP_DOWN 0x00100000
#define MEM_WRITE_WATCH 0x00200000
#define MEM_PHYSICAL 0x00400000
#define MEM_ROTATE 0x00800000
#define MEM_DIFFERENT_IMAGE_BASE_OK 0x00800000
#define MEM_RESET_UNDO 0x01000000
#define MEM_LARGE_PAGES 0x20000000
#define MEM_DOS_LIM 0x40000000
#define MEM_4MB_PAGES 0x80000000
#define MEM_64K_PAGES (MEM_LARGE_PAGES | MEM_PHYSICAL)

#define MEM_UNMAP_WITH_TRANSIENT_BOOST 0x00000001
#define MEM_COALESCE_PLACEHOLDERS 0x00000001
#define MEM_PRESERVE_PLACEHOLDER 0x00000002
#define MEM_REPLACE_PLACEHOLDER 0x00004000
#define MEM_RESERVE_PLACEHOLDER 0x00040000

#define SEC_HUGE_PAGES 0x00020000
#define SEC_PARTITION_OWNER_HANDLE 0x00040000
#define SEC_64K_PAGES 0x00080000
#define SEC_BASED 0x00200000
#define SEC_NO_CHANGE 0x00400000
#define SEC_FILE 0x00800000
#define SEC_IMAGE 0x01000000
#define SEC_PROTECTED_IMAGE 0x02000000
#define SEC_RESERVE 0x04000000
#define SEC_COMMIT 0x08000000
#define SEC_NOCACHE 0x10000000
#define SEC_GLOBAL 0x20000000
#define SEC_WRITECOMBINE 0x40000000
#define SEC_LARGE_PAGES 0x80000000
#define SEC_IMAGE_NO_EXECUTE (SEC_IMAGE | SEC_NOCACHE)
#if (PHNT_MODE == PHNT_MODE_KERNEL)
#define MEM_IMAGE SEC_IMAGE
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
// private
typedef enum _MEMORY_INFORMATION_CLASS
{
    MemoryBasicInformation, // MEMORY_BASIC_INFORMATION
    MemoryWorkingSetInformation, // MEMORY_WORKING_SET_INFORMATION
    MemoryMappedFilenameInformation, // UNICODE_STRING
    MemoryRegionInformation, // MEMORY_REGION_INFORMATION
    MemoryWorkingSetExInformation, // MEMORY_WORKING_SET_EX_INFORMATION // since VISTA
    MemorySharedCommitInformation, // MEMORY_SHARED_COMMIT_INFORMATION // since WIN8
    MemoryImageInformation, // MEMORY_IMAGE_INFORMATION
    MemoryRegionInformationEx, // MEMORY_REGION_INFORMATION
    MemoryPrivilegedBasicInformation,
    MemoryEnclaveImageInformation, // MEMORY_ENCLAVE_IMAGE_INFORMATION // since REDSTONE3
    MemoryBasicInformationCapped, // 10
    MemoryPhysicalContiguityInformation, // MEMORY_PHYSICAL_CONTIGUITY_INFORMATION // since 20H1
    MemoryBadInformation, // since WIN11
    MemoryBadInformationAllProcesses, // since 22H1
    MaxMemoryInfoClass
} MEMORY_INFORMATION_CLASS;
#else
#define MemoryBasicInformation 0x0
#define MemoryWorkingSetInformation 0x1
#define MemoryMappedFilenameInformation 0x2
#define MemoryRegionInformation 0x3
#define MemoryWorkingSetExInformation 0x4
#define MemorySharedCommitInformation 0x5
#define MemoryImageInformation 0x6
#define MemoryRegionInformationEx 0x7
#define MemoryPrivilegedBasicInformation 0x8
#define MemoryEnclaveImageInformation 0x9
#define MemoryBasicInformationCapped 0xA
#define MemoryPhysicalContiguityInformation 0xB
#define MemoryBadInformation 0xC
#define MemoryBadInformationAllProcesses 0xD
#endif

typedef struct _MEMORY_WORKING_SET_BLOCK
{
    ULONG_PTR Protection : 5;
    ULONG_PTR ShareCount : 3;
    ULONG_PTR Shared : 1;
    ULONG_PTR Node : 3;
#ifdef _WIN64
    ULONG_PTR VirtualPage : 52;
#else
    ULONG VirtualPage : 20;
#endif
} MEMORY_WORKING_SET_BLOCK, *PMEMORY_WORKING_SET_BLOCK;

typedef struct _MEMORY_WORKING_SET_INFORMATION
{
    ULONG_PTR NumberOfEntries;
    MEMORY_WORKING_SET_BLOCK WorkingSetInfo[1];
} MEMORY_WORKING_SET_INFORMATION, *PMEMORY_WORKING_SET_INFORMATION;

// private
typedef struct _MEMORY_REGION_INFORMATION
{
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union
    {
        ULONG RegionType;
        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG SoftwareEnclave : 1; // REDSTONE3
            ULONG PageSize64K : 1;
            ULONG PlaceholderReservation : 1; // REDSTONE4
            ULONG MappedAwe : 1; // 21H1
            ULONG MappedWriteWatch : 1;
            ULONG PageSizeLarge : 1;
            ULONG PageSizeHuge : 1;
            ULONG Reserved : 19;
        };
    };
    SIZE_T RegionSize;
    SIZE_T CommitSize;
    ULONG_PTR PartitionId; // 19H1
    ULONG_PTR NodePreference; // 20H1
} MEMORY_REGION_INFORMATION, *PMEMORY_REGION_INFORMATION;

// private
typedef enum _MEMORY_WORKING_SET_EX_LOCATION
{
    MemoryLocationInvalid,
    MemoryLocationResident,
    MemoryLocationPagefile,
    MemoryLocationReserved
} MEMORY_WORKING_SET_EX_LOCATION;

// private
typedef struct _MEMORY_WORKING_SET_EX_BLOCK
{
    union
    {
        struct
        {
            ULONG_PTR Valid : 1;
            ULONG_PTR ShareCount : 3;
            ULONG_PTR Win32Protection : 11;
            ULONG_PTR Shared : 1;
            ULONG_PTR Node : 6;
            ULONG_PTR Locked : 1;
            ULONG_PTR LargePage : 1;
            ULONG_PTR Priority : 3;
            ULONG_PTR Reserved : 3;
            ULONG_PTR SharedOriginal : 1;
            ULONG_PTR Bad : 1;
            ULONG_PTR Win32GraphicsProtection : 4; // 19H1
#ifdef _WIN64
            ULONG_PTR ReservedUlong : 28;
#endif
        };
        struct
        {
            ULONG_PTR Valid : 1;
            ULONG_PTR Reserved0 : 14;
            ULONG_PTR Shared : 1;
            ULONG_PTR Reserved1 : 5;
            ULONG_PTR PageTable : 1;
            ULONG_PTR Location : 2;
            ULONG_PTR Priority : 3;
            ULONG_PTR ModifiedList : 1;
            ULONG_PTR Reserved2 : 2;
            ULONG_PTR SharedOriginal : 1;
            ULONG_PTR Bad : 1;
#ifdef _WIN64
            ULONG_PTR ReservedUlong : 32;
#endif
        } Invalid;
    };
} MEMORY_WORKING_SET_EX_BLOCK, *PMEMORY_WORKING_SET_EX_BLOCK;

// private
typedef struct _MEMORY_WORKING_SET_EX_INFORMATION
{
    PVOID VirtualAddress;
    union
    {
        MEMORY_WORKING_SET_EX_BLOCK VirtualAttributes;
        ULONG_PTR Long;
    } u1;
} MEMORY_WORKING_SET_EX_INFORMATION, *PMEMORY_WORKING_SET_EX_INFORMATION;

// private
typedef struct _MEMORY_SHARED_COMMIT_INFORMATION
{
    SIZE_T CommitSize;
} MEMORY_SHARED_COMMIT_INFORMATION, *PMEMORY_SHARED_COMMIT_INFORMATION;

// private
typedef struct _MEMORY_IMAGE_INFORMATION
{
    PVOID ImageBase;
    SIZE_T SizeOfImage;
    union
    {
        ULONG ImageFlags;
        struct
        {
            ULONG ImagePartialMap : 1;
            ULONG ImageNotExecutable : 1;
            ULONG ImageSigningLevel : 4; // REDSTONE3
            ULONG Reserved : 26;
        };
    };
} MEMORY_IMAGE_INFORMATION, *PMEMORY_IMAGE_INFORMATION;

// private
typedef struct _MEMORY_ENCLAVE_IMAGE_INFORMATION
{
    MEMORY_IMAGE_INFORMATION ImageInfo;
    UCHAR UniqueID[32];
    UCHAR AuthorID[32];
} MEMORY_ENCLAVE_IMAGE_INFORMATION, *PMEMORY_ENCLAVE_IMAGE_INFORMATION;

// private
typedef enum _MEMORY_PHYSICAL_CONTIGUITY_UNIT_STATE
{
    MemoryNotContiguous,
    MemoryAlignedAndContiguous,
    MemoryNotResident,
    MemoryNotEligibleToMakeContiguous,
    MemoryContiguityStateMax,
} MEMORY_PHYSICAL_CONTIGUITY_UNIT_STATE;

// private
typedef struct _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION
{
    union
    {
        struct
        {
            ULONG State : 2;
            ULONG Reserved : 30;
        };
        ULONG AllInformation;
    };
} MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION, *PMEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION;

// private
typedef struct _MEMORY_PHYSICAL_CONTIGUITY_INFORMATION
{
    PVOID VirtualAddress;
    ULONG_PTR Size;
    ULONG_PTR ContiguityUnitSize;
    ULONG Flags;
    PMEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION ContiguityUnitInformation;
} MEMORY_PHYSICAL_CONTIGUITY_INFORMATION, *PMEMORY_PHYSICAL_CONTIGUITY_INFORMATION;

#define MMPFNLIST_ZERO 0
#define MMPFNLIST_FREE 1
#define MMPFNLIST_STANDBY 2
#define MMPFNLIST_MODIFIED 3
#define MMPFNLIST_MODIFIEDNOWRITE 4
#define MMPFNLIST_BAD 5
#define MMPFNLIST_ACTIVE 6
#define MMPFNLIST_TRANSITION 7

//typedef enum _MMLISTS
//{
//    ZeroedPageList = 0,
//    FreePageList = 1,
//    StandbyPageList = 2,
//    ModifiedPageList = 3,
//    ModifiedNoWritePageList = 4,
//    BadPageList = 5,
//    ActiveAndValid = 6,
//    TransitionPage = 7
//} MMLISTS;

#define MMPFNUSE_PROCESSPRIVATE 0
#define MMPFNUSE_FILE 1
#define MMPFNUSE_PAGEFILEMAPPED 2
#define MMPFNUSE_PAGETABLE 3
#define MMPFNUSE_PAGEDPOOL 4
#define MMPFNUSE_NONPAGEDPOOL 5
#define MMPFNUSE_SYSTEMPTE 6
#define MMPFNUSE_SESSIONPRIVATE 7
#define MMPFNUSE_METAFILE 8
#define MMPFNUSE_AWEPAGE 9
#define MMPFNUSE_DRIVERLOCKPAGE 10
#define MMPFNUSE_KERNELSTACK 11

//typedef enum _MMPFNUSE
//{
//    ProcessPrivatePage,
//    MemoryMappedFilePage,
//    PageFileMappedPage,
//    PageTablePage,
//    PagedPoolPage,
//    NonPagedPoolPage,
//    SystemPTEPage,
//    SessionPrivatePage,
//    MetafilePage,
//    AWEPage,
//    DriverLockedPage,
//    KernelStackPage
//} MMPFNUSE;

// private
typedef struct _MEMORY_FRAME_INFORMATION
{
    ULONGLONG UseDescription : 4; // MMPFNUSE_*
    ULONGLONG ListDescription : 3; // MMPFNLIST_*
    ULONGLONG Cold : 1; // 19H1
    ULONGLONG Pinned : 1; // 1 - pinned, 0 - not pinned
    ULONGLONG DontUse : 48; // *_INFORMATION overlay
    ULONGLONG Priority : 3;
    ULONGLONG NonTradeable : 1;
    ULONGLONG Reserved : 3;
} MEMORY_FRAME_INFORMATION;

// private
typedef struct _FILEOFFSET_INFORMATION
{
    ULONGLONG DontUse : 9; // MEMORY_FRAME_INFORMATION overlay
    ULONGLONG Offset : 48; // mapped files
    ULONGLONG Reserved : 7;
} FILEOFFSET_INFORMATION;

// private
typedef struct _PAGEDIR_INFORMATION
{
    ULONGLONG DontUse : 9; // MEMORY_FRAME_INFORMATION overlay
    ULONGLONG PageDirectoryBase : 48; // private pages
    ULONGLONG Reserved : 7;
} PAGEDIR_INFORMATION;

// private
typedef struct _UNIQUE_PROCESS_INFORMATION
{
    ULONGLONG DontUse : 9; // MEMORY_FRAME_INFORMATION overlay
    ULONGLONG UniqueProcessKey : 48; // ProcessId
    ULONGLONG Reserved  : 7;
} UNIQUE_PROCESS_INFORMATION, *PUNIQUE_PROCESS_INFORMATION;

// private
typedef struct _MMPFN_IDENTITY
{
    union
    {
        MEMORY_FRAME_INFORMATION e1; // all
        FILEOFFSET_INFORMATION e2; // mapped files
        PAGEDIR_INFORMATION e3; // private pages
        UNIQUE_PROCESS_INFORMATION e4; // owning process
    } u1;
    ULONG_PTR PageFrameIndex; // all
    union
    {
        struct
        {
            ULONG_PTR Image : 1;
            ULONG_PTR Mismatch : 1;
        } e1;
        struct
        {
            ULONG_PTR CombinedPage;
        } e2;
        ULONG_PTR FileObject; // mapped files
        ULONG_PTR UniqueFileObjectKey;
        ULONG_PTR ProtoPteAddress;
        ULONG_PTR VirtualAddress;  // everything else
    } u2;
} MMPFN_IDENTITY, *PMMPFN_IDENTITY;

typedef struct _MMPFN_MEMSNAP_INFORMATION
{
    ULONG_PTR InitialPageFrameIndex;
    ULONG_PTR Count;
} MMPFN_MEMSNAP_INFORMATION, *PMMPFN_MEMSNAP_INFORMATION;

typedef enum _SECTION_INFORMATION_CLASS
{
    SectionBasicInformation, // q; SECTION_BASIC_INFORMATION
    SectionImageInformation, // q; SECTION_IMAGE_INFORMATION
    SectionRelocationInformation, // q; PVOID RelocationAddress // name:wow64:whNtQuerySection_SectionRelocationInformation // since WIN7
    SectionOriginalBaseInformation, // PVOID BaseAddress
    SectionInternalImageInformation, // SECTION_INTERNAL_IMAGE_INFORMATION // since REDSTONE2
    MaxSectionInfoClass
} SECTION_INFORMATION_CLASS;

typedef struct _SECTION_BASIC_INFORMATION
{
    PVOID BaseAddress;
    ULONG AllocationAttributes;
    LARGE_INTEGER MaximumSize;
} SECTION_BASIC_INFORMATION, *PSECTION_BASIC_INFORMATION;

// symbols
typedef struct _SECTION_IMAGE_INFORMATION
{
    PVOID TransferAddress;
    ULONG ZeroBits;
    SIZE_T MaximumStackSize;
    SIZE_T CommittedStackSize;
    ULONG SubSystemType;
    union
    {
        struct
        {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };
        ULONG SubSystemVersion;
    };
    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;
            USHORT MinorOperatingSystemVersion;
        };
        ULONG OperatingSystemVersion;
    };
    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    USHORT Machine;
    BOOLEAN ImageContainsCode;
    union
    {
        UCHAR ImageFlags;
        struct
        {
            UCHAR ComPlusNativeReady : 1;
            UCHAR ComPlusILOnly : 1;
            UCHAR ImageDynamicallyRelocated : 1;
            UCHAR ImageMappedFlat : 1;
            UCHAR BaseBelow4gb : 1;
            UCHAR ComPlusPrefer32bit : 1;
            UCHAR Reserved : 2;
        };
    };
    ULONG LoaderFlags;
    ULONG ImageFileSize;
    ULONG CheckSum;
} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;

// symbols
typedef struct _SECTION_INTERNAL_IMAGE_INFORMATION
{
    SECTION_IMAGE_INFORMATION SectionInformation;
    union
    {
        ULONG ExtendedFlags;
        struct
        {
            ULONG ImageExportSuppressionEnabled : 1;
            ULONG ImageCetShadowStacksReady : 1; // 20H1
            ULONG ImageXfgEnabled : 1; // 20H2
            ULONG ImageCetShadowStacksStrictMode : 1;
            ULONG ImageCetSetContextIpValidationRelaxedMode : 1;
            ULONG ImageCetDynamicApisAllowInProc : 1;
            ULONG ImageCetDowngradeReserved1 : 1;
            ULONG ImageCetDowngradeReserved2 : 1;
            ULONG Reserved : 24;
        };
    };
} SECTION_INTERNAL_IMAGE_INFORMATION, *PSECTION_INTERNAL_IMAGE_INFORMATION;

#if (PHNT_MODE != PHNT_MODE_KERNEL)
typedef enum _SECTION_INHERIT
{
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;
#endif

#define MEM_EXECUTE_OPTION_ENABLE 0x1
#define MEM_EXECUTE_OPTION_DISABLE 0x2
#define MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION 0x4
#define MEM_EXECUTE_OPTION_PERMANENT 0x8
#define MEM_EXECUTE_OPTION_EXECUTE_DISPATCH_ENABLE 0x10
#define MEM_EXECUTE_OPTION_IMAGE_DISPATCH_ENABLE 0x20
#define MEM_EXECUTE_OPTION_VALID_FLAGS 0x3f

// Virtual memory

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect
    );

#if (PHNT_VERSION >= PHNT_REDSTONE5)
NTSYSAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemoryEx(
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG AllocationType,
    _In_ ULONG PageProtection,
    _Inout_updates_opt_(ExtendedParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreeVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG FreeType
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _Out_writes_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead
    );

#if (PHNT_VERSION >= PHNT_WIN11)
// rev
NTSYSAPI
NTSTATUS
NTAPI
NtReadVirtualMemoryEx(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _Out_writes_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead,
    _In_ ULONG Flags
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesWritten
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtProtectVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG NewProtect,
    _Out_ PULONG OldProtect
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass,
    _Out_writes_bytes_(MemoryInformationLength) PVOID MemoryInformation,
    _In_ SIZE_T MemoryInformationLength,
    _Out_opt_ PSIZE_T ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _Out_ struct _IO_STATUS_BLOCK* IoStatus
    );

#endif

// begin_private
#if (PHNT_MODE != PHNT_MODE_KERNEL)
typedef enum _VIRTUAL_MEMORY_INFORMATION_CLASS
{
    VmPrefetchInformation, // ULONG
    VmPagePriorityInformation, // OFFER_PRIORITY
    VmCfgCallTargetInformation, // CFG_CALL_TARGET_LIST_INFORMATION // REDSTONE2
    VmPageDirtyStateInformation, // REDSTONE3
    VmImageHotPatchInformation, // 19H1
    VmPhysicalContiguityInformation, // 20H1
    VmVirtualMachinePrepopulateInformation,
    VmRemoveFromWorkingSetInformation,
    MaxVmInfoClass
} VIRTUAL_MEMORY_INFORMATION_CLASS;

typedef struct _MEMORY_RANGE_ENTRY
{
    PVOID VirtualAddress;
    SIZE_T NumberOfBytes;
} MEMORY_RANGE_ENTRY, *PMEMORY_RANGE_ENTRY;

typedef struct _CFG_CALL_TARGET_LIST_INFORMATION
{
    ULONG NumberOfEntries;
    ULONG Reserved;
    PULONG NumberOfEntriesProcessed;
    PCFG_CALL_TARGET_INFO CallTargetInfo;
    PVOID Section; // since REDSTONE5
    ULONGLONG FileOffset;
} CFG_CALL_TARGET_LIST_INFORMATION, *PCFG_CALL_TARGET_LIST_INFORMATION;
#endif
// end_private

#if (PHNT_MODE != PHNT_MODE_KERNEL)

#if (PHNT_VERSION >= PHNT_WIN8)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_ VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass,
    _In_ ULONG_PTR NumberOfEntries,
    _In_reads_ (NumberOfEntries) PMEMORY_RANGE_ENTRY VirtualAddresses,
    _In_reads_bytes_ (VmInformationLength) PVOID VmInformation,
    _In_ ULONG VmInformationLength
    );

#endif

#define MAP_PROCESS 1
#define MAP_SYSTEM 2

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnlockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType
    );

#endif

// Sections

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle
    );

#if (PHNT_VERSION >= PHNT_REDSTONE5)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSectionEx(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle,
    _Inout_updates_opt_(ExtendedParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMapViewOfSection(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T CommitSize,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ SECTION_INHERIT InheritDisposition,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect
    );

#if (PHNT_VERSION >= PHNT_REDSTONE5)
NTSYSAPI
NTSTATUS
NTAPI
NtMapViewOfSectionEx(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID *BaseAddress,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect,
    _Inout_updates_opt_(ParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnmapViewOfSection(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress
    );

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnmapViewOfSectionEx(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ ULONG Flags
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtExtendSection(
    _In_ HANDLE SectionHandle,
    _Inout_ PLARGE_INTEGER NewSectionSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySection(
    _In_ HANDLE SectionHandle,
    _In_ SECTION_INFORMATION_CLASS SectionInformationClass,
    _Out_writes_bytes_(SectionInformationLength) PVOID SectionInformation,
    _In_ SIZE_T SectionInformationLength,
    _Out_opt_ PSIZE_T ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAreMappedFilesTheSame(
    _In_ PVOID File1MappedAsAnImage,
    _In_ PVOID File2MappedAsFile
    );

#endif

// Partitions

#ifndef MEMORY_PARTITION_QUERY_ACCESS
#define MEMORY_PARTITION_QUERY_ACCESS 0x0001
#define MEMORY_PARTITION_MODIFY_ACCESS 0x0002
#define MEMORY_PARTITION_ALL_ACCESS \
    (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
     MEMORY_PARTITION_QUERY_ACCESS | MEMORY_PARTITION_MODIFY_ACCESS)
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
// private
typedef enum _PARTITION_INFORMATION_CLASS
{
    SystemMemoryPartitionInformation, // q: MEMORY_PARTITION_CONFIGURATION_INFORMATION
    SystemMemoryPartitionMoveMemory, // s: MEMORY_PARTITION_TRANSFER_INFORMATION
    SystemMemoryPartitionAddPagefile, // s: MEMORY_PARTITION_PAGEFILE_INFORMATION
    SystemMemoryPartitionCombineMemory, // q; s: MEMORY_PARTITION_PAGE_COMBINE_INFORMATION
    SystemMemoryPartitionInitialAddMemory, // q; s: MEMORY_PARTITION_INITIAL_ADD_INFORMATION
    SystemMemoryPartitionGetMemoryEvents, // MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION // since REDSTONE2
    SystemMemoryPartitionSetAttributes,
    SystemMemoryPartitionNodeInformation,
    SystemMemoryPartitionCreateLargePages,
    SystemMemoryPartitionDedicatedMemoryInformation,
    SystemMemoryPartitionOpenDedicatedMemory, // 10
    SystemMemoryPartitionMemoryChargeAttributes,
    SystemMemoryPartitionClearAttributes,
    SystemMemoryPartitionSetMemoryThresholds, // since WIN11
    SystemMemoryPartitionMax
} PARTITION_INFORMATION_CLASS, *PPARTITION_INFORMATION_CLASS;
#else
#define SystemMemoryPartitionInformation 0x0
#define SystemMemoryPartitionMoveMemory 0x1
#define SystemMemoryPartitionAddPagefile 0x2
#define SystemMemoryPartitionCombineMemory 0x3
#define SystemMemoryPartitionInitialAddMemory 0x4
#define SystemMemoryPartitionGetMemoryEvents 0x5
#define SystemMemoryPartitionSetAttributes 0x6
#define SystemMemoryPartitionNodeInformation 0x7
#define SystemMemoryPartitionCreateLargePages 0x8
#define SystemMemoryPartitionDedicatedMemoryInformation 0x9
#define SystemMemoryPartitionOpenDedicatedMemory 0xA
#define SystemMemoryPartitionMemoryChargeAttributes 0xB
#define SystemMemoryPartitionClearAttributes 0xC
#define SystemMemoryPartitionSetMemoryThresholds 0xD
#define SystemMemoryPartitionMax 0xE
#endif

// private
typedef struct _MEMORY_PARTITION_CONFIGURATION_INFORMATION
{
    ULONG Flags;
    ULONG NumaNode;
    ULONG Channel;
    ULONG NumberOfNumaNodes;
    ULONG_PTR ResidentAvailablePages;
    ULONG_PTR CommittedPages;
    ULONG_PTR CommitLimit;
    ULONG_PTR PeakCommitment;
    ULONG_PTR TotalNumberOfPages;
    ULONG_PTR AvailablePages;
    ULONG_PTR ZeroPages;
    ULONG_PTR FreePages;
    ULONG_PTR StandbyPages;
    ULONG_PTR StandbyPageCountByPriority[8]; // since REDSTONE2
    ULONG_PTR RepurposedPagesByPriority[8];
    ULONG_PTR MaximumCommitLimit;
    ULONG_PTR Reserved; // DonatedPagesToPartitions
    ULONG PartitionId; // since REDSTONE3
} MEMORY_PARTITION_CONFIGURATION_INFORMATION, *PMEMORY_PARTITION_CONFIGURATION_INFORMATION;

// private
typedef struct _MEMORY_PARTITION_TRANSFER_INFORMATION
{
    ULONG_PTR NumberOfPages;
    ULONG NumaNode;
    ULONG Flags;
} MEMORY_PARTITION_TRANSFER_INFORMATION, *PMEMORY_PARTITION_TRANSFER_INFORMATION;

// private
typedef struct _MEMORY_PARTITION_PAGEFILE_INFORMATION
{
    UNICODE_STRING PageFileName;
    LARGE_INTEGER MinimumSize;
    LARGE_INTEGER MaximumSize;
    ULONG Flags;
} MEMORY_PARTITION_PAGEFILE_INFORMATION, *PMEMORY_PARTITION_PAGEFILE_INFORMATION;

// private
typedef struct _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION
{
    HANDLE StopHandle;
    ULONG Flags;
    ULONG_PTR TotalNumberOfPages;
} MEMORY_PARTITION_PAGE_COMBINE_INFORMATION, *PMEMORY_PARTITION_PAGE_COMBINE_INFORMATION;

// private
typedef struct _MEMORY_PARTITION_PAGE_RANGE
{
    ULONG_PTR StartPage;
    ULONG_PTR NumberOfPages;
} MEMORY_PARTITION_PAGE_RANGE, *PMEMORY_PARTITION_PAGE_RANGE;

// private
typedef struct _MEMORY_PARTITION_INITIAL_ADD_INFORMATION
{
    ULONG Flags;
    ULONG NumberOfRanges;
    ULONG_PTR NumberOfPagesAdded;
    MEMORY_PARTITION_PAGE_RANGE PartitionRanges[1];
} MEMORY_PARTITION_INITIAL_ADD_INFORMATION, *PMEMORY_PARTITION_INITIAL_ADD_INFORMATION;

// private
typedef struct _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION
{
    union
    {
        struct
        {
            ULONG CommitEvents : 1;
            ULONG Spare : 31;
        };
        ULONG AllFlags;
    } Flags;

    ULONG HandleAttributes;
    ULONG DesiredAccess;
    HANDLE LowCommitCondition; // \KernelObjects\LowCommitCondition
    HANDLE HighCommitCondition; // \KernelObjects\HighCommitCondition
    HANDLE MaximumCommitCondition; // \KernelObjects\MaximumCommitCondition
} MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION, *PMEMORY_PARTITION_MEMORY_EVENTS_INFORMATION;

#if (PHNT_MODE != PHNT_MODE_KERNEL)

#if (PHNT_VERSION >= PHNT_THRESHOLD)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreatePartition(
    _In_ HANDLE ParentPartitionHandle,
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG PreferredNode
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenPartition(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtManagePartition(
    _In_ HANDLE TargetHandle,
    _In_opt_ HANDLE SourceHandle,
    _In_ PARTITION_INFORMATION_CLASS PartitionInformationClass,
    _Inout_updates_bytes_(PartitionInformationLength) PVOID PartitionInformation,
    _In_ ULONG PartitionInformationLength
    );

#endif

#endif

// User physical pages

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPages(
    _In_ PVOID VirtualAddress,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPagesScatter(
    _In_reads_(NumberOfPages) PVOID *VirtualAddresses,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _Out_writes_(*NumberOfPages) PULONG_PTR UserPfnArray
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateUserPhysicalPagesEx(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _Out_writes_(*NumberOfPages) PULONG_PTR UserPfnArray,
    _Inout_updates_opt_(ParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreeUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _In_reads_(*NumberOfPages) PULONG_PTR UserPfnArray
    );

#endif

// Misc.

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetWriteWatch(
    _In_ HANDLE ProcessHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress,
    _In_ SIZE_T RegionSize,
    _Out_writes_(*EntriesInUserAddressArray) PVOID *UserAddressArray,
    _Inout_ PULONG_PTR EntriesInUserAddressArray,
    _Out_ PULONG Granularity
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtResetWriteWatch(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_ SIZE_T RegionSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreatePagingFile(
    _In_ PUNICODE_STRING PageFileName,
    _In_ PLARGE_INTEGER MinimumSize,
    _In_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG Priority
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushInstructionCache(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ SIZE_T Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushWriteBuffer(
    VOID
    );

#endif

// Enclave support

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateEnclave(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T Size,
    _In_ SIZE_T InitialCommitment,
    _In_ ULONG EnclaveType,
    _In_reads_bytes_(EnclaveInformationLength) PVOID EnclaveInformation,
    _In_ ULONG EnclaveInformationLength,
    _Out_opt_ PULONG EnclaveError
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadEnclaveData(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _In_ ULONG Protect,
    _In_reads_bytes_(PageInformationLength) PVOID PageInformation,
    _In_ ULONG PageInformationLength,
    _Out_opt_ PSIZE_T NumberOfBytesWritten,
    _Out_opt_ PULONG EnclaveError
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtInitializeEnclave(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_reads_bytes_(EnclaveInformationLength) PVOID EnclaveInformation,
    _In_ ULONG EnclaveInformationLength,
    _Out_opt_ PULONG EnclaveError
    );

// rev
NTSYSCALLAPI
NTSTATUS
NTAPI
NtTerminateEnclave(
    _In_ PVOID BaseAddress,
    _In_ BOOLEAN WaitForThread
    );

#if (PHNT_MODE != PHNT_MODE_KERNEL)
// rev
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCallEnclave(
    _In_ PENCLAVE_ROUTINE Routine,
    _In_ PVOID Parameter,
    _In_ BOOLEAN WaitForThread,
    _Out_opt_ PVOID *ReturnValue
    );
#endif

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTOBAPI_H
#define _NTOBAPI_H

#if (PHNT_MODE != PHNT_MODE_KERNEL)
#define OBJECT_TYPE_CREATE 0x0001
#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
#define DIRECTORY_QUERY 0x0001
#define DIRECTORY_TRAVERSE 0x0002
#define DIRECTORY_CREATE_OBJECT 0x0004
#define DIRECTORY_CREATE_SUBDIRECTORY 0x0008
#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xf)
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
#define SYMBOLIC_LINK_QUERY 0x0001
#define SYMBOLIC_LINK_SET 0x0002
#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)
#define SYMBOLIC_LINK_ALL_ACCESS_EX (STANDARD_RIGHTS_REQUIRED | 0xFFFF)
#endif

#ifndef OBJ_PROTECT_CLOSE
#define OBJ_PROTECT_CLOSE 0x00000001
#endif
#ifndef OBJ_INHERIT
#define OBJ_INHERIT 0x00000002
#endif
#ifndef OBJ_AUDIT_OBJECT_CLOSE
#define OBJ_AUDIT_OBJECT_CLOSE 0x00000004
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
typedef enum _OBJECT_INFORMATION_CLASS
{
    ObjectBasicInformation, // q: OBJECT_BASIC_INFORMATION
    ObjectNameInformation, // q: OBJECT_NAME_INFORMATION
    ObjectTypeInformation, // q: OBJECT_TYPE_INFORMATION
    ObjectTypesInformation, // q: OBJECT_TYPES_INFORMATION
    ObjectHandleFlagInformation, // qs: OBJECT_HANDLE_FLAG_INFORMATION
    ObjectSessionInformation, // s: void // change object session // (requires SeTcbPrivilege)
    ObjectSessionObjectInformation, // s: void // change object session // (requires SeTcbPrivilege)
    MaxObjectInfoClass
} OBJECT_INFORMATION_CLASS;
#else
#define ObjectBasicInformation 0
#define ObjectNameInformation 1
#define ObjectTypeInformation 2
#define ObjectTypesInformation 3
#define ObjectHandleFlagInformation 4
#define ObjectSessionInformation 5
#define ObjectSessionObjectInformation 6
#endif

typedef struct _OBJECT_BASIC_INFORMATION
{
    ULONG Attributes;
    ACCESS_MASK GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG Reserved[3];
    ULONG NameInfoSize;
    ULONG TypeInfoSize;
    ULONG SecurityDescriptorSize;
    LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

#if (PHNT_MODE != PHNT_MODE_KERNEL)
typedef struct _OBJECT_NAME_INFORMATION
{
    UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;
#endif

typedef struct _OBJECT_TYPE_INFORMATION
{
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    UCHAR TypeIndex; // since WINBLUE
    CHAR ReservedByte;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_TYPES_INFORMATION
{
    ULONG NumberOfTypes;
} OBJECT_TYPES_INFORMATION, *POBJECT_TYPES_INFORMATION;

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION
{
    BOOLEAN Inherit;
    BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

// Objects, handles

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryObject(
    _In_opt_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _Out_writes_bytes_opt_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationObject(
    _In_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _In_reads_bytes_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength
    );

#define DUPLICATE_CLOSE_SOURCE 0x00000001
#define DUPLICATE_SAME_ACCESS 0x00000002
#define DUPLICATE_SAME_ATTRIBUTES 0x00000004

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDuplicateObject(
    _In_ HANDLE SourceProcessHandle,
    _In_ HANDLE SourceHandle,
    _In_opt_ HANDLE TargetProcessHandle,
    _Out_opt_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMakeTemporaryObject(
    _In_ HANDLE Handle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMakePermanentObject(
    _In_ HANDLE Handle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSignalAndWaitForSingleObject(
    _In_ HANDLE SignalHandle,
    _In_ HANDLE WaitHandle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForSingleObject(
    _In_ HANDLE Handle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForMultipleObjects(
    _In_ ULONG Count,
    _In_reads_(Count) HANDLE Handles[],
    _In_ WAIT_TYPE WaitType,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForMultipleObjects32(
    _In_ ULONG Count,
    _In_reads_(Count) LONG Handles[],
    _In_ WAIT_TYPE WaitType,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _Out_writes_bytes_opt_(Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Length,
    _Out_ PULONG LengthNeeded
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtClose(
    _In_ _Post_ptr_invalid_ HANDLE Handle
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompareObjects(
    _In_ HANDLE FirstObjectHandle,
    _In_ HANDLE SecondObjectHandle
    );
#endif

#endif

// Directory objects

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateDirectoryObjectEx(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ShadowDirectoryHandle,
    _In_ ULONG Flags
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

typedef struct _OBJECT_DIRECTORY_INFORMATION
{
    UNICODE_STRING Name;
    UNICODE_STRING TypeName;
} OBJECT_DIRECTORY_INFORMATION, *POBJECT_DIRECTORY_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDirectoryObject(
    _In_ HANDLE DirectoryHandle,
    _Out_writes_bytes_opt_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_ BOOLEAN RestartScan,
    _Inout_ PULONG Context,
    _Out_opt_ PULONG ReturnLength
    );

#endif

// Private namespaces

#if (PHNT_MODE != PHNT_MODE_KERNEL)

#if (PHNT_VERSION >= PHNT_VISTA)

// private
typedef enum _BOUNDARY_ENTRY_TYPE
{
    OBNS_Invalid,
    OBNS_Name,
    OBNS_SID,
    OBNS_IL
} BOUNDARY_ENTRY_TYPE;

// private
typedef struct _OBJECT_BOUNDARY_ENTRY
{
    BOUNDARY_ENTRY_TYPE EntryType;
    ULONG EntrySize;
} OBJECT_BOUNDARY_ENTRY, *POBJECT_BOUNDARY_ENTRY;

// rev
#define OBJECT_BOUNDARY_DESCRIPTOR_VERSION 1

// private
typedef struct _OBJECT_BOUNDARY_DESCRIPTOR
{
    ULONG Version;
    ULONG Items;
    ULONG TotalSize;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG AddAppContainerSid : 1;
            ULONG Reserved : 31;
        };
    };
} OBJECT_BOUNDARY_DESCRIPTOR, *POBJECT_BOUNDARY_DESCRIPTOR;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreatePrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ POBJECT_BOUNDARY_DESCRIPTOR BoundaryDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenPrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ POBJECT_BOUNDARY_DESCRIPTOR BoundaryDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeletePrivateNamespace(
    _In_ HANDLE NamespaceHandle
    );

#endif

#endif

// Symbolic links

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PUNICODE_STRING LinkTarget
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySymbolicLinkObject(
    _In_ HANDLE LinkHandle,
    _Inout_ PUNICODE_STRING LinkTarget,
    _Out_opt_ PULONG ReturnedLength
    );

typedef enum _SYMBOLIC_LINK_INFO_CLASS
{
    SymbolicLinkGlobalInformation = 1, // s: ULONG
    SymbolicLinkAccessMask, // s: ACCESS_MASK
    MaxnSymbolicLinkInfoClass
} SYMBOLIC_LINK_INFO_CLASS;

#if (PHNT_VERSION >= PHNT_THRESHOLD)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationSymbolicLink(
    _In_ HANDLE LinkHandle,
    _In_ SYMBOLIC_LINK_INFO_CLASS SymbolicLinkInformationClass,
    _In_reads_bytes_(SymbolicLinkInformationLength) PVOID SymbolicLinkInformation,
    _In_ ULONG SymbolicLinkInformationLength
    );
#endif

#endif

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTPSAPI_H
#define _NTPSAPI_H

#if (PHNT_MODE == PHNT_MODE_KERNEL)
#define PROCESS_TERMINATE 0x0001
#define PROCESS_CREATE_THREAD 0x0002
#define PROCESS_SET_SESSIONID 0x0004
#define PROCESS_VM_OPERATION 0x0008
#define PROCESS_VM_READ 0x0010
#define PROCESS_VM_WRITE 0x0020
//#define PROCESS_DUP_HANDLE 0x0040
#define PROCESS_CREATE_PROCESS 0x0080
#define PROCESS_SET_QUOTA 0x0100
#define PROCESS_SET_INFORMATION 0x0200
#define PROCESS_QUERY_INFORMATION 0x0400
#define PROCESS_SET_PORT 0x0800
#define PROCESS_SUSPEND_RESUME 0x0800
#define PROCESS_QUERY_LIMITED_INFORMATION 0x1000
#else
#ifndef PROCESS_SET_PORT
#define PROCESS_SET_PORT 0x0800
#endif
#endif

#if (PHNT_MODE == PHNT_MODE_KERNEL)
#define THREAD_QUERY_INFORMATION 0x0040
#define THREAD_SET_THREAD_TOKEN 0x0080
#define THREAD_IMPERSONATE 0x0100
#define THREAD_DIRECT_IMPERSONATION 0x0200
#else
#ifndef THREAD_ALERT
#define THREAD_ALERT 0x0004
#endif
#endif

#if (PHNT_MODE == PHNT_MODE_KERNEL)
#define JOB_OBJECT_ASSIGN_PROCESS 0x0001
#define JOB_OBJECT_SET_ATTRIBUTES 0x0002
#define JOB_OBJECT_QUERY 0x0004
#define JOB_OBJECT_TERMINATE 0x0008
#define JOB_OBJECT_SET_SECURITY_ATTRIBUTES 0x0010
#define JOB_OBJECT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x3F)
//#define JOB_OBJECT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1f) // pre-Vista full access
#endif

#define GDI_HANDLE_BUFFER_SIZE32 34
#define GDI_HANDLE_BUFFER_SIZE64 60

#ifndef _WIN64
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE64
#endif

typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];

#ifndef FLS_MAXIMUM_AVAILABLE
#define FLS_MAXIMUM_AVAILABLE 128
#endif
#ifndef TLS_MINIMUM_AVAILABLE
#define TLS_MINIMUM_AVAILABLE 64
#endif
#ifndef TLS_EXPANSION_SLOTS
#define TLS_EXPANSION_SLOTS 1024
#endif

// symbols
typedef struct _PEB_LDR_DATA
{
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID EntryInProgress;
    BOOLEAN ShutdownInProgress;
    HANDLE ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _INITIAL_TEB
{
    struct
    {
        PVOID OldStackBase;
        PVOID OldStackLimit;
    } OldInitialTeb;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID StackAllocationBase;
} INITIAL_TEB, *PINITIAL_TEB;

typedef struct _WOW64_PROCESS
{
    PVOID Wow64;
} WOW64_PROCESS, *PWOW64_PROCESS;

/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTPEBTEB_H
#define _NTPEBTEB_H

typedef struct _RTL_USER_PROCESS_PARAMETERS *PRTL_USER_PROCESS_PARAMETERS;
typedef struct _RTL_CRITICAL_SECTION *PRTL_CRITICAL_SECTION;

// private
typedef struct _ACTIVATION_CONTEXT_STACK
{
    struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME* ActiveFrame;
    LIST_ENTRY FrameListCache;
    ULONG Flags;
    ULONG NextCookieSequenceNumber;
    ULONG StackId;
} ACTIVATION_CONTEXT_STACK, *PACTIVATION_CONTEXT_STACK;

// private
typedef struct _API_SET_NAMESPACE
{
    ULONG Version;
    ULONG Size;
    ULONG Flags;
    ULONG Count;
    ULONG EntryOffset;
    ULONG HashOffset;
    ULONG HashFactor;
} API_SET_NAMESPACE, *PAPI_SET_NAMESPACE;

// private
typedef struct _API_SET_HASH_ENTRY
{
    ULONG Hash;
    ULONG Index;
} API_SET_HASH_ENTRY, *PAPI_SET_HASH_ENTRY;

// private
typedef struct _API_SET_NAMESPACE_ENTRY
{
    ULONG Flags;
    ULONG NameOffset;
    ULONG NameLength;
    ULONG HashedLength;
    ULONG ValueOffset;
    ULONG ValueCount;
} API_SET_NAMESPACE_ENTRY, *PAPI_SET_NAMESPACE_ENTRY;

// private
typedef struct _API_SET_VALUE_ENTRY
{
    ULONG Flags;
    ULONG NameOffset;
    ULONG NameLength;
    ULONG ValueOffset;
    ULONG ValueLength;
} API_SET_VALUE_ENTRY, *PAPI_SET_VALUE_ENTRY;

// symbols
typedef struct _PEB
{
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN IsPackagedProcess : 1;
            BOOLEAN IsAppContainer : 1;
            BOOLEAN IsProtectedProcessLight : 1;
            BOOLEAN IsLongPathAwareProcess : 1;
        };
    };

    HANDLE Mutant;

    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PRTL_CRITICAL_SECTION FastPebLock;
    PSLIST_HEADER AtlThunkSListPtr;
    PVOID IFEOKey;

    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ProcessImagesHotPatched : 1; // REDSTONE5
            ULONG ReservedBits0 : 24;
        };
    };
    union
    {
        PVOID KernelCallbackTable;
        PVOID UserSharedInfoPtr;
    };
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    PAPI_SET_NAMESPACE ApiSetMap;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];

    PVOID ReadOnlySharedMemoryBase;
    PVOID SharedData; // HotpatchInformation
    PVOID *ReadOnlyStaticServerData;

    PVOID AnsiCodePageData; // PCPTABLEINFO
    PVOID OemCodePageData; // PCPTABLEINFO
    PVOID UnicodeCaseTableData; // PNLSTABLEINFO

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    ULARGE_INTEGER CriticalSectionTimeout;
    SIZE_T HeapSegmentReserve;
    SIZE_T HeapSegmentCommit;
    SIZE_T HeapDeCommitTotalFreeThreshold;
    SIZE_T HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PVOID *ProcessHeaps; // PHEAP

    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    PRTL_CRITICAL_SECTION LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    KAFFINITY ActiveProcessAffinityMask;
    GDI_HANDLE_BUFFER GdiHandleBuffer;
    PVOID PostProcessInitRoutine;

    PVOID TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    PVOID pShimData;
    PVOID AppCompatInfo; // APPCOMPAT_EXE_DATA

    UNICODE_STRING CSDVersion;

    PVOID ActivationContextData; // ACTIVATION_CONTEXT_DATA
    PVOID ProcessAssemblyStorageMap; // ASSEMBLY_STORAGE_MAP
    PVOID SystemDefaultActivationContextData; // ACTIVATION_CONTEXT_DATA
    PVOID SystemAssemblyStorageMap; // ASSEMBLY_STORAGE_MAP

    SIZE_T MinimumStackCommit;

    PVOID SparePointers[2]; // 19H1 (previously FlsCallback to FlsHighIndex)
    PVOID PatchLoaderData;
    PVOID ChpeV2ProcessInfo; // _CHPEV2_PROCESS_INFO

    ULONG AppModelFeatureState;
    ULONG SpareUlongs[2];

    USHORT ActiveCodePage;
    USHORT OemCodePage;
    USHORT UseCaseMapping;
    USHORT UnusedNlsField;

    PVOID WerRegistrationData;
    PVOID WerShipAssertPtr;

    union
    {
        PVOID pContextData; // WIN7
        PVOID pUnused; // WIN10
        PVOID EcCodeBitMap; // WIN11
    };

    PVOID pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG LibLoaderTracingEnabled : 1;
            ULONG SpareTracingBits : 29;
        };
    };
    ULONGLONG CsrServerReadOnlySharedMemoryBase;
    PRTL_CRITICAL_SECTION TppWorkerpListLock;
    LIST_ENTRY TppWorkerpList;
    PVOID WaitOnAddressHashTable[128];
    PVOID TelemetryCoverageHeader; // REDSTONE3
    ULONG CloudFileFlags;
    ULONG CloudFileDiagFlags; // REDSTONE4
    CHAR PlaceholderCompatibilityMode;
    CHAR PlaceholderCompatibilityModeReserved[7];
    struct _LEAP_SECOND_DATA *LeapSecondData; // REDSTONE5
    union
    {
        ULONG LeapSecondFlags;
        struct
        {
            ULONG SixtySecondEnabled : 1;
            ULONG Reserved : 31;
        };
    };
    ULONG NtGlobalFlag2;
    ULONGLONG ExtendedFeatureDisableMask; // since WIN11
} PEB, *PPEB;

#ifdef _WIN64
C_ASSERT(FIELD_OFFSET(PEB, SessionId) == 0x2C0);
//C_ASSERT(sizeof(PEB) == 0x7B0); // REDSTONE3
//C_ASSERT(sizeof(PEB) == 0x7B8); // REDSTONE4
//C_ASSERT(sizeof(PEB) == 0x7C8); // REDSTONE5 // 19H1
C_ASSERT(sizeof(PEB) == 0x7d0); // WIN11
#else
C_ASSERT(FIELD_OFFSET(PEB, SessionId) == 0x1D4);
//C_ASSERT(sizeof(PEB) == 0x468); // REDSTONE3
//C_ASSERT(sizeof(PEB) == 0x470); // REDSTONE4
//C_ASSERT(sizeof(PEB) == 0x480); // REDSTONE5 // 19H1
C_ASSERT(sizeof(PEB) == 0x488); // WIN11
#endif

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH
{
    ULONG Offset;
    ULONG_PTR HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH, *PGDI_TEB_BATCH;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT
{
    ULONG Flags;
    PSTR FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _TEB_ACTIVE_FRAME
{
    ULONG Flags;
    struct _TEB_ACTIVE_FRAME *Previous;
    PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

typedef struct _TEB
{
    NT_TIB NtTib;

    PVOID EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    PVOID WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    PVOID ReservedForDebuggerInstrumentation[16];
#ifdef _WIN64
    PVOID SystemReserved1[30];
#else
    PVOID SystemReserved1[26];
#endif

    CHAR PlaceholderCompatibilityMode;
    BOOLEAN PlaceholderHydrationAlwaysExplicit;
    CHAR PlaceholderReserved[10];

    ULONG ProxiedProcessId;
    ACTIVATION_CONTEXT_STACK ActivationStack;

    UCHAR WorkingOnBehalfTicket[8];
    NTSTATUS ExceptionCode;

    PACTIVATION_CONTEXT_STACK ActivationContextStackPointer;
    ULONG_PTR InstrumentationCallbackSp;
    ULONG_PTR InstrumentationCallbackPreviousPc;
    ULONG_PTR InstrumentationCallbackPreviousSp;
#ifdef _WIN64
    ULONG TxFsContext;
#endif

    BOOLEAN InstrumentationCallbackDisabled;
#ifdef _WIN64
    BOOLEAN UnalignedLoadStoreExceptions;
#endif
#ifndef _WIN64
    UCHAR SpareBytes[23];
    ULONG TxFsContext;
#endif
    GDI_TEB_BATCH GdiTebBatch;
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG_PTR Win32ClientInfo[62];
    PVOID glDispatchTable[233];
    ULONG_PTR glReserved1[29];
    PVOID glReserved2;
    PVOID glSectionInfo;
    PVOID glSection;
    PVOID glTable;
    PVOID glCurrentRC;
    PVOID glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    PVOID DeallocationStack;
    PVOID TlsSlots[64];
    LIST_ENTRY TlsLinks;

    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];

    ULONG HardErrorMode;
#ifdef _WIN64
    PVOID Instrumentation[11];
#else
    PVOID Instrumentation[9];
#endif
    GUID ActivityId;

    PVOID SubProcessTag;
    PVOID PerflibData;
    PVOID EtwTraceData;
    PVOID WinSockData;
    ULONG GdiBatchCount;

    union
    {
        PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        };
    };

    ULONG GuaranteedStackBytes;
    PVOID ReservedForPerf;
    PVOID ReservedForOle;
    ULONG WaitingOnLoaderLock;
    PVOID SavedPriorityState;
    ULONG_PTR ReservedForCodeCoverage;
    PVOID ThreadPoolData;
    PVOID *TlsExpansionSlots;
#ifdef _WIN64
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    PVOID NlsCache;
    PVOID pShimData;
    ULONG HeapData;
    HANDLE CurrentTransactionHandle;
    PTEB_ACTIVE_FRAME ActiveFrame;
    PVOID FlsData;

    PVOID PreferredLanguages;
    PVOID UserPrefLanguages;
    PVOID MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    };
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SessionAware : 1;
            USHORT LoadOwner : 1;
            USHORT LoaderWorker : 1;
            USHORT SkipLoaderInit : 1;
            USHORT SkipFileAPIBrokering : 1;
        };
    };

    PVOID TxnScopeEnterCallback;
    PVOID TxnScopeExitCallback;
    PVOID TxnScopeContext;
    ULONG LockCount;
    LONG WowTebOffset;
    PVOID ResourceRetValue;
    PVOID ReservedForWdf;
    ULONGLONG ReservedForCrt;
    GUID EffectiveContainerId;
    ULONGLONG LastSleepCounter; // Win11
    ULONG SpinCallCount;
    ULONGLONG ExtendedFeatureDisableMask;
} TEB, *PTEB;

#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
typedef enum _PROCESSINFOCLASS
{
    ProcessBasicInformation, // q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION
    ProcessQuotaLimits, // qs: QUOTA_LIMITS, QUOTA_LIMITS_EX
    ProcessIoCounters, // q: IO_COUNTERS
    ProcessVmCounters, // q: VM_COUNTERS, VM_COUNTERS_EX, VM_COUNTERS_EX2
    ProcessTimes, // q: KERNEL_USER_TIMES
    ProcessBasePriority, // s: KPRIORITY
    ProcessRaisePriority, // s: ULONG
    ProcessDebugPort, // q: HANDLE
    ProcessExceptionPort, // s: PROCESS_EXCEPTION_PORT (requires SeTcbPrivilege)
    ProcessAccessToken, // s: PROCESS_ACCESS_TOKEN
    ProcessLdtInformation, // qs: PROCESS_LDT_INFORMATION // 10
    ProcessLdtSize, // s: PROCESS_LDT_SIZE
    ProcessDefaultHardErrorMode, // qs: ULONG
    ProcessIoPortHandlers, // (kernel-mode only) // PROCESS_IO_PORT_HANDLER_INFORMATION
    ProcessPooledUsageAndLimits, // q: POOLED_USAGE_AND_LIMITS
    ProcessWorkingSetWatch, // q: PROCESS_WS_WATCH_INFORMATION[]; s: void
    ProcessUserModeIOPL, // qs: ULONG (requires SeTcbPrivilege)
    ProcessEnableAlignmentFaultFixup, // s: BOOLEAN
    ProcessPriorityClass, // qs: PROCESS_PRIORITY_CLASS
    ProcessWx86Information, // qs: ULONG (requires SeTcbPrivilege) (VdmAllowed)
    ProcessHandleCount, // q: ULONG, PROCESS_HANDLE_INFORMATION // 20
    ProcessAffinityMask, // (q >WIN7)s: KAFFINITY, qs: GROUP_AFFINITY
    ProcessPriorityBoost, // qs: ULONG
    ProcessDeviceMap, // qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX
    ProcessSessionInformation, // q: PROCESS_SESSION_INFORMATION
    ProcessForegroundInformation, // s: PROCESS_FOREGROUND_BACKGROUND
    ProcessWow64Information, // q: ULONG_PTR
    ProcessImageFileName, // q: UNICODE_STRING
    ProcessLUIDDeviceMapsEnabled, // q: ULONG
    ProcessBreakOnTermination, // qs: ULONG
    ProcessDebugObjectHandle, // q: HANDLE // 30
    ProcessDebugFlags, // qs: ULONG
    ProcessHandleTracing, // q: PROCESS_HANDLE_TRACING_QUERY; s: size 0 disables, otherwise enables
    ProcessIoPriority, // qs: IO_PRIORITY_HINT
    ProcessExecuteFlags, // qs: ULONG
    ProcessTlsInformation, // PROCESS_TLS_INFORMATION // ProcessResourceManagement
    ProcessCookie, // q: ULONG
    ProcessImageInformation, // q: SECTION_IMAGE_INFORMATION
    ProcessCycleTime, // q: PROCESS_CYCLE_TIME_INFORMATION // since VISTA
    ProcessPagePriority, // qs: PAGE_PRIORITY_INFORMATION
    ProcessInstrumentationCallback, // s: PVOID or PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION // 40
    ProcessThreadStackAllocation, // s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX
    ProcessWorkingSetWatchEx, // q: PROCESS_WS_WATCH_INFORMATION_EX[]
    ProcessImageFileNameWin32, // q: UNICODE_STRING
    ProcessImageFileMapping, // q: HANDLE (input)
    ProcessAffinityUpdateMode, // qs: PROCESS_AFFINITY_UPDATE_MODE
    ProcessMemoryAllocationMode, // qs: PROCESS_MEMORY_ALLOCATION_MODE
    ProcessGroupInformation, // q: USHORT[]
    ProcessTokenVirtualizationEnabled, // s: ULONG
    ProcessConsoleHostProcess, // q: ULONG_PTR // ProcessOwnerInformation
    ProcessWindowInformation, // q: PROCESS_WINDOW_INFORMATION // 50
    ProcessHandleInformation, // q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8
    ProcessMitigationPolicy, // s: PROCESS_MITIGATION_POLICY_INFORMATION
    ProcessDynamicFunctionTableInformation,
    ProcessHandleCheckingMode, // qs: ULONG; s: 0 disables, otherwise enables
    ProcessKeepAliveCount, // q: PROCESS_KEEPALIVE_COUNT_INFORMATION
    ProcessRevokeFileHandles, // s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION
    ProcessWorkingSetControl, // s: PROCESS_WORKING_SET_CONTROL
    ProcessHandleTable, // q: ULONG[] // since WINBLUE
    ProcessCheckStackExtentsMode, // qs: ULONG // KPROCESS->CheckStackExtents (CFG)
    ProcessCommandLineInformation, // q: UNICODE_STRING // 60
    ProcessProtectionInformation, // q: PS_PROTECTION
    ProcessMemoryExhaustion, // PROCESS_MEMORY_EXHAUSTION_INFO // since THRESHOLD
    ProcessFaultInformation, // PROCESS_FAULT_INFORMATION
    ProcessTelemetryIdInformation, // q: PROCESS_TELEMETRY_ID_INFORMATION
    ProcessCommitReleaseInformation, // PROCESS_COMMIT_RELEASE_INFORMATION
    ProcessDefaultCpuSetsInformation, // SYSTEM_CPU_SET_INFORMATION[5]
    ProcessAllowedCpuSetsInformation, // SYSTEM_CPU_SET_INFORMATION[5]
    ProcessSubsystemProcess,
    ProcessJobMemoryInformation, // q: PROCESS_JOB_MEMORY_INFO
    ProcessInPrivate, // s: void // ETW // since THRESHOLD2 // 70
    ProcessRaiseUMExceptionOnInvalidHandleClose, // qs: ULONG; s: 0 disables, otherwise enables
    ProcessIumChallengeResponse,
    ProcessChildProcessInformation, // q: PROCESS_CHILD_PROCESS_INFORMATION
    ProcessHighGraphicsPriorityInformation, // qs: BOOLEAN (requires SeTcbPrivilege)
    ProcessSubsystemInformation, // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
    ProcessEnergyValues, // q: PROCESS_ENERGY_VALUES, PROCESS_EXTENDED_ENERGY_VALUES
    ProcessPowerThrottlingState, // qs: POWER_THROTTLING_PROCESS_STATE
    ProcessReserved3Information, // ProcessActivityThrottlePolicy // PROCESS_ACTIVITY_THROTTLE_POLICY
    ProcessWin32kSyscallFilterInformation, // q: WIN32K_SYSCALL_FILTER
    ProcessDisableSystemAllowedCpuSets, // 80
    ProcessWakeInformation, // PROCESS_WAKE_INFORMATION
    ProcessEnergyTrackingState, // PROCESS_ENERGY_TRACKING_STATE
    ProcessManageWritesToExecutableMemory, // MANAGE_WRITES_TO_EXECUTABLE_MEMORY // since REDSTONE3
    ProcessCaptureTrustletLiveDump,
    ProcessTelemetryCoverage,
    ProcessEnclaveInformation,
    ProcessEnableReadWriteVmLogging, // PROCESS_READWRITEVM_LOGGING_INFORMATION
    ProcessUptimeInformation, // q: PROCESS_UPTIME_INFORMATION
    ProcessImageSection, // q: HANDLE
    ProcessDebugAuthInformation, // since REDSTONE4 // 90
    ProcessSystemResourceManagement, // PROCESS_SYSTEM_RESOURCE_MANAGEMENT
    ProcessSequenceNumber, // q: ULONGLONG
    ProcessLoaderDetour, // since REDSTONE5
    ProcessSecurityDomainInformation, // PROCESS_SECURITY_DOMAIN_INFORMATION
    ProcessCombineSecurityDomainsInformation, // PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION
    ProcessEnableLogging, // PROCESS_LOGGING_INFORMATION
    ProcessLeapSecondInformation, // PROCESS_LEAP_SECOND_INFORMATION
    ProcessFiberShadowStackAllocation, // PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION // since 19H1
    ProcessFreeFiberShadowStackAllocation, // PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION
    ProcessAltSystemCallInformation, // qs: BOOLEAN (kernel-mode only) // INT2E // since 20H1 // 100
    ProcessDynamicEHContinuationTargets, // PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION
    ProcessDynamicEnforcedCetCompatibleRanges, // PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE_INFORMATION // since 20H2
    ProcessCreateStateChange, // since WIN11
    ProcessApplyStateChange,
    ProcessEnableOptionalXStateFeatures,
    ProcessAltPrefetchParam, // since 22H1
    ProcessAssignCpuPartitions,
    ProcessPriorityClassEx, // s: PROCESS_PRIORITY_CLASS_EX
    ProcessMembershipInformation,
    ProcessEffectiveIoPriority, // q: IO_PRIORITY_HINT
    ProcessEffectivePagePriority, // q: ULONG
    MaxProcessInfoClass
} PROCESSINFOCLASS;
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
typedef enum _THREADINFOCLASS
{
    ThreadBasicInformation, // q: THREAD_BASIC_INFORMATION
    ThreadTimes, // q: KERNEL_USER_TIMES
    ThreadPriority, // s: KPRIORITY (requires SeIncreaseBasePriorityPrivilege)
    ThreadBasePriority, // s: KPRIORITY
    ThreadAffinityMask, // s: KAFFINITY
    ThreadImpersonationToken, // s: HANDLE
    ThreadDescriptorTableEntry, // q: DESCRIPTOR_TABLE_ENTRY (or WOW64_DESCRIPTOR_TABLE_ENTRY)
    ThreadEnableAlignmentFaultFixup, // s: BOOLEAN
    ThreadEventPair,
    ThreadQuerySetWin32StartAddress, // q: ULONG_PTR
    ThreadZeroTlsCell, // s: ULONG // TlsIndex // 10
    ThreadPerformanceCount, // q: LARGE_INTEGER
    ThreadAmILastThread, // q: ULONG
    ThreadIdealProcessor, // s: ULONG
    ThreadPriorityBoost, // qs: ULONG
    ThreadSetTlsArrayAddress, // s: ULONG_PTR
    ThreadIsIoPending, // q: ULONG
    ThreadHideFromDebugger, // q: BOOLEAN; s: void
    ThreadBreakOnTermination, // qs: ULONG
    ThreadSwitchLegacyState, // s: void // NtCurrentThread // NPX/FPU
    ThreadIsTerminated, // q: ULONG // 20
    ThreadLastSystemCall, // q: THREAD_LAST_SYSCALL_INFORMATION
    ThreadIoPriority, // qs: IO_PRIORITY_HINT (requires SeIncreaseBasePriorityPrivilege)
    ThreadCycleTime, // q: THREAD_CYCLE_TIME_INFORMATION
    ThreadPagePriority, // qs: PAGE_PRIORITY_INFORMATION
    ThreadActualBasePriority, // s: LONG (requires SeIncreaseBasePriorityPrivilege)
    ThreadTebInformation, // q: THREAD_TEB_INFORMATION (requires THREAD_GET_CONTEXT + THREAD_SET_CONTEXT)
    ThreadCSwitchMon,
    ThreadCSwitchPmu,
    ThreadWow64Context, // qs: WOW64_CONTEXT
    ThreadGroupInformation, // qs: GROUP_AFFINITY // 30
    ThreadUmsInformation, // q: THREAD_UMS_INFORMATION
    ThreadCounterProfiling, // q: BOOLEAN; s: THREAD_PROFILING_INFORMATION?
    ThreadIdealProcessorEx, // qs: PROCESSOR_NUMBER; s: previous PROCESSOR_NUMBER on return
    ThreadCpuAccountingInformation, // q: BOOLEAN; s: HANDLE (NtOpenSession) // NtCurrentThread // since WIN8
    ThreadSuspendCount, // q: ULONG // since WINBLUE
    ThreadHeterogeneousCpuPolicy, // q: KHETERO_CPU_POLICY // since THRESHOLD
    ThreadContainerId, // q: GUID
    ThreadNameInformation, // qs: THREAD_NAME_INFORMATION
    ThreadSelectedCpuSets,
    ThreadSystemThreadInformation, // q: SYSTEM_THREAD_INFORMATION // 40
    ThreadActualGroupAffinity, // q: GROUP_AFFINITY // since THRESHOLD2
    ThreadDynamicCodePolicyInfo, // q: ULONG; s: ULONG (NtCurrentThread)
    ThreadExplicitCaseSensitivity, // qs: ULONG; s: 0 disables, otherwise enables
    ThreadWorkOnBehalfTicket, // RTL_WORK_ON_BEHALF_TICKET_EX
    ThreadSubsystemInformation, // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
    ThreadDbgkWerReportActive, // s: ULONG; s: 0 disables, otherwise enables
    ThreadAttachContainer, // s: HANDLE (job object) // NtCurrentThread
    ThreadManageWritesToExecutableMemory, // MANAGE_WRITES_TO_EXECUTABLE_MEMORY // since REDSTONE3
    ThreadPowerThrottlingState, // POWER_THROTTLING_THREAD_STATE
    ThreadWorkloadClass, // THREAD_WORKLOAD_CLASS // since REDSTONE5 // 50
    ThreadCreateStateChange, // since WIN11
    ThreadApplyStateChange,
    ThreadStrongerBadHandleChecks, // since 22H1
    ThreadEffectiveIoPriority, // q: IO_PRIORITY_HINT
    ThreadEffectivePagePriority, // q: ULONG
    MaxThreadInfoClass
} THREADINFOCLASS;
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
// Use with both ProcessPagePriority and ThreadPagePriority
typedef struct _PAGE_PRIORITY_INFORMATION
{
    ULONG PagePriority;
} PAGE_PRIORITY_INFORMATION, *PPAGE_PRIORITY_INFORMATION;
#endif

// Process information structures

#if (PHNT_MODE != PHNT_MODE_KERNEL)

typedef struct _PROCESS_BASIC_INFORMATION
{
    NTSTATUS ExitStatus;
    PPEB PebBaseAddress;
    KAFFINITY AffinityMask;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;

typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION
{
    SIZE_T Size; // set to sizeof structure on input
    PROCESS_BASIC_INFORMATION BasicInfo;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG IsProtectedProcess : 1;
            ULONG IsWow64Process : 1;
            ULONG IsProcessDeleting : 1;
            ULONG IsCrossSessionCreate : 1;
            ULONG IsFrozen : 1;
            ULONG IsBackground : 1;
            ULONG IsStronglyNamed : 1;
            ULONG IsSecureProcess : 1;
            ULONG IsSubsystemProcess : 1;
            ULONG SpareBits : 23;
        };
    };
} PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;

typedef struct _VM_COUNTERS
{
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
} VM_COUNTERS, *PVM_COUNTERS;

typedef struct _VM_COUNTERS_EX
{
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivateUsage;
} VM_COUNTERS_EX, *PVM_COUNTERS_EX;

// private
typedef struct _VM_COUNTERS_EX2
{
    VM_COUNTERS_EX CountersEx;
    SIZE_T PrivateWorkingSetSize;
    SIZE_T SharedCommitUsage;
} VM_COUNTERS_EX2, *PVM_COUNTERS_EX2;

typedef struct _KERNEL_USER_TIMES
{
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER ExitTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
} KERNEL_USER_TIMES, *PKERNEL_USER_TIMES;

typedef struct _POOLED_USAGE_AND_LIMITS
{
    SIZE_T PeakPagedPoolUsage;
    SIZE_T PagedPoolUsage;
    SIZE_T PagedPoolLimit;
    SIZE_T PeakNonPagedPoolUsage;
    SIZE_T NonPagedPoolUsage;
    SIZE_T NonPagedPoolLimit;
    SIZE_T PeakPagefileUsage;
    SIZE_T PagefileUsage;
    SIZE_T PagefileLimit;
} POOLED_USAGE_AND_LIMITS, *PPOOLED_USAGE_AND_LIMITS;

#define PROCESS_EXCEPTION_PORT_ALL_STATE_BITS 0x00000003
#define PROCESS_EXCEPTION_PORT_ALL_STATE_FLAGS ((ULONG_PTR)((1UL << PROCESS_EXCEPTION_PORT_ALL_STATE_BITS) - 1))

typedef struct _PROCESS_EXCEPTION_PORT
{
    _In_ HANDLE ExceptionPortHandle; // Handle to the exception port. No particular access required.
    _Inout_ ULONG StateFlags; // Miscellaneous state flags to be cached along with the exception port in the kernel.
} PROCESS_EXCEPTION_PORT, *PPROCESS_EXCEPTION_PORT;

typedef struct _PROCESS_ACCESS_TOKEN
{
    HANDLE Token; // needs TOKEN_ASSIGN_PRIMARY access
    HANDLE Thread; // handle to initial/only thread; needs THREAD_QUERY_INFORMATION access
} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

typedef struct _PROCESS_LDT_INFORMATION
{
    ULONG Start;
    ULONG Length;
    LDT_ENTRY LdtEntries[1];
} PROCESS_LDT_INFORMATION, *PPROCESS_LDT_INFORMATION;

typedef struct _PROCESS_LDT_SIZE
{
    ULONG Length;
} PROCESS_LDT_SIZE, *PPROCESS_LDT_SIZE;

typedef struct _PROCESS_WS_WATCH_INFORMATION
{
    PVOID FaultingPc;
    PVOID FaultingVa;
} PROCESS_WS_WATCH_INFORMATION, *PPROCESS_WS_WATCH_INFORMATION;

#endif

// psapi:PSAPI_WS_WATCH_INFORMATION_EX
typedef struct _PROCESS_WS_WATCH_INFORMATION_EX
{
    PROCESS_WS_WATCH_INFORMATION BasicInfo;
    ULONG_PTR FaultingThreadId;
    ULONG_PTR Flags;
} PROCESS_WS_WATCH_INFORMATION_EX, *PPROCESS_WS_WATCH_INFORMATION_EX;

#define PROCESS_PRIORITY_CLASS_UNKNOWN 0
#define PROCESS_PRIORITY_CLASS_IDLE 1
#define PROCESS_PRIORITY_CLASS_NORMAL 2
#define PROCESS_PRIORITY_CLASS_HIGH 3
#define PROCESS_PRIORITY_CLASS_REALTIME 4
#define PROCESS_PRIORITY_CLASS_BELOW_NORMAL 5
#define PROCESS_PRIORITY_CLASS_ABOVE_NORMAL 6

typedef struct _PROCESS_PRIORITY_CLASS
{
    BOOLEAN Foreground;
    UCHAR PriorityClass;
} PROCESS_PRIORITY_CLASS, *PPROCESS_PRIORITY_CLASS;

typedef struct _PROCESS_PRIORITY_CLASS_EX
{
    union
    {
        struct
        {
            USHORT ForegroundValid : 1;
            USHORT PriorityClassValid : 1;
        };
        USHORT AllFlags;
    };
    UCHAR PriorityClass;
    BOOLEAN Foreground;
} PROCESS_PRIORITY_CLASS_EX, *PPROCESS_PRIORITY_CLASS_EX;

typedef struct _PROCESS_FOREGROUND_BACKGROUND
{
    BOOLEAN Foreground;
} PROCESS_FOREGROUND_BACKGROUND, *PPROCESS_FOREGROUND_BACKGROUND;

#if (PHNT_MODE != PHNT_MODE_KERNEL)

typedef struct _PROCESS_DEVICEMAP_INFORMATION
{
    union
    {
        struct
        {
            HANDLE DirectoryHandle;
        } Set;
        struct
        {
            ULONG DriveMap;
            UCHAR DriveType[32];
        } Query;
    };
} PROCESS_DEVICEMAP_INFORMATION, *PPROCESS_DEVICEMAP_INFORMATION;

#define PROCESS_LUID_DOSDEVICES_ONLY 0x00000001

typedef struct _PROCESS_DEVICEMAP_INFORMATION_EX
{
    union
    {
        struct
        {
            HANDLE DirectoryHandle;
        } Set;
        struct
        {
            ULONG DriveMap;
            UCHAR DriveType[32];
        } Query;
    };
    ULONG Flags; // PROCESS_LUID_DOSDEVICES_ONLY
} PROCESS_DEVICEMAP_INFORMATION_EX, *PPROCESS_DEVICEMAP_INFORMATION_EX;

typedef struct _PROCESS_SESSION_INFORMATION
{
    ULONG SessionId;
} PROCESS_SESSION_INFORMATION, *PPROCESS_SESSION_INFORMATION;

#define PROCESS_HANDLE_EXCEPTIONS_ENABLED 0x00000001

#define PROCESS_HANDLE_RAISE_EXCEPTION_ON_INVALID_HANDLE_CLOSE_DISABLED 0x00000000
#define PROCESS_HANDLE_RAISE_EXCEPTION_ON_INVALID_HANDLE_CLOSE_ENABLED 0x00000001

typedef struct _PROCESS_HANDLE_TRACING_ENABLE
{
    ULONG Flags;
} PROCESS_HANDLE_TRACING_ENABLE, *PPROCESS_HANDLE_TRACING_ENABLE;

#define PROCESS_HANDLE_TRACING_MAX_SLOTS 0x20000

typedef struct _PROCESS_HANDLE_TRACING_ENABLE_EX
{
    ULONG Flags;
    ULONG TotalSlots;
} PROCESS_HANDLE_TRACING_ENABLE_EX, *PPROCESS_HANDLE_TRACING_ENABLE_EX;

#define PROCESS_HANDLE_TRACING_MAX_STACKS 16

#define PROCESS_HANDLE_TRACE_TYPE_OPEN 1
#define PROCESS_HANDLE_TRACE_TYPE_CLOSE 2
#define PROCESS_HANDLE_TRACE_TYPE_BADREF 3

typedef struct _PROCESS_HANDLE_TRACING_ENTRY
{
    HANDLE Handle;
    CLIENT_ID ClientId;
    ULONG Type;
    PVOID Stacks[PROCESS_HANDLE_TRACING_MAX_STACKS];
} PROCESS_HANDLE_TRACING_ENTRY, *PPROCESS_HANDLE_TRACING_ENTRY;

typedef struct _PROCESS_HANDLE_TRACING_QUERY
{
    HANDLE Handle;
    ULONG TotalTraces;
    PROCESS_HANDLE_TRACING_ENTRY HandleTrace[1];
} PROCESS_HANDLE_TRACING_QUERY, *PPROCESS_HANDLE_TRACING_QUERY;

#endif

// private
typedef struct _THREAD_TLS_INFORMATION
{
    ULONG Flags;
    PVOID NewTlsData;
    PVOID OldTlsData;
    HANDLE ThreadId;
} THREAD_TLS_INFORMATION, *PTHREAD_TLS_INFORMATION;

// private
typedef enum _PROCESS_TLS_INFORMATION_TYPE
{
    ProcessTlsReplaceIndex,
    ProcessTlsReplaceVector,
    MaxProcessTlsOperation
} PROCESS_TLS_INFORMATION_TYPE, *PPROCESS_TLS_INFORMATION_TYPE;

// private
typedef struct _PROCESS_TLS_INFORMATION
{
    ULONG Flags;
    ULONG OperationType;
    ULONG ThreadDataCount;
    ULONG TlsIndex;
    ULONG PreviousCount;
    THREAD_TLS_INFORMATION ThreadData[1];
} PROCESS_TLS_INFORMATION, *PPROCESS_TLS_INFORMATION;

// private
typedef struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION
{
    ULONG Version;
    ULONG Reserved;
    PVOID Callback;
} PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION, *PPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;

// private
typedef struct _PROCESS_STACK_ALLOCATION_INFORMATION
{
    SIZE_T ReserveSize;
    SIZE_T ZeroBits;
    PVOID StackBase;
} PROCESS_STACK_ALLOCATION_INFORMATION, *PPROCESS_STACK_ALLOCATION_INFORMATION;

// private
typedef struct _PROCESS_STACK_ALLOCATION_INFORMATION_EX
{
    ULONG PreferredNode;
    ULONG Reserved0;
    ULONG Reserved1;
    ULONG Reserved2;
    PROCESS_STACK_ALLOCATION_INFORMATION AllocInfo;
} PROCESS_STACK_ALLOCATION_INFORMATION_EX, *PPROCESS_STACK_ALLOCATION_INFORMATION_EX;

// private
typedef union _PROCESS_AFFINITY_UPDATE_MODE
{
    ULONG Flags;
    struct
    {
        ULONG EnableAutoUpdate : 1;
        ULONG Permanent : 1;
        ULONG Reserved : 30;
    };
} PROCESS_AFFINITY_UPDATE_MODE, *PPROCESS_AFFINITY_UPDATE_MODE;

// private
typedef union _PROCESS_MEMORY_ALLOCATION_MODE
{
    ULONG Flags;
    struct
    {
        ULONG TopDown : 1;
        ULONG Reserved : 31;
    };
} PROCESS_MEMORY_ALLOCATION_MODE, *PPROCESS_MEMORY_ALLOCATION_MODE;

// private
typedef struct _PROCESS_HANDLE_INFORMATION
{
    ULONG HandleCount;
    ULONG HandleCountHighWatermark;
} PROCESS_HANDLE_INFORMATION, *PPROCESS_HANDLE_INFORMATION;

// private
typedef struct _PROCESS_CYCLE_TIME_INFORMATION
{
    ULONGLONG AccumulatedCycles;
    ULONGLONG CurrentCycleCount;
} PROCESS_CYCLE_TIME_INFORMATION, *PPROCESS_CYCLE_TIME_INFORMATION;

// private
typedef struct _PROCESS_WINDOW_INFORMATION
{
    ULONG WindowFlags;
    USHORT WindowTitleLength;
    WCHAR WindowTitle[1];
} PROCESS_WINDOW_INFORMATION, *PPROCESS_WINDOW_INFORMATION;

// private
typedef struct _PROCESS_HANDLE_TABLE_ENTRY_INFO
{
    HANDLE HandleValue;
    ULONG_PTR HandleCount;
    ULONG_PTR PointerCount;
    ULONG GrantedAccess;
    ULONG ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} PROCESS_HANDLE_TABLE_ENTRY_INFO, *PPROCESS_HANDLE_TABLE_ENTRY_INFO;

// private
typedef struct _PROCESS_HANDLE_SNAPSHOT_INFORMATION
{
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    PROCESS_HANDLE_TABLE_ENTRY_INFO Handles[1];
} PROCESS_HANDLE_SNAPSHOT_INFORMATION, *PPROCESS_HANDLE_SNAPSHOT_INFORMATION;

#if (PHNT_MODE != PHNT_MODE_KERNEL)

#if !defined(NTDDI_WIN10_FE) || (NTDDI_VERSION < NTDDI_WIN10_FE)
typedef struct _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY
{
    union {
        ULONG Flags;
        struct {
            ULONG EnforceRedirectionTrust : 1;
            ULONG AuditRedirectionTrust : 1;
            ULONG ReservedFlags : 30;
        };
    };
} PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY, * PPROCESS_MITIGATION_REDIRECTION_TRUST_POLICY;
#endif

// private
typedef struct _PROCESS_MITIGATION_POLICY_INFORMATION
{
    PROCESS_MITIGATION_POLICY Policy;
    union
    {
        PROCESS_MITIGATION_ASLR_POLICY ASLRPolicy;
        PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY StrictHandleCheckPolicy;
        PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY SystemCallDisablePolicy;
        PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY ExtensionPointDisablePolicy;
        PROCESS_MITIGATION_DYNAMIC_CODE_POLICY DynamicCodePolicy;
        PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY ControlFlowGuardPolicy;
        PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY SignaturePolicy;
        PROCESS_MITIGATION_FONT_DISABLE_POLICY FontDisablePolicy;
        PROCESS_MITIGATION_IMAGE_LOAD_POLICY ImageLoadPolicy;
        PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY SystemCallFilterPolicy;
        PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY PayloadRestrictionPolicy;
        PROCESS_MITIGATION_CHILD_PROCESS_POLICY ChildProcessPolicy;
        PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY SideChannelIsolationPolicy;
        PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY UserShadowStackPolicy;
        PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY RedirectionTrustPolicy;
    };
} PROCESS_MITIGATION_POLICY_INFORMATION, *PPROCESS_MITIGATION_POLICY_INFORMATION;

typedef struct _PROCESS_KEEPALIVE_COUNT_INFORMATION
{
    ULONG WakeCount;
    ULONG NoWakeCount;
} PROCESS_KEEPALIVE_COUNT_INFORMATION, *PPROCESS_KEEPALIVE_COUNT_INFORMATION;

typedef struct _PROCESS_REVOKE_FILE_HANDLES_INFORMATION
{
    UNICODE_STRING TargetDevicePath;
} PROCESS_REVOKE_FILE_HANDLES_INFORMATION, *PPROCESS_REVOKE_FILE_HANDLES_INFORMATION;

// begin_private

typedef enum _PROCESS_WORKING_SET_OPERATION
{
    ProcessWorkingSetSwap,
    ProcessWorkingSetEmpty,
    ProcessWorkingSetOperationMax
} PROCESS_WORKING_SET_OPERATION;

typedef struct _PROCESS_WORKING_SET_CONTROL
{
    ULONG Version;
    PROCESS_WORKING_SET_OPERATION Operation;
    ULONG Flags;
} PROCESS_WORKING_SET_CONTROL, *PPROCESS_WORKING_SET_CONTROL;

typedef enum _PS_PROTECTED_TYPE
{
    PsProtectedTypeNone,
    PsProtectedTypeProtectedLight,
    PsProtectedTypeProtected,
    PsProtectedTypeMax
} PS_PROTECTED_TYPE;

typedef enum _PS_PROTECTED_SIGNER
{
    PsProtectedSignerNone,
    PsProtectedSignerAuthenticode,
    PsProtectedSignerCodeGen,
    PsProtectedSignerAntimalware,
    PsProtectedSignerLsa,
    PsProtectedSignerWindows,
    PsProtectedSignerWinTcb,
    PsProtectedSignerWinSystem,
    PsProtectedSignerApp,
    PsProtectedSignerMax
} PS_PROTECTED_SIGNER;

#define PS_PROTECTED_SIGNER_MASK 0xFF
#define PS_PROTECTED_AUDIT_MASK 0x08
#define PS_PROTECTED_TYPE_MASK 0x07

// vProtectionLevel.Level = PsProtectedValue(PsProtectedSignerCodeGen, FALSE, PsProtectedTypeProtectedLight)
#define PsProtectedValue(aSigner, aAudit, aType) ( \
    ((aSigner & PS_PROTECTED_SIGNER_MASK) << 4) | \
    ((aAudit & PS_PROTECTED_AUDIT_MASK) << 3) | \
    (aType & PS_PROTECTED_TYPE_MASK)\
    )

// InitializePsProtection(&vProtectionLevel, PsProtectedSignerCodeGen, FALSE, PsProtectedTypeProtectedLight)
#define InitializePsProtection(aProtectionLevelPtr, aSigner, aAudit, aType) { \
    (aProtectionLevelPtr)->Signer = aSigner; \
    (aProtectionLevelPtr)->Audit = aAudit; \
    (aProtectionLevelPtr)->Type = aType; \
    }

typedef struct _PS_PROTECTION
{
    union
    {
        UCHAR Level;
        struct
        {
            UCHAR Type : 3;
            UCHAR Audit : 1;
            UCHAR Signer : 4;
        };
    };
} PS_PROTECTION, *PPS_PROTECTION;

typedef struct _PROCESS_FAULT_INFORMATION
{
    ULONG FaultFlags;
    ULONG AdditionalInfo;
} PROCESS_FAULT_INFORMATION, *PPROCESS_FAULT_INFORMATION;

typedef struct _PROCESS_TELEMETRY_ID_INFORMATION
{
    ULONG HeaderSize;
    ULONG ProcessId;
    ULONGLONG ProcessStartKey;
    ULONGLONG CreateTime;
    ULONGLONG CreateInterruptTime;
    ULONGLONG CreateUnbiasedInterruptTime;
    ULONGLONG ProcessSequenceNumber;
    ULONGLONG SessionCreateTime;
    ULONG SessionId;
    ULONG BootId;
    ULONG ImageChecksum;
    ULONG ImageTimeDateStamp;
    ULONG UserSidOffset;
    ULONG ImagePathOffset;
    ULONG PackageNameOffset;
    ULONG RelativeAppNameOffset;
    ULONG CommandLineOffset;
} PROCESS_TELEMETRY_ID_INFORMATION, *PPROCESS_TELEMETRY_ID_INFORMATION;

typedef struct _PROCESS_COMMIT_RELEASE_INFORMATION
{
    ULONG Version;
    struct
    {
        ULONG Eligible : 1;
        ULONG ReleaseRepurposedMemResetCommit : 1;
        ULONG ForceReleaseMemResetCommit : 1;
        ULONG Spare : 29;
    };
    SIZE_T CommitDebt;
    SIZE_T CommittedMemResetSize;
    SIZE_T RepurposedMemResetSize;
} PROCESS_COMMIT_RELEASE_INFORMATION, *PPROCESS_COMMIT_RELEASE_INFORMATION;

typedef struct _PROCESS_JOB_MEMORY_INFO
{
    ULONGLONG SharedCommitUsage;
    ULONGLONG PrivateCommitUsage;
    ULONGLONG PeakPrivateCommitUsage;
    ULONGLONG PrivateCommitLimit;
    ULONGLONG TotalCommitLimit;
} PROCESS_JOB_MEMORY_INFO, *PPROCESS_JOB_MEMORY_INFO;

typedef struct _PROCESS_CHILD_PROCESS_INFORMATION
{
    BOOLEAN ProhibitChildProcesses;
    BOOLEAN AlwaysAllowSecureChildProcess; // REDSTONE3
    BOOLEAN AuditProhibitChildProcesses;
} PROCESS_CHILD_PROCESS_INFORMATION, *PPROCESS_CHILD_PROCESS_INFORMATION;

#define POWER_THROTTLING_PROCESS_CURRENT_VERSION 1
#define POWER_THROTTLING_PROCESS_EXECUTION_SPEED 0x1
#define POWER_THROTTLING_PROCESS_DELAYTIMERS 0x2
#define POWER_THROTTLING_PROCESS_IGNORE_TIMER_RESOLUTION 0x4 // since WIN11
#define POWER_THROTTLING_PROCESS_VALID_FLAGS ((POWER_THROTTLING_PROCESS_EXECUTION_SPEED | POWER_THROTTLING_PROCESS_DELAYTIMERS | POWER_THROTTLING_PROCESS_IGNORE_TIMER_RESOLUTION))

typedef struct _POWER_THROTTLING_PROCESS_STATE
{
    ULONG Version;
    ULONG ControlMask;
    ULONG StateMask;
} POWER_THROTTLING_PROCESS_STATE, *PPOWER_THROTTLING_PROCESS_STATE;

// rev (tyranid)
#define WIN32K_SYSCALL_FILTER_STATE_ENABLE 0x1
#define WIN32K_SYSCALL_FILTER_STATE_AUDIT 0x2

// private
typedef struct _WIN32K_SYSCALL_FILTER
{
    ULONG FilterState;
    ULONG FilterSet;
} WIN32K_SYSCALL_FILTER, *PWIN32K_SYSCALL_FILTER;

typedef struct _PROCESS_WAKE_INFORMATION
{
    ULONGLONG NotificationChannel;
    ULONG WakeCounters[7];
    struct _JOBOBJECT_WAKE_FILTER* WakeFilter;
} PROCESS_WAKE_INFORMATION, *PPROCESS_WAKE_INFORMATION;

typedef struct _PROCESS_ENERGY_TRACKING_STATE
{
    ULONG StateUpdateMask;
    ULONG StateDesiredValue;
    ULONG StateSequence;
    ULONG UpdateTag : 1;
    WCHAR Tag[64];
} PROCESS_ENERGY_TRACKING_STATE, *PPROCESS_ENERGY_TRACKING_STATE;

typedef struct _MANAGE_WRITES_TO_EXECUTABLE_MEMORY
{
    ULONG Version : 8;
    ULONG ProcessEnableWriteExceptions : 1;
    ULONG ThreadAllowWrites : 1;
    ULONG Spare : 22;
    PVOID KernelWriteToExecutableSignal; // 19H1
} MANAGE_WRITES_TO_EXECUTABLE_MEMORY, *PMANAGE_WRITES_TO_EXECUTABLE_MEMORY;

#define POWER_THROTTLING_THREAD_CURRENT_VERSION 1
#define POWER_THROTTLING_THREAD_EXECUTION_SPEED 0x1
#define POWER_THROTTLING_THREAD_VALID_FLAGS (POWER_THROTTLING_THREAD_EXECUTION_SPEED)

typedef struct _POWER_THROTTLING_THREAD_STATE
{
    ULONG Version;
    ULONG ControlMask;
    ULONG StateMask;
} POWER_THROTTLING_THREAD_STATE, *PPOWER_THROTTLING_THREAD_STATE;

#define PROCESS_READWRITEVM_LOGGING_ENABLE_READVM 1
#define PROCESS_READWRITEVM_LOGGING_ENABLE_WRITEVM 2
#define PROCESS_READWRITEVM_LOGGING_ENABLE_READVM_V 1UL
#define PROCESS_READWRITEVM_LOGGING_ENABLE_WRITEVM_V 2UL

typedef union _PROCESS_READWRITEVM_LOGGING_INFORMATION
{
    UCHAR Flags;
    struct
    {
        UCHAR EnableReadVmLogging : 1;
        UCHAR EnableWriteVmLogging : 1;
        UCHAR Unused : 6;
    };
} PROCESS_READWRITEVM_LOGGING_INFORMATION, *PPROCESS_READWRITEVM_LOGGING_INFORMATION;

typedef struct _PROCESS_UPTIME_INFORMATION
{
    ULONGLONG QueryInterruptTime;
    ULONGLONG QueryUnbiasedTime;
    ULONGLONG EndInterruptTime;
    ULONGLONG TimeSinceCreation;
    ULONGLONG Uptime;
    ULONGLONG SuspendedTime;
    union
    {
        ULONG HangCount : 4;
        ULONG GhostCount : 4;
        ULONG Crashed : 1;
        ULONG Terminated : 1;
    };
} PROCESS_UPTIME_INFORMATION, *PPROCESS_UPTIME_INFORMATION;

typedef union _PROCESS_SYSTEM_RESOURCE_MANAGEMENT
{
    ULONG Flags;
    struct
    {
        ULONG Foreground : 1;
        ULONG Reserved : 31;
    };
} PROCESS_SYSTEM_RESOURCE_MANAGEMENT, *PPROCESS_SYSTEM_RESOURCE_MANAGEMENT;

// private
typedef struct _PROCESS_SECURITY_DOMAIN_INFORMATION
{
    ULONGLONG SecurityDomain;
} PROCESS_SECURITY_DOMAIN_INFORMATION, *PPROCESS_SECURITY_DOMAIN_INFORMATION;

// private
typedef struct _PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION
{
    HANDLE ProcessHandle;
} PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION, *PPROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION;

// private
typedef union _PROCESS_LOGGING_INFORMATION
{
    ULONG Flags;
    struct
    {
        ULONG EnableReadVmLogging : 1;
        ULONG EnableWriteVmLogging : 1;
        ULONG EnableProcessSuspendResumeLogging : 1;
        ULONG EnableThreadSuspendResumeLogging : 1;
        ULONG Reserved : 28;
    };
} PROCESS_LOGGING_INFORMATION, *PPROCESS_LOGGING_INFORMATION;

// private
typedef struct _PROCESS_LEAP_SECOND_INFORMATION
{
    ULONG Flags;
    ULONG Reserved;
} PROCESS_LEAP_SECOND_INFORMATION, *PPROCESS_LEAP_SECOND_INFORMATION;

// private
typedef struct _PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION
{
    ULONGLONG ReserveSize;
    ULONGLONG CommitSize;
    ULONG PreferredNode;
    ULONG Reserved;
    PVOID Ssp;
} PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION, *PPROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION;

// private
typedef struct _PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION
{
    PVOID Ssp;
} PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION, *PPROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION;

//// private
//typedef struct _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE
//{
//    ULONG_PTR BaseAddress;
//    SIZE_T Size;
//    ULONG Flags;
//} PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE, *PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE;
//
//// private
//typedef struct _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION
//{
//    USHORT NumberOfRanges;
//    USHORT Reserved;
//    ULONG Reserved2;
//    PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE Ranges;
//} PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION, *PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION;

// end_private

#endif

// Thread information structures

typedef struct _THREAD_BASIC_INFORMATION
{
    NTSTATUS ExitStatus;
    PTEB TebBaseAddress;
    CLIENT_ID ClientId;
    KAFFINITY AffinityMask;
    KPRIORITY Priority;
    KPRIORITY BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

// private
typedef struct _THREAD_LAST_SYSCALL_INFORMATION
{
    PVOID FirstArgument;
    USHORT SystemCallNumber;
#ifdef WIN64
    USHORT Pad[0x3]; // since REDSTONE2
#else
    USHORT Pad[0x1]; // since REDSTONE2
#endif
    ULONG64 WaitTime;
} THREAD_LAST_SYSCALL_INFORMATION, *PTHREAD_LAST_SYSCALL_INFORMATION;

// private
typedef struct _THREAD_CYCLE_TIME_INFORMATION
{
    ULONGLONG AccumulatedCycles;
    ULONGLONG CurrentCycleCount;
} THREAD_CYCLE_TIME_INFORMATION, *PTHREAD_CYCLE_TIME_INFORMATION;

// private
typedef struct _THREAD_TEB_INFORMATION
{
    PVOID TebInformation; // buffer to place data in
    ULONG TebOffset; // offset in TEB to begin reading from
    ULONG BytesToRead; // number of bytes to read
} THREAD_TEB_INFORMATION, *PTHREAD_TEB_INFORMATION;

// symbols
typedef struct _COUNTER_READING
{
    HARDWARE_COUNTER_TYPE Type;
    ULONG Index;
    ULONG64 Start;
    ULONG64 Total;
} COUNTER_READING, *PCOUNTER_READING;

// symbols
typedef struct _THREAD_PERFORMANCE_DATA
{
    USHORT Size;
    USHORT Version;
    PROCESSOR_NUMBER ProcessorNumber;
    ULONG ContextSwitches;
    ULONG HwCountersCount;
    ULONG64 UpdateCount;
    ULONG64 WaitReasonBitMap;
    ULONG64 HardwareCounters;
    COUNTER_READING CycleTime;
    COUNTER_READING HwCounters[MAX_HW_COUNTERS];
} THREAD_PERFORMANCE_DATA, *PTHREAD_PERFORMANCE_DATA;

// private
typedef struct _THREAD_PROFILING_INFORMATION
{
    ULONG64 HardwareCounters;
    ULONG Flags;
    ULONG Enable;
    PTHREAD_PERFORMANCE_DATA PerformanceData;
} THREAD_PROFILING_INFORMATION, *PTHREAD_PROFILING_INFORMATION;

// private
typedef struct _RTL_UMS_CONTEXT
{
    SINGLE_LIST_ENTRY Link;
    CONTEXT Context;
    PVOID Teb;
    PVOID UserContext;
    volatile ULONG ScheduledThread : 1;
    volatile ULONG Suspended : 1;
    volatile ULONG VolatileContext : 1;
    volatile ULONG Terminated : 1;
    volatile ULONG DebugActive : 1;
    volatile ULONG RunningOnSelfThread : 1;
    volatile ULONG DenyRunningOnSelfThread : 1;
    volatile LONG Flags;
    volatile ULONG64 KernelUpdateLock : 2;
    volatile ULONG64 PrimaryClientID : 62;
    volatile ULONG64 ContextLock;
    struct _RTL_UMS_CONTEXT* PrimaryUmsContext;
    ULONG SwitchCount;
    ULONG KernelYieldCount;
    ULONG MixedYieldCount;
    ULONG YieldCount;
} RTL_UMS_CONTEXT, *PRTL_UMS_CONTEXT;

// private
typedef enum _THREAD_UMS_INFORMATION_COMMAND
{
    UmsInformationCommandInvalid,
    UmsInformationCommandAttach,
    UmsInformationCommandDetach,
    UmsInformationCommandQuery
} THREAD_UMS_INFORMATION_COMMAND;

// private
typedef struct _RTL_UMS_COMPLETION_LIST
{
    PSINGLE_LIST_ENTRY ThreadListHead;
    PVOID CompletionEvent;
    ULONG CompletionFlags;
    SINGLE_LIST_ENTRY InternalListHead;
} RTL_UMS_COMPLETION_LIST, *PRTL_UMS_COMPLETION_LIST;

// private
typedef struct _THREAD_UMS_INFORMATION
{
    THREAD_UMS_INFORMATION_COMMAND Command;
    PRTL_UMS_COMPLETION_LIST CompletionList;
    PRTL_UMS_CONTEXT UmsContext;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG IsUmsSchedulerThread : 1;
            ULONG IsUmsWorkerThread : 1;
            ULONG SpareBits : 30;
        };
    };
} THREAD_UMS_INFORMATION, *PTHREAD_UMS_INFORMATION;

// private
typedef struct _THREAD_NAME_INFORMATION
{
    UNICODE_STRING ThreadName;
} THREAD_NAME_INFORMATION, *PTHREAD_NAME_INFORMATION;

// private
typedef struct _ALPC_WORK_ON_BEHALF_TICKET
{
    ULONG ThreadId;
    ULONG ThreadCreationTimeLow;
} ALPC_WORK_ON_BEHALF_TICKET, *PALPC_WORK_ON_BEHALF_TICKET;

// private
typedef struct _RTL_WORK_ON_BEHALF_TICKET_EX
{
    ALPC_WORK_ON_BEHALF_TICKET Ticket;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG CurrentThread : 1;
            ULONG Reserved1 : 31;
        };
    };
    ULONG Reserved2;
} RTL_WORK_ON_BEHALF_TICKET_EX, *PRTL_WORK_ON_BEHALF_TICKET_EX;

#if (PHNT_MODE != PHNT_MODE_KERNEL)
// private
typedef enum _SUBSYSTEM_INFORMATION_TYPE
{
    SubsystemInformationTypeWin32,
    SubsystemInformationTypeWSL,
    MaxSubsystemInformationType
} SUBSYSTEM_INFORMATION_TYPE;
#endif

// private
typedef enum _THREAD_WORKLOAD_CLASS
{
    ThreadWorkloadClassDefault,
    ThreadWorkloadClassGraphics,
    MaxThreadWorkloadClass
} THREAD_WORKLOAD_CLASS;

// Processes

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritObjectTable,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE TokenHandle
    );

// begin_rev
#define PROCESS_CREATE_FLAGS_BREAKAWAY 0x00000001 // NtCreateProcessEx & NtCreateUserProcess
#define PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT 0x00000002 // NtCreateProcessEx & NtCreateUserProcess
#define PROCESS_CREATE_FLAGS_INHERIT_HANDLES 0x00000004 // NtCreateProcessEx & NtCreateUserProcess
#define PROCESS_CREATE_FLAGS_OVERRIDE_ADDRESS_SPACE 0x00000008 // NtCreateProcessEx only
#define PROCESS_CREATE_FLAGS_LARGE_PAGES 0x00000010 // NtCreateProcessEx only, requires SeLockMemory
#define PROCESS_CREATE_FLAGS_LARGE_PAGE_SYSTEM_DLL 0x00000020 // NtCreateProcessEx only, requires SeLockMemory
#define PROCESS_CREATE_FLAGS_PROTECTED_PROCESS 0x00000040 // NtCreateUserProcess only
#define PROCESS_CREATE_FLAGS_CREATE_SESSION 0x00000080 // NtCreateProcessEx & NtCreateUserProcess, requires SeLoadDriver
#define PROCESS_CREATE_FLAGS_INHERIT_FROM_PARENT 0x00000100 // NtCreateProcessEx & NtCreateUserProcess
#define PROCESS_CREATE_FLAGS_SUSPENDED 0x00000200 // NtCreateProcessEx & NtCreateUserProcess
#define PROCESS_CREATE_FLAGS_FORCE_BREAKAWAY 0x00000400 // NtCreateProcessEx & NtCreateUserProcess, requires SeTcb
#define PROCESS_CREATE_FLAGS_MINIMAL_PROCESS 0x00000800 // NtCreateProcessEx only
#define PROCESS_CREATE_FLAGS_RELEASE_SECTION 0x00001000 // NtCreateProcessEx & NtCreateUserProcess
#define PROCESS_CREATE_FLAGS_CLONE_MINIMAL 0x00002000 // NtCreateProcessEx only
#define PROCESS_CREATE_FLAGS_CLONE_MINIMAL_REDUCED_COMMIT 0x00004000 //
#define PROCESS_CREATE_FLAGS_AUXILIARY_PROCESS 0x00008000 // NtCreateProcessEx & NtCreateUserProcess, requires SeTcb
#define PROCESS_CREATE_FLAGS_CREATE_STORE 0x00020000 // NtCreateProcessEx & NtCreateUserProcess
#define PROCESS_CREATE_FLAGS_USE_PROTECTED_ENVIRONMENT 0x00040000 // NtCreateProcessEx & NtCreateUserProcess
// end_rev

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateProcessEx(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ ULONG Flags, // PROCESS_CREATE_FLAGS_*
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE TokenHandle,
    _Reserved_ ULONG Reserved // JobMemberLevel
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTerminateProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ NTSTATUS ExitStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSuspendProcess(
    _In_ HANDLE ProcessHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtResumeProcess(
    _In_ HANDLE ProcessHandle
    );

#define NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)
#define ZwCurrentProcess() NtCurrentProcess()
#define NtCurrentThread() ((HANDLE)(LONG_PTR)-2)
#define ZwCurrentThread() NtCurrentThread()
#define NtCurrentSession() ((HANDLE)(LONG_PTR)-3)
#define ZwCurrentSession() NtCurrentSession()
#define NtCurrentPeb() (NtCurrentTeb()->ProcessEnvironmentBlock)

// Windows 8 and above
#define NtCurrentProcessToken() ((HANDLE)(LONG_PTR)-4) // NtOpenProcessToken(NtCurrentProcess())
#define NtCurrentThreadToken() ((HANDLE)(LONG_PTR)-5) // NtOpenThreadToken(NtCurrentThread())
#define NtCurrentThreadEffectiveToken() ((HANDLE)(LONG_PTR)-6) // NtOpenThreadToken(NtCurrentThread()) + NtOpenProcessToken(NtCurrentProcess())

#define NtCurrentSilo() ((HANDLE)(LONG_PTR)-1)

// Not NT, but useful.
#define NtCurrentProcessId() (NtCurrentTeb()->ClientId.UniqueProcess)
#define NtCurrentThreadId() (NtCurrentTeb()->ClientId.UniqueThread)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _Out_writes_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

#if (PHNT_VERSION >= PHNT_WS03)

#define PROCESS_GET_NEXT_FLAGS_PREVIOUS_PROCESS 0x00000001

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNextProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewProcessHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNextThread(
    _In_ HANDLE ProcessHandle,
    _In_opt_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewThreadHandle
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength
    );

#endif

#define STATECHANGE_SET_ATTRIBUTES 0x0001

typedef enum _PROCESS_STATE_CHANGE_TYPE
{
    ProcessStateChangeSuspend,
    ProcessStateChangeResume,
    ProcessStateChangeMax,
} PROCESS_STATE_CHANGE_TYPE, *PPROCESS_STATE_CHANGE_TYPE;

#if (PHNT_VERSION >= PHNT_WIN11)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateProcessStateChange(
    _Out_ PHANDLE ProcessStateChangeHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _In_opt_ ULONG64 Reserved
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtChangeProcessState(
    _In_ HANDLE ProcessStateChangeHandle,
    _In_ HANDLE ProcessHandle,
    _In_ PROCESS_STATE_CHANGE_TYPE StateChangeType,
    _In_opt_ PVOID ExtendedInformation,
    _In_opt_ SIZE_T ExtendedInformationLength,
    _In_opt_ ULONG64 Reserved
    );

#endif

typedef enum _THREAD_STATE_CHANGE_TYPE
{
    ThreadStateChangeSuspend,
    ThreadStateChangeResume,
    ThreadStateChangeMax,
} THREAD_STATE_CHANGE_TYPE, *PTHREAD_STATE_CHANGE_TYPE;

#if (PHNT_VERSION >= PHNT_WIN11)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateThreadStateChange(
    _Out_ PHANDLE ThreadStateChangeHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ThreadHandle,
    _In_opt_ ULONG64 Reserved
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtChangeThreadState(
    _In_ HANDLE ThreadStateChangeHandle,
    _In_ HANDLE ThreadHandle,
    _In_ THREAD_STATE_CHANGE_TYPE StateChangeType,
    _In_opt_ PVOID ExtendedInformation,
    _In_opt_ SIZE_T ExtendedInformationLength,
    _In_opt_ ULONG64 Reserved
    );

#endif

// Threads

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _Out_ PCLIENT_ID ClientId,
    _In_ PCONTEXT ThreadContext,
    _In_ PINITIAL_TEB InitialTeb,
    _In_ BOOLEAN CreateSuspended
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTerminateThread(
    _In_opt_ HANDLE ThreadHandle,
    _In_ NTSTATUS ExitStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSuspendThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount
    );

NTSYSCALLAPI
ULONG
NTAPI
NtGetCurrentProcessorNumber(
    VOID
    );

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
ULONG
NTAPI
NtGetCurrentProcessorNumberEx(
    _Out_opt_ PPROCESSOR_NUMBER ProcessorNumber
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetContextThread(
    _In_ HANDLE ThreadHandle,
    _Inout_ PCONTEXT ThreadContext
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetContextThread(
    _In_ HANDLE ThreadHandle,
    _In_ PCONTEXT ThreadContext
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _Out_writes_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _In_reads_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlertThread(
    _In_ HANDLE ThreadHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlertResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTestAlert(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtImpersonateThread(
    _In_ HANDLE ServerThreadHandle,
    _In_ HANDLE ClientThreadHandle,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRegisterThreadTerminatePort(
    _In_ HANDLE PortHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetLdtEntries(
    _In_ ULONG Selector0,
    _In_ ULONG Entry0Low,
    _In_ ULONG Entry0Hi,
    _In_ ULONG Selector1,
    _In_ ULONG Entry1Low,
    _In_ ULONG Entry1Hi
    );

typedef VOID (NTAPI* PPS_APC_ROUTINE)(
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
    );

#define Wow64EncodeApcRoutine(ApcRoutine) \
    ((PVOID)((0 - ((LONG_PTR)(ApcRoutine))) << 2))

#define Wow64DecodeApcRoutine(ApcRoutine) \
    ((PVOID)(0 - (((LONG_PTR)(ApcRoutine)) >> 2)))

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueueApcThread(
    _In_ HANDLE ThreadHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
    );

#if (PHNT_VERSION >= PHNT_WIN7)

#define APC_FORCE_THREAD_SIGNAL ((HANDLE)1) // ReserveHandle

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueueApcThreadEx(
    _In_ HANDLE ThreadHandle,
    _In_opt_ HANDLE ReserveHandle, // NtAllocateReserveObject
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN11)

#if !defined(NTDDI_WIN10_CO) || (NTDDI_VERSION < NTDDI_WIN10_CO)
typedef enum _QUEUE_USER_APC_FLAGS
{
    QUEUE_USER_APC_FLAGS_NONE = 0x0,
    QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC = 0x1,
} QUEUE_USER_APC_FLAGS;
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueueApcThreadEx2(
    _In_ HANDLE ThreadHandle,
    _In_opt_ HANDLE ReserveHandle, // NtAllocateReserveObject
    _In_ ULONG ApcFlags, // QUEUE_USER_APC_FLAGS
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
    );

#endif

#if (PHNT_VERSION >= PHNT_WIN8)

// rev
NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlertThreadByThreadId(
    _In_ HANDLE ThreadId
    );

// rev
NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForAlertByThreadId(
    _In_ PVOID Address,
    _In_opt_ PLARGE_INTEGER Timeout
    );

#endif

#endif

// User processes and threads

#if (PHNT_MODE != PHNT_MODE_KERNEL)

// Attributes (Win32 CreateProcess)

// PROC_THREAD_ATTRIBUTE_NUM (dmex)
#define ProcThreadAttributeParentProcess 0 // in HANDLE
#define ProcThreadAttributeExtendedFlags 1 // in ULONG (EXTENDED_PROCESS_CREATION_FLAG_*)
#define ProcThreadAttributeHandleList 2 // in HANDLE[]
#define ProcThreadAttributeGroupAffinity 3 // in GROUP_AFFINITY // since WIN7
#define ProcThreadAttributePreferredNode 4 // in USHORT
#define ProcThreadAttributeIdealProcessor 5 // in PROCESSOR_NUMBER
#define ProcThreadAttributeUmsThread 6 // in UMS_CREATE_THREAD_ATTRIBUTES
#define ProcThreadAttributeMitigationPolicy 7 // in ULONG, ULONG64, or ULONG64[2]
#define ProcThreadAttributePackageFullName 8 // in WCHAR[] // since WIN8
#define ProcThreadAttributeSecurityCapabilities 9 // in SECURITY_CAPABILITIES
#define ProcThreadAttributeConsoleReference 10 // BaseGetConsoleReference (kernelbase.dll)
#define ProcThreadAttributeProtectionLevel 11 // in ULONG (PROTECTION_LEVEL_*) // since WINBLUE
#define ProcThreadAttributeOsMaxVersionTested 12 // in MAXVERSIONTESTED_INFO // since THRESHOLD // (from exe.manifest)
#define ProcThreadAttributeJobList 13 // in HANDLE[]
#define ProcThreadAttributeChildProcessPolicy 14 // in ULONG (PROCESS_CREATION_CHILD_PROCESS_*) // since THRESHOLD2
#define ProcThreadAttributeAllApplicationPackagesPolicy 15 // in ULONG (PROCESS_CREATION_ALL_APPLICATION_PACKAGES_*) // since REDSTONE
#define ProcThreadAttributeWin32kFilter 16 // in WIN32K_SYSCALL_FILTER
#define ProcThreadAttributeSafeOpenPromptOriginClaim 17 // in SE_SAFE_OPEN_PROMPT_RESULTS
#define ProcThreadAttributeDesktopAppPolicy 18 // in ULONG (PROCESS_CREATION_DESKTOP_APP_*) // since RS2
#define ProcThreadAttributeBnoIsolation 19 // in PROC_THREAD_BNOISOLATION_ATTRIBUTE
#define ProcThreadAttributePseudoConsole 22 // in HANDLE (HPCON) // since RS5
#define ProcThreadAttributeIsolationManifest 23 // in ISOLATION_MANIFEST_PROPERTIES // rev (diversenok) // since 19H2+
#define ProcThreadAttributeMitigationAuditPolicy 24 // in ULONG, ULONG64, or ULONG64[2] // since 21H1
#define ProcThreadAttributeMachineType 25 // in USHORT // since 21H2
#define ProcThreadAttributeComponentFilter 26 // in ULONG
#define ProcThreadAttributeEnableOptionalXStateFeatures 27 // in ULONG64 // since WIN11
#define ProcThreadAttributeCreateStore 28 // ULONG // rev (diversenok)
#define ProcThreadAttributeTrustedApp 29

#ifndef PROC_THREAD_ATTRIBUTE_EXTENDED_FLAGS
#define PROC_THREAD_ATTRIBUTE_EXTENDED_FLAGS \
    ProcThreadAttributeValue(ProcThreadAttributeExtendedFlags, FALSE, TRUE, TRUE)
#endif
#ifndef PROC_THREAD_ATTRIBUTE_PACKAGE_FULL_NAME
#define PROC_THREAD_ATTRIBUTE_PACKAGE_FULL_NAME \
    ProcThreadAttributeValue(ProcThreadAttributePackageFullName, FALSE, TRUE, FALSE)
#endif
#ifndef PROC_THREAD_ATTRIBUTE_CONSOLE_REFERENCE
#define PROC_THREAD_ATTRIBUTE_CONSOLE_REFERENCE \
    ProcThreadAttributeValue(ProcThreadAttributeConsoleReference, FALSE, TRUE, FALSE)
#endif
#ifndef PROC_THREAD_ATTRIBUTE_OSMAXVERSIONTESTED
#define PROC_THREAD_ATTRIBUTE_OSMAXVERSIONTESTED \
    ProcThreadAttributeValue(ProcThreadAttributeOsMaxVersionTested, FALSE, TRUE, FALSE)
#endif
#ifndef PROC_THREAD_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM
#define PROC_THREAD_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM \
    ProcThreadAttributeValue(ProcThreadAttributeSafeOpenPromptOriginClaim, FALSE, TRUE, FALSE)
#endif
#ifndef PROC_THREAD_ATTRIBUTE_BNO_ISOLATION
#define PROC_THREAD_ATTRIBUTE_BNO_ISOLATION \
    ProcThreadAttributeValue(ProcThreadAttributeBnoIsolation, FALSE, TRUE, FALSE)
#endif
#ifndef PROC_THREAD_ATTRIBUTE_ISOLATION_MANIFEST
#define PROC_THREAD_ATTRIBUTE_ISOLATION_MANIFEST \
    ProcThreadAttributeValue(ProcThreadAttributeIsolationManifest, FALSE, TRUE, FALSE)
#endif
#ifndef PROC_THREAD_ATTRIBUTE_CREATE_STORE
#define PROC_THREAD_ATTRIBUTE_CREATE_STORE \
    ProcThreadAttributeValue(ProcThreadAttributeCreateStore, FALSE, TRUE, FALSE)
#endif

// private
typedef struct _PROC_THREAD_ATTRIBUTE
{
    ULONG_PTR Attribute;
    SIZE_T Size;
    ULONG_PTR Value;
} PROC_THREAD_ATTRIBUTE, *PPROC_THREAD_ATTRIBUTE;

// private
typedef struct _PROC_THREAD_ATTRIBUTE_LIST
{
    ULONG PresentFlags;
    ULONG AttributeCount;
    ULONG LastAttribute;
    ULONG SpareUlong0;
    PPROC_THREAD_ATTRIBUTE ExtendedFlagsAttribute;
    PROC_THREAD_ATTRIBUTE Attributes[1];
} PROC_THREAD_ATTRIBUTE_LIST, *PPROC_THREAD_ATTRIBUTE_LIST;

// private
#define EXTENDED_PROCESS_CREATION_FLAG_ELEVATION_HANDLED 0x00000001
#define EXTENDED_PROCESS_CREATION_FLAG_FORCELUA 0x00000002
#define EXTENDED_PROCESS_CREATION_FLAG_FORCE_BREAKAWAY 0x00000004 // requires SeTcbPrivilege // since WINBLUE

// private
#define PROTECTION_LEVEL_WINTCB_LIGHT 0x00000000
#define PROTECTION_LEVEL_WINDOWS 0x00000001
#define PROTECTION_LEVEL_WINDOWS_LIGHT 0x00000002
#define PROTECTION_LEVEL_ANTIMALWARE_LIGHT 0x00000003
#define PROTECTION_LEVEL_LSA_LIGHT 0x00000004
#define PROTECTION_LEVEL_WINTCB 0x00000005
#define PROTECTION_LEVEL_CODEGEN_LIGHT 0x00000006
#define PROTECTION_LEVEL_AUTHENTICODE 0x00000007

// private
typedef enum _SE_SAFE_OPEN_PROMPT_EXPERIENCE_RESULTS
{
    SeSafeOpenExperienceNone = 0x00,
    SeSafeOpenExperienceCalled = 0x01,
    SeSafeOpenExperienceAppRepCalled = 0x02,
    SeSafeOpenExperiencePromptDisplayed = 0x04,
    SeSafeOpenExperienceUAC = 0x08,
    SeSafeOpenExperienceUninstaller = 0x10,
    SeSafeOpenExperienceIgnoreUnknownOrBad = 0x20,
    SeSafeOpenExperienceDefenderTrustedInstaller = 0x40,
    SeSafeOpenExperienceMOTWPresent = 0x80
} SE_SAFE_OPEN_PROMPT_EXPERIENCE_RESULTS;

// private
typedef struct _SE_SAFE_OPEN_PROMPT_RESULTS
{
    SE_SAFE_OPEN_PROMPT_EXPERIENCE_RESULTS Results;
    WCHAR Path[MAX_PATH];
} SE_SAFE_OPEN_PROMPT_RESULTS, *PSE_SAFE_OPEN_PROMPT_RESULTS;

typedef struct _PROC_THREAD_BNOISOLATION_ATTRIBUTE
{
    BOOL IsolationEnabled;
    WCHAR IsolationPrefix[0x88];
} PROC_THREAD_BNOISOLATION_ATTRIBUTE, *PPROC_THREAD_BNOISOLATION_ATTRIBUTE;

// private
typedef struct _ISOLATION_MANIFEST_PROPERTIES
{
    UNICODE_STRING InstancePath;
    UNICODE_STRING FriendlyName;
    UNICODE_STRING Description;
    ULONG_PTR Level;
} ISOLATION_MANIFEST_PROPERTIES, *PISOLATION_MANIFEST_PROPERTIES;

#ifndef PROC_THREAD_ATTRIBUTE_EXTENDED_FLAGS
#define PROC_THREAD_ATTRIBUTE_EXTENDED_FLAGS \
    ProcThreadAttributeValue(ProcThreadAttributeExtendedFlags, FALSE, TRUE, TRUE)
#endif
#ifndef PROC_THREAD_ATTRIBUTE_CONSOLE_REFERENCE
#define PROC_THREAD_ATTRIBUTE_CONSOLE_REFERENCE \
    ProcThreadAttributeValue(ProcThreadAttributeConsoleReference, FALSE, TRUE, FALSE)
#endif
#ifndef PROC_THREAD_ATTRIBUTE_OSMAXVERSIONTESTED
#define PROC_THREAD_ATTRIBUTE_OSMAXVERSIONTESTED \
    ProcThreadAttributeValue(ProcThreadAttributeOsMaxVersionTested, FALSE, TRUE, FALSE)
#endif
#ifndef PROC_THREAD_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM
#define PROC_THREAD_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM \
    ProcThreadAttributeValue(ProcThreadAttributeSafeOpenPromptOriginClaim, FALSE, TRUE, FALSE)
#endif
#ifndef PROC_THREAD_ATTRIBUTE_BNO_ISOLATION
#define PROC_THREAD_ATTRIBUTE_BNO_ISOLATION \
    ProcThreadAttributeValue(ProcThreadAttributeBnoIsolation, FALSE, TRUE, FALSE)
#endif

// Attributes (Native)

// private
typedef enum _PS_ATTRIBUTE_NUM
{
    PsAttributeParentProcess, // in HANDLE
    PsAttributeDebugObject, // in HANDLE
    PsAttributeToken, // in HANDLE
    PsAttributeClientId, // out PCLIENT_ID
    PsAttributeTebAddress, // out PTEB *
    PsAttributeImageName, // in PWSTR
    PsAttributeImageInfo, // out PSECTION_IMAGE_INFORMATION
    PsAttributeMemoryReserve, // in PPS_MEMORY_RESERVE
    PsAttributePriorityClass, // in UCHAR
    PsAttributeErrorMode, // in ULONG
    PsAttributeStdHandleInfo, // 10, in PPS_STD_HANDLE_INFO
    PsAttributeHandleList, // in HANDLE[]
    PsAttributeGroupAffinity, // in PGROUP_AFFINITY
    PsAttributePreferredNode, // in PUSHORT
    PsAttributeIdealProcessor, // in PPROCESSOR_NUMBER
    PsAttributeUmsThread, // ? in PUMS_CREATE_THREAD_ATTRIBUTES
    PsAttributeMitigationOptions, // in PPS_MITIGATION_OPTIONS_MAP (PROCESS_CREATION_MITIGATION_POLICY_*) // since WIN8
    PsAttributeProtectionLevel, // in PS_PROTECTION // since WINBLUE
    PsAttributeSecureProcess, // in PPS_TRUSTLET_CREATE_ATTRIBUTES, since THRESHOLD
    PsAttributeJobList, // in HANDLE[]
    PsAttributeChildProcessPolicy, // 20, in PULONG (PROCESS_CREATION_CHILD_PROCESS_*) // since THRESHOLD2
    PsAttributeAllApplicationPackagesPolicy, // in PULONG (PROCESS_CREATION_ALL_APPLICATION_PACKAGES_*) // since REDSTONE
    PsAttributeWin32kFilter, // in PWIN32K_SYSCALL_FILTER
    PsAttributeSafeOpenPromptOriginClaim, // in
    PsAttributeBnoIsolation, // in PPS_BNO_ISOLATION_PARAMETERS // since REDSTONE2
    PsAttributeDesktopAppPolicy, // in PULONG (PROCESS_CREATION_DESKTOP_APP_*)
    PsAttributeChpe, // in BOOLEAN // since REDSTONE3
    PsAttributeMitigationAuditOptions, // in PPS_MITIGATION_AUDIT_OPTIONS_MAP (PROCESS_CREATION_MITIGATION_AUDIT_POLICY_*) // since 21H1
    PsAttributeMachineType, // in WORD // since 21H2
    PsAttributeComponentFilter,
    PsAttributeEnableOptionalXStateFeatures, // since WIN11
    PsAttributeMax
} PS_ATTRIBUTE_NUM;

// private
#define PS_ATTRIBUTE_NUMBER_MASK 0x0000ffff
#define PS_ATTRIBUTE_THREAD 0x00010000 // may be used with thread creation
#define PS_ATTRIBUTE_INPUT 0x00020000 // input only
#define PS_ATTRIBUTE_ADDITIVE 0x00040000 // "accumulated" e.g. bitmasks, counters, etc.

// begin_rev

#define PsAttributeValue(Number, Thread, Input, Additive) \
    (((Number) & PS_ATTRIBUTE_NUMBER_MASK) | \
    ((Thread) ? PS_ATTRIBUTE_THREAD : 0) | \
    ((Input) ? PS_ATTRIBUTE_INPUT : 0) | \
    ((Additive) ? PS_ATTRIBUTE_ADDITIVE : 0))

#define PS_ATTRIBUTE_PARENT_PROCESS \
    PsAttributeValue(PsAttributeParentProcess, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_DEBUG_OBJECT \
    PsAttributeValue(PsAttributeDebugObject, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_TOKEN \
    PsAttributeValue(PsAttributeToken, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_CLIENT_ID \
    PsAttributeValue(PsAttributeClientId, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_TEB_ADDRESS \
    PsAttributeValue(PsAttributeTebAddress, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_IMAGE_NAME \
    PsAttributeValue(PsAttributeImageName, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IMAGE_INFO \
    PsAttributeValue(PsAttributeImageInfo, FALSE, FALSE, FALSE)
#define PS_ATTRIBUTE_MEMORY_RESERVE \
    PsAttributeValue(PsAttributeMemoryReserve, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_PRIORITY_CLASS \
    PsAttributeValue(PsAttributePriorityClass, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ERROR_MODE \
    PsAttributeValue(PsAttributeErrorMode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_STD_HANDLE_INFO \
    PsAttributeValue(PsAttributeStdHandleInfo, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_HANDLE_LIST \
    PsAttributeValue(PsAttributeHandleList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_GROUP_AFFINITY \
    PsAttributeValue(PsAttributeGroupAffinity, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_PREFERRED_NODE \
    PsAttributeValue(PsAttributePreferredNode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IDEAL_PROCESSOR \
    PsAttributeValue(PsAttributeIdealProcessor, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_UMS_THREAD \
    PsAttributeValue(PsAttributeUmsThread, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_MITIGATION_OPTIONS \
    PsAttributeValue(PsAttributeMitigationOptions, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_PROTECTION_LEVEL \
    PsAttributeValue(PsAttributeProtectionLevel, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_SECURE_PROCESS \
    PsAttributeValue(PsAttributeSecureProcess, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_JOB_LIST \
    PsAttributeValue(PsAttributeJobList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_CHILD_PROCESS_POLICY \
    PsAttributeValue(PsAttributeChildProcessPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY \
    PsAttributeValue(PsAttributeAllApplicationPackagesPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_WIN32K_FILTER \
    PsAttributeValue(PsAttributeWin32kFilter, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM \
    PsAttributeValue(PsAttributeSafeOpenPromptOriginClaim, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_BNO_ISOLATION \
    PsAttributeValue(PsAttributeBnoIsolation, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_DESKTOP_APP_POLICY \
    PsAttributeValue(PsAttributeDesktopAppPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_CHPE \
    PsAttributeValue(PsAttributeChpe, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_MITIGATION_AUDIT_OPTIONS \
    PsAttributeValue(PsAttributeMitigationAuditOptions, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_MACHINE_TYPE \
    PsAttributeValue(PsAttributeMachineType, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_COMPONENT_FILTER \
    PsAttributeValue(PsAttributeComponentFilter, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ENABLE_OPTIONAL_XSTATE_FEATURES \
    PsAttributeValue(PsAttributeEnableOptionalXStateFeatures, TRUE, TRUE, FALSE)

// end_rev

// begin_private

typedef struct _PS_ATTRIBUTE
{
    ULONG_PTR Attribute;
    SIZE_T Size;
    union
    {
        ULONG_PTR Value;
        PVOID ValuePtr;
    };
    PSIZE_T ReturnLength;
} PS_ATTRIBUTE, *PPS_ATTRIBUTE;

typedef struct _PS_ATTRIBUTE_LIST
{
    SIZE_T TotalLength;
    PS_ATTRIBUTE Attributes[1];
} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;

typedef struct _PS_MEMORY_RESERVE
{
    PVOID ReserveAddress;
    SIZE_T ReserveSize;
} PS_MEMORY_RESERVE, *PPS_MEMORY_RESERVE;

typedef enum _PS_STD_HANDLE_STATE
{
    PsNeverDuplicate,
    PsRequestDuplicate, // duplicate standard handles specified by PseudoHandleMask, and only if StdHandleSubsystemType matches the image subsystem
    PsAlwaysDuplicate, // always duplicate standard handles
    PsMaxStdHandleStates
} PS_STD_HANDLE_STATE;

// begin_rev
#define PS_STD_INPUT_HANDLE 0x1
#define PS_STD_OUTPUT_HANDLE 0x2
#define PS_STD_ERROR_HANDLE 0x4
// end_rev

typedef struct _PS_STD_HANDLE_INFO
{
    union
    {
        ULONG Flags;
        struct
        {
            ULONG StdHandleState : 2; // PS_STD_HANDLE_STATE
            ULONG PseudoHandleMask : 3; // PS_STD_*
        };
    };
    ULONG StdHandleSubsystemType;
} PS_STD_HANDLE_INFO, *PPS_STD_HANDLE_INFO;

typedef union _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS
{
    UCHAR Trustlet : 1;
    UCHAR Ntos : 1;
    UCHAR WriteHandle : 1;
    UCHAR ReadHandle : 1;
    UCHAR Reserved : 4;
    UCHAR AccessRights;
} PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS, *PPS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS;

typedef struct _PS_TRUSTLET_ATTRIBUTE_TYPE
{
    union
    {
        struct
        {
            UCHAR Version;
            UCHAR DataCount;
            UCHAR SemanticType;
            PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS AccessRights;
        };
        ULONG AttributeType;
    };
} PS_TRUSTLET_ATTRIBUTE_TYPE, *PPS_TRUSTLET_ATTRIBUTE_TYPE;

typedef struct _PS_TRUSTLET_ATTRIBUTE_HEADER
{
    PS_TRUSTLET_ATTRIBUTE_TYPE AttributeType;
    ULONG InstanceNumber : 8;
    ULONG Reserved : 24;
} PS_TRUSTLET_ATTRIBUTE_HEADER, *PPS_TRUSTLET_ATTRIBUTE_HEADER;

typedef struct _PS_TRUSTLET_ATTRIBUTE_DATA
{
    PS_TRUSTLET_ATTRIBUTE_HEADER Header;
    ULONGLONG Data[1];
} PS_TRUSTLET_ATTRIBUTE_DATA, *PPS_TRUSTLET_ATTRIBUTE_DATA;

typedef struct _PS_TRUSTLET_CREATE_ATTRIBUTES
{
    ULONGLONG TrustletIdentity;
    PS_TRUSTLET_ATTRIBUTE_DATA Attributes[1];
} PS_TRUSTLET_CREATE_ATTRIBUTES, *PPS_TRUSTLET_CREATE_ATTRIBUTES;

// private
typedef struct _PS_BNO_ISOLATION_PARAMETERS
{
    UNICODE_STRING IsolationPrefix;
    ULONG HandleCount;
    PVOID *Handles;
    BOOLEAN IsolationEnabled;
} PS_BNO_ISOLATION_PARAMETERS, *PPS_BNO_ISOLATION_PARAMETERS;

// private
typedef enum _PS_MITIGATION_OPTION
{
    PS_MITIGATION_OPTION_NX,
    PS_MITIGATION_OPTION_SEHOP,
    PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES,
    PS_MITIGATION_OPTION_HEAP_TERMINATE,
    PS_MITIGATION_OPTION_BOTTOM_UP_ASLR,
    PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR,
    PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS,
    PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE,
    PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE,
    PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE,
    PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES,
    PS_MITIGATION_OPTION_FONT_DISABLE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL,
    PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32,
    PS_MITIGATION_OPTION_RETURN_FLOW_GUARD,
    PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY,
    PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT,
    PS_MITIGATION_OPTION_ROP_STACKPIVOT, // since REDSTONE3
    PS_MITIGATION_OPTION_ROP_CALLER_CHECK,
    PS_MITIGATION_OPTION_ROP_SIMEXEC,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS,
    PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION,
    PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER,
    PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION,
    PS_MITIGATION_OPTION_RESTRICT_INDIRECT_BRANCH_PREDICTION,
    PS_MITIGATION_OPTION_SPECULATIVE_STORE_BYPASS_DISABLE, // since REDSTONE5
    PS_MITIGATION_OPTION_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY,
    PS_MITIGATION_OPTION_CET_USER_SHADOW_STACKS,
    PS_MITIGATION_OPTION_USER_CET_SET_CONTEXT_IP_VALIDATION, // since 21H1
    PS_MITIGATION_OPTION_BLOCK_NON_CET_BINARIES,
    PS_MITIGATION_OPTION_CET_DYNAMIC_APIS_OUT_OF_PROC_ONLY,
    PS_MITIGATION_OPTION_REDIRECTION_TRUST, // since 22H1
} PS_MITIGATION_OPTION;

// windows-internals-book:"Chapter 5"
typedef enum _PS_CREATE_STATE
{
    PsCreateInitialState,
    PsCreateFailOnFileOpen,
    PsCreateFailOnSectionCreate,
    PsCreateFailExeFormat,
    PsCreateFailMachineMismatch,
    PsCreateFailExeName, // Debugger specified
    PsCreateSuccess,
    PsCreateMaximumStates
} PS_CREATE_STATE;

typedef struct _PS_CREATE_INFO
{
    SIZE_T Size;
    PS_CREATE_STATE State;
    union
    {
        // PsCreateInitialState
        struct
        {
            union
            {
                ULONG InitFlags;
                struct
                {
                    UCHAR WriteOutputOnExit : 1;
                    UCHAR DetectManifest : 1;
                    UCHAR IFEOSkipDebugger : 1;
                    UCHAR IFEODoNotPropagateKeyState : 1;
                    UCHAR SpareBits1 : 4;
                    UCHAR SpareBits2 : 8;
                    USHORT ProhibitedImageCharacteristics : 16;
                };
            };
            ACCESS_MASK AdditionalFileAccess;
        } InitState;

        // PsCreateFailOnSectionCreate
        struct
        {
            HANDLE FileHandle;
        } FailSection;

        // PsCreateFailExeFormat
        struct
        {
            USHORT DllCharacteristics;
        } ExeFormat;

        // PsCreateFailExeName
        struct
        {
            HANDLE IFEOKey;
        } ExeName;

        // PsCreateSuccess
        struct
        {
            union
            {
                ULONG OutputFlags;
                struct
                {
                    UCHAR ProtectedProcess : 1;
                    UCHAR AddressSpaceOverride : 1;
                    UCHAR DevOverrideEnabled : 1; // from Image File Execution Options
                    UCHAR ManifestDetected : 1;
                    UCHAR ProtectedProcessLight : 1;
                    UCHAR SpareBits1 : 3;
                    UCHAR SpareBits2 : 8;
                    USHORT SpareBits3 : 16;
                };
            };
            HANDLE FileHandle;
            HANDLE SectionHandle;
            ULONGLONG UserProcessParametersNative;
            ULONG UserProcessParametersWow64;
            ULONG CurrentParameterFlags;
            ULONGLONG PebAddressNative;
            ULONG PebAddressWow64;
            ULONGLONG ManifestAddress;
            ULONG ManifestSize;
        } SuccessState;
    };
} PS_CREATE_INFO, *PPS_CREATE_INFO;

// end_private

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateUserProcess(
    _Out_ PHANDLE ProcessHandle,
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK ProcessDesiredAccess,
    _In_ ACCESS_MASK ThreadDesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
    _In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
    _In_ ULONG ProcessFlags, // PROCESS_CREATE_FLAGS_*
    _In_ ULONG ThreadFlags, // THREAD_CREATE_FLAGS_*
    _In_opt_ PVOID ProcessParameters, // PRTL_USER_PROCESS_PARAMETERS
    _Inout_ PPS_CREATE_INFO CreateInfo,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList
    );
#endif

// begin_rev
#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED 0x00000001 // NtCreateUserProcess & NtCreateThreadEx
#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH 0x00000002 // NtCreateThreadEx only
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER 0x00000004 // NtCreateThreadEx only
#define THREAD_CREATE_FLAGS_LOADER_WORKER 0x00000010 // NtCreateThreadEx only
#define THREAD_CREATE_FLAGS_SKIP_LOADER_INIT 0x00000020 // NtCreateThreadEx only
#define THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE 0x00000040 // NtCreateThreadEx only
#define THREAD_CREATE_FLAGS_INITIAL_THREAD 0x00000080 // ?
// end_rev

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateThreadEx(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _In_ PVOID StartRoutine, // PUSER_THREAD_START_ROUTINE
    _In_opt_ PVOID Argument,
    _In_ ULONG CreateFlags, // THREAD_CREATE_FLAGS_*
    _In_ SIZE_T ZeroBits,
    _In_ SIZE_T StackSize,
    _In_ SIZE_T MaximumStackSize,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList
    );
#endif

#endif

// Job objects

#if (PHNT_MODE != PHNT_MODE_KERNEL)

// JOBOBJECTINFOCLASS
// Note: We don't use an enum since it conflicts with the Windows SDK.
#define JobObjectBasicAccountingInformation 1 // JOBOBJECT_BASIC_ACCOUNTING_INFORMATION
#define JobObjectBasicLimitInformation 2 // JOBOBJECT_BASIC_LIMIT_INFORMATION
#define JobObjectBasicProcessIdList 3 // JOBOBJECT_BASIC_PROCESS_ID_LIST
#define JobObjectBasicUIRestrictions 4 // JOBOBJECT_BASIC_UI_RESTRICTIONS
#define JobObjectSecurityLimitInformation 5 // JOBOBJECT_SECURITY_LIMIT_INFORMATION
#define JobObjectEndOfJobTimeInformation 6 // JOBOBJECT_END_OF_JOB_TIME_INFORMATION
#define JobObjectAssociateCompletionPortInformation 7 // JOBOBJECT_ASSOCIATE_COMPLETION_PORT
#define JobObjectBasicAndIoAccountingInformation 8 // JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION
#define JobObjectExtendedLimitInformation 9 // JOBOBJECT_EXTENDED_LIMIT_INFORMATION
#define JobObjectJobSetInformation 10 // JOBOBJECT_JOBSET_INFORMATION
#define JobObjectGroupInformation 11 // USHORT
#define JobObjectNotificationLimitInformation 12 // JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION
#define JobObjectLimitViolationInformation 13 // JOBOBJECT_LIMIT_VIOLATION_INFORMATION
#define JobObjectGroupInformationEx 14 // GROUP_AFFINITY (ARRAY)
#define JobObjectCpuRateControlInformation 15 // JOBOBJECT_CPU_RATE_CONTROL_INFORMATION
#define JobObjectCompletionFilter 16
#define JobObjectCompletionCounter 17
#define JobObjectFreezeInformation 18 // JOBOBJECT_FREEZE_INFORMATION
#define JobObjectExtendedAccountingInformation 19 // JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION
#define JobObjectWakeInformation 20 // JOBOBJECT_WAKE_INFORMATION
#define JobObjectBackgroundInformation 21
#define JobObjectSchedulingRankBiasInformation 22
#define JobObjectTimerVirtualizationInformation 23
#define JobObjectCycleTimeNotification 24
#define JobObjectClearEvent 25
#define JobObjectInterferenceInformation 26 // JOBOBJECT_INTERFERENCE_INFORMATION
#define JobObjectClearPeakJobMemoryUsed 27
#define JobObjectMemoryUsageInformation 28 // JOBOBJECT_MEMORY_USAGE_INFORMATION // JOBOBJECT_MEMORY_USAGE_INFORMATION_V2
#define JobObjectSharedCommit 29
#define JobObjectContainerId 30
#define JobObjectIoRateControlInformation 31
#define JobObjectNetRateControlInformation 32 // JOBOBJECT_NET_RATE_CONTROL_INFORMATION
#define JobObjectNotificationLimitInformation2 33 // JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2
#define JobObjectLimitViolationInformation2 34 // JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2
#define JobObjectCreateSilo 35
#define JobObjectSiloBasicInformation 36 // SILOOBJECT_BASIC_INFORMATION
#define JobObjectSiloRootDirectory 37 // SILOOBJECT_ROOT_DIRECTORY
#define JobObjectServerSiloBasicInformation 38 // SERVERSILO_BASIC_INFORMATION
#define JobObjectServerSiloUserSharedData 39 // SILO_USER_SHARED_DATA
#define JobObjectServerSiloInitialize 40
#define JobObjectServerSiloRunningState 41
#define JobObjectIoAttribution 42
#define JobObjectMemoryPartitionInformation 43
#define JobObjectContainerTelemetryId 44
#define JobObjectSiloSystemRoot 45
#define JobObjectEnergyTrackingState 46 // JOBOBJECT_ENERGY_TRACKING_STATE
#define JobObjectThreadImpersonationInformation 47
#define JobObjectIoPriorityLimit 48
#define JobObjectPagePriorityLimit 49
#define MaxJobObjectInfoClass 50

// private
typedef struct _JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION
{
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    IO_COUNTERS IoInfo;
    PROCESS_DISK_COUNTERS DiskIoInfo;
    ULONG64 ContextSwitches;
    LARGE_INTEGER TotalCycleTime;
    ULONG64 ReadyTime;
    PROCESS_ENERGY_VALUES EnergyValues;
} JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION, *PJOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION;

// private
typedef struct _JOBOBJECT_WAKE_INFORMATION
{
    HANDLE NotificationChannel;
    ULONG64 WakeCounters[7];
} JOBOBJECT_WAKE_INFORMATION, *PJOBOBJECT_WAKE_INFORMATION;

// private
typedef struct _JOBOBJECT_WAKE_INFORMATION_V1
{
    HANDLE NotificationChannel;
    ULONG64 WakeCounters[4];
} JOBOBJECT_WAKE_INFORMATION_V1, *PJOBOBJECT_WAKE_INFORMATION_V1;

// private
typedef struct _JOBOBJECT_INTERFERENCE_INFORMATION
{
    ULONG64 Count;
} JOBOBJECT_INTERFERENCE_INFORMATION, *PJOBOBJECT_INTERFERENCE_INFORMATION;

// private
typedef struct _JOBOBJECT_WAKE_FILTER
{
    ULONG HighEdgeFilter;
    ULONG LowEdgeFilter;
} JOBOBJECT_WAKE_FILTER, *PJOBOBJECT_WAKE_FILTER;

// private
typedef struct _JOBOBJECT_FREEZE_INFORMATION
{
    union
    {
        ULONG Flags;
        struct
        {
            ULONG FreezeOperation : 1;
            ULONG FilterOperation : 1;
            ULONG SwapOperation : 1;
            ULONG Reserved : 29;
        };
    };
    BOOLEAN Freeze;
    BOOLEAN Swap;
    UCHAR Reserved0[2];
    JOBOBJECT_WAKE_FILTER WakeFilter;
} JOBOBJECT_FREEZE_INFORMATION, *PJOBOBJECT_FREEZE_INFORMATION;

// private
typedef struct _JOBOBJECT_MEMORY_USAGE_INFORMATION
{
    ULONG64 JobMemory;
    ULONG64 PeakJobMemoryUsed;
} JOBOBJECT_MEMORY_USAGE_INFORMATION, *PJOBOBJECT_MEMORY_USAGE_INFORMATION;

// private
typedef struct _JOBOBJECT_MEMORY_USAGE_INFORMATION_V2
{
    JOBOBJECT_MEMORY_USAGE_INFORMATION BasicInfo;
    ULONG64 JobSharedMemory;
    ULONG64 Reserved[2];
} JOBOBJECT_MEMORY_USAGE_INFORMATION_V2, *PJOBOBJECT_MEMORY_USAGE_INFORMATION_V2;

// private
typedef struct _SILO_USER_SHARED_DATA
{
    ULONG64 ServiceSessionId;
    ULONG ActiveConsoleId;
    LONGLONG ConsoleSessionForegroundProcessId;
    NT_PRODUCT_TYPE NtProductType;
    ULONG SuiteMask;
    ULONG SharedUserSessionId;
    BOOLEAN IsMultiSessionSku;
    WCHAR NtSystemRoot[260];
    USHORT UserModeGlobalLogger[16];
} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;

// private
typedef struct _SILOOBJECT_ROOT_DIRECTORY
{
    ULONG ControlFlags;
    UNICODE_STRING Path;
} SILOOBJECT_ROOT_DIRECTORY, *PSILOOBJECT_ROOT_DIRECTORY;

// private
typedef struct _JOBOBJECT_ENERGY_TRACKING_STATE
{
    ULONG64 Value;
    ULONG UpdateMask;
    ULONG DesiredState;
} JOBOBJECT_ENERGY_TRACKING_STATE, *PJOBOBJECT_ENERGY_TRACKING_STATE;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAssignProcessToJobObject(
    _In_ HANDLE JobHandle,
    _In_ HANDLE ProcessHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTerminateJobObject(
    _In_ HANDLE JobHandle,
    _In_ NTSTATUS ExitStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtIsProcessInJob(
    _In_ HANDLE ProcessHandle,
    _In_opt_ HANDLE JobHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationJobObject(
    _In_opt_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _Out_writes_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationJobObject(
    _In_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _In_reads_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateJobSet(
    _In_ ULONG NumJob,
    _In_reads_(NumJob) PJOB_SET_ARRAY UserJobSet,
    _In_ ULONG Flags
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRevertContainerImpersonation(
    VOID
    );
#endif

#endif

// Reserve objects

#if (PHNT_MODE != PHNT_MODE_KERNEL)

// private
typedef enum _MEMORY_RESERVE_TYPE
{
    MemoryReserveUserApc,
    MemoryReserveIoCompletion,
    MemoryReserveTypeMax
} MEMORY_RESERVE_TYPE;

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateReserveObject(
    _Out_ PHANDLE MemoryReserveHandle,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ MEMORY_RESERVE_TYPE Type
    );
#endif

// Process snapshotting

#if (PHNT_VERSION >= PHNT_WINBLUE)
// rev
NTSYSCALLAPI
NTSTATUS
NTAPI
PssNtCaptureSnapshot(
    _Out_ PHANDLE SnapshotHandle,
    _In_ HANDLE ProcessHandle,
    _In_ ULONG CaptureFlags,
    _In_ ULONG ThreadContextFlags
    );
#endif

#endif

#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
#include <cfg.h>
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTDBG_H
#define _NTDBG_H

// Debugging

NTSYSAPI
VOID
NTAPI
DbgUserBreakPoint(
    VOID
    );

NTSYSAPI
VOID
NTAPI
DbgBreakPoint(
    VOID
    );

NTSYSAPI
VOID
NTAPI
DbgBreakPointWithStatus(
    _In_ ULONG Status
    );

#define DBG_STATUS_CONTROL_C 1
#define DBG_STATUS_SYSRQ 2
#define DBG_STATUS_BUGCHECK_FIRST 3
#define DBG_STATUS_BUGCHECK_SECOND 4
#define DBG_STATUS_FATAL 5
#define DBG_STATUS_DEBUG_CONTROL 6
#define DBG_STATUS_WORKER 7

NTSYSAPI
ULONG
STDAPIVCALLTYPE
DbgPrint(
    _In_z_ _Printf_format_string_ PCSTR Format,
    ...
    );

NTSYSAPI
ULONG
STDAPIVCALLTYPE
DbgPrintEx(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_z_ _Printf_format_string_ PCSTR Format,
    ...
    );

NTSYSAPI
ULONG
NTAPI
vDbgPrintEx(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_z_ PCCH Format,
    _In_ va_list arglist
    );

NTSYSAPI
ULONG
NTAPI
vDbgPrintExWithPrefix(
    _In_z_ PCCH Prefix,
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_z_ PCCH Format,
    _In_ va_list arglist
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgQueryDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgSetDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_ BOOLEAN State
    );

NTSYSAPI
ULONG
NTAPI
DbgPrompt(
    _In_ PCCH Prompt,
    _Out_writes_bytes_(Length) PCH Response,
    _In_ ULONG Length
    );

// Definitions

typedef struct _DBGKM_EXCEPTION
{
    EXCEPTION_RECORD ExceptionRecord;
    ULONG FirstChance;
} DBGKM_EXCEPTION, *PDBGKM_EXCEPTION;

typedef struct _DBGKM_CREATE_THREAD
{
    ULONG SubSystemKey;
    PVOID StartAddress;
} DBGKM_CREATE_THREAD, *PDBGKM_CREATE_THREAD;

typedef struct _DBGKM_CREATE_PROCESS
{
    ULONG SubSystemKey;
    HANDLE FileHandle;
    PVOID BaseOfImage;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
    DBGKM_CREATE_THREAD InitialThread;
} DBGKM_CREATE_PROCESS, *PDBGKM_CREATE_PROCESS;

typedef struct _DBGKM_EXIT_THREAD
{
    NTSTATUS ExitStatus;
} DBGKM_EXIT_THREAD, *PDBGKM_EXIT_THREAD;

typedef struct _DBGKM_EXIT_PROCESS
{
    NTSTATUS ExitStatus;
} DBGKM_EXIT_PROCESS, *PDBGKM_EXIT_PROCESS;

typedef struct _DBGKM_LOAD_DLL
{
    HANDLE FileHandle;
    PVOID BaseOfDll;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
    PVOID NamePointer;
} DBGKM_LOAD_DLL, *PDBGKM_LOAD_DLL;

typedef struct _DBGKM_UNLOAD_DLL
{
    PVOID BaseAddress;
} DBGKM_UNLOAD_DLL, *PDBGKM_UNLOAD_DLL;

typedef enum _DBG_STATE
{
    DbgIdle,
    DbgReplyPending,
    DbgCreateThreadStateChange,
    DbgCreateProcessStateChange,
    DbgExitThreadStateChange,
    DbgExitProcessStateChange,
    DbgExceptionStateChange,
    DbgBreakpointStateChange,
    DbgSingleStepStateChange,
    DbgLoadDllStateChange,
    DbgUnloadDllStateChange
} DBG_STATE, *PDBG_STATE;

typedef struct _DBGUI_CREATE_THREAD
{
    HANDLE HandleToThread;
    DBGKM_CREATE_THREAD NewThread;
} DBGUI_CREATE_THREAD, *PDBGUI_CREATE_THREAD;

typedef struct _DBGUI_CREATE_PROCESS
{
    HANDLE HandleToProcess;
    HANDLE HandleToThread;
    DBGKM_CREATE_PROCESS NewProcess;
} DBGUI_CREATE_PROCESS, *PDBGUI_CREATE_PROCESS;

typedef struct _DBGUI_WAIT_STATE_CHANGE
{
    DBG_STATE NewState;
    CLIENT_ID AppClientId;
    union
    {
        DBGKM_EXCEPTION Exception;
        DBGUI_CREATE_THREAD CreateThread;
        DBGUI_CREATE_PROCESS CreateProcessInfo;
        DBGKM_EXIT_THREAD ExitThread;
        DBGKM_EXIT_PROCESS ExitProcess;
        DBGKM_LOAD_DLL LoadDll;
        DBGKM_UNLOAD_DLL UnloadDll;
    } StateInfo;
} DBGUI_WAIT_STATE_CHANGE, *PDBGUI_WAIT_STATE_CHANGE;

#define DEBUG_READ_EVENT 0x0001
#define DEBUG_PROCESS_ASSIGN 0x0002
#define DEBUG_SET_INFORMATION 0x0004
#define DEBUG_QUERY_INFORMATION 0x0008
#define DEBUG_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
    DEBUG_READ_EVENT | DEBUG_PROCESS_ASSIGN | DEBUG_SET_INFORMATION | \
    DEBUG_QUERY_INFORMATION)

#define DEBUG_KILL_ON_CLOSE 0x1

typedef enum _DEBUGOBJECTINFOCLASS
{
    DebugObjectUnusedInformation,
    DebugObjectKillProcessOnExitInformation, // s: ULONG
    MaxDebugObjectInfoClass
} DEBUGOBJECTINFOCLASS, *PDEBUGOBJECTINFOCLASS;

// System calls

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateDebugObject(
    _Out_ PHANDLE DebugObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDebugActiveProcess(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDebugContinue(
    _In_ HANDLE DebugObjectHandle,
    _In_ PCLIENT_ID ClientId,
    _In_ NTSTATUS ContinueStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRemoveProcessDebug(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationDebugObject(
    _In_ HANDLE DebugObjectHandle,
    _In_ DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
    _In_ PVOID DebugInformation,
    _In_ ULONG DebugInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForDebugEvent(
    _In_ HANDLE DebugObjectHandle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout,
    _Out_ PDBGUI_WAIT_STATE_CHANGE WaitStateChange
    );

// Debugging UI

NTSYSAPI
NTSTATUS
NTAPI
DbgUiConnectToDbg(
    VOID
    );

NTSYSAPI
HANDLE
NTAPI
DbgUiGetThreadDebugObject(
    VOID
    );

NTSYSAPI
VOID
NTAPI
DbgUiSetThreadDebugObject(
    _In_ HANDLE DebugObject
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgUiWaitStateChange(
    _Out_ PDBGUI_WAIT_STATE_CHANGE StateChange,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgUiContinue(
    _In_ PCLIENT_ID AppClientId,
    _In_ NTSTATUS ContinueStatus
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgUiStopDebugging(
    _In_ HANDLE Process
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgUiDebugActiveProcess(
    _In_ HANDLE Process
    );

NTSYSAPI
VOID
NTAPI
DbgUiRemoteBreakin(
    _In_ PVOID Context
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgUiIssueRemoteBreakin(
    _In_ HANDLE Process
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgUiConvertStateChangeStructure(
    _In_ PDBGUI_WAIT_STATE_CHANGE StateChange,
    _Out_ LPDEBUG_EVENT DebugEvent
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgUiConvertStateChangeStructureEx(
    _In_ PDBGUI_WAIT_STATE_CHANGE StateChange,
    _Out_ LPDEBUG_EVENT DebugEvent
    );

struct _EVENT_FILTER_DESCRIPTOR;

typedef VOID (NTAPI *PENABLECALLBACK)(
    _In_ LPCGUID SourceId,
    _In_ ULONG IsEnabled,
    _In_ UCHAR Level,
    _In_ ULONGLONG MatchAnyKeyword,
    _In_ ULONGLONG MatchAllKeyword,
    _In_opt_ struct _EVENT_FILTER_DESCRIPTOR *FilterData,
    _Inout_opt_ PVOID CallbackContext
    );

typedef ULONGLONG REGHANDLE, *PREGHANDLE;

NTSYSAPI
NTSTATUS
NTAPI
EtwEventRegister(
    _In_ LPCGUID ProviderId,
    _In_opt_ PENABLECALLBACK EnableCallback,
    _In_opt_ PVOID CallbackContext,
    _Out_ PREGHANDLE RegHandle
    );

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTIOAPI_H
#define _NTIOAPI_H

// Create disposition

#define FILE_SUPERSEDE 0x00000000
#define FILE_OPEN 0x00000001
#define FILE_CREATE 0x00000002
#define FILE_OPEN_IF 0x00000003
#define FILE_OVERWRITE 0x00000004
#define FILE_OVERWRITE_IF 0x00000005
#define FILE_MAXIMUM_DISPOSITION 0x00000005

// Create/open flags

#define FILE_DIRECTORY_FILE 0x00000001
#define FILE_WRITE_THROUGH 0x00000002
#define FILE_SEQUENTIAL_ONLY 0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020
#define FILE_NON_DIRECTORY_FILE 0x00000040
#define FILE_CREATE_TREE_CONNECTION 0x00000080

#define FILE_COMPLETE_IF_OPLOCKED 0x00000100
#define FILE_NO_EA_KNOWLEDGE 0x00000200
#define FILE_OPEN_FOR_RECOVERY 0x00000400
#define FILE_RANDOM_ACCESS 0x00000800

#define FILE_DELETE_ON_CLOSE 0x00001000
#define FILE_OPEN_BY_FILE_ID 0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT 0x00004000
#define FILE_NO_COMPRESSION 0x00008000
#if (PHNT_VERSION >= PHNT_WIN7)
#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000
#define FILE_DISALLOW_EXCLUSIVE 0x00020000
#endif
#if (PHNT_VERSION >= PHNT_WIN8)
#define FILE_SESSION_AWARE 0x00040000
#endif

#define FILE_RESERVE_OPFILTER 0x00100000
#define FILE_OPEN_REPARSE_POINT 0x00200000
#define FILE_OPEN_NO_RECALL 0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY 0x00800000

#define FILE_COPY_STRUCTURED_STORAGE 0x00000041
#define FILE_STRUCTURED_STORAGE 0x00000441

// I/O status information values for NtCreateFile/NtOpenFile

#define FILE_SUPERSEDED 0x00000000
#define FILE_OPENED 0x00000001
#define FILE_CREATED 0x00000002
#define FILE_OVERWRITTEN 0x00000003
#define FILE_EXISTS 0x00000004
#define FILE_DOES_NOT_EXIST 0x00000005

// Special ByteOffset parameters

#define FILE_WRITE_TO_END_OF_FILE 0xffffffff
#define FILE_USE_FILE_POINTER_POSITION 0xfffffffe

// Alignment requirement values

#define FILE_BYTE_ALIGNMENT 0x00000000
#define FILE_WORD_ALIGNMENT 0x00000001
#define FILE_LONG_ALIGNMENT 0x00000003
#define FILE_QUAD_ALIGNMENT 0x00000007
#define FILE_OCTA_ALIGNMENT 0x0000000f
#define FILE_32_BYTE_ALIGNMENT 0x0000001f
#define FILE_64_BYTE_ALIGNMENT 0x0000003f
#define FILE_128_BYTE_ALIGNMENT 0x0000007f
#define FILE_256_BYTE_ALIGNMENT 0x000000ff
#define FILE_512_BYTE_ALIGNMENT 0x000001ff

// Maximum length of a filename string

#define MAXIMUM_FILENAME_LENGTH 256

// Extended attributes

#define FILE_NEED_EA 0x00000080

#define FILE_EA_TYPE_BINARY 0xfffe
#define FILE_EA_TYPE_ASCII 0xfffd
#define FILE_EA_TYPE_BITMAP 0xfffb
#define FILE_EA_TYPE_METAFILE 0xfffa
#define FILE_EA_TYPE_ICON 0xfff9
#define FILE_EA_TYPE_EA 0xffee
#define FILE_EA_TYPE_MVMT 0xffdf
#define FILE_EA_TYPE_MVST 0xffde
#define FILE_EA_TYPE_ASN1 0xffdd
#define FILE_EA_TYPE_FAMILY_IDS 0xff01

// Device characteristics

#define FILE_REMOVABLE_MEDIA 0x00000001
#define FILE_READ_ONLY_DEVICE 0x00000002
#define FILE_FLOPPY_DISKETTE 0x00000004
#define FILE_WRITE_ONCE_MEDIA 0x00000008
#define FILE_REMOTE_DEVICE 0x00000010
#define FILE_DEVICE_IS_MOUNTED 0x00000020
#define FILE_VIRTUAL_VOLUME 0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME 0x00000080
#define FILE_DEVICE_SECURE_OPEN 0x00000100
#define FILE_CHARACTERISTIC_PNP_DEVICE 0x00000800
#define FILE_CHARACTERISTIC_TS_DEVICE 0x00001000
#define FILE_CHARACTERISTIC_WEBDAV_DEVICE 0x00002000
#define FILE_CHARACTERISTIC_CSV 0x00010000
#define FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL 0x00020000
#define FILE_PORTABLE_DEVICE 0x00040000
#define FILE_REMOTE_DEVICE_VSMB 0x00080000
#define FILE_DEVICE_REQUIRE_SECURITY_CHECK 0x00100000

// Named pipe values

// NamedPipeType for NtCreateNamedPipeFile
#define FILE_PIPE_BYTE_STREAM_TYPE 0x00000000
#define FILE_PIPE_MESSAGE_TYPE 0x00000001
#define FILE_PIPE_ACCEPT_REMOTE_CLIENTS 0x00000000
#define FILE_PIPE_REJECT_REMOTE_CLIENTS 0x00000002
#define FILE_PIPE_TYPE_VALID_MASK 0x00000003

// CompletionMode for NtCreateNamedPipeFile
#define FILE_PIPE_QUEUE_OPERATION 0x00000000
#define FILE_PIPE_COMPLETE_OPERATION 0x00000001

// ReadMode for NtCreateNamedPipeFile
#define FILE_PIPE_BYTE_STREAM_MODE 0x00000000
#define FILE_PIPE_MESSAGE_MODE 0x00000001

// NamedPipeConfiguration for NtQueryInformationFile
#define FILE_PIPE_INBOUND 0x00000000
#define FILE_PIPE_OUTBOUND 0x00000001
#define FILE_PIPE_FULL_DUPLEX 0x00000002

// NamedPipeState for NtQueryInformationFile
#define FILE_PIPE_DISCONNECTED_STATE 0x00000001
#define FILE_PIPE_LISTENING_STATE 0x00000002
#define FILE_PIPE_CONNECTED_STATE 0x00000003
#define FILE_PIPE_CLOSING_STATE 0x00000004

// NamedPipeEnd for NtQueryInformationFile
#define FILE_PIPE_CLIENT_END 0x00000000
#define FILE_PIPE_SERVER_END 0x00000001

// Win32 pipe instance limit (0xff)
#define FILE_PIPE_UNLIMITED_INSTANCES 0xffffffff

// Mailslot values

#define MAILSLOT_SIZE_AUTO 0

typedef struct _IO_STATUS_BLOCK
{
    union
    {
        NTSTATUS Status;
        PVOID Pointer;
    };
    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef VOID (NTAPI *PIO_APC_ROUTINE)(
    _In_ PVOID ApcContext,
    _In_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG Reserved
    );

// private
typedef struct _FILE_IO_COMPLETION_INFORMATION
{
    PVOID KeyContext;
    PVOID ApcContext;
    IO_STATUS_BLOCK IoStatusBlock;
} FILE_IO_COMPLETION_INFORMATION, *PFILE_IO_COMPLETION_INFORMATION;

typedef enum _FILE_INFORMATION_CLASS
{
    FileDirectoryInformation = 1, // FILE_DIRECTORY_INFORMATION
    FileFullDirectoryInformation, // FILE_FULL_DIR_INFORMATION
    FileBothDirectoryInformation, // FILE_BOTH_DIR_INFORMATION
    FileBasicInformation, // FILE_BASIC_INFORMATION
    FileStandardInformation, // FILE_STANDARD_INFORMATION
    FileInternalInformation, // FILE_INTERNAL_INFORMATION
    FileEaInformation, // FILE_EA_INFORMATION
    FileAccessInformation, // FILE_ACCESS_INFORMATION
    FileNameInformation, // FILE_NAME_INFORMATION
    FileRenameInformation, // FILE_RENAME_INFORMATION // 10
    FileLinkInformation, // FILE_LINK_INFORMATION
    FileNamesInformation, // FILE_NAMES_INFORMATION
    FileDispositionInformation, // FILE_DISPOSITION_INFORMATION
    FilePositionInformation, // FILE_POSITION_INFORMATION
    FileFullEaInformation, // FILE_FULL_EA_INFORMATION
    FileModeInformation, // FILE_MODE_INFORMATION
    FileAlignmentInformation, // FILE_ALIGNMENT_INFORMATION
    FileAllInformation, // FILE_ALL_INFORMATION
    FileAllocationInformation, // FILE_ALLOCATION_INFORMATION
    FileEndOfFileInformation, // FILE_END_OF_FILE_INFORMATION // 20
    FileAlternateNameInformation, // FILE_NAME_INFORMATION
    FileStreamInformation, // FILE_STREAM_INFORMATION
    FilePipeInformation, // FILE_PIPE_INFORMATION
    FilePipeLocalInformation, // FILE_PIPE_LOCAL_INFORMATION
    FilePipeRemoteInformation, // FILE_PIPE_REMOTE_INFORMATION
    FileMailslotQueryInformation, // FILE_MAILSLOT_QUERY_INFORMATION
    FileMailslotSetInformation, // FILE_MAILSLOT_SET_INFORMATION
    FileCompressionInformation, // FILE_COMPRESSION_INFORMATION
    FileObjectIdInformation, // FILE_OBJECTID_INFORMATION
    FileCompletionInformation, // FILE_COMPLETION_INFORMATION // 30
    FileMoveClusterInformation, // FILE_MOVE_CLUSTER_INFORMATION
    FileQuotaInformation, // FILE_QUOTA_INFORMATION
    FileReparsePointInformation, // FILE_REPARSE_POINT_INFORMATION
    FileNetworkOpenInformation, // FILE_NETWORK_OPEN_INFORMATION
    FileAttributeTagInformation, // FILE_ATTRIBUTE_TAG_INFORMATION
    FileTrackingInformation, // FILE_TRACKING_INFORMATION
    FileIdBothDirectoryInformation, // FILE_ID_BOTH_DIR_INFORMATION
    FileIdFullDirectoryInformation, // FILE_ID_FULL_DIR_INFORMATION
    FileValidDataLengthInformation, // FILE_VALID_DATA_LENGTH_INFORMATION
    FileShortNameInformation, // FILE_NAME_INFORMATION // 40
    FileIoCompletionNotificationInformation, // FILE_IO_COMPLETION_NOTIFICATION_INFORMATION // since VISTA
    FileIoStatusBlockRangeInformation, // FILE_IOSTATUSBLOCK_RANGE_INFORMATION
    FileIoPriorityHintInformation, // FILE_IO_PRIORITY_HINT_INFORMATION, FILE_IO_PRIORITY_HINT_INFORMATION_EX
    FileSfioReserveInformation, // FILE_SFIO_RESERVE_INFORMATION
    FileSfioVolumeInformation, // FILE_SFIO_VOLUME_INFORMATION
    FileHardLinkInformation, // FILE_LINKS_INFORMATION
    FileProcessIdsUsingFileInformation, // FILE_PROCESS_IDS_USING_FILE_INFORMATION
    FileNormalizedNameInformation, // FILE_NAME_INFORMATION
    FileNetworkPhysicalNameInformation, // FILE_NETWORK_PHYSICAL_NAME_INFORMATION
    FileIdGlobalTxDirectoryInformation, // FILE_ID_GLOBAL_TX_DIR_INFORMATION // since WIN7 // 50
    FileIsRemoteDeviceInformation, // FILE_IS_REMOTE_DEVICE_INFORMATION
    FileUnusedInformation,
    FileNumaNodeInformation, // FILE_NUMA_NODE_INFORMATION
    FileStandardLinkInformation, // FILE_STANDARD_LINK_INFORMATION
    FileRemoteProtocolInformation, // FILE_REMOTE_PROTOCOL_INFORMATION
    FileRenameInformationBypassAccessCheck, // (kernel-mode only); FILE_RENAME_INFORMATION // since WIN8
    FileLinkInformationBypassAccessCheck, // (kernel-mode only); FILE_LINK_INFORMATION
    FileVolumeNameInformation, // FILE_VOLUME_NAME_INFORMATION
    FileIdInformation, // FILE_ID_INFORMATION
    FileIdExtdDirectoryInformation, // FILE_ID_EXTD_DIR_INFORMATION // 60
    FileReplaceCompletionInformation, // FILE_COMPLETION_INFORMATION // since WINBLUE
    FileHardLinkFullIdInformation, // FILE_LINK_ENTRY_FULL_ID_INFORMATION // FILE_LINKS_FULL_ID_INFORMATION
    FileIdExtdBothDirectoryInformation, // FILE_ID_EXTD_BOTH_DIR_INFORMATION // since THRESHOLD
    FileDispositionInformationEx, // FILE_DISPOSITION_INFO_EX // since REDSTONE
    FileRenameInformationEx, // FILE_RENAME_INFORMATION_EX
    FileRenameInformationExBypassAccessCheck, // (kernel-mode only); FILE_RENAME_INFORMATION_EX
    FileDesiredStorageClassInformation, // FILE_DESIRED_STORAGE_CLASS_INFORMATION // since REDSTONE2
    FileStatInformation, // FILE_STAT_INFORMATION
    FileMemoryPartitionInformation, // FILE_MEMORY_PARTITION_INFORMATION // since REDSTONE3
    FileStatLxInformation, // FILE_STAT_LX_INFORMATION // since REDSTONE4 // 70
    FileCaseSensitiveInformation, // FILE_CASE_SENSITIVE_INFORMATION
    FileLinkInformationEx, // FILE_LINK_INFORMATION_EX // since REDSTONE5
    FileLinkInformationExBypassAccessCheck, // (kernel-mode only); FILE_LINK_INFORMATION_EX
    FileStorageReserveIdInformation, // FILE_SET_STORAGE_RESERVE_ID_INFORMATION
    FileCaseSensitiveInformationForceAccessCheck, // FILE_CASE_SENSITIVE_INFORMATION
    FileKnownFolderInformation, // FILE_KNOWN_FOLDER_INFORMATION // since WIN11
    FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

// NtQueryInformationFile/NtSetInformationFile types

typedef struct _FILE_BASIC_INFORMATION
{
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    ULONG FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION
{
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION_EX
{
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
    BOOLEAN AlternateStream;
    BOOLEAN MetadataAttribute;
} FILE_STANDARD_INFORMATION_EX, *PFILE_STANDARD_INFORMATION_EX;

typedef struct _FILE_INTERNAL_INFORMATION
{
    LARGE_INTEGER IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;

typedef struct _FILE_EA_INFORMATION
{
    ULONG EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;

typedef struct _FILE_ACCESS_INFORMATION
{
    ACCESS_MASK AccessFlags;
} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;

typedef struct _FILE_POSITION_INFORMATION
{
    LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;

typedef struct _FILE_MODE_INFORMATION
{
    ULONG Mode;
} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;

typedef struct _FILE_ALIGNMENT_INFORMATION
{
    ULONG AlignmentRequirement;
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;

typedef struct _FILE_NAME_INFORMATION
{
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;

typedef struct _FILE_ALL_INFORMATION
{
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
    FILE_INTERNAL_INFORMATION InternalInformation;
    FILE_EA_INFORMATION EaInformation;
    FILE_ACCESS_INFORMATION AccessInformation;
    FILE_POSITION_INFORMATION PositionInformation;
    FILE_MODE_INFORMATION ModeInformation;
    FILE_ALIGNMENT_INFORMATION AlignmentInformation;
    FILE_NAME_INFORMATION NameInformation;
} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;

typedef struct _FILE_NETWORK_OPEN_INFORMATION
{
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;

typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION
{
    ULONG FileAttributes;
    ULONG ReparseTag;
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;

typedef struct _FILE_ALLOCATION_INFORMATION
{
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;

typedef struct _FILE_COMPRESSION_INFORMATION
{
    LARGE_INTEGER CompressedFileSize;
    USHORT CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;

typedef struct _FILE_DISPOSITION_INFORMATION
{
    BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;

typedef struct _FILE_END_OF_FILE_INFORMATION
{
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;

//#if (PHNT_VERSION >= PHNT_REDSTONE5)
#define FLAGS_END_OF_FILE_INFO_EX_EXTEND_PAGING 0x00000001
#define FLAGS_END_OF_FILE_INFO_EX_NO_EXTRA_PAGING_EXTEND 0x00000002
#define FLAGS_END_OF_FILE_INFO_EX_TIME_CONSTRAINED 0x00000004
#define FLAGS_DELAY_REASONS_LOG_FILE_FULL 0x00000001
#define FLAGS_DELAY_REASONS_BITMAP_SCANNED 0x00000002

typedef struct _FILE_END_OF_FILE_INFORMATION_EX
{
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER PagingFileSizeInMM;
    LARGE_INTEGER PagingFileMaxSize;
    ULONG Flags;
} FILE_END_OF_FILE_INFORMATION_EX, *PFILE_END_OF_FILE_INFORMATION_EX;
//#endif

typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION
{
    LARGE_INTEGER ValidDataLength;
} FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION;

#define FILE_LINK_REPLACE_IF_EXISTS 0x00000001 // since RS5
#define FILE_LINK_POSIX_SEMANTICS 0x00000002

#define FILE_LINK_SUPPRESS_STORAGE_RESERVE_INHERITANCE 0x00000008
#define FILE_LINK_NO_INCREASE_AVAILABLE_SPACE 0x00000010
#define FILE_LINK_NO_DECREASE_AVAILABLE_SPACE 0x00000020
#define FILE_LINK_PRESERVE_AVAILABLE_SPACE 0x00000030
#define FILE_LINK_IGNORE_READONLY_ATTRIBUTE 0x00000040
#define FILE_LINK_FORCE_RESIZE_TARGET_SR 0x00000080 // since 19H1
#define FILE_LINK_FORCE_RESIZE_SOURCE_SR 0x00000100
#define FILE_LINK_FORCE_RESIZE_SR 0x00000180

typedef struct _FILE_LINK_INFORMATION
{
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;

typedef struct _FILE_LINK_INFORMATION_EX
{
    ULONG Flags;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_INFORMATION_EX, *PFILE_LINK_INFORMATION_EX;

typedef struct _FILE_MOVE_CLUSTER_INFORMATION
{
    ULONG ClusterCount;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_MOVE_CLUSTER_INFORMATION, *PFILE_MOVE_CLUSTER_INFORMATION;

typedef struct _FILE_RENAME_INFORMATION
{
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

#define FILE_RENAME_REPLACE_IF_EXISTS 0x00000001 // since REDSTONE
#define FILE_RENAME_POSIX_SEMANTICS 0x00000002
#define FILE_RENAME_SUPPRESS_PIN_STATE_INHERITANCE 0x00000004 // since REDSTONE3
#define FILE_RENAME_SUPPRESS_STORAGE_RESERVE_INHERITANCE 0x00000008 // since REDSTONE5
#define FILE_RENAME_NO_INCREASE_AVAILABLE_SPACE 0x00000010
#define FILE_RENAME_NO_DECREASE_AVAILABLE_SPACE 0x00000020
#define FILE_RENAME_PRESERVE_AVAILABLE_SPACE 0x00000030
#define FILE_RENAME_IGNORE_READONLY_ATTRIBUTE 0x00000040
#define FILE_RENAME_FORCE_RESIZE_TARGET_SR 0x00000080 // since 19H1
#define FILE_RENAME_FORCE_RESIZE_SOURCE_SR 0x00000100
#define FILE_RENAME_FORCE_RESIZE_SR 0x00000180

typedef struct _FILE_RENAME_INFORMATION_EX
{
    ULONG Flags;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION_EX, *PFILE_RENAME_INFORMATION_EX;

typedef struct _FILE_STREAM_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

typedef struct _FILE_TRACKING_INFORMATION
{
    HANDLE DestinationFile;
    ULONG ObjectInformationLength;
    CHAR ObjectInformation[1];
} FILE_TRACKING_INFORMATION, *PFILE_TRACKING_INFORMATION;

typedef struct _FILE_COMPLETION_INFORMATION
{
    HANDLE Port;
    PVOID Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;

typedef struct _FILE_PIPE_INFORMATION
{
     ULONG ReadMode;
     ULONG CompletionMode;
} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;

typedef struct _FILE_PIPE_LOCAL_INFORMATION
{
     ULONG NamedPipeType;
     ULONG NamedPipeConfiguration;
     ULONG MaximumInstances;
     ULONG CurrentInstances;
     ULONG InboundQuota;
     ULONG ReadDataAvailable;
     ULONG OutboundQuota;
     ULONG WriteQuotaAvailable;
     ULONG NamedPipeState;
     ULONG NamedPipeEnd;
} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;

typedef struct _FILE_PIPE_REMOTE_INFORMATION
{
     LARGE_INTEGER CollectDataTime;
     ULONG MaximumCollectionCount;
} FILE_PIPE_REMOTE_INFORMATION, *PFILE_PIPE_REMOTE_INFORMATION;

typedef struct _FILE_MAILSLOT_QUERY_INFORMATION
{
    ULONG MaximumMessageSize;
    ULONG MailslotQuota;
    ULONG NextMessageSize;
    ULONG MessagesAvailable;
    LARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_QUERY_INFORMATION, *PFILE_MAILSLOT_QUERY_INFORMATION;

typedef struct _FILE_MAILSLOT_SET_INFORMATION
{
    PLARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;

typedef struct _FILE_REPARSE_POINT_INFORMATION
{
    LONGLONG FileReference;
    ULONG Tag;
} FILE_REPARSE_POINT_INFORMATION, *PFILE_REPARSE_POINT_INFORMATION;

typedef struct _FILE_LINK_ENTRY_INFORMATION
{
    ULONG NextEntryOffset;
    LONGLONG ParentFileId; // LARGE_INTEGER
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_ENTRY_INFORMATION, *PFILE_LINK_ENTRY_INFORMATION;

typedef struct _FILE_LINKS_INFORMATION
{
    ULONG BytesNeeded;
    ULONG EntriesReturned;
    FILE_LINK_ENTRY_INFORMATION Entry;
} FILE_LINKS_INFORMATION, *PFILE_LINKS_INFORMATION;

typedef struct _FILE_NETWORK_PHYSICAL_NAME_INFORMATION
{
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NETWORK_PHYSICAL_NAME_INFORMATION, *PFILE_NETWORK_PHYSICAL_NAME_INFORMATION;

typedef struct _FILE_STANDARD_LINK_INFORMATION
{
    ULONG NumberOfAccessibleLinks;
    ULONG TotalNumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_LINK_INFORMATION, *PFILE_STANDARD_LINK_INFORMATION;

typedef struct _FILE_SFIO_RESERVE_INFORMATION
{
    ULONG RequestsPerPeriod;
    ULONG Period;
    BOOLEAN RetryFailures;
    BOOLEAN Discardable;
    ULONG RequestSize;
    ULONG NumOutstandingRequests;
} FILE_SFIO_RESERVE_INFORMATION, *PFILE_SFIO_RESERVE_INFORMATION;

typedef struct _FILE_SFIO_VOLUME_INFORMATION
{
    ULONG MaximumRequestsPerPeriod;
    ULONG MinimumPeriod;
    ULONG MinimumTransferSize;
} FILE_SFIO_VOLUME_INFORMATION, *PFILE_SFIO_VOLUME_INFORMATION;

typedef enum _IO_PRIORITY_HINT
{
    IoPriorityVeryLow = 0, // Defragging, content indexing and other background I/Os.
    IoPriorityLow, // Prefetching for applications.
    IoPriorityNormal, // Normal I/Os.
    IoPriorityHigh, // Used by filesystems for checkpoint I/O.
    IoPriorityCritical, // Used by memory manager. Not available for applications.
    MaxIoPriorityTypes
} IO_PRIORITY_HINT;

typedef DECLSPEC_ALIGN(8) struct _FILE_IO_PRIORITY_HINT_INFORMATION
{
    IO_PRIORITY_HINT PriorityHint;
} FILE_IO_PRIORITY_HINT_INFORMATION, *PFILE_IO_PRIORITY_HINT_INFORMATION;

typedef struct _FILE_IO_PRIORITY_HINT_INFORMATION_EX
{
    IO_PRIORITY_HINT PriorityHint;
    BOOLEAN BoostOutstanding;
} FILE_IO_PRIORITY_HINT_INFORMATION_EX, *PFILE_IO_PRIORITY_HINT_INFORMATION_EX;

#define FILE_SKIP_COMPLETION_PORT_ON_SUCCESS 0x1
#define FILE_SKIP_SET_EVENT_ON_HANDLE 0x2
#define FILE_SKIP_SET_USER_EVENT_ON_FAST_IO 0x4

typedef struct _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION
{
    ULONG Flags;
} FILE_IO_COMPLETION_NOTIFICATION_INFORMATION, *PFILE_IO_COMPLETION_NOTIFICATION_INFORMATION;

typedef struct _FILE_PROCESS_IDS_USING_FILE_INFORMATION
{
    ULONG NumberOfProcessIdsInList;
    ULONG_PTR ProcessIdList[1];
} FILE_PROCESS_IDS_USING_FILE_INFORMATION, *PFILE_PROCESS_IDS_USING_FILE_INFORMATION;

typedef struct _FILE_IS_REMOTE_DEVICE_INFORMATION
{
    BOOLEAN IsRemote;
} FILE_IS_REMOTE_DEVICE_INFORMATION, *PFILE_IS_REMOTE_DEVICE_INFORMATION;

typedef struct _FILE_NUMA_NODE_INFORMATION
{
    USHORT NodeNumber;
} FILE_NUMA_NODE_INFORMATION, *PFILE_NUMA_NODE_INFORMATION;

typedef struct _FILE_IOSTATUSBLOCK_RANGE_INFORMATION
{
    PUCHAR IoStatusBlockRange;
    ULONG Length;
} FILE_IOSTATUSBLOCK_RANGE_INFORMATION, *PFILE_IOSTATUSBLOCK_RANGE_INFORMATION;

// Win32 FILE_REMOTE_PROTOCOL_INFO
typedef struct _FILE_REMOTE_PROTOCOL_INFORMATION
{
    // Structure Version
    USHORT StructureVersion;     // 1 for Win7, 2 for Win8 SMB3, 3 for Blue SMB3, 4 for RS5
    USHORT StructureSize;        // sizeof(FILE_REMOTE_PROTOCOL_INFORMATION)

    ULONG Protocol;             // Protocol (WNNC_NET_*) defined in winnetwk.h or ntifs.h.

    // Protocol Version & Type
    USHORT ProtocolMajorVersion;
    USHORT ProtocolMinorVersion;
    USHORT ProtocolRevision;

    USHORT Reserved;

    // Protocol-Generic Information
    ULONG Flags;

    struct
    {
        ULONG Reserved[8];
    } GenericReserved;

    // Protocol specific information

#if (_WIN32_WINNT < PHNT_WIN8)
    struct
    {
        ULONG Reserved[16];
    } ProtocolSpecificReserved;
#endif

#if (PHNT_VERSION >= PHNT_WIN8)
    union
    {
        struct
        {
            struct
            {
                ULONG Capabilities;
            } Server;
            struct
            {
                ULONG Capabilities;
#if (PHNT_VERSION >= PHNT_21H1)
                ULONG ShareFlags;
#else
                ULONG CachingFlags;
#endif
#if (PHNT_VERSION >= PHNT_REDSTONE5)
                UCHAR ShareType;
                UCHAR Reserved0[3];
                ULONG Reserved1;
#endif
            } Share;
        } Smb2;
        ULONG Reserved[16];
    } ProtocolSpecific;
#endif
} FILE_REMOTE_PROTOCOL_INFORMATION, *PFILE_REMOTE_PROTOCOL_INFORMATION;

#define CHECKSUM_ENFORCEMENT_OFF 0x00000001

typedef struct _FILE_INTEGRITY_STREAM_INFORMATION
{
    USHORT ChecksumAlgorithm;
    UCHAR ChecksumChunkShift;
    UCHAR ClusterShift;
    ULONG Flags;
} FILE_INTEGRITY_STREAM_INFORMATION, *PFILE_INTEGRITY_STREAM_INFORMATION;

typedef struct _FILE_VOLUME_NAME_INFORMATION
{
    ULONG DeviceNameLength;
    WCHAR DeviceName[1];
} FILE_VOLUME_NAME_INFORMATION, *PFILE_VOLUME_NAME_INFORMATION;

typedef struct _FILE_ID_INFORMATION
{
    ULONGLONG VolumeSerialNumber;
    FILE_ID_128 FileId;
} FILE_ID_INFORMATION, *PFILE_ID_INFORMATION;

typedef struct _FILE_ID_EXTD_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    ULONG ReparsePointTag;
    FILE_ID_128 FileId;
    WCHAR FileName[1];
} FILE_ID_EXTD_DIR_INFORMATION, *PFILE_ID_EXTD_DIR_INFORMATION;

typedef struct _FILE_LINK_ENTRY_FULL_ID_INFORMATION
{
    ULONG NextEntryOffset;
    FILE_ID_128 ParentFileId;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_ENTRY_FULL_ID_INFORMATION, *PFILE_LINK_ENTRY_FULL_ID_INFORMATION;

typedef struct _FILE_LINKS_FULL_ID_INFORMATION
{
    ULONG BytesNeeded;
    ULONG EntriesReturned;
    FILE_LINK_ENTRY_FULL_ID_INFORMATION Entry;
} FILE_LINKS_FULL_ID_INFORMATION, *PFILE_LINKS_FULL_ID_INFORMATION;

typedef struct _FILE_ID_EXTD_BOTH_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    ULONG ReparsePointTag;
    FILE_ID_128 FileId;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} FILE_ID_EXTD_BOTH_DIR_INFORMATION, *PFILE_ID_EXTD_BOTH_DIR_INFORMATION;

// private
typedef struct _FILE_STAT_INFORMATION
{
    LARGE_INTEGER FileId;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
    ULONG ReparseTag;
    ULONG NumberOfLinks;
    ACCESS_MASK EffectiveAccess;
} FILE_STAT_INFORMATION, *PFILE_STAT_INFORMATION;

// private
typedef struct _FILE_MEMORY_PARTITION_INFORMATION
{
    HANDLE OwnerPartitionHandle;
    union
    {
        struct
        {
            UCHAR NoCrossPartitionAccess;
            UCHAR Spare[3];
        };
        ULONG AllFlags;
    } Flags;
} FILE_MEMORY_PARTITION_INFORMATION, *PFILE_MEMORY_PARTITION_INFORMATION;

// LxFlags
#define LX_FILE_METADATA_HAS_UID 0x1
#define LX_FILE_METADATA_HAS_GID 0x2
#define LX_FILE_METADATA_HAS_MODE 0x4
#define LX_FILE_METADATA_HAS_DEVICE_ID 0x8
#define LX_FILE_CASE_SENSITIVE_DIR 0x10

// private
typedef struct _FILE_STAT_LX_INFORMATION
{
    LARGE_INTEGER FileId;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
    ULONG ReparseTag;
    ULONG NumberOfLinks;
    ACCESS_MASK EffectiveAccess;
    ULONG LxFlags;
    ULONG LxUid;
    ULONG LxGid;
    ULONG LxMode;
    ULONG LxDeviceIdMajor;
    ULONG LxDeviceIdMinor;
} FILE_STAT_LX_INFORMATION, *PFILE_STAT_LX_INFORMATION;

#define FILE_CS_FLAG_CASE_SENSITIVE_DIR     0x00000001

// private
typedef struct _FILE_CASE_SENSITIVE_INFORMATION
{
    ULONG Flags;
} FILE_CASE_SENSITIVE_INFORMATION, *PFILE_CASE_SENSITIVE_INFORMATION;

// private
typedef enum _FILE_KNOWN_FOLDER_TYPE
{
    KnownFolderNone,
    KnownFolderDesktop,
    KnownFolderDocuments,
    KnownFolderDownloads,
    KnownFolderMusic,
    KnownFolderPictures,
    KnownFolderVideos,
    KnownFolderOther,
    KnownFolderMax = 7
} FILE_KNOWN_FOLDER_TYPE;

// private
typedef struct _FILE_KNOWN_FOLDER_INFORMATION
{
    FILE_KNOWN_FOLDER_TYPE Type;
} FILE_KNOWN_FOLDER_INFORMATION, *PFILE_KNOWN_FOLDER_INFORMATION;

// NtQueryDirectoryFile types

typedef struct _FILE_DIRECTORY_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;

typedef struct _FILE_FULL_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;

typedef struct _FILE_ID_FULL_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;

typedef struct _FILE_BOTH_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

typedef struct _FILE_ID_BOTH_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;

typedef struct _FILE_NAMES_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;

typedef struct _FILE_ID_GLOBAL_TX_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    LARGE_INTEGER FileId;
    GUID LockingTransactionId;
    ULONG TxInfoFlags;
    WCHAR FileName[1];
} FILE_ID_GLOBAL_TX_DIR_INFORMATION, *PFILE_ID_GLOBAL_TX_DIR_INFORMATION;

#define FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_WRITELOCKED 0x00000001
#define FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_TO_TX 0x00000002
#define FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_OUTSIDE_TX 0x00000004

typedef struct _FILE_OBJECTID_INFORMATION
{
    LONGLONG FileReference;
    UCHAR ObjectId[16]; // GUID
    union
    {
        struct
        {
            UCHAR BirthVolumeId[16];
            UCHAR BirthObjectId[16];
            UCHAR DomainId[16];
        };
        UCHAR ExtendedInfo[48];
    };
} FILE_OBJECTID_INFORMATION, *PFILE_OBJECTID_INFORMATION;

// NtQueryEaFile/NtSetEaFile types

typedef struct _FILE_FULL_EA_INFORMATION
{
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

typedef struct _FILE_GET_EA_INFORMATION
{
    ULONG NextEntryOffset;
    UCHAR EaNameLength;
    CHAR EaName[1];
} FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;

// NtQueryQuotaInformationFile/NtSetQuotaInformationFile types

typedef struct _FILE_GET_QUOTA_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG SidLength;
    SID Sid;
} FILE_GET_QUOTA_INFORMATION, *PFILE_GET_QUOTA_INFORMATION;

typedef struct _FILE_QUOTA_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG SidLength;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER QuotaUsed;
    LARGE_INTEGER QuotaThreshold;
    LARGE_INTEGER QuotaLimit;
    SID Sid;
} FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;

typedef enum _FSINFOCLASS
{
    FileFsVolumeInformation = 1, // FILE_FS_VOLUME_INFORMATION
    FileFsLabelInformation, // FILE_FS_LABEL_INFORMATION
    FileFsSizeInformation, // FILE_FS_SIZE_INFORMATION
    FileFsDeviceInformation, // FILE_FS_DEVICE_INFORMATION
    FileFsAttributeInformation, // FILE_FS_ATTRIBUTE_INFORMATION
    FileFsControlInformation, // FILE_FS_CONTROL_INFORMATION
    FileFsFullSizeInformation, // FILE_FS_FULL_SIZE_INFORMATION
    FileFsObjectIdInformation, // FILE_FS_OBJECTID_INFORMATION
    FileFsDriverPathInformation, // FILE_FS_DRIVER_PATH_INFORMATION
    FileFsVolumeFlagsInformation, // FILE_FS_VOLUME_FLAGS_INFORMATION // 10
    FileFsSectorSizeInformation, // FILE_FS_SECTOR_SIZE_INFORMATION // since WIN8
    FileFsDataCopyInformation, // FILE_FS_DATA_COPY_INFORMATION
    FileFsMetadataSizeInformation, // FILE_FS_METADATA_SIZE_INFORMATION // since THRESHOLD
    FileFsFullSizeInformationEx, // FILE_FS_FULL_SIZE_INFORMATION_EX // since REDSTONE5
    FileFsMaximumInformation
} FSINFOCLASS, *PFSINFOCLASS;

// NtQueryVolumeInformation/NtSetVolumeInformation types

// private
typedef struct _FILE_FS_VOLUME_INFORMATION
{
    LARGE_INTEGER VolumeCreationTime;
    ULONG VolumeSerialNumber;
    ULONG VolumeLabelLength;
    BOOLEAN SupportsObjects;
    WCHAR VolumeLabel[1];
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;

// private
typedef struct _FILE_FS_LABEL_INFORMATION
{
    ULONG VolumeLabelLength;
    WCHAR VolumeLabel[1];
} FILE_FS_LABEL_INFORMATION, * PFILE_FS_LABEL_INFORMATION;

// private
typedef struct _FILE_FS_SIZE_INFORMATION
{
    LARGE_INTEGER TotalAllocationUnits;
    LARGE_INTEGER AvailableAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} FILE_FS_SIZE_INFORMATION, *PFILE_FS_SIZE_INFORMATION;

// FileSystemControlFlags
#define FILE_VC_QUOTA_NONE 0x00000000
#define FILE_VC_QUOTA_TRACK 0x00000001
#define FILE_VC_QUOTA_ENFORCE 0x00000002
#define FILE_VC_QUOTA_MASK 0x00000003
#define FILE_VC_CONTENT_INDEX_DISABLED 0x00000008
#define FILE_VC_LOG_QUOTA_THRESHOLD 0x00000010
#define FILE_VC_LOG_QUOTA_LIMIT 0x00000020
#define FILE_VC_LOG_VOLUME_THRESHOLD 0x00000040
#define FILE_VC_LOG_VOLUME_LIMIT 0x00000080
#define FILE_VC_QUOTAS_INCOMPLETE 0x00000100
#define FILE_VC_QUOTAS_REBUILDING 0x00000200
#define FILE_VC_VALID_MASK 0x000003ff

// private
typedef struct _FILE_FS_CONTROL_INFORMATION
{
    LARGE_INTEGER FreeSpaceStartFiltering;
    LARGE_INTEGER FreeSpaceThreshold;
    LARGE_INTEGER FreeSpaceStopFiltering;
    LARGE_INTEGER DefaultQuotaThreshold;
    LARGE_INTEGER DefaultQuotaLimit;
    ULONG FileSystemControlFlags;
} FILE_FS_CONTROL_INFORMATION, *PFILE_FS_CONTROL_INFORMATION;

// private
typedef struct _FILE_FS_FULL_SIZE_INFORMATION
{
    LARGE_INTEGER TotalAllocationUnits;
    LARGE_INTEGER CallerAvailableAllocationUnits;
    LARGE_INTEGER ActualAvailableAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} FILE_FS_FULL_SIZE_INFORMATION, *PFILE_FS_FULL_SIZE_INFORMATION;

// private
typedef struct _FILE_FS_OBJECTID_INFORMATION
{
    UCHAR ObjectId[16];
    UCHAR ExtendedInfo[48];
} FILE_FS_OBJECTID_INFORMATION, *PFILE_FS_OBJECTID_INFORMATION;

// private
typedef struct _FILE_FS_DEVICE_INFORMATION
{
    DEVICE_TYPE DeviceType;
    ULONG Characteristics;
} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;

// private
typedef struct _FILE_FS_ATTRIBUTE_INFORMATION
{
    ULONG FileSystemAttributes;
    LONG MaximumComponentNameLength;
    ULONG FileSystemNameLength;
    WCHAR FileSystemName[1];
} FILE_FS_ATTRIBUTE_INFORMATION, *PFILE_FS_ATTRIBUTE_INFORMATION;

// private
typedef struct _FILE_FS_DRIVER_PATH_INFORMATION
{
    BOOLEAN DriverInPath;
    ULONG DriverNameLength;
    WCHAR DriverName[1];
} FILE_FS_DRIVER_PATH_INFORMATION, *PFILE_FS_DRIVER_PATH_INFORMATION;

// private
typedef struct _FILE_FS_VOLUME_FLAGS_INFORMATION
{
    ULONG Flags;
} FILE_FS_VOLUME_FLAGS_INFORMATION, *PFILE_FS_VOLUME_FLAGS_INFORMATION;

#define SSINFO_FLAGS_ALIGNED_DEVICE 0x00000001
#define SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE 0x00000002

// If set for Sector and Partition fields, alignment is not known.
#define SSINFO_OFFSET_UNKNOWN 0xffffffff

typedef struct _FILE_FS_SECTOR_SIZE_INFORMATION
{
    ULONG LogicalBytesPerSector;
    ULONG PhysicalBytesPerSectorForAtomicity;
    ULONG PhysicalBytesPerSectorForPerformance;
    ULONG FileSystemEffectivePhysicalBytesPerSectorForAtomicity;
    ULONG Flags;
    ULONG ByteOffsetForSectorAlignment;
    ULONG ByteOffsetForPartitionAlignment;
} FILE_FS_SECTOR_SIZE_INFORMATION, *PFILE_FS_SECTOR_SIZE_INFORMATION;

// private
typedef struct _FILE_FS_DATA_COPY_INFORMATION
{
    ULONG NumberOfCopies;
} FILE_FS_DATA_COPY_INFORMATION, *PFILE_FS_DATA_COPY_INFORMATION;

// private
typedef struct _FILE_FS_METADATA_SIZE_INFORMATION
{
    LARGE_INTEGER TotalMetadataAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} FILE_FS_METADATA_SIZE_INFORMATION, *PFILE_FS_METADATA_SIZE_INFORMATION;

// private
typedef struct _FILE_FS_FULL_SIZE_INFORMATION_EX
{
    ULONGLONG ActualTotalAllocationUnits;
    ULONGLONG ActualAvailableAllocationUnits;
    ULONGLONG ActualPoolUnavailableAllocationUnits;
    ULONGLONG CallerTotalAllocationUnits;
    ULONGLONG CallerAvailableAllocationUnits;
    ULONGLONG CallerPoolUnavailableAllocationUnits;
    ULONGLONG UsedAllocationUnits;
    ULONGLONG TotalReservedAllocationUnits;
    ULONGLONG VolumeStorageReserveAllocationUnits;
    ULONGLONG AvailableCommittedAllocationUnits;
    ULONGLONG PoolAvailableAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} FILE_FS_FULL_SIZE_INFORMATION_EX, *PFILE_FS_FULL_SIZE_INFORMATION_EX;

// System calls

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER AllocationSize,
    _In_ ULONG FileAttributes,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,
    _In_ ULONG EaLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateNamedPipeFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_ ULONG NamedPipeType,
    _In_ ULONG ReadMode,
    _In_ ULONG CompletionMode,
    _In_ ULONG MaximumInstances,
    _In_ ULONG InboundQuota,
    _In_ ULONG OutboundQuota,
    _In_opt_ PLARGE_INTEGER DefaultTimeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateMailslotFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CreateOptions,
    _In_ ULONG MailslotQuota,
    _In_ ULONG MaximumMessageSize,
    _In_ PLARGE_INTEGER ReadTimeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG OpenOptions
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushBuffersFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );

#define FLUSH_FLAGS_FILE_DATA_ONLY 0x00000001
#define FLUSH_FLAGS_NO_SYNC 0x00000002
#define FLUSH_FLAGS_FILE_DATA_SYNC_ONLY 0x00000004 // REDSTONE1

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushBuffersFileEx(
    _In_ HANDLE FileHandle,
    _In_ ULONG Flags,
    _In_reads_bytes_(ParametersSize) PVOID Parameters,
    _In_ ULONG ParametersSize,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass
    );

#if (PHNT_VERSION >= PHNT_REDSTONE2)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationByName(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_opt_ PUNICODE_STRING FileName,
    _In_ BOOLEAN RestartScan
    );

#if (PHNT_VERSION >= PHNT_REDSTONE3)
// QueryFlags values for NtQueryDirectoryFileEx
#define FILE_QUERY_RESTART_SCAN 0x00000001
#define FILE_QUERY_RETURN_SINGLE_ENTRY 0x00000002
#define FILE_QUERY_INDEX_SPECIFIED 0x00000004
#define FILE_QUERY_RETURN_ON_DISK_ENTRIES_ONLY 0x00000008
#if (PHNT_VERSION >= PHNT_REDSTONE5)
#define FILE_QUERY_NO_CURSOR_UPDATE 0x00000010
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDirectoryFileEx(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ ULONG QueryFlags,
    _In_opt_ PUNICODE_STRING FileName
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(EaListLength) PVOID EaList,
    _In_ ULONG EaListLength,
    _In_opt_ PULONG EaIndex,
    _In_ BOOLEAN RestartScan
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(SidListLength) PVOID SidList,
    _In_ ULONG SidListLength,
    _In_opt_ PSID StartSid,
    _In_ BOOLEAN RestartScan
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryVolumeInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FsInformation,
    _In_ ULONG Length,
    _In_ FSINFOCLASS FsInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetVolumeInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID FsInformation,
    _In_ ULONG Length,
    _In_ FSINFOCLASS FsInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelIoFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelIoFileEx(
    _In_ HANDLE FileHandle,
    _In_opt_ PIO_STATUS_BLOCK IoRequestToCancel,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelSynchronousIoFile(
    _In_ HANDLE ThreadHandle,
    _In_opt_ PIO_STATUS_BLOCK IoRequestToCancel,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG IoControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFsControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG FsControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadFileScatter(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteFileGather(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key,
    _In_ BOOLEAN FailImmediately,
    _In_ BOOLEAN ExclusiveLock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnlockFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryAttributesFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PFILE_BASIC_INFORMATION FileInformation
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryFullAttributesFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PFILE_NETWORK_OPEN_INFORMATION FileInformation
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer, // FILE_NOTIFY_INFORMATION
    _In_ ULONG Length,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree
    );

// private
typedef enum _DIRECTORY_NOTIFY_INFORMATION_CLASS
{
    DirectoryNotifyInformation = 1, // FILE_NOTIFY_INFORMATION
    DirectoryNotifyExtendedInformation, // FILE_NOTIFY_EXTENDED_INFORMATION
    DirectoryNotifyFullInformation, // since 22H2
    DirectoryNotifyMaximumInformation
} DIRECTORY_NOTIFY_INFORMATION_CLASS, *PDIRECTORY_NOTIFY_INFORMATION_CLASS;

#if (PHNT_VERSION >= PHNT_REDSTONE3)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeDirectoryFileEx(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _In_opt_ DIRECTORY_NOTIFY_INFORMATION_CLASS DirectoryNotifyInformationClass
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadDriver(
    _In_ PUNICODE_STRING DriverServiceName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadDriver(
    _In_ PUNICODE_STRING DriverServiceName
    );

// I/O completion port

#ifndef IO_COMPLETION_QUERY_STATE
#define IO_COMPLETION_QUERY_STATE 0x0001
#endif

#ifndef IO_COMPLETION_MODIFY_STATE
#define IO_COMPLETION_MODIFY_STATE 0x0002
#endif

#ifndef IO_COMPLETION_ALL_ACCESS
#define IO_COMPLETION_ALL_ACCESS (IO_COMPLETION_QUERY_STATE|IO_COMPLETION_MODIFY_STATE|STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE)
#endif

typedef enum _IO_COMPLETION_INFORMATION_CLASS
{
    IoCompletionBasicInformation
} IO_COMPLETION_INFORMATION_CLASS;

typedef struct _IO_COMPLETION_BASIC_INFORMATION
{
    LONG Depth;
} IO_COMPLETION_BASIC_INFORMATION, *PIO_COMPLETION_BASIC_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_ IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    _Out_writes_bytes_(IoCompletionInformationLength) PVOID IoCompletionInformation,
    _In_ ULONG IoCompletionInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation
    );

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetIoCompletionEx(
    _In_ HANDLE IoCompletionHandle,
    _In_ HANDLE IoCompletionPacketHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRemoveIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _Out_ PVOID *KeyContext,
    _Out_ PVOID *ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER Timeout
    );

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRemoveIoCompletionEx(
    _In_ HANDLE IoCompletionHandle,
    _Out_writes_to_(Count, *NumEntriesRemoved) PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation,
    _In_ ULONG Count,
    _Out_ PULONG NumEntriesRemoved,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_ BOOLEAN Alertable
    );
#endif

// Wait completion packet

#if (PHNT_VERSION >= PHNT_WIN8)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateWaitCompletionPacket(
    _Out_ PHANDLE WaitCompletionPacketHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAssociateWaitCompletionPacket(
    _In_ HANDLE WaitCompletionPacketHandle,
    _In_ HANDLE IoCompletionHandle,
    _In_ HANDLE TargetObjectHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation,
    _Out_opt_ PBOOLEAN AlreadySignaled
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelWaitCompletionPacket(
    _In_ HANDLE WaitCompletionPacketHandle,
    _In_ BOOLEAN RemoveSignaledPacket
    );

#endif

// Sessions

typedef enum _IO_SESSION_EVENT
{
    IoSessionEventIgnore,
    IoSessionEventCreated,
    IoSessionEventTerminated,
    IoSessionEventConnected,
    IoSessionEventDisconnected,
    IoSessionEventLogon,
    IoSessionEventLogoff,
    IoSessionEventMax
} IO_SESSION_EVENT;

typedef enum _IO_SESSION_STATE
{
    IoSessionStateCreated = 1,
    IoSessionStateInitialized = 2,
    IoSessionStateConnected = 3,
    IoSessionStateDisconnected = 4,
    IoSessionStateDisconnectedLoggedOn = 5,
    IoSessionStateLoggedOn = 6,
    IoSessionStateLoggedOff = 7,
    IoSessionStateTerminated = 8,
    IoSessionStateMax
} IO_SESSION_STATE;

// Sessions

#if (PHNT_MODE != PHNT_MODE_KERNEL)

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSession(
    _Out_ PHANDLE SessionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif

#endif

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeSession(
    _In_ HANDLE SessionHandle,
    _In_ ULONG ChangeSequenceNumber,
    _In_ PLARGE_INTEGER ChangeTimeStamp,
    _In_ IO_SESSION_EVENT Event,
    _In_ IO_SESSION_STATE NewState,
    _In_ IO_SESSION_STATE PreviousState,
    _In_reads_bytes_opt_(PayloadSize) PVOID Payload,
    _In_ ULONG PayloadSize
    );
#endif

// Other types

typedef enum _INTERFACE_TYPE
{
    InterfaceTypeUndefined = -1,
    Internal = 0,
    Isa = 1,
    Eisa = 2,
    MicroChannel = 3,
    TurboChannel = 4,
    PCIBus = 5,
    VMEBus = 6,
    NuBus = 7,
    PCMCIABus = 8,
    CBus = 9,
    MPIBus = 10,
    MPSABus = 11,
    ProcessorInternal = 12,
    InternalPowerBus = 13,
    PNPISABus = 14,
    PNPBus = 15,
    Vmcs = 16,
    ACPIBus = 17,
    MaximumInterfaceType
} INTERFACE_TYPE, *PINTERFACE_TYPE;

typedef enum _DMA_WIDTH
{
    Width8Bits,
    Width16Bits,
    Width32Bits,
    Width64Bits,
    WidthNoWrap,
    MaximumDmaWidth
} DMA_WIDTH, *PDMA_WIDTH;

typedef enum _DMA_SPEED
{
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
} DMA_SPEED, *PDMA_SPEED;

typedef enum _BUS_DATA_TYPE
{
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;

// Control structures

// Reparse structure for FSCTL_SET_REPARSE_POINT, FSCTL_GET_REPARSE_POINT, FSCTL_DELETE_REPARSE_POINT

#define SYMLINK_FLAG_RELATIVE 0x00000001

#if (PHNT_VERSION >= PHNT_REDSTONE4)
#define SYMLINK_DIRECTORY 0x80000000 // If set then this is a directory symlink
#define SYMLINK_FILE 0x40000000 // If set then this is a file symlink
#endif

typedef struct _REPARSE_DATA_BUFFER
{
    ULONG ReparseTag;
    USHORT ReparseDataLength;
    USHORT Reserved;

    _Field_size_bytes_(ReparseDataLength)
    union
    {
        struct
        {
            USHORT SubstituteNameOffset;
            USHORT SubstituteNameLength;
            USHORT PrintNameOffset;
            USHORT PrintNameLength;
            ULONG Flags;
            WCHAR PathBuffer[1];
        } SymbolicLinkReparseBuffer;
        struct
        {
            USHORT SubstituteNameOffset;
            USHORT SubstituteNameLength;
            USHORT PrintNameOffset;
            USHORT PrintNameLength;
            WCHAR PathBuffer[1];
        } MountPointReparseBuffer;
        struct
        {
            UCHAR DataBuffer[1];
        } GenericReparseBuffer;
    };
} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;

#define REPARSE_DATA_BUFFER_HEADER_SIZE UFIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer)

// Named pipe FS control definitions

#define DEVICE_NAMED_PIPE L"\\Device\\NamedPipe\\"

#define FSCTL_PIPE_ASSIGN_EVENT             CTL_CODE(FILE_DEVICE_NAMED_PIPE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_DISCONNECT               CTL_CODE(FILE_DEVICE_NAMED_PIPE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_LISTEN                   CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_PEEK                     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 3, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_PIPE_QUERY_EVENT              CTL_CODE(FILE_DEVICE_NAMED_PIPE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_TRANSCEIVE               CTL_CODE(FILE_DEVICE_NAMED_PIPE, 5, METHOD_NEITHER,  FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_PIPE_WAIT                     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_IMPERSONATE              CTL_CODE(FILE_DEVICE_NAMED_PIPE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_CLIENT_PROCESS       CTL_CODE(FILE_DEVICE_NAMED_PIPE, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_QUERY_CLIENT_PROCESS     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_GET_PIPE_ATTRIBUTE       CTL_CODE(FILE_DEVICE_NAMED_PIPE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_PIPE_ATTRIBUTE       CTL_CODE(FILE_DEVICE_NAMED_PIPE, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_GET_CONNECTION_ATTRIBUTE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_CONNECTION_ATTRIBUTE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_GET_HANDLE_ATTRIBUTE     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 14, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_HANDLE_ATTRIBUTE     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_FLUSH                    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 16, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_PIPE_DISABLE_IMPERSONATE      CTL_CODE(FILE_DEVICE_NAMED_PIPE, 17, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SILO_ARRIVAL             CTL_CODE(FILE_DEVICE_NAMED_PIPE, 18, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_PIPE_CREATE_SYMLINK           CTL_CODE(FILE_DEVICE_NAMED_PIPE, 19, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_PIPE_DELETE_SYMLINK           CTL_CODE(FILE_DEVICE_NAMED_PIPE, 20, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_PIPE_QUERY_CLIENT_PROCESS_V2  CTL_CODE(FILE_DEVICE_NAMED_PIPE, 21, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_PIPE_INTERNAL_READ            CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2045, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_PIPE_INTERNAL_WRITE           CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2046, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_PIPE_INTERNAL_TRANSCEIVE      CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2047, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_PIPE_INTERNAL_READ_OVFLOW     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2048, METHOD_BUFFERED, FILE_READ_DATA)

// Flags for query event

#define FILE_PIPE_READ_DATA 0x00000000
#define FILE_PIPE_WRITE_SPACE 0x00000001

// Input for FSCTL_PIPE_ASSIGN_EVENT
typedef struct _FILE_PIPE_ASSIGN_EVENT_BUFFER
{
    HANDLE EventHandle;
    ULONG KeyValue;
} FILE_PIPE_ASSIGN_EVENT_BUFFER, *PFILE_PIPE_ASSIGN_EVENT_BUFFER;

// Output for FILE_PIPE_PEEK_BUFFER
typedef struct _FILE_PIPE_PEEK_BUFFER
{
    ULONG NamedPipeState;
    ULONG ReadDataAvailable;
    ULONG NumberOfMessages;
    ULONG MessageLength;
    CHAR Data[1];
} FILE_PIPE_PEEK_BUFFER, *PFILE_PIPE_PEEK_BUFFER;

// Output for FSCTL_PIPE_QUERY_EVENT
typedef struct _FILE_PIPE_EVENT_BUFFER
{
    ULONG NamedPipeState;
    ULONG EntryType;
    ULONG ByteCount;
    ULONG KeyValue;
    ULONG NumberRequests;
} FILE_PIPE_EVENT_BUFFER, *PFILE_PIPE_EVENT_BUFFER;

// Input for FSCTL_PIPE_WAIT
typedef struct _FILE_PIPE_WAIT_FOR_BUFFER
{
    LARGE_INTEGER Timeout;
    ULONG NameLength;
    BOOLEAN TimeoutSpecified;
    WCHAR Name[1];
} FILE_PIPE_WAIT_FOR_BUFFER, *PFILE_PIPE_WAIT_FOR_BUFFER;

// Input for FSCTL_PIPE_SET_CLIENT_PROCESS, Output for FSCTL_PIPE_QUERY_CLIENT_PROCESS
typedef struct _FILE_PIPE_CLIENT_PROCESS_BUFFER
{
#if !defined(BUILD_WOW6432)
    PVOID ClientSession;
    PVOID ClientProcess;
#else
    ULONGLONG ClientSession;
    ULONGLONG ClientProcess;
#endif
} FILE_PIPE_CLIENT_PROCESS_BUFFER, *PFILE_PIPE_CLIENT_PROCESS_BUFFER;

// Control structure for FSCTL_PIPE_QUERY_CLIENT_PROCESS_V2

typedef struct _FILE_PIPE_CLIENT_PROCESS_BUFFER_V2
{
     ULONGLONG ClientSession;
#if !defined(BUILD_WOW6432)
     PVOID ClientProcess;
#else
     ULONGLONG ClientProcess;
#endif
} FILE_PIPE_CLIENT_PROCESS_BUFFER_V2, *PFILE_PIPE_CLIENT_PROCESS_BUFFER_V2;

#define FILE_PIPE_COMPUTER_NAME_LENGTH 15

// Input for FSCTL_PIPE_SET_CLIENT_PROCESS, Output for FSCTL_PIPE_QUERY_CLIENT_PROCESS
typedef struct _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX
{
#if !defined(BUILD_WOW6432)
    PVOID ClientSession;
    PVOID ClientProcess;
#else
    ULONGLONG ClientSession;
    ULONGLONG ClientProcess;
#endif
    USHORT ClientComputerNameLength; // in bytes
    WCHAR ClientComputerBuffer[FILE_PIPE_COMPUTER_NAME_LENGTH + 1]; // null-terminated
} FILE_PIPE_CLIENT_PROCESS_BUFFER_EX, *PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX;

// Control structure for FSCTL_PIPE_SILO_ARRIVAL

typedef struct _FILE_PIPE_SILO_ARRIVAL_INPUT
{
    HANDLE JobHandle;
} FILE_PIPE_SILO_ARRIVAL_INPUT, *PFILE_PIPE_SILO_ARRIVAL_INPUT;

//
// Flags for create symlink
//

//
// A global symlink will cause resolution of the symlink's target to occur in
// the host silo (i.e. not in any current silo).  For example, if there is a
// symlink at \Device\Silos\37\Device\NamedPipe\symlink then the target will be
// resolved as \Device\NamedPipe\target instead of \Device\Silos\37\Device\NamedPipe\target
//
#define FILE_PIPE_SYMLINK_FLAG_GLOBAL   0x1

//
// A relative symlink will cause resolution of the symlink's target to occur relative
// to the root of the named pipe file system.  For example, if there is a symlink at
// \Device\NamedPipe\symlink that has a target called "target", then the target will
// be resolved as \Device\NamedPipe\target
//
#define FILE_PIPE_SYMLINK_FLAG_RELATIVE 0x2

#define FILE_PIPE_SYMLINK_VALID_FLAGS \
    (FILE_PIPE_SYMLINK_FLAG_GLOBAL | FILE_PIPE_SYMLINK_FLAG_RELATIVE)

// Control structure for FSCTL_PIPE_CREATE_SYMLINK

typedef struct _FILE_PIPE_CREATE_SYMLINK_INPUT
{
    USHORT NameOffset;
    USHORT NameLength;
    USHORT SubstituteNameOffset;
    USHORT SubstituteNameLength;
    ULONG Flags;
} FILE_PIPE_CREATE_SYMLINK_INPUT, *PFILE_PIPE_CREATE_SYMLINK_INPUT;

// Control structure for FSCTL_PIPE_DELETE_SYMLINK

typedef struct _FILE_PIPE_DELETE_SYMLINK_INPUT
{
    USHORT NameOffset;
    USHORT NameLength;
} FILE_PIPE_DELETE_SYMLINK_INPUT, *PFILE_PIPE_DELETE_SYMLINK_INPUT;

// Mailslot FS control definitions

#define MAILSLOT_CLASS_FIRSTCLASS 1
#define MAILSLOT_CLASS_SECONDCLASS 2

#define FSCTL_MAILSLOT_PEEK             CTL_CODE(FILE_DEVICE_MAILSLOT, 0, METHOD_NEITHER, FILE_READ_DATA)

// Output for FSCTL_MAILSLOT_PEEK
typedef struct _FILE_MAILSLOT_PEEK_BUFFER
{
    ULONG ReadDataAvailable;
    ULONG NumberOfMessages;
    ULONG MessageLength;
} FILE_MAILSLOT_PEEK_BUFFER, *PFILE_MAILSLOT_PEEK_BUFFER;

// Mount manager FS control definitions

#define MOUNTMGR_DEVICE_NAME L"\\Device\\MountPointManager"
#define MOUNTMGRCONTROLTYPE 0x0000006D // 'm'
#define MOUNTDEVCONTROLTYPE 0x0000004D // 'M'

#define IOCTL_MOUNTMGR_CREATE_POINT                 CTL_CODE(MOUNTMGRCONTROLTYPE, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_DELETE_POINTS                CTL_CODE(MOUNTMGRCONTROLTYPE, 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_POINTS                 CTL_CODE(MOUNTMGRCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY         CTL_CODE(MOUNTMGRCONTROLTYPE, 3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER            CTL_CODE(MOUNTMGRCONTROLTYPE, 4, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS          CTL_CODE(MOUNTMGRCONTROLTYPE, 5, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED   CTL_CODE(MOUNTMGRCONTROLTYPE, 6, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED   CTL_CODE(MOUNTMGRCONTROLTYPE, 7, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CHANGE_NOTIFY                CTL_CODE(MOUNTMGRCONTROLTYPE, 8, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE      CTL_CODE(MOUNTMGRCONTROLTYPE, 9, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES    CTL_CODE(MOUNTMGRCONTROLTYPE, 10, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION  CTL_CODE(MOUNTMGRCONTROLTYPE, 11, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH        CTL_CODE(MOUNTMGRCONTROLTYPE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS       CTL_CODE(MOUNTMGRCONTROLTYPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_MOUNTDEV_QUERY_DEVICE_NAME            CTL_CODE(MOUNTDEVCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Input structure for IOCTL_MOUNTMGR_CREATE_POINT.
typedef struct _MOUNTMGR_CREATE_POINT_INPUT
{
    USHORT SymbolicLinkNameOffset;
    USHORT SymbolicLinkNameLength;
    USHORT DeviceNameOffset;
    USHORT DeviceNameLength;
} MOUNTMGR_CREATE_POINT_INPUT, *PMOUNTMGR_CREATE_POINT_INPUT;

// Input structure for IOCTL_MOUNTMGR_DELETE_POINTS, IOCTL_MOUNTMGR_QUERY_POINTS, and IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY.
typedef struct _MOUNTMGR_MOUNT_POINT
{
    ULONG SymbolicLinkNameOffset;
    USHORT SymbolicLinkNameLength;
    USHORT Reserved1;
    ULONG UniqueIdOffset;
    USHORT UniqueIdLength;
    USHORT Reserved2;
    ULONG DeviceNameOffset;
    USHORT DeviceNameLength;
    USHORT Reserved3;
} MOUNTMGR_MOUNT_POINT, *PMOUNTMGR_MOUNT_POINT;

// Output structure for IOCTL_MOUNTMGR_DELETE_POINTS, IOCTL_MOUNTMGR_QUERY_POINTS, and IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY.
typedef struct _MOUNTMGR_MOUNT_POINTS
{
    ULONG Size;
    ULONG NumberOfMountPoints;
    MOUNTMGR_MOUNT_POINT MountPoints[1];
} MOUNTMGR_MOUNT_POINTS, *PMOUNTMGR_MOUNT_POINTS;

// Input structure for IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER.
typedef struct _MOUNTMGR_DRIVE_LETTER_TARGET
{
    USHORT DeviceNameLength;
    WCHAR DeviceName[1];
} MOUNTMGR_DRIVE_LETTER_TARGET, *PMOUNTMGR_DRIVE_LETTER_TARGET;

// Output structure for IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER.
typedef struct _MOUNTMGR_DRIVE_LETTER_INFORMATION
{
    BOOLEAN DriveLetterWasAssigned;
    UCHAR CurrentDriveLetter;
} MOUNTMGR_DRIVE_LETTER_INFORMATION, *PMOUNTMGR_DRIVE_LETTER_INFORMATION;

// Input structure for IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED and
// IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED.
typedef struct _MOUNTMGR_VOLUME_MOUNT_POINT
{
    USHORT SourceVolumeNameOffset;
    USHORT SourceVolumeNameLength;
    USHORT TargetVolumeNameOffset;
    USHORT TargetVolumeNameLength;
} MOUNTMGR_VOLUME_MOUNT_POINT, *PMOUNTMGR_VOLUME_MOUNT_POINT;

// Input structure for IOCTL_MOUNTMGR_CHANGE_NOTIFY.
// Output structure for IOCTL_MOUNTMGR_CHANGE_NOTIFY.
typedef struct _MOUNTMGR_CHANGE_NOTIFY_INFO
{
    ULONG EpicNumber;
} MOUNTMGR_CHANGE_NOTIFY_INFO, *PMOUNTMGR_CHANGE_NOTIFY_INFO;

// Input structure for IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE,
// IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,
// IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH, and
// IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS.
// IOCTL_MOUNTMGR_PREPARE_VOLUME_DELETE
// IOCTL_MOUNTMGR_CANCEL_VOLUME_DELETE
typedef struct _MOUNTMGR_TARGET_NAME
{
    USHORT DeviceNameLength;
    WCHAR DeviceName[1];
} MOUNTMGR_TARGET_NAME, * PMOUNTMGR_TARGET_NAME;

// Macro that defines what a "drive letter" mount point is.  This macro can
// be used to scan the result from QUERY_POINTS to discover which mount points
// are find "drive letter" mount points.
#define MOUNTMGR_IS_DRIVE_LETTER(s) ( \
    (s)->Length == 28 && \
    (s)->Buffer[0] == '\\' && \
    (s)->Buffer[1] == 'D' && \
    (s)->Buffer[2] == 'o' && \
    (s)->Buffer[3] == 's' && \
    (s)->Buffer[4] == 'D' && \
    (s)->Buffer[5] == 'e' && \
    (s)->Buffer[6] == 'v' && \
    (s)->Buffer[7] == 'i' && \
    (s)->Buffer[8] == 'c' && \
    (s)->Buffer[9] == 'e' && \
    (s)->Buffer[10] == 's' && \
    (s)->Buffer[11] == '\\' && \
    (s)->Buffer[12] >= 'A' && \
    (s)->Buffer[12] <= 'Z' && \
    (s)->Buffer[13] == ':')

// Macro that defines what a "volume name" mount point is.  This macro can
// be used to scan the result from QUERY_POINTS to discover which mount points
// are "volume name" mount points.
#define MOUNTMGR_IS_VOLUME_NAME(s) ( \
     ((s)->Length == 96 || ((s)->Length == 98 && (s)->Buffer[48] == '\\')) && \
     (s)->Buffer[0] == '\\' && \
     ((s)->Buffer[1] == '?' || (s)->Buffer[1] == '\\') && \
     (s)->Buffer[2] == '?' && \
     (s)->Buffer[3] == '\\' && \
     (s)->Buffer[4] == 'V' && \
     (s)->Buffer[5] == 'o' && \
     (s)->Buffer[6] == 'l' && \
     (s)->Buffer[7] == 'u' && \
     (s)->Buffer[8] == 'm' && \
     (s)->Buffer[9] == 'e' && \
     (s)->Buffer[10] == '{' && \
     (s)->Buffer[19] == '-' && \
     (s)->Buffer[24] == '-' && \
     (s)->Buffer[29] == '-' && \
     (s)->Buffer[34] == '-' && \
     (s)->Buffer[47] == '}')

// Output structure for IOCTL_MOUNTDEV_QUERY_DEVICE_NAME.
typedef struct _MOUNTDEV_NAME
{
    USHORT NameLength;
    WCHAR Name[1];
} MOUNTDEV_NAME, * PMOUNTDEV_NAME;

// Output structure for IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH and IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS.
typedef struct _MOUNTMGR_VOLUME_PATHS
{
    ULONG MultiSzLength;
    WCHAR MultiSz[1];
} MOUNTMGR_VOLUME_PATHS, *PMOUNTMGR_VOLUME_PATHS;

#define MOUNTMGR_IS_DOS_VOLUME_NAME(s) ( \
     MOUNTMGR_IS_VOLUME_NAME(s) && \
     (s)->Length == 96 && \
     (s)->Buffer[1] == '\\')

#define MOUNTMGR_IS_DOS_VOLUME_NAME_WB(s) ( \
     MOUNTMGR_IS_VOLUME_NAME(s) && \
     (s)->Length == 98 && \
     (s)->Buffer[1] == '\\')

#define MOUNTMGR_IS_NT_VOLUME_NAME(s) ( \
     MOUNTMGR_IS_VOLUME_NAME(s) && \
     (s)->Length == 96 && \
     (s)->Buffer[1] == '?')

#define MOUNTMGR_IS_NT_VOLUME_NAME_WB(s) ( \
     MOUNTMGR_IS_VOLUME_NAME(s) && \
     (s)->Length == 98 && \
     (s)->Buffer[1] == '?')

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTLPCAPI_H
#define _NTLPCAPI_H

#define PORT_CONNECT 0x0001
#define PORT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1)

typedef struct _PORT_MESSAGE
{
    union
    {
        struct
        {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union
    {
        struct
        {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union
    {
        CLIENT_ID ClientId;
        double DoNotUseThisField;
    };
    ULONG MessageId;
    union
    {
        SIZE_T ClientViewSize; // only valid for LPC_CONNECTION_REQUEST messages
        ULONG CallbackId; // only valid for LPC_REQUEST messages
    };
} PORT_MESSAGE, *PPORT_MESSAGE;

typedef struct _PORT_DATA_ENTRY
{
    PVOID Base;
    ULONG Size;
} PORT_DATA_ENTRY, *PPORT_DATA_ENTRY;

typedef struct _PORT_DATA_INFORMATION
{
    ULONG CountDataEntries;
    PORT_DATA_ENTRY DataEntries[1];
} PORT_DATA_INFORMATION, *PPORT_DATA_INFORMATION;

#define LPC_REQUEST 1
#define LPC_REPLY 2
#define LPC_DATAGRAM 3
#define LPC_LOST_REPLY 4
#define LPC_PORT_CLOSED 5
#define LPC_CLIENT_DIED 6
#define LPC_EXCEPTION 7
#define LPC_DEBUG_EVENT 8
#define LPC_ERROR_EVENT 9
#define LPC_CONNECTION_REQUEST 10

#define LPC_KERNELMODE_MESSAGE (CSHORT)0x8000
#define LPC_NO_IMPERSONATE (CSHORT)0x4000

#define PORT_VALID_OBJECT_ATTRIBUTES OBJ_CASE_INSENSITIVE

#ifdef _WIN64
#define PORT_MAXIMUM_MESSAGE_LENGTH 512
#else
#define PORT_MAXIMUM_MESSAGE_LENGTH 256
#endif

#define LPC_MAX_CONNECTION_INFO_SIZE (16 * sizeof(ULONG_PTR))

#define PORT_TOTAL_MAXIMUM_MESSAGE_LENGTH \
    ((PORT_MAXIMUM_MESSAGE_LENGTH + sizeof(PORT_MESSAGE) + LPC_MAX_CONNECTION_INFO_SIZE + 0xf) & ~0xf)

typedef struct _LPC_CLIENT_DIED_MSG
{
    PORT_MESSAGE PortMsg;
    LARGE_INTEGER CreateTime;
} LPC_CLIENT_DIED_MSG, *PLPC_CLIENT_DIED_MSG;

typedef struct _PORT_VIEW
{
    ULONG Length;
    HANDLE SectionHandle;
    ULONG SectionOffset;
    SIZE_T ViewSize;
    PVOID ViewBase;
    PVOID ViewRemoteBase;
} PORT_VIEW, *PPORT_VIEW;

typedef struct _REMOTE_PORT_VIEW
{
    ULONG Length;
    SIZE_T ViewSize;
    PVOID ViewBase;
} REMOTE_PORT_VIEW, *PREMOTE_PORT_VIEW;

// WOW64 definitions

// Except in a small number of special cases, WOW64 programs using the LPC APIs must use the 64-bit versions of the
// PORT_MESSAGE, PORT_VIEW and REMOTE_PORT_VIEW data structures. Note that we take a different approach than the
// official NT headers, which produce 64-bit versions in a 32-bit environment when USE_LPC6432 is defined.

typedef struct _PORT_MESSAGE64
{
    union
    {
        struct
        {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union
    {
        struct
        {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union
    {
        CLIENT_ID64 ClientId;
        double DoNotUseThisField;
    };
    ULONG MessageId;
    union
    {
        ULONGLONG ClientViewSize; // only valid for LPC_CONNECTION_REQUEST messages
        ULONG CallbackId; // only valid for LPC_REQUEST messages
    };
} PORT_MESSAGE64, *PPORT_MESSAGE64;

typedef struct _LPC_CLIENT_DIED_MSG64
{
    PORT_MESSAGE64 PortMsg;
    LARGE_INTEGER CreateTime;
} LPC_CLIENT_DIED_MSG64, *PLPC_CLIENT_DIED_MSG64;

typedef struct _PORT_VIEW64
{
    ULONG Length;
    ULONGLONG SectionHandle;
    ULONG SectionOffset;
    ULONGLONG ViewSize;
    ULONGLONG ViewBase;
    ULONGLONG ViewRemoteBase;
} PORT_VIEW64, *PPORT_VIEW64;

typedef struct _REMOTE_PORT_VIEW64
{
    ULONG Length;
    ULONGLONG ViewSize;
    ULONGLONG ViewBase;
} REMOTE_PORT_VIEW64, *PREMOTE_PORT_VIEW64;

// Port creation

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreatePort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG MaxConnectionInfoLength,
    _In_ ULONG MaxMessageLength,
    _In_opt_ ULONG MaxPoolUsage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateWaitablePort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG MaxConnectionInfoLength,
    _In_ ULONG MaxMessageLength,
    _In_opt_ ULONG MaxPoolUsage
    );

// Port connection (client)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _Inout_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_updates_bytes_to_opt_(*ConnectionInformationLength, *ConnectionInformationLength) PVOID ConnectionInformation,
    _Inout_opt_ PULONG ConnectionInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSecureConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _In_opt_ PSID RequiredServerSid,
    _Inout_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_updates_bytes_to_opt_(*ConnectionInformationLength, *ConnectionInformationLength) PVOID ConnectionInformation,
    _Inout_opt_ PULONG ConnectionInformationLength
    );

// Port connection (server)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtListenPort(
    _In_ HANDLE PortHandle,
    _Out_ PPORT_MESSAGE ConnectionRequest
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAcceptConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ PVOID PortContext,
    _In_ PPORT_MESSAGE ConnectionRequest,
    _In_ BOOLEAN AcceptConnection,
    _Inout_opt_ PPORT_VIEW ServerView,
    _Out_opt_ PREMOTE_PORT_VIEW ClientView
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompleteConnectPort(
    _In_ HANDLE PortHandle
    );

// General

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRequestPort(
    _In_ HANDLE PortHandle,
    _In_reads_bytes_(RequestMessage->u1.s1.TotalLength) PPORT_MESSAGE RequestMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRequestWaitReplyPort(
    _In_ HANDLE PortHandle,
    _In_reads_bytes_(RequestMessage->u1.s1.TotalLength) PPORT_MESSAGE RequestMessage,
    _Out_ PPORT_MESSAGE ReplyMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplyPort(
    _In_ HANDLE PortHandle,
    _In_reads_bytes_(ReplyMessage->u1.s1.TotalLength) PPORT_MESSAGE ReplyMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplyWaitReplyPort(
    _In_ HANDLE PortHandle,
    _Inout_ PPORT_MESSAGE ReplyMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplyWaitReceivePort(
    _In_ HANDLE PortHandle,
    _Out_opt_ PVOID *PortContext,
    _In_reads_bytes_opt_(ReplyMessage->u1.s1.TotalLength) PPORT_MESSAGE ReplyMessage,
    _Out_ PPORT_MESSAGE ReceiveMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplyWaitReceivePortEx(
    _In_ HANDLE PortHandle,
    _Out_opt_ PVOID *PortContext,
    _In_reads_bytes_opt_(ReplyMessage->u1.s1.TotalLength) PPORT_MESSAGE ReplyMessage,
    _Out_ PPORT_MESSAGE ReceiveMessage,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtImpersonateClientOfPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _Out_writes_bytes_to_(BufferSize, *NumberOfBytesRead) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesWritten
    );

typedef enum _PORT_INFORMATION_CLASS
{
    PortBasicInformation,
    PortDumpInformation
} PORT_INFORMATION_CLASS;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationPort(
    _In_ HANDLE PortHandle,
    _In_ PORT_INFORMATION_CLASS PortInformationClass,
    _Out_writes_bytes_to_(Length, *ReturnLength) PVOID PortInformation,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength
    );

// Asynchronous Local Inter-process Communication

// rev
typedef HANDLE ALPC_HANDLE, *PALPC_HANDLE;

#define ALPC_PORFLG_ALLOW_LPC_REQUESTS 0x20000 // rev
#define ALPC_PORFLG_WAITABLE_PORT 0x40000 // dbg
#define ALPC_PORFLG_SYSTEM_PROCESS 0x100000 // dbg

// symbols
typedef struct _ALPC_PORT_ATTRIBUTES
{
    ULONG Flags;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    SIZE_T MaxMessageLength;
    SIZE_T MemoryBandwidth;
    SIZE_T MaxPoolUsage;
    SIZE_T MaxSectionSize;
    SIZE_T MaxViewSize;
    SIZE_T MaxTotalSectionSize;
    ULONG DupObjectTypes;
#ifdef _WIN64
    ULONG Reserved;
#endif
} ALPC_PORT_ATTRIBUTES, *PALPC_PORT_ATTRIBUTES;

// begin_rev
#define ALPC_MESSAGE_SECURITY_ATTRIBUTE 0x80000000
#define ALPC_MESSAGE_VIEW_ATTRIBUTE 0x40000000
#define ALPC_MESSAGE_CONTEXT_ATTRIBUTE 0x20000000
#define ALPC_MESSAGE_HANDLE_ATTRIBUTE 0x10000000
// end_rev

// symbols
typedef struct _ALPC_MESSAGE_ATTRIBUTES
{
    ULONG AllocatedAttributes;
    ULONG ValidAttributes;
} ALPC_MESSAGE_ATTRIBUTES, *PALPC_MESSAGE_ATTRIBUTES;

// symbols
typedef struct _ALPC_COMPLETION_LIST_STATE
{
    union
    {
        struct
        {
            ULONG64 Head : 24;
            ULONG64 Tail : 24;
            ULONG64 ActiveThreadCount : 16;
        } s1;
        ULONG64 Value;
    } u1;
} ALPC_COMPLETION_LIST_STATE, *PALPC_COMPLETION_LIST_STATE;

#define ALPC_COMPLETION_LIST_BUFFER_GRANULARITY_MASK 0x3f // dbg

// symbols
typedef struct DECLSPEC_ALIGN(128) _ALPC_COMPLETION_LIST_HEADER
{
    ULONG64 StartMagic;

    ULONG TotalSize;
    ULONG ListOffset;
    ULONG ListSize;
    ULONG BitmapOffset;
    ULONG BitmapSize;
    ULONG DataOffset;
    ULONG DataSize;
    ULONG AttributeFlags;
    ULONG AttributeSize;

    DECLSPEC_ALIGN(128) ALPC_COMPLETION_LIST_STATE State;
    ULONG LastMessageId;
    ULONG LastCallbackId;
    DECLSPEC_ALIGN(128) ULONG PostCount;
    DECLSPEC_ALIGN(128) ULONG ReturnCount;
    DECLSPEC_ALIGN(128) ULONG LogSequenceNumber;
    DECLSPEC_ALIGN(128) RTL_SRWLOCK UserLock;

    ULONG64 EndMagic;
} ALPC_COMPLETION_LIST_HEADER, *PALPC_COMPLETION_LIST_HEADER;

// private
typedef struct _ALPC_CONTEXT_ATTR
{
    PVOID PortContext;
    PVOID MessageContext;
    ULONG Sequence;
    ULONG MessageId;
    ULONG CallbackId;
} ALPC_CONTEXT_ATTR, *PALPC_CONTEXT_ATTR;

// begin_rev
#define ALPC_HANDLEFLG_DUPLICATE_SAME_ACCESS 0x10000
#define ALPC_HANDLEFLG_DUPLICATE_SAME_ATTRIBUTES 0x20000
#define ALPC_HANDLEFLG_DUPLICATE_INHERIT 0x80000
// end_rev

// private
typedef struct _ALPC_HANDLE_ATTR32
{
    ULONG Flags;
    ULONG Reserved0;
    ULONG SameAccess;
    ULONG SameAttributes;
    ULONG Indirect;
    ULONG Inherit;
    ULONG Reserved1;
    ULONG Handle;
    ULONG ObjectType; // ObjectTypeCode, not ObjectTypeIndex
    ULONG DesiredAccess;
    ULONG GrantedAccess;
} ALPC_HANDLE_ATTR32, *PALPC_HANDLE_ATTR32;

// private
typedef struct _ALPC_HANDLE_ATTR
{
    ULONG Flags;
    ULONG Reserved0;
    ULONG SameAccess;
    ULONG SameAttributes;
    ULONG Indirect;
    ULONG Inherit;
    ULONG Reserved1;
    HANDLE Handle;
    PALPC_HANDLE_ATTR32 HandleAttrArray;
    ULONG ObjectType; // ObjectTypeCode, not ObjectTypeIndex
    ULONG HandleCount;
    ACCESS_MASK DesiredAccess;
    ACCESS_MASK GrantedAccess;
} ALPC_HANDLE_ATTR, *PALPC_HANDLE_ATTR;

#define ALPC_SECFLG_CREATE_HANDLE 0x20000 // dbg
#define ALPC_SECFLG_NOSECTIONHANDLE 0x40000
// private
typedef struct _ALPC_SECURITY_ATTR
{
    ULONG Flags;
    PSECURITY_QUALITY_OF_SERVICE QoS;
    ALPC_HANDLE ContextHandle; // dbg
} ALPC_SECURITY_ATTR, *PALPC_SECURITY_ATTR;

// begin_rev
#define ALPC_VIEWFLG_NOT_SECURE 0x40000
// end_rev

// private
typedef struct _ALPC_DATA_VIEW_ATTR
{
    ULONG Flags;
    ALPC_HANDLE SectionHandle;
    PVOID ViewBase; // must be zero on input
    SIZE_T ViewSize;
} ALPC_DATA_VIEW_ATTR, *PALPC_DATA_VIEW_ATTR;

// private
typedef enum _ALPC_PORT_INFORMATION_CLASS
{
    AlpcBasicInformation, // q: out ALPC_BASIC_INFORMATION
    AlpcPortInformation, // s: in ALPC_PORT_ATTRIBUTES
    AlpcAssociateCompletionPortInformation, // s: in ALPC_PORT_ASSOCIATE_COMPLETION_PORT
    AlpcConnectedSIDInformation, // q: in SID
    AlpcServerInformation, // q: inout ALPC_SERVER_INFORMATION
    AlpcMessageZoneInformation, // s: in ALPC_PORT_MESSAGE_ZONE_INFORMATION
    AlpcRegisterCompletionListInformation, // s: in ALPC_PORT_COMPLETION_LIST_INFORMATION
    AlpcUnregisterCompletionListInformation, // s: VOID
    AlpcAdjustCompletionListConcurrencyCountInformation, // s: in ULONG
    AlpcRegisterCallbackInformation, // kernel-mode only
    AlpcCompletionListRundownInformation, // s: VOID // 10
    AlpcWaitForPortReferences,
    AlpcServerSessionInformation // q: ALPC_SERVER_SESSION_INFORMATION // since 19H2
} ALPC_PORT_INFORMATION_CLASS;

// private
typedef struct _ALPC_BASIC_INFORMATION
{
    ULONG Flags;
    ULONG SequenceNo;
    PVOID PortContext;
} ALPC_BASIC_INFORMATION, *PALPC_BASIC_INFORMATION;

// private
typedef struct _ALPC_PORT_ASSOCIATE_COMPLETION_PORT
{
    PVOID CompletionKey;
    HANDLE CompletionPort;
} ALPC_PORT_ASSOCIATE_COMPLETION_PORT, *PALPC_PORT_ASSOCIATE_COMPLETION_PORT;

// private
typedef struct _ALPC_SERVER_INFORMATION
{
    union
    {
        struct
        {
            HANDLE ThreadHandle;
        } In;
        struct
        {
            BOOLEAN ThreadBlocked;
            HANDLE ConnectedProcessId;
            UNICODE_STRING ConnectionPortName;
        } Out;
    };
} ALPC_SERVER_INFORMATION, *PALPC_SERVER_INFORMATION;

// private
typedef struct _ALPC_PORT_MESSAGE_ZONE_INFORMATION
{
    PVOID Buffer;
    ULONG Size;
} ALPC_PORT_MESSAGE_ZONE_INFORMATION, *PALPC_PORT_MESSAGE_ZONE_INFORMATION;

// private
typedef struct _ALPC_PORT_COMPLETION_LIST_INFORMATION
{
    PVOID Buffer; // PALPC_COMPLETION_LIST_HEADER
    ULONG Size;
    ULONG ConcurrencyCount;
    ULONG AttributeFlags;
} ALPC_PORT_COMPLETION_LIST_INFORMATION, *PALPC_PORT_COMPLETION_LIST_INFORMATION;

// private
typedef struct _ALPC_SERVER_SESSION_INFORMATION
{
    ULONG SessionId;
    ULONG ProcessId;
} ALPC_SERVER_SESSION_INFORMATION, *PALPC_SERVER_SESSION_INFORMATION;

// private
typedef enum _ALPC_MESSAGE_INFORMATION_CLASS
{
    AlpcMessageSidInformation, // q: out SID
    AlpcMessageTokenModifiedIdInformation,  // q: out LUID
    AlpcMessageDirectStatusInformation,
    AlpcMessageHandleInformation, // ALPC_MESSAGE_HANDLE_INFORMATION
    MaxAlpcMessageInfoClass
} ALPC_MESSAGE_INFORMATION_CLASS, *PALPC_MESSAGE_INFORMATION_CLASS;

typedef struct _ALPC_MESSAGE_HANDLE_INFORMATION
{
    ULONG Index;
    ULONG Flags;
    ULONG Handle;
    ULONG ObjectType;
    ACCESS_MASK GrantedAccess;
} ALPC_MESSAGE_HANDLE_INFORMATION, *PALPC_MESSAGE_HANDLE_INFORMATION;

// begin_private

#if (PHNT_VERSION >= PHNT_VISTA)

// System calls

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcCreatePort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcDisconnectPort(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcQueryInformation(
    _In_opt_ HANDLE PortHandle,
    _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass,
    _Inout_updates_bytes_to_(Length, *ReturnLength) PVOID PortInformation,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcSetInformation(
    _In_ HANDLE PortHandle,
    _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass,
    _In_reads_bytes_opt_(Length) PVOID PortInformation,
    _In_ ULONG Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcCreatePortSection(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags,
    _In_opt_ HANDLE SectionHandle,
    _In_ SIZE_T SectionSize,
    _Out_ PALPC_HANDLE AlpcSectionHandle,
    _Out_ PSIZE_T ActualSectionSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcDeletePortSection(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE SectionHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcCreateResourceReserve(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ SIZE_T MessageSize,
    _Out_ PALPC_HANDLE ResourceId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcDeleteResourceReserve(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE ResourceId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcCreateSectionView(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _Inout_ PALPC_DATA_VIEW_ATTR ViewAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcDeleteSectionView(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ PVOID ViewBase
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcCreateSecurityContext(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _Inout_ PALPC_SECURITY_ATTR SecurityAttribute
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcDeleteSecurityContext(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE ContextHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcRevokeSecurityContext(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE ContextHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcQueryInformationMessage(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE PortMessage,
    _In_ ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass,
    _Out_writes_bytes_to_opt_(Length, *ReturnLength) PVOID MessageInformation,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength
    );

#define ALPC_MSGFLG_REPLY_MESSAGE 0x1
#define ALPC_MSGFLG_LPC_MODE 0x2 // ?
#define ALPC_MSGFLG_RELEASE_MESSAGE 0x10000 // dbg
#define ALPC_MSGFLG_SYNC_REQUEST 0x20000 // dbg
#define ALPC_MSGFLG_WAIT_USER_MODE 0x100000
#define ALPC_MSGFLG_WAIT_ALERTABLE 0x200000
#define ALPC_MSGFLG_WOW64_CALL 0x80000000 // dbg

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes,
    _In_ ULONG Flags,
    _In_opt_ PSID RequiredServerSid,
    _Inout_updates_bytes_to_opt_(*BufferLength, *BufferLength) PPORT_MESSAGE ConnectionMessage,
    _Inout_opt_ PULONG BufferLength,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES InMessageAttributes,
    _In_opt_ PLARGE_INTEGER Timeout
    );

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcConnectPortEx(
    _Out_ PHANDLE PortHandle,
    _In_ POBJECT_ATTRIBUTES ConnectionPortObjectAttributes,
    _In_opt_ POBJECT_ATTRIBUTES ClientPortObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes,
    _In_ ULONG Flags,
    _In_opt_ PSECURITY_DESCRIPTOR ServerSecurityRequirements,
    _Inout_updates_bytes_to_opt_(*BufferLength, *BufferLength) PPORT_MESSAGE ConnectionMessage,
    _Inout_opt_ PSIZE_T BufferLength,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES InMessageAttributes,
    _In_opt_ PLARGE_INTEGER Timeout
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcAcceptConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ HANDLE ConnectionPortHandle,
    _In_ ULONG Flags,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes,
    _In_opt_ PVOID PortContext,
    _In_reads_bytes_(ConnectionRequest->u1.s1.TotalLength) PPORT_MESSAGE ConnectionRequest,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes,
    _In_ BOOLEAN AcceptConnection
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcSendWaitReceivePort(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags,
    _In_reads_bytes_opt_(SendMessage->u1.s1.TotalLength) PPORT_MESSAGE SendMessage,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes,
    _Out_writes_bytes_to_opt_(*BufferLength, *BufferLength) PPORT_MESSAGE ReceiveMessage,
    _Inout_opt_ PSIZE_T BufferLength,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes,
    _In_opt_ PLARGE_INTEGER Timeout
    );

#define ALPC_CANCELFLG_TRY_CANCEL 0x1 // dbg
#define ALPC_CANCELFLG_NO_CONTEXT_CHECK 0x8
#define ALPC_CANCELFLGP_FLUSH 0x10000 // dbg

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcCancelMessage(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags,
    _In_ PALPC_CONTEXT_ATTR MessageContext
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcImpersonateClientOfPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ PVOID Flags
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcImpersonateClientContainerOfPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG Flags
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcOpenSenderProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE PortMessage,
    _In_ ULONG Flags,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcOpenSenderThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE PortMessage,
    _In_ ULONG Flags,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

// Support functions

NTSYSAPI
ULONG
NTAPI
AlpcMaxAllowedMessageLength(
    VOID
    );

NTSYSAPI
ULONG
NTAPI
AlpcGetHeaderSize(
    _In_ ULONG Flags
    );

#define ALPC_ATTRFLG_ALLOCATEDATTR 0x20000000
#define ALPC_ATTRFLG_VALIDATTR 0x40000000
#define ALPC_ATTRFLG_KEEPRUNNINGATTR 0x60000000

NTSYSAPI
NTSTATUS
NTAPI
AlpcInitializeMessageAttribute(
    _In_ ULONG AttributeFlags,
    _Out_opt_ PALPC_MESSAGE_ATTRIBUTES Buffer,
    _In_ ULONG BufferSize,
    _Out_ PULONG RequiredBufferSize
    );

NTSYSAPI
PVOID
NTAPI
AlpcGetMessageAttribute(
    _In_ PALPC_MESSAGE_ATTRIBUTES Buffer,
    _In_ ULONG AttributeFlag
    );

NTSYSAPI
NTSTATUS
NTAPI
AlpcRegisterCompletionList(
    _In_ HANDLE PortHandle,
    _Out_ PALPC_COMPLETION_LIST_HEADER Buffer,
    _In_ ULONG Size,
    _In_ ULONG ConcurrencyCount,
    _In_ ULONG AttributeFlags
    );

NTSYSAPI
NTSTATUS
NTAPI
AlpcUnregisterCompletionList(
    _In_ HANDLE PortHandle
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
AlpcRundownCompletionList(
    _In_ HANDLE PortHandle
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
AlpcAdjustCompletionListConcurrencyCount(
    _In_ HANDLE PortHandle,
    _In_ ULONG ConcurrencyCount
    );

NTSYSAPI
BOOLEAN
NTAPI
AlpcRegisterCompletionListWorkerThread(
    _Inout_ PVOID CompletionList
    );

NTSYSAPI
BOOLEAN
NTAPI
AlpcUnregisterCompletionListWorkerThread(
    _Inout_ PVOID CompletionList
    );

NTSYSAPI
VOID
NTAPI
AlpcGetCompletionListLastMessageInformation(
    _In_ PVOID CompletionList,
    _Out_ PULONG LastMessageId,
    _Out_ PULONG LastCallbackId
    );

NTSYSAPI
ULONG
NTAPI
AlpcGetOutstandingCompletionListMessageCount(
    _In_ PVOID CompletionList
    );

NTSYSAPI
PPORT_MESSAGE
NTAPI
AlpcGetMessageFromCompletionList(
    _In_ PVOID CompletionList,
    _Out_opt_ PALPC_MESSAGE_ATTRIBUTES *MessageAttributes
    );

NTSYSAPI
VOID
NTAPI
AlpcFreeCompletionListMessage(
    _Inout_ PVOID CompletionList,
    _In_ PPORT_MESSAGE Message
    );

NTSYSAPI
PALPC_MESSAGE_ATTRIBUTES
NTAPI
AlpcGetCompletionListMessageAttributes(
    _In_ PVOID CompletionList,
    _In_ PPORT_MESSAGE Message
    );

#endif

// end_private

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTPFAPI_H
#define _NTPFAPI_H

// begin_private

// Prefetch

typedef enum _PF_BOOT_PHASE_ID
{
    PfKernelInitPhase = 0,
    PfBootDriverInitPhase = 90,
    PfSystemDriverInitPhase = 120,
    PfSessionManagerInitPhase = 150,
    PfSMRegistryInitPhase = 180,
    PfVideoInitPhase = 210,
    PfPostVideoInitPhase = 240,
    PfBootAcceptedRegistryInitPhase = 270,
    PfUserShellReadyPhase = 300,
    PfMaxBootPhaseId = 900
} PF_BOOT_PHASE_ID;

typedef enum _PF_ENABLE_STATUS
{
    PfSvNotSpecified,
    PfSvEnabled,
    PfSvDisabled,
    PfSvMaxEnableStatus
} PF_ENABLE_STATUS;

typedef struct _PF_TRACE_LIMITS
{
    ULONG MaxNumPages;
    ULONG MaxNumSections;
    LONGLONG TimerPeriod;
} PF_TRACE_LIMITS, *PPF_TRACE_LIMITS;

typedef struct _PF_SYSTEM_PREFETCH_PARAMETERS
{
    PF_ENABLE_STATUS EnableStatus[2];
    PF_TRACE_LIMITS TraceLimits[2];
    ULONG MaxNumActiveTraces;
    ULONG MaxNumSavedTraces;
    WCHAR RootDirPath[32];
    WCHAR HostingApplicationList[128];
} PF_SYSTEM_PREFETCH_PARAMETERS, *PPF_SYSTEM_PREFETCH_PARAMETERS;

#define PF_BOOT_CONTROL_VERSION 1

typedef struct _PF_BOOT_CONTROL
{
    ULONG Version;
    ULONG DisableBootPrefetching;
} PF_BOOT_CONTROL, *PPF_BOOT_CONTROL;

typedef enum _PREFETCHER_INFORMATION_CLASS
{
    PrefetcherRetrieveTrace = 1, // q: CHAR[]
    PrefetcherSystemParameters, // q: PF_SYSTEM_PREFETCH_PARAMETERS
    PrefetcherBootPhase, // s: PF_BOOT_PHASE_ID
    PrefetcherSpare1, // PrefetcherRetrieveBootLoaderTrace // q: CHAR[]
    PrefetcherBootControl, // s: PF_BOOT_CONTROL
    PrefetcherScenarioPolicyControl,
    PrefetcherSpare2,
    PrefetcherAppLaunchScenarioControl,
    PrefetcherInformationMax
} PREFETCHER_INFORMATION_CLASS;

#define PREFETCHER_INFORMATION_VERSION 23 // rev
#define PREFETCHER_INFORMATION_MAGIC ('kuhC') // rev

typedef struct _PREFETCHER_INFORMATION
{
    _In_ ULONG Version;
    _In_ ULONG Magic;
    _In_ PREFETCHER_INFORMATION_CLASS PrefetcherInformationClass;
    _Inout_ PVOID PrefetcherInformation;
    _Inout_ ULONG PrefetcherInformationLength;
} PREFETCHER_INFORMATION, *PPREFETCHER_INFORMATION;

// Superfetch

typedef struct _PF_SYSTEM_SUPERFETCH_PARAMETERS
{
    ULONG EnabledComponents;
    ULONG BootID;
    ULONG SavedSectInfoTracesMax;
    ULONG SavedPageAccessTracesMax;
    ULONG ScenarioPrefetchTimeoutStandby;
    ULONG ScenarioPrefetchTimeoutHibernate;
    ULONG ScenarioPrefetchTimeoutHiberBoot;
} PF_SYSTEM_SUPERFETCH_PARAMETERS, *PPF_SYSTEM_SUPERFETCH_PARAMETERS;

#define PF_PFN_PRIO_REQUEST_VERSION 1
#define PF_PFN_PRIO_REQUEST_QUERY_MEMORY_LIST 0x1
#define PF_PFN_PRIO_REQUEST_VALID_FLAGS 0x1

typedef struct _PF_PFN_PRIO_REQUEST
{
    ULONG Version;
    ULONG RequestFlags;
    ULONG_PTR PfnCount;
    SYSTEM_MEMORY_LIST_INFORMATION MemInfo;
    MMPFN_IDENTITY PageData[256];
} PF_PFN_PRIO_REQUEST, *PPF_PFN_PRIO_REQUEST;

typedef enum _PFS_PRIVATE_PAGE_SOURCE_TYPE
{
    PfsPrivateSourceKernel,
    PfsPrivateSourceSession,
    PfsPrivateSourceProcess,
    PfsPrivateSourceMax
} PFS_PRIVATE_PAGE_SOURCE_TYPE;

typedef struct _PFS_PRIVATE_PAGE_SOURCE
{
    PFS_PRIVATE_PAGE_SOURCE_TYPE Type;
    union
    {
        ULONG SessionId;
        ULONG ProcessId;
    };
    ULONG ImagePathHash;
    ULONG_PTR UniqueProcessHash;
} PFS_PRIVATE_PAGE_SOURCE, *PPFS_PRIVATE_PAGE_SOURCE;

typedef struct _PF_PRIVSOURCE_INFO
{
    PFS_PRIVATE_PAGE_SOURCE DbInfo;
    PVOID EProcess;
    SIZE_T WsPrivatePages;
    SIZE_T TotalPrivatePages;
    ULONG SessionID;
    CHAR ImageName[16];
    union {
        ULONG_PTR WsSwapPages;                 // process only PF_PRIVSOURCE_QUERY_WS_SWAP_PAGES.
        ULONG_PTR SessionPagedPoolPages;       // session only.
        ULONG_PTR StoreSizePages;              // process only PF_PRIVSOURCE_QUERY_STORE_INFO.
    };
    ULONG_PTR WsTotalPages;         // process/session only.
    ULONG DeepFreezeTimeMs;         // process only.
    ULONG ModernApp : 1;            // process only.
    ULONG DeepFrozen : 1;           // process only. If set, DeepFreezeTimeMs contains the time at which the freeze occurred
    ULONG Foreground : 1;           // process only.
    ULONG PerProcessStore : 1;      // process only.
    ULONG Spare : 28;
} PF_PRIVSOURCE_INFO, *PPF_PRIVSOURCE_INFO;

#define PF_PRIVSOURCE_QUERY_REQUEST_VERSION 8

typedef struct _PF_PRIVSOURCE_QUERY_REQUEST
{
    ULONG Version;
    ULONG Flags;
    ULONG InfoCount;
    PF_PRIVSOURCE_INFO InfoArray[1];
} PF_PRIVSOURCE_QUERY_REQUEST, *PPF_PRIVSOURCE_QUERY_REQUEST;

typedef enum _PF_PHASED_SCENARIO_TYPE
{
    PfScenarioTypeNone,
    PfScenarioTypeStandby,
    PfScenarioTypeHibernate,
    PfScenarioTypeFUS,
    PfScenarioTypeMax
} PF_PHASED_SCENARIO_TYPE;

#define PF_SCENARIO_PHASE_INFO_VERSION 4

typedef struct _PF_SCENARIO_PHASE_INFO
{
    ULONG Version;
    PF_PHASED_SCENARIO_TYPE ScenType;
    ULONG PhaseId;
    ULONG SequenceNumber;
    ULONG Flags;
    ULONG FUSUserId;
} PF_SCENARIO_PHASE_INFO, *PPF_SCENARIO_PHASE_INFO;

typedef struct _PF_MEMORY_LIST_NODE
{
    ULONGLONG Node : 8;
    ULONGLONG Spare : 56;
    ULONGLONG StandbyLowPageCount;
    ULONGLONG StandbyMediumPageCount;
    ULONGLONG StandbyHighPageCount;
    ULONGLONG FreePageCount;
    ULONGLONG ModifiedPageCount;
} PF_MEMORY_LIST_NODE, *PPF_MEMORY_LIST_NODE;

#define PF_MEMORY_LIST_INFO_VERSION 1

typedef struct _PF_MEMORY_LIST_INFO
{
    ULONG Version;
    ULONG Size;
    ULONG NodeCount;
    PF_MEMORY_LIST_NODE Nodes[1];
} PF_MEMORY_LIST_INFO, *PPF_MEMORY_LIST_INFO;

typedef struct _PF_PHYSICAL_MEMORY_RANGE
{
    ULONG_PTR BasePfn;
    ULONG_PTR PageCount;
} PF_PHYSICAL_MEMORY_RANGE, *PPF_PHYSICAL_MEMORY_RANGE;

#define PF_PHYSICAL_MEMORY_RANGE_INFO_V1_VERSION 1

typedef struct _PF_PHYSICAL_MEMORY_RANGE_INFO_V1
{
    ULONG Version;
    ULONG RangeCount;
    PF_PHYSICAL_MEMORY_RANGE Ranges[1];
} PF_PHYSICAL_MEMORY_RANGE_INFO_V1, *PPF_PHYSICAL_MEMORY_RANGE_INFO_V1;

#define PF_PHYSICAL_MEMORY_RANGE_INFO_V2_VERSION 2

typedef struct _PF_PHYSICAL_MEMORY_RANGE_INFO_V2
{
    ULONG Version;
    ULONG Flags;
    ULONG RangeCount;
    PF_PHYSICAL_MEMORY_RANGE Ranges[ANYSIZE_ARRAY];
} PF_PHYSICAL_MEMORY_RANGE_INFO_V2, *PPF_PHYSICAL_MEMORY_RANGE_INFO_V2;

// begin_rev

#define PF_REPURPOSED_BY_PREFETCH_INFO_VERSION 1

typedef struct _PF_REPURPOSED_BY_PREFETCH_INFO
{
    ULONG Version;
    ULONG RepurposedByPrefetch;
} PF_REPURPOSED_BY_PREFETCH_INFO, *PPF_REPURPOSED_BY_PREFETCH_INFO;

// end_rev

typedef enum _SUPERFETCH_INFORMATION_CLASS
{
    SuperfetchRetrieveTrace = 1, // q: CHAR[]
    SuperfetchSystemParameters, // q: PF_SYSTEM_SUPERFETCH_PARAMETERS
    SuperfetchLogEvent,
    SuperfetchGenerateTrace,
    SuperfetchPrefetch,
    SuperfetchPfnQuery, // q: PF_PFN_PRIO_REQUEST
    SuperfetchPfnSetPriority,
    SuperfetchPrivSourceQuery, // q: PF_PRIVSOURCE_QUERY_REQUEST
    SuperfetchSequenceNumberQuery, // q: ULONG
    SuperfetchScenarioPhase, // 10
    SuperfetchWorkerPriority,
    SuperfetchScenarioQuery, // q: PF_SCENARIO_PHASE_INFO
    SuperfetchScenarioPrefetch,
    SuperfetchRobustnessControl,
    SuperfetchTimeControl,
    SuperfetchMemoryListQuery, // q: PF_MEMORY_LIST_INFO
    SuperfetchMemoryRangesQuery, // q: PF_PHYSICAL_MEMORY_RANGE_INFO
    SuperfetchTracingControl,
    SuperfetchTrimWhileAgingControl,
    SuperfetchRepurposedByPrefetch, // q: PF_REPURPOSED_BY_PREFETCH_INFO // rev
    SuperfetchChannelPowerRequest,
    SuperfetchMovePages,
    SuperfetchVirtualQuery,
    SuperfetchCombineStatsQuery,
    SuperfetchSetMinWsAgeRate,
    SuperfetchDeprioritizeOldPagesInWs,
    SuperfetchFileExtentsQuery,
    SuperfetchGpuUtilizationQuery, // PF_GPU_UTILIZATION_INFO
    SuperfetchInformationMax
} SUPERFETCH_INFORMATION_CLASS;

#define SUPERFETCH_INFORMATION_VERSION 45 // rev
#define SUPERFETCH_INFORMATION_MAGIC ('kuhC') // rev

typedef struct _SUPERFETCH_INFORMATION
{
    _In_ ULONG Version;
    _In_ ULONG Magic;
    _In_ SUPERFETCH_INFORMATION_CLASS SuperfetchInformationClass;
    _Inout_ PVOID SuperfetchInformation;
    _Inout_ ULONG SuperfetchInformationLength;
} SUPERFETCH_INFORMATION, *PSUPERFETCH_INFORMATION;

// end_private

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTPNPAPI_H
#define _NTPNPAPI_H

typedef enum _PLUGPLAY_EVENT_CATEGORY
{
    HardwareProfileChangeEvent,
    TargetDeviceChangeEvent,
    DeviceClassChangeEvent,
    CustomDeviceEvent,
    DeviceInstallEvent,
    DeviceArrivalEvent,
    PowerEvent,
    VetoEvent,
    BlockedDriverEvent,
    InvalidIDEvent,
    MaxPlugEventCategory
} PLUGPLAY_EVENT_CATEGORY, *PPLUGPLAY_EVENT_CATEGORY;

typedef struct _PLUGPLAY_EVENT_BLOCK
{
    GUID EventGuid;
    PLUGPLAY_EVENT_CATEGORY EventCategory;
    PULONG Result;
    ULONG Flags;
    ULONG TotalSize;
    PVOID DeviceObject;

    union
    {
        struct
        {
            GUID ClassGuid;
            WCHAR SymbolicLinkName[1];
        } DeviceClass;
        struct
        {
            WCHAR DeviceIds[1];
        } TargetDevice;
        struct
        {
            WCHAR DeviceId[1];
        } InstallDevice;
        struct
        {
            PVOID NotificationStructure;
            WCHAR DeviceIds[1];
        } CustomNotification;
        struct
        {
            PVOID Notification;
        } ProfileNotification;
        struct
        {
            ULONG NotificationCode;
            ULONG NotificationData;
        } PowerNotification;
        struct
        {
            PNP_VETO_TYPE VetoType;
            WCHAR DeviceIdVetoNameBuffer[1]; // DeviceId<null>VetoName<null><null>
        } VetoNotification;
        struct
        {
            GUID BlockedDriverGuid;
        } BlockedDriverNotification;
        struct
        {
            WCHAR ParentId[1];
        } InvalidIDNotification;
    } u;
} PLUGPLAY_EVENT_BLOCK, *PPLUGPLAY_EVENT_BLOCK;

typedef enum _PLUGPLAY_CONTROL_CLASS
{
    PlugPlayControlEnumerateDevice, // PLUGPLAY_CONTROL_ENUMERATE_DEVICE_DATA
    PlugPlayControlRegisterNewDevice, // PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA
    PlugPlayControlDeregisterDevice, // PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA
    PlugPlayControlInitializeDevice, // PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA
    PlugPlayControlStartDevice, // PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA
    PlugPlayControlUnlockDevice, // PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA
    PlugPlayControlQueryAndRemoveDevice, // PLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA
    PlugPlayControlUserResponse, // PLUGPLAY_CONTROL_USER_RESPONSE_DATA
    PlugPlayControlGenerateLegacyDevice, // PLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA
    PlugPlayControlGetInterfaceDeviceList, // PLUGPLAY_CONTROL_INTERFACE_LIST_DATA
    PlugPlayControlProperty, // PLUGPLAY_CONTROL_PROPERTY_DATA
    PlugPlayControlDeviceClassAssociation, // PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA
    PlugPlayControlGetRelatedDevice, // PLUGPLAY_CONTROL_RELATED_DEVICE_DATA
    PlugPlayControlGetInterfaceDeviceAlias, // PLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA
    PlugPlayControlDeviceStatus, // PLUGPLAY_CONTROL_STATUS_DATA
    PlugPlayControlGetDeviceDepth, // PLUGPLAY_CONTROL_DEPTH_DATA
    PlugPlayControlQueryDeviceRelations, // PLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA
    PlugPlayControlTargetDeviceRelation, // PLUGPLAY_CONTROL_TARGET_RELATION_DATA
    PlugPlayControlQueryConflictList, // PLUGPLAY_CONTROL_CONFLICT_LIST
    PlugPlayControlRetrieveDock, // PLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA
    PlugPlayControlResetDevice, // PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA
    PlugPlayControlHaltDevice, // PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA
    PlugPlayControlGetBlockedDriverList, // PLUGPLAY_CONTROL_BLOCKED_DRIVER_DATA
    PlugPlayControlGetDeviceInterfaceEnabled, // PLUGPLAY_CONTROL_DEVICE_INTERFACE_ENABLED
    MaxPlugPlayControl
} PLUGPLAY_CONTROL_CLASS, *PPLUGPLAY_CONTROL_CLASS;

#if (PHNT_VERSION < PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetPlugPlayEvent(
    _In_ HANDLE EventHandle,
    _In_opt_ PVOID Context,
    _Out_writes_bytes_(EventBufferSize) PPLUGPLAY_EVENT_BLOCK EventBlock,
    _In_ ULONG EventBufferSize
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPlugPlayControl(
    _In_ PLUGPLAY_CONTROL_CLASS PnPControlClass,
    _Inout_updates_bytes_(PnPControlDataLength) PVOID PnPControlData,
    _In_ ULONG PnPControlDataLength
    );

#if (PHNT_VERSION >= PHNT_WIN7)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSerializeBoot(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnableLastKnownGood(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDisableLastKnownGood(
    VOID
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplacePartitionUnit(
    _In_ PUNICODE_STRING TargetInstancePath,
    _In_ PUNICODE_STRING SpareInstancePath,
    _In_ ULONG Flags
    );
#endif

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTPOAPI_H
#define _NTPOAPI_H

#if (PHNT_MODE != PHNT_MODE_KERNEL)
// POWER_INFORMATION_LEVEL
// Note: We don't use an enum for these values to minimize conflicts with the Windows SDK. (dmex)
#define SystemPowerPolicyAc 0 // SYSTEM_POWER_POLICY // GET: InputBuffer NULL. SET: InputBuffer not NULL.
#define SystemPowerPolicyDc 1 // SYSTEM_POWER_POLICY
#define VerifySystemPolicyAc 2 // SYSTEM_POWER_POLICY
#define VerifySystemPolicyDc 3 // SYSTEM_POWER_POLICY
#define SystemPowerCapabilities 4 // SYSTEM_POWER_CAPABILITIES
#define SystemBatteryState 5 // SYSTEM_BATTERY_STATE
#define SystemPowerStateHandler 6 // POWER_STATE_HANDLER // (kernel-mode only)
#define ProcessorStateHandler 7 // PROCESSOR_STATE_HANDLER // (kernel-mode only)
#define SystemPowerPolicyCurrent 8 // SYSTEM_POWER_POLICY
#define AdministratorPowerPolicy 9 // ADMINISTRATOR_POWER_POLICY
#define SystemReserveHiberFile 10 // BOOLEAN // (requires SeCreatePagefilePrivilege) // TRUE: hibernation file created. FALSE: hibernation file deleted.
#define ProcessorInformation 11 // PROCESSOR_POWER_INFORMATION
#define SystemPowerInformation 12 // SYSTEM_POWER_INFORMATION
#define ProcessorStateHandler2 13 // PROCESSOR_STATE_HANDLER2 // not implemented
#define LastWakeTime 14 // ULONGLONG // InterruptTime
#define LastSleepTime 15 // ULONGLONG // InterruptTime
#define SystemExecutionState 16 // EXECUTION_STATE // NtSetThreadExecutionState
#define SystemPowerStateNotifyHandler 17 // POWER_STATE_NOTIFY_HANDLER // (kernel-mode only)
#define ProcessorPowerPolicyAc 18 // PROCESSOR_POWER_POLICY // not implemented
#define ProcessorPowerPolicyDc 19 // PROCESSOR_POWER_POLICY // not implemented
#define VerifyProcessorPowerPolicyAc 20 // PROCESSOR_POWER_POLICY // not implemented
#define VerifyProcessorPowerPolicyDc 21 // PROCESSOR_POWER_POLICY // not implemented
#define ProcessorPowerPolicyCurrent 22 // PROCESSOR_POWER_POLICY // not implemented
#define SystemPowerStateLogging 23 // SYSTEM_POWER_STATE_DISABLE_REASON[]
#define SystemPowerLoggingEntry 24 // SYSTEM_POWER_LOGGING_ENTRY[] // (kernel-mode only)
#define SetPowerSettingValue 25 // (kernel-mode only)
#define NotifyUserPowerSetting 26 // not implemented
#define PowerInformationLevelUnused0 27 // not implemented
#define SystemMonitorHiberBootPowerOff 28 // NULL (PowerMonitorOff)
#define SystemVideoState 29 // MONITOR_DISPLAY_STATE
#define TraceApplicationPowerMessage 30 // (kernel-mode only)
#define TraceApplicationPowerMessageEnd 31 // (kernel-mode only)
#define ProcessorPerfStates 32 // (kernel-mode only)
#define ProcessorIdleStates 33 // (kernel-mode only)
#define ProcessorCap 34 // (kernel-mode only)
#define SystemWakeSource 35
#define SystemHiberFileInformation 36 // q: SYSTEM_HIBERFILE_INFORMATION
#define TraceServicePowerMessage 37
#define ProcessorLoad 38
#define PowerShutdownNotification 39 // (kernel-mode only)
#define MonitorCapabilities 40 // (kernel-mode only)
#define SessionPowerInit 41 // (kernel-mode only)
#define SessionDisplayState 42 // (kernel-mode only)
#define PowerRequestCreate 43 // in: COUNTED_REASON_CONTEXT, out: HANDLE
#define PowerRequestAction 44 // in: POWER_REQUEST_ACTION
#define GetPowerRequestList 45 // out: POWER_REQUEST_LIST
#define ProcessorInformationEx 46 // in: USHORT ProcessorGroup, out: PROCESSOR_POWER_INFORMATION
#define NotifyUserModeLegacyPowerEvent 47 // (kernel-mode only)
#define GroupPark 48 // (debug-mode boot only)
#define ProcessorIdleDomains 49 // (kernel-mode only)
#define WakeTimerList 50 // powercfg.exe /waketimers
#define SystemHiberFileSize 51 // ULONG
#define ProcessorIdleStatesHv 52 // (kernel-mode only)
#define ProcessorPerfStatesHv 53 // (kernel-mode only)
#define ProcessorPerfCapHv 54 // (kernel-mode only)
#define ProcessorSetIdle 55 // (debug-mode boot only)
#define LogicalProcessorIdling 56 // (kernel-mode only)
#define UserPresence 57 // POWER_USER_PRESENCE // not implemented
#define PowerSettingNotificationName 58
#define GetPowerSettingValue 59 // GUID
#define IdleResiliency 60 // POWER_IDLE_RESILIENCY
#define SessionRITState 61 // POWER_SESSION_RIT_STATE
#define SessionConnectNotification 62 // POWER_SESSION_WINLOGON
#define SessionPowerCleanup 63
#define SessionLockState 64 // POWER_SESSION_WINLOGON
#define SystemHiberbootState 65 // BOOLEAN // fast startup supported
#define PlatformInformation 66 // BOOLEAN // connected standby supported
#define PdcInvocation 67 // (kernel-mode only)
#define MonitorInvocation 68 // (kernel-mode only)
#define FirmwareTableInformationRegistered 69 // (kernel-mode only)
#define SetShutdownSelectedTime 70 // NULL
#define SuspendResumeInvocation 71 // (kernel-mode only)
#define PlmPowerRequestCreate 72 // in: COUNTED_REASON_CONTEXT, out: HANDLE
#define ScreenOff 73 // NULL (PowerMonitorOff)
#define CsDeviceNotification 74 // (kernel-mode only)
#define PlatformRole 75 // POWER_PLATFORM_ROLE
#define LastResumePerformance 76 // RESUME_PERFORMANCE
#define DisplayBurst 77 // NULL (PowerMonitorOn)
#define ExitLatencySamplingPercentage 78
#define RegisterSpmPowerSettings 79 // (kernel-mode only)
#define PlatformIdleStates 80 // (kernel-mode only)
#define ProcessorIdleVeto 81 // (kernel-mode only) // deprecated
#define PlatformIdleVeto 82 // (kernel-mode only) // deprecated
#define SystemBatteryStatePrecise 83 // SYSTEM_BATTERY_STATE
#define ThermalEvent 84  // THERMAL_EVENT // PowerReportThermalEvent
#define PowerRequestActionInternal 85 // POWER_REQUEST_ACTION_INTERNAL
#define BatteryDeviceState 86
#define PowerInformationInternal 87 // POWER_INFORMATION_LEVEL_INTERNAL // PopPowerInformationInternal
#define ThermalStandby 88 // NULL // shutdown with thermal standby as reason.
#define SystemHiberFileType 89 // ULONG // zero ? reduced : full // powercfg.exe /h /type
#define PhysicalPowerButtonPress 90 // BOOLEAN
#define QueryPotentialDripsConstraint 91 // (kernel-mode only)
#define EnergyTrackerCreate 92
#define EnergyTrackerQuery 93
#define UpdateBlackBoxRecorder 94
#define SessionAllowExternalDmaDevices 95
#define SendSuspendResumeNotification 96 // since WIN11
#define PowerInformationLevelMaximum 97
#endif

typedef struct _PROCESSOR_POWER_INFORMATION
{
    ULONG Number;
    ULONG MaxMhz;
    ULONG CurrentMhz;
    ULONG MhzLimit;
    ULONG MaxIdleState;
    ULONG CurrentIdleState;
} PROCESSOR_POWER_INFORMATION, *PPROCESSOR_POWER_INFORMATION;

typedef struct _SYSTEM_POWER_INFORMATION
{
    ULONG MaxIdlenessAllowed;
    ULONG Idleness;
    ULONG TimeRemaining;
    UCHAR CoolingMode;
} SYSTEM_POWER_INFORMATION, *PSYSTEM_POWER_INFORMATION;

typedef struct _SYSTEM_HIBERFILE_INFORMATION
{
    ULONG NumberOfMcbPairs;
    LARGE_INTEGER Mcb[1];
} SYSTEM_HIBERFILE_INFORMATION, *PSYSTEM_HIBERFILE_INFORMATION;

#define POWER_REQUEST_CONTEXT_NOT_SPECIFIED DIAGNOSTIC_REASON_NOT_SPECIFIED

// wdm
typedef struct _COUNTED_REASON_CONTEXT
{
    ULONG Version;
    ULONG Flags;
    union
    {
        struct
        {
            UNICODE_STRING ResourceFileName;
            USHORT ResourceReasonId;
            ULONG StringCount;
            _Field_size_(StringCount) PUNICODE_STRING ReasonStrings;
        };
        UNICODE_STRING SimpleString;
    };
} COUNTED_REASON_CONTEXT, *PCOUNTED_REASON_CONTEXT;

typedef enum _POWER_REQUEST_TYPE_INTERNAL // POWER_REQUEST_TYPE
{
    PowerRequestDisplayRequiredInternal,
    PowerRequestSystemRequiredInternal,
    PowerRequestAwayModeRequiredInternal,
    PowerRequestExecutionRequiredInternal, // Windows 8+
    PowerRequestPerfBoostRequiredInternal, // Windows 8+
    PowerRequestActiveLockScreenInternal, // Windows 10 RS1+ (reserved on Windows 8)
    // Values 6 and 7 are reserved for Windows 8 only
    PowerRequestInternalInvalid,
    PowerRequestInternalUnknown,
    PowerRequestFullScreenVideoRequired  // Windows 8 only
} POWER_REQUEST_TYPE_INTERNAL;

typedef struct _POWER_REQUEST_ACTION
{
    HANDLE PowerRequestHandle;
    POWER_REQUEST_TYPE_INTERNAL RequestType;
    BOOLEAN SetAction;
    HANDLE ProcessHandle; // Windows 8+ and only for requests created via PlmPowerRequestCreate
} POWER_REQUEST_ACTION, *PPOWER_REQUEST_ACTION;

typedef union _POWER_STATE
{
    SYSTEM_POWER_STATE SystemState;
    DEVICE_POWER_STATE DeviceState;
} POWER_STATE, *PPOWER_STATE;

typedef enum _POWER_STATE_TYPE
{
    SystemPowerState = 0,
    DevicePowerState
} POWER_STATE_TYPE, *PPOWER_STATE_TYPE;

// wdm
typedef struct _SYSTEM_POWER_STATE_CONTEXT
{
    union
    {
        struct
        {
            ULONG Reserved1 : 8;
            ULONG TargetSystemState : 4;
            ULONG EffectiveSystemState : 4;
            ULONG CurrentSystemState : 4;
            ULONG IgnoreHibernationPath : 1;
            ULONG PseudoTransition : 1;
            ULONG Reserved2 : 10;
        };
        ULONG ContextAsUlong;
    };
} SYSTEM_POWER_STATE_CONTEXT, *PSYSTEM_POWER_STATE_CONTEXT;

typedef enum _REQUESTER_TYPE
{
    KernelRequester = 0,
    UserProcessRequester = 1,
    UserSharedServiceRequester = 2
} REQUESTER_TYPE;

typedef struct _COUNTED_REASON_CONTEXT_RELATIVE
{
    ULONG Flags;
    union
    {
        struct
        {
            ULONG_PTR ResourceFileNameOffset;
            USHORT ResourceReasonId;
            ULONG StringCount;
            ULONG_PTR SubstitutionStringsOffset;
        };
        ULONG_PTR SimpleStringOffset;
    };
} COUNTED_REASON_CONTEXT_RELATIVE, *PCOUNTED_REASON_CONTEXT_RELATIVE;

typedef struct _DIAGNOSTIC_BUFFER
{
    SIZE_T Size;
    REQUESTER_TYPE CallerType;
    union
    {
        struct
        {
            ULONG_PTR ProcessImageNameOffset; // PWSTR
            ULONG ProcessId;
            ULONG ServiceTag;
        };
        struct
        {
            ULONG_PTR DeviceDescriptionOffset; // PWSTR
            ULONG_PTR DevicePathOffset; // PWSTR
        };
    };
    ULONG_PTR ReasonOffset; // PCOUNTED_REASON_CONTEXT_RELATIVE
} DIAGNOSTIC_BUFFER, *PDIAGNOSTIC_BUFFER;

// The number of supported request types per version
#define POWER_REQUEST_SUPPORTED_TYPES_V1 3 // Windows 7
#define POWER_REQUEST_SUPPORTED_TYPES_V2 9 // Windows 8
#define POWER_REQUEST_SUPPORTED_TYPES_V3 5 // Windows 8.1 and Windows 10 TH1-TH2
#define POWER_REQUEST_SUPPORTED_TYPES_V4 6 // Windows 10 RS1+

typedef struct _POWER_REQUEST
{
    union
    {
        struct
        {
            ULONG SupportedRequestMask;
            ULONG PowerRequestCount[POWER_REQUEST_SUPPORTED_TYPES_V1];
            DIAGNOSTIC_BUFFER DiagnosticBuffer;
        } V1;
#if (PHNT_VERSION >= PHNT_WIN8)
        struct
        {
            ULONG SupportedRequestMask;
            ULONG PowerRequestCount[POWER_REQUEST_SUPPORTED_TYPES_V2];
            DIAGNOSTIC_BUFFER DiagnosticBuffer;
        } V2;
#endif
#if (PHNT_VERSION >= PHNT_WINBLUE)
        struct
        {
            ULONG SupportedRequestMask;
            ULONG PowerRequestCount[POWER_REQUEST_SUPPORTED_TYPES_V3];
            DIAGNOSTIC_BUFFER DiagnosticBuffer;
        } V3;
#endif
#if (PHNT_VERSION >= PHNT_REDSTONE)
        struct
        {
            ULONG SupportedRequestMask;
            ULONG PowerRequestCount[POWER_REQUEST_SUPPORTED_TYPES_V4];
            DIAGNOSTIC_BUFFER DiagnosticBuffer;
        } V4;
#endif
    };
} POWER_REQUEST, *PPOWER_REQUEST;

typedef struct _POWER_REQUEST_LIST
{
    ULONG_PTR Count;
    ULONG_PTR PowerRequestOffsets[ANYSIZE_ARRAY]; // PPOWER_REQUEST
} POWER_REQUEST_LIST, *PPOWER_REQUEST_LIST;

typedef enum _POWER_STATE_HANDLER_TYPE
{
    PowerStateSleeping1 = 0,
    PowerStateSleeping2 = 1,
    PowerStateSleeping3 = 2,
    PowerStateSleeping4 = 3,
    PowerStateShutdownOff = 4,
    PowerStateShutdownReset = 5,
    PowerStateSleeping4Firmware = 6,
    PowerStateMaximum = 7
} POWER_STATE_HANDLER_TYPE, *PPOWER_STATE_HANDLER_TYPE;

typedef NTSTATUS (NTAPI *PENTER_STATE_SYSTEM_HANDLER)(
    _In_ PVOID SystemContext
    );

typedef NTSTATUS (NTAPI *PENTER_STATE_HANDLER)(
    _In_ PVOID Context,
    _In_opt_ PENTER_STATE_SYSTEM_HANDLER SystemHandler,
    _In_ PVOID SystemContext,
    _In_ LONG NumberProcessors,
    _In_ LONG volatile *Number
    );

typedef struct _POWER_STATE_HANDLER
{
    POWER_STATE_HANDLER_TYPE Type;
    BOOLEAN RtcWake;
    UCHAR Spare[3];
    PENTER_STATE_HANDLER Handler;
    PVOID Context;
} POWER_STATE_HANDLER, *PPOWER_STATE_HANDLER;

typedef NTSTATUS (NTAPI *PENTER_STATE_NOTIFY_HANDLER)(
    _In_ POWER_STATE_HANDLER_TYPE State,
    _In_ PVOID Context,
    _In_ BOOLEAN Entering
    );

typedef struct _POWER_STATE_NOTIFY_HANDLER
{
    PENTER_STATE_NOTIFY_HANDLER Handler;
    PVOID Context;
} POWER_STATE_NOTIFY_HANDLER, *PPOWER_STATE_NOTIFY_HANDLER;

typedef struct _POWER_REQUEST_ACTION_INTERNAL
{
    PVOID PowerRequestPointer;
    POWER_REQUEST_TYPE_INTERNAL RequestType;
    BOOLEAN SetAction;
} POWER_REQUEST_ACTION_INTERNAL, *PPOWER_REQUEST_ACTION_INTERNAL;

typedef enum _POWER_INFORMATION_LEVEL_INTERNAL
{
    PowerInternalAcpiInterfaceRegister,
    PowerInternalS0LowPowerIdleInfo, // POWER_S0_LOW_POWER_IDLE_INFO
    PowerInternalReapplyBrightnessSettings,
    PowerInternalUserAbsencePrediction, // POWER_USER_ABSENCE_PREDICTION
    PowerInternalUserAbsencePredictionCapability, // POWER_USER_ABSENCE_PREDICTION_CAPABILITY
    PowerInternalPoProcessorLatencyHint, // POWER_PROCESSOR_LATENCY_HINT
    PowerInternalStandbyNetworkRequest, // POWER_STANDBY_NETWORK_REQUEST
    PowerInternalDirtyTransitionInformation,
    PowerInternalSetBackgroundTaskState, // POWER_SET_BACKGROUND_TASK_STATE
    PowerInternalTtmOpenTerminal,
    PowerInternalTtmCreateTerminal, // 10
    PowerInternalTtmEvacuateDevices,
    PowerInternalTtmCreateTerminalEventQueue,
    PowerInternalTtmGetTerminalEvent,
    PowerInternalTtmSetDefaultDeviceAssignment,
    PowerInternalTtmAssignDevice,
    PowerInternalTtmSetDisplayState,
    PowerInternalTtmSetDisplayTimeouts,
    PowerInternalBootSessionStandbyActivationInformation,
    PowerInternalSessionPowerState,
    PowerInternalSessionTerminalInput, // 20
    PowerInternalSetWatchdog,
    PowerInternalPhysicalPowerButtonPressInfoAtBoot,
    PowerInternalExternalMonitorConnected,
    PowerInternalHighPrecisionBrightnessSettings,
    PowerInternalWinrtScreenToggle,
    PowerInternalPpmQosDisable,
    PowerInternalTransitionCheckpoint,
    PowerInternalInputControllerState,
    PowerInternalFirmwareResetReason,
    PowerInternalPpmSchedulerQosSupport, // 30
    PowerInternalBootStatGet,
    PowerInternalBootStatSet,
    PowerInternalCallHasNotReturnedWatchdog,
    PowerInternalBootStatCheckIntegrity,
    PowerInternalBootStatRestoreDefaults, // in: void
    PowerInternalHostEsStateUpdate,
    PowerInternalGetPowerActionState,
    PowerInternalBootStatUnlock,
    PowerInternalWakeOnVoiceState,
    PowerInternalDeepSleepBlock, // 40
    PowerInternalIsPoFxDevice,
    PowerInternalPowerTransitionExtensionAtBoot,
    PowerInternalProcessorBrandedFrequency, // in: POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_INPUT, out: POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_OUTPUT
    PowerInternalTimeBrokerExpirationReason,
    PowerInternalNotifyUserShutdownStatus,
    PowerInternalPowerRequestTerminalCoreWindow,
    PowerInternalProcessorIdleVeto,
    PowerInternalPlatformIdleVeto,
    PowerInternalIsLongPowerButtonBugcheckEnabled,
    PowerInternalAutoChkCausedReboot, // 50
    PowerInternalSetWakeAlarmOverride,

    PowerInternalDirectedFxAddTestDevice = 53,
    PowerInternalDirectedFxRemoveTestDevice,

    PowerInternalDirectedFxSetMode = 56,
    PowerInternalRegisterPowerPlane,
    PowerInternalSetDirectedDripsFlags,
    PowerInternalClearDirectedDripsFlags,
    PowerInternalRetrieveHiberFileResumeContext, // 60
    PowerInternalReadHiberFilePage,
    PowerInternalLastBootSucceeded, // out: BOOLEAN
    PowerInternalQuerySleepStudyHelperRoutineBlock,
    PowerInternalDirectedDripsQueryCapabilities,
    PowerInternalClearConstraints,
    PowerInternalSoftParkVelocityEnabled,
    PowerInternalQueryIntelPepCapabilities,
    PowerInternalGetSystemIdleLoopEnablement, // since WIN11
    PowerInternalGetVmPerfControlSupport,
    PowerInternalGetVmPerfControlConfig, // 70
    PowerInternalSleepDetailedDiagUpdate,
    PowerInternalProcessorClassFrequencyBandsStats,
    PowerInternalHostGlobalUserPresenceStateUpdate,
    PowerInternalCpuNodeIdleIntervalStats,
    PowerInternalClassIdleIntervalStats,
    PowerInternalCpuNodeConcurrencyStats,
    PowerInternalClassConcurrencyStats,
    PowerInternalQueryProcMeasurementCapabilities,
    PowerInternalQueryProcMeasurementValues,
    PowerInternalPrepareForSystemInitiatedReboot, // 80
    PowerInternalGetAdaptiveSessionState,
    PowerInternalSetConsoleLockedState,
    PowerInternalOverrideSystemInitiatedRebootState,
    PowerInternalFanImpactStats,
    PowerInternalFanRpmBuckets,
    PowerInternalPowerBootAppDiagInfo,
    PowerInternalUnregisterShutdownNotification, // since 22H1
    PowerInternalManageTransitionStateRecord,
    PowerInformationInternalMaximum
} POWER_INFORMATION_LEVEL_INTERNAL;

typedef enum _POWER_S0_DISCONNECTED_REASON
{
    PoS0DisconnectedReasonNone,
    PoS0DisconnectedReasonNonCompliantNic,
    PoS0DisconnectedReasonSettingPolicy,
    PoS0DisconnectedReasonEnforceDsPolicy,
    PoS0DisconnectedReasonCsChecksFailed,
    PoS0DisconnectedReasonSmartStandby,
    PoS0DisconnectedReasonMaximum
} POWER_S0_DISCONNECTED_REASON;

typedef struct _POWER_S0_LOW_POWER_IDLE_INFO
{
    POWER_S0_DISCONNECTED_REASON DisconnectedReason;
    union
    {
        BOOLEAN Storage : 1;
        BOOLEAN WiFi : 1;
        BOOLEAN Mbn : 1;
        BOOLEAN Ethernet : 1;
        BOOLEAN Reserved : 4;
        UCHAR AsUCHAR;
    } CsDeviceCompliance;
    union
    {
        BOOLEAN DisconnectInStandby : 1;
        BOOLEAN EnforceDs : 1;
        BOOLEAN Reserved : 6;
        UCHAR AsUCHAR;
    } Policy;
} POWER_S0_LOW_POWER_IDLE_INFO, *PPOWER_S0_LOW_POWER_IDLE_INFO;

typedef struct _POWER_INFORMATION_INTERNAL_HEADER
{
    POWER_INFORMATION_LEVEL_INTERNAL InternalType;
    ULONG Version;
} POWER_INFORMATION_INTERNAL_HEADER, *PPOWER_INFORMATION_INTERNAL_HEADER;

typedef struct _POWER_USER_ABSENCE_PREDICTION
{
    POWER_INFORMATION_INTERNAL_HEADER Header;
    LARGE_INTEGER ReturnTime;
} POWER_USER_ABSENCE_PREDICTION, *PPOWER_USER_ABSENCE_PREDICTION;

typedef struct _POWER_USER_ABSENCE_PREDICTION_CAPABILITY
{
    BOOLEAN AbsencePredictionCapability;
} POWER_USER_ABSENCE_PREDICTION_CAPABILITY, *PPOWER_USER_ABSENCE_PREDICTION_CAPABILITY;

typedef struct _POWER_PROCESSOR_LATENCY_HINT
{
    POWER_INFORMATION_INTERNAL_HEADER PowerInformationInternalHeader;
    ULONG Type;
} POWER_PROCESSOR_LATENCY_HINT, *PPO_PROCESSOR_LATENCY_HINT;

typedef struct _POWER_STANDBY_NETWORK_REQUEST
{
    POWER_INFORMATION_INTERNAL_HEADER PowerInformationInternalHeader;
    BOOLEAN Active;
} POWER_STANDBY_NETWORK_REQUEST, *PPOWER_STANDBY_NETWORK_REQUEST;

typedef struct _POWER_SET_BACKGROUND_TASK_STATE
{
    POWER_INFORMATION_INTERNAL_HEADER PowerInformationInternalHeader;
    BOOLEAN Engaged;
} POWER_SET_BACKGROUND_TASK_STATE, *PPOWER_SET_BACKGROUND_TASK_STATE;

typedef struct POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_INPUT
{
    POWER_INFORMATION_LEVEL_INTERNAL InternalType;
    PROCESSOR_NUMBER ProcessorNumber; // ULONG_MAX
} POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_INPUT, *PPOWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_INPUT;

typedef struct POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_OUTPUT
{
    ULONG Version;
    ULONG NominalFrequency; // if (Domain) Prcb->PowerState.CheckContext.Domain.NominalFrequency else Prcb->MHz
} POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_OUTPUT, *PPOWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_OUTPUT;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPowerInformation(
    _In_ POWER_INFORMATION_LEVEL InformationLevel,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetThreadExecutionState(
    _In_ EXECUTION_STATE NewFlags, // ES_* flags
    _Out_ EXECUTION_STATE *PreviousFlags
    );

#if (PHNT_VERSION < PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRequestWakeupLatency(
    _In_ LATENCY_TIME latency
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtInitiatePowerAction(
    _In_ POWER_ACTION SystemAction,
    _In_ SYSTEM_POWER_STATE LightestSystemState,
    _In_ ULONG Flags, // POWER_ACTION_* flags
    _In_ BOOLEAN Asynchronous
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemPowerState(
    _In_ POWER_ACTION SystemAction,
    _In_ SYSTEM_POWER_STATE LightestSystemState,
    _In_ ULONG Flags // POWER_ACTION_* flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetDevicePowerState(
    _In_ HANDLE Device,
    _Out_ PDEVICE_POWER_STATE State
    );

NTSYSCALLAPI
BOOLEAN
NTAPI
NtIsSystemResumeAutomatic(
    VOID
    );

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTREGAPI_H
#define _NTREGAPI_H

// Boot condition flags (NtInitializeRegistry)

#define REG_INIT_BOOT_SM 0x0000
#define REG_INIT_BOOT_SETUP 0x0001
#define REG_INIT_BOOT_ACCEPTED_BASE 0x0002
#define REG_INIT_BOOT_ACCEPTED_MAX REG_INIT_BOOT_ACCEPTED_BASE + 999

#define REG_MAX_KEY_VALUE_NAME_LENGTH 32767
#define REG_MAX_KEY_NAME_LENGTH 512

typedef enum _KEY_INFORMATION_CLASS
{
    KeyBasicInformation, // KEY_BASIC_INFORMATION
    KeyNodeInformation, // KEY_NODE_INFORMATION
    KeyFullInformation, // KEY_FULL_INFORMATION
    KeyNameInformation, // KEY_NAME_INFORMATION
    KeyCachedInformation, // KEY_CACHED_INFORMATION
    KeyFlagsInformation, // KEY_FLAGS_INFORMATION
    KeyVirtualizationInformation, // KEY_VIRTUALIZATION_INFORMATION
    KeyHandleTagsInformation, // KEY_HANDLE_TAGS_INFORMATION
    KeyTrustInformation, // KEY_TRUST_INFORMATION
    KeyLayerInformation, // KEY_LAYER_INFORMATION
    MaxKeyInfoClass
} KEY_INFORMATION_CLASS;

typedef struct _KEY_BASIC_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef struct _KEY_NODE_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG ClassOffset;
    ULONG ClassLength;
    ULONG NameLength;
    WCHAR Name[1];
    // ...
    // WCHAR Class[1];
} KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION;

typedef struct _KEY_FULL_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG ClassOffset;
    ULONG ClassLength;
    ULONG SubKeys;
    ULONG MaxNameLen;
    ULONG MaxClassLen;
    ULONG Values;
    ULONG MaxValueNameLen;
    ULONG MaxValueDataLen;
    WCHAR Class[1];
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

typedef struct _KEY_NAME_INFORMATION
{
    ULONG NameLength;
    WCHAR Name[1];
} KEY_NAME_INFORMATION, *PKEY_NAME_INFORMATION;

typedef struct _KEY_CACHED_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG SubKeys;
    ULONG MaxNameLen;
    ULONG Values;
    ULONG MaxValueNameLen;
    ULONG MaxValueDataLen;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_CACHED_INFORMATION, *PKEY_CACHED_INFORMATION;

// rev
#define REG_FLAG_VOLATILE 0x0001
#define REG_FLAG_LINK 0x0002

// msdn
#define REG_KEY_DONT_VIRTUALIZE 0x0002
#define REG_KEY_DONT_SILENT_FAIL 0x0004
#define REG_KEY_RECURSE_FLAG 0x0008

// private
typedef struct _KEY_FLAGS_INFORMATION
{
    ULONG Wow64Flags;
    ULONG KeyFlags; // REG_FLAG_*
    ULONG ControlFlags; // REG_KEY_*
} KEY_FLAGS_INFORMATION, *PKEY_FLAGS_INFORMATION;

typedef struct _KEY_VIRTUALIZATION_INFORMATION
{
    ULONG VirtualizationCandidate : 1; // Tells whether the key is part of the virtualization namespace scope (only HKLM\Software for now).
    ULONG VirtualizationEnabled : 1; // Tells whether virtualization is enabled on this key. Can be 1 only if above flag is 1.
    ULONG VirtualTarget : 1; // Tells if the key is a virtual key. Can be 1 only if above 2 are 0. Valid only on the virtual store key handles.
    ULONG VirtualStore : 1; // Tells if the key is a part of the virtual store path. Valid only on the virtual store key handles.
    ULONG VirtualSource : 1; // Tells if the key has ever been virtualized, can be 1 only if VirtualizationCandidate is 1.
    ULONG Reserved : 27;
} KEY_VIRTUALIZATION_INFORMATION, *PKEY_VIRTUALIZATION_INFORMATION;

// private
typedef struct _KEY_TRUST_INFORMATION
{
    ULONG TrustedKey : 1;
    ULONG Reserved : 31;
} KEY_TRUST_INFORMATION, *PKEY_TRUST_INFORMATION;

// private
typedef struct _KEY_LAYER_INFORMATION
{
    ULONG IsTombstone : 1;
    ULONG IsSupersedeLocal : 1;
    ULONG IsSupersedeTree : 1;
    ULONG ClassIsInherited : 1;
    ULONG Reserved : 28;
} KEY_LAYER_INFORMATION, *PKEY_LAYER_INFORMATION;

typedef enum _KEY_SET_INFORMATION_CLASS
{
    KeyWriteTimeInformation, // KEY_WRITE_TIME_INFORMATION
    KeyWow64FlagsInformation, // KEY_WOW64_FLAGS_INFORMATION
    KeyControlFlagsInformation, // KEY_CONTROL_FLAGS_INFORMATION
    KeySetVirtualizationInformation, // KEY_SET_VIRTUALIZATION_INFORMATION
    KeySetDebugInformation,
    KeySetHandleTagsInformation, // KEY_HANDLE_TAGS_INFORMATION
    KeySetLayerInformation, // KEY_SET_LAYER_INFORMATION
    MaxKeySetInfoClass
} KEY_SET_INFORMATION_CLASS;

typedef struct _KEY_WRITE_TIME_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
} KEY_WRITE_TIME_INFORMATION, *PKEY_WRITE_TIME_INFORMATION;

typedef struct _KEY_WOW64_FLAGS_INFORMATION
{
    ULONG UserFlags;
} KEY_WOW64_FLAGS_INFORMATION, *PKEY_WOW64_FLAGS_INFORMATION;

typedef struct _KEY_HANDLE_TAGS_INFORMATION
{
    ULONG HandleTags;
} KEY_HANDLE_TAGS_INFORMATION, *PKEY_HANDLE_TAGS_INFORMATION;

typedef struct _KEY_SET_LAYER_INFORMATION
{
    ULONG IsTombstone : 1;
    ULONG IsSupersedeLocal : 1;
    ULONG IsSupersedeTree : 1;
    ULONG ClassIsInherited : 1;
    ULONG Reserved : 28;
} KEY_SET_LAYER_INFORMATION, *PKEY_SET_LAYER_INFORMATION;

typedef struct _KEY_CONTROL_FLAGS_INFORMATION
{
    ULONG ControlFlags;
} KEY_CONTROL_FLAGS_INFORMATION, *PKEY_CONTROL_FLAGS_INFORMATION;

typedef struct _KEY_SET_VIRTUALIZATION_INFORMATION
{
    ULONG VirtualTarget : 1;
    ULONG VirtualStore : 1;
    ULONG VirtualSource : 1; // true if key has been virtualized at least once
    ULONG Reserved : 29;
} KEY_SET_VIRTUALIZATION_INFORMATION, *PKEY_SET_VIRTUALIZATION_INFORMATION;

typedef enum _KEY_VALUE_INFORMATION_CLASS
{
    KeyValueBasicInformation, // KEY_VALUE_BASIC_INFORMATION
    KeyValueFullInformation, // KEY_VALUE_FULL_INFORMATION
    KeyValuePartialInformation, // KEY_VALUE_PARTIAL_INFORMATION
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64,  // KEY_VALUE_PARTIAL_INFORMATION_ALIGN64
    KeyValueLayerInformation, // KEY_VALUE_LAYER_INFORMATION
    MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_VALUE_BASIC_INFORMATION
{
    ULONG TitleIndex;
    ULONG Type;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION
{
    ULONG TitleIndex;
    ULONG Type;
    ULONG DataOffset;
    ULONG DataLength;
    ULONG NameLength;
    WCHAR Name[1];
    // ...
    // UCHAR Data[1];
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION
{
    ULONG TitleIndex;
    ULONG Type;
    ULONG DataLength;
    UCHAR Data[1];
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64
{
    ULONG Type;
    ULONG DataLength;
    UCHAR Data[1];
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

// private
typedef struct _KEY_VALUE_LAYER_INFORMATION
{
    ULONG IsTombstone : 1;
    ULONG Reserved : 31;
} KEY_VALUE_LAYER_INFORMATION, *PKEY_VALUE_LAYER_INFORMATION;

// rev
typedef enum _KEY_LOAD_ENTRY_TYPE
{
    KeyLoadTrustClassKey = 1,
    KeyLoadEvent,
    KeyLoadToken
} KEY_LOAD_ENTRY_TYPE;

// rev
typedef struct _KEY_LOAD_ENTRY
{
    KEY_LOAD_ENTRY_TYPE EntryType;
    union
    {
        HANDLE Handle;
        ULONG_PTR Value;
    };
} KEY_LOAD_ENTRY, *PKEY_LOAD_ENTRY;

typedef struct _KEY_VALUE_ENTRY
{
    PUNICODE_STRING ValueName;
    ULONG DataLength;
    ULONG DataOffset;
    ULONG Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

typedef enum _REG_ACTION
{
    KeyAdded,
    KeyRemoved,
    KeyModified
} REG_ACTION;

typedef struct _REG_NOTIFY_INFORMATION
{
    ULONG NextEntryOffset;
    REG_ACTION Action;
    ULONG KeyLength;
    WCHAR Key[1];
} REG_NOTIFY_INFORMATION, *PREG_NOTIFY_INFORMATION;

typedef struct _KEY_PID_ARRAY
{
    HANDLE ProcessId;
    UNICODE_STRING KeyName;
} KEY_PID_ARRAY, *PKEY_PID_ARRAY;

typedef struct _KEY_OPEN_SUBKEYS_INFORMATION
{
    ULONG Count;
    KEY_PID_ARRAY KeyArray[1];
} KEY_OPEN_SUBKEYS_INFORMATION, *PKEY_OPEN_SUBKEYS_INFORMATION;

// System calls

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _Out_opt_ PULONG Disposition
    );

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _In_ HANDLE TransactionHandle,
    _Out_opt_ PULONG Disposition
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE TransactionHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyTransactedEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions,
    _In_ HANDLE TransactionHandle
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteKey(
    _In_ HANDLE KeyHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRenameKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING NewName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    _In_reads_bytes_(KeySetInformationLength) PVOID KeySetInformation,
    _In_ ULONG KeySetInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_opt_ ULONG TitleIndex,
    _In_ ULONG Type,
    _In_reads_bytes_opt_(DataSize) PVOID Data,
    _In_ ULONG DataSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryMultipleValueKey(
    _In_ HANDLE KeyHandle,
    _Inout_updates_(EntryCount) PKEY_VALUE_ENTRY ValueEntries,
    _In_ ULONG EntryCount,
    _Out_writes_bytes_(*BufferLength) PVOID ValueBuffer,
    _Inout_ PULONG BufferLength,
    _Out_opt_ PULONG RequiredBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateValueKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushKey(
    _In_ HANDLE KeyHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompactKeys(
    _In_ ULONG Count,
    _In_reads_(Count) HANDLE KeyArray[]
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompressKey(
    _In_ HANDLE Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_opt_ HANDLE TrustClassKey, // this and below were added on Win10
    _In_opt_ HANDLE Event,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _Reserved_ PVOID Reserved // previously PIO_STATUS_BLOCK
    );

// rev by tyranid
#if (PHNT_VERSION >= PHNT_20H1)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadKey3(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_reads_(LoadEntryCount) PKEY_LOAD_ENTRY LoadEntries,
    _In_ ULONG LoadEntryCount,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _Reserved_ PVOID Reserved
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplaceKey(
    _In_ POBJECT_ATTRIBUTES NewFile,
    _In_ HANDLE TargetHandle,
    _In_ POBJECT_ATTRIBUTES OldFile
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSaveKey(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSaveKeyEx(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle,
    _In_ ULONG Format
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSaveMergedKeys(
    _In_ HANDLE HighPrecedenceKeyHandle,
    _In_ HANDLE LowPrecedenceKeyHandle,
    _In_ HANDLE FileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRestoreKey(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey
    );

//
// NtUnloadKey2 Flags (from winnt.h)
//
//#define REG_FORCE_UNLOAD            1
//#define REG_UNLOAD_LEGAL_FLAGS      (REG_FORCE_UNLOAD)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_opt_ HANDLE Event
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeKey(
    _In_ HANDLE KeyHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ BOOLEAN Asynchronous
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeMultipleKeys(
    _In_ HANDLE MasterKeyHandle,
    _In_opt_ ULONG Count,
    _In_reads_opt_(Count) OBJECT_ATTRIBUTES SubordinateObjects[],
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ BOOLEAN Asynchronous
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryOpenSubKeys(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _Out_ PULONG HandleCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryOpenSubKeysEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_opt_(BufferLength) PVOID Buffer,
    _Out_ PULONG RequiredSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtInitializeRegistry(
    _In_ USHORT BootCondition
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockRegistryKey(
    _In_ HANDLE KeyHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockProductActivationKeys(
    _Inout_opt_ ULONG *pPrivateVer,
    _Out_opt_ ULONG *pSafeMode
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreezeRegistry(
    _In_ ULONG TimeOutInSeconds
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSCALLAPI
NTSTATUS
NTAPI
NtThawRegistry(
    VOID
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE)
NTSTATUS NtCreateRegistryTransaction(
    _Out_ HANDLE *RegistryTransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjAttributes,
    _Reserved_ ULONG CreateOptions
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE)
NTSTATUS NtOpenRegistryTransaction(
    _Out_ HANDLE *RegistryTransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjAttributes
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE)
NTSTATUS NtCommitRegistryTransaction(
    _In_ HANDLE RegistryTransactionHandle,
    _Reserved_ ULONG Flags
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE)
NTSTATUS NtRollbackRegistryTransaction(
    _In_ HANDLE RegistryTransactionHandle,
    _Reserved_ ULONG Flags
    );
#endif

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTRTL_H
#define _NTRTL_H

#define RtlOffsetToPointer(Base, Offset) ((PCHAR)(((PCHAR)(Base)) + ((ULONG_PTR)(Offset))))
#define RtlPointerToOffset(Base, Pointer) ((ULONG)(((PCHAR)(Pointer)) - ((PCHAR)(Base))))

// Linked lists

FORCEINLINE VOID InitializeListHead(
    _Out_ PLIST_ENTRY ListHead
    )
{
    ListHead->Flink = ListHead->Blink = ListHead;
}

_Check_return_ FORCEINLINE BOOLEAN IsListEmpty(
    _In_ PLIST_ENTRY ListHead
    )
{
    return ListHead->Flink == ListHead;
}

FORCEINLINE BOOLEAN RemoveEntryList(
    _In_ PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Flink;

    Flink = Entry->Flink;
    Blink = Entry->Blink;
    Blink->Flink = Flink;
    Flink->Blink = Blink;

    return Flink == Blink;
}

FORCEINLINE PLIST_ENTRY RemoveHeadList(
    _Inout_ PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Flink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Flink;
    Flink = Entry->Flink;
    ListHead->Flink = Flink;
    Flink->Blink = ListHead;

    return Entry;
}

FORCEINLINE PLIST_ENTRY RemoveTailList(
    _Inout_ PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Blink;
    Blink = Entry->Blink;
    ListHead->Blink = Blink;
    Blink->Flink = ListHead;

    return Entry;
}

FORCEINLINE VOID InsertTailList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;

    Blink = ListHead->Blink;
    Entry->Flink = ListHead;
    Entry->Blink = Blink;
    Blink->Flink = Entry;
    ListHead->Blink = Entry;
}

FORCEINLINE VOID InsertHeadList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Flink;

    Flink = ListHead->Flink;
    Entry->Flink = Flink;
    Entry->Blink = ListHead;
    Flink->Blink = Entry;
    ListHead->Flink = Entry;
}

FORCEINLINE VOID AppendTailList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ PLIST_ENTRY ListToAppend
    )
{
    PLIST_ENTRY ListEnd = ListHead->Blink;

    ListHead->Blink->Flink = ListToAppend;
    ListHead->Blink = ListToAppend->Blink;
    ListToAppend->Blink->Flink = ListHead;
    ListToAppend->Blink = ListEnd;
}

FORCEINLINE PSINGLE_LIST_ENTRY PopEntryList(
    _Inout_ PSINGLE_LIST_ENTRY ListHead
    )
{
    PSINGLE_LIST_ENTRY FirstEntry;

    FirstEntry = ListHead->Next;

    if (FirstEntry)
        ListHead->Next = FirstEntry->Next;

    return FirstEntry;
}

FORCEINLINE VOID PushEntryList(
    _Inout_ PSINGLE_LIST_ENTRY ListHead,
    _Inout_ PSINGLE_LIST_ENTRY Entry
    )
{
    Entry->Next = ListHead->Next;
    ListHead->Next = Entry;
}

// AVL and splay trees

typedef enum _TABLE_SEARCH_RESULT
{
    TableEmptyTree,
    TableFoundNode,
    TableInsertAsLeft,
    TableInsertAsRight
} TABLE_SEARCH_RESULT;

typedef enum _RTL_GENERIC_COMPARE_RESULTS
{
    GenericLessThan,
    GenericGreaterThan,
    GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;

typedef RTL_GENERIC_COMPARE_RESULTS (NTAPI *PRTL_AVL_COMPARE_ROUTINE)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ PVOID FirstStruct,
    _In_ PVOID SecondStruct
    );

typedef PVOID (NTAPI *PRTL_AVL_ALLOCATE_ROUTINE)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ CLONG ByteSize
    );

typedef VOID (NTAPI *PRTL_AVL_FREE_ROUTINE)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ _Post_invalid_ PVOID Buffer
    );

typedef NTSTATUS (NTAPI *PRTL_AVL_MATCH_FUNCTION)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ PVOID UserData,
    _In_ PVOID MatchData
    );

typedef struct _RTL_BALANCED_LINKS
{
    struct _RTL_BALANCED_LINKS *Parent;
    struct _RTL_BALANCED_LINKS *LeftChild;
    struct _RTL_BALANCED_LINKS *RightChild;
    CHAR Balance;
    UCHAR Reserved[3];
} RTL_BALANCED_LINKS, *PRTL_BALANCED_LINKS;

typedef struct _RTL_AVL_TABLE
{
    RTL_BALANCED_LINKS BalancedRoot;
    PVOID OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    ULONG DepthOfTree;
    PRTL_BALANCED_LINKS RestartKey;
    ULONG DeleteCount;
    PRTL_AVL_COMPARE_ROUTINE CompareRoutine;
    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_AVL_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_AVL_TABLE, *PRTL_AVL_TABLE;

NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTableAvl(
    _Out_ PRTL_AVL_TABLE Table,
    _In_ PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
    _In_ PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
    _In_ PRTL_AVL_FREE_ROUTINE FreeRoutine,
    _In_opt_ PVOID TableContext
    );

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement
    );

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableFullAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement,
    _In_ PVOID NodeOrParent,
    _In_ TABLE_SEARCH_RESULT SearchResult
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlDeleteElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer
    );

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableFullAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *NodeOrParent,
    _Out_ TABLE_SEARCH_RESULT *SearchResult
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ BOOLEAN Restart
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplayingAvl(
    _In_ PRTL_AVL_TABLE Table,
    _Inout_ PVOID *RestartKey
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlLookupFirstMatchingElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *RestartKey
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableLikeADirectory(
    _In_ PRTL_AVL_TABLE Table,
    _In_opt_ PRTL_AVL_MATCH_FUNCTION MatchFunction,
    _In_opt_ PVOID MatchData,
    _In_ ULONG NextFlag,
    _Inout_ PVOID *RestartKey,
    _Inout_ PULONG DeleteCount,
    _In_ PVOID Buffer
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlGetElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ ULONG I
    );

NTSYSAPI
ULONG
NTAPI
RtlNumberGenericTableElementsAvl(
    _In_ PRTL_AVL_TABLE Table
    );

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmptyAvl(
    _In_ PRTL_AVL_TABLE Table
    );

typedef struct _RTL_SPLAY_LINKS
{
    struct _RTL_SPLAY_LINKS *Parent;
    struct _RTL_SPLAY_LINKS *LeftChild;
    struct _RTL_SPLAY_LINKS *RightChild;
} RTL_SPLAY_LINKS, *PRTL_SPLAY_LINKS;

#define RtlInitializeSplayLinks(Links) \
{ \
    PRTL_SPLAY_LINKS _SplayLinks; \
    _SplayLinks = (PRTL_SPLAY_LINKS)(Links); \
    _SplayLinks->Parent = _SplayLinks; \
    _SplayLinks->LeftChild = NULL; \
    _SplayLinks->RightChild = NULL; \
}

#define RtlParent(Links) ((PRTL_SPLAY_LINKS)(Links)->Parent)
#define RtlLeftChild(Links) ((PRTL_SPLAY_LINKS)(Links)->LeftChild)
#define RtlRightChild(Links) ((PRTL_SPLAY_LINKS)(Links)->RightChild)
#define RtlIsRoot(Links) ((RtlParent(Links) == (PRTL_SPLAY_LINKS)(Links)))
#define RtlIsLeftChild(Links) ((RtlLeftChild(RtlParent(Links)) == (PRTL_SPLAY_LINKS)(Links)))
#define RtlIsRightChild(Links) ((RtlRightChild(RtlParent(Links)) == (PRTL_SPLAY_LINKS)(Links)))

#define RtlInsertAsLeftChild(ParentLinks, ChildLinks) \
{ \
    PRTL_SPLAY_LINKS _SplayParent; \
    PRTL_SPLAY_LINKS _SplayChild; \
    _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks); \
    _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks); \
    _SplayParent->LeftChild = _SplayChild; \
    _SplayChild->Parent = _SplayParent; \
}

#define RtlInsertAsRightChild(ParentLinks, ChildLinks) \
{ \
    PRTL_SPLAY_LINKS _SplayParent; \
    PRTL_SPLAY_LINKS _SplayChild; \
    _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks); \
    _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks); \
    _SplayParent->RightChild = _SplayChild; \
    _SplayChild->Parent = _SplayParent; \
}

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSplay(
    _Inout_ PRTL_SPLAY_LINKS Links
    );

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlDelete(
    _In_ PRTL_SPLAY_LINKS Links
    );

NTSYSAPI
VOID
NTAPI
RtlDeleteNoSplay(
    _In_ PRTL_SPLAY_LINKS Links,
    _Inout_ PRTL_SPLAY_LINKS *Root
    );

_Check_return_
NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSubtreeSuccessor(
    _In_ PRTL_SPLAY_LINKS Links
    );

_Check_return_
NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSubtreePredecessor(
    _In_ PRTL_SPLAY_LINKS Links
    );

_Check_return_
NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlRealSuccessor(
    _In_ PRTL_SPLAY_LINKS Links
    );

_Check_return_
NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlRealPredecessor(
    _In_ PRTL_SPLAY_LINKS Links
    );

struct _RTL_GENERIC_TABLE;

typedef RTL_GENERIC_COMPARE_RESULTS (NTAPI *PRTL_GENERIC_COMPARE_ROUTINE)(
    _In_ struct _RTL_GENERIC_TABLE *Table,
    _In_ PVOID FirstStruct,
    _In_ PVOID SecondStruct
    );

typedef PVOID (NTAPI *PRTL_GENERIC_ALLOCATE_ROUTINE)(
    _In_ struct _RTL_GENERIC_TABLE *Table,
    _In_ CLONG ByteSize
    );

typedef VOID (NTAPI *PRTL_GENERIC_FREE_ROUTINE)(
    _In_ struct _RTL_GENERIC_TABLE *Table,
    _In_ _Post_invalid_ PVOID Buffer
    );

typedef struct _RTL_GENERIC_TABLE
{
    PRTL_SPLAY_LINKS TableRoot;
    LIST_ENTRY InsertOrderList;
    PLIST_ENTRY OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine;
    PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_GENERIC_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_GENERIC_TABLE, *PRTL_GENERIC_TABLE;

NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTable(
    _Out_ PRTL_GENERIC_TABLE Table,
    _In_ PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,
    _In_ PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,
    _In_ PRTL_GENERIC_FREE_ROUTINE FreeRoutine,
    _In_opt_ PVOID TableContext
    );

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTable(
    _In_ PRTL_GENERIC_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement
    );

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableFull(
    _In_ PRTL_GENERIC_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement,
    _In_ PVOID NodeOrParent,
    _In_ TABLE_SEARCH_RESULT SearchResult
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlDeleteElementGenericTable(
    _In_ PRTL_GENERIC_TABLE Table,
    _In_ PVOID Buffer
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTable(
    _In_ PRTL_GENERIC_TABLE Table,
    _In_ PVOID Buffer
    );

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableFull(
    _In_ PRTL_GENERIC_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *NodeOrParent,
    _Out_ TABLE_SEARCH_RESULT *SearchResult
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTable(
    _In_ PRTL_GENERIC_TABLE Table,
    _In_ BOOLEAN Restart
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplaying(
    _In_ PRTL_GENERIC_TABLE Table,
    _Inout_ PVOID *RestartKey
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlGetElementGenericTable(
    _In_ PRTL_GENERIC_TABLE Table,
    _In_ ULONG I
    );

NTSYSAPI
ULONG
NTAPI
RtlNumberGenericTableElements(
    _In_ PRTL_GENERIC_TABLE Table
    );

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmpty(
    _In_ PRTL_GENERIC_TABLE Table
    );

// RB trees

typedef struct _RTL_RB_TREE
{
    PRTL_BALANCED_NODE Root;
    PRTL_BALANCED_NODE Min;
} RTL_RB_TREE, *PRTL_RB_TREE;

#if (PHNT_VERSION >= PHNT_WIN8)

// rev
NTSYSAPI
VOID
NTAPI
RtlRbInsertNodeEx(
    _In_ PRTL_RB_TREE Tree,
    _In_opt_ PRTL_BALANCED_NODE Parent,
    _In_ BOOLEAN Right,
    _Out_ PRTL_BALANCED_NODE Node
    );

// rev
NTSYSAPI
VOID
NTAPI
RtlRbRemoveNode(
    _In_ PRTL_RB_TREE Tree,
    _In_ PRTL_BALANCED_NODE Node
    );

#endif

// Hash tables

// begin_ntddk

#define RTL_HASH_ALLOCATED_HEADER 0x00000001
#define RTL_HASH_RESERVED_SIGNATURE 0

typedef struct _RTL_DYNAMIC_HASH_TABLE_ENTRY
{
    LIST_ENTRY Linkage;
    ULONG_PTR Signature;
} RTL_DYNAMIC_HASH_TABLE_ENTRY, *PRTL_DYNAMIC_HASH_TABLE_ENTRY;

#define HASH_ENTRY_KEY(x) ((x)->Signature)

typedef struct _RTL_DYNAMIC_HASH_TABLE_CONTEXT
{
    PLIST_ENTRY ChainHead;
    PLIST_ENTRY PrevLinkage;
    ULONG_PTR Signature;
} RTL_DYNAMIC_HASH_TABLE_CONTEXT, *PRTL_DYNAMIC_HASH_TABLE_CONTEXT;

typedef struct _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR
{
    RTL_DYNAMIC_HASH_TABLE_ENTRY HashEntry;
    PLIST_ENTRY ChainHead;
    ULONG BucketIndex;
} RTL_DYNAMIC_HASH_TABLE_ENUMERATOR, *PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR;

typedef struct _RTL_DYNAMIC_HASH_TABLE
{
    // Entries initialized at creation.
    ULONG Flags;
    ULONG Shift;

    // Entries used in bucket computation.
    ULONG TableSize;
    ULONG Pivot;
    ULONG DivisorMask;

    // Counters.
    ULONG NumEntries;
    ULONG NonEmptyBuckets;
    ULONG NumEnumerators;

    // The directory. This field is for internal use only.
    PVOID Directory;
} RTL_DYNAMIC_HASH_TABLE, *PRTL_DYNAMIC_HASH_TABLE;

#if (PHNT_VERSION >= PHNT_WIN7)

FORCEINLINE
VOID
RtlInitHashTableContext(
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context
    )
{
    Context->ChainHead = NULL;
    Context->PrevLinkage = NULL;
}

FORCEINLINE
VOID
RtlInitHashTableContextFromEnumerator(
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context,
    _In_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    )
{
    Context->ChainHead = Enumerator->ChainHead;
    Context->PrevLinkage = Enumerator->HashEntry.Linkage.Blink;
}

FORCEINLINE
VOID
RtlReleaseHashTableContext(
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context
    )
{
    UNREFERENCED_PARAMETER(Context);
    return;
}

FORCEINLINE
ULONG
RtlTotalBucketsHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    )
{
    return HashTable->TableSize;
}

FORCEINLINE
ULONG
RtlNonEmptyBucketsHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    )
{
    return HashTable->NonEmptyBuckets;
}

FORCEINLINE
ULONG
RtlEmptyBucketsHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    )
{
    return HashTable->TableSize - HashTable->NonEmptyBuckets;
}

FORCEINLINE
ULONG
RtlTotalEntriesHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    )
{
    return HashTable->NumEntries;
}

FORCEINLINE
ULONG
RtlActiveEnumeratorsHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    )
{
    return HashTable->NumEnumerators;
}

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlCreateHashTable(
    _Inout_ _When_(*HashTable == NULL, __drv_allocatesMem(Mem)) PRTL_DYNAMIC_HASH_TABLE *HashTable,
    _In_ ULONG Shift,
    _In_ _Reserved_ ULONG Flags
    );

NTSYSAPI
VOID
NTAPI
RtlDeleteHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlInsertEntryHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _In_ PRTL_DYNAMIC_HASH_TABLE_ENTRY Entry,
    _In_ ULONG_PTR Signature,
    _Inout_opt_ PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlRemoveEntryHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _In_ PRTL_DYNAMIC_HASH_TABLE_ENTRY Entry,
    _Inout_opt_ PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context
    );

_Must_inspect_result_
NTSYSAPI
PRTL_DYNAMIC_HASH_TABLE_ENTRY
NTAPI
RtlLookupEntryHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _In_ ULONG_PTR Signature,
    _Out_opt_ PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context
    );

_Must_inspect_result_
NTSYSAPI
PRTL_DYNAMIC_HASH_TABLE_ENTRY
NTAPI
RtlGetNextEntryHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _In_ PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlInitEnumerationHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Out_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

_Must_inspect_result_
NTSYSAPI
PRTL_DYNAMIC_HASH_TABLE_ENTRY
NTAPI
RtlEnumerateEntryHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

NTSYSAPI
VOID
NTAPI
RtlEndEnumerationHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlInitWeakEnumerationHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Out_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

_Must_inspect_result_
NTSYSAPI
PRTL_DYNAMIC_HASH_TABLE_ENTRY
NTAPI
RtlWeaklyEnumerateEntryHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

NTSYSAPI
VOID
NTAPI
RtlEndWeakEnumerationHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlExpandHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlContractHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    );

#endif

#if (PHNT_VERSION >= PHNT_THRESHOLD)

NTSYSAPI
BOOLEAN
NTAPI
RtlInitStrongEnumerationHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Out_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

_Must_inspect_result_
NTSYSAPI
PRTL_DYNAMIC_HASH_TABLE_ENTRY
NTAPI
RtlStronglyEnumerateEntryHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

NTSYSAPI
VOID
NTAPI
RtlEndStrongEnumerationHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

#endif

// end_ntddk

// Critical sections

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSection(
    _Out_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSectionAndSpinCount(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteCriticalSection(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlEnterCriticalSection(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlLeaveCriticalSection(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
LOGICAL
NTAPI
RtlTryEnterCriticalSection(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLocked(
    _In_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLockedByThread(
    _In_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
ULONG
NTAPI
RtlGetCriticalSectionRecursionCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
ULONG
NTAPI
RtlSetCriticalSectionSpinCount(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
HANDLE
NTAPI
RtlQueryCriticalSectionOwner(
    _In_ HANDLE EventHandle
    );
#endif

NTSYSAPI
VOID
NTAPI
RtlCheckForOrphanedCriticalSections(
    _In_ HANDLE ThreadHandle
    );

// Resources

typedef struct _RTL_RESOURCE
{
    RTL_CRITICAL_SECTION CriticalSection;

    HANDLE SharedSemaphore;
    volatile ULONG NumberOfWaitingShared;
    HANDLE ExclusiveSemaphore;
    volatile ULONG NumberOfWaitingExclusive;

    volatile LONG NumberOfActive; // negative: exclusive acquire; zero: not acquired; positive: shared acquire(s)
    HANDLE ExclusiveOwnerThread;

    ULONG Flags; // RTL_RESOURCE_FLAG_*

    PRTL_RESOURCE_DEBUG DebugInfo;
} RTL_RESOURCE, *PRTL_RESOURCE;

#define RTL_RESOURCE_FLAG_LONG_TERM ((ULONG)0x00000001)

NTSYSAPI
VOID
NTAPI
RtlInitializeResource(
    _Out_ PRTL_RESOURCE Resource
    );

NTSYSAPI
VOID
NTAPI
RtlDeleteResource(
    _Inout_ PRTL_RESOURCE Resource
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlAcquireResourceShared(
    _Inout_ PRTL_RESOURCE Resource,
    _In_ BOOLEAN Wait
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlAcquireResourceExclusive(
    _Inout_ PRTL_RESOURCE Resource,
    _In_ BOOLEAN Wait
    );

NTSYSAPI
VOID
NTAPI
RtlReleaseResource(
    _Inout_ PRTL_RESOURCE Resource
    );

NTSYSAPI
VOID
NTAPI
RtlConvertSharedToExclusive(
    _Inout_ PRTL_RESOURCE Resource
    );

NTSYSAPI
VOID
NTAPI
RtlConvertExclusiveToShared(
    _Inout_ PRTL_RESOURCE Resource
    );

// Slim reader-writer locks, condition variables, and barriers

#if (PHNT_VERSION >= PHNT_VISTA)

// winbase:InitializeSRWLock
NTSYSAPI
VOID
NTAPI
RtlInitializeSRWLock(
    _Out_ PRTL_SRWLOCK SRWLock
    );

// winbase:AcquireSRWLockExclusive
NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock
    );

// winbase:AcquireSRWLockShared
NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock
    );

// winbase:ReleaseSRWLockExclusive
NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock
    );

// winbase:ReleaseSRWLockShared
NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock
    );

// winbase:TryAcquireSRWLockExclusive
NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock
    );

// winbase:TryAcquireSRWLockShared
NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
VOID
NTAPI
RtlAcquireReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock
    );
#endif

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// winbase:InitializeConditionVariable
NTSYSAPI
VOID
NTAPI
RtlInitializeConditionVariable(
    _Out_ PRTL_CONDITION_VARIABLE ConditionVariable
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSleepConditionVariableCS(
    _Inout_ PRTL_CONDITION_VARIABLE ConditionVariable,
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_opt_ PLARGE_INTEGER Timeout
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSleepConditionVariableSRW(
    _Inout_ PRTL_CONDITION_VARIABLE ConditionVariable,
    _Inout_ PRTL_SRWLOCK SRWLock,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_ ULONG Flags
    );

// winbase:WakeConditionVariable
NTSYSAPI
VOID
NTAPI
RtlWakeConditionVariable(
    _Inout_ PRTL_CONDITION_VARIABLE ConditionVariable
    );

// winbase:WakeAllConditionVariable
NTSYSAPI
VOID
NTAPI
RtlWakeAllConditionVariable(
    _Inout_ PRTL_CONDITION_VARIABLE ConditionVariable
    );

#endif

// begin_rev
#define RTL_BARRIER_FLAGS_SPIN_ONLY 0x00000001 // never block on event - always spin
#define RTL_BARRIER_FLAGS_BLOCK_ONLY 0x00000002 // always block on event - never spin
#define RTL_BARRIER_FLAGS_NO_DELETE 0x00000004 // use if barrier will never be deleted
// end_rev

// begin_private

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
NTSTATUS
NTAPI
RtlInitBarrier(
    _Out_ PRTL_BARRIER Barrier,
    _In_ ULONG TotalThreads,
    _In_ ULONG SpinCount
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteBarrier(
    _In_ PRTL_BARRIER Barrier
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlBarrier(
    _Inout_ PRTL_BARRIER Barrier,
    _In_ ULONG Flags
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlBarrierForDelete(
    _Inout_ PRTL_BARRIER Barrier,
    _In_ ULONG Flags
    );

#endif

// end_private

// Wait on address

// begin_rev

#if (PHNT_VERSION >= PHNT_WIN8)

NTSYSAPI
NTSTATUS
NTAPI
RtlWaitOnAddress(
    _In_ volatile VOID *Address,
    _In_ PVOID CompareAddress,
    _In_ SIZE_T AddressSize,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSAPI
VOID
NTAPI
RtlWakeAddressAll(
    _In_ PVOID Address
    );

NTSYSAPI
VOID
NTAPI
RtlWakeAddressSingle(
    _In_ PVOID Address
    );

#endif

// end_rev

// Strings

FORCEINLINE
VOID
NTAPI
RtlInitEmptyAnsiString(
    _Out_ PANSI_STRING AnsiString,
    _Pre_maybenull_ _Pre_readable_size_(MaximumLength) PCHAR Buffer,
    _In_ USHORT MaximumLength
    )
{
    memset(AnsiString, 0, sizeof(ANSI_STRING));
    AnsiString->MaximumLength = MaximumLength;
    AnsiString->Buffer = Buffer;
}

#ifndef PHNT_NO_INLINE_INIT_STRING
FORCEINLINE VOID RtlInitString(
    _Out_ PSTRING DestinationString,
    _In_opt_ PCSTR SourceString
    )
{
    if (SourceString)
        DestinationString->MaximumLength = (DestinationString->Length = (USHORT)strlen(SourceString)) + sizeof(ANSI_NULL);
    else
        DestinationString->MaximumLength = DestinationString->Length = 0;

    DestinationString->Buffer = (PCHAR)SourceString;
}
#else
NTSYSAPI
VOID
NTAPI
RtlInitString(
    _Out_ PSTRING DestinationString,
    _In_opt_ PCSTR SourceString
    );
#endif

#if (PHNT_VERSION >= PHNT_THRESHOLD)
NTSYSAPI
NTSTATUS
NTAPI
RtlInitStringEx(
    _Out_ PSTRING DestinationString,
    _In_opt_z_ PCSZ SourceString
    );
#endif

#ifndef PHNT_NO_INLINE_INIT_STRING
FORCEINLINE VOID RtlInitAnsiString(
    _Out_ PANSI_STRING DestinationString,
    _In_opt_ PCSTR SourceString
    )
{
    if (SourceString)
        DestinationString->MaximumLength = (DestinationString->Length = (USHORT)strlen(SourceString)) + sizeof(ANSI_NULL);
    else
        DestinationString->MaximumLength = DestinationString->Length = 0;

    DestinationString->Buffer = (PCHAR)SourceString;
}
#else
NTSYSAPI
VOID
NTAPI
RtlInitAnsiString(
    _Out_ PANSI_STRING DestinationString,
    _In_opt_ PCSTR SourceString
    );
#endif

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSAPI
NTSTATUS
NTAPI
RtlInitAnsiStringEx(
    _Out_ PANSI_STRING DestinationString,
    _In_opt_z_ PCSZ SourceString
    );
#endif

NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString(
    _Inout_ _At_(AnsiString->Buffer, _Frees_ptr_opt_) PANSI_STRING AnsiString
    );

#if (PHNT_VERSION >= PHNT_20H1)
NTSYSAPI
VOID
NTAPI
RtlInitUTF8String(
    _Out_ PUTF8_STRING DestinationString,
    _In_opt_z_ PCSZ SourceString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlInitUTF8StringEx(
    _Out_ PUTF8_STRING DestinationString,
    _In_opt_z_ PCSZ SourceString
    );

NTSYSAPI
VOID
NTAPI
RtlFreeUTF8String(
    _Inout_ _At_(utf8String->Buffer, _Frees_ptr_opt_) PUTF8_STRING Utf8String
    );
#endif

NTSYSAPI
VOID
NTAPI
RtlFreeOemString(
    _Inout_ POEM_STRING OemString
    );

NTSYSAPI
VOID
NTAPI
RtlCopyString(
    _In_ PSTRING DestinationString,
    _In_opt_ PSTRING SourceString
    );

NTSYSAPI
CHAR
NTAPI
RtlUpperChar(
    _In_ CHAR Character
    );

_Must_inspect_result_
NTSYSAPI
LONG
NTAPI
RtlCompareString(
    _In_ PSTRING String1,
    _In_ PSTRING String2,
    _In_ BOOLEAN CaseInSensitive
    );

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlEqualString(
    _In_ PSTRING String1,
    _In_ PSTRING String2,
    _In_ BOOLEAN CaseInSensitive
    );

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixString(
    _In_ PSTRING String1,
    _In_ PSTRING String2,
    _In_ BOOLEAN CaseInSensitive
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendStringToString(
    _Inout_ PSTRING Destination,
    _In_ PSTRING Source
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendAsciizToString(
    _In_ PSTRING Destination,
    _In_opt_ PCSTR Source
    );

NTSYSAPI
VOID
NTAPI
RtlUpperString(
    _Inout_ PSTRING DestinationString,
    _In_ const STRING* SourceString
    );

FORCEINLINE
BOOLEAN
RtlIsNullOrEmptyUnicodeString(
    _In_opt_ PUNICODE_STRING String
    )
{
    return !String || String->Length == 0;
}

FORCEINLINE
VOID
NTAPI
RtlInitEmptyUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _Writable_bytes_(MaximumLength) _When_(MaximumLength != 0, _Notnull_) PWCHAR Buffer,
    _In_ USHORT MaximumLength
    )
{
    memset(DestinationString, 0, sizeof(UNICODE_STRING));
    DestinationString->MaximumLength = MaximumLength;
    DestinationString->Buffer = Buffer;
}

#ifndef PHNT_NO_INLINE_INIT_STRING
FORCEINLINE VOID RtlInitUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_ PCWSTR SourceString
    )
{
    if (SourceString)
        DestinationString->MaximumLength = (DestinationString->Length = (USHORT)(wcslen(SourceString) * sizeof(WCHAR))) + sizeof(UNICODE_NULL);
    else
        DestinationString->MaximumLength = DestinationString->Length = 0;

    DestinationString->Buffer = (PWCH)SourceString;
}
#else
NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_z_ PCWSTR SourceString
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlInitUnicodeStringEx(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_z_ PCWSTR SourceString
    );

_Success_(return != 0)
_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_z_ PCWSTR SourceString
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeStringFromAsciiz(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PCSTR SourceString
    );

#ifdef PHNT_INLINE_FREE_UNICODE_STRING
FORCEINLINE
VOID
NTAPI
RtlFreeUnicodeString(
    _Inout_ _At_(UnicodeString->Buffer, _Frees_ptr_opt_) PUNICODE_STRING UnicodeString
    )
{
    HeapFree(NtCurrentPeb()->ProcessHeap, 0, UnicodeString->Buffer);
}
#else
NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
    _Inout_ _At_(UnicodeString->Buffer, _Frees_ptr_opt_) PUNICODE_STRING UnicodeString
    );
#endif

#define RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE (0x00000001)
#define RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING (0x00000002)

NTSYSAPI
NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
    _In_ ULONG Flags,
    _In_ PUNICODE_STRING StringIn,
    _Out_ PUNICODE_STRING StringOut
    );

NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    _In_ PUNICODE_STRING DestinationString,
    _In_opt_ PCUNICODE_STRING SourceString
    );

NTSYSAPI
WCHAR
NTAPI
RtlUpcaseUnicodeChar(
    _In_ WCHAR SourceCharacter
    );

NTSYSAPI
WCHAR
NTAPI
RtlDowncaseUnicodeChar(
    _In_ WCHAR SourceCharacter
    );

_Must_inspect_result_
NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString(
    _In_ PUNICODE_STRING String1,
    _In_ PUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive
    );

#if (PHNT_VERSION >= PHNT_VISTA)
_Must_inspect_result_
NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeStrings(
    _In_reads_(String1Length) PCWCH String1,
    _In_ SIZE_T String1Length,
    _In_reads_(String2Length) PCWCH String2,
    _In_ SIZE_T String2Length,
    _In_ BOOLEAN CaseInSensitive
    );
#endif

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    _In_ PUNICODE_STRING String1,
    _In_ PUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive
    );

#define HASH_STRING_ALGORITHM_DEFAULT 0
#define HASH_STRING_ALGORITHM_X65599 1
#define HASH_STRING_ALGORITHM_INVALID 0xffffffff

NTSYSAPI
NTSTATUS
NTAPI
RtlHashUnicodeString(
    _In_ PUNICODE_STRING String,
    _In_ BOOLEAN CaseInSensitive,
    _In_ ULONG HashAlgorithm,
    _Out_ PULONG HashValue
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlValidateUnicodeString(
    _In_ ULONG Flags,
    _In_ PUNICODE_STRING String
    );

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString(
    _In_ PUNICODE_STRING String1,
    _In_ PUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive
    );

#if (PHNT_MODE == PHNT_MODE_KERNEL && PHNT_VERSION >= PHNT_THRESHOLD)
_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlSuffixUnicodeString(
    _In_ PUNICODE_STRING String1,
    _In_ PUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive
    );
#endif

#if (PHNT_VERSION >= PHNT_THRESHOLD)
_Must_inspect_result_
NTSYSAPI
PWCHAR
NTAPI
RtlFindUnicodeSubstring(
    _In_ PUNICODE_STRING FullString,
    _In_ PUNICODE_STRING SearchString,
    _In_ BOOLEAN CaseInSensitive
    );
#endif

#define RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END 0x00000001
#define RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET 0x00000002
#define RTL_FIND_CHAR_IN_UNICODE_STRING_CASE_INSENSITIVE 0x00000004

NTSYSAPI
NTSTATUS
NTAPI
RtlFindCharInUnicodeString(
    _In_ ULONG Flags,
    _In_ PUNICODE_STRING StringToSearch,
    _In_ PUNICODE_STRING CharSet,
    _Out_ PUSHORT NonInclusivePrefixLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString(
    _In_ PUNICODE_STRING Destination,
    _In_ PCUNICODE_STRING Source
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString(
    _In_ PUNICODE_STRING Destination,
    _In_opt_ PCWSTR Source
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDowncaseUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
VOID
NTAPI
RtlEraseUnicodeString(
    _Inout_ PUNICODE_STRING String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PANSI_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    _Inout_ PANSI_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

#if (PHNT_VERSION >= PHNT_20H1)
NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToUTF8String(
    _Inout_ PUTF8_STRING DestinationString,
    _In_ PCUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUTF8StringToUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PUTF8_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );
#endif

NTSYSAPI
WCHAR
NTAPI
RtlAnsiCharToUnicodeChar(
    _Inout_ PUCHAR *SourceCharacter
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToAnsiString(
    _Inout_ PANSI_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlOemStringToUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ POEM_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToOemString(
    _Inout_ POEM_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToOemString(
    _Inout_ POEM_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlOemStringToCountedUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PCOEM_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToCountedOemString(
    _Inout_ POEM_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToCountedOemString(
    _Inout_ POEM_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlMultiByteToUnicodeN(
    _Out_writes_bytes_to_(MaxBytesInUnicodeString, *BytesInUnicodeString) PWCH UnicodeString,
    _In_ ULONG MaxBytesInUnicodeString,
    _Out_opt_ PULONG BytesInUnicodeString,
    _In_reads_bytes_(BytesInMultiByteString) PCSTR MultiByteString,
    _In_ ULONG BytesInMultiByteString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlMultiByteToUnicodeSize(
    _Out_ PULONG BytesInUnicodeString,
    _In_reads_bytes_(BytesInMultiByteString) PCSTR MultiByteString,
    _In_ ULONG BytesInMultiByteString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToMultiByteN(
    _Out_writes_bytes_to_(MaxBytesInMultiByteString, *BytesInMultiByteString) PCHAR MultiByteString,
    _In_ ULONG MaxBytesInMultiByteString,
    _Out_opt_ PULONG BytesInMultiByteString,
    _In_reads_bytes_(BytesInUnicodeString) PCWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToMultiByteSize(
    _Out_ PULONG BytesInMultiByteString,
    _In_reads_bytes_(BytesInUnicodeString) PCWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeToMultiByteN(
    _Out_writes_bytes_to_(MaxBytesInMultiByteString, *BytesInMultiByteString) PCHAR MultiByteString,
    _In_ ULONG MaxBytesInMultiByteString,
    _Out_opt_ PULONG BytesInMultiByteString,
    _In_reads_bytes_(BytesInUnicodeString) PCWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlOemToUnicodeN(
    _Out_writes_bytes_to_(MaxBytesInUnicodeString, *BytesInUnicodeString) PWSTR UnicodeString,
    _In_ ULONG MaxBytesInUnicodeString,
    _Out_opt_ PULONG BytesInUnicodeString,
    _In_reads_bytes_(BytesInOemString) PCCH OemString,
    _In_ ULONG BytesInOemString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToOemN(
    _Out_writes_bytes_to_(MaxBytesInOemString, *BytesInOemString) PCHAR OemString,
    _In_ ULONG MaxBytesInOemString,
    _Out_opt_ PULONG BytesInOemString,
    _In_reads_bytes_(BytesInUnicodeString) PCWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeToOemN(
    _Out_writes_bytes_to_(MaxBytesInOemString, *BytesInOemString) PCHAR OemString,
    _In_ ULONG MaxBytesInOemString,
    _Out_opt_ PULONG BytesInOemString,
    _In_reads_bytes_(BytesInUnicodeString) PCWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlConsoleMultiByteToUnicodeN(
    _Out_writes_bytes_to_(MaxBytesInUnicodeString, *BytesInUnicodeString) PWCH UnicodeString,
    _In_ ULONG MaxBytesInUnicodeString,
    _Out_opt_ PULONG BytesInUnicodeString,
    _In_reads_bytes_(BytesInMultiByteString) PCCH MultiByteString,
    _In_ ULONG BytesInMultiByteString,
    _Out_ PULONG pdwSpecialChar
    );

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSAPI
NTSTATUS
NTAPI
RtlUTF8ToUnicodeN(
    _Out_writes_bytes_to_(UnicodeStringMaxByteCount, *UnicodeStringActualByteCount) PWSTR UnicodeStringDestination,
    _In_ ULONG UnicodeStringMaxByteCount,
    _Out_ PULONG UnicodeStringActualByteCount,
    _In_reads_bytes_(UTF8StringByteCount) PCCH UTF8StringSource,
    _In_ ULONG UTF8StringByteCount
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToUTF8N(
    _Out_writes_bytes_to_(UTF8StringMaxByteCount, *UTF8StringActualByteCount) PCHAR UTF8StringDestination,
    _In_ ULONG UTF8StringMaxByteCount,
    _Out_ PULONG UTF8StringActualByteCount,
    _In_reads_bytes_(UnicodeStringByteCount) PCWCH UnicodeStringSource,
    _In_ ULONG UnicodeStringByteCount
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlCustomCPToUnicodeN(
    _In_ PCPTABLEINFO CustomCP,
    _Out_writes_bytes_to_(MaxBytesInUnicodeString, *BytesInUnicodeString) PWCH UnicodeString,
    _In_ ULONG MaxBytesInUnicodeString,
    _Out_opt_ PULONG BytesInUnicodeString,
    _In_reads_bytes_(BytesInCustomCPString) PCH CustomCPString,
    _In_ ULONG BytesInCustomCPString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToCustomCPN(
    _In_ PCPTABLEINFO CustomCP,
    _Out_writes_bytes_to_(MaxBytesInCustomCPString, *BytesInCustomCPString) PCH CustomCPString,
    _In_ ULONG MaxBytesInCustomCPString,
    _Out_opt_ PULONG BytesInCustomCPString,
    _In_reads_bytes_(BytesInUnicodeString) PWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeToCustomCPN(
    _In_ PCPTABLEINFO CustomCP,
    _Out_writes_bytes_to_(MaxBytesInCustomCPString, *BytesInCustomCPString) PCH CustomCPString,
    _In_ ULONG MaxBytesInCustomCPString,
    _Out_opt_ PULONG BytesInCustomCPString,
    _In_reads_bytes_(BytesInUnicodeString) PWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString
    );

NTSYSAPI
VOID
NTAPI
RtlInitCodePageTable(
    _In_reads_z_(2) PUSHORT TableBase,
    _Inout_ PCPTABLEINFO CodePageTable
    );

NTSYSAPI
VOID
NTAPI
RtlInitNlsTables(
    _In_ PUSHORT AnsiNlsBase,
    _In_ PUSHORT OemNlsBase,
    _In_ PUSHORT LanguageNlsBase,
    _Out_ PNLSTABLEINFO TableInfo // PCPTABLEINFO?
    );

NTSYSAPI
VOID
NTAPI
RtlResetRtlTranslations(
    _In_ PNLSTABLEINFO TableInfo
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlIsTextUnicode(
    _In_ PVOID Buffer,
    _In_ ULONG Size,
    _Inout_opt_ PULONG Result
    );

typedef enum _RTL_NORM_FORM
{
    NormOther = 0x0,
    NormC = 0x1,
    NormD = 0x2,
    NormKC = 0x5,
    NormKD = 0x6,
    NormIdna = 0xd,
    DisallowUnassigned = 0x100,
    NormCDisallowUnassigned = 0x101,
    NormDDisallowUnassigned = 0x102,
    NormKCDisallowUnassigned = 0x105,
    NormKDDisallowUnassigned = 0x106,
    NormIdnaDisallowUnassigned = 0x10d
} RTL_NORM_FORM;

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
RtlNormalizeString(
    _In_ ULONG NormForm, // RTL_NORM_FORM
    _In_ PCWSTR SourceString,
    _In_ LONG SourceStringLength,
    _Out_writes_to_(*DestinationStringLength, *DestinationStringLength) PWSTR DestinationString,
    _Inout_ PLONG DestinationStringLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
RtlIsNormalizedString(
    _In_ ULONG NormForm, // RTL_NORM_FORM
    _In_ PCWSTR SourceString,
    _In_ LONG SourceStringLength,
    _Out_ PBOOLEAN Normalized
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
// ntifs:FsRtlIsNameInExpression
NTSYSAPI
BOOLEAN
NTAPI
RtlIsNameInExpression(
    _In_ PUNICODE_STRING Expression,
    _In_ PUNICODE_STRING Name,
    _In_ BOOLEAN IgnoreCase,
    _In_opt_ PWCH UpcaseTable
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE4)
// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsNameInUnUpcasedExpression(
    _In_ PUNICODE_STRING Expression,
    _In_ PUNICODE_STRING Name,
    _In_ BOOLEAN IgnoreCase,
    _In_opt_ PWCH UpcaseTable
    );
#endif

#if (PHNT_VERSION >= PHNT_19H1)
NTSYSAPI
BOOLEAN
NTAPI
RtlDoesNameContainWildCards(
    _In_ PUNICODE_STRING Expression
    );
#endif

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualDomainName(
    _In_ PUNICODE_STRING String1,
    _In_ PUNICODE_STRING String2
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualComputerName(
    _In_ PUNICODE_STRING String1,
    _In_ PUNICODE_STRING String2
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDnsHostNameToComputerName(
    _Out_ PUNICODE_STRING ComputerNameString,
    _In_ PUNICODE_STRING DnsHostNameString,
    _In_ BOOLEAN AllocateComputerNameString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
    _In_ PGUID Guid,
    _Out_ PUNICODE_STRING GuidString
    );

#if (PHNT_VERSION >= PHNT_WINBLUE)

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUIDEx(
    _In_ PGUID Guid,
    _Inout_ PUNICODE_STRING GuidString,
    _In_ BOOLEAN AllocateGuidString
    );

#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    _In_ PUNICODE_STRING GuidString,
    _Out_ PGUID Guid
    );

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
LONG
NTAPI
RtlCompareAltitudes(
    _In_ PUNICODE_STRING Altitude1,
    _In_ PUNICODE_STRING Altitude2
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIdnToAscii(
    _In_ ULONG Flags,
    _In_ PCWSTR SourceString,
    _In_ LONG SourceStringLength,
    _Out_writes_to_(*DestinationStringLength, *DestinationStringLength) PWSTR DestinationString,
    _Inout_ PLONG DestinationStringLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIdnToUnicode(
    _In_ ULONG Flags,
    _In_ PCWSTR SourceString,
    _In_ LONG SourceStringLength,
    _Out_writes_to_(*DestinationStringLength, *DestinationStringLength) PWSTR DestinationString,
    _Inout_ PLONG DestinationStringLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIdnToNameprepUnicode(
    _In_ ULONG Flags,
    _In_ PCWSTR SourceString,
    _In_ LONG SourceStringLength,
    _Out_writes_to_(*DestinationStringLength, *DestinationStringLength) PWSTR DestinationString,
    _Inout_ PLONG DestinationStringLength
    );

#endif

// Prefix

typedef struct _PREFIX_TABLE_ENTRY
{
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    struct _PREFIX_TABLE_ENTRY *NextPrefixTree;
    RTL_SPLAY_LINKS Links;
    PSTRING Prefix;
} PREFIX_TABLE_ENTRY, *PPREFIX_TABLE_ENTRY;

typedef struct _PREFIX_TABLE
{
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    PPREFIX_TABLE_ENTRY NextPrefixTree;
} PREFIX_TABLE, *PPREFIX_TABLE;

NTSYSAPI
VOID
NTAPI
PfxInitialize(
    _Out_ PPREFIX_TABLE PrefixTable
    );

NTSYSAPI
BOOLEAN
NTAPI
PfxInsertPrefix(
    _In_ PPREFIX_TABLE PrefixTable,
    _In_ PSTRING Prefix,
    _Out_ PPREFIX_TABLE_ENTRY PrefixTableEntry
    );

NTSYSAPI
VOID
NTAPI
PfxRemovePrefix(
    _In_ PPREFIX_TABLE PrefixTable,
    _In_ PPREFIX_TABLE_ENTRY PrefixTableEntry
    );

NTSYSAPI
PPREFIX_TABLE_ENTRY
NTAPI
PfxFindPrefix(
    _In_ PPREFIX_TABLE PrefixTable,
    _In_ PSTRING FullName
    );

typedef struct _UNICODE_PREFIX_TABLE_ENTRY
{
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    struct _UNICODE_PREFIX_TABLE_ENTRY *NextPrefixTree;
    struct _UNICODE_PREFIX_TABLE_ENTRY *CaseMatch;
    RTL_SPLAY_LINKS Links;
    PUNICODE_STRING Prefix;
} UNICODE_PREFIX_TABLE_ENTRY, *PUNICODE_PREFIX_TABLE_ENTRY;

typedef struct _UNICODE_PREFIX_TABLE
{
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    PUNICODE_PREFIX_TABLE_ENTRY NextPrefixTree;
    PUNICODE_PREFIX_TABLE_ENTRY LastNextEntry;
} UNICODE_PREFIX_TABLE, *PUNICODE_PREFIX_TABLE;

NTSYSAPI
VOID
NTAPI
RtlInitializeUnicodePrefix(
    _Out_ PUNICODE_PREFIX_TABLE PrefixTable
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlInsertUnicodePrefix(
    _In_ PUNICODE_PREFIX_TABLE PrefixTable,
    _In_ PUNICODE_STRING Prefix,
    _Out_ PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    );

NTSYSAPI
VOID
NTAPI
RtlRemoveUnicodePrefix(
    _In_ PUNICODE_PREFIX_TABLE PrefixTable,
    _In_ PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    );

NTSYSAPI
PUNICODE_PREFIX_TABLE_ENTRY
NTAPI
RtlFindUnicodePrefix(
    _In_ PUNICODE_PREFIX_TABLE PrefixTable,
    _In_ PUNICODE_STRING FullName,
    _In_ ULONG CaseInsensitiveIndex
    );

NTSYSAPI
PUNICODE_PREFIX_TABLE_ENTRY
NTAPI
RtlNextUnicodePrefix(
    _In_ PUNICODE_PREFIX_TABLE PrefixTable,
    _In_ BOOLEAN Restart
    );

// Compression

typedef struct _COMPRESSED_DATA_INFO
{
    USHORT CompressionFormatAndEngine; // COMPRESSION_FORMAT_* and COMPRESSION_ENGINE_*

    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved;

    USHORT NumberOfChunks;

    ULONG CompressedChunkSizes[1];
} COMPRESSED_DATA_INFO, *PCOMPRESSED_DATA_INFO;

NTSYSAPI
NTSTATUS
NTAPI
RtlGetCompressionWorkSpaceSize(
    _In_ USHORT CompressionFormatAndEngine,
    _Out_ PULONG CompressBufferWorkSpaceSize,
    _Out_ PULONG CompressFragmentWorkSpaceSize
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCompressBuffer(
    _In_ USHORT CompressionFormatAndEngine,
    _In_reads_bytes_(UncompressedBufferSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _Out_writes_bytes_to_(CompressedBufferSize, *FinalCompressedSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_ ULONG UncompressedChunkSize,
    _Out_ PULONG FinalCompressedSize,
    _In_ PVOID WorkSpace
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBuffer(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _Out_ PULONG FinalUncompressedSize
    );

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBufferEx(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _Out_ PULONG FinalUncompressedSize,
    _In_opt_ PVOID WorkSpace
    );
#endif

#if (PHNT_VERSION >= PHNT_WINBLUE)
NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBufferEx2(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_ ULONG UncompressedChunkSize,
    _Out_ PULONG FinalUncompressedSize,
    _In_opt_ PVOID WorkSpace
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressFragment(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedFragmentSize, *FinalUncompressedSize) PUCHAR UncompressedFragment,
    _In_ ULONG UncompressedFragmentSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_range_(<, CompressedBufferSize) ULONG FragmentOffset,
    _Out_ PULONG FinalUncompressedSize,
    _In_ PVOID WorkSpace
    );

#if (PHNT_VERSION >= PHNT_WINBLUE)
NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressFragmentEx(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedFragmentSize, *FinalUncompressedSize) PUCHAR UncompressedFragment,
    _In_ ULONG UncompressedFragmentSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_range_(<, CompressedBufferSize) ULONG FragmentOffset,
    _In_ ULONG UncompressedChunkSize,
    _Out_ PULONG FinalUncompressedSize,
    _In_ PVOID WorkSpace
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlDescribeChunk(
    _In_ USHORT CompressionFormat,
    _Inout_ PUCHAR *CompressedBuffer,
    _In_ PUCHAR EndOfCompressedBufferPlus1,
    _Out_ PUCHAR *ChunkBuffer,
    _Out_ PULONG ChunkSize
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlReserveChunk(
    _In_ USHORT CompressionFormat,
    _Inout_ PUCHAR *CompressedBuffer,
    _In_ PUCHAR EndOfCompressedBufferPlus1,
    _Out_ PUCHAR *ChunkBuffer,
    _In_ ULONG ChunkSize
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressChunks(
    _Out_writes_bytes_(UncompressedBufferSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_reads_bytes_(CompressedTailSize) PUCHAR CompressedTail,
    _In_ ULONG CompressedTailSize,
    _In_ PCOMPRESSED_DATA_INFO CompressedDataInfo
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCompressChunks(
    _In_reads_bytes_(UncompressedBufferSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _Out_writes_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_range_(>=, (UncompressedBufferSize - (UncompressedBufferSize / 16))) ULONG CompressedBufferSize,
    _Inout_updates_bytes_(CompressedDataInfoLength) PCOMPRESSED_DATA_INFO CompressedDataInfo,
    _In_range_(>, sizeof(COMPRESSED_DATA_INFO)) ULONG CompressedDataInfoLength,
    _In_ PVOID WorkSpace
    );

// Locale

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlConvertLCIDToString(
    _In_ LCID LcidValue,
    _In_ ULONG Base,
    _In_ ULONG Padding, // string is padded to this width
    _Out_writes_(Size) PWSTR pResultBuf,
    _In_ ULONG Size
    );

// private
NTSYSAPI
BOOLEAN
NTAPI
RtlIsValidLocaleName(
    _In_ PCWSTR LocaleName,
    _In_ ULONG Flags
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlGetParentLocaleName(
    _In_ PCWSTR LocaleName,
    _Inout_ PUNICODE_STRING ParentLocaleName,
    _In_ ULONG Flags,
    _In_ BOOLEAN AllocateDestinationString
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlLcidToLocaleName(
    _In_ LCID lcid, // sic
    _Inout_ PUNICODE_STRING LocaleName,
    _In_ ULONG Flags,
    _In_ BOOLEAN AllocateDestinationString
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlLocaleNameToLcid(
    _In_ PCWSTR LocaleName,
    _Out_ PLCID lcid,
    _In_ ULONG Flags
    );

// private
NTSYSAPI
BOOLEAN
NTAPI
RtlLCIDToCultureName(
    _In_ LCID Lcid,
    _Inout_ PUNICODE_STRING String
    );

// private
NTSYSAPI
BOOLEAN
NTAPI
RtlCultureNameToLCID(
    _In_ PUNICODE_STRING String,
    _Out_ PLCID Lcid
    );

// private
NTSYSAPI
VOID
NTAPI
RtlCleanUpTEBLangLists(
    VOID
    );

#endif

#if (PHNT_VERSION >= PHNT_WIN7)

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetLocaleFileMappingAddress(
    _Out_ PVOID *BaseAddress,
    _Out_ PLCID DefaultLocaleId,
    _Out_ PLARGE_INTEGER DefaultCasingTableSize
    );

#endif

// PEB

NTSYSAPI
PPEB
NTAPI
RtlGetCurrentPeb(
    VOID
    );

NTSYSAPI
VOID
NTAPI
RtlAcquirePebLock(
    VOID
    );

NTSYSAPI
VOID
NTAPI
RtlReleasePebLock(
    VOID
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
LOGICAL
NTAPI
RtlTryAcquirePebLock(
    VOID
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateFromPeb(
    _In_ ULONG Size,
    _Out_ PVOID *Block
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlFreeToPeb(
    _In_ PVOID Block,
    _In_ ULONG Size
    );

// Processes

#define DOS_MAX_COMPONENT_LENGTH 255
#define DOS_MAX_PATH_LENGTH (DOS_MAX_COMPONENT_LENGTH + 5)

typedef struct _CURDIR
{
    UNICODE_STRING DosPath;
    HANDLE Handle;
} CURDIR, *PCURDIR;

#define RTL_USER_PROC_CURDIR_CLOSE 0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT 0x00000003

typedef struct _RTL_DRIVE_LETTER_CURDIR
{
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    HANDLE ConsoleHandle;
    ULONG ConsoleFlags;
    HANDLE StandardInput;
    HANDLE StandardOutput;
    HANDLE StandardError;

    CURDIR CurrentDirectory;
    UNICODE_STRING DllPath;
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
    PVOID Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeData;
    RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG_PTR EnvironmentSize;
    ULONG_PTR EnvironmentVersion;

    PVOID PackageDependencyData;
    ULONG ProcessGroupId;
    ULONG LoaderThreads;

    UNICODE_STRING RedirectionDllName; // REDSTONE4
    UNICODE_STRING HeapPartitionName; // 19H1
    ULONG_PTR DefaultThreadpoolCpuSetMasks;
    ULONG DefaultThreadpoolCpuSetMaskCount;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

#define RTL_USER_PROC_PARAMS_NORMALIZED 0x00000001
#define RTL_USER_PROC_PROFILE_USER 0x00000002
#define RTL_USER_PROC_PROFILE_KERNEL 0x00000004
#define RTL_USER_PROC_PROFILE_SERVER 0x00000008
#define RTL_USER_PROC_RESERVE_1MB 0x00000020
#define RTL_USER_PROC_RESERVE_16MB 0x00000040
#define RTL_USER_PROC_CASE_SENSITIVE 0x00000080
#define RTL_USER_PROC_DISABLE_HEAP_DECOMMIT 0x00000100
#define RTL_USER_PROC_DLL_REDIRECTION_LOCAL 0x00001000
#define RTL_USER_PROC_APP_MANIFEST_PRESENT 0x00002000
#define RTL_USER_PROC_IMAGE_KEY_MISSING 0x00004000
#define RTL_USER_PROC_OPTIN_PROCESS 0x00020000

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParameters(
    _Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParametersEx(
    _Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData,
    _In_ ULONG Flags // pass RTL_USER_PROC_PARAMS_NORMALIZED to keep parameters normalized
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyProcessParameters(
    _In_ _Post_invalid_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

NTSYSAPI
PRTL_USER_PROCESS_PARAMETERS
NTAPI
RtlNormalizeProcessParams(
    _Inout_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

NTSYSAPI
PRTL_USER_PROCESS_PARAMETERS
NTAPI
RtlDeNormalizeProcessParams(
    _Inout_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

typedef struct _RTL_USER_PROCESS_INFORMATION
{
    ULONG Length;
    HANDLE ProcessHandle;
    HANDLE ThreadHandle;
    CLIENT_ID ClientId;
    SECTION_IMAGE_INFORMATION ImageInformation;
} RTL_USER_PROCESS_INFORMATION, *PRTL_USER_PROCESS_INFORMATION;

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserProcess(
    _In_ PUNICODE_STRING NtImagePathName,
    _In_ ULONG AttributesDeprecated,
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    _In_opt_ PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_opt_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritHandles,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE TokenHandle, // used to be ExceptionPort
    _Out_ PRTL_USER_PROCESS_INFORMATION ProcessInformation
    );

#if (PHNT_VERSION >= PHNT_REDSTONE2)

#define RTL_USER_PROCESS_EXTENDED_PARAMETERS_VERSION 1

// private
typedef struct _RTL_USER_PROCESS_EXTENDED_PARAMETERS
{
    USHORT Version;
    USHORT NodeNumber;
    PSECURITY_DESCRIPTOR ProcessSecurityDescriptor;
    PSECURITY_DESCRIPTOR ThreadSecurityDescriptor;
    HANDLE ParentProcess;
    HANDLE DebugPort;
    HANDLE TokenHandle;
    HANDLE JobHandle;
} RTL_USER_PROCESS_EXTENDED_PARAMETERS, *PRTL_USER_PROCESS_EXTENDED_PARAMETERS;

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserProcessEx(
    _In_ PUNICODE_STRING NtImagePathName,
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    _In_ BOOLEAN InheritHandles,
    _In_opt_ PRTL_USER_PROCESS_EXTENDED_PARAMETERS ProcessExtendedParameters,
    _Out_ PRTL_USER_PROCESS_INFORMATION ProcessInformation
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)
DECLSPEC_NORETURN
NTSYSAPI
VOID
NTAPI
RtlExitUserProcess(
    _In_ NTSTATUS ExitStatus
    );
#else

#define RtlExitUserProcess RtlExitUserProcess_R

DECLSPEC_NORETURN
FORCEINLINE VOID RtlExitUserProcess_R(
    _In_ NTSTATUS ExitStatus
    )
{
    ExitProcess(ExitStatus);
}

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// begin_rev
#define RTL_CLONE_PROCESS_FLAGS_CREATE_SUSPENDED 0x00000001
#define RTL_CLONE_PROCESS_FLAGS_INHERIT_HANDLES 0x00000002
#define RTL_CLONE_PROCESS_FLAGS_NO_SYNCHRONIZE 0x00000004 // don't update synchronization objects
// end_rev

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlCloneUserProcess(
    _In_ ULONG ProcessFlags,
    _In_opt_ PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_opt_ HANDLE DebugPort,
    _Out_ PRTL_USER_PROCESS_INFORMATION ProcessInformation
    );

// private
NTSYSAPI
VOID
NTAPI
RtlUpdateClonedCriticalSection(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
    );

// private
NTSYSAPI
VOID
NTAPI
RtlUpdateClonedSRWLock(
    _Inout_ PRTL_SRWLOCK SRWLock,
    _In_ LOGICAL Shared // TRUE to set to shared acquire
    );

// rev
#define RTL_PROCESS_REFLECTION_FLAGS_INHERIT_HANDLES 0x2
#define RTL_PROCESS_REFLECTION_FLAGS_NO_SUSPEND 0x4
#define RTL_PROCESS_REFLECTION_FLAGS_NO_SYNCHRONIZE 0x8
#define RTL_PROCESS_REFLECTION_FLAGS_NO_CLOSE_EVENT 0x10

// private
typedef struct _RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION
{
    HANDLE ReflectionProcessHandle;
    HANDLE ReflectionThreadHandle;
    CLIENT_ID ReflectionClientId;
} RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION, *PRTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION;

typedef RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION PROCESS_REFLECTION_INFORMATION, *PPROCESS_REFLECTION_INFORMATION;

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessReflection(
    _In_ HANDLE ProcessHandle,
    _In_ ULONG Flags, // RTL_PROCESS_REFLECTION_FLAGS_*
    _In_opt_ PVOID StartRoutine,
    _In_opt_ PVOID StartContext,
    _In_opt_ HANDLE EventHandle,
    _Out_opt_ PRTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION ReflectionInformation
    );
#endif

#endif

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetProcessIsCritical(
    _In_ BOOLEAN NewValue,
    _Out_opt_ PBOOLEAN OldValue,
    _In_ BOOLEAN CheckFlag
    );

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetThreadIsCritical(
    _In_ BOOLEAN NewValue,
    _Out_opt_ PBOOLEAN OldValue,
    _In_ BOOLEAN CheckFlag
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlValidProcessProtection(
    _In_ PS_PROTECTION ProcessProtection
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlTestProtectedAccess(
    _In_ PS_PROTECTION Source,
    _In_ PS_PROTECTION Target
    );

#if (PHNT_VERSION >= PHNT_REDSTONE3)
// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsCurrentProcess( // NtCompareObjects(NtCurrentProcess(), ProcessHandle)
    _In_ HANDLE ProcessHandle
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsCurrentThread( // NtCompareObjects(NtCurrentThread(), ThreadHandle)
    _In_ HANDLE ThreadHandle
    );
#endif

// Threads

typedef NTSTATUS (NTAPI *PUSER_THREAD_START_ROUTINE)(
    _In_ PVOID ThreadParameter
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserThread(
    _In_ HANDLE Process,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_ BOOLEAN CreateSuspended,
    _In_opt_ ULONG ZeroBits,
    _In_opt_ SIZE_T MaximumStackSize,
    _In_opt_ SIZE_T CommittedStackSize,
    _In_ PUSER_THREAD_START_ROUTINE StartAddress,
    _In_opt_ PVOID Parameter,
    _Out_opt_ PHANDLE Thread,
    _Out_opt_ PCLIENT_ID ClientId
    );

#if (PHNT_VERSION >= PHNT_VISTA) // should be PHNT_WINXP, but is PHNT_VISTA for consistency with RtlExitUserProcess
DECLSPEC_NORETURN
NTSYSAPI
VOID
NTAPI
RtlExitUserThread(
    _In_ NTSTATUS ExitStatus
    );
#else

#define RtlExitUserThread RtlExitUserThread_R

DECLSPEC_NORETURN
FORCEINLINE VOID RtlExitUserThread_R(
    _In_ NTSTATUS ExitStatus
    )
{
    ExitThread(ExitStatus);
}

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsCurrentThreadAttachExempt(
    VOID
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserStack(
    _In_opt_ SIZE_T CommittedStackSize,
    _In_opt_ SIZE_T MaximumStackSize,
    _In_opt_ ULONG_PTR ZeroBits,
    _In_ SIZE_T PageSize,
    _In_ ULONG_PTR ReserveAlignment,
    _Out_ PINITIAL_TEB InitialTeb
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlFreeUserStack(
    _In_ PVOID AllocationBase
    );

#endif

// Extended thread context

typedef struct _CONTEXT_CHUNK
{
    LONG Offset; // Offset may be negative.
    ULONG Length;
} CONTEXT_CHUNK, *PCONTEXT_CHUNK;

typedef struct _CONTEXT_EX
{
    CONTEXT_CHUNK All;
    CONTEXT_CHUNK Legacy;
    CONTEXT_CHUNK XState;
} CONTEXT_EX, *PCONTEXT_EX;

#define CONTEXT_EX_LENGTH ALIGN_UP_BY(sizeof(CONTEXT_EX), PAGE_SIZE)
#define RTL_CONTEXT_EX_OFFSET(ContextEx, Chunk) ((ContextEx)->Chunk.Offset)
#define RTL_CONTEXT_EX_LENGTH(ContextEx, Chunk) ((ContextEx)->Chunk.Length)
#define RTL_CONTEXT_EX_CHUNK(Base, Layout, Chunk) ((PVOID)((PCHAR)(Base) + RTL_CONTEXT_EX_OFFSET(Layout, Chunk)))
#define RTL_CONTEXT_OFFSET(Context, Chunk) RTL_CONTEXT_EX_OFFSET((PCONTEXT_EX)(Context + 1), Chunk)
#define RTL_CONTEXT_LENGTH(Context, Chunk) RTL_CONTEXT_EX_LENGTH((PCONTEXT_EX)(Context + 1), Chunk)
#define RTL_CONTEXT_CHUNK(Context, Chunk) RTL_CONTEXT_EX_CHUNK((PCONTEXT_EX)(Context + 1), (PCONTEXT_EX)(Context + 1), Chunk)

NTSYSAPI
VOID
NTAPI
RtlInitializeContext(
    _In_ HANDLE Process,
    _Out_ PCONTEXT Context,
    _In_opt_ PVOID Parameter,
    _In_opt_ PVOID InitialPc,
    _In_opt_ PVOID InitialSp
    );

NTSYSAPI
ULONG
NTAPI
RtlInitializeExtendedContext(
    _Out_ PCONTEXT Context,
    _In_ ULONG ContextFlags,
    _Out_ PCONTEXT_EX* ContextEx
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCopyContext(
    _Inout_ PCONTEXT Context,
    _In_ ULONG ContextFlags,
    _Out_ PCONTEXT Source
    );

NTSYSAPI
ULONG
NTAPI
RtlCopyExtendedContext(
    _Out_ PCONTEXT_EX Destination,
    _In_ ULONG ContextFlags,
    _In_ PCONTEXT_EX Source
    );

NTSYSAPI
ULONG
NTAPI
RtlGetExtendedContextLength(
    _In_ ULONG ContextFlags,
    _Out_ PULONG ContextLength
    );

NTSYSAPI
ULONG64
NTAPI
RtlGetExtendedFeaturesMask(
    _In_ PCONTEXT_EX ContextEx
    );

NTSYSAPI
PVOID
NTAPI
RtlLocateExtendedFeature(
    _In_ PCONTEXT_EX ContextEx,
    _In_ ULONG FeatureId,
    _Out_opt_ PULONG Length
    );

NTSYSAPI
PCONTEXT
NTAPI
RtlLocateLegacyContext(
    _In_ PCONTEXT_EX ContextEx,
    _Out_opt_ PULONG Length
    );

NTSYSAPI
VOID
NTAPI
RtlSetExtendedFeaturesMask(
    _In_ PCONTEXT_EX ContextEx,
    _In_ ULONG64 FeatureMask
    );

#ifdef _WIN64
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlWow64GetThreadContext(
    _In_ HANDLE ThreadHandle,
    _Inout_ PWOW64_CONTEXT ThreadContext
    );
#endif

#ifdef _WIN64
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlWow64SetThreadContext(
    _In_ HANDLE ThreadHandle,
    _In_ PWOW64_CONTEXT ThreadContext
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlRemoteCall(
    _In_ HANDLE Process,
    _In_ HANDLE Thread,
    _In_ PVOID CallSite,
    _In_ ULONG ArgumentCount,
    _In_opt_ PULONG_PTR Arguments,
    _In_ BOOLEAN PassContext,
    _In_ BOOLEAN AlreadySuspended
    );

// Vectored Exception Handlers

NTSYSAPI
PVOID
NTAPI
RtlAddVectoredExceptionHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler
    );

NTSYSAPI
ULONG
NTAPI
RtlRemoveVectoredExceptionHandler(
    _In_ PVOID Handle
    );

NTSYSAPI
PVOID
NTAPI
RtlAddVectoredContinueHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler
    );

NTSYSAPI
ULONG
NTAPI
RtlRemoveVectoredContinueHandler(
    _In_ PVOID Handle
    );

// Runtime exception handling

typedef ULONG (NTAPI *PRTLP_UNHANDLED_EXCEPTION_FILTER)(
    _In_ PEXCEPTION_POINTERS ExceptionInfo
    );

NTSYSAPI
VOID
NTAPI
RtlSetUnhandledExceptionFilter(
    _In_ PRTLP_UNHANDLED_EXCEPTION_FILTER UnhandledExceptionFilter
    );

// rev
NTSYSAPI
LONG
NTAPI
RtlUnhandledExceptionFilter(
    _In_ PEXCEPTION_POINTERS ExceptionPointers
    );

// rev
NTSYSAPI
LONG
NTAPI
RtlUnhandledExceptionFilter2(
    _In_ PEXCEPTION_POINTERS ExceptionPointers,
    _In_ ULONG Flags
    );

// rev
NTSYSAPI
LONG
NTAPI
RtlKnownExceptionFilter(
    _In_ PEXCEPTION_POINTERS ExceptionPointers
    );

#ifdef _WIN64

// private
typedef enum _FUNCTION_TABLE_TYPE
{
    RF_SORTED,
    RF_UNSORTED,
    RF_CALLBACK,
    RF_KERNEL_DYNAMIC
} FUNCTION_TABLE_TYPE;

// private
typedef struct _DYNAMIC_FUNCTION_TABLE
{
    LIST_ENTRY ListEntry;
    PRUNTIME_FUNCTION FunctionTable;
    LARGE_INTEGER TimeStamp;
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    PGET_RUNTIME_FUNCTION_CALLBACK Callback;
    PVOID Context;
    PWSTR OutOfProcessCallbackDll;
    FUNCTION_TABLE_TYPE Type;
    ULONG EntryCount;
    RTL_BALANCED_NODE TreeNodeMin;
    RTL_BALANCED_NODE TreeNodeMax;
} DYNAMIC_FUNCTION_TABLE, *PDYNAMIC_FUNCTION_TABLE;

// rev
NTSYSAPI
PLIST_ENTRY
NTAPI
RtlGetFunctionTableListHead(
    VOID
    );

#endif

// Activation Contexts

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetActiveActivationContext(
    _Out_ HANDLE ActCtx
    );

// rev
NTSYSAPI
VOID
NTAPI
RtlAddRefActivationContext(
    _In_ HANDLE ActCtx
    );

// rev
NTSYSAPI
VOID
NTAPI
RtlReleaseActivationContext(
    _In_ HANDLE ActCtx
    );

// Images

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
    _In_ PVOID BaseOfImage
    );

#define RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK 0x00000001

NTSYSAPI
NTSTATUS
NTAPI
RtlImageNtHeaderEx(
    _In_ ULONG Flags,
    _In_ PVOID BaseOfImage,
    _In_ ULONG64 Size,
    _Out_ PIMAGE_NT_HEADERS *OutHeaders
    );

NTSYSAPI
PVOID
NTAPI
RtlAddressInSectionTable(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG VirtualAddress
    );

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlSectionTableFromVirtualAddress(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG VirtualAddress
    );

NTSYSAPI
PVOID
NTAPI
RtlImageDirectoryEntryToData(
    _In_ PVOID BaseOfImage,
    _In_ BOOLEAN MappedAsImage,
    _In_ USHORT DirectoryEntry,
    _Out_ PULONG Size
    );

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlImageRvaToSection(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG Rva
    );

NTSYSAPI
PVOID
NTAPI
RtlImageRvaToVa(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG Rva,
    _Out_opt_ PIMAGE_SECTION_HEADER *LastRvaSection
    );

#if (PHNT_VERSION >= PHNT_REDSTONE)

// rev
NTSYSAPI
PVOID
NTAPI
RtlFindExportedRoutineByName(
    _In_ PVOID BaseOfImage,
    _In_ PCSTR RoutineName
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGuardCheckLongJumpTarget(
    _In_ PVOID PcValue,
    _In_ BOOL IsFastFail,
    _Out_ PBOOL IsLongJumpTarget
    );

#endif

// Memory

_Must_inspect_result_
NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemoryUlong(
    _In_reads_bytes_(Length) PVOID Source,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern
    );

#if defined(_M_AMD64)
FORCEINLINE
VOID
RtlFillMemoryUlong(
    _Out_writes_bytes_all_(Length) PVOID Destination,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern
    )
{
    PULONG Address = (PULONG)Destination;

    //
    // If the number of DWORDs is not zero, then fill the specified buffer
    // with the specified pattern.
    //

    if ((Length /= 4) != 0) {

        //
        // If the destination is not quadword aligned (ignoring low bits),
        // then align the destination by storing one DWORD.
        //

        if (((ULONG64)Address & 4) != 0) {
            *Address = Pattern;
            if ((Length -= 1) == 0) {
                return;
            }

            Address += 1;
        }

        //
        // If the number of QWORDs is not zero, then fill the destination
        // buffer a QWORD at a time.
        //

         __stosq((PULONG64)(Address),
                 Pattern | ((ULONG64)Pattern << 32),
                 Length / 2);

        if ((Length & 1) != 0) {
            Address[Length - 1] = Pattern;
        }
    }

    return;
}
#else
NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlong(
    _Out_writes_bytes_all_(Length) PVOID Destination,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern
    );
#endif

#if defined(_M_AMD64)

#define RtlFillMemoryUlonglong(Destination, Length, Pattern) \
    __stosq((PULONG64)(Destination), Pattern, (Length) / 8)

#else
NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlonglong(
    _Out_writes_bytes_all_(Length) PVOID Destination,
    _In_ SIZE_T Length,
    _In_ ULONGLONG Pattern
    );
#endif
// Environment

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironment(
    _In_ BOOLEAN CloneCurrentEnvironment,
    _Out_ PVOID *Environment
    );

// begin_rev
#define RTL_CREATE_ENVIRONMENT_TRANSLATE 0x1 // translate from multi-byte to Unicode
#define RTL_CREATE_ENVIRONMENT_TRANSLATE_FROM_OEM 0x2 // translate from OEM to Unicode (Translate flag must also be set)
#define RTL_CREATE_ENVIRONMENT_EMPTY 0x4 // create empty environment block
// end_rev

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironmentEx(
    _In_ PVOID SourceEnv,
    _Out_ PVOID *Environment,
    _In_ ULONG Flags
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyEnvironment(
    _In_ PVOID Environment
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetCurrentEnvironment(
    _In_ PVOID Environment,
    _Out_opt_ PVOID *PreviousEnvironment
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentVar(
    _Inout_opt_ PVOID *Environment,
    _In_reads_(NameLength) PCWSTR Name,
    _In_ SIZE_T NameLength,
    _In_reads_(ValueLength) PCWSTR Value,
    _In_ SIZE_T ValueLength
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentVariable(
    _Inout_opt_ PVOID *Environment,
    _In_ PUNICODE_STRING Name,
    _In_opt_ PUNICODE_STRING Value
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryEnvironmentVariable(
    _In_opt_ PVOID Environment,
    _In_reads_(NameLength) PCWSTR Name,
    _In_ SIZE_T NameLength,
    _Out_writes_(ValueLength) PWSTR Value,
    _In_ SIZE_T ValueLength,
    _Out_ PSIZE_T ReturnLength
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryEnvironmentVariable_U(
    _In_opt_ PVOID Environment,
    _In_ PUNICODE_STRING Name,
    _Inout_ PUNICODE_STRING Value
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings(
    _In_opt_ PVOID Environment,
    _In_reads_(SrcLength) PCWSTR Src,
    _In_ SIZE_T SrcLength,
    _Out_writes_(DstLength) PWSTR Dst,
    _In_ SIZE_T DstLength,
    _Out_opt_ PSIZE_T ReturnLength
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings_U(
    _In_opt_ PVOID Environment,
    _In_ PUNICODE_STRING Source,
    _Inout_ PUNICODE_STRING Destination,
    _Out_opt_ PULONG ReturnedLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentStrings(
    _In_ PCWCHAR NewEnvironment,
    _In_ SIZE_T NewEnvironmentSize
    );

// Directory and path support

typedef struct _RTLP_CURDIR_REF
{
    LONG ReferenceCount;
    HANDLE DirectoryHandle;
} RTLP_CURDIR_REF, *PRTLP_CURDIR_REF;

typedef struct _RTL_RELATIVE_NAME_U
{
    UNICODE_STRING RelativeName;
    HANDLE ContainingDirectory;
    PRTLP_CURDIR_REF CurDirRef;
} RTL_RELATIVE_NAME_U, *PRTL_RELATIVE_NAME_U;

typedef enum _RTL_PATH_TYPE
{
    RtlPathTypeUnknown,
    RtlPathTypeUncAbsolute,
    RtlPathTypeDriveAbsolute,
    RtlPathTypeDriveRelative,
    RtlPathTypeRooted,
    RtlPathTypeRelative,
    RtlPathTypeLocalDevice,
    RtlPathTypeRootLocalDevice
} RTL_PATH_TYPE;

// Data exports (ntdll.lib/ntdllp.lib)

NTSYSAPI PWSTR RtlNtdllName;
NTSYSAPI UNICODE_STRING RtlDosPathSeperatorsString;
NTSYSAPI UNICODE_STRING RtlAlternateDosPathSeperatorString;
NTSYSAPI UNICODE_STRING RtlNtPathSeperatorString;

#ifndef PHNT_INLINE_SEPERATOR_STRINGS
#define RtlNtdllName L"ntdll.dll"
#define RtlDosPathSeperatorsString ((UNICODE_STRING)RTL_CONSTANT_STRING(L"\\/"))
#define RtlAlternateDosPathSeperatorString ((UNICODE_STRING)RTL_CONSTANT_STRING(L"/"))
#define RtlNtPathSeperatorString ((UNICODE_STRING)RTL_CONSTANT_STRING(L"\\"))
#endif

// Path functions

NTSYSAPI
RTL_PATH_TYPE
NTAPI
RtlDetermineDosPathNameType_U(
    _In_ PCWSTR DosFileName
    );

NTSYSAPI
ULONG
NTAPI
RtlIsDosDeviceName_U(
    _In_ PCWSTR DosFileName
    );

NTSYSAPI
ULONG
NTAPI
RtlGetFullPathName_U(
    _In_ PCWSTR FileName,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_(BufferLength) PWSTR Buffer,
    _Out_opt_ PWSTR *FilePart
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetFullPathName_UEx(
    _In_ PCWSTR FileName,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_(BufferLength) PWSTR Buffer,
    _Out_opt_ PWSTR *FilePart,
    _Out_opt_ ULONG *BytesRequired
    );
#endif

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSAPI
NTSTATUS
NTAPI
RtlGetFullPathName_UstrEx(
    _In_ PUNICODE_STRING FileName,
    _Inout_ PUNICODE_STRING StaticString,
    _Out_opt_ PUNICODE_STRING DynamicString,
    _Out_opt_ PUNICODE_STRING *StringUsed,
    _Out_opt_ SIZE_T *FilePartPrefixCch,
    _Out_opt_ PBOOLEAN NameInvalid,
    _Out_ RTL_PATH_TYPE *InputPathType,
    _Out_opt_ SIZE_T *BytesRequired
    );
#endif

NTSYSAPI
ULONG
NTAPI
RtlGetCurrentDirectory_U(
    _In_ ULONG BufferLength,
    _Out_writes_bytes_(BufferLength) PWSTR Buffer
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetCurrentDirectory_U(
    _In_ PUNICODE_STRING PathName
    );

NTSYSAPI
ULONG
NTAPI
RtlGetLongestNtPathLength(
    VOID
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlDosPathNameToNtPathName_U(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
    );

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSAPI
NTSTATUS
NTAPI
RtlDosPathNameToNtPathName_U_WithStatus(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE3)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlDosLongPathNameToNtPathName_U_WithStatus(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
    );
#endif

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSAPI
BOOLEAN
NTAPI
RtlDosPathNameToRelativeNtPathName_U(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
    );
#endif

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSAPI
NTSTATUS
NTAPI
RtlDosPathNameToRelativeNtPathName_U_WithStatus(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE3)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlDosLongPathNameToRelativeNtPathName_U_WithStatus(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
    );
#endif

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSAPI
VOID
NTAPI
RtlReleaseRelativeName(
    _Inout_ PRTL_RELATIVE_NAME_U RelativeName
    );
#endif

NTSYSAPI
ULONG
NTAPI
RtlDosSearchPath_U(
    _In_ PCWSTR Path,
    _In_ PCWSTR FileName,
    _In_opt_ PCWSTR Extension,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_(BufferLength) PWSTR Buffer,
    _Out_opt_ PWSTR *FilePart
    );

#define RTL_DOS_SEARCH_PATH_FLAG_APPLY_ISOLATION_REDIRECTION 0x00000001
#define RTL_DOS_SEARCH_PATH_FLAG_DISALLOW_DOT_RELATIVE_PATH_SEARCH 0x00000002
#define RTL_DOS_SEARCH_PATH_FLAG_APPLY_DEFAULT_EXTENSION_WHEN_NOT_RELATIVE_PATH_EVEN_IF_FILE_HAS_EXTENSION 0x00000004

NTSYSAPI
NTSTATUS
NTAPI
RtlDosSearchPath_Ustr(
    _In_ ULONG Flags,
    _In_ PUNICODE_STRING Path,
    _In_ PUNICODE_STRING FileName,
    _In_opt_ PUNICODE_STRING DefaultExtension,
    _Out_opt_ PUNICODE_STRING StaticString,
    _Out_opt_ PUNICODE_STRING DynamicString,
    _Out_opt_ PCUNICODE_STRING *FullFileNameOut,
    _Out_opt_ SIZE_T *FilePartPrefixCch,
    _Out_opt_ SIZE_T *BytesRequired
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlDoesFileExists_U(
    _In_ PCWSTR FileName
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetLengthWithoutLastFullDosOrNtPathElement(
    _Reserved_ ULONG Flags,
    _In_ PUNICODE_STRING PathString,
    _Out_ PULONG Length
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetLengthWithoutTrailingPathSeperators(
    _Reserved_ ULONG Flags,
    _In_ PUNICODE_STRING PathString,
    _Out_ PULONG Length
    );

typedef struct _GENERATE_NAME_CONTEXT
{
    USHORT Checksum;
    BOOLEAN CheckSumInserted;
    UCHAR NameLength;
    WCHAR NameBuffer[8];
    ULONG ExtensionLength;
    WCHAR ExtensionBuffer[4];
    ULONG LastIndexValue;
} GENERATE_NAME_CONTEXT, *PGENERATE_NAME_CONTEXT;

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlGenerate8dot3Name(
    _In_ PUNICODE_STRING Name,
    _In_ BOOLEAN AllowExtendedCharacters,
    _Inout_ PGENERATE_NAME_CONTEXT Context,
    _Inout_ PUNICODE_STRING Name8dot3
    );

#if (PHNT_VERSION >= PHNT_WIN8)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlComputePrivatizedDllName_U(
    _In_ PUNICODE_STRING DllName,
    _Out_ PUNICODE_STRING RealName,
    _Out_ PUNICODE_STRING LocalName
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetSearchPath(
    _Out_ PWSTR *SearchPath
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSetSearchPathMode(
    _In_ ULONG Flags
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetExePath(
    _In_ PCWSTR DosPathName,
    _Out_ PWSTR* SearchPath
    );

// rev
NTSYSAPI
VOID
NTAPI
RtlReleasePath(
    _In_ PWSTR Path
    );

#endif

#if (PHNT_VERSION >= PHNT_REDSTONE)
// rev
NTSYSAPI
ULONG
NTAPI
RtlReplaceSystemDirectoryInPath(
    _Inout_ PUNICODE_STRING Destination,
    _In_ ULONG Machine, // IMAGE_FILE_MACHINE_I386
    _In_ ULONG TargetMachine, // IMAGE_FILE_MACHINE_TARGET_HOST
    _In_ BOOLEAN IncludePathSeperator
    );
#endif

#if (PHNT_VERSION >= PHNT_21H2)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlWow64GetProcessMachines(
    _In_ HANDLE ProcessHandle,
    _Out_ PUSHORT ProcessMachine,
    _Out_ PUSHORT NativeMachine
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE2)

// private
NTSYSAPI
PWSTR
NTAPI
RtlGetNtSystemRoot(
    VOID
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlAreLongPathsEnabled(
    VOID
    );

#endif

NTSYSAPI
BOOLEAN
NTAPI
RtlIsThreadWithinLoaderCallout(
    VOID
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlDllShutdownInProgress(
    VOID
    );

// Heaps

typedef struct _RTL_HEAP_ENTRY
{
    SIZE_T Size;
    USHORT Flags;
    USHORT AllocatorBackTraceIndex;
    union
    {
        struct
        {
            SIZE_T Settable;
            ULONG Tag;
        } s1;
        struct
        {
            SIZE_T CommittedSize;
            PVOID FirstBlock;
        } s2;
    } u;
} RTL_HEAP_ENTRY, *PRTL_HEAP_ENTRY;

#define RTL_HEAP_BUSY (USHORT)0x0001
#define RTL_HEAP_SEGMENT (USHORT)0x0002
#define RTL_HEAP_SETTABLE_VALUE (USHORT)0x0010
#define RTL_HEAP_SETTABLE_FLAG1 (USHORT)0x0020
#define RTL_HEAP_SETTABLE_FLAG2 (USHORT)0x0040
#define RTL_HEAP_SETTABLE_FLAG3 (USHORT)0x0080
#define RTL_HEAP_SETTABLE_FLAGS (USHORT)0x00e0
#define RTL_HEAP_UNCOMMITTED_RANGE (USHORT)0x0100
#define RTL_HEAP_PROTECTED_ENTRY (USHORT)0x0200

typedef struct _RTL_HEAP_TAG
{
    ULONG NumberOfAllocations;
    ULONG NumberOfFrees;
    SIZE_T BytesAllocated;
    USHORT TagIndex;
    USHORT CreatorBackTraceIndex;
    WCHAR TagName[24];
} RTL_HEAP_TAG, *PRTL_HEAP_TAG;

// Windows 7/8/10
typedef struct _RTL_HEAP_INFORMATION_V1
{
    PVOID BaseAddress;
    ULONG Flags;
    USHORT EntryOverhead;
    USHORT CreatorBackTraceIndex;
    SIZE_T BytesAllocated;
    SIZE_T BytesCommitted;
    ULONG NumberOfTags;
    ULONG NumberOfEntries;
    ULONG NumberOfPseudoTags;
    ULONG PseudoTagGranularity;
    ULONG Reserved[5];
    PRTL_HEAP_TAG Tags;
    PRTL_HEAP_ENTRY Entries;
} RTL_HEAP_INFORMATION_V1, *PRTL_HEAP_INFORMATION_V1;

// Windows 11 > 22000
typedef struct _RTL_HEAP_INFORMATION_V2
{
    PVOID BaseAddress;
    ULONG Flags;
    USHORT EntryOverhead;
    USHORT CreatorBackTraceIndex;
    SIZE_T BytesAllocated;
    SIZE_T BytesCommitted;
    ULONG NumberOfTags;
    ULONG NumberOfEntries;
    ULONG NumberOfPseudoTags;
    ULONG PseudoTagGranularity;
    ULONG Reserved[5];
    PRTL_HEAP_TAG Tags;
    PRTL_HEAP_ENTRY Entries;
    ULONG64 HeapTag;
} RTL_HEAP_INFORMATION_V2, *PRTL_HEAP_INFORMATION_V2;

#define RTL_HEAP_SIGNATURE 0xFFEEFFEEUL
#define RTL_HEAP_SEGMENT_SIGNATURE 0xDDEEDDEEUL

typedef struct _RTL_PROCESS_HEAPS_V1
{
    ULONG NumberOfHeaps;
    RTL_HEAP_INFORMATION_V1 Heaps[1];
} RTL_PROCESS_HEAPS_V1, *PRTL_PROCESS_HEAPS_V1;

typedef struct _RTL_PROCESS_HEAPS_V2
{
    ULONG NumberOfHeaps;
    RTL_HEAP_INFORMATION_V2 Heaps[1];
} RTL_PROCESS_HEAPS_V2, *PRTL_PROCESS_HEAPS_V2;

typedef NTSTATUS (NTAPI *PRTL_HEAP_COMMIT_ROUTINE)(
    _In_ PVOID Base,
    _Inout_ PVOID *CommitAddress,
    _Inout_ PSIZE_T CommitSize
    );

typedef struct _RTL_HEAP_PARAMETERS
{
    ULONG Length;
    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;
    SIZE_T MaximumAllocationSize;
    SIZE_T VirtualMemoryThreshold;
    SIZE_T InitialCommit;
    SIZE_T InitialReserve;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
    SIZE_T Reserved[2];
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;

#define HEAP_SETTABLE_USER_VALUE 0x00000100
#define HEAP_SETTABLE_USER_FLAG1 0x00000200
#define HEAP_SETTABLE_USER_FLAG2 0x00000400
#define HEAP_SETTABLE_USER_FLAG3 0x00000800
#define HEAP_SETTABLE_USER_FLAGS 0x00000e00

#define HEAP_CLASS_0 0x00000000 // Process heap
#define HEAP_CLASS_1 0x00001000 // Private heap
#define HEAP_CLASS_2 0x00002000 // Kernel heap
#define HEAP_CLASS_3 0x00003000 // GDI heap
#define HEAP_CLASS_4 0x00004000 // User heap
#define HEAP_CLASS_5 0x00005000 // Console heap
#define HEAP_CLASS_6 0x00006000 // User desktop heap
#define HEAP_CLASS_7 0x00007000 // CSR shared heap
#define HEAP_CLASS_8 0x00008000 // CSR port heap
#define HEAP_CLASS_MASK 0x0000f000

_Must_inspect_result_
NTSYSAPI
PVOID
NTAPI
RtlCreateHeap(
    _In_ ULONG Flags,
    _In_opt_ PVOID HeapBase,
    _In_opt_ SIZE_T ReserveSize,
    _In_opt_ SIZE_T CommitSize,
    _In_opt_ PVOID Lock,
    _In_opt_ PRTL_HEAP_PARAMETERS Parameters
    );

NTSYSAPI
PVOID
NTAPI
RtlDestroyHeap(
    _In_ _Post_invalid_ PVOID HeapHandle
    );

_Must_inspect_result_
_Ret_maybenull_
_Post_writable_byte_size_(Size)
NTSYSAPI
PVOID
NTAPI
RtlAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_opt_ ULONG Flags,
    _In_ SIZE_T Size
    );

#if (PHNT_VERSION >= PHNT_WIN8)
_Success_(return != 0)
NTSYSAPI
LOGICAL
NTAPI
RtlFreeHeap(
    _In_ PVOID HeapHandle,
    _In_opt_ ULONG Flags,
    _Frees_ptr_opt_ PVOID BaseAddress
    );
#else
_Success_(return)
NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHeap(
    _In_ PVOID HeapHandle,
    _In_opt_ ULONG Flags,
    _Frees_ptr_opt_ PVOID BaseAddress
    );
#endif

NTSYSAPI
SIZE_T
NTAPI
RtlSizeHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlZeroHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags
    );

NTSYSAPI
VOID
NTAPI
RtlProtectHeap(
    _In_ PVOID HeapHandle,
    _In_ BOOLEAN MakeReadOnly
    );

#define RtlProcessHeap() (NtCurrentPeb()->ProcessHeap)

NTSYSAPI
BOOLEAN
NTAPI
RtlLockHeap(
    _In_ PVOID HeapHandle
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlUnlockHeap(
    _In_ PVOID HeapHandle
    );

NTSYSAPI
PVOID
NTAPI
RtlReAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _Frees_ptr_opt_ PVOID BaseAddress,
    _In_ SIZE_T Size
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlGetUserInfoHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress,
    _Out_opt_ PVOID *UserValue,
    _Out_opt_ PULONG UserFlags
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlSetUserValueHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress,
    _In_ PVOID UserValue
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlSetUserFlagsHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress,
    _In_ ULONG UserFlagsReset,
    _In_ ULONG UserFlagsSet
    );

typedef struct _RTL_HEAP_TAG_INFO
{
    ULONG NumberOfAllocations;
    ULONG NumberOfFrees;
    SIZE_T BytesAllocated;
} RTL_HEAP_TAG_INFO, *PRTL_HEAP_TAG_INFO;

#define RTL_HEAP_MAKE_TAG HEAP_MAKE_TAG_FLAGS

NTSYSAPI
ULONG
NTAPI
RtlCreateTagHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_opt_ PWSTR TagPrefix,
    _In_ PWSTR TagNames
    );

NTSYSAPI
PWSTR
NTAPI
RtlQueryTagHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ USHORT TagIndex,
    _In_ BOOLEAN ResetCounters,
    _Out_opt_ PRTL_HEAP_TAG_INFO TagInfo
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlExtendHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID Base,
    _In_ SIZE_T Size
    );

NTSYSAPI
SIZE_T
NTAPI
RtlCompactHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlValidateHeap(
    _In_opt_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlValidateProcessHeaps(
    VOID
    );

NTSYSAPI
ULONG
NTAPI
RtlGetProcessHeaps(
    _In_ ULONG NumberOfHeaps,
    _Out_ PVOID *ProcessHeaps
    );

typedef NTSTATUS (NTAPI *PRTL_ENUM_HEAPS_ROUTINE)(
    _In_ PVOID HeapHandle,
    _In_ PVOID Parameter
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlEnumProcessHeaps(
    _In_ PRTL_ENUM_HEAPS_ROUTINE EnumRoutine,
    _In_ PVOID Parameter
    );

typedef struct _RTL_HEAP_USAGE_ENTRY
{
    struct _RTL_HEAP_USAGE_ENTRY *Next;
    PVOID Address;
    SIZE_T Size;
    USHORT AllocatorBackTraceIndex;
    USHORT TagIndex;
} RTL_HEAP_USAGE_ENTRY, *PRTL_HEAP_USAGE_ENTRY;

typedef struct _RTL_HEAP_USAGE
{
    ULONG Length;
    SIZE_T BytesAllocated;
    SIZE_T BytesCommitted;
    SIZE_T BytesReserved;
    SIZE_T BytesReservedMaximum;
    PRTL_HEAP_USAGE_ENTRY Entries;
    PRTL_HEAP_USAGE_ENTRY AddedEntries;
    PRTL_HEAP_USAGE_ENTRY RemovedEntries;
    ULONG_PTR Reserved[8];
} RTL_HEAP_USAGE, *PRTL_HEAP_USAGE;

#define HEAP_USAGE_ALLOCATED_BLOCKS HEAP_REALLOC_IN_PLACE_ONLY
#define HEAP_USAGE_FREE_BUFFER HEAP_ZERO_MEMORY

NTSYSAPI
NTSTATUS
NTAPI
RtlUsageHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _Inout_ PRTL_HEAP_USAGE Usage
    );

typedef struct _RTL_HEAP_WALK_ENTRY
{
    PVOID DataAddress;
    SIZE_T DataSize;
    UCHAR OverheadBytes;
    UCHAR SegmentIndex;
    USHORT Flags;
    union
    {
        struct
        {
            SIZE_T Settable;
            USHORT TagIndex;
            USHORT AllocatorBackTraceIndex;
            ULONG Reserved[2];
        } Block;
        struct
        {
            ULONG CommittedSize;
            ULONG UnCommittedSize;
            PVOID FirstEntry;
            PVOID LastEntry;
        } Segment;
    };
} RTL_HEAP_WALK_ENTRY, *PRTL_HEAP_WALK_ENTRY;

NTSYSAPI
NTSTATUS
NTAPI
RtlWalkHeap(
    _In_ PVOID HeapHandle,
    _Inout_ PRTL_HEAP_WALK_ENTRY Entry
    );

// HEAP_INFORMATION_CLASS
#define HeapCompatibilityInformation 0x0 // q; s: ULONG
#define HeapEnableTerminationOnCorruption 0x1 // q; s: NULL
#define HeapExtendedInformation 0x2 // q; s: HEAP_EXTENDED_INFORMATION
#define HeapOptimizeResources 0x3 // q; s: HEAP_OPTIMIZE_RESOURCES_INFORMATION
#define HeapTaggingInformation 0x4
#define HeapStackDatabase 0x5 // q: RTL_HEAP_STACK_QUERY; s: RTL_HEAP_STACK_CONTROL
#define HeapMemoryLimit 0x6 // since 19H2
#define HeapTag 0x7 // since 20H1
#define HeapDetailedFailureInformation 0x80000001
#define HeapSetDebuggingInformation 0x80000002 // q; s: HEAP_DEBUGGING_INFORMATION

typedef enum _HEAP_COMPATIBILITY_MODE
{
    HEAP_COMPATIBILITY_STANDARD = 0UL,
    HEAP_COMPATIBILITY_LAL = 1UL,
    HEAP_COMPATIBILITY_LFH = 2UL,
} HEAP_COMPATIBILITY_MODE;

typedef struct _RTLP_TAG_INFO
{
    GUID Id;
    ULONG_PTR CurrentAllocatedBytes;
} RTLP_TAG_INFO, *PRTLP_TAG_INFO;

typedef struct _RTLP_HEAP_TAGGING_INFO
{
    USHORT Version;
    USHORT Flags;
    PVOID ProcessHandle;
    ULONG_PTR EntriesCount;
    RTLP_TAG_INFO Entries[1];
} RTLP_HEAP_TAGGING_INFO, *PRTLP_HEAP_TAGGING_INFO;

typedef struct _PROCESS_HEAP_INFORMATION
{
    SIZE_T ReserveSize;
    SIZE_T CommitSize;
    ULONG NumberOfHeaps;
    ULONG_PTR FirstHeapInformationOffset;
} PROCESS_HEAP_INFORMATION, *PPROCESS_HEAP_INFORMATION;

typedef struct _HEAP_REGION_INFORMATION
{
    PVOID Address;
    SIZE_T ReserveSize;
    SIZE_T CommitSize;
    ULONG_PTR FirstRangeInformationOffset;
    ULONG_PTR NextRegionInformationOffset;
} HEAP_REGION_INFORMATION, *PHEAP_REGION_INFORMATION;

typedef struct _HEAP_RANGE_INFORMATION
{
    PVOID Address;
    SIZE_T Size;
    ULONG Type;
    ULONG Protection;
    ULONG_PTR FirstBlockInformationOffset;
    ULONG_PTR NextRangeInformationOffset;
} HEAP_RANGE_INFORMATION, *PHEAP_RANGE_INFORMATION;

typedef struct _HEAP_BLOCK_INFORMATION
{
    PVOID Address;
    ULONG Flags;
    SIZE_T DataSize;
    ULONG_PTR OverheadSize;
    ULONG_PTR NextBlockInformationOffset;
} HEAP_BLOCK_INFORMATION, *PHEAP_BLOCK_INFORMATION;

typedef struct _HEAP_INFORMATION
{
    PVOID Address;
    ULONG Mode;
    SIZE_T ReserveSize;
    SIZE_T CommitSize;
    ULONG_PTR FirstRegionInformationOffset;
    ULONG_PTR NextHeapInformationOffset;
} HEAP_INFORMATION, *PHEAP_INFORMATION;

typedef struct _SEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION
{
    SIZE_T SegmentReserveSize;
    SIZE_T SegmentCommitSize;
    ULONG_PTR SegmentCount;
    SIZE_T AllocatedSize;
    SIZE_T LargeAllocReserveSize;
    SIZE_T LargeAllocCommitSize;
} SEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION, *PSEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION;

#define HeapPerformanceCountersInformationStandardHeapVersion 0x1
#define HeapPerformanceCountersInformationSegmentHeapVersion 0x2

typedef struct _HEAP_PERFORMANCE_COUNTERS_INFORMATION
{
    ULONG Size;
    ULONG Version;
    ULONG HeapIndex;
    ULONG LastHeapIndex;
    PVOID BaseAddress;
    SIZE_T ReserveSize;
    SIZE_T CommitSize;
    ULONG SegmentCount;
    SIZE_T LargeUCRMemory;
    ULONG UCRLength;
    SIZE_T AllocatedSpace;
    SIZE_T FreeSpace;
    ULONG FreeListLength;
    ULONG Contention;
    ULONG VirtualBlocks;
    ULONG CommitRate;
    ULONG DecommitRate;
    SEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION SegmentHeapPerfInformation; // since WIN8
} HEAP_PERFORMANCE_COUNTERS_INFORMATION, *PHEAP_PERFORMANCE_COUNTERS_INFORMATION;

typedef struct _HEAP_INFORMATION_ITEM
{
    ULONG Level;
    SIZE_T Size;
    union
    {
        PROCESS_HEAP_INFORMATION ProcessHeapInformation;
        HEAP_INFORMATION HeapInformation;
        HEAP_REGION_INFORMATION HeapRegionInformation;
        HEAP_RANGE_INFORMATION HeapRangeInformation;
        HEAP_BLOCK_INFORMATION HeapBlockInformation;
        HEAP_PERFORMANCE_COUNTERS_INFORMATION HeapPerfInformation;
        ULONG_PTR DynamicStart;
    };
} HEAP_INFORMATION_ITEM, *PHEAP_INFORMATION_ITEM;

typedef NTSTATUS (NTAPI *PRTL_HEAP_EXTENDED_ENUMERATION_ROUTINE)(
    _In_ PHEAP_INFORMATION_ITEM Information,
    _In_ PVOID Context
    );

// HEAP_EXTENDED_INFORMATION Level
#define HeapExtendedProcessHeapInformationLevel 0x1
#define HeapExtendedHeapInformationLevel 0x2
#define HeapExtendedHeapRegionInformationLevel 0x3
#define HeapExtendedHeapRangeInformationLevel 0x4
#define HeapExtendedHeapBlockInformationLevel 0x5
#define HeapExtendedHeapHeapPerfInformationLevel 0x80000000

typedef struct _HEAP_EXTENDED_INFORMATION
{
    HANDLE ProcessHandle;
    PVOID HeapHandle;
    ULONG Level;
    PRTL_HEAP_EXTENDED_ENUMERATION_ROUTINE CallbackRoutine;
    PVOID CallbackContext;
    union
    {
        PROCESS_HEAP_INFORMATION ProcessHeapInformation;
        HEAP_INFORMATION HeapInformation;
    };
} HEAP_EXTENDED_INFORMATION, *PHEAP_EXTENDED_INFORMATION;

// rev
typedef NTSTATUS (NTAPI *RTL_HEAP_STACK_WRITE_ROUTINE)(
    _In_ PVOID Information, // TODO: 3 missing structures (dmex)
    _In_ ULONG Size,
    _In_ PVOID Context
    );

// rev
typedef struct _RTLP_HEAP_STACK_TRACE_SERIALIZATION_INIT
{
    ULONG Count;
    ULONG Total;
    ULONG Flags;
} RTLP_HEAP_STACK_TRACE_SERIALIZATION_INIT, *PRTLP_HEAP_STACK_TRACE_SERIALIZATION_INIT;

// rev
typedef struct _RTLP_HEAP_STACK_TRACE_SERIALIZATION_HEADER
{
    USHORT Version;
    USHORT PointerSize;
    PVOID Heap;
    SIZE_T TotalCommit;
    SIZE_T TotalReserve;
} RTLP_HEAP_STACK_TRACE_SERIALIZATION_HEADER, *PRTLP_HEAP_STACK_TRACE_SERIALIZATION_HEADER;

// rev
typedef struct _RTLP_HEAP_STACK_TRACE_SERIALIZATION_ALLOCATION
{
    PVOID Address;
    ULONG Flags;
    SIZE_T DataSize;
} RTLP_HEAP_STACK_TRACE_SERIALIZATION_ALLOCATION, *PRTLP_HEAP_STACK_TRACE_SERIALIZATION_ALLOCATION;

// rev
typedef struct _RTLP_HEAP_STACK_TRACE_SERIALIZATION_STACKFRAME
{
    PVOID StackFrame[8];
} RTLP_HEAP_STACK_TRACE_SERIALIZATION_STACKFRAME, *PRTLP_HEAP_STACK_TRACE_SERIALIZATION_STACKFRAME;

#define HEAP_STACK_QUERY_VERSION 0x2

typedef struct _RTL_HEAP_STACK_QUERY
{
    ULONG Version;
    HANDLE ProcessHandle;
    RTL_HEAP_STACK_WRITE_ROUTINE WriteRoutine;
    PVOID SerializationContext;
    UCHAR QueryLevel;
    UCHAR Flags;
} RTL_HEAP_STACK_QUERY, *PRTL_HEAP_STACK_QUERY;

#define HEAP_STACK_CONTROL_VERSION 0x1
#define HEAP_STACK_CONTROL_FLAGS_STACKTRACE_ENABLE 0x1
#define HEAP_STACK_CONTROL_FLAGS_STACKTRACE_DISABLE 0x2

typedef struct _RTL_HEAP_STACK_CONTROL
{
    USHORT Version;
    USHORT Flags;
    HANDLE ProcessHandle;
} RTL_HEAP_STACK_CONTROL, *PRTL_HEAP_STACK_CONTROL;

// rev
typedef NTSTATUS (NTAPI *PRTL_HEAP_DEBUGGING_INTERCEPTOR_ROUTINE)(
    _In_ PVOID HeapHandle,
    _In_ ULONG Action,
    _In_ ULONG StackFramesToCapture,
    _In_ PVOID *StackTrace
    );

// rev
typedef NTSTATUS (NTAPI *PRTL_HEAP_LEAK_ENUMERATION_ROUTINE)(
    _In_ LONG Reserved,
    _In_ PVOID HeapHandle,
    _In_ PVOID BaseAddress,
    _In_ SIZE_T BlockSize,
    _In_ ULONG StackTraceDepth,
    _In_ PVOID *StackTrace
    );

// symbols
typedef struct _HEAP_DEBUGGING_INFORMATION
{
    PRTL_HEAP_DEBUGGING_INTERCEPTOR_ROUTINE InterceptorFunction;
    USHORT InterceptorValue;
    ULONG ExtendedOptions;
    ULONG StackTraceDepth;
    SIZE_T MinTotalBlockSize;
    SIZE_T MaxTotalBlockSize;
    PRTL_HEAP_LEAK_ENUMERATION_ROUTINE HeapLeakEnumerationRoutine;
} HEAP_DEBUGGING_INFORMATION, *PHEAP_DEBUGGING_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryHeapInformation(
    _In_opt_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _Out_opt_ PVOID HeapInformation,
    _In_opt_ SIZE_T HeapInformationLength,
    _Out_opt_ PSIZE_T ReturnLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetHeapInformation(
    _In_opt_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _In_opt_ PVOID HeapInformation,
    _In_opt_ SIZE_T HeapInformationLength
    );

NTSYSAPI
ULONG
NTAPI
RtlMultipleAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ SIZE_T Size,
    _In_ ULONG Count,
    _Out_ PVOID *Array
    );

NTSYSAPI
ULONG
NTAPI
RtlMultipleFreeHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ ULONG Count,
    _In_ PVOID *Array
    );

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSAPI
VOID
NTAPI
RtlDetectHeapLeaks(
    VOID
    );
#endif

NTSYSAPI
VOID
NTAPI
RtlFlushHeaps(
    VOID
    );

// Memory zones

// begin_private

typedef struct _RTL_MEMORY_ZONE_SEGMENT
{
    struct _RTL_MEMORY_ZONE_SEGMENT *NextSegment;
    SIZE_T Size;
    PVOID Next;
    PVOID Limit;
} RTL_MEMORY_ZONE_SEGMENT, *PRTL_MEMORY_ZONE_SEGMENT;

typedef struct _RTL_MEMORY_ZONE
{
    RTL_MEMORY_ZONE_SEGMENT Segment;
    RTL_SRWLOCK Lock;
    ULONG LockCount;
    PRTL_MEMORY_ZONE_SEGMENT FirstSegment;
} RTL_MEMORY_ZONE, *PRTL_MEMORY_ZONE;

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateMemoryZone(
    _Out_ PVOID *MemoryZone,
    _In_ SIZE_T InitialSize,
    _Reserved_ ULONG Flags
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyMemoryZone(
    _In_ _Post_invalid_ PVOID MemoryZone
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateMemoryZone(
    _In_ PVOID MemoryZone,
    _In_ SIZE_T BlockSize,
    _Out_ PVOID *Block
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlResetMemoryZone(
    _In_ PVOID MemoryZone
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlLockMemoryZone(
    _In_ PVOID MemoryZone
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnlockMemoryZone(
    _In_ PVOID MemoryZone
    );

#endif

// end_private

// Memory block lookaside lists

// begin_private

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateMemoryBlockLookaside(
    _Out_ PVOID *MemoryBlockLookaside,
    _Reserved_ ULONG Flags,
    _In_ ULONG InitialSize,
    _In_ ULONG MinimumBlockSize,
    _In_ ULONG MaximumBlockSize
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyMemoryBlockLookaside(
    _In_ PVOID MemoryBlockLookaside
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateMemoryBlockLookaside(
    _In_ PVOID MemoryBlockLookaside,
    _In_ ULONG BlockSize,
    _Out_ PVOID *Block
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlFreeMemoryBlockLookaside(
    _In_ PVOID MemoryBlockLookaside,
    _In_ PVOID Block
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlExtendMemoryBlockLookaside(
    _In_ PVOID MemoryBlockLookaside,
    _In_ ULONG Increment
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlResetMemoryBlockLookaside(
    _In_ PVOID MemoryBlockLookaside
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlLockMemoryBlockLookaside(
    _In_ PVOID MemoryBlockLookaside
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnlockMemoryBlockLookaside(
    _In_ PVOID MemoryBlockLookaside
    );

#endif

// end_private

// Transactions

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
HANDLE
NTAPI
RtlGetCurrentTransaction(
    VOID
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
LOGICAL
NTAPI
RtlSetCurrentTransaction(
    _In_opt_ HANDLE TransactionHandle
    );
#endif

// LUIDs

FORCEINLINE BOOLEAN RtlIsEqualLuid( // RtlEqualLuid
    _In_ PLUID L1,
    _In_ PLUID L2
    )
{
    return L1->LowPart == L2->LowPart &&
        L1->HighPart == L2->HighPart;
}

FORCEINLINE BOOLEAN RtlIsZeroLuid(
    _In_ PLUID L1
    )
{
    return (L1->LowPart | L1->HighPart) == 0;
}

FORCEINLINE LUID RtlConvertLongToLuid(
    _In_ LONG Long
    )
{
    LUID tempLuid;
    LARGE_INTEGER tempLi;

    tempLi.QuadPart = Long;
    tempLuid.LowPart = tempLi.LowPart;
    tempLuid.HighPart = tempLi.HighPart;

    return tempLuid;
}

FORCEINLINE LUID RtlConvertUlongToLuid(
    _In_ ULONG Ulong
    )
{
    LUID tempLuid;

    tempLuid.LowPart = Ulong;
    tempLuid.HighPart = 0;

    return tempLuid;
}

NTSYSAPI
VOID
NTAPI
RtlCopyLuid(
    _Out_ PLUID DestinationLuid,
    _In_ PLUID SourceLuid
    );

// ros
NTSYSAPI
VOID
NTAPI
RtlCopyLuidAndAttributesArray(
    _In_ ULONG Count,
    _In_ PLUID_AND_ATTRIBUTES Src,
    _In_ PLUID_AND_ATTRIBUTES Dest
    );

// Byte swap routines.

#ifndef PHNT_RTL_BYTESWAP
#define RtlUshortByteSwap(_x) _byteswap_ushort((USHORT)(_x))
#define RtlUlongByteSwap(_x) _byteswap_ulong((_x))
#define RtlUlonglongByteSwap(_x) _byteswap_uint64((_x))
#else
NTSYSAPI
USHORT
FASTCALL
RtlUshortByteSwap(
    _In_ USHORT Source
    );

NTSYSAPI
ULONG
FASTCALL
RtlUlongByteSwap(
    _In_ ULONG Source
    );

NTSYSAPI
ULONGLONG
FASTCALL
RtlUlonglongByteSwap(
    _In_ ULONGLONG Source
    );
#endif

// Debugging

// private
typedef struct _RTL_PROCESS_VERIFIER_OPTIONS
{
    ULONG SizeStruct;
    ULONG Option;
    UCHAR OptionData[1];
} RTL_PROCESS_VERIFIER_OPTIONS, *PRTL_PROCESS_VERIFIER_OPTIONS;

// private
typedef struct _RTL_DEBUG_INFORMATION
{
    HANDLE SectionHandleClient;
    PVOID ViewBaseClient;
    PVOID ViewBaseTarget;
    ULONG_PTR ViewBaseDelta;
    HANDLE EventPairClient;
    HANDLE EventPairTarget;
    HANDLE TargetProcessId;
    HANDLE TargetThreadHandle;
    ULONG Flags;
    SIZE_T OffsetFree;
    SIZE_T CommitSize;
    SIZE_T ViewSize;
    union
    {
        struct _RTL_PROCESS_MODULES *Modules;
        struct _RTL_PROCESS_MODULE_INFORMATION_EX *ModulesEx;
    };
    struct _RTL_PROCESS_BACKTRACES *BackTraces;
    PVOID Heaps;
    struct _RTL_PROCESS_LOCKS *Locks;
    PVOID SpecificHeap;
    HANDLE TargetProcessHandle;
    PRTL_PROCESS_VERIFIER_OPTIONS VerifierOptions;
    PVOID ProcessHeap;
    HANDLE CriticalSectionHandle;
    HANDLE CriticalSectionOwnerThread;
    PVOID Reserved[4];
} RTL_DEBUG_INFORMATION, *PRTL_DEBUG_INFORMATION;

NTSYSAPI
PRTL_DEBUG_INFORMATION
NTAPI
RtlCreateQueryDebugBuffer(
    _In_opt_ ULONG MaximumCommit,
    _In_ BOOLEAN UseEventPair
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyQueryDebugBuffer(
    _In_ PRTL_DEBUG_INFORMATION Buffer
    );

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
PVOID
NTAPI
RtlCommitDebugInfo(
    _Inout_ PRTL_DEBUG_INFORMATION Buffer,
    _In_ SIZE_T Size
    );

// private
NTSYSAPI
VOID
NTAPI
RtlDeCommitDebugInfo(
    _Inout_ PRTL_DEBUG_INFORMATION Buffer,
    _In_ PVOID p,
    _In_ SIZE_T Size
    );

#endif

#define RTL_QUERY_PROCESS_MODULES 0x00000001
#define RTL_QUERY_PROCESS_BACKTRACES 0x00000002
#define RTL_QUERY_PROCESS_HEAP_SUMMARY 0x00000004
#define RTL_QUERY_PROCESS_HEAP_TAGS 0x00000008
#define RTL_QUERY_PROCESS_HEAP_ENTRIES 0x00000010
#define RTL_QUERY_PROCESS_LOCKS 0x00000020
#define RTL_QUERY_PROCESS_MODULES32 0x00000040
#define RTL_QUERY_PROCESS_VERIFIER_OPTIONS 0x00000080 // rev
#define RTL_QUERY_PROCESS_MODULESEX 0x00000100 // rev
#define RTL_QUERY_PROCESS_HEAP_SEGMENTS 0x00000200
#define RTL_QUERY_PROCESS_CS_OWNER 0x00000400 // rev
#define RTL_QUERY_PROCESS_NONINVASIVE 0x80000000

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryProcessDebugInformation(
    _In_ HANDLE UniqueProcessId,
    _In_ ULONG Flags,
    _Inout_ PRTL_DEBUG_INFORMATION Buffer
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSetProcessDebugInformation(
    _In_ HANDLE UniqueProcessId,
    _In_ ULONG Flags,
    _Inout_ PRTL_DEBUG_INFORMATION Buffer
    );

// Messages

NTSYSAPI
NTSTATUS
NTAPI
RtlFindMessage(
    _In_ PVOID DllHandle,
    _In_ ULONG MessageTableId,
    _In_ ULONG MessageLanguageId,
    _In_ ULONG MessageId,
    _Out_ PMESSAGE_RESOURCE_ENTRY *MessageEntry
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlFormatMessage(
    _In_ PWSTR MessageFormat,
    _In_ ULONG MaximumWidth,
    _In_ BOOLEAN IgnoreInserts,
    _In_ BOOLEAN ArgumentsAreAnsi,
    _In_ BOOLEAN ArgumentsAreAnArray,
    _In_ va_list *Arguments,
    _Out_writes_bytes_to_(Length, *ReturnLength) PWSTR Buffer,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength
    );

typedef struct _PARSE_MESSAGE_CONTEXT
{
    ULONG fFlags;
    ULONG cwSavColumn;
    SIZE_T iwSrc;
    SIZE_T iwDst;
    SIZE_T iwDstSpace;
    va_list lpvArgStart;
} PARSE_MESSAGE_CONTEXT, *PPARSE_MESSAGE_CONTEXT;

#define INIT_PARSE_MESSAGE_CONTEXT(ctx) { (ctx)->fFlags = 0; }
#define TEST_PARSE_MESSAGE_CONTEXT_FLAG(ctx, flag) ((ctx)->fFlags & (flag))
#define SET_PARSE_MESSAGE_CONTEXT_FLAG(ctx, flag) ((ctx)->fFlags |= (flag))
#define CLEAR_PARSE_MESSAGE_CONTEXT_FLAG(ctx, flag) ((ctx)->fFlags &= ~(flag))

NTSYSAPI
NTSTATUS
NTAPI
RtlFormatMessageEx(
    _In_ PWSTR MessageFormat,
    _In_ ULONG MaximumWidth,
    _In_ BOOLEAN IgnoreInserts,
    _In_ BOOLEAN ArgumentsAreAnsi,
    _In_ BOOLEAN ArgumentsAreAnArray,
    _In_ va_list *Arguments,
    _Out_writes_bytes_to_(Length, *ReturnLength) PWSTR Buffer,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength,
    _Out_opt_ PPARSE_MESSAGE_CONTEXT ParseContext
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetFileMUIPath(
    _In_ ULONG Flags,
    _In_ PCWSTR FilePath,
    _Inout_opt_ PWSTR Language,
    _Inout_ PULONG LanguageLength,
    _Out_opt_ PWSTR FileMUIPath,
    _Inout_ PULONG FileMUIPathLength,
    _Inout_ PULONGLONG Enumerator
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlLoadString(
    _In_ PVOID DllHandle,
    _In_ ULONG StringId,
    _In_opt_ PCWSTR StringLanguage,
    _In_ ULONG Flags,
    _Out_ PCWSTR *ReturnString,
    _Out_opt_ PUSHORT ReturnStringLen,
    _Out_writes_(ReturnLanguageLen) PWSTR ReturnLanguageName,
    _Inout_opt_ PULONG ReturnLanguageLen
    );

// Errors

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosError(
    _In_ NTSTATUS Status
    );

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosErrorNoTeb(
    _In_ NTSTATUS Status
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetLastNtStatus(
    VOID
    );

NTSYSAPI
LONG
NTAPI
RtlGetLastWin32Error(
    VOID
    );

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
    _In_ NTSTATUS Status
    );

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32Error(
    _In_ LONG Win32Error
    );

NTSYSAPI
VOID
NTAPI
RtlRestoreLastWin32Error(
    _In_ LONG Win32Error
    );

#define RTL_ERRORMODE_FAILCRITICALERRORS 0x0010
#define RTL_ERRORMODE_NOGPFAULTERRORBOX 0x0020
#define RTL_ERRORMODE_NOOPENFILEERRORBOX 0x0040

NTSYSAPI
ULONG
NTAPI
RtlGetThreadErrorMode(
    VOID
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetThreadErrorMode(
    _In_ ULONG NewMode,
    _Out_opt_ PULONG OldMode
    );

// Windows Error Reporting

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlReportException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord,
    _In_ ULONG Flags
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlReportExceptionEx(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord,
    _In_ ULONG Flags,
    _In_ PLARGE_INTEGER Timeout
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlWerpReportException(
    _In_ ULONG ProcessId,
    _In_ HANDLE CrashReportSharedMem,
    _In_ ULONG Flags,
    _Out_ PHANDLE CrashVerticalProcessHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlReportSilentProcessExit(
    _In_ HANDLE ProcessHandle,
    _In_ NTSTATUS ExitStatus
    );
#endif

// Random

NTSYSAPI
ULONG
NTAPI
RtlUniform(
    _Inout_ PULONG Seed
    );

_Ret_range_(<=, MAXLONG)
NTSYSAPI
ULONG
NTAPI
RtlRandom(
    _Inout_ PULONG Seed
    );

_Ret_range_(<=, MAXLONG)
NTSYSAPI
ULONG
NTAPI
RtlRandomEx(
    _Inout_ PULONG Seed
    );

#define RTL_IMPORT_TABLE_HASH_REVISION 1

NTSYSAPI
NTSTATUS
NTAPI
RtlComputeImportTableHash(
    _In_ HANDLE FileHandle,
    _Out_writes_bytes_(16) PCHAR Hash,
    _In_ ULONG ImportTableHashRevision // must be 1
    );

// Integer conversion

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToChar(
    _In_ ULONG Value,
    _In_opt_ ULONG Base,
    _In_ LONG OutputLength, // negative to pad to width
    _Out_ PSTR String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCharToInteger(
    _In_ PCSTR String,
    _In_opt_ ULONG Base,
    _Out_ PULONG Value
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlLargeIntegerToChar(
    _In_ PLARGE_INTEGER Value,
    _In_opt_ ULONG Base,
    _In_ LONG OutputLength,
    _Out_ PSTR String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString(
    _In_ ULONG Value,
    _In_opt_ ULONG Base,
    _Inout_ PUNICODE_STRING String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlInt64ToUnicodeString(
    _In_ ULONGLONG Value,
    _In_opt_ ULONG Base,
    _Inout_ PUNICODE_STRING String
    );

#ifdef _WIN64
#define RtlIntPtrToUnicodeString(Value, Base, String) RtlInt64ToUnicodeString(Value, Base, String)
#else
#define RtlIntPtrToUnicodeString(Value, Base, String) RtlIntegerToUnicodeString(Value, Base, String)
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToInteger(
    _In_ PUNICODE_STRING String,
    _In_opt_ ULONG Base,
    _Out_ PULONG Value
    );

// IPv4/6 conversion

struct in_addr;
struct in6_addr;

NTSYSAPI
PWSTR
NTAPI
RtlIpv4AddressToStringW(
    _In_ const struct in_addr *Address,
    _Out_writes_(16) PWSTR AddressString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4AddressToStringExW(
    _In_ const struct in_addr *Address,
    _In_ USHORT Port,
    _Out_writes_to_(*AddressStringLength, *AddressStringLength) PWSTR AddressString,
    _Inout_ PULONG AddressStringLength
    );

NTSYSAPI
PWSTR
NTAPI
RtlIpv6AddressToStringW(
    _In_ const struct in6_addr *Address,
    _Out_writes_(46) PWSTR AddressString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6AddressToStringExW(
    _In_ const struct in6_addr *Address,
    _In_ ULONG ScopeId,
    _In_ USHORT Port,
    _Out_writes_to_(*AddressStringLength, *AddressStringLength) PWSTR AddressString,
    _Inout_ PULONG AddressStringLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4StringToAddressW(
    _In_ PCWSTR AddressString,
    _In_ BOOLEAN Strict,
    _Out_ LPCWSTR *Terminator,
    _Out_ struct in_addr *Address
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4StringToAddressExW(
    _In_ PCWSTR AddressString,
    _In_ BOOLEAN Strict,
    _Out_ struct in_addr *Address,
    _Out_ PUSHORT Port
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6StringToAddressW(
    _In_ PCWSTR AddressString,
    _Out_ PCWSTR *Terminator,
    _Out_ struct in6_addr *Address
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6StringToAddressExW(
    _In_ PCWSTR AddressString,
    _Out_ struct in6_addr *Address,
    _Out_ PULONG ScopeId,
    _Out_ PUSHORT Port
    );

#define RtlIpv4AddressToString RtlIpv4AddressToStringW
#define RtlIpv4AddressToStringEx RtlIpv4AddressToStringExW
#define RtlIpv6AddressToString RtlIpv6AddressToStringW
#define RtlIpv6AddressToStringEx RtlIpv6AddressToStringExW
#define RtlIpv4StringToAddress RtlIpv4StringToAddressW
#define RtlIpv4StringToAddressEx RtlIpv4StringToAddressExW
#define RtlIpv6StringToAddress RtlIpv6StringToAddressW
#define RtlIpv6StringToAddressEx RtlIpv6StringToAddressExW

// Time

typedef struct _TIME_FIELDS
{
    CSHORT Year; // 1601...
    CSHORT Month; // 1..12
    CSHORT Day; // 1..31
    CSHORT Hour; // 0..23
    CSHORT Minute; // 0..59
    CSHORT Second; // 0..59
    CSHORT Milliseconds; // 0..999
    CSHORT Weekday; // 0..6 = Sunday..Saturday
} TIME_FIELDS, *PTIME_FIELDS;

NTSYSAPI
BOOLEAN
NTAPI
RtlCutoverTimeToSystemTime(
    _In_ PTIME_FIELDS CutoverTime,
    _Out_ PLARGE_INTEGER SystemTime,
    _In_ PLARGE_INTEGER CurrentSystemTime,
    _In_ BOOLEAN ThisYear
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSystemTimeToLocalTime(
    _In_ PLARGE_INTEGER SystemTime,
    _Out_ PLARGE_INTEGER LocalTime
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlLocalTimeToSystemTime(
    _In_ PLARGE_INTEGER LocalTime,
    _Out_ PLARGE_INTEGER SystemTime
    );

NTSYSAPI
VOID
NTAPI
RtlTimeToElapsedTimeFields(
    _In_ PLARGE_INTEGER Time,
    _Out_ PTIME_FIELDS TimeFields
    );

NTSYSAPI
VOID
NTAPI
RtlTimeToTimeFields(
    _In_ PLARGE_INTEGER Time,
    _Out_ PTIME_FIELDS TimeFields
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime(
    _In_ PTIME_FIELDS TimeFields, // Weekday is ignored
    _Out_ PLARGE_INTEGER Time
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1980(
    _In_ PLARGE_INTEGER Time,
    _Out_ PULONG ElapsedSeconds
    );

NTSYSAPI
VOID
NTAPI
RtlSecondsSince1980ToTime(
    _In_ ULONG ElapsedSeconds,
    _Out_ PLARGE_INTEGER Time
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1970(
    _In_ PLARGE_INTEGER Time,
    _Out_ PULONG ElapsedSeconds
    );

NTSYSAPI
VOID
NTAPI
RtlSecondsSince1970ToTime(
    _In_ ULONG ElapsedSeconds,
    _Out_ PLARGE_INTEGER Time
    );

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSAPI
ULONGLONG
NTAPI
RtlGetSystemTimePrecise(
    VOID
    );
#endif

#if (PHNT_VERSION >= PHNT_21H2)
NTSYSAPI
KSYSTEM_TIME
NTAPI
RtlGetSystemTimeAndBias(
    _Out_ KSYSTEM_TIME TimeZoneBias,
    _Out_opt_ PLARGE_INTEGER TimeZoneBiasEffectiveStart,
    _Out_opt_ PLARGE_INTEGER TimeZoneBiasEffectiveEnd
    );
#endif

#if (PHNT_VERSION >= PHNT_THRESHOLD)
NTSYSAPI
LARGE_INTEGER
NTAPI
RtlGetInterruptTimePrecise(
    _Out_ PLARGE_INTEGER PerformanceCounter
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSAPI
BOOLEAN
NTAPI
RtlQueryUnbiasedInterruptTime(
    _Out_ PLARGE_INTEGER InterruptTime
    );
#endif

// Time zones

typedef struct _RTL_TIME_ZONE_INFORMATION
{
    LONG Bias;
    WCHAR StandardName[32];
    TIME_FIELDS StandardStart;
    LONG StandardBias;
    WCHAR DaylightName[32];
    TIME_FIELDS DaylightStart;
    LONG DaylightBias;
} RTL_TIME_ZONE_INFORMATION, *PRTL_TIME_ZONE_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryTimeZoneInformation(
    _Out_ PRTL_TIME_ZONE_INFORMATION TimeZoneInformation
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetTimeZoneInformation(
    _In_ PRTL_TIME_ZONE_INFORMATION TimeZoneInformation
    );

// Bitmaps

typedef struct _RTL_BITMAP
{
    ULONG SizeOfBitMap;
    PULONG Buffer;
} RTL_BITMAP, *PRTL_BITMAP;

NTSYSAPI
VOID
NTAPI
RtlInitializeBitMap(
    _Out_ PRTL_BITMAP BitMapHeader,
    _In_ PULONG BitMapBuffer,
    _In_ ULONG SizeOfBitMap
    );

#if (PHNT_MODE == PHNT_MODE_KERNEL || PHNT_VERSION >= PHNT_WIN8)
NTSYSAPI
VOID
NTAPI
RtlClearBit(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(<, BitMapHeader->SizeOfBitMap) ULONG BitNumber
    );
#endif

#if (PHNT_MODE == PHNT_MODE_KERNEL || PHNT_VERSION >= PHNT_WIN8)
NTSYSAPI
VOID
NTAPI
RtlSetBit(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(<, BitMapHeader->SizeOfBitMap) ULONG BitNumber
    );
#endif

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlTestBit(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(<, BitMapHeader->SizeOfBitMap) ULONG BitNumber
    );

NTSYSAPI
VOID
NTAPI
RtlClearAllBits(
    _In_ PRTL_BITMAP BitMapHeader
    );

NTSYSAPI
VOID
NTAPI
RtlSetAllBits(
    _In_ PRTL_BITMAP BitMapHeader
    );

_Success_(return != -1)
_Check_return_
NTSYSAPI
ULONG
NTAPI
RtlFindClearBits(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG NumberToFind,
    _In_ ULONG HintIndex
    );

_Success_(return != -1)
_Check_return_
NTSYSAPI
ULONG
NTAPI
RtlFindSetBits(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG NumberToFind,
    _In_ ULONG HintIndex
    );

_Success_(return != -1)
NTSYSAPI
ULONG
NTAPI
RtlFindClearBitsAndSet(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG NumberToFind,
    _In_ ULONG HintIndex
    );

_Success_(return != -1)
NTSYSAPI
ULONG
NTAPI
RtlFindSetBitsAndClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG NumberToFind,
    _In_ ULONG HintIndex
    );

NTSYSAPI
VOID
NTAPI
RtlClearBits(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(0, BitMapHeader->SizeOfBitMap - NumberToClear) ULONG StartingIndex,
    _In_range_(0, BitMapHeader->SizeOfBitMap - StartingIndex) ULONG NumberToClear
    );

NTSYSAPI
VOID
NTAPI
RtlSetBits(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(0, BitMapHeader->SizeOfBitMap - NumberToSet) ULONG StartingIndex,
    _In_range_(0, BitMapHeader->SizeOfBitMap - StartingIndex) ULONG NumberToSet
    );

NTSYSAPI
CCHAR
NTAPI
RtlFindMostSignificantBit(
    _In_ ULONGLONG Set
    );

NTSYSAPI
CCHAR
NTAPI
RtlFindLeastSignificantBit(
    _In_ ULONGLONG Set
    );

typedef struct _RTL_BITMAP_RUN
{
    ULONG StartingIndex;
    ULONG NumberOfBits;
} RTL_BITMAP_RUN, *PRTL_BITMAP_RUN;

NTSYSAPI
ULONG
NTAPI
RtlFindClearRuns(
    _In_ PRTL_BITMAP BitMapHeader,
    _Out_writes_to_(SizeOfRunArray, return) PRTL_BITMAP_RUN RunArray,
    _In_range_(>, 0) ULONG SizeOfRunArray,
    _In_ BOOLEAN LocateLongestRuns
    );

NTSYSAPI
ULONG
NTAPI
RtlFindLongestRunClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _Out_ PULONG StartingIndex
    );

NTSYSAPI
ULONG
NTAPI
RtlFindFirstRunClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _Out_ PULONG StartingIndex
    );

_Check_return_
FORCEINLINE
BOOLEAN
RtlCheckBit(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(<, BitMapHeader->SizeOfBitMap) ULONG BitPosition
    )
{
#ifdef _WIN64
    return BitTest64((LONG64 const *)BitMapHeader->Buffer, (LONG64)BitPosition);
#else
    return (((PLONG)BitMapHeader->Buffer)[BitPosition / 32] >> (BitPosition % 32)) & 0x1;
#endif
}

NTSYSAPI
ULONG
NTAPI
RtlNumberOfClearBits(
    _In_ PRTL_BITMAP BitMapHeader
    );

NTSYSAPI
ULONG
NTAPI
RtlNumberOfSetBits(
    _In_ PRTL_BITMAP BitMapHeader
    );

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG StartingIndex,
    _In_ ULONG Length
    );

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsSet(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG StartingIndex,
    _In_ ULONG Length
    );

NTSYSAPI
ULONG
NTAPI
RtlFindNextForwardRunClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG FromIndex,
    _Out_ PULONG StartingRunIndex
    );

NTSYSAPI
ULONG
NTAPI
RtlFindLastBackwardRunClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG FromIndex,
    _Out_ PULONG StartingRunIndex
    );

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
ULONG
NTAPI
RtlNumberOfSetBitsUlongPtr(
    _In_ ULONG_PTR Target
    );

#endif

#if (PHNT_VERSION >= PHNT_WIN7)

// rev
NTSYSAPI
VOID
NTAPI
RtlInterlockedClearBitRun(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(0, BitMapHeader->SizeOfBitMap - NumberToClear) ULONG StartingIndex,
    _In_range_(0, BitMapHeader->SizeOfBitMap - StartingIndex) ULONG NumberToClear
    );

// rev
NTSYSAPI
VOID
NTAPI
RtlInterlockedSetBitRun(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(0, BitMapHeader->SizeOfBitMap - NumberToSet) ULONG StartingIndex,
    _In_range_(0, BitMapHeader->SizeOfBitMap - StartingIndex) ULONG NumberToSet
    );

#endif

#if (PHNT_VERSION >= PHNT_WIN8)

NTSYSAPI
VOID
NTAPI
RtlCopyBitMap(
    _In_ PRTL_BITMAP Source,
    _In_ PRTL_BITMAP Destination,
    _In_range_(0, Destination->SizeOfBitMap - 1) ULONG TargetBit
    );

NTSYSAPI
VOID
NTAPI
RtlExtractBitMap(
    _In_ PRTL_BITMAP Source,
    _In_ PRTL_BITMAP Destination,
    _In_range_(0, Source->SizeOfBitMap - 1) ULONG TargetBit,
    _In_range_(0, Source->SizeOfBitMap) ULONG NumberOfBits
    );

NTSYSAPI
ULONG
NTAPI
RtlNumberOfClearBitsInRange(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG StartingIndex,
    _In_ ULONG Length
    );

NTSYSAPI
ULONG
NTAPI
RtlNumberOfSetBitsInRange(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG StartingIndex,
    _In_ ULONG Length
    );

#endif


#if (PHNT_VERSION >= PHNT_THRESHOLD)

// private
typedef struct _RTL_BITMAP_EX
{
    ULONG64 SizeOfBitMap;
    PULONG64 Buffer;
} RTL_BITMAP_EX, *PRTL_BITMAP_EX;

// rev
NTSYSAPI
VOID
NTAPI
RtlInitializeBitMapEx(
    _Out_ PRTL_BITMAP_EX BitMapHeader,
    _In_ PULONG64 BitMapBuffer,
    _In_ ULONG64 SizeOfBitMap
    );

// rev
_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlTestBitEx(
    _In_ PRTL_BITMAP_EX BitMapHeader,
    _In_range_(<, BitMapHeader->SizeOfBitMap) ULONG64 BitNumber
    );

#if (PHNT_MODE == PHNT_MODE_KERNEL)
// rev
NTSYSAPI
VOID
NTAPI
RtlClearAllBitsEx(
    _In_ PRTL_BITMAP_EX BitMapHeader
    );

// rev
NTSYSAPI
VOID
NTAPI
RtlClearBitEx(
    _In_ PRTL_BITMAP_EX BitMapHeader,
    _In_range_(<, BitMapHeader->SizeOfBitMap) ULONG64 BitNumber
    );

// rev
NTSYSAPI
VOID
NTAPI
RtlSetBitEx(
    _In_ PRTL_BITMAP_EX BitMapHeader,
    _In_range_(<, BitMapHeader->SizeOfBitMap) ULONG64 BitNumber
    );

// rev
NTSYSAPI
ULONG64
NTAPI
RtlFindSetBitsEx(
    _In_ PRTL_BITMAP_EX BitMapHeader,
    _In_ ULONG64 NumberToFind,
    _In_ ULONG64 HintIndex
    );

NTSYSAPI
ULONG64
NTAPI
RtlFindSetBitsAndClearEx(
    _In_ PRTL_BITMAP_EX BitMapHeader,
    _In_ ULONG64 NumberToFind,
    _In_ ULONG64 HintIndex
    );
#endif

#endif

// Handle tables

typedef struct _RTL_HANDLE_TABLE_ENTRY
{
    union
    {
        ULONG Flags; // allocated entries have the low bit set
        struct _RTL_HANDLE_TABLE_ENTRY *NextFree;
    };
} RTL_HANDLE_TABLE_ENTRY, *PRTL_HANDLE_TABLE_ENTRY;

#define RTL_HANDLE_ALLOCATED (USHORT)0x0001

typedef struct _RTL_HANDLE_TABLE
{
    ULONG MaximumNumberOfHandles;
    ULONG SizeOfHandleTableEntry;
    ULONG Reserved[2];
    PRTL_HANDLE_TABLE_ENTRY FreeHandles;
    PRTL_HANDLE_TABLE_ENTRY CommittedHandles;
    PRTL_HANDLE_TABLE_ENTRY UnCommittedHandles;
    PRTL_HANDLE_TABLE_ENTRY MaxReservedHandles;
} RTL_HANDLE_TABLE, *PRTL_HANDLE_TABLE;

NTSYSAPI
VOID
NTAPI
RtlInitializeHandleTable(
    _In_ ULONG MaximumNumberOfHandles,
    _In_ ULONG SizeOfHandleTableEntry,
    _Out_ PRTL_HANDLE_TABLE HandleTable
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyHandleTable(
    _Inout_ PRTL_HANDLE_TABLE HandleTable
    );

NTSYSAPI
PRTL_HANDLE_TABLE_ENTRY
NTAPI
RtlAllocateHandle(
    _In_ PRTL_HANDLE_TABLE HandleTable,
    _Out_opt_ PULONG HandleIndex
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHandle(
    _In_ PRTL_HANDLE_TABLE HandleTable,
    _In_ PRTL_HANDLE_TABLE_ENTRY Handle
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlIsValidHandle(
    _In_ PRTL_HANDLE_TABLE HandleTable,
    _In_ PRTL_HANDLE_TABLE_ENTRY Handle
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlIsValidIndexHandle(
    _In_ PRTL_HANDLE_TABLE HandleTable,
    _In_ ULONG HandleIndex,
    _Out_ PRTL_HANDLE_TABLE_ENTRY *Handle
    );

// Atom tables

#define RTL_ATOM_MAXIMUM_INTEGER_ATOM (RTL_ATOM)0xc000
#define RTL_ATOM_INVALID_ATOM (RTL_ATOM)0x0000
#define RTL_ATOM_TABLE_DEFAULT_NUMBER_OF_BUCKETS 37
#define RTL_ATOM_MAXIMUM_NAME_LENGTH 255
#define RTL_ATOM_PINNED 0x01

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAtomTable(
    _In_ ULONG NumberOfBuckets,
    _Out_ PVOID *AtomTableHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyAtomTable(
    _In_ _Post_invalid_ PVOID AtomTableHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlEmptyAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ BOOLEAN IncludePinnedAtoms
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAtomToAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ PWSTR AtomName,
    _Inout_opt_ PRTL_ATOM Atom
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlLookupAtomInAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ PWSTR AtomName,
    _Out_opt_ PRTL_ATOM Atom
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAtomFromAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ RTL_ATOM Atom
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlPinAtomInAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ RTL_ATOM Atom
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryAtomInAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ RTL_ATOM Atom,
    _Out_opt_ PULONG AtomUsage,
    _Out_opt_ PULONG AtomFlags,
    _Inout_updates_bytes_to_opt_(*AtomNameLength, *AtomNameLength) PWSTR AtomName,
    _Inout_opt_ PULONG AtomNameLength
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlGetIntegerAtom(
    _In_ PWSTR AtomName,
    _Out_opt_ PUSHORT IntegerAtom
    );
#endif

// SIDs

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlValidSid(
    _In_ PSID Sid
    );

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlEqualSid(
    _In_ PSID Sid1,
    _In_ PSID Sid2
    );

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlEqualPrefixSid(
    _In_ PSID Sid1,
    _In_ PSID Sid2
    );

NTSYSAPI
ULONG
NTAPI
RtlLengthRequiredSid(
    _In_ ULONG SubAuthorityCount
    );

NTSYSAPI
PVOID
NTAPI
RtlFreeSid(
    _In_ _Post_invalid_ PSID Sid
    );

_Must_inspect_result_
NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateAndInitializeSid(
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount,
    _In_ ULONG SubAuthority0,
    _In_ ULONG SubAuthority1,
    _In_ ULONG SubAuthority2,
    _In_ ULONG SubAuthority3,
    _In_ ULONG SubAuthority4,
    _In_ ULONG SubAuthority5,
    _In_ ULONG SubAuthority6,
    _In_ ULONG SubAuthority7,
    _Outptr_ PSID *Sid
    );

#if (PHNT_VERSION >= PHNT_WINBLUE)
_Must_inspect_result_
NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateAndInitializeSidEx(
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount,
    _In_reads_(SubAuthorityCount) PULONG SubAuthorities,
    _Outptr_ PSID *Sid
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeSid(
    _Out_ PSID Sid,
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)
NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeSidEx(
    _Out_writes_bytes_(SECURITY_SID_SIZE(SubAuthorityCount)) PSID Sid,
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount,
    ...
    );
#endif

NTSYSAPI
PSID_IDENTIFIER_AUTHORITY
NTAPI
RtlIdentifierAuthoritySid(
    _In_ PSID Sid
    );

NTSYSAPI
PULONG
NTAPI
RtlSubAuthoritySid(
    _In_ PSID Sid,
    _In_ ULONG SubAuthority
    );

NTSYSAPI
PUCHAR
NTAPI
RtlSubAuthorityCountSid(
    _In_ PSID Sid
    );

NTSYSAPI
ULONG
NTAPI
RtlLengthSid(
    _In_ PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySid(
    _In_ ULONG DestinationSidLength,
    _Out_writes_bytes_(DestinationSidLength) PSID DestinationSid,
    _In_ PSID SourceSid
    );

// ros
NTSYSAPI
NTSTATUS
NTAPI
RtlCopySidAndAttributesArray(
    _In_ ULONG Count,
    _In_ PSID_AND_ATTRIBUTES Src,
    _In_ ULONG SidAreaSize,
    _In_ PSID_AND_ATTRIBUTES Dest,
    _In_ PSID SidArea,
    _Out_ PSID *RemainingSidArea,
    _Out_ PULONG RemainingSidAreaSize
    );

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateServiceSid(
    _In_ PUNICODE_STRING ServiceName,
    _Out_writes_bytes_opt_(*ServiceSidLength) PSID ServiceSid,
    _Inout_ PULONG ServiceSidLength
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSidDominates(
    _In_ PSID Sid1,
    _In_ PSID Sid2,
    _Out_ PBOOLEAN Dominates
    );

#endif

#if (PHNT_VERSION >= PHNT_WINBLUE)

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSidDominatesForTrust(
    _In_ PSID Sid1,
    _In_ PSID Sid2,
    _Out_ PBOOLEAN DominatesTrust // TokenProcessTrustLevel
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSidEqualLevel(
    _In_ PSID Sid1,
    _In_ PSID Sid2,
    _Out_ PBOOLEAN EqualLevel
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSidIsHigherLevel(
    _In_ PSID Sid1,
    _In_ PSID Sid2,
    _Out_ PBOOLEAN HigherLevel
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateVirtualAccountSid(
    _In_ PUNICODE_STRING Name,
    _In_ ULONG BaseSubAuthority,
    _Out_writes_bytes_(*SidLength) PSID Sid,
    _Inout_ PULONG SidLength
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSAPI
NTSTATUS
NTAPI
RtlReplaceSidInSd(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PSID OldSid,
    _In_ PSID NewSid,
    _Out_ ULONG *NumChanges
    );
#endif

#define MAX_UNICODE_STACK_BUFFER_LENGTH 256

NTSYSAPI
NTSTATUS
NTAPI
RtlLengthSidAsUnicodeString(
    _In_ PSID Sid,
    _Out_ PULONG StringLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlConvertSidToUnicodeString(
    _Inout_ PUNICODE_STRING UnicodeString,
    _In_ PSID Sid,
    _In_ BOOLEAN AllocateDestinationString
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSidHashInitialize(
    _In_reads_(SidCount) PSID_AND_ATTRIBUTES SidAttr,
    _In_ ULONG SidCount,
    _Out_ PSID_AND_ATTRIBUTES_HASH SidAttrHash
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
PSID_AND_ATTRIBUTES
NTAPI
RtlSidHashLookup(
    _In_ PSID_AND_ATTRIBUTES_HASH SidAttrHash,
    _In_ PSID Sid
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsElevatedRid(
    _In_ PSID_AND_ATTRIBUTES SidAttr
    );
#endif

#if (PHNT_VERSION >= PHNT_THRESHOLD)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlDeriveCapabilitySidsFromName(
    _Inout_ PUNICODE_STRING UnicodeString,
    _Out_ PSID CapabilityGroupSid,
    _Out_ PSID CapabilitySid
    );
#endif

// Security Descriptors

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptor(
    _Out_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Revision
    );

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlValidSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSYSAPI
ULONG
NTAPI
RtlLengthSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlValidRelativeSecurityDescriptor(
    _In_reads_bytes_(SecurityDescriptorLength) PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    _In_ ULONG SecurityDescriptorLength,
    _In_ SECURITY_INFORMATION RequiredInformation
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetControlSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PSECURITY_DESCRIPTOR_CONTROL Control,
    _Out_ PULONG Revision
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetControlSecurityDescriptor(
     _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
     _In_ SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
     _In_ SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
     );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetAttributesSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ SECURITY_DESCRIPTOR_CONTROL Control,
    _Out_ PULONG Revision
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlGetSecurityDescriptorRMControl(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PUCHAR RMControl
    );

NTSYSAPI
VOID
NTAPI
RtlSetSecurityDescriptorRMControl(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PUCHAR RMControl
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ BOOLEAN DaclPresent,
    _In_opt_ PACL Dacl,
    _In_ BOOLEAN DaclDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetDaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN DaclPresent,
    _Outptr_result_maybenull_ PACL *Dacl,
    _Out_ PBOOLEAN DaclDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetSaclSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ BOOLEAN SaclPresent,
    _In_opt_ PACL Sacl,
    _In_ BOOLEAN SaclDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN SaclPresent,
    _Out_ PACL *Sacl,
    _Out_ PBOOLEAN SaclDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetOwnerSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID Owner,
    _In_ BOOLEAN OwnerDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetOwnerSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Outptr_result_maybenull_ PSID *Owner,
    _Out_ PBOOLEAN OwnerDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetGroupSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID Group,
    _In_ BOOLEAN GroupDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Outptr_result_maybenull_ PSID *Group,
    _Out_ PBOOLEAN GroupDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlMakeSelfRelativeSD(
    _In_ PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Out_writes_bytes_(*BufferLength) PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Inout_ PULONG BufferLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAbsoluteToSelfRelativeSD(
    _In_ PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Out_writes_bytes_to_opt_(*BufferLength, *BufferLength) PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Inout_ PULONG BufferLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD(
    _In_ PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Out_writes_bytes_to_opt_(*AbsoluteSecurityDescriptorSize, *AbsoluteSecurityDescriptorSize) PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Inout_ PULONG AbsoluteSecurityDescriptorSize,
    _Out_writes_bytes_to_opt_(*DaclSize, *DaclSize) PACL Dacl,
    _Inout_ PULONG DaclSize,
    _Out_writes_bytes_to_opt_(*SaclSize, *SaclSize) PACL Sacl,
    _Inout_ PULONG SaclSize,
    _Out_writes_bytes_to_opt_(*OwnerSize, *OwnerSize) PSID Owner,
    _Inout_ PULONG OwnerSize,
    _Out_writes_bytes_to_opt_(*PrimaryGroupSize, *PrimaryGroupSize) PSID PrimaryGroup,
    _Inout_ PULONG PrimaryGroupSize
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD2(
    _Inout_ PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Inout_ PULONG BufferSize
    );

// Access masks

#ifndef PHNT_NO_INLINE_ACCESSES_GRANTED
FORCEINLINE
BOOLEAN
NTAPI
RtlAreAllAccessesGranted(
    _In_ ACCESS_MASK GrantedAccess,
    _In_ ACCESS_MASK DesiredAccess
    )
{
    return (~GrantedAccess & DesiredAccess) == 0;
}

FORCEINLINE
BOOLEAN
NTAPI
RtlAreAnyAccessesGranted(
    _In_ ACCESS_MASK GrantedAccess,
    _In_ ACCESS_MASK DesiredAccess
    )
{
    return (GrantedAccess & DesiredAccess) != 0;
}
#else
NTSYSAPI
BOOLEAN
NTAPI
RtlAreAllAccessesGranted(
    _In_ ACCESS_MASK GrantedAccess,
    _In_ ACCESS_MASK DesiredAccess
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlAreAnyAccessesGranted(
    _In_ ACCESS_MASK GrantedAccess,
    _In_ ACCESS_MASK DesiredAccess
    );
#endif

NTSYSAPI
VOID
NTAPI
RtlMapGenericMask(
    _Inout_ PACCESS_MASK AccessMask,
    _In_ PGENERIC_MAPPING GenericMapping
    );

// ACLs

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAcl(
    _Out_writes_bytes_(AclLength) PACL Acl,
    _In_ ULONG AclLength,
    _In_ ULONG AclRevision
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlValidAcl(
    _In_ PACL Acl
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryInformationAcl(
    _In_ PACL Acl,
    _Out_writes_bytes_(AclInformationLength) PVOID AclInformation,
    _In_ ULONG AclInformationLength,
    _In_ ACL_INFORMATION_CLASS AclInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetInformationAcl(
    _Inout_ PACL Acl,
    _In_reads_bytes_(AclInformationLength) PVOID AclInformation,
    _In_ ULONG AclInformationLength,
    _In_ ACL_INFORMATION_CLASS AclInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG StartingAceIndex,
    _In_reads_bytes_(AceListLength) PVOID AceList,
    _In_ ULONG AceListLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceIndex
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetAce(
    _In_ PACL Acl,
    _In_ ULONG AceIndex,
    _Outptr_ PVOID *Ace
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlFirstFreeAce(
    _In_ PACL Acl,
    _Out_ PVOID *FirstFree
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
PVOID
NTAPI
RtlFindAceByType(
    _In_ PACL Acl,
    _In_ UCHAR AceType,
    _Out_opt_ PULONG Index
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
BOOLEAN
NTAPI
RtlOwnerAcesPresent(
    _In_ PACL pAcl
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ PGUID ObjectTypeGuid,
    _In_opt_ PGUID InheritedObjectTypeGuid,
    _In_ PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ PGUID ObjectTypeGuid,
    _In_opt_ PGUID InheritedObjectTypeGuid,
    _In_ PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ PGUID ObjectTypeGuid,
    _In_opt_ PGUID InheritedObjectTypeGuid,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddCompoundAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID ServerSid,
    _In_ PSID ClientSid
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlAddMandatoryAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ PSID Sid,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSAPI
NTSTATUS
NTAPI
RtlAddResourceAttributeAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ULONG AccessMask,
    _In_ PSID Sid,
    _In_ PCLAIM_SECURITY_ATTRIBUTES_INFORMATION AttributeInfo,
    _Out_ PULONG ReturnLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddScopedPolicyIDAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ULONG AccessMask,
    _In_ PSID Sid
    );
#endif

// Named pipes

NTSYSAPI
NTSTATUS
NTAPI
RtlDefaultNpAcl(
    _Out_ PACL *Acl
    );

// Security objects

NTSYSAPI
NTSTATUS
NTAPI
RtlNewSecurityObject(
    _In_opt_ PSECURITY_DESCRIPTOR ParentDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR CreatorDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *NewDescriptor,
    _In_ BOOLEAN IsDirectoryObject,
    _In_opt_ HANDLE Token,
    _In_ PGENERIC_MAPPING GenericMapping
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlNewSecurityObjectEx(
    _In_opt_ PSECURITY_DESCRIPTOR ParentDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR CreatorDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *NewDescriptor,
    _In_opt_ GUID *ObjectType,
    _In_ BOOLEAN IsDirectoryObject,
    _In_ ULONG AutoInheritFlags, // SEF_*
    _In_opt_ HANDLE Token,
    _In_ PGENERIC_MAPPING GenericMapping
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlNewSecurityObjectWithMultipleInheritance(
    _In_opt_ PSECURITY_DESCRIPTOR ParentDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR CreatorDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *NewDescriptor,
    _In_opt_ GUID **ObjectType,
    _In_ ULONG GuidCount,
    _In_ BOOLEAN IsDirectoryObject,
    _In_ ULONG AutoInheritFlags, // SEF_*
    _In_opt_ HANDLE Token,
    _In_ PGENERIC_MAPPING GenericMapping
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteSecurityObject(
    _Inout_ PSECURITY_DESCRIPTOR *ObjectDescriptor
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlQuerySecurityObject(
     _In_ PSECURITY_DESCRIPTOR ObjectDescriptor,
     _In_ SECURITY_INFORMATION SecurityInformation,
     _Out_opt_ PSECURITY_DESCRIPTOR ResultantDescriptor,
     _In_ ULONG DescriptorLength,
     _Out_ PULONG ReturnLength
     );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetSecurityObject(
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR ModificationDescriptor,
    _Inout_ PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_opt_ HANDLE Token
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetSecurityObjectEx(
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR ModificationDescriptor,
    _Inout_ PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    _In_ ULONG AutoInheritFlags, // SEF_*
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_opt_ HANDLE Token
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlConvertToAutoInheritSecurityObject(
    _In_opt_ PSECURITY_DESCRIPTOR ParentDescriptor,
    _In_ PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
    _In_opt_ GUID *ObjectType,
    _In_ BOOLEAN IsDirectoryObject,
    _In_ PGENERIC_MAPPING GenericMapping
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlNewInstanceSecurityObject(
    _In_ BOOLEAN ParentDescriptorChanged,
    _In_ BOOLEAN CreatorDescriptorChanged,
    _In_ PLUID OldClientTokenModifiedId,
    _Out_ PLUID NewClientTokenModifiedId,
    _In_opt_ PSECURITY_DESCRIPTOR ParentDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR CreatorDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *NewDescriptor,
    _In_ BOOLEAN IsDirectoryObject,
    _In_ HANDLE Token,
    _In_ PGENERIC_MAPPING GenericMapping
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *OutputSecurityDescriptor
    );

// private
typedef struct _RTL_ACE_DATA
{
    UCHAR AceType;
    UCHAR InheritFlags;
    UCHAR AceFlags;
    ACCESS_MASK AccessMask;
    PSID* Sid;
} RTL_ACE_DATA, *PRTL_ACE_DATA;

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserSecurityObject(
    _In_ PRTL_ACE_DATA AceData,
    _In_ ULONG AceCount,
    _In_ PSID OwnerSid,
    _In_ PSID GroupSid,
    _In_ BOOLEAN IsDirectoryObject,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_ PSECURITY_DESCRIPTOR* NewSecurityDescriptor
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAndSetSD(
    _In_ PRTL_ACE_DATA AceData,
    _In_ ULONG AceCount,
    _In_opt_ PSID OwnerSid,
    _In_opt_ PSID GroupSid,
    _Out_ PSECURITY_DESCRIPTOR* NewSecurityDescriptor
    );

// Misc. security

NTSYSAPI
VOID
NTAPI
RtlRunEncodeUnicodeString(
    _Inout_ PUCHAR Seed,
    _Inout_ PUNICODE_STRING String
    );

NTSYSAPI
VOID
NTAPI
RtlRunDecodeUnicodeString(
    _In_ UCHAR Seed,
    _Inout_ PUNICODE_STRING String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlImpersonateSelf(
    _In_ SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlImpersonateSelfEx(
    _In_ SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    _In_opt_ ACCESS_MASK AdditionalAccess,
    _Out_opt_ PHANDLE ThreadToken
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlAdjustPrivilege(
    _In_ ULONG Privilege,
    _In_ BOOLEAN Enable,
    _In_ BOOLEAN Client,
    _Out_ PBOOLEAN WasEnabled
    );

#define RTL_ACQUIRE_PRIVILEGE_REVERT 0x00000001
#define RTL_ACQUIRE_PRIVILEGE_PROCESS 0x00000002

NTSYSAPI
NTSTATUS
NTAPI
RtlAcquirePrivilege(
    _In_ PULONG Privilege,
    _In_ ULONG NumPriv,
    _In_ ULONG Flags,
    _Out_ PVOID *ReturnedState
    );

NTSYSAPI
VOID
NTAPI
RtlReleasePrivilege(
    _In_ PVOID StatePointer
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlRemovePrivileges(
    _In_ HANDLE TokenHandle,
    _In_ PULONG PrivilegesToKeep,
    _In_ ULONG PrivilegeCount
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8)

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlIsUntrustedObject(
    _In_opt_ HANDLE Handle,
    _In_opt_ PVOID Object,
    _Out_ PBOOLEAN IsUntrustedObject
    );

NTSYSAPI
ULONG
NTAPI
RtlQueryValidationRunlevel(
    _In_opt_ PUNICODE_STRING ComponentName
    );

#endif

// Private namespaces

#if (PHNT_VERSION >= PHNT_VISTA)

// rev
#define BOUNDARY_DESCRIPTOR_ADD_APPCONTAINER_SID 0x0001

// begin_private

_Ret_maybenull_
_Success_(return != NULL)
NTSYSAPI
POBJECT_BOUNDARY_DESCRIPTOR
NTAPI
RtlCreateBoundaryDescriptor(
    _In_ PUNICODE_STRING Name,
    _In_ ULONG Flags
    );

NTSYSAPI
VOID
NTAPI
RtlDeleteBoundaryDescriptor(
    _In_ _Post_invalid_ POBJECT_BOUNDARY_DESCRIPTOR BoundaryDescriptor
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddSIDToBoundaryDescriptor(
    _Inout_ POBJECT_BOUNDARY_DESCRIPTOR *BoundaryDescriptor,
    _In_ PSID RequiredSid
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlAddIntegrityLabelToBoundaryDescriptor(
    _Inout_ POBJECT_BOUNDARY_DESCRIPTOR *BoundaryDescriptor,
    _In_ PSID IntegrityLabel
    );
#endif

// end_private

#endif

// Version

NTSYSAPI
NTSTATUS
NTAPI
RtlGetVersion(
    _Out_ PRTL_OSVERSIONINFOEXW VersionInformation // PRTL_OSVERSIONINFOW
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlVerifyVersionInfo(
    _In_ PRTL_OSVERSIONINFOEXW VersionInformation, // PRTL_OSVERSIONINFOW
    _In_ ULONG TypeMask,
    _In_ ULONGLONG ConditionMask
    );

// rev
NTSYSAPI
VOID
NTAPI
RtlGetNtVersionNumbers(
    _Out_opt_ PULONG NtMajorVersion,
    _Out_opt_ PULONG NtMinorVersion,
    _Out_opt_ PULONG NtBuildNumber
    );

// System information

// rev
NTSYSAPI
ULONG
NTAPI
RtlGetNtGlobalFlags(
    VOID
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlGetNtProductType(
    _Out_ PNT_PRODUCT_TYPE NtProductType
    );

#if (PHNT_VERSION >= PHNT_REDSTONE)
// private
NTSYSAPI
ULONG
NTAPI
RtlGetSuiteMask(
    VOID
    );
#endif

// Thread pool (old)

NTSYSAPI
NTSTATUS
NTAPI
RtlRegisterWait(
    _Out_ PHANDLE WaitHandle,
    _In_ HANDLE Handle,
    _In_ WAITORTIMERCALLBACKFUNC Function,
    _In_ PVOID Context,
    _In_ ULONG Milliseconds,
    _In_ ULONG Flags
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeregisterWait(
    _In_ HANDLE WaitHandle
    );

#define RTL_WAITER_DEREGISTER_WAIT_FOR_COMPLETION ((HANDLE)(LONG_PTR)-1)

NTSYSAPI
NTSTATUS
NTAPI
RtlDeregisterWaitEx(
    _In_ HANDLE WaitHandle,
    _In_opt_ HANDLE Event // optional: RTL_WAITER_DEREGISTER_WAIT_FOR_COMPLETION
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlQueueWorkItem(
    _In_ WORKERCALLBACKFUNC Function,
    _In_ PVOID Context,
    _In_ ULONG Flags
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetIoCompletionCallback(
    _In_ HANDLE FileHandle,
    _In_ APC_CALLBACK_FUNCTION CompletionProc,
    _In_ ULONG Flags
    );

typedef NTSTATUS (NTAPI *PRTL_START_POOL_THREAD)(
    _In_ PTHREAD_START_ROUTINE Function,
    _In_ PVOID Parameter,
    _Out_ PHANDLE ThreadHandle
    );

typedef NTSTATUS (NTAPI *PRTL_EXIT_POOL_THREAD)(
    _In_ NTSTATUS ExitStatus
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetThreadPoolStartFunc(
    _In_ PRTL_START_POOL_THREAD StartPoolThread,
    _In_ PRTL_EXIT_POOL_THREAD ExitPoolThread
    );

NTSYSAPI
VOID
NTAPI
RtlUserThreadStart(
    _In_ PTHREAD_START_ROUTINE Function,
    _In_ PVOID Parameter
    );

NTSYSAPI
VOID
NTAPI
LdrInitializeThunk(
    _In_ PCONTEXT ContextRecord,
    _In_ PVOID Parameter
    );

// Thread execution

NTSYSCALLAPI
NTSTATUS
NTAPI
RtlDelayExecution(
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER DelayInterval
    );

// Timer support

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateTimerQueue(
    _Out_ PHANDLE TimerQueueHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateTimer(
    _In_ HANDLE TimerQueueHandle,
    _Out_ PHANDLE Handle,
    _In_ WAITORTIMERCALLBACKFUNC Function,
    _In_opt_ PVOID Context,
    _In_ ULONG DueTime,
    _In_ ULONG Period,
    _In_ ULONG Flags
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpdateTimer(
    _In_ HANDLE TimerQueueHandle,
    _In_ HANDLE TimerHandle,
    _In_ ULONG DueTime,
    _In_ ULONG Period
    );

#define RTL_TIMER_DELETE_WAIT_FOR_COMPLETION ((HANDLE)(LONG_PTR)-1)

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteTimer(
    _In_ HANDLE TimerQueueHandle,
    _In_ HANDLE TimerToCancel,
    _In_opt_ HANDLE Event // optional: RTL_TIMER_DELETE_WAIT_FOR_COMPLETION
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteTimerQueue(
    _In_ HANDLE TimerQueueHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteTimerQueueEx(
    _In_ HANDLE TimerQueueHandle,
    _In_opt_ HANDLE Event
    );

// Registry access

NTSYSAPI
NTSTATUS
NTAPI
RtlFormatCurrentUserKeyPath(
    _Out_ PUNICODE_STRING CurrentUserKeyPath
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlOpenCurrentUser(
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE CurrentUserKey
    );

#define RTL_REGISTRY_ABSOLUTE 0
#define RTL_REGISTRY_SERVICES 1 // \Registry\Machine\System\CurrentControlSet\Services
#define RTL_REGISTRY_CONTROL 2 // \Registry\Machine\System\CurrentControlSet\Control
#define RTL_REGISTRY_WINDOWS_NT 3 // \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
#define RTL_REGISTRY_DEVICEMAP 4 // \Registry\Machine\Hardware\DeviceMap
#define RTL_REGISTRY_USER 5 // \Registry\User\CurrentUser
#define RTL_REGISTRY_MAXIMUM 6
#define RTL_REGISTRY_HANDLE 0x40000000
#define RTL_REGISTRY_OPTIONAL 0x80000000

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateRegistryKey(
    _In_ ULONG RelativeTo,
    _In_ PWSTR Path
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCheckRegistryKey(
    _In_ ULONG RelativeTo,
    _In_ PWSTR Path
    );

typedef NTSTATUS (NTAPI *PRTL_QUERY_REGISTRY_ROUTINE)(
    _In_ PWSTR ValueName,
    _In_ ULONG ValueType,
    _In_ PVOID ValueData,
    _In_ ULONG ValueLength,
    _In_ PVOID Context,
    _In_ PVOID EntryContext
    );

typedef struct _RTL_QUERY_REGISTRY_TABLE
{
    PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;
    ULONG Flags;
    PWSTR Name;
    PVOID EntryContext;
    ULONG DefaultType;
    PVOID DefaultData;
    ULONG DefaultLength;
} RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;

#define RTL_QUERY_REGISTRY_SUBKEY 0x00000001
#define RTL_QUERY_REGISTRY_TOPKEY 0x00000002
#define RTL_QUERY_REGISTRY_REQUIRED 0x00000004
#define RTL_QUERY_REGISTRY_NOVALUE 0x00000008
#define RTL_QUERY_REGISTRY_NOEXPAND 0x00000010
#define RTL_QUERY_REGISTRY_DIRECT 0x00000020
#define RTL_QUERY_REGISTRY_DELETE 0x00000040

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryRegistryValues(
    _In_ ULONG RelativeTo,
    _In_ PCWSTR Path,
    _In_ PRTL_QUERY_REGISTRY_TABLE QueryTable,
    _In_ PVOID Context,
    _In_opt_ PVOID Environment
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryRegistryValuesEx(
    _In_ ULONG RelativeTo,
    _In_ PCWSTR Path,
    _In_ PRTL_QUERY_REGISTRY_TABLE QueryTable,
    _In_ PVOID Context,
    _In_opt_ PVOID Environment
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlWriteRegistryValue(
    _In_ ULONG RelativeTo,
    _In_ PCWSTR Path,
    _In_ PCWSTR ValueName,
    _In_ ULONG ValueType,
    _In_ PVOID ValueData,
    _In_ ULONG ValueLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteRegistryValue(
    _In_ ULONG RelativeTo,
    _In_ PCWSTR Path,
    _In_ PCWSTR ValueName
    );

// Thread profiling

#if (PHNT_VERSION >= PHNT_WIN7)

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlEnableThreadProfiling(
    _In_ HANDLE ThreadHandle,
    _In_ ULONG Flags,
    _In_ ULONG64 HardwareCounters,
    _Out_ PVOID *PerformanceDataHandle
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlDisableThreadProfiling(
    _In_ PVOID PerformanceDataHandle
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryThreadProfiling(
    _In_ HANDLE ThreadHandle,
    _Out_ PBOOLEAN Enabled
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlReadThreadProfilingData(
    _In_ HANDLE PerformanceDataHandle,
    _In_ ULONG Flags,
    _Out_ PPERFORMANCE_DATA PerformanceData
    );

#endif

// WOW64

NTSYSAPI
NTSTATUS
NTAPI
RtlGetNativeSystemInformation(
    _In_ ULONG SystemInformationClass,
    _In_ PVOID NativeSystemInformation,
    _In_ ULONG InformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlQueueApcWow64Thread(
    _In_ HANDLE ThreadHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64EnableFsRedirection(
    _In_ BOOLEAN Wow64FsEnableRedirection
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64EnableFsRedirectionEx(
    _In_ PVOID Wow64FsEnableRedirection,
    _Out_ PVOID *OldFsRedirectionLevel
    );

// Misc.

NTSYSAPI
ULONG32
NTAPI
RtlComputeCrc32(
    _In_ ULONG32 PartialCrc,
    _In_ PVOID Buffer,
    _In_ ULONG Length
    );

NTSYSAPI
PVOID
NTAPI
RtlEncodePointer(
    _In_ PVOID Ptr
    );

NTSYSAPI
PVOID
NTAPI
RtlDecodePointer(
    _In_ PVOID Ptr
    );

NTSYSAPI
PVOID
NTAPI
RtlEncodeSystemPointer(
    _In_ PVOID Ptr
    );

NTSYSAPI
PVOID
NTAPI
RtlDecodeSystemPointer(
    _In_ PVOID Ptr
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlEncodeRemotePointer(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID Pointer,
    _Out_ PVOID *EncodedPointer
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlDecodeRemotePointer(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID Pointer,
    _Out_ PVOID *DecodedPointer
    );
#endif

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsProcessorFeaturePresent(
    _In_ ULONG ProcessorFeature
    );

// rev
NTSYSAPI
ULONG
NTAPI
RtlGetCurrentProcessorNumber(
    VOID
    );

#if (PHNT_VERSION >= PHNT_WIN7)

// rev
NTSYSAPI
VOID
NTAPI
RtlGetCurrentProcessorNumberEx(
    _Out_ PPROCESSOR_NUMBER ProcessorNumber
    );

#endif

// Stack support

NTSYSAPI
VOID
NTAPI
RtlPushFrame(
    _In_ PTEB_ACTIVE_FRAME Frame
    );

NTSYSAPI
VOID
NTAPI
RtlPopFrame(
    _In_ PTEB_ACTIVE_FRAME Frame
    );

NTSYSAPI
PTEB_ACTIVE_FRAME
NTAPI
RtlGetFrame(
    VOID
    );

#define RTL_WALK_USER_MODE_STACK 0x00000001
#define RTL_WALK_VALID_FLAGS 0x00000001
#define RTL_STACK_WALKING_MODE_FRAMES_TO_SKIP_SHIFT 0x00000008

// private
NTSYSAPI
ULONG
NTAPI
RtlWalkFrameChain(
    _Out_writes_(Count - (Flags >> RTL_STACK_WALKING_MODE_FRAMES_TO_SKIP_SHIFT)) PVOID *Callers,
    _In_ ULONG Count,
    _In_ ULONG Flags
    );

// rev
NTSYSAPI
VOID
NTAPI
RtlGetCallersAddress( // Use the intrinsic _ReturnAddress instead.
    _Out_ PVOID *CallersAddress,
    _Out_ PVOID *CallersCaller
    );

#if (PHNT_VERSION >= PHNT_WIN7)

NTSYSAPI
ULONG64
NTAPI
RtlGetEnabledExtendedFeatures(
    _In_ ULONG64 FeatureMask
    );

#endif

#if (PHNT_VERSION >= PHNT_REDSTONE4)

// msdn
NTSYSAPI
ULONG64
NTAPI
RtlGetEnabledExtendedAndSupervisorFeatures(
    _In_ ULONG64 FeatureMask
    );

// msdn
_Ret_maybenull_
_Success_(return != NULL)
NTSYSAPI
PVOID
NTAPI
RtlLocateSupervisorFeature(
    _In_ PXSAVE_AREA_HEADER XStateHeader,
    _In_range_(XSTATE_AVX, MAXIMUM_XSTATE_FEATURES - 1) ULONG FeatureId,
    _Out_opt_ PULONG Length
    );

#endif

// private
typedef union _RTL_ELEVATION_FLAGS
{
    ULONG Flags;
    struct
    {
        ULONG ElevationEnabled : 1;
        ULONG VirtualizationEnabled : 1;
        ULONG InstallerDetectEnabled : 1;
        ULONG ReservedBits : 29;
    };
} RTL_ELEVATION_FLAGS, *PRTL_ELEVATION_FLAGS;

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryElevationFlags(
    _Out_ PRTL_ELEVATION_FLAGS Flags
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlRegisterThreadWithCsrss(
    VOID
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlLockCurrentThread(
    VOID
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlUnlockCurrentThread(
    VOID
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlLockModuleSection(
    _In_ PVOID Address
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlUnlockModuleSection(
    _In_ PVOID Address
    );

#endif

// begin_msdn:"Winternl"

#define RTL_UNLOAD_EVENT_TRACE_NUMBER 64

// private
typedef struct _RTL_UNLOAD_EVENT_TRACE
{
    PVOID BaseAddress;
    SIZE_T SizeOfImage;
    ULONG Sequence;
    ULONG TimeDateStamp;
    ULONG CheckSum;
    WCHAR ImageName[32];
    ULONG Version[2];
} RTL_UNLOAD_EVENT_TRACE, *PRTL_UNLOAD_EVENT_TRACE;

typedef struct _RTL_UNLOAD_EVENT_TRACE32
{
    ULONG BaseAddress;
    ULONG SizeOfImage;
    ULONG Sequence;
    ULONG TimeDateStamp;
    ULONG CheckSum;
    WCHAR ImageName[32];
    ULONG Version[2];
} RTL_UNLOAD_EVENT_TRACE32, *PRTL_UNLOAD_EVENT_TRACE32;

NTSYSAPI
PRTL_UNLOAD_EVENT_TRACE
NTAPI
RtlGetUnloadEventTrace(
    VOID
    );

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSAPI
VOID
NTAPI
RtlGetUnloadEventTraceEx(
    _Out_ PULONG *ElementSize,
    _Out_ PULONG *ElementCount,
    _Out_ PVOID *EventTrace // works across all processes
    );
#endif

// end_msdn

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
LOGICAL
NTAPI
RtlQueryPerformanceCounter(
    _Out_ PLARGE_INTEGER PerformanceCounter
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
LOGICAL
NTAPI
RtlQueryPerformanceFrequency(
    _Out_ PLARGE_INTEGER PerformanceFrequency
    );
#endif

// Image Mitigation

// rev
typedef enum _IMAGE_MITIGATION_POLICY
{
    ImageDepPolicy, // RTL_IMAGE_MITIGATION_DEP_POLICY
    ImageAslrPolicy, // RTL_IMAGE_MITIGATION_ASLR_POLICY
    ImageDynamicCodePolicy, // RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY
    ImageStrictHandleCheckPolicy, // RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY
    ImageSystemCallDisablePolicy, // RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY
    ImageMitigationOptionsMask,
    ImageExtensionPointDisablePolicy, // RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY
    ImageControlFlowGuardPolicy, // RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY
    ImageSignaturePolicy, // RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY
    ImageFontDisablePolicy, // RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY
    ImageImageLoadPolicy, // RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY
    ImagePayloadRestrictionPolicy, // RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY
    ImageChildProcessPolicy, // RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY
    ImageSehopPolicy, // RTL_IMAGE_MITIGATION_SEHOP_POLICY
    ImageHeapPolicy, // RTL_IMAGE_MITIGATION_HEAP_POLICY
    ImageUserShadowStackPolicy, // RTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY
    MaxImageMitigationPolicy
} IMAGE_MITIGATION_POLICY;

// rev
typedef union _RTL_IMAGE_MITIGATION_POLICY
{
    struct
    {
        ULONG64 AuditState : 2;
        ULONG64 AuditFlag : 1;
        ULONG64 EnableAdditionalAuditingOption : 1;
        ULONG64 Reserved : 60;
    };
    struct
    {
        ULONG64 PolicyState : 2;
        ULONG64 AlwaysInherit : 1;
        ULONG64 EnableAdditionalPolicyOption : 1;
        ULONG64 AuditReserved : 60;
    };
} RTL_IMAGE_MITIGATION_POLICY, *PRTL_IMAGE_MITIGATION_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_DEP_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY Dep;
} RTL_IMAGE_MITIGATION_DEP_POLICY, *PRTL_IMAGE_MITIGATION_DEP_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_ASLR_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY ForceRelocateImages;
    RTL_IMAGE_MITIGATION_POLICY BottomUpRandomization;
    RTL_IMAGE_MITIGATION_POLICY HighEntropyRandomization;
} RTL_IMAGE_MITIGATION_ASLR_POLICY, *PRTL_IMAGE_MITIGATION_ASLR_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY BlockDynamicCode;
} RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY, *PRTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY StrictHandleChecks;
} RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY, *PRTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY BlockWin32kSystemCalls;
} RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY, *PRTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY DisableExtensionPoints;
} RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY, *PRTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY ControlFlowGuard;
    RTL_IMAGE_MITIGATION_POLICY StrictControlFlowGuard;
} RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY, *PRTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY BlockNonMicrosoftSignedBinaries;
    RTL_IMAGE_MITIGATION_POLICY EnforceSigningOnModuleDependencies;
} RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY, *PRTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY DisableNonSystemFonts;
} RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY, *PRTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY BlockRemoteImageLoads;
    RTL_IMAGE_MITIGATION_POLICY BlockLowLabelImageLoads;
    RTL_IMAGE_MITIGATION_POLICY PreferSystem32;
} RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY, *PRTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY EnableExportAddressFilter;
    RTL_IMAGE_MITIGATION_POLICY EnableExportAddressFilterPlus;
    RTL_IMAGE_MITIGATION_POLICY EnableImportAddressFilter;
    RTL_IMAGE_MITIGATION_POLICY EnableRopStackPivot;
    RTL_IMAGE_MITIGATION_POLICY EnableRopCallerCheck;
    RTL_IMAGE_MITIGATION_POLICY EnableRopSimExec;
    WCHAR EafPlusModuleList[512]; // 19H1
} RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY, *PRTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY DisallowChildProcessCreation;
} RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY, *PRTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_SEHOP_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY Sehop;
} RTL_IMAGE_MITIGATION_SEHOP_POLICY, *PRTL_IMAGE_MITIGATION_SEHOP_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_HEAP_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY TerminateOnHeapErrors;
} RTL_IMAGE_MITIGATION_HEAP_POLICY, *PRTL_IMAGE_MITIGATION_HEAP_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY UserShadowStack;
    RTL_IMAGE_MITIGATION_POLICY SetContextIpValidation;
    RTL_IMAGE_MITIGATION_POLICY BlockNonCetBinaries;
} RTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY, *PRTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY;

typedef enum _RTL_IMAGE_MITIGATION_OPTION_STATE
{
    RtlMitigationOptionStateNotConfigured,
    RtlMitigationOptionStateOn,
    RtlMitigationOptionStateOff,
    RtlMitigationOptionStateForce,
    RtlMitigationOptionStateOption
} RTL_IMAGE_MITIGATION_OPTION_STATE;

#define RTL_IMAGE_MITIGATION_OPTION_STATEMASK 3UL
#define RTL_IMAGE_MITIGATION_OPTION_FORCEMASK 4UL
#define RTL_IMAGE_MITIGATION_OPTION_OPTIONMASK 8UL

// rev from PROCESS_MITIGATION_FLAGS
#define RTL_IMAGE_MITIGATION_FLAG_RESET 0x1
#define RTL_IMAGE_MITIGATION_FLAG_REMOVE 0x2
#define RTL_IMAGE_MITIGATION_FLAG_OSDEFAULT 0x4
#define RTL_IMAGE_MITIGATION_FLAG_AUDIT 0x8

#if (PHNT_VERSION >= PHNT_REDSTONE3)

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryImageMitigationPolicy(
    _In_opt_ PWSTR ImagePath, // NULL for system-wide defaults
    _In_ IMAGE_MITIGATION_POLICY Policy,
    _In_ ULONG Flags,
    _Inout_ PVOID Buffer,
    _In_ ULONG BufferSize
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSetImageMitigationPolicy(
    _In_opt_ PWSTR ImagePath, // NULL for system-wide defaults
    _In_ IMAGE_MITIGATION_POLICY Policy,
    _In_ ULONG Flags,
    _Inout_ PVOID Buffer,
    _In_ ULONG BufferSize
    );

#endif

// session

// rev
NTSYSAPI
ULONG
NTAPI
RtlGetCurrentServiceSessionId(
    VOID
    );

// private
NTSYSAPI
ULONG
NTAPI
RtlGetActiveConsoleId(
    VOID
    );

#if (PHNT_VERSION >= PHNT_REDSTONE)
// private
NTSYSAPI
ULONGLONG
NTAPI
RtlGetConsoleSessionForegroundProcessId(
    VOID
    );
#endif

// Appcontainer

#if (PHNT_VERSION >= PHNT_REDSTONE2)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetTokenNamedObjectPath(
    _In_ HANDLE Token,
    _In_opt_ PSID Sid,
    _Out_ PUNICODE_STRING ObjectPath // RtlFreeUnicodeString
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetAppContainerNamedObjectPath(
    _In_opt_ HANDLE Token,
    _In_opt_ PSID AppContainerSid,
    _In_ BOOLEAN RelativePath,
    _Out_ PUNICODE_STRING ObjectPath // RtlFreeUnicodeString
    );
#endif

#if (PHNT_VERSION >= PHNT_WINBLUE)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetAppContainerParent(
    _In_ PSID AppContainerSid,
    _Out_ PSID* AppContainerSidParent // RtlFreeSid
    );
#endif

#if (PHNT_VERSION >= PHNT_THRESHOLD)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCheckSandboxedToken(
    _In_opt_ HANDLE TokenHandle,
    _Out_ PBOOLEAN IsSandboxed
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCheckTokenCapability(
    _In_opt_ HANDLE TokenHandle,
    _In_ PSID CapabilitySidToCheck,
    _Out_ PBOOLEAN HasCapability
    );
#endif

#if (PHNT_VERSION >= PHNT_THRESHOLD)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCapabilityCheck(
    _In_opt_ HANDLE TokenHandle,
    _In_ PUNICODE_STRING CapabilityName,
    _Out_ PBOOLEAN HasCapability
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCheckTokenMembership(
    _In_opt_ HANDLE TokenHandle,
    _In_ PSID SidToCheck,
    _Out_ PBOOLEAN IsMember
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCheckTokenMembershipEx(
    _In_opt_ HANDLE TokenHandle,
    _In_ PSID SidToCheck,
    _In_ ULONG Flags, // CTMF_VALID_FLAGS
    _Out_ PBOOLEAN IsMember
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE4)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryTokenHostIdAsUlong64(
    _In_ HANDLE TokenHandle,
    _Out_ PULONG64 HostId // (WIN://PKGHOSTID)
    );
#endif

#if (PHNT_VERSION >= PHNT_WINBLUE)
// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsParentOfChildAppContainer(
    _In_ PSID ParentAppContainerSid,
    _In_ PSID ChildAppContainerSid
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN11)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlIsApiSetImplemented(
    _In_ PCSTR Namespace
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8)
// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsCapabilitySid(
    _In_ PSID Sid
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsPackageSid(
    _In_ PSID Sid
    );
#endif

#if (PHNT_VERSION >= PHNT_WINBLUE)
// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsValidProcessTrustLabelSid(
    _In_ PSID Sid
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE3)
NTSYSAPI
BOOLEAN
NTAPI
RtlIsStateSeparationEnabled(
    VOID
    );
#endif

typedef enum _APPCONTAINER_SID_TYPE
{
    NotAppContainerSidType,
    ChildAppContainerSidType,
    ParentAppContainerSidType,
    InvalidAppContainerSidType,
    MaxAppContainerSidType
} APPCONTAINER_SID_TYPE, *PAPPCONTAINER_SID_TYPE;

#if (PHNT_VERSION >= PHNT_WINBLUE)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetAppContainerSidType(
    _In_ PSID AppContainerSid,
    _Out_ PAPPCONTAINER_SID_TYPE AppContainerSidType
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlFlsAlloc(
    _In_ PFLS_CALLBACK_FUNCTION Callback,
    _Out_ PULONG FlsIndex
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlFlsFree(
    _In_ ULONG FlsIndex
    );

#if (PHNT_VERSION >= PHNT_20H1)
NTSYSAPI
NTSTATUS
WINAPI
RtlFlsGetValue(
    _In_ ULONG FlsIndex,
    _Out_ PVOID* FlsData
    );

NTSYSAPI
NTSTATUS
WINAPI
RtlFlsSetValue(
    _In_ ULONG FlsIndex,
    _In_ PVOID FlsData
    );
#endif

typedef enum _STATE_LOCATION_TYPE
{
    LocationTypeRegistry,
    LocationTypeFileSystem,
    LocationTypeMaximum
} STATE_LOCATION_TYPE;

#if (PHNT_VERSION >= PHNT_REDSTONE3)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlGetPersistedStateLocation(
    _In_ PCWSTR SourceID,
    _In_opt_ PCWSTR CustomValue,
    _In_opt_ PCWSTR DefaultPath,
    _In_ STATE_LOCATION_TYPE StateLocationType,
    _Out_writes_bytes_to_opt_(BufferLengthIn, *BufferLengthOut) PWCHAR TargetPath,
    _In_ ULONG BufferLengthIn,
    _Out_opt_ PULONG BufferLengthOut
    );

// msdn
NTSYSAPI
BOOLEAN
NTAPI
RtlIsCloudFilesPlaceholder(
    _In_ ULONG FileAttributes,
    _In_ ULONG ReparseTag
    );

// msdn
NTSYSAPI
BOOLEAN
NTAPI
RtlIsPartialPlaceholder(
    _In_ ULONG FileAttributes,
    _In_ ULONG ReparseTag
    );

// msdn
NTSYSAPI
NTSTATUS
NTAPI
RtlIsPartialPlaceholderFileHandle(
    _In_ HANDLE FileHandle,
    _Out_ PBOOLEAN IsPartialPlaceholder
    );

// msdn
NTSYSAPI
NTSTATUS
NTAPI
RtlIsPartialPlaceholderFileInfo(
    _In_ PVOID InfoBuffer,
    _In_ FILE_INFORMATION_CLASS InfoClass,
    _Out_ PBOOLEAN IsPartialPlaceholder
    );

#undef PHCM_MAX
#define PHCM_APPLICATION_DEFAULT ((CHAR)0)
#define PHCM_DISGUISE_PLACEHOLDERS ((CHAR)1)
#define PHCM_EXPOSE_PLACEHOLDERS ((CHAR)2)
#define PHCM_MAX ((CHAR)2)

#define PHCM_ERROR_INVALID_PARAMETER ((CHAR)-1)
#define PHCM_ERROR_NO_TEB ((CHAR)-2)

NTSYSAPI
CHAR
NTAPI
RtlQueryThreadPlaceholderCompatibilityMode(
    VOID
    );

NTSYSAPI
CHAR
NTAPI
RtlSetThreadPlaceholderCompatibilityMode(
    _In_ CHAR Mode
    );

#endif

#if (PHNT_VERSION >= PHNT_REDSTONE4)

#undef PHCM_MAX
#define PHCM_DISGUISE_FULL_PLACEHOLDERS ((CHAR)3)
#define PHCM_MAX ((CHAR)3)
#define PHCM_ERROR_NO_PEB ((CHAR)-3)

NTSYSAPI
CHAR
NTAPI
RtlQueryProcessPlaceholderCompatibilityMode(
    VOID
    );

NTSYSAPI
CHAR
NTAPI
RtlSetProcessPlaceholderCompatibilityMode(
    _In_ CHAR Mode
    );

#endif

#if (PHNT_VERSION >= PHNT_REDSTONE2)
// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsNonEmptyDirectoryReparsePointAllowed(
    _In_ ULONG ReparseTag
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlAppxIsFileOwnedByTrustedInstaller(
    _In_ HANDLE FileHandle,
    _Out_ PBOOLEAN IsFileOwnedByTrustedInstaller
    );
#endif

// Windows Internals book
#define PSM_ACTIVATION_TOKEN_PACKAGED_APPLICATION 0x1
#define PSM_ACTIVATION_TOKEN_SHARED_ENTITY 0x2
#define PSM_ACTIVATION_TOKEN_FULL_TRUST 0x4
#define PSM_ACTIVATION_TOKEN_NATIVE_SERVICE 0x8
#define PSM_ACTIVATION_TOKEN_DEVELOPMENT_APP 0x10
#define BREAKAWAY_INHIBITED 0x20

// private
typedef struct _PS_PKG_CLAIM
{
    ULONG Flags;  // PSM_ACTIVATION_TOKEN_*
    ULONG Origin; // PackageOrigin from appmodel.h
} PS_PKG_CLAIM, *PPS_PKG_CLAIM;

#if (PHNT_VERSION >= PHNT_THRESHOLD)
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryPackageClaims(
    _In_ HANDLE TokenHandle,
    _Out_writes_bytes_to_opt_(*PackageSize, *PackageSize) PWSTR PackageFullName,
    _Inout_opt_ PSIZE_T PackageSize,
    _Out_writes_bytes_to_opt_(*AppIdSize, *AppIdSize) PWSTR AppId,
    _Inout_opt_ PSIZE_T AppIdSize,
    _Out_opt_ PGUID DynamicId,
    _Out_opt_ PPS_PKG_CLAIM PkgClaim,
    _Out_opt_ PULONG64 AttributesPresent
    );
#endif

// Protected policies

#if (PHNT_VERSION >= PHNT_WINBLUE)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryProtectedPolicy(
    _In_ PGUID PolicyGuid,
    _Out_ PULONG_PTR PolicyValue
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSetProtectedPolicy(
    _In_ PGUID PolicyGuid,
    _In_ ULONG_PTR PolicyValue,
    _Out_ PULONG_PTR OldPolicyValue
    );
#endif

#if (PHNT_VERSION >= PHNT_THRESHOLD)
// private
NTSYSAPI
BOOLEAN
NTAPI
RtlIsMultiSessionSku(
    VOID
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE)
// private
NTSYSAPI
BOOLEAN
NTAPI
RtlIsMultiUsersInSessionSku(
    VOID
    );
#endif

// private
typedef enum _RTL_BSD_ITEM_TYPE
{
    RtlBsdItemVersionNumber, // q; s: ULONG
    RtlBsdItemProductType, // q; s: NT_PRODUCT_TYPE (ULONG)
    RtlBsdItemAabEnabled, // q: s: BOOLEAN // AutoAdvancedBoot
    RtlBsdItemAabTimeout, // q: s: UCHAR // AdvancedBootMenuTimeout
    RtlBsdItemBootGood, // q: s: BOOLEAN // LastBootSucceeded
    RtlBsdItemBootShutdown, // q: s: BOOLEAN // LastBootShutdown
    RtlBsdSleepInProgress, // q: s: BOOLEAN // SleepInProgress
    RtlBsdPowerTransition, // q: s: RTL_BSD_DATA_POWER_TRANSITION
    RtlBsdItemBootAttemptCount, // q: s: UCHAR // BootAttemptCount
    RtlBsdItemBootCheckpoint, // q: s: UCHAR // LastBootCheckpoint
    RtlBsdItemBootId, // q; s: ULONG (USER_SHARED_DATA->BootId)
    RtlBsdItemShutdownBootId, // q; s: ULONG
    RtlBsdItemReportedAbnormalShutdownBootId, // q; s: ULONG
    RtlBsdItemErrorInfo, // RTL_BSD_DATA_ERROR_INFO
    RtlBsdItemPowerButtonPressInfo, // RTL_BSD_POWER_BUTTON_PRESS_INFO
    RtlBsdItemChecksum, // q: s: UCHAR
    RtlBsdPowerTransitionExtension,
    RtlBsdItemFeatureConfigurationState, // q; s: ULONG
    RtlBsdItemMax
} RTL_BSD_ITEM_TYPE;

// ros
typedef struct _RTL_BSD_DATA_POWER_TRANSITION
{
    LARGE_INTEGER PowerButtonTimestamp;
    struct
    {
        BOOLEAN SystemRunning : 1;
        BOOLEAN ConnectedStandbyInProgress : 1;
        BOOLEAN UserShutdownInProgress : 1;
        BOOLEAN SystemShutdownInProgress : 1;
        BOOLEAN SleepInProgress : 4;
    } Flags;
    UCHAR ConnectedStandbyScenarioInstanceId;
    UCHAR ConnectedStandbyEntryReason;
    UCHAR ConnectedStandbyExitReason;
    USHORT SystemSleepTransitionCount;
    LARGE_INTEGER LastReferenceTime;
    ULONG LastReferenceTimeChecksum;
    ULONG LastUpdateBootId;
} RTL_BSD_DATA_POWER_TRANSITION, *PRTL_BSD_DATA_POWER_TRANSITION;

// ros
typedef struct _RTL_BSD_DATA_ERROR_INFO
{
    ULONG BootId;
    ULONG RepeatCount;
    ULONG OtherErrorCount;
    ULONG Code;
    ULONG OtherErrorCount2;
} RTL_BSD_DATA_ERROR_INFO, *PRTL_BSD_DATA_ERROR_INFO;

// ros
typedef struct _RTL_BSD_POWER_BUTTON_PRESS_INFO
{
    LARGE_INTEGER LastPressTime;
    ULONG CumulativePressCount;
    USHORT LastPressBootId;
    UCHAR LastPowerWatchdogStage;
    struct
    {
        UCHAR WatchdogArmed : 1;
        UCHAR ShutdownInProgress : 1;
    } Flags;
    LARGE_INTEGER LastReleaseTime;
    ULONG CumulativeReleaseCount;
    USHORT LastReleaseBootId;
    USHORT ErrorCount;
    UCHAR CurrentConnectedStandbyPhase;
    ULONG TransitionLatestCheckpointId;
    ULONG TransitionLatestCheckpointType;
    ULONG TransitionLatestCheckpointSequenceNumber;
} RTL_BSD_POWER_BUTTON_PRESS_INFO, *PRTL_BSD_POWER_BUTTON_PRESS_INFO;

// private
typedef struct _RTL_BSD_ITEM
{
    RTL_BSD_ITEM_TYPE Type;
    PVOID DataBuffer;
    ULONG DataLength;
} RTL_BSD_ITEM, *PRTL_BSD_ITEM;

// ros
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateBootStatusDataFile(
    VOID
    );

// ros
NTSYSAPI
NTSTATUS
NTAPI
RtlLockBootStatusData(
    _Out_ PHANDLE FileHandle
    );

// ros
NTSYSAPI
NTSTATUS
NTAPI
RtlUnlockBootStatusData(
    _In_ HANDLE FileHandle
    );

// ros
NTSYSAPI
NTSTATUS
NTAPI
RtlGetSetBootStatusData(
    _In_ HANDLE FileHandle,
    _In_ BOOLEAN Read,
    _In_ RTL_BSD_ITEM_TYPE DataClass,
    _In_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ReturnLength
    );

#if (PHNT_VERSION >= PHNT_REDSTONE)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCheckBootStatusIntegrity(
    _In_ HANDLE FileHandle,
    _Out_ PBOOLEAN Verified
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlRestoreBootStatusDefaults(
    _In_ HANDLE FileHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE3)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlRestoreSystemBootStatusDefaults(
    VOID
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetSystemBootStatus(
    _In_ RTL_BSD_ITEM_TYPE BootStatusInformationClass,
    _Out_ PVOID DataBuffer,
    _In_ ULONG DataLength,
    _Out_opt_ PULONG ReturnLength
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSetSystemBootStatus(
    _In_ RTL_BSD_ITEM_TYPE BootStatusInformationClass,
    _In_ PVOID DataBuffer,
    _In_ ULONG DataLength,
    _Out_opt_ PULONG ReturnLength
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCheckPortableOperatingSystem(
    _Out_ PBOOLEAN IsPortable // VOID
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSetPortableOperatingSystem(
    _In_ BOOLEAN IsPortable
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
NTSTATUS
NTAPI
RtlFindClosestEncodableLength(
    _In_ ULONGLONG SourceLength,
    _Out_ PULONGLONG TargetLength
    );

#endif

// Memory cache

typedef NTSTATUS (NTAPI *PRTL_SECURE_MEMORY_CACHE_CALLBACK)(
    _In_ PVOID Address,
    _In_ SIZE_T Length
    );

// ros
NTSYSAPI
NTSTATUS
NTAPI
RtlRegisterSecureMemoryCacheCallback(
    _In_ PRTL_SECURE_MEMORY_CACHE_CALLBACK Callback
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeregisterSecureMemoryCacheCallback(
    _In_ PRTL_SECURE_MEMORY_CACHE_CALLBACK Callback
    );

// ros
NTSYSAPI
BOOLEAN
NTAPI
RtlFlushSecureMemoryCache(
    _In_ PVOID MemoryCache,
    _In_opt_ SIZE_T MemoryLength
    );

#if (PHNT_VERSION >= PHNT_20H1)

// Feature configuration

typedef struct __RTL_FEATURE_USAGE_REPORT
{
    ULONG FeatureId;
    USHORT ReportingKind;
    USHORT ReportingOptions;
} RTL_FEATURE_USAGE_REPORT, *PRTL_FEATURE_USAGE_REPORT;

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlNotifyFeatureUsage(
    _In_ PRTL_FEATURE_USAGE_REPORT FeatureUsageReport
    );

typedef enum _RTL_FEATURE_CONFIGURATION_TYPE
{
    RtlFeatureConfigurationBoot,
    RtlFeatureConfigurationRuntime,
    RtlFeatureConfigurationCount
} RTL_FEATURE_CONFIGURATION_TYPE;

// rev
typedef struct _RTL_FEATURE_CONFIGURATION
{
    ULONG FeatureId;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG Priority : 4;
            ULONG EnabledState : 2;
            ULONG IsWexpConfiguration : 1;
            ULONG HasSubscriptions : 1;
            ULONG Variant : 6;
            ULONG VariantPayloadKind : 2;
            ULONG Reserved : 16;
        };
    };
    ULONG VariantPayload;
} RTL_FEATURE_CONFIGURATION, *PRTL_FEATURE_CONFIGURATION;

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryFeatureConfiguration(
    _In_ ULONG FeatureId,
    _In_ RTL_FEATURE_CONFIGURATION_TYPE FeatureType,
    _Inout_ PULONGLONG ChangeStamp,
    _In_ PRTL_FEATURE_CONFIGURATION FeatureConfiguration
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSetFeatureConfigurations(
    _Inout_ PULONGLONG ChangeStamp,
    _In_ RTL_FEATURE_CONFIGURATION_TYPE FeatureType,
    _In_ PRTL_FEATURE_CONFIGURATION FeatureConfiguration,
    _In_ ULONG FeatureConfigurationCount
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryAllFeatureConfigurations(
    _In_ RTL_FEATURE_CONFIGURATION_TYPE FeatureType,
    _Inout_ PULONGLONG ChangeStamp,
    _Out_ PRTL_FEATURE_CONFIGURATION FeatureConfigurations,
    _Inout_ PULONG FeatureConfigurationCount
    );

// rev
NTSYSAPI
ULONGLONG
NTAPI
RtlQueryFeatureConfigurationChangeStamp(
    VOID
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryFeatureUsageNotificationSubscriptions(
    _Out_ PRTL_FEATURE_CONFIGURATION FeatureConfiguration,
    _Inout_ PULONG FeatureConfigurationCount
    );

typedef VOID (NTAPI *PRTL_FEATURE_CONFIGURATION_CHANGE_NOTIFICATION)(
    _In_opt_ PVOID Context
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlRegisterFeatureConfigurationChangeNotification(
    _In_ PRTL_FEATURE_CONFIGURATION_CHANGE_NOTIFICATION Callback,
    _In_opt_ PVOID Context,
    _Inout_opt_ PULONGLONG ChangeStamp,
    _Out_ PHANDLE NotificationHandle
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlUnregisterFeatureConfigurationChangeNotification(
    _In_ HANDLE NotificationHandle
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSubscribeForFeatureUsageNotification(
    _In_ PRTL_FEATURE_CONFIGURATION FeatureConfiguration,
    _In_ ULONG FeatureConfigurationCount
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlUnsubscribeFromFeatureUsageNotifications(
    _In_ PRTL_FEATURE_CONFIGURATION FeatureConfiguration,
    _In_ ULONG FeatureConfigurationCount
    );
#endif

#endif
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)

/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTSEAPI_H
#define _NTSEAPI_H

// Privileges

#define SE_MIN_WELL_KNOWN_PRIVILEGE (2L)
#define SE_CREATE_TOKEN_PRIVILEGE (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE (3L)
#define SE_LOCK_MEMORY_PRIVILEGE (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE (5L)

#define SE_MACHINE_ACCOUNT_PRIVILEGE (6L)
#define SE_TCB_PRIVILEGE (7L)
#define SE_SECURITY_PRIVILEGE (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE (9L)
#define SE_LOAD_DRIVER_PRIVILEGE (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE (11L)
#define SE_SYSTEMTIME_PRIVILEGE (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE (16L)
#define SE_BACKUP_PRIVILEGE (17L)
#define SE_RESTORE_PRIVILEGE (18L)
#define SE_SHUTDOWN_PRIVILEGE (19L)
#define SE_DEBUG_PRIVILEGE (20L)
#define SE_AUDIT_PRIVILEGE (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE (24L)
#define SE_UNDOCK_PRIVILEGE (25L)
#define SE_SYNC_AGENT_PRIVILEGE (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE (27L)
#define SE_MANAGE_VOLUME_PRIVILEGE (28L)
#define SE_IMPERSONATE_PRIVILEGE (29L)
#define SE_CREATE_GLOBAL_PRIVILEGE (30L)
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE (31L)
#define SE_RELABEL_PRIVILEGE (32L)
#define SE_INC_WORKING_SET_PRIVILEGE (33L)
#define SE_TIME_ZONE_PRIVILEGE (34L)
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE (35L)
#define SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE (36L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE

// Authz

// begin_rev

#if (PHNT_MODE == PHNT_MODE_KERNEL)
typedef enum _TOKEN_INFORMATION_CLASS
{
    TokenUser = 1, // q: TOKEN_USER
    TokenGroups, // q: TOKEN_GROUPS
    TokenPrivileges, // q: TOKEN_PRIVILEGES
    TokenOwner, // q; s: TOKEN_OWNER
    TokenPrimaryGroup, // q; s: TOKEN_PRIMARY_GROUP
    TokenDefaultDacl, // q; s: TOKEN_DEFAULT_DACL
    TokenSource, // q: TOKEN_SOURCE
    TokenType, // q: TOKEN_TYPE
    TokenImpersonationLevel, // q: SECURITY_IMPERSONATION_LEVEL
    TokenStatistics, // q: TOKEN_STATISTICS // 10
    TokenRestrictedSids, // q: TOKEN_GROUPS
    TokenSessionId, // q; s: ULONG (requires SeTcbPrivilege)
    TokenGroupsAndPrivileges, // q: TOKEN_GROUPS_AND_PRIVILEGES
    TokenSessionReference, // s: ULONG (requires SeTcbPrivilege)
    TokenSandBoxInert, // q: ULONG
    TokenAuditPolicy, // q; s: TOKEN_AUDIT_POLICY (requires SeSecurityPrivilege/SeTcbPrivilege)
    TokenOrigin, // q; s: TOKEN_ORIGIN (requires SeTcbPrivilege)
    TokenElevationType, // q: TOKEN_ELEVATION_TYPE
    TokenLinkedToken, // q; s: TOKEN_LINKED_TOKEN (requires SeCreateTokenPrivilege)
    TokenElevation, // q: TOKEN_ELEVATION // 20
    TokenHasRestrictions, // q: ULONG
    TokenAccessInformation, // q: TOKEN_ACCESS_INFORMATION
    TokenVirtualizationAllowed, // q; s: ULONG (requires SeCreateTokenPrivilege)
    TokenVirtualizationEnabled, // q; s: ULONG
    TokenIntegrityLevel, // q; s: TOKEN_MANDATORY_LABEL
    TokenUIAccess, // q; s: ULONG
    TokenMandatoryPolicy, // q; s: TOKEN_MANDATORY_POLICY (requires SeTcbPrivilege)
    TokenLogonSid, // q: TOKEN_GROUPS
    TokenIsAppContainer, // q: ULONG
    TokenCapabilities, // q: TOKEN_GROUPS // 30
    TokenAppContainerSid, // q: TOKEN_APPCONTAINER_INFORMATION
    TokenAppContainerNumber, // q: ULONG
    TokenUserClaimAttributes, // q: CLAIM_SECURITY_ATTRIBUTES_INFORMATION
    TokenDeviceClaimAttributes, // q: CLAIM_SECURITY_ATTRIBUTES_INFORMATION
    TokenRestrictedUserClaimAttributes, // q: CLAIM_SECURITY_ATTRIBUTES_INFORMATION
    TokenRestrictedDeviceClaimAttributes, // q: CLAIM_SECURITY_ATTRIBUTES_INFORMATION
    TokenDeviceGroups, // q: TOKEN_GROUPS
    TokenRestrictedDeviceGroups, // q: TOKEN_GROUPS
    TokenSecurityAttributes, // q; s: TOKEN_SECURITY_ATTRIBUTES_[AND_OPERATION_]INFORMATION
    TokenIsRestricted, // q: ULONG // 40
    TokenProcessTrustLevel, // q: TOKEN_PROCESS_TRUST_LEVEL
    TokenPrivateNameSpace, // q; s: ULONG
    TokenSingletonAttributes, // q: TOKEN_SECURITY_ATTRIBUTES_INFORMATION
    TokenBnoIsolation, // q: TOKEN_BNO_ISOLATION_INFORMATION
    TokenChildProcessFlags, // s: ULONG
    TokenIsLessPrivilegedAppContainer, // q: ULONG
    TokenIsSandboxed, // q: ULONG
    TokenIsAppSilo, // TokenOriginatingProcessTrustLevel // q: TOKEN_PROCESS_TRUST_LEVEL
    MaxTokenInfoClass
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;
#endif

// Types

#define TOKEN_SECURITY_ATTRIBUTE_TYPE_INVALID 0x00
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_INT64 0x01
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_UINT64 0x02
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_STRING 0x03
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_FQBN 0x04
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_SID 0x05
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_BOOLEAN 0x06
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING 0x10

// Flags

#define TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE 0x0001
#define TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE 0x0002
#define TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY 0x0004
#define TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT 0x0008
#define TOKEN_SECURITY_ATTRIBUTE_DISABLED 0x0010
#define TOKEN_SECURITY_ATTRIBUTE_MANDATORY 0x0020
#define TOKEN_SECURITY_ATTRIBUTE_COMPARE_IGNORE 0x0040

#define TOKEN_SECURITY_ATTRIBUTE_VALID_FLAGS ( \
    TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE | \
    TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE | \
    TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY | \
    TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT | \
    TOKEN_SECURITY_ATTRIBUTE_DISABLED | \
    TOKEN_SECURITY_ATTRIBUTE_MANDATORY)

#define TOKEN_SECURITY_ATTRIBUTE_CUSTOM_FLAGS 0xffff0000

// end_rev

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE
{
    ULONG64 Version;
    UNICODE_STRING Name;
} TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE;

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE
{
    PVOID pValue;
    ULONG ValueLength;
} TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTE_V1
{
    UNICODE_STRING Name;
    USHORT ValueType;
    USHORT Reserved;
    ULONG Flags;
    ULONG ValueCount;
    union
    {
        PLONG64 pInt64;
        PULONG64 pUint64;
        PUNICODE_STRING pString;
        PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE pFqbn;
        PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
    } Values;
} TOKEN_SECURITY_ATTRIBUTE_V1, *PTOKEN_SECURITY_ATTRIBUTE_V1;

// rev
#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1 1
// rev
#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTES_INFORMATION
{
    USHORT Version;
    USHORT Reserved;
    ULONG AttributeCount;
    union
    {
        PTOKEN_SECURITY_ATTRIBUTE_V1 pAttributeV1;
    } Attribute;
} TOKEN_SECURITY_ATTRIBUTES_INFORMATION, *PTOKEN_SECURITY_ATTRIBUTES_INFORMATION;

// private
typedef enum _TOKEN_SECURITY_ATTRIBUTE_OPERATION
{
    TOKEN_SECURITY_ATTRIBUTE_OPERATION_NONE,
    TOKEN_SECURITY_ATTRIBUTE_OPERATION_REPLACE_ALL,
    TOKEN_SECURITY_ATTRIBUTE_OPERATION_ADD,
    TOKEN_SECURITY_ATTRIBUTE_OPERATION_DELETE,
    TOKEN_SECURITY_ATTRIBUTE_OPERATION_REPLACE
} TOKEN_SECURITY_ATTRIBUTE_OPERATION, *PTOKEN_SECURITY_ATTRIBUTE_OPERATION;

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTES_AND_OPERATION_INFORMATION
{
    PTOKEN_SECURITY_ATTRIBUTES_INFORMATION Attributes;
    PTOKEN_SECURITY_ATTRIBUTE_OPERATION Operations;
} TOKEN_SECURITY_ATTRIBUTES_AND_OPERATION_INFORMATION, *PTOKEN_SECURITY_ATTRIBUTES_AND_OPERATION_INFORMATION;

// rev
typedef struct _TOKEN_PROCESS_TRUST_LEVEL
{
    PSID TrustLevelSid;
} TOKEN_PROCESS_TRUST_LEVEL, *PTOKEN_PROCESS_TRUST_LEVEL;

// Tokens

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateToken(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE Type,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE Source
    );

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateLowBoxToken(
    _Out_ PHANDLE TokenHandle,
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PSID PackageSid,
    _In_ ULONG CapabilityCount,
    _In_reads_opt_(CapabilityCount) PSID_AND_ATTRIBUTES Capabilities,
    _In_ ULONG HandleCount,
    _In_reads_opt_(HandleCount) HANDLE *Handles
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTokenEx(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE Type,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION UserAttributes,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION DeviceAttributes,
    _In_opt_ PTOKEN_GROUPS DeviceGroups,
    _In_opt_ PTOKEN_MANDATORY_POLICY MandatoryPolicy,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE Source
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcessToken(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcessTokenEx(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThreadToken(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThreadTokenEx(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDuplicateToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN EffectiveOnly,
    _In_ TOKEN_TYPE Type,
    _Out_ PHANDLE NewTokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength,
    _Out_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAdjustPrivilegesToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN DisableAllPrivileges,
    _In_opt_ PTOKEN_PRIVILEGES NewState,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAdjustGroupsToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN ResetToDefault,
    _In_opt_ PTOKEN_GROUPS NewState,
    _In_opt_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
    _Out_opt_ PULONG ReturnLength
    );

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtAdjustTokenClaimsAndDeviceGroups(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN UserResetToDefault,
    _In_ BOOLEAN DeviceResetToDefault,
    _In_ BOOLEAN DeviceGroupsResetToDefault,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewUserState,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewDeviceState,
    _In_opt_ PTOKEN_GROUPS NewDeviceGroupsState,
    _In_ ULONG UserBufferLength,
    _Out_writes_bytes_to_opt_(UserBufferLength, *UserReturnLength) PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousUserState,
    _In_ ULONG DeviceBufferLength,
    _Out_writes_bytes_to_opt_(DeviceBufferLength, *DeviceReturnLength) PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousDeviceState,
    _In_ ULONG DeviceGroupsBufferLength,
    _Out_writes_bytes_to_opt_(DeviceGroupsBufferLength, *DeviceGroupsReturnBufferLength) PTOKEN_GROUPS PreviousDeviceGroups,
    _Out_opt_ PULONG UserReturnLength,
    _Out_opt_ PULONG DeviceReturnLength,
    _Out_opt_ PULONG DeviceGroupsReturnBufferLength
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFilterToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ULONG Flags,
    _In_opt_ PTOKEN_GROUPS SidsToDisable,
    _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
    _In_opt_ PTOKEN_GROUPS RestrictedSids,
    _Out_ PHANDLE NewTokenHandle
    );

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtFilterTokenEx(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ULONG Flags,
    _In_opt_ PTOKEN_GROUPS SidsToDisable,
    _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
    _In_opt_ PTOKEN_GROUPS RestrictedSids,
    _In_ ULONG DisableUserClaimsCount,
    _In_opt_ PUNICODE_STRING UserClaimsToDisable,
    _In_ ULONG DisableDeviceClaimsCount,
    _In_opt_ PUNICODE_STRING DeviceClaimsToDisable,
    _In_opt_ PTOKEN_GROUPS DeviceGroupsToDisable,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedUserAttributes,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedDeviceAttributes,
    _In_opt_ PTOKEN_GROUPS RestrictedDeviceGroups,
    _Out_ PHANDLE NewTokenHandle
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompareTokens(
    _In_ HANDLE FirstTokenHandle,
    _In_ HANDLE SecondTokenHandle,
    _Out_ PBOOLEAN Equal
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrivilegeCheck(
    _In_ HANDLE ClientToken,
    _Inout_ PPRIVILEGE_SET RequiredPrivileges,
    _Out_ PBOOLEAN Result
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtImpersonateAnonymousToken(
    _In_ HANDLE ThreadHandle
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySecurityAttributesToken(
    _In_ HANDLE TokenHandle,
    _In_reads_opt_(NumberOfAttributes) PUNICODE_STRING Attributes,
    _In_ ULONG NumberOfAttributes,
    _Out_writes_bytes_(Length) PVOID Buffer, // PTOKEN_SECURITY_ATTRIBUTES_INFORMATION
    _In_ ULONG Length,
    _Out_ PULONG ReturnLength
    );
#endif

// Access checking

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheck(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByType(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeResultList(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus
    );

// Signing

#if (PHNT_VERSION >= PHNT_THRESHOLD)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetCachedSigningLevel(
    _In_ ULONG Flags,
    _In_ SE_SIGNING_LEVEL InputSigningLevel,
    _In_reads_(SourceFileCount) PHANDLE SourceFiles,
    _In_ ULONG SourceFileCount,
    _In_opt_ HANDLE TargetFile
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetCachedSigningLevel(
    _In_ HANDLE File,
    _Out_ PULONG Flags,
    _Out_ PSE_SIGNING_LEVEL SigningLevel,
    _Out_writes_bytes_to_opt_(*ThumbprintSize, *ThumbprintSize) PUCHAR Thumbprint,
    _Inout_opt_ PULONG ThumbprintSize,
    _Out_opt_ PULONG ThumbprintAlgorithm
    );

// rev
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompareSigningLevels(
    _In_ SE_SIGNING_LEVEL FirstSigningLevel,
    _In_ SE_SIGNING_LEVEL SecondSigningLevel
    );

#endif

// Audit alarm

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckAndAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeAndAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ AUDIT_EVENT_TYPE AuditType,
    _In_ ULONG Flags,
    _In_reads_opt_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeResultListAndAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ AUDIT_EVENT_TYPE AuditType,
    _In_ ULONG Flags,
    _In_reads_opt_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeResultListAndAuditAlarmByHandle(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ HANDLE ClientToken,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ AUDIT_EVENT_TYPE AuditType,
    _In_ ULONG Flags,
    _In_reads_opt_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ACCESS_MASK GrantedAccess,
    _In_opt_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN ObjectCreation,
    _In_ BOOLEAN AccessGranted,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrivilegeObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN AccessGranted
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCloseObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ BOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ BOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrivilegedServiceAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_ PUNICODE_STRING ServiceName,
    _In_ HANDLE ClientToken,
    _In_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN AccessGranted
    );

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTTMAPI_H
#define _NTTMAPI_H

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ ULONG CommitStrength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ LPGUID TmIdentity,
    _In_opt_ ULONG OpenOptions
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRenameTransactionManager(
    _In_ PUNICODE_STRING LogFileName,
    _In_ LPGUID ExistingTransactionManagerGuid
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollforwardTransactionManager(
    _In_ HANDLE TransactionManagerHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverTransactionManager(
    _In_ HANDLE TransactionManagerHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationTransactionManager(
    _In_ HANDLE TransactionManagerHandle,
    _In_ TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
    _Out_writes_bytes_(TransactionManagerInformationLength) PVOID TransactionManagerInformation,
    _In_ ULONG TransactionManagerInformationLength,
    _Out_opt_ PULONG ReturnLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationTransactionManager(
    _In_opt_ HANDLE TmHandle,
    _In_ TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
    _In_reads_bytes_(TransactionManagerInformationLength) PVOID TransactionManagerInformation,
    _In_ ULONG TransactionManagerInformationLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateTransactionObject(
    _In_opt_ HANDLE RootObjectHandle,
    _In_ KTMOBJECT_TYPE QueryType,
    _Inout_updates_bytes_(ObjectCursorLength) PKTMOBJECT_CURSOR ObjectCursor,
    _In_ ULONG ObjectCursorLength,
    _Out_ PULONG ReturnLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ ULONG IsolationLevel,
    _In_opt_ ULONG IsolationFlags,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_opt_ PUNICODE_STRING Description
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    _Out_writes_bytes_(TransactionInformationLength) PVOID TransactionInformation,
    _In_ ULONG TransactionInformationLength,
    _Out_opt_ PULONG ReturnLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    _In_reads_bytes_(TransactionInformationLength) PVOID TransactionInformation,
    _In_ ULONG TransactionInformationLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ HANDLE TransactionHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_ NOTIFICATION_MASK NotificationMask,
    _In_opt_ PVOID EnlistmentKey
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ LPGUID EnlistmentGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_ ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
    _Out_writes_bytes_(EnlistmentInformationLength) PVOID EnlistmentInformation,
    _In_ ULONG EnlistmentInformationLength,
    _Out_opt_ PULONG ReturnLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationEnlistment(
    _In_opt_ HANDLE EnlistmentHandle,
    _In_ ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
    _In_reads_bytes_(EnlistmentInformationLength) PVOID EnlistmentInformation,
    _In_ ULONG EnlistmentInformationLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PVOID EnlistmentKey
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrePrepareEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrepareEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrePrepareComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrepareComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadOnlyEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSinglePhaseReject(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_ LPGUID RmGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ PUNICODE_STRING Description
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_opt_ LPGUID ResourceManagerGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverResourceManager(
    _In_ HANDLE ResourceManagerHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNotificationResourceManager(
    _In_ HANDLE ResourceManagerHandle,
    _Out_ PTRANSACTION_NOTIFICATION TransactionNotification,
    _In_ ULONG NotificationLength,
    _In_opt_ PLARGE_INTEGER Timeout,
    _Out_opt_ PULONG ReturnLength,
    _In_ ULONG Asynchronous,
    _In_opt_ ULONG_PTR AsynchronousContext
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationResourceManager(
    _In_ HANDLE ResourceManagerHandle,
    _In_ RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
    _Out_writes_bytes_(ResourceManagerInformationLength) PVOID ResourceManagerInformation,
    _In_ ULONG ResourceManagerInformationLength,
    _Out_opt_ PULONG ReturnLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationResourceManager(
    _In_ HANDLE ResourceManagerHandle,
    _In_ RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
    _In_reads_bytes_(ResourceManagerInformationLength) PVOID ResourceManagerInformation,
    _In_ ULONG ResourceManagerInformationLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRegisterProtocolAddressInformation(
    _In_ HANDLE ResourceManager,
    _In_ PCRM_PROTOCOL_ID ProtocolId,
    _In_ ULONG ProtocolInformationSize,
    _In_ PVOID ProtocolInformation,
    _In_opt_ ULONG CreateOptions
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtPropagationComplete(
    _In_ HANDLE ResourceManagerHandle,
    _In_ ULONG RequestCookie,
    _In_ ULONG BufferLength,
    _In_ PVOID Buffer
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtPropagationFailed(
    _In_ HANDLE ResourceManagerHandle,
    _In_ ULONG RequestCookie,
    _In_ NTSTATUS PropStatus
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreezeTransactions(
    _In_ PLARGE_INTEGER FreezeTimeout,
    _In_ PLARGE_INTEGER ThawTimeout
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSCALLAPI
NTSTATUS
NTAPI
NtThawTransactions(
    VOID
    );
#endif

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTTP_H
#define _NTTP_H

// Some types are already defined in winnt.h.

typedef struct _TP_ALPC TP_ALPC, *PTP_ALPC;

// private
typedef VOID (NTAPI *PTP_ALPC_CALLBACK)(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _Inout_opt_ PVOID Context,
    _In_ PTP_ALPC Alpc
    );

// rev
typedef VOID (NTAPI *PTP_ALPC_CALLBACK_EX)(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _Inout_opt_ PVOID Context,
    _In_ PTP_ALPC Alpc,
    _In_ PVOID ApcContext
    );

#if (PHNT_VERSION >= PHNT_VISTA)

// private
_Check_return_
NTSYSAPI
NTSTATUS
NTAPI
TpAllocPool(
    _Out_ PTP_POOL *PoolReturn,
    _Reserved_ PVOID Reserved
    );

// winbase:CloseThreadpool
NTSYSAPI
VOID
NTAPI
TpReleasePool(
    _Inout_ PTP_POOL Pool
    );

// winbase:SetThreadpoolThreadMaximum
NTSYSAPI
VOID
NTAPI
TpSetPoolMaxThreads(
    _Inout_ PTP_POOL Pool,
    _In_ ULONG MaxThreads
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
TpSetPoolMinThreads(
    _Inout_ PTP_POOL Pool,
    _In_ ULONG MinThreads
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
TpQueryPoolStackInformation(
    _In_ PTP_POOL Pool,
    _Out_ PTP_POOL_STACK_INFORMATION PoolStackInformation
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
TpSetPoolStackInformation(
    _Inout_ PTP_POOL Pool,
    _In_ PTP_POOL_STACK_INFORMATION PoolStackInformation
    );
#endif

// private
_Check_return_
NTSYSAPI
NTSTATUS
NTAPI
TpAllocCleanupGroup(
    _Out_ PTP_CLEANUP_GROUP *CleanupGroupReturn
    );

// winbase:CloseThreadpoolCleanupGroup
NTSYSAPI
VOID
NTAPI
TpReleaseCleanupGroup(
    _Inout_ PTP_CLEANUP_GROUP CleanupGroup
    );

// winbase:CloseThreadpoolCleanupGroupMembers
NTSYSAPI
VOID
NTAPI
TpReleaseCleanupGroupMembers(
    _Inout_ PTP_CLEANUP_GROUP CleanupGroup,
    _In_ LOGICAL CancelPendingCallbacks,
    _Inout_opt_ PVOID CleanupParameter
    );

// winbase:SetEventWhenCallbackReturns
NTSYSAPI
VOID
NTAPI
TpCallbackSetEventOnCompletion(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _In_ HANDLE Event
    );

// winbase:ReleaseSemaphoreWhenCallbackReturns
NTSYSAPI
VOID
NTAPI
TpCallbackReleaseSemaphoreOnCompletion(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _In_ HANDLE Semaphore,
    _In_ ULONG ReleaseCount
    );

// winbase:ReleaseMutexWhenCallbackReturns
NTSYSAPI
VOID
NTAPI
TpCallbackReleaseMutexOnCompletion(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _In_ HANDLE Mutex
    );

// winbase:LeaveCriticalSectionWhenCallbackReturns
NTSYSAPI
VOID
NTAPI
TpCallbackLeaveCriticalSectionOnCompletion(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
    );

// winbase:FreeLibraryWhenCallbackReturns
NTSYSAPI
VOID
NTAPI
TpCallbackUnloadDllOnCompletion(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _In_ PVOID DllHandle
    );

// winbase:CallbackMayRunLong
NTSYSAPI
NTSTATUS
NTAPI
TpCallbackMayRunLong(
    _Inout_ PTP_CALLBACK_INSTANCE Instance
    );

// winbase:DisassociateCurrentThreadFromCallback
NTSYSAPI
VOID
NTAPI
TpDisassociateCallback(
    _Inout_ PTP_CALLBACK_INSTANCE Instance
    );

// winbase:TrySubmitThreadpoolCallback
_Check_return_
NTSYSAPI
NTSTATUS
NTAPI
TpSimpleTryPost(
    _In_ PTP_SIMPLE_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
    );

// private
_Check_return_
NTSYSAPI
NTSTATUS
NTAPI
TpAllocWork(
    _Out_ PTP_WORK *WorkReturn,
    _In_ PTP_WORK_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
    );

// winbase:CloseThreadpoolWork
NTSYSAPI
VOID
NTAPI
TpReleaseWork(
    _Inout_ PTP_WORK Work
    );

// winbase:SubmitThreadpoolWork
NTSYSAPI
VOID
NTAPI
TpPostWork(
    _Inout_ PTP_WORK Work
    );

// winbase:WaitForThreadpoolWorkCallbacks
NTSYSAPI
VOID
NTAPI
TpWaitForWork(
    _Inout_ PTP_WORK Work,
    _In_ LOGICAL CancelPendingCallbacks
    );

// private
_Check_return_
NTSYSAPI
NTSTATUS
NTAPI
TpAllocTimer(
    _Out_ PTP_TIMER *Timer,
    _In_ PTP_TIMER_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
    );

// winbase:CloseThreadpoolTimer
NTSYSAPI
VOID
NTAPI
TpReleaseTimer(
    _Inout_ PTP_TIMER Timer
    );

// winbase:SetThreadpoolTimer
NTSYSAPI
VOID
NTAPI
TpSetTimer(
    _Inout_ PTP_TIMER Timer,
    _In_opt_ PLARGE_INTEGER DueTime,
    _In_ ULONG Period,
    _In_opt_ ULONG WindowLength
    );

#if (PHNT_VERSION >= PHNT_WIN8)
// winbase:SetThreadpoolTimerEx
NTSYSAPI
NTSTATUS
NTAPI
TpSetTimerEx(
    _Inout_ PTP_TIMER Timer,
    _In_opt_ PLARGE_INTEGER DueTime,
    _In_ ULONG Period,
    _In_opt_ ULONG WindowLength
    );
#endif

// winbase:IsThreadpoolTimerSet
NTSYSAPI
LOGICAL
NTAPI
TpIsTimerSet(
    _In_ PTP_TIMER Timer
    );

// winbase:WaitForThreadpoolTimerCallbacks
NTSYSAPI
VOID
NTAPI
TpWaitForTimer(
    _Inout_ PTP_TIMER Timer,
    _In_ LOGICAL CancelPendingCallbacks
    );

// private
_Check_return_
NTSYSAPI
NTSTATUS
NTAPI
TpAllocWait(
    _Out_ PTP_WAIT *WaitReturn,
    _In_ PTP_WAIT_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
    );

// winbase:CloseThreadpoolWait
NTSYSAPI
VOID
NTAPI
TpReleaseWait(
    _Inout_ PTP_WAIT Wait
    );

// winbase:SetThreadpoolWait
NTSYSAPI
VOID
NTAPI
TpSetWait(
    _Inout_ PTP_WAIT Wait,
    _In_opt_ HANDLE Handle,
    _In_opt_ PLARGE_INTEGER Timeout
    );

#if (PHNT_VERSION >= PHNT_WIN8)
// winbase:SetThreadpoolWaitEx
NTSYSAPI
NTSTATUS
NTAPI
TpSetWaitEx(
    _Inout_ PTP_WAIT Wait,
    _In_opt_ HANDLE Handle,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_opt_ PVOID Reserved
    );
#endif

// winbase:WaitForThreadpoolWaitCallbacks
NTSYSAPI
VOID
NTAPI
TpWaitForWait(
    _Inout_ PTP_WAIT Wait,
    _In_ LOGICAL CancelPendingCallbacks
    );

// private
typedef VOID (NTAPI *PTP_IO_CALLBACK)(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _Inout_opt_ PVOID Context,
    _In_ PVOID ApcContext,
    _In_ PIO_STATUS_BLOCK IoSB,
    _In_ PTP_IO Io
    );

// private
_Check_return_
NTSYSAPI
NTSTATUS
NTAPI
TpAllocIoCompletion(
    _Out_ PTP_IO *IoReturn,
    _In_ HANDLE File,
    _In_ PTP_IO_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
    );

// winbase:CloseThreadpoolIo
NTSYSAPI
VOID
NTAPI
TpReleaseIoCompletion(
    _Inout_ PTP_IO Io
    );

// winbase:StartThreadpoolIo
NTSYSAPI
VOID
NTAPI
TpStartAsyncIoOperation(
    _Inout_ PTP_IO Io
    );

// winbase:CancelThreadpoolIo
NTSYSAPI
VOID
NTAPI
TpCancelAsyncIoOperation(
    _Inout_ PTP_IO Io
    );

// winbase:WaitForThreadpoolIoCallbacks
NTSYSAPI
VOID
NTAPI
TpWaitForIoCompletion(
    _Inout_ PTP_IO Io,
    _In_ LOGICAL CancelPendingCallbacks
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
TpAllocAlpcCompletion(
    _Out_ PTP_ALPC *AlpcReturn,
    _In_ HANDLE AlpcPort,
    _In_ PTP_ALPC_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
TpAllocAlpcCompletionEx(
    _Out_ PTP_ALPC *AlpcReturn,
    _In_ HANDLE AlpcPort,
    _In_ PTP_ALPC_CALLBACK_EX Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
    );
#endif

// private
NTSYSAPI
VOID
NTAPI
TpReleaseAlpcCompletion(
    _Inout_ PTP_ALPC Alpc
    );

// private
NTSYSAPI
VOID
NTAPI
TpWaitForAlpcCompletion(
    _Inout_ PTP_ALPC Alpc
    );

// private
typedef enum _TP_TRACE_TYPE
{
    TpTraceThreadPriority = 1,
    TpTraceThreadAffinity,
    MaxTpTraceType
} TP_TRACE_TYPE;

// private
NTSYSAPI
VOID
NTAPI
TpCaptureCaller(
    _In_ TP_TRACE_TYPE Type
    );

// private
NTSYSAPI
VOID
NTAPI
TpCheckTerminateWorker(
    _In_ HANDLE Thread
    );

#endif

#endif
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTXCAPI_H
#define _NTXCAPI_H

NTSYSAPI
BOOLEAN
NTAPI
RtlDispatchException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord
    );

NTSYSAPI
DECLSPEC_NORETURN
VOID
NTAPI
RtlRaiseStatus(
    _In_ NTSTATUS Status
    );

NTSYSAPI
VOID
NTAPI
RtlRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtContinue(
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN TestAlert
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)
typedef enum _KCONTINUE_TYPE
{
    KCONTINUE_UNWIND,
    KCONTINUE_RESUME,
    KCONTINUE_LONGJUMP,
    KCONTINUE_SET,
    KCONTINUE_LAST,
} KCONTINUE_TYPE;

typedef struct _KCONTINUE_ARGUMENT
{
    KCONTINUE_TYPE ContinueType;
    ULONG ContinueFlags;
    ULONGLONG Reserved[2];
} KCONTINUE_ARGUMENT, *PKCONTINUE_ARGUMENT;

#define KCONTINUE_FLAG_TEST_ALERT 0x00000001 // wbenny
#define KCONTINUE_FLAG_DELIVER_APC 0x00000002 // wbenny

NTSYSCALLAPI
NTSTATUS
NTAPI
NtContinueEx(
    _In_ PCONTEXT ContextRecord,
    _In_ PVOID ContinueArgument // PKCONTINUE_ARGUMENT and BOOLEAN are valid
    );

//FORCEINLINE
//NTSTATUS
//NtContinue(
//    _In_ PCONTEXT ContextRecord,
//    _In_ BOOLEAN TestAlert
//    )
//{
//    return NtContinueEx(ContextRecord, (PCONTINUE_ARGUMENT)TestAlert);
//}
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN FirstChance
    );

__analysis_noreturn
NTSYSCALLAPI
VOID
NTAPI
RtlAssert(
    _In_ PVOID VoidFailedAssertion,
    _In_ PVOID VoidFileName,
    _In_ ULONG LineNumber,
    _In_opt_ PSTR MutableMessage
    );

#define RTL_ASSERT(exp) \
    ((!(exp)) ? (RtlAssert((PVOID)#exp, (PVOID)__FILE__, __LINE__, NULL), FALSE) : TRUE)
#define RTL_ASSERTMSG(msg, exp) \
    ((!(exp)) ? (RtlAssert((PVOID)#exp, (PVOID)__FILE__, __LINE__, msg), FALSE) : TRUE)
#define RTL_SOFT_ASSERT(_exp) \
    ((!(_exp)) ? (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n", __FILE__, __LINE__, #_exp), FALSE) : TRUE)
#define RTL_SOFT_ASSERTMSG(_msg, _exp) \
    ((!(_exp)) ? (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n   Message: %s\n", __FILE__, __LINE__, #_exp, (_msg)), FALSE) : TRUE)

#endif

/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTWOW64_H
#define _NTWOW64_H

#define WOW64_SYSTEM_DIRECTORY "SysWOW64"
#define WOW64_SYSTEM_DIRECTORY_U L"SysWOW64"
#define WOW64_X86_TAG " (x86)"
#define WOW64_X86_TAG_U L" (x86)"

// In USER_SHARED_DATA
typedef enum _WOW64_SHARED_INFORMATION
{
    SharedNtdll32LdrInitializeThunk,
    SharedNtdll32KiUserExceptionDispatcher,
    SharedNtdll32KiUserApcDispatcher,
    SharedNtdll32KiUserCallbackDispatcher,
    SharedNtdll32ExpInterlockedPopEntrySListFault,
    SharedNtdll32ExpInterlockedPopEntrySListResume,
    SharedNtdll32ExpInterlockedPopEntrySListEnd,
    SharedNtdll32RtlUserThreadStart,
    SharedNtdll32pQueryProcessDebugInformationRemote,
    SharedNtdll32BaseAddress,
    SharedNtdll32LdrSystemDllInitBlock,
    Wow64SharedPageEntriesCount
} WOW64_SHARED_INFORMATION;

// 32-bit definitions

#define WOW64_POINTER(Type) ULONG

typedef struct _RTL_BALANCED_NODE32
{
    union
    {
        WOW64_POINTER(struct _RTL_BALANCED_NODE *) Children[2];
        struct
        {
            WOW64_POINTER(struct _RTL_BALANCED_NODE *) Left;
            WOW64_POINTER(struct _RTL_BALANCED_NODE *) Right;
        };
    };
    union
    {
        WOW64_POINTER(UCHAR) Red : 1;
        WOW64_POINTER(UCHAR) Balance : 2;
        WOW64_POINTER(ULONG_PTR) ParentValue;
    };
} RTL_BALANCED_NODE32, *PRTL_BALANCED_NODE32;

typedef struct _RTL_RB_TREE32
{
    WOW64_POINTER(PRTL_BALANCED_NODE) Root;
    WOW64_POINTER(PRTL_BALANCED_NODE) Min;
} RTL_RB_TREE32, *PRTL_RB_TREE32;

typedef struct _PEB_LDR_DATA32
{
    ULONG Length;
    BOOLEAN Initialized;
    WOW64_POINTER(HANDLE) SsHandle;
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
    WOW64_POINTER(PVOID) EntryInProgress;
    BOOLEAN ShutdownInProgress;
    WOW64_POINTER(HANDLE) ShutdownThreadId;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

typedef struct _LDR_SERVICE_TAG_RECORD32
{
    WOW64_POINTER(struct _LDR_SERVICE_TAG_RECORD *) Next;
    ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD32, *PLDR_SERVICE_TAG_RECORD32;

typedef struct _LDRP_CSLIST32
{
    WOW64_POINTER(PSINGLE_LIST_ENTRY) Tail;
} LDRP_CSLIST32, *PLDRP_CSLIST32;

typedef struct _LDR_DDAG_NODE32
{
    LIST_ENTRY32 Modules;
    WOW64_POINTER(PLDR_SERVICE_TAG_RECORD) ServiceTagList;
    ULONG LoadCount;
    ULONG LoadWhileUnloadingCount;
    ULONG LowestLink;
    union
    {
        LDRP_CSLIST32 Dependencies;
        SINGLE_LIST_ENTRY32 RemovalLink;
    };
    LDRP_CSLIST32 IncomingDependencies;
    LDR_DDAG_STATE State;
    SINGLE_LIST_ENTRY32 CondenseLink;
    ULONG PreorderNumber;
} LDR_DDAG_NODE32, *PLDR_DDAG_NODE32;

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP_32 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY32, DdagNode)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN7_32 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY32, BaseNameHashValue)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN8_32 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY32, ImplicitPathOptions)

typedef struct _LDR_DATA_TABLE_ENTRY32
{
    LIST_ENTRY32 InLoadOrderLinks;
    LIST_ENTRY32 InMemoryOrderLinks;
    union
    {
        LIST_ENTRY32 InInitializationOrderLinks;
        LIST_ENTRY32 InProgressLinks;
    };
    WOW64_POINTER(PVOID) DllBase;
    WOW64_POINTER(PVOID) EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING32 FullDllName;
    UNICODE_STRING32 BaseDllName;
    union
    {
        UCHAR FlagGroup[4];
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1;
            ULONG MarkedForRemoval : 1;
            ULONG ImageDll : 1;
            ULONG LoadNotificationsSent : 1;
            ULONG TelemetryEntryProcessed : 1;
            ULONG ProcessStaticImport : 1;
            ULONG InLegacyLists : 1;
            ULONG InIndexes : 1;
            ULONG ShimDll : 1;
            ULONG InExceptionTable : 1;
            ULONG ReservedFlags1 : 2;
            ULONG LoadInProgress : 1;
            ULONG LoadConfigProcessed : 1;
            ULONG EntryProcessed : 1;
            ULONG ProtectDelayLoad : 1;
            ULONG ReservedFlags3 : 2;
            ULONG DontCallForThreads : 1;
            ULONG ProcessAttachCalled : 1;
            ULONG ProcessAttachFailed : 1;
            ULONG CorDeferredValidate : 1;
            ULONG CorImage : 1;
            ULONG DontRelocate : 1;
            ULONG CorILOnly : 1;
            ULONG ChpeImage : 1;
            ULONG ReservedFlags5 : 2;
            ULONG Redirected : 1;
            ULONG ReservedFlags6 : 2;
            ULONG CompatDatabaseProcessed : 1;
        };
    };
    USHORT ObsoleteLoadCount;
    USHORT TlsIndex;
    LIST_ENTRY32 HashLinks;
    ULONG TimeDateStamp;
    WOW64_POINTER(struct _ACTIVATION_CONTEXT *) EntryPointActivationContext;
    WOW64_POINTER(PVOID) Lock;
    WOW64_POINTER(PLDR_DDAG_NODE) DdagNode;
    LIST_ENTRY32 NodeModuleLink;
    WOW64_POINTER(struct _LDRP_LOAD_CONTEXT *) LoadContext;
    WOW64_POINTER(PVOID) ParentDllBase;
    WOW64_POINTER(PVOID) SwitchBackContext;
    RTL_BALANCED_NODE32 BaseAddressIndexNode;
    RTL_BALANCED_NODE32 MappingInfoIndexNode;
    WOW64_POINTER(ULONG_PTR) OriginalBase;
    LARGE_INTEGER LoadTime;
    ULONG BaseNameHashValue;
    LDR_DLL_LOAD_REASON LoadReason;
    ULONG ImplicitPathOptions;
    ULONG ReferenceCount;
    ULONG DependentLoadFlags;
    UCHAR SigningLevel; // since REDSTONE2
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

typedef struct _CURDIR32
{
    UNICODE_STRING32 DosPath;
    WOW64_POINTER(HANDLE) Handle;
} CURDIR32, *PCURDIR32;

typedef struct _RTL_DRIVE_LETTER_CURDIR32
{
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING32 DosPath;
} RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;

typedef struct _RTL_USER_PROCESS_PARAMETERS32
{
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    WOW64_POINTER(HANDLE) ConsoleHandle;
    ULONG ConsoleFlags;
    WOW64_POINTER(HANDLE) StandardInput;
    WOW64_POINTER(HANDLE) StandardOutput;
    WOW64_POINTER(HANDLE) StandardError;

    CURDIR32 CurrentDirectory;
    UNICODE_STRING32 DllPath;
    UNICODE_STRING32 ImagePathName;
    UNICODE_STRING32 CommandLine;
    WOW64_POINTER(PVOID) Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING32 WindowTitle;
    UNICODE_STRING32 DesktopInfo;
    UNICODE_STRING32 ShellInfo;
    UNICODE_STRING32 RuntimeData;
    RTL_DRIVE_LETTER_CURDIR32 CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    WOW64_POINTER(ULONG_PTR) EnvironmentSize;
    WOW64_POINTER(ULONG_PTR) EnvironmentVersion;
    WOW64_POINTER(PVOID) PackageDependencyData;
    ULONG ProcessGroupId;
    ULONG LoaderThreads;

    UNICODE_STRING32 RedirectionDllName; // REDSTONE4
    UNICODE_STRING32 HeapPartitionName; // 19H1
    WOW64_POINTER(ULONG_PTR) DefaultThreadpoolCpuSetMasks;
    ULONG DefaultThreadpoolCpuSetMaskCount;
} RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;

typedef struct _PEB32
{
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN IsPackagedProcess : 1;
            BOOLEAN IsAppContainer : 1;
            BOOLEAN IsProtectedProcessLight : 1;
            BOOLEAN IsLongPathAwareProcess : 1;
        };
    };
    WOW64_POINTER(HANDLE) Mutant;

    WOW64_POINTER(PVOID) ImageBaseAddress;
    WOW64_POINTER(PPEB_LDR_DATA) Ldr;
    WOW64_POINTER(PRTL_USER_PROCESS_PARAMETERS) ProcessParameters;
    WOW64_POINTER(PVOID) SubSystemData;
    WOW64_POINTER(PVOID) ProcessHeap;
    WOW64_POINTER(PRTL_CRITICAL_SECTION) FastPebLock;
    WOW64_POINTER(PVOID) AtlThunkSListPtr;
    WOW64_POINTER(PVOID) IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ReservedBits0 : 27;
        };
    };
    union
    {
        WOW64_POINTER(PVOID) KernelCallbackTable;
        WOW64_POINTER(PVOID) UserSharedInfoPtr;
    };
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    WOW64_POINTER(PVOID) ApiSetMap;
    ULONG TlsExpansionCounter;
    WOW64_POINTER(PVOID) TlsBitmap;
    ULONG TlsBitmapBits[2];
    WOW64_POINTER(PVOID) ReadOnlySharedMemoryBase;
    WOW64_POINTER(PVOID) HotpatchInformation;
    WOW64_POINTER(PVOID *) ReadOnlyStaticServerData;
    WOW64_POINTER(PVOID) AnsiCodePageData;
    WOW64_POINTER(PVOID) OemCodePageData;
    WOW64_POINTER(PVOID) UnicodeCaseTableData;

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    LARGE_INTEGER CriticalSectionTimeout;
    WOW64_POINTER(SIZE_T) HeapSegmentReserve;
    WOW64_POINTER(SIZE_T) HeapSegmentCommit;
    WOW64_POINTER(SIZE_T) HeapDeCommitTotalFreeThreshold;
    WOW64_POINTER(SIZE_T) HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    WOW64_POINTER(PVOID *) ProcessHeaps;

    WOW64_POINTER(PVOID) GdiSharedHandleTable;
    WOW64_POINTER(PVOID) ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    WOW64_POINTER(PRTL_CRITICAL_SECTION) LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    WOW64_POINTER(ULONG_PTR) ActiveProcessAffinityMask;
    GDI_HANDLE_BUFFER32 GdiHandleBuffer;
    WOW64_POINTER(PVOID) PostProcessInitRoutine;

    WOW64_POINTER(PVOID) TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    WOW64_POINTER(PVOID) pShimData;
    WOW64_POINTER(PVOID) AppCompatInfo;

    UNICODE_STRING32 CSDVersion;

    WOW64_POINTER(PVOID) ActivationContextData;
    WOW64_POINTER(PVOID) ProcessAssemblyStorageMap;
    WOW64_POINTER(PVOID) SystemDefaultActivationContextData;
    WOW64_POINTER(PVOID) SystemAssemblyStorageMap;

    WOW64_POINTER(SIZE_T) MinimumStackCommit;

    WOW64_POINTER(PVOID) SparePointers[4];
    ULONG SpareUlongs[5];
    //WOW64_POINTER(PVOID *) FlsCallback;
    //LIST_ENTRY32 FlsListHead;
    //WOW64_POINTER(PVOID) FlsBitmap;
    //ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
    //ULONG FlsHighIndex;

    WOW64_POINTER(PVOID) WerRegistrationData;
    WOW64_POINTER(PVOID) WerShipAssertPtr;
    WOW64_POINTER(PVOID) pContextData;
    WOW64_POINTER(PVOID) pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG LibLoaderTracingEnabled : 1;
            ULONG SpareTracingBits : 29;
        };
    };
    ULONGLONG CsrServerReadOnlySharedMemoryBase;
    WOW64_POINTER(PVOID) TppWorkerpListLock;
    LIST_ENTRY32 TppWorkerpList;
    WOW64_POINTER(PVOID) WaitOnAddressHashTable[128];
    WOW64_POINTER(PVOID) TelemetryCoverageHeader; // REDSTONE3
    ULONG CloudFileFlags;
    ULONG CloudFileDiagFlags; // REDSTONE4
    CHAR PlaceholderCompatibilityMode;
    CHAR PlaceholderCompatibilityModeReserved[7];
} PEB32, *PPEB32;

C_ASSERT(FIELD_OFFSET(PEB32, IFEOKey) == 0x024);
C_ASSERT(FIELD_OFFSET(PEB32, UnicodeCaseTableData) == 0x060);
C_ASSERT(FIELD_OFFSET(PEB32, SystemAssemblyStorageMap) == 0x204);
C_ASSERT(FIELD_OFFSET(PEB32, pImageHeaderHash) == 0x23c);
C_ASSERT(FIELD_OFFSET(PEB32, WaitOnAddressHashTable) == 0x25c);
//C_ASSERT(sizeof(PEB32) == 0x460); // REDSTONE3
C_ASSERT(sizeof(PEB32) == 0x470);

// Note: Use PhGetProcessPeb32 instead. (dmex)
//#define WOW64_GET_PEB32(peb64) ((PPEB32)PTR_ADD_OFFSET((peb64), ALIGN_UP_BY(sizeof(PEB), PAGE_SIZE)))

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH32
{
    ULONG Offset;
    WOW64_POINTER(ULONG_PTR) HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH32, *PGDI_TEB_BATCH32;

typedef struct _TEB32
{
    NT_TIB32 NtTib;

    WOW64_POINTER(PVOID) EnvironmentPointer;
    CLIENT_ID32 ClientId;
    WOW64_POINTER(PVOID) ActiveRpcHandle;
    WOW64_POINTER(PVOID) ThreadLocalStoragePointer;
    WOW64_POINTER(PPEB) ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    WOW64_POINTER(PVOID) CsrClientThread;
    WOW64_POINTER(PVOID) Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    WOW64_POINTER(PVOID) WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    WOW64_POINTER(PVOID) ReservedForDebuggerInstrumentation[16];
    WOW64_POINTER(PVOID) SystemReserved1[36];
    UCHAR WorkingOnBehalfTicket[8];
    NTSTATUS ExceptionCode;

    WOW64_POINTER(PVOID) ActivationContextStackPointer;
    WOW64_POINTER(ULONG_PTR) InstrumentationCallbackSp;
    WOW64_POINTER(ULONG_PTR) InstrumentationCallbackPreviousPc;
    WOW64_POINTER(ULONG_PTR) InstrumentationCallbackPreviousSp;
    BOOLEAN InstrumentationCallbackDisabled;
    UCHAR SpareBytes[23];
    ULONG TxFsContext;

    GDI_TEB_BATCH32 GdiTebBatch;
    CLIENT_ID32 RealClientId;
    WOW64_POINTER(HANDLE) GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    WOW64_POINTER(PVOID) GdiThreadLocalInfo;
    WOW64_POINTER(ULONG_PTR) Win32ClientInfo[62];
    WOW64_POINTER(PVOID) glDispatchTable[233];
    WOW64_POINTER(ULONG_PTR) glReserved1[29];
    WOW64_POINTER(PVOID) glReserved2;
    WOW64_POINTER(PVOID) glSectionInfo;
    WOW64_POINTER(PVOID) glSection;
    WOW64_POINTER(PVOID) glTable;
    WOW64_POINTER(PVOID) glCurrentRC;
    WOW64_POINTER(PVOID) glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING32 StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    WOW64_POINTER(PVOID) DeallocationStack;
    WOW64_POINTER(PVOID) TlsSlots[64];
    LIST_ENTRY32 TlsLinks;

    WOW64_POINTER(PVOID) Vdm;
    WOW64_POINTER(PVOID) ReservedForNtRpc;
    WOW64_POINTER(PVOID) DbgSsReserved[2];

    ULONG HardErrorMode;
    WOW64_POINTER(PVOID) Instrumentation[9];
    GUID ActivityId;

    WOW64_POINTER(PVOID) SubProcessTag;
    WOW64_POINTER(PVOID) PerflibData;
    WOW64_POINTER(PVOID) EtwTraceData;
    WOW64_POINTER(PVOID) WinSockData;
    ULONG GdiBatchCount;

    union
    {
        PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        };
    };

    ULONG GuaranteedStackBytes;
    WOW64_POINTER(PVOID) ReservedForPerf;
    WOW64_POINTER(PVOID) ReservedForOle;
    ULONG WaitingOnLoaderLock;
    WOW64_POINTER(PVOID) SavedPriorityState;
    WOW64_POINTER(ULONG_PTR) ReservedForCodeCoverage;
    WOW64_POINTER(PVOID) ThreadPoolData;
    WOW64_POINTER(PVOID *) TlsExpansionSlots;

    ULONG MuiGeneration;
    ULONG IsImpersonating;
    WOW64_POINTER(PVOID) NlsCache;
    WOW64_POINTER(PVOID) pShimData;
    USHORT HeapVirtualAffinity;
    USHORT LowFragHeapDataSlot;
    WOW64_POINTER(HANDLE) CurrentTransactionHandle;
    WOW64_POINTER(PTEB_ACTIVE_FRAME) ActiveFrame;
    WOW64_POINTER(PVOID) FlsData;

    WOW64_POINTER(PVOID) PreferredLanguages;
    WOW64_POINTER(PVOID) UserPrefLanguages;
    WOW64_POINTER(PVOID) MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    };
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SessionAware : 1;
            USHORT LoadOwner : 1;
            USHORT LoaderWorker : 1;
            USHORT SpareSameTebBits : 2;
        };
    };

    WOW64_POINTER(PVOID) TxnScopeEnterCallback;
    WOW64_POINTER(PVOID) TxnScopeExitCallback;
    WOW64_POINTER(PVOID) TxnScopeContext;
    ULONG LockCount;
    LONG WowTebOffset;
    WOW64_POINTER(PVOID) ResourceRetValue;
    WOW64_POINTER(PVOID) ReservedForWdf;
    ULONGLONG ReservedForCrt;
    GUID EffectiveContainerId;
} TEB32, *PTEB32;

C_ASSERT(FIELD_OFFSET(TEB32, ProcessEnvironmentBlock) == 0x030);
C_ASSERT(FIELD_OFFSET(TEB32, ExceptionCode) == 0x1a4);
C_ASSERT(FIELD_OFFSET(TEB32, TxFsContext) == 0x1d0);
C_ASSERT(FIELD_OFFSET(TEB32, glContext) == 0xbf0);
C_ASSERT(FIELD_OFFSET(TEB32, StaticUnicodeBuffer) == 0xc00);
C_ASSERT(FIELD_OFFSET(TEB32, TlsLinks) == 0xf10);
C_ASSERT(FIELD_OFFSET(TEB32, DbgSsReserved) == 0xf20);
C_ASSERT(FIELD_OFFSET(TEB32, ActivityId) == 0xf50);
C_ASSERT(FIELD_OFFSET(TEB32, GdiBatchCount) == 0xf70);
C_ASSERT(FIELD_OFFSET(TEB32, TlsExpansionSlots) == 0xf94);
C_ASSERT(FIELD_OFFSET(TEB32, FlsData) == 0xfb4);
C_ASSERT(FIELD_OFFSET(TEB32, MuiImpersonation) == 0xfc4);
C_ASSERT(FIELD_OFFSET(TEB32, ReservedForCrt) == 0xfe8);
C_ASSERT(FIELD_OFFSET(TEB32, EffectiveContainerId) == 0xff0);
C_ASSERT(sizeof(TEB32) == 0x1000);

// Get the 32-bit TEB without doing a memory reference
// modified from public SDK /10.0.10240.0/um/minwin/wow64t.h (dmex)
#define WOW64_GET_TEB32(teb64) ((PTEB32)PTR_ADD_OFFSET((teb64), ALIGN_UP_BY(sizeof(TEB), PAGE_SIZE)))
#define WOW64_TEB32_POINTER_ADDRESS(teb64) (PVOID)&((teb64)->NtTib.ExceptionList)

// Conversion

FORCEINLINE VOID UStr32ToUStr(
    _Out_ PUNICODE_STRING Destination,
    _In_ PUNICODE_STRING32 Source
    )
{
    Destination->Length = Source->Length;
    Destination->MaximumLength = Source->MaximumLength;
    Destination->Buffer = (PWCH)UlongToPtr(Source->Buffer);
}

FORCEINLINE VOID UStrToUStr32(
    _Out_ PUNICODE_STRING32 Destination,
    _In_ PUNICODE_STRING Source
    )
{
    Destination->Length = Source->Length;
    Destination->MaximumLength = Source->MaximumLength;
    Destination->Buffer = PtrToUlong(Source->Buffer);
}

#endif

#include <ntlsa.h>
/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTSAM_H
#define _NTSAM_H

#define SAM_MAXIMUM_LOOKUP_COUNT (1000)
#define SAM_MAXIMUM_LOOKUP_LENGTH (32000)
#define SAM_MAX_PASSWORD_LENGTH (256)
#define SAM_PASSWORD_ENCRYPTION_SALT_LEN (16)

typedef PVOID SAM_HANDLE, *PSAM_HANDLE;
typedef ULONG SAM_ENUMERATE_HANDLE, *PSAM_ENUMERATE_HANDLE;

typedef struct _SAM_RID_ENUMERATION
{
    ULONG RelativeId;
    UNICODE_STRING Name;
} SAM_RID_ENUMERATION, *PSAM_RID_ENUMERATION;

typedef struct _SAM_SID_ENUMERATION
{
    PSID Sid;
    UNICODE_STRING Name;
} SAM_SID_ENUMERATION, *PSAM_SID_ENUMERATION;

typedef struct _SAM_BYTE_ARRAY
{
    ULONG Size;
    _Field_size_bytes_(Size) PUCHAR Data;
} SAM_BYTE_ARRAY, *PSAM_BYTE_ARRAY;

typedef struct _SAM_BYTE_ARRAY_32K
{
    ULONG Size;
    _Field_size_bytes_(Size) PUCHAR Data;
} SAM_BYTE_ARRAY_32K, *PSAM_BYTE_ARRAY_32K;

typedef SAM_BYTE_ARRAY_32K SAM_SHELL_OBJECT_PROPERTIES, *PSAM_SHELL_OBJECT_PROPERTIES;

// Basic

NTSTATUS
NTAPI
SamFreeMemory(
    _In_ PVOID Buffer
    );

NTSTATUS
NTAPI
SamCloseHandle(
    _In_ SAM_HANDLE SamHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamSetSecurityObject(
    _In_ SAM_HANDLE ObjectHandle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

_Check_return_
NTSTATUS
NTAPI
SamQuerySecurityObject(
    _In_ SAM_HANDLE ObjectHandle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _Outptr_ PSECURITY_DESCRIPTOR *SecurityDescriptor
    );

_Check_return_
NTSTATUS
NTAPI
SamRidToSid(
    _In_ SAM_HANDLE ObjectHandle,
    _In_ ULONG Rid,
    _Outptr_ PSID *Sid
    );

// Server

#define SAM_SERVER_CONNECT 0x0001
#define SAM_SERVER_SHUTDOWN 0x0002
#define SAM_SERVER_INITIALIZE 0x0004
#define SAM_SERVER_CREATE_DOMAIN 0x0008
#define SAM_SERVER_ENUMERATE_DOMAINS 0x0010
#define SAM_SERVER_LOOKUP_DOMAIN 0x0020

#define SAM_SERVER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED     | \
    SAM_SERVER_CONNECT | \
    SAM_SERVER_INITIALIZE | \
    SAM_SERVER_CREATE_DOMAIN | \
    SAM_SERVER_SHUTDOWN | \
    SAM_SERVER_ENUMERATE_DOMAINS | \
    SAM_SERVER_LOOKUP_DOMAIN)

#define SAM_SERVER_READ (STANDARD_RIGHTS_READ | \
    SAM_SERVER_ENUMERATE_DOMAINS)

#define SAM_SERVER_WRITE (STANDARD_RIGHTS_WRITE | \
    SAM_SERVER_INITIALIZE | \
    SAM_SERVER_CREATE_DOMAIN | \
    SAM_SERVER_SHUTDOWN)

#define SAM_SERVER_EXECUTE (STANDARD_RIGHTS_EXECUTE | \
    SAM_SERVER_CONNECT | \
    SAM_SERVER_LOOKUP_DOMAIN)

// Functions

_Check_return_
NTSTATUS
NTAPI
SamConnect(
    _In_opt_ PUNICODE_STRING ServerName,
    _Out_ PSAM_HANDLE ServerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

_Check_return_
NTSTATUS
NTAPI
SamConnectWithCreds(
    _In_ PUNICODE_STRING ServerName,
    _Out_ PSAM_HANDLE ServerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ struct _RPC_AUTH_IDENTITY_HANDLE* Creds,
    _In_ PWCHAR Spn,
    _Out_ BOOL* pfDstIsW2K
    );

_Check_return_
NTSTATUS
NTAPI
SamShutdownSamServer(
    _In_ SAM_HANDLE ServerHandle
    );

// Domain

#define DOMAIN_READ_PASSWORD_PARAMETERS 0x0001
#define DOMAIN_WRITE_PASSWORD_PARAMS 0x0002
#define DOMAIN_READ_OTHER_PARAMETERS 0x0004
#define DOMAIN_WRITE_OTHER_PARAMETERS 0x0008
#define DOMAIN_CREATE_USER 0x0010
#define DOMAIN_CREATE_GROUP 0x0020
#define DOMAIN_CREATE_ALIAS 0x0040
#define DOMAIN_GET_ALIAS_MEMBERSHIP 0x0080
#define DOMAIN_LIST_ACCOUNTS 0x0100
#define DOMAIN_LOOKUP 0x0200
#define DOMAIN_ADMINISTER_SERVER 0x0400

#define DOMAIN_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | \
    DOMAIN_READ_OTHER_PARAMETERS | \
    DOMAIN_WRITE_OTHER_PARAMETERS | \
    DOMAIN_WRITE_PASSWORD_PARAMS | \
    DOMAIN_CREATE_USER | \
    DOMAIN_CREATE_GROUP | \
    DOMAIN_CREATE_ALIAS | \
    DOMAIN_GET_ALIAS_MEMBERSHIP | \
    DOMAIN_LIST_ACCOUNTS | \
    DOMAIN_READ_PASSWORD_PARAMETERS | \
    DOMAIN_LOOKUP | \
    DOMAIN_ADMINISTER_SERVER)

#define DOMAIN_READ (STANDARD_RIGHTS_READ | \
    DOMAIN_GET_ALIAS_MEMBERSHIP | \
    DOMAIN_READ_OTHER_PARAMETERS)

#define DOMAIN_WRITE (STANDARD_RIGHTS_WRITE | \
    DOMAIN_WRITE_OTHER_PARAMETERS | \
    DOMAIN_WRITE_PASSWORD_PARAMS | \
    DOMAIN_CREATE_USER | \
    DOMAIN_CREATE_GROUP | \
    DOMAIN_CREATE_ALIAS | \
    DOMAIN_ADMINISTER_SERVER)

#define DOMAIN_EXECUTE (STANDARD_RIGHTS_EXECUTE | \
    DOMAIN_READ_PASSWORD_PARAMETERS | \
    DOMAIN_LIST_ACCOUNTS | \
    DOMAIN_LOOKUP)

#define DOMAIN_PROMOTION_INCREMENT { 0x0, 0x10 }
#define DOMAIN_PROMOTION_MASK { 0x0, 0xfffffff0 }

// SamQueryInformationDomain/SamSetInformationDomain types

typedef enum _DOMAIN_INFORMATION_CLASS
{
    DomainPasswordInformation = 1, // q; s: DOMAIN_PASSWORD_INFORMATION
    DomainGeneralInformation, // q: DOMAIN_GENERAL_INFORMATION
    DomainLogoffInformation, // q; s: DOMAIN_LOGOFF_INFORMATION
    DomainOemInformation, // q; s: DOMAIN_OEM_INFORMATION
    DomainNameInformation, // q: DOMAIN_NAME_INFORMATION
    DomainReplicationInformation, // q; s: DOMAIN_REPLICATION_INFORMATION
    DomainServerRoleInformation, // q; s: DOMAIN_SERVER_ROLE_INFORMATION
    DomainModifiedInformation, // q: DOMAIN_MODIFIED_INFORMATION
    DomainStateInformation, // q; s: DOMAIN_STATE_INFORMATION
    DomainUasInformation, // q; s: DOMAIN_UAS_INFORMATION
    DomainGeneralInformation2, // q: DOMAIN_GENERAL_INFORMATION2
    DomainLockoutInformation, // q; s: DOMAIN_LOCKOUT_INFORMATION
    DomainModifiedInformation2 // q: DOMAIN_MODIFIED_INFORMATION2
} DOMAIN_INFORMATION_CLASS;

typedef enum _DOMAIN_SERVER_ENABLE_STATE
{
    DomainServerEnabled = 1,
    DomainServerDisabled
} DOMAIN_SERVER_ENABLE_STATE, *PDOMAIN_SERVER_ENABLE_STATE;

typedef enum _DOMAIN_SERVER_ROLE
{
    DomainServerRoleBackup = 2,
    DomainServerRolePrimary
} DOMAIN_SERVER_ROLE, *PDOMAIN_SERVER_ROLE;

#include <pshpack4.h>
typedef struct _DOMAIN_GENERAL_INFORMATION
{
    LARGE_INTEGER ForceLogoff;
    UNICODE_STRING OemInformation;
    UNICODE_STRING DomainName;
    UNICODE_STRING ReplicaSourceNodeName;
    LARGE_INTEGER DomainModifiedCount;
    DOMAIN_SERVER_ENABLE_STATE DomainServerState;
    DOMAIN_SERVER_ROLE DomainServerRole;
    BOOLEAN UasCompatibilityRequired;
    ULONG UserCount;
    ULONG GroupCount;
    ULONG AliasCount;
} DOMAIN_GENERAL_INFORMATION, *PDOMAIN_GENERAL_INFORMATION;
#include <poppack.h>

#include <pshpack4.h>
typedef struct _DOMAIN_GENERAL_INFORMATION2
{
    DOMAIN_GENERAL_INFORMATION I1;
    LARGE_INTEGER LockoutDuration; // delta time
    LARGE_INTEGER LockoutObservationWindow; // delta time
    USHORT LockoutThreshold;
} DOMAIN_GENERAL_INFORMATION2, *PDOMAIN_GENERAL_INFORMATION2;
#include <poppack.h>

typedef struct _DOMAIN_UAS_INFORMATION
{
    BOOLEAN UasCompatibilityRequired;
} DOMAIN_UAS_INFORMATION;

#ifndef _DOMAIN_PASSWORD_INFORMATION_DEFINED // defined in ntsecapi.h
#define _DOMAIN_PASSWORD_INFORMATION_DEFINED

typedef struct _DOMAIN_PASSWORD_INFORMATION
{
    USHORT MinPasswordLength;
    USHORT PasswordHistoryLength;
    ULONG PasswordProperties;
    LARGE_INTEGER MaxPasswordAge;
    LARGE_INTEGER MinPasswordAge;
} DOMAIN_PASSWORD_INFORMATION, *PDOMAIN_PASSWORD_INFORMATION;

// PasswordProperties flags

#define DOMAIN_PASSWORD_COMPLEX 0x00000001L
#define DOMAIN_PASSWORD_NO_ANON_CHANGE 0x00000002L
#define DOMAIN_PASSWORD_NO_CLEAR_CHANGE 0x00000004L
#define DOMAIN_LOCKOUT_ADMINS 0x00000008L
#define DOMAIN_PASSWORD_STORE_CLEARTEXT 0x00000010L
#define DOMAIN_REFUSE_PASSWORD_CHANGE 0x00000020L
#define DOMAIN_NO_LM_OWF_CHANGE 0x00000040L

#endif

typedef enum _DOMAIN_PASSWORD_CONSTRUCTION
{
    DomainPasswordSimple = 1,
    DomainPasswordComplex
} DOMAIN_PASSWORD_CONSTRUCTION;

typedef struct _DOMAIN_LOGOFF_INFORMATION
{
    LARGE_INTEGER ForceLogoff;
} DOMAIN_LOGOFF_INFORMATION, *PDOMAIN_LOGOFF_INFORMATION;

typedef struct _DOMAIN_OEM_INFORMATION
{
    UNICODE_STRING OemInformation;
} DOMAIN_OEM_INFORMATION, *PDOMAIN_OEM_INFORMATION;

typedef struct _DOMAIN_NAME_INFORMATION
{
    UNICODE_STRING DomainName;
} DOMAIN_NAME_INFORMATION, *PDOMAIN_NAME_INFORMATION;

typedef struct _DOMAIN_SERVER_ROLE_INFORMATION
{
    DOMAIN_SERVER_ROLE DomainServerRole;
} DOMAIN_SERVER_ROLE_INFORMATION, *PDOMAIN_SERVER_ROLE_INFORMATION;

typedef struct _DOMAIN_REPLICATION_INFORMATION
{
    UNICODE_STRING ReplicaSourceNodeName;
} DOMAIN_REPLICATION_INFORMATION, *PDOMAIN_REPLICATION_INFORMATION;

typedef struct _DOMAIN_MODIFIED_INFORMATION
{
    LARGE_INTEGER DomainModifiedCount;
    LARGE_INTEGER CreationTime;
} DOMAIN_MODIFIED_INFORMATION, *PDOMAIN_MODIFIED_INFORMATION;

typedef struct _DOMAIN_MODIFIED_INFORMATION2
{
    LARGE_INTEGER DomainModifiedCount;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER ModifiedCountAtLastPromotion;
} DOMAIN_MODIFIED_INFORMATION2, *PDOMAIN_MODIFIED_INFORMATION2;

typedef struct _DOMAIN_STATE_INFORMATION
{
    DOMAIN_SERVER_ENABLE_STATE DomainServerState;
} DOMAIN_STATE_INFORMATION, *PDOMAIN_STATE_INFORMATION;

typedef struct _DOMAIN_LOCKOUT_INFORMATION
{
    LARGE_INTEGER LockoutDuration; // delta time
    LARGE_INTEGER LockoutObservationWindow; // delta time
    USHORT LockoutThreshold; // zero means no lockout
} DOMAIN_LOCKOUT_INFORMATION, *PDOMAIN_LOCKOUT_INFORMATION;

// SamQueryDisplayInformation types

typedef enum _DOMAIN_DISPLAY_INFORMATION
{
    DomainDisplayUser = 1, // DOMAIN_DISPLAY_USER
    DomainDisplayMachine, // DOMAIN_DISPLAY_MACHINE
    DomainDisplayGroup, // DOMAIN_DISPLAY_GROUP
    DomainDisplayOemUser, // DOMAIN_DISPLAY_OEM_USER
    DomainDisplayOemGroup, // DOMAIN_DISPLAY_OEM_GROUP
    DomainDisplayServer
} DOMAIN_DISPLAY_INFORMATION, *PDOMAIN_DISPLAY_INFORMATION;

typedef struct _DOMAIN_DISPLAY_USER
{
    ULONG Index;
    ULONG Rid;
    ULONG AccountControl;
    UNICODE_STRING LogonName;
    UNICODE_STRING AdminComment;
    UNICODE_STRING FullName;
} DOMAIN_DISPLAY_USER, *PDOMAIN_DISPLAY_USER;

typedef struct _DOMAIN_DISPLAY_MACHINE
{
    ULONG Index;
    ULONG Rid;
    ULONG AccountControl;
    UNICODE_STRING Machine;
    UNICODE_STRING Comment;
} DOMAIN_DISPLAY_MACHINE, *PDOMAIN_DISPLAY_MACHINE;

typedef struct _DOMAIN_DISPLAY_GROUP
{
    ULONG Index;
    ULONG Rid;
    ULONG Attributes;
    UNICODE_STRING Group;
    UNICODE_STRING Comment;
} DOMAIN_DISPLAY_GROUP, *PDOMAIN_DISPLAY_GROUP;

typedef struct _DOMAIN_DISPLAY_OEM_USER
{
    ULONG Index;
    OEM_STRING User;
} DOMAIN_DISPLAY_OEM_USER, *PDOMAIN_DISPLAY_OEM_USER;

typedef struct _DOMAIN_DISPLAY_OEM_GROUP
{
    ULONG Index;
    OEM_STRING Group;
} DOMAIN_DISPLAY_OEM_GROUP, *PDOMAIN_DISPLAY_OEM_GROUP;

// SamQueryLocalizableAccountsInDomain types

typedef enum _DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION
{
    DomainLocalizableAccountsBasic = 1,
} DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION, *PDOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION;

typedef struct _DOMAIN_LOCALIZABLE_ACCOUNTS_ENTRY
{
    ULONG Rid;
    SID_NAME_USE Use;
    UNICODE_STRING Name;
    UNICODE_STRING AdminComment;
} DOMAIN_LOCALIZABLE_ACCOUNT_ENTRY, *PDOMAIN_LOCALIZABLE_ACCOUNT_ENTRY;

typedef struct _DOMAIN_LOCALIZABLE_ACCOUNTS
{
    ULONG Count;
    _Field_size_(Count) DOMAIN_LOCALIZABLE_ACCOUNT_ENTRY *Entries;
} DOMAIN_LOCALIZABLE_ACCOUNTS_BASIC, *PDOMAIN_LOCALIZABLE_ACCOUNTS_BASIC;

typedef union _DOMAIN_LOCALIZABLE_INFO_BUFFER
{
    DOMAIN_LOCALIZABLE_ACCOUNTS_BASIC Basic;
} DOMAIN_LOCALIZABLE_ACCOUNTS_INFO_BUFFER, *PDOMAIN_LOCALIZABLE_ACCOUNTS_INFO_BUFFER;

// Functions

_Check_return_
NTSTATUS
NTAPI
SamLookupDomainInSamServer(
    _In_ SAM_HANDLE ServerHandle,
    _In_ PUNICODE_STRING Name,
    _Outptr_ PSID *DomainId
    );

_Check_return_
NTSTATUS
NTAPI
SamEnumerateDomainsInSamServer(
    _In_ SAM_HANDLE ServerHandle,
    _Inout_ PSAM_ENUMERATE_HANDLE EnumerationContext,
    _Outptr_ PVOID *Buffer, // PSAM_SID_ENUMERATION *Buffer
    _In_ ULONG PreferedMaximumLength,
    _Out_ PULONG CountReturned
    );

_Check_return_
NTSTATUS
NTAPI
SamOpenDomain(
    _In_ SAM_HANDLE ServerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PSID DomainId,
    _Out_ PSAM_HANDLE DomainHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamQueryInformationDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ DOMAIN_INFORMATION_CLASS DomainInformationClass,
    _Outptr_ PVOID *Buffer
    );

_Check_return_
NTSTATUS
NTAPI
SamSetInformationDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ DOMAIN_INFORMATION_CLASS DomainInformationClass,
    _In_ PVOID DomainInformation
    );

_Check_return_
NTSTATUS
NTAPI
SamLookupNamesInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ ULONG Count,
    _In_reads_(Count) PUNICODE_STRING Names,
    _Out_ _Deref_post_count_(Count) PULONG *RelativeIds,
    _Out_ _Deref_post_count_(Count) PSID_NAME_USE *Use
    );

_Check_return_
NTSTATUS
NTAPI
SamLookupNamesInDomain2(
    _In_ SAM_HANDLE DomainHandle,
    _In_ ULONG Count,
    _In_reads_(Count) PUNICODE_STRING Names,
    _Out_ _Deref_post_count_(Count) PSID* Sids,
    _Out_ _Deref_post_count_(Count) PSID_NAME_USE* Use
    );

_Check_return_
NTSTATUS
NTAPI
SamLookupIdsInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ ULONG Count,
    _In_reads_(Count) PULONG RelativeIds,
    _Out_ _Deref_post_count_(Count) PUNICODE_STRING *Names,
    _Out_ _Deref_post_opt_count_(Count) PSID_NAME_USE *Use
    );

_Check_return_
NTSTATUS
NTAPI
SamRemoveMemberFromForeignDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ PSID MemberId
    );

_Check_return_
NTSTATUS
NTAPI
SamQueryLocalizableAccountsInDomain(
    _In_ SAM_HANDLE Domain,
    _In_ ULONG Flags,
    _In_ ULONG LanguageId,
    _In_ DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION Class,
    _Outptr_ PVOID *Buffer
    );

// Group

#define GROUP_READ_INFORMATION 0x0001
#define GROUP_WRITE_ACCOUNT 0x0002
#define GROUP_ADD_MEMBER 0x0004
#define GROUP_REMOVE_MEMBER 0x0008
#define GROUP_LIST_MEMBERS 0x0010

#define GROUP_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | \
    GROUP_LIST_MEMBERS | \
    GROUP_WRITE_ACCOUNT | \
    GROUP_ADD_MEMBER | \
    GROUP_REMOVE_MEMBER | \
    GROUP_READ_INFORMATION)

#define GROUP_READ (STANDARD_RIGHTS_READ | \
    GROUP_LIST_MEMBERS)

#define GROUP_WRITE (STANDARD_RIGHTS_WRITE | \
    GROUP_WRITE_ACCOUNT | \
    GROUP_ADD_MEMBER | \
    GROUP_REMOVE_MEMBER)

#define GROUP_EXECUTE (STANDARD_RIGHTS_EXECUTE | \
    GROUP_READ_INFORMATION)

typedef struct _GROUP_MEMBERSHIP
{
    ULONG RelativeId;
    ULONG Attributes;
} GROUP_MEMBERSHIP, *PGROUP_MEMBERSHIP;

// SamQueryInformationGroup/SamSetInformationGroup types

typedef enum _GROUP_INFORMATION_CLASS
{
    GroupGeneralInformation = 1, // q: GROUP_GENERAL_INFORMATION
    GroupNameInformation, // q; s: GROUP_NAME_INFORMATION
    GroupAttributeInformation, // q; s: GROUP_ATTRIBUTE_INFORMATION
    GroupAdminCommentInformation, // q; s: GROUP_ADM_COMMENT_INFORMATION
    GroupReplicationInformation
} GROUP_INFORMATION_CLASS;

typedef struct _GROUP_GENERAL_INFORMATION
{
    UNICODE_STRING Name;
    ULONG Attributes;
    ULONG MemberCount;
    UNICODE_STRING AdminComment;
} GROUP_GENERAL_INFORMATION, *PGROUP_GENERAL_INFORMATION;

typedef struct _GROUP_NAME_INFORMATION
{
    UNICODE_STRING Name;
} GROUP_NAME_INFORMATION, *PGROUP_NAME_INFORMATION;

typedef struct _GROUP_ATTRIBUTE_INFORMATION
{
    ULONG Attributes;
} GROUP_ATTRIBUTE_INFORMATION, *PGROUP_ATTRIBUTE_INFORMATION;

typedef struct _GROUP_ADM_COMMENT_INFORMATION
{
    UNICODE_STRING AdminComment;
} GROUP_ADM_COMMENT_INFORMATION, *PGROUP_ADM_COMMENT_INFORMATION;

// Functions

_Check_return_
NTSTATUS
NTAPI
SamEnumerateGroupsInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _Inout_ PSAM_ENUMERATE_HANDLE EnumerationContext,
    _Outptr_ PVOID *Buffer, // PSAM_RID_ENUMERATION *
    _In_ ULONG PreferedMaximumLength,
    _Out_ PULONG CountReturned
    );

_Check_return_
NTSTATUS
NTAPI
SamCreateGroupInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ PUNICODE_STRING AccountName,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PSAM_HANDLE GroupHandle,
    _Out_ PULONG RelativeId
    );

_Check_return_
NTSTATUS
NTAPI
SamOpenGroup(
    _In_ SAM_HANDLE DomainHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG GroupId,
    _Out_ PSAM_HANDLE GroupHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamDeleteGroup(
    _In_ SAM_HANDLE GroupHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamQueryInformationGroup(
    _In_ SAM_HANDLE GroupHandle,
    _In_ GROUP_INFORMATION_CLASS GroupInformationClass,
    _Outptr_ PVOID *Buffer
    );

_Check_return_
NTSTATUS
NTAPI
SamSetInformationGroup(
    _In_ SAM_HANDLE GroupHandle,
    _In_ GROUP_INFORMATION_CLASS GroupInformationClass,
    _In_ PVOID Buffer
    );

_Check_return_
NTSTATUS
NTAPI
SamAddMemberToGroup(
    _In_ SAM_HANDLE GroupHandle,
    _In_ ULONG MemberId,
    _In_ ULONG Attributes
    );

_Check_return_
NTSTATUS
NTAPI
SamRemoveMemberFromGroup(
    _In_ SAM_HANDLE GroupHandle,
    _In_ ULONG MemberId
    );

_Check_return_
NTSTATUS
NTAPI
SamGetMembersInGroup(
    _In_ SAM_HANDLE GroupHandle,
    _Out_ _Deref_post_count_(*MemberCount) PULONG *MemberIds,
    _Out_ _Deref_post_count_(*MemberCount) PULONG *Attributes,
    _Out_ PULONG MemberCount
    );

_Check_return_
NTSTATUS
NTAPI
SamSetMemberAttributesOfGroup(
    _In_ SAM_HANDLE GroupHandle,
    _In_ ULONG MemberId,
    _In_ ULONG Attributes
    );

// Alias

#define ALIAS_ADD_MEMBER 0x0001
#define ALIAS_REMOVE_MEMBER 0x0002
#define ALIAS_LIST_MEMBERS 0x0004
#define ALIAS_READ_INFORMATION 0x0008
#define ALIAS_WRITE_ACCOUNT 0x0010

#define ALIAS_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | \
    ALIAS_READ_INFORMATION | \
    ALIAS_WRITE_ACCOUNT | \
    ALIAS_LIST_MEMBERS | \
    ALIAS_ADD_MEMBER | \
    ALIAS_REMOVE_MEMBER)

#define ALIAS_READ (STANDARD_RIGHTS_READ | \
    ALIAS_LIST_MEMBERS)

#define ALIAS_WRITE (STANDARD_RIGHTS_WRITE | \
    ALIAS_WRITE_ACCOUNT | \
    ALIAS_ADD_MEMBER | \
    ALIAS_REMOVE_MEMBER)

#define ALIAS_EXECUTE (STANDARD_RIGHTS_EXECUTE | \
    ALIAS_READ_INFORMATION)

// SamQueryInformationAlias/SamSetInformationAlias types

typedef enum _ALIAS_INFORMATION_CLASS
{
    AliasGeneralInformation = 1, // q: ALIAS_GENERAL_INFORMATION
    AliasNameInformation, // q; s: ALIAS_NAME_INFORMATION
    AliasAdminCommentInformation, // q; s: ALIAS_ADM_COMMENT_INFORMATION
    AliasReplicationInformation,
    AliasExtendedInformation,
} ALIAS_INFORMATION_CLASS;

typedef struct _ALIAS_GENERAL_INFORMATION
{
    UNICODE_STRING Name;
    ULONG MemberCount;
    UNICODE_STRING AdminComment;
} ALIAS_GENERAL_INFORMATION,  *PALIAS_GENERAL_INFORMATION;

typedef struct _ALIAS_NAME_INFORMATION
{
    UNICODE_STRING Name;
} ALIAS_NAME_INFORMATION, *PALIAS_NAME_INFORMATION;

typedef struct _ALIAS_ADM_COMMENT_INFORMATION
{
    UNICODE_STRING AdminComment;
} ALIAS_ADM_COMMENT_INFORMATION, *PALIAS_ADM_COMMENT_INFORMATION;

#define ALIAS_ALL_NAME (0x00000001L)
#define ALIAS_ALL_MEMBER_COUNT (0x00000002L)
#define ALIAS_ALL_ADMIN_COMMENT (0x00000004L)
#define ALIAS_ALL_SHELL_ADMIN_OBJECT_PROPERTIES (0x00000008L)

typedef struct _ALIAS_EXTENDED_INFORMATION
{
    ULONG WhichFields;
    SAM_SHELL_OBJECT_PROPERTIES ShellAdminObjectProperties;
} ALIAS_EXTENDED_INFORMATION, *PALIAS_EXTENDED_INFORMATION;

// Functions

_Check_return_
NTSTATUS
NTAPI
SamEnumerateAliasesInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _Inout_ PSAM_ENUMERATE_HANDLE EnumerationContext,
    _Outptr_ PVOID *Buffer, // PSAM_RID_ENUMERATION *Buffer
    _In_ ULONG PreferedMaximumLength,
    _Out_ PULONG CountReturned
    );

_Check_return_
NTSTATUS
NTAPI
SamCreateAliasInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ PUNICODE_STRING AccountName,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PSAM_HANDLE AliasHandle,
    _Out_ PULONG RelativeId
    );

_Check_return_
NTSTATUS
NTAPI
SamOpenAlias(
    _In_ SAM_HANDLE DomainHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG AliasId,
    _Out_ PSAM_HANDLE AliasHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamDeleteAlias(
    _In_ SAM_HANDLE AliasHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamQueryInformationAlias(
    _In_ SAM_HANDLE AliasHandle,
    _In_ ALIAS_INFORMATION_CLASS AliasInformationClass,
    _Outptr_ PVOID *Buffer
    );

_Check_return_
NTSTATUS
NTAPI
SamSetInformationAlias(
    _In_ SAM_HANDLE AliasHandle,
    _In_ ALIAS_INFORMATION_CLASS AliasInformationClass,
    _In_ PVOID Buffer
    );

_Check_return_
NTSTATUS
NTAPI
SamAddMemberToAlias(
    _In_ SAM_HANDLE AliasHandle,
    _In_ PSID MemberId
    );

_Check_return_
NTSTATUS
NTAPI
SamAddMultipleMembersToAlias(
    _In_ SAM_HANDLE AliasHandle,
    _In_reads_(MemberCount) PSID *MemberIds,
    _In_ ULONG MemberCount
    );

_Check_return_
NTSTATUS
NTAPI
SamRemoveMemberFromAlias(
    _In_ SAM_HANDLE AliasHandle,
    _In_ PSID MemberId
    );

_Check_return_
NTSTATUS
NTAPI
SamRemoveMultipleMembersFromAlias(
    _In_ SAM_HANDLE AliasHandle,
    _In_reads_(MemberCount) PSID *MemberIds,
    _In_ ULONG MemberCount
    );

_Check_return_
NTSTATUS
NTAPI
SamGetMembersInAlias(
    _In_ SAM_HANDLE AliasHandle,
    _Out_ _Deref_post_count_(*MemberCount) PSID **MemberIds,
    _Out_ PULONG MemberCount
    );

_Check_return_
NTSTATUS
NTAPI
SamGetAliasMembership(
    _In_ SAM_HANDLE DomainHandle,
    _In_ ULONG PassedCount,
    _In_reads_(PassedCount) PSID *Sids,
    _Out_ PULONG MembershipCount,
    _Out_ _Deref_post_count_(*MembershipCount) PULONG *Aliases
    );

// Group types

#define GROUP_TYPE_BUILTIN_LOCAL_GROUP 0x00000001
#define GROUP_TYPE_ACCOUNT_GROUP 0x00000002
#define GROUP_TYPE_RESOURCE_GROUP 0x00000004
#define GROUP_TYPE_UNIVERSAL_GROUP 0x00000008
#define GROUP_TYPE_APP_BASIC_GROUP 0x00000010
#define GROUP_TYPE_APP_QUERY_GROUP 0x00000020
#define GROUP_TYPE_SECURITY_ENABLED 0x80000000

#define GROUP_TYPE_RESOURCE_BEHAVOIR (GROUP_TYPE_RESOURCE_GROUP | \
    GROUP_TYPE_APP_BASIC_GROUP | \
    GROUP_TYPE_APP_QUERY_GROUP)

// User

#define USER_READ_GENERAL 0x0001
#define USER_READ_PREFERENCES 0x0002
#define USER_WRITE_PREFERENCES 0x0004
#define USER_READ_LOGON 0x0008
#define USER_READ_ACCOUNT 0x0010
#define USER_WRITE_ACCOUNT 0x0020
#define USER_CHANGE_PASSWORD 0x0040
#define USER_FORCE_PASSWORD_CHANGE 0x0080
#define USER_LIST_GROUPS 0x0100
#define USER_READ_GROUP_INFORMATION 0x0200
#define USER_WRITE_GROUP_INFORMATION 0x0400

#define USER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | \
    USER_READ_PREFERENCES | \
    USER_READ_LOGON | \
    USER_LIST_GROUPS | \
    USER_READ_GROUP_INFORMATION | \
    USER_WRITE_PREFERENCES | \
    USER_CHANGE_PASSWORD | \
    USER_FORCE_PASSWORD_CHANGE | \
    USER_READ_GENERAL | \
    USER_READ_ACCOUNT | \
    USER_WRITE_ACCOUNT | \
    USER_WRITE_GROUP_INFORMATION)

#define USER_READ (STANDARD_RIGHTS_READ | \
    USER_READ_PREFERENCES | \
    USER_READ_LOGON | \
    USER_READ_ACCOUNT | \
    USER_LIST_GROUPS | \
    USER_READ_GROUP_INFORMATION)

#define USER_WRITE (STANDARD_RIGHTS_WRITE | \
    USER_WRITE_PREFERENCES | \
    USER_CHANGE_PASSWORD)

#define USER_EXECUTE (STANDARD_RIGHTS_EXECUTE | \
    USER_READ_GENERAL | \
    USER_CHANGE_PASSWORD)

// User account control flags

#define USER_ACCOUNT_DISABLED (0x00000001)
#define USER_HOME_DIRECTORY_REQUIRED (0x00000002)
#define USER_PASSWORD_NOT_REQUIRED (0x00000004)
#define USER_TEMP_DUPLICATE_ACCOUNT (0x00000008)
#define USER_NORMAL_ACCOUNT (0x00000010)
#define USER_MNS_LOGON_ACCOUNT (0x00000020)
#define USER_INTERDOMAIN_TRUST_ACCOUNT (0x00000040)
#define USER_WORKSTATION_TRUST_ACCOUNT (0x00000080)
#define USER_SERVER_TRUST_ACCOUNT (0x00000100)
#define USER_DONT_EXPIRE_PASSWORD (0x00000200)
#define USER_ACCOUNT_AUTO_LOCKED (0x00000400)
#define USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED (0x00000800)
#define USER_SMARTCARD_REQUIRED (0x00001000)
#define USER_TRUSTED_FOR_DELEGATION (0x00002000)
#define USER_NOT_DELEGATED (0x00004000)
#define USER_USE_DES_KEY_ONLY (0x00008000)
#define USER_DONT_REQUIRE_PREAUTH (0x00010000)
#define USER_PASSWORD_EXPIRED (0x00020000)
#define USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION (0x00040000)
#define USER_NO_AUTH_DATA_REQUIRED (0x00080000)
#define USER_PARTIAL_SECRETS_ACCOUNT (0x00100000)
#define USER_USE_AES_KEYS (0x00200000)

#define NEXT_FREE_ACCOUNT_CONTROL_BIT (USER_USE_AES_KEYS << 1)

#define USER_MACHINE_ACCOUNT_MASK ( \
    USER_INTERDOMAIN_TRUST_ACCOUNT | \
    USER_WORKSTATION_TRUST_ACCOUNT | \
    USER_SERVER_TRUST_ACCOUNT \
    )

#define USER_ACCOUNT_TYPE_MASK ( \
    USER_TEMP_DUPLICATE_ACCOUNT | \
    USER_NORMAL_ACCOUNT | \
    USER_MACHINE_ACCOUNT_MASK \
    )

#define USER_COMPUTED_ACCOUNT_CONTROL_BITS ( \
    USER_ACCOUNT_AUTO_LOCKED | \
    USER_PASSWORD_EXPIRED \
    )

// Logon times may be expressed in day, hour, or minute granularity.

#define SAM_DAYS_PER_WEEK (7)
#define SAM_HOURS_PER_WEEK (24 * SAM_DAYS_PER_WEEK)
#define SAM_MINUTES_PER_WEEK (60 * SAM_HOURS_PER_WEEK)

typedef struct _LOGON_HOURS
{
    USHORT UnitsPerWeek;

    // UnitsPerWeek is the number of equal length time units the week is
    // divided into. This value is used to compute the length of the bit
    // string in logon_hours. Must be less than or equal to
    // SAM_UNITS_PER_WEEK (10080) for this release.
    //
    // LogonHours is a bit map of valid logon times. Each bit represents
    // a unique division in a week. The largest bit map supported is 1260
    // bytes (10080 bits), which represents minutes per week. In this case
    // the first bit (bit 0, byte 0) is Sunday, 00:00:00 - 00-00:59; bit 1,
    // byte 0 is Sunday, 00:01:00 - 00:01:59, etc. A NULL pointer means
    // DONT_CHANGE for SamSetInformationUser() calls.

    PUCHAR LogonHours;
} LOGON_HOURS, *PLOGON_HOURS;

typedef struct _SR_SECURITY_DESCRIPTOR
{
    ULONG Length;
    PUCHAR SecurityDescriptor;
} SR_SECURITY_DESCRIPTOR, *PSR_SECURITY_DESCRIPTOR;

// SamQueryInformationUser/SamSetInformationUser types

typedef enum _USER_INFORMATION_CLASS
{
    UserGeneralInformation = 1, // q: USER_GENERAL_INFORMATION
    UserPreferencesInformation, // q; s: USER_PREFERENCES_INFORMATION
    UserLogonInformation, // q: USER_LOGON_INFORMATION
    UserLogonHoursInformation, // q; s: USER_LOGON_HOURS_INFORMATION
    UserAccountInformation, // q: USER_ACCOUNT_INFORMATION
    UserNameInformation, // q; s: USER_NAME_INFORMATION
    UserAccountNameInformation, // q; s: USER_ACCOUNT_NAME_INFORMATION
    UserFullNameInformation, // q; s: USER_FULL_NAME_INFORMATION
    UserPrimaryGroupInformation, // q; s: USER_PRIMARY_GROUP_INFORMATION
    UserHomeInformation, // q; s: USER_HOME_INFORMATION // 10
    UserScriptInformation, // q; s: USER_SCRIPT_INFORMATION
    UserProfileInformation, // q; s: USER_PROFILE_INFORMATION
    UserAdminCommentInformation, // q; s: USER_ADMIN_COMMENT_INFORMATION
    UserWorkStationsInformation, // q; s: USER_WORKSTATIONS_INFORMATION
    UserSetPasswordInformation, // s: USER_SET_PASSWORD_INFORMATION
    UserControlInformation, // q; s: USER_CONTROL_INFORMATION
    UserExpiresInformation, // q; s: USER_EXPIRES_INFORMATION
    UserInternal1Information, // USER_INTERNAL1_INFORMATION
    UserInternal2Information, // USER_INTERNAL2_INFORMATION
    UserParametersInformation, // q; s: USER_PARAMETERS_INFORMATION // 20
    UserAllInformation, // USER_ALL_INFORMATION
    UserInternal3Information, // USER_INTERNAL3_INFORMATION
    UserInternal4Information, // USER_INTERNAL4_INFORMATION
    UserInternal5Information, // USER_INTERNAL5_INFORMATION
    UserInternal4InformationNew, // USER_INTERNAL4_INFORMATION_NEW
    UserInternal5InformationNew, // USER_INTERNAL5_INFORMATION_NEW
    UserInternal6Information, // USER_INTERNAL6_INFORMATION
    UserExtendedInformation, // USER_EXTENDED_INFORMATION
    UserLogonUIInformation, // USER_LOGON_UI_INFORMATION
    UserUnknownTodoInformation,
    UserInternal7Information, // USER_INTERNAL7_INFORMATION
    UserInternal8Information, // USER_INTERNAL8_INFORMATION
} USER_INFORMATION_CLASS, *PUSER_INFORMATION_CLASS;

typedef struct _USER_GENERAL_INFORMATION
{
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    ULONG PrimaryGroupId;
    UNICODE_STRING AdminComment;
    UNICODE_STRING UserComment;
} USER_GENERAL_INFORMATION, *PUSER_GENERAL_INFORMATION;

typedef struct _USER_PREFERENCES_INFORMATION
{
    UNICODE_STRING UserComment;
    UNICODE_STRING Reserved1;
    USHORT CountryCode;
    USHORT CodePage;
} USER_PREFERENCES_INFORMATION, *PUSER_PREFERENCES_INFORMATION;

#include <pshpack4.h>
typedef struct _USER_LOGON_INFORMATION
{
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    ULONG UserId;
    ULONG PrimaryGroupId;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING ScriptPath;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING WorkStations;
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    ULONG UserAccountControl;
} USER_LOGON_INFORMATION, * PUSER_LOGON_INFORMATION;
#include <poppack.h>

typedef struct _USER_LOGON_HOURS_INFORMATION
{
    LOGON_HOURS LogonHours;
} USER_LOGON_HOURS_INFORMATION, * PUSER_LOGON_HOURS_INFORMATION;

#include <pshpack4.h>
typedef struct _USER_ACCOUNT_INFORMATION
{
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    ULONG UserId;
    ULONG PrimaryGroupId;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING ScriptPath;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING AdminComment;
    UNICODE_STRING WorkStations;
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER AccountExpires;
    ULONG UserAccountControl;
} USER_ACCOUNT_INFORMATION, * PUSER_ACCOUNT_INFORMATION;
#include <poppack.h>

typedef struct _USER_NAME_INFORMATION
{
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
} USER_NAME_INFORMATION, *PUSER_NAME_INFORMATION;

typedef struct _USER_ACCOUNT_NAME_INFORMATION
{
    UNICODE_STRING UserName;
} USER_ACCOUNT_NAME_INFORMATION, *PUSER_ACCOUNT_NAME_INFORMATION;

typedef struct _USER_FULL_NAME_INFORMATION
{
    UNICODE_STRING FullName;
} USER_FULL_NAME_INFORMATION, *PUSER_FULL_NAME_INFORMATION;

typedef struct _USER_PRIMARY_GROUP_INFORMATION
{
    ULONG PrimaryGroupId;
} USER_PRIMARY_GROUP_INFORMATION, *PUSER_PRIMARY_GROUP_INFORMATION;

typedef struct _USER_HOME_INFORMATION
{
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
} USER_HOME_INFORMATION, *PUSER_HOME_INFORMATION;

typedef struct _USER_SCRIPT_INFORMATION
{
    UNICODE_STRING ScriptPath;
} USER_SCRIPT_INFORMATION, *PUSER_SCRIPT_INFORMATION;

typedef struct _USER_PROFILE_INFORMATION
{
    UNICODE_STRING ProfilePath;
} USER_PROFILE_INFORMATION, *PUSER_PROFILE_INFORMATION;

typedef struct _USER_ADMIN_COMMENT_INFORMATION
{
    UNICODE_STRING AdminComment;
} USER_ADMIN_COMMENT_INFORMATION, *PUSER_ADMIN_COMMENT_INFORMATION;

typedef struct _USER_WORKSTATIONS_INFORMATION
{
    UNICODE_STRING WorkStations;
} USER_WORKSTATIONS_INFORMATION, *PUSER_WORKSTATIONS_INFORMATION;

typedef struct _USER_SET_PASSWORD_INFORMATION
{
    UNICODE_STRING Password;
    BOOLEAN PasswordExpired;
} USER_SET_PASSWORD_INFORMATION, *PUSER_SET_PASSWORD_INFORMATION;

typedef struct _USER_CONTROL_INFORMATION
{
    ULONG UserAccountControl;
} USER_CONTROL_INFORMATION, *PUSER_CONTROL_INFORMATION;

typedef struct _USER_EXPIRES_INFORMATION
{
    LARGE_INTEGER AccountExpires;
} USER_EXPIRES_INFORMATION, *PUSER_EXPIRES_INFORMATION;

#define CYPHER_BLOCK_LENGTH 8

typedef struct _CYPHER_BLOCK
{
    CHAR data[CYPHER_BLOCK_LENGTH];
} CYPHER_BLOCK, *PCYPHER_BLOCK;

typedef struct _ENCRYPTED_NT_OWF_PASSWORD
{
    CYPHER_BLOCK data[2];
} ENCRYPTED_NT_OWF_PASSWORD, *PENCRYPTED_NT_OWF_PASSWORD;

typedef struct _ENCRYPTED_LM_OWF_PASSWORD
{
    CYPHER_BLOCK data[2];
} ENCRYPTED_LM_OWF_PASSWORD, *PENCRYPTED_LM_OWF_PASSWORD;

typedef struct _USER_INTERNAL1_INFORMATION
{
    ENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword;
    ENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword;
    BOOLEAN NtPasswordPresent;
    BOOLEAN LmPasswordPresent;
    BOOLEAN PasswordExpired;
} USER_INTERNAL1_INFORMATION, *PUSER_INTERNAL1_INFORMATION;

typedef struct _USER_INTERNAL2_INFORMATION
{
    ULONG StatisticsToApply;
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    USHORT BadPasswordCount;
    USHORT LogonCount;
} USER_INTERNAL2_INFORMATION, *PUSER_INTERNAL2_INFORMATION;

typedef struct _USER_PARAMETERS_INFORMATION
{
    UNICODE_STRING Parameters;
} USER_PARAMETERS_INFORMATION, *PUSER_PARAMETERS_INFORMATION;

// Flags for WhichFields in USER_ALL_INFORMATION

#define USER_ALL_USERNAME 0x00000001
#define USER_ALL_FULLNAME 0x00000002
#define USER_ALL_USERID 0x00000004
#define USER_ALL_PRIMARYGROUPID 0x00000008
#define USER_ALL_ADMINCOMMENT 0x00000010
#define USER_ALL_USERCOMMENT 0x00000020
#define USER_ALL_HOMEDIRECTORY 0x00000040
#define USER_ALL_HOMEDIRECTORYDRIVE 0x00000080
#define USER_ALL_SCRIPTPATH 0x00000100
#define USER_ALL_PROFILEPATH 0x00000200
#define USER_ALL_WORKSTATIONS 0x00000400
#define USER_ALL_LASTLOGON 0x00000800
#define USER_ALL_LASTLOGOFF 0x00001000
#define USER_ALL_LOGONHOURS 0x00002000
#define USER_ALL_BADPASSWORDCOUNT 0x00004000
#define USER_ALL_LOGONCOUNT 0x00008000
#define USER_ALL_PASSWORDCANCHANGE 0x00010000
#define USER_ALL_PASSWORDMUSTCHANGE 0x00020000
#define USER_ALL_PASSWORDLASTSET 0x00040000
#define USER_ALL_ACCOUNTEXPIRES 0x00080000
#define USER_ALL_USERACCOUNTCONTROL 0x00100000
#define USER_ALL_PARAMETERS 0x00200000
#define USER_ALL_COUNTRYCODE 0x00400000
#define USER_ALL_CODEPAGE 0x00800000
#define USER_ALL_NTPASSWORDPRESENT 0x01000000 // field AND boolean
#define USER_ALL_LMPASSWORDPRESENT 0x02000000 // field AND boolean
#define USER_ALL_PRIVATEDATA 0x04000000 // field AND boolean
#define USER_ALL_PASSWORDEXPIRED 0x08000000
#define USER_ALL_SECURITYDESCRIPTOR 0x10000000
#define USER_ALL_OWFPASSWORD 0x20000000 // boolean

#define USER_ALL_UNDEFINED_MASK 0xc0000000

// Fields that require USER_READ_GENERAL access to read.

#define USER_ALL_READ_GENERAL_MASK \
    (USER_ALL_USERNAME | \
    USER_ALL_FULLNAME | \
    USER_ALL_USERID | \
    USER_ALL_PRIMARYGROUPID | \
    USER_ALL_ADMINCOMMENT | \
    USER_ALL_USERCOMMENT)

// Fields that require USER_READ_LOGON access to read.

#define USER_ALL_READ_LOGON_MASK \
   (USER_ALL_HOMEDIRECTORY | \
    USER_ALL_HOMEDIRECTORYDRIVE | \
    USER_ALL_SCRIPTPATH | \
    USER_ALL_PROFILEPATH | \
    USER_ALL_WORKSTATIONS | \
    USER_ALL_LASTLOGON | \
    USER_ALL_LASTLOGOFF | \
    USER_ALL_LOGONHOURS | \
    USER_ALL_BADPASSWORDCOUNT | \
    USER_ALL_LOGONCOUNT | \
    USER_ALL_PASSWORDCANCHANGE | \
    USER_ALL_PASSWORDMUSTCHANGE)

// Fields that require USER_READ_ACCOUNT access to read.

#define USER_ALL_READ_ACCOUNT_MASK \
    (USER_ALL_PASSWORDLASTSET | \
    USER_ALL_ACCOUNTEXPIRES | \
    USER_ALL_USERACCOUNTCONTROL | \
    USER_ALL_PARAMETERS)

// Fields that require USER_READ_PREFERENCES access to read.

#define USER_ALL_READ_PREFERENCES_MASK \
    (USER_ALL_COUNTRYCODE | USER_ALL_CODEPAGE)

// Fields that can only be read by trusted clients.

#define USER_ALL_READ_TRUSTED_MASK \
    (USER_ALL_NTPASSWORDPRESENT | \
    USER_ALL_LMPASSWORDPRESENT | \
    USER_ALL_PASSWORDEXPIRED | \
    USER_ALL_SECURITYDESCRIPTOR | \
    USER_ALL_PRIVATEDATA)

// Fields that can't be read.

#define USER_ALL_READ_CANT_MASK USER_ALL_UNDEFINED_MASK

// Fields that require USER_WRITE_ACCOUNT access to write.

#define USER_ALL_WRITE_ACCOUNT_MASK \
    (USER_ALL_USERNAME | \
    USER_ALL_FULLNAME | \
    USER_ALL_PRIMARYGROUPID | \
    USER_ALL_HOMEDIRECTORY | \
    USER_ALL_HOMEDIRECTORYDRIVE | \
    USER_ALL_SCRIPTPATH | \
    USER_ALL_PROFILEPATH | \
    USER_ALL_ADMINCOMMENT | \
    USER_ALL_WORKSTATIONS | \
    USER_ALL_LOGONHOURS | \
    USER_ALL_ACCOUNTEXPIRES | \
    USER_ALL_USERACCOUNTCONTROL | \
    USER_ALL_PARAMETERS)

// Fields that require USER_WRITE_PREFERENCES access to write.

#define USER_ALL_WRITE_PREFERENCES_MASK \
    (USER_ALL_USERCOMMENT | USER_ALL_COUNTRYCODE | USER_ALL_CODEPAGE)

// Fields that require USER_FORCE_PASSWORD_CHANGE access to write.
//
// Note that non-trusted clients only set the NT password as a
// UNICODE string. The wrapper will convert it to an LM password,
// OWF and encrypt both versions. Trusted clients can pass in OWF
// versions of either or both.

#define USER_ALL_WRITE_FORCE_PASSWORD_CHANGE_MASK \
    (USER_ALL_NTPASSWORDPRESENT | \
    USER_ALL_LMPASSWORDPRESENT | \
    USER_ALL_PASSWORDEXPIRED)

// Fields that can only be written by trusted clients.

#define USER_ALL_WRITE_TRUSTED_MASK \
    (USER_ALL_LASTLOGON | \
    USER_ALL_LASTLOGOFF | \
    USER_ALL_BADPASSWORDCOUNT | \
    USER_ALL_LOGONCOUNT | \
    USER_ALL_PASSWORDLASTSET | \
    USER_ALL_SECURITYDESCRIPTOR | \
    USER_ALL_PRIVATEDATA)

// Fields that can't be written.

#define USER_ALL_WRITE_CANT_MASK \
    (USER_ALL_USERID | \
    USER_ALL_PASSWORDCANCHANGE | \
    USER_ALL_PASSWORDMUSTCHANGE | \
    USER_ALL_UNDEFINED_MASK)

#include <pshpack4.h>
typedef struct _USER_ALL_INFORMATION
{
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER AccountExpires;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING ScriptPath;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING AdminComment;
    UNICODE_STRING WorkStations;
    UNICODE_STRING UserComment;
    UNICODE_STRING Parameters;
    UNICODE_STRING LmPassword;
    UNICODE_STRING NtPassword;
    UNICODE_STRING PrivateData;
    SR_SECURITY_DESCRIPTOR SecurityDescriptor;
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG UserAccountControl;
    ULONG WhichFields;
    LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    USHORT CountryCode;
    USHORT CodePage;
    BOOLEAN LmPasswordPresent;
    BOOLEAN NtPasswordPresent;
    BOOLEAN PasswordExpired;
    BOOLEAN PrivateDataSensitive;
} USER_ALL_INFORMATION, *PUSER_ALL_INFORMATION;
#include <poppack.h>

#include <pshpack4.h>
typedef struct _USER_INTERNAL3_INFORMATION
{
    USER_ALL_INFORMATION I1;
    LARGE_INTEGER LastBadPasswordTime;
} USER_INTERNAL3_INFORMATION, *PUSER_INTERNAL3_INFORMATION;
#include <poppack.h>

typedef struct _ENCRYPTED_USER_PASSWORD
{
    UCHAR Buffer[(SAM_MAX_PASSWORD_LENGTH * 2) + 4];
} ENCRYPTED_USER_PASSWORD, *PENCRYPTED_USER_PASSWORD;

typedef struct _USER_INTERNAL4_INFORMATION
{
    USER_ALL_INFORMATION I1;
    ENCRYPTED_USER_PASSWORD UserPassword;
} USER_INTERNAL4_INFORMATION, *PUSER_INTERNAL4_INFORMATION;

typedef struct _USER_INTERNAL5_INFORMATION
{
    ENCRYPTED_USER_PASSWORD UserPassword;
    BOOLEAN PasswordExpired;
} USER_INTERNAL5_INFORMATION, *PUSER_INTERNAL5_INFORMATION;

typedef struct _ENCRYPTED_USER_PASSWORD_NEW
{
    UCHAR Buffer[(SAM_MAX_PASSWORD_LENGTH * 2) + 4 + SAM_PASSWORD_ENCRYPTION_SALT_LEN];
} ENCRYPTED_USER_PASSWORD_NEW, *PENCRYPTED_USER_PASSWORD_NEW;

typedef struct _USER_INTERNAL4_INFORMATION_NEW
{
    USER_ALL_INFORMATION I1;
    ENCRYPTED_USER_PASSWORD_NEW UserPassword;
} USER_INTERNAL4_INFORMATION_NEW, *PUSER_INTERNAL4_INFORMATION_NEW;

typedef struct _USER_INTERNAL5_INFORMATION_NEW
{
    ENCRYPTED_USER_PASSWORD_NEW UserPassword;
    BOOLEAN PasswordExpired;
} USER_INTERNAL5_INFORMATION_NEW, *PUSER_INTERNAL5_INFORMATION_NEW;

typedef struct _USER_ALLOWED_TO_DELEGATE_TO_LIST
{
    ULONG Size;
    ULONG NumSPNs;
    UNICODE_STRING SPNList[ANYSIZE_ARRAY];
} USER_ALLOWED_TO_DELEGATE_TO_LIST, *PUSER_ALLOWED_TO_DELEGATE_TO_LIST;

#define USER_EXTENDED_FIELD_UPN 0x00000001L
#define USER_EXTENDED_FIELD_A2D2 0x00000002L

typedef struct _USER_INTERNAL6_INFORMATION
{
    USER_ALL_INFORMATION I1;
    LARGE_INTEGER LastBadPasswordTime;
    ULONG ExtendedFields;
    BOOLEAN UPNDefaulted;
    UNICODE_STRING UPN;
    PUSER_ALLOWED_TO_DELEGATE_TO_LIST A2D2List;
} USER_INTERNAL6_INFORMATION, *PUSER_INTERNAL6_INFORMATION;

typedef SAM_BYTE_ARRAY_32K SAM_USER_TILE, *PSAM_USER_TILE;

// 0xff000fff is reserved for internal callers and implementation.

#define USER_EXTENDED_FIELD_USER_TILE (0x00001000L)
#define USER_EXTENDED_FIELD_PASSWORD_HINT (0x00002000L)
#define USER_EXTENDED_FIELD_DONT_SHOW_IN_LOGON_UI (0x00004000L)
#define USER_EXTENDED_FIELD_SHELL_ADMIN_OBJECT_PROPERTIES (0x00008000L)

typedef struct _USER_EXTENDED_INFORMATION
{
    ULONG ExtendedWhichFields;
    SAM_USER_TILE UserTile;
    UNICODE_STRING PasswordHint;
    BOOLEAN DontShowInLogonUI;
    SAM_SHELL_OBJECT_PROPERTIES ShellAdminObjectProperties;
} USER_EXTENDED_INFORMATION, *PUSER_EXTENDED_INFORMATION;

// For local callers only.
typedef struct _USER_LOGON_UI_INFORMATION
{
    BOOLEAN PasswordIsBlank;
    BOOLEAN AccountIsDisabled;
} USER_LOGON_UI_INFORMATION, *PUSER_LOGON_UI_INFORMATION;

typedef struct _ENCRYPTED_PASSWORD_AES
{
    UCHAR AuthData[64];
    UCHAR Salt[SAM_PASSWORD_ENCRYPTION_SALT_LEN];
    ULONG cbCipher;
    PUCHAR Cipher;
    ULONGLONG PBKDF2Iterations;
} ENCRYPTED_PASSWORD_AES, *PENCRYPTED_PASSWORD_AES;

typedef struct _USER_INTERNAL7_INFORMATION
{
    ENCRYPTED_PASSWORD_AES UserPassword;
    BOOLEAN PasswordExpired;
} USER_INTERNAL7_INFORMATION, *PUSER_INTERNAL7_INFORMATION;

typedef struct _USER_INTERNAL8_INFORMATION
{
    USER_ALL_INFORMATION I1;
    ENCRYPTED_PASSWORD_AES UserPassword;
} USER_INTERNAL8_INFORMATION, *PUSER_INTERNAL8_INFORMATION;

// SamChangePasswordUser3 types

// Error values:
// * SAM_PWD_CHANGE_NO_ERROR
// * SAM_PWD_CHANGE_PASSWORD_TOO_SHORT
// * SAM_PWD_CHANGE_PWD_IN_HISTORY
// * SAM_PWD_CHANGE_USERNAME_IN_PASSWORD
// * SAM_PWD_CHANGE_FULLNAME_IN_PASSWORD
// * SAM_PWD_CHANGE_MACHINE_PASSWORD_NOT_DEFAULT
// * SAM_PWD_CHANGE_FAILED_BY_FILTER

typedef struct _USER_PWD_CHANGE_FAILURE_INFORMATION
{
    ULONG ExtendedFailureReason;
    UNICODE_STRING FilterModuleName;
} USER_PWD_CHANGE_FAILURE_INFORMATION,*PUSER_PWD_CHANGE_FAILURE_INFORMATION;

// ExtendedFailureReason values

#define SAM_PWD_CHANGE_NO_ERROR 0
#define SAM_PWD_CHANGE_PASSWORD_TOO_SHORT 1
#define SAM_PWD_CHANGE_PWD_IN_HISTORY 2
#define SAM_PWD_CHANGE_USERNAME_IN_PASSWORD 3
#define SAM_PWD_CHANGE_FULLNAME_IN_PASSWORD 4
#define SAM_PWD_CHANGE_NOT_COMPLEX 5
#define SAM_PWD_CHANGE_MACHINE_PASSWORD_NOT_DEFAULT 6
#define SAM_PWD_CHANGE_FAILED_BY_FILTER 7
#define SAM_PWD_CHANGE_PASSWORD_TOO_LONG 8
#define SAM_PWD_CHANGE_FAILURE_REASON_MAX 8

// Functions

_Check_return_
NTSTATUS
NTAPI
SamEnumerateUsersInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _Inout_ PSAM_ENUMERATE_HANDLE EnumerationContext,
    _In_ ULONG UserAccountControl,
    _Outptr_ PVOID *Buffer, // PSAM_RID_ENUMERATION *
    _In_ ULONG PreferedMaximumLength,
    _Out_ PULONG CountReturned
    );

_Check_return_
NTSTATUS
NTAPI
SamCreateUserInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ PUNICODE_STRING AccountName,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PSAM_HANDLE UserHandle,
    _Out_ PULONG RelativeId
    );

_Check_return_
NTSTATUS
NTAPI
SamCreateUser2InDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ PUNICODE_STRING AccountName,
    _In_ ULONG AccountType,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PSAM_HANDLE UserHandle,
    _Out_ PULONG GrantedAccess,
    _Out_ PULONG RelativeId
    );

_Check_return_
NTSTATUS
NTAPI
SamOpenUser(
    _In_ SAM_HANDLE DomainHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG UserId,
    _Out_ PSAM_HANDLE UserHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamDeleteUser(
    _In_ SAM_HANDLE UserHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamQueryInformationUser(
    _In_ SAM_HANDLE UserHandle,
    _In_ USER_INFORMATION_CLASS UserInformationClass,
    _Outptr_ PVOID *Buffer
    );

_Check_return_
NTSTATUS
NTAPI
SamSetInformationUser(
    _In_ SAM_HANDLE UserHandle,
    _In_ USER_INFORMATION_CLASS UserInformationClass,
    _In_ PVOID Buffer
    );

_Check_return_
NTSTATUS
NTAPI
SamGetGroupsForUser(
    _In_ SAM_HANDLE UserHandle,
    _Out_ _Deref_post_count_(*MembershipCount) PGROUP_MEMBERSHIP *Groups,
    _Out_ PULONG MembershipCount
    );

_Check_return_
NTSTATUS
NTAPI
SamChangePasswordUser(
    _In_ SAM_HANDLE UserHandle,
    _In_ PUNICODE_STRING OldPassword,
    _In_ PUNICODE_STRING NewPassword
    );

_Check_return_
NTSTATUS
NTAPI
SamChangePasswordUser2(
    _In_ PUNICODE_STRING ServerName,
    _In_ PUNICODE_STRING UserName,
    _In_ PUNICODE_STRING OldPassword,
    _In_ PUNICODE_STRING NewPassword
    );

_Check_return_
NTSTATUS
NTAPI
SamChangePasswordUser3(
    _In_ PUNICODE_STRING ServerName,
    _In_ PUNICODE_STRING UserName,
    _In_ PUNICODE_STRING OldPassword,
    _In_ PUNICODE_STRING NewPassword,
    _Outptr_ PDOMAIN_PASSWORD_INFORMATION *EffectivePasswordPolicy,
    _Outptr_ PUSER_PWD_CHANGE_FAILURE_INFORMATION *PasswordChangeFailureInfo
    );

_Check_return_
NTSTATUS
NTAPI
SamQueryDisplayInformation(
    _In_ SAM_HANDLE DomainHandle,
    _In_ DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    _In_ ULONG Index,
    _In_ ULONG EntryCount,
    _In_ ULONG PreferredMaximumLength,
    _Out_ PULONG TotalAvailable,
    _Out_ PULONG TotalReturned,
    _Out_ PULONG ReturnedEntryCount,
    _Outptr_ PVOID *SortedBuffer
    );

_Check_return_
NTSTATUS
NTAPI
SamGetDisplayEnumerationIndex(
    _In_ SAM_HANDLE DomainHandle,
    _In_ DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    _In_ PUNICODE_STRING Prefix,
    _Out_ PULONG Index
    );

// Database replication

typedef enum _SECURITY_DB_DELTA_TYPE
{
    SecurityDbNew = 1,
    SecurityDbRename,
    SecurityDbDelete,
    SecurityDbChangeMemberAdd,
    SecurityDbChangeMemberSet,
    SecurityDbChangeMemberDel,
    SecurityDbChange,
    SecurityDbChangePassword
} SECURITY_DB_DELTA_TYPE, *PSECURITY_DB_DELTA_TYPE;

typedef enum _SECURITY_DB_OBJECT_TYPE
{
    SecurityDbObjectSamDomain = 1,
    SecurityDbObjectSamUser,
    SecurityDbObjectSamGroup,
    SecurityDbObjectSamAlias,
    SecurityDbObjectLsaPolicy,
    SecurityDbObjectLsaTDomain,
    SecurityDbObjectLsaAccount,
    SecurityDbObjectLsaSecret
} SECURITY_DB_OBJECT_TYPE, *PSECURITY_DB_OBJECT_TYPE;

typedef enum _SAM_ACCOUNT_TYPE
{
    SamObjectUser = 1,
    SamObjectGroup,
    SamObjectAlias
} SAM_ACCOUNT_TYPE, *PSAM_ACCOUNT_TYPE;

#define SAM_USER_ACCOUNT (0x00000001)
#define SAM_GLOBAL_GROUP_ACCOUNT (0x00000002)
#define SAM_LOCAL_GROUP_ACCOUNT (0x00000004)

typedef struct _SAM_GROUP_MEMBER_ID
{
    ULONG MemberRid;
} SAM_GROUP_MEMBER_ID, *PSAM_GROUP_MEMBER_ID;

typedef struct _SAM_ALIAS_MEMBER_ID
{
    PSID MemberSid;
} SAM_ALIAS_MEMBER_ID, *PSAM_ALIAS_MEMBER_ID;

typedef union _SAM_DELTA_DATA
{
    SAM_GROUP_MEMBER_ID GroupMemberId;
    SAM_ALIAS_MEMBER_ID AliasMemberId;
    ULONG AccountControl;
} SAM_DELTA_DATA, *PSAM_DELTA_DATA;

typedef NTSTATUS (NTAPI *PSAM_DELTA_NOTIFICATION_ROUTINE)(
    _In_ PSID DomainSid,
    _In_ SECURITY_DB_DELTA_TYPE DeltaType,
    _In_ SECURITY_DB_OBJECT_TYPE ObjectType,
    _In_ ULONG ObjectRid,
    _In_opt_ PUNICODE_STRING ObjectName,
    _In_ PLARGE_INTEGER ModifiedCount,
    _In_opt_ PSAM_DELTA_DATA DeltaData
    );

#define SAM_DELTA_NOTIFY_ROUTINE "DeltaNotify"

_Check_return_
NTSTATUS
NTAPI
SamRegisterObjectChangeNotification(
    _In_ SECURITY_DB_OBJECT_TYPE ObjectType,
    _In_ HANDLE NotificationEventHandle
    );

NTSTATUS
NTAPI
SamUnregisterObjectChangeNotification(
    _In_ SECURITY_DB_OBJECT_TYPE ObjectType,
    _In_ HANDLE NotificationEventHandle
    );

// Compatibility mode

#define SAM_SID_COMPATIBILITY_ALL 0
#define SAM_SID_COMPATIBILITY_LAX 1
#define SAM_SID_COMPATIBILITY_STRICT 2

_Check_return_
NTSTATUS
NTAPI
SamGetCompatibilityMode(
    _In_ SAM_HANDLE ObjectHandle,
    _Out_ ULONG *Mode
    );

// Password validation

typedef enum _PASSWORD_POLICY_VALIDATION_TYPE
{
    SamValidateAuthentication = 1,
    SamValidatePasswordChange,
    SamValidatePasswordReset
} PASSWORD_POLICY_VALIDATION_TYPE;

typedef struct _SAM_VALIDATE_PASSWORD_HASH
{
    ULONG Length;
    _Field_size_bytes_(Length) PUCHAR Hash;
} SAM_VALIDATE_PASSWORD_HASH, *PSAM_VALIDATE_PASSWORD_HASH;

// Flags for PresentFields in SAM_VALIDATE_PERSISTED_FIELDS

#define SAM_VALIDATE_PASSWORD_LAST_SET 0x00000001
#define SAM_VALIDATE_BAD_PASSWORD_TIME 0x00000002
#define SAM_VALIDATE_LOCKOUT_TIME 0x00000004
#define SAM_VALIDATE_BAD_PASSWORD_COUNT 0x00000008
#define SAM_VALIDATE_PASSWORD_HISTORY_LENGTH 0x00000010
#define SAM_VALIDATE_PASSWORD_HISTORY 0x00000020

typedef struct _SAM_VALIDATE_PERSISTED_FIELDS
{
    ULONG PresentFields;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER BadPasswordTime;
    LARGE_INTEGER LockoutTime;
    ULONG BadPasswordCount;
    ULONG PasswordHistoryLength;
    _Field_size_bytes_(PasswordHistoryLength) PSAM_VALIDATE_PASSWORD_HASH PasswordHistory;
} SAM_VALIDATE_PERSISTED_FIELDS, *PSAM_VALIDATE_PERSISTED_FIELDS;

typedef enum _SAM_VALIDATE_VALIDATION_STATUS
{
    SamValidateSuccess = 0,
    SamValidatePasswordMustChange,
    SamValidateAccountLockedOut,
    SamValidatePasswordExpired,
    SamValidatePasswordIncorrect,
    SamValidatePasswordIsInHistory,
    SamValidatePasswordTooShort,
    SamValidatePasswordTooLong,
    SamValidatePasswordNotComplexEnough,
    SamValidatePasswordTooRecent,
    SamValidatePasswordFilterError
} SAM_VALIDATE_VALIDATION_STATUS, *PSAM_VALIDATE_VALIDATION_STATUS;

typedef struct _SAM_VALIDATE_STANDARD_OUTPUT_ARG
{
    SAM_VALIDATE_PERSISTED_FIELDS ChangedPersistedFields;
    SAM_VALIDATE_VALIDATION_STATUS ValidationStatus;
} SAM_VALIDATE_STANDARD_OUTPUT_ARG, *PSAM_VALIDATE_STANDARD_OUTPUT_ARG;

typedef struct _SAM_VALIDATE_AUTHENTICATION_INPUT_ARG
{
    SAM_VALIDATE_PERSISTED_FIELDS InputPersistedFields;
    BOOLEAN PasswordMatched;
} SAM_VALIDATE_AUTHENTICATION_INPUT_ARG, *PSAM_VALIDATE_AUTHENTICATION_INPUT_ARG;

typedef struct _SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG
{
    SAM_VALIDATE_PERSISTED_FIELDS InputPersistedFields;
    UNICODE_STRING ClearPassword;
    UNICODE_STRING UserAccountName;
    SAM_VALIDATE_PASSWORD_HASH HashedPassword;
    BOOLEAN PasswordMatch; // denotes if the old password supplied by user matched or not
} SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG, *PSAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG;

typedef struct _SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG
{
    SAM_VALIDATE_PERSISTED_FIELDS InputPersistedFields;
    UNICODE_STRING ClearPassword;
    UNICODE_STRING UserAccountName;
    SAM_VALIDATE_PASSWORD_HASH HashedPassword;
    BOOLEAN PasswordMustChangeAtNextLogon; // looked at only for password reset
    BOOLEAN ClearLockout; // can be used clear user account lockout
}SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG, *PSAM_VALIDATE_PASSWORD_RESET_INPUT_ARG;

typedef union _SAM_VALIDATE_INPUT_ARG
{
    SAM_VALIDATE_AUTHENTICATION_INPUT_ARG ValidateAuthenticationInput;
    SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG ValidatePasswordChangeInput;
    SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG ValidatePasswordResetInput;
} SAM_VALIDATE_INPUT_ARG, *PSAM_VALIDATE_INPUT_ARG;

typedef union _SAM_VALIDATE_OUTPUT_ARG
{
    SAM_VALIDATE_STANDARD_OUTPUT_ARG ValidateAuthenticationOutput;
    SAM_VALIDATE_STANDARD_OUTPUT_ARG ValidatePasswordChangeOutput;
    SAM_VALIDATE_STANDARD_OUTPUT_ARG ValidatePasswordResetOutput;
} SAM_VALIDATE_OUTPUT_ARG, *PSAM_VALIDATE_OUTPUT_ARG;

_Check_return_
NTSTATUS
NTAPI
SamValidatePassword(
    _In_opt_ PUNICODE_STRING ServerName,
    _In_ PASSWORD_POLICY_VALIDATION_TYPE ValidationType,
    _In_ PSAM_VALIDATE_INPUT_ARG InputArg,
    _Out_ PSAM_VALIDATE_OUTPUT_ARG *OutputArg
    );

// Generic operation

typedef enum _SAM_GENERIC_OPERATION_TYPE
{
    SamObjectChangeNotificationOperation
} SAM_GENERIC_OPERATION_TYPE, *PSAM_GENERIC_OPERATION_TYPE;

typedef struct _SAM_OPERATION_OBJCHG_INPUT
{
    BOOLEAN Register;
    ULONG64 EventHandle;
    SECURITY_DB_OBJECT_TYPE ObjectType;
    ULONG ProcessID;
} SAM_OPERATION_OBJCHG_INPUT, *PSAM_OPERATION_OBJCHG_INPUT;

typedef struct _SAM_OPERATION_OBJCHG_OUTPUT
{
    ULONG Reserved;
} SAM_OPERATION_OBJCHG_OUTPUT, *PSAM_OPERATION_OBJCHG_OUTPUT;

typedef union _SAM_GENERIC_OPERATION_INPUT
{
    SAM_OPERATION_OBJCHG_INPUT ObjChangeIn;
} SAM_GENERIC_OPERATION_INPUT, *PSAM_GENERIC_OPERATION_INPUT;

typedef union _SAM_GENERIC_OPERATION_OUTPUT
{
    SAM_OPERATION_OBJCHG_OUTPUT ObjChangeOut;
} SAM_GENERIC_OPERATION_OUTPUT, *PSAM_GENERIC_OPERATION_OUTPUT;

_Check_return_
NTSTATUS
NTAPI
SamPerformGenericOperation(
    _In_opt_ PWSTR ServerName,
    _In_ SAM_GENERIC_OPERATION_TYPE OperationType,
    _In_ PSAM_GENERIC_OPERATION_INPUT OperationIn,
    _Out_ PSAM_GENERIC_OPERATION_OUTPUT *OperationOut
    );

#endif

/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTMISC_H
#define _NTMISC_H

// Filter manager

#define FLT_PORT_CONNECT 0x0001
#define FLT_PORT_ALL_ACCESS (FLT_PORT_CONNECT | STANDARD_RIGHTS_ALL)

// VDM

typedef enum _VDMSERVICECLASS
{
    VdmStartExecution,
    VdmQueueInterrupt,
    VdmDelayInterrupt,
    VdmInitialize,
    VdmFeatures,
    VdmSetInt21Handler,
    VdmQueryDir,
    VdmPrinterDirectIoOpen,
    VdmPrinterDirectIoClose,
    VdmPrinterInitialize,
    VdmSetLdtEntries,
    VdmSetProcessLdtInfo,
    VdmAdlibEmulation,
    VdmPMCliControl,
    VdmQueryVdmProcess,
    VdmPreInitialize
} VDMSERVICECLASS, *PVDMSERVICECLASS;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtVdmControl(
    _In_ VDMSERVICECLASS Service,
    _Inout_ PVOID ServiceData
    );

// WMI/ETW

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTraceEvent(
    _In_ HANDLE TraceHandle,
    _In_ ULONG Flags,
    _In_ ULONG FieldSize,
    _In_ PVOID Fields
    );

typedef enum _TRACE_CONTROL_INFORMATION_CLASS
{
    TraceControlStartLogger = 1, // inout WMI_LOGGER_INFORMATION
    TraceControlStopLogger = 2, // inout WMI_LOGGER_INFORMATION
    TraceControlQueryLogger = 3, // inout WMI_LOGGER_INFORMATION
    TraceControlUpdateLogger = 4, // inout WMI_LOGGER_INFORMATION
    TraceControlFlushLogger = 5, // inout WMI_LOGGER_INFORMATION
    TraceControlIncrementLoggerFile = 6, // inout WMI_LOGGER_INFORMATION
    TraceControlUnknown = 7,
    // unused
    TraceControlRealtimeConnect = 11,
    TraceControlActivityIdCreate = 12,
    TraceControlWdiDispatchControl = 13,
    TraceControlRealtimeDisconnectConsumerByHandle = 14, // in HANDLE
    TraceControlRegisterGuidsCode = 15,
    TraceControlReceiveNotification = 16,
    TraceControlSendDataBlock = 17, // ETW_ENABLE_NOTIFICATION_PACKET
    TraceControlSendReplyDataBlock = 18,
    TraceControlReceiveReplyDataBlock = 19,
    TraceControlWdiUpdateSem = 20,
    TraceControlEnumTraceGuidList = 21, // out GUID[]
    TraceControlGetTraceGuidInfo = 22, // in GUID, out TRACE_GUID_INFO
    TraceControlEnumerateTraceGuids = 23,
    TraceControlRegisterSecurityProv = 24,
    TraceControlQueryReferenceTime = 25,
    TraceControlTrackProviderBinary = 26, // in HANDLE
    TraceControlAddNotificationEvent = 27,
    TraceControlUpdateDisallowList = 28,
    TraceControlSetEnableAllKeywordsCode = 29,
    TraceControlSetProviderTraitsCode = 30,
    TraceControlUseDescriptorTypeCode = 31,
    TraceControlEnumTraceGroupList = 32,
    TraceControlGetTraceGroupInfo = 33,
    TraceControlTraceSetDisallowList = 34,
    TraceControlSetCompressionSettings = 35,
    TraceControlGetCompressionSettings = 36,
    TraceControlUpdatePeriodicCaptureState = 37,
    TraceControlGetPrivateSessionTraceHandle = 38,
    TraceControlRegisterPrivateSession = 39,
    TraceControlQuerySessionDemuxObject = 40,
    TraceControlSetProviderBinaryTracking = 41,
    TraceControlMaxLoggers = 42, // out ULONG
    TraceControlMaxPmcCounter = 43, // out ULONG
    TraceControlQueryUsedProcessorCount = 44, // ULONG // since WIN11
    TraceControlGetPmcOwnership = 45,
} TRACE_CONTROL_INFORMATION_CLASS;

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtTraceControl(
    _In_ TRACE_CONTROL_INFORMATION_CLASS TraceInformationClass,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(TraceInformationLength) PVOID TraceInformation,
    _In_ ULONG TraceInformationLength,
    _Out_ PULONG ReturnLength
    );
#endif

#endif

/*
 * This file is part of the Process Hacker project - https://processhacker.sourceforge.io/
 *
 * You can redistribute this file and/or modify it under the terms of the 
 * Attribution 4.0 International (CC BY 4.0) license. 
 * 
 * You must give appropriate credit, provide a link to the license, and 
 * indicate if changes were made. You may do so in any reasonable manner, but 
 * not in any way that suggests the licensor endorses you or your use.
 */

#ifndef _NTZWAPI_H
#define _NTZWAPI_H

// This file was automatically generated. Do not edit.

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAcceptConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ PVOID PortContext,
    _In_ PPORT_MESSAGE ConnectionRequest,
    _In_ BOOLEAN AcceptConnection,
    _Inout_opt_ PPORT_VIEW ServerView,
    _Out_opt_ PREMOTE_PORT_VIEW ClientView
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheck(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheckAndAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheckByType(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeAndAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ AUDIT_EVENT_TYPE AuditType,
    _In_ ULONG Flags,
    _In_reads_opt_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultList(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ AUDIT_EVENT_TYPE AuditType,
    _In_ ULONG Flags,
    _In_reads_opt_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarmByHandle(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ HANDLE ClientToken,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ AUDIT_EVENT_TYPE AuditType,
    _In_ ULONG Flags,
    _In_reads_opt_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAcquireCMFViewOwnership(
    _Out_ PULONGLONG TimeStamp,
    _Out_ PBOOLEAN tokenTaken,
    _In_ BOOLEAN replaceExisting
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAddAtom(
    _In_reads_bytes_opt_(Length) PWSTR AtomName,
    _In_ ULONG Length,
    _Out_opt_ PRTL_ATOM Atom
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAddAtomEx(
    _In_reads_bytes_opt_(Length) PWSTR AtomName,
    _In_ ULONG Length,
    _Out_opt_ PRTL_ATOM Atom,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAddBootEntry(
    _In_ PBOOT_ENTRY BootEntry,
    _Out_opt_ PULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAddDriverEntry(
    _In_ PEFI_DRIVER_ENTRY DriverEntry,
    _Out_opt_ PULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAdjustGroupsToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN ResetToDefault,
    _In_opt_ PTOKEN_GROUPS NewState,
    _In_opt_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAdjustPrivilegesToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN DisableAllPrivileges,
    _In_opt_ PTOKEN_PRIVILEGES NewState,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAdjustTokenClaimsAndDeviceGroups(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN UserResetToDefault,
    _In_ BOOLEAN DeviceResetToDefault,
    _In_ BOOLEAN DeviceGroupsResetToDefault,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewUserState,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewDeviceState,
    _In_opt_ PTOKEN_GROUPS NewDeviceGroupsState,
    _In_ ULONG UserBufferLength,
    _Out_writes_bytes_to_opt_(UserBufferLength, *UserReturnLength) PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousUserState,
    _In_ ULONG DeviceBufferLength,
    _Out_writes_bytes_to_opt_(DeviceBufferLength, *DeviceReturnLength) PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousDeviceState,
    _In_ ULONG DeviceGroupsBufferLength,
    _Out_writes_bytes_to_opt_(DeviceGroupsBufferLength, *DeviceGroupsReturnBufferLength) PTOKEN_GROUPS PreviousDeviceGroups,
    _Out_opt_ PULONG UserReturnLength,
    _Out_opt_ PULONG DeviceReturnLength,
    _Out_opt_ PULONG DeviceGroupsReturnBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlertResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlertThread(
    _In_ HANDLE ThreadHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlertThreadByThreadId(
    _In_ HANDLE ThreadId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAllocateLocallyUniqueId(
    _Out_ PLUID Luid
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAllocateReserveObject(
    _Out_ PHANDLE MemoryReserveHandle,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ MEMORY_RESERVE_TYPE Type
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAllocateUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _Out_writes_(*NumberOfPages) PULONG_PTR UserPfnArray
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAllocateUserPhysicalPagesEx(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _Out_writes_(*NumberOfPages) PULONG_PTR UserPfnArray,
    _Inout_updates_opt_(ParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAllocateUuids(
    _Out_ PULARGE_INTEGER Time,
    _Out_ PULONG Range,
    _Out_ PULONG Sequence,
    _Out_ PCHAR Seed
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAllocateVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcAcceptConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ HANDLE ConnectionPortHandle,
    _In_ ULONG Flags,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes,
    _In_opt_ PVOID PortContext,
    _In_reads_bytes_(ConnectionRequest->u1.s1.TotalLength) PPORT_MESSAGE ConnectionRequest,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes,
    _In_ BOOLEAN AcceptConnection
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcCancelMessage(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags,
    _In_ PALPC_CONTEXT_ATTR MessageContext
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes,
    _In_ ULONG Flags,
    _In_opt_ PSID RequiredServerSid,
    _Inout_updates_bytes_to_opt_(*BufferLength, *BufferLength) PPORT_MESSAGE ConnectionMessage,
    _Inout_opt_ PULONG BufferLength,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES InMessageAttributes,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcConnectPortEx(
    _Out_ PHANDLE PortHandle,
    _In_ POBJECT_ATTRIBUTES ConnectionPortObjectAttributes,
    _In_opt_ POBJECT_ATTRIBUTES ClientPortObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes,
    _In_ ULONG Flags,
    _In_opt_ PSECURITY_DESCRIPTOR ServerSecurityRequirements,
    _Inout_updates_bytes_to_opt_(*BufferLength, *BufferLength) PPORT_MESSAGE ConnectionMessage,
    _Inout_opt_ PSIZE_T BufferLength,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES InMessageAttributes,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcCreatePort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcCreatePortSection(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags,
    _In_opt_ HANDLE SectionHandle,
    _In_ SIZE_T SectionSize,
    _Out_ PALPC_HANDLE AlpcSectionHandle,
    _Out_ PSIZE_T ActualSectionSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcCreateResourceReserve(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ SIZE_T MessageSize,
    _Out_ PALPC_HANDLE ResourceId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcCreateSectionView(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _Inout_ PALPC_DATA_VIEW_ATTR ViewAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcCreateSecurityContext(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _Inout_ PALPC_SECURITY_ATTR SecurityAttribute
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcDeletePortSection(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE SectionHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcDeleteResourceReserve(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE ResourceId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcDeleteSectionView(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ PVOID ViewBase
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcDeleteSecurityContext(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE ContextHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcDisconnectPort(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcImpersonateClientContainerOfPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcImpersonateClientOfPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ PVOID Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcOpenSenderProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE PortMessage,
    _In_ ULONG Flags,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcOpenSenderThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE PortMessage,
    _In_ ULONG Flags,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcQueryInformation(
    _In_opt_ HANDLE PortHandle,
    _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass,
    _Inout_updates_bytes_to_(Length, *ReturnLength) PVOID PortInformation,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcQueryInformationMessage(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE PortMessage,
    _In_ ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass,
    _Out_writes_bytes_to_opt_(Length, *ReturnLength) PVOID MessageInformation,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcRevokeSecurityContext(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE ContextHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcSendWaitReceivePort(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags,
    _In_reads_bytes_opt_(SendMessage->u1.s1.TotalLength) PPORT_MESSAGE SendMessage,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes,
    _Out_writes_bytes_to_opt_(*BufferLength, *BufferLength) PPORT_MESSAGE ReceiveMessage,
    _Inout_opt_ PSIZE_T BufferLength,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcSetInformation(
    _In_ HANDLE PortHandle,
    _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass,
    _In_reads_bytes_opt_(Length) PVOID PortInformation,
    _In_ ULONG Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAreMappedFilesTheSame(
    _In_ PVOID File1MappedAsAnImage,
    _In_ PVOID File2MappedAsFile
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAssignProcessToJobObject(
    _In_ HANDLE JobHandle,
    _In_ HANDLE ProcessHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAssociateWaitCompletionPacket(
    _In_ HANDLE WaitCompletionPacketHandle,
    _In_ HANDLE IoCompletionHandle,
    _In_ HANDLE TargetObjectHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation,
    _Out_opt_ PBOOLEAN AlreadySignaled
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCallbackReturn(
    _In_reads_bytes_opt_(OutputLength) PVOID OutputBuffer,
    _In_ ULONG OutputLength,
    _In_ NTSTATUS Status
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCallEnclave(
    _In_ PENCLAVE_ROUTINE Routine,
    _In_ PVOID Parameter,
    _In_ BOOLEAN WaitForThread,
    _Out_opt_ PVOID *ReturnValue
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelIoFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelIoFileEx(
    _In_ HANDLE FileHandle,
    _In_opt_ PIO_STATUS_BLOCK IoRequestToCancel,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelSynchronousIoFile(
    _In_ HANDLE ThreadHandle,
    _In_opt_ PIO_STATUS_BLOCK IoRequestToCancel,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelTimer(
    _In_ HANDLE TimerHandle,
    _Out_opt_ PBOOLEAN CurrentState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelTimer2(
    _In_ HANDLE TimerHandle,
    _In_ PT2_CANCEL_PARAMETERS Parameters
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelWaitCompletionPacket(
    _In_ HANDLE WaitCompletionPacketHandle,
    _In_ BOOLEAN RemoveSignaledPacket
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwChangeProcessState(
    _In_ HANDLE ProcessStateChangeHandle,
    _In_ HANDLE ProcessHandle,
    _In_ PROCESS_STATE_CHANGE_TYPE StateChangeType,
    _In_opt_ PVOID ExtendedInformation,
    _In_opt_ SIZE_T ExtendedInformationLength,
    _In_opt_ ULONG64 Reserved
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwChangeThreadState(
    _In_ HANDLE ThreadStateChangeHandle,
    _In_ HANDLE ThreadHandle,
    _In_ THREAD_STATE_CHANGE_TYPE StateChangeType,
    _In_opt_ PVOID ExtendedInformation,
    _In_opt_ SIZE_T ExtendedInformationLength,
    _In_opt_ ULONG64 Reserved
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwClearEvent(
    _In_ HANDLE EventHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwClose(
    _In_ _Post_ptr_invalid_ HANDLE Handle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCloseObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ BOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCommitComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCommitEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCommitTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCompactKeys(
    _In_ ULONG Count,
    _In_reads_(Count) HANDLE KeyArray[]
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCompareObjects(
    _In_ HANDLE FirstObjectHandle,
    _In_ HANDLE SecondObjectHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCompareSigningLevels(
    _In_ SE_SIGNING_LEVEL FirstSigningLevel,
    _In_ SE_SIGNING_LEVEL SecondSigningLevel
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCompareTokens(
    _In_ HANDLE FirstTokenHandle,
    _In_ HANDLE SecondTokenHandle,
    _Out_ PBOOLEAN Equal
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCompleteConnectPort(
    _In_ HANDLE PortHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCompressKey(
    _In_ HANDLE Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _Inout_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_updates_bytes_to_opt_(*ConnectionInformationLength, *ConnectionInformationLength) PVOID ConnectionInformation,
    _Inout_opt_ PULONG ConnectionInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwContinue(
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN TestAlert
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwContinueEx(
    _In_ PCONTEXT ContextRecord,
    _In_ PVOID ContinueArgument // PKCONTINUE_ARGUMENT and BOOLEAN are valid
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateDebugObject(
    _Out_ PHANDLE DebugObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObjectEx(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ShadowDirectoryHandle,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateEnclave(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T Size,
    _In_ SIZE_T InitialCommitment,
    _In_ ULONG EnclaveType,
    _In_reads_bytes_(EnclaveInformationLength) PVOID EnclaveInformation,
    _In_ ULONG EnclaveInformationLength,
    _Out_opt_ PULONG EnclaveError
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ HANDLE TransactionHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_ NOTIFICATION_MASK NotificationMask,
    _In_opt_ PVOID EnlistmentKey
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ EVENT_TYPE EventType,
    _In_ BOOLEAN InitialState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER AllocationSize,
    _In_ ULONG FileAttributes,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,
    _In_ ULONG EaLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateIRTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateJobSet(
    _In_ ULONG NumJob,
    _In_reads_(NumJob) PJOB_SET_ARRAY UserJobSet,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _Out_opt_ PULONG Disposition
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateKeyedEvent(
    _Out_ PHANDLE KeyedEventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _In_ HANDLE TransactionHandle,
    _Out_opt_ PULONG Disposition
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateLowBoxToken(
    _Out_ PHANDLE TokenHandle,
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PSID PackageSid,
    _In_ ULONG CapabilityCount,
    _In_reads_opt_(CapabilityCount) PSID_AND_ATTRIBUTES Capabilities,
    _In_ ULONG HandleCount,
    _In_reads_opt_(HandleCount) HANDLE *Handles
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateMailslotFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CreateOptions,
    _In_ ULONG MailslotQuota,
    _In_ ULONG MaximumMessageSize,
    _In_ PLARGE_INTEGER ReadTimeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN InitialOwner
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateNamedPipeFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_ ULONG NamedPipeType,
    _In_ ULONG ReadMode,
    _In_ ULONG CompletionMode,
    _In_ ULONG MaximumInstances,
    _In_ ULONG InboundQuota,
    _In_ ULONG OutboundQuota,
    _In_opt_ PLARGE_INTEGER DefaultTimeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreatePagingFile(
    _In_ PUNICODE_STRING PageFileName,
    _In_ PLARGE_INTEGER MinimumSize,
    _In_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG Priority
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreatePartition(
    _In_ HANDLE ParentPartitionHandle,
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG PreferredNode
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreatePort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG MaxConnectionInfoLength,
    _In_ ULONG MaxMessageLength,
    _In_opt_ ULONG MaxPoolUsage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreatePrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ POBJECT_BOUNDARY_DESCRIPTOR BoundaryDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritObjectTable,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateProcessEx(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ ULONG Flags, // PROCESS_CREATE_FLAGS_*
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE TokenHandle,
    _Reserved_ ULONG Reserved // JobMemberLevel
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateProcessStateChange(
    _Out_ PHANDLE ProcessStateChangeHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _In_opt_ ULONG64 Reserved
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateProfile(
    _Out_ PHANDLE ProfileHandle,
    _In_opt_ HANDLE Process,
    _In_ PVOID ProfileBase,
    _In_ SIZE_T ProfileSize,
    _In_ ULONG BucketSize,
    _In_reads_bytes_(BufferSize) PULONG Buffer,
    _In_ ULONG BufferSize,
    _In_ KPROFILE_SOURCE ProfileSource,
    _In_ KAFFINITY Affinity
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateProfileEx(
    _Out_ PHANDLE ProfileHandle,
    _In_opt_ HANDLE Process,
    _In_ PVOID ProfileBase,
    _In_ SIZE_T ProfileSize,
    _In_ ULONG BucketSize,
    _In_reads_bytes_(BufferSize) PULONG Buffer,
    _In_ ULONG BufferSize,
    _In_ KPROFILE_SOURCE ProfileSource,
    _In_ USHORT GroupCount,
    _In_reads_(GroupCount) PGROUP_AFFINITY GroupAffinity
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_ LPGUID RmGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ PUNICODE_STRING Description
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateSectionEx(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle,
    _Inout_updates_opt_(ExtendedParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ LONG InitialCount,
    _In_ LONG MaximumCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PUNICODE_STRING LinkTarget
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _Out_ PCLIENT_ID ClientId,
    _In_ PCONTEXT ThreadContext,
    _In_ PINITIAL_TEB InitialTeb,
    _In_ BOOLEAN CreateSuspended
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateThreadEx(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _In_ PVOID StartRoutine, // PUSER_THREAD_START_ROUTINE
    _In_opt_ PVOID Argument,
    _In_ ULONG CreateFlags, // THREAD_CREATE_FLAGS_*
    _In_ SIZE_T ZeroBits,
    _In_ SIZE_T StackSize,
    _In_ SIZE_T MaximumStackSize,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateThreadStateChange(
    _Out_ PHANDLE ThreadStateChangeHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ThreadHandle,
    _In_opt_ ULONG64 Reserved
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TIMER_TYPE TimerType
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTimer2(
    _Out_ PHANDLE TimerHandle,
    _In_opt_ PVOID Reserved1,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Attributes,
    _In_ ACCESS_MASK DesiredAccess
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateToken(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE Type,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE Source
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTokenEx(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE Type,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION UserAttributes,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION DeviceAttributes,
    _In_opt_ PTOKEN_GROUPS DeviceGroups,
    _In_opt_ PTOKEN_MANDATORY_POLICY MandatoryPolicy,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE Source
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ ULONG IsolationLevel,
    _In_opt_ ULONG IsolationFlags,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_opt_ PUNICODE_STRING Description
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ ULONG CommitStrength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateUserProcess(
    _Out_ PHANDLE ProcessHandle,
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK ProcessDesiredAccess,
    _In_ ACCESS_MASK ThreadDesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
    _In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
    _In_ ULONG ProcessFlags, // PROCESS_CREATE_FLAGS_*
    _In_ ULONG ThreadFlags, // THREAD_CREATE_FLAGS_*
    _In_opt_ PVOID ProcessParameters, // PRTL_USER_PROCESS_PARAMETERS
    _Inout_ PPS_CREATE_INFO CreateInfo,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateWaitablePort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG MaxConnectionInfoLength,
    _In_ ULONG MaxMessageLength,
    _In_opt_ ULONG MaxPoolUsage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateWaitCompletionPacket(
    _Out_ PHANDLE WaitCompletionPacketHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateWnfStateName(
    _Out_ PWNF_STATE_NAME StateName,
    _In_ WNF_STATE_NAME_LIFETIME NameLifetime,
    _In_ WNF_DATA_SCOPE DataScope,
    _In_ BOOLEAN PersistData,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_ ULONG MaximumStateSize,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateWorkerFactory(
    _Out_ PHANDLE WorkerFactoryHandleReturn,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE CompletionPortHandle,
    _In_ HANDLE WorkerProcessHandle,
    _In_ PVOID StartRoutine,
    _In_opt_ PVOID StartParameter,
    _In_opt_ ULONG MaxThreadCount,
    _In_opt_ SIZE_T StackReserve,
    _In_opt_ SIZE_T StackCommit
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDebugActiveProcess(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDebugContinue(
    _In_ HANDLE DebugObjectHandle,
    _In_ PCLIENT_ID ClientId,
    _In_ NTSTATUS ContinueStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDelayExecution(
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER DelayInterval
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteAtom(
    _In_ RTL_ATOM Atom
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteBootEntry(
    _In_ ULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteDriverEntry(
    _In_ ULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteKey(
    _In_ HANDLE KeyHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ BOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeletePrivateNamespace(
    _In_ HANDLE NamespaceHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ const VOID *ExplicitScope
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteWnfStateName(
    _In_ PCWNF_STATE_NAME StateName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG IoControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDisableLastKnownGood(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDisplayString(
    _In_ PUNICODE_STRING String
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDrawText(
    _In_ PUNICODE_STRING Text
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDuplicateObject(
    _In_ HANDLE SourceProcessHandle,
    _In_ HANDLE SourceHandle,
    _In_opt_ HANDLE TargetProcessHandle,
    _Out_opt_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDuplicateToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN EffectiveOnly,
    _In_ TOKEN_TYPE Type,
    _Out_ PHANDLE NewTokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnableLastKnownGood(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateBootEntries(
    _Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
    _Inout_ PULONG BufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateDriverEntries(
    _Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
    _Inout_ PULONG BufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateSystemEnvironmentValuesEx(
    _In_ ULONG InformationClass, // SYSTEM_ENVIRONMENT_INFORMATION_CLASS
    _Out_ PVOID Buffer,
    _Inout_ PULONG BufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateTransactionObject(
    _In_opt_ HANDLE RootObjectHandle,
    _In_ KTMOBJECT_TYPE QueryType,
    _Inout_updates_bytes_(ObjectCursorLength) PKTMOBJECT_CURSOR ObjectCursor,
    _In_ ULONG ObjectCursorLength,
    _Out_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwExtendSection(
    _In_ HANDLE SectionHandle,
    _Inout_ PLARGE_INTEGER NewSectionSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFilterBootOption(
    _In_ FILTER_BOOT_OPTION_OPERATION FilterOperation,
    _In_ ULONG ObjectType,
    _In_ ULONG ElementType,
    _In_reads_bytes_opt_(DataSize) PVOID Data,
    _In_ ULONG DataSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFilterToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ULONG Flags,
    _In_opt_ PTOKEN_GROUPS SidsToDisable,
    _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
    _In_opt_ PTOKEN_GROUPS RestrictedSids,
    _Out_ PHANDLE NewTokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFilterTokenEx(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ULONG Flags,
    _In_opt_ PTOKEN_GROUPS SidsToDisable,
    _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
    _In_opt_ PTOKEN_GROUPS RestrictedSids,
    _In_ ULONG DisableUserClaimsCount,
    _In_opt_ PUNICODE_STRING UserClaimsToDisable,
    _In_ ULONG DisableDeviceClaimsCount,
    _In_opt_ PUNICODE_STRING DeviceClaimsToDisable,
    _In_opt_ PTOKEN_GROUPS DeviceGroupsToDisable,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedUserAttributes,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedDeviceAttributes,
    _In_opt_ PTOKEN_GROUPS RestrictedDeviceGroups,
    _Out_ PHANDLE NewTokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFindAtom(
    _In_reads_bytes_opt_(Length) PWSTR AtomName,
    _In_ ULONG Length,
    _Out_opt_ PRTL_ATOM Atom
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushBuffersFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushBuffersFileEx(
    _In_ HANDLE FileHandle,
    _In_ ULONG Flags,
    _In_reads_bytes_(ParametersSize) PVOID Parameters,
    _In_ ULONG ParametersSize,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushInstallUILanguage(
    _In_ LANGID InstallUILanguage,
    _In_ ULONG SetComittedFlag
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushInstructionCache(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ SIZE_T Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushKey(
    _In_ HANDLE KeyHandle
    );

NTSYSCALLAPI
VOID
NTAPI
ZwFlushProcessWriteBuffers(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _Out_ struct _IO_STATUS_BLOCK* IoStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushWriteBuffer(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFreeUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _In_reads_(*NumberOfPages) PULONG_PTR UserPfnArray
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFreeVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG FreeType
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFreezeRegistry(
    _In_ ULONG TimeOutInSeconds
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFreezeTransactions(
    _In_ PLARGE_INTEGER FreezeTimeout,
    _In_ PLARGE_INTEGER ThawTimeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFsControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG FsControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetCachedSigningLevel(
    _In_ HANDLE File,
    _Out_ PULONG Flags,
    _Out_ PSE_SIGNING_LEVEL SigningLevel,
    _Out_writes_bytes_to_opt_(*ThumbprintSize, *ThumbprintSize) PUCHAR Thumbprint,
    _Inout_opt_ PULONG ThumbprintSize,
    _Out_opt_ PULONG ThumbprintAlgorithm
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetCompleteWnfStateSubscription(
    _In_opt_ PWNF_STATE_NAME OldDescriptorStateName,
    _In_opt_ ULONG64 *OldSubscriptionId,
    _In_opt_ ULONG OldDescriptorEventMask,
    _In_opt_ ULONG OldDescriptorStatus,
    _Out_writes_bytes_(DescriptorSize) PWNF_DELIVERY_DESCRIPTOR NewDeliveryDescriptor,
    _In_ ULONG DescriptorSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetContextThread(
    _In_ HANDLE ThreadHandle,
    _Inout_ PCONTEXT ThreadContext
    );

NTSYSCALLAPI
ULONG
NTAPI
ZwGetCurrentProcessorNumber(
    VOID
    );

NTSYSCALLAPI
ULONG
NTAPI
ZwGetCurrentProcessorNumberEx(
    _Out_opt_ PPROCESSOR_NUMBER ProcessorNumber
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetDevicePowerState(
    _In_ HANDLE Device,
    _Out_ PDEVICE_POWER_STATE State
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetMUIRegistryInfo(
    _In_ ULONG Flags,
    _Inout_ PULONG DataSize,
    _Out_ PVOID Data
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetNextProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewProcessHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetNextThread(
    _In_ HANDLE ProcessHandle,
    _In_opt_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewThreadHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetNlsSectionPtr(
    _In_ ULONG SectionType,
    _In_ ULONG SectionData,
    _In_ PVOID ContextData,
    _Out_ PVOID *SectionPointer,
    _Out_ PULONG SectionSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetNotificationResourceManager(
    _In_ HANDLE ResourceManagerHandle,
    _Out_ PTRANSACTION_NOTIFICATION TransactionNotification,
    _In_ ULONG NotificationLength,
    _In_opt_ PLARGE_INTEGER Timeout,
    _Out_opt_ PULONG ReturnLength,
    _In_ ULONG Asynchronous,
    _In_opt_ ULONG_PTR AsynchronousContext
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetPlugPlayEvent(
    _In_ HANDLE EventHandle,
    _In_opt_ PVOID Context,
    _Out_writes_bytes_(EventBufferSize) PPLUGPLAY_EVENT_BLOCK EventBlock,
    _In_ ULONG EventBufferSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetWriteWatch(
    _In_ HANDLE ProcessHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress,
    _In_ SIZE_T RegionSize,
    _Out_writes_(*EntriesInUserAddressArray) PVOID *UserAddressArray,
    _Inout_ PULONG_PTR EntriesInUserAddressArray,
    _Out_ PULONG Granularity
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwImpersonateAnonymousToken(
    _In_ HANDLE ThreadHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwImpersonateClientOfPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwImpersonateThread(
    _In_ HANDLE ServerThreadHandle,
    _In_ HANDLE ClientThreadHandle,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwInitializeEnclave(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_reads_bytes_(EnclaveInformationLength) PVOID EnclaveInformation,
    _In_ ULONG EnclaveInformationLength,
    _Out_opt_ PULONG EnclaveError
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwInitializeNlsFiles(
    _Out_ PVOID *BaseAddress,
    _Out_ PLCID DefaultLocaleId,
    _Out_ PLARGE_INTEGER DefaultCasingTableSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwInitializeRegistry(
    _In_ USHORT BootCondition
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwInitiatePowerAction(
    _In_ POWER_ACTION SystemAction,
    _In_ SYSTEM_POWER_STATE LightestSystemState,
    _In_ ULONG Flags, // POWER_ACTION_* flags
    _In_ BOOLEAN Asynchronous
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwIsProcessInJob(
    _In_ HANDLE ProcessHandle,
    _In_opt_ HANDLE JobHandle
    );

NTSYSCALLAPI
BOOLEAN
NTAPI
ZwIsSystemResumeAutomatic(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwIsUILanguageComitted(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwListenPort(
    _In_ HANDLE PortHandle,
    _Out_ PPORT_MESSAGE ConnectionRequest
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLoadDriver(
    _In_ PUNICODE_STRING DriverServiceName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLoadEnclaveData(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _In_ ULONG Protect,
    _In_reads_bytes_(PageInformationLength) PVOID PageInformation,
    _In_ ULONG PageInformationLength,
    _Out_opt_ PSIZE_T NumberOfBytesWritten,
    _Out_opt_ PULONG EnclaveError
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLoadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLoadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLoadKey3(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_reads_(LoadEntryCount) PKEY_LOAD_ENTRY LoadEntries,
    _In_ ULONG LoadEntryCount,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _Reserved_ PVOID Reserved
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLoadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_opt_ HANDLE TrustClassKey, // this and below were added on Win10
    _In_opt_ HANDLE Event,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _Reserved_ PVOID Reserved // previously PIO_STATUS_BLOCK
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLockFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key,
    _In_ BOOLEAN FailImmediately,
    _In_ BOOLEAN ExclusiveLock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLockProductActivationKeys(
    _Inout_opt_ ULONG *pPrivateVer,
    _Out_opt_ ULONG *pSafeMode
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLockRegistryKey(
    _In_ HANDLE KeyHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwMakePermanentObject(
    _In_ HANDLE Handle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
    _In_ HANDLE Handle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwManagePartition(
    _In_ HANDLE TargetHandle,
    _In_opt_ HANDLE SourceHandle,
    _In_ PARTITION_INFORMATION_CLASS PartitionInformationClass,
    _Inout_updates_bytes_(PartitionInformationLength) PVOID PartitionInformation,
    _In_ ULONG PartitionInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwMapCMFModule(
    _In_ ULONG What,
    _In_ ULONG Index,
    _Out_opt_ PULONG CacheIndexOut,
    _Out_opt_ PULONG CacheFlagsOut,
    _Out_opt_ PULONG ViewSizeOut,
    _Out_opt_ PVOID *BaseAddress
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwMapUserPhysicalPages(
    _In_ PVOID VirtualAddress,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwMapUserPhysicalPagesScatter(
    _In_reads_(NumberOfPages) PVOID *VirtualAddresses,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T CommitSize,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ SECTION_INHERIT InheritDisposition,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwModifyBootEntry(
    _In_ PBOOT_ENTRY BootEntry
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwModifyDriverEntry(
    _In_ PEFI_DRIVER_ENTRY DriverEntry
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwNotifyChangeDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer, // FILE_NOTIFY_INFORMATION
    _In_ ULONG Length,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwNotifyChangeDirectoryFileEx(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _In_opt_ DIRECTORY_NOTIFY_INFORMATION_CLASS DirectoryNotifyInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwNotifyChangeKey(
    _In_ HANDLE KeyHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ BOOLEAN Asynchronous
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwNotifyChangeMultipleKeys(
    _In_ HANDLE MasterKeyHandle,
    _In_opt_ ULONG Count,
    _In_reads_opt_(Count) OBJECT_ATTRIBUTES SubordinateObjects[],
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ BOOLEAN Asynchronous
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwNotifyChangeSession(
    _In_ HANDLE SessionHandle,
    _In_ ULONG ChangeSequenceNumber,
    _In_ PLARGE_INTEGER ChangeTimeStamp,
    _In_ IO_SESSION_EVENT Event,
    _In_ IO_SESSION_STATE NewState,
    _In_ IO_SESSION_STATE PreviousState,
    _In_reads_bytes_opt_(PayloadSize) PVOID Payload,
    _In_ ULONG PayloadSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ LPGUID EnlistmentGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG OpenOptions
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenKeyedEvent(
    _Out_ PHANDLE KeyedEventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenKeyEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE TransactionHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenKeyTransactedEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions,
    _In_ HANDLE TransactionHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ACCESS_MASK GrantedAccess,
    _In_opt_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN ObjectCreation,
    _In_ BOOLEAN AccessGranted,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenPartition(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenPrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ POBJECT_BOUNDARY_DESCRIPTOR BoundaryDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenProcessToken(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenProcessTokenEx(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_opt_ LPGUID ResourceManagerGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenSession(
    _Out_ PHANDLE SessionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenThreadToken(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenThreadTokenEx(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ LPGUID TmIdentity,
    _In_opt_ ULONG OpenOptions
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPlugPlayControl(
    _In_ PLUGPLAY_CONTROL_CLASS PnPControlClass,
    _Inout_updates_bytes_(PnPControlDataLength) PVOID PnPControlData,
    _In_ ULONG PnPControlDataLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPowerInformation(
    _In_ POWER_INFORMATION_LEVEL InformationLevel,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrepareComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrepareEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrePrepareComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrePrepareEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrivilegeCheck(
    _In_ HANDLE ClientToken,
    _Inout_ PPRIVILEGE_SET RequiredPrivileges,
    _Out_ PBOOLEAN Result
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrivilegedServiceAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_ PUNICODE_STRING ServiceName,
    _In_ HANDLE ClientToken,
    _In_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN AccessGranted
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrivilegeObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN AccessGranted
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPropagationComplete(
    _In_ HANDLE ResourceManagerHandle,
    _In_ ULONG RequestCookie,
    _In_ ULONG BufferLength,
    _In_ PVOID Buffer
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPropagationFailed(
    _In_ HANDLE ResourceManagerHandle,
    _In_ ULONG RequestCookie,
    _In_ NTSTATUS PropStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwProtectVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG NewProtect,
    _Out_ PULONG OldProtect
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPulseEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryAttributesFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PFILE_BASIC_INFORMATION FileInformation
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryBootEntryOrder(
    _Out_writes_opt_(*Count) PULONG Ids,
    _Inout_ PULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryBootOptions(
    _Out_writes_bytes_opt_(*BootOptionsLength) PBOOT_OPTIONS BootOptions,
    _Inout_ PULONG BootOptionsLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDefaultLocale(
    _In_ BOOLEAN UserProfile,
    _Out_ PLCID DefaultLocaleId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDefaultUILanguage(
    _Out_ LANGID *DefaultUILanguageId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_opt_ PUNICODE_STRING FileName,
    _In_ BOOLEAN RestartScan
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDirectoryFileEx(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ ULONG QueryFlags,
    _In_opt_ PUNICODE_STRING FileName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDirectoryObject(
    _In_ HANDLE DirectoryHandle,
    _Out_writes_bytes_opt_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_ BOOLEAN RestartScan,
    _Inout_ PULONG Context,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDriverEntryOrder(
    _Out_writes_opt_(*Count) PULONG Ids,
    _Inout_ PULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(EaListLength) PVOID EaList,
    _In_ ULONG EaListLength,
    _In_opt_ PULONG EaIndex,
    _In_ BOOLEAN RestartScan
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryEvent(
    _In_ HANDLE EventHandle,
    _In_ EVENT_INFORMATION_CLASS EventInformationClass,
    _Out_writes_bytes_(EventInformationLength) PVOID EventInformation,
    _In_ ULONG EventInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryFullAttributesFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PFILE_NETWORK_OPEN_INFORMATION FileInformation
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationAtom(
    _In_ RTL_ATOM Atom,
    _In_ ATOM_INFORMATION_CLASS AtomInformationClass,
    _Out_writes_bytes_(AtomInformationLength) PVOID AtomInformation,
    _In_ ULONG AtomInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationByName(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_ ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
    _Out_writes_bytes_(EnlistmentInformationLength) PVOID EnlistmentInformation,
    _In_ ULONG EnlistmentInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationJobObject(
    _In_opt_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _Out_writes_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationPort(
    _In_ HANDLE PortHandle,
    _In_ PORT_INFORMATION_CLASS PortInformationClass,
    _Out_writes_bytes_to_(Length, *ReturnLength) PVOID PortInformation,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _Out_writes_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationResourceManager(
    _In_ HANDLE ResourceManagerHandle,
    _In_ RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
    _Out_writes_bytes_(ResourceManagerInformationLength) PVOID ResourceManagerInformation,
    _In_ ULONG ResourceManagerInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _Out_writes_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength,
    _Out_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    _Out_writes_bytes_(TransactionInformationLength) PVOID TransactionInformation,
    _In_ ULONG TransactionInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationTransactionManager(
    _In_ HANDLE TransactionManagerHandle,
    _In_ TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
    _Out_writes_bytes_(TransactionManagerInformationLength) PVOID TransactionManagerInformation,
    _In_ ULONG TransactionManagerInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
    _Out_writes_bytes_(WorkerFactoryInformationLength) PVOID WorkerFactoryInformation,
    _In_ ULONG WorkerFactoryInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInstallUILanguage(
    _Out_ LANGID *InstallUILanguageId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryIntervalProfile(
    _In_ KPROFILE_SOURCE ProfileSource,
    _Out_ PULONG Interval
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_ IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    _Out_writes_bytes_(IoCompletionInformationLength) PVOID IoCompletionInformation,
    _In_ ULONG IoCompletionInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryLicenseValue(
    _In_ PUNICODE_STRING ValueName,
    _Out_opt_ PULONG Type,
    _Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,
    _In_ ULONG DataSize,
    _Out_ PULONG ResultDataSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryMultipleValueKey(
    _In_ HANDLE KeyHandle,
    _Inout_updates_(EntryCount) PKEY_VALUE_ENTRY ValueEntries,
    _In_ ULONG EntryCount,
    _Out_writes_bytes_(*BufferLength) PVOID ValueBuffer,
    _Inout_ PULONG BufferLength,
    _Out_opt_ PULONG RequiredBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryMutant(
    _In_ HANDLE MutantHandle,
    _In_ MUTANT_INFORMATION_CLASS MutantInformationClass,
    _Out_writes_bytes_(MutantInformationLength) PVOID MutantInformation,
    _In_ ULONG MutantInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryObject(
    _In_opt_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _Out_writes_bytes_opt_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryOpenSubKeys(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _Out_ PULONG HandleCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryOpenSubKeysEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_opt_(BufferLength) PVOID Buffer,
    _Out_ PULONG RequiredSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryPerformanceCounter(
    _Out_ PLARGE_INTEGER PerformanceCounter,
    _Out_opt_ PLARGE_INTEGER PerformanceFrequency
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(SidListLength) PVOID SidList,
    _In_ ULONG SidListLength,
    _In_opt_ PSID StartSid,
    _In_ BOOLEAN RestartScan
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySection(
    _In_ HANDLE SectionHandle,
    _In_ SECTION_INFORMATION_CLASS SectionInformationClass,
    _Out_writes_bytes_(SectionInformationLength) PVOID SectionInformation,
    _In_ SIZE_T SectionInformationLength,
    _Out_opt_ PSIZE_T ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySecurityAttributesToken(
    _In_ HANDLE TokenHandle,
    _In_reads_opt_(NumberOfAttributes) PUNICODE_STRING Attributes,
    _In_ ULONG NumberOfAttributes,
    _Out_writes_bytes_(Length) PVOID Buffer, // PTOKEN_SECURITY_ATTRIBUTES_INFORMATION
    _In_ ULONG Length,
    _Out_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _Out_writes_bytes_opt_(Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Length,
    _Out_ PULONG LengthNeeded
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    _Out_writes_bytes_(SemaphoreInformationLength) PVOID SemaphoreInformation,
    _In_ ULONG SemaphoreInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySymbolicLinkObject(
    _In_ HANDLE LinkHandle,
    _Inout_ PUNICODE_STRING LinkTarget,
    _Out_opt_ PULONG ReturnedLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValue(
    _In_ PUNICODE_STRING VariableName,
    _Out_writes_bytes_(ValueLength) PWSTR VariableValue,
    _In_ USHORT ValueLength,
    _Out_opt_ PUSHORT ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValueEx(
    _In_ PUNICODE_STRING VariableName,
    _In_ PGUID VendorGuid,
    _Out_writes_bytes_opt_(*ValueLength) PVOID Value,
    _Inout_ PULONG ValueLength,
    _Out_opt_ PULONG Attributes // EFI_VARIABLE_*
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySystemInformationEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySystemTime(
    _Out_ PLARGE_INTEGER SystemTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryTimer(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_INFORMATION_CLASS TimerInformationClass,
    _Out_writes_bytes_(TimerInformationLength) PVOID TimerInformation,
    _In_ ULONG TimerInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryTimerResolution(
    _Out_ PULONG MaximumTime,
    _Out_ PULONG MinimumTime,
    _Out_ PULONG CurrentTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass,
    _Out_writes_bytes_(MemoryInformationLength) PVOID MemoryInformation,
    _In_ SIZE_T MemoryInformationLength,
    _Out_opt_ PSIZE_T ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryVolumeInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FsInformation,
    _In_ ULONG Length,
    _In_ FSINFOCLASS FsInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const VOID *ExplicitScope,
    _Out_ PWNF_CHANGE_STAMP ChangeStamp,
    _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer,
    _Inout_ PULONG BufferSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryWnfStateNameInformation(
    _In_ PCWNF_STATE_NAME StateName,
    _In_ WNF_STATE_NAME_INFORMATION NameInfoClass,
    _In_opt_ const VOID *ExplicitScope,
    _Out_writes_bytes_(InfoBufferSize) PVOID InfoBuffer,
    _In_ ULONG InfoBufferSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueueApcThread(
    _In_ HANDLE ThreadHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueueApcThreadEx(
    _In_ HANDLE ThreadHandle,
    _In_opt_ HANDLE ReserveHandle, // NtAllocateReserveObject
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueueApcThreadEx2(
    _In_ HANDLE ThreadHandle,
    _In_opt_ HANDLE ReserveHandle, // NtAllocateReserveObject
    _In_ ULONG ApcFlags, // QUEUE_USER_APC_FLAGS
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN FirstChance
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRaiseHardError(
    _In_ NTSTATUS ErrorStatus,
    _In_ ULONG NumberOfParameters,
    _In_ ULONG UnicodeStringParameterMask,
    _In_reads_(NumberOfParameters) PULONG_PTR Parameters,
    _In_ ULONG ValidResponseOptions,
    _Out_ PULONG Response
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReadFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReadFileScatter(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReadOnlyEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReadRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _Out_writes_bytes_to_(BufferSize, *NumberOfBytesRead) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReadVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _Out_writes_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRecoverEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PVOID EnlistmentKey
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRecoverResourceManager(
    _In_ HANDLE ResourceManagerHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRecoverTransactionManager(
    _In_ HANDLE TransactionManagerHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRegisterProtocolAddressInformation(
    _In_ HANDLE ResourceManager,
    _In_ PCRM_PROTOCOL_ID ProtocolId,
    _In_ ULONG ProtocolInformationSize,
    _In_ PVOID ProtocolInformation,
    _In_opt_ ULONG CreateOptions
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRegisterThreadTerminatePort(
    _In_ HANDLE PortHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReleaseCMFViewOwnership(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReleaseKeyedEvent(
    _In_ HANDLE KeyedEventHandle,
    _In_ PVOID KeyValue,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReleaseMutant(
    _In_ HANDLE MutantHandle,
    _Out_opt_ PLONG PreviousCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReleaseSemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ LONG ReleaseCount,
    _Out_opt_ PLONG PreviousCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReleaseWorkerFactoryWorker(
    _In_ HANDLE WorkerFactoryHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRemoveIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _Out_ PVOID *KeyContext,
    _Out_ PVOID *ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRemoveIoCompletionEx(
    _In_ HANDLE IoCompletionHandle,
    _Out_writes_to_(Count, *NumEntriesRemoved) PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation,
    _In_ ULONG Count,
    _Out_ PULONG NumEntriesRemoved,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_ BOOLEAN Alertable
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRemoveProcessDebug(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRenameKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING NewName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRenameTransactionManager(
    _In_ PUNICODE_STRING LogFileName,
    _In_ LPGUID ExistingTransactionManagerGuid
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReplaceKey(
    _In_ POBJECT_ATTRIBUTES NewFile,
    _In_ HANDLE TargetHandle,
    _In_ POBJECT_ATTRIBUTES OldFile
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReplacePartitionUnit(
    _In_ PUNICODE_STRING TargetInstancePath,
    _In_ PUNICODE_STRING SpareInstancePath,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReplyPort(
    _In_ HANDLE PortHandle,
    _In_reads_bytes_(ReplyMessage->u1.s1.TotalLength) PPORT_MESSAGE ReplyMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReplyWaitReceivePort(
    _In_ HANDLE PortHandle,
    _Out_opt_ PVOID *PortContext,
    _In_reads_bytes_opt_(ReplyMessage->u1.s1.TotalLength) PPORT_MESSAGE ReplyMessage,
    _Out_ PPORT_MESSAGE ReceiveMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReplyWaitReceivePortEx(
    _In_ HANDLE PortHandle,
    _Out_opt_ PVOID *PortContext,
    _In_reads_bytes_opt_(ReplyMessage->u1.s1.TotalLength) PPORT_MESSAGE ReplyMessage,
    _Out_ PPORT_MESSAGE ReceiveMessage,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReplyWaitReplyPort(
    _In_ HANDLE PortHandle,
    _Inout_ PPORT_MESSAGE ReplyMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRequestPort(
    _In_ HANDLE PortHandle,
    _In_reads_bytes_(RequestMessage->u1.s1.TotalLength) PPORT_MESSAGE RequestMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRequestWaitReplyPort(
    _In_ HANDLE PortHandle,
    _In_reads_bytes_(RequestMessage->u1.s1.TotalLength) PPORT_MESSAGE RequestMessage,
    _Out_ PPORT_MESSAGE ReplyMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRequestWakeupLatency(
    _In_ LATENCY_TIME latency
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwResetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwResetWriteWatch(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_ SIZE_T RegionSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRestoreKey(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwResumeProcess(
    _In_ HANDLE ProcessHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRevertContainerImpersonation(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollbackComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollbackEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollbackTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollforwardTransactionManager(
    _In_ HANDLE TransactionManagerHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSaveKey(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSaveKeyEx(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle,
    _In_ ULONG Format
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSaveMergedKeys(
    _In_ HANDLE HighPrecedenceKeyHandle,
    _In_ HANDLE LowPrecedenceKeyHandle,
    _In_ HANDLE FileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSecureConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _In_opt_ PSID RequiredServerSid,
    _Inout_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_updates_bytes_to_opt_(*ConnectionInformationLength, *ConnectionInformationLength) PVOID ConnectionInformation,
    _Inout_opt_ PULONG ConnectionInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSerializeBoot(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetBootEntryOrder(
    _In_reads_(Count) PULONG Ids,
    _In_ ULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetBootOptions(
    _In_ PBOOT_OPTIONS BootOptions,
    _In_ ULONG FieldsToChange
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetCachedSigningLevel(
    _In_ ULONG Flags,
    _In_ SE_SIGNING_LEVEL InputSigningLevel,
    _In_reads_(SourceFileCount) PHANDLE SourceFiles,
    _In_ ULONG SourceFileCount,
    _In_opt_ HANDLE TargetFile
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetContextThread(
    _In_ HANDLE ThreadHandle,
    _In_ PCONTEXT ThreadContext
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_ BOOLEAN State
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetDefaultHardErrorPort(
    _In_ HANDLE DefaultHardErrorPort
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetDefaultLocale(
    _In_ BOOLEAN UserProfile,
    _In_ LCID DefaultLocaleId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetDefaultUILanguage(
    _In_ LANGID DefaultUILanguageId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetDriverEntryOrder(
    _In_reads_(Count) PULONG Ids,
    _In_ ULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetEventBoostPriority(
    _In_ HANDLE EventHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetHighEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetHighWaitLowEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationDebugObject(
    _In_ HANDLE DebugObjectHandle,
    _In_ DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
    _In_ PVOID DebugInformation,
    _In_ ULONG DebugInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationEnlistment(
    _In_opt_ HANDLE EnlistmentHandle,
    _In_ ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
    _In_reads_bytes_(EnlistmentInformationLength) PVOID EnlistmentInformation,
    _In_ ULONG EnlistmentInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationJobObject(
    _In_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _In_reads_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    _In_reads_bytes_(KeySetInformationLength) PVOID KeySetInformation,
    _In_ ULONG KeySetInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationObject(
    _In_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _In_reads_bytes_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationResourceManager(
    _In_ HANDLE ResourceManagerHandle,
    _In_ RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
    _In_reads_bytes_(ResourceManagerInformationLength) PVOID ResourceManagerInformation,
    _In_ ULONG ResourceManagerInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationSymbolicLink(
    _In_ HANDLE LinkHandle,
    _In_ SYMBOLIC_LINK_INFO_CLASS SymbolicLinkInformationClass,
    _In_reads_bytes_(SymbolicLinkInformationLength) PVOID SymbolicLinkInformation,
    _In_ ULONG SymbolicLinkInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _In_reads_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    _In_reads_bytes_(TransactionInformationLength) PVOID TransactionInformation,
    _In_ ULONG TransactionInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationTransactionManager(
    _In_opt_ HANDLE TmHandle,
    _In_ TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
    _In_reads_bytes_(TransactionManagerInformationLength) PVOID TransactionManagerInformation,
    _In_ ULONG TransactionManagerInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_ VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass,
    _In_ ULONG_PTR NumberOfEntries,
    _In_reads_ (NumberOfEntries) PMEMORY_RANGE_ENTRY VirtualAddresses,
    _In_reads_bytes_ (VmInformationLength) PVOID VmInformation,
    _In_ ULONG VmInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
    _In_reads_bytes_(WorkerFactoryInformationLength) PVOID WorkerFactoryInformation,
    _In_ ULONG WorkerFactoryInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetIntervalProfile(
    _In_ ULONG Interval,
    _In_ KPROFILE_SOURCE Source
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetIoCompletionEx(
    _In_ HANDLE IoCompletionHandle,
    _In_ HANDLE IoCompletionPacketHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetIRTimer(
    _In_ HANDLE TimerHandle,
    _In_opt_ PLARGE_INTEGER DueTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetLdtEntries(
    _In_ ULONG Selector0,
    _In_ ULONG Entry0Low,
    _In_ ULONG Entry0Hi,
    _In_ ULONG Selector1,
    _In_ ULONG Entry1Low,
    _In_ ULONG Entry1Hi
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetLowEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetLowWaitHighEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemEnvironmentValue(
    _In_ PUNICODE_STRING VariableName,
    _In_ PUNICODE_STRING VariableValue
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemEnvironmentValueEx(
    _In_ PUNICODE_STRING VariableName,
    _In_ PGUID VendorGuid,
    _In_reads_bytes_opt_(ValueLength) PVOID Value,
    _In_ ULONG ValueLength, // 0 = delete variable
    _In_ ULONG Attributes // EFI_VARIABLE_*
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemPowerState(
    _In_ POWER_ACTION SystemAction,
    _In_ SYSTEM_POWER_STATE LightestSystemState,
    _In_ ULONG Flags // POWER_ACTION_* flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemTime(
    _In_opt_ PLARGE_INTEGER SystemTime,
    _Out_opt_ PLARGE_INTEGER PreviousTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetThreadExecutionState(
    _In_ EXECUTION_STATE NewFlags, // ES_* flags
    _Out_ EXECUTION_STATE *PreviousFlags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetTimer(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine,
    _In_opt_ PVOID TimerContext,
    _In_ BOOLEAN ResumeTimer,
    _In_opt_ LONG Period,
    _Out_opt_ PBOOLEAN PreviousState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetTimer2(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PLARGE_INTEGER Period,
    _In_ PT2_SET_PARAMETERS Parameters
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetTimerEx(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_SET_INFORMATION_CLASS TimerSetInformationClass,
    _Inout_updates_bytes_opt_(TimerSetInformationLength) PVOID TimerSetInformation,
    _In_ ULONG TimerSetInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetTimerResolution(
    _In_ ULONG DesiredTime,
    _In_ BOOLEAN SetResolution,
    _Out_ PULONG ActualTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetUuidSeed(
    _In_ PCHAR Seed
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_opt_ ULONG TitleIndex,
    _In_ ULONG Type,
    _In_reads_bytes_opt_(DataSize) PVOID Data,
    _In_ ULONG DataSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetVolumeInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID FsInformation,
    _In_ ULONG Length,
    _In_ FSINFOCLASS FsInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetWnfProcessNotificationEvent(
    _In_ HANDLE NotificationEvent
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwShutdownSystem(
    _In_ SHUTDOWN_ACTION Action
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwShutdownWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Inout_ volatile LONG *PendingWorkerCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSignalAndWaitForSingleObject(
    _In_ HANDLE SignalHandle,
    _In_ HANDLE WaitHandle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSinglePhaseReject(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwStartProfile(
    _In_ HANDLE ProfileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwStopProfile(
    _In_ HANDLE ProfileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSubscribeWnfStateChange(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ WNF_CHANGE_STAMP ChangeStamp,
    _In_ ULONG EventMask,
    _Out_opt_ PULONG64 SubscriptionId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSuspendProcess(
    _In_ HANDLE ProcessHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSuspendThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSystemDebugControl(
    _In_ SYSDBG_COMMAND Command,
    _Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTerminateEnclave(
    _In_ PVOID BaseAddress,
    _In_ BOOLEAN WaitForThread
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTerminateJobObject(
    _In_ HANDLE JobHandle,
    _In_ NTSTATUS ExitStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTerminateProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ NTSTATUS ExitStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTerminateThread(
    _In_opt_ HANDLE ThreadHandle,
    _In_ NTSTATUS ExitStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTestAlert(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwThawRegistry(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwThawTransactions(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTraceControl(
    _In_ TRACE_CONTROL_INFORMATION_CLASS TraceInformationClass,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(TraceInformationLength) PVOID TraceInformation,
    _In_ ULONG TraceInformationLength,
    _Out_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTraceEvent(
    _In_ HANDLE TraceHandle,
    _In_ ULONG Flags,
    _In_ ULONG FieldSize,
    _In_ PVOID Fields
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTranslateFilePath(
    _In_ PFILE_PATH InputFilePath,
    _In_ ULONG OutputType,
    _Out_writes_bytes_opt_(*OutputFilePathLength) PFILE_PATH OutputFilePath,
    _Inout_opt_ PULONG OutputFilePathLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUmsThreadYield(
    _In_ PVOID SchedulerParam
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnloadDriver(
    _In_ PUNICODE_STRING DriverServiceName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnloadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnloadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnloadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_opt_ HANDLE Event
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnlockFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnlockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSectionEx(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnsubscribeWnfStateChange(
    _In_ PCWNF_STATE_NAME StateName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUpdateWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_reads_bytes_opt_(Length) const VOID *Buffer,
    _In_opt_ ULONG Length,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const VOID *ExplicitScope,
    _In_ WNF_CHANGE_STAMP MatchingChangeStamp,
    _In_ LOGICAL CheckStamp
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwVdmControl(
    _In_ VDMSERVICECLASS Service,
    _Inout_ PVOID ServiceData
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForAlertByThreadId(
    _In_ PVOID Address,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForDebugEvent(
    _In_ HANDLE DebugObjectHandle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout,
    _Out_ PDBGUI_WAIT_STATE_CHANGE WaitStateChange
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForKeyedEvent(
    _In_ HANDLE KeyedEventHandle,
    _In_ PVOID KeyValue,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForMultipleObjects(
    _In_ ULONG Count,
    _In_reads_(Count) HANDLE Handles[],
    _In_ WAIT_TYPE WaitType,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForMultipleObjects32(
    _In_ ULONG Count,
    _In_reads_(Count) LONG Handles[],
    _In_ WAIT_TYPE WaitType,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForSingleObject(
    _In_ HANDLE Handle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForWorkViaWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Out_writes_to_(Count, *PacketsReturned) struct _FILE_IO_COMPLETION_INFORMATION *MiniPackets,
    _In_ ULONG Count,
    _Out_ PULONG PacketsReturned,
    _In_ struct _WORKER_FACTORY_DEFERRED_WORK* DeferredWork
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitHighEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitLowEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWorkerFactoryWorkerReady(
    _In_ HANDLE WorkerFactoryHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWriteFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWriteFileGather(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWriteRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesWritten
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWriteVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesWritten
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwYieldExecution(
    VOID
    );

#endif

#endif

#ifdef __cplusplus
}
#endif

#endif

```

`tests/StringEncryptionFun/StringEncryptionFun.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31911.196
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "StringEncryptionFun", "StringEncryptionFun\StringEncryptionFun.vcxproj", "{4DF88650-7AF7-450C-B867-534D2A5304E1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Debug|x64.ActiveCfg = Debug|x64
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Debug|x64.Build.0 = Debug|x64
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Debug|x86.ActiveCfg = Debug|Win32
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Debug|x86.Build.0 = Debug|Win32
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Release|x64.ActiveCfg = Release|x64
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Release|x64.Build.0 = Release|x64
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Release|x86.ActiveCfg = Release|Win32
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C233290A-8A7F-4F3C-879D-90EB09B42BEC}
	EndGlobalSection
EndGlobal

```

`tests/StringEncryptionFun/StringEncryptionFun/StringEncryptionFun.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4df88650-7af7-450c-b867-534d2a5304e1}</ProjectGuid>
    <RootNamespace>StringEncryptionFun</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="xorstr.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="decryption.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`tests/StringEncryptionFun/StringEncryptionFun/StringEncryptionFun.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="xorstr.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="decryption.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`tests/StringEncryptionFun/StringEncryptionFun/decryption.cpp`:

```cpp
__declspec(noinline) void decrypt(char* decrypted, const char* encrypted)
{
	auto size = *(unsigned short*)encrypted;
	encrypted += 2;
	for (unsigned short i = 0; i < size; i++)
		*decrypted++ = *encrypted++ ^ 0x66;
}
```

`tests/StringEncryptionFun/StringEncryptionFun/main.cpp`:

```cpp
#include <cstdio>

static char g_encrypted[256] = "\x1C\x00\x12\x0e\x0f\x15\x46\x0f\x15\x46\x07\x08\x46\x03\x08\x05\x14\x1f\x16\x12\x03\x02\x46\x15\x12\x14\x0f\x08\x01\x66";

void decrypt(char* decrypted, const char* encrypted);

int main()
{
	char decrypted[256];
	decrypt(decrypted, g_encrypted);
	puts(decrypted);
}
```

`tests/download_artifacts.py`:

```py
import os
import pathlib
import sys
import shutil
import argparse
import json
import urllib.request
from urllib.error import URLError

from typing import Dict

def download_file(url: str, file: str):
    with urllib.request.urlopen(url) as response:
        with open(file, "wb") as f:
            shutil.copyfileobj(response, f)

def main(*argv):
    # Defaults
    default_url = "https://api.github.com/repos/mrexodia/dumpulator/releases/tags/artifacts"
    default_dir = str(pathlib.Path(__file__).parent)

    # Parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("artifacts", nargs="*", help="Names of the release artifacts to download")
    parser.add_argument("--url", default=default_url)
    parser.add_argument("--dir", default=default_dir, help="Download destination directory")
    args = parser.parse_args(argv)

    # Create destination directory
    os.makedirs(args.dir, exist_ok=True)

    print(f"Fetching release JSON: {args.url}")
    assets: Dict[str, str] = {}
    try:
        with urllib.request.urlopen(args.url) as response:
            release = json.load(response)
            for asset in release["assets"]:
                assets[asset["name"]] = asset["browser_download_url"]
    except URLError as error:
        print(error)
        return False

    if not args.artifacts:
        args.artifacts = list(assets.keys())

    destination_dir = pathlib.Path(args.dir)
    print(f"Destination: {destination_dir}")
    for artifact in args.artifacts:
        if artifact not in assets:
            print(f"Could not find artifact '{artifact}' in release")
            return False
        try:
            url = assets[artifact]
            print(f"Downloading: {url}")
            download_file(url, str(destination_dir.joinpath(artifact)))
        except URLError as error:
            print(error)
            return False

    return True

if __name__ == "__main__":
    sys.exit(1 if main(*sys.argv[1:]) is False else 0)

```

`tests/emulate-process.py`:

```py
from dumpulator import Dumpulator, syscall
from dumpulator.native import *

# Dummy syscall implementations

@syscall
def ZwOpenKey(dp: Dumpulator,
              KeyHandle: P[HANDLE],
              DesiredAccess: ACCESS_MASK,
              ObjectAttributes: P[OBJECT_ATTRIBUTES]
              ):
    return STATUS_NOT_IMPLEMENTED

@syscall
def ZwQueryVirtualMemory(dp: Dumpulator,
                         ProcessHandle: HANDLE,
                         BaseAddress: PVOID,
                         MemoryInformationClass: MEMORY_INFORMATION_CLASS,
                         MemoryInformation: PVOID,
                         MemoryInformationLength: SIZE_T,
                         ReturnLength: P[SIZE_T]
                         ):
    return STATUS_SUCCESS

@syscall
def ZwOpenSection(dp: Dumpulator,
                  SectionHandle: P[HANDLE],
                  DesiredAccess: ACCESS_MASK,
                  ObjectAttributes: P[OBJECT_ATTRIBUTES]
                  ):
    return STATUS_NOT_IMPLEMENTED

@syscall
def ZwSetEvent(dp: Dumpulator,
               EventHandle: HANDLE,
               PreviousState: P[LONG]
               ):
    return STATUS_NOT_IMPLEMENTED

def main():
    dp = Dumpulator("StringEncryptionFun_x64.dmp")
    dp.start(dp.regs.rip)

if __name__ == '__main__':
    main()

```

`tests/exception-test32.py`:

```py
from dumpulator import Dumpulator, syscall
from dumpulator.native import *

# Dummy syscall implementations

@syscall
def ZwOpenKey(dp: Dumpulator,
              KeyHandle: P[HANDLE],
              DesiredAccess: ACCESS_MASK,
              ObjectAttributes: P[OBJECT_ATTRIBUTES]
              ):
    return STATUS_NOT_IMPLEMENTED

def main():
    dp = Dumpulator("ExceptionTest32_main.dmp", trace=True)
    dp.start(dp.regs.cip, end=0x00401462)

if __name__ == '__main__':
    main()

```

`tests/exception-test64.py`:

```py
from dumpulator import Dumpulator, syscall
from dumpulator.native import *

# Dummy syscall implementations

@syscall
def ZwOpenKey(dp: Dumpulator,
              KeyHandle: P[HANDLE],
              DesiredAccess: ACCESS_MASK,
              ObjectAttributes: P[OBJECT_ATTRIBUTES]
              ):
    return STATUS_NOT_IMPLEMENTED

def main():
    dp = Dumpulator("ExceptionTest64-full.dmp", trace=True)
    dp.start(dp.regs.rip, end=0x1400015B0)

if __name__ == '__main__':
    main()

```

`tests/execute-dump.py`:

```py
import sys

from dumpulator import Dumpulator

def main():
    if len(sys.argv) < 2:
        print("Usage: execute-dump.py my.dmp")
        sys.exit(1)

    dp = Dumpulator(sys.argv[1], trace=len(sys.argv) > 2)
    dp.start(dp.regs.cip)
    exit_code = dp.exit_code if dp.exit_code is not None else 1
    sys.exit(exit_code)

if __name__ == '__main__':
    main()

```

`tests/getting-started.py`:

```py
from dumpulator import Dumpulator

dp = Dumpulator("StringEncryptionFun_x64.dmp")
temp_addr = dp.allocate(256)
dp.call(0x140001000, [temp_addr, 0x140017000])
decrypted = dp.read_str(temp_addr)
print(f"decrypted: '{decrypted}'")

```

`tests/getting-started32.py`:

```py
from dumpulator import Dumpulator

dp = Dumpulator("StringEncryptionFun_x86.dmp")
temp_addr = dp.allocate(256)
dp.call(0x401000, [temp_addr, 0x413000])
decrypted = dp.read_str(temp_addr)
print(f"decrypted: '{decrypted}'")

```

`tests/handletest.py`:

```py
import unittest
from dumpulator.handles import *


class TestHandleManager(unittest.TestCase):
    @classmethod
    def setUp(cls):
        cls.handles = HandleManager()
        cls.file_handle = FileObject("test.txt")

    def test_single_handle(self):
        handle = self.handles.new(self.file_handle)
        self.assertEqual(handle, 0x100)
        self.handles.close(handle)

    def test_multiple_handles(self):
        handle_1 = self.handles.new(self.file_handle)
        handle_2 = self.handles.new(self.file_handle)
        handle_3 = self.handles.new(self.file_handle)
        handle_4 = self.handles.new(self.file_handle)
        self.assertEqual(handle_1, 0x100)
        self.assertEqual(handle_2, 0x104)
        self.assertEqual(handle_3, 0x108)
        self.assertEqual(handle_4, 0x10C)
        self.handles.close(handle_1)
        self.handles.close(handle_2)
        self.handles.close(handle_3)
        self.handles.close(handle_4)

    def test_get_handle(self):
        handle = self.handles.new(self.file_handle)
        data = self.handles.get(handle, FileObject)
        self.assertEqual(data, self.file_handle)
        self.handles.close(handle)

    def test_duplicate_handle(self):
        handle_data = FileObject("dupe.txt")
        handle = self.handles.new(handle_data)
        dup_handle = self.handles.duplicate(handle)
        self.assertEqual(self.handles.close(handle), True)
        data = self.handles.get(dup_handle, FileObject)
        self.assertEqual(data, handle_data)
        self.assertEqual(self.handles.close(dup_handle), True)

    def test_add_handle(self):
        handle = 0x10
        self.handles.add(handle, self.file_handle)
        data = self.handles.get(handle, FileObject)
        self.assertEqual(data, self.file_handle)
        self.handles.close(handle)
        with self.assertRaises(AssertionError):
            self.handles.get(handle, FileObject)

    def test_add_handle_assert(self):
        handle = 0x10
        self.handles.add(handle, FileObject(""))
        with self.assertRaises(AssertionError):
            self.handles.add(handle, FileObject(""))
        self.handles.close(handle)

    def test_get_handle_assert(self):
        with self.assertRaises(AssertionError):
            self.handles.get(1, None)

    def test_close_handle_assert(self):
        self.assertEqual(self.handles.close(1), False)

    def test_duplicate_handle_assert(self):
        with self.assertRaises(AssertionError):
            self.handles.duplicate(1)

    def test_file_object_read(self):
        file_data = b"file_data"
        file = FileObject("file_path", file_data)

        # test read no given size
        self.assertEqual(file_data, file.read())
        self.assertEqual(file.file_offset, len(file_data))
        file.file_offset = 0

        # test read with given size
        self.assertEqual(b"file", file.read(4))
        self.assertEqual(4, file.file_offset)
        file.file_offset = 0

        # test read with file offset not 0
        file.file_offset = 5
        self.assertEqual(b"data", file.read())
        self.assertEqual(9, file.file_offset)

        # test read with file offset not 0 and with given size
        file.file_offset = 5
        self.assertEqual(b"data", file.read(4))
        self.assertEqual(9, file.file_offset)

        empty_file = FileObject("empty_file")
        self.assertEqual(b"", empty_file.read())

    def test_file_object_write(self):
        file_data = b"file_data"
        new_buffer = b"test_buffer"
        file = FileObject("file_path", file_data)

        # test write no given size
        file.write(new_buffer)
        self.assertEqual(new_buffer, file.data)
        self.assertEqual(len(new_buffer), file.file_offset)
        file.data = file_data
        file.file_offset = 0

        # test write given size
        file.write(new_buffer, 4)
        self.assertEqual(b"test_data", file.data)
        self.assertEqual(4, file.file_offset)
        file.data = file_data
        file.file_offset = 0

        # test write no given size with file offset
        file.file_offset = 5
        file.write(new_buffer)
        self.assertEqual(b"file_test_buffer", file.data)
        self.assertEqual(5 + len(new_buffer), file.file_offset)
        file.data = file_data
        file.file_offset = 0

        # test write given size with file offset
        file.file_offset = 5
        file.write(new_buffer, 4)
        self.assertEqual(b"file_test", file.data)
        self.assertEqual(9, file.file_offset)
        file.data = file_data
        file.file_offset = 0

if __name__ == '__main__':
    unittest.main()

```

`tests/memory_test.py`:

```py
import unittest
from typing import Dict

from dumpulator.memory import *

class MockPageManager(PageManager):
    def __init__(self):
        self.pages: Dict[int, MemoryProtect] = {}

    def commit(self, addr: int, size: int, protect: MemoryProtect) -> None:
        print(f"commit({hex(addr)}, {hex(size)}, {protect})")
        for page in range(addr, addr + size, PAGE_SIZE):
            self.pages[page] = protect

    def decommit(self, addr: int, size: int) -> None:
        print(f"decommit({hex(addr)}, {hex(size)})")
        for page in range(addr, addr + size, PAGE_SIZE):
            del self.pages[page]

    def protect(self, addr: int, size: int, protect: MemoryProtect) -> None:
        print(f"protect({hex(addr)}, {hex(size)}, {protect})")
        for page in range(addr, addr + size, PAGE_SIZE):
            assert page in self.pages
            self.pages[page] = protect

class TestMemoryManager(unittest.TestCase):
    def setUp(self) -> None:
        self.pm = MockPageManager()
        self.mm = MemoryManager(self.pm)

    def test_reserve(self):
        self.mm.reserve(0x20000, 0x10000, MemoryProtect.PAGE_READWRITE)
        assert self.pm.pages == {}
        assert self.mm.query(0x20000).region_size == 0x10000
        assert self.mm.query(0x22000).region_size == 0x10000 - 0x2000
        self.assertRaises(KeyError, lambda: self.mm.reserve(0x10000, 0x100000, MemoryProtect.PAGE_READWRITE))
        self.assertRaises(KeyError, lambda: self.mm.reserve(0x0, 0x2000, MemoryProtect.PAGE_NOACCESS))
        self.assertRaises(KeyError, lambda: self.mm.reserve(self.mm._maximum, 0x1000, MemoryProtect.PAGE_READWRITE))
        self.mm.reserve(0x30000, 0x2000, MemoryProtect.PAGE_READONLY)
        assert self.pm.pages == {}
        assert self.mm.query(0x30000).region_size == 0x2000

    def test_commit(self):
        self.mm.reserve(0x20000, 0x30000, MemoryProtect.PAGE_NOACCESS)
        self.mm.commit(0x20000, 0x2000, MemoryProtect.PAGE_READWRITE)
        assert self.pm.pages == {
            0x20000: MemoryProtect.PAGE_READWRITE,
            0x21000: MemoryProtect.PAGE_READWRITE,
        }
        info = self.mm.query(0x20000)
        assert info.base == 0x20000
        assert info.allocation_base == 0x20000
        assert info.allocation_protect == MemoryProtect.PAGE_NOACCESS
        assert info.region_size == 0x2000
        assert info.state == MemoryState.MEM_COMMIT
        assert info.protect == MemoryProtect.PAGE_READWRITE
        assert info.type == MemoryType.MEM_PRIVATE
        info = self.mm.query(0x23000)
        assert info.base == 0x23000
        assert info.allocation_base == 0x20000
        assert info.allocation_protect == MemoryProtect.PAGE_NOACCESS
        assert info.region_size == 0x30000 - 0x3000
        assert info.state == MemoryState.MEM_RESERVE
        assert info.protect == MemoryProtect.UNDEFINED
        assert info.type == MemoryType.MEM_PRIVATE

    def test_protect(self):
        # Protect parent region that doesn't exist
        self.assertRaises(KeyError, lambda: self.mm.protect(0x20000, 0x5000, MemoryProtect.PAGE_NOACCESS))
        # Reserve the region
        self.mm.reserve(0x20000, 0x5000, MemoryProtect.PAGE_READWRITE)
        # Protect uncommited pages
        self.assertRaises(KeyError, lambda: self.mm.protect(0x20000, 0x2000, MemoryProtect.PAGE_EXECUTE_READ))
        # Commit part of the region (use parent protection)
        self.mm.commit(0x20000, 0x2000, MemoryProtect.UNDEFINED)
        assert self.pm.pages == {
            0x20000: MemoryProtect.PAGE_READWRITE,
            0x21000: MemoryProtect.PAGE_READWRITE,
        }
        info = self.mm.query(0x20000)
        assert info.protect == MemoryProtect.PAGE_READWRITE
        assert info.region_size == 0x2000
        # Change the protection
        old_protect = self.mm.protect(0x20000, 0x2000, MemoryProtect.PAGE_EXECUTE_READ)
        assert old_protect == info.protect
        assert self.pm.pages == {
            0x20000: MemoryProtect.PAGE_EXECUTE_READ,
            0x21000: MemoryProtect.PAGE_EXECUTE_READ,
        }
        info = self.mm.query(0x20000)
        assert info.protect == MemoryProtect.PAGE_EXECUTE_READ
        # Commit the whole region (overrides the protection)
        self.mm.commit(0x20000, 0x5000, MemoryProtect.PAGE_EXECUTE_READWRITE)
        assert self.pm.pages == {
            0x20000: MemoryProtect.PAGE_EXECUTE_READWRITE,
            0x21000: MemoryProtect.PAGE_EXECUTE_READWRITE,
            0x22000: MemoryProtect.PAGE_EXECUTE_READWRITE,
            0x23000: MemoryProtect.PAGE_EXECUTE_READWRITE,
            0x24000: MemoryProtect.PAGE_EXECUTE_READWRITE,
        }
        info = self.mm.query(0x20000)
        assert info.region_size == 0x5000
        assert info.protect == MemoryProtect.PAGE_EXECUTE_READWRITE

if __name__ == "__main__":
    unittest.main()

```

`tests/run-tests.py`:

```py
import os.path
import re
import subprocess
import sys
import inspect
import argparse
from typing import Dict, List, Type, Tuple, Callable
from pathlib import Path

from dumpulator import Dumpulator
from dumpulator.native import *
from dumpulator.modules import Module
import pefile

class TestEnvironment:
    def setup(self, dp: Dumpulator):
        pass

class HandleEnvironment(TestEnvironment):
    def setup(self, dp: Dumpulator):
        dp.handles.create_file("test_file.txt", FILE_OPEN)
        dp.handles.create_file("nonexistent_file.txt", FILE_CREATE)

def collect_environments():
    environments: Dict[str, Type[TestEnvironment]] = {}
    for name, obj in inspect.getmembers(sys.modules[__name__], inspect.isclass):
        if issubclass(obj, TestEnvironment) and obj is not TestEnvironment:
            # Extract the first capital word from the class name
            match = re.match(r"^([A-Z][a-z]+)", name)
            assert match is not None
            prefix = match.group(1)
            environments[prefix] = obj
    return environments

def collect_tests(dll_data) -> Tuple[Dict[str, List[str]], int]:
    pe = pefile.PE(data=dll_data, fast_load=True)
    module = Module(pe, "tests.dll")
    tests: Dict[str, List[str]] = {}
    for export in module.exports:
        if "_" not in export.name:
            continue
        prefix = export.name.split("_")[0]
        if prefix not in tests:
            tests[prefix] = []
        tests[prefix].append(export.name)
    return tests, module.base

def run_tests(dll_path: str, harness_dump: str, filter: Callable[[str, str], bool]) -> Dict[str, bool]:
    print(f"--- {dll_path} ---")
    with open(dll_path, "rb") as dll:
        dll_data = dll.read()
    environments = collect_environments()
    tests, base = collect_tests(dll_data)
    results: Dict[str, bool] = {}
    for prefix, exports in tests.items():
        printed_prefix = False
        environment = environments.get(prefix, TestEnvironment)
        for export in exports:
            if not filter(prefix, export):
                continue
            if not printed_prefix:
                print(f"\nRunning {prefix.lower()} tests:")
                printed_prefix = True
            dp = Dumpulator(harness_dump, trace=True)
            module = dp.map_module(dll_data, dll_path, base)
            environment().setup(dp)
            test = module.find_export(export)
            assert test is not None
            print(f"--- Executing {test.name} at {hex(test.address)} ---")
            success = dp.call(test.address) & 0xFF
            results[export] = success != 0
            print(f"{export} -> {success}")
    return results

def print_results(result_name, results):
    max_len = len(result_name)
    for name in results:
        max_len = max(max_len, len(name))
    def format_value(value):
        return f"{value}{' ' * (max_len - len(value))} |"
    print(f"+---------+-{'-' * max_len}-+")
    print(f"| Status  | {format_value(f'Test ({result_name})')}")
    print(f"|---------|-{'-' * max_len}-+")
    all_success = True
    for name, success in results.items():
        print(f"| {'SUCCESS' if success else 'FAILURE'} | {format_value(name)}")
        if not success:
            all_success = False
    print(f"+---------+-{'-' * max_len}-+")
    return all_success

def vswhere(args):
    vswhere_path = os.path.expandvars(R"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe")
    if not os.path.exists(vswhere_path):
        return False
    command = f"\"{vswhere_path}\" -nologo -nocolor {args}"
    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()
    result = stdout.decode("utf-8").strip().replace("\r", "")
    if process.returncode != 0:
        raise Exception(f"Command failed: {command}\n{result}")
    return stdout.decode("utf-8").strip()

def build_tests():
    if os.name != "nt":
        raise NotImplementedError(f"Unsupported OS: {os.name}")
    # Reference: https://stackoverflow.com/a/53319707/1806760
    msbuild_path = Path(vswhere(R"-latest -products * -requires Microsoft.Component.MSBuild -find MSBuild\**\Bin\MSBuild.exe"))
    if not msbuild_path.exists():
        raise FileNotFoundError(f"Not found: {msbuild_path}")
    # Reference: https://github.com/microsoft/vswhere/wiki/Find-VC#batch
    vc_install_path = Path(vswhere(R"-latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath"))
    aux_path = vc_install_path.joinpath(R"VC\Auxiliary\Build")
    if not aux_path.exists():
        raise FileNotFoundError(f"Not found: {aux_path}")
    props = list(aux_path.glob("Microsoft.VCToolsVersion.v*.default.props"))
    latest_toolset = 0
    for prop in props:
        s = str(prop)
        # Extract the first capital word from the class name
        match = re.match(r"Microsoft\.VCToolsVersion\.v(\d+)\.default\.props", str(prop.name))
        assert match is not None, "No match found"
        latest_toolset = max(latest_toolset, int(match.group(1)))
    print(f"Latest platform toolset: v{latest_toolset}")

    def build(platform):
        command = f"\"{msbuild_path}\" /p:Platform={platform} /p:Configuration=Release /t:Rebuild /p:PlatformToolset=v{latest_toolset} DumpulatorTests\\DumpulatorTests.sln"
        print(f"Executing: {command}")
        process = subprocess.Popen(command)
        process.communicate()
        if process.returncode != 0:
            raise Exception(f"MSBuild failed (platform: {platform})")

    build("Win32")
    build("x64")

def main():
    # Make sure all the required artifacts are there
    dll_x64 = "DumpulatorTests/bin/Tests_x64.dll"
    dll_x86 = "DumpulatorTests/bin/Tests_x86.dll"
    if not os.path.exists(dll_x64) or not os.path.exists(dll_x86):
        print(f"Missing required files: {', '.join([dll_x64, dll_x86])}")
        try:
            build_tests()
            assert os.path.exists(dll_x64), f"Not found: {dll_x64}"
            assert os.path.exists(dll_x86), f"Not found: {dll_x86}"
        except Exception as x:
            print(x)
            print()
            print(f"You need to compile DumpulatorTests\\DumpulatorTests.sln using Visual Studio yourself")
            sys.exit(1)

    dmp_x64 = "HarnessMinimal_x64.dmp"
    dmp_x86 = "HarnessMinimal_x86.dmp"
    if not os.path.exists(dmp_x64) or not os.path.exists(dmp_x86):
        from download_artifacts import main as download_main
        if not download_main(dmp_x64, dmp_x86):
            sys.exit(1)

    archs = {
        "x64": (dll_x64, dmp_x64),
        "x86": (dll_x86, dmp_x86),
    }

    # Parse arguments
    parser = argparse.ArgumentParser(description="Dumpulator test harness")
    parser.add_argument("--arch", choices=["x86", "x64"], help="Architecture to use (omit for both)", required=False)
    parser.add_argument("--tests", nargs="+", help="List of specific tests to run", required=False)
    parser.add_argument("--list", action="store_true", help="List all tests")
    parser.add_argument("--prefix", help="Only run tests from this prefix", required=False)
    args = parser.parse_args()
    #if isinstance(args.tests, str):
    #    args.tests = [args.tests]

    # List all tests
    if args.list:
        for arch, (dll, _) in archs.items():
            with open(dll, "rb") as f:
                dll_data = f.read()
            print(f"--- {dll} ---")
            tests, _ = collect_tests(dll_data)
            for prefix, exports in tests.items():
                for export in exports:
                    print(f"python run-tests.py --arch {arch} --prefix {prefix.lower()} --tests {export}")
        return

    if args.arch:
        archs = { args.arch: archs[args.arch] }

    def filter(prefix, export) -> bool:
        prefix_ok = not args.prefix or args.prefix.lower() == prefix.lower()
        export_ok = not args.tests or export in args.tests
        return prefix_ok and export_ok

    # Run the tests
    results = {}
    for arch, (dll, dmp) in archs.items():
        results[arch] = run_tests(dll, dmp, filter)
        print("")

    # Print the results
    success = True
    for arch, result in results.items():
        if not print_results(arch, result):
            success = False

    if not success:
        sys.exit(1)

if __name__ == "__main__":
    main()

```

`tests/x64dbg-tracedump.py`:

```py
# Based on: https://github.com/teemu-l/execution-trace-viewer (MIT)
# Licensed under MIT (not BSL)

import sys
import json
from capstone import *
from capstone.x86_const import *
from operator import attrgetter
from collections import OrderedDict

class TraceData:
    """TraceData class.

    Class for storing execution trace and bookmarks.

    Attributes:
        filename (str): A trace file name.
        arch (str): CPU architecture.
        ip_reg (str): Name of instruction pointer register
        pointer_size (int): Pointer size (4 in x86, 8 in x64)
        regs (dict): Register names and indexes
        trace (list): A list of traced instructions, registers and memory accesses.
        bookmarks (list): A list of bookmarks.
    """

    def __init__(self):
        """Inits TraceData."""
        self.filename = ""
        self.arch = ""
        self.ip_reg = ""
        self.pointer_size = 0
        self.regs = {}
        self.trace = []
        self.bookmarks = []

    def clear(self):
        """Clears trace and all data"""
        self.trace = []
        self.bookmarks = []

    def get_trace(self):
        """Returns a full trace

        Returns:
            list: Trace
        """
        return self.trace

    def get_regs(self):
        """Returns dict of registers and their indexes

        Returns:
            dict: Regs
        """
        return self.regs

    def get_regs_and_values(self, row):
        """Returns dict of registers and their values

        Returns:
            dict: Register names and values
        """
        registers = {}
        try:
            reg_values = self.trace[row]["regs"]
            for reg_name, reg_index in self.regs.items():
                reg_value = reg_values[reg_index]
                registers[reg_name] = reg_value
        except IndexError:
            print(f"Error. Could not get regs from row {row}.")
            return {}
        return registers

    def get_reg_index(self, reg_name):
        """Returns a register index

        Args:
            reg_name (str): Register name
        Returns:
            int: Register index
        """
        try:
            index = self.regs[reg_name]
        except KeyError:
            print("Unknown register")
        return index

    def get_modified_regs(self, row):
        """Returns modfied regs

        Args:
            row (int): Trace row index
        Returns:
            list: List of register names
        """
        modified_regs = []
        reg_values = self.trace[row]["regs"]
        next_row = row + 1
        if next_row < len(self.trace):
            next_row_data = self.trace[next_row]
            for reg_name, reg_index in self.regs.items():
                reg_value = reg_values[reg_index]
                next_reg_value = next_row_data["regs"][reg_index]
                if next_reg_value != reg_value:
                    modified_regs.append(reg_name)
        return modified_regs

    def get_trace_rows(self, rows):
        """Returns a trace of given rows

        Args:
            rows (list): List of trace indexes
        Returns:
            list: Trace
        """
        trace = []
        try:
            trace = [self.trace[int(i)] for i in rows]
        except IndexError:
            print("Error. Could not get trace rows.")
        return trace

    def get_instruction_pointer_name(self):
        """Returns an instruction pointer name

        Returns:
            str: Instruction pointer name
        """
        if self.ip_reg:
            return self.ip_reg
        elif "eip" in self.regs:
            return "eip"
        elif "rip" in self.regs:
            return "rip"
        elif "ip" in self.regs:
            return "ip"
        elif "pc" in self.regs:
            return "pc"
        return ""

    def get_instruction_pointer(self, row):
        """Returns a value of instruction pointer of given row

        Args:
            row: A row index in trace
        Returns:
            int: Address of instruction
        """
        ip = 0
        ip_reg = self.get_instruction_pointer_name()
        try:
            reg_index = self.regs[ip_reg]
            ip = self.trace[row]["regs"][reg_index]
        except IndexError:
            print(f"Error. Could not get IP from row {row}")
        return ip

    def set_comment(self, row, comment):
        """Adds a comment to trace

        Args:
            row (int): Row index in trace
            comment (str): Comment text
        """
        try:
            self.trace[row]["comment"] = str(comment)
        except IndexError:
            print(f"Error. Could not set comment to row {row}")

    def add_bookmark(self, new_bookmark, replace=False):
        """Adds a new bookmark

        Args:
            new_bookmark (Bookmark): A new bookmark
            replace (bool): Replace an existing bookmark if found on same row?
                Defaults to False.
        """
        for i, bookmark in enumerate(self.bookmarks):
            if bookmark.startrow == new_bookmark.startrow:
                if replace:
                    self.bookmarks[i] = new_bookmark
                    print(f"Bookmark at {bookmark.startrow} replaced.")
                else:
                    print(f"Error: bookmark at {bookmark.startrow} already exists.")
                return
        self.bookmarks.append(new_bookmark)
        self.sort_bookmarks()

    def delete_bookmark(self, index):
        """Deletes a bookmark

        Args:
            index (int): Index on bookmark list
        Returns:
            bool: True if bookmark deleted, False otherwise
        """
        try:
            del self.bookmarks[index]
        except IndexError:
            print(f"Error. Could not delete a bookmark {index}")
            return False
        return True

    def sort_bookmarks(self):
        """Sorts bookmarks by startrow"""
        self.bookmarks.sort(key=attrgetter("startrow"))

    def get_bookmark_from_row(self, row):
        """Returns a bookmark for a given trace row.

        Args:
            row (int): Trace row index
        Returns:
            Bookmark: Returns A Bookmark if found, None otherwise.
        """
        for bookmark in self.bookmarks:
            if bookmark.startrow <= row <= bookmark.endrow:
                return bookmark
        return None

    def get_bookmarks(self):
        """Returns all bookmarks

        Returns:
            list: List of bookmarks
        """
        return self.bookmarks

    def set_bookmarks(self, bookmarks):
        """Sets bookmarks

        Args:
            bookmarks (list): Bookmarks
        """
        self.bookmarks = bookmarks

    def clear_bookmarks(self):
        """Clears bookmarks"""
        self.bookmarks = []

# registers for x64dbg traces
# if you want to see more regs, add them here (in correct order)
# check the order of regs from REGISTERCONTEXT:
# https://github.com/x64dbg/x64dbg/blob/development/src/bridge/bridgemain.h#L723
X32_REGS = [
    "eax",
    "ecx",
    "edx",
    "ebx",
    "esp",
    "ebp",
    "esi",
    "edi",
    "eip",
    "eflags",
    "seg:gs,fs",
    "seg:es,ds",
    "seg:cs,ss",
    "dr0",
    "dr1",
    "dr2",
    "dr3",
    "dr6",
    "dr7",
]
X64_REGS = [
    "rax",
    "rcx",
    "rdx",
    "rbx",
    "rsp",
    "rbp",
    "rsi",
    "rdi",
    "r8",
    "r9",
    "r10",
    "r11",
    "r12",
    "r13",
    "r14",
    "r15",
    "rip",
    "eflags",
    "seg:gs,fs,es,ds",
    "seg:cs,ss",
    "dr0",
    "dr1",
    "dr2",
    "dr3",
    "dr6",
    "dr7",
]

def _get_regs(instr, include_write=False):
    regs = OrderedDict()
    operands = instr.operands
    if instr.id != X86_INS_NOP:
        for i in range(0, len(operands)):
            op = operands[i]
            if op.type == CS_OP_REG:
                is_write_op = (i == 0 and instr.id in [X86_INS_MOV, X86_INS_MOVZX, X86_INS_LEA])
                if not is_write_op and not include_write:
                    regs[instr.reg_name(op.value.reg)] = None
            elif op.type == CS_OP_MEM:
                if op.value.mem.base not in [0, X86_REG_RIP]:
                    regs[instr.reg_name(op.value.mem.base)] = None
                if op.value.mem.index not in [0, X86_REG_RIP]:
                    regs[instr.reg_name(op.value.mem.index)] = None
        for reg in instr.regs_read:
            regs[instr.reg_name(reg)] = None
        if include_write:
            for reg in instr.regs_write:
                regs[instr.reg_name(reg)] = None
    return regs

# TODO: this function uses a lot of ram, modify it do allow accessing the trace as a stream
def open_x64dbg_trace(filename, tracef):
    """Opens x64dbg trace file

    Args:
        filename: name of trace file
        tracef: file handle of txt trace
    Returns:
        TraceData object
    """
    with open(filename, "rb") as f:
        trace_data = TraceData()
        trace_data.filename = filename

        # check first 4 bytes
        magic = f.read(4)
        if magic != b"TRAC":
            raise ValueError("Error, wrong file format.")

        json_length_bytes = f.read(4)
        json_length = int.from_bytes(json_length_bytes, "little")

        # read JSON blob
        json_blob = f.read(json_length)
        json_str = str(json_blob, "utf-8")
        arch = json.loads(json_str)["arch"]

        reg_masks = {}
        reg_indexes = {}
        if arch == "x64":
            regs = X64_REGS
            ip_reg = "rip"
            capstone_mode = CS_MODE_64
            pointer_size = 8  # qword
        else:
            regs = X32_REGS
            ip_reg = "eip"
            capstone_mode = CS_MODE_32
            pointer_size = 4  # dword

        for i, reg in enumerate(regs):
            if reg.startswith("seg:"):
                for j, seg in enumerate(reg[4:].split(',')):
                    reg_indexes[seg] = i
                    reg_masks[seg] = 0xFFFF << (16 * j)
            else:
                reg_indexes[reg] = i
                reg_masks[reg] = 0xFFFFFFFFFFFFFFFF >> (64 - pointer_size * 8)
        reg_indexes["rflags"] = reg_indexes["eflags"]
        reg_masks["rflags"] = reg_masks["eflags"]

        def add_reg(parent, child, mask):
            reg_indexes[child] = reg_indexes[parent]
            reg_masks[child] = mask

        if pointer_size == 8:
            for reg in X32_REGS[:9]:
                add_reg("r" + reg[1:], reg, 0xFFFFFFFF)

            add_reg("r8", "r8d", 0xFFFFFFFF)
            add_reg("r9", "r9d", 0xFFFFFFFF)
            add_reg("r10", "r10d", 0xFFFFFFFF)
            add_reg("r11", "r11d", 0xFFFFFFFF)
            add_reg("r12", "r12d", 0xFFFFFFFF)
            add_reg("r13", "r13d", 0xFFFFFFFF)
            add_reg("r14", "r14d", 0xFFFFFFFF)
            add_reg("r15", "r15d", 0xFFFFFFFF)

            add_reg("r8", "r8w", 0xFFFF)
            add_reg("r9", "r9w", 0xFFFF)
            add_reg("r10", "r10w", 0xFFFF)
            add_reg("r11", "r11w", 0xFFFF)
            add_reg("r12", "r12w", 0xFFFF)
            add_reg("r13", "r13w", 0xFFFF)
            add_reg("r14", "r14w", 0xFFFF)
            add_reg("r15", "r15w", 0xFFFF)

            add_reg("r8", "r8b", 0xFF)
            add_reg("r9", "r9b", 0xFF)
            add_reg("r10", "r10b", 0xFF)
            add_reg("r11", "r11b", 0xFF)
            add_reg("r12", "r12b", 0xFF)
            add_reg("r13", "r13b", 0xFF)
            add_reg("r14", "r14b", 0xFF)
            add_reg("r15", "r15b", 0xFF)

            add_reg("rsi", "sil", 0xFF)
            add_reg("rdi", "dil", 0xFF)
            add_reg("rbp", "bpl", 0xFF)
            add_reg("rsp", "spl", 0xFF)

        for reg in X32_REGS[:9]:
            add_reg(reg, reg[1:], 0xFFFF)

        add_reg("eax", "al", 0xFF)
        add_reg("eax", "ah", 0xFF00)
        add_reg("ebx", "bl", 0xFF)
        add_reg("ebx", "bh", 0xFF00)
        add_reg("ecx", "cl", 0xFF)
        add_reg("ecx", "ch", 0xFF00)
        add_reg("edx", "dl", 0xFF)
        add_reg("edx", "dh", 0xFF00)

        trace_data.arch = arch
        trace_data.ip_reg = ip_reg
        trace_data.regs = reg_indexes
        trace_data.pointer_size = pointer_size

        md = Cs(CS_ARCH_X86, capstone_mode)
        md.detail = True
        reg_values = [None] * len(regs)
        trace = []
        row_id = 0
        while f.read(1) == b"\x00":
            register_changes = int.from_bytes(f.read(1), "little")
            memory_accesses = int.from_bytes(f.read(1), "little")
            flags_and_opcode_size = int.from_bytes(f.read(1), "little")  # Bitfield
            thread_id_bit = (flags_and_opcode_size >> 7) & 1  # msb
            opcode_size = flags_and_opcode_size & 15  # 4 lsbs

            if thread_id_bit > 0:
                thread_id = int.from_bytes(f.read(4), "little")

            opcodes = f.read(opcode_size)

            register_change_position = []
            for _ in range(register_changes):
                register_change_position.append(int.from_bytes(f.read(1), "little"))

            register_change_new_data = []
            for _ in range(register_changes):
                register_change_new_data.append(
                    int.from_bytes(f.read(pointer_size), "little")
                )

            memory_access_flags = []
            for _ in range(memory_accesses):
                memory_access_flags.append(int.from_bytes(f.read(1), "little"))

            memory_access_addresses = []
            for _ in range(memory_accesses):
                memory_access_addresses.append(
                    int.from_bytes(f.read(pointer_size), "little")
                )

            memory_access_old_data = []
            for _ in range(memory_accesses):
                memory_access_old_data.append(
                    int.from_bytes(f.read(pointer_size), "little")
                )

            memory_access_new_data = []
            for i in range(memory_accesses):
                if memory_access_flags[i] & 1 == 0:
                    memory_access_new_data.append(
                        int.from_bytes(f.read(pointer_size), "little")
                    )

            reg_id = 0
            regchanges = ""
            for i, change in enumerate(register_change_position):
                reg_id += change
                if reg_id + i < len(regs):
                    reg_values[reg_id + i] = register_change_new_data[i]
                if reg_id + i < len(regs) and row_id > 0:
                    reg_name = regs[reg_id + i]
                    if reg_name is not ip_reg:
                        old_value = trace[-1]["regs"][reg_id + i]
                        new_value = register_change_new_data[i]
                        if old_value != new_value:
                            regchanges += f"{reg_name}: {hex(new_value)} "
                            if 0x7F > new_value > 0x1F:
                                regchanges += f"'{chr(new_value)}' "

            # disassemble
            ip = reg_values[reg_indexes[ip_reg]]
            for _address, _size, mnemonic, op_str in md.disasm_lite(opcodes, ip):
                disasm = mnemonic
                if op_str:
                    disasm += " " + op_str

            def get_reg(name):
                if len(name) == 2 and name[1] == 's':
                    print(f"{name} moment")
                index = reg_indexes[name]
                mask = reg_masks[name]
                val = reg_values[index]
                # Shifts are encoded in the mask
                while (mask & 0xFF) == 0:
                    mask >>= 8
                    val >>= 8
                return val & mask

            # (somewhat) matches format in dumpulator.py _hook_code
            instr = next(md.disasm(opcodes, ip, 1))
            address = ip
            address_name = ""
            line = f"{hex(address)}{address_name}|{instr.mnemonic}"
            if instr.op_str:
                line += " "
                line += instr.op_str
            for reg in _get_regs(instr):
                if reg in reg_indexes:
                    line += f"|{reg}={hex(get_reg(reg))}"
                else:
                    line += f"|{reg}=0x???"  # TODO: add xmm support

            line += "\n"
            tracef.write(line)

            mems = []
            mem = {}
            new_data_counter = 0
            for i in range(memory_accesses):
                flag = memory_access_flags[i]
                value = memory_access_old_data[i]
                mem["access"] = "READ"
                if flag & 1 == 0:
                    value = memory_access_new_data[new_data_counter]
                    mem["access"] = "WRITE"
                    new_data_counter += 1
                else:
                    pass
                    # memory value didn't change
                    # (it is read or overwritten with identical value)
                    # this has to be fixed somehow in x64dbg

                mem["addr"] = memory_access_addresses[i]

                # fix value (x64dbg saves all values as qwords)
                if "qword" in disasm:
                    pass
                elif "dword" in disasm:
                    value &= 0xFFFFFFFF
                elif "word" in disasm:
                    value &= 0xFFFF
                elif "byte" in disasm:
                    value &= 0xFF
                mem["value"] = value
                mems.append(mem.copy())

            if regchanges:
                trace[-1]["regchanges"] = regchanges

            trace_row = {}
            trace_row["id"] = row_id
            trace_row["ip"] = ip
            trace_row["disasm"] = disasm
            trace_row["regs"] = reg_values.copy()
            trace_row["opcodes"] = opcodes.hex()
            trace_row["mem"] = mems.copy()
            # trace_row["comment"] = ""
            trace.append(trace_row)
            row_id += 1

        trace_data.trace = trace
        return trace_data


def main():
    if len(sys.argv) < 2:
        print("Usage: x64dbg-tracedump my.trace64")
        return
    trace_file = sys.argv[1]
    with open(trace_file + ".txt", "w") as tracef:
        data = open_x64dbg_trace(trace_file, tracef)

if __name__ == '__main__':
    main()

```

`utils/parse_phnt.py`:

```py
# pip install libclang
import json
import sys
from typing import *
from enum import Enum

import clang.cindex
from clang.cindex import *
from collections import OrderedDict

# Resources:
# https://gregoryszorc.com/blog/2012/05/14/python-bindings-updates-in-clang-3.1/
# https://sudonull.com/post/907-An-example-of-parsing-C-code-using-libclang-in-Python
# https://github.com/StatisKit/AutoWIG
# https://github.com/tekord/Python-Clang-RTTI-Generator-Example

def filter_by_folder(
        nodes: Iterable[Cursor],
        folder: str
) -> Iterable[Cursor]:
    for i in nodes:
        if folder in str(i.location.file):
            yield i

def filter_by_kind(
    nodes: Iterable[Cursor],
    kinds: list
) -> Iterable[Cursor]:
    for i in nodes:
        if i.kind in kinds:
            yield i

class EnumValue:
    def __init__(self, name: str, value: int):
        self.name = name
        self.value = value
        self.comment = ""

class EnumType:
    def __init__(self, name: str):
        self.name: str = name.lstrip("_")
        self.values: List[EnumValue] = []

    def format_python(self):
        r = f"class {self.name}(Enum):\n"
        for evalue in self.values:
            r += f"    {evalue.name} = {evalue.value}"
            if evalue.comment:
                r += f"  # {evalue.comment}"
            r += "\n"
        return r

class FunctionArgument:
    def __init__(self, name: str):
        self.name = name
        self.typename = ""
        self.is_ptr = False
        self.sal = ""
        self.comment = ""

class FunctionType:
    def __init__(self, name: str):
        self.name = name
        self.arguments: [FunctionArgument] = []

    def format_python(self, body: Optional[str] = None):
        r = "@syscall\n"
        r += f"def {self.name}(dp: Dumpulator"
        indent = (len(self.name) + 5) * " "
        a: FunctionArgument
        for i, a in enumerate(self.arguments):
            r += ",\n"
            pytype = f"P[{a.typename}]" if a.is_ptr else a.typename
            if len(a.sal) > 0:
                assert "\"" not in a.sal and "\\" not in a.sal
                sal = f"SAL(\"{a.sal}\""
                if a.comment:
                    assert "\"" not in a.comment and "\\" not in a.comment
                    sal += f", \"{a.comment}\""
                sal += ")"
                r += f"{indent}{a.name}: Annotated[{pytype}, {sal}]"
            else:
                r += f"{indent}{a.name}: {pytype}"
        r += "\n"
        r += f"{indent}):\n"
        if body is None:
            r += "    raise NotImplementedError()\n"
        else:
            r += body

        return r

class FunctionBodies:
    def __init__(self, impl_file: Optional[str] = None):
        self.functions: Dict[str, str] = {}

        if impl_file is None:
            return

        with open(impl_file, "r") as f:
            self.lines = [line.rstrip("\n") for line in f.readlines()]

        class State(Enum):
            Imports = 0
            Neutral = 1
            FnType = 2
            FnBody = 3

        self.imports = ""
        current_name = ""
        current_body: List[str] = []
        state = State.Imports
        for line in self.lines:
            if state == State.Imports:
                if line == "@syscall":
                    state = State.Neutral
                else:
                    self.imports += line
                    self.imports += "\n"
            elif state == State.Neutral:
                if line.startswith("def Zw"):
                    assert len(current_body) == 0
                    current_name = line[4:line.index("(")]
                    state = State.FnType
            elif state == State.FnType:
                if line.strip() == "):":
                    state = State.FnBody
            elif state == State.FnBody:
                assert not line.startswith("def Zw")
                if line.startswith("@syscall"):
                    self.add_function_body(current_name, current_body)
                    current_body = []
                    state = State.Neutral
                else:
                    current_body.append(line)

        if len(current_body) > 0:
            self.add_function_body(current_name, current_body)

    def add_function_body(self, name: str, body: List[str]):
        assert len(body) > 0
        if body[-1] == "":
            body.pop()

        # Skip unimplemented functions
        if body == ["    raise NotImplementedError()"]:
            return

        final_body = ""
        for line in body:
            final_body += line
            final_body += "\n"

        assert name not in self.functions
        self.functions[name] = final_body

    def get(self, name) -> Optional[str]:
        return self.functions.get(name, None)

class FileState:
    def __init__(self):
        self.files: Dict[str, List[str]] = {}

    def lines(self, file_name: str):
        if file_name not in self.files:
            with open(file_name, "r") as fp:
                self.files[file_name] = [line.rstrip("\n") for line in fp.readlines()]
        return self.files[file_name]

def extract_line_comment(file_state: FileState, cursor: Cursor):
    end: clang.cindex.SourceLocation = cursor.extent.end
    line = file_state.lines(cursor.location.file.name)[end.line - 1]
    if end.column - 1 < len(line):
        comment = line[end.column - 1:]
        if comment.startswith(","):
            comment = comment[1:]
        comment = comment.strip()
        if comment.startswith("//"):
            return comment[2:].strip()
    return ""

def add_enum(file_state: FileState, enums : Dict[str, EnumType], edecl: Cursor):
    if edecl.spelling:
        et = EnumType(edecl.spelling)
        v: Cursor
        for v in edecl.get_children():
            ev = EnumValue(v.spelling, v.enum_value)
            ev.comment = extract_line_comment(file_state, v)
            et.values.append(ev)
        if len(et.values) > 0:
            enums[et.name] = et

# This script was only tested on Windows, Visual Studio 2019
# phnt version: https://github.com/processhacker/phnt/commit/49539260245f4291b699884a9ef4552530c8cfa4
def main():
    if len(sys.argv) < 2:
        print("Usage: parse_phnt.py c:\\projects\\phnt")
        sys.exit(1)

    file_state = FileState()
    phnt_dir = sys.argv[1]
    index = Index.create()
    tu = index.parse("phnt.c", args=[f"-I{phnt_dir}"], options=TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD)
    diag: Diagnostic
    parse_errors = False
    for diag in tu.diagnostics:
        if diag.severity in [Diagnostic.Error, Diagnostic.Fatal]:
            print(diag)
            parse_errors = True
    if parse_errors:
        sys.exit(1)

    cursor: Cursor = tu.cursor
    phnt_nodes = list(filter_by_folder(cursor.get_children(), phnt_dir))
    system_enums: Dict[str, EnumType] = OrderedDict()

    # This is bad, these CursorKind.XXX are added in cindex.py, no autocomplete possible :(
    edecl: Cursor
    for edecl in filter_by_kind(cursor.get_children(), [CursorKind.ENUM_DECL]):
        if phnt_dir not in str(edecl.location.file):
            add_enum(file_state, system_enums, edecl)

    phnt_enums: Dict[str, EnumType] = OrderedDict()
    for edecl in filter_by_kind(phnt_nodes, [CursorKind.ENUM_DECL]):
        if edecl.spelling:
            add_enum(file_state, phnt_enums, edecl)

    primitive_types = {
        "PVOID",
        "UCHAR",
        "CHAR",
        "USHORT",
        "ULONG",
        "LONG",
        "ULONG_PTR",
        "SIZE_T",
        "HANDLE",
        "ULONG64",
        "ULONGLONG",  # ULONG64
        "BYTE",  # UCHAR
        "RTL_ATOM",  # USHORT
        "NTSTATUS",  # ULONG
        "LANGID",  # USHORT
        "ALPC_HANDLE",  # HANDLE
        "NOTIFICATION_MASK",  # ULONG
        "SECURITY_INFORMATION",  # ULONG
        "EXECUTION_STATE",  # ULONG
        "SE_SIGNING_LEVEL",  # BYTE
        "ACCESS_MASK",  # ULONG
        "WNF_CHANGE_STAMP",  # ULONG
        "KAFFINITY",  # ULONG_PTR
        "BOOLEAN",  # bool
        "LOGICAL",  # ULONG
        "LCID",  # ULONG
        "LATENCY_TIME",  # Unnamed enum, hacked in by hand
        "PSID",  # PVOID
        "PWSTR",  # PVOID
    }

    fdecl: Cursor
    functions: List[FunctionType] = []
    for fdecl in filter_by_kind(phnt_nodes, [CursorKind.FUNCTION_DECL]):
        if fdecl.spelling.startswith("Zw"):
            loc: clang.cindex.SourceLocation = fdecl.location
            file_lines = file_state.lines(loc.file.name)
            ft = FunctionType(fdecl.spelling)
            a: Cursor
            for a in fdecl.get_arguments():
                at = FunctionArgument(a.spelling)

                # Extract argument SAL annotation
                loc = a.location
                extent: clang.cindex.SourceRange = a.extent
                start: clang.cindex.SourceLocation = extent.start
                line = file_lines[loc.line - 1]
                at.sal = line[:start.column - 1].strip()
                at.comment = extract_line_comment(file_state, a)

                # Extract argument type
                at.typename = str(a.type.spelling) \
                    .replace("volatile ", "") \
                    .replace("const ", "")

                if at.typename.startswith("P") and at.typename not in phnt_enums and at.typename not in primitive_types:
                    at.is_ptr = True
                    at.typename = at.typename[1:]

                # Hacky workarounds
                if at.typename == "LPGUID":
                    at.is_ptr = True
                    at.typename = "GUID"
                elif at.typename == "VOID *" or at.typename == "void *":
                    at.typename = "PVOID"
                elif at.typename.startswith("struct _") and at.typename.endswith(" *"):
                    assert not at.is_ptr
                    at.is_ptr = True
                    at.typename = at.typename[8:-2]
                elif at.typename.endswith(" *"):
                    assert not at.is_ptr
                    at.is_ptr = True
                    at.typename = at.typename[:-2]
                elif at.typename.endswith(" []"):
                    assert not at.is_ptr
                    at.is_ptr = True
                    at.typename = at.typename[:-3]
                elif at.typename.endswith("[]"):
                    assert not at.is_ptr
                    at.is_ptr = True
                    at.typename = at.typename[:-2]

                # Make sure the typename is a valid identifier
                if " " in at.typename:
                    ft.arguments.append(at)
                    print(ft.format_python())
                    assert False

                ft.arguments.append(at)
            functions.append(ft)

    unknown_types = set()
    struct_types = set()
    ft: FunctionType
    for ft in functions:
        at: FunctionArgument
        for at in ft.arguments:
            if not at.is_ptr and at.typename not in phnt_enums:
                if at.typename in system_enums:
                    print(f"Merge system enum {at.typename} into phnt_enums")
                    phnt_enums[at.typename] = system_enums[at.typename]
                elif at.typename not in primitive_types:
                    unknown_types.add(at.typename)
            elif at.is_ptr and at.typename not in primitive_types and at.typename not in phnt_enums:
                if at.typename in system_enums:
                    print(f"Merge system enum {at.typename} into phnt_enums")
                    phnt_enums[at.typename] = system_enums[at.typename]
                else:
                    struct_types.add(at.typename)

    # Anything printed here needs to be adjusted earlier on
    print(f"Found {len(unknown_types)} unknown primitive types:")
    for t in unknown_types:
        print("  " + t + ";")

    if len(sys.argv) > 2 and sys.argv[2] == "json":
        with open("ntsyscalls.json", "w") as f:
            data = {}
            for fn in functions:
                args = []
                arg: FunctionArgument
                for arg in fn.arguments:
                    args.append({
                        "name": arg.name,
                        "type": arg.typename + ("*" if arg.is_ptr else ""),
                        "sal": arg.sal,
                        "comment": arg.comment
                    })
                data[fn.name] = args
            f.write(json.dumps(data, indent=2))
        with open("ntenums.json", "w") as f:
            data = {}
            e: EnumType
            for e in phnt_enums.values():
                values = []
                for evalue in e.values:
                    values.append({
                        "name": evalue.name,
                        "value": evalue.value,
                        "comment": evalue.comment
                    })
                data[e.name] = values
            f.write(json.dumps(data, indent=2))
    else:
        if len(sys.argv) > 2 and sys.argv[2].endswith(".py"):
            bodies = FunctionBodies(sys.argv[2])
        else:
            bodies = FunctionBodies()

        with open("ntsyscalls.py", "w") as f:
            f.write(bodies.imports)
            for fn in functions:
                f.write(fn.format_python(bodies.get(fn.name)))
                f.write("\n")

        with open("ntenums.py", "w") as f:
            header = """
# Automatically generated with parse_phnt.py, do not edit
from enum import Enum
            """
            f.write(header.strip() + "\n\n")

            for e in phnt_enums.values():
                f.write(e.format_python())
                f.write("\n")

        with open("ntstructs.py", "w") as f:
            header = """
# Automatically generated with parse_phnt.py, do not edit
            """
            f.write(header.strip() + "\n\n")

            for t in sorted(struct_types):
                if t == "CONTEXT":
                    continue
                f.write(f"class {t}:\n")
                f.write("    pass\n")
                f.write("\n")

if __name__ == "__main__":
    main()

```

`utils/phnt.c`:

```c
#include <phnt_windows.h>
#include <phnt.h>
```